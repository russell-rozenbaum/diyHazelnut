// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1+5.8.1

//# unitInfo: Provides: Typerep_lib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib = [0];
   runtime.caml_register_global(0, Typerep_lib, "Typerep_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Named_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib_Named_intf = [0];
   runtime.caml_register_global
    (0, Typerep_lib_Named_intf, "Typerep_lib__Named_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_equal
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function conv(param, x){return x;}
   function Lift(X){function lift(param){return 0;} return [0, lift];}
   var Typerep_lib_Type_equal = [0, conv, 0, Lift];
   runtime.caml_register_global
    (0, Typerep_lib_Type_equal, "Typerep_lib__Type_equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typename
//# unitInfo: Requires: Base, Caml, Stdlib, Stdlib__Hashtbl, Stdlib__List, Stdlib__Printf, Typerep_lib__Type_equal
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    Base = global_data.Base,
    Caml = global_data.Caml,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl;
   global_data.Stdlib__List;
   function compare(a, b){return runtime.caml_int_compare(a[1], b[1]);}
   function equal(a, b){return a[1] === b[1] ? 1 : 0;}
   var uid = [0, 0];
   function next(name){var code = uid[1]; uid[1]++; return [0, code, name];}
   function hash(a){return caml_call1(Stdlib_Hashtbl[28], a[1]);}
   function name(a){return a[2];}
   var static$0 = next("static");
   function compare$0(k1, k2){
    if(k1 === k2) return 0;
    var cmp = compare(k1[1], k2[1]);
    if(0 !== cmp) return cmp;
    var b$0 = k2[2], a$0 = k1[2], a = a$0, b = b$0;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var ys = b[2], y = b[1], xs = a[2], x = a[1], n = compare$0(x, y);
     if(0 !== n) return n;
     a = xs;
     b = ys;
    }
   }
   function equal$0(a, b){return 0 === compare$0(a, b) ? 1 : 0;}
   var
    hash$0 = Stdlib_Hashtbl[28],
    static$1 = [0, static$0, 0],
    cst_Typename_create = "Typename.create",
    cst_Typename_same_witness_exn = "Typename.same_witness_exn";
   function key(t){return t;}
   function uid$0(t){return t[1];}
   function name$0(t){var a = t[1]; return a[2];}
   function create(opt, param){
    if(opt) var sth = opt[1], name = sth; else var name = cst_Typename_create;
    return [0, next(name), 0];
   }
   function same(nm1, nm2){return 0 === compare$0(nm1, nm2) ? 1 : 0;}
   function same_witness(nm1, nm2){
    return 0 === compare$0(nm1, nm2) ? [0, Typerep_lib_Type_equal[2]] : 0;
   }
   function same_witness_exn(nm1, nm2){
    return 0 === compare$0(nm1, nm2)
            ? Typerep_lib_Type_equal[2]
            : caml_call1(Stdlib[2], cst_Typename_same_witness_exn);
   }
   var
    Key_table = caml_call1(Stdlib_Hashtbl[26], [0, equal$0, hash$0]),
    _a_ =
      [0,
       [11, "Typename.Same_witness_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "Typename.Same_witness_exn %S %S"];
   function Table(X){
    function create(int$0){return caml_call1(Key_table[1], int$0);}
    function mem(table, name){return caml_call2(Key_table[11], table, name);}
    function set(table, name, data){
     return caml_call3(Key_table[10], table, name, [0, name, data]);
    }
    function find(table, name){
     try{var _c_ = [0, caml_call2(Key_table[7], table, name)], data = _c_;}
     catch(_d_){
      var _b_ = caml_wrap_exception(_d_);
      if(_b_[1] !== Base[205] && _b_ !== Caml[8])
       throw caml_maybe_attach_backtrace(_b_, 0);
      var data = 0;
     }
     if(! data) return 0;
     var match = data[1], data$0 = match[2], name$0 = match[1];
     same_witness_exn(name$0, name);
     return [0, data$0];
    }
    return [0, create, mem, set, find];
   }
   function fail(uid_a, uid_b){
    var msg = caml_call3(Stdlib_Printf[4], _a_, uid_a[2], uid_b[2]);
    return caml_call1(Stdlib[2], msg);
   }
   function Same_witness_exn_1(A, B){
    var
     t = caml_call1(A[1], static$1),
     uid_a = t[1],
     t$0 = caml_call1(B[1], static$1),
     uid_b = t$0[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_2(A, B){
    var
     t = caml_call2(A[1], static$1, static$1),
     uid_a = t[1],
     t$0 = caml_call2(B[1], static$1, static$1),
     uid_b = t$0[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_3(A, B){
    var
     t = caml_call3(A[1], static$1, static$1, static$1),
     uid_a = t[1],
     t$0 = caml_call3(B[1], static$1, static$1, static$1),
     uid_b = t$0[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_4(A, B){
    var
     t = caml_call4(A[1], static$1, static$1, static$1, static$1),
     uid_a = t[1],
     t$0 = caml_call4(B[1], static$1, static$1, static$1, static$1),
     uid_b = t$0[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   function Same_witness_exn_5(A, B){
    var
     t = caml_call5(A[1], static$1, static$1, static$1, static$1, static$1),
     uid_a = t[1],
     t$0 = caml_call5(B[1], static$1, static$1, static$1, static$1, static$1),
     uid_b = t$0[1],
     witness =
       equal(uid_a, uid_b)
        ? [0, Typerep_lib_Type_equal[2]]
        : fail(uid_a, uid_b);
    return [0, witness];
   }
   var
    Typerep_lib_Typename =
      [0,
       create,
       static$1,
       same,
       same_witness,
       same_witness_exn,
       [0, compare$0, equal$0, hash$0],
       key,
       [0, compare, equal, hash, name],
       uid$0,
       name$0,
       function(X){
        var uid = next(X[1]), typename_of_t = [0, uid, 0];
        return [0, typename_of_t];
       },
       function(X){
        var uid = next(X[1]);
        function typename_of_t(a){return [0, uid, [0, a, 0]];}
        return [0, typename_of_t];
       },
       function(X){
        var uid = next(X[1]);
        function typename_of_t(a, b){return [0, uid, [0, a, [0, b, 0]]];}
        return [0, typename_of_t];
       },
       function(X){
        var uid = next(X[1]);
        function typename_of_t(a, b, c){
         return [0, uid, [0, a, [0, b, [0, c, 0]]]];
        }
        return [0, typename_of_t];
       },
       function(X){
        var uid = next(X[1]);
        function typename_of_t(a, b, c, d){
         return [0, uid, [0, a, [0, b, [0, c, [0, d, 0]]]]];
        }
        return [0, typename_of_t];
       },
       function(X){
        var uid = next(X[1]);
        function typename_of_t(a, b, c, d, e){
         return [0, uid, [0, a, [0, b, [0, c, [0, d, [0, e, 0]]]]]];
        }
        return [0, typename_of_t];
       },
       Table,
       Same_witness_exn_1,
       Same_witness_exn_2,
       Same_witness_exn_3,
       Same_witness_exn_4,
       Same_witness_exn_5];
   runtime.caml_register_global
    (11, Typerep_lib_Typename, "Typerep_lib__Typename");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Variant_and_record_intf
//# unitInfo: Requires: Stdlib__Array
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Array = global_data.Stdlib__Array;
   function M(X){
    var Tag_internal = [0];
    function label(t){return t[1];}
    function arity(t){return t[3];}
    function args_labels(t){return t[4];}
    function index(t){return t[5];}
    function ocaml_repr(t){return t[6];}
    function create(t){return t[8];}
    function tyid(t){return t[7];}
    function traverse(t){return t[2];}
    function internal_use_only(t){return t;}
    var
     Tag =
       [0,
        label,
        arity,
        args_labels,
        index,
        ocaml_repr,
        create,
        tyid,
        traverse,
        internal_use_only],
     Variant_internal = [0];
    function typename_of_t(t){return t[1];}
    function length(t){return t[2].length - 1;}
    function tag(t, index){return caml_check_bound(t[2], index)[1 + index];}
    function is_polymorphic(t){return t[3];}
    function value(t){return t[4];}
    function fold(t, init, f){
     return caml_call3(Stdlib_Array[17], f, init, t[2]);
    }
    function internal_use_only$0(t){return t;}
    var
     Variant =
       [0,
        typename_of_t,
        length,
        tag,
        is_polymorphic,
        value,
        fold,
        internal_use_only$0],
     Field_internal = [0];
    function label$0(t){return t[1];}
    function index$0(t){return t[3];}
    function get(t){return t[5];}
    function is_mutable(t){return t[6];}
    function tyid$0(t){return t[4];}
    function traverse$0(t){return t[2];}
    function internal_use_only$1(t){return t;}
    var
     Field =
       [0,
        label$0,
        index$0,
        get,
        is_mutable,
        tyid$0,
        traverse$0,
        internal_use_only$1],
     Record_internal = [0];
    function typename_of_t$0(t){return t[1];}
    function length$0(t){return t[2].length - 1;}
    function field(t, index){return caml_check_bound(t[2], index)[1 + index];}
    function has_double_array_tag(t){return t[3];}
    function create$0(t){return t[4];}
    function fold$0(t, init, f){
     return caml_call3(Stdlib_Array[17], f, init, t[2]);
    }
    function internal_use_only$2(t){return t;}
    var
     Record =
       [0,
        typename_of_t$0,
        length$0,
        field,
        has_double_array_tag,
        create$0,
        fold$0,
        internal_use_only$2];
    return [0,
            Tag_internal,
            Tag,
            Variant_internal,
            Variant,
            Field_internal,
            Field,
            Record_internal,
            Record];
   }
   var Typerep_lib_Variant_and_record = [0, M];
   runtime.caml_register_global
    (1,
     Typerep_lib_Variant_and_record,
     "Typerep_lib__Variant_and_record_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Std_internal
//# unitInfo: Requires: Assert_failure, Base__Int63, CamlinternalLazy, CamlinternalMod, Typerep_lib__Typename, Typerep_lib__Variant_and_record_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_std_internal_ml = "lib/std_internal.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    name = "int",
    name$0 = "int32",
    name$1 = "int64",
    name$2 = "nativeint",
    name$3 = "char",
    name$4 = "float",
    name$5 = "string",
    name$6 = "bytes",
    name$7 = "bool",
    name$8 = "unit",
    name$9 = "option",
    name$10 = "list",
    name$11 = "array",
    name$12 = "lazy_t",
    name$13 = "ref",
    name$14 = "function",
    name$15 = "tuple0",
    name$16 = "tuple2",
    name$17 = "tuple3",
    name$18 = "tuple4",
    name$19 = "tuple5",
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Assert_failure = global_data.Assert_failure,
    CamlinternalMod = global_data.CamlinternalMod,
    Typerep_lib_Variant_and_record =
      global_data.Typerep_lib__Variant_and_record_intf,
    Base_Int63 = global_data.Base__Int63,
    typename_of_int = caml_call1(Typerep_lib_Typename[11], [0, name])[1],
    typename_of_int32 = caml_call1(Typerep_lib_Typename[11], [0, name$0])[1],
    typename_of_int64 = caml_call1(Typerep_lib_Typename[11], [0, name$1])[1],
    typename_of_nativeint =
      caml_call1(Typerep_lib_Typename[11], [0, name$2])[1],
    typename_of_char = caml_call1(Typerep_lib_Typename[11], [0, name$3])[1],
    typename_of_float = caml_call1(Typerep_lib_Typename[11], [0, name$4])[1],
    typename_of_string = caml_call1(Typerep_lib_Typename[11], [0, name$5])[1],
    typename_of_bytes = caml_call1(Typerep_lib_Typename[11], [0, name$6])[1],
    typename_of_bool = caml_call1(Typerep_lib_Typename[11], [0, name$7])[1],
    typename_of_unit = caml_call1(Typerep_lib_Typename[11], [0, name$8])[1],
    M_option = caml_call1(Typerep_lib_Typename[12], [0, name$9]),
    typename_of_option = M_option[1],
    M_list = caml_call1(Typerep_lib_Typename[12], [0, name$10]),
    typename_of_list = M_list[1],
    M_array = caml_call1(Typerep_lib_Typename[12], [0, name$11]),
    typename_of_array = M_array[1],
    M_lazy_t = caml_call1(Typerep_lib_Typename[12], [0, name$12]),
    typename_of_lazy_t = M_lazy_t[1],
    M_ref = caml_call1(Typerep_lib_Typename[12], [0, name$13]),
    typename_of_ref = M_ref[1],
    M_function = caml_call1(Typerep_lib_Typename[13], [0, name$14]),
    typename_of_function = M_function[1],
    M_tuple0 = caml_call1(Typerep_lib_Typename[11], [0, name$15]),
    typename_of_tuple0 = M_tuple0[1],
    M_tuple2 = caml_call1(Typerep_lib_Typename[13], [0, name$16]),
    typename_of_tuple2 = M_tuple2[1],
    M_tuple3 = caml_call1(Typerep_lib_Typename[14], [0, name$17]),
    typename_of_tuple3 = M_tuple3[1],
    M_tuple4 = caml_call1(Typerep_lib_Typename[15], [0, name$18]),
    typename_of_tuple4 = M_tuple4[1],
    M_tuple5 = caml_call1(Typerep_lib_Typename[16], [0, name$19]),
    typename_of_tuple5 = M_tuple5[1],
    Typerep =
      caml_call2
       (CamlinternalMod[1],
        [0, cst_lib_std_internal_ml, 401, 6],
        [0,
         [0,
          [0, [0, 0, 0, 0]],
          [0, [0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          [0, [0]],
          [0, [0, 0, 0, 0, 0, 0, 0, 0]],
          0,
          0,
          0,
          0,
          0]]);
   function arity(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      case 3:
       return 3;
      case 4:
       return 4;
      default: return 5;
    }
   }
   function typename_of_t(param){
    switch(param[0]){
      case 0:
       var rep = param[1]; return rep[2];
      case 1:
       var rep$0 = param[1]; return rep$0[3];
      case 2:
       var rep$1 = param[1]; return rep$1[4];
      case 3:
       var rep$2 = param[1]; return rep$2[5];
      case 4:
       var rep$3 = param[1]; return rep$3[6];
      default: var rep$4 = param[1]; return rep$4[7];
    }
   }
   function name$20(rep){
    var
     _Z_ = typename_of_t(rep),
     ___ = caml_call1(Typerep_lib_Typename[9], _Z_);
    return caml_call1(Typerep_lib_Typename[8][4], ___);
   }
   var Named = [0, arity, typename_of_t, name$20];
   function arity$0(param){
    switch(param[0]){
      case 0:
       return 2;
      case 1:
       return 3;
      case 2:
       return 4;
      default: return 5;
    }
   }
   function typename_of_t$0(param){
    switch(param[0]){
      case 0:
       var
        match = param[1],
        b = match[2],
        a = match[1],
        _P_ = caml_call1(Typerep[14], b);
       return caml_call2(typename_of_tuple2, caml_call1(Typerep[14], a), _P_);
      case 1:
       var
        match$0 = param[1],
        c = match$0[3],
        b$0 = match$0[2],
        a$0 = match$0[1],
        _Q_ = caml_call1(Typerep[14], c),
        _R_ = caml_call1(Typerep[14], b$0);
       return caml_call3
               (typename_of_tuple3, caml_call1(Typerep[14], a$0), _R_, _Q_);
      case 2:
       var
        match$1 = param[1],
        d = match$1[4],
        c$0 = match$1[3],
        b$1 = match$1[2],
        a$1 = match$1[1],
        _S_ = caml_call1(Typerep[14], d),
        _T_ = caml_call1(Typerep[14], c$0),
        _U_ = caml_call1(Typerep[14], b$1);
       return caml_call4
               (typename_of_tuple4,
                caml_call1(Typerep[14], a$1),
                _U_,
                _T_,
                _S_);
      default:
       var
        match$2 = param[1],
        e = match$2[5],
        d$0 = match$2[4],
        c$1 = match$2[3],
        b$2 = match$2[2],
        a$2 = match$2[1],
        _V_ = caml_call1(Typerep[14], e),
        _W_ = caml_call1(Typerep[14], d$0),
        _X_ = caml_call1(Typerep[14], c$1),
        _Y_ = caml_call1(Typerep[14], b$2);
       return caml_call5
               (typename_of_tuple5,
                caml_call1(Typerep[14], a$2),
                _Y_,
                _X_,
                _W_,
                _V_);
    }
   }
   var
    Tuple = [0, arity$0, typename_of_t$0],
    include = caml_call1(Typerep_lib_Variant_and_record[1], [0]),
    Tag_internal = include[1],
    Tag = include[2],
    Variant_internal = include[3],
    Variant = include[4],
    Field_internal = include[5],
    Field = include[6],
    Record_internal = include[7],
    Record = include[8],
    _a_ = [0, 0],
    _b_ = [0, 0],
    _c_ = [0, 0],
    _d_ = [0, 0],
    _e_ = [0, 0],
    _f_ = [0, 0],
    _g_ = [0, 0],
    _h_ = [0, 0],
    _i_ = [0, 0],
    _j_ = [0, 0],
    _k_ = [0, 0],
    _l_ = [0, 0],
    _m_ = [0, 0],
    _n_ = [0, 0],
    _o_ = [0, 0],
    _p_ = [0, cst_lib_std_internal_ml, 802, 14];
   function typename_of_t$1(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return typename_of_int;
       case 1:
        return typename_of_int32;
       case 2:
        return typename_of_int64;
       case 3:
        return typename_of_nativeint;
       case 4:
        return typename_of_char;
       case 5:
        return typename_of_float;
       case 6:
        return typename_of_string;
       case 7:
        return typename_of_bytes;
       case 8:
        return typename_of_bool;
       default: return typename_of_unit;
     }
    switch(param[0]){
      case 0:
       var rep = param[1];
       return caml_call1(typename_of_option, typename_of_t$1(rep));
      case 1:
       var rep$0 = param[1];
       return caml_call1(typename_of_list, typename_of_t$1(rep$0));
      case 2:
       var rep$1 = param[1];
       return caml_call1(typename_of_array, typename_of_t$1(rep$1));
      case 3:
       var rep$2 = param[1];
       return caml_call1(typename_of_lazy_t, typename_of_t$1(rep$2));
      case 4:
       var rep$3 = param[1];
       return caml_call1(typename_of_ref, typename_of_t$1(rep$3));
      case 5:
       var
        match = param[1],
        rng = match[2],
        dom = match[1],
        _O_ = typename_of_t$1(rng);
       return caml_call2(typename_of_function, typename_of_t$1(dom), _O_);
      case 6:
       var rep$4 = param[1]; return caml_call1(Typerep[2][2], rep$4);
      case 7:
       var rep$5 = param[1]; return caml_call1(Typerep[10][1], rep$5);
      case 8:
       var rep$6 = param[1]; return caml_call1(Typerep[6][1], rep$6);
      default: var name = param[1][1]; return caml_call1(Named[2], name);
    }
   }
   function same_witness(t1, t2){
    var t1$0 = t1, t2$0 = t2;
    for(;;){
     a:
     {
      if(typeof t1$0 === "number")
       switch(t1$0){
         case 0:
          if(typeof t2$0 === "number"){if(0 === t2$0) return _a_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 1:
          if(typeof t2$0 === "number"){if(1 === t2$0) return _b_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 2:
          if(typeof t2$0 === "number"){if(2 === t2$0) return _c_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 3:
          if(typeof t2$0 === "number"){if(3 === t2$0) return _d_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 4:
          if(typeof t2$0 === "number"){if(4 === t2$0) return _e_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 5:
          if(typeof t2$0 === "number"){if(5 === t2$0) return _f_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 6:
          if(typeof t2$0 === "number"){if(6 === t2$0) return _g_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 7:
          if(typeof t2$0 === "number"){if(7 === t2$0) return _h_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         case 8:
          if(typeof t2$0 === "number"){if(8 === t2$0) return _i_; break a;}
          if(9 !== t2$0[0]) break a;
          break;
         default:
          if(typeof t2$0 === "number"){if(9 === t2$0) return _j_; break a;}
          if(9 !== t2$0[0]) break a;
       }
      else
       b:
       switch(t1$0[0]){
         case 0:
          var r1 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 0:
              var r2$0 = t2$0[1], x = same_witness(r1, r2$0);
              return x ? x : x;
             case 9:
              break b;
           }
          break a;
         case 1:
          var r1$0 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 1:
              var r2$1 = t2$0[1], x$0 = same_witness(r1$0, r2$1);
              return x$0 ? x$0 : x$0;
             case 9:
              break b;
           }
          break a;
         case 2:
          var r1$1 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 2:
              var r2$2 = t2$0[1], x$1 = same_witness(r1$1, r2$2);
              return x$1 ? x$1 : x$1;
             case 9:
              break b;
           }
          break a;
         case 3:
          var r1$2 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 3:
              var r2$3 = t2$0[1], x$2 = same_witness(r1$2, r2$3);
              return x$2 ? x$2 : x$2;
             case 9:
              break b;
           }
          break a;
         case 4:
          var r1$3 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 4:
              var r2$4 = t2$0[1], x$3 = same_witness(r1$3, r2$4);
              return x$3 ? x$3 : x$3;
             case 9:
              break b;
           }
          break a;
         case 5:
          var _v_ = t1$0[1], rng1 = _v_[2], dom1 = _v_[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 5:
              var
               match = t2$0[1],
               rng2 = match[2],
               dom2 = match[1],
               match$0 = same_witness(dom1, dom2),
               match$1 = same_witness(rng1, rng2);
              if(match$0 && match$1) return _k_;
              return 0;
             case 9:
              break b;
           }
          break a;
         case 6:
          var t1$1 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 6:
              var t2$2 = t2$0[1];
              switch(t1$1[0]){
                case 0:
                 var _w_ = t1$1[1];
                 if(0 !== t2$2[0]) return 0;
                 var
                  match$2 = t2$2[1],
                  b2 = match$2[2],
                  a2 = match$2[1],
                  b1 = _w_[2],
                  a1 = _w_[1],
                  match$3 = same_witness(a1, a2),
                  match$4 = same_witness(b1, b2);
                 if(match$3 && match$4) return _l_;
                 return 0;
                case 1:
                 var _x_ = t1$1[1];
                 if(1 !== t2$2[0]) return 0;
                 var
                  match$5 = t2$2[1],
                  c2 = match$5[3],
                  b2$0 = match$5[2],
                  a2$0 = match$5[1],
                  c1 = _x_[3],
                  b1$0 = _x_[2],
                  a1$0 = _x_[1],
                  match$6 = same_witness(a1$0, a2$0),
                  match$7 = same_witness(b1$0, b2$0),
                  match$8 = same_witness(c1, c2);
                 if(match$6 && match$7 && match$8) return _m_;
                 return 0;
                case 2:
                 var _y_ = t1$1[1];
                 if(2 !== t2$2[0]) return 0;
                 var
                  match$9 = t2$2[1],
                  d2 = match$9[4],
                  c2$0 = match$9[3],
                  b2$1 = match$9[2],
                  a2$1 = match$9[1],
                  d1 = _y_[4],
                  c1$0 = _y_[3],
                  b1$1 = _y_[2],
                  a1$1 = _y_[1],
                  match$10 = same_witness(a1$1, a2$1),
                  match$11 = same_witness(b1$1, b2$1),
                  match$12 = same_witness(c1$0, c2$0),
                  match$13 = same_witness(d1, d2);
                 if(match$10 && match$11 && match$12 && match$13) return _n_;
                 return 0;
                default:
                 var _z_ = t1$1[1];
                 if(3 !== t2$2[0]) return 0;
                 var
                  match$14 = t2$2[1],
                  e2 = match$14[5],
                  d2$0 = match$14[4],
                  c2$1 = match$14[3],
                  b2$2 = match$14[2],
                  a2$2 = match$14[1],
                  e1 = _z_[5],
                  d1$0 = _z_[4],
                  c1$1 = _z_[3],
                  b1$2 = _z_[2],
                  a1$2 = _z_[1],
                  match$15 = same_witness(a1$2, a2$2),
                  match$16 = same_witness(b1$2, b2$2),
                  match$17 = same_witness(c1$1, c2$1),
                  match$18 = same_witness(d1$0, d2$0),
                  match$19 = same_witness(e1, e2);
                 if(match$15 && match$16 && match$17 && match$18 && match$19)
                  return _o_;
                 return 0;
              }
             case 9:
              break b;
           }
          break a;
         case 7:
          var r1$4 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 7:
              var
               r2$5 = t2$0[1],
               _A_ = caml_call1(Typerep[10][1], r2$5),
               _B_ = caml_call1(Typerep[10][1], r1$4);
              return caml_call2(Typerep_lib_Typename[4], _B_, _A_);
             case 9:
              break b;
           }
          break a;
         case 8:
          var r1$5 = t1$0[1];
          if(typeof t2$0 !== "number")
           switch(t2$0[0]){
             case 8:
              var
               r2$6 = t2$0[1],
               _C_ = caml_call1(Typerep[6][1], r2$6),
               _D_ = caml_call1(Typerep[6][1], r1$5);
              return caml_call2(Typerep_lib_Typename[4], _D_, _C_);
             case 9:
              break b;
           }
          break a;
         default:
          var match$20 = t1$0[1], name1 = match$20[1];
          if(typeof t2$0 !== "number" && 9 === t2$0[0]){
           var
            match$21 = t2$0[1],
            r2$7 = match$21[2],
            name2 = match$21[1],
            r1$7 = match$20[2],
            _G_ = caml_call1(Named[2], name2),
            _H_ = caml_call1(Named[2], name1),
            x$4 = caml_call2(Typerep_lib_Typename[4], _H_, _G_);
           if(x$4) return x$4;
           if(! r1$7){
            if(! r2$7) return 0;
            var
             _M_ = r2$7[1],
             _N_ = caml_obj_tag(_M_),
             t2$4 =
               250 === _N_
                ? _M_[1]
                : 246 === _N_ ? caml_call1(CamlinternalLazy[2], _M_) : _M_;
            t2$0 = t2$4;
            continue;
           }
           var
            _I_ = r1$7[1],
            _J_ = caml_obj_tag(_I_),
            t1$3 =
              250 === _J_
               ? _I_[1]
               : 246 === _J_ ? caml_call1(CamlinternalLazy[2], _I_) : _I_;
           if(r2$7){
            var
             _K_ = r2$7[1],
             _L_ = caml_obj_tag(_K_),
             t2$3 =
               250 === _L_
                ? _K_[1]
                : 246 === _L_ ? caml_call1(CamlinternalLazy[2], _K_) : _K_;
            t1$0 = t1$3;
            t2$0 = t2$3;
            continue;
           }
           t1$0 = t1$3;
           continue;
          }
          var r1$6 = match$20[2];
          if(! r1$6) return 0;
          var
           _E_ = r1$6[1],
           _F_ = caml_obj_tag(_E_),
           t1$2 =
             250 === _F_
              ? _E_[1]
              : 246 === _F_ ? caml_call1(CamlinternalLazy[2], _E_) : _E_;
          t1$0 = t1$2;
          continue;
       }
      var r2 = t2$0[1][2];
      if(! r2) return 0;
      var
       _t_ = r2[1],
       _u_ = caml_obj_tag(_t_),
       t2$1 =
         250 === _u_
          ? _t_[1]
          : 246 === _u_ ? caml_call1(CamlinternalLazy[2], _t_) : _t_;
      t2$0 = t2$1;
      continue;
     }
     if(typeof t1$0 === "number")
      switch(t1$0){
        case 0: break;
        case 1:
         return 0;
        case 2:
         return 0;
        case 3:
         return 0;
        case 4:
         return 0;
        case 5:
         return 0;
        case 6:
         return 0;
        case 7:
         return 0;
        case 8:
         return 0;
        default: return 0;
      }
     else
      switch(t1$0[0]){
        case 9: break;
        case 0:
         return 0;
        case 1:
         return 0;
        case 2:
         return 0;
        case 3:
         return 0;
        case 4:
         return 0;
        case 5:
         return 0;
        case 6:
         return 0;
        case 7:
         return 0;
        default: return 0;
      }
     return 0;
    }
   }
   function same(a, b){return 0 !== same_witness(a, b) ? 1 : 0;}
   function same_witness_exn(a, b){
    var match = same_witness(a, b);
    if(! match)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
    var proof = match[1];
    return proof;
   }
   function head(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 !== "number" && 9 === t$0[0]){
      var _q_ = t$0[1][2];
      if(_q_){
       var
        _r_ = _q_[1],
        _s_ = caml_obj_tag(_r_),
        t$1 =
          250 === _s_
           ? _r_[1]
           : 246 === _s_ ? caml_call1(CamlinternalLazy[2], _r_) : _r_;
       t$0 = t$1;
       continue;
      }
     }
     return t$0;
    }
   }
   caml_call3
    (CamlinternalMod[2],
     [0,
      [0,
       [0, [0, 0, 0, 0]],
       [0, [0, 0, 0]],
       [0, [0]],
       [0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
       [0, [0]],
       [0, [0, 0, 0, 0, 0, 0, 0, 0]],
       [0, [0]],
       [0, [0, 0, 0, 0, 0, 0, 0, 0]],
       [0, [0]],
       [0, [0, 0, 0, 0, 0, 0, 0, 0]],
       0,
       0,
       0,
       0,
       0]],
     Typerep,
     [0,
      Named,
      Tuple,
      Tag_internal,
      Tag,
      Variant_internal,
      Variant,
      Field_internal,
      Field,
      Record_internal,
      Record,
      same,
      same_witness,
      same_witness_exn,
      typename_of_t$1,
      head]);
   var typerep_of_int = 0, typerep_of_int64 = 2;
   function typerep_of_option(rep){return [0, rep];}
   function typerep_of_list(rep){return [1, rep];}
   function typerep_of_array(rep){return [2, rep];}
   function typerep_of_lazy_t(rep){return [3, rep];}
   function typerep_of_ref(rep){return [4, rep];}
   function typerep_of_function(dom, rng){return [5, [0, dom, rng]];}
   function typerep_of_tuple2(a, b){return [6, [0, [0, a, b]]];}
   function typerep_of_tuple3(a, b, c){return [6, [1, [0, a, b, c]]];}
   function typerep_of_tuple4(a, b, c, d){return [6, [2, [0, a, b, c, d]]];}
   function typerep_of_tuple5(a, b, c, d, e){return [6, [3, [0, a, b, c, d, e]]];
   }
   var
    typerep_of_int32 = 1,
    typerep_of_nativeint = 3,
    typerep_of_char = 4,
    typerep_of_float = 5,
    typerep_of_string = 6,
    typerep_of_bytes = 7,
    typerep_of_bool = 8,
    typerep_of_unit = 9,
    typerep_of_tuple0 = 9,
    value_tuple0 = 0,
    match =
      Base_Int63[114][2]
       ? [0, typerep_of_int64, typename_of_int64]
       : [0, typerep_of_int, typename_of_int],
    typename_of_int63 = match[2],
    typerep_of_int63 = match[1],
    Typerep_lib_Std_internal =
      [0,
       Typerep,
       typerep_of_int,
       typerep_of_int32,
       typerep_of_int64,
       typerep_of_nativeint,
       typerep_of_int63,
       typerep_of_char,
       typerep_of_float,
       typerep_of_string,
       typerep_of_bytes,
       typerep_of_bool,
       typerep_of_unit,
       value_tuple0,
       typerep_of_option,
       typerep_of_list,
       typerep_of_array,
       typerep_of_lazy_t,
       typerep_of_ref,
       typerep_of_function,
       typerep_of_tuple0,
       typerep_of_tuple2,
       typerep_of_tuple3,
       typerep_of_tuple4,
       typerep_of_tuple5,
       typename_of_int,
       typename_of_int32,
       typename_of_int64,
       typename_of_nativeint,
       typename_of_int63,
       typename_of_char,
       typename_of_float,
       typename_of_string,
       typename_of_bytes,
       typename_of_bool,
       typename_of_unit,
       typename_of_option,
       typename_of_list,
       typename_of_array,
       typename_of_lazy_t,
       typename_of_ref,
       typename_of_function,
       typename_of_tuple0,
       typename_of_tuple2,
       typename_of_tuple3,
       typename_of_tuple4,
       typename_of_tuple5];
   runtime.caml_register_global
    (46, Typerep_lib_Std_internal, "Typerep_lib__Std_internal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typerepable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Typerep_lib_Typerepable = [0];
   runtime.caml_register_global
    (0, Typerep_lib_Typerepable, "Typerep_lib__Typerepable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Typerep_obj
//# unitInfo: Requires: Assert_failure, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_typerep_obj_ml = "lib/typerep_obj.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Obj = global_data.Stdlib__Obj,
    Assert_failure = global_data.Assert_failure,
    _a_ = [0, cst_lib_typerep_obj_ml, 11, 4],
    _b_ = [0, cst_lib_typerep_obj_ml, 9, 4];
   function repr_of_poly_variant(variant){
    if(typeof variant === "number") return variant;
    var size = variant.length - 1;
    if(2 !== size)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var repr = variant[1];
    if(typeof repr === "number") return repr;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function hash_variant(s){
    var
     accu = [0, 0],
     _k_ = runtime.caml_ml_string_length(s) - 1 | 0,
     _j_ = 0;
    if(_k_ >= 0){
     var i = _j_;
     for(;;){
      var _l_ = runtime.caml_string_get(s, i);
      accu[1] = (223 * accu[1] | 0) + _l_ | 0;
      var _m_ = i + 1 | 0;
      if(_k_ === i) break;
      i = _m_;
     }
    }
    accu[1] = accu[1] & 2147483647;
    return 1073741823 < accu[1] ? accu[1] + 2147483648 | 0 : accu[1];
   }
   var
    _c_ = hash_variant("Latency_stats"),
    _h_ = [0, cst_lib_typerep_obj_ml, 28, 9],
    cst_zero = "zero",
    _g_ = [0, cst_lib_typerep_obj_ml, 29, 9],
    _f_ = [0, cst_lib_typerep_obj_ml, 49, 2],
    _e_ = [0, cst_lib_typerep_obj_ml, 50, 2];
   if(repr_of_poly_variant(-894644482) !== _c_)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   var _d_ = hash_variant(cst_zero);
   if(repr_of_poly_variant(-789508312) !== _d_)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   var double_array_value = 0.;
   function has_double_array_tag(a){
    var _i_ = runtime.caml_obj_tag(a);
    return Stdlib_Obj[15] === _i_ ? 1 : 0;
   }
   var
    double$0 = [254, double_array_value, double_array_value],
    simple = [0, double_array_value, double_array_value];
   if(! has_double_array_tag(double$0))
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   if(has_double_array_tag(simple))
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   var
    Typerep_lib_Typerep_obj =
      [0,
       repr_of_poly_variant,
       hash_variant,
       double_array_value,
       has_double_array_tag];
   runtime.caml_register_global
    (11, Typerep_lib_Typerep_obj, "Typerep_lib__Typerep_obj");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_generic_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function M(X){return [0];}
   var Typerep_lib_Type_generic_intf = [0, M];
   runtime.caml_register_global
    (0, Typerep_lib_Type_generic_intf, "Typerep_lib__Type_generic_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_generic
//# unitInfo: Requires: Assert_failure, Base, Caml, CamlinternalLazy, Stdlib, Stdlib__Array, Stdlib__Hashtbl, Stdlib__Lazy, Stdlib__List, Stdlib__Printf, Typerep_lib__Std_internal, Typerep_lib__Type_equal, Typerep_lib__Type_generic_intf, Typerep_lib__Typename, Typerep_lib__Variant_and_record_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_type_generic_ml = "lib/type_generic.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Base = global_data.Base,
    Caml = global_data.Caml,
    Typerep_lib_Type_generic_intf = global_data.Typerep_lib__Type_generic_intf,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Array = global_data.Stdlib__Array,
    Typerep_lib_Variant_and_record =
      global_data.Typerep_lib__Variant_and_record_intf;
   function Helper(A, B){
    function map_variant(param, variant){
     var
      map = param[1],
      typename = caml_call1(A[4][1], variant),
      polymorphic = caml_call1(A[4][4], variant),
      _au_ = caml_call1(A[4][2], variant),
      tags =
        caml_call2
         (Stdlib_Array[2],
          _au_,
          function(index$0){
           var
            tag$0 = caml_call2(A[4][3], variant, index$0),
            tag = tag$0[1],
            label = caml_call1(A[2][1], tag),
            rep = caml_call1(map, caml_call1(A[2][8], tag)),
            arity = caml_call1(A[2][2], tag),
            args_labels = caml_call1(A[2][3], tag),
            index = caml_call1(A[2][4], tag),
            ocaml_repr = caml_call1(A[2][5], tag),
            tyid = caml_call1(A[2][7], tag),
            param = caml_call1(A[2][6], tag);
           if(0 === param[0])
            var fct = param[1], create = [0, fct];
           else
            var k = param[1], create = [1, k];
           return [0,
                   caml_call1
                    (B[2][9],
                     [0,
                      label,
                      rep,
                      arity,
                      args_labels,
                      index,
                      ocaml_repr,
                      tyid,
                      create])];
          });
     function value(a){
      var
       match = caml_call2(A[4][5], variant, a),
       a$0 = match[2],
       atag = match[1],
       _av_ = caml_call1(A[2][4], atag),
       btag = caml_check_bound(tags, _av_)[1 + _av_][1],
       _aw_ = caml_call1(B[2][7], btag),
       _ax_ = caml_call1(A[2][7], atag);
      caml_call2(Typerep_lib_Typename[5], _ax_, _aw_);
      return [0, btag, a$0];
     }
     return caml_call1(B[4][7], [0, typename, tags, polymorphic, value]);
    }
    function map_record(param, record){
     var
      map = param[1],
      typename = caml_call1(A[8][1], record),
      has_double_array_tag = caml_call1(A[8][4], record),
      _aq_ = caml_call1(A[8][2], record),
      fields =
        caml_call2
         (Stdlib_Array[2],
          _aq_,
          function(index$0){
           var
            field$0 = caml_call2(A[8][3], record, index$0),
            field = field$0[1],
            label = caml_call1(A[6][1], field),
            rep = caml_call1(map, caml_call1(A[6][6], field)),
            index = caml_call1(A[6][2], field),
            is_mutable = caml_call1(A[6][4], field),
            tyid = caml_call1(A[6][5], field),
            get = caml_call1(A[6][3], field);
           return [0,
                   caml_call1
                    (B[6][7], [0, label, rep, index, tyid, get, is_mutable])];
          });
     function create(param){
      var get = param[1];
      function get$0(afield){
       var
        _ar_ = caml_call1(A[6][2], afield),
        bfield = caml_check_bound(fields, _ar_)[1 + _ar_][1],
        _as_ = caml_call1(B[6][5], bfield),
        _at_ = caml_call1(A[6][5], afield);
       caml_call2(Typerep_lib_Typename[5], _at_, _as_);
       return caml_call1(get, bfield);
      }
      return caml_call2(A[8][5], record, [0, get$0]);
     }
     return caml_call1
             (B[8][7], [0, typename, fields, has_double_array_tag, create]);
    }
    return [0, map_variant, map_record];
   }
   var
    Broken_dependency =
      [248,
       "Typerep_lib.Type_generic.Ident.Broken_dependency",
       caml_fresh_oo_id(0)],
    _d_ = Typerep_lib_Typename[6];
   caml_call1(Stdlib_Hashtbl[26], [0, _d_[2], _d_[3]]);
   var
    _c_ =
      [0,
       [11,
        "Type_generic ",
        [3,
         0,
         [11, " requires ", [3, 0, [11, " for uid ", [3, 0, [12, 10, 0]]]]]]],
       "Type_generic %S requires %S for uid %S\n"],
    cst_Typerep_lib_Type_generic_M$0 =
      "Typerep_lib.Type_generic.Make_S_implementation(X).Not_implemented",
    cst_Typerep_lib_Type_generic_M =
      "Typerep_lib.Type_generic.Make_named_for_closure(X).Undefined",
    _a_ = [0, cst_lib_type_generic_ml, 185, 16],
    _b_ = [0, cst_lib_type_generic_ml, 187, 69],
    Typerep_lib_Type_generic =
      [0,
       Typerep_lib_Variant_and_record,
       Helper,
       function(_an_){
        function create(_ap_){return 0;}
        var
         Context = [0, create],
         Undefined =
           [248, cst_Typerep_lib_Type_generic_M, caml_fresh_oo_id(0)];
        function init(param, name){
         var
          _ao_ = caml_call1(Typerep_lib_Typename[9], name),
          path = caml_call1(Typerep_lib_Typename[8][4], _ao_),
          r =
            [0,
             function(param){
              throw caml_maybe_attach_backtrace([0, Undefined, path], 1);
             }];
         return [0,
                 function(input){return caml_call1(r[1], input);},
                 r,
                 [0, 0]];
        }
        function get_wip_computation(shared){
         var match = shared[3][1];
         if(! match) return shared[1];
         var clos = match[1];
         return clos;
        }
        function set_final_computation(shared, computation){
         var compiletime_dereference = shared[3];
         if(compiletime_dereference[1])
          throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
         if(caml_call2(Base[203], shared[1], computation))
          throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
         compiletime_dereference[1] = [0, computation];
         shared[2][1] = computation;
         return computation;
        }
        function share(param){return 1;}
        return [0,
                Context,
                init,
                get_wip_computation,
                set_final_computation,
                share];
       },
       [0],
       function(X){
        var required = X[2], name = X[1];
        caml_call1(Typerep_lib_Type_generic_intf[1], [0]);
        var
         _e_ = Typerep_lib_Typename[8],
         include = caml_call1(Stdlib_Hashtbl[26], [0, _e_[2], _e_[3]]),
         create = include[1],
         replace = include[10],
         mem = include[11],
         _f_ = include[7];
        function find(table, key){
         if(! caml_call1(Stdlib_Lazy[3], table)) return 0;
         var
          _aj_ = caml_obj_tag(table),
          table$0 =
            250 === _aj_
             ? table[1]
             : 246 === _aj_ ? caml_call1(CamlinternalLazy[2], table) : table;
         try{var _al_ = [0, caml_call2(_f_, table$0, key)]; return _al_;}
         catch(_am_){
          var _ak_ = caml_wrap_exception(_am_);
          if(_ak_[1] !== Base[205] && _ak_ !== Caml[8])
           throw caml_maybe_attach_backtrace(_ak_, 0);
          return 0;
         }
        }
        var
         check_dependencies =
           required
            ? function
             (uid){
              return caml_call2
                      (Stdlib_List[17],
                       function(param){
                        var
                         implements$0 = param[2],
                         name$0 = param[1],
                         _ah_ = 1 - caml_call1(implements$0, uid);
                        if(! _ah_) return _ah_;
                        var
                         _ai_ = caml_call1(Typerep_lib_Typename[8][4], uid),
                         message =
                           caml_call4(Stdlib_Printf[4], _c_, name, name$0, _ai_);
                        caml_call1(Stdlib[53], message);
                        throw caml_maybe_attach_backtrace
                               ([0, Broken_dependency, message], 1);
                       },
                       required);
             }
            : function(param){return;};
        function replace$0(table, key, value){
         check_dependencies(key);
         var
          _af_ = caml_obj_tag(table),
          _ag_ =
            250 === _af_
             ? table[1]
             : 246 === _af_ ? caml_call1(CamlinternalLazy[2], table) : table;
         return caml_call3(replace, _ag_, key, value);
        }
        function mem$0(table, key){
         if(! caml_call1(Stdlib_Lazy[3], table)) return 0;
         var
          _ae_ = caml_obj_tag(table),
          table$0 =
            250 === _ae_
             ? table[1]
             : 246 === _ae_ ? caml_call1(CamlinternalLazy[2], table) : table;
         return caml_call2(mem, table$0, key);
        }
        var
         size = 256,
         table0 = [246, function(_ad_){return caml_call1(create, size);}],
         table1 = [246, function(_ac_){return caml_call1(create, size);}],
         table2 = [246, function(_ab_){return caml_call1(create, size);}],
         table3 = [246, function(_aa_){return caml_call1(create, size);}],
         table4 = [246, function(_$_){return caml_call1(create, size);}],
         table5 = [246, function(___){return caml_call1(create, size);}];
        function is_registered(uid){
         var _U_ = mem$0(table0, uid);
         if(_U_)
          var _V_ = _U_;
         else{
          var _W_ = mem$0(table1, uid);
          if(_W_)
           var _V_ = _W_;
          else{
           var _X_ = mem$0(table2, uid);
           if(_X_)
            var _V_ = _X_;
           else{
            var _Y_ = mem$0(table3, uid);
            if(_Y_)
             var _V_ = _Y_;
            else{
             var _Z_ = mem$0(table4, uid);
             if(! _Z_) return mem$0(table5, uid);
             var _V_ = _Z_;
            }
           }
          }
         }
         return _V_;
        }
        var ident = [0, name, is_registered], unit = Typerep_lib_Typename[2];
        function register0(compute){
         var uid = caml_call1(Typerep_lib_Typename[9], compute[2]);
         return replace$0(table0, uid, compute);
        }
        function register1(compute){
         var
          _T_ = caml_call1(compute[2], unit),
          uid = caml_call1(Typerep_lib_Typename[9], _T_);
         return replace$0(table1, uid, compute);
        }
        function register2(compute){
         var
          _S_ = caml_call2(compute[2], unit, unit),
          uid = caml_call1(Typerep_lib_Typename[9], _S_);
         return replace$0(table2, uid, compute);
        }
        function register3(compute){
         var
          _R_ = caml_call3(compute[2], unit, unit, unit),
          uid = caml_call1(Typerep_lib_Typename[9], _R_);
         return replace$0(table3, uid, compute);
        }
        function register4(compute){
         var
          _Q_ = caml_call4(compute[2], unit, unit, unit, unit),
          uid = caml_call1(Typerep_lib_Typename[9], _Q_);
         return replace$0(table4, uid, compute);
        }
        function register5(compute){
         var
          _P_ = caml_call5(compute[2], unit, unit, unit, unit, unit),
          uid = caml_call1(Typerep_lib_Typename[9], _P_);
         return replace$0(table5, uid, compute);
        }
        function register(typerep_of_a, compute){
         var
          typename_of_t =
            caml_call1(Typerep_lib_Std_internal[1][14], typerep_of_a);
         return register0([0, typerep_of_a, typename_of_t, compute]);
        }
        var
         Not_implemented =
           [248, cst_Typerep_lib_Type_generic_M$0, caml_fresh_oo_id(0)],
         Memo = caml_call1(Typerep_lib_Typename[17], [0]),
         _g_ = Typerep_lib_Std_internal[1],
         Helper$0 =
           Helper
            ([0,
              _g_[3],
              _g_[4],
              _g_[5],
              _g_[6],
              _g_[7],
              _g_[8],
              _g_[9],
              _g_[10]],
             [0, X[3], X[4], X[5], X[6], X[7], X[8], X[9], X[10]]);
        function of_typerep(rep){
         var
          context = caml_call1(X[33][1][1], 0),
          memo_table = caml_call1(Memo[1], 32);
         function of_typerep(param){
          var param$0 = param;
          for(;;){
           if(typeof param$0 === "number")
            switch(param$0){
              case 0:
               return X[11];
              case 1:
               return X[12];
              case 2:
               return X[13];
              case 3:
               return X[14];
              case 4:
               return X[15];
              case 5:
               return X[16];
              case 6:
               return X[17];
              case 7:
               return X[18];
              case 8:
               return X[19];
              default: return X[20];
            }
           switch(param$0[0]){
             case 0:
              var rep$11 = param$0[1], _D_ = of_typerep(rep$11);
              return caml_call1(X[21], _D_);
             case 1:
              var rep$12 = param$0[1], _E_ = of_typerep(rep$12);
              return caml_call1(X[22], _E_);
             case 2:
              var rep$13 = param$0[1], _F_ = of_typerep(rep$13);
              return caml_call1(X[23], _F_);
             case 3:
              var rep$14 = param$0[1], _G_ = of_typerep(rep$14);
              return caml_call1(X[24], _G_);
             case 4:
              var rep$15 = param$0[1], _H_ = of_typerep(rep$15);
              return caml_call1(X[25], _H_);
             case 5:
              var
               match$11 = param$0[1],
               rng = match$11[2],
               dom = match$11[1],
               _I_ = of_typerep(rng),
               _J_ = of_typerep(dom);
              return caml_call2(X[26], _J_, _I_);
             case 6:
              var tuple = param$0[1];
              switch(tuple[0]){
                case 0:
                 var
                  match$12 = tuple[1],
                  b = match$12[2],
                  a = match$12[1],
                  ra = of_typerep(a),
                  rb = of_typerep(b);
                 return caml_call2(X[27], ra, rb);
                case 1:
                 var
                  match$13 = tuple[1],
                  c = match$13[3],
                  b$0 = match$13[2],
                  a$0 = match$13[1],
                  ra$0 = of_typerep(a$0),
                  rb$0 = of_typerep(b$0),
                  rc = of_typerep(c);
                 return caml_call3(X[28], ra$0, rb$0, rc);
                case 2:
                 var
                  match$14 = tuple[1],
                  d = match$14[4],
                  c$0 = match$14[3],
                  b$1 = match$14[2],
                  a$1 = match$14[1],
                  ra$1 = of_typerep(a$1),
                  rb$1 = of_typerep(b$1),
                  rc$0 = of_typerep(c$0),
                  rd = of_typerep(d);
                 return caml_call4(X[29], ra$1, rb$1, rc$0, rd);
                default:
                 var
                  match$15 = tuple[1],
                  e = match$15[5],
                  d$0 = match$15[4],
                  c$1 = match$15[3],
                  b$2 = match$15[2],
                  a$2 = match$15[1],
                  ra$2 = of_typerep(a$2),
                  rb$2 = of_typerep(b$2),
                  rc$1 = of_typerep(c$1),
                  rd$0 = of_typerep(d$0),
                  re = of_typerep(e);
                 return caml_call5(X[30], ra$2, rb$2, rc$1, rd$0, re);
              }
             case 7:
              var
               record = param$0[1],
               _K_ = caml_call2(Helper$0[2], [0, of_typerep], record);
              return caml_call1(X[31], _K_);
             case 8:
              var
               variant = param$0[1],
               _L_ = caml_call2(Helper$0[1], [0, of_typerep], variant);
              return caml_call1(X[32], _L_);
             default:
              var
               match$16 = param$0[1],
               content = match$16[2],
               named = match$16[1],
               typename = caml_call1(Typerep_lib_Std_internal[1][1][2], named),
               match$17 = caml_call2(Memo[4], memo_table, typename);
              if(match$17){
               var shared = match$17[1];
               return caml_call1(X[33][3], shared);
              }
              switch(named[0]){
                case 0:
                 var
                  rep$5 = named[1],
                  match =
                    find(table0, caml_call1(Typerep_lib_Typename[9], rep$5[2]));
                 if(match)
                  var
                   rep = match[1],
                   witness =
                     caml_call2(Typerep_lib_Typename[5], rep[2], rep$5[1]),
                   L = caml_call1(Typerep_lib_Type_equal[3], [0]),
                   _h_ = rep[3],
                   _i_ = caml_call1(L[1], witness),
                   match$5 =
                     [0, caml_call2(Typerep_lib_Type_equal[1], _i_, _h_)];
                 else
                  var match$5 = 0;
                 if(match$5)
                  var custom = match$5[1], match$18 = [0, custom];
                 else
                  var match$18 = 0;
                 break;
                case 1:
                 var
                  rep$6 = named[1],
                  match$0 =
                    find(table1, caml_call1(Typerep_lib_Typename[9], rep$6[3]));
                 if(match$0)
                  var
                   rep$0 = match$0[1],
                   typename_of_t = rep$6[2],
                   Conv =
                     caml_call1
                      (caml_call1(Typerep_lib_Typename[18], [0, rep$0[2]]),
                       [0, typename_of_t]),
                   L$0 = caml_call1(Typerep_lib_Type_equal[3], [0]),
                   _j_ = rep$0[3],
                   _k_ = caml_call1(L$0[1], Conv[1][1]),
                   match$6 =
                     [0, caml_call2(Typerep_lib_Type_equal[1], _k_, _j_)];
                 else
                  var match$6 = 0;
                 if(match$6)
                  var
                   custom$0 = match$6[1],
                   custom$1 = caml_call1(custom$0, of_typerep(rep$6[1])),
                   match$18 = [0, custom$1];
                 else
                  var match$18 = 0;
                 break;
                case 2:
                 var
                  rep$7 = named[1],
                  match$1 =
                    find(table2, caml_call1(Typerep_lib_Typename[9], rep$7[4]));
                 if(match$1)
                  var
                   rep$1 = match$1[1],
                   typename_of_t$0 = rep$7[3],
                   Conv$0 =
                     caml_call1
                      (caml_call1(Typerep_lib_Typename[19], [0, rep$1[2]]),
                       [0, typename_of_t$0]),
                   L$1 = caml_call1(Typerep_lib_Type_equal[3], [0]),
                   _l_ = rep$1[3],
                   _m_ = caml_call1(L$1[1], Conv$0[1][1]),
                   match$7 =
                     [0, caml_call2(Typerep_lib_Type_equal[1], _m_, _l_)];
                 else
                  var match$7 = 0;
                 if(match$7)
                  var
                   custom$2 = match$7[1],
                   _t_ = of_typerep(rep$7[2]),
                   custom$3 = caml_call2(custom$2, of_typerep(rep$7[1]), _t_),
                   match$18 = [0, custom$3];
                 else
                  var match$18 = 0;
                 break;
                case 3:
                 var
                  rep$8 = named[1],
                  match$2 =
                    find(table3, caml_call1(Typerep_lib_Typename[9], rep$8[5]));
                 if(match$2)
                  var
                   rep$2 = match$2[1],
                   typename_of_t$1 = rep$8[4],
                   Conv$1 =
                     caml_call1
                      (caml_call1(Typerep_lib_Typename[20], [0, rep$2[2]]),
                       [0, typename_of_t$1]),
                   L$2 = caml_call1(Typerep_lib_Type_equal[3], [0]),
                   _n_ = rep$2[3],
                   _o_ = caml_call1(L$2[1], Conv$1[1][1]),
                   match$8 =
                     [0, caml_call2(Typerep_lib_Type_equal[1], _o_, _n_)];
                 else
                  var match$8 = 0;
                 if(match$8)
                  var
                   custom$4 = match$8[1],
                   _u_ = of_typerep(rep$8[3]),
                   _v_ = of_typerep(rep$8[2]),
                   custom$5 =
                     caml_call3(custom$4, of_typerep(rep$8[1]), _v_, _u_),
                   match$18 = [0, custom$5];
                 else
                  var match$18 = 0;
                 break;
                case 4:
                 var
                  rep$9 = named[1],
                  match$3 =
                    find(table4, caml_call1(Typerep_lib_Typename[9], rep$9[6]));
                 if(match$3)
                  var
                   rep$3 = match$3[1],
                   typename_of_t$2 = rep$9[5],
                   Conv$2 =
                     caml_call1
                      (caml_call1(Typerep_lib_Typename[21], [0, rep$3[2]]),
                       [0, typename_of_t$2]),
                   L$3 = caml_call1(Typerep_lib_Type_equal[3], [0]),
                   _p_ = rep$3[3],
                   _q_ = caml_call1(L$3[1], Conv$2[1][1]),
                   match$9 =
                     [0, caml_call2(Typerep_lib_Type_equal[1], _q_, _p_)];
                 else
                  var match$9 = 0;
                 if(match$9)
                  var
                   custom$6 = match$9[1],
                   _w_ = of_typerep(rep$9[4]),
                   _x_ = of_typerep(rep$9[3]),
                   _y_ = of_typerep(rep$9[2]),
                   custom$7 =
                     caml_call4(custom$6, of_typerep(rep$9[1]), _y_, _x_, _w_),
                   match$18 = [0, custom$7];
                 else
                  var match$18 = 0;
                 break;
                default:
                 var
                  rep$10 = named[1],
                  match$4 =
                    find(table5, caml_call1(Typerep_lib_Typename[9], rep$10[7]));
                 if(match$4)
                  var
                   rep$4 = match$4[1],
                   typename_of_t$3 = rep$10[6],
                   Conv$3 =
                     caml_call1
                      (caml_call1(Typerep_lib_Typename[22], [0, rep$4[2]]),
                       [0, typename_of_t$3]),
                   L$4 = caml_call1(Typerep_lib_Type_equal[3], [0]),
                   _r_ = rep$4[3],
                   _s_ = caml_call1(L$4[1], Conv$3[1][1]),
                   match$10 =
                     [0, caml_call2(Typerep_lib_Type_equal[1], _s_, _r_)];
                 else
                  var match$10 = 0;
                 if(match$10)
                  var
                   custom$8 = match$10[1],
                   _z_ = of_typerep(rep$10[5]),
                   _A_ = of_typerep(rep$10[4]),
                   _B_ = of_typerep(rep$10[3]),
                   _C_ = of_typerep(rep$10[2]),
                   custom$9 =
                     caml_call5
                      (custom$8, of_typerep(rep$10[1]), _C_, _B_, _A_, _z_),
                   match$18 = [0, custom$9];
                 else
                  var match$18 = 0;
              }
              if(match$18){var computation = match$18[1]; return computation;}
              if(! content){
               var
                _O_ = caml_call1(Typerep_lib_Typename[9], typename),
                string = caml_call1(Typerep_lib_Typename[8][4], _O_);
               throw caml_maybe_attach_backtrace
                      ([0, Not_implemented, name, string], 1);
              }
              var
               _M_ = content[1],
               _N_ = caml_obj_tag(_M_),
               content$0 =
                 250 === _N_
                  ? _M_[1]
                  : 246 === _N_ ? caml_call1(CamlinternalLazy[2], _M_) : _M_;
              if(caml_call1(X[33][5], content$0)){
               var shared$0 = caml_call2(X[33][2], context, typename);
               caml_call3(Memo[3], memo_table, typename, shared$0);
               var computation$0 = of_typerep(content$0);
               return caml_call2(X[33][4], shared$0, computation$0);
              }
              param$0 = content$0;
           }
          }
         }
         var computation = of_typerep(rep);
         return [0, 911962647, computation];
        }
        return [0,
                ident,
                Not_implemented,
                register0,
                register1,
                register2,
                register3,
                register4,
                register5,
                register,
                of_typerep,
                [0,
                 X[3],
                 X[4],
                 X[5],
                 X[6],
                 X[7],
                 X[8],
                 X[9],
                 X[10],
                 X[11],
                 X[12],
                 X[13],
                 X[14],
                 X[15],
                 X[16],
                 X[17],
                 X[18],
                 X[19],
                 X[20],
                 X[21],
                 X[22],
                 X[23],
                 X[24],
                 X[25],
                 X[26],
                 X[27],
                 X[28],
                 X[29],
                 X[30],
                 X[31],
                 X[32],
                 X[33]]];
       }];
   runtime.caml_register_global
    (21, Typerep_lib_Type_generic, "Typerep_lib__Type_generic");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Make_typename
//# unitInfo: Requires: Typerep_lib__Std_internal, Typerep_lib__Type_equal, Typerep_lib__Typename
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    Typerep_lib_Type_equal = global_data.Typerep_lib__Type_equal,
    Typerep_lib_Typename = global_data.Typerep_lib__Typename,
    Typerep_lib_Make_typename =
      [0,
       function(X){
        var
         Name_of_x = caml_call1(Typerep_lib_Typename[11], X),
         typename_of_t = Name_of_x[1],
         typename_of_named = Name_of_x[1],
         witness = Typerep_lib_Type_equal[2],
         named = [0, [0, typename_of_named, typename_of_t, witness]];
        return [0, named, typename_of_t];
       },
       function(X){
        var
         Name_of_x = caml_call1(Typerep_lib_Typename[12], X),
         typename_of_t = Name_of_x[1];
        function named(of_p1){
         var
          _o_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
          typename_of_t = caml_call1(Name_of_x[1], _o_),
          typename_of_named = Name_of_x[1],
          witness = Typerep_lib_Type_equal[2];
         return [1, [0, of_p1, typename_of_named, typename_of_t, witness]];
        }
        return [0, named, typename_of_t];
       },
       function(X){
        var
         Name_of_x = caml_call1(Typerep_lib_Typename[13], X),
         typename_of_t = Name_of_x[1];
        function named(of_p1, of_p2){
         var
          _m_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
          _n_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
          typename_of_t = caml_call2(Name_of_x[1], _n_, _m_),
          typename_of_named = Name_of_x[1],
          witness = Typerep_lib_Type_equal[2];
         return [2,
                 [0, of_p1, of_p2, typename_of_named, typename_of_t, witness]];
        }
        return [0, named, typename_of_t];
       },
       function(X){
        var
         Name_of_x = caml_call1(Typerep_lib_Typename[14], X),
         typename_of_t = Name_of_x[1];
        function named(of_p1, of_p2, of_p3){
         var
          _j_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
          _k_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
          _l_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
          typename_of_t = caml_call3(Name_of_x[1], _l_, _k_, _j_),
          typename_of_named = Name_of_x[1],
          witness = Typerep_lib_Type_equal[2];
         return [3,
                 [0,
                  of_p1,
                  of_p2,
                  of_p3,
                  typename_of_named,
                  typename_of_t,
                  witness]];
        }
        return [0, named, typename_of_t];
       },
       function(X){
        var
         Name_of_x = caml_call1(Typerep_lib_Typename[15], X),
         typename_of_t = Name_of_x[1];
        function named(of_p1, of_p2, of_p3, of_p4){
         var
          _f_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p4),
          _g_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
          _h_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
          _i_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
          typename_of_t = caml_call4(Name_of_x[1], _i_, _h_, _g_, _f_),
          typename_of_named = Name_of_x[1],
          witness = Typerep_lib_Type_equal[2];
         return [4,
                 [0,
                  of_p1,
                  of_p2,
                  of_p3,
                  of_p4,
                  typename_of_named,
                  typename_of_t,
                  witness]];
        }
        return [0, named, typename_of_t];
       },
       function(X){
        var
         Name_of_x = caml_call1(Typerep_lib_Typename[16], X),
         typename_of_t = Name_of_x[1];
        function named(of_p1, of_p2, of_p3, of_p4, of_p5){
         var
          _a_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p5),
          _b_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p4),
          _c_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p3),
          _d_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p2),
          _e_ = caml_call1(Typerep_lib_Std_internal[1][14], of_p1),
          typename_of_t = caml_call5(Name_of_x[1], _e_, _d_, _c_, _b_, _a_),
          typename_of_named = Name_of_x[1],
          witness = Typerep_lib_Type_equal[2];
         return [5,
                 [0,
                  of_p1,
                  of_p2,
                  of_p3,
                  of_p4,
                  of_p5,
                  typename_of_named,
                  typename_of_t,
                  witness]];
        }
        return [0, named, typename_of_t];
       }];
   runtime.caml_register_global
    (3, Typerep_lib_Make_typename, "Typerep_lib__Make_typename");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Type_abstract
//# unitInfo: Requires: Typerep_lib__Make_typename
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Make_typename = global_data.Typerep_lib__Make_typename;
   function Make0(X){
    var
     M = caml_call1(Typerep_lib_Make_typename[1], X),
     typerep_of_t = [9, [0, M[1], 0]],
     typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make1(X){
    var M = caml_call1(Typerep_lib_Make_typename[2], X);
    function typerep_of_t(of_p1){return [9, [0, caml_call1(M[1], of_p1), 0]];}
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make2(X){
    var M = caml_call1(Typerep_lib_Make_typename[3], X);
    function typerep_of_t(of_p1, of_p2){
     return [9, [0, caml_call2(M[1], of_p1, of_p2), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make3(X){
    var M = caml_call1(Typerep_lib_Make_typename[4], X);
    function typerep_of_t(of_p1, of_p2, of_p3){
     return [9, [0, caml_call3(M[1], of_p1, of_p2, of_p3), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make4(X){
    var M = caml_call1(Typerep_lib_Make_typename[5], X);
    function typerep_of_t(of_p1, of_p2, of_p3, of_p4){
     return [9, [0, caml_call4(M[1], of_p1, of_p2, of_p3, of_p4), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   function Make5(X){
    var M = caml_call1(Typerep_lib_Make_typename[6], X);
    function typerep_of_t(of_p1, of_p2, of_p3, of_p4, of_p5){
     return [9, [0, caml_call5(M[1], of_p1, of_p2, of_p3, of_p4, of_p5), 0]];
    }
    var typename_of_t = M[2];
    return [0, typerep_of_t, typename_of_t];
   }
   var
    Typerep_lib_Type_abstract = [0, Make0, Make1, Make2, Make3, Make4, Make5];
   runtime.caml_register_global
    (1, Typerep_lib_Type_abstract, "Typerep_lib__Type_abstract");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Typerep_lib__Std
//# unitInfo: Requires: Typerep_lib__Std_internal
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Typerep_lib_Std_internal = global_data.Typerep_lib__Std_internal,
    Typerep = Typerep_lib_Std_internal[1],
    typerep_of_int = Typerep_lib_Std_internal[2],
    typerep_of_int32 = Typerep_lib_Std_internal[3],
    typerep_of_int64 = Typerep_lib_Std_internal[4],
    typerep_of_nativeint = Typerep_lib_Std_internal[5],
    typerep_of_int63 = Typerep_lib_Std_internal[6],
    typerep_of_char = Typerep_lib_Std_internal[7],
    typerep_of_float = Typerep_lib_Std_internal[8],
    typerep_of_string = Typerep_lib_Std_internal[9],
    typerep_of_bytes = Typerep_lib_Std_internal[10],
    typerep_of_bool = Typerep_lib_Std_internal[11],
    typerep_of_unit = Typerep_lib_Std_internal[12],
    value_tuple0 = Typerep_lib_Std_internal[13],
    typerep_of_option = Typerep_lib_Std_internal[14],
    typerep_of_list = Typerep_lib_Std_internal[15],
    typerep_of_array = Typerep_lib_Std_internal[16],
    typerep_of_lazy_t = Typerep_lib_Std_internal[17],
    typerep_of_ref = Typerep_lib_Std_internal[18],
    typerep_of_function = Typerep_lib_Std_internal[19],
    typerep_of_tuple0 = Typerep_lib_Std_internal[20],
    typerep_of_tuple2 = Typerep_lib_Std_internal[21],
    typerep_of_tuple3 = Typerep_lib_Std_internal[22],
    typerep_of_tuple4 = Typerep_lib_Std_internal[23],
    typerep_of_tuple5 = Typerep_lib_Std_internal[24],
    typename_of_int = Typerep_lib_Std_internal[25],
    typename_of_int32 = Typerep_lib_Std_internal[26],
    typename_of_int64 = Typerep_lib_Std_internal[27],
    typename_of_nativeint = Typerep_lib_Std_internal[28],
    typename_of_int63 = Typerep_lib_Std_internal[29],
    typename_of_char = Typerep_lib_Std_internal[30],
    typename_of_float = Typerep_lib_Std_internal[31],
    typename_of_string = Typerep_lib_Std_internal[32],
    typename_of_bytes = Typerep_lib_Std_internal[33],
    typename_of_bool = Typerep_lib_Std_internal[34],
    typename_of_unit = Typerep_lib_Std_internal[35],
    typename_of_option = Typerep_lib_Std_internal[36],
    typename_of_list = Typerep_lib_Std_internal[37],
    typename_of_array = Typerep_lib_Std_internal[38],
    typename_of_lazy_t = Typerep_lib_Std_internal[39],
    typename_of_ref = Typerep_lib_Std_internal[40],
    typename_of_function = Typerep_lib_Std_internal[41],
    typename_of_tuple0 = Typerep_lib_Std_internal[42],
    typename_of_tuple2 = Typerep_lib_Std_internal[43],
    typename_of_tuple3 = Typerep_lib_Std_internal[44],
    typename_of_tuple4 = Typerep_lib_Std_internal[45],
    typename_of_tuple5 = Typerep_lib_Std_internal[46],
    Typerep_lib_Std =
      [0,
       Typerep,
       typerep_of_int,
       typerep_of_int32,
       typerep_of_int64,
       typerep_of_nativeint,
       typerep_of_int63,
       typerep_of_char,
       typerep_of_float,
       typerep_of_string,
       typerep_of_bytes,
       typerep_of_bool,
       typerep_of_unit,
       value_tuple0,
       typerep_of_option,
       typerep_of_list,
       typerep_of_array,
       typerep_of_lazy_t,
       typerep_of_ref,
       typerep_of_function,
       typerep_of_tuple0,
       typerep_of_tuple2,
       typerep_of_tuple3,
       typerep_of_tuple4,
       typerep_of_tuple5,
       typename_of_int,
       typename_of_int32,
       typename_of_int64,
       typename_of_nativeint,
       typename_of_int63,
       typename_of_char,
       typename_of_float,
       typename_of_string,
       typename_of_bytes,
       typename_of_bool,
       typename_of_unit,
       typename_of_option,
       typename_of_list,
       typename_of_array,
       typename_of_lazy_t,
       typename_of_ref,
       typename_of_function,
       typename_of_tuple0,
       typename_of_tuple2,
       typename_of_tuple3,
       typename_of_tuple4,
       typename_of_tuple5];
   runtime.caml_register_global(1, Typerep_lib_Std, "Typerep_lib__Std");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0eXBlcmVwX2xpYi5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiY29udiIsIngiLCJsaWZ0IiwiY29tcGFyZSIsImEiLCJiIiwiZXF1YWwiLCJ1aWQiLCJuZXh0IiwibmFtZSIsImNvZGUiLCJoYXNoIiwic3RhdGljJDAiLCJjb21wYXJlJDAiLCJrMSIsImsyIiwiY21wIiwiYiQwIiwiYSQwIiwieXMiLCJ5IiwieHMiLCJuIiwiZXF1YWwkMCIsImhhc2gkMCIsInN0YXRpYyQxIiwia2V5IiwidCIsInVpZCQwIiwibmFtZSQwIiwiY3JlYXRlIiwib3B0Iiwic3RoIiwic2FtZSIsIm5tMSIsIm5tMiIsInNhbWVfd2l0bmVzcyIsInNhbWVfd2l0bmVzc19leG4iLCJpbnQkMCIsIm1lbSIsInRhYmxlIiwic2V0IiwiZGF0YSIsImZpbmQiLCJkYXRhJDAiLCJmYWlsIiwidWlkX2EiLCJ1aWRfYiIsIm1zZyIsInQkMCIsIndpdG5lc3MiLCJ0eXBlbmFtZV9vZl90IiwiYyIsImQiLCJlIiwibGFiZWwiLCJhcml0eSIsImFyZ3NfbGFiZWxzIiwiaW5kZXgiLCJvY2FtbF9yZXByIiwidHlpZCIsInRyYXZlcnNlIiwiaW50ZXJuYWxfdXNlX29ubHkiLCJsZW5ndGgiLCJ0YWciLCJpc19wb2x5bW9ycGhpYyIsInZhbHVlIiwiZm9sZCIsImluaXQiLCJmIiwiaW50ZXJuYWxfdXNlX29ubHkkMCIsImxhYmVsJDAiLCJpbmRleCQwIiwiZ2V0IiwiaXNfbXV0YWJsZSIsInR5aWQkMCIsInRyYXZlcnNlJDAiLCJpbnRlcm5hbF91c2Vfb25seSQxIiwidHlwZW5hbWVfb2ZfdCQwIiwibGVuZ3RoJDAiLCJmaWVsZCIsImhhc19kb3VibGVfYXJyYXlfdGFnIiwiY3JlYXRlJDAiLCJmb2xkJDAiLCJpbnRlcm5hbF91c2Vfb25seSQyIiwibmFtZSQxIiwibmFtZSQyIiwibmFtZSQzIiwibmFtZSQ0IiwibmFtZSQ1IiwibmFtZSQ2IiwibmFtZSQ3IiwibmFtZSQ4IiwibmFtZSQ5IiwibmFtZSQxMCIsIm5hbWUkMTEiLCJuYW1lJDEyIiwibmFtZSQxMyIsIm5hbWUkMTQiLCJuYW1lJDE1IiwibmFtZSQxNiIsIm5hbWUkMTciLCJuYW1lJDE4IiwibmFtZSQxOSIsInR5cGVuYW1lX29mX2ludCIsInR5cGVuYW1lX29mX2ludDMyIiwidHlwZW5hbWVfb2ZfaW50NjQiLCJ0eXBlbmFtZV9vZl9uYXRpdmVpbnQiLCJ0eXBlbmFtZV9vZl9jaGFyIiwidHlwZW5hbWVfb2ZfZmxvYXQiLCJ0eXBlbmFtZV9vZl9zdHJpbmciLCJ0eXBlbmFtZV9vZl9ieXRlcyIsInR5cGVuYW1lX29mX2Jvb2wiLCJ0eXBlbmFtZV9vZl91bml0IiwidHlwZW5hbWVfb2Zfb3B0aW9uIiwidHlwZW5hbWVfb2ZfbGlzdCIsInR5cGVuYW1lX29mX2FycmF5IiwidHlwZW5hbWVfb2ZfbGF6eV90IiwidHlwZW5hbWVfb2ZfcmVmIiwidHlwZW5hbWVfb2ZfZnVuY3Rpb24iLCJ0eXBlbmFtZV9vZl90dXBsZTAiLCJ0eXBlbmFtZV9vZl90dXBsZTIiLCJ0eXBlbmFtZV9vZl90dXBsZTMiLCJ0eXBlbmFtZV9vZl90dXBsZTQiLCJ0eXBlbmFtZV9vZl90dXBsZTUiLCJyZXAiLCJyZXAkMCIsInJlcCQxIiwicmVwJDIiLCJyZXAkMyIsInJlcCQ0IiwibmFtZSQyMCIsImFyaXR5JDAiLCJjJDAiLCJiJDEiLCJhJDEiLCJkJDAiLCJjJDEiLCJiJDIiLCJhJDIiLCJ0eXBlbmFtZV9vZl90JDEiLCJybmciLCJkb20iLCJyZXAkNSIsInJlcCQ2IiwidDEiLCJ0MiIsInQxJDAiLCJ0MiQwIiwicjEiLCJyMiQwIiwicjEkMCIsInIyJDEiLCJ4JDAiLCJyMSQxIiwicjIkMiIsIngkMSIsInIxJDIiLCJyMiQzIiwieCQyIiwicjEkMyIsInIyJDQiLCJ4JDMiLCJybmcxIiwiZG9tMSIsInJuZzIiLCJkb20yIiwidDEkMSIsInQyJDIiLCJiMiIsImEyIiwiYjEiLCJhMSIsImMyIiwiYjIkMCIsImEyJDAiLCJjMSIsImIxJDAiLCJhMSQwIiwiZDIiLCJjMiQwIiwiYjIkMSIsImEyJDEiLCJkMSIsImMxJDAiLCJiMSQxIiwiYTEkMSIsImUyIiwiZDIkMCIsImMyJDEiLCJiMiQyIiwiYTIkMiIsImUxIiwiZDEkMCIsImMxJDEiLCJiMSQyIiwiYTEkMiIsInIxJDQiLCJyMiQ1IiwicjEkNSIsInIyJDYiLCJuYW1lMSIsInIyJDciLCJuYW1lMiIsInIxJDciLCJ4JDQiLCJ0MiQ0IiwidDEkMyIsInQyJDMiLCJyMSQ2IiwidDEkMiIsInIyIiwidDIkMSIsInByb29mIiwiaGVhZCIsInQkMSIsInR5cGVyZXBfb2ZfaW50IiwidHlwZXJlcF9vZl9pbnQ2NCIsInR5cGVyZXBfb2Zfb3B0aW9uIiwidHlwZXJlcF9vZl9saXN0IiwidHlwZXJlcF9vZl9hcnJheSIsInR5cGVyZXBfb2ZfbGF6eV90IiwidHlwZXJlcF9vZl9yZWYiLCJ0eXBlcmVwX29mX2Z1bmN0aW9uIiwidHlwZXJlcF9vZl90dXBsZTIiLCJ0eXBlcmVwX29mX3R1cGxlMyIsInR5cGVyZXBfb2ZfdHVwbGU0IiwidHlwZXJlcF9vZl90dXBsZTUiLCJ0eXBlcmVwX29mX2ludDMyIiwidHlwZXJlcF9vZl9uYXRpdmVpbnQiLCJ0eXBlcmVwX29mX2NoYXIiLCJ0eXBlcmVwX29mX2Zsb2F0IiwidHlwZXJlcF9vZl9zdHJpbmciLCJ0eXBlcmVwX29mX2J5dGVzIiwidHlwZXJlcF9vZl9ib29sIiwidHlwZXJlcF9vZl91bml0IiwidHlwZXJlcF9vZl90dXBsZTAiLCJ2YWx1ZV90dXBsZTAiLCJ0eXBlbmFtZV9vZl9pbnQ2MyIsInR5cGVyZXBfb2ZfaW50NjMiLCJyZXByX29mX3BvbHlfdmFyaWFudCIsInZhcmlhbnQiLCJzaXplIiwicmVwciIsImhhc2hfdmFyaWFudCIsInMiLCJhY2N1IiwiaSIsImRvdWJsZV9hcnJheV92YWx1ZSIsImRvdWJsZSQwIiwic2ltcGxlIiwibWFwX3ZhcmlhbnQiLCJtYXAiLCJ0eXBlbmFtZSIsInBvbHltb3JwaGljIiwidGFncyIsInRhZyQwIiwiZmN0IiwiayIsImF0YWciLCJidGFnIiwibWFwX3JlY29yZCIsInJlY29yZCIsImZpZWxkcyIsImZpZWxkJDAiLCJnZXQkMCIsImFmaWVsZCIsImJmaWVsZCIsInBhdGgiLCJyIiwiaW5wdXQiLCJnZXRfd2lwX2NvbXB1dGF0aW9uIiwic2hhcmVkIiwiY2xvcyIsInNldF9maW5hbF9jb21wdXRhdGlvbiIsImNvbXB1dGF0aW9uIiwiY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UiLCJzaGFyZSIsInJlcXVpcmVkIiwidGFibGUkMCIsImNoZWNrX2RlcGVuZGVuY2llcyIsImltcGxlbWVudHMkMCIsIm1lc3NhZ2UiLCJyZXBsYWNlJDAiLCJtZW0kMCIsInRhYmxlMCIsInRhYmxlMSIsInRhYmxlMiIsInRhYmxlMyIsInRhYmxlNCIsInRhYmxlNSIsImlzX3JlZ2lzdGVyZWQiLCJpZGVudCIsInVuaXQiLCJyZWdpc3RlcjAiLCJjb21wdXRlIiwicmVnaXN0ZXIxIiwicmVnaXN0ZXIyIiwicmVnaXN0ZXIzIiwicmVnaXN0ZXI0IiwicmVnaXN0ZXI1IiwicmVnaXN0ZXIiLCJ0eXBlcmVwX29mX2EiLCJvZl90eXBlcmVwIiwiY29udGV4dCIsIm1lbW9fdGFibGUiLCJyZXAkMTEiLCJyZXAkMTIiLCJyZXAkMTMiLCJyZXAkMTQiLCJyZXAkMTUiLCJ0dXBsZSIsInJhIiwicmIiLCJyYSQwIiwicmIkMCIsInJjIiwicmEkMSIsInJiJDEiLCJyYyQwIiwicmQiLCJyYSQyIiwicmIkMiIsInJjJDEiLCJyZCQwIiwicmUiLCJjb250ZW50IiwibmFtZWQiLCJjdXN0b20iLCJjdXN0b20kMCIsImN1c3RvbSQxIiwicmVwJDciLCJjdXN0b20kMiIsImN1c3RvbSQzIiwicmVwJDgiLCJjdXN0b20kNCIsImN1c3RvbSQ1IiwicmVwJDkiLCJ0eXBlbmFtZV9vZl90JDIiLCJjdXN0b20kNiIsImN1c3RvbSQ3IiwicmVwJDEwIiwidHlwZW5hbWVfb2ZfdCQzIiwiY3VzdG9tJDgiLCJjdXN0b20kOSIsInN0cmluZyIsImNvbnRlbnQkMCIsInNoYXJlZCQwIiwiY29tcHV0YXRpb24kMCIsInR5cGVuYW1lX29mX25hbWVkIiwib2ZfcDEiLCJvZl9wMiIsIm9mX3AzIiwib2ZfcDQiLCJvZl9wNSIsInR5cGVyZXBfb2ZfdCJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvdHlwZXJlcC90eXBlX2VxdWFsLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi90eXBlcmVwL3R5cGVuYW1lLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi90eXBlcmVwL3ZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi90eXBlcmVwL3N0ZF9pbnRlcm5hbC5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvdHlwZXJlcC90eXBlcmVwX29iai5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvdHlwZXJlcC90eXBlX2dlbmVyaWNfaW50Zi5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvdHlwZXJlcC90eXBlX2dlbmVyaWMubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL3R5cGVyZXAvbWFrZV90eXBlbmFtZS5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvdHlwZXJlcC90eXBlX2Fic3RyYWN0Lm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7RTs7Ozs7OztZQUlJQSxZQUE0Q0MsR0FBSyxPQUFMQSxFQUFNOzZCQU1oREMsWUFBb0QsU0FBQyxFQUQzRCxXQUNNQTtvQ0FORkY7Ozs7RTs7Ozs7Ozs7Ozs7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QyxPQUFNQyxPQUFNQyxPQUFNQztJQUNvQjtRQUd6RC9TO0lBUDBFLFdBRzFFZ1QsY0FJQWhUOzs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsidHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgQmFzZS5UeXBlX2VxdWFsLnQgPSBUIDogKCdhLCAnYSkgdFxudHlwZSAoJ2EsICdiKSBlcXVhbCA9ICgnYSwgJ2IpIHRcblxubGV0IHJlZmwgPSBUXG5sZXQgY29udiA6IHR5cGUgYSBiLiAoYSwgYikgdCAtPiBhIC0+IGIgPSBmdW4gVCB4IC0+IHhcblxubW9kdWxlIExpZnQgKFggOiBzaWdcbiAgICB0eXBlICdhIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbGV0IGxpZnQgKHR5cGUgYSBiKSAoVCA6IChhLCBiKSB0KSA6IChhIFgudCwgYiBYLnQpIHQgPSBUXG5lbmRcbiIsIigqIHRoaXMgbGliIHNob3VsZCBub3QgZGVwZW5kIG9uIGNvcmUgKilcbm1vZHVsZSBMaXN0ID0gc3RydWN0XG4gIGluY2x1ZGUgTGlzdFxuXG4gIGxldCBjb21wYXJlIGNtcCBhIGIgPVxuICAgIGxldCByZWMgbG9vcCBhIGIgPVxuICAgICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgICB8IFtdLCBbXSAtPiAwXG4gICAgICB8IFtdLCBfIC0+IC0xXG4gICAgICB8IF8sIFtdIC0+IDFcbiAgICAgIHwgeCA6OiB4cywgeSA6OiB5cyAtPlxuICAgICAgICBsZXQgbiA9IGNtcCB4IHkgaW5cbiAgICAgICAgaWYgbiA9IDAgdGhlbiBsb29wIHhzIHlzIGVsc2UgblxuICAgIGluXG4gICAgbG9vcCBhIGJcbiAgOztcbmVuZFxuXG5tb2R1bGUgVWlkIDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBjb21wYXJlIDogdCAtPiB0IC0+IGludFxuICB2YWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbFxuICB2YWwgbmV4dCA6IHN0cmluZyAtPiB0XG4gIHZhbCBoYXNoIDogdCAtPiBpbnRcbiAgdmFsIG5hbWUgOiB0IC0+IHN0cmluZ1xuICB2YWwgc3RhdGljIDogdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBjb2RlIDogaW50XG4gICAgOyBuYW1lIDogc3RyaW5nXG4gICAgfVxuXG4gIGxldCBjb21wYXJlIGEgYiA9IGNvbXBhcmUgKGEuY29kZSA6IGludCkgYi5jb2RlXG4gIGxldCBlcXVhbCBhIGIgPSAoYS5jb2RlIDogaW50KSA9IGIuY29kZVxuICBsZXQgdWlkID0gcmVmIDBcblxuICBsZXQgbmV4dCBuYW1lID1cbiAgICBsZXQgY29kZSA9ICF1aWQgaW5cbiAgICBpbmNyIHVpZDtcbiAgICB7IGNvZGU7IG5hbWUgfVxuICA7O1xuXG4gIGxldCBoYXNoIGEgPSBIYXNodGJsLmhhc2ggYS5jb2RlXG4gIGxldCBuYW1lIGEgPSBhLm5hbWVcbiAgbGV0IHN0YXRpYyA9IG5leHQgXCJzdGF0aWNcIlxuZW5kXG5cbm1vZHVsZSBLZXkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHVpZCA6IFVpZC50XG4gICAgOyBwYXJhbXMgOiB0IGxpc3RcbiAgICB9XG5cbiAgbGV0IHJlYyBjb21wYXJlIGsxIGsyID1cbiAgICBpZiBrMSA9PSBrMlxuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbGV0IGNtcCA9IFVpZC5jb21wYXJlIGsxLnVpZCBrMi51aWQgaW5cbiAgICAgIGlmIGNtcCA8PiAwIHRoZW4gY21wIGVsc2UgTGlzdC5jb21wYXJlIGNvbXBhcmUgazEucGFyYW1zIGsyLnBhcmFtcylcbiAgOztcblxuICBsZXQgZXF1YWwgYSBiID0gY29tcGFyZSBhIGIgPSAwXG4gIGxldCBoYXNoID0gKEhhc2h0YmwuaGFzaCA6IHQgLT4gaW50KVxuICBsZXQgc3RhdGljID0geyB1aWQgPSBVaWQuc3RhdGljOyBwYXJhbXMgPSBbXSB9XG5lbmRcblxudHlwZSAnYSB0ID0gS2V5LnRcbnR5cGUgJ2EgdHlwZW5hbWUgPSAnYSB0XG5cbmxldCBrZXkgdCA9IHRcbmxldCB1aWQgdCA9IHQuS2V5LnVpZFxubGV0IG5hbWUgdCA9IFVpZC5uYW1lIHQuS2V5LnVpZFxubGV0IHN0YXRpYyA9IEtleS5zdGF0aWNcbmxldCBjcmVhdGUgPyhuYW1lID0gXCJUeXBlbmFtZS5jcmVhdGVcIikgKCkgPSB7IEtleS51aWQgPSBVaWQubmV4dCBuYW1lOyBwYXJhbXMgPSBbXSB9XG5cbmluY2x1ZGUgc3RydWN0XG4gICgqIFRoZSBhcmd1bWVudCBmb3IgT2JqLm1hZ2ljIGhlcmUgaXMgdGhlIHNhbWUgYXMgdGhlIG9uZSBpbiBjb3JlL3R5cGVfZXF1YWwgKilcblxuICBsZXQgc2FtZSAodHlwZSBhIGIpIChubTEgOiBhIHQpIChubTIgOiBiIHQpID0gS2V5LmNvbXBhcmUgbm0xIG5tMiA9IDBcblxuICBsZXQgc2FtZV93aXRuZXNzICh0eXBlIGEgYikgKG5tMSA6IGEgdCkgKG5tMiA6IGIgdCkgPVxuICAgIGlmIEtleS5jb21wYXJlIG5tMSBubTIgPSAwXG4gICAgdGhlbiBTb21lIChPYmoubWFnaWMgVHlwZV9lcXVhbC5yZWZsIDogKGEsIGIpIFR5cGVfZXF1YWwudClcbiAgICBlbHNlIE5vbmVcbiAgOztcblxuICBsZXQgc2FtZV93aXRuZXNzX2V4biAodHlwZSBhIGIpIChubTEgOiBhIHQpIChubTIgOiBiIHQpID1cbiAgICBpZiBLZXkuY29tcGFyZSBubTEgbm0yID0gMFxuICAgIHRoZW4gKE9iai5tYWdpYyBUeXBlX2VxdWFsLnJlZmwgOiAoYSwgYikgVHlwZV9lcXVhbC50KVxuICAgIGVsc2UgZmFpbHdpdGggXCJUeXBlbmFtZS5zYW1lX3dpdG5lc3NfZXhuXCJcbiAgOztcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMCA9IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgdHlwZW5hbWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHR5cGVuYW1lIC0+ICdhIHQgdHlwZW5hbWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcblxuICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHR5cGVuYW1lIC0+ICdiIHR5cGVuYW1lIC0+ICgnYSwgJ2IpIHQgdHlwZW5hbWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0eXBlbmFtZSAtPiAnYiB0eXBlbmFtZSAtPiAnYyB0eXBlbmFtZSAtPiAoJ2EsICdiLCAnYykgdCB0eXBlbmFtZVxuZW5kXG5cbm1vZHVsZSB0eXBlIFM0ID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0XG5cbiAgdmFsIHR5cGVuYW1lX29mX3RcbiAgICA6ICAnYSB0eXBlbmFtZVxuICAgIC0+ICdiIHR5cGVuYW1lXG4gICAgLT4gJ2MgdHlwZW5hbWVcbiAgICAtPiAnZCB0eXBlbmFtZVxuICAgIC0+ICgnYSwgJ2IsICdjLCAnZCkgdCB0eXBlbmFtZVxuZW5kXG5cbm1vZHVsZSB0eXBlIFM1ID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdFxuXG4gIHZhbCB0eXBlbmFtZV9vZl90XG4gICAgOiAgJ2EgdHlwZW5hbWVcbiAgICAtPiAnYiB0eXBlbmFtZVxuICAgIC0+ICdjIHR5cGVuYW1lXG4gICAgLT4gJ2QgdHlwZW5hbWVcbiAgICAtPiAnZSB0eXBlbmFtZVxuICAgIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHQgdHlwZW5hbWVcbmVuZFxuXG5tb2R1bGUgTWFrZTAgKFggOiBOYW1lZF9pbnRmLlMwKSA9IHN0cnVjdFxuICBsZXQgdWlkID0gVWlkLm5leHQgWC5uYW1lXG4gIGxldCB0eXBlbmFtZV9vZl90ID0geyBLZXkudWlkOyBwYXJhbXMgPSBbXSB9XG5lbmRcblxubW9kdWxlIE1ha2UxIChYIDogTmFtZWRfaW50Zi5TMSkgPSBzdHJ1Y3RcbiAgbGV0IHVpZCA9IFVpZC5uZXh0IFgubmFtZVxuICBsZXQgdHlwZW5hbWVfb2ZfdCBhID0geyBLZXkudWlkOyBwYXJhbXMgPSBbIGEgXSB9XG5lbmRcblxubW9kdWxlIE1ha2UyIChYIDogTmFtZWRfaW50Zi5TMikgPSBzdHJ1Y3RcbiAgbGV0IHVpZCA9IFVpZC5uZXh0IFgubmFtZVxuICBsZXQgdHlwZW5hbWVfb2ZfdCBhIGIgPSB7IEtleS51aWQ7IHBhcmFtcyA9IFsgYTsgYiBdIH1cbmVuZFxuXG5tb2R1bGUgTWFrZTMgKFggOiBOYW1lZF9pbnRmLlMzKSA9IHN0cnVjdFxuICBsZXQgdWlkID0gVWlkLm5leHQgWC5uYW1lXG4gIGxldCB0eXBlbmFtZV9vZl90IGEgYiBjID0geyBLZXkudWlkOyBwYXJhbXMgPSBbIGE7IGI7IGMgXSB9XG5lbmRcblxubW9kdWxlIE1ha2U0IChYIDogTmFtZWRfaW50Zi5TNCkgPSBzdHJ1Y3RcbiAgbGV0IHVpZCA9IFVpZC5uZXh0IFgubmFtZVxuICBsZXQgdHlwZW5hbWVfb2ZfdCBhIGIgYyBkID0geyBLZXkudWlkOyBwYXJhbXMgPSBbIGE7IGI7IGM7IGQgXSB9XG5lbmRcblxubW9kdWxlIE1ha2U1IChYIDogTmFtZWRfaW50Zi5TNSkgPSBzdHJ1Y3RcbiAgbGV0IHVpZCA9IFVpZC5uZXh0IFgubmFtZVxuICBsZXQgdHlwZW5hbWVfb2ZfdCBhIGIgYyBkIGUgPSB7IEtleS51aWQ7IHBhcmFtcyA9IFsgYTsgYjsgYzsgZDsgZSBdIH1cbmVuZFxuXG5tb2R1bGUgS2V5X3RhYmxlID0gSGFzaHRibC5NYWtlIChLZXkpXG5cbm1vZHVsZSBUYWJsZSAoWCA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuICBlbmQpID1cbnN0cnVjdFxuICB0eXBlIGRhdGEgPSBEYXRhIDogJ2EgdCAqICdhIFgudCAtPiBkYXRhXG4gIHR5cGUgdCA9IGRhdGEgS2V5X3RhYmxlLnRcblxuICBsZXQgY3JlYXRlIGludCA9IEtleV90YWJsZS5jcmVhdGUgaW50XG4gIGxldCBtZW0gdGFibGUgbmFtZSA9IEtleV90YWJsZS5tZW0gdGFibGUgKGtleSBuYW1lKVxuICBsZXQgc2V0IHRhYmxlIG5hbWUgZGF0YSA9IEtleV90YWJsZS5yZXBsYWNlIHRhYmxlIChrZXkgbmFtZSkgKERhdGEgKG5hbWUsIGRhdGEpKVxuXG4gIGxldCBmaW5kICh0eXBlIGEpIHRhYmxlIChuYW1lIDogYSB0eXBlbmFtZSkgPVxuICAgIGxldCBkYXRhID1cbiAgICAgIHRyeSBTb21lIChLZXlfdGFibGUuZmluZCB0YWJsZSAoa2V5IG5hbWUpKSB3aXRoXG4gICAgICB8IEJhc2UuTm90X2ZvdW5kX3MgXyB8IENhbWwuTm90X2ZvdW5kIC0+IE5vbmVcbiAgICBpblxuICAgIG1hdGNoIGRhdGEgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIChEYXRhIChuYW1lJywgZGF0YSkpIC0+XG4gICAgICAoZnVuICh0eXBlIGIpIChuYW1lJyA6IGIgdHlwZW5hbWUpIChkYXRhIDogYiBYLnQpIC0+XG4gICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID0gKHNhbWVfd2l0bmVzc19leG4gbmFtZScgbmFtZSA6IChiLCBhKSBUeXBlX2VxdWFsLnQpIGluXG4gICAgICAgICBTb21lIChkYXRhIDogYSBYLnQpKVxuICAgICAgICBuYW1lJ1xuICAgICAgICBkYXRhXG4gIDs7XG5lbmRcblxubGV0IGZhaWwgdWlkX2EgdWlkX2IgPVxuICBsZXQgbXNnID1cbiAgICBQcmludGYuc3ByaW50ZiBcIlR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG4gJVMgJVNcIiAoVWlkLm5hbWUgdWlkX2EpIChVaWQubmFtZSB1aWRfYilcbiAgaW5cbiAgZmFpbHdpdGggbXNnXG47O1xuXG5tb2R1bGUgU2FtZV93aXRuZXNzX2V4bl8xIChBIDogUzEpIChCIDogUzEpID0gc3RydWN0XG4gIHR5cGUgdCA9IHsgZXEgOiAnYS4gKCdhIEEudCwgJ2EgQi50KSBUeXBlX2VxdWFsLnQgfVxuXG4gIGxldCB3aXRuZXNzID1cbiAgICBsZXQgdWlkX2EgPSB1aWQgKEEudHlwZW5hbWVfb2ZfdCBzdGF0aWMpIGluXG4gICAgbGV0IHVpZF9iID0gdWlkIChCLnR5cGVuYW1lX29mX3Qgc3RhdGljKSBpblxuICAgIGlmIFVpZC5lcXVhbCB1aWRfYSB1aWRfYiB0aGVuIHsgZXEgPSBPYmoubWFnaWMgVHlwZV9lcXVhbC5yZWZsIH0gZWxzZSBmYWlsIHVpZF9hIHVpZF9iXG4gIDs7XG5lbmRcblxubW9kdWxlIFNhbWVfd2l0bmVzc19leG5fMiAoQSA6IFMyKSAoQiA6IFMyKSA9IHN0cnVjdFxuICB0eXBlIHQgPSB7IGVxIDogJ2EgJ2IuICgoJ2EsICdiKSBBLnQsICgnYSwgJ2IpIEIudCkgVHlwZV9lcXVhbC50IH1cblxuICBsZXQgd2l0bmVzcyA9XG4gICAgbGV0IHVpZF9hID0gdWlkIChBLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYykgaW5cbiAgICBsZXQgdWlkX2IgPSB1aWQgKEIudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljKSBpblxuICAgIGlmIFVpZC5lcXVhbCB1aWRfYSB1aWRfYiB0aGVuIHsgZXEgPSBPYmoubWFnaWMgVHlwZV9lcXVhbC5yZWZsIH0gZWxzZSBmYWlsIHVpZF9hIHVpZF9iXG4gIDs7XG5lbmRcblxubW9kdWxlIFNhbWVfd2l0bmVzc19leG5fMyAoQSA6IFMzKSAoQiA6IFMzKSA9IHN0cnVjdFxuICB0eXBlIHQgPSB7IGVxIDogJ2EgJ2IgJ2MuICgoJ2EsICdiLCAnYykgQS50LCAoJ2EsICdiLCAnYykgQi50KSBUeXBlX2VxdWFsLnQgfVxuXG4gIGxldCB3aXRuZXNzID1cbiAgICBsZXQgdWlkX2EgPSB1aWQgKEEudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljIHN0YXRpYykgaW5cbiAgICBsZXQgdWlkX2IgPSB1aWQgKEIudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljIHN0YXRpYykgaW5cbiAgICBpZiBVaWQuZXF1YWwgdWlkX2EgdWlkX2IgdGhlbiB7IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCB9IGVsc2UgZmFpbCB1aWRfYSB1aWRfYlxuICA7O1xuZW5kXG5cbm1vZHVsZSBTYW1lX3dpdG5lc3NfZXhuXzQgKEEgOiBTNCkgKEIgOiBTNCkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0geyBlcSA6ICdhICdiICdjICdkLiAoKCdhLCAnYiwgJ2MsICdkKSBBLnQsICgnYSwgJ2IsICdjLCAnZCkgQi50KSBUeXBlX2VxdWFsLnQgfVxuXG4gIGxldCB3aXRuZXNzID1cbiAgICBsZXQgdWlkX2EgPSB1aWQgKEEudHlwZW5hbWVfb2ZfdCBzdGF0aWMgc3RhdGljIHN0YXRpYyBzdGF0aWMpIGluXG4gICAgbGV0IHVpZF9iID0gdWlkIChCLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYyBzdGF0aWMgc3RhdGljKSBpblxuICAgIGlmIFVpZC5lcXVhbCB1aWRfYSB1aWRfYiB0aGVuIHsgZXEgPSBPYmoubWFnaWMgVHlwZV9lcXVhbC5yZWZsIH0gZWxzZSBmYWlsIHVpZF9hIHVpZF9iXG4gIDs7XG5lbmRcblxubW9kdWxlIFNhbWVfd2l0bmVzc19leG5fNSAoQSA6IFM1KSAoQiA6IFM1KSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgZXEgOlxuICAgICAgICAnYSAnYiAnYyAnZCAnZS4gKCgnYSwgJ2IsICdjLCAnZCwgJ2UpIEEudCwgKCdhLCAnYiwgJ2MsICdkLCAnZSkgQi50KSBUeXBlX2VxdWFsLnRcbiAgICB9XG5cbiAgbGV0IHdpdG5lc3MgPVxuICAgIGxldCB1aWRfYSA9IHVpZCAoQS50eXBlbmFtZV9vZl90IHN0YXRpYyBzdGF0aWMgc3RhdGljIHN0YXRpYyBzdGF0aWMpIGluXG4gICAgbGV0IHVpZF9iID0gdWlkIChCLnR5cGVuYW1lX29mX3Qgc3RhdGljIHN0YXRpYyBzdGF0aWMgc3RhdGljIHN0YXRpYykgaW5cbiAgICBpZiBVaWQuZXF1YWwgdWlkX2EgdWlkX2IgdGhlbiB7IGVxID0gT2JqLm1hZ2ljIFR5cGVfZXF1YWwucmVmbCB9IGVsc2UgZmFpbCB1aWRfYSB1aWRfYlxuICA7O1xuZW5kXG4iLCIoKipcbiAgIFBsYWNlIGhvbGRlciBmb3IgY29tbW9uIFZhcmlhbnRzIGFuZCBGaWVsZHMgaW50ZXJmYWNlXG4qKVxuXG5tb2R1bGUgTSAoWCA6IHNpZ1xuICAgICgqKlxuICAgICAgIFRoaXMgZnVuY3RvciBpcyBlc3NlbnRpYWxseSB0aGVyZSBiZWNhdXNlIHdlIHVzZSB0aGlzIHNhbWUgaW50ZXJmYWNlIGluIGRpZmZlcmVudFxuICAgICAgIGNvbnRleHRzLCB3aXRoIGRpZmZlcmVudCB0eXBlcyBmb3IgWydhIHRdLlxuXG4gICAgICAgMSkgT25lIHVzZSBjYXNlIGZvciBpdCBpcyB3aGVyZSBbJ2EgWC50ID0gJ2EgVHlwZXJlcC50XS4gIFRoZXNlIGludGVyZmFjZXMgYXJlIHRoZW5cbiAgICAgICBwYXJ0IG9mIHRoZSB0eXBlIHdpdG5lc3MgYnVpbHQgZm9yIGEgdHlwZSBjb250YWluaW5nIGEgcmVjb3JkIG9yIGEgdmFyaWFudCBpbiBpdHNcbiAgICAgICBzdHJ1Y3R1cmUuIFt0cmF2ZXJzZV0gd2lsbCBnaXZlIGEgd2F5IG9mIGFjY2Vzc2luZyB0aGUgdHlwZSByZXByZXNlbnRhdGlvbiBmb3IgdGhlXG4gICAgICAgYXJndW1lbnRzIG9mIGEgdmFyaWFudCBvciByZWNvcmQgdHlwZS5cblxuICAgICAgIDIpIEFub3RoZXIgdXNlIGNhc2UgaXMgZm9yIGJ1aWxkaW5nIFwic3RhZ2VkIGdlbmVyaWMgY29tcHV0YXRpb25zXCIuIEluIHRoYXQgY2FzZSwgdGhlXG4gICAgICAgdHlwZSBbJ2EgWC50XSBpcyB0aGUgdHlwZSBvZiB0aGUgY29tcHV0YXRpb24gdGhhdCBpcyBiZWluZyBidWlsdC4gIFt0cmF2ZXJzZV1cbiAgICAgICByZXR1cm5zIHRoZSBjb21wdXRhdGlvbiBidWlsdCBmb3IgdGhlIGFyZ3VtZW50LiBUaGUgaW50ZXJmYWNlIG5vIGxvbmdlciBleHBvcnRzXG4gICAgICAgdGhlIHR5cGVyZXAgb2YgdGhlIGFyZ3VtZW50cyBpbiBob3BlcyBvZiBlbmZvcmNpbmcgdGhhdCBubyB0eXBlcmVwIHRyYXZlcnNhbFxuICAgICAgIGhhcHBlbnMgYXQgcnVudGltZSBpZiB0aGUgY29tcHV0YXRpb24gaGFwcGVuIHRvIGJlIGEgZnVuY3Rpb24uXG4gICAgKilcbiAgICB0eXBlICdhIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgKCogVGhlIGZ1bmN0aW9ucyBwcmVmaXhlZCBieSBbaW50ZXJuYWxdIGFzIHdlbGwgYXMgdGhlIG1vZHVsZSBzdWZmaXhlZCBieSBbX2ludGVybmFsXVxuICAgICBhcmUgdXNlZCBieSB0aGUgY29kZSBnZW5lcmF0ZWQgYnkgdGhlIGNhbWxwNCBleHRlbnNpb24gW3dpdGggdHlwZXJlcF0gYXMgd2VsbCBhcyBzb21lXG4gICAgIGludGVybmFscyBvZiB0aGUgdHlwZXJlcCBsaWJyYXJ5LiBEbyBub3QgY29uc2lkZXIgdXNpbmcgdGhlc2Ugc29tZXdoZXJlIGVsc2UuICBUaGV5XG4gICAgIHNob3VsZCBpZGVhbGx5IG5vdCBiZSBleHBvcnRlZCBvdXRzaWRlIHRoZSB0eXBlcmVwIGxpYnJhcnksIGJ1dCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgbmVlZHMgc29tZWhvdyB0byBhY2Nlc3MgdGhpcywgZXZlbiBvdXRzaWRlLiAqKVxuXG4gIG1vZHVsZSBUYWdfaW50ZXJuYWwgPSBzdHJ1Y3RcbiAgICB0eXBlICgndmFyaWFudCwgJ2FyZ3MpIGNyZWF0ZSA9XG4gICAgICB8IEFyZ3Mgb2YgKCdhcmdzIC0+ICd2YXJpYW50KVxuICAgICAgfCBDb25zdCBvZiAndmFyaWFudFxuXG4gICAgdHlwZSAoJ3ZhcmlhbnQsICdhcmdzKSB0ID1cbiAgICAgIHsgbGFiZWwgOiBzdHJpbmdcbiAgICAgIDsgcmVwIDogJ2FyZ3MgWC50XG4gICAgICA7IGFyaXR5IDogaW50XG4gICAgICA7IGFyZ3NfbGFiZWxzIDogc3RyaW5nIGxpc3RcbiAgICAgIDsgaW5kZXggOiBpbnRcbiAgICAgIDsgb2NhbWxfcmVwciA6IGludFxuICAgICAgOyB0eWlkIDogJ2FyZ3MgVHlwZW5hbWUudFxuICAgICAgOyBjcmVhdGUgOiAoJ3ZhcmlhbnQsICdhcmdzKSBjcmVhdGVcbiAgICAgIH1cbiAgZW5kXG5cbiAgKCoqXG4gICAgIFdpdG5lc3Mgb2YgYSB0YWcsIHRoYXQgaXMgYW4gaXRlbSBpbiBhIHZhcmlhbnQgdHlwZSwgYWxzbyBjYWxsZWQgYW4gXCJhcHBsaWVkXG4gICAgIHZhcmlhbnQgQ29uc3RydWN0b3JcIlxuXG4gICAgIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgdGhlIHZhcmlhbnQgdHlwZSwgdGhlIHNlY29uZCBpcyB0aGUgdHlwZSBvZiB0aGUgdGFnXG4gICAgIHBhcmFtZXRlcnMuICBFeGFtcGxlOlxuXG4gICAgIHtbXG4gICAgICAgdHlwZSB0ID1cbiAgICAgICAgIHwgQSBvZiAoaW50ICogc3RyaW5nKVxuICAgICAgICAgfCBCIG9mIHN0cmluZ1xuICAgICAgICAgfCBDIG9mIHsgeCA6IGludDsgeSA6IHN0cmluZyB9XG4gICAgIF19XG5cbiAgICAgdGhpcyB0eXBlIGhhcyB0aHJlZSBjb25zdHJ1Y3RvcnMuIEZvciBlYWNoIG9mIHRoZW0gd2UnbGwgaGF2ZSBhIGNvcnJlc3BvbmRpbmdcbiAgICAgW1RhZy50XTpcblxuICAgICB7W1xuICAgICAgIHZhbCB0YWdfQSA6ICh0LCAoaW50ICogc3RyaW5nKSkgVGFnLnRcbiAgICAgICB2YWwgdGFnX0IgOiAodCwgc3RyaW5nICAgICAgICApIFRhZy50XG4gICAgICAgdmFsIHRhZ19DIDogKHQsIChpbnQgKiBzdHJpbmcpKSBUYWcudFxuICAgICBdfVxuXG4gICAgIE5vdGUsIGlubGluZSByZWNvcmQgaW4gdmFyaWFudCBhcmUgdHlwZWQgYXMgaWYgdGhlaXIgZGVmaW5pdGlvbiB3YXMgdXNpbmcgdHVwbGVzLFxuICAgICB3aXRob3V0IHRoZSBwYXJlbnRoZXNpcy4gIFRoaXMgaXMgY29uc2lzdGVudCB3aXRoIHRoZWlyIHJ1bnRpbWUgcmVwcmVzZW50YXRpb24uICBCdXRcbiAgICAgdGhlIGRpc3RpbmN0aW9uIGlzIGNhcnJpZWQgYW5kIGF2YWlsYWJsZSBmb3IgaW50cm9zcGVjdGlvbiBhcyBwYXJ0IG9mIHRoZSBbVGFnLnRdLlxuICAgICBTZWUgW2FyZ3NfbGFiZWxzXS4gKilcbiAgbW9kdWxlIFRhZyA6IHNpZ1xuICAgIHR5cGUgKCd2YXJpYW50LCAnYXJncykgY3JlYXRlID1cbiAgICAgIHwgQXJncyBvZiAoJ2FyZ3MgLT4gJ3ZhcmlhbnQpXG4gICAgICB8IENvbnN0IG9mICd2YXJpYW50XG5cbiAgICB0eXBlICgndmFyaWFudCwgJ2FyZ3MpIHRcblxuICAgICgqKlxuICAgICAgIFRoZSBuYW1lIG9mIHRoZSBjb25zdHJ1Y3RvciBhcyBpdCBpcyBnaXZlbiBpbiB0aGUgY29uY3JldGUgc3ludGF4XG4gICAgICAgRXhhbXBsZXM6XG5cbiAgICAgICB7dlxuICAgICAgICAgQ29uc3RydWN0b3IgICAgICAgIHwgbGFiZWxcbiAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgIHwgQSBvZiBpbnQgICAgICAgICB8ICBcIkFcIlxuICAgICAgICAgfCBgYSBvZiBpbnQgICAgICAgIHwgIFwiYVwiXG4gICAgICAgICB8IGBBIG9mIGludCAgICAgICAgfCAgXCJBXCJcbiAgICAgICAgIHwgQSBvZiB7IHggOiBpbnQgfSB8ICBcIkFcIlxuICAgICAgIHZ9XG5cbiAgICAgICBmb3Igc3RhbmRhcmQgdmFyaWFudCwgdGhlIG9jYW1sIHN5bnRheCBpbXBsaWVzIHRoYXQgdGhpcyBsYWJlbCB3aWxsIGFsd2F5cyBzdGFydHNcbiAgICAgICB3aXRoIGEgY2FwaXRhbCBsZXR0ZXIuIEZvciBwb2x5bW9ycGhpYyB2YXJpYW50cywgdGhpcyBtaWdodCBiZSBhIGxvd2VyY2FzZSBjaGFyLlxuICAgICAgIEZvciBwb2x5bW9ycGhpYyB2YXJpYW50LCB0aGlzIGxhYmVsIGRvZXMgbm90IGluY2x1ZGUgdGhlIFtgXSBjaGFyYWN0ZXIuXG4gICAgKilcbiAgICB2YWwgbGFiZWwgOiAoXywgXykgdCAtPiBzdHJpbmdcblxuICAgICgqKlxuICAgICAgIFRoZSBzaXplIG9mIHRoZSBvY2FtbCBoZWFwIGJsb2NrIGNvbnRhaW5pbmcgdGhlIGFyZ3VtZW50c1xuXG4gICAgICAgRXhhbXBsZXM6XG4gICAgICAge3ZcbiAgICAgICAgICAwOiB8IEEgfCAnQVxuICAgICAgICAgIDE6IHwgQSBvZiBpbnQgfCBgQSBvZiBpbnQgfCBBIG9mIChpbnQgKiBpbnQpIHwgYEEgb2YgKGludCAqIGludClcbiAgICAgICAgICAgICB8IGBBIG9mIGludCAqIGludFxuICAgICAgICAgICAgIHwgQSBvZiB7IHggOiBpbnR9XG4gICAgICAgICAgMjogfCBBIG9mIGludCAqIGZsb2F0XG4gICAgICAgICAgICAgfCBBIG9mIHsgeCA6IGludDsgeSA6IHN0cmluZyB9XG4gICAgICAgICAgZXRjLlxuICAgICAgIHZ9XG4gICAgKilcbiAgICB2YWwgYXJpdHkgOiAoXywgXykgdCAtPiBpbnRcblxuICAgICgqKiBUaGUgbGFiZWwgb2YgdGhlIGZpZWxkcyBmb3IgaW5saW5lIHJlY29yZHMuICBGb3Igb3RoZXIgZm9ybXMgb2YgdGFncywgdGhpcyBpcyB0aGVcbiAgICAgICAgZW1wdHkgbGlzdC4gIFdoZW4gdGhpcyByZXR1cm5zIGEgbm9uIGVtcHR5IGxpc3QsIHRoZSBsZW5ndGggb2YgdGhlIHJldHVybmVkIGxpc3RcbiAgICAgICAgaXMgZXF1YWwgdG8gdGhlIGFyaXR5LlxuXG4gICAgICAgIEV4YW1wbGU6XG5cbiAgICAgICAge3ZcbiAgICAgICAgICgxKSBFbXB0eTpcblxuICAgICAgICAgICB8IEEgfCAnQVxuICAgICAgICAgICB8IEEgb2YgaW50IHwgYEEgb2YgaW50IHwgQSBvZiAoaW50ICogaW50KSB8IGBBIG9mIChpbnQgKiBpbnQpXG4gICAgICAgICAgIHwgYEEgb2YgaW50ICogaW50XG4gICAgICAgICAgIHwgQSBvZiBpbnQgKiBmbG9hdFxuXG4gICAgICAgICAoMikgTm9uIGVtcHR5OlxuXG4gICAgICAgICAgIHwgQSBvZiB7IHggOiBpbnQgfSAgICAgICAgICAgICAgIC0+IFsgXCJ4XCIgXVxuICAgICAgICAgICB8IEEgb2YgeyB4IDogaW50OyB5IDogc3RyaW5nIH0gICAtPiBbIFwieFwiIDsgXCJ5XCIgXVxuICAgICAgIHZ9XG4gICAgKilcbiAgICB2YWwgYXJnc19sYWJlbHMgOiAoXywgXykgdCAtPiBzdHJpbmcgbGlzdFxuXG4gICAgKCoqXG4gICAgICAgVGhlIGluZGV4IG9mIHRoZSBjb25zdHJ1Y3RvciBpbiB0aGUgbGlzdCBvZiBhbGwgdGhlIHZhcmlhbnQgdHlwZSdzIGNvbnN0cnVjdG9yc1xuICAgICAgIEV4YW1wbGVzOlxuICAgICAgIHtbXG4gICAgICAgICB0eXBlIHQgPVxuICAgICAgICAgICB8IEEgb2YgaW50ICAgICAgICAgICgqIDAgKilcbiAgICAgICAgICAgfCBCICAgICAgICAgICAgICAgICAoKiAxICopXG4gICAgICAgICAgIHwgQyBvZiBpbnQgICAgICAgICAgKCogMiAqKVxuICAgICAgICAgICB8IEQgb2YgY2hhciAgICAgICAgICgqIDMgKilcbiAgICAgICAgICAgfCBFIG9mIHsgeCA6IGludCB9ICAoKiA0ICopXG4gICAgICAgXX1cbiAgICAqKVxuICAgIHZhbCBpbmRleCA6IChfLCBfKSB0IC0+IGludFxuXG4gICAgKCoqXG4gICAgICAgb2NhbWxfcmVwciBpcyByZWxhdGVkIHRvIHRoZSBydW50aW1lIG9mIG9iamVjdHMuIHRoaXMgaXMgZXNzZW50aWFsbHkgYSB3YXkgb2ZcbiAgICAgICBnaXZpbmcgb25lIHRoZSBhYmlsaXR5IHRvIHJlYnVpbGQgZHluYW1pY2FsbHkgYW4gW09iai50XSByZXByZXNlbnRpbmcgYSB0YWcuXG5cbiAgICAgICBQb2x5bW9ycGhpYyB2YXJpYW50czpcbiAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgIFtvY2FtbF9yZXByXSBpcyB0aGUgaGFzaCBvZiB0aGUgbGFiZWwsIGFzIGRvbmUgYnkgdGhlIGNvbXBpbGVyLlxuICAgICAgIEV4YW1wbGU6XG4gICAgICAgcHJpbnRfaW50IChPYmoubWFnaWMgYGJhcikgICgqIDQ4OTUxODcgKilcbiAgICAgICBwcmludF9pbnQgKE9iai5tYWdpYyAnZm9vKSAgKCogNTA5NzIyMiAqKVxuXG4gICAgICAgU3RhbmRhcmRzIHZhcmlhbnRzOlxuICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgIFtvY2FtbF9yZXByXSBpcyB0aGUgdGFnIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNvbnN0cnVjdG9yIHdpdGhpbiB0aGUgdHlwZS5cbiAgICAgICB0aGUgd2F5IGl0IHdvcmtzIGluIHRoZSBvY2FtbCBydW50aW1lIGlzIGJ5IHBhcnRpdGlvbmluZyB0aGUgY29uc3RydWN0b3JzIHJlZ2FyZGluZ1xuICAgICAgIGlmIHRoZXkgaGF2ZSBzb21lIGFyZ3VtZW50cyBvciBub3QsIHByZXNlcnZpbmcgdGhlIG9yZGVyLCB0aGVuIGFzc2lnbiBpbmNyZWFzaW5nXG4gICAgICAgaW5kZXggd2l0aGluZyBlYWNoIHBhcnRpdGlvbi5cbiAgICAgICBFeGFtcGxlOlxuXG4gICAgICAge1tcbiAgICAgICAgIHR5cGUgdCA9ICAgICAgICAgICAgICAgICAgKCogbm8gYXJnICopICAoKiBhcmdzICopXG4gICAgICAgICAgIHwgQSAgICAgICAgICAgICAgICAgICAgICAgKCogMCAqKVxuICAgICAgICAgICB8IEIgb2YgaW50ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogMCAqKVxuICAgICAgICAgICB8IEMgICAgICAgICAgICAgICAgICAgICAgICgqIDEgKilcbiAgICAgICAgICAgfCBEIG9mIChmbG9hdCAqIHN0cmluZykgICAgICAgICAgICAgICAgICgqIDEgKilcbiAgICAgICAgICAgfCBFICAgICAgICAgICAgICAgICAgICAgICAoKiAyICopXG4gICAgICAgICAgIHwgRiAgICAgICAgICAgICAgICAgICAgICAgKCogMyAqKVxuICAgICAgICAgICB8IEcgb2Ygc3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogMiAqKVxuICAgICAgICAgICB8IEggb2YgeyB4IDogaW50IH0gICAgICAgICAgICAgICAgICAgICAgKCogMyAqKVxuICAgICAgIF19XG4gICAgKilcbiAgICB2YWwgb2NhbWxfcmVwciA6IChfLCBfKSB0IC0+IGludFxuXG4gICAgKCoqXG4gICAgICAgR2l2ZSBiYWNrIGEgd2F5IG9mIGNvbnN0cnVjdGluZyBhIHZhbHVlIG9mIHRoYXQgY29uc3RydWN0b3IgZnJvbSBpdHMgYXJndW1lbnRzLlxuXG4gICAgICAgRXhhbXBsZXM6XG5cbiAgICAgICB7W1xuICAgICAgICAgdHlwZSB0ID1cbiAgICAgICAgICAgfCBBIG9mIChpbnQgKiBzdHJpbmcpXG4gICAgICAgICAgIHwgQiBvZiBpbnQgKiBmbG9hdFxuICAgICAgICAgICB8IENcbiAgICAgICAgICAgfCBEIG9mIHsgeCA6IGludDsgeSA6IHN0cmluZyB9XG4gICAgICAgXX1cblxuICAgICAgIFtjcmVhdGVdIHdpbGwgcmV0dXJuIHNvbWV0aGluZyBlcXVpdmFsZW50IHRvOlxuICAgICAgIHRhZ19BIDogW0FyZ3MgKGZ1biAoZCA6IChpbnQgKiBzdHJpbmcpIC0+IEEgZCldXG4gICAgICAgdGFnX0IgOiBbQXJncyAoZnVuIChpLCBmKSAtPiBCIChpLCBmKSldXG4gICAgICAgdGFnX0MgOiBbQ29uc3QgQ11cbiAgICAgICB0YWdfRCA6IFtBcmdzIChmdW4gKHgsIHkpIC0+IEQgeyB4OyB5IH0pXVxuICAgICopXG4gICAgdmFsIGNyZWF0ZSA6ICgndmFyaWFudCwgJ2FyZ3MpIHQgLT4gKCd2YXJpYW50LCAnYXJncykgY3JlYXRlXG5cbiAgICAoKiogcmV0dXJuIHRoZSB0eXBlX25hbWUgb2YgdGhlIGFyZ3VtZW50cy4gbWlnaHQgYmUgdXNlZCB0byBwZXJmb3JtIHNvbWUgbG9va3VwIGJhc2VkXG4gICAgICAgIG9uIGl0IHdoaWxlIGJ1aWxkaW5nIGEgY29tcHV0YXRpb24gZm9yIGV4YW1wbGUgKilcbiAgICB2YWwgdHlpZCA6IChfLCAnYXJncykgdCAtPiAnYXJncyBUeXBlbmFtZS50XG5cbiAgICAoKiogZ2V0IHRoZSByZXByZXNlbnRhdGlvbi9jb21wdXRhdGlvbiBvZiB0aGUgYXJndW1lbnRzICopXG4gICAgdmFsIHRyYXZlcnNlIDogKF8sICdhcmdzKSB0IC0+ICdhcmdzIFgudFxuXG4gICAgKCogdXNlZCBieSB0aGUgY2FtbHA0IGV4dGVuc2lvbiB0byBidWlsZCB0eXBlIHdpdG5lc3Nlcywgb3IgYnkgc29tZSBpbnRlcm5hbCBwYXJ0cyBvZlxuICAgICAgIHR5cGVyZXAuIHlvdSBzaG91bGQgZmVlbCBiYWQgaWYgeW91IG5lZWQgdG8gdXNlIGl0IGluIHNvbWUgdXNlciBjb2RlICopXG4gICAgdmFsIGludGVybmFsX3VzZV9vbmx5IDogKCdhLCAnYikgVGFnX2ludGVybmFsLnQgLT4gKCdhLCAnYikgdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRhZ19pbnRlcm5hbFxuXG4gICAgbGV0IGxhYmVsIHQgPSB0LmxhYmVsXG4gICAgbGV0IGFyaXR5IHQgPSB0LmFyaXR5XG4gICAgbGV0IGFyZ3NfbGFiZWxzIHQgPSB0LmFyZ3NfbGFiZWxzXG4gICAgbGV0IGluZGV4IHQgPSB0LmluZGV4XG4gICAgbGV0IG9jYW1sX3JlcHIgdCA9IHQub2NhbWxfcmVwclxuICAgIGxldCBjcmVhdGUgdCA9IHQuY3JlYXRlXG4gICAgbGV0IHR5aWQgdCA9IHQudHlpZFxuICAgIGxldCB0cmF2ZXJzZSB0ID0gdC5yZXBcbiAgICBsZXQgaW50ZXJuYWxfdXNlX29ubHkgdCA9IHRcbiAgZW5kXG5cbiAgbW9kdWxlIFZhcmlhbnRfaW50ZXJuYWwgPSBzdHJ1Y3RcbiAgICB0eXBlIF8gdGFnID0gVGFnIDogKCd2YXJpYW50LCAnYSkgVGFnLnQgLT4gJ3ZhcmlhbnQgdGFnXG4gICAgdHlwZSBfIHZhbHVlID0gVmFsdWUgOiAoJ3ZhcmlhbnQsICdhKSBUYWcudCAqICdhIC0+ICd2YXJpYW50IHZhbHVlXG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyB0eXBlbmFtZSA6ICdhIFR5cGVuYW1lLnRcbiAgICAgIDsgdGFncyA6ICdhIHRhZyBhcnJheVxuICAgICAgOyBwb2x5bW9ycGhpYyA6IGJvb2xcbiAgICAgIDsgdmFsdWUgOiAnYSAtPiAnYSB2YWx1ZVxuICAgICAgfVxuICBlbmRcblxuICBtb2R1bGUgVmFyaWFudCA6IHNpZ1xuICAgICgqKlxuICAgICAgIEFuIGV4aXN0ZW50aWFsIHR5cGUgdXNlZCB0byBnYXRoZXIgYWxsIHRoZSB0YWdzIGNvbnN0aXR1aW5nIGEgdmFyaWFudFxuICAgICAgIHR5cGUuIHRoZSBbJ3ZhcmlhbnRdIHBhcmFtZXRlciBpcyB0aGUgdmFyaWFudCB0eXBlLCBpdCBpcyB0aGUgc2FtZSBmb3IgYWxsIHRoZVxuICAgICAgIGNvbnN0cnVjdG9ycyBvZiB0aGF0IHZhcmlhbnQgdHlwZS4gVGhlIHR5cGUgb2YgdGhlIHBhcmFtZXRlcnMgbWlnaHQgYmUgZGlmZmVyZW50XG4gICAgICAgZm9yIGVhY2ggY29uc3RydWN0b3IgYW5kIGlzIHRodXMgZXhpc3RlbnRpYWxcbiAgICAqKVxuICAgIHR5cGUgXyB0YWcgPSBUYWcgOiAoJ3ZhcmlhbnQsICdhcmdzKSBUYWcudCAtPiAndmFyaWFudCB0YWdcblxuICAgICgqKlxuICAgICAgIEEgc2ltaWxhciBleGlzdGVudGlhbCBjb25zdHJ1Y3RvciB0byBbXyB0YWddIGJ1dCB0aGlzIG9uZSBob2xkcyBhIHZhbHVlIHdob3NlIHR5cGVcbiAgICAgICBpcyB0aGUgYXJndW1lbnRzIG9mIHRoZSB0YWcgY29uc3RydWN0b3IuICBBIHZhbHVlIG9mIHR5cGUgWydhIHZhbHVlXSBpcyBhIHBhaXIgb2ZcbiAgICAgICAoMSkgYSB2YWx1ZSBvZiB2YXJpYW50IHR5cGUgWydhXSBhbG9uZyB3aXRoICgyKSBzb21lIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICAgICAgIGNvbnN0cnVjdG9yIHdpdGhpbiB0aGUgdHlwZSBbJ2FdXG4gICAgKilcbiAgICB0eXBlIF8gdmFsdWUgPSBWYWx1ZSA6ICgndmFyaWFudCwgJ2FyZ3MpIFRhZy50ICogJ2FyZ3MgLT4gJ3ZhcmlhbnQgdmFsdWVcblxuICAgICgqKlxuICAgICAgIFdpdG5lc3Mgb2YgYSB2YXJpYW50IHR5cGUuIFRoZSBwYXJhbWV0ZXIgaXMgdGhlIHR5cGUgb2YgdGhlIHZhcmlhbnQgdHlwZSB3aXRuZXNzZWQuXG4gICAgKilcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCB0eXBlbmFtZV9vZl90IDogJ2EgdCAtPiAnYSBUeXBlbmFtZS50XG5cbiAgICAoKipcbiAgICAgICBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGFncyBvZiB0aGlzIHZhcmlhbnQgdHlwZSBkZWZpbml0aW9uLlxuICAgICopXG4gICAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG5cbiAgICAoKipcbiAgICAgICBHZXQgdGhlIG50aCB0YWcgb2YgdGhpcyB2YXJpYW50IHR5cGUsIGluZGV4ZWQgZnJvbSAwLlxuICAgICopXG4gICAgdmFsIHRhZyA6ICdhIHQgLT4gaW50IC0+ICdhIHRhZ1xuXG4gICAgKCoqXG4gICAgICAgRGlzdGluZ3Vpc2ggcG9seW1vcnBoaWMgdmFyaWFudHMgYW5kIHN0YW5kYXJkIHZhcmlhbnRzLiBUeXBpY2FsbHksIHBvbHltb3JwaGljXG4gICAgICAgdmFyaWFudHMgdGFncyBzdGFydHMgd2l0aCB0aGUgW2BdIGNoYXJhY3Rlci5cbiAgICAgICBFeGFtcGxlXG4gICAgICAgcG9seW1vcnBoaWMgdmFyaWFudDogdHlwZSB0ID0gWyBgQSB8IGBCIF1cbiAgICAgICBzdGFuZGFyZCB2YXJpYW50OiAgICB0eXBlIHQgPSBBIHwgQlxuICAgICopXG4gICAgdmFsIGlzX3BvbHltb3JwaGljIDogXyB0IC0+IGJvb2xcblxuICAgICgqKlxuICAgICAgIFBhdHRlcm4gbWF0Y2hpbmcgb24gYSB2YWx1ZSBvZiB0aGlzIHZhcmlhbnQgdHlwZS5cbiAgICAqKVxuICAgIHZhbCB2YWx1ZSA6ICdhIHQgLT4gJ2EgLT4gJ2EgdmFsdWVcblxuICAgICgqKlxuICAgICAgIGZvbGRpbmcgYWxvbmcgdGhlIHRhZ3Mgb2YgdGhlIHZhcmlhbnQgdHlwZVxuICAgICopXG4gICAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2FjYyAtPiBmOignYWNjIC0+ICdhIHRhZyAtPiAnYWNjKSAtPiAnYWNjXG5cbiAgICAoKiB1c2VkIGJ5IHRoZSBjYW1scDQgZXh0ZW5zaW9uIHRvIGJ1aWxkIHR5cGUgd2l0bmVzc2VzLCBvciBieSBzb21lIGludGVybmFsIHBhcnRzIG9mXG4gICAgICAgdHlwZXJlcC4geW91IHNob3VsZCBmZWVsIGJhZCBpZiB5b3UgbmVlZCB0byB1c2UgaXQgaW4gc29tZSB1c2VyIGNvZGUgKilcbiAgICB2YWwgaW50ZXJuYWxfdXNlX29ubHkgOiAnYSBWYXJpYW50X2ludGVybmFsLnQgLT4gJ2EgdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFZhcmlhbnRfaW50ZXJuYWxcblxuICAgIGxldCB0eXBlbmFtZV9vZl90IHQgPSB0LnR5cGVuYW1lXG4gICAgbGV0IGxlbmd0aCB0ID0gQXJyYXkubGVuZ3RoIHQudGFnc1xuICAgIGxldCB0YWcgdCBpbmRleCA9IHQudGFncy4oaW5kZXgpXG4gICAgbGV0IGlzX3BvbHltb3JwaGljIHQgPSB0LnBvbHltb3JwaGljXG4gICAgbGV0IHZhbHVlIHQgPSB0LnZhbHVlXG4gICAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IEFycmF5LmZvbGRfbGVmdCBmIGluaXQgdC50YWdzXG4gICAgbGV0IGludGVybmFsX3VzZV9vbmx5IHQgPSB0XG4gIGVuZFxuXG4gIG1vZHVsZSBGaWVsZF9pbnRlcm5hbCA9IHN0cnVjdFxuICAgIHR5cGUgKCdyZWNvcmQsICdmaWVsZCkgdCA9XG4gICAgICB7IGxhYmVsIDogc3RyaW5nXG4gICAgICA7IHJlcCA6ICdmaWVsZCBYLnRcbiAgICAgIDsgaW5kZXggOiBpbnRcbiAgICAgIDsgdHlpZCA6ICdmaWVsZCBUeXBlbmFtZS50XG4gICAgICA7IGdldCA6ICdyZWNvcmQgLT4gJ2ZpZWxkXG4gICAgICA7ICgqIHNldCA6ICgncmVjb3JkIC0+ICdmaWVsZCAtPiB1bml0KSBvcHRpb247IChcXCogbXV0YWJsZSBmaWVsZCAqXFwpICopXG4gICAgICAgIGlzX211dGFibGUgOiBib29sXG4gICAgICB9XG4gIGVuZFxuXG4gICgqKlxuICAgICBXaXRuZXNzIG9mIGEgZmllbGQsIHRoYXQgaXMgYW4gaXRlbSBpbiBhIHJlY29yZCB0eXBlLlxuICAgICBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSByZWNvcmQgdHlwZSwgdGhlIHNlY29uZCBpcyB0aGUgdHlwZSBvZiB0aGUgZmllbGQuXG4gICAgIEV4YW1wbGU6XG4gICAgIHtbXG4gICAgICAgdHlwZSB0ID0geyB4IDogaW50IDsgeSA6IHN0cmluZyB9XG4gICAgIF19XG4gICAgIFRoaXMgdHlwZSBoYXMgdHdvIGZpZWxkcy4gZm9yIGVhY2ggb2YgdGhlbSB3ZSdsbCBoYXZlIGEgY29ycmVzcG9uZGluZyBbRmllbGQudF1cblxuICAgICB2YWwgZmllbGRfeCA6ICh0LCBpbnQpIEZpZWxkLnRcbiAgICAgdmFsIGZpZWxkX3kgOiAodCwgc3RyaW5nKSBGaWVsZC50XG4gICopXG4gIG1vZHVsZSBGaWVsZCA6IHNpZ1xuICAgIHR5cGUgKCdyZWNvcmQsICdmaWVsZCkgdFxuXG5cbiAgICAoKipcbiAgICAgICBUaGUgbmFtZSBvZiB0aGUgZmllbGQgYXMgaXQgaXMgZ2l2ZW4gaW4gdGhlIGNvbmNyZXRlIHN5bnRheFxuICAgICAgIEV4YW1wbGVzOlxuICAgICAgIHtbXG4gICAgICAgICB7IHggICA6IGludDsgICAgICgqIFwieFwiICopXG4gICAgICAgICAgIGZvbyA6IHN0cmluZzsgICgqIFwiZm9vXCIgKilcbiAgICAgICAgICAgYmFyIDogZmxvYXQ7ICAgKCogXCJiYXJcIiAqKVxuICAgICAgICAgfVxuICAgICAgIF19XG4gICAgKilcbiAgICB2YWwgbGFiZWwgOiAoXywgXykgdCAtPiBzdHJpbmdcblxuICAgICgqKlxuICAgICAgIFRoZSAwLWJhc2VkIGluZGV4IG9mIHRoZSBmaWVsZCBpbiB0aGUgbGlzdCBvZiBhbGwgZmllbGRzIGZvciB0aGlzIHJlY29yZCB0eXBlLlxuICAgICAgIEV4YW1wbGU6XG4gICAgICAge1tcbiAgICAgICAgIHR5cGUgdCA9IHtcbiAgICAgICAgICAgeCAgIDogaW50OyAgICAgKCogMCAqKVxuICAgICAgICAgICBmb28gOiBzdHJpbmc7ICAoKiAxICopXG4gICAgICAgICAgIGJhciA6IHN0cmluZzsgICgqIDIgKilcbiAgICAgICAgIH1cbiAgICAgICBdfVxuICAgICopXG4gICAgdmFsIGluZGV4IDogKF8sIF8pIHQgLT4gaW50XG5cbiAgICAoKipcbiAgICAgICBGaWVsZCBhY2Nlc3NvcnMuIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGRvdCBvcGVyYXRpb24uXG4gICAgICAgW0ZpZWxkLmdldCBiYXJfZmllbGQgdF0gcmV0dXJucyB0aGUgZmllbGQgW2Jhcl0gb2YgdGhlIHJlY29yZCB2YWx1ZSBbdF0sIGp1c3QgdGhlXG4gICAgICAgc2FtZSBhcyBbdC5iYXJdXG4gICAgKilcbiAgICB2YWwgZ2V0IDogKCdyZWNvcmQsICdmaWVsZCkgdCAtPiAncmVjb3JkIC0+ICdmaWVsZFxuXG4gICAgKCoqIHJldHVybiB3aGV0aGVyIHRoZSBmaWVsZCBpcyBtdXRhYmxlLCBpLmUuIHdoZXRoZXIgaXRzIGRlY2xhcmF0aW9uIGlzIHByZWZpeGVkIHdpdGhcbiAgICAgICAgdGhlIGtleXdvcmQgW211dGFibGVdICopXG4gICAgdmFsIGlzX211dGFibGUgOiAoXywgXykgdCAtPiBib29sXG5cbiAgICAoKiogcmV0dXJuIHRoZSB0eXBlX25hbWUgb2YgdGhlIGFyZ3VtZW50cy4gIE1pZ2h0IGJlIHVzZWQgdG8gcGVyZm9ybSBzb21lIGxvb2t1cCBiYXNlZFxuICAgICAgICBvbiBpdCAqKVxuICAgIHZhbCB0eWlkIDogKF8sICdmaWVsZCkgdCAtPiAnZmllbGQgVHlwZW5hbWUudFxuXG4gICAgKCoqIGdldCB0aGUgY29tcHV0YXRpb24gb2YgdGhlIGFyZ3VtZW50cyAqKVxuICAgIHZhbCB0cmF2ZXJzZSA6IChfLCAnZmllbGQpIHQgLT4gJ2ZpZWxkIFgudFxuXG4gICAgKCogdXNlZCBieSB0aGUgY2FtbHA0IGV4dGVuc2lvbiB0byBidWlsZCB0eXBlIHdpdG5lc3Nlcywgb3IgYnkgc29tZSBpbnRlcm5hbCBwYXJ0cyBvZlxuICAgICAgIHR5cGVyZXAuIHlvdSBzaG91bGQgZmVlbCBiYWQgaWYgeW91IG5lZWQgdG8gdXNlIGl0IGluIHNvbWUgdXNlciBjb2RlICopXG4gICAgdmFsIGludGVybmFsX3VzZV9vbmx5IDogKCdhLCAnYikgRmllbGRfaW50ZXJuYWwudCAtPiAoJ2EsICdiKSB0XG4gIGVuZCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgRmllbGRfaW50ZXJuYWxcblxuICAgIGxldCBsYWJlbCB0ID0gdC5sYWJlbFxuICAgIGxldCBpbmRleCB0ID0gdC5pbmRleFxuICAgIGxldCBnZXQgdCA9IHQuZ2V0XG4gICAgbGV0IGlzX211dGFibGUgdCA9IHQuaXNfbXV0YWJsZVxuICAgIGxldCB0eWlkIHQgPSB0LnR5aWRcbiAgICBsZXQgdHJhdmVyc2UgdCA9IHQucmVwXG4gICAgbGV0IGludGVybmFsX3VzZV9vbmx5IHQgPSB0XG4gIGVuZFxuXG4gIG1vZHVsZSBSZWNvcmRfaW50ZXJuYWwgPSBzdHJ1Y3RcbiAgICB0eXBlIF8gZmllbGQgPSBGaWVsZCA6ICgncmVjb3JkLCAnYSkgRmllbGQudCAtPiAncmVjb3JkIGZpZWxkXG4gICAgdHlwZSAncmVjb3JkIGZpZWxkcyA9IHsgZ2V0IDogJ2ZpZWxkLiAoJ3JlY29yZCwgJ2ZpZWxkKSBGaWVsZC50IC0+ICdmaWVsZCB9XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyB0eXBlbmFtZSA6ICdhIFR5cGVuYW1lLnRcbiAgICAgIDsgZmllbGRzIDogJ2EgZmllbGQgYXJyYXlcbiAgICAgIDsgaGFzX2RvdWJsZV9hcnJheV90YWcgOiBib29sXG4gICAgICA7IGNyZWF0ZSA6ICdhIGZpZWxkcyAtPiAnYVxuICAgICAgfVxuICBlbmRcblxuICBtb2R1bGUgUmVjb3JkIDogc2lnXG4gICAgKCoqXG4gICAgICAgQW4gZXhpc3RlbnRpYWwgdHlwZSB1c2VkIHRvIGdhdGhlciBhbGwgdGhlIGZpZWxkcyBjb25zdGl0dWluZyBhIHJlY29yZCB0eXBlLiB0aGVcbiAgICAgICBbJ3JlY29yZF0gcGFyYW1ldGVyIGlzIHRoZSByZWNvcmQgdHlwZSwgaXQgaXMgdGhlIHNhbWUgZm9yIGFsbCB0aGUgZmllbGQgb2YgdGhhdFxuICAgICAgIHJlY29yZCB0eXBlLiBUaGUgdHlwZSBvZiB0aGUgZmllbGRzIG1pZ2h0IGJlIGRpZmZlcmVudCBmb3IgZWFjaCBmaWVsZCBhbmQgaXMgdGh1c1xuICAgICAgIGV4aXN0ZW50aWFsLlxuICAgICopXG4gICAgdHlwZSBfIGZpZWxkID0gRmllbGQgOiAoJ3JlY29yZCwgJ2EpIEZpZWxkLnQgLT4gJ3JlY29yZCBmaWVsZFxuXG4gICAgKCoqXG4gICAgICAgWydyZWNvcmQgZmllbGRzXSBpcyBhIHR5cGUgaXNvbW9ycGhpYyB0byBbJ3JlY29yZF0uICBUaGlzIGdpdmVzIGEgd2F5IHRvIGdldCB0aGVcbiAgICAgICBmaWVsZCB2YWx1ZSBmb3IgZWFjaCBmaWVsZCBvZiB0aGUgcmVjb3JkLiAgVGhlIGFkdmFudGFnZSBvZiB0aGlzIHJlcHJlc2VudGF0aW9uIGlzXG4gICAgICAgdGhhdCBpdCBpcyBjb252ZW5pZW50IGZvciB3cml0aW5nIGdlbmVyaWMgY29tcHV0YXRpb25zLlxuICAgICopXG4gICAgdHlwZSAncmVjb3JkIGZpZWxkcyA9IHsgZ2V0IDogJ2ZpZWxkLiAoJ3JlY29yZCwgJ2ZpZWxkKSBGaWVsZC50IC0+ICdmaWVsZCB9XG5cbiAgICAoKipcbiAgICAgICBXaXRuZXNzIG9mIGEgcmVjb3JkIHR5cGUuIFRoZSBwYXJhbWV0ZXIgaXMgdGhlIHR5cGUgb2YgdGhlIHJlY29yZCB0eXBlIHdpdG5lc3NlZC5cbiAgICAqKVxuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0IC0+ICdhIFR5cGVuYW1lLnRcblxuICAgICgqKlxuICAgICAgIFJldHVybnMgdGhlIG51bWJlciBvZiBmaWVsZHMgb2YgdGhpcyByZWNvcmQgdHlwZSBkZWZpbml0aW9uLlxuICAgICopXG4gICAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG5cbiAgICAoKipcbiAgICAgICBHZXQgdGhlIG50aCBmaWVsZCBvZiB0aGlzIHJlY29yZCB0eXBlLCBpbmRleGVkIGZyb20gMC5cbiAgICAqKVxuICAgIHZhbCBmaWVsZCA6ICdhIHQgLT4gaW50IC0+ICdhIGZpZWxkXG5cbiAgICAoKipcbiAgICAgICBUaGlzIGlzIGEgbG93IGxldmVsIG1ldGFkYXRhIHJlZ2FyZGluZyB0aGUgd2F5IHRoZSBvY2FtbCBjb21waWxlciByZXByZXNlbnQgdGhlXG4gICAgICAgYXJyYXkgdW5kZXJuZWF0aCB0aGF0IGlzIHRoZSBydW50aW1lIHZhbHVlIG9mIGEgcmVjb3JkIG9mIHR5cGUgWydhXSBnaXZlbiBhIHdpdG5lc3NcbiAgICAgICBvZiB0eXBlIFsnYSB0XS4gW2hhc19kb3VibGVfYXJyYXlfdGFnIHddIHJldHVybnMgW3RydWVdIGlmIHRoZSBhcnJheSB0aGF0XG4gICAgICAgcmVwcmVzZW50cyBydW50aW1lIHZhbHVlcyBvZiB0aGlzIHR5cGUgaXMgYW4gb3B0aW1pemVkIG9jYW1sIGZsb2F0IGFycmF5LlxuICAgICAgIFR5cGljYWxseSwgdGhpcyB3aWxsIGJlIHRydWUgZm9yIHJlY29yZCB3aGVyZSBhbGwgZmllbGRzIGFyZSBzdGF0aWNhbGx5IGtub3duIGFzIHRvXG4gICAgICAgYmUgW2Zsb2F0c10uXG5cbiAgICAgICBOb3RlIHRoYXQgeW91IGNhbid0IGdldCB0aGlzIGluZm9ybWF0aW9uIGR5bmFtaWNhbGx5IGJ5IGluc3BlY3RpbmcgdGhlIHR5cGVyZXAgb25jZVxuICAgICAgIGl0IGlzIGFwcGxpZWQsIGJlY2F1c2UgdGhlcmUgaXMgYXQgdGhpcyBwb2ludCBubyB3YXkgdG8gdGVsbCB3aGV0aGVyIG9uZSBvZiB0aGVcbiAgICAgICBmaWVsZCBpcyBwb2x5bW9ycGhpYyBpbiB0aGUgdHlwZSBkZWZpbml0aW9uLlxuICAgICopXG4gICAgdmFsIGhhc19kb3VibGVfYXJyYXlfdGFnIDogXyB0IC0+IGJvb2xcblxuICAgICgqKlxuICAgICAgIEV4cG9zZSBvbmUgZGlyZWN0aW9uIG9mIHRoZSBpc29tb3JwaGlzbSBiZXR3ZWVuIGEgdmFsdWUgb2YgdHlwZSBbJ2FdIGFuZCBhIHZhbHVlIG9mXG4gICAgICAgdHlwZSBbJ2EgZmllbGRzXS4gQmFzaWNhbGx5LCBnaXZlbiBhbiBlbmNvZGluZyB3YXkgb2YgYWNjZXNzaW5nIHRoZSB2YWx1ZSBvZiBhbGxcbiAgICAgICB0aGUgZmllbGRzIG9mIGEgcmVjb3JkLCBjcmVhdGUgdGhhdCByZWNvcmQgYW5kIHJldHVybiBpdC5cbiAgICAqKVxuICAgIHZhbCBjcmVhdGUgOiAnYSB0IC0+ICdhIGZpZWxkcyAtPiAnYVxuXG4gICAgKCoqXG4gICAgICAgZm9sZGluZyBhbG9uZyB0aGUgdGFncyBvZiB0aGUgdmFyaWFudCB0eXBlXG4gICAgKilcbiAgICB2YWwgZm9sZCA6ICdhIHQgLT4gaW5pdDonYWNjIC0+IGY6KCdhY2MgLT4gJ2EgZmllbGQgLT4gJ2FjYykgLT4gJ2FjY1xuXG4gICAgKCogdXNlZCBieSB0aGUgY2FtbHA0IGV4dGVuc2lvbiB0byBidWlsZCB0eXBlIHdpdG5lc3Nlcywgb3IgYnkgc29tZSBpbnRlcm5hbCBwYXJ0cyBvZlxuICAgICAgIHR5cGVyZXAuIHlvdSBzaG91bGQgZmVlbCBiYWQgaWYgeW91IG5lZWQgdG8gdXNlIGl0IGluIHNvbWUgdXNlciBjb2RlICopXG4gICAgdmFsIGludGVybmFsX3VzZV9vbmx5IDogJ2EgUmVjb3JkX2ludGVybmFsLnQgLT4gJ2EgdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFJlY29yZF9pbnRlcm5hbFxuXG4gICAgbGV0IHR5cGVuYW1lX29mX3QgdCA9IHQudHlwZW5hbWVcbiAgICBsZXQgbGVuZ3RoIHQgPSBBcnJheS5sZW5ndGggdC5maWVsZHNcbiAgICBsZXQgZmllbGQgdCBpbmRleCA9IHQuZmllbGRzLihpbmRleClcbiAgICBsZXQgaGFzX2RvdWJsZV9hcnJheV90YWcgdCA9IHQuaGFzX2RvdWJsZV9hcnJheV90YWdcbiAgICBsZXQgY3JlYXRlIHQgPSB0LmNyZWF0ZVxuICAgIGxldCBmb2xkIHQgfmluaXQgfmYgPSBBcnJheS5mb2xkX2xlZnQgZiBpbml0IHQuZmllbGRzXG4gICAgbGV0IGludGVybmFsX3VzZV9vbmx5IHQgPSB0XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBNIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgcmVwID0gJ2EgdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgcmVwXG4gICAgZW5kKVxuZW5kXG4iLCJtb2R1bGUgTmFtZV9vZiA9IHN0cnVjdFxuICBsZXQgdHlwZW5hbWVfb2ZfaW50ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBpbnRcblxuICAgICAgICBsZXQgbmFtZSA9IFwiaW50XCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9pbnQzMiA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gaW50MzJcblxuICAgICAgICBsZXQgbmFtZSA9IFwiaW50MzJcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX2ludDY0ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBpbnQ2NFxuXG4gICAgICAgIGxldCBuYW1lID0gXCJpbnQ2NFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfbmF0aXZlaW50ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBuYXRpdmVpbnRcblxuICAgICAgICBsZXQgbmFtZSA9IFwibmF0aXZlaW50XCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9jaGFyID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBjaGFyXG5cbiAgICAgICAgbGV0IG5hbWUgPSBcImNoYXJcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX2Zsb2F0ID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBmbG9hdFxuXG4gICAgICAgIGxldCBuYW1lID0gXCJmbG9hdFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2Zfc3RyaW5nID1cbiAgICBsZXQgbW9kdWxlIE0gPVxuICAgICAgVHlwZW5hbWUuTWFrZTAgKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBzdHJpbmdcblxuICAgICAgICBsZXQgbmFtZSA9IFwic3RyaW5nXCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl9ieXRlcyA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gYnl0ZXNcblxuICAgICAgICBsZXQgbmFtZSA9IFwiYnl0ZXNcIlxuICAgICAgZW5kKVxuICAgIGluXG4gICAgTS50eXBlbmFtZV9vZl90XG4gIDs7XG5cbiAgbGV0IHR5cGVuYW1lX29mX2Jvb2wgPVxuICAgIGxldCBtb2R1bGUgTSA9XG4gICAgICBUeXBlbmFtZS5NYWtlMCAoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IGJvb2xcblxuICAgICAgICBsZXQgbmFtZSA9IFwiYm9vbFwiXG4gICAgICBlbmQpXG4gICAgaW5cbiAgICBNLnR5cGVuYW1lX29mX3RcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfdW5pdCA9XG4gICAgbGV0IG1vZHVsZSBNID1cbiAgICAgIFR5cGVuYW1lLk1ha2UwIChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gdW5pdFxuXG4gICAgICAgIGxldCBuYW1lID0gXCJ1bml0XCJcbiAgICAgIGVuZClcbiAgICBpblxuICAgIE0udHlwZW5hbWVfb2ZfdFxuICA7O1xuXG4gIG1vZHVsZSBNX29wdGlvbiA9IFR5cGVuYW1lLk1ha2UxIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIG9wdGlvblxuXG4gICAgICBsZXQgbmFtZSA9IFwib3B0aW9uXCJcbiAgICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX29wdGlvbiA9IE1fb3B0aW9uLnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV9saXN0ID0gVHlwZW5hbWUuTWFrZTEgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2EgbGlzdFxuXG4gICAgICBsZXQgbmFtZSA9IFwibGlzdFwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9saXN0ID0gTV9saXN0LnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV9hcnJheSA9IFR5cGVuYW1lLk1ha2UxIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIGFycmF5XG5cbiAgICAgIGxldCBuYW1lID0gXCJhcnJheVwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9hcnJheSA9IE1fYXJyYXkudHlwZW5hbWVfb2ZfdFxuXG4gIG1vZHVsZSBNX2xhenlfdCA9IFR5cGVuYW1lLk1ha2UxIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIGxhenlfdFxuXG4gICAgICBsZXQgbmFtZSA9IFwibGF6eV90XCJcbiAgICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX2xhenlfdCA9IE1fbGF6eV90LnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV9yZWYgPSBUeXBlbmFtZS5NYWtlMSAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYSByZWZcblxuICAgICAgbGV0IG5hbWUgPSBcInJlZlwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl9yZWYgPSBNX3JlZi50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fZnVuY3Rpb24gPSBUeXBlbmFtZS5NYWtlMiAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAnYSAtPiAnYlxuXG4gICAgICBsZXQgbmFtZSA9IFwiZnVuY3Rpb25cIlxuICAgIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfZnVuY3Rpb24gPSBNX2Z1bmN0aW9uLnR5cGVuYW1lX29mX3RcblxuICB0eXBlIHR1cGxlMCA9IHVuaXRcblxuICBtb2R1bGUgTV90dXBsZTAgPSBUeXBlbmFtZS5NYWtlMCAoc3RydWN0XG4gICAgICB0eXBlIHQgPSB0dXBsZTBcblxuICAgICAgbGV0IG5hbWUgPSBcInR1cGxlMFwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90dXBsZTAgPSBNX3R1cGxlMC50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fdHVwbGUyID0gVHlwZW5hbWUuTWFrZTIgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gJ2EgKiAnYlxuXG4gICAgICBsZXQgbmFtZSA9IFwidHVwbGUyXCJcbiAgICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3R1cGxlMiA9IE1fdHVwbGUyLnR5cGVuYW1lX29mX3RcblxuICBtb2R1bGUgTV90dXBsZTMgPSBUeXBlbmFtZS5NYWtlMyAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gJ2EgKiAnYiAqICdjXG5cbiAgICAgIGxldCBuYW1lID0gXCJ0dXBsZTNcIlxuICAgIGVuZClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdHVwbGUzID0gTV90dXBsZTMudHlwZW5hbWVfb2ZfdFxuXG4gIG1vZHVsZSBNX3R1cGxlNCA9IFR5cGVuYW1lLk1ha2U0IChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0ID0gJ2EgKiAnYiAqICdjICogJ2RcblxuICAgICAgbGV0IG5hbWUgPSBcInR1cGxlNFwiXG4gICAgZW5kKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90dXBsZTQgPSBNX3R1cGxlNC50eXBlbmFtZV9vZl90XG5cbiAgbW9kdWxlIE1fdHVwbGU1ID0gVHlwZW5hbWUuTWFrZTUgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0ID0gJ2EgKiAnYiAqICdjICogJ2QgKiAnZVxuXG4gICAgICBsZXQgbmFtZSA9IFwidHVwbGU1XCJcbiAgICBlbmQpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3R1cGxlNSA9IE1fdHVwbGU1LnR5cGVuYW1lX29mX3RcbmVuZFxuXG5tb2R1bGUgcmVjIFR5cGVyZXAgOiBzaWdcbiAgdHlwZSBfIHQgPVxuICAgIHwgSW50IDogaW50IHRcbiAgICB8IEludDMyIDogaW50MzIgdFxuICAgIHwgSW50NjQgOiBpbnQ2NCB0XG4gICAgfCBOYXRpdmVpbnQgOiBuYXRpdmVpbnQgdFxuICAgIHwgQ2hhciA6IGNoYXIgdFxuICAgIHwgRmxvYXQgOiBmbG9hdCB0XG4gICAgfCBTdHJpbmcgOiBzdHJpbmcgdFxuICAgIHwgQnl0ZXMgOiBieXRlcyB0XG4gICAgfCBCb29sIDogYm9vbCB0XG4gICAgfCBVbml0IDogdW5pdCB0XG4gICAgfCBPcHRpb24gOiAnYSB0IC0+ICdhIG9wdGlvbiB0XG4gICAgfCBMaXN0IDogJ2EgdCAtPiAnYSBsaXN0IHRcbiAgICB8IEFycmF5IDogJ2EgdCAtPiAnYSBhcnJheSB0XG4gICAgfCBMYXp5IDogJ2EgdCAtPiAnYSBsYXp5X3QgdFxuICAgIHwgUmVmIDogJ2EgdCAtPiAnYSByZWYgdFxuICAgIHwgRnVuY3Rpb24gOiAoJ2RvbSB0ICogJ3JuZyB0KSAtPiAoJ2RvbSAtPiAncm5nKSB0XG4gICAgfCBUdXBsZSA6ICdhIFR5cGVyZXAuVHVwbGUudCAtPiAnYSB0XG4gICAgfCBSZWNvcmQgOiAnYSBUeXBlcmVwLlJlY29yZC50IC0+ICdhIHRcbiAgICB8IFZhcmlhbnQgOiAnYSBUeXBlcmVwLlZhcmlhbnQudCAtPiAnYSB0XG4gICAgfCBOYW1lZCA6ICgnYSBUeXBlcmVwLk5hbWVkLnQgKiAnYSB0IGxhenlfdCBvcHRpb24pIC0+ICdhIHRcblxuICB0eXBlIHBhY2tlZCA9IFQgOiAnYSB0IC0+IHBhY2tlZFxuXG4gIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgIG1vZHVsZSB0eXBlIFQwID0gc2lnXG4gICAgICB0eXBlIG5hbWVkXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkIDogbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQxID0gc2lnXG4gICAgICB0eXBlICdhIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkIDogJ2EgVHlwZW5hbWUudCAtPiAnYSBuYW1lZCBUeXBlbmFtZS50XG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgYSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMiA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiKSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBiXG5cbiAgICAgIHZhbCBiIDogYiBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6ICdhIFR5cGVuYW1lLnQgLT4gJ2IgVHlwZW5hbWUudCAtPiAoJ2EsICdiKSBuYW1lZCBUeXBlbmFtZS50XG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgKGEsIGIpIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQzID0gc2lnXG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBiXG5cbiAgICAgIHZhbCBiIDogYiBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBjXG5cbiAgICAgIHZhbCBjIDogYyBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICA6ICAnYSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdiIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2MgVHlwZW5hbWUudFxuICAgICAgICAtPiAoJ2EsICdiLCAnYykgbmFtZWQgVHlwZW5hbWUudFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgKGEsIGIsIGMpIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFQ0ID0gc2lnXG4gICAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZFxuXG4gICAgICB2YWwgZCA6IGQgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2QgVHlwZW5hbWUudFxuICAgICAgICAtPiAoJ2EsICdiLCAnYywgJ2QpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjLCBkKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUNSA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBiXG5cbiAgICAgIHZhbCBiIDogYiBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBjXG5cbiAgICAgIHZhbCBjIDogYyBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBkXG5cbiAgICAgIHZhbCBkIDogZCBUeXBlcmVwLnRcblxuICAgICAgdHlwZSBlXG5cbiAgICAgIHZhbCBlIDogZSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICA6ICAnYSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdiIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2MgVHlwZW5hbWUudFxuICAgICAgICAtPiAnZCBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdlIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSkgbmFtZWQgVHlwZW5hbWUudFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6IHQgVHlwZW5hbWUudFxuICAgICAgdmFsIHdpdG5lc3MgOiAodCwgKGEsIGIsIGMsIGQsIGUpIG5hbWVkKSBUeXBlX2VxdWFsLnRcbiAgICBlbmRcblxuICAgICgqIHRoZXJlIHRoZSBtb2R1bGUgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugd2UgbmVlZCB0byBkZWFsIHdpdGggYSB0eXBlIFt0XSB3aXRoXG4gICAgICAgcGFyYW1ldGVycyB3aG9zZSBraW5kIGlzIG5vdCByZXByZXNlbnRhYmxlIGFzIGEgdHlwZSB2YXJpYWJsZTogWydhICd0XSwgZXZlbiB3aXRoXG4gICAgICAgYSBnYWR0LiAqKVxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB8IFQwIG9mIChtb2R1bGUgVDAgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDEgb2YgKG1vZHVsZSBUMSB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUMiBvZiAobW9kdWxlIFQyIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQzIG9mIChtb2R1bGUgVDMgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDQgb2YgKG1vZHVsZSBUNCB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUNSBvZiAobW9kdWxlIFQ1IHdpdGggdHlwZSB0ID0gJ2EpXG5cbiAgICB2YWwgYXJpdHkgOiBfIHQgLT4gaW50XG4gICAgdmFsIHR5cGVuYW1lX29mX3QgOiAnYSB0IC0+ICdhIFR5cGVuYW1lLnRcbiAgICB2YWwgbmFtZSA6IF8gdCAtPiBzdHJpbmdcbiAgZW5kXG5cbiAgbW9kdWxlIFR1cGxlIDogc2lnXG4gICAgKCogdGhlc2UgY29uc3RydWN0b3JzIGNvdWxkIGJlIHBsdW5nZWQgYXQgdG9wbGV2ZWwgb2YgVHlwZXJlcC50LCBob3dldmVyIGl0IGlzIGxlc3NcbiAgICAgICB2ZXJib3NlIHRoYXQgd2F5ICopXG4gICAgdHlwZSBfIHQgPVxuICAgICAgfCBUMiA6ICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQpIC0+ICgnYSAqICdiKSB0XG4gICAgICB8IFQzIDogKCdhIFR5cGVyZXAudCAqICdiIFR5cGVyZXAudCAqICdjIFR5cGVyZXAudCkgLT4gKCdhICogJ2IgKiAnYykgdFxuICAgICAgfCBUNCA6XG4gICAgICAgICAgKCdhIFR5cGVyZXAudCAqICdiIFR5cGVyZXAudCAqICdjIFR5cGVyZXAudCAqICdkIFR5cGVyZXAudClcbiAgICAgICAgICAtPiAoJ2EgKiAnYiAqICdjICogJ2QpIHRcbiAgICAgIHwgVDUgOlxuICAgICAgICAgICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQgKiAnZCBUeXBlcmVwLnQgKiAnZSBUeXBlcmVwLnQpXG4gICAgICAgICAgLT4gKCdhICogJ2IgKiAnYyAqICdkICogJ2UpIHRcblxuICAgIHZhbCBhcml0eSA6IF8gdCAtPiBpbnRcbiAgICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHQgLT4gJ2EgVHlwZW5hbWUudFxuICBlbmRcblxuICBpbmNsdWRlIFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLlMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVHlwZXJlcC50XG5cbiAgdmFsIHNhbWUgOiBfIHQgLT4gXyB0IC0+IGJvb2xcbiAgdmFsIHNhbWVfd2l0bmVzcyA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EsICdiKSBUeXBlX2VxdWFsLnQgb3B0aW9uXG4gIHZhbCBzYW1lX3dpdG5lc3NfZXhuIDogJ2EgdCAtPiAnYiB0IC0+ICgnYSwgJ2IpIFR5cGVfZXF1YWwudFxuICB2YWwgdHlwZW5hbWVfb2ZfdCA6ICdhIHQgLT4gJ2EgVHlwZW5hbWUudFxuICB2YWwgaGVhZCA6ICdhIHQgLT4gJ2EgdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgXyB0ID1cbiAgICB8IEludCA6IGludCB0XG4gICAgfCBJbnQzMiA6IGludDMyIHRcbiAgICB8IEludDY0IDogaW50NjQgdFxuICAgIHwgTmF0aXZlaW50IDogbmF0aXZlaW50IHRcbiAgICB8IENoYXIgOiBjaGFyIHRcbiAgICB8IEZsb2F0IDogZmxvYXQgdFxuICAgIHwgU3RyaW5nIDogc3RyaW5nIHRcbiAgICB8IEJ5dGVzIDogYnl0ZXMgdFxuICAgIHwgQm9vbCA6IGJvb2wgdFxuICAgIHwgVW5pdCA6IHVuaXQgdFxuICAgIHwgT3B0aW9uIDogJ2EgdCAtPiAnYSBvcHRpb24gdFxuICAgIHwgTGlzdCA6ICdhIHQgLT4gJ2EgbGlzdCB0XG4gICAgfCBBcnJheSA6ICdhIHQgLT4gJ2EgYXJyYXkgdFxuICAgIHwgTGF6eSA6ICdhIHQgLT4gJ2EgbGF6eV90IHRcbiAgICB8IFJlZiA6ICdhIHQgLT4gJ2EgcmVmIHRcbiAgICB8IEZ1bmN0aW9uIDogKCdkb20gdCAqICdybmcgdCkgLT4gKCdkb20gLT4gJ3JuZykgdFxuICAgIHwgVHVwbGUgOiAnYSBUeXBlcmVwLlR1cGxlLnQgLT4gJ2EgdFxuICAgIHwgUmVjb3JkIDogJ2EgVHlwZXJlcC5SZWNvcmQudCAtPiAnYSB0XG4gICAgfCBWYXJpYW50IDogJ2EgVHlwZXJlcC5WYXJpYW50LnQgLT4gJ2EgdFxuICAgIHwgTmFtZWQgOiAoJ2EgVHlwZXJlcC5OYW1lZC50ICogJ2EgdCBsYXp5X3Qgb3B0aW9uKSAtPiAnYSB0XG5cbiAgdHlwZSBwYWNrZWQgPSBUIDogJ2EgdCAtPiBwYWNrZWRcblxuICBtb2R1bGUgTmFtZWQgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgdHlwZSBUMCA9IHNpZ1xuICAgICAgdHlwZSBuYW1lZFxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6IG5hbWVkIFR5cGVuYW1lLnRcbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMSA9IHNpZ1xuICAgICAgdHlwZSAnYSBuYW1lZFxuICAgICAgdHlwZSBhXG5cbiAgICAgIHZhbCBhIDogYSBUeXBlcmVwLnRcblxuICAgICAgdHlwZSB0XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl9uYW1lZCA6ICdhIFR5cGVuYW1lLnQgLT4gJ2EgbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIGEgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDIgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYikgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWQgOiAnYSBUeXBlbmFtZS50IC0+ICdiIFR5cGVuYW1lLnQgLT4gKCdhLCAnYikgbmFtZWQgVHlwZW5hbWUudFxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUMyA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICBtb2R1bGUgdHlwZSBUNCA9IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QpIG5hbWVkXG4gICAgICB0eXBlIGFcblxuICAgICAgdmFsIGEgOiBhIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGJcblxuICAgICAgdmFsIGIgOiBiIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGNcblxuICAgICAgdmFsIGMgOiBjIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIGRcblxuICAgICAgdmFsIGQgOiBkIFR5cGVyZXAudFxuXG4gICAgICB0eXBlIHRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgIDogICdhIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2IgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYyBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdkIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gKCdhLCAnYiwgJ2MsICdkKSBuYW1lZCBUeXBlbmFtZS50XG5cbiAgICAgIHZhbCB0eXBlbmFtZV9vZl90IDogdCBUeXBlbmFtZS50XG4gICAgICB2YWwgd2l0bmVzcyA6ICh0LCAoYSwgYiwgYywgZCkgbmFtZWQpIFR5cGVfZXF1YWwudFxuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgVDUgPSBzaWdcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgbmFtZWRcbiAgICAgIHR5cGUgYVxuXG4gICAgICB2YWwgYSA6IGEgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgYlxuXG4gICAgICB2YWwgYiA6IGIgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgY1xuXG4gICAgICB2YWwgYyA6IGMgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZFxuXG4gICAgICB2YWwgZCA6IGQgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgZVxuXG4gICAgICB2YWwgZSA6IGUgVHlwZXJlcC50XG5cbiAgICAgIHR5cGUgdFxuXG4gICAgICB2YWwgdHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgOiAgJ2EgVHlwZW5hbWUudFxuICAgICAgICAtPiAnYiBUeXBlbmFtZS50XG4gICAgICAgIC0+ICdjIFR5cGVuYW1lLnRcbiAgICAgICAgLT4gJ2QgVHlwZW5hbWUudFxuICAgICAgICAtPiAnZSBUeXBlbmFtZS50XG4gICAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIG5hbWVkIFR5cGVuYW1lLnRcblxuICAgICAgdmFsIHR5cGVuYW1lX29mX3QgOiB0IFR5cGVuYW1lLnRcbiAgICAgIHZhbCB3aXRuZXNzIDogKHQsIChhLCBiLCBjLCBkLCBlKSBuYW1lZCkgVHlwZV9lcXVhbC50XG4gICAgZW5kXG5cbiAgICAoKiB0aGVyZSB0aGUgbW9kdWxlIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIG5lZWQgdG8gZGVhbCB3aXRoIGEgdHlwZSBbdF0gd2l0aFxuICAgICAgIHBhcmFtZXRlcnMgd2hvc2Uga2luZCBpcyBub3QgcmVwcmVzZW50YWJsZSBhcyBhIHR5cGUgdmFyaWFibGU6IFsnYSAndF0sIGV2ZW4gd2l0aFxuICAgICAgIGEgZ2FkdC4gKilcbiAgICB0eXBlICdhIHQgPVxuICAgICAgfCBUMCBvZiAobW9kdWxlIFQwIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQxIG9mIChtb2R1bGUgVDEgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDIgb2YgKG1vZHVsZSBUMiB3aXRoIHR5cGUgdCA9ICdhKVxuICAgICAgfCBUMyBvZiAobW9kdWxlIFQzIHdpdGggdHlwZSB0ID0gJ2EpXG4gICAgICB8IFQ0IG9mIChtb2R1bGUgVDQgd2l0aCB0eXBlIHQgPSAnYSlcbiAgICAgIHwgVDUgb2YgKG1vZHVsZSBUNSB3aXRoIHR5cGUgdCA9ICdhKVxuXG4gICAgbGV0IGFyaXR5ID0gZnVuY3Rpb25cbiAgICAgIHwgVDAgXyAtPiAwXG4gICAgICB8IFQxIF8gLT4gMVxuICAgICAgfCBUMiBfIC0+IDJcbiAgICAgIHwgVDMgXyAtPiAzXG4gICAgICB8IFQ0IF8gLT4gNFxuICAgICAgfCBUNSBfIC0+IDVcbiAgICA7O1xuXG4gICAgbGV0IHR5cGVuYW1lX29mX3QgKHR5cGUgYSkgPSBmdW5jdGlvblxuICAgICAgfCBUMCByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMCB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUMSByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMSB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUMiByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMiB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUMyByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUMyB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUNCByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUNCB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgICAgfCBUNSByZXAgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUNSB3aXRoIHR5cGUgdCA9IGEpIGluXG4gICAgICAgIFQudHlwZW5hbWVfb2ZfdFxuICAgIDs7XG5cbiAgICBsZXQgbmFtZSByZXAgPSBUeXBlbmFtZS5VaWQubmFtZSAoVHlwZW5hbWUudWlkICh0eXBlbmFtZV9vZl90IHJlcCkpXG4gIGVuZFxuXG4gIG1vZHVsZSBUdXBsZSA9IHN0cnVjdFxuICAgICgqIHRoZXNlIGNvbnN0cnVjdG9ycyBjb3VsZCBiZSBwbHVuZ2VkIGF0IHRvcGxldmVsIG9mIFR5cGVyZXAudCwgaG93ZXZlciBpdCBpcyBsZXNzXG4gICAgICAgdmVyYm9zZSB0aGlzIHdheSAqKVxuICAgIHR5cGUgXyB0ID1cbiAgICAgIHwgVDIgOiAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50KSAtPiAoJ2EgKiAnYikgdFxuICAgICAgfCBUMyA6ICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQpIC0+ICgnYSAqICdiICogJ2MpIHRcbiAgICAgIHwgVDQgOlxuICAgICAgICAgICgnYSBUeXBlcmVwLnQgKiAnYiBUeXBlcmVwLnQgKiAnYyBUeXBlcmVwLnQgKiAnZCBUeXBlcmVwLnQpXG4gICAgICAgICAgLT4gKCdhICogJ2IgKiAnYyAqICdkKSB0XG4gICAgICB8IFQ1IDpcbiAgICAgICAgICAoJ2EgVHlwZXJlcC50ICogJ2IgVHlwZXJlcC50ICogJ2MgVHlwZXJlcC50ICogJ2QgVHlwZXJlcC50ICogJ2UgVHlwZXJlcC50KVxuICAgICAgICAgIC0+ICgnYSAqICdiICogJ2MgKiAnZCAqICdlKSB0XG5cbiAgICBsZXQgYXJpdHkgOiB0eXBlIGEuIGEgdCAtPiBpbnQgPSBmdW5jdGlvblxuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQyIF8gLT4gMlxuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQzIF8gLT4gM1xuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQ0IF8gLT4gNFxuICAgICAgfCBUeXBlcmVwLlR1cGxlLlQ1IF8gLT4gNVxuICAgIDs7XG5cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA6IHR5cGUgYS4gYSB0IC0+IGEgVHlwZW5hbWUudCA9IGZ1bmN0aW9uXG4gICAgICB8IFQyIChhLCBiKSAtPlxuICAgICAgICBOYW1lX29mLnR5cGVuYW1lX29mX3R1cGxlMiAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGEpIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYilcbiAgICAgIHwgVDMgKGEsIGIsIGMpIC0+XG4gICAgICAgIE5hbWVfb2YudHlwZW5hbWVfb2ZfdHVwbGUzXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBhKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYilcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGMpXG4gICAgICB8IFQ0IChhLCBiLCBjLCBkKSAtPlxuICAgICAgICBOYW1lX29mLnR5cGVuYW1lX29mX3R1cGxlNFxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYSlcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGIpXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBjKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgZClcbiAgICAgIHwgVDUgKGEsIGIsIGMsIGQsIGUpIC0+XG4gICAgICAgIE5hbWVfb2YudHlwZW5hbWVfb2ZfdHVwbGU1XG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBhKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgYilcbiAgICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IGMpXG4gICAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBkKVxuICAgICAgICAgIChUeXBlcmVwLnR5cGVuYW1lX29mX3QgZSlcbiAgICA7O1xuICBlbmRcblxuICBpbmNsdWRlIFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLk0gKHN0cnVjdFxuICAgICAgdHlwZSAnYSByZXAgPSAnYSB0XG4gICAgICB0eXBlICdhIHQgPSAnYSByZXBcbiAgICBlbmQpXG5cbiAgbGV0IHJlYyB0eXBlbmFtZV9vZl90IDogdHlwZSBhLiBhIHQgLT4gYSBUeXBlbmFtZS50ID0gZnVuY3Rpb25cbiAgICB8IEludCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2ludFxuICAgIHwgSW50MzIgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9pbnQzMlxuICAgIHwgSW50NjQgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9pbnQ2NFxuICAgIHwgTmF0aXZlaW50IC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfbmF0aXZlaW50XG4gICAgfCBDaGFyIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfY2hhclxuICAgIHwgRmxvYXQgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9mbG9hdFxuICAgIHwgU3RyaW5nIC0+IE5hbWVfb2YudHlwZW5hbWVfb2Zfc3RyaW5nXG4gICAgfCBCeXRlcyAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2J5dGVzXG4gICAgfCBCb29sIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfYm9vbFxuICAgIHwgVW5pdCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX3VuaXRcbiAgICB8IE9wdGlvbiByZXAgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9vcHRpb24gKHR5cGVuYW1lX29mX3QgcmVwKVxuICAgIHwgTGlzdCByZXAgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9saXN0ICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IEFycmF5IHJlcCAtPiBOYW1lX29mLnR5cGVuYW1lX29mX2FycmF5ICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IExhenkgcmVwIC0+IE5hbWVfb2YudHlwZW5hbWVfb2ZfbGF6eV90ICh0eXBlbmFtZV9vZl90IHJlcClcbiAgICB8IFJlZiByZXAgLT4gTmFtZV9vZi50eXBlbmFtZV9vZl9yZWYgKHR5cGVuYW1lX29mX3QgcmVwKVxuICAgIHwgRnVuY3Rpb24gKGRvbSwgcm5nKSAtPlxuICAgICAgTmFtZV9vZi50eXBlbmFtZV9vZl9mdW5jdGlvbiAodHlwZW5hbWVfb2ZfdCBkb20pICh0eXBlbmFtZV9vZl90IHJuZylcbiAgICB8IFR1cGxlIHJlcCAtPiBUeXBlcmVwLlR1cGxlLnR5cGVuYW1lX29mX3QgcmVwXG4gICAgfCBSZWNvcmQgcmVwIC0+IFR5cGVyZXAuUmVjb3JkLnR5cGVuYW1lX29mX3QgcmVwXG4gICAgfCBWYXJpYW50IHJlcCAtPiBUeXBlcmVwLlZhcmlhbnQudHlwZW5hbWVfb2ZfdCByZXBcbiAgICB8IE5hbWVkIChuYW1lLCBfKSAtPiBOYW1lZC50eXBlbmFtZV9vZl90IG5hbWVcbiAgOztcblxuICBsZXQgcmVjIHNhbWVfd2l0bmVzcyA6IHR5cGUgYSBiLiBhIHQgLT4gYiB0IC0+IChhLCBiKSBUeXBlX2VxdWFsLnQgb3B0aW9uID1cbiAgICBmdW4gdDEgdDIgLT5cbiAgICAgIGxldCBtb2R1bGUgRSA9IFR5cGVfZXF1YWwgaW5cbiAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICB8IE5hbWVkIChuYW1lMSwgcjEpLCBOYW1lZCAobmFtZTIsIHIyKSAtPlxuICAgICAgICAobWF0Y2hcbiAgICAgICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzIChOYW1lZC50eXBlbmFtZV9vZl90IG5hbWUxKSAoTmFtZWQudHlwZW5hbWVfb2ZfdCBuYW1lMilcbiAgICAgICAgIHdpdGhcbiAgICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4XG4gICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgKG1hdGNoIHIxLCByMiB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgKGxhenkgdDEpLCBTb21lIChsYXp5IHQyKSAtPiBzYW1lX3dpdG5lc3MgdDEgdDJcbiAgICAgICAgICAgIHwgU29tZSAobGF6eSB0MSksIE5vbmUgLT4gc2FtZV93aXRuZXNzIHQxIHQyXG4gICAgICAgICAgICB8IE5vbmUsIFNvbWUgKGxhenkgdDIpIC0+IHNhbWVfd2l0bmVzcyB0MSB0MlxuICAgICAgICAgICAgfCBOb25lLCBOb25lIC0+IE5vbmUpKVxuICAgICAgfCBOYW1lZCAoXywgcjEpLCB0MiAtPlxuICAgICAgICAobWF0Y2ggcjEgd2l0aFxuICAgICAgICAgfCBTb21lIChsYXp5IHQxKSAtPiBzYW1lX3dpdG5lc3MgdDEgdDJcbiAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgICAgfCB0MSwgTmFtZWQgKF8sIHIyKSAtPlxuICAgICAgICAobWF0Y2ggcjIgd2l0aFxuICAgICAgICAgfCBTb21lIChsYXp5IHQyKSAtPiBzYW1lX3dpdG5lc3MgdDEgdDJcbiAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICAgICAgfCBJbnQsIEludCAtPiBTb21lIEUuVFxuICAgICAgfCBJbnQzMiwgSW50MzIgLT4gU29tZSBFLlRcbiAgICAgIHwgSW50NjQsIEludDY0IC0+IFNvbWUgRS5UXG4gICAgICB8IE5hdGl2ZWludCwgTmF0aXZlaW50IC0+IFNvbWUgRS5UXG4gICAgICB8IENoYXIsIENoYXIgLT4gU29tZSBFLlRcbiAgICAgIHwgRmxvYXQsIEZsb2F0IC0+IFNvbWUgRS5UXG4gICAgICB8IFN0cmluZywgU3RyaW5nIC0+IFNvbWUgRS5UXG4gICAgICB8IEJ5dGVzLCBCeXRlcyAtPiBTb21lIEUuVFxuICAgICAgfCBCb29sLCBCb29sIC0+IFNvbWUgRS5UXG4gICAgICB8IFVuaXQsIFVuaXQgLT4gU29tZSBFLlRcbiAgICAgIHwgT3B0aW9uIHIxLCBPcHRpb24gcjIgLT5cbiAgICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyByMSByMiB3aXRoXG4gICAgICAgICB8IE5vbmUgYXMgeCAtPiB4XG4gICAgICAgICB8IFNvbWUgRS5UIGFzIHggLT4geClcbiAgICAgIHwgTGlzdCByMSwgTGlzdCByMiAtPlxuICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIHIxIHIyIHdpdGhcbiAgICAgICAgIHwgTm9uZSBhcyB4IC0+IHhcbiAgICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4KVxuICAgICAgfCBBcnJheSByMSwgQXJyYXkgcjIgLT5cbiAgICAgICAgKG1hdGNoIHNhbWVfd2l0bmVzcyByMSByMiB3aXRoXG4gICAgICAgICB8IE5vbmUgYXMgeCAtPiB4XG4gICAgICAgICB8IFNvbWUgRS5UIGFzIHggLT4geClcbiAgICAgIHwgTGF6eSByMSwgTGF6eSByMiAtPlxuICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIHIxIHIyIHdpdGhcbiAgICAgICAgIHwgTm9uZSBhcyB4IC0+IHhcbiAgICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4KVxuICAgICAgfCBSZWYgcjEsIFJlZiByMiAtPlxuICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIHIxIHIyIHdpdGhcbiAgICAgICAgIHwgTm9uZSBhcyB4IC0+IHhcbiAgICAgICAgIHwgU29tZSBFLlQgYXMgeCAtPiB4KVxuICAgICAgfCBGdW5jdGlvbiAoZG9tMSwgcm5nMSksIEZ1bmN0aW9uIChkb20yLCBybmcyKSAtPlxuICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIGRvbTEgZG9tMiwgc2FtZV93aXRuZXNzIHJuZzEgcm5nMiB3aXRoXG4gICAgICAgICB8IFNvbWUgRS5ULCBTb21lIEUuVCAtPiBTb21lIEUuVFxuICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBOb25lKVxuICAgICAgfCBUdXBsZSB0MSwgVHVwbGUgdDIgLT5cbiAgICAgICAgbGV0IG1vZHVsZSBUID0gVHlwZXJlcC5UdXBsZSBpblxuICAgICAgICAobWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgICAgIHwgVC5UMiAoYTEsIGIxKSwgVC5UMiAoYTIsIGIyKSAtPlxuICAgICAgICAgICAobWF0Y2ggc2FtZV93aXRuZXNzIGExIGEyLCBzYW1lX3dpdG5lc3MgYjEgYjIgd2l0aFxuICAgICAgICAgICAgfCBTb21lIEUuVCwgU29tZSBFLlQgLT4gU29tZSBFLlRcbiAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gTm9uZSlcbiAgICAgICAgIHwgVC5UMyAoYTEsIGIxLCBjMSksIFQuVDMgKGEyLCBiMiwgYzIpIC0+XG4gICAgICAgICAgIChtYXRjaCBzYW1lX3dpdG5lc3MgYTEgYTIsIHNhbWVfd2l0bmVzcyBiMSBiMiwgc2FtZV93aXRuZXNzIGMxIGMyIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBFLlQsIFNvbWUgRS5ULCBTb21lIEUuVCAtPiBTb21lIEUuVFxuICAgICAgICAgICAgfCBOb25lLCBfLCBfIHwgXywgTm9uZSwgXyB8IF8sIF8sIE5vbmUgLT4gTm9uZSlcbiAgICAgICAgIHwgVC5UNCAoYTEsIGIxLCBjMSwgZDEpLCBULlQ0IChhMiwgYjIsIGMyLCBkMikgLT5cbiAgICAgICAgICAgKG1hdGNoXG4gICAgICAgICAgICAgIHNhbWVfd2l0bmVzcyBhMSBhMiwgc2FtZV93aXRuZXNzIGIxIGIyLCBzYW1lX3dpdG5lc3MgYzEgYzIsIHNhbWVfd2l0bmVzcyBkMSBkMlxuICAgICAgICAgICAgd2l0aFxuICAgICAgICAgICAgfCBTb21lIEUuVCwgU29tZSBFLlQsIFNvbWUgRS5ULCBTb21lIEUuVCAtPiBTb21lIEUuVFxuICAgICAgICAgICAgfCBOb25lLCBfLCBfLCBfIHwgXywgTm9uZSwgXywgXyB8IF8sIF8sIE5vbmUsIF8gfCBfLCBfLCBfLCBOb25lIC0+IE5vbmUpXG4gICAgICAgICB8IFQuVDUgKGExLCBiMSwgYzEsIGQxLCBlMSksIFQuVDUgKGEyLCBiMiwgYzIsIGQyLCBlMikgLT5cbiAgICAgICAgICAgKG1hdGNoXG4gICAgICAgICAgICAgICggc2FtZV93aXRuZXNzIGExIGEyXG4gICAgICAgICAgICAgICwgc2FtZV93aXRuZXNzIGIxIGIyXG4gICAgICAgICAgICAgICwgc2FtZV93aXRuZXNzIGMxIGMyXG4gICAgICAgICAgICAgICwgc2FtZV93aXRuZXNzIGQxIGQyXG4gICAgICAgICAgICAgICwgc2FtZV93aXRuZXNzIGUxIGUyIClcbiAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBFLlQsIFNvbWUgRS5ULCBTb21lIEUuVCwgU29tZSBFLlQsIFNvbWUgRS5UIC0+IFNvbWUgRS5UXG4gICAgICAgICAgICB8IE5vbmUsIF8sIF8sIF8sIF9cbiAgICAgICAgICAgIHwgXywgTm9uZSwgXywgXywgX1xuICAgICAgICAgICAgfCBfLCBfLCBOb25lLCBfLCBfXG4gICAgICAgICAgICB8IF8sIF8sIF8sIE5vbmUsIF9cbiAgICAgICAgICAgIHwgXywgXywgXywgXywgTm9uZSAtPiBOb25lKVxuICAgICAgICAgfCBULlQyIF8sIF8gLT4gTm9uZVxuICAgICAgICAgfCBULlQzIF8sIF8gLT4gTm9uZVxuICAgICAgICAgfCBULlQ0IF8sIF8gLT4gTm9uZVxuICAgICAgICAgfCBULlQ1IF8sIF8gLT4gTm9uZSlcbiAgICAgIHwgUmVjb3JkIHIxLCBSZWNvcmQgcjIgLT5cbiAgICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzXG4gICAgICAgICAgKFR5cGVyZXAuUmVjb3JkLnR5cGVuYW1lX29mX3QgcjEpXG4gICAgICAgICAgKFR5cGVyZXAuUmVjb3JkLnR5cGVuYW1lX29mX3QgcjIpXG4gICAgICB8IFZhcmlhbnQgcjEsIFZhcmlhbnQgcjIgLT5cbiAgICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzXG4gICAgICAgICAgKFR5cGVyZXAuVmFyaWFudC50eXBlbmFtZV9vZl90IHIxKVxuICAgICAgICAgIChUeXBlcmVwLlZhcmlhbnQudHlwZW5hbWVfb2ZfdCByMilcbiAgICAgIHwgSW50LCBfIC0+IE5vbmVcbiAgICAgIHwgSW50MzIsIF8gLT4gTm9uZVxuICAgICAgfCBJbnQ2NCwgXyAtPiBOb25lXG4gICAgICB8IE5hdGl2ZWludCwgXyAtPiBOb25lXG4gICAgICB8IENoYXIsIF8gLT4gTm9uZVxuICAgICAgfCBGbG9hdCwgXyAtPiBOb25lXG4gICAgICB8IFN0cmluZywgXyAtPiBOb25lXG4gICAgICB8IEJ5dGVzLCBfIC0+IE5vbmVcbiAgICAgIHwgQm9vbCwgXyAtPiBOb25lXG4gICAgICB8IFVuaXQsIF8gLT4gTm9uZVxuICAgICAgfCBPcHRpb24gXywgXyAtPiBOb25lXG4gICAgICB8IExpc3QgXywgXyAtPiBOb25lXG4gICAgICB8IEFycmF5IF8sIF8gLT4gTm9uZVxuICAgICAgfCBMYXp5IF8sIF8gLT4gTm9uZVxuICAgICAgfCBSZWYgXywgXyAtPiBOb25lXG4gICAgICB8IEZ1bmN0aW9uIF8sIF8gLT4gTm9uZVxuICAgICAgfCBUdXBsZSBfLCBfIC0+IE5vbmVcbiAgICAgIHwgUmVjb3JkIF8sIF8gLT4gTm9uZVxuICAgICAgfCBWYXJpYW50IF8sIF8gLT4gTm9uZVxuICA7O1xuXG4gIGxldCBzYW1lIGEgYiA9IHNhbWVfd2l0bmVzcyBhIGIgPD4gTm9uZVxuXG4gIGxldCBzYW1lX3dpdG5lc3NfZXhuIGEgYiA9XG4gICAgbWF0Y2ggc2FtZV93aXRuZXNzIGEgYiB3aXRoXG4gICAgfCBTb21lIHByb29mIC0+IHByb29mXG4gICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZVxuICA7O1xuXG4gIGxldCByZWMgaGVhZCA9IGZ1bmN0aW9uXG4gICAgfCBUeXBlcmVwLk5hbWVkIChfLCBTb21lIChsYXp5IHQpKSAtPiBoZWFkIHRcbiAgICB8IHQgLT4gdFxuICA7O1xuZW5kXG5cbmxldCB0eXBlcmVwX29mX2ludCA9IFR5cGVyZXAuSW50XG5sZXQgdHlwZXJlcF9vZl9pbnQzMiA9IFR5cGVyZXAuSW50MzJcbmxldCB0eXBlcmVwX29mX2ludDY0ID0gVHlwZXJlcC5JbnQ2NFxubGV0IHR5cGVyZXBfb2ZfbmF0aXZlaW50ID0gVHlwZXJlcC5OYXRpdmVpbnRcbmxldCB0eXBlcmVwX29mX2NoYXIgPSBUeXBlcmVwLkNoYXJcbmxldCB0eXBlcmVwX29mX2Zsb2F0ID0gVHlwZXJlcC5GbG9hdFxubGV0IHR5cGVyZXBfb2Zfc3RyaW5nID0gVHlwZXJlcC5TdHJpbmdcbmxldCB0eXBlcmVwX29mX2J5dGVzID0gVHlwZXJlcC5CeXRlc1xubGV0IHR5cGVyZXBfb2ZfYm9vbCA9IFR5cGVyZXAuQm9vbFxubGV0IHR5cGVyZXBfb2ZfdW5pdCA9IFR5cGVyZXAuVW5pdFxubGV0IHR5cGVyZXBfb2Zfb3B0aW9uIHJlcCA9IFR5cGVyZXAuT3B0aW9uIHJlcFxubGV0IHR5cGVyZXBfb2ZfbGlzdCByZXAgPSBUeXBlcmVwLkxpc3QgcmVwXG5sZXQgdHlwZXJlcF9vZl9hcnJheSByZXAgPSBUeXBlcmVwLkFycmF5IHJlcFxubGV0IHR5cGVyZXBfb2ZfbGF6eV90IHJlcCA9IFR5cGVyZXAuTGF6eSByZXBcbmxldCB0eXBlcmVwX29mX3JlZiByZXAgPSBUeXBlcmVwLlJlZiByZXBcbmxldCB0eXBlcmVwX29mX2Z1bmN0aW9uIGRvbSBybmcgPSBUeXBlcmVwLkZ1bmN0aW9uIChkb20sIHJuZylcbmxldCB0eXBlcmVwX29mX3R1cGxlMCA9IFR5cGVyZXAuVW5pdFxubGV0IHR5cGVyZXBfb2ZfdHVwbGUyIGEgYiA9IFR5cGVyZXAuVHVwbGUgKFR5cGVyZXAuVHVwbGUuVDIgKGEsIGIpKVxubGV0IHR5cGVyZXBfb2ZfdHVwbGUzIGEgYiBjID0gVHlwZXJlcC5UdXBsZSAoVHlwZXJlcC5UdXBsZS5UMyAoYSwgYiwgYykpXG5sZXQgdHlwZXJlcF9vZl90dXBsZTQgYSBiIGMgZCA9IFR5cGVyZXAuVHVwbGUgKFR5cGVyZXAuVHVwbGUuVDQgKGEsIGIsIGMsIGQpKVxubGV0IHR5cGVyZXBfb2ZfdHVwbGU1IGEgYiBjIGQgZSA9IFR5cGVyZXAuVHVwbGUgKFR5cGVyZXAuVHVwbGUuVDUgKGEsIGIsIGMsIGQsIGUpKVxuXG5pbmNsdWRlIE5hbWVfb2ZcblxubGV0IHZhbHVlX3R1cGxlMCA9ICgpXG5cbmxldCB0eXBlcmVwX29mX2ludDYzLCB0eXBlbmFtZV9vZl9pbnQ2MyA9XG4gIGxldCB0eXBlcmVwX2FuZF90eXBlbmFtZV9vZl9pbnQ2M19yZXByXG4gICAgOiB0eXBlIGEgYi4gKGEsIGIpIEJhc2UuSW50NjMuUHJpdmF0ZS5SZXByLnQgLT4gYSBUeXBlcmVwLnQgKiBhIFR5cGVuYW1lLnRcbiAgICA9IGZ1bmN0aW9uXG4gICAgICB8IEJhc2UuSW50NjMuUHJpdmF0ZS5SZXByLkludCAtPiB0eXBlcmVwX29mX2ludCwgdHlwZW5hbWVfb2ZfaW50XG4gICAgICB8IEJhc2UuSW50NjMuUHJpdmF0ZS5SZXByLkludDY0IC0+IHR5cGVyZXBfb2ZfaW50NjQsIHR5cGVuYW1lX29mX2ludDY0XG4gIGluXG4gIHR5cGVyZXBfYW5kX3R5cGVuYW1lX29mX2ludDYzX3JlcHIgQmFzZS5JbnQ2My5Qcml2YXRlLnJlcHJcbjs7XG4iLCIoKiB1c2luZyB0aGUgaGFzaF92YXJpYW50IG9mIHBhX3R5cGVfY29udiBhdCBjb21waWxlIHRpbWUgKilcbmxldCByZXByX29mX3BvbHlfdmFyaWFudCA6IFs+IF0gLT4gaW50ID1cbiAgZnVuIHZhcmlhbnQgLT5cbiAgbGV0IG9iaiA9IE9iai5yZXByIHZhcmlhbnQgaW5cbiAgaWYgT2JqLmlzX2ludCBvYmpcbiAgdGhlbiBPYmoub2JqIG9ialxuICBlbHNlIChcbiAgICBsZXQgc2l6ZSA9IE9iai5zaXplIG9iaiBpblxuICAgIGFzc2VydCAoc2l6ZSA9IDIpO1xuICAgIGxldCByZXByID0gT2JqLmZpZWxkIG9iaiAwIGluXG4gICAgYXNzZXJ0IChPYmouaXNfaW50IHJlcHIpO1xuICAgIE9iai5vYmogcmVwcilcbjs7XG5cbmxldCBoYXNoX3ZhcmlhbnQgcyA9XG4gIGxldCBhY2N1ID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICBhY2N1IDo9ICgyMjMgKiAhYWNjdSkgKyBDaGFyLmNvZGUgcy5baV1cbiAgZG9uZTtcbiAgKCogcmVkdWNlIHRvIDMxIGJpdHMgKilcbiAgYWNjdSA6PSAhYWNjdSBsYW5kICgoMSBsc2wgMzEpIC0gMSk7XG4gICgqIG1ha2UgaXQgc2lnbmVkIGZvciA2NCBiaXRzIGFyY2hpdGVjdHVyZXMgKilcbiAgaWYgIWFjY3UgPiAweDNGRkZGRkZGIHRoZW4gIWFjY3UgLSAoMSBsc2wgMzEpIGVsc2UgIWFjY3Vcbjs7XG5cbigqIGEgZmV3IHVuaXQgdGVzdHMgb2YgY2FzZXMgdGhhdCBoYXZlIHRyaWdnZXJlZCBkaWZmcyBpbiB0aGUgcGFzdCBvZiB0aGlzXG4gICBsaWIgKilcbmxldCAoKSA9IGFzc2VydCAocmVwcl9vZl9wb2x5X3ZhcmlhbnQgYExhdGVuY3lfc3RhdHMgPSBoYXNoX3ZhcmlhbnQgXCJMYXRlbmN5X3N0YXRzXCIpXG5sZXQgKCkgPSBhc3NlcnQgKHJlcHJfb2ZfcG9seV92YXJpYW50IGB6ZXJvID0gaGFzaF92YXJpYW50IFwiemVyb1wiKVxubGV0IGRvdWJsZV9hcnJheV92YWx1ZSA9IE9iai5tYWdpYyAwLlxubGV0IGhhc19kb3VibGVfYXJyYXlfdGFnIGEgPSBPYmouZG91YmxlX2FycmF5X3RhZyA9IE9iai50YWcgKE9iai5yZXByIGEpXG5cbmxldCAoKSA9XG4gIGxldCBtb2R1bGUgTSA9IHN0cnVjdFxuICAgIHR5cGUgZG91YmxlID1cbiAgICAgIHsgYSA6IGZsb2F0XG4gICAgICA7IGIgOiBmbG9hdFxuICAgICAgfVxuXG4gICAgdHlwZSBzaW1wbGUgPVxuICAgICAgeyBjIDogZmxvYXRcbiAgICAgIDsgZCA6IGludFxuICAgICAgfVxuXG4gICAgbGV0IGRvdWJsZSA9IHsgYSA9IGRvdWJsZV9hcnJheV92YWx1ZTsgYiA9IGRvdWJsZV9hcnJheV92YWx1ZSB9XG4gICAgbGV0IHNpbXBsZSA9IHsgYyA9IGRvdWJsZV9hcnJheV92YWx1ZTsgZCA9IGRvdWJsZV9hcnJheV92YWx1ZSB9XG4gIGVuZFxuICBpblxuICBhc3NlcnQgKGhhc19kb3VibGVfYXJyYXlfdGFnIE0uZG91YmxlKTtcbiAgYXNzZXJ0IChub3QgKGhhc19kb3VibGVfYXJyYXlfdGFnIE0uc2ltcGxlKSlcbjs7XG4iLCJtb2R1bGUgTSAoWCA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuICBlbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIGNvbXB1dGUgOiB0IFgudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIFgudCAtPiAnYSB0IFgudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIFgudCAtPiAnYiBYLnQgLT4gKCdhLCAnYikgdCBYLnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlMzIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBYLnQgLT4gJ2IgWC50IC0+ICdjIFgudCAtPiAoJ2EsICdiLCAnYykgdCBYLnRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzQgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TNCB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0IDo9ICgnYSwgJ2IsICdjLCAnZCkgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBYLnQgLT4gJ2IgWC50IC0+ICdjIFgudCAtPiAnZCBYLnQgLT4gKCdhLCAnYiwgJ2MsICdkKSB0IFgudFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNSA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TNSB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCA6PSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgWC50XG4gICAgICAtPiAnYiBYLnRcbiAgICAgIC0+ICdjIFgudFxuICAgICAgLT4gJ2QgWC50XG4gICAgICAtPiAnZSBYLnRcbiAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHQgWC50XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBNIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29tcHV0YXRpb24gPSAnYSB0XG4gICAgICB0eXBlICdhIHQgPSAnYSBjb21wdXRhdGlvblxuICAgIGVuZClcbmVuZFxuIiwib3BlbiBTdGRfaW50ZXJuYWxcbm1vZHVsZSBWYXJpYW50X2FuZF9yZWNvcmRfaW50ZiA9IFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmXG5cbm1vZHVsZSBIZWxwZXIgKEEgOiBWYXJpYW50X2FuZF9yZWNvcmRfaW50Zi5TKSAoQiA6IFZhcmlhbnRfYW5kX3JlY29yZF9pbnRmLlMpID0gc3RydWN0XG4gIHR5cGUgbWFwID0geyBtYXAgOiAnYS4gJ2EgQS50IC0+ICdhIEIudCB9XG5cbiAgbGV0IG1hcF92YXJpYW50ICh0eXBlIHZhcmlhbnQpIHsgbWFwIH0gKHZhcmlhbnQgOiB2YXJpYW50IEEuVmFyaWFudC50KSA9XG4gICAgbGV0IG1hcF9jcmVhdGUgPSBmdW5jdGlvblxuICAgICAgfCBBLlRhZy5BcmdzIGZjdCAtPiBCLlRhZ19pbnRlcm5hbC5BcmdzIGZjdFxuICAgICAgfCBBLlRhZy5Db25zdCBrIC0+IEIuVGFnX2ludGVybmFsLkNvbnN0IGtcbiAgICBpblxuICAgIGxldCBtYXBfdGFnIHRhZyA9XG4gICAgICBtYXRjaCB0YWcgd2l0aFxuICAgICAgfCBBLlZhcmlhbnQuVGFnIHRhZyAtPlxuICAgICAgICBsZXQgbGFiZWwgPSBBLlRhZy5sYWJlbCB0YWcgaW5cbiAgICAgICAgbGV0IHJlcCA9IG1hcCAoQS5UYWcudHJhdmVyc2UgdGFnKSBpblxuICAgICAgICBsZXQgYXJpdHkgPSBBLlRhZy5hcml0eSB0YWcgaW5cbiAgICAgICAgbGV0IGFyZ3NfbGFiZWxzID0gQS5UYWcuYXJnc19sYWJlbHMgdGFnIGluXG4gICAgICAgIGxldCBpbmRleCA9IEEuVGFnLmluZGV4IHRhZyBpblxuICAgICAgICBsZXQgb2NhbWxfcmVwciA9IEEuVGFnLm9jYW1sX3JlcHIgdGFnIGluXG4gICAgICAgIGxldCB0eWlkID0gQS5UYWcudHlpZCB0YWcgaW5cbiAgICAgICAgbGV0IGNyZWF0ZSA9IG1hcF9jcmVhdGUgKEEuVGFnLmNyZWF0ZSB0YWcpIGluXG4gICAgICAgIEIuVmFyaWFudF9pbnRlcm5hbC5UYWdcbiAgICAgICAgICAoQi5UYWcuaW50ZXJuYWxfdXNlX29ubHlcbiAgICAgICAgICAgICB7IEIuVGFnX2ludGVybmFsLmxhYmVsXG4gICAgICAgICAgICAgOyByZXBcbiAgICAgICAgICAgICA7IGFyaXR5XG4gICAgICAgICAgICAgOyBhcmdzX2xhYmVsc1xuICAgICAgICAgICAgIDsgaW5kZXhcbiAgICAgICAgICAgICA7IG9jYW1sX3JlcHJcbiAgICAgICAgICAgICA7IHR5aWRcbiAgICAgICAgICAgICA7IGNyZWF0ZVxuICAgICAgICAgICAgIH0pXG4gICAgaW5cbiAgICBsZXQgdHlwZW5hbWUgPSBBLlZhcmlhbnQudHlwZW5hbWVfb2ZfdCB2YXJpYW50IGluXG4gICAgbGV0IHBvbHltb3JwaGljID0gQS5WYXJpYW50LmlzX3BvbHltb3JwaGljIHZhcmlhbnQgaW5cbiAgICBsZXQgdGFncyA9XG4gICAgICBBcnJheS5pbml0IChBLlZhcmlhbnQubGVuZ3RoIHZhcmlhbnQpIChmdW4gaW5kZXggLT5cbiAgICAgICAgbWFwX3RhZyAoQS5WYXJpYW50LnRhZyB2YXJpYW50IGluZGV4KSlcbiAgICBpblxuICAgIGxldCB2YWx1ZSAoYSA6IHZhcmlhbnQpID1cbiAgICAgIG1hdGNoIEEuVmFyaWFudC52YWx1ZSB2YXJpYW50IGEgd2l0aFxuICAgICAgfCBBLlZhcmlhbnQuVmFsdWUgKGF0YWcsIGEpIC0+XG4gICAgICAgIChmdW4gKHR5cGUgYXJncykgKGF0YWcgOiAodmFyaWFudCwgYXJncykgQS5UYWcudCkgKGEgOiBhcmdzKSAtPlxuICAgICAgICAgICBsZXQgKEIuVmFyaWFudF9pbnRlcm5hbC5UYWcgYnRhZykgPSB0YWdzLihBLlRhZy5pbmRleCBhdGFnKSBpblxuICAgICAgICAgICAoZnVuICh0eXBlIGV4KSAoYnRhZyA6ICh2YXJpYW50LCBleCkgQi5UYWcudCkgLT5cbiAgICAgICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9XG4gICAgICAgICAgICAgICAgVHlwZW5hbWUuc2FtZV93aXRuZXNzX2V4biAoQS5UYWcudHlpZCBhdGFnKSAoQi5UYWcudHlpZCBidGFnKVxuICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICBsZXQgYnRhZyA9IChidGFnIDogKHZhcmlhbnQsIGFyZ3MpIEIuVGFnLnQpIGluXG4gICAgICAgICAgICAgIEIuVmFyaWFudF9pbnRlcm5hbC5WYWx1ZSAoYnRhZywgYSkpXG4gICAgICAgICAgICAgYnRhZylcbiAgICAgICAgICBhdGFnXG4gICAgICAgICAgYVxuICAgIGluXG4gICAgQi5WYXJpYW50LmludGVybmFsX3VzZV9vbmx5IHsgQi5WYXJpYW50X2ludGVybmFsLnR5cGVuYW1lOyB0YWdzOyBwb2x5bW9ycGhpYzsgdmFsdWUgfVxuICA7O1xuXG4gIGxldCBtYXBfcmVjb3JkICh0eXBlIHJlY29yZCkgeyBtYXAgfSAocmVjb3JkIDogcmVjb3JkIEEuUmVjb3JkLnQpID1cbiAgICBsZXQgbWFwX2ZpZWxkIGZpZWxkID1cbiAgICAgIG1hdGNoIGZpZWxkIHdpdGhcbiAgICAgIHwgQS5SZWNvcmQuRmllbGQgZmllbGQgLT5cbiAgICAgICAgbGV0IGxhYmVsID0gQS5GaWVsZC5sYWJlbCBmaWVsZCBpblxuICAgICAgICBsZXQgcmVwID0gbWFwIChBLkZpZWxkLnRyYXZlcnNlIGZpZWxkKSBpblxuICAgICAgICBsZXQgaW5kZXggPSBBLkZpZWxkLmluZGV4IGZpZWxkIGluXG4gICAgICAgIGxldCBpc19tdXRhYmxlID0gQS5GaWVsZC5pc19tdXRhYmxlIGZpZWxkIGluXG4gICAgICAgIGxldCB0eWlkID0gQS5GaWVsZC50eWlkIGZpZWxkIGluXG4gICAgICAgIGxldCBnZXQgPSBBLkZpZWxkLmdldCBmaWVsZCBpblxuICAgICAgICBCLlJlY29yZF9pbnRlcm5hbC5GaWVsZFxuICAgICAgICAgIChCLkZpZWxkLmludGVybmFsX3VzZV9vbmx5XG4gICAgICAgICAgICAgeyBCLkZpZWxkX2ludGVybmFsLmxhYmVsOyByZXA7IGluZGV4OyBpc19tdXRhYmxlOyB0eWlkOyBnZXQgfSlcbiAgICBpblxuICAgIGxldCB0eXBlbmFtZSA9IEEuUmVjb3JkLnR5cGVuYW1lX29mX3QgcmVjb3JkIGluXG4gICAgbGV0IGhhc19kb3VibGVfYXJyYXlfdGFnID0gQS5SZWNvcmQuaGFzX2RvdWJsZV9hcnJheV90YWcgcmVjb3JkIGluXG4gICAgbGV0IGZpZWxkcyA9XG4gICAgICBBcnJheS5pbml0IChBLlJlY29yZC5sZW5ndGggcmVjb3JkKSAoZnVuIGluZGV4IC0+XG4gICAgICAgIG1hcF9maWVsZCAoQS5SZWNvcmQuZmllbGQgcmVjb3JkIGluZGV4KSlcbiAgICBpblxuICAgIGxldCBjcmVhdGUgeyBCLlJlY29yZF9pbnRlcm5hbC5nZXQgfSA9XG4gICAgICBsZXQgZ2V0ICh0eXBlIGEpIChhZmllbGQgOiAoXywgYSkgQS5GaWVsZC50KSA9XG4gICAgICAgIG1hdGNoIGZpZWxkcy4oQS5GaWVsZC5pbmRleCBhZmllbGQpIHdpdGhcbiAgICAgICAgfCBCLlJlY29yZF9pbnRlcm5hbC5GaWVsZCBiZmllbGQgLT5cbiAgICAgICAgICAoZnVuICh0eXBlIGV4KSAoYmZpZWxkIDogKHJlY29yZCwgZXgpIEIuRmllbGQudCkgLT5cbiAgICAgICAgICAgICBsZXQgVHlwZV9lcXVhbC5UID1cbiAgICAgICAgICAgICAgIFR5cGVuYW1lLnNhbWVfd2l0bmVzc19leG4gKEEuRmllbGQudHlpZCBhZmllbGQpIChCLkZpZWxkLnR5aWQgYmZpZWxkKVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgbGV0IGJmaWVsZCA9IChiZmllbGQgOiAocmVjb3JkLCBhKSBCLkZpZWxkLnQpIGluXG4gICAgICAgICAgICAgZ2V0IGJmaWVsZClcbiAgICAgICAgICAgIGJmaWVsZFxuICAgICAgaW5cbiAgICAgIEEuUmVjb3JkLmNyZWF0ZSByZWNvcmQgeyBBLlJlY29yZC5nZXQgfVxuICAgIGluXG4gICAgQi5SZWNvcmQuaW50ZXJuYWxfdXNlX29ubHlcbiAgICAgIHsgQi5SZWNvcmRfaW50ZXJuYWwudHlwZW5hbWU7IGZpZWxkczsgaGFzX2RvdWJsZV9hcnJheV90YWc7IGNyZWF0ZSB9XG4gIDs7XG5lbmRcblxubW9kdWxlIHR5cGUgTmFtZWQgPSBzaWdcbiAgdHlwZSAnYSBjb21wdXRhdGlvblxuXG4gIG1vZHVsZSBDb250ZXh0IDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgY3JlYXRlIDogdW5pdCAtPiB0XG4gIGVuZFxuXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBpbml0IDogQ29udGV4dC50IC0+ICdhIFR5cGVuYW1lLnQgLT4gJ2EgdFxuICB2YWwgZ2V0X3dpcF9jb21wdXRhdGlvbiA6ICdhIHQgLT4gJ2EgY29tcHV0YXRpb25cbiAgdmFsIHNldF9maW5hbF9jb21wdXRhdGlvbiA6ICdhIHQgLT4gJ2EgY29tcHV0YXRpb24gLT4gJ2EgY29tcHV0YXRpb25cbiAgdmFsIHNoYXJlIDogXyBUeXBlcmVwLnQgLT4gYm9vbFxuZW5kXG5cbm1vZHVsZSB0eXBlIENvbXB1dGF0aW9uID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIGluY2x1ZGUgVmFyaWFudF9hbmRfcmVjb3JkX2ludGYuUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgdmFsIGludCA6IGludCB0XG4gIHZhbCBpbnQzMiA6IGludDMyIHRcbiAgdmFsIGludDY0IDogaW50NjQgdFxuICB2YWwgbmF0aXZlaW50IDogbmF0aXZlaW50IHRcbiAgdmFsIGNoYXIgOiBjaGFyIHRcbiAgdmFsIGZsb2F0IDogZmxvYXQgdFxuICB2YWwgc3RyaW5nIDogc3RyaW5nIHRcbiAgdmFsIGJ5dGVzIDogYnl0ZXMgdFxuICB2YWwgYm9vbCA6IGJvb2wgdFxuICB2YWwgdW5pdCA6IHVuaXQgdFxuICB2YWwgb3B0aW9uIDogJ2EgdCAtPiAnYSBvcHRpb24gdFxuICB2YWwgbGlzdCA6ICdhIHQgLT4gJ2EgbGlzdCB0XG4gIHZhbCBhcnJheSA6ICdhIHQgLT4gJ2EgYXJyYXkgdFxuICB2YWwgbGF6eV90IDogJ2EgdCAtPiAnYSBsYXp5X3QgdFxuICB2YWwgcmVmXyA6ICdhIHQgLT4gJ2EgcmVmIHRcbiAgdmFsIGZ1bmN0aW9uXyA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EgLT4gJ2IpIHRcbiAgdmFsIHR1cGxlMiA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EgKiAnYikgdFxuICB2YWwgdHVwbGUzIDogJ2EgdCAtPiAnYiB0IC0+ICdjIHQgLT4gKCdhICogJ2IgKiAnYykgdFxuICB2YWwgdHVwbGU0IDogJ2EgdCAtPiAnYiB0IC0+ICdjIHQgLT4gJ2QgdCAtPiAoJ2EgKiAnYiAqICdjICogJ2QpIHRcbiAgdmFsIHR1cGxlNSA6ICdhIHQgLT4gJ2IgdCAtPiAnYyB0IC0+ICdkIHQgLT4gJ2UgdCAtPiAoJ2EgKiAnYiAqICdjICogJ2QgKiAnZSkgdFxuICB2YWwgcmVjb3JkIDogJ2EgUmVjb3JkLnQgLT4gJ2EgdFxuICB2YWwgdmFyaWFudCA6ICdhIFZhcmlhbnQudCAtPiAnYSB0XG5cbiAgbW9kdWxlIE5hbWVkIDogTmFtZWQgd2l0aCB0eXBlICdhIGNvbXB1dGF0aW9uIDo9ICdhIHRcbmVuZFxuXG4oKiBzcGVjaWFsIGZ1bmN0b3IgYXBwbGljYXRpb24gZm9yIGNvbXB1dGF0aW9uIGFzIGNsb3N1cmUgb2YgdGhlIGZvcm0gW2EgLT4gYl0gKilcbm1vZHVsZSBNYWtlX25hbWVkX2Zvcl9jbG9zdXJlIChYIDogc2lnXG4gICAgdHlwZSAnYSBpbnB1dFxuICAgIHR5cGUgJ2Egb3V0cHV0XG4gICAgdHlwZSAnYSB0ID0gJ2EgaW5wdXQgLT4gJ2Egb3V0cHV0XG4gIGVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBDb250ZXh0ID0gc3RydWN0XG4gICAgdHlwZSB0ID0gdW5pdFxuXG4gICAgbGV0IGNyZWF0ZSA9IGlnbm9yZVxuICBlbmRcblxuICB0eXBlICdhIHQgPVxuICAgIHsgcnVudGltZV9kZXJlZmVyZW5jZSA6ICdhIFgudFxuICAgIDsgcnVudGltZV9yZWZlcmVuY2UgOiAnYSBYLnQgcmVmXG4gICAgOyBjb21waWxldGltZV9kZXJlZmVyZW5jZSA6ICdhIFgudCBvcHRpb24gcmVmXG4gICAgfVxuXG4gIGV4Y2VwdGlvbiBVbmRlZmluZWQgb2Ygc3RyaW5nXG5cbiAgbGV0IGluaXQgKCkgbmFtZSA9XG4gICAgbGV0IHBhdGggPSBUeXBlbmFtZS5VaWQubmFtZSAoVHlwZW5hbWUudWlkIG5hbWUpIGluXG4gICAgbGV0IHIgPSByZWYgKGZ1biBfIC0+IHJhaXNlIChVbmRlZmluZWQgcGF0aCkpIGluXG4gICAgeyBydW50aW1lX2RlcmVmZXJlbmNlID0gKGZ1biBpbnB1dCAtPiAhciBpbnB1dClcbiAgICA7IHJ1bnRpbWVfcmVmZXJlbmNlID0gclxuICAgIDsgY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgPSByZWYgTm9uZVxuICAgIH1cbiAgOztcblxuICBsZXQgZ2V0X3dpcF9jb21wdXRhdGlvbiBzaGFyZWQgPVxuICAgIG1hdGNoIHNoYXJlZC5jb21waWxldGltZV9kZXJlZmVyZW5jZS5jb250ZW50cyB3aXRoXG4gICAgfCBTb21lIGNsb3MgLT4gY2xvc1xuICAgIHwgTm9uZSAtPiBzaGFyZWQucnVudGltZV9kZXJlZmVyZW5jZVxuICA7O1xuXG4gIGxldCBzZXRfZmluYWxfY29tcHV0YXRpb24gc2hhcmVkIGNvbXB1dGF0aW9uID1cbiAgICBsZXQgY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgPSBzaGFyZWQuY29tcGlsZXRpbWVfZGVyZWZlcmVuY2UgaW5cbiAgICBtYXRjaCBjb21waWxldGltZV9kZXJlZmVyZW5jZS5jb250ZW50cyB3aXRoXG4gICAgfCBTb21lIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBOb25lIC0+XG4gICAgICBpZiBCYXNlLnBoeXNfZXF1YWwgc2hhcmVkLnJ1bnRpbWVfZGVyZWZlcmVuY2UgY29tcHV0YXRpb24gdGhlbiBhc3NlcnQgZmFsc2U7XG4gICAgICBjb21waWxldGltZV9kZXJlZmVyZW5jZSA6PSBTb21lIGNvbXB1dGF0aW9uO1xuICAgICAgc2hhcmVkLnJ1bnRpbWVfcmVmZXJlbmNlIDo9IGNvbXB1dGF0aW9uO1xuICAgICAgY29tcHV0YXRpb25cbiAgOztcblxuICBsZXQgc2hhcmUgXyA9IHRydWVcbmVuZFxuXG5tb2R1bGUgSWRlbnQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IG5hbWUgOiBzdHJpbmdcbiAgICA7IGltcGxlbWVudHMgOiBUeXBlbmFtZS5VaWQudCAtPiBib29sXG4gICAgfVxuXG4gIGV4Y2VwdGlvbiBCcm9rZW5fZGVwZW5kZW5jeSBvZiBzdHJpbmdcblxuICBsZXQgY2hlY2tfZGVwZW5kZW5jaWVzIG5hbWUgcmVxdWlyZWQgPVxuICAgIG1hdGNoIHJlcXVpcmVkIHdpdGhcbiAgICB8IFtdIC0+IGZ1biBfIC0+ICgpXG4gICAgfCBfIC0+XG4gICAgICBmdW4gdWlkIC0+XG4gICAgICAgIExpc3QuaXRlclxuICAgICAgICAgIChmdW4geyBuYW1lID0gbmFtZSc7IGltcGxlbWVudHMgfSAtPlxuICAgICAgICAgICAgIGlmIG5vdCAoaW1wbGVtZW50cyB1aWQpXG4gICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAoKiBzb21ldGhpbmcgaXMgd3Jvbmcgd2l0aCB0aGUgc2V0IHVwLCB0aGlzIGlzIGFuIGVycm9yIGR1cmluZyB0aGVcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uIG9mIHRoZSBwcm9ncmFtLCB3ZSByYXRoZXIgZmFpbCB3aXRoIGEgaHVtYW5cbiAgICAgICAgICAgICAgICAgIHJlYWRhYmxlIG91dHB1dCAqKVxuICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgICBQcmludGYuc3ByaW50ZlxuICAgICAgICAgICAgICAgICAgIFwiVHlwZV9nZW5lcmljICVTIHJlcXVpcmVzICVTIGZvciB1aWQgJVNcXG5cIlxuICAgICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgICAgICAgICBuYW1lJ1xuICAgICAgICAgICAgICAgICAgIChUeXBlbmFtZS5VaWQubmFtZSB1aWQpXG4gICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgcHJlcnJfZW5kbGluZSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgcmFpc2UgKEJyb2tlbl9kZXBlbmRlbmN5IG1lc3NhZ2UpKSlcbiAgICAgICAgICByZXF1aXJlZFxuICA7O1xuZW5kXG5cbigqIEV4dGVuZGluZyBhbiBleGlzdGluZyBnZW5lcmljICopXG5tb2R1bGUgdHlwZSBFeHRlbmRpbmcgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgY29tcHV0YXRpb24gPSAnYSB0XG5cbiAgdmFsIGlkZW50IDogSWRlbnQudFxuXG4gICgqIGdlbmVyaWNfaWRlbnQgKiB0eXBlbmFtZSBvciBpbmZvICopXG4gIGV4Y2VwdGlvbiBOb3RfaW1wbGVtZW50ZWQgb2Ygc3RyaW5nICogc3RyaW5nXG5cbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBjb21wdXRlIDogdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICB2YWwgY29tcHV0ZSA6ICdhIGNvbXB1dGF0aW9uIC0+ICdhIHQgY29tcHV0YXRpb25cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIGluY2x1ZGUgVHlwZXJlcGFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gICAgdmFsIGNvbXB1dGUgOiAnYSBjb21wdXRhdGlvbiAtPiAnYiBjb21wdXRhdGlvbiAtPiAoJ2EsICdiKSB0IGNvbXB1dGF0aW9uXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TMyB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcblxuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICAnYSBjb21wdXRhdGlvblxuICAgICAgLT4gJ2IgY29tcHV0YXRpb25cbiAgICAgIC0+ICdjIGNvbXB1dGF0aW9uXG4gICAgICAtPiAoJ2EsICdiLCAnYykgdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNCA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSB0XG5cbiAgICBpbmNsdWRlIFR5cGVyZXBhYmxlLlM0IHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIHQgOj0gKCdhLCAnYiwgJ2MsICdkKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgY29tcHV0YXRpb25cbiAgICAgIC0+ICdiIGNvbXB1dGF0aW9uXG4gICAgICAtPiAnYyBjb21wdXRhdGlvblxuICAgICAgLT4gJ2QgY29tcHV0YXRpb25cbiAgICAgIC0+ICgnYSwgJ2IsICdjLCAnZCkgdCBjb21wdXRhdGlvblxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTNSA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdFxuXG4gICAgaW5jbHVkZSBUeXBlcmVwYWJsZS5TNSB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSkgdCA6PSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0XG5cbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgJ2EgY29tcHV0YXRpb25cbiAgICAgIC0+ICdiIGNvbXB1dGF0aW9uXG4gICAgICAtPiAnYyBjb21wdXRhdGlvblxuICAgICAgLT4gJ2QgY29tcHV0YXRpb25cbiAgICAgIC0+ICdlIGNvbXB1dGF0aW9uXG4gICAgICAtPiAoJ2EsICdiLCAnYywgJ2QsICdlKSB0IGNvbXB1dGF0aW9uXG4gIGVuZFxuXG4gIHZhbCByZWdpc3RlcjAgOiAobW9kdWxlIFMpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMSA6IChtb2R1bGUgUzEpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMiA6IChtb2R1bGUgUzIpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyMyA6IChtb2R1bGUgUzMpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyNCA6IChtb2R1bGUgUzQpIC0+IHVuaXRcbiAgdmFsIHJlZ2lzdGVyNSA6IChtb2R1bGUgUzUpIC0+IHVuaXRcblxuICAoKiBzcGVjaWFsIGxlc3Mgc2NhcnkgdHlwZSB3aGVuIHRoZSB0eXBlIGhhcyBubyBwYXJhbWV0ZXJzICopXG4gIHZhbCByZWdpc3RlciA6ICdhIFR5cGVyZXAudCAtPiAnYSBjb21wdXRhdGlvbiAtPiB1bml0XG5cbiAgKCpcbiAgICAgRXNzZW50aWFsbHkgYmVjYXVzZSB3ZSBjYW5ub3QgdGFsayBhYm91dCBhIHZhcmlhYmxlIG9mIGtpbmQgKiAtPiBrXG4gICAgIHZhbCByZWdpc3RlcjEgOiAnYSAndCBUeXBlcmVwLnQgLT4gKCdhIGNvbXB1dGF0aW9uIC0+ICdhICd0IGNvbXB1dGF0aW9uKSAtPiB1bml0XG4gICAgIC4uLlxuICAqKVxuZW5kXG5cbigqIEltcGxlbWVudGluZyBhIG5ldyBnZW5lcmljICopXG5tb2R1bGUgdHlwZSBTX2ltcGxlbWVudGF0aW9uID0gc2lnXG4gIGluY2x1ZGUgRXh0ZW5kaW5nXG5cbiAgKCogcmFpc2UgdXNpbmcgdGhlIGN1cnJlbnQgaWRlbnQgKilcbiAgdmFsIHJhaXNlX25vdF9pbXBsZW1lbnRlZCA6IHN0cmluZyAtPiAnYVxuXG4gIHR5cGUgaW1wbGVtZW50YXRpb24gPSB7IGdlbmVyaWMgOiAnYS4gJ2EgVHlwZXJlcC50IC0+ICdhIGNvbXB1dGF0aW9uIH1cblxuICAoKlxuICAgICBTdGFuZGFyZCBjYXNlLCBmaW5kIGEgZXh0ZW5kZWRfaW1wbGVtZW50YXRpb24sIG9yIGxvb2sgaW4gdGhlIGNvbnRlbnRcbiAgKilcbiAgdmFsIF91c2luZ19leHRlbmRlZF9pbXBsZW1lbnRhdGlvblxuICAgIDogIGltcGxlbWVudGF0aW9uXG4gICAgLT4gJ2EgVHlwZXJlcC5OYW1lZC50XG4gICAgLT4gJ2EgVHlwZXJlcC50IGxhenlfdCBvcHRpb25cbiAgICAtPiAnYSBjb21wdXRhdGlvblxuXG4gICgqXG4gICAgIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSBtb3JlIGNvbnRyb2wgb24gd2hhdCB5b3Ugd2FudCB0byBkb1xuICAqKVxuICB2YWwgZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvblxuICAgIDogIGltcGxlbWVudGF0aW9uXG4gICAgLT4gJ2EgVHlwZXJlcC5OYW1lZC50XG4gICAgLT4gJ2EgY29tcHV0YXRpb24gb3B0aW9uXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICBpbmNsdWRlIEV4dGVuZGluZ1xuXG4gIHZhbCBvZl90eXBlcmVwIDogJ2EgVHlwZXJlcC50IC0+IFsgYGdlbmVyaWMgb2YgJ2EgY29tcHV0YXRpb24gXVxuXG4gIG1vZHVsZSBDb21wdXRhdGlvbiA6IENvbXB1dGF0aW9uIHdpdGggdHlwZSAnYSB0ID0gJ2EgdFxuZW5kXG5cbm1vZHVsZSBNYWtlX1NfaW1wbGVtZW50YXRpb24gKFggOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBuYW1lIDogc3RyaW5nXG4gICAgdmFsIHJlcXVpcmVkIDogSWRlbnQudCBsaXN0XG4gIGVuZCkgOiBTX2ltcGxlbWVudGF0aW9uIHdpdGggdHlwZSAnYSB0ID0gJ2EgWC50ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIFgudFxuICB0eXBlICdhIGNvbXB1dGF0aW9uID0gJ2EgdFxuXG4gIGluY2x1ZGUgVHlwZV9nZW5lcmljX2ludGYuTSAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYSBjb21wdXRhdGlvblxuICAgIGVuZClcblxuICAoKiB3ZSBkbyBub3QgdXNlIGNvcmUgc2luY2Ugd2UgYXJlIGVhcmxpZXIgaW4gdGhlIGRlcGVuZGVuY2llcyBncmFwaCAqKVxuICBtb2R1bGUgVWlkX3RhYmxlID0gc3RydWN0XG4gICAgaW5jbHVkZSBIYXNodGJsLk1ha2UgKFR5cGVuYW1lLlVpZClcblxuICAgIGxldCBmaW5kIHRhYmxlIGtleSA9XG4gICAgICBpZiBMYXp5LmlzX3ZhbCB0YWJsZVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB0YWJsZSA9IExhenkuZm9yY2UgdGFibGUgaW5cbiAgICAgICAgdHJ5IFNvbWUgKGZpbmQgdGFibGUga2V5KSB3aXRoXG4gICAgICAgIHwgQmFzZS5Ob3RfZm91bmRfcyBfIHwgQ2FtbC5Ob3RfZm91bmQgLT4gTm9uZSlcbiAgICAgIGVsc2UgTm9uZVxuICAgIDs7XG5cbiAgICBsZXQgY2hlY2tfZGVwZW5kZW5jaWVzID0gSWRlbnQuY2hlY2tfZGVwZW5kZW5jaWVzIFgubmFtZSBYLnJlcXVpcmVkXG5cbiAgICBsZXQgcmVwbGFjZSB0YWJsZSBrZXkgdmFsdWUgPVxuICAgICAgY2hlY2tfZGVwZW5kZW5jaWVzIGtleTtcbiAgICAgIHJlcGxhY2UgKExhenkuZm9yY2UgdGFibGUpIGtleSB2YWx1ZVxuICAgIDs7XG5cbiAgICBsZXQgbWVtIHRhYmxlIGtleSA9XG4gICAgICBpZiBMYXp5LmlzX3ZhbCB0YWJsZVxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB0YWJsZSA9IExhenkuZm9yY2UgdGFibGUgaW5cbiAgICAgICAgbWVtIHRhYmxlIGtleSlcbiAgICAgIGVsc2UgZmFsc2VcbiAgICA7O1xuICBlbmRcblxuICBsZXQgc2l6ZSA9IDI1NlxuICBsZXQgdGFibGUwID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGUxID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGUyID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGUzID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGU0ID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuICBsZXQgdGFibGU1ID0gbGF6eSAoVWlkX3RhYmxlLmNyZWF0ZSBzaXplKVxuXG4gIGxldCBpc19yZWdpc3RlcmVkIHVpZCA9XG4gICAgVWlkX3RhYmxlLm1lbSB0YWJsZTAgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTEgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTIgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTMgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTQgdWlkXG4gICAgfHwgVWlkX3RhYmxlLm1lbSB0YWJsZTUgdWlkXG4gIDs7XG5cbiAgbGV0IGlkZW50ID0geyBJZGVudC5uYW1lID0gWC5uYW1lOyBpbXBsZW1lbnRzID0gaXNfcmVnaXN0ZXJlZCB9XG5cbiAgbW9kdWxlIEZpbmQwIChUIDogVHlwZXJlcC5OYW1lZC5UMCkgOiBzaWdcbiAgICB2YWwgY29tcHV0ZSA6IHVuaXQgLT4gVC5uYW1lZCBjb21wdXRhdGlvbiBvcHRpb25cbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGNvbXB1dGUgKCkgPVxuICAgICAgbWF0Y2ggVWlkX3RhYmxlLmZpbmQgdGFibGUwIChUeXBlbmFtZS51aWQgVC50eXBlbmFtZV9vZl90KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHJlcCAtPlxuICAgICAgICBsZXQgbW9kdWxlIFMgPSAodmFsIHJlcCA6IFMpIGluXG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZW5hbWUuc2FtZV93aXRuZXNzX2V4biBTLnR5cGVuYW1lX29mX3QgVC50eXBlbmFtZV9vZl9uYW1lZCBpblxuICAgICAgICBsZXQgbW9kdWxlIEwgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuTGlmdCAoc3RydWN0XG4gICAgICAgICAgICB0eXBlICdhIHQgPSAnYSBjb21wdXRhdGlvblxuICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgU29tZSAoVHlwZV9lcXVhbC5jb252IChMLmxpZnQgd2l0bmVzcykgUy5jb21wdXRlKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBGaW5kMSAoVCA6IFR5cGVyZXAuTmFtZWQuVDEpIDogc2lnXG4gICAgdmFsIGNvbXB1dGUgOiB1bml0IC0+IChULmEgY29tcHV0YXRpb24gLT4gVC5hIFQubmFtZWQgY29tcHV0YXRpb24pIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTEgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUzEgPSAodmFsIHJlcCA6IFMxKSBpblxuICAgICAgICBsZXQgbW9kdWxlIENvbnYgPVxuICAgICAgICAgIFR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG5fMVxuICAgICAgICAgICAgKFMxKVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlICdhIHQgPSAnYSBULm5hbWVkXG5cbiAgICAgICAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSBULnR5cGVuYW1lX29mX25hbWVkXG4gICAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBtb2R1bGUgTCA9XG4gICAgICAgICAgVHlwZV9lcXVhbC5MaWZ0IChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgJ2EgdCA9IFQuYSBjb21wdXRhdGlvbiAtPiAnYSBjb21wdXRhdGlvblxuICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgU29tZSAoVHlwZV9lcXVhbC5jb252IChMLmxpZnQgQ29udi4od2l0bmVzcy5lcSkpIFMxLmNvbXB1dGUpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIEZpbmQyIChUIDogVHlwZXJlcC5OYW1lZC5UMikgOiBzaWdcbiAgICB2YWwgY29tcHV0ZVxuICAgICAgOiAgdW5pdFxuICAgICAgLT4gKFQuYSBjb21wdXRhdGlvbiAtPiBULmIgY29tcHV0YXRpb24gLT4gKFQuYSwgVC5iKSBULm5hbWVkIGNvbXB1dGF0aW9uKSBvcHRpb25cbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGNvbXB1dGUgKCkgPVxuICAgICAgbWF0Y2ggVWlkX3RhYmxlLmZpbmQgdGFibGUyIChUeXBlbmFtZS51aWQgVC50eXBlbmFtZV9vZl90KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHJlcCAtPlxuICAgICAgICBsZXQgbW9kdWxlIFMyID0gKHZhbCByZXAgOiBTMikgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBDb252ID1cbiAgICAgICAgICBUeXBlbmFtZS5TYW1lX3dpdG5lc3NfZXhuXzJcbiAgICAgICAgICAgIChTMilcbiAgICAgICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgVC5uYW1lZFxuXG4gICAgICAgICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gVC50eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbW9kdWxlIEwgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuTGlmdCAoc3RydWN0XG4gICAgICAgICAgICB0eXBlICdhIHQgPSBULmEgY29tcHV0YXRpb24gLT4gVC5iIGNvbXB1dGF0aW9uIC0+ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCBDb252Lih3aXRuZXNzLmVxKSkgUzIuY29tcHV0ZSlcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgRmluZDMgKFQgOiBUeXBlcmVwLk5hbWVkLlQzKSA6IHNpZ1xuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICB1bml0XG4gICAgICAtPiAoVC5hIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5iIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5jIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gKFQuYSwgVC5iLCBULmMpIFQubmFtZWQgY29tcHV0YXRpb24pXG4gICAgICAgICAgIG9wdGlvblxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcHV0ZSAoKSA9XG4gICAgICBtYXRjaCBVaWRfdGFibGUuZmluZCB0YWJsZTMgKFR5cGVuYW1lLnVpZCBULnR5cGVuYW1lX29mX3QpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgcmVwIC0+XG4gICAgICAgIGxldCBtb2R1bGUgUzMgPSAodmFsIHJlcCA6IFMzKSBpblxuICAgICAgICBsZXQgbW9kdWxlIENvbnYgPVxuICAgICAgICAgIFR5cGVuYW1lLlNhbWVfd2l0bmVzc19leG5fM1xuICAgICAgICAgICAgKFMzKVxuICAgICAgICAgICAgKHN0cnVjdFxuICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIFQubmFtZWRcblxuICAgICAgICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IFQudHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBMID1cbiAgICAgICAgICBUeXBlX2VxdWFsLkxpZnQgKHN0cnVjdFxuICAgICAgICAgICAgdHlwZSAnYSB0ID1cbiAgICAgICAgICAgICAgVC5hIGNvbXB1dGF0aW9uIC0+IFQuYiBjb21wdXRhdGlvbiAtPiBULmMgY29tcHV0YXRpb24gLT4gJ2EgY29tcHV0YXRpb25cbiAgICAgICAgICBlbmQpXG4gICAgICAgIGluXG4gICAgICAgIFNvbWUgKFR5cGVfZXF1YWwuY29udiAoTC5saWZ0IENvbnYuKHdpdG5lc3MuZXEpKSBTMy5jb21wdXRlKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBGaW5kNCAoVCA6IFR5cGVyZXAuTmFtZWQuVDQpIDogc2lnXG4gICAgdmFsIGNvbXB1dGVcbiAgICAgIDogIHVuaXRcbiAgICAgIC0+IChULmEgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmIgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmMgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiBULmQgY29tcHV0YXRpb25cbiAgICAgICAgICAtPiAoVC5hLCBULmIsIFQuYywgVC5kKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgICBvcHRpb25cbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGNvbXB1dGUgKCkgPVxuICAgICAgbWF0Y2ggVWlkX3RhYmxlLmZpbmQgdGFibGU0IChUeXBlbmFtZS51aWQgVC50eXBlbmFtZV9vZl90KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHJlcCAtPlxuICAgICAgICBsZXQgbW9kdWxlIFM0ID0gKHZhbCByZXAgOiBTNCkgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBDb252ID1cbiAgICAgICAgICBUeXBlbmFtZS5TYW1lX3dpdG5lc3NfZXhuXzRcbiAgICAgICAgICAgIChTNClcbiAgICAgICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QpIHQgPSAoJ2EsICdiLCAnYywgJ2QpIFQubmFtZWRcblxuICAgICAgICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IFQudHlwZW5hbWVfb2ZfbmFtZWRcbiAgICAgICAgICAgIGVuZClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBMID1cbiAgICAgICAgICBUeXBlX2VxdWFsLkxpZnQgKHN0cnVjdFxuICAgICAgICAgICAgdHlwZSAnYSB0ID1cbiAgICAgICAgICAgICAgVC5hIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+IFQuYiBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiBULmMgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5kIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCBDb252Lih3aXRuZXNzLmVxKSkgUzQuY29tcHV0ZSlcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgRmluZDUgKFQgOiBUeXBlcmVwLk5hbWVkLlQ1KSA6IHNpZ1xuICAgIHZhbCBjb21wdXRlXG4gICAgICA6ICB1bml0XG4gICAgICAtPiAoVC5hIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5iIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5jIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5kIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gVC5lIGNvbXB1dGF0aW9uXG4gICAgICAgICAgLT4gKFQuYSwgVC5iLCBULmMsIFQuZCwgVC5lKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgICBvcHRpb25cbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGNvbXB1dGUgKCkgPVxuICAgICAgbWF0Y2ggVWlkX3RhYmxlLmZpbmQgdGFibGU1IChUeXBlbmFtZS51aWQgVC50eXBlbmFtZV9vZl90KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIHJlcCAtPlxuICAgICAgICBsZXQgbW9kdWxlIFM1ID0gKHZhbCByZXAgOiBTNSkgaW5cbiAgICAgICAgbGV0IG1vZHVsZSBDb252ID1cbiAgICAgICAgICBUeXBlbmFtZS5TYW1lX3dpdG5lc3NfZXhuXzVcbiAgICAgICAgICAgIChTNSlcbiAgICAgICAgICAgIChzdHJ1Y3RcbiAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSB0ID0gKCdhLCAnYiwgJ2MsICdkLCAnZSkgVC5uYW1lZFxuXG4gICAgICAgICAgICAgIGxldCB0eXBlbmFtZV9vZl90ID0gVC50eXBlbmFtZV9vZl9uYW1lZFxuICAgICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbW9kdWxlIEwgPVxuICAgICAgICAgIFR5cGVfZXF1YWwuTGlmdCAoc3RydWN0XG4gICAgICAgICAgICB0eXBlICdhIHQgPVxuICAgICAgICAgICAgICBULmEgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5iIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+IFQuYyBjb21wdXRhdGlvblxuICAgICAgICAgICAgICAtPiBULmQgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgLT4gVC5lIGNvbXB1dGF0aW9uXG4gICAgICAgICAgICAgIC0+ICdhIGNvbXB1dGF0aW9uXG4gICAgICAgICAgZW5kKVxuICAgICAgICBpblxuICAgICAgICBTb21lIChUeXBlX2VxdWFsLmNvbnYgKEwubGlmdCBDb252Lih3aXRuZXNzLmVxKSkgUzUuY29tcHV0ZSlcbiAgICA7O1xuICBlbmRcblxuICBsZXQgdW5pdCA9IFR5cGVuYW1lLnN0YXRpY1xuXG4gIGxldCByZWdpc3RlcjAgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTID0gKHZhbCBjb21wdXRlIDogUykgaW5cbiAgICBsZXQgdWlkID0gVHlwZW5hbWUudWlkIFMudHlwZW5hbWVfb2ZfdCBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlMCB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlcjEgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTMSA9ICh2YWwgY29tcHV0ZSA6IFMxKSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgKFMxLnR5cGVuYW1lX29mX3QgdW5pdCkgaW5cbiAgICBVaWRfdGFibGUucmVwbGFjZSB0YWJsZTEgdWlkIGNvbXB1dGVcbiAgOztcblxuICBsZXQgcmVnaXN0ZXIyIGNvbXB1dGUgPVxuICAgIGxldCBtb2R1bGUgUzIgPSAodmFsIGNvbXB1dGUgOiBTMikgaW5cbiAgICBsZXQgdWlkID0gVHlwZW5hbWUudWlkIChTMi50eXBlbmFtZV9vZl90IHVuaXQgdW5pdCkgaW5cbiAgICBVaWRfdGFibGUucmVwbGFjZSB0YWJsZTIgdWlkIGNvbXB1dGVcbiAgOztcblxuICBsZXQgcmVnaXN0ZXIzIGNvbXB1dGUgPVxuICAgIGxldCBtb2R1bGUgUzMgPSAodmFsIGNvbXB1dGUgOiBTMykgaW5cbiAgICBsZXQgdWlkID0gVHlwZW5hbWUudWlkIChTMy50eXBlbmFtZV9vZl90IHVuaXQgdW5pdCB1bml0KSBpblxuICAgIFVpZF90YWJsZS5yZXBsYWNlIHRhYmxlMyB1aWQgY29tcHV0ZVxuICA7O1xuXG4gIGxldCByZWdpc3RlcjQgY29tcHV0ZSA9XG4gICAgbGV0IG1vZHVsZSBTNCA9ICh2YWwgY29tcHV0ZSA6IFM0KSBpblxuICAgIGxldCB1aWQgPSBUeXBlbmFtZS51aWQgKFM0LnR5cGVuYW1lX29mX3QgdW5pdCB1bml0IHVuaXQgdW5pdCkgaW5cbiAgICBVaWRfdGFibGUucmVwbGFjZSB0YWJsZTQgdWlkIGNvbXB1dGVcbiAgOztcblxuICBsZXQgcmVnaXN0ZXI1IGNvbXB1dGUgPVxuICAgIGxldCBtb2R1bGUgUzUgPSAodmFsIGNvbXB1dGUgOiBTNSkgaW5cbiAgICBsZXQgdWlkID0gVHlwZW5hbWUudWlkIChTNS50eXBlbmFtZV9vZl90IHVuaXQgdW5pdCB1bml0IHVuaXQgdW5pdCkgaW5cbiAgICBVaWRfdGFibGUucmVwbGFjZSB0YWJsZTUgdWlkIGNvbXB1dGVcbiAgOztcblxuICBsZXQgcmVnaXN0ZXIgKHR5cGUgYSkgdHlwZXJlcF9vZl9hIGNvbXB1dGUgPVxuICAgIGxldCBtb2R1bGUgUyA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID0gYVxuXG4gICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IFR5cGVyZXAudHlwZW5hbWVfb2ZfdCB0eXBlcmVwX29mX2FcbiAgICAgIGxldCB0eXBlcmVwX29mX3QgPSB0eXBlcmVwX29mX2FcbiAgICAgIGxldCBjb21wdXRlID0gY29tcHV0ZVxuICAgIGVuZFxuICAgIGluXG4gICAgcmVnaXN0ZXIwIChtb2R1bGUgUyA6IFMpXG4gIDs7XG5cbiAgKCogSU1QTEVNRU5UQVRJT04gKilcblxuICB0eXBlIGltcGxlbWVudGF0aW9uID0geyBnZW5lcmljIDogJ2EuICdhIFR5cGVyZXAudCAtPiAnYSBjb21wdXRhdGlvbiB9XG5cbiAgbGV0IGZpbmRfZXh0ZW5kZWRfaW1wbGVtZW50YXRpb24gKHR5cGUgYSkgYXV4ID0gZnVuY3Rpb25cbiAgICB8IFR5cGVyZXAuTmFtZWQuVDAgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDAgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kMCAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IFQud2l0bmVzcyBpblxuICAgICAgICAgU29tZSAoY3VzdG9tIDogYSBjb21wdXRhdGlvbilcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICB8IFR5cGVyZXAuTmFtZWQuVDEgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDEgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kMSAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IGN1c3RvbSA9IChjdXN0b20gKGF1eC5nZW5lcmljIFQuYSkgOiBULmEgVC5uYW1lZCBjb21wdXRhdGlvbikgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgfCBUeXBlcmVwLk5hbWVkLlQyIHJlcCAtPlxuICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUeXBlcmVwLk5hbWVkLlQyIHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQ3VzdG9tID0gRmluZDIgKFQpIGluXG4gICAgICAobWF0Y2ggQ3VzdG9tLmNvbXB1dGUgKCkgd2l0aFxuICAgICAgIHwgU29tZSBjdXN0b20gLT5cbiAgICAgICAgIGxldCBjdXN0b20gPVxuICAgICAgICAgICAoY3VzdG9tIChhdXguZ2VuZXJpYyBULmEpIChhdXguZ2VuZXJpYyBULmIpIDogKFQuYSwgVC5iKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgfCBUeXBlcmVwLk5hbWVkLlQzIHJlcCAtPlxuICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUeXBlcmVwLk5hbWVkLlQzIHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQ3VzdG9tID0gRmluZDMgKFQpIGluXG4gICAgICAobWF0Y2ggQ3VzdG9tLmNvbXB1dGUgKCkgd2l0aFxuICAgICAgIHwgU29tZSBjdXN0b20gLT5cbiAgICAgICAgIGxldCBjdXN0b20gPVxuICAgICAgICAgICAoY3VzdG9tIChhdXguZ2VuZXJpYyBULmEpIChhdXguZ2VuZXJpYyBULmIpIChhdXguZ2VuZXJpYyBULmMpXG4gICAgICAgICAgICA6IChULmEsIFQuYiwgVC5jKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgfCBUeXBlcmVwLk5hbWVkLlQ0IHJlcCAtPlxuICAgICAgbGV0IG1vZHVsZSBUID0gKHZhbCByZXAgOiBUeXBlcmVwLk5hbWVkLlQ0IHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQ3VzdG9tID0gRmluZDQgKFQpIGluXG4gICAgICAobWF0Y2ggQ3VzdG9tLmNvbXB1dGUgKCkgd2l0aFxuICAgICAgIHwgU29tZSBjdXN0b20gLT5cbiAgICAgICAgIGxldCBjdXN0b20gPVxuICAgICAgICAgICAoY3VzdG9tIChhdXguZ2VuZXJpYyBULmEpIChhdXguZ2VuZXJpYyBULmIpIChhdXguZ2VuZXJpYyBULmMpIChhdXguZ2VuZXJpYyBULmQpXG4gICAgICAgICAgICA6IChULmEsIFQuYiwgVC5jLCBULmQpIFQubmFtZWQgY29tcHV0YXRpb24pXG4gICAgICAgICBpblxuICAgICAgICAgbGV0IFR5cGVfZXF1YWwuVCA9IFQud2l0bmVzcyBpblxuICAgICAgICAgU29tZSAoY3VzdG9tIDogYSBjb21wdXRhdGlvbilcbiAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICB8IFR5cGVyZXAuTmFtZWQuVDUgcmVwIC0+XG4gICAgICBsZXQgbW9kdWxlIFQgPSAodmFsIHJlcCA6IFR5cGVyZXAuTmFtZWQuVDUgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBDdXN0b20gPSBGaW5kNSAoVCkgaW5cbiAgICAgIChtYXRjaCBDdXN0b20uY29tcHV0ZSAoKSB3aXRoXG4gICAgICAgfCBTb21lIGN1c3RvbSAtPlxuICAgICAgICAgbGV0IGN1c3RvbSA9XG4gICAgICAgICAgIChjdXN0b21cbiAgICAgICAgICAgICAgKGF1eC5nZW5lcmljIFQuYSlcbiAgICAgICAgICAgICAgKGF1eC5nZW5lcmljIFQuYilcbiAgICAgICAgICAgICAgKGF1eC5nZW5lcmljIFQuYylcbiAgICAgICAgICAgICAgKGF1eC5nZW5lcmljIFQuZClcbiAgICAgICAgICAgICAgKGF1eC5nZW5lcmljIFQuZSlcbiAgICAgICAgICAgIDogKFQuYSwgVC5iLCBULmMsIFQuZCwgVC5lKSBULm5hbWVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgaW5cbiAgICAgICAgIGxldCBUeXBlX2VxdWFsLlQgPSBULndpdG5lc3MgaW5cbiAgICAgICAgIFNvbWUgKGN1c3RvbSA6IGEgY29tcHV0YXRpb24pXG4gICAgICAgfCBOb25lIC0+IE5vbmUpXG4gIDs7XG5cbiAgZXhjZXB0aW9uIE5vdF9pbXBsZW1lbnRlZCBvZiBzdHJpbmcgKiBzdHJpbmdcblxuICBsZXQgcmFpc2Vfbm90X2ltcGxlbWVudGVkIHN0cmluZyA9IHJhaXNlIChOb3RfaW1wbGVtZW50ZWQgKFgubmFtZSwgc3RyaW5nKSlcblxuICBsZXQgX3VzaW5nX2V4dGVuZGVkX2ltcGxlbWVudGF0aW9uIGF1eCByZXAgY29udGVudCA9XG4gICAgbWF0Y2ggZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvbiBhdXggcmVwIHdpdGhcbiAgICB8IFNvbWUgY29tcHV0YXRpb24gLT4gY29tcHV0YXRpb25cbiAgICB8IE5vbmUgLT5cbiAgICAgIChtYXRjaCBjb250ZW50IHdpdGhcbiAgICAgICB8IFNvbWUgKGxhenkgY29udGVudCkgLT4gYXV4LmdlbmVyaWMgY29udGVudFxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgbGV0IHR5cGVuYW1lID0gVHlwZXJlcC5OYW1lZC50eXBlbmFtZV9vZl90IHJlcCBpblxuICAgICAgICAgbGV0IG5hbWUgPSBUeXBlbmFtZS5VaWQubmFtZSAoVHlwZW5hbWUudWlkIHR5cGVuYW1lKSBpblxuICAgICAgICAgcmFpc2Vfbm90X2ltcGxlbWVudGVkIG5hbWUpXG4gIDs7XG5lbmRcblxubW9kdWxlIF8gPSBIYXNodGJsLk1ha2UgKFR5cGVuYW1lLktleSlcblxubW9kdWxlIE1ha2UgKFggOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBuYW1lIDogc3RyaW5nXG4gICAgdmFsIHJlcXVpcmVkIDogSWRlbnQudCBsaXN0XG5cbiAgICBpbmNsdWRlIENvbXB1dGF0aW9uIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIENvbXB1dGF0aW9uID0gWFxuICBpbmNsdWRlIE1ha2VfU19pbXBsZW1lbnRhdGlvbiAoWClcblxuICBtb2R1bGUgTWVtbyA9IFR5cGVuYW1lLlRhYmxlIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIFguTmFtZWQudFxuICAgIGVuZClcblxuICBtb2R1bGUgSGVscGVyID0gSGVscGVyIChUeXBlcmVwKSAoQ29tcHV0YXRpb24pXG5cbiAgbGV0IG9mX3R5cGVyZXAgcmVwID1cbiAgICBsZXQgY29udGV4dCA9IFguTmFtZWQuQ29udGV4dC5jcmVhdGUgKCkgaW5cbiAgICBsZXQgbWVtb190YWJsZSA9IE1lbW8uY3JlYXRlIDMyIGluXG4gICAgbGV0IHJlYyBvZl90eXBlcmVwIDogdHlwZSBhLiBhIFR5cGVyZXAudCAtPiBhIHQgPSBmdW5jdGlvblxuICAgICAgfCBUeXBlcmVwLkludCAtPiBYLmludFxuICAgICAgfCBUeXBlcmVwLkludDMyIC0+IFguaW50MzJcbiAgICAgIHwgVHlwZXJlcC5JbnQ2NCAtPiBYLmludDY0XG4gICAgICB8IFR5cGVyZXAuTmF0aXZlaW50IC0+IFgubmF0aXZlaW50XG4gICAgICB8IFR5cGVyZXAuQ2hhciAtPiBYLmNoYXJcbiAgICAgIHwgVHlwZXJlcC5GbG9hdCAtPiBYLmZsb2F0XG4gICAgICB8IFR5cGVyZXAuU3RyaW5nIC0+IFguc3RyaW5nXG4gICAgICB8IFR5cGVyZXAuQnl0ZXMgLT4gWC5ieXRlc1xuICAgICAgfCBUeXBlcmVwLkJvb2wgLT4gWC5ib29sXG4gICAgICB8IFR5cGVyZXAuVW5pdCAtPiBYLnVuaXRcbiAgICAgIHwgVHlwZXJlcC5PcHRpb24gcmVwIC0+IFgub3B0aW9uIChvZl90eXBlcmVwIHJlcClcbiAgICAgIHwgVHlwZXJlcC5MaXN0IHJlcCAtPiBYLmxpc3QgKG9mX3R5cGVyZXAgcmVwKVxuICAgICAgfCBUeXBlcmVwLkFycmF5IHJlcCAtPiBYLmFycmF5IChvZl90eXBlcmVwIHJlcClcbiAgICAgIHwgVHlwZXJlcC5MYXp5IHJlcCAtPiBYLmxhenlfdCAob2ZfdHlwZXJlcCByZXApXG4gICAgICB8IFR5cGVyZXAuUmVmIHJlcCAtPiBYLnJlZl8gKG9mX3R5cGVyZXAgcmVwKVxuICAgICAgfCBUeXBlcmVwLkZ1bmN0aW9uIChkb20sIHJuZykgLT4gWC5mdW5jdGlvbl8gKG9mX3R5cGVyZXAgZG9tKSAob2ZfdHlwZXJlcCBybmcpXG4gICAgICB8IFR5cGVyZXAuVHVwbGUgdHVwbGUgLT5cbiAgICAgICAgKCogZG8gTk9UIHdyaXRlIFtYLnR1cGxlMiAob2ZfdHlwZXJlcCBhKSAob2ZfdHlwZXJlcCBiKV1cbiAgICAgICAgICAgYmVjYXVzZSBvZl90eXBlcmVwIGNhbiBjb250YWluIGEgc2lkZSBlZmZlY3QgYW5kIFthXSBzaG91bGQgYmUgZXhlY3V0ZWRcbiAgICAgICAgICAgYmVmb3JlIFtiXSAqKVxuICAgICAgICAobWF0Y2ggdHVwbGUgd2l0aFxuICAgICAgICAgfCBUeXBlcmVwLlR1cGxlLlQyIChhLCBiKSAtPlxuICAgICAgICAgICBsZXQgcmEgPSBvZl90eXBlcmVwIGEgaW5cbiAgICAgICAgICAgbGV0IHJiID0gb2ZfdHlwZXJlcCBiIGluXG4gICAgICAgICAgIFgudHVwbGUyIHJhIHJiXG4gICAgICAgICB8IFR5cGVyZXAuVHVwbGUuVDMgKGEsIGIsIGMpIC0+XG4gICAgICAgICAgIGxldCByYSA9IG9mX3R5cGVyZXAgYSBpblxuICAgICAgICAgICBsZXQgcmIgPSBvZl90eXBlcmVwIGIgaW5cbiAgICAgICAgICAgbGV0IHJjID0gb2ZfdHlwZXJlcCBjIGluXG4gICAgICAgICAgIFgudHVwbGUzIHJhIHJiIHJjXG4gICAgICAgICB8IFR5cGVyZXAuVHVwbGUuVDQgKGEsIGIsIGMsIGQpIC0+XG4gICAgICAgICAgIGxldCByYSA9IG9mX3R5cGVyZXAgYSBpblxuICAgICAgICAgICBsZXQgcmIgPSBvZl90eXBlcmVwIGIgaW5cbiAgICAgICAgICAgbGV0IHJjID0gb2ZfdHlwZXJlcCBjIGluXG4gICAgICAgICAgIGxldCByZCA9IG9mX3R5cGVyZXAgZCBpblxuICAgICAgICAgICBYLnR1cGxlNCByYSByYiByYyByZFxuICAgICAgICAgfCBUeXBlcmVwLlR1cGxlLlQ1IChhLCBiLCBjLCBkLCBlKSAtPlxuICAgICAgICAgICBsZXQgcmEgPSBvZl90eXBlcmVwIGEgaW5cbiAgICAgICAgICAgbGV0IHJiID0gb2ZfdHlwZXJlcCBiIGluXG4gICAgICAgICAgIGxldCByYyA9IG9mX3R5cGVyZXAgYyBpblxuICAgICAgICAgICBsZXQgcmQgPSBvZl90eXBlcmVwIGQgaW5cbiAgICAgICAgICAgbGV0IHJlID0gb2ZfdHlwZXJlcCBlIGluXG4gICAgICAgICAgIFgudHVwbGU1IHJhIHJiIHJjIHJkIHJlKVxuICAgICAgfCBUeXBlcmVwLlJlY29yZCByZWNvcmQgLT5cbiAgICAgICAgWC5yZWNvcmQgKEhlbHBlci5tYXBfcmVjb3JkIHsgSGVscGVyLm1hcCA9IG9mX3R5cGVyZXAgfSByZWNvcmQpXG4gICAgICB8IFR5cGVyZXAuVmFyaWFudCB2YXJpYW50IC0+XG4gICAgICAgIFgudmFyaWFudCAoSGVscGVyLm1hcF92YXJpYW50IHsgSGVscGVyLm1hcCA9IG9mX3R5cGVyZXAgfSB2YXJpYW50KVxuICAgICAgfCBUeXBlcmVwLk5hbWVkIChuYW1lZCwgY29udGVudCkgLT5cbiAgICAgICAgbGV0IHR5cGVuYW1lID0gVHlwZXJlcC5OYW1lZC50eXBlbmFtZV9vZl90IG5hbWVkIGluXG4gICAgICAgIChtYXRjaCBNZW1vLmZpbmQgbWVtb190YWJsZSB0eXBlbmFtZSB3aXRoXG4gICAgICAgICB8IFNvbWUgc2hhcmVkIC0+IFguTmFtZWQuZ2V0X3dpcF9jb21wdXRhdGlvbiBzaGFyZWRcbiAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAobWF0Y2ggZmluZF9leHRlbmRlZF9pbXBsZW1lbnRhdGlvbiB7IGdlbmVyaWMgPSBvZl90eXBlcmVwIH0gbmFtZWQgd2l0aFxuICAgICAgICAgICAgfCBTb21lIGNvbXB1dGF0aW9uIC0+IGNvbXB1dGF0aW9uXG4gICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgKG1hdGNoIGNvbnRlbnQgd2l0aFxuICAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgIGxldCBuYW1lID0gVHlwZW5hbWUuVWlkLm5hbWUgKFR5cGVuYW1lLnVpZCB0eXBlbmFtZSkgaW5cbiAgICAgICAgICAgICAgICAgcmFpc2Vfbm90X2ltcGxlbWVudGVkIG5hbWVcbiAgICAgICAgICAgICAgIHwgU29tZSAobGF6eSBjb250ZW50KSAtPlxuICAgICAgICAgICAgICAgICBpZiBYLk5hbWVkLnNoYXJlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgICAgbGV0IHNoYXJlZCA9IFguTmFtZWQuaW5pdCBjb250ZXh0IHR5cGVuYW1lIGluXG4gICAgICAgICAgICAgICAgICAgTWVtby5zZXQgbWVtb190YWJsZSB0eXBlbmFtZSBzaGFyZWQ7XG4gICAgICAgICAgICAgICAgICAgbGV0IGNvbXB1dGF0aW9uID0gb2ZfdHlwZXJlcCBjb250ZW50IGluXG4gICAgICAgICAgICAgICAgICAgWC5OYW1lZC5zZXRfZmluYWxfY29tcHV0YXRpb24gc2hhcmVkIGNvbXB1dGF0aW9uKVxuICAgICAgICAgICAgICAgICBlbHNlIG9mX3R5cGVyZXAgY29udGVudCkpKVxuICAgIGluXG4gICAgbGV0IGNvbXB1dGF0aW9uID0gb2ZfdHlwZXJlcCByZXAgaW5cbiAgICBgZ2VuZXJpYyBjb21wdXRhdGlvblxuICA7O1xuZW5kXG4iLCJvcGVuIFN0ZF9pbnRlcm5hbFxuXG5tb2R1bGUgTWFrZTAgKFggOiBOYW1lZF9pbnRmLlMwKSA9IHN0cnVjdFxuICBtb2R1bGUgTmFtZV9vZl94ID0gVHlwZW5hbWUuTWFrZTAgKFgpXG5cbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuXG4gIGxldCBuYW1lZCA9XG4gICAgVHlwZXJlcC5OYW1lZC5UMFxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSBuYW1lZCA9IFgudFxuICAgICAgICB0eXBlIHQgPSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDBcbiAgICAgICAgd2l0aCB0eXBlIHQgPSBYLnQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UxIChYIDogTmFtZWRfaW50Zi5TMSkgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2UxIChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgKHR5cGUgcDEpIG9mX3AxID1cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90IChUeXBlcmVwLnR5cGVuYW1lX29mX3Qgb2ZfcDEpIGluXG4gICAgVHlwZXJlcC5OYW1lZC5UMVxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAnYSBuYW1lZCA9ICdhIFgudFxuICAgICAgICB0eXBlIGEgPSBwMVxuXG4gICAgICAgIGxldCBhID0gb2ZfcDFcblxuICAgICAgICB0eXBlIHQgPSBwMSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDFcbiAgICAgICAgd2l0aCB0eXBlIHQgPSBwMSBYLnQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UyIChYIDogTmFtZWRfaW50Zi5TMikgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2UyIChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgKHR5cGUgcDEgcDIpIG9mX3AxIG9mX3AyID1cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9XG4gICAgICBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdCAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AxKSAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AyKVxuICAgIGluXG4gICAgVHlwZXJlcC5OYW1lZC5UMlxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAoJ2EsICdiKSBuYW1lZCA9ICgnYSwgJ2IpIFgudFxuICAgICAgICB0eXBlIGEgPSBwMVxuXG4gICAgICAgIGxldCBhID0gb2ZfcDFcblxuICAgICAgICB0eXBlIGIgPSBwMlxuXG4gICAgICAgIGxldCBiID0gb2ZfcDJcblxuICAgICAgICB0eXBlIHQgPSAocDEsIHAyKSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDJcbiAgICAgICAgd2l0aCB0eXBlIHQgPSAocDEsIHAyKSBYLnQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UzIChYIDogTmFtZWRfaW50Zi5TMykgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2UzIChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgKHR5cGUgcDEgcDIgcDMpIG9mX3AxIG9mX3AyIG9mX3AzID1cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9XG4gICAgICBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AxKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AyKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AzKVxuICAgIGluXG4gICAgVHlwZXJlcC5OYW1lZC5UM1xuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAoJ2EsICdiLCAnYykgbmFtZWQgPSAoJ2EsICdiLCAnYykgWC50XG4gICAgICAgIHR5cGUgYSA9IHAxXG5cbiAgICAgICAgbGV0IGEgPSBvZl9wMVxuXG4gICAgICAgIHR5cGUgYiA9IHAyXG5cbiAgICAgICAgbGV0IGIgPSBvZl9wMlxuXG4gICAgICAgIHR5cGUgYyA9IHAzXG5cbiAgICAgICAgbGV0IGMgPSBvZl9wM1xuXG4gICAgICAgIHR5cGUgdCA9IChwMSwgcDIsIHAzKSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDNcbiAgICAgICAgd2l0aCB0eXBlIHQgPSAocDEsIHAyLCBwMykgWC50KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlNCAoWCA6IE5hbWVkX2ludGYuUzQpID0gc3RydWN0XG4gIG1vZHVsZSBOYW1lX29mX3ggPSBUeXBlbmFtZS5NYWtlNCAoWClcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE5hbWVfb2ZfeC50eXBlbmFtZV9vZl90XG5cbiAgbGV0IG5hbWVkICh0eXBlIHAxIHAyIHAzIHA0KSBvZl9wMSBvZl9wMiBvZl9wMyBvZl9wNCA9XG4gICAgbGV0IHR5cGVuYW1lX29mX3QgPVxuICAgICAgTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMSlcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMilcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wMylcbiAgICAgICAgKFR5cGVyZXAudHlwZW5hbWVfb2ZfdCBvZl9wNClcbiAgICBpblxuICAgIFR5cGVyZXAuTmFtZWQuVDRcbiAgICAgIChtb2R1bGUgc3RydWN0XG4gICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSBuYW1lZCA9ICgnYSwgJ2IsICdjLCAnZCkgWC50XG4gICAgICAgIHR5cGUgYSA9IHAxXG5cbiAgICAgICAgbGV0IGEgPSBvZl9wMVxuXG4gICAgICAgIHR5cGUgYiA9IHAyXG5cbiAgICAgICAgbGV0IGIgPSBvZl9wMlxuXG4gICAgICAgIHR5cGUgYyA9IHAzXG5cbiAgICAgICAgbGV0IGMgPSBvZl9wM1xuXG4gICAgICAgIHR5cGUgZCA9IHA0XG5cbiAgICAgICAgbGV0IGQgPSBvZl9wNFxuXG4gICAgICAgIHR5cGUgdCA9IChwMSwgcDIsIHAzLCBwNCkgWC50XG5cbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX25hbWVkID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHR5cGVuYW1lX29mX3QgPSB0eXBlbmFtZV9vZl90XG4gICAgICAgIGxldCB3aXRuZXNzID0gVHlwZV9lcXVhbC5yZWZsXG4gICAgICBlbmQgOiBUeXBlcmVwLk5hbWVkLlQ0XG4gICAgICAgIHdpdGggdHlwZSB0ID0gKHAxLCBwMiwgcDMsIHA0KSBYLnQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2U1IChYIDogTmFtZWRfaW50Zi5TNSkgPSBzdHJ1Y3RcbiAgbW9kdWxlIE5hbWVfb2ZfeCA9IFR5cGVuYW1lLk1ha2U1IChYKVxuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTmFtZV9vZl94LnR5cGVuYW1lX29mX3RcblxuICBsZXQgbmFtZWQgKHR5cGUgcDEgcDIgcDMgcDQgcDUpIG9mX3AxIG9mX3AyIG9mX3AzIG9mX3A0IG9mX3A1ID1cbiAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9XG4gICAgICBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AxKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AyKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3AzKVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3A0KVxuICAgICAgICAoVHlwZXJlcC50eXBlbmFtZV9vZl90IG9mX3A1KVxuICAgIGluXG4gICAgVHlwZXJlcC5OYW1lZC5UNVxuICAgICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgICAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlKSBuYW1lZCA9ICgnYSwgJ2IsICdjLCAnZCwgJ2UpIFgudFxuICAgICAgICB0eXBlIGEgPSBwMVxuXG4gICAgICAgIGxldCBhID0gb2ZfcDFcblxuICAgICAgICB0eXBlIGIgPSBwMlxuXG4gICAgICAgIGxldCBiID0gb2ZfcDJcblxuICAgICAgICB0eXBlIGMgPSBwM1xuXG4gICAgICAgIGxldCBjID0gb2ZfcDNcblxuICAgICAgICB0eXBlIGQgPSBwNFxuXG4gICAgICAgIGxldCBkID0gb2ZfcDRcblxuICAgICAgICB0eXBlIGUgPSBwNVxuXG4gICAgICAgIGxldCBlID0gb2ZfcDVcblxuICAgICAgICB0eXBlIHQgPSAocDEsIHAyLCBwMywgcDQsIHA1KSBYLnRcblxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfbmFtZWQgPSBOYW1lX29mX3gudHlwZW5hbWVfb2ZfdFxuICAgICAgICBsZXQgdHlwZW5hbWVfb2ZfdCA9IHR5cGVuYW1lX29mX3RcbiAgICAgICAgbGV0IHdpdG5lc3MgPSBUeXBlX2VxdWFsLnJlZmxcbiAgICAgIGVuZCA6IFR5cGVyZXAuTmFtZWQuVDVcbiAgICAgICAgd2l0aCB0eXBlIHQgPSAocDEsIHAyLCBwMywgcDQsIHA1KSBYLnQpXG4gIDs7XG5lbmRcbiIsIm9wZW4gU3RkX2ludGVybmFsXG5cbm1vZHVsZSBNYWtlMCAoWCA6IE5hbWVkX2ludGYuUzApIDogVHlwZXJlcGFibGUuUyB3aXRoIHR5cGUgdCA6PSBYLnQgPSBzdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNYWtlX3R5cGVuYW1lLk1ha2UwIChYKVxuXG4gIGxldCB0eXBlcmVwX29mX3QgPSBUeXBlcmVwLk5hbWVkIChNLm5hbWVkLCBOb25lKVxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE0udHlwZW5hbWVfb2ZfdFxuZW5kXG5cbm1vZHVsZSBNYWtlMSAoWCA6IE5hbWVkX2ludGYuUzEpIDogVHlwZXJlcGFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgWC50ID0gc3RydWN0XG4gIG1vZHVsZSBNID0gTWFrZV90eXBlbmFtZS5NYWtlMSAoWClcblxuICBsZXQgdHlwZXJlcF9vZl90IG9mX3AxID0gVHlwZXJlcC5OYW1lZCAoTS5uYW1lZCBvZl9wMSwgTm9uZSlcbiAgbGV0IHR5cGVuYW1lX29mX3QgPSBNLnR5cGVuYW1lX29mX3RcbmVuZFxuXG5tb2R1bGUgTWFrZTIgKFggOiBOYW1lZF9pbnRmLlMyKSA6IFR5cGVyZXBhYmxlLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIFgudCA9XG5zdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNYWtlX3R5cGVuYW1lLk1ha2UyIChYKVxuXG4gIGxldCB0eXBlcmVwX29mX3Qgb2ZfcDEgb2ZfcDIgPSBUeXBlcmVwLk5hbWVkIChNLm5hbWVkIG9mX3AxIG9mX3AyLCBOb25lKVxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE0udHlwZW5hbWVfb2ZfdFxuZW5kXG5cbm1vZHVsZSBNYWtlMyAoWCA6IE5hbWVkX2ludGYuUzMpIDpcbiAgVHlwZXJlcGFibGUuUzMgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSBYLnQgPSBzdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNYWtlX3R5cGVuYW1lLk1ha2UzIChYKVxuXG4gIGxldCB0eXBlcmVwX29mX3Qgb2ZfcDEgb2ZfcDIgb2ZfcDMgPSBUeXBlcmVwLk5hbWVkIChNLm5hbWVkIG9mX3AxIG9mX3AyIG9mX3AzLCBOb25lKVxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE0udHlwZW5hbWVfb2ZfdFxuZW5kXG5cbm1vZHVsZSBNYWtlNCAoWCA6IE5hbWVkX2ludGYuUzQpIDpcbiAgVHlwZXJlcGFibGUuUzQgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCkgdCA6PSAoJ2EsICdiLCAnYywgJ2QpIFgudCA9IHN0cnVjdFxuICBtb2R1bGUgTSA9IE1ha2VfdHlwZW5hbWUuTWFrZTQgKFgpXG5cbiAgbGV0IHR5cGVyZXBfb2ZfdCBvZl9wMSBvZl9wMiBvZl9wMyBvZl9wNCA9XG4gICAgVHlwZXJlcC5OYW1lZCAoTS5uYW1lZCBvZl9wMSBvZl9wMiBvZl9wMyBvZl9wNCwgTm9uZSlcbiAgOztcblxuICBsZXQgdHlwZW5hbWVfb2ZfdCA9IE0udHlwZW5hbWVfb2ZfdFxuZW5kXG5cbm1vZHVsZSBNYWtlNSAoWCA6IE5hbWVkX2ludGYuUzUpIDpcbiAgVHlwZXJlcGFibGUuUzUgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UpIHQgOj0gKCdhLCAnYiwgJ2MsICdkLCAnZSkgWC50ID0gc3RydWN0XG4gIG1vZHVsZSBNID0gTWFrZV90eXBlbmFtZS5NYWtlNSAoWClcblxuICBsZXQgdHlwZXJlcF9vZl90IG9mX3AxIG9mX3AyIG9mX3AzIG9mX3A0IG9mX3A1ID1cbiAgICBUeXBlcmVwLk5hbWVkIChNLm5hbWVkIG9mX3AxIG9mX3AyIG9mX3AzIG9mX3A0IG9mX3A1LCBOb25lKVxuICA7O1xuXG4gIGxldCB0eXBlbmFtZV9vZl90ID0gTS50eXBlbmFtZV9vZl90XG5lbmRcbiJdfQ==
