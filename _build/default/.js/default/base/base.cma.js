// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1+5.8.1

//# unitInfo: Provides: Base__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base = [0];
   runtime.caml_register_global(0, Base, "Base__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Poly0
//# unitInfo: Requires: Caml
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_compare = runtime.caml_compare,
    global_data = runtime.caml_get_global_data(),
    Caml = global_data.Caml;
   function descending(x, y){return caml_compare(y, x);}
   var
    max = Caml[17],
    min = Caml[16],
    Base_Poly0 = [0, caml_compare, descending, min, max];
   runtime.caml_register_global(1, Base_Poly0, "Base__Poly0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Import0
//# unitInfo: Requires: Base__Poly0, Caml, Shadow_stdlib, Stdlib__Uchar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_equal = runtime.caml_bytes_equal,
    caml_bytes_greaterequal = runtime.caml_bytes_greaterequal,
    caml_bytes_lessequal = runtime.caml_bytes_lessequal,
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int_compare = runtime.caml_int_compare,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_notequal = runtime.caml_notequal,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_greaterequal = runtime.caml_string_greaterequal,
    caml_string_lessequal = runtime.caml_string_lessequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Poly0 = global_data.Base__Poly0,
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    Shadow_stdlib = global_data.Shadow_stdlib,
    Caml = global_data.Caml,
    do_at_exit = Shadow_stdlib[91],
    unsafe_really_input = Shadow_stdlib[90],
    valid_float_lexem = Shadow_stdlib[89],
    at_exit = Shadow_stdlib[88],
    exit = Shadow_stdlib[87],
    symbol = Shadow_stdlib[86],
    string_of_format = Shadow_stdlib[85],
    set_binary_mode_in = Shadow_stdlib[84],
    close_in_noerr = Shadow_stdlib[83],
    close_in = Shadow_stdlib[82],
    in_channel_length = Shadow_stdlib[81],
    pos_in = Shadow_stdlib[80],
    seek_in = Shadow_stdlib[79],
    input_value = Shadow_stdlib[78],
    input_binary_int = Shadow_stdlib[77],
    input_byte = Shadow_stdlib[76],
    really_input_string = Shadow_stdlib[75],
    really_input = Shadow_stdlib[74],
    input = Shadow_stdlib[73],
    input_line = Shadow_stdlib[72],
    input_char = Shadow_stdlib[71],
    open_in_gen = Shadow_stdlib[70],
    open_in_bin = Shadow_stdlib[69],
    open_in = Shadow_stdlib[68],
    set_binary_mode_out = Shadow_stdlib[67],
    close_out_noerr = Shadow_stdlib[66],
    close_out = Shadow_stdlib[65],
    out_channel_length = Shadow_stdlib[64],
    pos_out = Shadow_stdlib[63],
    seek_out = Shadow_stdlib[62],
    output_value = Shadow_stdlib[61],
    output_binary_int = Shadow_stdlib[60],
    output_byte = Shadow_stdlib[59],
    output_substring = Shadow_stdlib[58],
    output = Shadow_stdlib[57],
    output_bytes = Shadow_stdlib[56],
    output_string = Shadow_stdlib[55],
    output_char = Shadow_stdlib[54],
    flush_all = Shadow_stdlib[53],
    flush = Shadow_stdlib[52],
    open_out_gen = Shadow_stdlib[51],
    open_out_bin = Shadow_stdlib[50],
    open_out = Shadow_stdlib[49],
    read_float = Shadow_stdlib[48],
    read_float_opt = Shadow_stdlib[47],
    read_int = Shadow_stdlib[46],
    read_int_opt = Shadow_stdlib[45],
    read_line = Shadow_stdlib[44],
    prerr_newline = Shadow_stdlib[43],
    prerr_endline = Shadow_stdlib[42],
    prerr_float = Shadow_stdlib[41],
    prerr_int = Shadow_stdlib[40],
    prerr_bytes = Shadow_stdlib[39],
    prerr_string = Shadow_stdlib[38],
    prerr_char = Shadow_stdlib[37],
    print_newline = Shadow_stdlib[36],
    print_endline = Shadow_stdlib[35],
    print_float = Shadow_stdlib[34],
    print_int = Shadow_stdlib[33],
    print_bytes = Shadow_stdlib[32],
    print_string = Shadow_stdlib[31],
    print_char = Shadow_stdlib[30],
    stderr = Shadow_stdlib[29],
    stdout = Shadow_stdlib[28],
    stdin = Shadow_stdlib[27],
    float_of_string_opt = Shadow_stdlib[25],
    string_of_float = Shadow_stdlib[24],
    int_of_string_opt = Shadow_stdlib[23],
    string_of_int = Shadow_stdlib[22],
    bool_of_string = Shadow_stdlib[21],
    bool_of_string_opt = Shadow_stdlib[20],
    string_of_bool = Shadow_stdlib[19],
    char_of_int = Shadow_stdlib[18],
    epsilon_float = Shadow_stdlib[16],
    min_float = Shadow_stdlib[15],
    max_float = Shadow_stdlib[14],
    nan = Shadow_stdlib[13],
    neg_infinity = Shadow_stdlib[12],
    infinity = Shadow_stdlib[11],
    min_int = Shadow_stdlib[9],
    max_int = Shadow_stdlib[8],
    Not_found = Shadow_stdlib[4],
    Exit = Shadow_stdlib[3],
    invalid_arg = Caml[1],
    failwith = Caml[2],
    Exit$0 = Caml[3],
    Match_failure = Caml[4],
    Assert_failure = Caml[5],
    Invalid_argument = Caml[6],
    Failure = Caml[7],
    Out_of_memory = Caml[9],
    Stack_overflow = Caml[10],
    Sys_error = Caml[11],
    End_of_file = Caml[12],
    Division_by_zero = Caml[13],
    Sys_blocked_io = Caml[14],
    Undefined_recursive_module = Caml[15],
    min = Caml[16],
    max = Caml[17],
    abs = Caml[18],
    max_int$0 = Caml[19],
    min_int$0 = Caml[20],
    lnot = Caml[21],
    infinity$0 = Caml[22],
    neg_infinity$0 = Caml[23],
    nan$0 = Caml[24],
    max_float$0 = Caml[25],
    min_float$0 = Caml[26],
    epsilon_float$0 = Caml[27],
    symbol_concat = Caml[28],
    char_of_int$0 = Caml[29],
    string_of_bool$0 = Caml[30],
    bool_of_string_opt$0 = Caml[31],
    bool_of_string$0 = Caml[32],
    string_of_int$0 = Caml[33],
    int_of_string_opt$0 = Caml[34],
    string_of_float$0 = Caml[35],
    float_of_string_opt$0 = Caml[36],
    symbol$0 = Caml[37],
    stdin$0 = Caml[38],
    stdout$0 = Caml[39],
    stderr$0 = Caml[40],
    print_char$0 = Caml[41],
    print_string$0 = Caml[42],
    print_bytes$0 = Caml[43],
    print_int$0 = Caml[44],
    print_float$0 = Caml[45],
    print_endline$0 = Caml[46],
    print_newline$0 = Caml[47],
    prerr_char$0 = Caml[48],
    prerr_string$0 = Caml[49],
    prerr_bytes$0 = Caml[50],
    prerr_int$0 = Caml[51],
    prerr_float$0 = Caml[52],
    prerr_endline$0 = Caml[53],
    prerr_newline$0 = Caml[54],
    read_line$0 = Caml[55],
    read_int_opt$0 = Caml[56],
    read_int$0 = Caml[57],
    read_float_opt$0 = Caml[58],
    read_float$0 = Caml[59],
    open_out$0 = Caml[60],
    open_out_bin$0 = Caml[61],
    open_out_gen$0 = Caml[62],
    flush$0 = Caml[63],
    flush_all$0 = Caml[64],
    output_char$0 = Caml[65],
    output_string$0 = Caml[66],
    output_bytes$0 = Caml[67],
    output$0 = Caml[68],
    output_substring$0 = Caml[69],
    output_byte$0 = Caml[70],
    output_binary_int$0 = Caml[71],
    output_value$0 = Caml[72],
    seek_out$0 = Caml[73],
    pos_out$0 = Caml[74],
    out_channel_length$0 = Caml[75],
    close_out$0 = Caml[76],
    close_out_noerr$0 = Caml[77],
    set_binary_mode_out$0 = Caml[78],
    open_in$0 = Caml[79],
    open_in_bin$0 = Caml[80],
    open_in_gen$0 = Caml[81],
    input_char$0 = Caml[82],
    input_line$0 = Caml[83],
    input$0 = Caml[84],
    really_input$0 = Caml[85],
    really_input_string$0 = Caml[86],
    input_byte$0 = Caml[87],
    input_binary_int$0 = Caml[88],
    input_value$0 = Caml[89],
    seek_in$0 = Caml[90],
    pos_in$0 = Caml[91],
    in_channel_length$0 = Caml[92],
    close_in$0 = Caml[93],
    close_in_noerr$0 = Caml[94],
    set_binary_mode_in$0 = Caml[95],
    LargeFile = Caml[96],
    string_of_format$0 = Caml[97],
    symbol$1 = Caml[98],
    exit$0 = Caml[99],
    at_exit$0 = Caml[100],
    valid_float_lexem$0 = Caml[101],
    unsafe_really_input$0 = Caml[102],
    do_at_exit$0 = Caml[103],
    In_channel = Caml[104],
    Out_channel = Caml[105],
    Not_found$0 = Caml[8],
    Caml$0 =
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int$0,
       min_int$0,
       lnot,
       infinity$0,
       neg_infinity$0,
       nan$0,
       max_float$0,
       min_float$0,
       epsilon_float$0,
       symbol_concat,
       char_of_int$0,
       string_of_bool$0,
       bool_of_string_opt$0,
       bool_of_string$0,
       string_of_int$0,
       int_of_string_opt$0,
       string_of_float$0,
       float_of_string_opt$0,
       symbol$0,
       stdin$0,
       stdout$0,
       stderr$0,
       print_char$0,
       print_string$0,
       print_bytes$0,
       print_int$0,
       print_float$0,
       print_endline$0,
       print_newline$0,
       prerr_char$0,
       prerr_string$0,
       prerr_bytes$0,
       prerr_int$0,
       prerr_float$0,
       prerr_endline$0,
       prerr_newline$0,
       read_line$0,
       read_int_opt$0,
       read_int$0,
       read_float_opt$0,
       read_float$0,
       open_out$0,
       open_out_bin$0,
       open_out_gen$0,
       flush$0,
       flush_all$0,
       output_char$0,
       output_string$0,
       output_bytes$0,
       output$0,
       output_substring$0,
       output_byte$0,
       output_binary_int$0,
       output_value$0,
       seek_out$0,
       pos_out$0,
       out_channel_length$0,
       close_out$0,
       close_out_noerr$0,
       set_binary_mode_out$0,
       open_in$0,
       open_in_bin$0,
       open_in_gen$0,
       input_char$0,
       input_line$0,
       input$0,
       really_input$0,
       really_input_string$0,
       input_byte$0,
       input_binary_int$0,
       input_value$0,
       seek_in$0,
       pos_in$0,
       in_channel_length$0,
       close_in$0,
       close_in_noerr$0,
       set_binary_mode_in$0,
       LargeFile,
       string_of_format$0,
       symbol$1,
       exit$0,
       at_exit$0,
       valid_float_lexem$0,
       unsafe_really_input$0,
       do_at_exit$0,
       In_channel,
       Out_channel,
       Not_found$0];
   function bool_to_int(x){return x;}
   function symbol$2(_V_, _U_){return _V_ !== _U_ ? 1 : 0;}
   var symbol$3 = runtime.caml_mul;
   function symbol$4(_T_, _S_){return Math.pow(_T_, _S_);}
   function symbol$5(_R_, _Q_){return _R_ * _Q_;}
   function symbol$6(_P_, _O_){return _P_ + _O_ | 0;}
   function symbol$7(_N_, _M_){return _N_ + _M_;}
   function symbol$8(_L_, _K_){return _L_ - _K_ | 0;}
   function symbol$9(_J_, _I_){return _J_ - _I_;}
   var symbol$10 = runtime.caml_div;
   function symbol$11(_H_, _G_){return _H_ / _G_;}
   var ascending = caml_int_compare;
   function descending(x, y){return caml_int_compare(y, x);}
   function max$0(x, y){return y <= x ? x : y;}
   function min$0(x, y){return x <= y ? x : y;}
   var
    Int_replace_polymorphic_compar = [0, ascending, descending, max$0, min$0],
    ascending$0 = Int_replace_polymorphic_compar[1],
    descending$0 = Int_replace_polymorphic_compar[2],
    max$1 = Int_replace_polymorphic_compar[3],
    min$1 = Int_replace_polymorphic_compar[4],
    symbol$12 = caml_lessthan,
    symbol$13 = caml_lessequal,
    symbol$14 = caml_notequal,
    symbol$15 = caml_equal,
    symbol$16 = caml_greaterthan,
    symbol$17 = caml_greaterequal;
   function ascending$1(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$1(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare = caml_int_compare, equal = caml_equal;
   function max$2(x, y){return caml_greaterequal(x, y) ? x : y;}
   function min$2(x, y){return caml_lessequal(x, y) ? x : y;}
   var
    Int32_replace_polymorphic_comp =
      [0,
       symbol$12,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       symbol$17,
       ascending$1,
       descending$1,
       compare,
       equal,
       max$2,
       min$2];
   function ascending$2(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$2(x, y){return caml_call2(Base_Poly0[2], x, y);}
   function max$3(x, y){return caml_greaterequal(x, y) ? x : y;}
   function min$3(x, y){return caml_lessequal(x, y) ? x : y;}
   var
    Int64_replace_polymorphic_comp =
      [0, ascending$2, descending$2, max$3, min$3],
    symbol$18 = caml_lessthan,
    symbol$19 = caml_lessequal,
    symbol$20 = caml_notequal,
    symbol$21 = caml_equal,
    symbol$22 = caml_greaterthan,
    symbol$23 = caml_greaterequal;
   function ascending$3(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$3(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare, equal$0 = caml_equal;
   function max$4(x, y){return caml_greaterequal(x, y) ? x : y;}
   function min$4(x, y){return caml_lessequal(x, y) ? x : y;}
   var
    Nativeint_replace_polymorphic_ =
      [0,
       symbol$18,
       symbol$19,
       symbol$20,
       symbol$21,
       symbol$22,
       symbol$23,
       ascending$3,
       descending$3,
       compare$0,
       equal$0,
       max$4,
       min$4];
   function symbol$24(x, y){return x < y ? 1 : 0;}
   function symbol$25(x, y){return x <= y ? 1 : 0;}
   function symbol$26(x, y){return x !== y ? 1 : 0;}
   function symbol$27(x, y){return x === y ? 1 : 0;}
   function symbol$28(x, y){return y < x ? 1 : 0;}
   function symbol$29(x, y){return y <= x ? 1 : 0;}
   function ascending$4(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$4(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$1 = caml_int_compare;
   function equal$1(x, y){return x === y ? 1 : 0;}
   function max$5(x, y){return y <= x ? x : y;}
   function min$5(x, y){return x <= y ? x : y;}
   var
    Bool_replace_polymorphic_compa =
      [0,
       symbol$24,
       symbol$25,
       symbol$26,
       symbol$27,
       symbol$28,
       symbol$29,
       ascending$4,
       descending$4,
       compare$1,
       equal$1,
       max$5,
       min$5];
   function symbol$30(x, y){return x < y ? 1 : 0;}
   function symbol$31(x, y){return x <= y ? 1 : 0;}
   function symbol$32(x, y){return x !== y ? 1 : 0;}
   function symbol$33(x, y){return x === y ? 1 : 0;}
   function symbol$34(x, y){return y < x ? 1 : 0;}
   function symbol$35(x, y){return y <= x ? 1 : 0;}
   function ascending$5(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$5(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$2 = caml_int_compare;
   function equal$2(x, y){return x === y ? 1 : 0;}
   function max$6(x, y){return y <= x ? x : y;}
   function min$6(x, y){return x <= y ? x : y;}
   var
    Char_replace_polymorphic_compa =
      [0,
       symbol$30,
       symbol$31,
       symbol$32,
       symbol$33,
       symbol$34,
       symbol$35,
       ascending$5,
       descending$5,
       compare$2,
       equal$2,
       max$6,
       min$6];
   function i(x){return caml_call1(Stdlib_Uchar[10], x);}
   function symbol$36(x, y){var _F_ = i(y); return i(x) < _F_ ? 1 : 0;}
   function symbol$37(x, y){var _E_ = i(y); return i(x) <= _E_ ? 1 : 0;}
   function symbol$38(x, y){var _D_ = i(y); return i(x) !== _D_ ? 1 : 0;}
   function symbol$39(x, y){var _C_ = i(y); return i(x) === _C_ ? 1 : 0;}
   function symbol$40(x, y){var _B_ = i(y); return _B_ < i(x) ? 1 : 0;}
   function symbol$41(x, y){var _A_ = i(y); return _A_ <= i(x) ? 1 : 0;}
   function ascending$6(x, y){
    var _y_ = i(y), _z_ = i(x);
    return caml_call2(Int_replace_polymorphic_compar[1], _z_, _y_);
   }
   function descending$6(x, y){
    var _w_ = i(y), _x_ = i(x);
    return caml_call2(Int_replace_polymorphic_compar[2], _x_, _w_);
   }
   function compare$3(x, y){
    var _v_ = i(y);
    return caml_int_compare(i(x), _v_);
   }
   function equal$3(x, y){var _u_ = i(y); return i(x) === _u_ ? 1 : 0;}
   function max$7(x, y){return symbol$41(x, y) ? x : y;}
   function min$7(x, y){return symbol$37(x, y) ? x : y;}
   var
    Uchar_replace_polymorphic_comp =
      [0,
       i,
       symbol$36,
       symbol$37,
       symbol$38,
       symbol$39,
       symbol$40,
       symbol$41,
       ascending$6,
       descending$6,
       compare$3,
       equal$3,
       max$7,
       min$7];
   function symbol$42(x, y){return x < y ? 1 : 0;}
   function symbol$43(x, y){return x <= y ? 1 : 0;}
   function symbol$44(x, y){return x != y ? 1 : 0;}
   function symbol$45(x, y){return x == y ? 1 : 0;}
   function symbol$46(x, y){return y < x ? 1 : 0;}
   function symbol$47(x, y){return y <= x ? 1 : 0;}
   function ascending$7(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$7(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$4 = runtime.caml_float_compare;
   function equal$4(x, y){return x == y ? 1 : 0;}
   function max$8(x, y){return y <= x ? x : y;}
   function min$8(x, y){return x <= y ? x : y;}
   var
    Float_replace_polymorphic_comp =
      [0,
       symbol$42,
       symbol$43,
       symbol$44,
       symbol$45,
       symbol$46,
       symbol$47,
       ascending$7,
       descending$7,
       compare$4,
       equal$4,
       max$8,
       min$8],
    symbol$48 = runtime.caml_string_lessthan,
    symbol$49 = caml_string_lessequal,
    symbol$50 = runtime.caml_string_notequal,
    symbol$51 = caml_string_equal,
    symbol$52 = runtime.caml_string_greaterthan,
    symbol$53 = caml_string_greaterequal;
   function ascending$8(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$8(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$5 = runtime.caml_string_compare, equal$5 = caml_string_equal;
   function max$9(x, y){return caml_string_greaterequal(x, y) ? x : y;}
   function min$9(x, y){return caml_string_lessequal(x, y) ? x : y;}
   var
    String_replace_polymorphic_com =
      [0,
       symbol$48,
       symbol$49,
       symbol$50,
       symbol$51,
       symbol$52,
       symbol$53,
       ascending$8,
       descending$8,
       compare$5,
       equal$5,
       max$9,
       min$9],
    symbol$54 = runtime.caml_bytes_lessthan,
    symbol$55 = caml_bytes_lessequal,
    symbol$56 = runtime.caml_bytes_notequal,
    symbol$57 = caml_bytes_equal,
    symbol$58 = runtime.caml_bytes_greaterthan,
    symbol$59 = caml_bytes_greaterequal;
   function ascending$9(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$9(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$6 = runtime.caml_bytes_compare, equal$6 = caml_bytes_equal;
   function max$10(x, y){return caml_bytes_greaterequal(x, y) ? x : y;}
   function min$10(x, y){return caml_bytes_lessequal(x, y) ? x : y;}
   var
    Bytes_replace_polymorphic_comp =
      [0,
       symbol$54,
       symbol$55,
       symbol$56,
       symbol$57,
       symbol$58,
       symbol$59,
       ascending$9,
       descending$9,
       compare$6,
       equal$6,
       max$10,
       min$10],
    symbol$60 = Caml$0[36],
    symbol_concat$0 = Caml$0[27];
   function symbol$61(_t_){return - _t_ | 0;}
   function symbol$62(_s_){return - _s_;}
   function asr(_r_, _q_){return _r_ >> _q_;}
   function land(_p_, _o_){return _p_ & _o_;}
   var lnot$0 = Caml$0[20];
   function lor(_n_, _m_){return _n_ | _m_;}
   function lsl(_l_, _k_){return _l_ << _k_;}
   function lsr(_j_, _i_){return _j_ >>> _i_ | 0;}
   function lxor(_h_, _g_){return _h_ ^ _g_;}
   var mod = runtime.caml_mod, abs$0 = Caml$0[17], failwith$0 = Caml$0[2];
   function fst(_f_){return _f_[1];}
   var invalid_arg$0 = Caml$0[1];
   function snd(_e_){return _e_[2];}
   function phys_equal(_d_, _c_){return _d_ === _c_ ? 1 : 0;}
   function decr(_b_){_b_[1]--; return 0;}
   function incr(_a_){_a_[1]++; return 0;}
   var
    float_of_string = runtime.caml_float_of_string,
    am_testing = runtime.Base_am_testing(0),
    Base_Import0 =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       Caml$0,
       bool_to_int,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       symbol$11,
       Int_replace_polymorphic_compar,
       ascending$0,
       descending$0,
       max$1,
       min$1,
       Int32_replace_polymorphic_comp,
       Int64_replace_polymorphic_comp,
       Nativeint_replace_polymorphic_,
       Bool_replace_polymorphic_compa,
       Char_replace_polymorphic_compa,
       Uchar_replace_polymorphic_comp,
       Float_replace_polymorphic_comp,
       String_replace_polymorphic_com,
       Bytes_replace_polymorphic_comp,
       symbol$60,
       symbol_concat$0,
       symbol$61,
       symbol$62,
       asr,
       land,
       lnot$0,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs$0,
       failwith$0,
       fst,
       invalid_arg$0,
       snd,
       phys_equal,
       decr,
       incr,
       float_of_string,
       am_testing];
   runtime.caml_register_global(4, Base_Import0, "Base__Import0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Printf
//# unitInfo: Requires: Base__Import0, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Stdlib_Printf = global_data.Stdlib__Printf,
    sprintf = Stdlib_Printf[4],
    bprintf = Stdlib_Printf[5],
    ifprintf = Stdlib_Printf[6],
    ksprintf = Stdlib_Printf[10],
    kbprintf = Stdlib_Printf[11];
   function failwithf(fmt){
    return caml_call2
            (ksprintf,
             function(s, param){return caml_call1(Base_Import0[123], s);},
             fmt);
   }
   function invalid_argf(fmt){
    return caml_call2
            (ksprintf,
             function(s, param){return caml_call1(Base_Import0[125], s);},
             fmt);
   }
   var
    Base_Printf =
      [0,
       ifprintf,
       sprintf,
       bprintf,
       ksprintf,
       kbprintf,
       failwithf,
       invalid_argf];
   runtime.caml_register_global(2, Base_Printf, "Base__Printf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sys0
//# unitInfo: Requires: Base__Import0, Base__Printf, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Sys = global_data.Stdlib__Sys,
    backend_type = Stdlib_Sys[5],
    interactive = Stdlib_Sys[3],
    os_type = Stdlib_Sys[4],
    unix = Stdlib_Sys[6],
    win32 = Stdlib_Sys[7],
    cygwin = Stdlib_Sys[8],
    word_size_in_bits = Stdlib_Sys[9],
    int_size_in_bits = Stdlib_Sys[10],
    big_endian = Stdlib_Sys[11],
    max_string_length = Stdlib_Sys[12],
    max_array_length = Stdlib_Sys[13],
    runtime_variant = runtime.caml_runtime_variant,
    runtime_parameters = runtime.caml_runtime_parameters,
    argv = caml_sys_argv(0);
   function get_argv(param){return caml_sys_argv(0);}
   var
    ocaml_version = Stdlib_Sys[46],
    enable_runtime_warnings = Stdlib_Sys[47],
    runtime_warnings_enabled = Stdlib_Sys[48],
    _a_ =
      [0,
       [11,
        "Sys.getenv_exn: environment variable ",
        [2, 0, [11, " is not set", 0]]],
       "Sys.getenv_exn: environment variable %s is not set"];
   function getenv_exn(var$0){
    try{var _e_ = caml_sys_getenv(var$0); return _e_;}
    catch(_f_){
     var _d_ = caml_wrap_exception(_f_);
     if(_d_ === Base_Import0[84][105])
      return caml_call3(Base_Printf[6], _a_, var$0, 0);
     throw caml_maybe_attach_backtrace(_d_, 0);
    }
   }
   function getenv(var$0){
    try{var x = caml_sys_getenv(var$0);}
    catch(_c_){
     var _b_ = caml_wrap_exception(_c_);
     if(_b_ === Base_Import0[84][105]) return 0;
     throw caml_maybe_attach_backtrace(_b_, 0);
    }
    return [0, x];
   }
   var
    Break = Stdlib_Sys[44],
    Base_Sys0 =
      [0,
       backend_type,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       word_size_in_bits,
       int_size_in_bits,
       big_endian,
       max_string_length,
       max_array_length,
       runtime_variant,
       runtime_parameters,
       argv,
       get_argv,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       getenv_exn,
       getenv,
       Break];
   runtime.caml_register_global(4, Base_Sys0, "Base__Sys0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array0
//# unitInfo: Requires: Base__Printf, Base__Sys0, Stdlib, Stdlib__ArrayLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_ArrayLabels = global_data.Stdlib__ArrayLabels;
   global_data.Stdlib;
   var
    Base_Printf = global_data.Base__Printf,
    Base_Sys0 = global_data.Base__Sys0,
    invalid_argf = Base_Printf[7],
    Array = [0],
    max_length = Base_Sys0[11];
   function create(len, x){return runtime.caml_make_vect(len, x);}
   function create_float_uninitialized(len){
    return runtime.caml_make_float_vect(len);
   }
   var
    append = Stdlib_ArrayLabels[5],
    blit = Stdlib_ArrayLabels[10],
    concat = Stdlib_ArrayLabels[6],
    copy = Stdlib_ArrayLabels[8],
    fill = Stdlib_ArrayLabels[9],
    init = Stdlib_ArrayLabels[2],
    make_matrix = Stdlib_ArrayLabels[3],
    of_list = Stdlib_ArrayLabels[12],
    sub = Stdlib_ArrayLabels[7],
    to_list = Stdlib_ArrayLabels[11];
   function fold(t, init, f){
    return caml_call3(Stdlib_ArrayLabels[17], f, init, t);
   }
   function fold_right(t, f, init){
    return caml_call3(Stdlib_ArrayLabels[19], f, t, init);
   }
   function iter(t, f){return caml_call2(Stdlib_ArrayLabels[13], f, t);}
   function iteri(t, f){return caml_call2(Stdlib_ArrayLabels[14], f, t);}
   function map(t, f){return caml_call2(Stdlib_ArrayLabels[15], f, t);}
   function mapi(t, f){return caml_call2(Stdlib_ArrayLabels[16], f, t);}
   function stable_sort(t, compare){
    return caml_call2(Stdlib_ArrayLabels[33], compare, t);
   }
   function swap(t, i, j){
    var
     elt_i = caml_check_bound(t, i)[1 + i],
     elt_j = caml_check_bound(t, j)[1 + j];
    t[1 + i] = elt_j;
    t[1 + j] = elt_i;
    return 0;
   }
   var
    Base_Array0 =
      [0,
       invalid_argf,
       Array,
       max_length,
       create,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap];
   runtime.caml_register_global(6, Base_Array0, "Base__Array0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Char0
//# unitInfo: Requires: Base__Printf, Stdlib__Char
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Printf = global_data.Base__Printf,
    Stdlib_Char = global_data.Stdlib__Char,
    failwithf = Base_Printf[6],
    escaped = Stdlib_Char[2],
    lowercase = Stdlib_Char[5];
   function to_int(_e_){return _e_;}
   function unsafe_of_int(_d_){return _d_;}
   var uppercase = Stdlib_Char[6];
   function int_is_ok(i){
    var _b_ = 0 <= i ? 1 : 0, _c_ = _b_ ? i <= 255 ? 1 : 0 : _b_;
    return _c_;
   }
   var
    _a_ =
      [0,
       [11, "Char.of_int_exn got integer out of range: ", [4, 0, 0, 0, 0]],
       "Char.of_int_exn got integer out of range: %d"];
   function of_int(i){return int_is_ok(i) ? [0, i] : 0;}
   function of_int_exn(i){
    return int_is_ok(i) ? i : caml_call3(failwithf, _a_, i, 0);
   }
   function equal(t1, t2){return t1 === t2 ? 1 : 0;}
   var
    Base_Char0 =
      [0,
       failwithf,
       escaped,
       lowercase,
       to_int,
       unsafe_of_int,
       uppercase,
       int_is_ok,
       0,
       255,
       of_int,
       of_int_exn,
       equal];
   runtime.caml_register_global(3, Base_Char0, "Base__Char0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hash_intf = [0];
   runtime.caml_register_global(0, Base_Hash_intf, "Base__Hash_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int0
//# unitInfo: Requires: Caml
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Caml = global_data.Caml,
    to_string = Caml[33],
    of_string = runtime.caml_int_of_string;
   function to_float(_c_){return _c_;}
   function of_float(_b_){return _b_ | 0;}
   var max_value = Caml[19], min_value = Caml[20];
   function succ(_a_){return _a_ + 1 | 0;}
   var
    Base_Int0 =
      [0,
       to_string,
       of_string,
       to_float,
       of_float,
       max_value,
       min_value,
       succ];
   runtime.caml_register_global(1, Base_Int0, "Base__Int0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List0
//# unitInfo: Requires: Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    hd_exn = Stdlib_ListLabels[5],
    length = Stdlib_ListLabels[1],
    rev_append = Stdlib_ListLabels[12],
    tl_exn = Stdlib_ListLabels[6],
    unzip = Stdlib_ListLabels[54];
   function exists(t, f){return caml_call2(Stdlib_ListLabels[33], f, t);}
   function exists2_ok(l1, l2, f){
    return caml_call3(Stdlib_ListLabels[35], f, l1, l2);
   }
   function fold(t, init, f){
    return caml_call3(Stdlib_ListLabels[25], f, init, t);
   }
   function fold2_ok(l1, l2, init, f){
    return caml_call4(Stdlib_ListLabels[30], f, init, l1, l2);
   }
   function for_all(t, f){return caml_call2(Stdlib_ListLabels[32], f, t);}
   function for_all2_ok(l1, l2, f){
    return caml_call3(Stdlib_ListLabels[34], f, l1, l2);
   }
   function iter(t, f){return caml_call2(Stdlib_ListLabels[17], f, t);}
   function iter2_ok(l1, l2, f){
    return caml_call3(Stdlib_ListLabels[27], f, l1, l2);
   }
   function nontail_map(t, f){return caml_call2(Stdlib_ListLabels[19], f, t);}
   function nontail_mapi(t, f){
    return caml_call2(Stdlib_ListLabels[20], f, t);
   }
   function partition(t, f){return caml_call2(Stdlib_ListLabels[44], f, t);}
   function rev_map(t, f){return caml_call2(Stdlib_ListLabels[21], f, t);}
   function rev_map2_ok(l1, l2, f){
    return caml_call3(Stdlib_ListLabels[29], f, l1, l2);
   }
   function sort(l, compare){
    return caml_call2(Stdlib_ListLabels[56], compare, l);
   }
   function stable_sort(l, compare){
    return caml_call2(Stdlib_ListLabels[57], compare, l);
   }
   function rev(res){
    if(res){
     var match = res[2];
     if(match){
      var rest = match[2], y = match[1], x = res[1];
      return caml_call2(rev_append, rest, [0, y, [0, x, 0]]);
     }
    }
    return res;
   }
   function fold_right(l, f, init){
    return l
            ? fold(rev(l), init, function(a, b){return caml_call2(f, b, a);})
            : init;
   }
   var
    Base_List0 =
      [0,
       hd_exn,
       length,
       rev_append,
       tl_exn,
       unzip,
       exists,
       exists2_ok,
       fold,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       sort,
       stable_sort,
       rev,
       fold_right];
   runtime.caml_register_global(1, Base_List0, "Base__List0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash
//# unitInfo: Requires: Base__Char0, Base__Hash_intf, Base__Import0, Base__Int0, Base__List0, Base_internalhash_types, CamlinternalLazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    description = "internalhash",
    Base_Import0 = global_data.Base__Import0,
    Base_Int0 = global_data.Base__Int0,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_List0 = global_data.Base__List0,
    Base_Char0 = global_data.Base__Char0;
   function Folding(Hash){
    function hash_fold_unit(s, param){return s;}
    var
     hash_fold_int = Hash[2],
     hash_fold_int64 = Hash[3],
     hash_fold_float = Hash[4],
     hash_fold_string = Hash[5];
    function as_int(f, s, x){
     return caml_call2(hash_fold_int, s, caml_call1(f, x));
    }
    function _H_(_ah_){return _ah_;}
    function hash_fold_int32(_af_, _ag_){return as_int(_H_, _af_, _ag_);}
    var _I_ = Base_Char0[4];
    function hash_fold_char(_ad_, _ae_){return as_int(_I_, _ad_, _ae_);}
    function _J_(param){return param ? 1 : 0;}
    function hash_fold_bool(_ab_, _ac_){return as_int(_J_, _ab_, _ac_);}
    function hash_fold_nativeint(s, x){
     return caml_call2(hash_fold_int64, s, runtime.caml_int64_of_int32(x));
    }
    function hash_fold_option(hash_fold_elem, s, param){
     if(! param) return caml_call2(hash_fold_int, s, 0);
     var x = param[1];
     return caml_call2(hash_fold_elem, caml_call2(hash_fold_int, s, 1), x);
    }
    function hash_fold_list(hash_fold_elem, s$1, list$1){
     var
      s$2 = caml_call2(hash_fold_int, s$1, caml_call1(Base_List0[2], list$1)),
      s = s$2,
      list = list$1;
     for(;;){
      if(! list) return s;
      var
       list$0 = list[2],
       x = list[1],
       s$0 = caml_call2(hash_fold_elem, s, x);
      s = s$0;
      list = list$0;
     }
    }
    function hash_fold_lazy_t(hash_fold_elem, s, x){
     var
      _$_ = runtime.caml_obj_tag(x),
      _aa_ =
        250 === _$_
         ? x[1]
         : 246 === _$_ ? caml_call1(CamlinternalLazy[2], x) : x;
     return caml_call2(hash_fold_elem, s, _aa_);
    }
    function hash_fold_ref_frozen(hash_fold_elem, s, x){return caml_call2(hash_fold_elem, s, x[1]);
    }
    function hash_fold_array_frozen(hash_fold_elem, s$1, array){
     var
      s$2 = caml_call2(hash_fold_int, s$1, array.length - 1),
      s = s$2,
      i = 0;
     for(;;){
      if(i === array.length - 1) return s;
      var
       e = array[1 + i],
       i$0 = caml_call2(Base_Import0[90], i, 1),
       s$0 = caml_call2(hash_fold_elem, s, e);
      s = s$0;
      i = i$0;
     }
    }
    function hash_nativeint(x){
     var
      _Z_ = caml_call1(Hash[6], 0),
      ___ = hash_fold_nativeint(caml_call2(Hash[7], 0, _Z_), x);
     return caml_call1(Hash[8], ___);
    }
    function hash_int64(x){
     var
      _X_ = caml_call1(Hash[6], 0),
      _Y_ = caml_call2(hash_fold_int64, caml_call2(Hash[7], 0, _X_), x);
     return caml_call1(Hash[8], _Y_);
    }
    function hash_int32(x){
     var
      _V_ = caml_call1(Hash[6], 0),
      _W_ = as_int(_H_, caml_call2(Hash[7], 0, _V_), x);
     return caml_call1(Hash[8], _W_);
    }
    function hash_char(x){
     var
      _T_ = caml_call1(Hash[6], 0),
      _U_ = as_int(_I_, caml_call2(Hash[7], 0, _T_), x);
     return caml_call1(Hash[8], _U_);
    }
    function hash_int(x){
     var
      _R_ = caml_call1(Hash[6], 0),
      _S_ = caml_call2(hash_fold_int, caml_call2(Hash[7], 0, _R_), x);
     return caml_call1(Hash[8], _S_);
    }
    function hash_bool(x){
     var
      _P_ = caml_call1(Hash[6], 0),
      _Q_ = as_int(_J_, caml_call2(Hash[7], 0, _P_), x);
     return caml_call1(Hash[8], _Q_);
    }
    function hash_string(x){
     var
      _N_ = caml_call1(Hash[6], 0),
      _O_ = caml_call2(hash_fold_string, caml_call2(Hash[7], 0, _N_), x);
     return caml_call1(Hash[8], _O_);
    }
    function hash_float(x){
     var
      _L_ = caml_call1(Hash[6], 0),
      _M_ = caml_call2(hash_fold_float, caml_call2(Hash[7], 0, _L_), x);
     return caml_call1(Hash[8], _M_);
    }
    function hash_unit(x){
     var _K_ = caml_call1(Hash[6], 0), s = caml_call2(Hash[7], 0, _K_);
     return caml_call1(Hash[8], s);
    }
    return [0,
            hash_fold_nativeint,
            hash_fold_int64,
            hash_fold_int32,
            hash_fold_char,
            hash_fold_int,
            hash_fold_bool,
            hash_fold_string,
            hash_fold_float,
            hash_fold_unit,
            hash_fold_option,
            hash_fold_list,
            hash_fold_lazy_t,
            hash_fold_ref_frozen,
            hash_fold_array_frozen,
            hash_nativeint,
            hash_int64,
            hash_int32,
            hash_char,
            hash_int,
            hash_bool,
            hash_string,
            hash_float,
            hash_unit];
   }
   function F(Hash){
    var
     description = Hash[1],
     fold_int = Hash[2],
     fold_int64 = Hash[3],
     fold_float = Hash[4],
     fold_string = Hash[5],
     alloc = Hash[6],
     reset = Hash[7],
     get_hash_value = Hash[8],
     For_tests = Hash[9];
    function create(seed, param){
     return caml_call2(reset, seed, caml_call1(alloc, 0));
    }
    function of_fold(hash_fold_t, t){
     return caml_call1
             (get_hash_value, caml_call2(hash_fold_t, create(0, 0), t));
    }
    var Builtin = Folding(Hash);
    function run(seed, folder, x){
     var
      _F_ = caml_call1(Hash[6], 0),
      _G_ = caml_call2(folder, caml_call2(Hash[7], seed, _F_), x);
     return caml_call1(Hash[8], _G_);
    }
    return [0,
            description,
            fold_int,
            fold_int64,
            fold_float,
            fold_string,
            alloc,
            reset,
            get_hash_value,
            For_tests,
            create,
            of_fold,
            Builtin,
            run];
   }
   function alloc(param){return 0;}
   function reset(opt, t){
    if(opt) var sth = opt[1], seed = sth; else var seed = 0;
    return seed;
   }
   var compare_state = runtime.caml_int_compare;
   function state_to_string(state){return caml_call1(Base_Int0[1], state);}
   var For_tests = [0, compare_state, state_to_string];
   function create(seed, param){return reset(seed, 0);}
   function run(seed, folder, x){
    return runtime.Base_internalhash_get_hash_value
            (caml_call2(folder, reset(seed, 0), x));
   }
   function of_fold(hash_fold_t, t){
    return runtime.Base_internalhash_get_hash_value
            (caml_call2(hash_fold_t, create(0, 0), t));
   }
   var
    Folding$0 =
      Folding
       ([0,
         description,
         function(_E_, _D_){
          return runtime.Base_internalhash_fold_int(_E_, _D_);
         },
         function(_C_, _B_){
          return runtime.Base_internalhash_fold_int64(_C_, _B_);
         },
         function(_A_, _z_){
          return runtime.Base_internalhash_fold_float(_A_, _z_);
         },
         function(_y_, _x_){
          return runtime.Base_internalhash_fold_string(_y_, _x_);
         },
         alloc,
         reset,
         function(_w_){return runtime.Base_internalhash_get_hash_value(_w_);},
         For_tests]),
    hash_fold_nativeint = Folding$0[1],
    hash_fold_int64 = Folding$0[2],
    hash_fold_int32 = Folding$0[3],
    hash_fold_char = Folding$0[4],
    hash_fold_int = Folding$0[5],
    hash_fold_bool = Folding$0[6],
    hash_fold_string = Folding$0[7],
    hash_fold_float = Folding$0[8],
    hash_fold_unit = Folding$0[9],
    hash_fold_option = Folding$0[10],
    hash_fold_list = Folding$0[11],
    hash_fold_lazy_t = Folding$0[12],
    hash_fold_ref_frozen = Folding$0[13],
    hash_fold_array_frozen = Folding$0[14],
    hash_nativeint = Folding$0[15],
    hash_int64 = Folding$0[16],
    hash_int32 = Folding$0[17],
    hash_string = Folding$0[21],
    hash_char = Base_Char0[4];
   function hash_int(t){
    var
     _k_ = caml_call2(Base_Import0[118], t, 21),
     _l_ = caml_call1(Base_Import0[116], t),
     t$0 = caml_call2(Base_Import0[90], _l_, _k_),
     _m_ = caml_call2(Base_Import0[119], t$0, 24),
     t$1 = caml_call2(Base_Import0[120], t$0, _m_),
     _n_ = caml_call2(Base_Import0[118], t$1, 8),
     _o_ = caml_call2(Base_Import0[118], t$1, 3),
     _p_ = caml_call2(Base_Import0[90], t$1, _o_),
     t$2 = caml_call2(Base_Import0[90], _p_, _n_),
     _q_ = caml_call2(Base_Import0[119], t$2, 14),
     t$3 = caml_call2(Base_Import0[120], t$2, _q_),
     _r_ = caml_call2(Base_Import0[118], t$3, 4),
     _s_ = caml_call2(Base_Import0[118], t$3, 2),
     _t_ = caml_call2(Base_Import0[90], t$3, _s_),
     t$4 = caml_call2(Base_Import0[90], _t_, _r_),
     _u_ = caml_call2(Base_Import0[119], t$4, 28),
     t$5 = caml_call2(Base_Import0[120], t$4, _u_),
     _v_ = caml_call2(Base_Import0[118], t$5, 31);
    return caml_call2(Base_Import0[90], t$5, _v_);
   }
   function hash_bool(x){return x ? 1 : 0;}
   function hash_unit(param){return 0;}
   var
    Base_Hash =
      [0,
       F,
       description,
       function(_j_, _i_){
        return runtime.Base_internalhash_fold_int(_j_, _i_);
       },
       function(_h_, _g_){
        return runtime.Base_internalhash_fold_int64(_h_, _g_);
       },
       function(_f_, _e_){
        return runtime.Base_internalhash_fold_float(_f_, _e_);
       },
       function(_d_, _c_){
        return runtime.Base_internalhash_fold_string(_d_, _c_);
       },
       alloc,
       reset,
       function(_b_){return runtime.Base_internalhash_get_hash_value(_b_);},
       For_tests,
       create,
       of_fold,
       [0,
        hash_fold_nativeint,
        hash_fold_int64,
        hash_fold_int32,
        hash_fold_char,
        hash_fold_int,
        hash_fold_bool,
        hash_fold_string,
        hash_fold_float,
        hash_fold_unit,
        hash_fold_option,
        hash_fold_list,
        hash_fold_lazy_t,
        hash_fold_ref_frozen,
        hash_fold_array_frozen,
        hash_nativeint,
        hash_int64,
        hash_int32,
        hash_char,
        hash_int,
        hash_bool,
        hash_string,
        function(_a_){return runtime.Base_hash_double(_a_);},
        hash_unit],
       run];
   runtime.caml_register_global(6, Base_Hash, "Base__Hash");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_compare_lib
//# unitInfo: Requires: Base__Import0, Base__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_which_is_abstract_in_an_im =
      ", which is abstract in an implementation.",
    caml_equal = runtime.caml_equal,
    caml_float_compare = runtime.caml_float_compare,
    caml_int_compare = runtime.caml_int_compare;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Printf = global_data.Base__Printf,
    phys_equal = Base_Import0[127],
    _a_ =
      [0,
       [11,
        "Compare called on the type ",
        [2, 0, [11, cst_which_is_abstract_in_an_im, 0]]],
       "Compare called on the type %s, which is abstract in an implementation."],
    _b_ =
      [0,
       [11,
        "Equal called on the type ",
        [2, 0, [11, cst_which_is_abstract_in_an_im, 0]]],
       "Equal called on the type %s, which is abstract in an implementation."];
   function compare_abstract(type_name, param, _u_){
    return caml_call3(Base_Printf[4], Base_Import0[123], _a_, type_name);
   }
   function equal_abstract(type_name, param, _t_){
    return caml_call3(Base_Printf[4], Base_Import0[123], _b_, type_name);
   }
   var
    Comparable = [0],
    Equal = [0],
    compare_bool = caml_int_compare,
    compare_char = caml_int_compare,
    compare_float = caml_float_compare,
    compare_int = caml_int_compare,
    compare_int32 = caml_int_compare;
   function compare_int64(_s_, _r_){
    return runtime.caml_int64_compare(_s_, _r_);
   }
   var
    compare_nativeint = caml_int_compare,
    compare_string = runtime.caml_string_compare,
    compare_unit = caml_int_compare;
   function compare_array(compare_elt, a, b){
    if(caml_call2(phys_equal, a, b)) return 0;
    var
     len_a = a.length - 1,
     len_b = b.length - 1,
     ret = caml_int_compare(len_a, len_b);
    if(0 !== ret) return ret;
    var i = 0;
    for(;;){
     if(i === len_a) return 0;
     var l = a[1 + i], r = b[1 + i], res = caml_call2(compare_elt, l, r);
     if(0 !== res) return res;
     var i$0 = caml_call2(Base_Import0[90], i, 1);
     i = i$0;
    }
   }
   function compare_list(compare_elt, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      res = caml_call2(compare_elt, x, y);
     if(0 !== res) return res;
     a$0 = xs;
     b$0 = ys;
    }
   }
   function compare_option(compare_elt, a, b){
    if(! a) return b ? -1 : 0;
    var a$0 = a[1];
    if(! b) return 1;
    var b$0 = b[1];
    return caml_call2(compare_elt, a$0, b$0);
   }
   function compare_ref(compare_elt, a, b){
    return caml_call2(compare_elt, a[1], b[1]);
   }
   function equal_bool(_q_, _p_){return _q_ === _p_ ? 1 : 0;}
   function equal_char(_o_, _n_){return _o_ === _n_ ? 1 : 0;}
   function equal_int(_m_, _l_){return _m_ === _l_ ? 1 : 0;}
   var
    equal_int32 = caml_equal,
    equal_int64 = caml_equal,
    equal_nativeint = caml_equal,
    equal_string = runtime.caml_string_equal;
   function equal_unit(_k_, _j_){return _k_ === _j_ ? 1 : 0;}
   function equal_float(x, y){return caml_float_compare(x, y) === 0 ? 1 : 0;}
   function equal_array(equal_elt, a, b){
    var _d_ = caml_call2(phys_equal, a, b);
    if(_d_)
     var _e_ = _d_;
    else{
     var
      len_a = a.length - 1,
      len_b = b.length - 1,
      _f_ = len_a === len_b ? 1 : 0;
     if(_f_){
      var i = 0;
      for(;;){
       var _g_ = i === len_a ? 1 : 0;
       if(_g_)
        var _h_ = _g_;
       else{
        var l = a[1 + i], r = b[1 + i], _i_ = caml_call2(equal_elt, l, r);
        if(_i_){
         var i$0 = caml_call2(Base_Import0[90], i, 1);
         i = i$0;
         continue;
        }
        var _h_ = _i_;
       }
       return _h_;
      }
     }
     var _e_ = _f_;
    }
    return _e_;
   }
   function equal_list(equal_elt, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(a$0){
      if(b$0){
       var
        ys = b$0[2],
        y = b$0[1],
        xs = a$0[2],
        x = a$0[1],
        _c_ = caml_call2(equal_elt, x, y);
       if(! _c_) return _c_;
       a$0 = xs;
       b$0 = ys;
       continue;
      }
     }
     else if(! b$0) return 1;
     return 0;
    }
   }
   function equal_option(equal_elt, a, b){
    if(a){
     if(b){
      var b$0 = b[1], a$0 = a[1];
      return caml_call2(equal_elt, a$0, b$0);
     }
    }
    else if(! b) return 1;
    return 0;
   }
   function equal_ref(equal_elt, a, b){
    return caml_call2(equal_elt, a[1], b[1]);
   }
   var
    Base_Ppx_compare_lib =
      [0,
       phys_equal,
       compare_abstract,
       equal_abstract,
       Comparable,
       Equal,
       [0,
        compare_bool,
        compare_char,
        compare_float,
        compare_int,
        compare_int32,
        compare_int64,
        compare_nativeint,
        compare_string,
        compare_unit,
        compare_array,
        compare_list,
        compare_option,
        compare_ref,
        equal_bool,
        equal_char,
        equal_float,
        equal_int,
        equal_int32,
        equal_int64,
        equal_nativeint,
        equal_string,
        equal_unit,
        equal_array,
        equal_list,
        equal_option,
        equal_ref]];
   runtime.caml_register_global
    (4, Base_Ppx_compare_lib, "Base__Ppx_compare_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_hash_lib
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Std = [0],
    Hashable = [0],
    Base_Ppx_hash_lib = [0, Std, Hashable];
   runtime.caml_register_global(0, Base_Ppx_hash_lib, "Base__Ppx_hash_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexp
//# unitInfo: Requires: Base__Hash, Base__Ppx_compare_lib, Sexplib0__Sexp, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp = global_data.Sexplib0__Sexp,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    t_of_sexp = Sexplib0_Sexp[1],
    sexp_of_t = Sexplib0_Sexp[2],
    equal = Sexplib0_Sexp[3],
    Not_found_s = Sexplib0_Sexp[5],
    Of_sexp_error = Sexplib0_Sexp[6],
    message = Sexplib0_Sexp[7],
    default_indent = Sexplib0_Sexp[8],
    pp_hum = Sexplib0_Sexp[9],
    pp_hum_indent = Sexplib0_Sexp[10],
    pp_mach = Sexplib0_Sexp[11],
    pp = Sexplib0_Sexp[12],
    to_string_hum = Sexplib0_Sexp[13],
    to_string_mach = Sexplib0_Sexp[14],
    to_string = Sexplib0_Sexp[15],
    of_float_style = Sexplib0_Sexp[16],
    of_int_style = Sexplib0_Sexp[17],
    Private = Sexplib0_Sexp[18];
   function compare(a_001, b_002){
    if(caml_call2(Base_Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(0 === a_001[0]){
     var a_003 = a_001[1];
     if(0 !== b_002[0]) return -1;
     var b_004 = b_002[1];
     return caml_call2(Base_Ppx_compare_lib[6][8], a_003, b_004);
    }
    var a_005 = a_001[1];
    if(0 === b_002[0]) return 1;
    var b_006 = b_002[1];
    return caml_call3(Base_Ppx_compare_lib[6][11], compare, a_005, b_006);
   }
   var
    hash_fold_t = function _f_(_d_, _e_){return _f_.fun(_d_, _e_);},
    hash = function _c_(_b_){return _c_.fun(_b_);};
   caml_update_dummy
    (hash_fold_t,
     function(hsv, arg){
      if(0 === arg[0]){
       var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
       return caml_call2(Base_Hash[13][7], hsv$0, a0);
      }
      var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
      return caml_call3(Base_Hash[13][11], hash_fold_t, hsv$1, a0$0);
     });
   caml_update_dummy
    (hash,
     function(arg){
      var
       hsv = caml_call2(Base_Hash[11], 0, 0),
       _a_ = caml_call2(hash_fold_t, hsv, arg);
      return caml_call1(Base_Hash[9], _a_);
     });
   var t_sexp_grammar = Sexplib0_Sexp_conv[59];
   function invariant(param){return 0;}
   var
    Base_Sexp =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       Private,
       t_sexp_grammar,
       invariant,
       0];
   runtime.caml_register_global(4, Base_Sexp, "Base__Sexp");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Import
//# unitInfo: Requires: Base__Hash, Base__Import0, Base__Ppx_compare_lib, Base__Sexp, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Sexp = global_data.Base__Sexp,
    Exit = Base_Import0[1],
    Not_found = Base_Import0[2],
    max_int = Base_Import0[3],
    min_int = Base_Import0[4],
    infinity = Base_Import0[5],
    neg_infinity = Base_Import0[6],
    nan = Base_Import0[7],
    max_float = Base_Import0[8],
    min_float = Base_Import0[9],
    epsilon_float = Base_Import0[10],
    char_of_int = Base_Import0[11],
    string_of_bool = Base_Import0[12],
    bool_of_string_opt = Base_Import0[13],
    bool_of_string = Base_Import0[14],
    string_of_int = Base_Import0[15],
    int_of_string_opt = Base_Import0[16],
    string_of_float = Base_Import0[17],
    float_of_string_opt = Base_Import0[18],
    stdin = Base_Import0[19],
    stdout = Base_Import0[20],
    stderr = Base_Import0[21],
    print_char = Base_Import0[22],
    print_string = Base_Import0[23],
    print_bytes = Base_Import0[24],
    print_int = Base_Import0[25],
    print_float = Base_Import0[26],
    print_endline = Base_Import0[27],
    print_newline = Base_Import0[28],
    prerr_char = Base_Import0[29],
    prerr_string = Base_Import0[30],
    prerr_bytes = Base_Import0[31],
    prerr_int = Base_Import0[32],
    prerr_float = Base_Import0[33],
    prerr_endline = Base_Import0[34],
    prerr_newline = Base_Import0[35],
    read_line = Base_Import0[36],
    read_int_opt = Base_Import0[37],
    read_int = Base_Import0[38],
    read_float_opt = Base_Import0[39],
    read_float = Base_Import0[40],
    open_out = Base_Import0[41],
    open_out_bin = Base_Import0[42],
    open_out_gen = Base_Import0[43],
    flush = Base_Import0[44],
    flush_all = Base_Import0[45],
    output_char = Base_Import0[46],
    output_string = Base_Import0[47],
    output_bytes = Base_Import0[48],
    output = Base_Import0[49],
    output_substring = Base_Import0[50],
    output_byte = Base_Import0[51],
    output_binary_int = Base_Import0[52],
    output_value = Base_Import0[53],
    seek_out = Base_Import0[54],
    pos_out = Base_Import0[55],
    out_channel_length = Base_Import0[56],
    close_out = Base_Import0[57],
    close_out_noerr = Base_Import0[58],
    set_binary_mode_out = Base_Import0[59],
    open_in = Base_Import0[60],
    open_in_bin = Base_Import0[61],
    open_in_gen = Base_Import0[62],
    input_char = Base_Import0[63],
    input_line = Base_Import0[64],
    input = Base_Import0[65],
    really_input = Base_Import0[66],
    really_input_string = Base_Import0[67],
    input_byte = Base_Import0[68],
    input_binary_int = Base_Import0[69],
    input_value = Base_Import0[70],
    seek_in = Base_Import0[71],
    pos_in = Base_Import0[72],
    in_channel_length = Base_Import0[73],
    close_in = Base_Import0[74],
    close_in_noerr = Base_Import0[75],
    set_binary_mode_in = Base_Import0[76],
    string_of_format = Base_Import0[77],
    symbol = Base_Import0[78],
    exit = Base_Import0[79],
    at_exit = Base_Import0[80],
    valid_float_lexem = Base_Import0[81],
    unsafe_really_input = Base_Import0[82],
    do_at_exit = Base_Import0[83],
    Caml = Base_Import0[84],
    bool_to_int = Base_Import0[85],
    symbol$0 = Base_Import0[86],
    symbol$1 = Base_Import0[87],
    symbol$2 = Base_Import0[88],
    symbol$3 = Base_Import0[89],
    symbol$4 = Base_Import0[90],
    symbol$5 = Base_Import0[91],
    symbol$6 = Base_Import0[92],
    symbol$7 = Base_Import0[93],
    symbol$8 = Base_Import0[94],
    symbol$9 = Base_Import0[95],
    Int_replace_polymorphic_compar = Base_Import0[96],
    ascending = Base_Import0[97],
    descending = Base_Import0[98],
    max = Base_Import0[99],
    min = Base_Import0[100],
    Int32_replace_polymorphic_comp = Base_Import0[101],
    Int64_replace_polymorphic_comp = Base_Import0[102],
    Nativeint_replace_polymorphic_ = Base_Import0[103],
    Bool_replace_polymorphic_compa = Base_Import0[104],
    Char_replace_polymorphic_compa = Base_Import0[105],
    Uchar_replace_polymorphic_comp = Base_Import0[106],
    Float_replace_polymorphic_comp = Base_Import0[107],
    String_replace_polymorphic_com = Base_Import0[108],
    Bytes_replace_polymorphic_comp = Base_Import0[109],
    symbol$10 = Base_Import0[110],
    symbol_concat = Base_Import0[111],
    symbol$11 = Base_Import0[112],
    symbol$12 = Base_Import0[113],
    asr = Base_Import0[114],
    land = Base_Import0[115],
    lnot = Base_Import0[116],
    lor = Base_Import0[117],
    lsl = Base_Import0[118],
    lsr = Base_Import0[119],
    lxor = Base_Import0[120],
    mod = Base_Import0[121],
    abs = Base_Import0[122],
    failwith = Base_Import0[123],
    fst = Base_Import0[124],
    invalid_arg = Base_Import0[125],
    snd = Base_Import0[126],
    phys_equal = Base_Import0[127],
    decr = Base_Import0[128],
    incr = Base_Import0[129],
    float_of_string = Base_Import0[130],
    am_testing = Base_Import0[131],
    default_string_of_float = Sexplib0_Sexp_conv[1],
    write_old_option_format = Sexplib0_Sexp_conv[2],
    read_old_option_format = Sexplib0_Sexp_conv[3],
    list_map = Sexplib0_Sexp_conv[4],
    sexp_of_unit = Sexplib0_Sexp_conv[5],
    sexp_of_bool = Sexplib0_Sexp_conv[6],
    sexp_of_string = Sexplib0_Sexp_conv[7],
    sexp_of_bytes = Sexplib0_Sexp_conv[8],
    sexp_of_char = Sexplib0_Sexp_conv[9],
    sexp_of_int = Sexplib0_Sexp_conv[10],
    sexp_of_float = Sexplib0_Sexp_conv[11],
    sexp_of_int32 = Sexplib0_Sexp_conv[12],
    sexp_of_int64 = Sexplib0_Sexp_conv[13],
    sexp_of_nativeint = Sexplib0_Sexp_conv[14],
    sexp_of_ref = Sexplib0_Sexp_conv[15],
    sexp_of_lazy_t = Sexplib0_Sexp_conv[16],
    sexp_of_option = Sexplib0_Sexp_conv[17],
    sexp_of_pair = Sexplib0_Sexp_conv[18],
    sexp_of_triple = Sexplib0_Sexp_conv[19],
    sexp_of_list = Sexplib0_Sexp_conv[20],
    sexp_of_array = Sexplib0_Sexp_conv[21],
    sexp_of_hashtbl = Sexplib0_Sexp_conv[22],
    sexp_of_opaque = Sexplib0_Sexp_conv[23],
    sexp_of_fun = Sexplib0_Sexp_conv[24],
    Of_sexp_error = Sexplib0_Sexp_conv[25],
    record_check_extra_fields = Sexplib0_Sexp_conv[26],
    of_sexp_error = Sexplib0_Sexp_conv[27],
    of_sexp_error_exn = Sexplib0_Sexp_conv[28],
    unit_of_sexp = Sexplib0_Sexp_conv[29],
    bool_of_sexp = Sexplib0_Sexp_conv[30],
    string_of_sexp = Sexplib0_Sexp_conv[31],
    bytes_of_sexp = Sexplib0_Sexp_conv[32],
    char_of_sexp = Sexplib0_Sexp_conv[33],
    int_of_sexp = Sexplib0_Sexp_conv[34],
    float_of_sexp = Sexplib0_Sexp_conv[35],
    int32_of_sexp = Sexplib0_Sexp_conv[36],
    int64_of_sexp = Sexplib0_Sexp_conv[37],
    nativeint_of_sexp = Sexplib0_Sexp_conv[38],
    ref_of_sexp = Sexplib0_Sexp_conv[39],
    lazy_t_of_sexp = Sexplib0_Sexp_conv[40],
    option_of_sexp = Sexplib0_Sexp_conv[41],
    pair_of_sexp = Sexplib0_Sexp_conv[42],
    triple_of_sexp = Sexplib0_Sexp_conv[43],
    list_of_sexp = Sexplib0_Sexp_conv[44],
    array_of_sexp = Sexplib0_Sexp_conv[45],
    hashtbl_of_sexp = Sexplib0_Sexp_conv[46],
    opaque_of_sexp = Sexplib0_Sexp_conv[47],
    fun_of_sexp = Sexplib0_Sexp_conv[48],
    unit_sexp_grammar = Sexplib0_Sexp_conv[49],
    bool_sexp_grammar = Sexplib0_Sexp_conv[50],
    string_sexp_grammar = Sexplib0_Sexp_conv[51],
    bytes_sexp_grammar = Sexplib0_Sexp_conv[52],
    char_sexp_grammar = Sexplib0_Sexp_conv[53],
    int_sexp_grammar = Sexplib0_Sexp_conv[54],
    float_sexp_grammar = Sexplib0_Sexp_conv[55],
    int32_sexp_grammar = Sexplib0_Sexp_conv[56],
    int64_sexp_grammar = Sexplib0_Sexp_conv[57],
    nativeint_sexp_grammar = Sexplib0_Sexp_conv[58],
    sexp_t_sexp_grammar = Sexplib0_Sexp_conv[59],
    ref_sexp_grammar = Sexplib0_Sexp_conv[60],
    lazy_t_sexp_grammar = Sexplib0_Sexp_conv[61],
    option_sexp_grammar = Sexplib0_Sexp_conv[62],
    list_sexp_grammar = Sexplib0_Sexp_conv[63],
    array_sexp_grammar = Sexplib0_Sexp_conv[64],
    opaque_sexp_grammar = Sexplib0_Sexp_conv[65],
    fun_sexp_grammar = Sexplib0_Sexp_conv[66],
    sexp_of_exn = Sexplib0_Sexp_conv[67],
    printexc_prefer_sexp = Sexplib0_Sexp_conv[68],
    sexp_of_exn_opt = Sexplib0_Sexp_conv[69],
    Exn_converter = Sexplib0_Sexp_conv[70],
    _a_ = Base_Hash[13],
    hash_fold_nativeint = _a_[1],
    hash_fold_int64 = _a_[2],
    hash_fold_int32 = _a_[3],
    hash_fold_char = _a_[4],
    hash_fold_int = _a_[5],
    hash_fold_bool = _a_[6],
    hash_fold_string = _a_[7],
    hash_fold_float = _a_[8],
    hash_fold_unit = _a_[9],
    hash_fold_option = _a_[10],
    hash_fold_list = _a_[11],
    hash_fold_lazy_t = _a_[12],
    hash_fold_ref_frozen = _a_[13],
    hash_fold_array_frozen = _a_[14],
    hash_nativeint = _a_[15],
    hash_int64 = _a_[16],
    hash_int32 = _a_[17],
    hash_char = _a_[18],
    hash_int = _a_[19],
    hash_bool = _a_[20],
    hash_string = _a_[21],
    hash_float = _a_[22],
    hash_unit = _a_[23],
    include = Base_Ppx_compare_lib[6],
    compare_bool = include[1],
    compare_char = include[2],
    compare_float = include[3],
    compare_int = include[4],
    compare_int32 = include[5],
    compare_int64 = include[6],
    compare_nativeint = include[7],
    compare_string = include[8],
    compare_unit = include[9],
    compare_array = include[10],
    compare_list = include[11],
    compare_option = include[12],
    compare_ref = include[13],
    equal_bool = include[14],
    equal_char = include[15],
    equal_float = include[16],
    equal_int = include[17],
    equal_int32 = include[18],
    equal_int64 = include[19],
    equal_nativeint = include[20],
    equal_string = include[21],
    equal_unit = include[22],
    equal_array = include[23],
    equal_list = include[24],
    equal_option = include[25],
    equal_ref = include[26],
    Not_found_s = Base_Sexp[7],
    Base_Import =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       Caml,
       bool_to_int,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       Int_replace_polymorphic_compar,
       ascending,
       descending,
       max,
       min,
       Int32_replace_polymorphic_comp,
       Int64_replace_polymorphic_comp,
       Nativeint_replace_polymorphic_,
       Bool_replace_polymorphic_compa,
       Char_replace_polymorphic_compa,
       Uchar_replace_polymorphic_comp,
       Float_replace_polymorphic_comp,
       String_replace_polymorphic_com,
       Bytes_replace_polymorphic_comp,
       symbol$10,
       symbol_concat,
       symbol$11,
       symbol$12,
       asr,
       land,
       lnot,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs,
       failwith,
       fst,
       invalid_arg,
       snd,
       phys_equal,
       decr,
       incr,
       float_of_string,
       am_testing,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       Exn_converter,
       hash_fold_nativeint,
       hash_fold_int64,
       hash_fold_int32,
       hash_fold_char,
       hash_fold_int,
       hash_fold_bool,
       hash_fold_string,
       hash_fold_float,
       hash_fold_unit,
       hash_fold_option,
       hash_fold_list,
       hash_fold_lazy_t,
       hash_fold_ref_frozen,
       hash_fold_array_frozen,
       hash_nativeint,
       hash_int64,
       hash_int32,
       hash_char,
       hash_int,
       hash_bool,
       hash_string,
       hash_float,
       hash_unit,
       compare_bool,
       compare_char,
       compare_float,
       compare_int,
       compare_int32,
       compare_int64,
       compare_nativeint,
       compare_string,
       compare_unit,
       compare_array,
       compare_list,
       compare_option,
       compare_ref,
       equal_bool,
       equal_char,
       equal_float,
       equal_int,
       equal_int32,
       equal_int64,
       equal_nativeint,
       equal_string,
       equal_unit,
       equal_array,
       equal_list,
       equal_option,
       equal_ref,
       Not_found_s];
   runtime.caml_register_global(5, Base_Import, "Base__Import");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Word_size
//# unitInfo: Requires: Base__Import, Base__Sys0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Sys0 = global_data.Base__Sys0,
    Base_Import = global_data.Base__Import,
    _a_ = [0, "W64"],
    _b_ = [0, "W32"];
   function sexp_of_t(param){return param ? _a_ : _b_;}
   function num_bits(param){return param ? 64 : 32;}
   var
    _c_ = Base_Sys0[7],
    cst_unknown_word_size = "unknown word size",
    word_size =
      32 === _c_
       ? 0
       : 64 === _c_ ? 1 : caml_call1(Base_Import[123], cst_unknown_word_size),
    Base_Word_size = [0, sexp_of_t, num_bits, word_size];
   runtime.caml_register_global(5, Base_Word_size, "Base__Word_size");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Formatter
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Formatter = [0];
   runtime.caml_register_global(0, Base_Formatter, "Base__Formatter");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Pretty_printer
//# unitInfo: Requires: Base__Import, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Import = global_data.Base__Import,
    r = [0, [0, "Base.Sexp.pp_hum", 0]],
    cst_pp = ".pp";
   function all(param){return r[1];}
   function register(p){r[1] = [0, p, r[1]]; return 0;}
   function Register_pp(M){
    var pp = M[1];
    register(caml_call2(Base_Import[111], M[2], cst_pp));
    return [0, pp];
   }
   var
    Base_Pretty_printer =
      [0,
       all,
       function(M){
        var module_name = M[1];
        function pp(formatter, t){
         var _b_ = caml_call1(M[2], t);
         return caml_call2(Stdlib_Format[13], formatter, _b_);
        }
        return [0, Register_pp([0, pp, module_name])[1]];
       },
       function(_a_){return [0, Register_pp(_a_)[1]];},
       register];
   runtime.caml_register_global
    (4, Base_Pretty_printer, "Base__Pretty_printer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Exn
//# unitInfo: Requires: Assert_failure, Base__Import, Base__Pretty_printer, Base__Printf, Base__Sexp, Sexplib0__Sexp_conv, Stdlib__Format, Stdlib__Printexc, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_2 = "<2>",
    cst_src_exn_ml = "src/exn.ml",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Exn",
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Import = global_data.Base__Import,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Sexp = global_data.Base__Sexp,
    Base_Printf = global_data.Base__Printf,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    sexp_of_t = Base_Import[198],
    exit = Base_Import[84][98],
    Finally = [248, "Base__Exn.Finally", caml_fresh_oo_id(0)],
    _a_ = [0, "exn.ml.Finally"],
    _b_ = [0, cst_src_exn_ml, 19, 11];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Finally,
     function(param){
      if(param[1] !== Finally)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
      var
       arg1_002 = param[3],
       arg0_001 = param[2],
       res0_003 = caml_call1(sexp_of_t, arg0_001),
       res1_004 = caml_call1(sexp_of_t, arg1_002);
      return [1, [0, _a_, [0, res0_003, [0, res1_004, 0]]]];
     });
   var
    Reraised = [248, "Base__Exn.Reraised", caml_fresh_oo_id(0)],
    _c_ = [0, "exn.ml.Reraised"],
    _d_ = [0, cst_src_exn_ml, 33, 11];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Reraised,
     function(param){
      if(param[1] !== Reraised)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      var
       arg1_006 = param[3],
       arg0_005 = param[2],
       res0_007 = caml_call1(Base_Import[138], arg0_005),
       res1_008 = caml_call1(sexp_of_t, arg1_006);
      return [1, [0, _c_, [0, res0_007, [0, res1_008, 0]]]];
     });
   var
    Sexp = [248, "Base__Exn.Sexp", caml_fresh_oo_id(0)],
    _e_ = [0, cst_src_exn_ml, 54, 6];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Sexp,
     function(param){
      if(param[1] !== Sexp)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      var t = param[2];
      return t;
     });
   var _f_ = [0, 2];
   function create_s(sexp){return [0, Sexp, sexp];}
   function raise_with_original_backtrace(t, backtrace){
    runtime.caml_restore_raw_backtrace(t, backtrace);
    throw caml_maybe_attach_backtrace(t, 0);
   }
   function reraise(exn, str){
    var exn$0 = [0, Reraised, str, exn];
    if(! runtime.Base_caml_exn_is_most_recent_exn(exn))
     throw caml_maybe_attach_backtrace(exn$0, 1);
    var bt = caml_call1(Stdlib_Printexc[12], 0);
    return raise_with_original_backtrace(exn$0, bt);
   }
   function reraisef(exc, format){
    return caml_call2
            (Base_Printf[4],
             function(str, param){return reraise(exc, str);},
             format);
   }
   function to_string(exc){
    var _u_ = caml_call1(Base_Import[198], exc);
    return caml_call2(Base_Sexp[15], _f_, _u_);
   }
   function to_string_mach(exc){
    var _t_ = caml_call1(Base_Import[198], exc);
    return caml_call1(Base_Sexp[16], _t_);
   }
   var sexp_of_t$0 = Base_Import[198];
   function protectx(f, x, finally$0){
    try{var res = caml_call1(f, x);}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      bt = caml_call1(Stdlib_Printexc[12], 0);
     try{caml_call1(finally$0, x);}
     catch(final_exn$0){
      var final_exn = caml_wrap_exception(final_exn$0);
      return raise_with_original_backtrace([0, Finally, exn, final_exn], bt);
     }
     return raise_with_original_backtrace(exn, bt);
    }
    caml_call1(finally$0, x);
    return res;
   }
   function protect(f, finally$0){return protectx(f, 0, finally$0);}
   function does_raise(f){
    try{caml_call1(f, 0); var _r_ = 0; return _r_;}catch(_s_){return 1;}
   }
   function pp(ppf, t){
    var match = caml_call1(Base_Import[200], t);
    if(match){
     var sexp = match[1];
     return caml_call2(Base_Sexp[11], ppf, sexp);
    }
    var _q_ = caml_call1(Stdlib_Printexc[1], t);
    return caml_call2(Stdlib_Format[13], ppf, _q_);
   }
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    _g_ =
      [0,
       [18,
        [1, [0, [11, cst_2, 0], cst_2]],
        [11,
         "Uncaught exception:",
         [17,
          3,
          [17,
           3,
           [18, [1, [0, 0, ""]], [15, [17, 0, [17, 0, [17, 3, [17, 4, 0]]]]]]]]]],
       "@[<2>Uncaught exception:@\n@\n@[%a@]@]@\n@."],
    _h_ =
      [0,
       [11, "Exn.handle_uncaught could not print; exiting anyway\n", [10, 0]],
       "Exn.handle_uncaught could not print; exiting anyway\n%!"];
   function print_with_backtrace(exc, raw_backtrace){
    caml_call3(Stdlib_Format[131], _g_, pp$0, exc);
    if(caml_call1(Stdlib_Printexc[8], 0))
     caml_call2(Stdlib_Printexc[13], Base_Import[84][39], raw_backtrace);
    return caml_call1(Base_Import[84][62], Base_Import[84][39]);
   }
   function handle_uncaught_aux(do_at_exit, exit, f){
    try{var _m_ = caml_call1(f, 0); return _m_;}
    catch(exc$0){
     var
      exc = caml_wrap_exception(exc$0),
      raw_backtrace = caml_call1(Stdlib_Printexc[12], 0);
     if(do_at_exit) try{caml_call1(Base_Import[84][102], 0);}catch(_p_){}
     try{print_with_backtrace(exc, raw_backtrace);}
     catch(_n_){try{caml_call1(Stdlib_Printf[3], _h_);}catch(_o_){}}
     return caml_call1(exit, 1);
    }
   }
   function handle_uncaught_and_exit(f){
    return handle_uncaught_aux(1, exit, f);
   }
   function handle_uncaught(must_exit, f){
    var exit$0 = must_exit ? exit : function(_l_){return 0;};
    return handle_uncaught_aux(must_exit, exit$0, f);
   }
   function reraise_uncaught(str, func){
    try{var _k_ = caml_call1(func, 0); return _k_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      bt = caml_call1(Stdlib_Printexc[12], 0);
     return raise_with_original_backtrace([0, Reraised, str, exn], bt);
    }
   }
   function raise_without_backtrace(e){
    runtime.Base_clear_caml_backtrace_pos(0);
    throw e;
   }
   function initialize_module(param){
    return caml_call1(Stdlib_Printexc[16], print_with_backtrace);
   }
   function clear_backtrace(_j_){
    return runtime.Base_clear_caml_backtrace_pos(_j_);
   }
   var
    Private = [0, clear_backtrace],
    Base_Exn =
      [0,
       sexp_of_t$0,
       pp$0,
       Finally,
       Reraised,
       create_s,
       raise_without_backtrace,
       raise_with_original_backtrace,
       reraise,
       reraisef,
       to_string,
       to_string_mach,
       protectx,
       protect,
       handle_uncaught,
       handle_uncaught_and_exit,
       reraise_uncaught,
       does_raise,
       function(_i_){return runtime.Base_caml_exn_is_most_recent_exn(_i_);},
       initialize_module,
       Private];
   runtime.caml_register_global(21, Base_Exn, "Base__Exn");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__With_return
//# unitInfo: Requires: Base__Exn, Base__Import
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Exn = global_data.Base__Exn,
    cst_Return = "Return",
    cst_use_of_return_from_a_with_ =
      "use of [return] from a [with_return] that already returned";
   function with_return(f){
    var
     Return = [248, cst_Return, runtime.caml_fresh_oo_id(0)],
     is_alive = [0, 1];
    function return$0(a){
     if(1 - is_alive[1])
      caml_call1(Base_Import[123], cst_use_of_return_from_a_with_);
     return caml_call1(Base_Exn[6], [0, Return, a]);
    }
    try{var a$0 = caml_call1(f, return$0); is_alive[1] = 0; return a$0;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     is_alive[1] = 0;
     if(exn[1] !== Return) throw caml_maybe_attach_backtrace(exn, 0);
     var a = exn[2];
     return a;
    }
   }
   function with_return_option(f){
    return with_return
            (function(return$0){
              caml_call1(f, function(a){return caml_call1(return$0, [0, a]);});
              return 0;
             });
   }
   function prepend(param, f){
    return function(x){return caml_call1(param, caml_call1(f, x));};
   }
   var Base_With_return = [0, with_return, with_return_option, prepend];
   runtime.caml_register_global(4, Base_With_return, "Base__With_return");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Variant
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Variant = [0];
   runtime.caml_register_global(0, Base_Variant, "Base__Variant");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Variantslib
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Variantslib = [0];
   runtime.caml_register_global(0, Base_Variantslib, "Base__Variantslib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Monad_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function S_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Monad_infix = X[3],
     bind = X[4],
     return$0 = X[5],
     map = X[6],
     join = X[7],
     ignore_m = X[8],
     all = X[9],
     all_unit = X[10],
     Let_syntax = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S2_to_S3(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S_to_S_indexed(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Monad_infix = X[3],
     bind = X[4],
     return$0 = X[5],
     map = X[6],
     join = X[7],
     ignore_m = X[8],
     all = X[9],
     all_unit = X[10],
     Let_syntax = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S2_to_S(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit,
            Let_syntax];
   }
   function S3_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S_indexed_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   var
    Base_Monad_intf =
      [0,
       S_to_S2,
       S2_to_S3,
       S_to_S_indexed,
       S2_to_S,
       S3_to_S2,
       S_indexed_to_S2];
   runtime.caml_register_global(0, Base_Monad_intf, "Base__Monad_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Monad
//# unitInfo: Requires: Base__List0, Base__Monad_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_List0 = global_data.Base__List0;
   function Make_general(_o_){
    var bind = _o_[1], return$0 = _o_[3];
    function map_via_bind(ma, f){
     return caml_call2
             (_o_[1],
              ma,
              function(a){
               var _p_ = caml_call1(f, a);
               return caml_call1(_o_[3], _p_);
              });
    }
    var match = _o_[2];
    if(typeof match === "number")
     var map = map_via_bind;
    else
     var x = match[2], map = x;
    function symbol_bind(t, f){return caml_call2(bind, t, f);}
    function symbol_map(t, f){return caml_call2(map, t, f);}
    var
     Monad_infix = [0, symbol_bind, symbol_map],
     symbol_bind$0 = Monad_infix[1],
     symbol_map$0 = Monad_infix[2],
     symbol_bind$1 = Monad_infix[1],
     symbol_map$1 = Monad_infix[2];
    function both(a, b){
     return caml_call2
             (symbol_bind$1,
              a,
              function(a){
               return caml_call2
                       (symbol_map$1, b, function(b){return [0, a, b];});
              });
    }
    var
     Open_on_rhs = [0],
     Let_syntax = [0, return$0, bind, map, both, Open_on_rhs],
     Let_syntax$0 = [0, return$0, symbol_bind$1, symbol_map$1, Let_syntax];
    function join(t){
     return caml_call2(symbol_bind$0, t, function(t){return t;});
    }
    function ignore_m(t){
     return caml_call2(map, t, function(param){return 0;});
    }
    function loop(vs, param){
     if(! param) return caml_call1(return$0, caml_call1(Base_List0[21], vs));
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(v){return loop([0, v, vs], ts);});
    }
    function all(ts){return loop(0, ts);}
    function all_unit(param){
     if(! param) return caml_call1(return$0, 0);
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(param){return all_unit(ts);});
    }
    return [0,
            bind,
            return$0,
            ,
            map,
            Monad_infix,
            symbol_bind$0,
            symbol_map$0,
            Let_syntax$0,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function Make_indexed(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _n_ = Make_general([0, bind, map, return$0]);
    return [0,
            _n_[6],
            _n_[7],
            _n_[8],
            _n_[5],
            _n_[1],
            _n_[2],
            _n_[4],
            _n_[9],
            _n_[10],
            _n_[11],
            _n_[12]];
   }
   function Make3(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _m_ = Make_general([0, bind, map, return$0]);
    return [0,
            _m_[6],
            _m_[7],
            _m_[8],
            _m_[5],
            _m_[1],
            _m_[2],
            _m_[4],
            _m_[9],
            _m_[10],
            _m_[11],
            _m_[12]];
   }
   function Make2(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _l_ = Make_general([0, bind, map, return$0]);
    return [0,
            _l_[6],
            _l_[7],
            _l_[8],
            _l_[5],
            _l_[1],
            _l_[2],
            _l_[4],
            _l_[9],
            _l_[10],
            _l_[11],
            _l_[12]];
   }
   function Make(M){
    var
     bind = M[1],
     return$0 = M[2],
     map = M[3],
     _k_ = Make_general([0, bind, map, return$0]);
    return [0,
            _k_[6],
            _k_[7],
            _k_[5],
            _k_[1],
            _k_[2],
            _k_[4],
            _k_[9],
            _k_[10],
            _k_[11],
            _k_[12],
            _k_[8]];
   }
   function Of_monad_general(Monad, M){
    function return$0(a){
     var _j_ = caml_call1(Monad[3], a);
     return caml_call1(M[2], _j_);
    }
    function bind(t, f){
     var
      _g_ = caml_call1(M[1], t),
      _h_ =
        caml_call2
         (Monad[1],
          _g_,
          function(a){
           var _i_ = caml_call1(f, a);
           return caml_call1(M[1], _i_);
          });
     return caml_call1(M[2], _h_);
    }
    var
     map =
       [0,
        -198771759,
        function(t, f){
         var _e_ = caml_call1(M[1], t), _f_ = caml_call2(Monad[2], _e_, f);
         return caml_call1(M[2], _f_);
        }];
    return Make_general([0, bind, map, return$0]);
   }
   function bind(a, f){return caml_call1(f, a);}
   function return$0(a){return a;}
   var
    map = [0, -198771759, function(a, f){return caml_call1(f, a);}],
    include = Make([0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11],
    Ident =
      [0,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax],
    Base_Monad =
      [0,
       Make,
       Make2,
       Make3,
       Make_indexed,
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[4],
         return$0 = Monad[5],
         map = Monad[6],
         _d_ =
           Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
        return [0,
                _d_[6],
                _d_[7],
                _d_[5],
                _d_[1],
                _d_[2],
                _d_[4],
                _d_[9],
                _d_[10],
                _d_[11],
                _d_[12],
                _d_[8]];
       },
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[5],
         return$0 = Monad[6],
         map = Monad[7],
         _c_ =
           Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
        return [0,
                _c_[6],
                _c_[7],
                _c_[8],
                _c_[5],
                _c_[1],
                _c_[2],
                _c_[4],
                _c_[9],
                _c_[10],
                _c_[11],
                _c_[12]];
       },
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[5],
         return$0 = Monad[6],
         map = Monad[7],
         _b_ =
           Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
        return [0,
                _b_[6],
                _b_[7],
                _b_[8],
                _b_[5],
                _b_[1],
                _b_[2],
                _b_[4],
                _b_[9],
                _b_[10],
                _b_[11],
                _b_[12]];
       },
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[5],
         return$0 = Monad[6],
         map = Monad[7],
         _a_ =
           Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
        return [0,
                _a_[6],
                _a_[7],
                _a_[8],
                _a_[5],
                _a_[1],
                _a_[2],
                _a_[4],
                _a_[9],
                _a_[10],
                _a_[11],
                _a_[12]];
       },
       Ident];
   runtime.caml_register_global(1, Base_Monad, "Base__Monad");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Applicative_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Applicative_intf = [0];
   runtime.caml_register_global
    (0, Base_Applicative_intf, "Base__Applicative_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Applicative
//# unitInfo: Requires: Base__Applicative_intf, Base__Import, Base__List0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_List0 = global_data.Base__List0;
   function S_to_S2(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S2_to_S(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S2_to_S3(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S3_to_S2(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function Make3(_G_){
    var return$0 = _G_[1], symbol = _G_[2];
    function derived_map(t, f){
     return caml_call2(symbol, caml_call1(return$0, f), t);
    }
    var match = _G_[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var x = match[2], map = x;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function map2(ta, tb, f){
     return caml_call2(symbol, caml_call2(map, ta, f), tb);
    }
    function map3(ta, tb, tc, f){
     return caml_call2
             (symbol, caml_call2(symbol, caml_call2(map, ta, f), tb), tc);
    }
    function all(ts){
     function _J_(x, xs){return [0, x, xs];}
     var _I_ = caml_call1(return$0, 0);
     return caml_call3
             (Base_List0[22],
              ts,
              function(_K_){
               return function(_L_){return map2(_K_, _L_, _J_);};
              },
              _I_);
    }
    function both(ta, tb){
     return map2(ta, tb, function(a, b){return [0, a, b];});
    }
    function symbol$0(u, v){
     return caml_call2
             (symbol,
              caml_call2
               (symbol,
                caml_call1(return$0, function(param, y){return y;}),
                u),
              v);
    }
    function symbol$1(u, v){
     return caml_call2
             (symbol,
              caml_call2
               (symbol,
                caml_call1(return$0, function(x, param){return x;}),
                u),
              v);
    }
    function all_unit(ts){
     var _H_ = caml_call1(return$0, 0);
     return caml_call3(Base_List0[8], ts, _H_, symbol$0);
    }
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2(X){
    var return$0 = X[1], apply = X[2], map = X[3];
    return Make3([0, return$0, apply, map]);
   }
   function Make(X){
    var return$0 = X[1], apply = X[2], map = X[3];
    return Make2([0, return$0, apply, map]);
   }
   function Make_let_syntax3(X, Intf, Impl){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     return$1 = X[1],
     map$0 = X[2],
     both$0 = X[3],
     symbol$2 = X[4],
     symbol$3 = X[5],
     symbol$4 = X[6],
     symbol_map$0 = X[7],
     Let_syntax =
       [0,
        return$1,
        map$0,
        both$0,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol_map$0,
        Impl],
     Let_syntax$0 =
       [0,
        return$0,
        map,
        both,
        symbol,
        symbol$0,
        symbol$1,
        symbol_map,
        Let_syntax];
    return [0, Let_syntax$0];
   }
   function Make_let_syntax2(X, Intf, Impl){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7];
    return Make_let_syntax3
            ([0, return$0, map, both, symbol, symbol$0, symbol$1, symbol_map],
             Intf,
             Impl);
   }
   function Make3_using_map2(_z_){
    var return$0 = _z_[1], map2 = _z_[2];
    function symbol(tf, ta){
     return caml_call3(map2, tf, ta, function(f, a){return caml_call1(f, a);});
    }
    function derived_map(t, f){return symbol(caml_call1(return$0, f), t);}
    var match = _z_[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var x = match[2], map = x;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function both(ta, tb){
     return caml_call3(map2, ta, tb, function(a, b){return [0, a, b];});
    }
    function map3(ta, tb, tc, f){
     return caml_call3
             (map2,
              caml_call3(map2, ta, tb, f),
              tc,
              function(fab, c){return caml_call1(fab, c);});
    }
    function all(ts){
     function _C_(x, xs){return [0, x, xs];}
     var _B_ = caml_call1(return$0, 0);
     return caml_call3
             (Base_List0[22],
              ts,
              function(_D_){
               var _E_ = caml_call1(map2, _D_);
               return function(_F_){return caml_call2(_E_, _F_, _C_);};
              },
              _B_);
    }
    function symbol$0(u, v){
     return caml_call3(map2, u, v, function(param, y){return y;});
    }
    function symbol$1(u, v){
     return caml_call3(map2, u, v, function(x, param){return x;});
    }
    function all_unit(ts){
     var _A_ = caml_call1(return$0, 0);
     return caml_call3(Base_List0[8], ts, _A_, symbol$0);
    }
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2_using_map2(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make3_using_map2([0, return$0, map2, map]);
   }
   function Make_using_map2(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make2_using_map2([0, return$0, map2, map]);
   }
   function Of_monad2(M){
    var return$0 = M[6];
    function apply(mf, mx){
     return caml_call2(M[5], mf, function(f){return caml_call2(M[7], mx, f);});
    }
    var map = [0, -198771759, M[7]];
    return Make2([0, return$0, apply, map]);
   }
   function Of_monad(M){
    var
     symbol_bind = M[1],
     symbol_map = M[2],
     Monad_infix = M[3],
     bind = M[4],
     return$0 = M[5],
     map = M[6],
     join = M[7],
     ignore_m = M[8],
     all = M[9],
     all_unit = M[10],
     Let_syntax = M[11];
    return Of_monad2
            ([0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit]);
   }
   function Compose(F, G){
    function return$0(a){
     var _y_ = caml_call1(F[1], a);
     return caml_call1(G[1], _y_);
    }
    function apply(tf, tx){
     var _x_ = caml_call2(G[2], tf, F[8]);
     return caml_call2(G[8], _x_, tx);
    }
    function custom_map(t, f){
     var _v_ = F[2];
     return caml_call2
             (G[2], t, function(_w_){return caml_call2(_v_, _w_, f);});
    }
    var
     map = [0, -198771759, custom_map],
     include = Make([0, return$0, apply, map]),
     return$1 = include[1],
     map$0 = include[2],
     both = include[3],
     symbol = include[4],
     symbol$0 = include[5],
     symbol$1 = include[6],
     symbol_map = include[7],
     apply$0 = include[8],
     map2 = include[9],
     map3 = include[10],
     all = include[11],
     all_unit = include[12],
     Applicative_infix = include[13];
    return [0,
            return$1,
            map$0,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function Pair(F, G){
    function return$0(a){
     var _u_ = caml_call1(G[1], a);
     return [0, caml_call1(F[1], a), _u_];
    }
    function apply(tf, tx){
     var
      _p_ = caml_call1(Base_Import[126], tx),
      _q_ = caml_call1(Base_Import[126], tf),
      _r_ = caml_call2(G[8], _q_, _p_),
      _s_ = caml_call1(Base_Import[124], tx),
      _t_ = caml_call1(Base_Import[124], tf);
     return [0, caml_call2(F[8], _t_, _s_), _r_];
    }
    function custom_map(t, f){
     var
      _m_ = caml_call1(Base_Import[126], t),
      _n_ = caml_call2(G[2], _m_, f),
      _o_ = caml_call1(Base_Import[124], t);
     return [0, caml_call2(F[2], _o_, f), _n_];
    }
    var
     map = [0, -198771759, custom_map],
     include = Make([0, return$0, apply, map]),
     return$1 = include[1],
     map$0 = include[2],
     both = include[3],
     symbol = include[4],
     symbol$0 = include[5],
     symbol$1 = include[6],
     symbol_map = include[7],
     apply$0 = include[8],
     map2 = include[9],
     map3 = include[10],
     all = include[11],
     all_unit = include[12],
     Applicative_infix = include[13];
    return [0,
            return$1,
            map$0,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   var
    Base_Applicative =
      [0,
       S2_to_S,
       S_to_S2,
       S3_to_S2,
       S2_to_S3,
       Make,
       Make2,
       Make3,
       function(X, Intf, Impl){
        var
         return$0 = X[1],
         map = X[2],
         both = X[3],
         symbol = X[4],
         symbol$0 = X[5],
         symbol$1 = X[6],
         symbol_map = X[7],
         _k_ =
           Make_let_syntax2
             ([0, return$0, map, both, symbol, symbol$0, symbol$1, symbol_map],
              Intf,
              Impl)
            [1],
         _l_ = _k_[8];
        return [0,
                [0,
                 _k_[1],
                 _k_[4],
                 _k_[5],
                 _k_[6],
                 _k_[7],
                 [0, _l_[1], _l_[2], _l_[3], _l_[8]]]];
       },
       function(_h_, _g_, _f_){
        var _i_ = Make_let_syntax2(_h_, _g_, _f_)[1], _j_ = _i_[8];
        return [0,
                [0,
                 _i_[1],
                 _i_[4],
                 _i_[5],
                 _i_[6],
                 _i_[7],
                 [0, _j_[1], _j_[2], _j_[3], _j_[8]]]];
       },
       function(_c_, _b_, _a_){
        var _d_ = Make_let_syntax3(_c_, _b_, _a_)[1], _e_ = _d_[8];
        return [0,
                [0,
                 _d_[1],
                 _d_[4],
                 _d_[5],
                 _d_[6],
                 _d_[7],
                 [0, _e_[1], _e_[2], _e_[3], _e_[8]]]];
       },
       Make_using_map2,
       Make2_using_map2,
       Make3_using_map2,
       Of_monad,
       Of_monad2,
       Compose,
       Pair];
   runtime.caml_register_global(2, Base_Applicative, "Base__Applicative");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes0
//# unitInfo: Requires: Base__Sys0, Stdlib__BytesLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Base_Sys0 = global_data.Base__Sys0,
    Primitives = [0],
    max_length = Base_Sys0[10],
    blit = Stdlib_BytesLabels[11],
    blit_string = Stdlib_BytesLabels[12],
    compare = Stdlib_BytesLabels[44],
    copy = Stdlib_BytesLabels[4],
    create = runtime.caml_create_bytes,
    fill = Stdlib_BytesLabels[10],
    make = Stdlib_BytesLabels[1],
    map = Stdlib_BytesLabels[17],
    mapi = Stdlib_BytesLabels[18],
    sub = Stdlib_BytesLabels[7],
    unsafe_blit = runtime.caml_blit_bytes,
    to_string = Stdlib_BytesLabels[6],
    of_string = Stdlib_BytesLabels[5];
   function unsafe_to_string(s){return caml_call1(Stdlib_BytesLabels[48], s);}
   var
    unsafe_of_string_promise_no_mu = Stdlib_BytesLabels[49],
    Base_Bytes0 =
      [0,
       Primitives,
       max_length,
       blit,
       blit_string,
       compare,
       copy,
       create,
       fill,
       make,
       map,
       mapi,
       sub,
       unsafe_blit,
       to_string,
       of_string,
       unsafe_to_string,
       unsafe_of_string_promise_no_mu];
   runtime.caml_register_global(2, Base_Bytes0, "Base__Bytes0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparator
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var Module = [0];
   function make(compare, sexp_of_t){
    var comparator = [0, compare, sexp_of_t];
    return [0, comparator];
   }
   function S_to_S1(S){var comparator = S[1]; return [0, comparator];}
   function Make1(M){
    var comparator = [0, M[1], M[2]];
    return [0, comparator];
   }
   var compare = runtime.caml_compare, _a_ = [0, "_"];
   function sexp_of_t(param){return _a_;}
   var
    include = Make1([0, compare, sexp_of_t]),
    comparator = include[1],
    Poly = [0, comparator];
   function Derived(M){
    function comparator(a){
     var _d_ = caml_call1(M[2], a[2]);
     return [0, caml_call1(M[1], a[1]), _d_];
    }
    return [0, comparator];
   }
   function Derived2(M){
    function comparator(a, b){
     var _c_ = caml_call2(M[2], a[2], b[2]);
     return [0, caml_call2(M[1], a[1], b[1]), _c_];
    }
    return [0, comparator];
   }
   function Derived_phantom(M){
    function comparator(a){
     var _b_ = caml_call1(M[2], a[2]);
     return [0, caml_call1(M[1], a[1]), _b_];
    }
    return [0, comparator];
   }
   var
    Base_Comparator =
      [0,
       make,
       Poly,
       Module,
       S_to_S1,
       function(M){var comparator = [0, M[1], M[2]]; return [0, comparator];},
       Make1,
       Derived,
       Derived2,
       Derived_phantom];
   runtime.caml_register_global(1, Base_Comparator, "Base__Comparator");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparisons
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Comparisons = [0];
   runtime.caml_register_global(0, Base_Comparisons, "Base__Comparisons");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either0
//# unitInfo: Requires: Base__Hash, Base__Ppx_compare_lib, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_First$0 = "First",
    cst_Second$0 = "Second",
    cst_first = "first",
    cst_second = "second";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_011 = "either0.ml.t",
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    _a_ = [0, cst_First$0],
    _b_ = [0, cst_Second$0],
    cst_Second = cst_Second$0,
    cst_First = cst_First$0;
   function compare(cmp_f, cmp_s, a_001, b_002){
    if(caml_call2(Base_Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(0 === a_001[0]){
     var a_003 = a_001[1];
     if(0 !== b_002[0]) return -1;
     var b_004 = b_002[1];
     return caml_call2(cmp_f, a_003, b_004);
    }
    var a_005 = a_001[1];
    if(0 === b_002[0]) return 1;
    var b_006 = b_002[1];
    return caml_call2(cmp_s, a_005, b_006);
   }
   function hash_fold_t(hash_fold_f, hash_fold_s, hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
     return caml_call2(hash_fold_f, hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
    return caml_call2(hash_fold_s, hsv$1, a0$0);
   }
   function t_of_sexp(of_f_007, of_s_008, sexp_013){
    a:
    {
     if(0 === sexp_013[0]){
      var _c_ = sexp_013[1];
      b:
      if(_c_ !== cst_First$0){
       if(_c_ !== cst_Second$0){
        if(_c_ === cst_first) break b;
        if(_c_ !== cst_second) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_011, sexp_013);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_011, sexp_013);
     }
     var _d_ = sexp_013[1];
     if(! _d_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_011, sexp_013);
     var _e_ = _d_[1];
     if(0 !== _e_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_011, sexp_013);
     var tag_014 = _e_[1];
     b:
     if(tag_014 !== cst_First$0){
      if(tag_014 !== cst_Second$0){
       if(tag_014 === cst_first) break b;
       if(tag_014 !== cst_second) break a;
      }
      var sexp_args_020 = _d_[2];
      if(sexp_args_020 && ! sexp_args_020[2]){
       var
        arg0_021 = sexp_args_020[1],
        res0_022 = caml_call1(of_s_008, arg0_021);
       return [1, res0_022];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_011,
               tag_014,
               sexp_013);
     }
     var sexp_args_015 = _d_[2];
     if(sexp_args_015 && ! sexp_args_015[2]){
      var
       arg0_016 = sexp_args_015[1],
       res0_017 = caml_call1(of_f_007, arg0_016);
      return [0, res0_017];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_011,
              tag_014,
              sexp_013);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_011, sexp_013);
   }
   function sexp_of_t(of_f_025, of_s_026, param){
    if(0 === param[0]){
     var arg0_027 = param[1], res0_028 = caml_call1(of_f_025, arg0_027);
     return [1, [0, _a_, [0, res0_028, 0]]];
    }
    var arg0_029 = param[1], res0_030 = caml_call1(of_s_026, arg0_029);
    return [1, [0, _b_, [0, res0_030, 0]]];
   }
   function t_sexp_grammar(f_sexp_grammar, s_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_First, [0, [0, f_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Second, [0, [0, s_sexp_grammar, 0]]]], 0]]]];
   }
   var
    Base_Either0 =
      [0, compare, hash_fold_t, t_of_sexp, sexp_of_t, t_sexp_grammar];
   runtime.caml_register_global(16, Base_Either0, "Base__Either0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Field
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function opaque_identity(_b_){return _b_;}
   var For_generated_code = [0, opaque_identity];
   function name(param){return param[2];}
   function get(param, r){return caml_call1(param[4], r);}
   function fset(param, r, v){return caml_call2(param[5], r, v);}
   function setter(param){return param[3];}
   function map(param, r, f){
    var _a_ = caml_call1(f, caml_call1(param[4], r));
    return caml_call2(param[5], r, _a_);
   }
   function updater(field){
    var match = field[3];
    if(! match) return 0;
    var setter = match[1];
    return [0,
            function(r, f){
             return caml_call2
                     (setter, r, caml_call1(f, caml_call1(field[4], r)));
            }];
   }
   var
    Base_Field =
      [0, For_generated_code, name, get, fset, setter, map, updater];
   runtime.caml_register_global(0, Base_Field, "Base__Field");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String0
//# unitInfo: Requires: Base__Bytes0, Base__Import0, Base__Sys0, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$1 = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Sys0 = global_data.Base__Sys0,
    Base_Import0 = global_data.Base__Import0,
    String = [0],
    max_length = Base_Sys0[10],
    symbol_concat = Base_Import0[111],
    capitalize = Stdlib_StringLabels[27],
    compare = Stdlib_StringLabels[9];
   function copy(x){
    var _a_ = caml_call1(Base_Bytes0[15], x);
    return caml_call1(Base_Bytes0[16], _a_);
   }
   var
    escaped = Stdlib_StringLabels[24],
    lowercase = Stdlib_StringLabels[26],
    make = Stdlib_StringLabels[1],
    sub = Stdlib_StringLabels[15],
    uncapitalize = Stdlib_StringLabels[28],
    unsafe_blit = runtime.caml_blit_string,
    uppercase = Stdlib_StringLabels[25];
   function concat(opt, l){
    if(opt) var sth = opt[1], sep = sth; else var sep = cst$0;
    if(! l) return cst;
    if(l[2]) return caml_call2(Stdlib_StringLabels[6], sep, l);
    var x = l[1];
    return x;
   }
   function iter(t, f){return caml_call2(Stdlib_StringLabels[29], f, t);}
   var
    Base_String0 =
      [0,
       String,
       max_length,
       symbol_concat,
       capitalize,
       compare,
       copy,
       escaped,
       lowercase,
       make,
       sub,
       uncapitalize,
       unsafe_blit,
       uppercase,
       concat,
       iter];
   runtime.caml_register_global(6, Base_String0, "Base__String0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Source_code_position0
//# unitInfo: Requires: Base__Comparator, Base__Hash, Base__Import, Base__Int0, Base__Ppx_compare_lib, Base__String0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$1 = ":";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Base_Import = global_data.Base__Import,
    Base_Int0 = global_data.Base__Int0,
    Base_String0 = global_data.Base__String0,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Comparator = global_data.Base__Comparator,
    _a_ = [0, "pos_cnum"],
    _b_ = [0, "pos_bol"],
    _c_ = [0, "pos_lnum"],
    _d_ = [0, "pos_fname"];
   function compare(a_001, b_002){
    if(caml_call2(Base_Ppx_compare_lib[1], a_001, b_002)) return 0;
    var n = caml_call2(Base_Import[232], a_001[1], b_002[1]);
    if(0 !== n) return n;
    var n$0 = caml_call2(Base_Import[228], a_001[2], b_002[2]);
    if(0 !== n$0) return n$0;
    var n$1 = caml_call2(Base_Import[228], a_001[3], b_002[3]);
    return 0 === n$1 ? caml_call2(Base_Import[228], a_001[4], b_002[4]) : n$1;
   }
   function hash_fold_t(hsv, arg){
    var
     hsv$0 = caml_call2(Base_Import[208], hsv, arg[1]),
     hsv$1 = caml_call2(Base_Import[206], hsv$0, arg[2]),
     hsv$2 = caml_call2(Base_Import[206], hsv$1, arg[3]);
    return caml_call2(Base_Import[206], hsv$2, arg[4]);
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _h_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _h_);
   }
   function sexp_of_t(param){
    var
     pos_cnum_010 = param[4],
     pos_bol_008 = param[3],
     pos_lnum_006 = param[2],
     pos_fname_004 = param[1],
     arg_011 = caml_call1(Base_Import[141], pos_cnum_010),
     bnds_003 = [0, [1, [0, _a_, [0, arg_011, 0]]], 0],
     arg_009 = caml_call1(Base_Import[141], pos_bol_008),
     bnds_003$0 = [0, [1, [0, _b_, [0, arg_009, 0]]], bnds_003],
     arg_007 = caml_call1(Base_Import[141], pos_lnum_006),
     bnds_003$1 = [0, [1, [0, _c_, [0, arg_007, 0]]], bnds_003$0],
     arg_005 = caml_call1(Base_Import[138], pos_fname_004),
     bnds_003$2 = [0, [1, [0, _d_, [0, arg_005, 0]]], bnds_003$1];
    return [1, bnds_003$2];
   }
   var
    T = [0, compare, hash_fold_t, hash, sexp_of_t],
    compare$0 = T[1],
    hash_fold_t$0 = T[2],
    hash$0 = T[3],
    include = caml_call1(Base_Comparator[5], [0, T[1], T[4]]),
    comparator = include[1];
   function make_location_string(pos_fname, pos_lnum, pos_cnum, pos_bol){
    var
     _e_ = caml_call2(Base_Import[92], pos_cnum, pos_bol),
     _f_ = [0, cst, [0, caml_call1(Base_Int0[1], _e_), 0]],
     _g_ =
       [0,
        pos_fname,
        [0, cst$0, [0, caml_call1(Base_Int0[1], pos_lnum), _f_]]];
    return caml_call2(Base_String0[14], 0, _g_);
   }
   function to_string(param){
    var
     pos_cnum = param[4],
     pos_bol = param[3],
     pos_lnum = param[2],
     pos_fname = param[1];
    return make_location_string(pos_fname, pos_lnum, pos_cnum, pos_bol);
   }
   function sexp_of_t$0(t){return [0, to_string(t)];}
   var
    Base_Source_code_position0 =
      [0,
       T,
       compare$0,
       hash_fold_t$0,
       hash$0,
       comparator,
       make_location_string,
       to_string,
       sexp_of_t$0];
   runtime.caml_register_global
    (12, Base_Source_code_position0, "Base__Source_code_position0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Invariant_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Invariant_intf = [0];
   runtime.caml_register_global
    (0, Base_Invariant_intf, "Base__Invariant_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List1
//# unitInfo: Requires: Base__List0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List0 = global_data.Base__List0,
    hd_exn = Base_List0[1],
    length = Base_List0[2],
    rev_append = Base_List0[3],
    tl_exn = Base_List0[4],
    unzip = Base_List0[5],
    exists = Base_List0[6],
    exists2_ok = Base_List0[7],
    fold = Base_List0[8],
    fold2_ok = Base_List0[9],
    for_all = Base_List0[10],
    for_all2_ok = Base_List0[11],
    iter = Base_List0[12],
    iter2_ok = Base_List0[13],
    nontail_map = Base_List0[14],
    nontail_mapi = Base_List0[15],
    partition = Base_List0[16],
    rev_map = Base_List0[17],
    rev_map2_ok = Base_List0[18],
    sort = Base_List0[19],
    stable_sort = Base_List0[20],
    rev = Base_List0[21],
    fold_right = Base_List0[22];
   function is_empty(param){return param ? 0 : 1;}
   function partition_map(t, f){
    var t$0 = t, fst = 0, snd = 0;
    for(;;){
     if(! t$0){
      var _a_ = caml_call1(rev, snd);
      return [0, caml_call1(rev, fst), _a_];
     }
     var t$1 = t$0[2], x = t$0[1], match = caml_call1(f, x);
     if(0 === match[0]){
      var y = match[1], fst$0 = [0, y, fst];
      t$0 = t$1;
      fst = fst$0;
     }
     else{var y$0 = match[1], snd$0 = [0, y$0, snd]; t$0 = t$1; snd = snd$0;}
    }
   }
   var
    Base_List1 =
      [0,
       hd_exn,
       length,
       rev_append,
       tl_exn,
       unzip,
       exists,
       exists2_ok,
       fold,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       sort,
       stable_sort,
       rev,
       fold_right,
       is_empty,
       partition_map];
   runtime.caml_register_global(1, Base_List1, "Base__List1");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Result
//# unitInfo: Requires: Base__Hash, Base__Import, Base__List1, Base__Monad, Base__Ppx_compare_lib, Base__Printf, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Error$0 = "Error",
    cst_Ok$0 = "Ok",
    cst_error = "error",
    cst_ok = "ok",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_005 = "result.ml.t",
    Base_List1 = global_data.Base__List1,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Monad = global_data.Base__Monad,
    _a_ = [0, cst_Ok$0],
    _b_ = [0, cst_Error$0],
    cst_Error = cst_Error$0,
    cst_Ok = cst_Ok$0;
   function t_of_sexp(of_a_001, of_b_002, sexp_007){
    a:
    {
     if(0 === sexp_007[0]){
      var _e_ = sexp_007[1];
      b:
      if(_e_ !== cst_Error$0){
       if(_e_ !== cst_Ok$0){
        if(_e_ === cst_error) break b;
        if(_e_ !== cst_ok) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_005, sexp_007);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_005, sexp_007);
     }
     var _f_ = sexp_007[1];
     if(! _f_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_007);
     var _g_ = _f_[1];
     if(0 !== _g_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_005, sexp_007);
     var tag_008 = _g_[1];
     b:
     if(tag_008 !== cst_Error$0){
      if(tag_008 !== cst_Ok$0){
       if(tag_008 === cst_error) break b;
       if(tag_008 !== cst_ok) break a;
      }
      var sexp_args_009 = _f_[2];
      if(sexp_args_009 && ! sexp_args_009[2]){
       var
        arg0_010 = sexp_args_009[1],
        res0_011 = caml_call1(of_a_001, arg0_010);
       return [0, res0_011];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_005,
               tag_008,
               sexp_007);
     }
     var sexp_args_014 = _f_[2];
     if(sexp_args_014 && ! sexp_args_014[2]){
      var
       arg0_015 = sexp_args_014[1],
       res0_016 = caml_call1(of_b_002, arg0_015);
      return [1, res0_016];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_005,
              tag_008,
              sexp_007);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_005, sexp_007);
   }
   function sexp_of_t(of_a_019, of_b_020, param){
    if(0 === param[0]){
     var arg0_021 = param[1], res0_022 = caml_call1(of_a_019, arg0_021);
     return [1, [0, _a_, [0, res0_022, 0]]];
    }
    var arg0_023 = param[1], res0_024 = caml_call1(of_b_020, arg0_023);
    return [1, [0, _b_, [0, res0_024, 0]]];
   }
   function t_sexp_grammar(a_sexp_grammar, b_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Ok, [0, [0, a_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Error, [0, [0, b_sexp_grammar, 0]]]], 0]]]];
   }
   function compare(cmp_a, cmp_b, a_027, b_028){
    if(caml_call2(Base_Ppx_compare_lib[1], a_027, b_028)) return 0;
    if(0 === a_027[0]){
     var a_029 = a_027[1];
     if(0 !== b_028[0]) return -1;
     var b_030 = b_028[1];
     return caml_call2(cmp_a, a_029, b_030);
    }
    var a_031 = a_027[1];
    if(0 === b_028[0]) return 1;
    var b_032 = b_028[1];
    return caml_call2(cmp_b, a_031, b_032);
   }
   function equal(cmp_a, cmp_b, a_033, b_034){
    if(caml_call2(Base_Ppx_compare_lib[1], a_033, b_034)) return 1;
    if(0 === a_033[0]){
     var a_035 = a_033[1];
     if(0 !== b_034[0]) return 0;
     var b_036 = b_034[1];
     return caml_call2(cmp_a, a_035, b_036);
    }
    var a_037 = a_033[1];
    if(0 === b_034[0]) return 0;
    var b_038 = b_034[1];
    return caml_call2(cmp_b, a_037, b_038);
   }
   function hash_fold_t(hash_fold_a, hash_fold_b, hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
     return caml_call2(hash_fold_a, hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
    return caml_call2(hash_fold_b, hsv$1, a0$0);
   }
   function bind(x, f){
    if(0 !== x[0]) return x;
    var x$0 = x[1];
    return caml_call1(f, x$0);
   }
   var
    map =
      [0,
       -198771759,
       function(x, f){
        if(0 !== x[0]) return x;
        var x$0 = x[1];
        return [0, caml_call1(f, x$0)];
       }];
   function return$0(x){return [0, x];}
   var
    include = caml_call1(Base_Monad[2], [0, bind, map, return$0]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Let_syntax = include[3],
    Monad_infix = include[4],
    bind$0 = include[5],
    return$1 = include[6],
    map$0 = include[7],
    join = include[8],
    ignore_m = include[9],
    all = include[10],
    all_unit = include[11];
   function invariant(check_ok, check_error, t){
    if(0 === t[0]){var ok = t[1]; return caml_call1(check_ok, ok);}
    var error = t[1];
    return caml_call1(check_error, error);
   }
   function fail(x){return [1, x];}
   function failf(format){return caml_call2(Base_Printf[4], fail, format);}
   function map_error(t, f){
    if(0 === t[0]) return t;
    var x = t[1];
    return [1, caml_call1(f, x)];
   }
   function bind$1(x, f){
    if(0 === x[0]) return x;
    var e = x[1];
    return caml_call1(f, e);
   }
   var map$1 = [0, -198771759, map_error];
   function return$2(e){return [1, e];}
   var
    Error = caml_call1(Base_Monad[2], [0, bind$1, map$1, return$2]),
    _c_ = [0, 0];
   function is_ok(param){return 0 === param[0] ? 1 : 0;}
   function is_error(param){return 0 === param[0] ? 0 : 1;}
   function ok(param){
    if(0 !== param[0]) return 0;
    var x = param[1];
    return [0, x];
   }
   function error(param){
    if(0 === param[0]) return 0;
    var x = param[1];
    return [0, x];
   }
   function of_option(opt, error){
    if(! opt) return [1, error];
    var x = opt[1];
    return [0, x];
   }
   function iter(v, f){
    if(0 !== v[0]) return 0;
    var x = v[1];
    return caml_call1(f, x);
   }
   function iter_error(v, f){
    if(0 === v[0]) return 0;
    var x = v[1];
    return caml_call1(f, x);
   }
   function to_either(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var x$0 = param[1];
    return [1, x$0];
   }
   function of_either(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var x$0 = param[1];
    return [1, x$0];
   }
   function ok_if_true(bool, error){return bool ? _c_ : [1, error];}
   function try_with(f){
    try{var _d_ = [0, caml_call1(f, 0)]; return _d_;}
    catch(exn$0){var exn = caml_wrap_exception(exn$0); return [1, exn];}
   }
   function ok_exn(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var exn = param[1];
    throw caml_maybe_attach_backtrace(exn, 1);
   }
   function ok_or_failwith(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var str = param[1];
    return caml_call1(Base_Import[123], str);
   }
   function combine(t1, t2, ok, err){
    if(0 === t1[0]){
     var ok1 = t1[1];
     if(0 === t2[0]){var ok2 = t2[1]; return [0, caml_call2(ok, ok1, ok2)];}
     var e = t2[1];
    }
    else{
     var err1 = t1[1];
     if(0 !== t2[0]){
      var err2 = t2[1];
      return [1, caml_call2(err, err1, err2)];
     }
     var e = err1;
    }
    return [1, e];
   }
   function combine_errors(l){
    var
     match = caml_call2(Base_List1[24], l, to_either),
     errs = match[2],
     ok = match[1];
    return errs ? [1, errs] : [0, ok];
   }
   function combine_errors_unit(l){
    return caml_call2(map$0, combine_errors(l), function(param){return 0;});
   }
   var
    Base_Result =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       equal,
       hash_fold_t,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Monad_infix,
       bind$0,
       return$1,
       join,
       ignore_m,
       all,
       all_unit,
       Error,
       invariant,
       fail,
       failf,
       is_ok,
       is_error,
       ok,
       ok_exn,
       ok_or_failwith,
       error,
       of_option,
       iter,
       iter_error,
       map$0,
       map_error,
       combine,
       combine_errors,
       combine_errors_unit,
       to_either,
       of_either,
       to_either,
       ok_if_true,
       try_with,
       [0, is_ok, is_error]];
   runtime.caml_register_global(21, Base_Result, "Base__Result");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Container_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Continue_or_stop = [0],
    Export = [0, Continue_or_stop],
    Continue_or_stop$0 = Export[1],
    Base_Container_intf = [0, Export, Continue_or_stop$0];
   runtime.caml_register_global
    (0, Base_Container_intf, "Base__Container_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Container
//# unitInfo: Requires: Base__Array0, Base__Container_intf, Base__Import, Base__List0, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array0 = global_data.Base__Array0,
    Base_Import = global_data.Base__Import,
    Base_List0 = global_data.Base__List0,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1];
   function iter(fold, t, f){
    return caml_call3
            (fold, t, 0, function(param, a){return caml_call1(f, a);});
   }
   function count(fold, t, f){
    return caml_call3
            (fold,
             t,
             0,
             function(n, a){
              return caml_call1(f, a) ? caml_call2(Base_Import[90], n, 1) : n;
             });
   }
   function sum(fold, M){
    return function(t, f){
     return caml_call3
             (fold,
              t,
              M[1],
              function(n, a){
               var _j_ = caml_call1(f, a);
               return caml_call2(M[2], n, _j_);
              });};
   }
   function fold_result(fold, init, f, t){
    return caml_call1
            (with_return,
             function(param){
              return [0,
                      caml_call3
                       (fold,
                        t,
                        init,
                        function(acc, item){
                         var e = caml_call2(f, acc, item);
                         if(0 !== e[0]) return caml_call1(param, e);
                         var x = e[1];
                         return x;
                        })];
             });
   }
   function fold_until(fold, init, f, finish, t){
    return caml_call1
            (with_return,
             function(param){
              return caml_call1
                      (finish,
                       caml_call3
                        (fold,
                         t,
                         init,
                         function(acc, item){
                          var match = caml_call2(f, acc, item);
                          if(0 === match[0]){var x = match[1]; return x;}
                          var x$0 = match[1];
                          return caml_call1(param, x$0);
                         }));
             });
   }
   function min_elt(fold, t, compare){
    return caml_call3
            (fold,
             t,
             0,
             function(acc, elt){
              if(! acc) return [0, elt];
              var min = acc[1];
              return 0 < caml_call2(compare, min, elt) ? [0, elt] : acc;
             });
   }
   function max_elt(fold, t, compare){
    return caml_call3
            (fold,
             t,
             0,
             function(acc, elt){
              if(! acc) return [0, elt];
              var max = acc[1];
              return 0 <= caml_call2(compare, max, elt) ? acc : [0, elt];
             });
   }
   function length(fold, c){
    return caml_call3
            (fold,
             c,
             0,
             function(acc, param){return caml_call2(Base_Import[90], acc, 1);});
   }
   function is_empty(iter, c){
    return caml_call1
            (with_return,
             function(r){
              caml_call2(iter, c, function(param){return caml_call1(r, 0);});
              return 1;
             });
   }
   function exists(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _i_ = caml_call1(f, x);
                 return _i_ ? caml_call1(r, 1) : _i_;
                });
              return 0;
             });
   }
   function for_all(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _h_ = 1 - caml_call1(f, x);
                 return _h_ ? caml_call1(r, 0) : _h_;
                });
              return 1;
             });
   }
   function find_map(iter, t, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                t,
                function(x){
                 var res = caml_call1(f, x);
                 return res ? caml_call1(r, res) : 0;
                });
              return 0;
             });
   }
   function find(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _g_ = caml_call1(f, x);
                 return _g_ ? caml_call1(r, [0, x]) : _g_;
                });
              return 0;
             });
   }
   function to_list(fold, c){
    var _f_ = caml_call3(fold, c, 0, function(acc, x){return [0, x, acc];});
    return caml_call1(Base_List0[21], _f_);
   }
   function to_array(length, iter, c){
    var array = [0, [0]], i = [0, 0];
    caml_call2
     (iter,
      c,
      function(x){
       if(0 === i[1]){
        var _d_ = caml_call1(length, c);
        array[1] = caml_call2(Base_Array0[4], _d_, x);
       }
       var _e_ = i[1];
       runtime.caml_check_bound(array[1], _e_)[1 + _e_] = x;
       return caml_call1(Base_Import[129], i);
      });
    return array[1];
   }
   function Make_gen(T){
    var fold = T[1], match = T[2];
    if(typeof match === "number")
     var iter$0 = function(t, f){return iter(fold, t, f);};
    else
     var iter$1 = match[2], iter$0 = iter$1;
    var match$0 = T[3];
    if(typeof match$0 === "number")
     var length$0 = function(t){return length(fold, t);};
    else
     var length$1 = match$0[2], length$0 = length$1;
    function is_empty$0(t){return is_empty(iter$0, t);}
    function sum$0(m, t){
     var _a_ = sum(fold, m);
     return function(_b_){var _c_ = _b_; return _a_(t, _c_);};
    }
    function count$0(t, f){return count(fold, t, f);}
    function exists$0(t, f){return exists(iter$0, t, f);}
    function for_all$0(t, f){return for_all(iter$0, t, f);}
    function find_map$0(t, f){return find_map(iter$0, t, f);}
    function find$0(t, f){return find(iter$0, t, f);}
    function to_list$0(t){return to_list(fold, t);}
    function to_array$0(t){return to_array(length$0, iter$0, t);}
    function min_elt$0(t, compare){return min_elt(fold, t, compare);}
    function max_elt$0(t, compare){return max_elt(fold, t, compare);}
    function fold_result$0(t, init, f){return fold_result(fold, init, f, t);}
    function fold_until$0(t, init, f, finish){
     return fold_until(fold, init, f, finish, t);
    }
    return [0,
            length$0,
            is_empty$0,
            iter$0,
            fold,
            fold_result$0,
            fold_until$0,
            exists$0,
            for_all$0,
            count$0,
            sum$0,
            find$0,
            find_map$0,
            to_list$0,
            to_array$0,
            min_elt$0,
            max_elt$0];
   }
   var
    Base_Container =
      [0,
       iter,
       count,
       min_elt,
       max_elt,
       length,
       to_list,
       sum,
       fold_result,
       fold_until,
       is_empty,
       exists,
       for_all,
       find,
       find_map,
       to_array,
       function(T){
        var
         fold = T[1],
         iter = T[2],
         length = T[3],
         include = Make_gen([0, fold, iter, length]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[3],
         fold$0 = include[4],
         fold_result = include[5],
         fold_until = include[6],
         exists = include[7],
         for_all = include[8],
         count = include[9],
         sum = include[10],
         find = include[11],
         find_map = include[12],
         to_list = include[13],
         to_array = include[14],
         min_elt = include[15],
         max_elt = include[16];
        function mem(t, a, equal){
         return caml_call2(exists, t, caml_call1(equal, a));
        }
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt];
       },
       function(T){
        var
         fold = T[2],
         iter = T[3],
         length = T[4],
         include = Make_gen([0, fold, iter, length]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[3],
         fold$0 = include[4],
         fold_result = include[5],
         fold_until = include[6],
         exists = include[7],
         for_all = include[8],
         count = include[9],
         sum = include[10],
         find = include[11],
         find_map = include[12],
         to_list = include[13],
         to_array = include[14],
         min_elt = include[15],
         max_elt = include[16];
        function mem(t, elt){
         return caml_call2(exists, t, caml_call1(T[1][1], elt));
        }
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt];
       },
       Make_gen];
   runtime.caml_register_global(4, Base_Container, "Base__Container");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Lazy
//# unitInfo: Requires: Base__Hash, Base__Import, Base__Monad, CamlinternalLazy, Stdlib__Lazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Import = global_data.Base__Import,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Base_Hash = global_data.Base__Hash,
    Base_Monad = global_data.Base__Monad,
    Undefined = Stdlib_Lazy[1],
    is_val = Stdlib_Lazy[3],
    from_val = Stdlib_Lazy[4],
    from_fun = Stdlib_Lazy[6],
    force_val = Stdlib_Lazy[7],
    t_of_sexp = Base_Import[171],
    sexp_of_t = Base_Import[147];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[192], a_sexp_grammar);
   }
   function compare(compare_a, t1, t2){
    if(caml_call2(Base_Import[127], t1, t2)) return 0;
    var
     _o_ = caml_obj_tag(t2),
     _p_ =
       250 === _o_
        ? t2[1]
        : 246 === _o_ ? caml_call1(CamlinternalLazy[2], t2) : t2,
     _q_ = caml_obj_tag(t1),
     _r_ =
       250 === _q_
        ? t1[1]
        : 246 === _q_ ? caml_call1(CamlinternalLazy[2], t1) : t1;
    return caml_call2(compare_a, _r_, _p_);
   }
   function equal(equal_a, t1, t2){
    if(caml_call2(Base_Import[127], t1, t2)) return 1;
    var
     _k_ = caml_obj_tag(t2),
     _l_ =
       250 === _k_
        ? t2[1]
        : 246 === _k_ ? caml_call1(CamlinternalLazy[2], t2) : t2,
     _m_ = caml_obj_tag(t1),
     _n_ =
       250 === _m_
        ? t1[1]
        : 246 === _m_ ? caml_call1(CamlinternalLazy[2], t1) : t1;
    return caml_call2(equal_a, _n_, _l_);
   }
   var hash_fold_t = Base_Hash[13][12];
   function return$0(x){return caml_call1(from_val, x);}
   function bind(t, f){
    return [246,
            function(_f_){
             var
              _g_ = caml_obj_tag(t),
              _h_ =
                250 === _g_
                 ? t[1]
                 : 246 === _g_ ? caml_call1(CamlinternalLazy[2], t) : t,
              _i_ = caml_call1(f, _h_),
              _j_ = caml_obj_tag(_i_);
             return 250 === _j_
                     ? _i_[1]
                     : 246 === _j_ ? caml_call1(CamlinternalLazy[2], _i_) : _i_;
            }];
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        return [246,
                function(_c_){
                 var
                  _d_ = caml_obj_tag(t),
                  _e_ =
                    250 === _d_
                     ? t[1]
                     : 246 === _d_ ? caml_call1(CamlinternalLazy[2], t) : t;
                 return caml_call1(f, _e_);
                }];
       }],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11],
    cst_unforced_lazy = "<unforced lazy>";
   function sexp_of_t$0(sexp_of_a, t){
    if(! caml_call1(is_val, t))
     return caml_call1(Base_Import[138], cst_unforced_lazy);
    var
     _a_ = caml_obj_tag(t),
     _b_ =
       250 === _a_
        ? t[1]
        : 246 === _a_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call1(sexp_of_a, _b_);
   }
   var
    T_unforcing = [0, sexp_of_t$0],
    Base_Lazy =
      [0,
       compare,
       equal,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       T_unforcing];
   runtime.caml_register_global(6, Base_Lazy, "Base__Lazy");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Info_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Info_intf = [0];
   runtime.caml_register_global(0, Base_Info_intf, "Base__Info_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordered_collection_common0
//# unitInfo: Requires: Base__Import, Base__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    invalid_argf = Base_Printf[7],
    _a_ =
      [0,
       [11, "Negative position: ", [4, 0, 0, 0, 0]],
       "Negative position: %d"],
    _b_ =
      [0, [11, "Negative length: ", [4, 0, 0, 0, 0]], "Negative length: %d"],
    _c_ =
      [0,
       [11,
        "pos + len past end: ",
        [4, 0, 0, 0, [11, " + ", [4, 0, 0, 0, [11, " > ", [4, 0, 0, 0, 0]]]]]],
       "pos + len past end: %d + %d > %d"];
   function slow_check_pos_len_exn(pos, len, total_length){
    if(pos < 0) caml_call3(invalid_argf, _a_, pos, 0);
    if(len < 0) caml_call3(invalid_argf, _b_, len, 0);
    var _h_ = caml_call2(Base_Import[92], total_length, len) < pos ? 1 : 0;
    return _h_
            ? caml_call5(invalid_argf, _c_, pos, len, total_length, 0)
            : _h_;
   }
   function check_pos_len_exn(pos, len, total_length){
    var
     stop = caml_call2(Base_Import[90], pos, len),
     _d_ = caml_call2(Base_Import[92], total_length, stop),
     _e_ = caml_call2(Base_Import[117], pos, len),
     _f_ = caml_call2(Base_Import[117], _e_, stop),
     _g_ = caml_call2(Base_Import[117], _f_, _d_) < 0 ? 1 : 0;
    return _g_ ? slow_check_pos_len_exn(pos, len, total_length) : _g_;
   }
   function get_pos_len_exn(opt, len, param, total_length){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(len)
     var i = len[1], len$0 = i;
    else
     var len$0 = caml_call2(Base_Import[92], total_length, pos);
    check_pos_len_exn(pos, len$0, total_length);
    return [0, pos, len$0];
   }
   var
    Private = [0, slow_check_pos_len_exn],
    Base_Ordered_collection_common =
      [0, get_pos_len_exn, check_pos_len_exn, Private];
   runtime.caml_register_global
    (5, Base_Ordered_collection_common, "Base__Ordered_collection_common0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Random_repr
//# unitInfo: Requires: Base__Array0, CamlinternalLazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Array0 = global_data.Base__Array0;
   function of_state(_e_){return _e_;}
   var Repr = [0, of_state];
   function assign(t1, t2){
    var
     _a_ = caml_obj_tag(t1),
     _b_ =
       250 === _a_
        ? t1[1]
        : 246 === _a_ ? caml_call1(CamlinternalLazy[2], t1) : t1,
     t1$0 = caml_call1(Repr[1], _b_),
     _c_ = caml_obj_tag(t2),
     _d_ =
       250 === _c_
        ? t2[1]
        : 246 === _c_ ? caml_call1(CamlinternalLazy[2], t2) : t2,
     t2$0 = caml_call1(Repr[1], _d_);
    caml_call5(Base_Array0[7], t2$0[1], 0, t1$0[1], 0, t1$0[1].length - 1);
    t1$0[2] = t2$0[2];
    return 0;
   }
   function make_default(default$0){return default$0;}
   function get_state(state){return state;}
   var Base_Random_repr = [0, Repr, assign, make_default, get_state];
   runtime.caml_register_global(2, Base_Random_repr, "Base__Random_repr");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Random
//# unitInfo: Requires: Base__Char0, Base__Import, Base__Int0, Base__Lazy, Base__Printf, Base__Random_repr, Base__Word_size, CamlinternalLazy, Stdlib__Int32, Stdlib__Int64, Stdlib__Nativeint, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_int64_xor = runtime.caml_int64_xor,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Random_repr = global_data.Base__Random_repr,
    Base_Import = global_data.Base__Import,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Base_Int0 = global_data.Base__Int0,
    Base_Printf = global_data.Base__Printf,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random,
    Base_Lazy = global_data.Base__Lazy,
    Base_Char0 = global_data.Base__Char0,
    Base_Word_size = global_data.Base__Word_size,
    cst_initializing_Random_with_a =
      "initializing Random with a nondeterministic seed is forbidden in inline tests";
   function forbid_nondeterminism_in_tests(allow_in_tests){
    var _M_ = Base_Import[131];
    if(! _M_) return _M_;
    if(allow_in_tests && allow_in_tests[1]) return;
    return caml_call1(Base_Import[123], cst_initializing_Random_with_a);
   }
   function bits(t){
    var
     _K_ = caml_obj_tag(t),
     _L_ =
       250 === _K_
        ? t[1]
        : 246 === _K_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call1(Stdlib_Random[12][4], _L_);
   }
   function bool(t){
    var
     _I_ = caml_obj_tag(t),
     _J_ =
       250 === _I_
        ? t[1]
        : 246 === _I_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call1(Stdlib_Random[12][11], _J_);
   }
   function int$0(t, x){
    var
     _G_ = caml_obj_tag(t),
     _H_ =
       250 === _G_
        ? t[1]
        : 246 === _G_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call2(Stdlib_Random[12][5], _H_, x);
   }
   function int32(t, x){
    var
     _E_ = caml_obj_tag(t),
     _F_ =
       250 === _E_
        ? t[1]
        : 246 === _E_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call2(Stdlib_Random[12][7], _F_, x);
   }
   function int64(t, x){
    var
     _C_ = caml_obj_tag(t),
     _D_ =
       250 === _C_
        ? t[1]
        : 246 === _C_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call2(Stdlib_Random[12][9], _D_, x);
   }
   function nativeint(t, x){
    var
     _A_ = caml_obj_tag(t),
     _B_ =
       250 === _A_
        ? t[1]
        : 246 === _A_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call2(Stdlib_Random[12][8], _B_, x);
   }
   function make(seed){
    var _z_ = caml_call1(Stdlib_Random[12][1], seed);
    return caml_call1(Base_Lazy[21], _z_);
   }
   function copy(t){
    var
     _w_ = caml_obj_tag(t),
     _x_ =
       250 === _w_
        ? t[1]
        : 246 === _w_ ? caml_call1(CamlinternalLazy[2], t) : t,
     _y_ = caml_call1(Stdlib_Random[12][3], _x_);
    return caml_call1(Base_Lazy[21], _y_);
   }
   function char$0(t){
    var _v_ = int$0(t, 256);
    return caml_call1(Base_Char0[5], _v_);
   }
   function ascii(t){
    var _u_ = int$0(t, 128);
    return caml_call1(Base_Char0[5], _u_);
   }
   function make_self_init(allow_in_tests, param){
    forbid_nondeterminism_in_tests(allow_in_tests);
    var _t_ = caml_call1(Stdlib_Random[12][2], 0);
    return caml_call1(Base_Lazy[21], _t_);
   }
   var
    assign = Base_Random_repr[2],
    cst_float = "float",
    cst_int64 = "int64",
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_nativeint = "nativeint",
    cst_int32 = "int32",
    cst_int = "int",
    _a_ =
      [0,
       [11,
        "Random.",
        [2,
         0,
         [11, ": crossed bounds [", [2, 0, [11, " > ", [2, 0, [12, 93, 0]]]]]]],
       "Random.%s: crossed bounds [%s > %s]"];
   if(Base_Import[131]){
    var t = caml_call1(Stdlib_Random[13], 0);
    caml_call1(Stdlib_Random[1], 137);
    var default$0 = caml_call1(Base_Lazy[21], t);
   }
   else
    var
     default$0 =
       [246,
        function(param){
         var _r_ = make_self_init(0, 0), _s_ = caml_obj_tag(_r_);
         return 250 === _s_
                 ? _r_[1]
                 : 246 === _s_ ? caml_call1(CamlinternalLazy[2], _r_) : _r_;
        }];
   function int_on_64bits(t, bound){
    return 1073741823 < bound
            ? caml_int64_to_int32(int64(t, caml_int64_of_int32(bound)))
            : int$0(t, bound);
   }
   function int_on_32bits(t, bound){
    return 1073741823 < bound ? int32(t, bound) : int$0(t, bound);
   }
   var int$1 = Base_Word_size[3] ? int_on_64bits : int_on_32bits;
   function bits$0(state){return caml_int64_of_int32(bits(state));}
   function full_range_int64(state){
    var
     _p_ = caml_int64_shift_left(bits$0(state), 60),
     _q_ = caml_int64_xor(caml_int64_shift_left(bits$0(state), 30), _p_);
    return caml_int64_xor(bits$0(state), _q_);
   }
   function full_range_int32(state){
    var _o_ = bits(state) << 30;
    return bits(state) ^ _o_;
   }
   function full_range_int_on_64bits(state){
    return caml_int64_to_int32(full_range_int64(state));
   }
   function full_range_int_on_32bits(state){return full_range_int32(state);}
   var
    full_range_int_on_64bits$0 =
      Base_Word_size[3] ? full_range_int_on_64bits : full_range_int_on_32bits;
   function full_range_nativeint_on_64bits(state){
    return caml_int64_to_int32(full_range_int64(state));
   }
   function full_range_nativeint_on_32bits(state){return full_range_int32(state);
   }
   var
    full_range_nativeint =
      Base_Word_size[3]
       ? full_range_nativeint_on_64bits
       : full_range_nativeint_on_32bits;
   function raise_crossed_bounds
   (name, lower_bound, upper_bound, string_of_bound){
    var
     _m_ = caml_call1(string_of_bound, upper_bound),
     _n_ = caml_call1(string_of_bound, lower_bound);
    return caml_call5(Base_Printf[6], _a_, name, _n_, _m_, 0);
   }
   function int_incl(state, lo, hi){
    if(hi < lo) raise_crossed_bounds(cst_int, lo, hi, Base_Int0[1]);
    var diff = caml_call2(Base_Import[92], hi, lo);
    if(diff === Base_Int0[5]){
     var
      _i_ = Base_Int0[5],
      _j_ = full_range_int_on_64bits$0(state),
      _k_ = caml_call2(Base_Import[115], _j_, _i_);
     return caml_call2(Base_Import[90], lo, _k_);
    }
    if(0 <= diff){
     var _l_ = int$1(state, caml_call1(Base_Int0[7], diff));
     return caml_call2(Base_Import[90], lo, _l_);
    }
    for(;;){
     var int$0 = full_range_int_on_64bits$0(state);
     if(lo <= int$0 && int$0 <= hi) return int$0;
    }
   }
   function int32_incl(state, lo, hi){
    if(caml_call2(Base_Import[101][5], lo, hi))
     raise_crossed_bounds(cst_int32, lo, hi, Stdlib_Int32[14]);
    var diff = hi - lo | 0;
    if(caml_call2(Base_Import[101][4], diff, Stdlib_Int32[9])){
     var _h_ = Stdlib_Int32[9];
     return lo + (full_range_int32(state) & _h_) | 0;
    }
    if(caml_call2(Base_Import[101][6], diff, 0))
     return lo + int32(state, caml_call1(Stdlib_Int32[6], diff)) | 0;
    for(;;){
     var int$0 = full_range_int32(state);
     if
      (caml_call2(Base_Import[101][6], int$0, lo)
       && caml_call2(Base_Import[101][2], int$0, hi))
      return int$0;
    }
   }
   function nativeint_incl(state, lo, hi){
    if(caml_call2(Base_Import[103][5], lo, hi))
     raise_crossed_bounds(cst_nativeint, lo, hi, Stdlib_Nativeint[15]);
    var diff = hi - lo | 0;
    if(caml_call2(Base_Import[103][4], diff, Stdlib_Nativeint[10])){
     var _g_ = Stdlib_Nativeint[10];
     return lo + (full_range_nativeint(state) & _g_) | 0;
    }
    if(caml_call2(Base_Import[103][6], diff, 0))
     return lo + nativeint(state, caml_call1(Stdlib_Nativeint[6], diff)) | 0;
    for(;;){
     var int$0 = full_range_nativeint(state);
     if
      (caml_call2(Base_Import[103][6], int$0, lo)
       && caml_call2(Base_Import[103][2], int$0, hi))
      return int$0;
    }
   }
   function int64_incl(state, lo, hi){
    if(runtime.caml_greaterthan(lo, hi))
     raise_crossed_bounds(cst_int64, lo, hi, Stdlib_Int64[14]);
    var diff = runtime.caml_int64_sub(hi, lo);
    if(runtime.caml_equal(diff, Stdlib_Int64[9])){
     var _f_ = Stdlib_Int64[9];
     return caml_int64_add
             (lo, runtime.caml_int64_and(full_range_int64(state), _f_));
    }
    if(caml_greaterequal(diff, _b_))
     return caml_int64_add
             (lo, int64(state, caml_call1(Stdlib_Int64[6], diff)));
    for(;;){
     var int$0 = full_range_int64(state);
     if(caml_greaterequal(int$0, lo) && runtime.caml_lessequal(int$0, hi))
      return int$0;
    }
   }
   function float$0(state, hi){
    for(;;){
     var
      scale = 9.313225746154785e-10,
      r1 = bits(state),
      r2 = bits(state),
      _d_ = caml_call2(Base_Import[89], r1, scale),
      _e_ = caml_call2(Base_Import[91], _d_, r2),
      result = caml_call2(Base_Import[89], _e_, scale);
     if(caml_call2(Base_Import[107][1], result, 1.))
      return caml_call2(Base_Import[89], result, hi);
    }
   }
   function float_range(state, lo, hi){
    if(caml_call2(Base_Import[107][5], lo, hi))
     raise_crossed_bounds(cst_float, lo, hi, Base_Import[84][34]);
    var _c_ = float$0(state, caml_call2(Base_Import[93], hi, lo));
    return caml_call2(Base_Import[91], lo, _c_);
   }
   var default$1 = caml_call1(Base_Random_repr[3], default$0);
   function bits$1(param){
    return bits(caml_call1(Base_Random_repr[4], default$1));
   }
   function int$2(x){
    return int$1(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function int32$0(x){
    return int32(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function nativeint$0(x){
    return nativeint(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function int64$0(x){
    return int64(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function float$1(x){
    return float$0(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function int_incl$0(x, y){
    return int_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function int32_incl$0(x, y){
    return int32_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function nativeint_incl$0(x, y){
    return nativeint_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function int64_incl$0(x, y){
    return int64_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function float_range$0(x, y){
    return float_range(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function bool$0(param){
    return bool(caml_call1(Base_Random_repr[4], default$1));
   }
   function char$1(param){
    return char$0(caml_call1(Base_Random_repr[4], default$1));
   }
   function ascii$0(param){
    return ascii(caml_call1(Base_Random_repr[4], default$1));
   }
   function full_init(seed){
    var t = caml_call1(Base_Random_repr[4], default$1);
    return caml_call2(assign, t, make(seed));
   }
   function init(seed){return full_init([0, seed]);}
   function self_init(allow_in_tests, param){
    forbid_nondeterminism_in_tests(allow_in_tests);
    return full_init(runtime.caml_sys_random_seed(0));
   }
   function set_state(s){
    return caml_call2(assign, caml_call1(Base_Random_repr[4], default$1), s);
   }
   var
    Base_Random =
      [0,
       init,
       full_init,
       self_init,
       bits$1,
       int$2,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       int_incl$0,
       int32_incl$0,
       nativeint_incl$0,
       int64_incl$0,
       float_range$0,
       bool$0,
       char$1,
       ascii$0,
       [0,
        default$0,
        make,
        make_self_init,
        copy,
        bits,
        int$1,
        int32,
        nativeint,
        int64,
        float$0,
        int_incl,
        int32_incl,
        nativeint_incl,
        int64_incl,
        float_range,
        bool,
        char$0,
        ascii],
       set_state];
   runtime.caml_register_global(24, Base_Random, "Base__Random");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array_permute
//# unitInfo: Requires: Base__Array0, Base__Import, Base__Ordered_collection_common0, Base__Random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Random = global_data.Base__Random,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common0,
    Base_Array0 = global_data.Base__Array0,
    invalid_argf = Base_Array0[1],
    Array = Base_Array0[2],
    max_length = Base_Array0[3],
    create = Base_Array0[4],
    create_float_uninitialized = Base_Array0[5],
    append = Base_Array0[6],
    blit = Base_Array0[7],
    concat = Base_Array0[8],
    copy = Base_Array0[9],
    fill = Base_Array0[10],
    init = Base_Array0[11],
    make_matrix = Base_Array0[12],
    of_list = Base_Array0[13],
    sub = Base_Array0[14],
    to_list = Base_Array0[15],
    fold = Base_Array0[16],
    fold_right = Base_Array0[17],
    iter = Base_Array0[18],
    iteri = Base_Array0[19],
    map = Base_Array0[20],
    mapi = Base_Array0[21],
    stable_sort = Base_Array0[22],
    swap = Base_Array0[23];
   function permute(opt, _a_, len, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    if(_a_) var sth$0 = _a_[1], pos = sth$0; else var pos = 0;
    var total_length = t.length - 1;
    if(len)
     var l = len[1], len$0 = l;
    else
     var len$0 = caml_call2(Base_Import[92], total_length, pos);
    caml_call3(Base_Ordered_collection_common[2], pos, len$0, total_length);
    var num_swaps = caml_call2(Base_Import[92], len$0, 1);
    if(num_swaps >= 1){
     var i = num_swaps;
     for(;;){
      var
       this_i = caml_call2(Base_Import[90], pos, i),
       _b_ = caml_call2(Base_Import[90], i, 1),
       _c_ = caml_call2(Base_Random[18][6], random_state, _b_),
       random_i = caml_call2(Base_Import[90], pos, _c_);
      caml_call3(swap, t, this_i, random_i);
      var _d_ = i - 1 | 0;
      if(1 === i) break;
      i = _d_;
     }
    }
    return 0;
   }
   var
    Base_Array_permute =
      [0,
       invalid_argf,
       Array,
       max_length,
       create,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap,
       permute];
   runtime.caml_register_global(4, Base_Array_permute, "Base__Array_permute");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Equal
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Equal = [0];
   runtime.caml_register_global(0, Base_Equal, "Base__Equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Fn
//# unitInfo: Requires: Base__Import
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import;
   function const$0(c, param){return c;}
   function non(f, x){return 1 - caml_call1(f, x);}
   function forever(f){
    try{for(;;) caml_call1(f, 0);}
    catch(e$0){var e = caml_wrap_exception(e$0); return e;}
   }
   function compose(f, g, x){return caml_call1(f, caml_call1(g, x));}
   function flip(f, x, y){return caml_call2(f, y, x);}
   function apply_n_times(n, f, x){
    var n$0 = n, x$0 = x;
    for(;;){
     if(0 >= n$0) return x$0;
     var x$1 = caml_call1(f, x$0), n$1 = caml_call2(Base_Import[92], n$0, 1);
     n$0 = n$1;
     x$0 = x$1;
    }
   }
   var Base_Fn = [0, const$0, non, forever, apply_n_times, compose, flip];
   runtime.caml_register_global(1, Base_Fn, "Base__Fn");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordering
//# unitInfo: Requires: Base__Hash, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Equal = "Equal",
    cst_Greater = "Greater",
    cst_Less = "Less",
    cst_equal = "equal",
    cst_greater = "greater",
    cst_less = "less",
    caml_int_compare = runtime.caml_int_compare;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, [0, 2, 0]]],
    error_source_005 = "ordering.ml.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Less, 0]],
         [0, [1, [0, cst_Equal, 0]], [0, [1, [0, cst_Greater, 0]], 0]]]]],
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    compare = caml_int_compare,
    _a_ = [0, cst_Less],
    _b_ = [0, cst_Equal],
    _c_ = [0, cst_Greater];
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      default: return caml_call2(Base_Hash[3], hsv, 2);
    }
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _h_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _h_);
   }
   function t_of_sexp(sexp_006){
    a:
    {
     if(0 === sexp_006[0]){
      var _d_ = sexp_006[1];
      b:
      if(_d_ !== cst_Equal){
       c:
       if(_d_ !== cst_Greater){
        if(_d_ !== cst_Less){
         if(_d_ === cst_equal) break b;
         if(_d_ === cst_greater) break c;
         if(_d_ !== cst_less) break a;
        }
        return 0;
       }
       return 2;
      }
      return 1;
     }
     var _e_ = sexp_006[1];
     if(! _e_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
     var _f_ = _e_[1];
     if(0 !== _f_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_005, sexp_006);
     var _g_ = _f_[1];
     b:
     if(_g_ !== cst_Equal){
      c:
      if(_g_ !== cst_Greater){
       if(_g_ !== cst_Less){
        if(_g_ === cst_equal) break b;
        if(_g_ === cst_greater) break c;
        if(_g_ !== cst_less) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_005, sexp_006);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   function equal(a, b){return 0 === caml_int_compare(a, b) ? 1 : 0;}
   var Export = [0];
   function of_int(n){return 0 <= n ? 0 === n ? 1 : 2 : 0;}
   function to_int(param){
    switch(param){case 0: return -1;case 1: return 0;default: return 1;
    }
   }
   var
    Base_Ordering =
      [0,
       compare,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       all,
       equal,
       of_int,
       to_int,
       Export];
   runtime.caml_register_global(20, Base_Ordering, "Base__Ordering");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sys
//# unitInfo: Requires: Base__Sys0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Sys0 = global_data.Base__Sys0,
    backend_type = Base_Sys0[1],
    interactive = Base_Sys0[2],
    os_type = Base_Sys0[3],
    unix = Base_Sys0[4],
    win32 = Base_Sys0[5],
    cygwin = Base_Sys0[6],
    word_size_in_bits = Base_Sys0[7],
    int_size_in_bits = Base_Sys0[8],
    big_endian = Base_Sys0[9],
    max_string_length = Base_Sys0[10],
    max_array_length = Base_Sys0[11],
    runtime_variant = Base_Sys0[12],
    runtime_parameters = Base_Sys0[13],
    argv = Base_Sys0[14],
    get_argv = Base_Sys0[15],
    ocaml_version = Base_Sys0[16],
    enable_runtime_warnings = Base_Sys0[17],
    runtime_warnings_enabled = Base_Sys0[18],
    getenv_exn = Base_Sys0[19],
    getenv = Base_Sys0[20],
    Base_Sys =
      [0,
       get_argv,
       argv,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       backend_type,
       word_size_in_bits,
       int_size_in_bits,
       big_endian,
       max_string_length,
       max_array_length,
       runtime_variant,
       runtime_parameters,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       getenv,
       getenv_exn];
   runtime.caml_register_global(1, Base_Sys, "Base__Sys");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List
//# unitInfo: Requires: Assert_failure, Base__Applicative, Base__Array0, Base__Array_permute, Base__Container, Base__Import, Base__List1, Base__Monad, Base__Ordering, Base__Ppx_compare_lib, Base__Printf, Base__Random, Base__Result, Base__Sys, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = " <> ",
    cst$0 = ": ",
    cst_length_mismatch_in = "length mismatch in ",
    cst_src_list_ml = "src/list.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    error_source_022 = "list.ml.Assoc.t",
    Base_Import = global_data.Base__Import,
    Base_Container = global_data.Base__Container,
    Assert_failure = global_data.Assert_failure,
    Base_Random = global_data.Base__Random,
    Base_Array0 = global_data.Base__Array0,
    Base_Array_permute = global_data.Base__Array_permute,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Result = global_data.Base__Result,
    Base_Ordering = global_data.Base__Ordering,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_List1 = global_data.Base__List1,
    Base_Printf = global_data.Base__Printf,
    Base_Sys = global_data.Base__Sys,
    Base_Applicative = global_data.Base__Applicative,
    Base_Monad = global_data.Base__Monad,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    hd_exn = Base_List1[1],
    length = Base_List1[2],
    rev_append = Base_List1[3],
    tl_exn = Base_List1[4],
    exists = Base_List1[6],
    exists2_ok = Base_List1[7],
    fold_left = Base_List1[8],
    fold2_ok = Base_List1[9],
    for_all = Base_List1[10],
    for_all2_ok = Base_List1[11],
    iter = Base_List1[12],
    iter2_ok = Base_List1[13],
    nontail_map = Base_List1[14],
    rev_map = Base_List1[17],
    rev_map2_ok = Base_List1[18],
    sort = Base_List1[19],
    stable_sort = Base_List1[20],
    rev = Base_List1[21],
    fold_right = Base_List1[22],
    is_empty = Base_List1[23],
    partition_map = Base_List1[24],
    invalid_argf = Base_Printf[7],
    t_of_sexp = Base_Import[175],
    sexp_of_t = Base_Import[151],
    _a_ = [0, "Ok"],
    _b_ = [0, "Unequal_lengths"];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[194], a_sexp_grammar);
   }
   function compare(cmp_a, a_006, b_007){
    if(caml_call2(Base_Ppx_compare_lib[1], a_006, b_007)) return 0;
    if(! a_006) return b_007 ? 1 : 0;
    var a_008 = a_006[1];
    if(! b_007) return -1;
    var b_009 = b_007[1];
    return caml_call2(cmp_a, a_008, b_009);
   }
   function sexp_of_t$0(of_a_010, param){
    if(! param) return _b_;
    var arg0_011 = param[1], res0_012 = caml_call1(of_a_010, arg0_011);
    return [1, [0, _a_, [0, res0_012, 0]]];
   }
   var
    Or_unequal_lengths = [0, compare, sexp_of_t$0],
    cst_List_range_stride_function =
      "List.range': stride function cannot return the same value",
    cst_List_range_stride_function$0 =
      "List.range': stride function cannot change direction",
    cst_List_range_stride_must_be_ = "List.range: stride must be non-zero",
    _c_ =
      [0,
       [11,
        "List.nth_exn ",
        [4, 0, 0, 0, [11, " called on list of length ", [4, 0, 0, 0, 0]]]],
       "List.nth_exn %d called on list of length %d"],
    _d_ =
      [0,
       [11,
        cst_length_mismatch_in,
        [2, 0, [11, cst$0, [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]]]],
       "length mismatch in %s: %d <> %d"],
    _e_ =
      [0,
       [11,
        cst_length_mismatch_in,
        [2,
         0,
         [11,
          cst$0,
          [4,
           0,
           0,
           0,
           [11,
            cst,
            [4,
             0,
             0,
             0,
             [11, " || ", [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]]]]]]]],
       "length mismatch in %s: %d <> %d || %d <> %d"],
    cst_iter2_exn = "iter2_exn",
    cst_rev_map2_exn = "rev_map2_exn",
    cst_fold2_exn = "fold2_exn",
    cst_for_all2_exn = "for_all2_exn",
    cst_exists2_exn = "exists2_exn";
   function invariant(f, t){return caml_call2(iter, t, f);}
   function of_list(t){return t;}
   function range(compare, stride, opt, _aP_, start_i, stop_i){
    if(opt) var sth = opt[1], start = sth; else var start = 104758188;
    if(_aP_) var sth$0 = _aP_[1], stop = sth$0; else var stop = -160346914;
    var next_i = caml_call1(stride, start_i);
    function order(x, y){
     var _aR_ = caml_call2(compare, x, y);
     return caml_call1(Base_Ordering[9], _aR_);
    }
    function raise_stride_cannot_return_sam(param){
     return caml_call1(Base_Import[125], cst_List_range_stride_function);
    }
    switch(order(start_i, next_i)){
      case 0:
       var initial_stride_order = 847855481; break;
      case 1:
       var initial_stride_order = raise_stride_cannot_return_sam(0); break;
      default: var initial_stride_order = 85047514;
    }
    var
     start_i$0 = 104758188 <= start ? start_i : next_i,
     i = start_i$0,
     accum = 0;
    for(;;){
     var i_to_stop_order = order(i, stop_i);
     a:
     {
      b:
      {
       switch(i_to_stop_order){
         case 0:
          if(847855481 > initial_stride_order) break b; break;
         case 1:
          if(104758188 <= stop){var _aQ_ = [0, i, accum]; break a;}
          var _aQ_ = accum;
          break a;
         default: if(847855481 <= initial_stride_order) break b;
       }
       var next_i$0 = caml_call1(stride, i);
       c:
       {
        switch(order(i, next_i$0)){
          case 0:
           if(847855481 > initial_stride_order) break c; break;
          case 1:
           var _aQ_ = raise_stride_cannot_return_sam(0); break a;
          default: if(847855481 <= initial_stride_order) break c;
        }
        var accum$0 = [0, i, accum];
        i = next_i$0;
        accum = accum$0;
        continue;
       }
       var
        _aQ_ = caml_call1(Base_Import[125], cst_List_range_stride_function$0);
       break a;
      }
      var _aQ_ = accum;
     }
     return caml_call1(rev, _aQ_);
    }
   }
   function range$0(opt, _aO_, _aN_, start_i, stop_i){
    if(opt) var sth = opt[1], stride = sth; else var stride = 1;
    if(_aO_) var sth$0 = _aO_[1], start = sth$0; else var start = 104758188;
    if(_aN_) var sth$1 = _aN_[1], stop = sth$1; else var stop = -160346914;
    if(0 === stride)
     caml_call1(Base_Import[125], cst_List_range_stride_must_be_);
    return range
            (runtime.caml_int_compare,
             function(x){return caml_call2(Base_Import[90], x, stride);},
             [0, start],
             [0, stop],
             start_i,
             stop_i);
   }
   function hd(t){if(! t) return 0; var x = t[1]; return [0, x];}
   function tl(t){if(! t) return 0; var t$0 = t[2]; return [0, t$0];}
   function nth(t, n){
    if(0 > n) return 0;
    var t$0 = t, n$0 = n;
    for(;;){
     if(! t$0) return 0;
     var t$1 = t$0[2], a = t$0[1];
     if(0 === n$0) return [0, a];
     var n$1 = caml_call2(Base_Import[92], n$0, 1);
     t$0 = t$1;
     n$0 = n$1;
    }
   }
   function nth_exn(t, n){
    var match = nth(t, n);
    if(! match)
     return caml_call4(invalid_argf, _c_, n, caml_call1(length, t), 0);
    var a = match[1];
    return a;
   }
   function unordered_append(l1, l2){
    if(l1){
     if(l2) return caml_call2(rev_append, l1, l2);
     var l = l1;
    }
    else
     var l = l2;
    return l;
   }
   function of_lists(l1, l2){
    var a = l1, b = l2, shared_length = 0;
    for(;;){
     if(a){
      if(b){
       var
        b$0 = b[2],
        a$0 = a[2],
        shared_length$0 = caml_call2(Base_Import[90], shared_length, 1);
       a = a$0;
       b = b$0;
       shared_length = shared_length$0;
       continue;
      }
     }
     else if(! b) return [0, shared_length];
     return [1, shared_length, a, b];
    }
   }
   function check_length2_exn(name, l1, l2){
    var match = of_lists(l1, l2);
    if(0 === match[0]) return;
    var
     tail_of_b = match[3],
     tail_of_a = match[2],
     shared_length = match[1],
     _aK_ = caml_call1(length, tail_of_b),
     _aL_ = caml_call2(Base_Import[90], shared_length, _aK_),
     _aM_ = caml_call1(length, tail_of_a);
    return caml_call5
            (invalid_argf,
             _d_,
             name,
             caml_call2(Base_Import[90], shared_length, _aM_),
             _aL_,
             0);
   }
   function check_length2(l1, l2, f){
    return 0 === of_lists(l1, l2)[0] ? [0, caml_call2(f, l1, l2)] : 0;
   }
   function of_lists$0(l1, l2, l3){
    var a = l1, b = l2, c = l3, shared_length = 0;
    for(;;){
     if(a){
      if(b && c){
       var
        c$0 = c[2],
        b$0 = b[2],
        a$0 = a[2],
        shared_length$0 = caml_call2(Base_Import[90], shared_length, 1);
       a = a$0;
       b = b$0;
       c = c$0;
       shared_length = shared_length$0;
       continue;
      }
     }
     else if(! b && ! c) return [0, shared_length];
     return [1, shared_length, a, b, c];
    }
   }
   function check_length3_exn(name, l1, l2, l3){
    var match = of_lists$0(l1, l2, l3);
    if(0 === match[0]) return;
    var
     tail_of_c = match[4],
     tail_of_b = match[3],
     tail_of_a = match[2],
     shared_length = match[1],
     _aH_ = caml_call1(length, tail_of_a),
     n1 = caml_call2(Base_Import[90], shared_length, _aH_),
     _aI_ = caml_call1(length, tail_of_b),
     n2 = caml_call2(Base_Import[90], shared_length, _aI_),
     _aJ_ = caml_call1(length, tail_of_c),
     n3 = caml_call2(Base_Import[90], shared_length, _aJ_);
    return caml_call7(invalid_argf, _e_, name, n1, n2, n2, n3, 0);
   }
   function check_length3(l1, l2, l3, f){
    return 0 === of_lists$0(l1, l2, l3)[0]
            ? [0, caml_call3(f, l1, l2, l3)]
            : 0;
   }
   function iter2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_aE_){
              var _aF_ = caml_call1(iter2_ok, _aE_);
              return function(_aG_){return caml_call2(_aF_, _aG_, f);};
             });
   }
   function iter2_exn(l1, l2, f){
    check_length2_exn(cst_iter2_exn, l1, l2);
    return caml_call3(iter2_ok, l1, l2, f);
   }
   function rev_map2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_aB_){
              var _aC_ = caml_call1(rev_map2_ok, _aB_);
              return function(_aD_){return caml_call2(_aC_, _aD_, f);};
             });
   }
   function rev_map2_exn(l1, l2, f){
    check_length2_exn(cst_rev_map2_exn, l1, l2);
    return caml_call3(rev_map2_ok, l1, l2, f);
   }
   function fold2(l1, l2, init, f){
    return check_length2
            (l1,
             l2,
             function(_ay_){
              var _az_ = caml_call1(fold2_ok, _ay_);
              return function(_aA_){return caml_call3(_az_, _aA_, init, f);};
             });
   }
   function fold2_exn(l1, l2, init, f){
    check_length2_exn(cst_fold2_exn, l1, l2);
    return caml_call4(fold2_ok, l1, l2, init, f);
   }
   function for_all2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_av_){
              var _aw_ = caml_call1(for_all2_ok, _av_);
              return function(_ax_){return caml_call2(_aw_, _ax_, f);};
             });
   }
   function for_all2_exn(l1, l2, f){
    check_length2_exn(cst_for_all2_exn, l1, l2);
    return caml_call3(for_all2_ok, l1, l2, f);
   }
   function exists2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_as_){
              var _at_ = caml_call1(exists2_ok, _as_);
              return function(_au_){return caml_call2(_at_, _au_, f);};
             });
   }
   function exists2_exn(l1, l2, f){
    check_length2_exn(cst_exists2_exn, l1, l2);
    return caml_call3(exists2_ok, l1, l2, f);
   }
   function mem(t, a, equal){
    var param = t;
    for(;;){
     if(! param) return 0;
     var bs = param[2], b = param[1], _ar_ = caml_call2(equal, a, b);
     if(_ar_) return _ar_;
     param = bs;
    }
   }
   function rev_filter(t, f){
    var accu = 0, param = t;
    for(;;){
     if(! param) return accu;
     var l = param[2], x = param[1];
     if(caml_call1(f, x)){
      var accu$0 = [0, x, accu];
      accu = accu$0;
      param = l;
     }
     else
      param = l;
    }
   }
   function filter(t, f){return caml_call1(rev, rev_filter(t, f));}
   function find_map(t, f){
    var param = t;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1], r = caml_call1(f, x);
     if(r) return r;
     param = l;
    }
   }
   var not_found = [0, Base_Import[251], [0, "List.find_map_exn: not found"]];
   function find_map_exn(t, f){
    var match = find_map(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var x = match[1];
    return x;
   }
   function find(t, f){
    var param = t;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1];
     if(caml_call1(f, x)) return [0, x];
     param = l;
    }
   }
   var not_found$0 = [0, Base_Import[251], [0, "List.find_exn: not found"]];
   function find_exn(t, f){
    var t$0 = t;
    for(;;){
     if(! t$0) throw caml_maybe_attach_backtrace(not_found$0, 1);
     var t$1 = t$0[2], x = t$0[1];
     if(caml_call1(f, x)) return x;
     t$0 = t$1;
    }
   }
   function findi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], x = t$0[1];
     if(caml_call2(f, i, x)) return [0, [0, i, x]];
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     t$0 = l;
    }
   }
   var not_found$1 = [0, Base_Import[251], [0, "List.findi_exn: not found"]];
   function findi_exn(t, f){
    var match = findi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$1, 1);
    var x = match[1];
    return x;
   }
   function find_mapi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], x = t$0[1], result = caml_call2(f, i, x);
     if(result) return result;
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     t$0 = l;
    }
   }
   var
    not_found$2 = [0, Base_Import[251], [0, "List.find_mapi_exn: not found"]];
   function find_mapi_exn(t, f){
    var match = find_mapi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$2, 1);
    var x = match[1];
    return x;
   }
   function for_alli(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 1;
     var tl = t$0[2], hd = t$0[1], _aq_ = caml_call2(f, i, hd);
     if(! _aq_) return _aq_;
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     t$0 = tl;
    }
   }
   function existsi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var tl = t$0[2], hd = t$0[1], _ap_ = caml_call2(f, i, hd);
     if(_ap_) return _ap_;
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     t$0 = tl;
    }
   }
   var to_array = Base_Array0[13];
   function to_list(t){return t;}
   var
    cst_List_last = "List.last",
    _n_ = [0, "list.ml.Transpose_got_lists_of_different_lengths"],
    _o_ = [0, cst_src_list_ml, 1301, 13],
    cst_List_random_element_exn_em = "List.random_element_exn: empty list",
    cst_List_drop_last_exn_empty_l = "List.drop_last_exn: empty list",
    _m_ =
      [0,
       [11, "List.chunks_of: Expected length > 0, got ", [4, 0, 0, 0, 0]],
       "List.chunks_of: Expected length > 0, got %d"],
    cst_List_sub = "List.sub",
    _k_ = [0, cst_src_list_ml, 1045, 12],
    _j_ = [0, cst_src_list_ml, 933, 4],
    _i_ = [0, [11, "List.init ", [4, 0, 0, 0, 0]], "List.init %d"],
    cst_List_reduce_balanced_exn = "List.reduce_balanced_exn",
    _h_ = [0, cst_src_list_ml, 661, 14],
    cst_List_reduce_exn = "List.reduce_exn",
    _g_ =
      [0,
       [11,
        "length mismatch in zip_exn: ",
        [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]],
       "length mismatch in zip_exn: %d <> %d"],
    cst_map3_exn = "map3_exn",
    cst_rev_map3_exn = "rev_map3_exn",
    _f_ = [0, cst_src_list_ml, 528, 11],
    cst_map2_exn = "map2_exn",
    _l_ = [0, "List.Assoc.find_exn: not found"],
    cst_Base_List_Transpose_got_li =
      "Base__List.Transpose_got_lists_of_different_lengths",
    max_non_tailcall = typeof Base_Sys[8] === "number" ? 1000 : 50;
   function count_append(l1, l2, count){
    if(! l2) return l1;
    if(! l1) return l2;
    var _al_ = l1[2], x1 = l1[1];
    if(! _al_) return [0, x1, l2];
    var _am_ = _al_[2], x2 = _al_[1];
    if(! _am_) return [0, x1, [0, x2, l2]];
    var _an_ = _am_[2], x3 = _am_[1];
    if(! _an_) return [0, x1, [0, x2, [0, x3, l2]]];
    var match = _an_[2], x4 = _an_[1];
    if(! match) return [0, x1, [0, x2, [0, x3, [0, x4, l2]]]];
    var
     tl = match[2],
     x5 = match[1],
     _ao_ =
       max_non_tailcall < count
        ? caml_call2(rev_append, caml_call1(rev, tl), l2)
        : count_append(tl, l2, caml_call2(Base_Import[90], count, 1));
    return [0, x1, [0, x2, [0, x3, [0, x4, [0, x5, _ao_]]]]];
   }
   function append(l1, l2){return count_append(l1, l2, 0);}
   function count_map(f, l, ctr){
    if(! l) return 0;
    var _ah_ = l[2], x1$0 = l[1];
    if(! _ah_){var f1$3 = caml_call1(f, x1$0); return [0, f1$3, 0];}
    var _ai_ = _ah_[2], x2$0 = _ah_[1];
    if(! _ai_){
     var f1$2 = caml_call1(f, x1$0), f2$2 = caml_call1(f, x2$0);
     return [0, f1$2, [0, f2$2, 0]];
    }
    var _aj_ = _ai_[2], x3$0 = _ai_[1];
    if(! _aj_){
     var
      f1$1 = caml_call1(f, x1$0),
      f2$1 = caml_call1(f, x2$0),
      f3$1 = caml_call1(f, x3$0);
     return [0, f1$1, [0, f2$1, [0, f3$1, 0]]];
    }
    var match$1 = _aj_[2], x4$0 = _aj_[1];
    if(! match$1){
     var
      f1$0 = caml_call1(f, x1$0),
      f2$0 = caml_call1(f, x2$0),
      f3$0 = caml_call1(f, x3$0),
      f4$0 = caml_call1(f, x4$0);
     return [0, f1$0, [0, f2$0, [0, f3$0, [0, f4$0, 0]]]];
    }
    var
     tl = match$1[2],
     x5$0 = match$1[1],
     f1 = caml_call1(f, x1$0),
     f2 = caml_call1(f, x2$0),
     f3 = caml_call1(f, x3$0),
     f4 = caml_call1(f, x4$0),
     f5 = caml_call1(f, x5$0);
    if(max_non_tailcall < ctr){
     a:
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           h:
           {
            var bs$0 = 0, xs = tl;
            for(;;){
             if(! xs) break a;
             var _aa_ = xs[2];
             if(! _aa_) break;
             var _ab_ = _aa_[2];
             if(! _ab_) break h;
             var _ac_ = _ab_[2];
             if(! _ac_) break g;
             var _ad_ = _ac_[2];
             if(! _ad_) break f;
             var _ae_ = _ad_[2];
             if(! _ae_) break e;
             var _af_ = _ae_[2];
             if(! _af_) break d;
             var _ag_ = _af_[2];
             if(! _ag_) break c;
             var match$0 = _ag_[2];
             if(! match$0) break b;
             var
              xs$0 = match$0[2],
              x8 = match$0[1],
              x7 = _ag_[1],
              x6 = _af_[1],
              x5 = _ae_[1],
              x4 = _ad_[1],
              x3 = _ac_[1],
              x2 = _ab_[1],
              x1 = _aa_[1],
              x0 = xs[1],
              y0$0 = caml_call1(f, x0),
              y1$0 = caml_call1(f, x1),
              y2$0 = caml_call1(f, x2),
              y3$0 = caml_call1(f, x3),
              y4$0 = caml_call1(f, x4),
              y5$0 = caml_call1(f, x5),
              y6$0 = caml_call1(f, x6),
              y7$0 = caml_call1(f, x7),
              y8$0 = caml_call1(f, x8),
              bs$1 =
                [0,
                 [0, y0$0, y1$0, y2$0, y3$0, y4$0, y5$0, y6$0, y7$0, y8$0],
                 bs$0];
             bs$0 = bs$1;
             xs = xs$0;
            }
            break a;
           }
           break a;
          }
          break a;
         }
         break a;
        }
        break a;
       }
       break a;
      }
      break a;
     }
     var ys$1 = caml_call2(nontail_map, xs, f), ys = ys$1, param = bs$0;
     for(;;){
      if(! param){var _ak_ = ys; break;}
      var
       bs = param[2],
       match = param[1],
       y8 = match[9],
       y7 = match[8],
       y6 = match[7],
       y5 = match[6],
       y4 = match[5],
       y3 = match[4],
       y2 = match[3],
       y1 = match[2],
       y0 = match[1],
       ys$0 =
         [0,
          y0,
          [0,
           y1,
           [0, y2, [0, y3, [0, y4, [0, y5, [0, y6, [0, y7, [0, y8, ys]]]]]]]]];
      ys = ys$0;
      param = bs;
     }
    }
    else
     var _ak_ = count_map(f, tl, caml_call2(Base_Import[90], ctr, 1));
    return [0, f1, [0, f2, [0, f3, [0, f4, [0, f5, _ak_]]]]];
   }
   function map(l, f){return count_map(f, l, 0);}
   function folding_map(t, init, f){
    var acc = [0, init];
    return map
            (t,
             function(x){
              var
               match = caml_call2(f, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_map(t, init, f){
    var
     acc = [0, init],
     result =
       map
        (t,
         function(x){
          var
           match = caml_call2(f, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function symbol_map(l, f){return map(l, f);}
   function map2_ok(l1, l2, f){
    return caml_call1(rev, caml_call3(rev_map2_ok, l1, l2, f));
   }
   function map2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(___){
              return function(_$_){return map2_ok(___, _$_, f);};
             });
   }
   function map2_exn(l1, l2, f){
    check_length2_exn(cst_map2_exn, l1, l2);
    return map2_ok(l1, l2, f);
   }
   function rev_map3_ok(l1, l2, l3, f){
    var l1$0 = l1, l2$0 = l2, l3$0 = l3, ac = 0;
    for(;;){
     if(l1$0){
      if(l2$0 && l3$0){
       var
        l3$1 = l3$0[2],
        x3 = l3$0[1],
        l2$1 = l2$0[2],
        x2 = l2$0[1],
        l1$1 = l1$0[2],
        x1 = l1$0[1],
        ac$0 = [0, caml_call3(f, x1, x2, x3), ac];
       l1$0 = l1$1;
       l2$0 = l2$1;
       l3$0 = l3$1;
       ac = ac$0;
       continue;
      }
     }
     else if(! l2$0 && ! l3$0) return ac;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    }
   }
   function rev_map3(l1, l2, l3, f){
    return check_length3
            (l1,
             l2,
             l3,
             function(_X_){
              return function(_Y_){
               return function(_Z_){return rev_map3_ok(_X_, _Y_, _Z_, f);};};
             });
   }
   function rev_map3_exn(l1, l2, l3, f){
    check_length3_exn(cst_rev_map3_exn, l1, l2, l3);
    return rev_map3_ok(l1, l2, l3, f);
   }
   function map3_ok(l1, l2, l3, f){
    return caml_call1(rev, rev_map3_ok(l1, l2, l3, f));
   }
   function map3(l1, l2, l3, f){
    return check_length3
            (l1,
             l2,
             l3,
             function(_U_){
              return function(_V_){
               return function(_W_){return map3_ok(_U_, _V_, _W_, f);};};
             });
   }
   function map3_exn(l1, l2, l3, f){
    check_length3_exn(cst_map3_exn, l1, l2, l3);
    return map3_ok(l1, l2, l3, f);
   }
   function rev_map_append(l1, l2, f){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0;
     var l1$1 = l1$0[2], h = l1$0[1], l2$1 = [0, caml_call1(f, h), l2$0];
     l1$0 = l1$1;
     l2$0 = l2$1;
    }
   }
   function unzip(list){
    var list$2 = caml_call1(rev, list), list$0 = list$2, l1 = 0, l2 = 0;
    for(;;){
     if(! list$0) return [0, l1, l2];
     var
      list$1 = list$0[2],
      match = list$0[1],
      y = match[2],
      x = match[1],
      l2$0 = [0, y, l2],
      l1$0 = [0, x, l1];
     list$0 = list$1;
     l1 = l1$0;
     l2 = l2$0;
    }
   }
   function unzip3(list){
    var
     list$2 = caml_call1(rev, list),
     list$0 = list$2,
     l1 = 0,
     l2 = 0,
     l3 = 0;
    for(;;){
     if(! list$0) return [0, l1, l2, l3];
     var
      list$1 = list$0[2],
      match = list$0[1],
      z = match[3],
      y = match[2],
      x = match[1],
      l3$0 = [0, z, l3],
      l2$0 = [0, y, l2],
      l1$0 = [0, x, l1];
     list$0 = list$1;
     l1 = l1$0;
     l2 = l2$0;
     l3 = l3$0;
    }
   }
   function zip_exn(l1, l2){
    try{
     var _S_ = map2_ok(l1, l2, function(a, b){return [0, a, b];});
     return _S_;
    }
    catch(_T_){
     var _R_ = caml_call1(length, l2);
     return caml_call4(invalid_argf, _g_, caml_call1(length, l1), _R_, 0);
    }
   }
   function zip(l1, l2){
    return map2(l1, l2, function(a, b){return [0, a, b];});
   }
   function rev_mapi(l, f){
    var i = 0, acc = 0, param = l;
    for(;;){
     if(! param) return acc;
     var
      t = param[2],
      h = param[1],
      acc$0 = [0, caml_call2(f, i, h), acc],
      i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     acc = acc$0;
     param = t;
    }
   }
   function mapi(l, f){return caml_call1(rev, rev_mapi(l, f));}
   function folding_mapi(t, init, f){
    var acc = [0, init];
    return mapi
            (t,
             function(i, x){
              var
               match = caml_call3(f, i, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_mapi(t, init, f){
    var
     acc = [0, init],
     result =
       mapi
        (t,
         function(i, x){
          var
           match = caml_call3(f, i, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function iteri(l, f){
    caml_call3
     (fold_left,
      l,
      0,
      function(i, x){
       caml_call2(f, i, x);
       return caml_call2(Base_Import[90], i, 1);
      });
    return 0;
   }
   function foldi(t, init, f){
    var
     _P_ =
       caml_call3
        (fold_left,
         t,
         [0, 0, init],
         function(param, v){
          var acc = param[2], i = param[1], _Q_ = caml_call3(f, i, acc, v);
          return [0, caml_call2(Base_Import[90], i, 1), _Q_];
         });
    return caml_call1(Base_Import[126], _P_);
   }
   function filteri(l, f){
    return caml_call1
            (rev,
             foldi
              (l,
               0,
               function(pos, acc, x){
                return caml_call2(f, pos, x) ? [0, x, acc] : acc;
               }));
   }
   function reduce(l, f){
    if(! l) return 0;
    var tl = l[2], hd = l[1];
    return [0, caml_call3(fold_left, tl, hd, f)];
   }
   function reduce_exn(l, f){
    var match = reduce(l, f);
    if(! match) return caml_call1(Base_Import[125], cst_List_reduce_exn);
    var v = match[1];
    return v;
   }
   function reduce_balanced(l, f){
    function step_accum(num, acc, x){
     var num$0 = num, acc$0 = acc, x$0 = x;
     for(;;){
      if(0 === caml_call2(Base_Import[115], num$0, 1)) return [0, x$0, acc$0];
      if(! acc$0)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
      var
       acc$1 = acc$0[2],
       y = acc$0[1],
       x$1 = caml_call2(f, y, x$0),
       num$1 = caml_call2(Base_Import[114], num$0, 1);
      num$0 = num$1;
      acc$0 = acc$1;
      x$0 = x$1;
     }
    }
    var match = foldi(l, 0, step_accum);
    if(! match) return 0;
    var xs = match[2], x = match[1];
    return [0,
            caml_call3
             (fold_left, xs, x, function(x, y){return caml_call2(f, y, x);})];
   }
   function reduce_balanced_exn(l, f){
    var match = reduce_balanced(l, f);
    if(! match)
     return caml_call1(Base_Import[125], cst_List_reduce_balanced_exn);
    var v = match[1];
    return v;
   }
   function groupi(l, break$0){
    var
     groups =
       foldi
        (l,
         0,
         function(i, acc, x){
          if(! acc) return [0, [0, x, 0], 0];
          var tl = acc[2], current_group = acc[1];
          return caml_call3(break$0, i, caml_call1(hd_exn, current_group), x)
                  ? [0, [0, x, 0], [0, current_group, tl]]
                  : [0, [0, x, current_group], tl];
         });
    return groups ? caml_call2(rev_map, groups, rev) : 0;
   }
   function group(l, break$0){
    return groupi(l, function(param, x, y){return caml_call2(break$0, x, y);});
   }
   function sort_and_group(l, compare){
    return group
            (caml_call2(stable_sort, l, compare),
             function(x, y){return 0 !== caml_call2(compare, x, y) ? 1 : 0;});
   }
   function concat_map(l, f){
    var acc = 0, param = l;
    for(;;){
     if(! param) return caml_call1(rev, acc);
     var
      tl = param[2],
      hd = param[1],
      acc$0 = caml_call2(rev_append, caml_call1(f, hd), acc);
     acc = acc$0;
     param = tl;
    }
   }
   function concat_mapi(l, f){
    var cont = 0, acc = 0, param = l;
    for(;;){
     if(! param) return caml_call1(rev, acc);
     var
      tl = param[2],
      hd = param[1],
      acc$0 = caml_call2(rev_append, caml_call2(f, cont, hd), acc),
      cont$0 = caml_call2(Base_Import[90], cont, 1);
     cont = cont$0;
     acc = acc$0;
     param = tl;
    }
   }
   function merge(l1, l2, compare){
    var acc = 0, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return caml_call2(rev_append, acc, l2$0);
     if(! l2$0) return caml_call2(rev_append, acc, l1$0);
     var t2 = l2$0[2], h2 = l2$0[1], t1 = l1$0[2], h1 = l1$0[1];
     if(0 < caml_call2(compare, h1, h2)){
      var acc$0 = [0, h2, acc];
      acc = acc$0;
      l2$0 = t2;
     }
     else{var acc$1 = [0, h1, acc]; acc = acc$1; l1$0 = t1;}
    }
   }
   function map2$0(a, b, f){
    return concat_map
            (a,
             function(x){
              return map(b, function(y){return caml_call2(f, x, y);});
             });
   }
   function return$0(x){return [0, x, 0];}
   function symbol_bind(t, f){return concat_map(t, f);}
   var
    map$0 = [0, -198771759, map],
    Applicative =
      caml_call1(Base_Applicative[11], [0, return$0, map2$0, map$0]),
    map$1 = [0, -198771759, map],
    Monad = caml_call1(Base_Monad[1], [0, concat_map, return$0, map$1]),
    all = Monad[9],
    all_unit = Monad[10],
    ignore_m = Monad[8],
    join = Monad[7],
    apply = Applicative[8],
    both = Applicative[3],
    map3$0 = Applicative[10],
    symbol = Applicative[4],
    symbol$0 = Applicative[6],
    symbol$1 = Applicative[5],
    symbol$2 = Applicative[4],
    symbol$3 = Applicative[6],
    symbol$4 = Applicative[5],
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, concat_map, map, both, Open_on_rhs],
    Let_syntax$0 = [0, return$0, symbol_bind, symbol_map, Let_syntax],
    Monad_infix = [0, symbol_bind, symbol_map];
   function last_exn(list){
    var list$0 = list;
    for(;;){
     if(! list$0) return caml_call1(Base_Import[125], cst_List_last);
     var x = list$0[1];
     if(! list$0[2]) return x;
     var list$1 = list$0[2];
     list$0 = list$1;
    }
   }
   function last(list){
    var list$0 = list;
    for(;;){
     if(! list$0) return 0;
     var x = list$0[1];
     if(! list$0[2]) return [0, x];
     var list$1 = list$0[2];
     list$0 = list$1;
    }
   }
   function is_prefix(list, prefix, equal){
    var list$0 = list, prefix$0 = prefix;
    for(;;){
     if(! prefix$0) return 1;
     var prefix$1 = prefix$0[2], hd = prefix$0[1];
     if(! list$0) return 0;
     var
      list$1 = list$0[2],
      hd$0 = list$0[1],
      _O_ = caml_call2(equal, hd, hd$0);
     if(! _O_) return _O_;
     list$0 = list$1;
     prefix$0 = prefix$1;
    }
   }
   function find_consecutive_duplicate(t, equal){
    if(! t) return 0;
    var t$0 = t[2], a1 = t[1], a1$0 = a1, t$1 = t$0;
    for(;;){
     if(! t$1) return 0;
     var t$2 = t$1[2], a2 = t$1[1];
     if(caml_call2(equal, a1$0, a2)) return [0, [0, a1$0, a2]];
     a1$0 = a2;
     t$1 = t$2;
    }
   }
   function remove_consecutive_duplicates(opt, list, equal){
    if(opt)
     var sth = opt[1], which_to_keep = sth;
    else
     var which_to_keep = 847656566;
    if(! list) return 0;
    var
     tl$0 = list[2],
     to_keep$2 = list[1],
     to_keep = to_keep$2,
     accum = 0,
     param = tl$0;
    for(;;){
     if(! param) return caml_call1(rev, [0, to_keep, accum]);
     var tl = param[2], to_keep$0 = param[1];
     if(caml_call2(equal, to_keep$0, to_keep)){
      var to_keep$1 = 847656566 <= which_to_keep ? to_keep$0 : to_keep;
      to_keep = to_keep$1;
      param = tl;
     }
     else{
      var accum$0 = [0, to_keep, accum];
      to_keep = to_keep$0;
      accum = accum$0;
      param = tl;
     }
    }
   }
   function dedup_and_sort(list, compare){
    if(list && list[2]){
     var
      equal =
        function(x$0, x){return 0 === caml_call2(compare, x$0, x) ? 1 : 0;},
      sorted = caml_call2(sort, list, compare);
     return remove_consecutive_duplicates(0, sorted, equal);
    }
    return list;
   }
   function find_a_dup(l, compare){
    var sorted = caml_call2(sort, l, compare), l$0 = sorted;
    for(;;){
     if(l$0){
      var tl = l$0[2];
      if(tl){
       var hd2 = tl[1], hd1 = l$0[1];
       if(0 === caml_call2(compare, hd1, hd2)) return [0, hd1];
       l$0 = tl;
       continue;
      }
     }
     return 0;
    }
   }
   function contains_dup(lst, compare){
    return find_a_dup(lst, compare) ? 1 : 0;
   }
   function find_all_dups(l, compare){
    function compare$0(a, b){
     var _N_ = caml_call2(compare, a, b);
     return caml_call2(Base_Import[87], -1, _N_);
    }
    var sorted = caml_call2(sort, l, compare$0);
    if(! sorted) return 0;
    var
     sorted$2 = sorted[2],
     prev$1 = sorted[1],
     sorted$0 = sorted$2,
     prev = prev$1,
     already_recorded = 0,
     acc = 0;
    for(;;){
     if(! sorted$0) return acc;
     var sorted$1 = sorted$0[2], prev$0 = sorted$0[1];
     if(0 === compare$0(prev, prev$0))
      if(already_recorded){
       sorted$0 = sorted$1;
       prev = prev$0;
       already_recorded = 1;
      }
      else{
       var acc$0 = [0, prev$0, acc];
       sorted$0 = sorted$1;
       prev = prev$0;
       already_recorded = 1;
       acc = acc$0;
      }
     else{sorted$0 = sorted$1; prev = prev$0; already_recorded = 0;}
    }
   }
   function all_equal(t$0, equal){
    if(! t$0) return 0;
    var xs$0 = t$0[2], x$0 = t$0[1], t = xs$0;
    for(;;){
     if(t){
      var xs = t[2], x = t[1], _L_ = caml_call2(equal, x, x$0);
      if(_L_){t = xs; continue;}
      var _M_ = _L_;
     }
     else
      var _M_ = 1;
     return _M_ ? [0, x$0] : 0;
    }
   }
   function count(t, f){
    return caml_call3(Base_Container[2], fold_left, t, f);
   }
   function sum(m, t, f){
    return caml_call4(Base_Container[7], fold_left, m, t, f);
   }
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold_left, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold_left, t, compare);
   }
   function counti(t, f){
    return foldi
            (t,
             0,
             function(idx, count, a){
              return caml_call2(f, idx, a)
                      ? caml_call2(Base_Import[90], count, 1)
                      : count;
             });
   }
   function init(n, f){
    if(n < 0) caml_call3(invalid_argf, _i_, n, 0);
    var i = n, accum = 0;
    for(;;){
     if(0 > i) throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
     if(0 === i) return accum;
     var
      accum$0 = [0, caml_call1(f, caml_call2(Base_Import[92], i, 1)), accum],
      i$0 = caml_call2(Base_Import[92], i, 1);
     i = i$0;
     accum = accum$0;
    }
   }
   function rev_filter_map(l, f){
    var l$0 = l, accum = 0;
    for(;;){
     if(! l$0) return accum;
     var tl = l$0[2], hd = l$0[1], match = caml_call1(f, hd);
     if(match){
      var x = match[1], accum$0 = [0, x, accum];
      l$0 = tl;
      accum = accum$0;
     }
     else
      l$0 = tl;
    }
   }
   function filter_map(l, f){return caml_call1(rev, rev_filter_map(l, f));}
   function rev_filter_mapi(l, f){
    var i = 0, l$0 = l, accum = 0;
    for(;;){
     if(! l$0) return accum;
     var tl = l$0[2], hd = l$0[1], match = caml_call2(f, i, hd);
     if(match){
      var
       x = match[1],
       accum$0 = [0, x, accum],
       i$0 = caml_call2(Base_Import[90], i, 1);
      i = i$0;
      l$0 = tl;
      accum = accum$0;
     }
     else{var i$1 = caml_call2(Base_Import[90], i, 1); i = i$1; l$0 = tl;}
    }
   }
   function filter_mapi(l, f){return caml_call1(rev, rev_filter_mapi(l, f));}
   function filter_opt(l){return filter_map(l, function(_K_){return _K_;});}
   function partition3_map(t, f){
    var t$0 = t, fst = 0, snd = 0, trd = 0;
    for(;;){
     if(! t$0){
      var _I_ = caml_call1(rev, trd), _J_ = caml_call1(rev, snd);
      return [0, caml_call1(rev, fst), _J_, _I_];
     }
     var t$1 = t$0[2], x = t$0[1], match = caml_call1(f, x), _H_ = match[1];
     if(4152137 === _H_){
      var y = match[2], snd$0 = [0, y, snd];
      t$0 = t$1;
      snd = snd$0;
     }
     else if(4202758 <= _H_){
      var y$0 = match[2], trd$0 = [0, y$0, trd];
      t$0 = t$1;
      trd = trd$0;
     }
     else{var y$1 = match[2], fst$0 = [0, y$1, fst]; t$0 = t$1; fst = fst$0;}
    }
   }
   function partition_tf(t, f){
    function f$0(x){return caml_call1(f, x) ? [0, x] : [1, x];}
    return caml_call2(partition_map, t, f$0);
   }
   function partition_result(t){
    return caml_call2(partition_map, t, Base_Result[35]);
   }
   function t_of_sexp$0(of_a_014, of_b_015, x_023){
    return caml_call2
            (Base_Import[175],
             function(sexp_021){
              if(1 === sexp_021[0]){
               var _F_ = sexp_021[1];
               if(_F_){
                var _G_ = _F_[2];
                if(_G_ && ! _G_[2]){
                 var
                  arg1_018 = _G_[1],
                  arg0_017 = _F_[1],
                  res0_019 = caml_call1(of_a_014, arg0_017),
                  res1_020 = caml_call1(of_b_015, arg1_018);
                 return [0, res0_019, res1_020];
                }
               }
              }
              return caml_call3
                      (Sexplib0_Sexp_conv_error[2], error_source_022, 2, sexp_021);
             },
             x_023);
   }
   function sexp_of_t$1(of_a_024, of_b_025, x_030){
    return caml_call2
            (Base_Import[151],
             function(param){
              var
               arg1_027 = param[2],
               arg0_026 = param[1],
               res0_028 = caml_call1(of_a_024, arg0_026),
               res1_029 = caml_call1(of_b_025, arg1_027);
              return [1, [0, res0_028, [0, res1_029, 0]]];
             },
             x_030);
   }
   function t_sexp_grammar$0(a_sexp_grammar, b_sexp_grammar){
    return caml_call1
            (Base_Import[194],
             [2, [0, a_sexp_grammar, [0, b_sexp_grammar, 0]]]);
   }
   function pair_of_group(list){
    if(! list) throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
    var k = list[1][1];
    return [0, k, map(list, Base_Import[126])];
   }
   function group$0(alist, equal){
    return map
            (group
              (alist,
               function(param, _E_){
                var y = _E_[1], x = param[1];
                return 1 - caml_call2(equal, x, y);
               }),
             pair_of_group);
   }
   function sort_and_group$0(alist, compare){
    return map
            (sort_and_group
              (alist,
               function(param, _D_){
                var y = _D_[1], x = param[1];
                return caml_call2(compare, x, y);
               }),
             pair_of_group);
   }
   function find$0(t, equal, key){
    var
     match =
       find
        (t,
         function(param){
          var key$0 = param[1];
          return caml_call2(equal, key, key$0);
         });
    if(! match) return 0;
    var x = match[1];
    return [0, caml_call1(Base_Import[126], x)];
   }
   var not_found$3 = [0, Base_Import[251], _l_];
   function find_exn$0(t, equal, key){
    var match = find$0(t, equal, key);
    if(! match) throw caml_maybe_attach_backtrace(not_found$3, 1);
    var value = match[1];
    return value;
   }
   function mem$0(t, equal, key){return find$0(t, equal, key) ? 1 : 0;}
   function remove(t, equal, key){
    return filter
            (t,
             function(param){
              var key$0 = param[1];
              return 1 - caml_call2(equal, key, key$0);
             });
   }
   function add(t, equal, key, value){
    return [0, [0, key, value], remove(t, equal, key)];
   }
   function inverse(t){
    return map
            (t,
             function(param){
              var y = param[2], x = param[1];
              return [0, y, x];
             });
   }
   function map$2(t, f){
    return map
            (t,
             function(param){
              var value = param[2], key = param[1];
              return [0, key, caml_call1(f, value)];
             });
   }
   function sub(l, pos, len){
    var _z_ = pos < 0 ? 1 : 0;
    if(_z_)
     var _A_ = _z_;
    else{
     var _B_ = len < 0 ? 1 : 0;
     if(_B_)
      var _A_ = _B_;
     else
      var
       _C_ = caml_call1(length, l),
       _A_ = caml_call2(Base_Import[92], _C_, len) < pos ? 1 : 0;
    }
    if(_A_) caml_call1(Base_Import[125], cst_List_sub);
    return caml_call1
            (rev,
             foldi
              (l,
               0,
               function(i, acc, el){
                if(pos <= i && i < caml_call2(Base_Import[90], pos, len))
                 return [0, el, acc];
                return acc;
               }));
   }
   function split_n(t_orig, n){
    if(0 >= n) return [0, 0, t_orig];
    var n$0 = n, t = t_orig, accum = 0;
    for(;;){
     if(0 === n$0) return [0, caml_call1(rev, accum), t];
     if(! t) return [0, t_orig, 0];
     var
      tl = t[2],
      hd = t[1],
      accum$0 = [0, hd, accum],
      n$1 = caml_call2(Base_Import[92], n$0, 1);
     n$0 = n$1;
     t = tl;
     accum = accum$0;
    }
   }
   function take(t_orig, n){
    if(0 >= n) return 0;
    var n$0 = n, t = t_orig, accum = 0;
    for(;;){
     if(0 === n$0) return caml_call1(rev, accum);
     if(! t) return t_orig;
     var
      tl = t[2],
      hd = t[1],
      accum$0 = [0, hd, accum],
      n$1 = caml_call2(Base_Import[92], n$0, 1);
     n$0 = n$1;
     t = tl;
     accum = accum$0;
    }
   }
   function drop(t, n){
    var t$0 = t, n$0 = n;
    for(;;){
     if(t$0){
      var tl = t$0[2];
      if(0 < n$0){
       var n$1 = caml_call2(Base_Import[92], n$0, 1);
       t$0 = tl;
       n$0 = n$1;
       continue;
      }
     }
     return t$0;
    }
   }
   function chunks_of(l, length){
    if(length <= 0) caml_call3(invalid_argf, _m_, length, 0);
    var acc = 0, l$0 = l;
    for(;;){
     if(! l$0) return caml_call1(rev, acc);
     var
      match = split_n(l$0, length),
      l$1 = match[2],
      sublist = match[1],
      acc$0 = [0, sublist, acc];
     acc = acc$0;
     l$0 = l$1;
    }
   }
   function split_while(xs, f){
    var acc = 0, t = xs;
    for(;;){
     if(t){
      var tl = t[2], hd = t[1];
      if(caml_call1(f, hd)){
       var acc$0 = [0, hd, acc];
       acc = acc$0;
       t = tl;
       continue;
      }
     }
     return [0, caml_call1(rev, acc), t];
    }
   }
   function take_while(xs, f){
    var acc = 0, param = xs;
    for(;;){
     if(param){
      var tl = param[2], hd = param[1];
      if(caml_call1(f, hd)){
       var acc$0 = [0, hd, acc];
       acc = acc$0;
       param = tl;
       continue;
      }
     }
     return caml_call1(rev, acc);
    }
   }
   function drop_while(t, f){
    var t$0 = t;
    for(;;){
     if(t$0){
      var tl = t$0[2], hd = t$0[1];
      if(caml_call1(f, hd)){t$0 = tl; continue;}
     }
     return t$0;
    }
   }
   function drop_last(t){
    var match = caml_call1(rev, t);
    if(! match) return 0;
    var lst = match[2];
    return [0, caml_call1(rev, lst)];
   }
   function drop_last_exn(t){
    var match = drop_last(t);
    if(! match)
     return caml_call1(Base_Import[123], cst_List_drop_last_exn_empty_l);
    var lst = match[1];
    return lst;
   }
   function cartesian_product(list1, list2){
    if(caml_call1(is_empty, list2)) return 0;
    var l1 = list1, accum = 0;
    for(;;){
     if(! l1) return caml_call1(rev, accum);
     var tl = l1[2], hd = l1[1];
     let hd$0 = hd;
     var
      accum$0 =
        caml_call2
         (rev_append, map(list2, function(x){return [0, hd$0, x];}), accum);
     l1 = tl;
     accum = accum$0;
    }
   }
   function concat(l){return caml_call3(fold_right, l, append, 0);}
   function concat_no_order(l){
    return caml_call3
            (fold_left,
             l,
             0,
             function(acc, l){return caml_call2(rev_append, l, acc);});
   }
   function cons(x, l){return [0, x, l];}
   function is_sorted(l, compare){
    var l$0 = l;
    for(;;){
     if(l$0){
      var rest = l$0[2];
      if(rest){
       var
        x2 = rest[1],
        x1 = l$0[1],
        _y_ = caml_call2(compare, x1, x2) <= 0 ? 1 : 0;
       if(! _y_) return _y_;
       l$0 = rest;
       continue;
      }
     }
     return 1;
    }
   }
   function is_sorted_strictly(l, compare){
    var l$0 = l;
    for(;;){
     if(l$0){
      var rest = l$0[2];
      if(rest){
       var
        x2 = rest[1],
        x1 = l$0[1],
        _x_ = caml_call2(compare, x1, x2) < 0 ? 1 : 0;
       if(! _x_) return _x_;
       l$0 = rest;
       continue;
      }
     }
     return 1;
    }
   }
   var Infix = [0, append];
   function permute(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    if(list){
     var _w_ = list[2];
     if(_w_){
      if(_w_[2]){
       var arr = caml_call1(Base_Array0[13], list);
       caml_call4(Base_Array_permute[24], [0, random_state], 0, 0, arr);
       return caml_call1(Base_Array0[15], arr);
      }
      var y = _w_[1], x = list[1];
      return caml_call1(Base_Random[18][16], random_state)
              ? [0, y, [0, x, 0]]
              : list;
     }
    }
    return list;
   }
   function random_element_exn(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    if(caml_call1(is_empty, list))
     return caml_call1(Base_Import[123], cst_List_random_element_exn_em);
    var _v_ = caml_call1(length, list);
    return nth_exn(list, caml_call2(Base_Random[18][6], random_state, _v_));
   }
   function random_element(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    try{
     var _t_ = [0, random_element_exn([0, random_state], list)];
     return _t_;
    }
    catch(_u_){return 0;}
   }
   function compare$0(cmp, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      n = caml_call2(cmp, x, y);
     if(0 !== n) return n;
     a$0 = xs;
     b$0 = ys;
    }
   }
   var hash_fold_t = Base_Import[212];
   function equal(equal, t1, t2){
    var t1$0 = t1, t2$0 = t2;
    for(;;){
     if(t1$0){
      if(t2$0){
       var
        t2$1 = t2$0[2],
        x2 = t2$0[1],
        t1$1 = t1$0[2],
        x1 = t1$0[1],
        _s_ = caml_call2(equal, x1, x2);
       if(! _s_) return _s_;
       t1$0 = t1$1;
       t2$0 = t2$1;
       continue;
      }
     }
     else if(! t2$0) return 1;
     return 0;
    }
   }
   function transpose(rows$0){
    var rows = rows$0, columns = 0, do_rev = 1;
    for(;;){
     var t = rows, column_acc = 0, trimmed_rows = 0, found_empty = 0;
     for(;;){
      if(! t) break;
      var match = t[1];
      if(match){
       var
        tl = t[2],
        xs = match[2],
        x = match[1],
        trimmed = [0, xs, trimmed_rows],
        column_acc$0 = [0, x, column_acc];
       t = tl;
       column_acc = column_acc$0;
       trimmed_rows = trimmed;
      }
      else{var tl$0 = t[2]; t = tl$0; found_empty = 1;}
     }
     if(! column_acc && ! trimmed_rows) return [0, caml_call1(rev, columns)];
     if(found_empty) return 0;
     var
      column = do_rev ? caml_call1(rev, column_acc) : column_acc,
      do_rev$0 = 1 - do_rev,
      columns$0 = [0, column, columns];
     rows = trimmed_rows;
     columns = columns$0;
     do_rev = do_rev$0;
    }
   }
   var
    Transpose_got_lists_of_differe =
      [248, cst_Base_List_Transpose_got_li, runtime.caml_fresh_oo_id(0)];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Transpose_got_lists_of_differe,
     function(param){
      if(param[1] !== Transpose_got_lists_of_differe)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
      var
       arg0_031 = param[2],
       res0_032 = caml_call2(Base_Import[151], Base_Import[141], arg0_031);
      return [1, [0, _n_, [0, res0_032, 0]]];
     });
   function transpose_exn(l){
    var match = transpose(l);
    if(! match)
     throw caml_maybe_attach_backtrace
            ([0, Transpose_got_lists_of_differe, map(l, length)], 1);
    var l$0 = match[1];
    return l$0;
   }
   function intersperse(t, sep){
    if(! t) return 0;
    var xs = t[2], x = t[1];
    return [0,
            x,
            caml_call3
             (fold_right,
              xs,
              function(y, acc){return [0, sep, [0, y, acc]];},
              0)];
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold_left, init, f, t);
   }
   function fold_until(t, init, f){
    var _q_ = caml_call3(Base_Container[9], fold_left, init, f);
    return function(_r_){return caml_call2(_q_, _r_, t);};
   }
   function is_suffix(list, suffix, equal_elt){
    var
     list_len = caml_call1(length, list),
     suffix_len = caml_call1(length, suffix),
     _p_ = suffix_len <= list_len ? 1 : 0;
    return _p_
            ? equal
              (equal_elt,
               drop(list, caml_call2(Base_Import[92], list_len, suffix_len)),
               suffix)
            : _p_;
   }
   var
    Base_List =
      [0,
       compare$0,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold_left,
       fold_result,
       fold_until,
       exists,
       for_all,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       invariant,
       [0,
        both,
        symbol,
        symbol$1,
        symbol$0,
        apply,
        map2$0,
        map3$0,
        [0, symbol$2, symbol$4, symbol$3, symbol_map],
        symbol_bind,
        symbol_map,
        [0, symbol_bind, symbol_map],
        concat_map,
        return$0,
        map,
        join,
        ignore_m,
        all,
        all_unit,
        [0, return$0, symbol_bind, symbol_map, Let_syntax]],
       symbol_bind,
       symbol_map,
       Monad_infix,
       concat_map,
       return$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax$0,
       Or_unequal_lengths,
       of_list,
       nth,
       nth_exn,
       rev,
       rev_append,
       unordered_append,
       rev_map,
       iter2_exn,
       iter2,
       rev_map2_exn,
       rev_map2,
       fold2_exn,
       fold2,
       for_alli,
       for_all2_exn,
       for_all2,
       existsi,
       exists2_exn,
       exists2,
       filter,
       rev_filter,
       filteri,
       partition_map,
       partition3_map,
       partition_tf,
       partition_result,
       split_n,
       sort,
       stable_sort,
       merge,
       hd,
       tl,
       hd_exn,
       tl_exn,
       findi,
       findi_exn,
       find_exn,
       find_map_exn,
       find_mapi,
       find_mapi_exn,
       append,
       map,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       concat_map,
       concat_mapi,
       map2_exn,
       map2,
       rev_map3_exn,
       rev_map3,
       map3_exn,
       map3,
       rev_map_append,
       fold_right,
       fold_left,
       unzip,
       unzip3,
       zip,
       zip_exn,
       mapi,
       rev_mapi,
       iteri,
       foldi,
       reduce_exn,
       reduce,
       reduce_balanced,
       reduce_balanced_exn,
       group,
       groupi,
       sort_and_group,
       chunks_of,
       last,
       last_exn,
       is_prefix,
       is_suffix,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       dedup_and_sort,
       find_a_dup,
       contains_dup,
       find_all_dups,
       all_equal,
       count,
       counti,
       range$0,
       range,
       init,
       rev_filter_map,
       rev_filter_mapi,
       filter_map,
       filter_mapi,
       filter_opt,
       [0,
        t_of_sexp$0,
        sexp_of_t$1,
        t_sexp_grammar$0,
        add,
        find$0,
        find_exn$0,
        mem$0,
        remove,
        map$2,
        inverse,
        group$0,
        sort_and_group$0],
       sub,
       take,
       drop,
       take_while,
       drop_while,
       split_while,
       drop_last,
       drop_last_exn,
       concat,
       concat_no_order,
       cons,
       cartesian_product,
       permute,
       random_element,
       random_element_exn,
       is_sorted,
       is_sorted_strictly,
       equal,
       Infix,
       transpose,
       transpose_exn,
       intersperse];
   runtime.caml_register_global(54, Base_List, "Base__List");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Info
//# unitInfo: Requires: Assert_failure, Base__Exn, Base__Hash, Base__Import, Base__Info_intf, Base__Lazy, Base__List, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Source_code_position0, Base__String0, CamlinternalLazy, Sexplib0__Sexp_conv, Stdlib__Format, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$5 = ": ",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$4 = "",
    cst$3 = "; ",
    cst = cst$5,
    cst$0 = cst$5,
    cst$1 = cst$5,
    cst$2 = cst$5,
    t_sexp_grammar = [0, "Info.t"],
    module_name = "Base.Info",
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Exn = global_data.Base__Exn,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Lazy = global_data.Base__Lazy,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Assert_failure = global_data.Assert_failure,
    Base_List = global_data.Base__List,
    Base_Printf = global_data.Base__Printf,
    Base_Sexp = global_data.Base__Sexp,
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_String0 = global_data.Base__String0,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    _a_ = [0, "Could_not_construct"],
    _b_ = [0, "String"],
    _c_ = [0, "Exn"],
    _d_ = [0, "Sexp"],
    _e_ = [0, "Tag_sexp"],
    _f_ = [0, "Tag_t"],
    _g_ = [0, "Tag_arg"],
    _h_ = [0, "Of_list"],
    _i_ = [0, "With_backtrace"],
    cst_could_not_construct_info = "could not construct info: ",
    _j_ =
      [0,
       [11, "and ", [4, 0, 0, 0, [11, " more info", 0]]],
       "and %d more info"],
    cst_Backtrace = "\nBacktrace:\n";
   function sexp_of_t(param){
    switch(param[0]){
      case 0:
       var arg0_001 = param[1], res0_002 = caml_call1(Base_Sexp[4], arg0_001);
       return [1, [0, _a_, [0, res0_002, 0]]];
      case 1:
       var
        arg0_003 = param[1],
        res0_004 = caml_call1(Base_Import[138], arg0_003);
       return [1, [0, _b_, [0, res0_004, 0]]];
      case 2:
       var
        arg0_005 = param[1],
        res0_006 = caml_call1(Base_Import[198], arg0_005);
       return [1, [0, _c_, [0, res0_006, 0]]];
      case 3:
       var arg0_007 = param[1], res0_008 = caml_call1(Base_Sexp[4], arg0_007);
       return [1, [0, _d_, [0, res0_008, 0]]];
      case 4:
       var
        arg2_011 = param[3],
        arg1_010 = param[2],
        arg0_009 = param[1],
        res0_012 = caml_call1(Base_Import[138], arg0_009),
        res1_013 = caml_call1(Base_Sexp[4], arg1_010),
        res2_014 =
          caml_call2
           (Base_Import[148], Base_Source_code_position0[8], arg2_011);
       return [1, [0, _e_, [0, res0_012, [0, res1_013, [0, res2_014, 0]]]]];
      case 5:
       var
        arg1_016 = param[2],
        arg0_015 = param[1],
        res0_017 = caml_call1(Base_Import[138], arg0_015),
        res1_018 = sexp_of_t(arg1_016);
       return [1, [0, _f_, [0, res0_017, [0, res1_018, 0]]]];
      case 6:
       var
        arg2_021 = param[3],
        arg1_020 = param[2],
        arg0_019 = param[1],
        res0_022 = caml_call1(Base_Import[138], arg0_019),
        res1_023 = caml_call1(Base_Sexp[4], arg1_020),
        res2_024 = sexp_of_t(arg2_021);
       return [1, [0, _g_, [0, res0_022, [0, res1_023, [0, res2_024, 0]]]]];
      case 7:
       var
        arg1_026 = param[2],
        arg0_025 = param[1],
        res0_027 = caml_call2(Base_Import[148], Base_Import[141], arg0_025),
        res1_028 = caml_call2(Base_Import[151], sexp_of_t, arg1_026);
       return [1, [0, _h_, [0, res0_027, [0, res1_028, 0]]]];
      default:
       var
        arg1_030 = param[2],
        arg0_029 = param[1],
        res0_031 = sexp_of_t(arg0_029),
        res1_032 = caml_call1(Base_Import[138], arg1_030);
       return [1, [0, _i_, [0, res0_031, [0, res1_032, 0]]]];
    }
   }
   function to_strings_hum(t, ac){
    var t$0 = t, ac$0 = ac;
    for(;;)
     switch(t$0[0]){
       case 0:
        var sexp = t$0[1];
        return [0,
                cst_could_not_construct_info,
                [0, caml_call1(Base_Sexp[16], sexp), ac$0]];
       case 1:
        var string = t$0[1]; return [0, string, ac$0];
       case 2:
        var exn = t$0[1], _P_ = caml_call1(Base_Exn[1], exn);
        return [0, caml_call1(Base_Sexp[16], _P_), ac$0];
       case 3:
        var sexp$0 = t$0[1];
        return [0, caml_call1(Base_Sexp[16], sexp$0), ac$0];
       case 4:
        var sexp$1 = t$0[2], tag = t$0[1];
        return [0,
                tag,
                [0, cst, [0, caml_call1(Base_Sexp[16], sexp$1), ac$0]]];
       case 5:
        var t$1 = t$0[2], tag$0 = t$0[1];
        return [0, tag$0, [0, cst$0, to_strings_hum(t$1, ac$0)]];
       case 6:
        var
         t$2 = t$0[3],
         sexp$2 = t$0[2],
         tag$1 = t$0[1],
         _Q_ = [0, cst$1, to_strings_hum(t$2, ac$0)],
         body = [0, caml_call1(Base_Sexp[16], sexp$2), _Q_];
        return 0 === caml_ml_string_length(tag$1)
                ? body
                : [0, tag$1, [0, cst$2, body]];
       case 7:
        var ts = t$0[2], trunc_after = t$0[1];
        if(trunc_after){
         var max = trunc_after[1], n = caml_call1(Base_List[7], ts);
         if(n <= max)
          var ts$0 = ts;
         else
          var
           _S_ = caml_call2(Base_Import[92], n, max),
           _T_ = [0, [1, caml_call2(Base_Printf[2], _j_, _S_)], 0],
           _U_ = caml_call2(Base_List[131], ts, max),
           ts$0 = caml_call2(Base_Import[110], _U_, _T_);
         var ts$1 = ts$0;
        }
        else
         var ts$1 = ts;
        var _R_ = caml_call1(Base_List[38], ts$1);
        return caml_call3
                (Base_List[10],
                 _R_,
                 ac$0,
                 function(ac, t){
                  var
                   ac$0 = caml_call1(Base_List[8], ac) ? ac : [0, cst$3, ac];
                  return to_strings_hum(t, ac$0);
                 });
       default:
        var
         backtrace = t$0[2],
         t$3 = t$0[1],
         ac$1 = [0, cst_Backtrace, [0, backtrace, ac$0]];
        t$0 = t$3;
        ac$0 = ac$1;
     }
   }
   function to_sexps_hum(t, ac){
    switch(t[0]){
      case 0:
       return [0, sexp_of_t(t), ac];
      case 1:
       var string = t[1]; return [0, [0, string], ac];
      case 2:
       var exn = t[1]; return [0, caml_call1(Base_Exn[1], exn), ac];
      case 3:
       var sexp = t[1]; return [0, sexp, ac];
      case 4:
       var here = t[3], sexp$0 = t[2], tag = t[1];
       if(here)
        var
         here$0 = here[1],
         _N_ = [0, caml_call1(Base_Source_code_position0[8], here$0), 0];
       else
        var _N_ = 0;
       return [0, [1, [0, [0, tag], [0, sexp$0, _N_]]], ac];
      case 5:
       var t$0 = t[2], tag$0 = t[1];
       return [0, [1, [0, [0, tag$0], to_sexps_hum(t$0, 0)]], ac];
      case 6:
       var
        t$1 = t[3],
        sexp$1 = t[2],
        tag$1 = t[1],
        body = [0, sexp$1, to_sexps_hum(t$1, 0)];
       return 0 === caml_ml_string_length(tag$1)
               ? [0, [1, body], ac]
               : [0, [1, [0, [0, tag$1], body]], ac];
      case 7:
       var ts = t[2], _O_ = caml_call1(Base_List[38], ts);
       return caml_call3
               (Base_List[10],
                _O_,
                ac,
                function(ac, t){return to_sexps_hum(t, ac);});
      default:
       var backtrace = t[2], t$2 = t[1];
       return [0, [1, [0, to_sexp_hum(t$2), [0, [0, backtrace], 0]]], ac];
    }
   }
   function to_sexp_hum(t){
    var sexps = to_sexps_hum(t, 0);
    if(sexps && ! sexps[2]){var sexp = sexps[1]; return sexp;}
    return [1, sexps];
   }
   function protect(f){
    try{var _M_ = caml_call1(f, 0); return _M_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     return [0, caml_call1(Base_Exn[1], exn)];
    }
   }
   function to_message(info){
    return protect
            (function(param){
              var _L_ = caml_obj_tag(info);
              return 250 === _L_
                      ? info[1]
                      : 246 === _L_ ? caml_call1(CamlinternalLazy[2], info) : info;
             });
   }
   function of_message(t){return [250, t];}
   function invariant(param){return 0;}
   function sexp_of_t$0(t){return to_sexp_hum(to_message(t));}
   function t_of_sexp(sexp){return [246, function(_K_){return [3, sexp];}];}
   function compare(t1, t2){
    var _I_ = sexp_of_t$0(t2), _J_ = sexp_of_t$0(t1);
    return caml_call2(Base_Sexp[6], _J_, _I_);
   }
   function equal(t1, t2){
    var _G_ = sexp_of_t$0(t2), _H_ = sexp_of_t$0(t1);
    return caml_call2(Base_Sexp[5], _H_, _G_);
   }
   function hash_fold_t(state, t){
    var _F_ = sexp_of_t$0(t);
    return caml_call2(Base_Sexp[1], state, _F_);
   }
   function hash(t){return caml_call3(Base_Hash[14], 0, hash_fold_t, t);}
   function to_string_hum(t){
    var message = to_message(t);
    if(1 === message[0]){var s = message[1]; return s;}
    var _E_ = to_sexp_hum(message);
    return caml_call2(Base_Sexp[15], 0, _E_);
   }
   function to_string_hum_deprecated(t){
    var t$0 = to_message(t), _D_ = to_strings_hum(t$0, 0);
    return caml_call2(Base_String0[14], 0, _D_);
   }
   function to_string_mach(t){
    var _C_ = sexp_of_t$0(t);
    return caml_call1(Base_Sexp[16], _C_);
   }
   function of_lazy(l){
    return [246,
            function(_z_){
             return protect
                     (function(param){
                       var
                        _A_ = caml_obj_tag(l),
                        _B_ =
                          250 === _A_
                           ? l[1]
                           : 246 === _A_ ? caml_call1(CamlinternalLazy[2], l) : l;
                       return [1, _B_];
                      });
            }];
   }
   function of_lazy_sexp(l){
    return [246,
            function(_w_){
             return protect
                     (function(param){
                       var
                        _x_ = caml_obj_tag(l),
                        _y_ =
                          250 === _x_
                           ? l[1]
                           : 246 === _x_ ? caml_call1(CamlinternalLazy[2], l) : l;
                       return [3, _y_];
                      });
            }];
   }
   function of_lazy_t(lazy_t){return caml_call1(Base_Lazy[13], lazy_t);}
   function of_string(message){
    return caml_call1(Base_Lazy[21], [1, message]);
   }
   function createf(format){
    return caml_call2(Base_Printf[4], of_string, format);
   }
   function of_thunk(f){
    return [246,
            function(_v_){
             return protect(function(param){return [1, caml_call1(f, 0)];});
            }];
   }
   function create(here, strict, tag, x, sexp_of_x){
    if(! strict)
     return [246,
             function(_u_){
              return protect
                      (function(param){
                        return [4, tag, caml_call1(sexp_of_x, x), here];
                       });
             }];
    var t = [4, tag, caml_call1(sexp_of_x, x), here];
    return [250, t];
   }
   function create_s(sexp){return caml_call1(Base_Lazy[21], [3, sexp]);}
   function tag(t, tag){
    return [246, function(param){return [5, tag, to_message(t)];}];
   }
   function tag_s_lazy(t, tag){
    return [246,
            function(_q_){
             return protect
                     (function(param){
                       var
                        _r_ = to_message(t),
                        _s_ = caml_obj_tag(tag),
                        _t_ =
                          250 === _s_
                           ? tag[1]
                           : 246 === _s_ ? caml_call1(CamlinternalLazy[2], tag) : tag;
                       return [6, cst$4, _t_, _r_];
                      });
            }];
   }
   function tag_s(t, tag){
    return tag_s_lazy(t, caml_call1(Base_Lazy[21], tag));
   }
   function tag_arg(t, tag, x, sexp_of_x){
    return [246,
            function(_o_){
             return protect
                     (function(param){
                       var _p_ = to_message(t);
                       return [6, tag, caml_call1(sexp_of_x, x), _p_];
                      });
            }];
   }
   function of_list(trunc_after, ts){
    return [246,
            function(param){
             return [7,
                     trunc_after,
                     caml_call2(Base_List[76], ts, to_message)];
            }];
   }
   var
    Exn = [248, "Base__Info.Exn", runtime.caml_fresh_oo_id(0)],
    _k_ = [0, "src/info.ml", 204, 6];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Exn,
     function(param){
      if(param[1] !== Exn)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
      var t = param[2];
      return sexp_of_t$0(t);
     });
   function to_exn(t){
    if(! caml_call1(Base_Lazy[22], t)) return [0, Exn, t];
    var
     _n_ = caml_obj_tag(t),
     match =
       250 === _n_
        ? t[1]
        : 246 === _n_ ? caml_call1(CamlinternalLazy[2], t) : t;
    if(2 !== match[0]) return [0, Exn, t];
    var exn = match[1];
    return exn;
   }
   function of_exn(backtrace, exn){
    if(backtrace){
     var match = backtrace[1];
     if(typeof match === "number")
      var _m_ = [0, caml_call1(Stdlib_Printexc[6], 0)];
     else
      var s = match[2], _m_ = [0, s];
     var backtrace$0 = _m_;
    }
    else
     var backtrace$0 = 0;
    if(exn[1] === Exn){
     var t = exn[2];
     if(! backtrace$0) return t;
     var backtrace$1 = backtrace$0[1];
     return [246, function(param){return [8, to_message(t), backtrace$1];}];
    }
    if(! backtrace$0) return caml_call1(Base_Lazy[21], [2, exn]);
    var backtrace$2 = backtrace$0[1];
    return [246,
            function(param){
             return [8, [3, caml_call1(Base_Exn[1], exn)], backtrace$2];
            }];
   }
   function pp(ppf, t){
    var _l_ = to_string_hum(t);
    return caml_call2(Stdlib_Format[13], ppf, _l_);
   }
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    Base_Info =
      [0,
       compare,
       equal,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       t_sexp_grammar,
       invariant,
       to_string_hum,
       to_string_mach,
       to_string_hum_deprecated,
       of_string,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create,
       create_s,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       of_list,
       of_exn,
       to_exn,
       pp$0,
       [0, sexp_of_t, to_message, of_message]];
   runtime.caml_register_global(37, Base_Info, "Base__Info");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Error
//# unitInfo: Requires: Base__Info, Base__Pretty_printer
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    t_sexp_grammar = [0, "Error.t"],
    module_name = "Base.Error",
    Base_Info = global_data.Base__Info,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    compare = Base_Info[1],
    equal = Base_Info[2],
    hash_fold_t = Base_Info[3],
    hash = Base_Info[4],
    t_of_sexp = Base_Info[5],
    sexp_of_t = Base_Info[6],
    invariant = Base_Info[8],
    to_string_hum = Base_Info[9],
    to_string_mach = Base_Info[10],
    to_string_hum_deprecated = Base_Info[11],
    of_string = Base_Info[12],
    of_lazy = Base_Info[13],
    of_lazy_sexp = Base_Info[14],
    of_thunk = Base_Info[15],
    of_lazy_t = Base_Info[16],
    create = Base_Info[17],
    create_s = Base_Info[18],
    createf = Base_Info[19],
    tag = Base_Info[20],
    tag_s = Base_Info[21],
    tag_s_lazy = Base_Info[22],
    tag_arg = Base_Info[23],
    of_list = Base_Info[24],
    of_exn = Base_Info[25],
    to_exn = Base_Info[26],
    pp = Base_Info[27],
    Internal_repr = Base_Info[28];
   function raise(t){
    throw caml_maybe_attach_backtrace(caml_call1(to_exn, t), 1);
   }
   function raise_s(sexp){return raise(caml_call1(create_s, sexp));}
   function to_info(t){return t;}
   function of_info(t){return t;}
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    Base_Error =
      [0,
       compare,
       equal,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       to_string_hum,
       to_string_mach,
       to_string_hum_deprecated,
       of_string,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create,
       create_s,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       of_list,
       of_exn,
       to_exn,
       pp$0,
       Internal_repr,
       raise,
       raise_s,
       to_info,
       of_info];
   runtime.caml_register_global(4, Base_Error, "Base__Error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Invariant
//# unitInfo: Requires: Base__Error, Base__Field, Base__Import, Base__Invariant_intf, Base__Sexp, Base__Source_code_position0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_exn$1 = "exn",
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Base_Field = global_data.Base__Field,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Error = global_data.Base__Error,
    raise_s = Base_Error[30],
    cst_exn = cst_exn$1,
    cst_invariant_failed = "invariant failed",
    cst_exn$0 = cst_exn$1,
    cst_field = "field",
    cst_problem_with_field = "problem with field";
   function invariant(here, t, sexp_of_t, f){
    try{var _h_ = caml_call1(f, 0); return _h_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _e_ = [0, [0, cst, caml_call1(sexp_of_t, t)], 0],
      _f_ = [0, [0, cst_exn, caml_call1(Base_Import[198], exn)], _e_],
      _g_ =
        [0, [0, cst$0, caml_call1(Base_Source_code_position0[8], here)], _f_];
     return caml_call1
             (raise_s, caml_call2(Base_Sexp[9], cst_invariant_failed, _g_));
    }
   }
   function check_field(t, f, field){
    try{
     var _d_ = caml_call1(f, caml_call2(Base_Field[3], field, t));
     return _d_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _a_ = [0, [0, cst_exn$0, caml_call1(Base_Import[198], exn)], 0],
      _b_ = caml_call1(Base_Field[2], field),
      _c_ = [0, [0, cst_field, caml_call1(Base_Import[138], _b_)], _a_];
     return caml_call1
             (raise_s, caml_call2(Base_Sexp[9], cst_problem_with_field, _c_));
    }
   }
   var Base_Invariant = [0, invariant, check_field];
   runtime.caml_register_global(12, Base_Invariant, "Base__Invariant");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Or_error
//# unitInfo: Requires: Assert_failure, Base__Applicative, Base__Error, Base__Import, Base__List, Base__Printf, Base__Result, Base__With_return
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Base_Error = global_data.Base__Error,
    Base_With_return = global_data.Base__With_return,
    Assert_failure = global_data.Assert_failure,
    Base_Result = global_data.Base__Result,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Applicative = global_data.Base__Applicative,
    ignore_m = Base_Result[14],
    join = Base_Result[13],
    return$0 = Base_Result[12],
    bind = Base_Result[11],
    symbol_bind = Base_Result[7];
   function compare(cmp_a, a_001, b_002){
    return caml_call4(Base_Result[4], cmp_a, Base_Error[1], a_001, b_002);
   }
   function equal(cmp_a, a_007, b_008){
    return caml_call4(Base_Result[5], cmp_a, Base_Error[2], a_007, b_008);
   }
   function hash_fold_t(hash_fold_a, hsv, arg){
    return caml_call4(Base_Result[6], hash_fold_a, Base_Error[3], hsv, arg);
   }
   function t_of_sexp(of_a_013, x_015){
    return caml_call3(Base_Result[1], of_a_013, Base_Error[5], x_015);
   }
   function sexp_of_t(of_a_016, x_017){
    return caml_call3(Base_Result[2], of_a_016, Base_Error[6], x_017);
   }
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call2(Base_Result[3], a_sexp_grammar, Base_Error[7]);
   }
   function invariant(invariant_a, t){
    if(0 === t[0]){var a = t[1]; return caml_call1(invariant_a, a);}
    var error = t[1];
    return caml_call1(Base_Error[8], error);
   }
   function apply(f, x){
    return caml_call4
            (Base_Result[32],
             f,
             x,
             function(f, x){return caml_call1(f, x);},
             function(e1, e2){
              return caml_call2(Base_Error[24], 0, [0, e1, [0, e2, 0]]);
             });
   }
   var
    map = [0, -198771759, Base_Result[30]],
    include = caml_call1(Base_Applicative[5], [0, return$0, apply, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol$1 = include[6],
    symbol_map = include[7],
    apply$0 = include[8],
    map2 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13],
    include$0 = Base_Result[10],
    symbol_bind$0 = include$0[1],
    symbol_map$0 = include$0[2],
    Open_on_rhs = [0],
    ok = Base_Result[23],
    is_ok = Base_Result[21],
    is_error = Base_Result[22],
    _a_ = [0, 3553398],
    cst_unimplemented = "unimplemented",
    _b_ = [0, "src/or_error.ml", 135, 22];
   function try_with(opt, f){
    if(opt) var sth = opt[1], backtrace = sth; else var backtrace = 0;
    try{var _n_ = [0, caml_call1(f, 0)]; return _n_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), _m_ = backtrace ? _a_ : 0;
     return [1, caml_call2(Base_Error[25], _m_, exn)];
    }
   }
   function try_with_join(backtrace, f){
    return caml_call1(join, try_with(backtrace, f));
   }
   function ok_exn(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var err = param[1];
    return caml_call1(Base_Error[29], err);
   }
   function of_exn(backtrace, exn){
    return [1, caml_call2(Base_Error[25], backtrace, exn)];
   }
   function of_exn_result(backtrace, z){
    if(0 === z[0]) return z;
    var exn = z[1];
    return of_exn(backtrace, exn);
   }
   function error(here, strict, message, a, sexp_of_a){
    return [1,
            caml_call5(Base_Error[17], here, strict, message, a, sexp_of_a)];
   }
   function error_s(sexp){return [1, caml_call1(Base_Error[18], sexp)];}
   function error_string(message){
    return [1, caml_call1(Base_Error[12], message)];
   }
   function errorf(format){
    return caml_call2(Base_Printf[4], error_string, format);
   }
   function tag(t, tag){
    var _k_ = Base_Error[20];
    return caml_call2
            (Base_Result[31],
             t,
             function(_l_){return caml_call2(_k_, _l_, tag);});
   }
   function tag_s(t, tag){
    var _i_ = Base_Error[21];
    return caml_call2
            (Base_Result[31],
             t,
             function(_j_){return caml_call2(_i_, _j_, tag);});
   }
   function tag_s_lazy(t, tag){
    var _g_ = Base_Error[22];
    return caml_call2
            (Base_Result[31],
             t,
             function(_h_){return caml_call2(_g_, _h_, tag);});
   }
   function tag_arg(t, message, a, sexp_of_a){
    return caml_call2
            (Base_Result[31],
             t,
             function(e){
              return caml_call4(Base_Error[23], e, message, a, sexp_of_a);
             });
   }
   function unimplemented(s){
    return error(0, 0, cst_unimplemented, s, Base_Import[138]);
   }
   function combine_errors(l){
    var arg = Base_Error[24], _f_ = caml_call1(Base_Result[33], l);
    return caml_call2
            (Base_Result[31],
             _f_,
             function(eta){return caml_call2(arg, 0, eta);});
   }
   function combine_errors_unit(l){
    var _e_ = combine_errors(l);
    return caml_call2(Base_Result[30], _e_, function(param){return 0;});
   }
   function filter_ok_at_least_one(l){
    var
     match = caml_call2(Base_List[57], l, Base_Result[35]),
     errs = match[2],
     ok = match[1];
    return ok ? [0, ok] : [1, caml_call2(Base_Error[24], 0, errs)];
   }
   function find_ok(l){
    var match = caml_call2(Base_List[17], l, Base_Result[23]);
    if(match){var x = match[1]; return [0, x];}
    var
     _d_ =
       caml_call2
        (Base_List[76],
         l,
         function(param){
          if(0 === param[0])
           throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
          var err = param[1];
          return err;
         });
    return [1, caml_call2(Base_Error[24], 0, _d_)];
   }
   function find_map_ok(l, f){
    return caml_call1
            (Base_With_return[1],
             function(param){
              var
               _c_ =
                 caml_call2
                  (Base_List[76],
                   l,
                   function(elt){
                    var x = caml_call1(f, elt);
                    if(0 === x[0]) return caml_call1(param, x);
                    var err = x[1];
                    return err;
                   });
              return [1, caml_call2(Base_Error[24], 0, _c_)];
             });
   }
   var
    map$1 = Base_Result[30],
    iter = Base_Result[28],
    iter_error = Base_Result[29],
    Base_Or_error =
      [0,
       compare,
       equal,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply$0,
       map2,
       map3,
       Applicative_infix,
       invariant,
       symbol_bind,
       symbol_map,
       Base_Result[10],
       bind,
       return$1,
       join,
       ignore_m,
       all,
       all_unit,
       [0,
        return$1,
        symbol_bind$0,
        symbol_map$0,
        [0, return$1, bind, map$0, both, Open_on_rhs]],
       is_ok,
       is_error,
       try_with,
       try_with_join,
       ok,
       ok_exn,
       of_exn,
       of_exn_result,
       error,
       error_s,
       error_string,
       errorf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       unimplemented,
       map$1,
       iter,
       iter_error,
       combine_errors,
       combine_errors_unit,
       filter_ok_at_least_one,
       find_ok,
       find_map_ok];
   runtime.caml_register_global(11, Base_Or_error, "Base__Or_error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign0
//# unitInfo: Requires: Base__Hash, Base__Import, Base__Poly0, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Neg = "Neg",
    cst_Pos = "Pos",
    cst_Zero = "Zero",
    cst_neg = "neg",
    cst_pos = "pos",
    cst_zero = "zero",
    caml_int_compare = runtime.caml_int_compare;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "sign0.ml.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Neg, 0]],
         [0, [1, [0, cst_Zero, 0]], [0, [1, [0, cst_Pos, 0]], 0]]]]],
    all = [0, 0, [0, 1, [0, 2, 0]]],
    module_name = "Base.Sign",
    Base_Import = global_data.Base__Import,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    _a_ = [0, cst_Neg],
    _b_ = [0, cst_Zero],
    _c_ = [0, cst_Pos];
   function t_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var _e_ = sexp_004[1];
      b:
      if(_e_ !== cst_Neg){
       c:
       if(_e_ !== cst_Pos){
        if(_e_ !== cst_Zero){
         if(_e_ === cst_neg) break b;
         if(_e_ === cst_pos) break c;
         if(_e_ !== cst_zero) break a;
        }
        return 1;
       }
       return 2;
      }
      return 0;
     }
     var _f_ = sexp_004[1];
     if(! _f_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
     var _g_ = _f_[1];
     if(0 !== _g_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_003, sexp_004);
     var _h_ = _g_[1];
     b:
     if(_h_ !== cst_Neg){
      c:
      if(_h_ !== cst_Pos){
       if(_h_ !== cst_Zero){
        if(_h_ === cst_neg) break b;
        if(_h_ === cst_pos) break c;
        if(_h_ !== cst_zero) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_003, sexp_004);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   var compare = caml_int_compare;
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      default: return caml_call2(Base_Hash[3], hsv, 2);
    }
   }
   function symbol(x, y){return x < y ? 1 : 0;}
   function symbol$0(x, y){return x <= y ? 1 : 0;}
   function symbol$1(x, y){return x !== y ? 1 : 0;}
   function symbol$2(x, y){return x === y ? 1 : 0;}
   function symbol$3(x, y){return y < x ? 1 : 0;}
   function symbol$4(x, y){return y <= x ? 1 : 0;}
   function ascending(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare;
   function equal(x, y){return x === y ? 1 : 0;}
   function max(x, y){return y <= x ? x : y;}
   function min(x, y){return x <= y ? x : y;}
   var
    Replace_polymorphic_compare =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       ascending,
       descending,
       compare$0,
       equal,
       max,
       min];
   function of_string(s){return t_of_sexp(caml_call1(Base_Import[138], s));}
   function to_string(t){
    var _d_ = sexp_of_t(t);
    return caml_call1(Base_Import[162], _d_);
   }
   function to_int(param){
    switch(param){case 0: return -1;case 1: return 0;default: return 1;
    }
   }
   function of_int(n){return 0 <= n ? 0 === n ? 1 : 2 : 0;}
   var
    Base_Sign0 =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       hash_fold_t,
       all,
       Replace_polymorphic_compare,
       of_string,
       to_string,
       to_int,
       to_int,
       module_name,
       of_int];
   runtime.caml_register_global(23, Base_Sign0, "Base__Sign0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparable_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Comparable_intf = [0];
   runtime.caml_register_global
    (0, Base_Comparable_intf, "Base__Comparable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparable
//# unitInfo: Requires: Assert_failure, Base__Comparable_intf, Base__Comparator, Base__Or_error, Base__Poly0, Base__Sexp, Base__Sign0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_clamp_requires_min_max$1 = "clamp requires [min <= max]",
    cst_max$1 = "max",
    cst_min$1 = "min",
    cst_src_comparable_ml = "src/comparable.ml",
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Comparator = global_data.Base__Comparator,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Sign0 = global_data.Base__Sign0,
    _a_ = [0, cst_src_comparable_ml, 47, 4],
    cst_max = cst_max$1,
    cst_min = cst_min$1,
    cst_clamp_requires_min_max = cst_clamp_requires_min_max$1,
    _b_ = [0, cst_src_comparable_ml, 133, 4],
    cst_max$0 = cst_max$1,
    cst_min$0 = cst_min$1,
    cst_clamp_requires_min_max$0 = cst_clamp_requires_min_max$1;
   function geq(cmp, a, b){return 0 <= caml_call2(cmp, a, b) ? 1 : 0;}
   function leq(cmp, a, b){return caml_call2(cmp, a, b) <= 0 ? 1 : 0;}
   function equal(cmp, a, b){return 0 === caml_call2(cmp, a, b) ? 1 : 0;}
   function min(cmp, t$0, t){return leq(cmp, t$0, t) ? t$0 : t;}
   function max(cmp, t$0, t){return geq(cmp, t$0, t) ? t$0 : t;}
   function Infix(T){
    function symbol(a, b){
     var cmp = T[1];
     return 0 < caml_call2(cmp, a, b) ? 1 : 0;
    }
    function symbol$0(a, b){
     var cmp = T[1];
     return caml_call2(cmp, a, b) < 0 ? 1 : 0;
    }
    function symbol$1(a, b){return geq(T[1], a, b);}
    function symbol$2(a, b){return leq(T[1], a, b);}
    function symbol$3(a, b){return equal(T[1], a, b);}
    function symbol$4(a, b){
     var cmp = T[1];
     return 0 !== caml_call2(cmp, a, b) ? 1 : 0;
    }
    return [0, symbol$1, symbol$2, symbol$3, symbol, symbol$0, symbol$4];
   }
   function Polymorphic_compare(T){
    var
     include = Infix(T),
     symbol = include[1],
     symbol$0 = include[2],
     symbol$1 = include[3],
     symbol$2 = include[4],
     symbol$3 = include[5],
     symbol$4 = include[6],
     compare = T[1];
    function min$0(t$0, t){return min(compare, t$0, t);}
    function max$0(t$0, t){return max(compare, t$0, t);}
    return [0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            symbol$1,
            compare,
            min$0,
            max$0];
   }
   function Make_using_comparator(T){
    var
     sexp_of_t = T[1],
     comparator = T[2],
     compare = comparator[1],
     Replace_polymorphic_compare = Polymorphic_compare([0, compare]),
     symbol = Replace_polymorphic_compare[1],
     symbol$0 = Replace_polymorphic_compare[2],
     symbol$1 = Replace_polymorphic_compare[3],
     symbol$2 = Replace_polymorphic_compare[4],
     symbol$3 = Replace_polymorphic_compare[5],
     symbol$4 = Replace_polymorphic_compare[6],
     equal = Replace_polymorphic_compare[7],
     compare$0 = Replace_polymorphic_compare[8],
     min = Replace_polymorphic_compare[9],
     max = Replace_polymorphic_compare[10];
    function descending(t$0, t){return caml_call2(compare$0, t, t$0);}
    function between(t, low, high){
     var _r_ = caml_call2(symbol$0, low, t);
     return _r_ ? caml_call2(symbol$0, t, high) : _r_;
    }
    function clamp_unchecked(t, min, max){
     return caml_call2(symbol$3, t, min)
             ? min
             : caml_call2(symbol$0, t, max) ? t : max;
    }
    function clamp_exn(t, min, max){
     if(caml_call2(symbol$0, min, max)) return clamp_unchecked(t, min, max);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    }
    function clamp(t, min, max){
     if(! caml_call2(symbol$2, min, max))
      return [0, clamp_unchecked(t, min, max)];
     var
      _o_ = [0, [0, cst_max$0, caml_call1(sexp_of_t, max)], 0],
      _p_ = [0, [0, cst_min$0, caml_call1(sexp_of_t, min)], _o_],
      _q_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max$0, _p_);
     return caml_call1(Base_Or_error[35], _q_);
    }
    return [0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            equal,
            compare$0,
            min,
            max,
            compare$0,
            descending,
            between,
            clamp_exn,
            clamp,
            comparator];
   }
   function Make(T){
    var
     sexp_of_t = T[2],
     include = caml_call1(Base_Comparator[5], T),
     comparator = include[1];
    return Make_using_comparator([0, sexp_of_t, comparator]);
   }
   function Inherit(C, T){
    var sexp_of_t = T[1];
    function compare(t$0, t){
     var _m_ = caml_call1(T[2], t), _n_ = caml_call1(T[2], t$0);
     return caml_call2(C[1], _n_, _m_);
    }
    return Make([0, compare, sexp_of_t]);
   }
   function lexicographic(cmps, x, y){
    var param = cmps;
    for(;;){
     if(! param) return 0;
     var cmps$0 = param[2], cmp = param[1], res = caml_call2(cmp, x, y);
     if(0 !== res) return res;
     param = cmps$0;
    }
   }
   function lift(cmp, f, x, y){
    var _l_ = caml_call1(f, y);
    return caml_call2(cmp, caml_call1(f, x), _l_);
   }
   function reverse(cmp, x, y){return caml_call2(cmp, y, x);}
   var
    Base_Comparable =
      [0,
       lexicographic,
       lift,
       reverse,
       equal,
       max,
       min,
       Infix,
       Polymorphic_compare,
       Inherit,
       Make,
       Make_using_comparator,
       function(T){
        var
         sexp_of_t = T[1],
         ascending = Base_Poly0[1],
         descending = Base_Poly0[2],
         min = Base_Poly0[3],
         max = Base_Poly0[4];
        function between(t, low, high){
         var
          _j_ = caml_lessequal(low, t),
          _k_ = _j_ ? caml_lessequal(t, high) : _j_;
         return _k_;
        }
        function clamp_unchecked(t, min, max){
         return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
        }
        function clamp_exn(t, min, max){
         if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
         throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
        }
        function clamp(t, min, max){
         if(! caml_greaterthan(min, max))
          return [0, clamp_unchecked(t, min, max)];
         var
          _g_ = [0, [0, cst_max, caml_call1(T[1], max)], 0],
          _h_ = [0, [0, cst_min, caml_call1(T[1], min)], _g_],
          _i_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _h_);
         return caml_call1(Base_Or_error[35], _i_);
        }
        var
         include =
           caml_call1(Base_Comparator[5], [0, caml_compare, sexp_of_t]),
         comparator = include[1];
        return [0,
                runtime.caml_greaterequal,
                caml_lessequal,
                caml_equal,
                caml_greaterthan,
                caml_lessthan,
                runtime.caml_notequal,
                caml_equal,
                caml_compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator];
       },
       function(_c_){
        var _d_ = _c_[3], _e_ = _c_[1];
        function is_positive(t){return 0 < caml_call2(_e_, t, _d_) ? 1 : 0;}
        function is_non_negative(t){
         return 0 <= caml_call2(_e_, t, _d_) ? 1 : 0;
        }
        function is_negative(t){return caml_call2(_e_, t, _d_) < 0 ? 1 : 0;}
        function is_non_positive(t){
         return caml_call2(_e_, t, _d_) <= 0 ? 1 : 0;
        }
        function sign(t){
         var _f_ = caml_call2(_e_, t, _d_);
         return caml_call1(Base_Sign0[13], _f_);
        }
        return [0,
                is_positive,
                is_non_negative,
                is_negative,
                is_non_positive,
                sign];
       }];
   runtime.caml_register_global(14, Base_Comparable, "Base__Comparable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashable_intf
//# unitInfo: Requires: Base__Import, Stdlib__MoreLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels;
   function equal(a, b){
    var _b_ = caml_call2(Base_Import[127], a, b);
    if(_b_)
     var _c_ = _b_;
    else{
     var _d_ = caml_call2(Base_Import[127], a[1], b[1]);
     if(_d_){
      var _e_ = caml_call2(Base_Import[127], a[2], b[2]);
      if(_e_) return caml_call2(Base_Import[127], a[3], b[3]);
      var _c_ = _e_;
     }
     else
      var _c_ = _d_;
    }
    return _c_;
   }
   var
    hash_param = Stdlib_MoreLabels[1][30],
    hash = Stdlib_MoreLabels[1][28],
    _a_ = [0, "_"],
    poly = [0, hash, runtime.caml_compare, function(param){return _a_;}];
   function of_key(Key){return [0, Key[3], Key[1], Key[2]];}
   function to_key(param){
    var sexp_of_t = param[3], compare = param[2], hash = param[1];
    return [0, compare, sexp_of_t, hash];
   }
   var
    Hashable = [0, equal, hash_param, hash, poly, of_key, to_key],
    equal$0 = Hashable[1],
    hash_param$0 = Hashable[2],
    hash$0 = Hashable[3],
    poly$0 = Hashable[4],
    of_key$0 = Hashable[5],
    to_key$0 = Hashable[6],
    Base_Hashable_intf =
      [0, Hashable, equal$0, hash_param$0, hash$0, poly$0, of_key$0, to_key$0];
   runtime.caml_register_global(3, Base_Hashable_intf, "Base__Hashable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashable
//# unitInfo: Requires: Base__Hashable_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Hashable_intf = global_data.Base__Hashable_intf,
    equal = Base_Hashable_intf[2],
    hash_param = Base_Hashable_intf[3],
    hash = Base_Hashable_intf[4],
    poly = Base_Hashable_intf[5],
    of_key = Base_Hashable_intf[6],
    to_key = Base_Hashable_intf[7],
    Base_Hashable = [0, equal, poly, of_key, to_key, hash_param, hash];
   runtime.caml_register_global(1, Base_Hashable, "Base__Hashable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stringable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Stringable = [0];
   runtime.caml_register_global(0, Base_Stringable, "Base__Stringable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Identifiable_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Identifiable_intf = [0];
   runtime.caml_register_global
    (0, Base_Identifiable_intf, "Base__Identifiable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Identifiable
//# unitInfo: Requires: Base__Comparable, Base__Identifiable_intf, Base__Pretty_printer
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Identifiable =
      [0,
       function(T){
        var
         hash_fold_t = T[2],
         hash = T[3],
         t_of_sexp = T[4],
         sexp_of_t = T[5],
         of_string = T[6],
         to_string = T[7],
         _b_ = caml_call1(Base_Comparable[10], [0, T[1], T[5]]),
         symbol = _b_[1],
         symbol$0 = _b_[2],
         symbol$1 = _b_[3],
         symbol$2 = _b_[4],
         symbol$3 = _b_[5],
         symbol$4 = _b_[6],
         equal = _b_[7],
         compare = _b_[8],
         min = _b_[9],
         max = _b_[10],
         ascending = _b_[11],
         descending = _b_[12],
         between = _b_[13],
         clamp_exn = _b_[14],
         clamp = _b_[15],
         comparator = _b_[16],
         include = caml_call1(Base_Pretty_printer[2], [0, T[8], T[7]]),
         pp = include[1],
         hashable = [0, hash, compare, sexp_of_t];
        return [0,
                hash_fold_t,
                hash,
                t_of_sexp,
                sexp_of_t,
                of_string,
                to_string,
                symbol,
                symbol$0,
                symbol$1,
                symbol$2,
                symbol$3,
                symbol$4,
                equal,
                compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator,
                pp,
                hashable];
       },
       function(T){
        var
         hash_fold_t = T[2],
         hash = T[3],
         t_of_sexp = T[4],
         sexp_of_t = T[5],
         of_string = T[6],
         to_string = T[7],
         _a_ = caml_call1(Base_Comparable[11], [0, T[5], T[9]]),
         symbol = _a_[1],
         symbol$0 = _a_[2],
         symbol$1 = _a_[3],
         symbol$2 = _a_[4],
         symbol$3 = _a_[5],
         symbol$4 = _a_[6],
         equal = _a_[7],
         compare = _a_[8],
         min = _a_[9],
         max = _a_[10],
         ascending = _a_[11],
         descending = _a_[12],
         between = _a_[13],
         clamp_exn = _a_[14],
         clamp = _a_[15],
         comparator = _a_[16],
         include = caml_call1(Base_Pretty_printer[2], [0, T[8], T[7]]),
         pp = include[1],
         hashable = [0, hash, compare, sexp_of_t];
        return [0,
                hash_fold_t,
                hash,
                t_of_sexp,
                sexp_of_t,
                of_string,
                to_string,
                symbol,
                symbol$0,
                symbol$1,
                symbol$2,
                symbol$3,
                symbol$4,
                equal,
                compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator,
                pp,
                hashable];
       }];
   runtime.caml_register_global(2, Base_Identifiable, "Base__Identifiable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Unit
//# unitInfo: Requires: Base__Identifiable, Base__Import
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$0 = "()";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    all = [0, 0, 0],
    module_name = "Base.Unit",
    Base_Import = global_data.Base__Import,
    Base_Identifiable = global_data.Base__Identifiable,
    hash_fold_t = Base_Import[210],
    func = Base_Import[224];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[160],
    sexp_of_t = Base_Import[136],
    t_sexp_grammar = Base_Import[180],
    cst_Base_Unit_of_string_expect = "Base.Unit.of_string: () expected";
   function compare(param, _a_){return 0;}
   function of_string(param){
    return param !== cst$0
            ? caml_call1(Base_Import[123], cst_Base_Unit_of_string_expect)
            : 0;
   }
   function to_string(param){return cst;}
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = include[1],
    hash$0 = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t$0 = include[4],
    of_string$0 = include[5],
    to_string$0 = include[6],
    symbol = include[7],
    symbol$0 = include[8],
    symbol$1 = include[9],
    symbol$2 = include[10],
    symbol$3 = include[11],
    symbol$4 = include[12],
    equal = include[13],
    compare$0 = include[14],
    min = include[15],
    max = include[16],
    ascending = include[17],
    descending = include[18],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    pp = include[23],
    hashable = include[24];
   function invariant(param){return 0;}
   var
    Base_Unit =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       invariant];
   runtime.caml_register_global(7, Base_Unit, "Base__Unit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordered_collection_common
//# unitInfo: Requires: Base__Or_error, Base__Ordered_collection_common0, Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Base_Or_error = global_data.Base__Or_error,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common0,
    get_pos_len_exn = Base_Ordered_collection_common[1],
    check_pos_len_exn = Base_Ordered_collection_common[2],
    Private = Base_Ordered_collection_common[3];
   function get_pos_len(pos, len, param, total_length){
    try{
     var _a_ = [0, caml_call4(get_pos_len_exn, pos, len, 0, total_length)];
     return _a_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var s = exn[2];
     return caml_call1(Base_Or_error[36], s);
    }
   }
   var
    Base_Ordered_collection_common$0 =
      [0, get_pos_len_exn, check_pos_len_exn, Private, get_pos_len];
   runtime.caml_register_global
    (3, Base_Ordered_collection_common$0, "Base__Ordered_collection_common");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_search
//# unitInfo: Requires: Base__Fn, Base__Import, Base__Ordered_collection_common
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Fn = global_data.Base__Fn;
   function find_first_satisfying(pos, len, t, get, length, pred){
    var
     _e_ = caml_call1(length, t),
     match = caml_call4(Base_Ordered_collection_common[1], pos, len, 0, _e_),
     len$0 = match[2],
     pos$0 = match[1],
     _f_ = caml_call2(Base_Import[90], pos$0, len$0),
     hi$0 = caml_call2(Base_Import[92], _f_, 1),
     lo$1 = pos$0,
     hi = hi$0;
    for(;;){
     if(8 >= caml_call2(Base_Import[92], hi, lo$1)) break;
     var
      _c_ = caml_call2(Base_Import[92], hi, lo$1),
      _d_ = caml_call2(Base_Import[94], _c_, 2),
      mid = caml_call2(Base_Import[90], lo$1, _d_);
     if(caml_call1(pred, caml_call2(get, t, mid)))
      hi = mid;
     else{var lo$2 = caml_call2(Base_Import[90], mid, 1); lo$1 = lo$2;}
    }
    var lo = lo$1;
    for(;;){
     if(hi < lo) return 0;
     if(caml_call1(pred, caml_call2(get, t, lo))) return [0, lo];
     var lo$0 = caml_call2(Base_Import[90], lo, 1);
     lo = lo$0;
    }
   }
   function find_last_satisfying(pos, len, t, pred, get, length){
    var
     _a_ = caml_call1(length, t),
     match = caml_call4(Base_Ordered_collection_common[1], pos, len, 0, _a_),
     len$0 = match[2],
     pos$0 = match[1];
    if(0 === len$0) return 0;
    var
     match$0 =
       find_first_satisfying
        ([0, pos$0], [0, len$0], t, get, length, caml_call1(Base_Fn[2], pred));
    if(match$0){
     var i = match$0[1];
     return i === pos$0 ? 0 : [0, caml_call2(Base_Import[92], i, 1)];
    }
    var _b_ = caml_call2(Base_Import[90], pos$0, len$0);
    return [0, caml_call2(Base_Import[92], _b_, 1)];
   }
   function binary_search(pos, len, t, length, get, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (pos,
                  len,
                  t,
                  get,
                  length,
                  function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;})
               : find_last_satisfying
                 (pos,
                  len,
                  t,
                  function(x){return caml_call2(compare, x, v) < 0 ? 1 : 0;},
                  get,
                  length)
             : -253007807
               <= how
               ? find_last_satisfying
                 (pos,
                  len,
                  t,
                  function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;},
                  get,
                  length)
               : find_first_satisfying
                 (pos,
                  len,
                  t,
                  get,
                  length,
                  function(x){return 0 < caml_call2(compare, x, v) ? 1 : 0;});
    if(-1055410545 <= how){
     var
      match =
        find_last_satisfying
         (pos,
          len,
          t,
          function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;},
          get,
          length);
     if(match){
      var x = match[1];
      if(0 === caml_call2(compare, caml_call2(get, t, x), v)) return [0, x];
     }
     return 0;
    }
    var
     match$0 =
       find_first_satisfying
        (pos,
         len,
         t,
         get,
         length,
         function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;});
    if(match$0){
     var x$0 = match$0[1];
     if(0 === caml_call2(compare, caml_call2(get, t, x$0), v))
      return [0, x$0];
    }
    return 0;
   }
   function binary_search_segmented(pos, len, t, length, get, segment_of, how){
    function is_left(x){
     return 847852583 <= caml_call1(segment_of, x) ? 1 : 0;
    }
    function is_right(x){return 1 - is_left(x);}
    return 125585502 <= how
            ? find_last_satisfying(pos, len, t, is_left, get, length)
            : find_first_satisfying(pos, len, t, get, length, is_right);
   }
   var Base_Binary_search = [0, binary_search, binary_search_segmented];
   runtime.caml_register_global(3, Base_Binary_search, "Base__Binary_search");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_searchable_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    all =
      [0,
       200870407,
       [0,
        -253007807,
        [0, -1055410545, [0, -1056898635, [0, 926943384, [0, -839473056, 0]]]]]],
    all$0 = [0, 125585502, [0, -63348021, 0]],
    Which_target_by_key = [0, all],
    Which_target_by_segment = [0, all$0],
    Base_Binary_searchable_intf =
      [0, Which_target_by_key, Which_target_by_segment];
   runtime.caml_register_global
    (2, Base_Binary_searchable_intf, "Base__Binary_searchable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_searchable
//# unitInfo: Requires: Base__Binary_search, Base__Binary_searchable_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Binary_search = global_data.Base__Binary_search;
   function Make_gen(T){
    var get = T[1], length = T[2];
    function binary_search(pos, len, t, compare, how, v){
     return caml_call8
             (Base_Binary_search[1],
              pos,
              len,
              t,
              length,
              get,
              compare,
              how,
              v);
    }
    function binary_search_segmented(pos, len, t, segment_of, how){
     return caml_call7
             (Base_Binary_search[2],
              pos,
              len,
              t,
              length,
              get,
              segment_of,
              how);
    }
    return [0, , , binary_search, binary_search_segmented];
   }
   var
    Base_Binary_searchable =
      [0,
       function(T){
        var get = T[1], length = T[2], _b_ = Make_gen([0, get, length]);
        return [0, _b_[3], _b_[4]];
       },
       function(T){
        var get = T[1], length = T[2], _a_ = Make_gen([0, get, length]);
        return [0, _a_[3], _a_[4]];
       }];
   runtime.caml_register_global
    (1, Base_Binary_searchable, "Base__Binary_searchable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Blit_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Blit_intf = [0];
   runtime.caml_register_global(0, Base_Blit_intf, "Base__Blit_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Blit
//# unitInfo: Requires: Base__Blit_intf, Base__Bytes0, Base__Import, Base__Ordered_collection_common
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common;
   function Make_gen(Src, Dst){
    var unsafe_blit = Dst[3];
    function blit(src, src_pos, dst, dst_pos, len){
     var _n_ = caml_call1(Src[1], src);
     caml_call3(Base_Ordered_collection_common[2], src_pos, len, _n_);
     var _o_ = caml_call1(Dst[1], dst);
     caml_call3(Base_Ordered_collection_common[2], dst_pos, len, _o_);
     var _p_ = 0 < len ? 1 : 0;
     return _p_
             ? caml_call5(unsafe_blit, src, src_pos, dst, dst_pos, len)
             : _p_;
    }
    function blito(src, opt, _l_, dst, _k_, param){
     if(opt) var sth = opt[1], src_pos = sth; else var src_pos = 0;
     if(_l_)
      var sth$0 = _l_[1], src_len = sth$0;
     else
      var
       _m_ = caml_call1(Src[1], src),
       src_len = caml_call2(Base_Import[92], _m_, src_pos);
     if(_k_) var sth$1 = _k_[1], dst_pos = sth$1; else var dst_pos = 0;
     return blit(src, src_pos, dst, dst_pos, src_len);
    }
    function sub(src, pos, len){
     var _j_ = caml_call1(Src[1], src);
     caml_call3(Base_Ordered_collection_common[2], pos, len, _j_);
     var dst = caml_call2(Dst[2], len, src);
     if(0 < len) caml_call5(unsafe_blit, src, pos, dst, 0, len);
     return dst;
    }
    function subo(opt, len, src){
     if(opt) var sth = opt[1], pos = sth; else var pos = 0;
     if(len)
      var i = len[1], i$0 = i;
     else
      var
       _i_ = caml_call1(Src[1], src),
       i$0 = caml_call2(Base_Import[92], _i_, pos);
     return sub(src, pos, i$0);
    }
    return [0, unsafe_blit, blit, blito, sub, subo];
   }
   function Make_to_string(T, To_bytes){
    function sub(src, pos, len){
     var _h_ = caml_call3(To_bytes[4], src, pos, len);
     return caml_call1(Base_Bytes0[16], _h_);
    }
    function subo(pos, len, src){
     var _g_ = caml_call3(To_bytes[5], pos, len, src);
     return caml_call1(Base_Bytes0[16], _g_);
    }
    return [0, sub, subo];
   }
   var
    Base_Blit =
      [0,
       function(Sequence){
        function create_like(len, param){return caml_call1(Sequence[2], len);}
        var
         length = Sequence[1],
         unsafe_blit = Sequence[3],
         include =
           Make_gen([0, length], [0, length, create_like, unsafe_blit]),
         unsafe_blit$0 = include[1],
         blit = include[2],
         blito = include[3],
         sub = include[4],
         subo = include[5];
        return [0, blit, blito, unsafe_blit$0, sub, subo];
       },
       function(Src, Dst){
        var length = Dst[1];
        function create_like(len, param){return caml_call1(Dst[2], len);}
        var
         unsafe_blit = Dst[3],
         length$0 = Src[1],
         _f_ = Make_gen([0, length$0], [0, length, create_like, unsafe_blit]);
        return [0, _f_[2], _f_[3], _f_[1], _f_[4], _f_[5]];
       },
       Make_to_string,
       function(_c_){
        var
         _d_ = [0, _c_[2], _c_[1], _c_[3]],
         _e_ = Make_gen([0, _d_[1]], _d_);
        return [0, _e_[2], _e_[3], _e_[1], _e_[4], _e_[5]];
       },
       function(_a_){
        var _b_ = Make_gen([0, _a_[2]], [0, _a_[2], _a_[1], _a_[3]]);
        return [0, _b_[2], _b_[3], _b_[1], _b_[4], _b_[5]];
       }];
   runtime.caml_register_global(3, Base_Blit, "Base__Blit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Either_intf = [0];
   runtime.caml_register_global(0, Base_Either_intf, "Base__Either_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Option
//# unitInfo: Requires: Base__Applicative, Base__Container, Base__Error, Base__Import, Base__Monad, Base__Source_code_position0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Container = global_data.Base__Container,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Error = global_data.Base__Error,
    Base_Import = global_data.Base__Import,
    Base_Monad = global_data.Base__Monad,
    Base_Applicative = global_data.Base__Applicative,
    compare = Base_Import[236],
    hash_fold_t = Base_Import[211],
    t_of_sexp = Base_Import[172],
    sexp_of_t = Base_Import[148],
    cst_Option_value_exn = "Option.value_exn",
    cst_Option_value_exn_None = "Option.value_exn None";
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[193], a_sexp_grammar);
   }
   function is_none(param){return param ? 0 : 1;}
   function is_some(param){return param ? 1 : 0;}
   function value_map(o, default$0, f){
    if(! o) return default$0;
    var x = o[1];
    return caml_call1(f, x);
   }
   function iter(o, f){
    if(! o) return 0;
    var a = o[1];
    return caml_call1(f, a);
   }
   function invariant(f, t){return iter(t, f);}
   function call(x, f){
    if(! f) return 0;
    var f$0 = f[1];
    return caml_call1(f$0, x);
   }
   function value(t, default$0){
    if(! t) return default$0;
    var x = t[1];
    return x;
   }
   function value_exn(here, error, message, t){
    if(t){var x = t[1]; return x;}
    if(here){
     var p = here[1];
     if(error)
      var
       e = error[1],
       _g_ =
         caml_call2
          (Base_Import[149], Base_Error[6], Base_Source_code_position0[8]),
       _h_ = value(message, cst),
       _i_ = caml_call5(Base_Error[17], 0, 0, _h_, [0, e, p], _g_);
     else if(message)
      var
       m = message[1],
       _i_ =
         caml_call5(Base_Error[17], 0, 0, m, p, Base_Source_code_position0[8]);
     else
      var
       _i_ =
         caml_call5
          (Base_Error[17],
           0,
           0,
           cst_Option_value_exn,
           p,
           Base_Source_code_position0[8]);
     var error$0 = _i_;
    }
    else if(error){
     var e$0 = error[1];
     if(message)
      var m$0 = message[1], _j_ = caml_call2(Base_Error[20], e$0, m$0);
     else
      var _j_ = e$0;
     var error$0 = _j_;
    }
    else if(message)
     var m$1 = message[1], error$0 = caml_call1(Base_Error[12], m$1);
    else
     var error$0 = caml_call1(Base_Error[12], cst_Option_value_exn_None);
    return caml_call1(Base_Error[29], error$0);
   }
   function value_or_thunk(o, default$0){
    if(! o) return caml_call1(default$0, 0);
    var x = o[1];
    return x;
   }
   function to_array(t){if(! t) return [0]; var x = t[1]; return [0, x];}
   function to_list(t){if(! t) return 0; var x = t[1]; return [0, x, 0];}
   function min_elt(t, param){return t;}
   function max_elt(t, param){return t;}
   function sum(M){return function(t, f){return value_map(t, M[1], f);};}
   function for_all(t, f){
    if(! t) return 1;
    var x = t[1];
    return caml_call1(f, x);
   }
   function exists(t, f){
    if(! t) return 0;
    var x = t[1];
    return caml_call1(f, x);
   }
   function mem(t, a, equal){
    if(! t) return 0;
    var a$0 = t[1];
    return caml_call2(equal, a, a$0);
   }
   function length(t){return t ? 1 : 0;}
   function fold(t, init, f){
    if(! t) return init;
    var x = t[1];
    return caml_call2(f, init, x);
   }
   function count(t, f){
    if(! t) return 0;
    var a = t[1];
    return caml_call1(f, a) ? 1 : 0;
   }
   function find(t, f){
    if(! t) return 0;
    var x = t[1];
    return caml_call1(f, x) ? t : 0;
   }
   function find_map(t, f){
    if(! t) return 0;
    var a = t[1];
    return caml_call1(f, a);
   }
   function equal(f, t$0, t){
    if(t$0){
     if(t){var x = t[1], x$0 = t$0[1]; return caml_call2(f, x$0, x);}
    }
    else if(! t) return 1;
    return 0;
   }
   function some(x){return [0, x];}
   function first_some(x, y){return x ? x : y;}
   function some_if(cond, x){return cond ? [0, x] : 0;}
   function merge(a, b, f){
    if(a){
     if(b){var b$0 = b[1], a$0 = a[1]; return [0, caml_call2(f, a$0, b$0)];}
     var x = a;
    }
    else
     var x = b;
    return x;
   }
   function filter(t, f){
    if(t){var v = t[1]; if(caml_call1(f, v)) return t;}
    return 0;
   }
   function try_with(f){
    try{var x = caml_call1(f, 0);}catch(_f_){return 0;}
    return [0, x];
   }
   function try_with_join(f){
    try{var x = caml_call1(f, 0); return x;}catch(_e_){return 0;}
   }
   function _a_(t, f){
    if(! t) return 0;
    var a = t[1];
    return [0, caml_call1(f, a)];
   }
   function apply(f, x){if(! f) return 0; var f$0 = f[1]; return _a_(x, f$0);}
   function return$0(x){return [0, x];}
   var map = [0, -198771759, _a_];
   function bind(o, f){
    if(! o) return 0;
    var x = o[1];
    return caml_call1(f, x);
   }
   var
    _b_ = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = _b_[1],
    Monad_infix = _b_[3],
    bind$0 = _b_[4],
    join = _b_[7],
    ignore_m = _b_[8],
    Let_syntax = _b_[11],
    include = caml_call1(Base_Applicative[5], [0, return$0, apply, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol$1 = include[6],
    symbol_map = include[7],
    apply$0 = include[8],
    map2 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13];
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f){
    var _c_ = caml_call3(Base_Container[9], fold, init, f);
    return function(_d_){return caml_call2(_c_, _d_, t);};
   }
   var
    Base_Option =
      [0,
       compare,
       hash_fold_t,
       t_sexp_grammar,
       equal,
       invariant,
       t_of_sexp,
       sexp_of_t,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply$0,
       map2,
       map3,
       Applicative_infix,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       value,
       value_exn,
       value_map,
       value_or_thunk,
       fold,
       mem,
       length,
       iter,
       exists,
       for_all,
       find,
       find_map,
       to_list,
       to_array,
       call,
       merge,
       filter,
       try_with,
       try_with_join,
       some,
       first_some,
       some_if,
       is_none,
       is_some,
       is_none,
       fold_result,
       fold_until,
       min_elt,
       max_elt,
       count,
       sum];
   runtime.caml_register_global(9, Base_Option, "Base__Option");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexpable
//# unitInfo: Requires: Base__Import, Sexplib0__Sexpable
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    cst_Sexpable_Of_stringable_t_o =
      "Sexpable.Of_stringable.t_of_sexp expected an atom, but got a list";
   function Of_sexpable(Sexpable, M){
    function t_of_sexp(sexp){
     var s = caml_call1(Sexpable[1], sexp);
     try{var _i_ = caml_call1(M[2], s); return _i_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[159], exn, sexp);
     }
    }
    function sexp_of_t(t){
     var _h_ = caml_call1(M[1], t);
     return caml_call1(Sexpable[2], _h_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable1(Sexpable, M){
    function t_of_sexp(a_of_sexp, sexp){
     var s = caml_call2(Sexpable[1], a_of_sexp, sexp);
     try{var _g_ = caml_call1(M[2], s); return _g_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[159], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, t){
     var _f_ = caml_call1(M[1], t);
     return caml_call2(Sexpable[2], sexp_of_a, _f_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable2(Sexpable, M){
    function t_of_sexp(a_of_sexp, b_of_sexp, sexp){
     var s = caml_call3(Sexpable[1], a_of_sexp, b_of_sexp, sexp);
     try{var _e_ = caml_call1(M[2], s); return _e_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[159], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, sexp_of_b, t){
     var _d_ = caml_call1(M[1], t);
     return caml_call3(Sexpable[2], sexp_of_a, sexp_of_b, _d_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable3(Sexpable, M){
    function t_of_sexp(a_of_sexp, b_of_sexp, c_of_sexp, sexp){
     var s = caml_call4(Sexpable[1], a_of_sexp, b_of_sexp, c_of_sexp, sexp);
     try{var _c_ = caml_call1(M[2], s); return _c_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[159], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, sexp_of_b, sexp_of_c, t){
     var _b_ = caml_call1(M[1], t);
     return caml_call4(Sexpable[2], sexp_of_a, sexp_of_b, sexp_of_c, _b_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_stringable(M){
    function t_of_sexp(sexp){
     if(0 !== sexp[0])
      return caml_call2
              (Base_Import[158], cst_Sexpable_Of_stringable_t_o, sexp);
     var s = sexp[1];
     try{var _a_ = caml_call1(M[1], s); return _a_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[159], exn, sexp);
     }
    }
    function sexp_of_t(t){return [0, caml_call1(M[2], t)];}
    return [0, t_of_sexp, sexp_of_t];
   }
   var
    Base_Sexpable =
      [0,
       Of_sexpable,
       Of_sexpable1,
       Of_sexpable2,
       Of_sexpable3,
       Of_stringable];
   runtime.caml_register_global(2, Base_Sexpable, "Base__Sexpable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either
//# unitInfo: Requires: Base__Applicative, Base__Either0, Base__Either_intf, Base__List0, Base__Monad, Base__Option, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_With_return = global_data.Base__With_return,
    Base_Option = global_data.Base__Option,
    Base_List0 = global_data.Base__List0,
    Base_Monad = global_data.Base__Monad,
    Base_Applicative = global_data.Base__Applicative,
    Base_Either0 = global_data.Base__Either0,
    compare = Base_Either0[1],
    hash_fold_t = Base_Either0[2],
    t_of_sexp = Base_Either0[3],
    sexp_of_t = Base_Either0[4],
    t_sexp_grammar = Base_Either0[5];
   function swap(param){
    if(0 === param[0]){var x = param[1]; return [1, x];}
    var x$0 = param[1];
    return [0, x$0];
   }
   function is_first(param){return 0 === param[0] ? 1 : 0;}
   function is_second(param){return 0 === param[0] ? 0 : 1;}
   function value(param){var x = param[1]; return x;}
   function value_map(t, first, second){
    if(0 === t[0]){var x = t[1]; return caml_call1(first, x);}
    var x$0 = t[1];
    return caml_call1(second, x$0);
   }
   function map(t, first, second){
    if(0 === t[0]){var x = t[1]; return [0, caml_call1(first, x)];}
    var x$0 = t[1];
    return [1, caml_call1(second, x$0)];
   }
   function first(x){return [0, x];}
   function second(x){return [1, x];}
   function equal(eq1, eq2, t1, t2){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return caml_call2(eq1, x, y);}
    }
    else{
     var x$0 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return caml_call2(eq2, x$0, y$0);}
    }
    return 0;
   }
   function invariant(f, s, param){
    if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
    var y = param[1];
    return caml_call1(s, y);
   }
   function Make_focused(M){
    var
     return$0 = M[1],
     other = M[2],
     either = M[3],
     combine = M[4],
     bind = M[5],
     map =
       [0,
        -198771759,
        function(t, f){
         return caml_call2
                 (bind,
                  t,
                  function(x){return caml_call1(return$0, caml_call1(f, x));});
        }],
     include = caml_call1(Base_Monad[2], [0, bind, map, return$0]),
     symbol_bind = include[1],
     Let_syntax = include[3],
     Monad_infix = include[4],
     bind$0 = include[5],
     return$1 = include[6],
     join = include[8],
     ignore_m = include[9];
    function apply(t1, t2){
     return caml_call2
             (bind$0,
              t1,
              function(f){
               return caml_call2
                       (bind$0,
                        t2,
                        function(x){return caml_call1(return$1, caml_call1(f, x));});
              });
    }
    var
     map$0 = [0, -198771759, include[7]],
     App = caml_call1(Base_Applicative[6], [0, return$1, apply, map$0]),
     return$2 = App[1],
     map$1 = App[2],
     both = App[3],
     symbol = App[4],
     symbol$0 = App[5],
     symbol$1 = App[6],
     symbol_map = App[7],
     apply$0 = App[8],
     map2 = App[9],
     map3 = App[10],
     all = App[11],
     all_unit = App[12],
     Applicative_infix = App[13];
    function other_loop(f, acc, param){
     if(! param) return caml_call1(other, acc);
     var ts = param[2], t = param[1];
     return caml_call3
             (either,
              t,
              function(param){return other_loop(f, acc, ts);},
              function(o){return other_loop(f, caml_call2(f, acc, o), ts);});
    }
    function return_loop(f, acc, param){
     if(! param) return caml_call1(return$2, caml_call1(Base_List0[21], acc));
     var ts = param[2], t = param[1];
     return caml_call3
             (either,
              t,
              function(x){return return_loop(f, [0, x, acc], ts);},
              function(o){return other_loop(f, o, ts);});
    }
    function combine_all(ts, f){return return_loop(f, 0, ts);}
    function other_loop$0(f, acc, param){
     if(! param) return caml_call1(other, acc);
     var ts = param[2], t = param[1];
     return caml_call3
             (either,
              t,
              function(param){return other_loop$0(f, acc, ts);},
              function(o){return other_loop$0(f, caml_call2(f, acc, o), ts);});
    }
    function return_loop$0(f, param){
     if(! param) return caml_call1(return$2, 0);
     var ts = param[2], t = param[1];
     return caml_call3
             (either,
              t,
              function(param){return return_loop$0(f, ts);},
              function(o){return other_loop$0(f, o, ts);});
    }
    function combine_all_unit(ts, f){return return_loop$0(f, ts);}
    function to_option(t){
     return caml_call3(either, t, Base_Option[46], function(param){return 0;});
    }
    function value(t, default$0){
     return caml_call3
             (either,
              t,
              function(_a_){return _a_;},
              function(param){return default$0;});
    }
    function with_return(f){
     return caml_call1
             (Base_With_return[1],
              function(ret){
               return caml_call1
                       (other,
                        caml_call1
                         (f, caml_call2(Base_With_return[3], ret, return$2)));
              });
    }
    return [0,
            ,
            ,
            combine,
            symbol_bind,
            Let_syntax,
            Monad_infix,
            bind$0,
            join,
            ignore_m,
            ,
            return$2,
            map$1,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix,
            combine_all,
            combine_all_unit,
            to_option,
            value,
            with_return];
   }
   function either(t, return$0, other){
    if(0 === t[0]){var x = t[1]; return caml_call1(return$0, x);}
    var y = t[1];
    return caml_call1(other, y);
   }
   function combine(t1, t2, f, other){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return [0, caml_call2(f, x, y)];}
     var x$0 = t2[1];
    }
    else{
     var x$1 = t1[1];
     if(0 !== t2[0]){
      var y$0 = t2[1];
      return [1, caml_call2(other, x$1, y$0)];
     }
     var x$0 = x$1;
    }
    return [1, x$0];
   }
   function bind(t, f){
    if(0 !== t[0]) return t;
    var x = t[1];
    return caml_call1(f, x);
   }
   var First = Make_focused([0, first, second, either, combine, bind]);
   function either$0(t, return$0, other){
    if(0 === t[0]){var x = t[1]; return caml_call1(other, x);}
    var y = t[1];
    return caml_call1(return$0, y);
   }
   function combine$0(t1, t2, f, other){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return [0, caml_call2(other, x, y)];}
     var x$0 = x;
    }
    else{
     var x$1 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return [1, caml_call2(f, x$1, y$0)];}
     var x$0 = t2[1];
    }
    return [0, x$0];
   }
   function bind$0(t, f){
    if(0 === t[0]) return t;
    var x = t[1];
    return caml_call1(f, x);
   }
   var
    Second = Make_focused([0, second, first, either$0, combine$0, bind$0]),
    Export = [0],
    Base_Either =
      [0,
       compare,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       swap,
       value,
       value_map,
       value_map,
       map,
       equal,
       [0,
        First[4],
        First[5],
        First[6],
        First[7],
        First[8],
        First[9],
        First[11],
        First[12],
        First[13],
        First[14],
        First[15],
        First[16],
        First[17],
        First[18],
        First[19],
        First[20],
        First[21],
        First[22],
        First[23],
        First[27],
        First[26],
        First[28],
        First[3],
        First[24],
        First[25]],
       [0,
        Second[4],
        Second[5],
        Second[6],
        Second[7],
        Second[8],
        Second[9],
        Second[11],
        Second[12],
        Second[13],
        Second[14],
        Second[15],
        Second[16],
        Second[17],
        Second[18],
        Second[19],
        Second[20],
        Second[21],
        Second[22],
        Second[23],
        Second[27],
        Second[26],
        Second[28],
        Second[3],
        Second[24],
        Second[25]],
       is_first,
       is_second,
       first,
       second,
       Export];
   runtime.caml_register_global(6, Base_Either, "Base__Either");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Indexed_container_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Indexed_container_intf = [0];
   runtime.caml_register_global
    (0, Base_Indexed_container_intf, "Base__Indexed_container_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Indexed_container
//# unitInfo: Requires: Base__Container, Base__Indexed_container_intf, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Container = global_data.Base__Container,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1];
   function iteri(fold, t, f){
    caml_call3
     (fold, t, 0, function(i, x){caml_call2(f, i, x); return i + 1 | 0;});
    return 0;
   }
   function foldi(fold, t, init, f){
    var i = [0, 0];
    return caml_call3
            (fold,
             t,
             init,
             function(acc, v){
              var acc$0 = caml_call3(f, i[1], acc, v);
              i[1] = i[1] + 1 | 0;
              return acc$0;
             });
   }
   function counti(foldi, t, f){
    return caml_call3
            (foldi,
             t,
             0,
             function(i, n, a){return caml_call2(f, i, a) ? n + 1 | 0 : n;});
   }
   function existsi(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _c_ = caml_call2(f, i, x);
                 return _c_ ? caml_call1(r, 1) : _c_;
                });
              return 0;
             });
   }
   function for_alli(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _b_ = 1 - caml_call2(f, i, x);
                 return _b_ ? caml_call1(r, 0) : _b_;
                });
              return 1;
             });
   }
   function find_mapi(iteri, t, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                t,
                function(i, x){
                 var res = caml_call2(f, i, x);
                 return res ? caml_call1(r, res) : 0;
                });
              return 0;
             });
   }
   function findi(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _a_ = caml_call2(f, i, x);
                 return _a_ ? caml_call1(r, [0, [0, i, x]]) : _a_;
                });
              return 0;
             });
   }
   function Make_gen(T){
    var
     include = caml_call1(Base_Container[18], [0, T[1], T[2], T[3]]),
     length = include[1],
     is_empty = include[2],
     iter = include[3],
     fold = include[4],
     fold_result = include[5],
     fold_until = include[6],
     exists = include[7],
     for_all = include[8],
     count = include[9],
     sum = include[10],
     find = include[11],
     find_map = include[12],
     to_list = include[13],
     to_array = include[14],
     min_elt = include[15],
     max_elt = include[16],
     match = T[4];
    if(typeof match === "number")
     var iteri$0 = function(t, f){return iteri(fold, t, f);};
    else
     var iteri$1 = match[2], iteri$0 = iteri$1;
    var match$0 = T[5];
    if(typeof match$0 === "number")
     var foldi$0 = function(t, init, f){return foldi(fold, t, init, f);};
    else
     var foldi$1 = match$0[2], foldi$0 = foldi$1;
    function counti$0(t, f){return counti(foldi$0, t, f);}
    function existsi$0(t, f){return existsi(iteri$0, t, f);}
    function for_alli$0(t, f){return for_alli(iteri$0, t, f);}
    function find_mapi$0(t, f){return find_mapi(iteri$0, t, f);}
    function findi$0(t, f){return findi(iteri$0, t, f);}
    return [0,
            length,
            is_empty,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi$0,
            iteri$0,
            existsi$0,
            for_alli$0,
            counti$0,
            findi$0,
            find_mapi$0];
   }
   var
    Base_Indexed_container =
      [0,
       foldi,
       iteri,
       counti,
       existsi,
       for_alli,
       findi,
       find_mapi,
       function(T){
        var
         C = caml_call1(Base_Container[16], [0, T[1], T[2], T[3]]),
         mem = C[1],
         fold = T[1],
         iter = T[2],
         length = T[3],
         iteri = T[4],
         foldi = T[5],
         include = Make_gen([0, fold, iter, length, iteri, foldi]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[3],
         fold$0 = include[4],
         fold_result = include[5],
         fold_until = include[6],
         exists = include[7],
         for_all = include[8],
         count = include[9],
         sum = include[10],
         find = include[11],
         find_map = include[12],
         to_list = include[13],
         to_array = include[14],
         min_elt = include[15],
         max_elt = include[16],
         foldi$0 = include[17],
         iteri$0 = include[18],
         existsi = include[19],
         for_alli = include[20],
         counti = include[21],
         findi = include[22],
         find_mapi = include[23];
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                foldi$0,
                iteri$0,
                existsi,
                for_alli,
                counti,
                findi,
                find_mapi];
       },
       function(T){
        var
         C = caml_call1(Base_Container[17], [0, T[1], T[2], T[3], T[4]]),
         mem = C[1],
         fold = T[2],
         iter = T[3],
         length = T[4],
         iteri = T[5],
         foldi = T[6],
         include = Make_gen([0, fold, iter, length, iteri, foldi]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[3],
         fold$0 = include[4],
         fold_result = include[5],
         fold_until = include[6],
         exists = include[7],
         for_all = include[8],
         count = include[9],
         sum = include[10],
         find = include[11],
         find_map = include[12],
         to_list = include[13],
         to_array = include[14],
         min_elt = include[15],
         max_elt = include[16],
         foldi$0 = include[17],
         iteri$0 = include[18],
         existsi = include[19],
         for_alli = include[20],
         counti = include[21],
         findi = include[22],
         find_mapi = include[23];
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                foldi$0,
                iteri$0,
                existsi,
                for_alli,
                counti,
                findi,
                find_mapi];
       },
       Make_gen];
   runtime.caml_register_global
    (2, Base_Indexed_container, "Base__Indexed_container");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sequence
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Container, Base__Hash, Base__Import, Base__List1, Base__Monad, Base__Ppx_compare_lib, Base__Result, Base__With_return, CamlinternalLazy, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Both$0 = "Both",
    cst_Left$0 = "Left",
    cst_Right$0 = "Right",
    cst_Sequence_nth$1 = "Sequence.nth",
    cst_both = "both",
    cst_left = "left",
    cst_right = "right",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_025 = "sequence.ml.Merge_with_duplicates_element.t",
    Base_List1 = global_data.Base__List1,
    Base_With_return = global_data.Base__With_return,
    Base_Import = global_data.Base__Import,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Result = global_data.Base__Result,
    Base_Container = global_data.Base__Container,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Assert_failure = global_data.Assert_failure,
    Base_Array0 = global_data.Base__Array0,
    Base_Monad = global_data.Base__Monad,
    _a_ = [0, "Done"],
    _b_ = [0, "Skip"],
    _c_ = [0, "Yield"];
   function sexp_of_t(of_a_001, of_s_002, param){
    if(typeof param === "number") return _a_;
    if(0 === param[0]){
     var arg0_003 = param[1], res0_004 = caml_call1(of_s_002, arg0_003);
     return [1, [0, _b_, [0, res0_004, 0]]];
    }
    var
     arg1_006 = param[2],
     arg0_005 = param[1],
     res0_007 = caml_call1(of_a_001, arg0_005),
     res1_008 = caml_call1(of_s_002, arg1_006);
    return [1, [0, _c_, [0, res0_007, [0, res1_008, 0]]]];
   }
   var Step = [0, sexp_of_t];
   function next_step(param){
    var f = param[2], s = param[1], match = caml_call1(f, s);
    if(typeof match === "number") return 0;
    if(0 === match[0]){var s$0 = match[1]; return [0, [0, s$0, f]];}
    var s$1 = match[2], a = match[1];
    return [1, a, [0, s$1, f]];
   }
   function delayed_fold_step(s, init, f, finish){
    function loop(s, next, finish, f, acc){
     var match = caml_call1(next, s);
     if(typeof match === "number") return caml_call1(finish, acc);
     if(0 === match[0]){
      var s$0 = match[1];
      return caml_call3
              (f,
               acc,
               0,
               function(_K_){return loop(s$0, next, finish, f, _K_);});
     }
     var s$1 = match[2], a = match[1];
     return caml_call3
             (f,
              acc,
              [0, a],
              function(_J_){return loop(s$1, next, finish, f, _J_);});
    }
    var next = s[2], s$0 = s[1];
    return loop(s$0, next, finish, f, init);
   }
   var
    Expert = [0, next_step, delayed_fold_step],
    _e_ = [0, 0, 0],
    _f_ = [0, "src/sequence.ml", 259, 14];
   function unfold_step(init, f){return [0, init, f];}
   function unfold(init, f){
    function f$0(s){
     var match = caml_call1(f, s);
     if(! match) return 0;
     var match$0 = match[1], s$0 = match$0[2], a = match$0[1];
     return [1, a, s$0];
    }
    return [0, init, f$0];
   }
   function unfold_with(s, init, f){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, init, s$0],
            function(param){
             var s = param[2], seed = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){
              var s$0 = match[1];
              return [0, [0, seed, s$0]];
             }
             var
              s$1 = match[2],
              a = match[1],
              match$0 = caml_call2(f, seed, a);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var seed$0 = match$0[1];
              return [0, [0, seed$0, s$1]];
             }
             var seed$1 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, seed$1, s$1]];
            }];
   }
   function unfold_with_and_finish
   (s, init, running_step, inner_finished, finishing_step){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, -172306698, [0, init, s$0]],
            function(state){
             if(301075099 <= state[1]){
              var
               state$0 = state[2],
               match = caml_call1(finishing_step, state$0);
              if(typeof match === "number") return 0;
              if(0 === match[0]){
               var state$1 = match[1];
               return [0, [0, 301075099, state$1]];
              }
              var state$2 = match[2], y = match[1];
              return [1, y, [0, 301075099, state$2]];
             }
             var
              match$0 = state[2],
              inner_state = match$0[2],
              state$3 = match$0[1],
              match$1 = caml_call1(next, inner_state);
             if(typeof match$1 === "number")
              return [0, [0, 301075099, caml_call1(inner_finished, state$3)]];
             if(0 === match$1[0]){
              var inner_state$0 = match$1[1];
              return [0, [0, -172306698, [0, state$3, inner_state$0]]];
             }
             var
              inner_state$1 = match$1[2],
              x = match$1[1],
              match$2 = caml_call2(running_step, state$3, x);
             if(typeof match$2 === "number") return 0;
             if(0 === match$2[0]){
              var state$4 = match$2[1];
              return [0, [0, -172306698, [0, state$4, inner_state$1]]];
             }
             var state$5 = match$2[2], y$0 = match$2[1];
             return [1, y$0, [0, -172306698, [0, state$5, inner_state$1]]];
            }];
   }
   function of_list(init){
    function f(param){
     if(! param) return 0;
     var l = param[2], x = param[1];
     return [1, x, l];
    }
    return [0, init, f];
   }
   function fold(t, init, f){
    var next = t[2], seed$2 = t[1], seed = seed$2, v = init;
    for(;;){
     var match = caml_call1(next, seed);
     if(typeof match === "number") return v;
     if(0 === match[0]){
      var seed$0 = match[1];
      seed = seed$0;
     }
     else{
      var seed$1 = match[2], a = match[1], v$0 = caml_call2(f, v, a);
      seed = seed$1;
      v = v$0;
     }
    }
   }
   function to_list_rev(t){
    return fold(t, 0, function(l, x){return [0, x, l];});
   }
   function to_list(param){
    var next = param[2], s = param[1];
    function to_list(s, next, i){
     var s$0 = s;
     for(;;){
      if(0 === i){
       var t = [0, s$0, next], _I_ = to_list_rev(t);
       return caml_call1(Base_List1[21], _I_);
      }
      var match = caml_call1(next, s$0);
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s$2 = match[2], a = match[1];
       return [0, a, to_list(s$2, next, caml_call2(Base_Import[92], i, 1))];
      }
      var s$1 = match[1];
      s$0 = s$1;
     }
    }
    return to_list(s, next, 500);
   }
   function sexp_of_t$0(sexp_of_a, t){
    var _H_ = to_list(t);
    return caml_call2(Base_Import[151], sexp_of_a, _H_);
   }
   function range(opt, _G_, _F_, start_v, stop_v){
    if(opt) var sth = opt[1], stride = sth; else var stride = 1;
    if(_G_) var sth$0 = _G_[1], start = sth$0; else var start = 104758188;
    if(_F_) var sth$1 = _F_[1], stop = sth$1; else var stop = -160346914;
    var
     step =
       104758188 <= stop
        ? 0
          <= stride
          ? function
           (i){
            return stop_v < i
                    ? 0
                    : [1, i, caml_call2(Base_Import[90], i, stride)];
           }
          : function
           (i){
            return i < stop_v
                    ? 0
                    : [1, i, caml_call2(Base_Import[90], i, stride)];
           }
        : 0
          <= stride
          ? function
           (i){
            return stop_v <= i
                    ? 0
                    : [1, i, caml_call2(Base_Import[90], i, stride)];
           }
          : function
           (i){
            return i <= stop_v
                    ? 0
                    : [1, i, caml_call2(Base_Import[90], i, stride)];
           },
     init =
       104758188 <= start
        ? start_v
        : caml_call2(Base_Import[90], start_v, stride);
    return [0, init, step];
   }
   function of_lazy(t_lazy){
    function f(t_lazy){
     var
      _E_ = caml_obj_tag(t_lazy),
      match =
        250 === _E_
         ? t_lazy[1]
         : 246 === _E_ ? caml_call1(CamlinternalLazy[2], t_lazy) : t_lazy,
      next = match[2],
      s = match[1],
      match$0 = caml_call1(next, s);
     if(typeof match$0 === "number") return 0;
     if(0 === match$0[0]){
      var s$0 = match$0[1], v = [0, s$0, next];
      return [0, v];
     }
     var s$1 = match$0[2], x = match$0[1], v$0 = [0, s$1, next];
     return [1, x, v$0];
    }
    return [0, t_lazy, f];
   }
   function _d_(t, f){
    var next = t[2], seed = t[1];
    return [0,
            seed,
            function(seed){
             var match = caml_call1(next, seed);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s = match[1]; return [0, s];}
             var s$0 = match[2], a = match[1];
             return [1, caml_call1(f, a), s$0];
            }];
   }
   function mapi(t, f){
    var next = t[2], s = t[1];
    return [0,
            [0, 0, s],
            function(param){
             var s = param[2], i = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var
              s$1 = match[2],
              a = match[1],
              _D_ = [0, caml_call2(Base_Import[90], i, 1), s$1];
             return [1, caml_call2(f, i, a), _D_];
            }];
   }
   function folding_map(t, init, f){
    return unfold_with
            (t,
             init,
             function(acc, x){
              var
               match = caml_call2(f, acc, x),
               x$0 = match[2],
               acc$0 = match[1];
              return [1, x$0, acc$0];
             });
   }
   function folding_mapi(t, init, f){
    return unfold_with
            (t,
             [0, 0, init],
             function(param, x){
              var
               acc = param[2],
               i = param[1],
               match = caml_call3(f, i, acc, x),
               x$0 = match[2],
               acc$0 = match[1];
              return [1, x$0, [0, caml_call2(Base_Import[90], i, 1), acc$0]];
             });
   }
   function filter(t, f){
    var next = t[2], seed = t[1];
    return [0,
            seed,
            function(seed){
             var match = caml_call1(next, seed);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s = match[1]; return [0, s];}
             var a = match[1], s$0 = match[2];
             if(caml_call1(f, a)) return [1, a, s$0];
             var s$1 = match[2];
             return [0, s$1];
            }];
   }
   function filteri(t, f){
    var _C_ = Base_Import[126];
    return _d_
            (filter
              (mapi(t, function(i, s){return [0, i, s];}),
               function(param){
                var s = param[2], i = param[1];
                return caml_call2(f, i, s);
               }),
             _C_);
   }
   function length(t){
    var next = t[2], seed = t[1], i = 0, s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return i;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var s$1 = match[2], i$0 = caml_call2(Base_Import[90], i, 1);
      i = i$0;
      s = s$1;
     }
    }
   }
   function to_array(t){
    var
     match =
       fold
        (t,
         _e_,
         function(param, x){
          var i = param[2], l = param[1];
          return [0, [0, x, l], caml_call2(Base_Import[90], i, 1)];
         }),
     len = match[2],
     l = match[1];
    if(! l) return [0];
    var
     l$0 = l[2],
     x = l[1],
     a = caml_call2(Base_Array0[4], len, x),
     i$1 = caml_call2(Base_Import[92], len, 2),
     i = i$1,
     l$1 = l$0;
    for(;;){
     if(! l$1){
      if(-1 === i) return a;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     }
     var l$2 = l$1[2], x$0 = l$1[1];
     runtime.caml_check_bound(a, i)[1 + i] = x$0;
     var i$0 = caml_call2(Base_Import[92], i, 1);
     i = i$0;
     l$1 = l$2;
    }
   }
   function find(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var a = match[1];
      if(caml_call1(f, a)) return [0, a];
      var s$0 = match[2];
     }
     s = s$0;
    }
   }
   function find_map(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var s$1 = match[2], a = match[1], some_b = caml_call1(f, a);
      if(some_b) return some_b;
      s = s$1;
     }
    }
   }
   function find_mapi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var s$1 = match[2], a = match[1], some_b = caml_call2(f, i, a);
      if(some_b) return some_b;
      var i$0 = caml_call2(Base_Import[90], i, 1);
      s = s$1;
      i = i$0;
     }
    }
   }
   function for_all(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var a = match[1];
      if(! caml_call1(f, a)) return 0;
      var s$0 = match[2];
     }
     s = s$0;
    }
   }
   function for_alli(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var a = match[1];
      if(! caml_call2(f, i, a)) return 0;
      var s$1 = match[2], i$0 = caml_call2(Base_Import[90], i, 1);
      s = s$1;
      i = i$0;
     }
    }
   }
   function exists(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{var a = match[1]; if(caml_call1(f, a)) return 1; var s$0 = match[2];
     }
     s = s$0;
    }
   }
   function existsi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$0 = match[1];
      s = s$0;
     }
     else{
      var a = match[1];
      if(caml_call2(f, i, a)) return 1;
      var s$1 = match[2], i$0 = caml_call2(Base_Import[90], i, 1);
      s = s$1;
      i = i$0;
     }
    }
   }
   function iter(t, f){
    var next = t[2], seed$2 = t[1], seed = seed$2;
    for(;;){
     var match = caml_call1(next, seed);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var seed$0 = match[1];
      seed = seed$0;
     }
     else{
      var seed$1 = match[2], a = match[1];
      caml_call1(f, a);
      seed = seed$1;
     }
    }
   }
   function is_empty(t){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 !== match[0]) return 0;
     var s$0 = match[1];
     s = s$0;
    }
   }
   function mem(t, a, equal){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var b = match[1];
      if(caml_call2(equal, a, b)) return 1;
      var s$0 = match[2];
     }
     s = s$0;
    }
   }
   var empty = [0, 0, function(param){return 0;}];
   function bind(t, f){
    function f$0(param){
     var
      rest = param[2],
      match = param[1],
      next = match[2],
      seed = match[1],
      match$0 = caml_call1(next, seed);
     if(typeof match$0 === "number"){
      var
       next$0 = rest[2],
       seed$0 = rest[1],
       match$1 = caml_call1(next$0, seed$0);
      if(typeof match$1 === "number") return 0;
      if(0 === match$1[0]){
       var s = match$1[1];
       return [0, [0, empty, [0, s, next$0]]];
      }
      var s$0 = match$1[2], a = match$1[1];
      return [0, [0, caml_call1(f, a), [0, s$0, next$0]]];
     }
     if(0 === match$0[0]){
      var s$1 = match$0[1];
      return [0, [0, [0, s$1, next], rest]];
     }
     var s$2 = match$0[2], a$0 = match$0[1];
     return [1, a$0, [0, [0, s$2, next], rest]];
    }
    var init = [0, empty, t];
    return [0, init, f$0];
   }
   function return$0(x){
    function f(param){
     if(! param) return 0;
     var x = param[1];
     return [1, x, 0];
    }
    var init = [0, x];
    return [0, init, f];
   }
   var
    map = [0, -198771759, _d_],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11],
    cst_Sequence_nth = cst_Sequence_nth$1,
    cst_Sequence_nth$0 = cst_Sequence_nth$1,
    _g_ = [0, cst_Left$0],
    _h_ = [0, cst_Right$0],
    _i_ = [0, cst_Both$0],
    cst_Both = cst_Both$0,
    cst_Right = cst_Right$0,
    cst_Left = cst_Left$0;
   function nth(s, n){
    if(0 > n) return 0;
    var next = s[2], s$3 = s[1], i = n, s$0 = s$3;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], a = match[1];
      if(caml_call2(Base_Import[127], i, 0)) return [0, a];
      var i$0 = caml_call2(Base_Import[92], i, 1);
      i = i$0;
      s$0 = s$2;
     }
    }
   }
   function nth_exn(s, n){
    if(0 > n) return caml_call1(Base_Import[125], cst_Sequence_nth$0);
    var match = nth(s, n);
    if(! match) return caml_call1(Base_Import[123], cst_Sequence_nth);
    var x = match[1];
    return x;
   }
   function compare(cmp_a, cmp_b, a_011, b_012){
    if(caml_call2(Base_Ppx_compare_lib[1], a_011, b_012)) return 0;
    switch(a_011[0]){
      case 0:
       var a_013 = a_011[1];
       if(0 !== b_012[0]) return -1;
       var b_014 = b_012[1];
       return caml_call2(cmp_a, a_013, b_014);
      case 1:
       var a_015 = a_011[1];
       switch(b_012[0]){
         case 0: break;
         case 1:
          var b_016 = b_012[1]; return caml_call2(cmp_b, a_015, b_016);
         default: return -1;
       }
       break;
      default:
       var a_019 = a_011[2], a_017 = a_011[1];
       switch(b_012[0]){
         case 0: break;
         case 1:
          return 1;
         default:
          var
           b_020 = b_012[2],
           b_018 = b_012[1],
           n = caml_call2(cmp_a, a_017, b_018);
          return 0 === n ? caml_call2(cmp_b, a_019, b_020) : n;
       }
    }
    return 1;
   }
   function hash_fold_t(hash_fold_a, hash_fold_b, hsv, arg){
    switch(arg[0]){
      case 0:
       var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
       return caml_call2(hash_fold_a, hsv$0, a0);
      case 1:
       var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
       return caml_call2(hash_fold_b, hsv$1, a0$0);
      default:
       var
        a1 = arg[2],
        a0$1 = arg[1],
        hsv$2 = caml_call2(Base_Hash[3], hsv, 2),
        hsv$3 = caml_call2(hash_fold_a, hsv$2, a0$1);
       return caml_call2(hash_fold_b, hsv$3, a1);
    }
   }
   function t_of_sexp(of_a_021, of_b_022, sexp_027){
    a:
    {
     if(0 === sexp_027[0]){
      var _y_ = sexp_027[1];
      b:
      if(_y_ !== cst_Both$0){
       c:
       if(_y_ !== cst_Left$0){
        if(_y_ !== cst_Right$0){
         if(_y_ === cst_both) break b;
         if(_y_ === cst_left) break c;
         if(_y_ !== cst_right) break a;
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_025, sexp_027);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_025, sexp_027);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_025, sexp_027);
     }
     var _z_ = sexp_027[1];
     if(! _z_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_025, sexp_027);
     var _A_ = _z_[1];
     if(0 !== _A_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_025, sexp_027);
     var tag_028 = _A_[1];
     b:
     if(tag_028 !== cst_Both$0){
      c:
      if(tag_028 !== cst_Left$0){
       if(tag_028 !== cst_Right$0){
        if(tag_028 === cst_both) break b;
        if(tag_028 === cst_left) break c;
        if(tag_028 !== cst_right) break a;
       }
       var sexp_args_034 = _z_[2];
       if(sexp_args_034 && ! sexp_args_034[2]){
        var
         arg0_035 = sexp_args_034[1],
         res0_036 = caml_call1(of_b_022, arg0_035);
        return [1, res0_036];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[4],
                error_source_025,
                tag_028,
                sexp_027);
      }
      var sexp_args_029 = _z_[2];
      if(sexp_args_029 && ! sexp_args_029[2]){
       var
        arg0_030 = sexp_args_029[1],
        res0_031 = caml_call1(of_a_021, arg0_030);
       return [0, res0_031];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_025,
               tag_028,
               sexp_027);
     }
     var sexp_args_039 = _z_[2];
     if(sexp_args_039){
      var _B_ = sexp_args_039[2];
      if(_B_ && ! _B_[2]){
       var
        arg1_041 = _B_[1],
        arg0_040 = sexp_args_039[1],
        res0_042 = caml_call1(of_a_021, arg0_040),
        res1_043 = caml_call1(of_b_022, arg1_041);
       return [2, res0_042, res1_043];
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_025,
              tag_028,
              sexp_027);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_025, sexp_027);
   }
   function sexp_of_t$1(of_a_046, of_b_047, param){
    switch(param[0]){
      case 0:
       var arg0_048 = param[1], res0_049 = caml_call1(of_a_046, arg0_048);
       return [1, [0, _g_, [0, res0_049, 0]]];
      case 1:
       var arg0_050 = param[1], res0_051 = caml_call1(of_b_047, arg0_050);
       return [1, [0, _h_, [0, res0_051, 0]]];
      default:
       var
        arg1_053 = param[2],
        arg0_052 = param[1],
        res0_054 = caml_call1(of_a_046, arg0_052),
        res1_055 = caml_call1(of_b_047, arg1_053);
       return [1, [0, _i_, [0, res0_054, [0, res1_055, 0]]]];
    }
   }
   function t_sexp_grammar(a_sexp_grammar, b_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Left, [0, [0, a_sexp_grammar, 0]]]],
              [0,
               [1, [0, cst_Right, [0, [0, b_sexp_grammar, 0]]]],
               [0,
                [1,
                 [0,
                  cst_Both,
                  [0, [0, a_sexp_grammar, [0, b_sexp_grammar, 0]]]]],
                0]]]]];
   }
   var
    Merge_with_duplicates_element =
      [0, compare, hash_fold_t, t_of_sexp, sexp_of_t$1, t_sexp_grammar],
    cst_hd_exn = "hd_exn",
    cst_Sequence_tl_exn = "Sequence.tl_exn",
    cst_Sequence_chunks_exn = "Sequence.chunks_exn",
    cst_Sequence_find_exn = "Sequence.find_exn",
    cst_Sequence_reduce_exn = "Sequence.reduce_exn",
    cst_Sequence_sub = "Sequence.sub",
    cst_Sequence_take = "Sequence.take",
    cst_Sequence_drop = "Sequence.drop";
   function merge_with_duplicates(param, _x_, compare){
    var next2 = _x_[2], s2 = _x_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, [1, b], [0, 0, [0, s2$0]]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var s2$2 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof s2$2 === "number") return [1, [0, a], [0, [0, s1$1], 0]];
      if(0 !== s2$2[0]){
       var
        s2$3 = s2$2[2],
        b$0 = s2$2[1],
        comparison = caml_call2(compare, a, b$0);
       return 0 <= comparison
               ? 0
                 === comparison
                 ? [1, [2, a, b$0], [0, [0, s1$1], [0, s2$3]]]
                 : [1, [1, b$0], [0, s1, [0, s2$3]]]
               : [1, [0, a], [0, [0, s1$1], s2$2]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function merge_deduped_and_sorted(s1, s2, compare){
    return caml_call2
            (map$0,
             merge_with_duplicates(s1, s2, compare),
             function(param){var x = param[1]; return x;});
   }
   function merge_sorted(param, _w_, compare){
    var next2 = _w_[2], s2 = _w_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, b, [0, 0, [0, s2$0]]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var s2$2 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof s2$2 === "number") return [1, a, [0, [0, s1$1], 0]];
      if(0 !== s2$2[0]){
       var
        s2$3 = s2$2[2],
        b$0 = s2$2[1],
        comparison = caml_call2(compare, a, b$0);
       return 0 < comparison
               ? [1, b$0, [0, s1, [0, s2$3]]]
               : [1, a, [0, [0, s1$1], s2$2]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function hd(s){
    var next = s[2], s$2 = s[1], s$0 = s$2;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 !== match[0]){var a = match[1]; return [0, a];}
     var s$1 = match[1];
     s$0 = s$1;
    }
   }
   function hd_exn(s){
    var match = hd(s);
    if(! match) return caml_call1(Base_Import[123], cst_hd_exn);
    var a = match[1];
    return a;
   }
   function tl(s){
    var next = s[2], s$2 = s[1], s$0 = s$2;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number")
      var match$0 = 0;
     else{
      if(0 === match[0]){var s$1 = match[1]; s$0 = s$1; continue;}
      var a = match[2], match$0 = [0, a];
     }
     if(! match$0) return 0;
     var s$3 = match$0[1];
     return [0, [0, s$3, next]];
    }
   }
   function tl_eagerly_exn(s){
    var match = tl(s);
    if(! match) return caml_call1(Base_Import[123], cst_Sequence_tl_exn);
    var s$0 = match[1];
    return s$0;
   }
   function lift_identity(next, s){
    var match = caml_call1(next, s);
    if(typeof match === "number") return 0;
    if(0 === match[0]){var s$0 = match[1]; return [0, [0, 316735838, s$0]];}
    var s$1 = match[2], a = match[1];
    return [1, a, [0, 316735838, s$1]];
   }
   function next(s){
    var next = s[2], s$3 = s[1], s$0 = s$3;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 !== match[0]){
      var s$2 = match[2], a = match[1];
      return [0, [0, a, [0, s$2, next]]];
     }
     var s$1 = match[1];
     s$0 = s$1;
    }
   }
   function filter_opt(s){
    var next = s[2], s$0 = s[1];
    return [0,
            s$0,
            function(s){
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, s$0];}
             var match$0 = match[1];
             if(match$0){
              var s$1 = match[2], a = match$0[1];
              return [1, a, s$1];
             }
             var s$2 = match[2];
             return [0, s$2];
            }];
   }
   function filter_map(s, f){return filter_opt(caml_call2(map$0, s, f));}
   function filter_mapi(s, f){
    return filter_map
            (mapi(s, function(i, s){return [0, i, s];}),
             function(param){
              var s = param[2], i = param[1];
              return caml_call2(f, i, s);
             });
   }
   function split_n(s, n){
    var next = s[2], s$3 = s[1], s$0 = s$3, i = n, accum = 0;
    for(;;){
     if(0 >= i) return [0, caml_call1(Base_List1[21], accum), [0, s$0, next]];
     var match = caml_call1(next, s$0);
     if(typeof match === "number")
      return [0, caml_call1(Base_List1[21], accum), empty];
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var
       s$2 = match[2],
       a = match[1],
       accum$0 = [0, a, accum],
       i$0 = caml_call2(Base_Import[92], i, 1);
      s$0 = s$2;
      i = i$0;
      accum = accum$0;
     }
    }
   }
   function chunks_exn(init, n){
    if(0 >= n) return caml_call1(Base_Import[125], cst_Sequence_chunks_exn);
    function f(t){
     var match = split_n(t, n), xs = match[1];
     if(! xs) return 0;
     var t$0 = match[2];
     return [1, xs, t$0];
    }
    return [0, init, f];
   }
   function findi(s, f){
    return find
            (mapi(s, function(i, s){return [0, i, s];}),
             function(param){
              var s = param[2], i = param[1];
              return caml_call2(f, i, s);
             });
   }
   function find_exn(s, f){
    var match = find(s, f);
    if(! match) return caml_call1(Base_Import[123], cst_Sequence_find_exn);
    var x = match[1];
    return x;
   }
   function append(s1, s2){
    var next2 = s2[2], s2$0 = s2[1], next1 = s1[2], s1$0 = s1[1];
    return [0,
            [0, 472258093, s1$0],
            function(param){
             if(472258093 <= param[1]){
              var s1 = param[2], match = caml_call1(next1, s1);
              if(typeof match === "number") return [0, [0, -630817751, s2$0]];
              if(0 === match[0]){
               var s1$0 = match[1];
               return [0, [0, 472258093, s1$0]];
              }
              var s1$1 = match[2], a = match[1];
              return [1, a, [0, 472258093, s1$1]];
             }
             var s2 = param[2], match$0 = caml_call1(next2, s2);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s2$1 = match$0[1];
              return [0, [0, -630817751, s2$1]];
             }
             var s2$2 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, -630817751, s2$2]];
            }];
   }
   function concat_map(s, f){return caml_call2(bind$0, s, f);}
   function concat(s){
    function f(_v_){return _v_;}
    return caml_call2(bind$0, s, f);
   }
   function concat_mapi(s, f){
    function f$0(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    var s$0 = mapi(s, function(i, s){return [0, i, s];});
    return caml_call2(bind$0, s$0, f$0);
   }
   function zip(param, _t_){
    var next2 = _t_[2], s2 = _t_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var _u_ = param[1];
     if(typeof _u_ !== "number"){
      if(1 === _u_[0]){
       var match = param[2], s1$0 = _u_[2], a = _u_[1];
       if(typeof match !== "number"){
        if(0 === match[0]){
         var s2$0 = param[2][1];
         return [0, [0, _u_, caml_call1(next2, s2$0)]];
        }
        var s2$1 = match[2], b = match[1];
        return [1, [0, a, b], [0, [0, s1$0], [0, s2$1]]];
       }
      }
      if(typeof param[2] !== "number"){
       var s2 = param[2], s1 = _u_[1];
       return [0, [0, caml_call1(next1, s1), s2]];
      }
     }
     return 0;
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function zip_full(param, _s_){
    var next2 = _s_[2], s2 = _s_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, [0, -57574468, b], [0, 0, caml_call1(next2, s2$0)]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var match$0 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof match$0 === "number")
       return [1, [0, 847852583, a], [0, caml_call1(next1, s1$1), 0]];
      if(0 !== match$0[0]){
       var s2$2 = match$0[2], b$0 = match$0[1];
       return [1, [0, 737457313, [0, a, b$0]], [0, [0, s1$1], [0, s2$2]]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function bounded_length(param, at_most){
    var next = param[2], seed = param[1], i = 0, seed$0 = seed;
    for(;;){
     if(at_most < i) return 85047514;
     var match = caml_call1(next, seed$0);
     if(typeof match === "number") return [0, 16394, i];
     if(0 === match[0]){
      var seed$1 = match[1];
      seed$0 = seed$1;
     }
     else{
      var seed$2 = match[2], i$0 = caml_call2(Base_Import[90], i, 1);
      i = i$0;
      seed$0 = seed$2;
     }
    }
   }
   function length_is_bounded_by(opt, max, t){
    if(opt) var sth = opt[1], min = sth; else var min = -1;
    if(max){
     var max$0 = max[1], match$0 = bounded_length(t, max$0);
     if(typeof match$0 !== "number" && 16394 === match$0[1]){var len = match$0[2]; if(min <= len) return 1;}
     return 0;
    }
    var next = t[2], s = t[1], s$0 = s, acc = 0;
    for(;;){
     if(min <= acc) return 1;
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], acc$0 = caml_call2(Base_Import[90], acc, 1);
      s$0 = s$2;
      acc = acc$0;
     }
    }
   }
   function iteri(s, f){
    return iter
            (mapi(s, function(i, s){return [0, i, s];}),
             function(param){
              var s = param[2], i = param[1];
              return caml_call2(f, i, s);
             });
   }
   function foldi(s, init, f){
    return fold
            (mapi(s, function(i, s){return [0, i, s];}),
             init,
             function(acc, param){
              var s = param[2], i = param[1];
              return caml_call3(f, i, acc, s);
             });
   }
   function reduce(s, f){
    var match = next(s);
    if(! match) return 0;
    var match$0 = match[1], s$0 = match$0[2], a = match$0[1];
    return [0, fold(s$0, a, f)];
   }
   function reduce_exn(s, f){
    var match = reduce(s, f);
    if(! match) return caml_call1(Base_Import[123], cst_Sequence_reduce_exn);
    var res = match[1];
    return res;
   }
   function group(param, break$0){
    var next = param[2], s = param[1];
    function f(param){
     if(! param) return 0;
     var
      match = param[1],
      s = match[2],
      acc = match[1],
      match$0 = caml_call1(next, s);
     if(typeof match$0 !== "number" && 0 === match$0[0]){
      var s$2 = match$0[1];
      return [0, [0, [0, acc, s$2]]];
     }
     if(acc){
      if(typeof match$0 === "number")
       return [1, caml_call1(Base_List1[21], acc), 0];
      var s$0 = match$0[2], cur = match$0[1], prev = acc[1];
      return caml_call2(break$0, prev, cur)
              ? [1,
                caml_call1(Base_List1[21], acc),
                [0, [0, [0, cur, 0], s$0]]]
              : [0, [0, [0, [0, cur, acc], s$0]]];
     }
     if(typeof match$0 === "number") return 0;
     var s$1 = match$0[2], cur$0 = match$0[1];
     return [0, [0, [0, [0, cur$0, 0], s$1]]];
    }
    var init = [0, [0, 0, s]];
    return [0, init, f];
   }
   function find_consecutive_duplicate(param, equal){
    var next = param[2], s = param[1], last_elt = 0, s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], a = match[1];
      if(last_elt){
       var b = last_elt[1];
       if(caml_call2(equal, a, b)) return [0, [0, b, a]];
      }
      var last_elt$0 = [0, a];
      last_elt = last_elt$0;
      s$0 = s$2;
     }
    }
   }
   function remove_consecutive_duplicates(s, equal){
    return unfold_with
            (s,
             0,
             function(prev, a){
              if(prev){
               var b = prev[1];
               if(caml_call2(equal, a, b)) return [0, [0, a]];
              }
              return [1, a, [0, a]];
             });
   }
   function count(s, f){return length(filter(s, f));}
   function counti(t, f){return length(filteri(t, f));}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function init(n, f){
    function f$0(i){
     if(n <= i) return 0;
     var _r_ = caml_call2(Base_Import[90], i, 1);
     return [1, caml_call1(f, i), _r_];
    }
    return [0, 0, f$0];
   }
   function sub(s, pos, len){
    var _p_ = pos < 0 ? 1 : 0, _q_ = _p_ || (len < 0 ? 1 : 0);
    if(_q_) caml_call1(Base_Import[123], cst_Sequence_sub);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1];
             if(len <= caml_call2(Base_Import[92], i, pos)) return 0;
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var a = match[1], s$1 = match[2];
             if(pos <= i)
              return [1, a, [0, caml_call2(Base_Import[90], i, 1), s$1]];
             var s$2 = match[2];
             return [0, [0, caml_call2(Base_Import[90], i, 1), s$2]];
            }];
   }
   function take(s, len){
    if(len < 0) caml_call1(Base_Import[123], cst_Sequence_take);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1];
             if(len <= i) return 0;
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var s$1 = match[2], a = match[1];
             return [1, a, [0, caml_call2(Base_Import[90], i, 1), s$1]];
            }];
   }
   function drop(s, len){
    if(len < 0) caml_call1(Base_Import[123], cst_Sequence_drop);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var a = match[1], s$1 = match[2];
             if(len <= i)
              return [1, a, [0, caml_call2(Base_Import[90], i, 1), s$1]];
             var s$2 = match[2];
             return [0, [0, caml_call2(Base_Import[90], i, 1), s$2]];
            }];
   }
   function take_while(s, f){
    var next = s[2], s$0 = s[1];
    return [0,
            s$0,
            function(s){
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, s$0];}
             var a = match[1], s$1 = match[2];
             return caml_call1(f, a) ? [1, a, s$1] : 0;
            }];
   }
   function drop_while(s, f){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, -557110719, s$0],
            function(param){
             if(316735838 <= param[1]){
              var s = param[2];
              return lift_identity(next, s);
             }
             var s$0 = param[2], match = caml_call1(next, s$0);
             if(typeof match === "number") return 0;
             if(0 === match[0]){
              var s$1 = match[1];
              return [0, [0, -557110719, s$1]];
             }
             var a = match[1], s$2 = match[2];
             if(caml_call1(f, a)) return [0, [0, -557110719, s$2]];
             var s$3 = match[2];
             return [1, a, [0, 316735838, s$3]];
            }];
   }
   function shift_right(s, x){
    var next = s[2], seed = s[1];
    return [0,
            [0, -433944719, [0, seed, x]],
            function(param){
             if(316735838 <= param[1]){
              var s = param[2];
              return lift_identity(next, s);
             }
             var match = param[2], x = match[2], seed = match[1];
             return [1, x, [0, 316735838, seed]];
            }];
   }
   function shift_right_with_list(s, l){return append(of_list(l), s);}
   var
    Infix = [0, append],
    cst_Sequence_cycle_list_exn = "Sequence.cycle_list_exn";
   function intersperse(s, sep){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 815032112, s$0],
            function(param){
             var _o_ = param[1];
             if(815032112 === _o_){
              var s = param[2], match = caml_call1(next, s);
              if(typeof match === "number") return 0;
              if(0 === match[0]){
               var s$0 = match[1];
               return [0, [0, 815032112, s$0]];
              }
              var s$1 = match[2], a = match[1];
              return [1, a, [0, 951752159, s$1]];
             }
             if(951752159 > _o_){
              var match$1 = param[2], s$5 = match$1[2], a$1 = match$1[1];
              return [1, a$1, [0, 951752159, s$5]];
             }
             var s$2 = param[2], match$0 = caml_call1(next, s$2);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s$3 = match$0[1];
              return [0, [0, 951752159, s$3]];
             }
             var s$4 = match$0[2], a$0 = match$0[1];
             return [1, sep, [0, -571577571, [0, a$0, s$4]]];
            }];
   }
   function repeat(init){
    function f(x){return [1, x, x];}
    return [0, init, f];
   }
   function cycle_list_exn(xs){
    if(caml_call1(Base_List1[23], xs))
     caml_call1(Base_Import[125], cst_Sequence_cycle_list_exn);
    var s = of_list(xs);
    function f(param){return s;}
    var s$0 = repeat(0);
    return caml_call2(bind$0, s$0, f);
   }
   function cartesian_product(sa, sb){
    function f(a){return zip(repeat(a), sb);}
    return caml_call2(bind$0, sa, f);
   }
   function singleton(x){return caml_call1(return$1, x);}
   function delayed_fold(s, init, f, finish){
    return caml_call4
            (Expert[2],
             s,
             init,
             function(acc, option, k){
              if(! option) return caml_call1(k, acc);
              var a = option[1];
              return caml_call3(f, acc, a, k);
             },
             finish);
   }
   function fold_m(bind, return$0, t, init, f){
    return caml_call4
            (Expert[2],
             t,
             init,
             function(acc, option, k){
              if(! option)
               return caml_call2(bind, caml_call1(return$0, acc), k);
              var a = option[1];
              return caml_call2(bind, caml_call2(f, acc, a), k);
             },
             return$0);
   }
   function iter_m(bind, return$0, t, f){
    return caml_call4
            (Expert[2],
             t,
             0,
             function(param, option, k){
              if(! option)
               return caml_call2(bind, caml_call1(return$0, 0), k);
              var a = option[1];
              return caml_call2(bind, caml_call1(f, a), k);
             },
             return$0);
   }
   function fold_until(s, init, f, finish){
    var next = s[2], s$3 = s[1], s$0 = s$3, acc = init;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return caml_call1(finish, acc);
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], a = match[1], match$0 = caml_call2(f, acc, a);
      if(0 !== match$0[0]){var x = match$0[1]; return x;}
      var acc$0 = match$0[1];
      s$0 = s$2;
      acc = acc$0;
     }
    }
   }
   function fold_result(s, init, f){
    var next = s[2], s$3 = s[1], s$0 = s$3, acc = init;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return caml_call1(Base_Result[12], acc);
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], a = match[1], e = caml_call2(f, acc, a);
      if(0 !== e[0]) return e;
      var acc$0 = e[1];
      s$0 = s$2;
      acc = acc$0;
     }
    }
   }
   function force_eagerly(t){return of_list(to_list(t));}
   function memoize(param){
    var next = param[2], s = param[1];
    function memoize(s){
     return [0,
             [246,
              function(_n_){
               var s$0 = s;
               for(;;){
                var match = caml_call1(next, s$0);
                if(typeof match === "number") return 0;
                if(0 !== match[0]){
                 var s$2 = match[2], a = match[1];
                 return [1, a, memoize(s$2)];
                }
                var s$1 = match[1];
                s$0 = s$1;
               }
              }]];
    }
    return [0,
            memoize(s),
            function(param){
             var l = param[1], _m_ = caml_obj_tag(l);
             return 250 === _m_
                     ? l[1]
                     : 246 === _m_ ? caml_call1(CamlinternalLazy[2], l) : l;
            }];
   }
   function drop_eagerly(s, len){
    var next = s[2], s$3 = s[1], i = 0, s$0 = s$3;
    for(;;){
     if(len <= i) return [0, s$0, next];
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return empty;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], i$0 = caml_call2(Base_Import[90], i, 1);
      i = i$0;
      s$0 = s$2;
     }
    }
   }
   function drop_while_option(param, f){
    var next = param[2], s = param[1], s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){
      var s$1 = match[1];
      s$0 = s$1;
     }
     else{
      var s$2 = match[2], x = match[1];
      if(! caml_call1(f, x)) return [0, [0, x, [0, s$2, next]]];
      s$0 = s$2;
     }
    }
   }
   function compare$0(compare_a, t1, t2){
    return caml_call1
            (Base_With_return[1],
             function(r){
              iter
               (zip_full(t1, t2),
                function(param){
                 var _k_ = param[1];
                 if(737457313 !== _k_)
                  return 847852583 <= _k_
                          ? caml_call1(r, 1)
                          : caml_call1(r, -1);
                 var
                  match = param[2],
                  v2 = match[2],
                  v1 = match[1],
                  c = caml_call2(compare_a, v1, v2),
                  _l_ = 0 !== c ? 1 : 0;
                 return _l_ ? caml_call1(r, c) : _l_;
                });
              return 0;
             });
   }
   function equal(equal_a, t1, t2){
    return for_all
            (zip_full(t1, t2),
             function(param){
              if(737457313 !== param[1]) return 0;
              var match = param[2], a2 = match[2], a1 = match[1];
              return caml_call2(equal_a, a1, a2);
             });
   }
   function round_robin(list){
    function next(param){
     var done_stack = param[2], todo_stack = param[1];
     if(! todo_stack)
      return caml_call1(Base_List1[23], done_stack)
              ? 0
              : [0, [0, caml_call1(Base_List1[21], done_stack), 0]];
     var
      todo_stack$0 = todo_stack[2],
      match = todo_stack[1],
      f = match[2],
      s = match[1],
      match$0 = caml_call1(f, s);
     if(typeof match$0 === "number")
      return [0, [0, todo_stack$0, done_stack]];
     if(0 === match$0[0]){
      var s$0 = match$0[1];
      return [0, [0, [0, [0, s$0, f], todo_stack$0], done_stack]];
     }
     var s$1 = match$0[2], x = match$0[1];
     return [1, x, [0, todo_stack$0, [0, [0, s$1, f], done_stack]]];
    }
    var state = [0, list, 0];
    return [0, state, next];
   }
   function interleave(param){
    var f1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[3], done_stack = param[2], todo_stack = param[1];
     if(todo_stack){
      var
       todo_stack$0 = todo_stack[2],
       match = todo_stack[1],
       f2 = match[2],
       s2 = match[1],
       match$0 = caml_call1(f2, s2);
      if(typeof match$0 === "number")
       return [0, [0, todo_stack$0, done_stack, s1]];
      if(0 === match$0[0]){
       var s2$0 = match$0[1];
       return [0, [0, todo_stack$0, [0, [0, s2$0, f2], done_stack], s1]];
      }
      var s2$1 = match$0[2], x = match$0[1];
      return [1, x, [0, todo_stack$0, [0, [0, s2$1, f2], done_stack], s1]];
     }
     var match$1 = caml_call1(f1, s1);
     if(typeof match$1 === "number")
      return done_stack
              ? [0, [0, caml_call1(Base_List1[21], done_stack), 0, s1]]
              : 0;
     if(0 === match$1[0]){
      var s1$0 = match$1[1];
      return [0, [0, caml_call1(Base_List1[21], done_stack), 0, s1$0]];
     }
     var s1$1 = match$1[2], t = match$1[1];
     return [0, [0, caml_call1(Base_List1[21], [0, t, done_stack]), 0, s1$1]];
    }
    var state = [0, 0, 0, s1];
    return [0, state, next];
   }
   function interleaved_cartesian_product(s1, s2){
    return interleave
            (caml_call2
              (map$0,
               s1,
               function(x1){
                return caml_call2
                        (map$0, s2, function(x2){return [0, x1, x2];});
               }));
   }
   function of_seq(init){
    function f(seq){
     var match = caml_call1(seq, 0);
     if(! match) return 0;
     var tl = match[2], hd = match[1];
     return [1, hd, tl];
    }
    return [0, init, f];
   }
   function to_seq(param){
    var next = param[2], state = param[1];
    function loop(state){
     var state$0 = state;
     for(;;){
      var match = caml_call1(next, state$0);
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var state$2 = match[2], hd = match[1];
       return [0, hd, function(param){return loop(state$2);}];
      }
      var state$1 = match[1];
      state$0 = state$1;
     }
    }
    return function(param){return loop(state);};
   }
   function return$2(x, k){return caml_call1(k, x);}
   function bind$1(m, f, k){
    return caml_call1
            (m,
             function(a){var m = caml_call1(f, a); return caml_call1(m, k);});
   }
   var
    map$1 =
      [0,
       -198771759,
       function(m, f, k){
        return caml_call1
                (m, function(a){return caml_call1(k, caml_call1(f, a));});
       }],
    include$0 = caml_call1(Base_Monad[2], [0, bind$1, map$1, return$2]),
    symbol_bind$0 = include$0[1],
    symbol_map$0 = include$0[2],
    Let_syntax$0 = include$0[3],
    Monad_infix$0 = include$0[4],
    bind$2 = include$0[5],
    return$3 = include$0[6],
    map$2 = include$0[7],
    join$0 = include$0[8],
    ignore_m$0 = include$0[9],
    all$0 = include$0[10],
    all_unit$0 = include$0[11],
    _j_ = [0, 0];
   function yield$0(e, k){return [0, [1, e, k]];}
   function of_sequence(sequence){
    return delayed_fold
            (sequence,
             0,
             function(param, x, k, f){
              return [0, [1, x, function(param){return caml_call2(k, 0, f);}]];
             },
             return$3);
   }
   function run(t){
    function init(param){return caml_call1(t, function(param){return _j_;});}
    function f(thunk){var step = caml_call1(thunk, 0)[1]; return step;}
    return [0, init, f];
   }
   var
    Base_Sequence =
      [0,
       sexp_of_t$0,
       equal,
       compare$0,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       counti,
       findi,
       find_mapi,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       empty,
       next,
       Step,
       unfold_step,
       unfold,
       unfold_with,
       unfold_with_and_finish,
       nth,
       nth_exn,
       folding_map,
       folding_mapi,
       mapi,
       filteri,
       filter,
       merge_deduped_and_sorted,
       merge_deduped_and_sorted,
       merge_sorted,
       Merge_with_duplicates_element,
       merge_with_duplicates,
       hd,
       hd_exn,
       tl,
       tl_eagerly_exn,
       find_exn,
       for_alli,
       append,
       concat,
       concat_map,
       concat_mapi,
       interleave,
       round_robin,
       zip,
       zip_full,
       reduce_exn,
       reduce,
       group,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       range,
       init,
       filter_map,
       filter_mapi,
       filter_opt,
       sub,
       take,
       drop,
       drop_eagerly,
       take_while,
       drop_while,
       drop_while_option,
       split_n,
       chunks_exn,
       shift_right,
       shift_right_with_list,
       drop,
       Infix,
       cartesian_product,
       interleaved_cartesian_product,
       intersperse,
       cycle_list_exn,
       repeat,
       singleton,
       delayed_fold,
       fold_m,
       iter_m,
       to_list_rev,
       of_list,
       of_lazy,
       memoize,
       force_eagerly,
       bounded_length,
       length_is_bounded_by,
       of_seq,
       to_seq,
       [0,
        symbol_bind$0,
        symbol_map$0,
        Let_syntax$0,
        Monad_infix$0,
        bind$2,
        return$3,
        map$2,
        join$0,
        ignore_m$0,
        all$0,
        all_unit$0,
        yield$0,
        of_sequence,
        run],
       Expert];
   runtime.caml_register_global(48, Base_Sequence, "Base__Sequence");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Array_permute, Base__Binary_searchable, Base__Blit, Base__Container, Base__Import, Base__List, Base__Option, Base__Ordered_collection_common, Base__Random, Base__Sequence
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_array_ml = "src/array.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Sequence = global_data.Base__Sequence,
    Base_Random = global_data.Base__Random,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Container = global_data.Base__Container,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Array0 = global_data.Base__Array0,
    Base_Array_permute = global_data.Base__Array_permute,
    Base_Binary_searchable = global_data.Base__Binary_searchable,
    Base_Blit = global_data.Base__Blit,
    invalid_argf = Base_Array0[1],
    max_length = Base_Array0[3],
    create = Base_Array0[4],
    create_float_uninitialized = Base_Array0[5],
    append = Base_Array0[6],
    concat = Base_Array0[8],
    copy = Base_Array0[9],
    fill = Base_Array0[10],
    init = Base_Array0[11],
    make_matrix = Base_Array0[12],
    of_list = Base_Array0[13],
    sub = Base_Array0[14],
    to_list = Base_Array0[15],
    fold = Base_Array0[16],
    fold_right = Base_Array0[17],
    iter = Base_Array0[18],
    iteri = Base_Array0[19],
    map = Base_Array0[20],
    mapi = Base_Array0[21],
    stable_sort = Base_Array0[22],
    swap = Base_Array0[23],
    compare = Base_Import[234],
    t_of_sexp = Base_Import[176],
    sexp_of_t = Base_Import[152];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[195], a_sexp_grammar);
   }
   function get(_aD_, _aC_){return caml_check_bound(_aD_, _aC_)[1 + _aC_];}
   function set(_aB_, _aA_, _az_){
    caml_check_bound(_aB_, _aA_)[1 + _aA_] = _az_;
    return 0;
   }
   function swap$0(arr, i, j){
    var tmp = get(arr, i);
    set(arr, i, get(arr, j));
    return set(arr, j, tmp);
   }
   function sort(arr, compare, left, right){
    var _ax_ = caml_call2(Base_Import[90], left, 1);
    if(right >= _ax_){
     var pos = _ax_;
     for(;;){
      var v = get(arr, pos), final_pos = pos;
      for(;;){
       var i_next = caml_call2(Base_Import[92], final_pos, 1);
       if(left > i_next) break;
       if(0 >= caml_call2(compare, get(arr, i_next), v)) break;
       set(arr, final_pos, get(arr, i_next));
       final_pos = i_next;
      }
      set(arr, final_pos, v);
      var _ay_ = pos + 1 | 0;
      if(right === pos) break;
      pos = _ay_;
     }
    }
    return 0;
   }
   var Insertion_sort = [0, sort];
   function heapify(arr, compare, root, left, right){
    var root$0 = root;
    for(;;){
     var
      relative_root = caml_call2(Base_Import[92], root$0, left),
      _aq_ = caml_call2(Base_Import[87], 2, relative_root),
      _ar_ = caml_call2(Base_Import[90], _aq_, left),
      left_child = caml_call2(Base_Import[90], _ar_, 1),
      _as_ = caml_call2(Base_Import[87], 2, relative_root),
      _at_ = caml_call2(Base_Import[90], _as_, left),
      right_child = caml_call2(Base_Import[90], _at_, 2);
     a:
     {
      if(left_child <= right){
       var _au_ = get(arr, root$0);
       if(0 < caml_call2(compare, get(arr, left_child), _au_)){var largest = left_child; break a;}
      }
      var largest = root$0;
     }
     a:
     {
      if(right_child <= right){
       var _av_ = get(arr, largest);
       if(0 < caml_call2(compare, get(arr, right_child), _av_)){var largest$0 = right_child; break a;}
      }
      var largest$0 = largest;
     }
     var _aw_ = largest$0 !== root$0 ? 1 : 0;
     if(! _aw_) return _aw_;
     swap$0(arr, root$0, largest$0);
     root$0 = largest$0;
    }
   }
   function sort$0(arr, compare, left, right){
    var
     _al_ = caml_call2(Base_Import[90], left, right),
     _am_ = caml_call2(Base_Import[94], _al_, 2);
    if(_am_ >= left){
     var i = _am_;
     for(;;){
      heapify(arr, compare, i, left, right);
      var _an_ = i - 1 | 0;
      if(left === i) break;
      i = _an_;
     }
    }
    var _ao_ = caml_call2(Base_Import[90], left, 1);
    if(right >= _ao_){
     var i$0 = right;
     for(;;){
      swap$0(arr, left, i$0);
      heapify(arr, compare, left, left, caml_call2(Base_Import[92], i$0, 1));
      var _ap_ = i$0 - 1 | 0;
      if(_ao_ === i$0) break;
      i$0 = _ap_;
     }
    }
    return 0;
   }
   var Heap_sort = [0, sort$0];
   function five_element_sort(arr, compare, m1, m2, m3, m4, m5){
    function compare_and_swap(i, j){
     var
      _aj_ = get(arr, j),
      _ak_ = 0 < caml_call2(compare, get(arr, i), _aj_) ? 1 : 0;
     return _ak_ ? swap$0(arr, i, j) : _ak_;
    }
    compare_and_swap(m1, m2);
    compare_and_swap(m4, m5);
    compare_and_swap(m1, m3);
    compare_and_swap(m2, m3);
    compare_and_swap(m1, m4);
    compare_and_swap(m3, m4);
    compare_and_swap(m2, m5);
    compare_and_swap(m2, m3);
    return compare_and_swap(m4, m5);
   }
   function intro_sort(arr, max_depth, compare, left, right){
    var max_depth$0 = max_depth, left$0 = left;
    for(;;){
     var
      _ai_ = caml_call2(Base_Import[92], right, left$0),
      len = caml_call2(Base_Import[90], _ai_, 1);
     if(32 >= len)
      return caml_call4(Insertion_sort[1], arr, compare, left$0, right);
     if(0 > max_depth$0)
      return caml_call4(Heap_sort[1], arr, compare, left$0, right);
     var
      max_depth$1 = caml_call2(Base_Import[92], max_depth$0, 1),
      _ah_ = caml_call2(Base_Import[92], right, left$0),
      sixth = caml_call2(Base_Import[94], _ah_, 6),
      m1 = caml_call2(Base_Import[90], left$0, sixth),
      m2 = caml_call2(Base_Import[90], m1, sixth),
      m3 = caml_call2(Base_Import[90], m2, sixth),
      m4 = caml_call2(Base_Import[90], m3, sixth),
      m5 = caml_call2(Base_Import[90], m4, sixth);
     five_element_sort(arr, compare, m1, m2, m3, m4, m5);
     var
      m2_val = get(arr, m2),
      m3_val = get(arr, m3),
      m4_val = get(arr, m4),
      match =
        0 === caml_call2(compare, m2_val, m3_val)
         ? [0, m2_val, m3_val, 1]
         : 0
           === caml_call2(compare, m3_val, m4_val)
           ? [0, m3_val, m4_val, 1]
           : [0, m2_val, m4_val, 0],
      middle_sorted = match[3],
      pivot2 = match[2],
      pivot1 = match[1],
      l$0 = left$0,
      p$1 = left$0,
      r$2 = right;
     for(;;){
      if(r$2 < p$1) break;
      var pv = get(arr, p$1);
      if(0 <= caml_call2(compare, pv, pivot1))
       if(0 < caml_call2(compare, pv, pivot2)){
        var r = r$2;
        for(;;){
         if(p$1 >= r) break;
         if(0 >= caml_call2(compare, get(arr, r), pivot2)) break;
         var r$0 = caml_call2(Base_Import[92], r, 1);
         r = r$0;
        }
        swap$0(arr, r, p$1);
        var r$1 = caml_call2(Base_Import[92], r, 1);
        r$2 = r$1;
       }
       else{var p = caml_call2(Base_Import[90], p$1, 1); p$1 = p;}
      else{
       swap$0(arr, p$1, l$0);
       var
        p$0 = caml_call2(Base_Import[90], p$1, 1),
        l = caml_call2(Base_Import[90], l$0, 1);
       l$0 = l;
       p$1 = p$0;
      }
     }
     intro_sort
      (arr, max_depth$1, compare, left$0, caml_call2(Base_Import[92], l$0, 1));
     if(1 - middle_sorted) intro_sort(arr, max_depth$1, compare, l$0, r$2);
     var left$1 = caml_call2(Base_Import[90], r$2, 1);
     max_depth$0 = max_depth$1;
     left$0 = left$1;
    }
   }
   function sort$1(arr, compare, left, right){
    return intro_sort(arr, 32, compare, left, right);
   }
   var
    Intro_sort = [0, sort$1, five_element_sort],
    _a_ = [0, cst_src_array_ml, 435, 14],
    _b_ =
      [0,
       [11,
        "length mismatch in ",
        [2, 0, [11, ": ", [4, 0, 0, 0, [11, " <> ", [4, 0, 0, 0, 0]]]]]],
       "length mismatch in %s: %d <> %d"],
    cst_Array_iter2_exn = "Array.iter2_exn",
    cst_Array_map2_exn = "Array.map2_exn",
    cst_Array_fold2_exn = "Array.fold2_exn",
    cst_Array_exists2_exn = "Array.exists2_exn",
    cst_Array_for_all2_exn = "Array.for_all2_exn",
    _c_ = [0, "Array.findi_exn: not found"],
    _d_ = [0, "Array.find_exn: not found"];
   function sort$2(pos, len, arr, compare){
    var
     match =
       caml_call4
        (Base_Ordered_collection_common[1], pos, len, 0, arr.length - 1),
     len$0 = match[2],
     pos$0 = match[1],
     _af_ = caml_call2(Base_Import[90], pos$0, len$0),
     _ag_ = caml_call2(Base_Import[92], _af_, 1);
    return caml_call4(Intro_sort[1], arr, compare, pos$0, _ag_);
   }
   function to_array(t){return t;}
   function is_empty(t){return 0 === t.length - 1 ? 1 : 0;}
   function is_sorted(t, compare){
    var
     i = [0, caml_call2(Base_Import[92], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 < i[1] && result[1]){
      var
       elt_i = t[1 + i[1]],
       elt_i_minus_1 = t[1 + caml_call2(Base_Import[92], i[1], 1)];
      if(0 < caml_call2(compare, elt_i_minus_1, elt_i)) result[1] = 0;
      caml_call1(Base_Import[128], i);
      continue;
     }
     return result[1];
    }
   }
   function is_sorted_strictly(t, compare){
    var
     i = [0, caml_call2(Base_Import[92], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 < i[1] && result[1]){
      var
       elt_i = t[1 + i[1]],
       elt_i_minus_1 = t[1 + caml_call2(Base_Import[92], i[1], 1)];
      if(0 <= caml_call2(compare, elt_i_minus_1, elt_i)) result[1] = 0;
      caml_call1(Base_Import[128], i);
      continue;
     }
     return result[1];
    }
   }
   function merge(a1, a2, compare){
    var l1 = a1.length - 1, l2 = a2.length - 1;
    if(0 === l1) return caml_call1(copy, a2);
    if(0 === l2) return caml_call1(copy, a1);
    var _aa_ = a1[1 + caml_call2(Base_Import[92], l1, 1)];
    if(0 <= caml_call2(compare, a2[1], _aa_))
     return caml_call2(append, a1, a2);
    var _ab_ = a2[1 + caml_call2(Base_Import[92], l2, 1)];
    if(0 < caml_call2(compare, a1[1], _ab_))
     return caml_call2(append, a2, a1);
    var
     len = caml_call2(Base_Import[90], l1, l2),
     merged = caml_call2(create, len, a1[1]),
     a1_index = [0, 0],
     a2_index = [0, 0],
     _ad_ = caml_call2(Base_Import[92], len, 1),
     _ac_ = 0;
    if(_ad_ >= 0){
     var i = _ac_;
     for(;;){
      var
       use_a1 =
         l1 === a1_index[1]
          ? 0
          : l2
            === a2_index[1]
            ? 1
            : caml_call2
               (compare, a1[1 + a1_index[1]], a2[1 + a2_index[1]])
              <= 0
              ? 1
              : 0;
      if(use_a1){
       merged[1 + i] = a1[1 + a1_index[1]];
       a1_index[1] = caml_call2(Base_Import[90], a1_index[1], 1);
      }
      else{
       merged[1 + i] = a2[1 + a2_index[1]];
       a2_index[1] = caml_call2(Base_Import[90], a2_index[1], 1);
      }
      var _ae_ = i + 1 | 0;
      if(_ad_ === i) break;
      i = _ae_;
     }
    }
    return merged;
   }
   function copy_matrix(_$_){return caml_call2(map, _$_, copy);}
   function folding_map(t, init, f){
    var acc = [0, init];
    return caml_call2
            (map,
             t,
             function(x){
              var
               match = caml_call2(f, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_map(t, init, f){
    var
     acc = [0, init],
     result =
       caml_call2
        (map,
         t,
         function(x){
          var
           match = caml_call2(f, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f){
    var _Z_ = caml_call3(Base_Container[9], fold, init, f);
    return function(___){return caml_call2(_Z_, ___, t);};
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function foldi(t, init, f){
    var
     acc = [0, init],
     _X_ = caml_call2(Base_Import[92], t.length - 1, 1),
     _W_ = 0;
    if(_X_ >= 0){
     var i = _W_;
     for(;;){
      acc[1] = caml_call3(f, i, acc[1], t[1 + i]);
      var _Y_ = i + 1 | 0;
      if(_X_ === i) break;
      i = _Y_;
     }
    }
    return acc[1];
   }
   function folding_mapi(t, init, f){
    var acc = [0, init];
    return caml_call2
            (mapi,
             t,
             function(i, x){
              var
               match = caml_call3(f, i, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_mapi(t, init, f){
    var
     acc = [0, init],
     result =
       caml_call2
        (mapi,
         t,
         function(i, x){
          var
           match = caml_call3(f, i, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function counti(t, f){
    return foldi
            (t,
             0,
             function(idx, count, a){
              return caml_call2(f, idx, a)
                      ? caml_call2(Base_Import[90], count, 1)
                      : count;
             });
   }
   function concat_map(t, f){
    return caml_call1(concat, caml_call1(to_list, caml_call2(map, t, f)));
   }
   function concat_mapi(t, f){
    return caml_call1(concat, caml_call1(to_list, caml_call2(mapi, t, f)));
   }
   function rev_inplace(t){
    var i = [0, 0], j = [0, caml_call2(Base_Import[92], t.length - 1, 1)];
    for(;;){
     if(i[1] >= j[1]) return 0;
     caml_call3(swap, t, i[1], j[1]);
     caml_call1(Base_Import[129], i);
     caml_call1(Base_Import[128], j);
    }
   }
   function rev(t){
    var t$0 = caml_call1(copy, t);
    rev_inplace(t$0);
    return t$0;
   }
   function of_list_rev(l){
    if(! l) return [0];
    var
     l$0 = l[2],
     a = l[1],
     _T_ = caml_call1(Base_List[7], l$0),
     len = caml_call2(Base_Import[90], 1, _T_),
     t = caml_call2(create, len, a),
     r = [0, l$0],
     _U_ = caml_call2(Base_Import[92], len, 2);
    if(_U_ >= 0){
     var i = _U_;
     for(;;){
      var match = r[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      var l$1 = match[2], a$0 = match[1];
      caml_check_bound(t, i)[1 + i] = a$0;
      r[1] = l$1;
      var _V_ = i - 1 | 0;
      if(0 === i) break;
      i = _V_;
     }
    }
    return t;
   }
   function of_list_map(xs, f){
    if(! xs) return [0];
    var
     tl = xs[2],
     hd = xs[1],
     _R_ = caml_call1(f, hd),
     _S_ = caml_call1(Base_List[7], tl),
     a = caml_call2(create, caml_call2(Base_Import[90], 1, _S_), _R_),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = caml_call1(f, hd$0);
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     param = tl$0;
    }
   }
   function of_list_mapi(xs, f){
    if(! xs) return [0];
    var
     tl = xs[2],
     hd = xs[1],
     _P_ = caml_call2(f, 0, hd),
     _Q_ = caml_call1(Base_List[7], tl),
     a = caml_call2(create, caml_call2(Base_Import[90], 1, _Q_), _P_),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = caml_call2(f, i, hd$0);
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     param = tl$0;
    }
   }
   function of_list_rev_map(xs, f){
    var t = of_list_map(xs, f);
    rev_inplace(t);
    return t;
   }
   function of_list_rev_mapi(xs, f){
    var t = of_list_mapi(xs, f);
    rev_inplace(t);
    return t;
   }
   function filter_mapi(t, f){
    var
     r = [0, [0]],
     k = [0, 0],
     _N_ = caml_call2(Base_Import[92], t.length - 1, 1),
     _M_ = 0;
    if(_N_ >= 0){
     var i = _M_;
     for(;;){
      var match = caml_call2(f, i, t[1 + i]);
      if(match){
       var a = match[1];
       if(0 === k[1]) r[1] = caml_call2(create, t.length - 1, a);
       r[1][1 + k[1]] = a;
       caml_call1(Base_Import[129], k);
      }
      var _O_ = i + 1 | 0;
      if(_N_ === i) break;
      i = _O_;
     }
    }
    return k[1] === t.length - 1
            ? r[1]
            : 0 < k[1] ? caml_call3(sub, r[1], 0, k[1]) : [0];
   }
   function filter_map(t, f){
    return filter_mapi(t, function(i, a){return caml_call1(f, a);});
   }
   function filter_opt(t){return filter_map(t, function(_L_){return _L_;});}
   function check_length2_exn(name, t1, t2){
    var n1 = t1.length - 1, n2 = t2.length - 1, _K_ = n1 !== n2 ? 1 : 0;
    return _K_ ? caml_call5(invalid_argf, _b_, name, n1, n2, 0) : _K_;
   }
   function iter2_exn(t1, t2, f){
    check_length2_exn(cst_Array_iter2_exn, t1, t2);
    return caml_call2
            (iteri, t1, function(i, x1){return caml_call2(f, x1, t2[1 + i]);});
   }
   function map2_exn(t1, t2, f){
    check_length2_exn(cst_Array_map2_exn, t1, t2);
    return caml_call2
            (init,
             t1.length - 1,
             function(i){return caml_call2(f, t1[1 + i], t2[1 + i]);});
   }
   function fold2_exn(t1, t2, init, f){
    check_length2_exn(cst_Array_fold2_exn, t1, t2);
    return foldi
            (t1,
             init,
             function(i, ac, x){return caml_call3(f, ac, x, t2[1 + i]);});
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function filteri(t, f){
    return filter_mapi
            (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : 0;});
   }
   function exists(t, f){
    var
     i = [0, caml_call2(Base_Import[92], t.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call1(f, t[1 + i[1]])){result[1] = 1; continue;}
      caml_call1(Base_Import[128], i);
      continue;
     }
     return result[1];
    }
   }
   function existsi(t, f){
    var
     i = [0, caml_call2(Base_Import[92], t.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call2(f, i[1], t[1 + i[1]])){result[1] = 1; continue;}
      caml_call1(Base_Import[128], i);
      continue;
     }
     return result[1];
    }
   }
   function mem(t, a, equal){return exists(t, caml_call1(equal, a));}
   function for_all(t, f){
    var
     i = [0, caml_call2(Base_Import[92], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call1(f, t[1 + i[1]])){
       caml_call1(Base_Import[128], i);
       continue;
      }
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function for_alli(t, f){
    var
     length = t.length - 1,
     i = [0, caml_call2(Base_Import[92], length, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call2(f, i[1], t[1 + i[1]])){
       caml_call1(Base_Import[128], i);
       continue;
      }
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function exists2_exn(t1, t2, f){
    check_length2_exn(cst_Array_exists2_exn, t1, t2);
    var
     i = [0, caml_call2(Base_Import[92], t1.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call2(f, t1[1 + i[1]], t2[1 + i[1]])){result[1] = 1; continue;}
      caml_call1(Base_Import[128], i);
      continue;
     }
     return result[1];
    }
   }
   function for_all2_exn(t1, t2, f){
    check_length2_exn(cst_Array_for_all2_exn, t1, t2);
    var
     i = [0, caml_call2(Base_Import[92], t1.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call2(f, t1[1 + i[1]], t2[1 + i[1]])){caml_call1(Base_Import[128], i); continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function equal(equal, t1, t2){
    var _J_ = t1.length - 1 === t2.length - 1 ? 1 : 0;
    return _J_ ? for_all2_exn(t1, t2, equal) : _J_;
   }
   function map_inplace(t, f){
    var _H_ = caml_call2(Base_Import[92], t.length - 1, 1), _G_ = 0;
    if(_H_ >= 0){
     var i = _G_;
     for(;;){
      t[1 + i] = caml_call1(f, t[1 + i]);
      var _I_ = i + 1 | 0;
      if(_H_ === i) break;
      i = _I_;
     }
    }
    return 0;
   }
   function findi_internal(t, f, if_found, if_not_found){
    var length = t.length - 1;
    if(0 === length) return caml_call1(if_not_found, 0);
    var i = [0, 0], found = [0, 0], value_found = [0, t[1]];
    for(;;){
     if(! found[1] && i[1] < length){
      var value = t[1 + i[1]];
      if(caml_call2(f, i[1], value)){
       value_found[1] = value;
       found[1] = 1;
      }
      else
       caml_call1(Base_Import[129], i);
      continue;
     }
     return found[1]
             ? caml_call2(if_found, i[1], value_found[1])
             : caml_call1(if_not_found, 0);
    }
   }
   function findi(t, f){
    return findi_internal
            (t,
             f,
             function(i, value){return [0, [0, i, value]];},
             function(param){return 0;});
   }
   function findi_exn(t, f){
    return findi_internal
            (t,
             f,
             function(i, value){return [0, i, value];},
             function(param){
              throw caml_maybe_attach_backtrace([0, Base_Import[251], _c_], 1);
             });
   }
   function find_exn(t, f){
    return findi_internal
            (t,
             function(i, x){return caml_call1(f, x);},
             function(param, value){return value;},
             function(param){
              throw caml_maybe_attach_backtrace([0, Base_Import[251], _d_], 1);
             });
   }
   function find(t, f){
    var _F_ = findi(t, function(i, x){return caml_call1(f, x);});
    return caml_call2
            (Base_Option[21],
             _F_,
             function(param){var x = param[2]; return x;});
   }
   function find_map(t, f){
    var length = t.length - 1;
    if(0 === length) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[49], value_found[1]) && i[1] < length){
      var value = t[1 + i[1]];
      value_found[1] = caml_call1(f, value);
      caml_call1(Base_Import[129], i);
      continue;
     }
     return value_found[1];
    }
   }
   var
    not_found = [0, Base_Import[251], [0, "Array.find_map_exn: not found"]];
   function find_map_exn(t, f){
    var match = find_map(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var x = match[1];
    return x;
   }
   function find_mapi(t, f){
    var length = t.length - 1;
    if(0 === length) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[49], value_found[1]) && i[1] < length){
      var value = t[1 + i[1]];
      value_found[1] = caml_call2(f, i[1], value);
      caml_call1(Base_Import[129], i);
      continue;
     }
     return value_found[1];
    }
   }
   var
    not_found$0 = [0, Base_Import[251], [0, "Array.find_mapi_exn: not found"]],
    cst_Array_reduce_exn = "Array.reduce_exn";
   function find_mapi_exn(t, f){
    var match = find_mapi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$0, 1);
    var x = match[1];
    return x;
   }
   function find_consecutive_duplicate(t, equal){
    var n = t.length - 1;
    if(1 >= n) return 0;
    var result = [0, 0], i = [0, 1], prev = [0, t[1]];
    for(;;){
     if(i[1] >= n) return result[1];
     var cur = t[1 + i[1]];
     if(caml_call2(equal, cur, prev[1])){
      result[1] = [0, [0, prev[1], cur]];
      i[1] = n;
     }
     else{prev[1] = cur; caml_call1(Base_Import[129], i);}
    }
   }
   function reduce(t, f){
    if(0 === t.length - 1) return 0;
    var
     r = [0, t[1]],
     _D_ = caml_call2(Base_Import[92], t.length - 1, 1),
     _C_ = 1;
    if(_D_ >= 1){
     var i = _C_;
     for(;;){
      r[1] = caml_call2(f, r[1], t[1 + i]);
      var _E_ = i + 1 | 0;
      if(_D_ === i) break;
      i = _E_;
     }
    }
    return [0, r[1]];
   }
   function reduce_exn(t, f){
    var match = reduce(t, f);
    if(! match) return caml_call1(Base_Import[125], cst_Array_reduce_exn);
    var v = match[1];
    return v;
   }
   var
    permute = Base_Array_permute[24],
    cst_Array_random_element_exn_e = "Array.random_element_exn: empty array",
    cst_Array_zip_exn = "Array.zip_exn",
    cst_Array_transpose_exn = "Array.transpose_exn";
   function random_element_exn(opt, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    if(is_empty(t))
     return caml_call1(Base_Import[123], cst_Array_random_element_exn_e);
    var _B_ = caml_call2(Base_Random[18][6], random_state, t.length - 1);
    return caml_check_bound(t, _B_)[1 + _B_];
   }
   function random_element(opt, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    try{var _z_ = [0, random_element_exn([0, random_state], t)]; return _z_;}
    catch(_A_){return 0;}
   }
   function zip(t1, t2){
    return t1.length - 1 !== t2.length - 1
            ? 0
            : [0, map2_exn(t1, t2, function(x1, x2){return [0, x1, x2];})];
   }
   function zip_exn(t1, t2){
    return t1.length - 1 !== t2.length - 1
            ? caml_call1(Base_Import[123], cst_Array_zip_exn)
            : map2_exn(t1, t2, function(x1, x2){return [0, x1, x2];});
   }
   function unzip(t){
    var n = t.length - 1;
    if(0 === n) return [0, [0], [0]];
    var
     match = caml_check_bound(t, 0)[1],
     y = match[2],
     x = match[1],
     res1 = caml_call2(create, n, x),
     res2 = caml_call2(create, n, y),
     _x_ = caml_call2(Base_Import[92], n, 1),
     _w_ = 1;
    if(_x_ >= 1){
     var i = _w_;
     for(;;){
      var
       match$0 = caml_check_bound(t, i)[1 + i],
       y$0 = match$0[2],
       x$0 = match$0[1];
      caml_check_bound(res1, i)[1 + i] = x$0;
      caml_check_bound(res2, i)[1 + i] = y$0;
      var _y_ = i + 1 | 0;
      if(_x_ === i) break;
      i = _y_;
     }
    }
    return [0, res1, res2];
   }
   function sorted_copy(t, compare){
    var t1 = caml_call1(copy, t);
    sort$2(0, 0, t1, compare);
    return t1;
   }
   function partitioni_tf(t, f){
    var
     both =
       caml_call2
        (mapi,
         t,
         function(i, x){return caml_call2(f, i, x) ? [0, x] : [1, x];}),
     trues =
       filter_map
        (both,
         function(param){
          if(0 !== param[0]) return 0;
          var x = param[1];
          return [0, x];
         }),
     falses =
       filter_map
        (both,
         function(param){
          if(0 === param[0]) return 0;
          var x = param[1];
          return [0, x];
         });
    return [0, trues, falses];
   }
   function partition_tf(t, f){
    return partitioni_tf(t, function(i, x){return caml_call1(f, x);});
   }
   function last(t){
    var _v_ = caml_call2(Base_Import[92], t.length - 1, 1);
    return caml_check_bound(t, _v_)[1 + _v_];
   }
   function to_sequence_mutable(t){
    return caml_call2
            (Base_Sequence[41],
             0,
             function(i){
              if(t.length - 1 <= i) return 0;
              var _u_ = caml_call2(Base_Import[90], i, 1);
              return [1, caml_check_bound(t, i)[1 + i], _u_];
             });
   }
   function to_sequence(t){return to_sequence_mutable(caml_call1(copy, t));}
   function cartesian_product(t1, t2){
    if(! is_empty(t1) && ! is_empty(t2)){
     var
      n1 = t1.length - 1,
      n2 = t2.length - 1,
      _j_ = caml_check_bound(t2, 0)[1],
      _k_ = [0, caml_check_bound(t1, 0)[1], _j_],
      t = caml_call2(create, caml_call2(Base_Import[87], n1, n2), _k_),
      r = [0, 0],
      _m_ = caml_call2(Base_Import[92], n1, 1),
      _l_ = 0;
     if(_m_ >= 0){
      var i1 = _l_;
      for(;;){
       var _o_ = caml_call2(Base_Import[92], n2, 1), _n_ = 0;
       if(_o_ >= 0){
        var i2 = _n_;
        for(;;){
         var
          _q_ = caml_check_bound(t2, i2)[1 + i2],
          _r_ = [0, caml_check_bound(t1, i1)[1 + i1], _q_],
          _s_ = r[1];
         caml_check_bound(t, _s_)[1 + _s_] = _r_;
         caml_call1(Base_Import[129], r);
         var _t_ = i2 + 1 | 0;
         if(_o_ === i2) break;
         i2 = _t_;
        }
       }
       var _p_ = i1 + 1 | 0;
       if(_m_ === i1) break;
       i1 = _p_;
      }
     }
     return t;
    }
    return [0];
   }
   function transpose(tt){
    if(0 === tt.length - 1) return [0, [0]];
    var width = tt.length - 1, depth = caml_check_bound(tt, 0)[1].length - 1;
    return exists(tt, function(t){return t.length - 1 !== depth ? 1 : 0;})
            ? 0
            : [0,
              caml_call2
               (init,
                depth,
                function(d){
                 return caml_call2
                         (init,
                          width,
                          function(w){
                           return caml_check_bound(caml_check_bound(tt, w)[1 + w], d)
                                   [1 + d];
                          });
                })];
   }
   function transpose_exn(tt){
    var match = transpose(tt);
    if(! match) return caml_call1(Base_Import[125], cst_Array_transpose_exn);
    var tt$0 = match[1];
    return tt$0;
   }
   function get$0(_i_, _h_){return caml_check_bound(_i_, _h_)[1 + _h_];}
   function length(_g_){return _g_.length - 1;}
   var
    include = caml_call1(Base_Binary_searchable[2], [0, get$0, length]),
    binary_search = include[1],
    binary_search_segmented = include[2],
    _e_ = [0, cst_src_array_ml, 858, 8];
   function length$0(_f_){return _f_.length - 1;}
   function create_like(len, t){
    if(0 === len) return [0];
    if(0 < t.length - 1)
     return caml_call2(create, len, caml_check_bound(t, 0)[1]);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   var
    unsafe_blit = runtime.caml_array_blit,
    include$0 =
      caml_call1(Base_Blit[4], [0, create_like, length$0, unsafe_blit]),
    blit = include$0[1],
    blito = include$0[2],
    unsafe_blit$0 = include$0[3],
    sub$0 = include$0[4],
    subo = include$0[5];
   function invariant(invariant_a, t){
    return caml_call2(iter, t, invariant_a);
   }
   var
    Base_Array =
      [0,
       compare,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       binary_search,
       binary_search_segmented,
       mem,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       invariant,
       max_length,
       create,
       create_float_uninitialized,
       init,
       make_matrix,
       copy_matrix,
       append,
       concat,
       copy,
       fill,
       blit,
       blito,
       unsafe_blit$0,
       sub$0,
       subo,
       of_list,
       map,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       iteri,
       mapi,
       foldi,
       fold_right,
       sort$2,
       stable_sort,
       is_sorted,
       is_sorted_strictly,
       merge,
       concat_map,
       concat_mapi,
       partition_tf,
       partitioni_tf,
       cartesian_product,
       transpose,
       transpose_exn,
       filter_opt,
       filter_map,
       filter_mapi,
       for_alli,
       existsi,
       counti,
       iter2_exn,
       map2_exn,
       fold2_exn,
       for_all2_exn,
       exists2_exn,
       filter,
       filteri,
       swap,
       rev_inplace,
       rev,
       of_list_rev,
       of_list_map,
       of_list_mapi,
       of_list_rev_map,
       of_list_rev_mapi,
       map_inplace,
       find_exn,
       find_map_exn,
       findi,
       findi_exn,
       find_mapi,
       find_mapi_exn,
       find_consecutive_duplicate,
       reduce,
       reduce_exn,
       permute,
       random_element,
       random_element_exn,
       zip,
       zip_exn,
       unzip,
       sorted_copy,
       last,
       equal,
       to_sequence,
       to_sequence_mutable,
       [0, [0, Insertion_sort, Heap_sort, Intro_sort]]];
   runtime.caml_register_global(28, Base_Array, "Base__Array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Obj_array
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Blit, Base__Import, Base__Int0, Base__String0, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Array0 = global_data.Base__Array0,
    Base_Int0 = global_data.Base__Int0,
    Base_String0 = global_data.Base__String0,
    Assert_failure = global_data.Assert_failure,
    Base_Blit = global_data.Base__Blit,
    _a_ = [0, "src/obj_array.ml", 11, 18],
    _b_ = [0, ">", 0],
    cst_Obj_array_t_of_length = "<Obj_array.t of length ",
    _c_ = [0, ""];
   function invariant(t){
    var _t_ = Stdlib_Obj[15];
    if(caml_obj_tag(t) !== _t_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function length(_s_){return _s_.length - 1;}
   function sexp_of_t(t){
    var
     _r_ =
       [0,
        cst_Obj_array_t_of_length,
        [0, caml_call1(Base_Int0[1], t.length - 1), _b_]];
    return [0, caml_call2(Base_String0[14], _c_, _r_)];
   }
   var zero_obj = 0;
   function create_zero(len){
    return caml_call2(Base_Array0[4], len, zero_obj);
   }
   var empty = [0];
   function get(t, i){return caml_check_bound(t, i)[1 + i];}
   function unsafe_get(t, i){return t[1 + i];}
   function unsafe_set_with_caml_modify(t, i, obj){t[1 + i] = obj; return 0;}
   function set_with_caml_modify(t, i, obj){
    caml_check_bound(t, i)[1 + i] = obj;
    return 0;
   }
   function unsafe_set_int_assuming_curren(t, i, int$0){t[1 + i] = int$0; return 0;
   }
   function set(t, i, obj){
    var old_obj = get(t, i);
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    var _q_ = 1 - caml_call2(Base_Import[127], old_obj, obj);
    return _q_ ? unsafe_set_with_caml_modify(t, i, obj) : _q_;
   }
   function unsafe_set(t, i, obj){
    var old_obj = t[1 + i];
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    var _p_ = 1 - caml_call2(Base_Import[127], old_obj, obj);
    return _p_ ? unsafe_set_with_caml_modify(t, i, obj) : _p_;
   }
   function unsafe_set_omit_phys_equal_che(t, i, obj){
    var old_obj = t[1 + i];
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    return unsafe_set_with_caml_modify(t, i, obj);
   }
   function swap(t, i, j){
    var a = get(t, i), b = get(t, j);
    unsafe_set(t, i, b);
    return unsafe_set(t, j, a);
   }
   function create(len, x){
    var _l_ = Stdlib_Obj[14];
    if(caml_obj_tag(x) !== _l_) return caml_call2(Base_Array0[4], len, x);
    var
     t = create_zero(len),
     _n_ = caml_call2(Base_Import[92], len, 1),
     _m_ = 0;
    if(_n_ >= 0){
     var i = _m_;
     for(;;){
      unsafe_set_with_caml_modify(t, i, x);
      var _o_ = i + 1 | 0;
      if(_n_ === i) break;
      i = _o_;
     }
    }
    return t;
   }
   function singleton(obj){return create(1, obj);}
   function unsafe_set_assuming_currently_(t, i, obj){
    return typeof obj === "number"
            ? unsafe_set_int_assuming_curren(t, i, obj)
            : unsafe_set_with_caml_modify(t, i, obj);
   }
   function unsafe_set_int(t, i, int$0){
    var old_obj = t[1 + i];
    return typeof old_obj === "number"
            ? unsafe_set_int_assuming_curren(t, i, int$0)
            : unsafe_set_with_caml_modify(t, i, int$0);
   }
   function unsafe_clear_if_pointer(t, i){
    var old_obj = t[1 + i], _k_ = 1 - (typeof old_obj === "number" ? 1 : 0);
    return _k_ ? unsafe_set_with_caml_modify(t, i, 0) : _k_;
   }
   function unsafe_blit(src, src_pos, dst, dst_pos, len){
    if(dst_pos < src_pos){
     var _e_ = caml_call2(Base_Import[92], len, 1), _d_ = 0;
     if(_e_ >= 0){
      var i = _d_;
      for(;;){
       var i$0 = caml_call2(Base_Import[90], src_pos, i), _i_ = src[1 + i$0];
       unsafe_set(dst, caml_call2(Base_Import[90], dst_pos, i), _i_);
       var _f_ = i + 1 | 0;
       if(_e_ === i) break;
       i = _f_;
      }
     }
     return 0;
    }
    var _g_ = caml_call2(Base_Import[92], len, 1);
    if(_g_ >= 0){
     var i$1 = _g_;
     for(;;){
      var i$2 = caml_call2(Base_Import[90], src_pos, i$1), _j_ = src[1 + i$2];
      unsafe_set(dst, caml_call2(Base_Import[90], dst_pos, i$1), _j_);
      var _h_ = i$1 - 1 | 0;
      if(0 === i$1) break;
      i$1 = _h_;
     }
    }
    return 0;
   }
   var
    include = caml_call1(Base_Blit[1], [0, length, create_zero, unsafe_blit]),
    blit = include[1],
    blito = include[2],
    unsafe_blit$0 = include[3],
    sub = include[4],
    subo = include[5];
   function copy(src){
    var dst = create_zero(src.length - 1);
    caml_call6(blito, src, 0, 0, dst, 0, 0);
    return dst;
   }
   var
    Base_Obj_array =
      [0,
       sexp_of_t,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       invariant,
       create,
       create_zero,
       copy,
       singleton,
       empty,
       length,
       get,
       unsafe_get,
       set,
       unsafe_set,
       swap,
       set_with_caml_modify,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       unsafe_clear_if_pointer];
   runtime.caml_register_global(12, Base_Obj_array, "Base__Obj_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uniform_array
//# unitInfo: Requires: Assert_failure, Base__Array, Base__Blit, Base__Container, Base__Import, Base__List, Base__Obj_array, Base__Sexpable, Sexplib0__Sexp_grammar, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_uniform_array_ml = "src/uniform_array.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Container = global_data.Base__Container,
    Assert_failure = global_data.Assert_failure,
    Base_Array = global_data.Base__Array,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_List = global_data.Base__List,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Obj_array = global_data.Base__Obj_array,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Blit = global_data.Base__Blit,
    empty = Base_Obj_array[12];
   function unsafe_create_uninitialized(len){
    return caml_call1(Base_Obj_array[9], len);
   }
   function create_obj_array(len){return caml_call1(Base_Obj_array[9], len);}
   function create(len, x){return caml_call2(Base_Obj_array[8], len, x);}
   function singleton(x){return caml_call1(Base_Obj_array[11], x);}
   function swap(t, i, j){return caml_call3(Base_Obj_array[18], t, i, j);}
   function get(arr, i){return caml_call2(Base_Obj_array[14], arr, i);}
   function set(arr, i, x){return caml_call3(Base_Obj_array[16], arr, i, x);}
   function unsafe_get(arr, i){return caml_call2(Base_Obj_array[15], arr, i);}
   function unsafe_set(arr, i, x){
    return caml_call3(Base_Obj_array[17], arr, i, x);
   }
   function unsafe_set_int(arr, i, x){
    return caml_call3(Base_Obj_array[22], arr, i, x);
   }
   function unsafe_set_int_assuming_curren(arr, i, x){return caml_call3(Base_Obj_array[21], arr, i, x);
   }
   function unsafe_set_assuming_currently_(arr, i, x){return caml_call3(Base_Obj_array[20], arr, i, x);
   }
   var
    length = Base_Obj_array[13],
    unsafe_blit = Base_Obj_array[4],
    copy = Base_Obj_array[10];
   function unsafe_set_omit_phys_equal_che(t, i, x){return caml_call3(Base_Obj_array[23], t, i, x);
   }
   function unsafe_set_with_caml_modify(t, i, x){
    return caml_call3(Base_Obj_array[24], t, i, x);
   }
   function set_with_caml_modify(t, i, x){
    return caml_call3(Base_Obj_array[19], t, i, x);
   }
   var
    unsafe_clear_if_pointer = Base_Obj_array[25],
    _a_ = [0, cst_src_uniform_array_ml, 71, 18],
    cst_Uniform_array_init = "Uniform_array.init",
    cst_Array_map2_exn = "Array.map2_exn";
   function invariant(t){
    var _H_ = Stdlib_Obj[15];
    if(runtime.caml_obj_tag(t) !== _H_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function init(l, f){
    if(0 > l) return caml_call1(Base_Import[125], cst_Uniform_array_init);
    var
     res = unsafe_create_uninitialized(l),
     _F_ = caml_call2(Base_Import[92], l, 1),
     _E_ = 0;
    if(_F_ >= 0){
     var i = _E_;
     for(;;){
      unsafe_set(res, i, caml_call1(f, i));
      var _G_ = i + 1 | 0;
      if(_F_ === i) break;
      i = _G_;
     }
    }
    return res;
   }
   function of_array(arr){
    return init(arr.length - 1, function(_D_){return arr[1 + _D_];});
   }
   function map(a, f){
    return init
            (caml_call1(length, a),
             function(i){return caml_call1(f, unsafe_get(a, i));});
   }
   function mapi(a, f){
    return init
            (caml_call1(length, a),
             function(i){return caml_call2(f, i, unsafe_get(a, i));});
   }
   function iter(a, f){
    var
     _A_ = caml_call1(length, a),
     _B_ = caml_call2(Base_Import[92], _A_, 1),
     _z_ = 0;
    if(_B_ >= 0){
     var i = _z_;
     for(;;){
      caml_call1(f, unsafe_get(a, i));
      var _C_ = i + 1 | 0;
      if(_B_ === i) break;
      i = _C_;
     }
    }
    return 0;
   }
   function iteri(a, f){
    var
     _w_ = caml_call1(length, a),
     _x_ = caml_call2(Base_Import[92], _w_, 1),
     _v_ = 0;
    if(_x_ >= 0){
     var i = _v_;
     for(;;){
      caml_call2(f, i, unsafe_get(a, i));
      var _y_ = i + 1 | 0;
      if(_x_ === i) break;
      i = _y_;
     }
    }
    return 0;
   }
   function foldi(a, init, f){
    var
     acc = [0, init],
     _r_ = caml_call1(length, a),
     _s_ = caml_call2(Base_Import[92], _r_, 1),
     _q_ = 0;
    if(_s_ >= 0){
     var i = _q_;
     for(;;){
      var _t_ = unsafe_get(a, i);
      acc[1] = caml_call3(f, i, acc[1], _t_);
      var _u_ = i + 1 | 0;
      if(_s_ === i) break;
      i = _u_;
     }
    }
    return acc[1];
   }
   function to_list(t){
    var _o_ = caml_call1(length, t);
    return caml_call2(Base_List[123], _o_, function(_p_){return get(t, _p_);});
   }
   function of_list(l){
    var
     len = caml_call1(Base_List[7], l),
     res = unsafe_create_uninitialized(len);
    caml_call2(Base_List[98], l, function(i, x){return set(res, i, x);});
    return res;
   }
   function to_array(t){
    var _n_ = caml_call1(length, t);
    return caml_call2
            (Base_Array[27], _n_, function(i){return unsafe_get(t, i);});
   }
   function exists(t, f){
    var
     _m_ = caml_call1(length, t),
     i$1 = caml_call2(Base_Import[92], _m_, 1),
     i = i$1;
    for(;;){
     if(0 > i) return 0;
     var _l_ = caml_call1(f, unsafe_get(t, i));
     if(_l_) return _l_;
     var i$0 = caml_call2(Base_Import[92], i, 1);
     i = i$0;
    }
   }
   function for_all(t, f){
    var
     _k_ = caml_call1(length, t),
     i$1 = caml_call2(Base_Import[92], _k_, 1),
     i = i$1;
    for(;;){
     if(0 > i) return 1;
     var _j_ = caml_call1(f, unsafe_get(t, i));
     if(! _j_) return _j_;
     var i$0 = caml_call2(Base_Import[92], i, 1);
     i = i$0;
    }
   }
   function map2_exn(t1, t2, f){
    var len = caml_call1(length, t1);
    if(caml_call1(length, t2) !== len)
     caml_call1(Base_Import[125], cst_Array_map2_exn);
    return init
            (len,
             function(i){
              var _i_ = unsafe_get(t2, i);
              return caml_call2(f, unsafe_get(t1, i), _i_);
             });
   }
   function t_sexp_grammar(grammar){
    var _h_ = caml_call1(Base_Array[4], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _h_);
   }
   var
    include =
      caml_call1
       (caml_call1(Base_Sexpable[2], [0, Base_Array[2], Base_Array[3]]),
        [0, to_array, of_array]),
    t_of_sexp = include[1],
    sexp_of_t = include[2],
    _b_ = [0, cst_src_uniform_array_ml, 164, 8];
   function create_like(len, t){
    if(0 === len) return empty;
    if(0 < caml_call1(length, t)) return create(len, get(t, 0));
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   var
    include$0 =
      caml_call1(Base_Blit[4], [0, create_like, length, unsafe_blit]),
    blit = include$0[1],
    blito = include$0[2],
    unsafe_blit$0 = include$0[3],
    sub = include$0[4],
    subo = include$0[5];
   function fold(t, init, f){
    var
     r = [0, init],
     _d_ = caml_call1(length, t),
     _e_ = caml_call2(Base_Import[92], _d_, 1),
     _c_ = 0;
    if(_e_ >= 0){
     var i = _c_;
     for(;;){
      var _f_ = unsafe_get(t, i);
      r[1] = caml_call2(f, r[1], _f_);
      var _g_ = i + 1 | 0;
      if(_e_ === i) break;
      i = _g_;
     }
    }
    return r[1];
   }
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function compare(compare_elt, a, b){
    if(caml_call2(Base_Import[127], a, b)) return 0;
    var
     len_a = caml_call1(length, a),
     len_b = caml_call1(length, b),
     ret = runtime.caml_int_compare(len_a, len_b);
    if(0 !== ret) return ret;
    var i = 0;
    for(;;){
     if(i === len_a) return 0;
     var
      l = unsafe_get(a, i),
      r = unsafe_get(b, i),
      res = caml_call2(compare_elt, l, r);
     if(0 !== res) return res;
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
    }
   }
   var
    Base_Uniform_array =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       invariant,
       empty,
       create,
       singleton,
       init,
       length,
       get,
       unsafe_get,
       set,
       unsafe_set,
       swap,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       set_with_caml_modify,
       map,
       mapi,
       iter,
       iteri,
       foldi,
       of_array,
       to_array,
       of_list,
       to_list,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       copy,
       unsafe_create_uninitialized,
       create_obj_array,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_clear_if_pointer,
       exists,
       for_all,
       map2_exn,
       min_elt,
       max_elt];
   runtime.caml_register_global(14, Base_Uniform_array, "Base__Uniform_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar0
//# unitInfo: Requires: Stdlib__Uchar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    succ = Stdlib_Uchar[5],
    pred = Stdlib_Uchar[6],
    is_valid = Stdlib_Uchar[7],
    is_char = Stdlib_Uchar[11],
    unsafe_to_char = Stdlib_Uchar[14],
    unsafe_of_int = Stdlib_Uchar[9],
    of_int = Stdlib_Uchar[8],
    to_int = Stdlib_Uchar[10],
    of_char = Stdlib_Uchar[12],
    compare = Stdlib_Uchar[16],
    equal = Stdlib_Uchar[15],
    min_value = Stdlib_Uchar[1],
    max_value = Stdlib_Uchar[2],
    Base_Uchar0 =
      [0,
       succ,
       pred,
       is_valid,
       is_char,
       unsafe_to_char,
       unsafe_of_int,
       of_int,
       to_int,
       of_char,
       compare,
       equal,
       min_value,
       max_value];
   runtime.caml_register_global(1, Base_Uchar0, "Base__Uchar0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Floatable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Floatable = [0];
   runtime.caml_register_global(0, Base_Floatable, "Base__Floatable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Float0
//# unitInfo: Requires: Assert_failure, Base__Import, Base__Import0, Base__Option, Base__Printf, Stdlib__Float, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_float0_ml = "src/float0.ml",
    caml_int64_bits_of_float = runtime.caml_int64_bits_of_float,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Assert_failure = global_data.Assert_failure,
    Base_Option = global_data.Base__Option,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Float = global_data.Stdlib__Float;
   function ceil(_p_){return Math.ceil(_p_);}
   function floor(_o_){return Math.floor(_o_);}
   function mod_float(_n_, _m_){return _n_ % _m_;}
   var
    modf = runtime.caml_modf_float,
    float_of_string = runtime.caml_float_of_string,
    nan = Base_Import[84][23],
    infinity = Base_Import[84][21],
    neg_infinity = Base_Import[84][22],
    max_finite_value = Base_Import[84][24],
    epsilon_float = Base_Import[84][26],
    classify_float = runtime.caml_classify_float;
   function abs_float(_l_){return Math.abs(_l_);}
   var
    is_integer = Stdlib_Float[16],
    _a_ =
      [0,
       [8,
        [0, 0, 0],
        0,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [8,
            [0, 0, 0],
            0,
            0,
            [11, " in float0.ml: modulus should be positive", 0]]]]]],
       "%f %% %f in float0.ml: modulus should be positive"];
   function symbol(_k_, _j_){return Math.pow(_k_, _j_);}
   function symbol$0(a, b){
    if(caml_call2(Base_Import[107][1], b, 0.))
     caml_call4(Base_Printf[7], _a_, a, b, 0);
    var m = a % b;
    return caml_call2(Base_Import[107][1], m, 0.)
            ? caml_call2(Base_Import[91], m, b)
            : m;
   }
   var
    frexp = runtime.caml_frexp_float,
    ldexp = runtime.caml_ldexp_float,
    _b_ = [0, runtime.caml_int64_create_lo_mi_hi(0, 0, 0)],
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    _e_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _f_ = [0, cst_src_float0_ml, 174, 4],
    _g_ = [0, cst_src_float0_ml, 170, 4];
   function is_nan(x){return caml_call2(Base_Import[107][3], x, x);}
   function to_int64_preserve_order(t){
    return is_nan(t)
            ? 0
            : caml_call2
               (Base_Import[107][4], t, 0.)
              ? _b_
              : caml_call2
                 (Base_Import[107][5], t, 0.)
                ? [0, caml_int64_bits_of_float(t)]
                : [0,
                  caml_int64_neg
                   (caml_int64_bits_of_float(caml_call1(Base_Import[113], t)))];
   }
   function to_int64_preserve_order_exn(x){
    var _i_ = to_int64_preserve_order(x);
    return caml_call4(Base_Option[28], 0, 0, 0, _i_);
   }
   function of_int64_preserve_order(x){
    return runtime.caml_greaterequal(x, _c_)
            ? caml_int64_float_of_bits(x)
            : caml_call1
              (Base_Import[113], caml_int64_float_of_bits(caml_int64_neg(x)));
   }
   function one_ulp(dir, t){
    var match = to_int64_preserve_order(t);
    if(! match) return Base_Import[84][23];
    var x = match[1], _h_ = 759637122 <= dir ? _d_ : _e_;
    return of_int64_preserve_order(runtime.caml_int64_add(x, _h_));
   }
   function upper_bound_for_int(num_bits){
    var exp = caml_call2(Base_Import[92], num_bits, 1);
    return one_ulp(759637122, Math.pow(2., exp));
   }
   function is_x_minus_one_exact(x){
    return 1
           -
            runtime.caml_equal
             (caml_int64_bits_of_float(x),
              caml_int64_bits_of_float(caml_call2(Base_Import[93], x, 1.)));
   }
   function lower_bound_for_int(num_bits){
    var
     exp = caml_call2(Base_Import[92], num_bits, 1),
     min_int_as_float = caml_call1(Base_Import[113], Math.pow(2., exp));
    if(53 <= caml_call2(Base_Import[92], num_bits, 1)){
     if(is_x_minus_one_exact(min_int_as_float))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     return min_int_as_float;
    }
    if(is_x_minus_one_exact(min_int_as_float))
     return one_ulp(19067, caml_call2(Base_Import[93], min_int_as_float, 1.));
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[107][1], t, min)
            ? min
            : caml_call2(Base_Import[107][1], max, t) ? max : t;
   }
   var x = 0.;
   function box(f){return caml_call2(Base_Import[91], f, x);}
   var
    include = Base_Import[107],
    symbol$1 = include[1],
    symbol$2 = include[2],
    symbol$3 = include[3],
    symbol$4 = include[4],
    symbol$5 = include[5],
    symbol$6 = include[6],
    ascending = include[7],
    descending = include[8],
    compare = include[9],
    equal = include[10],
    max = include[11],
    min = include[12],
    Base_Float0 =
      [0,
       ceil,
       floor,
       mod_float,
       modf,
       float_of_string,
       nan,
       infinity,
       neg_infinity,
       max_finite_value,
       epsilon_float,
       classify_float,
       abs_float,
       is_integer,
       symbol,
       symbol$0,
       frexp,
       ldexp,
       is_nan,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       upper_bound_for_int,
       is_x_minus_one_exact,
       lower_bound_for_int,
       clamp_unchecked,
       box,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       ascending,
       descending,
       compare,
       equal,
       max,
       min];
   runtime.caml_register_global(21, Base_Float0, "Base__Float0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Char
//# unitInfo: Requires: Base__Array0, Base__Char0, Base__Comparable, Base__Error, Base__Hash, Base__Identifiable, Base__Import, Base__Sexp, Base__String0, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Char",
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_String0 = global_data.Base__String0,
    Base_Char0 = global_data.Base__Char0,
    Base_Identifiable = global_data.Base__Identifiable,
    Base_Array0 = global_data.Base__Array0,
    Base_Comparable = global_data.Base__Comparable,
    failwithf = Base_Char0[1],
    escaped = Base_Char0[2],
    lowercase = Base_Char0[3],
    to_int = Base_Char0[4],
    unsafe_of_int = Base_Char0[5],
    uppercase = Base_Char0[6],
    min_value = Base_Char0[8],
    max_value = Base_Char0[9],
    of_int = Base_Char0[10],
    of_int_exn = Base_Char0[11],
    compare = Base_Import[226],
    hash_fold_t = Base_Import[205],
    func = Base_Import[219];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[164],
    sexp_of_t = Base_Import[140],
    t_sexp_grammar = Base_Import[184],
    _a_ = [0, [11, "Char.of_string: ", [3, 0, 0]], "Char.of_string: %S"];
   function to_string(t){return caml_call2(Base_String0[9], 1, t);}
   function of_string(s){
    return 1 === runtime.caml_ml_string_length(s)
            ? runtime.caml_string_get(s, 0)
            : caml_call3(failwithf, _a_, s, 0);
   }
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = include[1],
    hash$0 = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t$0 = include[4],
    of_string$0 = include[5],
    to_string$0 = include[6],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    hashable = include[24],
    _b_ = [0, [1, 0], "%C"];
   function pp(fmt, c){return caml_call3(Stdlib_Format[129], fmt, _b_, c);}
   function invariant(param){return 0;}
   var
    _c_ = caml_call2(Base_Array0[11], 256, unsafe_of_int),
    all = caml_call1(Base_Array0[15], _c_),
    _d_ =
      [0,
       [11, "Char.get_digit_exn ", [1, [11, ": not a digit", 0]]],
       "Char.get_digit_exn %C: not a digit"],
    cst_char = "char",
    cst_Char_get_hex_digit_exn_not =
      "Char.get_hex_digit_exn: not a hexadecimal digit";
   function is_lowercase(param){return 25 < param - 97 >>> 0 ? 0 : 1;}
   function is_uppercase(param){return 25 < param - 65 >>> 0 ? 0 : 1;}
   function is_print(param){return 94 < param - 32 >>> 0 ? 0 : 1;}
   function is_whitespace(param){
    a:
    {
     if(14 <= param){if(32 === param) break a;} else if(9 <= param) break a;
     return 0;
    }
    return 1;
   }
   function is_digit(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   function is_alpha(param){
    a:
    {
     if(91 <= param){
      if(25 < param - 97 >>> 0) break a;
     }
     else if(65 > param) break a;
     return 1;
    }
    return 0;
   }
   function is_alphanum(param){
    var _u_ = param - 48 | 0;
    a:
    {
     if(42 < _u_ >>> 0){
      if(25 < _u_ - 49 >>> 0) break a;
     }
     else if(6 >= _u_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function get_digit_unsafe(t){
    var _s_ = caml_call1(to_int, 48), _t_ = caml_call1(to_int, t);
    return caml_call2(Base_Import[92], _t_, _s_);
   }
   function get_digit_exn(t){
    return is_digit(t)
            ? get_digit_unsafe(t)
            : caml_call3(failwithf, _d_, t, 0);
   }
   function get_digit(t){return is_digit(t) ? [0, get_digit_unsafe(t)] : 0;}
   function is_hex_digit(param){
    var _r_ = param - 48 | 0;
    a:
    {
     if(22 < _r_ >>> 0){
      if(5 < _r_ - 49 >>> 0) break a;
     }
     else if(6 >= _r_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   function is_hex_digit_lower(param){
    a:
    {
     if(58 <= param){
      if(5 < param - 97 >>> 0) break a;
     }
     else if(48 > param) break a;
     return 1;
    }
    return 0;
   }
   function is_hex_digit_upper(param){
    a:
    {
     if(58 <= param){
      if(5 < param - 65 >>> 0) break a;
     }
     else if(48 > param) break a;
     return 1;
    }
    return 0;
   }
   function get_hex_digit_exn(t){
    if(65 <= t){
     if(97 <= t){
      if(103 > t){
       var
        _j_ = caml_call1(to_int, 97),
        _k_ = caml_call1(to_int, t),
        _l_ = caml_call2(Base_Import[92], _k_, _j_);
       return caml_call2(Base_Import[90], _l_, 10);
      }
     }
     else if(71 > t){
      var
       _m_ = caml_call1(to_int, 65),
       _n_ = caml_call1(to_int, t),
       _o_ = caml_call2(Base_Import[92], _n_, _m_);
      return caml_call2(Base_Import[90], _o_, 10);
     }
    }
    else if(9 >= t - 48 >>> 0){
     var _p_ = caml_call1(to_int, 48), _q_ = caml_call1(to_int, t);
     return caml_call2(Base_Import[92], _q_, _p_);
    }
    var
     _h_ = [0, [0, cst_char, caml_call1(sexp_of_t$0, t)], 0],
     _i_ = caml_call2(Base_Sexp[9], cst_Char_get_hex_digit_exn_not, _h_);
    return caml_call1(Base_Error[30], _i_);
   }
   function get_hex_digit(t){
    return is_hex_digit(t) ? [0, get_hex_digit_exn(t)] : 0;
   }
   var
    symbol = Base_Import[105][6],
    symbol$0 = Base_Import[105][2],
    symbol$1 = Base_Import[105][4],
    symbol$2 = Base_Import[105][5],
    symbol$3 = Base_Import[105][1],
    symbol$4 = Base_Import[105][3],
    O = [0, symbol, symbol$0, symbol$1, symbol$2, symbol$3, symbol$4],
    t_of_sexp$1 = Base_Import[164],
    sexp_of_t$1 = Base_Import[140],
    t_sexp_grammar$0 = Base_Import[184];
   function compare$0(c1, c2){
    var _f_ = caml_call1(lowercase, c2), _g_ = caml_call1(lowercase, c1);
    return caml_call2(Base_Import[105][9], _g_, _f_);
   }
   function hash_fold_t$1(state, t){
    var _e_ = caml_call1(lowercase, t);
    return caml_call2(Base_Import[205], state, _e_);
   }
   function hash$1(t){return caml_call3(Base_Hash[14], 0, hash_fold_t$1, t);}
   var
    include$0 = caml_call1(Base_Comparable[10], [0, compare$0, sexp_of_t$1]),
    symbol$5 = include$0[1],
    symbol$6 = include$0[2],
    symbol$7 = include$0[3],
    symbol$8 = include$0[4],
    symbol$9 = include$0[5],
    symbol$10 = include$0[6],
    equal = include$0[7],
    compare$1 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between$0 = include$0[13],
    clamp_exn$0 = include$0[14],
    clamp$0 = include$0[15],
    comparator$0 = include$0[16],
    include$1 = Base_Import[105],
    symbol$11 = include$1[1],
    symbol$12 = include$1[2],
    symbol$13 = include$1[3],
    symbol$14 = include$1[4],
    symbol$15 = include$1[5],
    symbol$16 = include$1[6],
    ascending$0 = include$1[7],
    descending$0 = include$1[8],
    compare$2 = include$1[9],
    equal$0 = include$1[10],
    max$0 = include$1[11],
    min$0 = include$1[12],
    Base_Char =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$16,
       symbol$12,
       symbol$14,
       symbol$15,
       symbol$11,
       symbol$13,
       equal$0,
       compare$2,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       invariant,
       O,
       to_int,
       of_int,
       of_int_exn,
       unsafe_of_int,
       escaped,
       lowercase,
       uppercase,
       is_digit,
       is_lowercase,
       is_uppercase,
       is_alpha,
       is_alphanum,
       is_print,
       is_whitespace,
       get_digit,
       get_digit_exn,
       is_hex_digit,
       is_hex_digit_lower,
       is_hex_digit_upper,
       get_hex_digit,
       get_hex_digit_exn,
       min_value,
       max_value,
       [0,
        hash_fold_t$1,
        hash$1,
        t_of_sexp$1,
        sexp_of_t$1,
        t_sexp_grammar$0,
        symbol$5,
        symbol$6,
        symbol$7,
        symbol$8,
        symbol$9,
        symbol$10,
        equal,
        compare$1,
        min,
        max,
        ascending,
        descending,
        between$0,
        clamp_exn$0,
        clamp$0,
        comparator$0]];
   runtime.caml_register_global(16, Base_Char, "Base__Char");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_enumerate_lib
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Enumerable = [0],
    Base_Ppx_enumerate_lib = [0, Enumerable];
   runtime.caml_register_global
    (0, Base_Ppx_enumerate_lib, "Base__Ppx_enumerate_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes_tr
//# unitInfo: Requires: Base__Bytes0, Base__Char, Base__Import0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Char = global_data.Base__Char,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Import0 = global_data.Base__Import0;
   function tr_create_map(target, replacement){
    var tr_map = caml_call1(Base_Bytes0[7], 256), i$3 = 0;
    for(;;){
     caml_bytes_unsafe_set(tr_map, i$3, caml_call1(Base_Char[31], i$3));
     var _j_ = i$3 + 1 | 0;
     if(255 === i$3) break;
     i$3 = _j_;
    }
    var
     _b_ =
       caml_call2
        (Base_Import0[96][4],
         caml_ml_string_length(target),
         caml_ml_string_length(replacement))
       - 1
       | 0,
     _a_ = 0;
    if(_b_ >= 0){
     var i$2 = _a_;
     for(;;){
      var
       index$0 =
         caml_call1(Base_Char[29], caml_string_unsafe_get(target, i$2));
      caml_bytes_unsafe_set
       (tr_map, index$0, caml_string_unsafe_get(replacement, i$2));
      var _i_ = i$2 + 1 | 0;
      if(_b_ === i$2) break;
      i$2 = _i_;
     }
    }
    var
     last_replacement =
       caml_string_unsafe_get
        (replacement, caml_ml_string_length(replacement) - 1 | 0),
     _c_ =
       caml_call2
        (Base_Import0[96][4],
         caml_ml_string_length(target),
         caml_ml_string_length(replacement)),
     _d_ = caml_ml_string_length(target) - 1 | 0;
    if(_d_ >= _c_){
     var i$1 = _c_;
     for(;;){
      var
       index = caml_call1(Base_Char[29], caml_string_unsafe_get(target, i$1));
      caml_bytes_unsafe_set(tr_map, index, last_replacement);
      var _h_ = i$1 + 1 | 0;
      if(_d_ === i$1) break;
      i$1 = _h_;
     }
    }
    var
     first_target = runtime.caml_string_get(target, 0),
     _f_ =
       caml_bytes_unsafe_get(tr_map, caml_call1(Base_Char[29], first_target));
    if(! caml_call2(Base_Char[14], _f_, first_target)){
     var i = 0;
     for(;;){
      if(256 === i)
       var _g_ = 0;
      else{
       var _e_ = caml_call1(Base_Char[31], i);
       if(! caml_call2(Base_Char[14], caml_bytes_unsafe_get(tr_map, i), _e_)){var i$0 = i + 1 | 0; i = i$0; continue;}
       var _g_ = 1;
      }
      if(_g_) break;
      return 0;
     }
    }
    return [0, caml_call1(Base_Bytes0[16], tr_map)];
   }
   var Base_Bytes_tr = [0, tr_create_map];
   runtime.caml_register_global(3, Base_Bytes_tr, "Base__Bytes_tr");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Staged
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function stage(_b_){return _b_;}
   function unstage(_a_){return _a_;}
   var Base_Staged = [0, stage, unstage];
   runtime.caml_register_global(0, Base_Staged, "Base__Staged");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Bytes0, Base__Bytes_tr, Base__Char, Base__Comparable, Base__Comparator, Base__Container, Base__Error, Base__Hash, Base__Import, Base__Indexed_container, Base__List, Base__Option, Base__Or_error, Base__Ordered_collection_common, Base__Ppx_compare_lib, Base__Printf, Base__Sexp, Base__Staged, Base__String0, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$11 = "",
    cst_case_sensitive = "case_sensitive",
    cst_char$1 = "char",
    cst_escape_char$1 = "escape_char",
    cst_pattern = "pattern",
    cst_pos$1 = "pos",
    cst_src_string_ml = "src/string.ml",
    cst_str$1 = "str",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$10 = cst$11,
    cst$9 = cst$11,
    cst$8 = cst$11,
    cst$6 = cst$11,
    cst$7 = cst$11,
    cst$5 = cst$11,
    cst$4 = cst$11,
    cst$3 = cst$11,
    cst$2 = cst$11,
    cst$1 = cst$11,
    cst$0 = cst$11,
    cst = cst$11,
    Base_Char = global_data.Base__Char,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Array0 = global_data.Base__Array0,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Bytes_tr = global_data.Base__Bytes_tr,
    Base_Indexed_container = global_data.Base__Indexed_container,
    Base_Container = global_data.Base__Container,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_String0 = global_data.Base__String0,
    Base_Printf = global_data.Base__Printf,
    Base_Error = global_data.Base__Error,
    Base_Staged = global_data.Base__Staged,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    max_length = Base_String0[2],
    symbol_concat = Base_String0[3],
    capitalize = Base_String0[4],
    compare = Base_String0[5],
    copy = Base_String0[6],
    escaped = Base_String0[7],
    lowercase = Base_String0[8],
    make = Base_String0[9],
    uncapitalize = Base_String0[11],
    uppercase = Base_String0[13],
    concat = Base_String0[14],
    iter = Base_String0[15],
    invalid_argf = Base_Printf[7],
    raise_s = Base_Error[30],
    stage = Base_Staged[1],
    hash_fold_t = Base_Import[208],
    func = Base_Import[222];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[162],
    sexp_of_t = Base_Import[138],
    t_sexp_grammar = Base_Import[182],
    hashable = [0, hash, compare, sexp_of_t],
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1];
   function invariant(param){return 0;}
   function sub(src, pos, len){
    if(0 === pos && len === caml_ml_string_length(src)) return src;
    caml_call3
     (Base_Ordered_collection_common[2], pos, len, caml_ml_string_length(src));
    if(0 === len) return cst;
    var dst = caml_call1(Base_Bytes0[7], len);
    runtime.caml_blit_string(src, pos, dst, 0, len);
    return caml_call1(Base_Bytes0[16], dst);
   }
   function subo(opt, len, src){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(len)
     var i = len[1], i$0 = i;
    else
     var i$0 = caml_call2(Base_Import[92], caml_ml_string_length(src), pos);
    return sub(src, pos, i$0);
   }
   function contains(opt, len, t, char$0){
    if(opt) var sth = opt[1], pos$1 = sth; else var pos$1 = 0;
    var
     total_length = caml_ml_string_length(t),
     _df_ = caml_call2(Base_Import[92], total_length, pos$1),
     len$0 = caml_call2(Base_Option[27], len, _df_);
    caml_call3(Base_Ordered_collection_common[2], pos$1, len$0, total_length);
    var end = caml_call2(Base_Import[90], pos$1, len$0), pos = pos$1;
    for(;;){
     var _dc_ = pos < end ? 1 : 0;
     if(_dc_){
      var
       _dd_ =
         caml_call2(Base_Char[15], caml_string_unsafe_get(t, pos), char$0);
      if(! _dd_){
       var pos$0 = caml_call2(Base_Import[90], pos, 1);
       pos = pos$0;
       continue;
      }
      var _de_ = _dd_;
     }
     else
      var _de_ = _dc_;
     return _de_;
    }
   }
   function is_empty(t){return 0 === caml_ml_string_length(t) ? 1 : 0;}
   function index_from_exn_internal(string, pos, len, not_found, char$0){
    var pos$0 = pos;
    for(;;){
     if(len <= pos$0) throw caml_maybe_attach_backtrace(not_found, 1);
     if
      (caml_call2
        (Base_Char[15], caml_string_unsafe_get(string, pos$0), char$0))
      return pos$0;
     var pos$1 = caml_call2(Base_Import[90], pos$0, 1);
     pos$0 = pos$1;
    }
   }
   function index_exn_internal(t, not_found, char$0){
    return index_from_exn_internal
            (t, 0, caml_ml_string_length(t), not_found, char$0);
   }
   var not_found = [0, Base_Import[251], [0, "String.index_exn: not found"]];
   function index_exn(t, char$0){
    return index_exn_internal(t, not_found, char$0);
   }
   var
    not_found$0 =
      [0, Base_Import[251], [0, "String.index_from_exn: not found"]],
    cst_String_index_from_exn = "String.index_from_exn";
   function index_from_exn(t, pos, char$0){
    var len = caml_ml_string_length(t);
    if(0 <= pos && len >= pos)
     return index_from_exn_internal(t, pos, len, not_found$0, char$0);
    return caml_call1(Base_Import[125], cst_String_index_from_exn);
   }
   function rindex_from_exn_internal(string, pos, len, not_found, char$0){
    var pos$0 = pos;
    for(;;){
     if(0 > pos$0) throw caml_maybe_attach_backtrace(not_found, 1);
     if
      (caml_call2
        (Base_Char[15], caml_string_unsafe_get(string, pos$0), char$0))
      return pos$0;
     var pos$1 = caml_call2(Base_Import[92], pos$0, 1);
     pos$0 = pos$1;
    }
   }
   function rindex_exn_internal(t, not_found, char$0){
    var len = caml_ml_string_length(t);
    return rindex_from_exn_internal
            (t, caml_call2(Base_Import[92], len, 1), len, not_found, char$0);
   }
   var
    not_found$1 = [0, Base_Import[251], [0, "String.rindex_exn: not found"]];
   function rindex_exn(t, char$0){
    return rindex_exn_internal(t, not_found$1, char$0);
   }
   var
    not_found$2 =
      [0, Base_Import[251], [0, "String.rindex_from_exn: not found"]],
    cst_String_rindex_from_exn = "String.rindex_from_exn",
    _a_ = [0, cst_case_sensitive],
    _b_ = [0, cst_pattern],
    cst_substring = "substring",
    cst_Substring_not_found = "Substring not found",
    _c_ = [0, "kmp_array"],
    _d_ = [0, cst_case_sensitive],
    _e_ = [0, cst_pattern];
   function rindex_from_exn(t, pos, char$0){
    var len = caml_ml_string_length(t);
    if(-1 <= pos && len > pos)
     return rindex_from_exn_internal(t, pos, len, not_found$2, char$0);
    return caml_call1(Base_Import[125], cst_String_rindex_from_exn);
   }
   function index(t, char$0){
    try{var _da_ = [0, index_exn_internal(t, not_found, char$0)]; return _da_;
    }
    catch(_db_){
     var _c$_ = caml_wrap_exception(_db_);
     if(_c$_[1] !== Base_Import[251] && _c$_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_c$_, 0);
     return 0;
    }
   }
   function rindex(t, char$0){
    try{
     var _c9_ = [0, rindex_exn_internal(t, not_found$1, char$0)];
     return _c9_;
    }
    catch(_c__){
     var _c8_ = caml_wrap_exception(_c__);
     if(_c8_[1] !== Base_Import[251] && _c8_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_c8_, 0);
     return 0;
    }
   }
   function index_from(t, pos, char$0){
    try{var _c6_ = [0, index_from_exn(t, pos, char$0)]; return _c6_;}
    catch(_c7_){
     var _c5_ = caml_wrap_exception(_c7_);
     if(_c5_[1] !== Base_Import[251] && _c5_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_c5_, 0);
     return 0;
    }
   }
   function rindex_from(t, pos, char$0){
    try{var _c3_ = [0, rindex_from_exn(t, pos, char$0)]; return _c3_;}
    catch(_c4_){
     var _c2_ = caml_wrap_exception(_c4_);
     if(_c2_[1] !== Base_Import[251] && _c2_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_c2_, 0);
     return 0;
    }
   }
   function sexp_of_t$0(param){
    var
     case_sensitive = param[2],
     pattern = param[1],
     _c1_ =
       [0,
        [1, [0, _a_, [0, caml_call1(Base_Import[137], case_sensitive), 0]]],
        0];
    return [1,
            [0,
             [1, [0, _b_, [0, caml_call1(Base_Import[138], pattern), 0]]],
             _c1_]];
   }
   function pattern(t){return t[1];}
   function case_sensitive(t){return t[2];}
   function kmp_internal_loop
   (matched_chars, next_text_char, pattern, kmp_array, char_equal){
    var matched_chars$0 = [0, matched_chars];
    for(;;){
     if
      (0 < matched_chars$0[1]
       &&
        !
        caml_call2
         (char_equal,
          next_text_char,
          caml_string_unsafe_get(pattern, matched_chars$0[1]))){
      matched_chars$0[1] =
       kmp_array[1 + caml_call2(Base_Import[92], matched_chars$0[1], 1)];
      continue;
     }
     if
      (caml_call2
        (char_equal,
         next_text_char,
         caml_string_unsafe_get(pattern, matched_chars$0[1])))
      matched_chars$0[1] = caml_call2(Base_Import[90], matched_chars$0[1], 1);
     return matched_chars$0[1];
    }
   }
   function get_char_equal(case_sensitive){
    return case_sensitive ? Base_Char[15] : Base_Char[52][12];
   }
   function create(pattern, case_sensitive){
    var
     n = caml_ml_string_length(pattern),
     kmp_array = caml_call2(Base_Array0[4], n, -1);
    if(0 < n){
     var char_equal = get_char_equal(case_sensitive);
     kmp_array[1] = 0;
     var
      matched_chars = [0, 0],
      _cZ_ = caml_call2(Base_Import[92], n, 1),
      _cY_ = 1;
     if(_cZ_ >= 1){
      var i = _cY_;
      for(;;){
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1],
          caml_string_unsafe_get(pattern, i),
          pattern,
          kmp_array,
          char_equal);
       kmp_array[1 + i] = matched_chars[1];
       var _c0_ = i + 1 | 0;
       if(_cZ_ === i) break;
       i = _c0_;
      }
     }
    }
    return [0, pattern, case_sensitive, kmp_array];
   }
   function index_internal(opt, param){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var kmp_array = param[3], case_sensitive = param[2], pattern = param[1];
    return function(text){
     if
      (0 <= pos
       &&
        caml_call2
         (Base_Import[92],
          caml_ml_string_length(text),
          caml_ml_string_length(pattern))
        >= pos){
      var
       char_equal = get_char_equal(case_sensitive),
       j = [0, pos],
       matched_chars = [0, 0],
       k = caml_ml_string_length(pattern),
       n = caml_ml_string_length(text);
      for(;;){
       if(j[1] < n && matched_chars[1] < k){
        var next_text_char = caml_string_unsafe_get(text, j[1]);
        matched_chars[1] =
         kmp_internal_loop
          (matched_chars[1], next_text_char, pattern, kmp_array, char_equal);
        j[1] = caml_call2(Base_Import[90], j[1], 1);
        continue;
       }
       return matched_chars[1] === k
               ? caml_call2(Base_Import[92], j[1], k)
               : -1;
      }
     }
     return -1;};
   }
   function matches(t, str){return 0 <= index_internal(0, t)(str) ? 1 : 0;}
   function index$0(pos, t, in$0){
    var p = index_internal(pos, t)(in$0);
    return 0 <= p ? [0, p] : 0;
   }
   function index_exn$0(pos, t, in$0){
    var p = index_internal(pos, t)(in$0);
    if(0 <= p) return p;
    var _cX_ = [0, [0, cst_substring, caml_call1(Base_Import[138], t[1])], 0];
    return caml_call1
            (raise_s, caml_call2(Base_Sexp[9], cst_Substring_not_found, _cX_));
   }
   function index_all(param, may_overlap, text){
    var kmp_array = param[3], case_sensitive = param[2], pattern = param[1];
    if(0 === caml_ml_string_length(pattern)){
     var _cS_ = caml_call2(Base_Import[90], 1, caml_ml_string_length(text));
     return caml_call2(Base_List[123], _cS_, function(_cW_){return _cW_;});
    }
    var
     char_equal = get_char_equal(case_sensitive),
     matched_chars = [0, 0],
     k = caml_ml_string_length(pattern),
     n = caml_ml_string_length(text),
     found = [0, 0],
     _cT_ = 0;
    if(n >= 0){
     var j = _cT_;
     for(;;){
      if(matched_chars[1] === k){
       var _cU_ = found[1];
       found[1] = [0, caml_call2(Base_Import[92], j, k), _cU_];
       matched_chars[1] =
        may_overlap ? kmp_array[1 + caml_call2(Base_Import[92], k, 1)] : 0;
      }
      if(j < n){
       var next_text_char = caml_string_unsafe_get(text, j);
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1], next_text_char, pattern, kmp_array, char_equal);
      }
      var _cV_ = j + 1 | 0;
      if(n === j) break;
      j = _cV_;
     }
    }
    return caml_call1(Base_List[38], found[1]);
   }
   function replace_first(pos, t, s, with$0){
    var match = index$0(pos, t, s);
    if(! match) return s;
    var
     i = match[1],
     len_s = caml_ml_string_length(s),
     len_t = caml_ml_string_length(t[1]),
     len_with = caml_ml_string_length(with$0),
     _cM_ = caml_call2(Base_Import[90], len_s, len_with),
     _cN_ = caml_call2(Base_Import[92], _cM_, len_t),
     dst = caml_call1(Base_Bytes0[7], _cN_);
    caml_call5(Base_Bytes0[4], s, 0, dst, 0, i);
    caml_call5(Base_Bytes0[4], with$0, 0, dst, i, len_with);
    var
     _cO_ = caml_call2(Base_Import[92], len_s, i),
     _cP_ = caml_call2(Base_Import[92], _cO_, len_t),
     _cQ_ = caml_call2(Base_Import[90], i, len_with),
     _cR_ = caml_call2(Base_Import[90], i, len_t);
    caml_call5(Base_Bytes0[4], s, _cR_, dst, _cQ_, _cP_);
    return caml_call1(Base_Bytes0[16], dst);
   }
   function replace_all(t, s, with$0){
    var matches = index_all(t, 0, s);
    if(! matches) return s;
    var
     len_s = caml_ml_string_length(s),
     len_t = caml_ml_string_length(t[1]),
     len_with = caml_ml_string_length(with$0),
     num_matches = caml_call1(Base_List[7], matches),
     _cF_ = caml_call2(Base_Import[92], len_with, len_t),
     _cG_ = caml_call2(Base_Import[87], _cF_, num_matches),
     _cH_ = caml_call2(Base_Import[90], len_s, _cG_),
     dst = caml_call1(Base_Bytes0[7], _cH_),
     next_dst_pos = [0, 0],
     next_src_pos = [0, 0];
    caml_call2
     (Base_List[9],
      matches,
      function(i){
       var len = caml_call2(Base_Import[92], i, next_src_pos[1]);
       caml_call5
        (Base_Bytes0[4], s, next_src_pos[1], dst, next_dst_pos[1], len);
       var _cJ_ = caml_call2(Base_Import[90], next_dst_pos[1], len);
       caml_call5(Base_Bytes0[4], with$0, 0, dst, _cJ_, len_with);
       var _cK_ = caml_call2(Base_Import[90], next_dst_pos[1], len);
       next_dst_pos[1] = caml_call2(Base_Import[90], _cK_, len_with);
       var _cL_ = caml_call2(Base_Import[90], next_src_pos[1], len);
       next_src_pos[1] = caml_call2(Base_Import[90], _cL_, len_t);
       return 0;
      });
    var _cI_ = caml_call2(Base_Import[92], len_s, next_src_pos[1]);
    caml_call5(Base_Bytes0[4], s, next_src_pos[1], dst, next_dst_pos[1], _cI_);
    return caml_call1(Base_Bytes0[16], dst);
   }
   function split_on(t, s){
    var
     pattern_len = caml_ml_string_length(t[1]),
     matches = index_all(t, 0, s),
     _cB_ =
       caml_call2(Base_Import[110], matches, [0, caml_ml_string_length(s), 0]),
     _cC_ = [0, caml_call1(Base_Import[112], pattern_len), matches];
    return caml_call3
            (Base_List[83],
             _cC_,
             _cB_,
             function(i, j){
              var
               _cD_ = caml_call2(Base_Import[92], j, i),
               _cE_ = caml_call2(Base_Import[92], _cD_, pattern_len);
              return sub(s, caml_call2(Base_Import[90], i, pattern_len), _cE_);
             });
   }
   function equal(a_002, b_003){
    if(caml_call2(Base_Ppx_compare_lib[1], a_002, b_003)) return 1;
    var _cy_ = caml_call2(Base_Import[245], a_002[1], b_003[1]);
    if(_cy_){
     var _cz_ = caml_call2(Base_Import[238], a_002[2], b_003[2]);
     if(_cz_)
      return caml_call3
              (Base_Import[247], Base_Import[241], a_002[3], b_003[3]);
     var _cA_ = _cz_;
    }
    else
     var _cA_ = _cy_;
    return _cA_;
   }
   function sexp_of_t$1(param){
    var
     kmp_array_011 = param[3],
     case_sensitive_009 = param[2],
     pattern_007 = param[1],
     arg_012 = caml_call2(Base_Import[152], Base_Import[141], kmp_array_011),
     bnds_006 = [0, [1, [0, _c_, [0, arg_012, 0]]], 0],
     arg_010 = caml_call1(Base_Import[137], case_sensitive_009),
     bnds_006$0 = [0, [1, [0, _d_, [0, arg_010, 0]]], bnds_006],
     arg_008 = caml_call1(Base_Import[138], pattern_007),
     bnds_006$1 = [0, [1, [0, _e_, [0, arg_008, 0]]], bnds_006$0];
    return [1, bnds_006$1];
   }
   function representation(_cx_){return _cx_;}
   var Private = [0, equal, sexp_of_t$1, representation];
   function substr_index_gen(case_sensitive, pos, t, pattern){return index$0(pos, create(pattern, case_sensitive), t);
   }
   function substr_index_exn_gen(case_sensitive, pos, t, pattern){return index_exn$0(pos, create(pattern, case_sensitive), t);
   }
   function substr_index_all_gen(case_sensitive, t, may_overlap, pattern){return index_all(create(pattern, case_sensitive), may_overlap, t);
   }
   function substr_replace_first_gen(case_sensitive, pos, t, pattern){
    var _cv_ = create(pattern, case_sensitive);
    return function(_cw_){return replace_first(pos, _cv_, t, _cw_);};
   }
   function substr_replace_all_gen(case_sensitive, t, pattern){
    var _ct_ = create(pattern, case_sensitive);
    return function(_cu_){return replace_all(_ct_, t, _cu_);};
   }
   function is_substring_gen(case_sensitive, t, substring){
    var _cs_ = substr_index_gen(case_sensitive, 0, t, substring);
    return caml_call1(Base_Option[50], _cs_);
   }
   var _f_ = 1;
   function substr_index(_cp_, _cq_, _cr_){
    return substr_index_gen(_f_, _cp_, _cq_, _cr_);
   }
   var _g_ = 1;
   function substr_index_exn(_cm_, _cn_, _co_){
    return substr_index_exn_gen(_g_, _cm_, _cn_, _co_);
   }
   var _h_ = 1;
   function substr_index_all(_cj_, _ck_, _cl_){
    return substr_index_all_gen(_h_, _cj_, _ck_, _cl_);
   }
   var _i_ = 1;
   function substr_replace_first(_cg_, _ch_, _ci_){
    return substr_replace_first_gen(_i_, _cg_, _ch_, _ci_);
   }
   var _j_ = 1;
   function substr_replace_all(_ce_, _cf_){
    return substr_replace_all_gen(_j_, _ce_, _cf_);
   }
   var
    _k_ = 1,
    _l_ =
      [0,
       [11,
        "String.is_substring_at: invalid index ",
        [4, 0, 0, 0, [11, " for string of length ", [4, 0, 0, 0, 0]]]],
       "String.is_substring_at: invalid index %d for string of length %d"];
   function is_substring(_cc_, _cd_){
    return is_substring_gen(_k_, _cc_, _cd_);
   }
   function is_substring_at_gen(str, str_pos$1, sub, char_equal){
    var
     str_len = caml_ml_string_length(str),
     sub_len = caml_ml_string_length(sub),
     _b$_ = str_pos$1 < 0 ? 1 : 0,
     _ca_ = _b$_ || (str_len < str_pos$1 ? 1 : 0);
    if(_ca_) caml_call4(invalid_argf, _l_, str_pos$1, str_len, 0);
    var
     _cb_ = caml_call2(Base_Import[90], str_pos$1, sub_len) <= str_len ? 1 : 0;
    if(! _cb_) return _cb_;
    var str_pos = str_pos$1, sub_pos = 0;
    for(;;){
     if(sub_pos === sub_len) return 1;
     if
      (!
       caml_call2
        (char_equal,
         caml_string_unsafe_get(str, str_pos),
         caml_string_unsafe_get(sub, sub_pos)))
      return 0;
     var
      sub_pos$0 = caml_call2(Base_Import[90], sub_pos, 1),
      str_pos$0 = caml_call2(Base_Import[90], str_pos, 1);
     str_pos = str_pos$0;
     sub_pos = sub_pos$0;
    }
   }
   function is_suffix_gen(string, suffix, char_equal){
    var
     string_len = caml_ml_string_length(string),
     suffix_len = caml_ml_string_length(suffix),
     _b__ = suffix_len <= string_len ? 1 : 0;
    return _b__
            ? is_substring_at_gen
              (string,
               caml_call2(Base_Import[92], string_len, suffix_len),
               suffix,
               char_equal)
            : _b__;
   }
   function is_prefix_gen(string, prefix, char_equal){
    var
     string_len = caml_ml_string_length(string),
     prefix_len = caml_ml_string_length(prefix),
     _b9_ = prefix_len <= string_len ? 1 : 0;
    return _b9_ ? is_substring_at_gen(string, 0, prefix, char_equal) : _b9_;
   }
   var
    t_of_sexp$0 = Base_Import[162],
    sexp_of_t$2 = Base_Import[138],
    t_sexp_grammar$0 = Base_Import[182];
   function compare$0(string1, string2){
    if(caml_call2(Base_Import[127], string1, string2)) return 0;
    var
     len2 = caml_ml_string_length(string2),
     len1 = caml_ml_string_length(string1),
     pos = 0;
    for(;;){
     if(pos === len1) return pos === len2 ? 0 : -1;
     if(pos === len2) return 1;
     var
      c2 = caml_string_unsafe_get(string2, pos),
      c1 = caml_string_unsafe_get(string1, pos),
      _b7_ = caml_call1(Base_Char[34], c2),
      _b8_ = caml_call1(Base_Char[34], c1),
      c = caml_call2(Base_Char[16], _b8_, _b7_);
     if(0 !== c) return c;
     var pos$0 = caml_call2(Base_Import[90], pos, 1);
     pos = pos$0;
    }
   }
   function hash_fold_t$0(state, t){
    var
     len = caml_ml_string_length(t),
     state$0 = [0, caml_call2(Base_Import[206], state, len)],
     _b4_ = caml_call2(Base_Import[92], len, 1),
     _b3_ = 0;
    if(_b4_ >= 0){
     var pos = _b3_;
     for(;;){
      var _b5_ = caml_call1(Base_Char[34], caml_string_unsafe_get(t, pos));
      state$0[1] = caml_call2(Base_Import[205], state$0[1], _b5_);
      var _b6_ = pos + 1 | 0;
      if(_b4_ === pos) break;
      pos = _b6_;
     }
    }
    return state$0[1];
   }
   function hash$0(t){return caml_call3(Base_Hash[14], 0, hash_fold_t$0, t);}
   function is_suffix(s, suffix){
    return is_suffix_gen(s, suffix, Base_Char[52][12]);
   }
   function is_prefix(s, prefix){
    return is_prefix_gen(s, prefix, Base_Char[52][12]);
   }
   var _m_ = 0;
   function substr_index$0(_b0_, _b1_, _b2_){
    return substr_index_gen(_m_, _b0_, _b1_, _b2_);
   }
   var _n_ = 0;
   function substr_index_exn$0(_bX_, _bY_, _bZ_){
    return substr_index_exn_gen(_n_, _bX_, _bY_, _bZ_);
   }
   var _o_ = 0;
   function substr_index_all$0(_bU_, _bV_, _bW_){
    return substr_index_all_gen(_o_, _bU_, _bV_, _bW_);
   }
   var _p_ = 0;
   function substr_replace_first$0(_bR_, _bS_, _bT_){
    return substr_replace_first_gen(_p_, _bR_, _bS_, _bT_);
   }
   var _q_ = 0;
   function substr_replace_all$0(_bP_, _bQ_){
    return substr_replace_all_gen(_q_, _bP_, _bQ_);
   }
   var _r_ = 0;
   function is_substring$0(_bN_, _bO_){
    return is_substring_gen(_r_, _bN_, _bO_);
   }
   var _s_ = Base_Char[52][12];
   function is_substring_at(_bK_){
    return function(_bL_){
     return function(_bM_){
      return is_substring_at_gen(_bK_, _bL_, _bM_, _s_);};};
   }
   var
    include$0 = caml_call1(Base_Comparable[10], [0, compare$0, sexp_of_t$2]),
    symbol = include$0[1],
    symbol$0 = include$0[2],
    symbol$1 = include$0[3],
    symbol$2 = include$0[4],
    symbol$3 = include$0[5],
    symbol$4 = include$0[6],
    equal$0 = include$0[7],
    compare$1 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between = include$0[13],
    clamp_exn = include$0[14],
    clamp = include$0[15],
    comparator$0 = include$0[16],
    _t_ = [0, [11, "String.init ", [4, 0, 0, 0, 0]], "String.init %d"];
   function of_string(_bJ_){return _bJ_;}
   function to_string(_bI_){return _bI_;}
   function init(n, f){
    if(n < 0) caml_call3(invalid_argf, _t_, n, 0);
    var
     t = caml_call1(Base_Bytes0[7], n),
     _bG_ = caml_call2(Base_Import[92], n, 1),
     _bF_ = 0;
    if(_bG_ >= 0){
     var i = _bF_;
     for(;;){
      caml_bytes_set(t, i, caml_call1(f, i));
      var _bH_ = i + 1 | 0;
      if(_bG_ === i) break;
      i = _bH_;
     }
    }
    return caml_call1(Base_Bytes0[16], t);
   }
   function to_list(s){
    var
     i$1 = caml_call2(Base_Import[92], caml_ml_string_length(s), 1),
     acc = 0,
     i = i$1;
    for(;;){
     if(0 > i) return acc;
     var
      i$0 = caml_call2(Base_Import[92], i, 1),
      acc$0 = [0, caml_string_get(s, i), acc];
     acc = acc$0;
     i = i$0;
    }
   }
   function to_list_rev(s){
    var len = caml_ml_string_length(s), acc = 0, i = 0;
    for(;;){
     if(i === len) return acc;
     var
      i$0 = caml_call2(Base_Import[90], i, 1),
      acc$0 = [0, caml_string_get(s, i), acc];
     acc = acc$0;
     i = i$0;
    }
   }
   function rev(t){
    var
     len = caml_ml_string_length(t),
     res = caml_call1(Base_Bytes0[7], len),
     _bC_ = caml_call2(Base_Import[92], len, 1),
     _bB_ = 0;
    if(_bC_ >= 0){
     var i = _bB_;
     for(;;){
      var _bD_ = caml_call2(Base_Import[92], len, 1);
      caml_bytes_unsafe_set
       (res,
        i,
        caml_string_unsafe_get(t, caml_call2(Base_Import[92], _bD_, i)));
      var _bE_ = i + 1 | 0;
      if(_bC_ === i) break;
      i = _bE_;
     }
    }
    return caml_call1(Base_Bytes0[16], res);
   }
   var
    not_found$3 = [0, Base_Import[251], [0, "String.lsplit2_exn: not found"]];
   function lsplit2_exn(line, delim){
    var
     pos = index_exn_internal(line, not_found$3, delim),
     _by_ = caml_call2(Base_Import[92], caml_ml_string_length(line), pos),
     _bz_ = caml_call2(Base_Import[92], _by_, 1),
     _bA_ = sub(line, caml_call2(Base_Import[90], pos, 1), _bz_);
    return [0, sub(line, 0, pos), _bA_];
   }
   var
    not_found$4 = [0, Base_Import[251], [0, "String.rsplit2_exn: not found"]],
    cst_expecting_nonnegative_argu = " expecting nonnegative argument",
    cst_drop_prefix = "drop_prefix",
    cst_drop_suffix = "drop_suffix",
    cst_prefix = "prefix",
    cst_suffix = "suffix",
    _u_ = [0, cst_src_string_ml, 765, 17],
    cst_tr_multi_replacement_is_em = "tr_multi replacement is empty string",
    _v_ =
      [0,
       [11, "String.chop_prefix_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "String.chop_prefix_exn %S %S"],
    _w_ =
      [0,
       [11, "String.chop_suffix_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "String.chop_suffix_exn %S %S"],
    _x_ = [0, [3, 0, 0], "%S"],
    cst_escapeworthy_map = "escapeworthy_map",
    cst_c_to = "c_to",
    cst_c_from = "c_from",
    cst_escapeworthy_map_not_one_t = "escapeworthy_map not one-to-one",
    _y_ = [0, [2, 0, [11, ": out of bounds", 0]], "%s: out of bounds"],
    cst_is_char_escaping = "is_char_escaping",
    cst_is_char_escaped = "is_char_escaped",
    cst_is_char_literal = "is_char_literal",
    cst_index_from = "index_from",
    cst_char = cst_char$1,
    cst_pos = cst_pos$1,
    cst_escape_char = cst_escape_char$1,
    cst_str = cst_str$1,
    cst_index_from_exn_not_found = "index_from_exn: not found",
    cst_rindex_from = "rindex_from",
    cst_char$0 = cst_char$1,
    cst_pos$0 = cst_pos$1,
    cst_escape_char$0 = cst_escape_char$1,
    cst_str$0 = cst_str$1,
    cst_rindex_from_exn_not_found = "rindex_from_exn: not found",
    _z_ = [0, cst_src_string_ml, 1573, 19],
    _A_ = [0, cst_src_string_ml, 1587, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function rsplit2_exn(line, delim){
    var
     pos = rindex_exn_internal(line, not_found$4, delim),
     _bv_ = caml_call2(Base_Import[92], caml_ml_string_length(line), pos),
     _bw_ = caml_call2(Base_Import[92], _bv_, 1),
     _bx_ = sub(line, caml_call2(Base_Import[90], pos, 1), _bw_);
    return [0, sub(line, 0, pos), _bx_];
   }
   function lsplit2(line, on){
    try{var _bt_ = [0, lsplit2_exn(line, on)]; return _bt_;}
    catch(_bu_){
     var _bs_ = caml_wrap_exception(_bu_);
     if(_bs_[1] !== Base_Import[251] && _bs_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_bs_, 0);
     return 0;
    }
   }
   function rsplit2(line, on){
    try{var _bq_ = [0, rsplit2_exn(line, on)]; return _bq_;}
    catch(_br_){
     var _bp_ = caml_wrap_exception(_br_);
     if(_bp_[1] !== Base_Import[251] && _bp_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_bp_, 0);
     return 0;
    }
   }
   function char_list_mem(l, c){
    var l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1], _bo_ = caml_call2(Base_Char[15], hd, c);
     if(_bo_) return _bo_;
     l$0 = tl;
    }
   }
   function split_gen(str, on){
    if(552554919 <= on[1])
     var l = on[2], is_delim = function(c){return char_list_mem(l, c);};
    else
     var
      c = on[2],
      is_delim = function(c$0){return caml_call2(Base_Char[15], c$0, c);};
    var
     last_pos = caml_ml_string_length(str),
     pos$1 = caml_call2(Base_Import[92], last_pos, 1),
     acc = 0,
     last_pos$1 = last_pos,
     last_pos$0 = pos$1;
    for(;;){
     if(-1 === last_pos$0) return [0, sub(str, 0, last_pos$1), acc];
     if(is_delim(caml_string_get(str, last_pos$0))){
      var
       pos1 = caml_call2(Base_Import[90], last_pos$0, 1),
       sub_str = sub(str, pos1, caml_call2(Base_Import[92], last_pos$1, pos1)),
       pos = caml_call2(Base_Import[92], last_pos$0, 1),
       acc$0 = [0, sub_str, acc];
      acc = acc$0;
      last_pos$1 = last_pos$0;
      last_pos$0 = pos;
     }
     else{
      var pos$0 = caml_call2(Base_Import[92], last_pos$0, 1);
      last_pos$0 = pos$0;
     }
    }
   }
   function split(str, on){return split_gen(str, [0, -1044422954, on]);}
   function split_on_chars(str, chars){
    return split_gen(str, [0, 552554919, chars]);
   }
   function back_up_at_newline(t, pos, eol){
    a:
    {
     if(0 < pos[1]){
      var _bm_ = caml_string_get(t, caml_call2(Base_Import[92], pos[1], 1));
      if(caml_call2(Base_Char[15], _bm_, 13)){var _bn_ = 2; break a;}
     }
     var _bn_ = 1;
    }
    pos[1] = caml_call2(Base_Import[92], pos[1], _bn_);
    eol[1] = caml_call2(Base_Import[90], pos[1], 1);
    return;
   }
   function split_lines(t){
    var n = caml_ml_string_length(t);
    if(0 === n) return 0;
    var
     pos = [0, caml_call2(Base_Import[92], n, 1)],
     eol = [0, n],
     ac = [0, 0],
     _bi_ = caml_string_get(t, pos[1]);
    if(caml_call2(Base_Char[15], _bi_, 10)) back_up_at_newline(t, pos, eol);
    for(;;){
     if(0 > pos[1]){var _bl_ = ac[1]; return [0, sub(t, 0, eol[1]), _bl_];}
     var _bj_ = caml_string_get(t, pos[1]);
     if(caml_call2(Base_Char[14], _bj_, 10))
      caml_call1(Base_Import[128], pos);
     else{
      var start = caml_call2(Base_Import[90], pos[1], 1), _bk_ = ac[1];
      ac[1] =
       [0, sub(t, start, caml_call2(Base_Import[92], eol[1], start)), _bk_];
      back_up_at_newline(t, pos, eol);
     }
    }
   }
   function is_suffix$0(s, suffix){
    return is_suffix_gen(s, suffix, Base_Char[15]);
   }
   function is_prefix$0(s, prefix){
    return is_prefix_gen(s, prefix, Base_Char[15]);
   }
   function is_substring_at$0(s, pos, substring){
    return is_substring_at_gen(s, pos, substring, Base_Char[15]);
   }
   function wrap_sub_n(t, n, name, pos, len, on_error){
    if(0 <= n)
     try{var _bf_ = sub(t, pos, len); return _bf_;}
     catch(_bh_){return on_error;}
    var
     _bg_ = caml_call2(symbol_concat, name, cst_expecting_nonnegative_argu);
    return caml_call1(Base_Import[125], _bg_);
   }
   function drop_prefix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_drop_prefix,
             n,
             caml_call2(Base_Import[92], caml_ml_string_length(t), n),
             cst$0);
   }
   function drop_suffix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_drop_suffix,
             0,
             caml_call2(Base_Import[92], caml_ml_string_length(t), n),
             cst$1);
   }
   function prefix(t, n){return wrap_sub_n(t, n, cst_prefix, 0, n, t);}
   function suffix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_suffix,
             caml_call2(Base_Import[92], caml_ml_string_length(t), n),
             n,
             t);
   }
   function lfindi(opt, t, f){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var n = caml_ml_string_length(t), i = pos;
    for(;;){
     if(i === n) return 0;
     if(caml_call2(f, i, caml_string_get(t, i))) return [0, i];
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
    }
   }
   function find(t, f){
    var match = lfindi(0, t, function(param, c){return caml_call1(f, c);});
    if(! match) return 0;
    var i = match[1];
    return [0, caml_string_get(t, i)];
   }
   function find_map(t, f){
    var n = caml_ml_string_length(t), i = 0;
    for(;;){
     if(i === n) return 0;
     var res = caml_call1(f, caml_string_get(t, i));
     if(res) return res;
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
    }
   }
   function rfindi(pos, t, f){
    if(pos)
     var pos$0 = pos[1], pos$1 = pos$0;
    else
     var pos$1 = caml_call2(Base_Import[92], caml_ml_string_length(t), 1);
    var i = pos$1;
    for(;;){
     if(0 > i) return 0;
     if(caml_call2(f, i, caml_string_get(t, i))) return [0, i];
     var i$0 = caml_call2(Base_Import[92], i, 1);
     i = i$0;
    }
   }
   function last_non_drop(drop, t){
    return rfindi(0, t, function(param, c){return 1 - caml_call1(drop, c);});
   }
   function rstrip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var match = last_non_drop(drop, t);
    if(! match) return cst$2;
    var i = match[1];
    return i === caml_call2(Base_Import[92], caml_ml_string_length(t), 1)
            ? t
            : prefix(t, caml_call2(Base_Import[90], i, 1));
   }
   function first_non_drop(drop, t){
    return lfindi(0, t, function(param, c){return 1 - caml_call1(drop, c);});
   }
   function lstrip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var match = first_non_drop(drop, t);
    if(! match) return cst$3;
    var n = match[1];
    return 0 === n ? t : drop_prefix(t, n);
   }
   function strip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var length = caml_ml_string_length(t);
    a:
    if(0 !== length){
     if
      (!
       caml_call1(drop, caml_string_get(t, 0))
       &&
        !
        caml_call1
         (drop, caml_string_get(t, caml_call2(Base_Import[92], length, 1))))
      break a;
     var match = first_non_drop(drop, t);
     if(! match) return cst$4;
     var first = match[1], match$0 = last_non_drop(drop, t);
     if(! match$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
     var last = match$0[1], _be_ = caml_call2(Base_Import[92], last, first);
     return sub(t, first, caml_call2(Base_Import[90], _be_, 1));
    }
    return t;
   }
   function mapi(t, f){
    var
     l = caml_ml_string_length(t),
     t$0 = caml_call1(Base_Bytes0[7], l),
     _bc_ = caml_call2(Base_Import[92], l, 1),
     _bb_ = 0;
    if(_bc_ >= 0){
     var i = _bb_;
     for(;;){
      caml_bytes_unsafe_set(t$0, i, caml_call2(f, i, caml_string_get(t, i)));
      var _bd_ = i + 1 | 0;
      if(_bc_ === i) break;
      i = _bd_;
     }
    }
    return caml_call1(Base_Bytes0[16], t$0);
   }
   function map(t, f){
    var
     l = caml_ml_string_length(t),
     t$0 = caml_call1(Base_Bytes0[7], l),
     _a$_ = caml_call2(Base_Import[92], l, 1),
     _a__ = 0;
    if(_a$_ >= 0){
     var i = _a__;
     for(;;){
      caml_bytes_unsafe_set(t$0, i, caml_call1(f, caml_string_get(t, i)));
      var _ba_ = i + 1 | 0;
      if(_a$_ === i) break;
      i = _ba_;
     }
    }
    return caml_call1(Base_Bytes0[16], t$0);
   }
   function to_array(s){
    return caml_call2
            (Base_Array0[11],
             caml_ml_string_length(s),
             function(i){return caml_string_get(s, i);});
   }
   function exists(s, f){
    var len = caml_ml_string_length(s), i = 0;
    for(;;){
     var _a7_ = i < len ? 1 : 0;
     if(_a7_){
      var _a8_ = caml_call1(f, caml_string_get(s, i));
      if(! _a8_){
       var i$0 = caml_call2(Base_Import[90], i, 1);
       i = i$0;
       continue;
      }
      var _a9_ = _a8_;
     }
     else
      var _a9_ = _a7_;
     return _a9_;
    }
   }
   function for_all(s, f){
    var len = caml_ml_string_length(s), i = 0;
    for(;;){
     var _a4_ = i === len ? 1 : 0;
     if(_a4_)
      var _a5_ = _a4_;
     else{
      var _a6_ = caml_call1(f, caml_string_get(s, i));
      if(_a6_){
       var i$0 = caml_call2(Base_Import[90], i, 1);
       i = i$0;
       continue;
      }
      var _a5_ = _a6_;
     }
     return _a5_;
    }
   }
   function fold(t, init, f){
    var len = caml_ml_string_length(t), i = 0, ac = init;
    for(;;){
     if(i === len) return ac;
     var
      ac$0 = caml_call2(f, ac, caml_string_get(t, i)),
      i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     ac = ac$0;
    }
   }
   function foldi(t, init, f){
    var len = caml_ml_string_length(t), i = 0, ac = init;
    for(;;){
     if(i === len) return ac;
     var
      ac$0 = caml_call3(f, i, ac, caml_string_get(t, i)),
      i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
     ac = ac$0;
    }
   }
   function iteri(t, f){
    var
     _a2_ = caml_call2(Base_Import[92], caml_ml_string_length(t), 1),
     _a1_ = 0;
    if(_a2_ >= 0){
     var i = _a1_;
     for(;;){
      caml_call2(f, i, caml_string_unsafe_get(t, i));
      var _a3_ = i + 1 | 0;
      if(_a2_ === i) break;
      i = _a3_;
     }
    }
    return 0;
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t){return caml_call2(Base_Container[3], fold, t);}
   function max_elt(t){return caml_call2(Base_Container[4], fold, t);}
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f){
    var _aZ_ = caml_call3(Base_Container[9], fold, init, f);
    return function(_a0_){return caml_call2(_aZ_, _a0_, t);};
   }
   function find_mapi(t, f){
    return caml_call3(Base_Indexed_container[7], iteri, t, f);
   }
   function findi(t, f){
    return caml_call3(Base_Indexed_container[6], iteri, t, f);
   }
   function counti(t, f){
    return caml_call3(Base_Indexed_container[3], foldi, t, f);
   }
   function for_alli(t, f){
    return caml_call3(Base_Indexed_container[5], iteri, t, f);
   }
   function existsi(t, f){
    return caml_call3(Base_Indexed_container[4], iteri, t, f);
   }
   function mem(t, c){
    var len = caml_ml_string_length(t), i = 0;
    for(;;){
     var _aW_ = i < len ? 1 : 0;
     if(_aW_){
      var _aX_ = caml_call2(Base_Char[15], c, caml_string_unsafe_get(t, i));
      if(! _aX_){
       var i$0 = caml_call2(Base_Import[90], i, 1);
       i = i$0;
       continue;
      }
      var _aY_ = _aX_;
     }
     else
      var _aY_ = _aW_;
     return _aY_;
    }
   }
   function tr(target, replacement, s){
    return caml_call2(Base_Char[15], target, replacement)
            ? s
            : mem
               (s, target)
              ? map
                (s,
                 function(c){
                  return caml_call2(Base_Char[15], c, target)
                          ? replacement
                          : c;
                 })
              : s;
   }
   function tr_multi(target, replacement){
    if(is_empty(target))
     return caml_call1(stage, function(_aV_){return _aV_;});
    if(is_empty(replacement))
     return caml_call1(Base_Import[125], cst_tr_multi_replacement_is_em);
    var match = caml_call2(Base_Bytes_tr[1], target, replacement);
    if(! match) return caml_call1(stage, function(_aU_){return _aU_;});
    var tr_map = match[1];
    return caml_call1
            (stage,
             function(s){
              return exists
                       (s,
                        function(c){
                         var
                          _aT_ =
                            caml_string_unsafe_get(tr_map, caml_call1(Base_Char[29], c));
                         return caml_call2(Base_Char[14], c, _aT_);
                        })
                      ? map
                        (s,
                         function(c){
                          return caml_string_unsafe_get
                                  (tr_map, caml_call1(Base_Char[29], c));
                         })
                      : s;
             });
   }
   function concat_array(sep, ar){
    return caml_call2(concat, sep, caml_call1(Base_Array0[15], ar));
   }
   function concat_map(sep, s, f){
    var _aS_ = to_array(s);
    return concat_array(sep, caml_call2(Base_Array0[20], _aS_, f));
   }
   function filter(t, f){
    var n = caml_ml_string_length(t), i = [0, 0];
    for(;;){
     if(i[1] >= n) break;
     if(! caml_call1(f, caml_string_get(t, i[1]))) break;
     caml_call1(Base_Import[129], i);
    }
    if(i[1] === n) return t;
    var
     _aQ_ = caml_call2(Base_Import[92], n, 1),
     out = caml_call1(Base_Bytes0[7], _aQ_);
    caml_call5(Base_Bytes0[4], t, 0, out, 0, i[1]);
    var out_pos = [0, i[1]];
    caml_call1(Base_Import[129], i);
    for(;;){
     if(i[1] >= n){
      var
       out$0 = caml_call1(Base_Bytes0[16], out),
       _aR_ = caml_call2(Base_Import[92], n, 1);
      return out_pos[1] === _aR_ ? out$0 : sub(out$0, 0, out_pos[1]);
     }
     var c = caml_string_get(t, i[1]);
     if(caml_call1(f, c)){
      caml_bytes_set(out, out_pos[1], c);
      caml_call1(Base_Import[129], out_pos);
     }
     caml_call1(Base_Import[129], i);
    }
   }
   function filteri(t, f){
    var n = caml_ml_string_length(t), i = [0, 0];
    for(;;){
     if(i[1] >= n) break;
     var _aN_ = caml_string_get(t, i[1]);
     if(! caml_call2(f, i[1], _aN_)) break;
     caml_call1(Base_Import[129], i);
    }
    if(i[1] === n) return t;
    var
     _aO_ = caml_call2(Base_Import[92], n, 1),
     out = caml_call1(Base_Bytes0[7], _aO_);
    caml_call5(Base_Bytes0[4], t, 0, out, 0, i[1]);
    var out_pos = [0, i[1]];
    caml_call1(Base_Import[129], i);
    for(;;){
     if(i[1] >= n){
      var
       out$0 = caml_call1(Base_Bytes0[16], out),
       _aP_ = caml_call2(Base_Import[92], n, 1);
      return out_pos[1] === _aP_ ? out$0 : sub(out$0, 0, out_pos[1]);
     }
     var c = caml_string_get(t, i[1]);
     if(caml_call2(f, i[1], c)){
      caml_bytes_set(out, out_pos[1], c);
      caml_call1(Base_Import[129], out_pos);
     }
     caml_call1(Base_Import[129], i);
    }
   }
   function chop_prefix(s, prefix){
    return is_prefix$0(s, prefix)
            ? [0, drop_prefix(s, caml_ml_string_length(prefix))]
            : 0;
   }
   function chop_prefix_if_exists(s, prefix){
    return is_prefix$0(s, prefix)
            ? drop_prefix(s, caml_ml_string_length(prefix))
            : s;
   }
   function chop_prefix_exn(s, prefix){
    var match = chop_prefix(s, prefix);
    if(! match) return caml_call4(invalid_argf, _v_, s, prefix, 0);
    var str = match[1];
    return str;
   }
   function chop_suffix(s, suffix){
    return is_suffix$0(s, suffix)
            ? [0, drop_suffix(s, caml_ml_string_length(suffix))]
            : 0;
   }
   function chop_suffix_if_exists(s, suffix){
    return is_suffix$0(s, suffix)
            ? drop_suffix(s, caml_ml_string_length(suffix))
            : s;
   }
   function chop_suffix_exn(s, suffix){
    var match = chop_suffix(s, suffix);
    if(! match) return caml_call4(invalid_argf, _w_, s, suffix, 0);
    var str = match[1];
    return str;
   }
   function shorter(a, b){
    return caml_ml_string_length(a) <= caml_ml_string_length(b) ? a : b;
   }
   function shortest(list){
    if(! list) return cst$5;
    var rest = list[2], first = list[1];
    return caml_call3(Base_List[10], rest, first, shorter);
   }
   function pos_from_left(param, i){return i;}
   function pos_from_right(t, i){
    var _aM_ = caml_call2(Base_Import[92], caml_ml_string_length(t), i);
    return caml_call2(Base_Import[92], _aM_, 1);
   }
   function common_generic2_length_loop(a, b, get_pos, max_len, len_so_far){
    var len_so_far$0 = len_so_far;
    for(;;){
     if(max_len <= len_so_far$0) return max_len;
     var
      _aK_ = caml_string_unsafe_get(b, caml_call2(get_pos, b, len_so_far$0)),
      _aL_ = caml_string_unsafe_get(a, caml_call2(get_pos, a, len_so_far$0));
     if(! caml_call2(Base_Char[15], _aL_, _aK_)) return len_so_far$0;
     var len_so_far$1 = caml_call2(Base_Import[90], len_so_far$0, 1);
     len_so_far$0 = len_so_far$1;
    }
   }
   function common_generic2_length(a, b, get_pos){
    var
     max_len =
       caml_call2
        (Base_Import[100], caml_ml_string_length(a), caml_ml_string_length(b));
    return common_generic2_length_loop(a, b, get_pos, max_len, 0);
   }
   function common_generic_length_loop(first, list, get_pos, max_len){
    var first$0 = first, list$0 = list, max_len$0 = max_len;
    for(;;){
     if(! list$0) return max_len$0;
     var
      rest = list$0[2],
      second = list$0[1],
      max_len$1 =
        common_generic2_length_loop(first$0, second, get_pos, max_len$0, 0);
     first$0 = second;
     list$0 = rest;
     max_len$0 = max_len$1;
    }
   }
   function common_generic_length(list, get_pos){
    if(! list) return 0;
    var
     rest = list[2],
     first = list[1],
     max_len = caml_ml_string_length(shortest(list));
    return common_generic_length_loop(first, rest, get_pos, max_len);
   }
   function common_generic2(a, b, get_pos, take){
    var len = common_generic2_length(a, b, get_pos);
    return caml_call2(take, shorter(a, b), len);
   }
   function common_generic(list, get_pos, take){
    if(! list) return cst$7;
    var
     rest = list[2],
     first = list[1],
     s = shortest(list),
     max_len = caml_ml_string_length(s);
    if(0 === max_len) return cst$6;
    var len = common_generic_length_loop(first, rest, get_pos, max_len);
    return caml_call2(take, s, len);
   }
   function common_prefix(list){
    return common_generic(list, pos_from_left, prefix);
   }
   function common_suffix(list){
    return common_generic(list, pos_from_right, suffix);
   }
   function common_prefix2(a, b){
    return common_generic2(a, b, pos_from_left, prefix);
   }
   function common_suffix2(a, b){
    return common_generic2(a, b, pos_from_right, suffix);
   }
   function common_prefix_length(list){
    return common_generic_length(list, pos_from_left);
   }
   function common_suffix_length(list){
    return common_generic_length(list, pos_from_right);
   }
   function common_prefix2_length(a, b){
    return common_generic2_length(a, b, pos_from_left);
   }
   function common_suffix2_length(a, b){
    return common_generic2_length(a, b, pos_from_right);
   }
   function pp(ppf, string){
    return caml_call3(Stdlib_Format[129], ppf, _x_, string);
   }
   function of_char(c){return caml_call2(make, 1, c);}
   function of_char_list(l){
    var
     _aJ_ = caml_call1(Base_List[7], l),
     t = caml_call1(Base_Bytes0[7], _aJ_);
    caml_call2
     (Base_List[98], l, function(i, c){return caml_bytes_set(t, i, c);});
    return caml_call1(Base_Bytes0[16], t);
   }
   function build_and_validate_escapeworth
   (escapeworthy_map, escape_char, func){
    var
     escapeworthy_map$0 =
       caml_call3
         (Base_List[129][7], escapeworthy_map, Base_Char[15], escape_char)
        ? escapeworthy_map
        : [0, [0, escape_char, escape_char], escapeworthy_map],
     arr = caml_call2(Base_Array0[4], 256, -1),
     vals = caml_call2(Base_Array0[4], 256, 0),
     param = escapeworthy_map$0;
    for(;;){
     if(! param) return [0, arr];
     var l = param[2], match = param[1], c_to = match[2], c_from = match[1];
     if(919809722 <= func)
      var v = c_from, k = caml_call1(Base_Char[29], c_to);
     else
      var k$0 = caml_call1(Base_Char[29], c_from), v = c_to, k = k$0;
     if(-1 !== caml_check_bound(arr, k)[1 + k]) break;
     var _aB_ = caml_call1(Base_Char[29], v);
     if(caml_check_bound(vals, _aB_)[1 + _aB_]) break;
     var _aH_ = caml_call1(Base_Char[29], v);
     caml_check_bound(arr, k)[1 + k] = _aH_;
     var _aI_ = caml_call1(Base_Char[29], v);
     caml_check_bound(vals, _aI_)[1 + _aI_] = 1;
     param = l;
    }
    var
     _aC_ = caml_call2(Base_Import[149], Base_Import[140], Base_Import[140]),
     _aD_ =
       [0,
        [0,
         cst_escapeworthy_map,
         caml_call2(Base_Import[151], _aC_, escapeworthy_map$0)],
        0],
     _aE_ = [0, [0, cst_c_to, caml_call1(Base_Import[140], c_to)], _aD_],
     _aF_ = [0, [0, cst_c_from, caml_call1(Base_Import[140], c_from)], _aE_],
     _aG_ = caml_call2(Base_Sexp[9], cst_escapeworthy_map_not_one_t, _aF_);
    return caml_call1(Base_Or_error[35], _aG_);
   }
   function escape_gen(escapeworthy_map, escape_char){
    var
     x =
       build_and_validate_escapeworth
        (escapeworthy_map, escape_char, 258914209);
    if(0 !== x[0]) return x;
    var escapeworthy = x[1];
    return [0,
            function(src){
             var
              to_escape_len = [0, 0],
              to_escape =
                foldi
                 (src,
                  0,
                  function(i, acc, c){
                   var
                    _aA_ = caml_call1(Base_Char[29], c),
                    n = caml_check_bound(escapeworthy, _aA_)[1 + _aA_];
                   return -1 === n
                           ? acc
                           : (caml_call1
                              (Base_Import[129], to_escape_len),
                             [0, [0, i, caml_call1(Base_Char[32], n)], acc]);
                  });
             if(! to_escape) return src;
             var
              last_idx = caml_ml_string_length(src),
              last_dst_pos =
                caml_call2(Base_Import[90], last_idx, to_escape_len[1]),
              dst = caml_call1(Base_Bytes0[7], last_dst_pos),
              last_idx$0 = last_idx,
              last_dst_pos$0 = last_dst_pos,
              param = to_escape;
             for(;;){
              if(! param){
               caml_call5(Base_Bytes0[4], src, 0, dst, 0, last_idx$0);
               return caml_call1(Base_Bytes0[16], dst);
              }
              var
               to_escape$0 = param[2],
               match = param[1],
               escaped_char = match[2],
               last_idx$1 = match[1],
               _ay_ = caml_call2(Base_Import[92], last_idx$0, last_idx$1),
               len = caml_call2(Base_Import[92], _ay_, 1),
               dst_pos = caml_call2(Base_Import[92], last_dst_pos$0, len),
               _az_ = caml_call2(Base_Import[90], last_idx$1, 1);
              caml_call5(Base_Bytes0[4], src, _az_, dst, dst_pos, len);
              var last_dst_pos$1 = caml_call2(Base_Import[92], dst_pos, 2);
              caml_bytes_set(dst, last_dst_pos$1, escape_char);
              caml_bytes_set
               (dst,
                caml_call2(Base_Import[90], last_dst_pos$1, 1),
                escaped_char);
              last_idx$0 = last_idx$1;
              last_dst_pos$0 = last_dst_pos$1;
              param = to_escape$0;
             }
            }];
   }
   function escape_gen_exn(escapeworthy_map, escape_char){
    var _ax_ = escape_gen(escapeworthy_map, escape_char);
    return caml_call1(stage, caml_call1(Base_Or_error[31], _ax_));
   }
   function escape(escapeworthy, escape_char){
    var
     _aw_ = caml_call2(Base_List[114], escapeworthy, Base_Char[16]),
     escapeworthy_map =
       caml_call2(Base_List[76], _aw_, function(c){return [0, c, c];});
    return escape_gen_exn(escapeworthy_map, escape_char);
   }
   function unescape_gen(escapeworthy_map, escape_char){
    var
     x =
       build_and_validate_escapeworth
        (escapeworthy_map, escape_char, 919809722);
    if(0 !== x[0]) return x;
    var escapeworthy = x[1];
    return [0,
            function(src){
             var i = 0, status = -512962225, to_unescape = 0;
             for(;;){
              if(caml_ml_string_length(src) <= i) break;
              if(-512962225 <= status)
               var
                _ao_ = caml_string_get(src, i),
                status$0 =
                  caml_call2(Base_Char[15], _ao_, escape_char)
                   ? -767030498
                   : -512962225;
              else
               var status$0 = -244189789;
              var
               acc =
                 -512962225 <= status$0 ? to_unescape : [0, i, to_unescape],
               i$0 = caml_call2(Base_Import[90], i, 1);
              i = i$0;
              status = status$0;
              to_unescape = acc;
             }
             if(! to_unescape) return src;
             var
              to_unescape$0 = to_unescape[2],
              idx = to_unescape[1],
              _ap_ = caml_call1(Base_List[7], to_unescape),
              _aq_ =
                caml_call2(Base_Import[92], caml_ml_string_length(src), _ap_),
              dst = caml_call1(Base_Bytes0[7], _aq_);
             function loop(last_idx, last_dst_pos, param){
              var
               last_idx$0 = last_idx,
               last_dst_pos$0 = last_dst_pos,
               param$0 = param;
              for(;;){
               if(! param$0)
                return caml_call5(Base_Bytes0[4], src, 0, dst, 0, last_idx$0);
               var
                to_unescape = param$0[2],
                last_idx$1 = param$0[1],
                _ar_ = caml_call2(Base_Import[92], last_idx$0, last_idx$1),
                len = caml_call2(Base_Import[92], _ar_, 2),
                dst_pos = caml_call2(Base_Import[92], last_dst_pos$0, len),
                _as_ = caml_call2(Base_Import[90], last_idx$1, 2);
               caml_call5(Base_Bytes0[4], src, _as_, dst, dst_pos, len);
               var
                last_dst_pos$1 = caml_call2(Base_Import[92], dst_pos, 1),
                _at_ =
                  caml_string_get
                   (src, caml_call2(Base_Import[90], last_idx$1, 1)),
                _au_ = caml_call1(Base_Char[29], _at_),
                n = caml_check_bound(escapeworthy, _au_)[1 + _au_],
                _av_ =
                  -1 === n
                   ? caml_string_get
                     (src, caml_call2(Base_Import[90], last_idx$1, 1))
                   : caml_call1(Base_Char[32], n);
               caml_bytes_set(dst, last_dst_pos$1, _av_);
               last_idx$0 = last_idx$1;
               last_dst_pos$0 = last_dst_pos$1;
               param$0 = to_unescape;
              }
             }
             if
              (idx
               < caml_call2(Base_Import[92], caml_ml_string_length(src), 1))
              loop
               (caml_ml_string_length(src),
                caml_ml_bytes_length(dst),
                to_unescape);
             else
              loop
               (caml_call2(Base_Import[92], caml_ml_string_length(src), 1),
                caml_ml_bytes_length(dst),
                to_unescape$0);
             return caml_call1(Base_Bytes0[16], dst);
            }];
   }
   function unescape_gen_exn(escapeworthy_map, escape_char){
    var _an_ = unescape_gen(escapeworthy_map, escape_char);
    return caml_call1(stage, caml_call1(Base_Or_error[31], _an_));
   }
   function unescape(escape_char){return unescape_gen_exn(0, escape_char);}
   function preceding_escape_chars(str, escape_char, pos){
    var p$1 = caml_call2(Base_Import[92], pos, 1), p = p$1, cnt = 0;
    for(;;){
     if(0 <= p){
      var _am_ = caml_string_get(str, p);
      if(! caml_call2(Base_Char[14], _am_, escape_char)){
       var
        cnt$0 = caml_call2(Base_Import[90], cnt, 1),
        p$0 = caml_call2(Base_Import[92], p, 1);
       p = p$0;
       cnt = cnt$0;
       continue;
      }
     }
     return cnt;
    }
   }
   function update_escape_status(str, escape_char, i, param){
    if(-512962225 > param) return -244189789;
    var _al_ = caml_string_get(str, i);
    return caml_call2(Base_Char[15], _al_, escape_char)
            ? -767030498
            : -512962225;
   }
   function escape_status(str, escape_char, pos){
    var
     _aj_ = preceding_escape_chars(str, escape_char, pos),
     odd = 1 === caml_call2(Base_Import[121], _aj_, 2) ? 1 : 0,
     _ak_ = caml_string_get(str, pos),
     match = caml_call2(Base_Char[15], _ak_, escape_char);
    return odd ? -244189789 : match ? -767030498 : -512962225;
   }
   function check_bound(str, pos, function_name){
    var
     _ah_ = caml_ml_string_length(str) <= pos ? 1 : 0,
     _ai_ = _ah_ || (pos < 0 ? 1 : 0);
    return _ai_ ? caml_call3(invalid_argf, _y_, function_name, 0) : _ai_;
   }
   function is_char_escaping(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_escaping);
    return -512962225 <= escape_status(str, escape_char, pos) ? 0 : 1;
   }
   function is_char_escaped(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_escaped);
    return -244189789 <= escape_status(str, escape_char, pos) ? 1 : 0;
   }
   function is_char_literal(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_literal);
    return -512962225 === escape_status(str, escape_char, pos) ? 1 : 0;
   }
   function index_from$0(str, escape_char, pos, char$0){
    check_bound(str, pos, cst_index_from);
    var
     status$1 = escape_status(str, escape_char, pos),
     i = pos,
     status = status$1;
    for(;;){
     if(pos <= i){
      var _af_ = -512962225 === status ? 1 : 0;
      if(_af_){
       var _ag_ = caml_string_get(str, i);
       if(caml_call2(Base_Char[15], _ag_, char$0)) return [0, i];
      }
     }
     var i$0 = caml_call2(Base_Import[90], i, 1);
     if(caml_ml_string_length(str) <= i$0) return 0;
     var status$0 = update_escape_status(str, escape_char, i$0, status);
     i = i$0;
     status = status$0;
    }
   }
   function index_from_exn$0(str, escape_char, pos, char$0){
    var match = index_from$0(str, escape_char, pos, char$0);
    if(match){var pos$0 = match[1]; return pos$0;}
    var
     _ab_ = [0, [0, cst_char, caml_call1(Base_Import[140], char$0)], 0],
     _ac_ = [0, [0, cst_pos, caml_call1(Base_Import[141], pos)], _ab_],
     _ad_ =
       [0,
        [0, cst_escape_char, caml_call1(Base_Import[140], escape_char)],
        _ac_],
     _ae_ = [0, [0, cst_str, caml_call1(sexp_of_t, str)], _ad_];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[9], cst_index_from_exn_not_found, _ae_));
   }
   function index$1(str, escape_char, char$0){
    return index_from$0(str, escape_char, 0, char$0);
   }
   function index_exn$1(str, escape_char, char$0){
    return index_from_exn$0(str, escape_char, 0, char$0);
   }
   function rindex_from$0(str, escape_char, pos, char$0){
    check_bound(str, pos, cst_rindex_from);
    if(caml_call2(Base_Char[15], char$0, escape_char)) return 0;
    var pos$0 = pos;
    for(;;){
     if(0 > pos$0) return 0;
     var escape_chars = preceding_escape_chars(str, escape_char, pos$0);
     if(0 === caml_call2(Base_Import[121], escape_chars, 2)){
      var _$_ = caml_string_get(str, pos$0);
      if(caml_call2(Base_Char[15], _$_, char$0)) return [0, pos$0];
     }
     var
      _aa_ = caml_call2(Base_Import[92], pos$0, escape_chars),
      pos$1 = caml_call2(Base_Import[92], _aa_, 1);
     pos$0 = pos$1;
    }
   }
   function rindex_from_exn$0(str, escape_char, pos, char$0){
    var match = rindex_from$0(str, escape_char, pos, char$0);
    if(match){var pos$0 = match[1]; return pos$0;}
    var
     _X_ = [0, [0, cst_char$0, caml_call1(Base_Import[140], char$0)], 0],
     _Y_ = [0, [0, cst_pos$0, caml_call1(Base_Import[141], pos)], _X_],
     _Z_ =
       [0,
        [0, cst_escape_char$0, caml_call1(Base_Import[140], escape_char)],
        _Y_],
     ___ = [0, [0, cst_str$0, caml_call1(sexp_of_t, str)], _Z_];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[9], cst_rindex_from_exn_not_found, ___));
   }
   function rindex$0(str, escape_char, char$0){
    return is_empty(str)
            ? 0
            : rindex_from$0
              (str,
               escape_char,
               caml_call2(Base_Import[92], caml_ml_string_length(str), 1),
               char$0);
   }
   function rindex_exn$0(str, escape_char, char$0){
    return rindex_from_exn$0
            (str,
             escape_char,
             caml_call2(Base_Import[92], caml_ml_string_length(str), 1),
             char$0);
   }
   function split_gen$0(str, escape_char, on){
    if(552554919 <= on[1])
     var l = on[2], is_delim = function(c){return char_list_mem(l, c);};
    else
     var
      c = on[2],
      is_delim = function(c$0){return caml_call2(Base_Char[15], c$0, c);};
    var
     len = caml_ml_string_length(str),
     acc = 0,
     status = -512962225,
     last_pos = 0,
     pos = 0;
    for(;;){
     if(pos === len){
      var
       _V_ =
         [0,
          sub(str, last_pos, caml_call2(Base_Import[92], len, last_pos)),
          acc];
      return caml_call1(Base_List[38], _V_);
     }
     var
      status$0 = update_escape_status(str, escape_char, pos, status),
      _W_ = -512962225 === status$0 ? 1 : 0;
     if(_W_ && is_delim(caml_string_get(str, pos))){
      var
       sub_str =
         sub(str, last_pos, caml_call2(Base_Import[92], pos, last_pos)),
       pos$0 = caml_call2(Base_Import[90], pos, 1),
       last_pos$0 = caml_call2(Base_Import[90], pos, 1),
       acc$0 = [0, sub_str, acc];
      acc = acc$0;
      status = status$0;
      last_pos = last_pos$0;
      pos = pos$0;
      continue;
     }
     var pos$1 = caml_call2(Base_Import[90], pos, 1);
     status = status$0;
     pos = pos$1;
    }
   }
   function split$0(str, on){
    var _T_ = [0, -1044422954, on];
    return function(_U_){return split_gen$0(str, _U_, _T_);};
   }
   function split_on_chars$0(str, chars){
    var _R_ = [0, 552554919, chars];
    return function(_S_){return split_gen$0(str, _S_, _R_);};
   }
   function split_at(str, pos){
    var
     _O_ = caml_call2(Base_Import[92], caml_ml_string_length(str), pos),
     _P_ = caml_call2(Base_Import[92], _O_, 1),
     _Q_ = sub(str, caml_call2(Base_Import[90], pos, 1), _P_);
    return [0, sub(str, 0, pos), _Q_];
   }
   function lsplit2$0(str, on, escape_char){
    var _N_ = index$1(str, escape_char, on);
    return caml_call2
            (Base_Option[21], _N_, function(x){return split_at(str, x);});
   }
   function rsplit2$0(str, on, escape_char){
    var _M_ = rindex$0(str, escape_char, on);
    return caml_call2
            (Base_Option[21], _M_, function(x){return split_at(str, x);});
   }
   function lsplit2_exn$0(str, on, escape_char){
    return split_at(str, index_exn$1(str, escape_char, on));
   }
   function rsplit2_exn$0(str, on, escape_char){
    return split_at(str, rindex_exn$0(str, escape_char, on));
   }
   function last_non_drop_literal(drop, escape_char, t){
    return rfindi
            (0,
             t,
             function(i, c){
              var _J_ = 1 - caml_call1(drop, c);
              if(_J_)
               var _K_ = _J_;
              else{
               var _L_ = is_char_escaping(t, escape_char, i);
               if(! _L_) return is_char_escaped(t, escape_char, i);
               var _K_ = _L_;
              }
              return _K_;
             });
   }
   function first_non_drop_literal(drop, escape_char, t){
    return lfindi
            (0,
             t,
             function(i, c){
              var _G_ = 1 - caml_call1(drop, c);
              if(_G_)
               var _H_ = _G_;
              else{
               var _I_ = is_char_escaping(t, escape_char, i);
               if(! _I_) return is_char_escaped(t, escape_char, i);
               var _H_ = _I_;
              }
              return _H_;
             });
   }
   function rstrip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var match = last_non_drop_literal(drop, escape_char, t);
    if(! match) return cst$8;
    var i = match[1];
    return i === caml_call2(Base_Import[92], caml_ml_string_length(t), 1)
            ? t
            : prefix(t, caml_call2(Base_Import[90], i, 1));
   }
   function lstrip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var match = first_non_drop_literal(drop, escape_char, t);
    if(! match) return cst$9;
    var n = match[1];
    return 0 === n ? t : drop_prefix(t, n);
   }
   function strip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var length = caml_ml_string_length(t);
    a:
    if(0 !== length){
     if
      (!
       caml_call1(drop, caml_string_get(t, 0))
       &&
        !
        caml_call1
         (drop, caml_string_get(t, caml_call2(Base_Import[92], length, 1))))
      break a;
     var match = first_non_drop_literal(drop, escape_char, t);
     if(! match) return cst$10;
     var
      first = match[1],
      match$0 = last_non_drop_literal(drop, escape_char, t);
     if(! match$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
     var last = match$0[1], _F_ = caml_call2(Base_Import[92], last, first);
     return sub(t, first, caml_call2(Base_Import[90], _F_, 1));
    }
    return t;
   }
   function between$0(t, low, high){
    var _E_ = caml_call2(Base_Import[108][2], low, t);
    return _E_ ? caml_call2(Base_Import[108][2], t, high) : _E_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[108][1], t, min)
            ? min
            : caml_call2(Base_Import[108][2], t, max) ? t : max;
   }
   function clamp_exn$0(t, min, max){
    if(caml_call2(Base_Import[108][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
   }
   function clamp$0(t, min, max){
    if(! caml_call2(Base_Import[108][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _B_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _C_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _B_],
     _D_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _C_);
    return caml_call1(Base_Or_error[35], _D_);
   }
   function create$0(opt, pattern){
    if(opt)
     var sth = opt[1], case_sensitive = sth;
    else
     var case_sensitive = 1;
    return create(pattern, case_sensitive);
   }
   var
    include$1 = Base_Import[108],
    symbol$5 = include$1[1],
    symbol$6 = include$1[2],
    symbol$7 = include$1[3],
    symbol$8 = include$1[4],
    symbol$9 = include$1[5],
    symbol$10 = include$1[6],
    ascending$0 = include$1[7],
    descending$0 = include$1[8],
    compare$2 = include$1[9],
    equal$1 = include$1[10],
    max$0 = include$1[11],
    min$0 = include$1[12],
    Base_String =
      [0,
       t_sexp_grammar,
       sub,
       subo,
       mem,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       of_string,
       to_string,
       symbol$10,
       symbol$6,
       symbol$8,
       symbol$9,
       symbol$5,
       symbol$7,
       compare$2,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator,
       pp,
       hashable,
       invariant,
       max_length,
       make,
       copy,
       init,
       symbol_concat,
       concat,
       escaped,
       contains,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       [0,
        hash_fold_t$0,
        hash$0,
        t_of_sexp$0,
        sexp_of_t$2,
        t_sexp_grammar$0,
        symbol,
        symbol$0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        equal$0,
        compare$1,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator$0,
        is_suffix,
        is_prefix,
        is_substring$0,
        is_substring_at,
        substr_index$0,
        substr_index_exn$0,
        substr_index_all$0,
        substr_replace_first$0,
        substr_replace_all$0],
       index,
       index_exn,
       index_from,
       index_from_exn,
       rindex,
       rindex_exn,
       rindex_from,
       rindex_from_exn,
       [0,
        sexp_of_t$0,
        create$0,
        pattern,
        case_sensitive,
        matches,
        index$0,
        index_exn$0,
        index_all,
        replace_first,
        replace_all,
        split_on,
        Private],
       substr_index,
       substr_index_exn,
       substr_index_all,
       substr_replace_first,
       substr_replace_all,
       is_substring,
       is_substring_at$0,
       to_list_rev,
       rev,
       is_suffix$0,
       is_prefix$0,
       lsplit2_exn,
       rsplit2_exn,
       lsplit2,
       rsplit2,
       split,
       split_on_chars,
       split_lines,
       lfindi,
       rfindi,
       lstrip,
       rstrip,
       strip,
       map,
       mapi,
       foldi,
       concat_map,
       filter,
       filteri,
       tr,
       tr_multi,
       chop_suffix_exn,
       chop_prefix_exn,
       chop_suffix,
       chop_prefix,
       chop_suffix_if_exists,
       chop_prefix_if_exists,
       suffix,
       prefix,
       drop_suffix,
       drop_prefix,
       common_suffix,
       common_prefix,
       common_suffix_length,
       common_prefix_length,
       common_suffix2,
       common_prefix2,
       common_suffix2_length,
       common_prefix2_length,
       concat_array,
       equal$1,
       of_char,
       of_char_list,
       [0,
        escape_gen_exn,
        escape_gen,
        escape,
        unescape_gen_exn,
        unescape_gen,
        unescape,
        is_char_escaping,
        is_char_escaped,
        is_char_literal,
        index$1,
        index_exn$1,
        rindex$0,
        rindex_exn$0,
        index_from$0,
        index_from_exn$0,
        rindex_from$0,
        rindex_from_exn$0,
        split$0,
        split_on_chars$0,
        lsplit2$0,
        lsplit2_exn$0,
        rsplit2$0,
        rsplit2_exn$0,
        lstrip_literal,
        rstrip_literal,
        strip_literal]];
   runtime.caml_register_global(86, Base_String, "Base__String");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Blit, Base__Bytes0, Base__Bytes_tr, Base__Char, Base__Comparator, Base__Import, Base__List, Base__Or_error, Base__Ordered_collection_common, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Staged, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Bytes",
    Base_Char = global_data.Base__Char,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Bytes_tr = global_data.Base__Bytes_tr,
    Base_Array0 = global_data.Base__Array0,
    Base_List = global_data.Base__List,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Staged = global_data.Base__Staged,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Blit = global_data.Base__Blit,
    Base_Comparator = global_data.Base__Comparator,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    stage = Base_Staged[1],
    t_of_sexp = Base_Import[163],
    sexp_of_t = Base_Import[139],
    t_sexp_grammar = Base_Import[183],
    max_length = Base_Bytes0[2],
    compare = Base_Bytes0[5],
    copy = Base_Bytes0[6],
    create = Base_Bytes0[7],
    fill = Base_Bytes0[8],
    make = Base_Bytes0[9],
    map = Base_Bytes0[10],
    mapi = Base_Bytes0[11],
    unsafe_blit = Base_Bytes0[13],
    to_string = Base_Bytes0[14],
    of_string = Base_Bytes0[15],
    unsafe_to_string = Base_Bytes0[16],
    unsafe_of_string_promise_no_mu = Base_Bytes0[17],
    _a_ = [0, [3, 0, 0], "%S"];
   function pp(fmt, t){
    var _w_ = caml_call1(to_string, t);
    return caml_call3(Stdlib_Format[129], fmt, _a_, _w_);
   }
   function create$0(len){return caml_call1(create, len);}
   var
    To_bytes =
      caml_call1
       (Base_Blit[1], [0, caml_ml_bytes_length, create$0, unsafe_blit]),
    blit = To_bytes[1],
    blito = To_bytes[2],
    unsafe_blit$0 = To_bytes[3],
    sub = To_bytes[4],
    subo = To_bytes[5],
    comparator = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t])[1],
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    To_string = caml_call1(caml_call1(Base_Blit[3], [0]), To_bytes);
   function create$1(len){return caml_call1(create, len);}
   var
    length = caml_ml_bytes_length,
    unsafe_blit$1 = runtime.caml_blit_string,
    length$0 = caml_ml_string_length,
    From_string =
      caml_call1
       (caml_call1(Base_Blit[2], [0, length$0]),
        [0, length, create$1, unsafe_blit$1]),
    _b_ = [0, [11, "Bytes.init ", [4, 0, 0, 0, 0]], "Bytes.init %d"],
    cst_tr_multi_replacement_is_th =
      "tr_multi: replacement is the empty string",
    _c_ = [0, "src/bytes.ml", 128, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function invariant(param){return 0;}
   function init(n, f){
    if(n < 0) caml_call3(Base_Printf[7], _b_, n, 0);
    var
     t = caml_call1(create, n),
     _u_ = caml_call2(Base_Import[92], n, 1),
     _t_ = 0;
    if(_u_ >= 0){
     var i = _t_;
     for(;;){
      caml_bytes_unsafe_set(t, i, caml_call1(f, i));
      var _v_ = i + 1 | 0;
      if(_u_ === i) break;
      i = _v_;
     }
    }
    return t;
   }
   function of_char_list(l){
    var t = caml_call1(create, caml_call1(Base_List[7], l));
    caml_call2
     (Base_List[98], l, function(i, c){return caml_bytes_set(t, i, c);});
    return t;
   }
   function to_list(t){
    var
     i$1 = caml_call2(Base_Import[92], caml_ml_bytes_length(t), 1),
     i = i$1,
     acc = 0;
    for(;;){
     if(0 > i) return acc;
     var
      acc$0 = [0, caml_bytes_unsafe_get(t, i), acc],
      i$0 = caml_call2(Base_Import[92], i, 1);
     i = i$0;
     acc = acc$0;
    }
   }
   function to_array(t){
    return caml_call2
            (Base_Array0[11],
             caml_ml_bytes_length(t),
             function(i){return caml_bytes_unsafe_get(t, i);});
   }
   function map$0(t, f){return caml_call2(map, f, t);}
   function mapi$0(t, f){return caml_call2(mapi, f, t);}
   function fold(t, init, f){
    var len = caml_ml_bytes_length(t), pos = 0, acc = init;
    for(;;){
     if(pos === len) return acc;
     var
      acc$0 = caml_call2(f, acc, caml_bytes_unsafe_get(t, pos)),
      pos$0 = caml_call2(Base_Import[90], pos, 1);
     pos = pos$0;
     acc = acc$0;
    }
   }
   function foldi(t, init, f){
    var len = caml_ml_bytes_length(t), pos = 0, acc = init;
    for(;;){
     if(pos === len) return acc;
     var
      acc$0 = caml_call3(f, pos, acc, caml_bytes_unsafe_get(t, pos)),
      pos$0 = caml_call2(Base_Import[90], pos, 1);
     pos = pos$0;
     acc = acc$0;
    }
   }
   function tr(target, replacement, s){
    var
     _r_ = caml_call2(Base_Import[92], caml_ml_bytes_length(s), 1),
     _q_ = 0;
    if(_r_ >= 0){
     var i = _q_;
     for(;;){
      if(caml_call2(Base_Char[15], caml_bytes_unsafe_get(s, i), target))
       caml_bytes_unsafe_set(s, i, replacement);
      var _s_ = i + 1 | 0;
      if(_r_ === i) break;
      i = _s_;
     }
    }
    return 0;
   }
   function tr_multi(target, replacement){
    if(0 === caml_ml_string_length(target))
     return caml_call1(stage, function(_p_){return 0;});
    if(0 === caml_ml_string_length(replacement))
     return caml_call1(Base_Import[125], cst_tr_multi_replacement_is_th);
    var match = caml_call2(Base_Bytes_tr[1], target, replacement);
    if(! match) return caml_call1(stage, function(_o_){return 0;});
    var tr_map = match[1];
    return caml_call1
            (stage,
             function(s){
              var
               _m_ = caml_call2(Base_Import[92], caml_ml_bytes_length(s), 1),
               _l_ = 0;
              if(_m_ >= 0){
               var i = _l_;
               for(;;){
                caml_bytes_unsafe_set
                 (s,
                  i,
                  runtime.caml_string_unsafe_get
                   (tr_map,
                    caml_call1(Base_Char[29], caml_bytes_unsafe_get(s, i))));
                var _n_ = i + 1 | 0;
                if(_m_ === i) break;
                i = _n_;
               }
              }
              return 0;
             });
   }
   function between(t, low, high){
    var _k_ = caml_call2(Base_Import[109][2], low, t);
    return _k_ ? caml_call2(Base_Import[109][2], t, high) : _k_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[109][1], t, min)
            ? min
            : caml_call2(Base_Import[109][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[109][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[109][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _h_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _i_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _h_],
     _j_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _i_);
    return caml_call1(Base_Or_error[35], _j_);
   }
   function contains(pos, len, t, char$0){
    var
     match =
       caml_call4
        (Base_Ordered_collection_common[1],
         pos,
         len,
         0,
         caml_ml_bytes_length(t)),
     len$0 = match[2],
     pos$0 = match[1],
     last = caml_call2(Base_Import[90], pos$0, len$0),
     i = pos$0;
    for(;;){
     var _d_ = i < last ? 1 : 0;
     if(_d_){
      var
       _e_ = caml_bytes_get(t, i),
       _f_ = caml_call2(Base_Char[15], _e_, char$0);
      if(! _f_){
       var i$0 = caml_call2(Base_Import[90], i, 1);
       i = i$0;
       continue;
      }
      var _g_ = _f_;
     }
     else
      var _g_ = _d_;
     return _g_;
    }
   }
   var
    include$0 = Base_Import[109],
    symbol = include$0[1],
    symbol$0 = include$0[2],
    symbol$1 = include$0[3],
    symbol$2 = include$0[4],
    symbol$3 = include$0[5],
    symbol$4 = include$0[6],
    ascending = include$0[7],
    descending = include$0[8],
    compare$0 = include$0[9],
    equal = include$0[10],
    max = include$0[11],
    min = include$0[12],
    Base_Bytes =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       of_string,
       to_string,
       pp$0,
       invariant,
       To_string,
       From_string,
       create,
       make,
       map$0,
       mapi$0,
       copy,
       init,
       of_char_list,
       caml_bytes_get,
       caml_bytes_set,
       fill,
       tr,
       tr_multi,
       to_list,
       to_array,
       fold,
       foldi,
       contains,
       max_length,
       unsafe_to_string,
       unsafe_of_string_promise_no_mu];
   runtime.caml_register_global(24, Base_Bytes, "Base__Bytes");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hex_lexer
//# unitInfo: Requires: Stdlib__Lexing
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    ocaml_lex_tables =
      [0,
       "\0\0\0\0\x01\0\x01\0\x02\0\x1b\0R\0i\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\x01\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\x01\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\x06\0\x04\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\x04\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\x02\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xff\x01\0\x03\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\0\x03\0\x05\0\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       cst,
       cst,
       cst,
       cst,
       cst,
       cst],
    Stdlib_Lexing = global_data.Stdlib__Lexing;
   function parse_hex(lexbuf){
    var ocaml_lex_state = 0;
    for(;;){
     var
      ocaml_lex_state$0 =
        caml_call3
         (Stdlib_Lexing[20], ocaml_lex_tables, ocaml_lex_state, lexbuf);
     if(0 === ocaml_lex_state$0){
      var
       body =
         caml_call3(Stdlib_Lexing[16], lexbuf, lexbuf[5] + 3 | 0, lexbuf[6]);
      return [0, body];
     }
     if(1 === ocaml_lex_state$0){
      var
       body$0 =
         caml_call3(Stdlib_Lexing[16], lexbuf, lexbuf[5] + 2 | 0, lexbuf[6]);
      return [1, body$0];
     }
     caml_call1(lexbuf[1], lexbuf);
     ocaml_lex_state = ocaml_lex_state$0;
    }
   }
   var Base_Hex_lexer = [0, parse_hex];
   runtime.caml_register_global(2, Base_Hex_lexer, "Base__Hex_lexer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_conversions
//# unitInfo: Requires: Assert_failure, Base__Bytes, Base__Char, Base__Hex_lexer, Base__Import, Base__Int0, Base__Option, Base__Printf, Base__Sexp, Base__Sexpable, Base__String, Base__Sys0, Base__Word_size, Sexplib0__Sexp_grammar, Stdlib__Int32, Stdlib__Int64, Stdlib__Lexing, Stdlib__Nativeint
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_int$3 = "int",
    cst_int32$3 = "int32",
    cst_int64$3 = "int64",
    cst_nativeint$2 = "nativeint",
    cst_src_int_conversions_ml = "src/int_conversions.ml",
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Hex_lexer = global_data.Base__Hex_lexer,
    Stdlib_Lexing = global_data.Stdlib__Lexing,
    Base_Option = global_data.Base__Option,
    Base_Char = global_data.Base__Char,
    Base_String = global_data.Base__String,
    Base_Printf = global_data.Base__Printf,
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Bytes = global_data.Base__Bytes,
    Base_Sys0 = global_data.Base__Sys0,
    Base_Word_size = global_data.Base__Word_size,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Base_Int0 = global_data.Base__Int0,
    Base_Sexp = global_data.Base__Sexp,
    _a_ =
      [0,
       [11,
        "conversion from ",
        [2,
         0,
         [11,
          " to ",
          [2, 0, [11, " failed: ", [2, 0, [11, " is out of range", 0]]]]]]],
       "conversion from %s to %s failed: %s is out of range"];
   function convert_failure(x, a, b, to_string){
    var _P_ = caml_call1(to_string, x);
    return caml_call5(Base_Printf[6], _a_, a, b, _P_, 0);
   }
   var
    num_bits_int = Base_Sys0[8],
    num_bits_nativeint = caml_call1(Base_Word_size[2], Base_Word_size[3]),
    _g_ =
      [0,
       [2, 0, [11, ".of_string: invalid input ", [3, 0, 0]]],
       "%s.of_string: invalid input %S"],
    cst_0x = "-0x",
    cst_0x$0 = "0x",
    cst_int63 = "int63",
    cst_int64$2 = cst_int64$3,
    cst_nativeint$1 = cst_nativeint$2,
    cst_int64$1 = cst_int64$3,
    cst_int32$2 = cst_int32$3,
    cst_nativeint$0 = cst_nativeint$2,
    cst_int32$1 = cst_int32$3,
    cst_int64$0 = cst_int64$3,
    cst_int$2 = cst_int$3,
    cst_nativeint = cst_nativeint$2,
    cst_int$1 = cst_int$3,
    cst_int64 = cst_int64$3,
    cst_int$0 = cst_int$3,
    cst_int32$0 = cst_int32$3,
    cst_int32 = cst_int32$3,
    cst_int = cst_int$3,
    _l_ = [0, cst_src_int_conversions_ml, 19, 9],
    _k_ = [0, cst_src_int_conversions_ml, 75, 9],
    _j_ = [0, cst_src_int_conversions_ml, 96, 9],
    _i_ = [0, cst_src_int_conversions_ml, 148, 9],
    _h_ = [0, cst_src_int_conversions_ml, 176, 9],
    num_bits_int32 = 32,
    num_bits_int64 = 64;
   if(63 !== num_bits_int && 31 !== num_bits_int && 32 !== num_bits_int)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
   var
    min_int32 = Stdlib_Int32[10],
    max_int32 = Stdlib_Int32[9],
    min_int64 = Stdlib_Int64[10],
    max_int64 = Stdlib_Int64[9],
    min_nativeint = Stdlib_Nativeint[11],
    max_nativeint = Stdlib_Nativeint[10],
    int64_to_string = Stdlib_Int64[14],
    nativeint_to_string = Stdlib_Nativeint[15];
   function int32_to_int_trunc(_O_){return _O_;}
   function int_to_int32_trunc(_N_){return _N_;}
   var
    _b_ = Base_Import[84][32],
    _c_ = Stdlib_Int32[14],
    int_is_representable_as_int32 =
      num_bits_int <= 32
       ? function(param){return 1;}
       : function
        (x){
         var
          _L_ = caml_call2(Base_Import[228], min_int32, x) <= 0 ? 1 : 0,
          _M_ =
            _L_
             ? caml_call2(Base_Import[228], x, max_int32) <= 0 ? 1 : 0
             : _L_;
         return _M_;
        };
   if(32 <= num_bits_int)
    var _d_ = function(param){return 1;};
   else
    var
     min$1 = Base_Int0[6],
     max$1 = Base_Int0[5],
     _d_ =
       function(x){
        var
         _J_ = caml_call2(Base_Import[229], min$1, x) <= 0 ? 1 : 0,
         _K_ = _J_ ? caml_call2(Base_Import[229], x, max$1) <= 0 ? 1 : 0 : _J_;
        return _K_;
       };
   function int_to_int32(x){
    return int_is_representable_as_int32(x) ? [0, x] : 0;
   }
   function int32_to_int(x){return _d_(x) ? [0, x] : 0;}
   function int_to_int32_exn(x){
    return int_is_representable_as_int32(x)
            ? x
            : convert_failure(x, cst_int, cst_int32, _b_);
   }
   function int32_to_int_exn(x){
    return _d_(x) ? x : convert_failure(x, cst_int32$0, cst_int$0, _c_);
   }
   if(num_bits_int >= 64)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   var
    int_to_int64 = caml_int64_of_int32,
    int64_to_int_trunc = caml_int64_to_int32,
    min$4 = caml_int64_of_int32(Base_Int0[6]),
    max$4 = caml_int64_of_int32(Base_Int0[5]);
   function int64_is_representable_as_int(x){
    var
     _H_ = caml_call2(Base_Import[230], min$4, x) <= 0 ? 1 : 0,
     _I_ = _H_ ? caml_call2(Base_Import[230], x, max$4) <= 0 ? 1 : 0 : _H_;
    return _I_;
   }
   function int64_to_int(x){
    return int64_is_representable_as_int(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_int_exn(x){
    return int64_is_representable_as_int(x)
            ? caml_int64_to_int32(x)
            : convert_failure(x, cst_int64, cst_int$1, int64_to_string);
   }
   if(num_bits_int > num_bits_nativeint)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   function int_to_nativeint(_G_){return _G_;}
   function nativeint_to_int_trunc(_F_){return _F_;}
   if(num_bits_nativeint <= num_bits_int)
    var _e_ = function(param){return 1;};
   else
    var
     min$0 = Base_Int0[6],
     max$0 = Base_Int0[5],
     _e_ =
       function(x){
        var
         _D_ = caml_call2(Base_Import[231], min$0, x) <= 0 ? 1 : 0,
         _E_ = _D_ ? caml_call2(Base_Import[231], x, max$0) <= 0 ? 1 : 0 : _D_;
        return _E_;
       };
   function nativeint_to_int(x){return _e_(x) ? [0, x] : 0;}
   function nativeint_to_int_exn(x){
    return _e_(x)
            ? x
            : convert_failure
              (x, cst_nativeint, cst_int$2, nativeint_to_string);
   }
   var
    int32_to_int64 = caml_int64_of_int32,
    int64_to_int32_trunc = caml_int64_to_int32,
    min$3 = caml_int64_of_int32(min_int32),
    max$3 = caml_int64_of_int32(max_int32);
   function int64_is_representable_as_int3(x){
    var
     _B_ = caml_call2(Base_Import[230], min$3, x) <= 0 ? 1 : 0,
     _C_ = _B_ ? caml_call2(Base_Import[230], x, max$3) <= 0 ? 1 : 0 : _B_;
    return _C_;
   }
   function int64_to_int32(x){
    return int64_is_representable_as_int3(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_int32_exn(x){
    return int64_is_representable_as_int3(x)
            ? caml_int64_to_int32(x)
            : convert_failure(x, cst_int64$0, cst_int32$1, int64_to_string);
   }
   if(32 > num_bits_nativeint)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
   function int32_to_nativeint(_A_){return _A_;}
   function nativeint_to_int32_trunc(_z_){return _z_;}
   var
    _f_ =
      num_bits_nativeint <= 32
       ? function(param){return 1;}
       : function
        (x){
         var
          _x_ = caml_call2(Base_Import[231], min_int32, x) <= 0 ? 1 : 0,
          _y_ =
            _x_
             ? caml_call2(Base_Import[231], x, max_int32) <= 0 ? 1 : 0
             : _x_;
         return _y_;
        };
   function nativeint_to_int32(x){return _f_(x) ? [0, x] : 0;}
   function nativeint_to_int32_exn(x){
    return _f_(x)
            ? x
            : convert_failure
              (x, cst_nativeint$0, cst_int32$2, nativeint_to_string);
   }
   if(num_bits_nativeint > 64)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   var
    int64_to_nativeint_trunc = caml_int64_to_int32,
    nativeint_to_int64 = caml_int64_of_int32;
   if(64 <= num_bits_nativeint)
    var int64_is_representable_as_nati = function(param){return 1;};
   else
    var
     min$2 = caml_int64_of_int32(min_nativeint),
     max$2 = caml_int64_of_int32(max_nativeint),
     int64_is_representable_as_nati =
       function(x){
        var
         _v_ = caml_call2(Base_Import[230], min$2, x) <= 0 ? 1 : 0,
         _w_ = _v_ ? caml_call2(Base_Import[230], x, max$2) <= 0 ? 1 : 0 : _v_;
        return _w_;
       };
   function int64_to_nativeint(x){
    return int64_is_representable_as_nati(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_nativeint_exn(x){
    return int64_is_representable_as_nati(x)
            ? caml_int64_to_int32(x)
            : convert_failure
              (x, cst_int64$1, cst_nativeint$1, int64_to_string);
   }
   var
    min = caml_int64_shift_right(min_int64, 1),
    max = caml_int64_shift_right(max_int64, 1);
   function int64_is_representable_as_int6(x){
    var
     _t_ = caml_call2(Base_Import[230], min, x) <= 0 ? 1 : 0,
     _u_ = _t_ ? caml_call2(Base_Import[230], x, max) <= 0 ? 1 : 0 : _t_;
    return _u_;
   }
   function int64_fit_on_int63_exn(x){
    return int64_is_representable_as_int6(x)
            ? 0
            : convert_failure(x, cst_int64$2, cst_int63, int64_to_string);
   }
   function insert_delimiter_every(input, delimiter, chars_per_delimiter){
    var input_length = runtime.caml_ml_string_length(input);
    if(input_length <= chars_per_delimiter) return input;
    var match = caml_string_get(input, 0);
    a:
    {
     if(43 !== match && 45 !== match){var has_sign = 0; break a;}
     var has_sign = 1;
    }
    var
     num_digits =
       has_sign ? caml_call2(Base_Import[92], input_length, 1) : input_length,
     _q_ = caml_call2(Base_Import[92], num_digits, 1),
     num_delimiters = caml_call2(Base_Import[94], _q_, chars_per_delimiter),
     output_length = caml_call2(Base_Import[90], input_length, num_delimiters),
     output = caml_call1(Base_Bytes[31], output_length),
     input_pos = [0, caml_call2(Base_Import[92], input_length, 1)],
     output_pos = [0, caml_call2(Base_Import[92], output_length, 1)],
     num_chars_until_delimiter = [0, chars_per_delimiter],
     first_digit_pos = has_sign ? 1 : 0;
    for(;;){
     if(first_digit_pos > input_pos[1]){
      if(has_sign){
       var _s_ = caml_string_get(input, 0);
       caml_call3(Base_Bytes[39], output, 0, _s_);
      }
      return caml_call1(Base_Bytes[49], output);
     }
     if(0 === num_chars_until_delimiter[1]){
      caml_call3(Base_Bytes[39], output, output_pos[1], delimiter);
      caml_call1(Base_Import[128], output_pos);
      num_chars_until_delimiter[1] = chars_per_delimiter;
     }
     var _r_ = caml_string_get(input, input_pos[1]);
     caml_call3(Base_Bytes[39], output, output_pos[1], _r_);
     caml_call1(Base_Import[128], input_pos);
     caml_call1(Base_Import[128], output_pos);
     caml_call1(Base_Import[128], num_chars_until_delimiter);
    }
   }
   function insert_delimiter(input, delimiter){
    return insert_delimiter_every(input, delimiter, 3);
   }
   function insert_underscores(input){return insert_delimiter(input, 95);}
   var
    sexp_of_int_style = Base_Sexp[19],
    Base_Int_conversions =
      [0,
       int_to_int32,
       int_to_int32_exn,
       int_to_int32_trunc,
       int_to_int64,
       int_to_nativeint,
       int32_to_int,
       int32_to_int_exn,
       int32_to_int_trunc,
       int32_to_int64,
       int32_to_nativeint,
       int64_to_int,
       int64_to_int_exn,
       int64_to_int_trunc,
       int64_to_int32,
       int64_to_int32_exn,
       int64_to_int32_trunc,
       int64_to_nativeint,
       int64_to_nativeint_exn,
       int64_to_nativeint_trunc,
       int64_fit_on_int63_exn,
       int64_is_representable_as_int6,
       nativeint_to_int,
       nativeint_to_int_exn,
       nativeint_to_int_trunc,
       nativeint_to_int32,
       nativeint_to_int32_exn,
       nativeint_to_int32_trunc,
       nativeint_to_int64,
       num_bits_int,
       num_bits_int32,
       num_bits_int64,
       num_bits_nativeint,
       function(I){
        var chars_per_delimiter = 3;
        function to_string_hum(opt, t){
         if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
         return insert_delimiter_every
                 (caml_call1(I[1], t), delimiter, chars_per_delimiter);
        }
        function sexp_of_t(t){
         var
          s = caml_call1(I[1], t),
          s$0 =
            1009018843 <= sexp_of_int_style[1]
             ? s
             : insert_delimiter_every(s, 95, chars_per_delimiter);
         return [0, s$0];
        }
        return [0, to_string_hum, sexp_of_t];
       },
       function(I){
        var compare = I[1], hash_fold_t = I[2], func = I[3];
        function hash(x){return caml_call1(func, x);}
        var chars_per_delimiter = 4;
        function to_string(delimiter, t){
         if(delimiter)
          var
           delimiter$0 = delimiter[1],
           make_suffix =
             function(t){
              return insert_delimiter_every
                      (caml_call1(I[4], t), delimiter$0, chars_per_delimiter);
             };
         else
          var make_suffix = I[4];
         if(caml_call2(I[7], t, I[6])){
          var _o_ = caml_call1(make_suffix, caml_call1(I[8], t));
          return caml_call2(Base_Import[111], cst_0x, _o_);
         }
         var _p_ = caml_call1(make_suffix, t);
         return caml_call2(Base_Import[111], cst_0x$0, _p_);
        }
        function to_string$0(t){return to_string(0, t);}
        function to_string_hum(opt, t){
         if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
         return to_string([0, delimiter], t);
        }
        function invalid(str){
         return caml_call4(Base_Printf[6], _g_, I[9], str, 0);
        }
        function of_string_with_delimiter(str){
         var
          _n_ =
            caml_call2
             (Base_String[98],
              str,
              function(c){return caml_call2(Base_Char[14], c, 95);});
         return caml_call1(I[5], _n_);
        }
        function of_string(str){
         var
          lex = caml_call2(Stdlib_Lexing[3], 0, str),
          result =
            caml_call1
             (Base_Option[44],
              function(param){return caml_call1(Base_Hex_lexer[1], lex);});
         if(lex[6] !== lex[3]) return invalid(str);
         if(! result) return invalid(str);
         var match = result[1];
         if(0 === match[0]){
          var body = match[1], _m_ = of_string_with_delimiter(body);
          return caml_call1(I[8], _m_);
         }
         var body$0 = match[1];
         return of_string_with_delimiter(body$0);
        }
        var
         t_sexp_grammar = caml_call1(Sexplib0_Sexp_grammar[1], Base_String[1]),
         include = caml_call1(Base_Sexpable[5], [0, of_string, to_string$0]),
         t_of_sexp = include[1],
         sexp_of_t = include[2];
        return [0,
                [0,
                 t_of_sexp,
                 sexp_of_t,
                 t_sexp_grammar,
                 compare,
                 hash_fold_t,
                 hash,
                 of_string,
                 to_string$0,
                 to_string_hum]];
       },
       sexp_of_int_style,
       insert_delimiter_every,
       insert_delimiter,
       insert_underscores];
   runtime.caml_register_global
    (44, Base_Int_conversions, "Base__Int_conversions");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Intable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Intable = [0];
   runtime.caml_register_global(0, Base_Intable, "Base__Intable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Int_intf = [0];
   runtime.caml_register_global(0, Base_Int_intf, "Base__Int_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Pow_overflow_bounds
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Import, Base__Int_conversions
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    overflow_bound_max_int63_on_in =
      runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    overflow_bound_max_int64_value =
      runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
    Base_Import = global_data.Base__Import,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Assert_failure = global_data.Assert_failure,
    Base_Array0 = global_data.Base__Array0,
    int32_positive_overflow_bounds =
      [0,
        2147483647,
        2147483647,
        46340,
        1290,
        215,
        73,
        35,
        21,
        14,
        10,
        8,
        7,
        5,
        5,
        4,
        4,
        3,
        3,
        3,
        3,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1].slice
       (),
    overflow_bound_max_int_value = caml_call2(Base_Import[119], -1, 1),
    switcher = Base_Int_conversions[29] - 31 | 0,
    _g_ = [0, "src/pow_overflow_bounds.ml", 218, 9],
    _a_ = runtime.caml_int64_create_lo_mi_hi(16777215, 127, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    _c_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    _h_ =
      [0,
       1073741823,
       1073741823,
       32767,
       1023,
       181,
       63,
       31,
       19,
       13,
       10,
       7,
       6,
       5,
       4,
       4,
       3,
       3,
       3,
       3,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1],
    _d_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
       runtime.caml_int64_create_lo_mi_hi(16777215, 127, 0),
       runtime.caml_int64_create_lo_mi_hi(1664510, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(46340, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5404, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1290, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(463, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(215, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(118, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(73, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(49, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(35, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(27, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(21, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(17, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(14, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(12, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(10, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(9, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(8, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0)],
    _e_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
       runtime.caml_int64_create_lo_mi_hi(324403, 181, 0),
       runtime.caml_int64_create_lo_mi_hi(2097151, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(55108, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6208, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1448, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(511, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(234, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(127, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(78, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(52, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(38, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(28, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(22, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(18, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(15, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(13, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(11, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(9, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(8, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0)],
    _f_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(1, 0, 32768),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 32768),
       runtime.caml_int64_create_lo_mi_hi(16452813, 16777034, 65535),
       runtime.caml_int64_create_lo_mi_hi(14680065, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16722108, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16771008, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16775768, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16776705, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16776982, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777089, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777138, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777164, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777178, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777188, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777194, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777198, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777201, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777203, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777205, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777207, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777208, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777209, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777209, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777210, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777210, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535)],
    overflow_bound_max_int32_value = 2147483647;
   if(1 < switcher >>> 0){
    if(32 !== switcher)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    var
     int_positive_overflow_bounds =
       [0,
        caml_int64_to_int32(_c_),
        caml_int64_to_int32(_b_),
        caml_int64_to_int32(_a_),
        1664510,
        46340,
        5404,
        1290,
        463,
        215,
        118,
        73,
        49,
        35,
        27,
        21,
        17,
        14,
        12,
        10,
        9,
        8,
        7,
        7,
        6,
        5,
        5,
        5,
        4,
        4,
        4,
        4,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        1];
   }
   else
    var
     int_positive_overflow_bounds =
       switcher
        ? caml_call2
          (Base_Array0[20],
           int32_positive_overflow_bounds,
           function(_i_){return _i_;})
        : _h_.slice();
   var
    int63_on_int64_positive_overfl = _d_.slice(),
    int64_positive_overflow_bounds = _e_.slice(),
    int64_negative_overflow_bounds = _f_.slice(),
    Base_Pow_overflow_bounds =
      [0,
       overflow_bound_max_int32_value,
       int32_positive_overflow_bounds,
       overflow_bound_max_int_value,
       int_positive_overflow_bounds,
       overflow_bound_max_int63_on_in,
       int63_on_int64_positive_overfl,
       overflow_bound_max_int64_value,
       int64_positive_overflow_bounds,
       int64_negative_overflow_bounds];
   runtime.caml_register_global
    (16, Base_Pow_overflow_bounds, "Base__Pow_overflow_bounds");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_math
//# unitInfo: Requires: Base__Import, Base__Pow_overflow_bounds, Base__Printf, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_exponent_can_not_be_negati = "exponent can not be negative",
    cst_integer_overflow_in_pow = "integer overflow in pow",
    caml_check_bound = runtime.caml_check_bound,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_lessthan = runtime.caml_lessthan;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Pow_overflow_bounds = global_data.Base__Pow_overflow_bounds,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    invalid_argf = Base_Printf[7],
    _a_ =
      [0,
       [11, cst_exponent_can_not_be_negati, 0],
       cst_exponent_can_not_be_negati],
    _b_ =
      [0, [11, cst_integer_overflow_in_pow, 0], cst_integer_overflow_in_pow];
   function negative_exponent(param){
    return caml_call2(Base_Printf[7], _a_, 0);
   }
   function overflow(param){return caml_call2(Base_Printf[7], _b_, 0);}
   function int_pow(base, exponent){
    if(exponent < 0) negative_exponent(0);
    var _J_ = 1 < caml_call1(Base_Import[122], base) ? 1 : 0;
    if(_J_){
     var _K_ = 63 < exponent ? 1 : 0;
     if(_K_)
      var _L_ = _K_;
     else
      var
       _M_ =
         caml_check_bound(Base_Pow_overflow_bounds[4], exponent)[1 + exponent],
       _L_ = _M_ < caml_call1(Base_Import[122], base) ? 1 : 0;
    }
    else
     var _L_ = _J_;
    if(_L_) overflow(0);
    return runtime.Base_int_math_int_pow_stub(base, exponent);
   }
   var
    abs = Stdlib_Int64[8],
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _e_ = runtime.caml_int64_create_lo_mi_hi(63, 0, 0),
    _f_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _g_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _h_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    _i_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _j_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _k_ = runtime.caml_int64_create_lo_mi_hi(63, 0, 0);
   function int64_pow(base, exponent){
    if(caml_lessthan(exponent, _c_)) negative_exponent(0);
    var
     _A_ = caml_greaterthan(base, _d_),
     _B_ = _A_ || caml_lessthan(base, _h_);
    if(_B_){
     var _C_ = caml_greaterthan(exponent, _e_);
     if(_C_)
      var _D_ = _C_;
     else{
      var _E_ = runtime.caml_greaterequal(base, _f_);
      if(_E_)
       var
        _F_ = caml_int64_to_int32(exponent),
        _G_ =
          caml_greaterthan
           (base, caml_check_bound(Base_Pow_overflow_bounds[8], _F_)[1 + _F_]);
      else
       var _G_ = _E_;
      if(_G_)
       var _D_ = _G_;
      else{
       var _H_ = caml_lessthan(base, _g_);
       if(_H_)
        var
         _I_ = caml_int64_to_int32(exponent),
         _D_ =
           caml_lessthan
            (base,
             caml_check_bound(Base_Pow_overflow_bounds[9], _I_)[1 + _I_]);
       else
        var _D_ = _H_;
      }
     }
    }
    else
     var _D_ = _B_;
    if(_D_) overflow(0);
    return runtime.Base_int_math_int64_pow_stub(base, exponent);
   }
   function int63_pow_on_int64(base, exponent){
    if(caml_lessthan(exponent, _i_)) negative_exponent(0);
    var _v_ = caml_greaterthan(caml_call1(abs, base), _j_);
    if(_v_){
     var _w_ = caml_greaterthan(exponent, _k_);
     if(_w_)
      var _x_ = _w_;
     else
      var
       _y_ = caml_int64_to_int32(exponent),
       _z_ = caml_check_bound(Base_Pow_overflow_bounds[6], _y_)[1 + _y_],
       _x_ = caml_greaterthan(caml_call1(abs, base), _z_);
    }
    else
     var _x_ = _v_;
    if(_x_) overflow(0);
    return runtime.Base_int_math_int64_pow_stub(base, exponent);
   }
   var
    Private = [0, int_pow, int64_pow, int63_pow_on_int64],
    _l_ =
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: modulus should be positive", 0]]]]]],
       "%s %% %s in core_int.ml: modulus should be positive"],
    _m_ =
      [0,
       [2,
        0,
        [11,
         " /",
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: divisor should be positive", 0]]]]]],
       "%s /%% %s in core_int.ml: divisor should be positive"],
    Base_Int_math =
      [0,
       function(X){
        function symbol(x, y){
         if(caml_call2(X[11], y, X[18])){
          var _u_ = caml_call1(X[4], y);
          caml_call4(invalid_argf, _l_, caml_call1(X[4], x), _u_, 0);
         }
         var rval = caml_call2(X[20], x, y);
         return caml_call2(X[14], rval, X[18])
                 ? caml_call2(X[5], rval, y)
                 : rval;
        }
        var one = caml_call1(X[19], 1);
        function symbol$0(x, y){
         if(caml_call2(X[11], y, X[18])){
          var _r_ = caml_call1(X[4], y);
          caml_call4(invalid_argf, _m_, caml_call1(X[4], x), _r_, 0);
         }
         if(! caml_call2(X[14], x, X[18])) return caml_call2(X[8], x, y);
         var _s_ = caml_call2(X[5], x, one), _t_ = caml_call2(X[8], _s_, y);
         return caml_call2(X[6], _t_, one);
        }
        function symbol$1(x, y){
         var _p_ = caml_call1(X[2], y), _q_ = caml_call1(X[2], x);
         return caml_call2(Base_Import[95], _q_, _p_);
        }
        function round_down(i, modulus){
         var _o_ = symbol(i, modulus);
         return caml_call2(X[6], i, _o_);
        }
        function round_up(i, modulus){
         var remainder = symbol(i, modulus);
         if(caml_call2(X[12], remainder, X[18])) return i;
         var _n_ = caml_call2(X[5], i, modulus);
         return caml_call2(X[6], _n_, remainder);
        }
        function round_towards_zero(i, to_multiple_of){
         return caml_call2(X[12], i, X[18])
                 ? X[18]
                 : caml_call2
                    (X[13], i, X[18])
                   ? round_down(i, to_multiple_of)
                   : round_up(i, to_multiple_of);
        }
        function round_nearest(i, modulus){
         var
          remainder = symbol(i, modulus),
          modulus_minus_remainder = caml_call2(X[6], modulus, remainder);
         return caml_call2(X[11], modulus_minus_remainder, remainder)
                 ? caml_call2(X[5], i, modulus_minus_remainder)
                 : caml_call2(X[6], i, remainder);
        }
        function round(opt, i, to_multiple_of){
         if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
         return 857423934 <= dir
                 ? 1003109192
                   <= dir
                   ? round_towards_zero(i, to_multiple_of)
                   : round_nearest(i, to_multiple_of)
                 : 759637122
                   <= dir
                   ? round_down(i, to_multiple_of)
                   : round_up(i, to_multiple_of);
        }
        return [0,
                symbol,
                symbol$0,
                symbol$1,
                round,
                round_towards_zero,
                round_down,
                round_up,
                round_nearest];
       },
       Private];
   runtime.caml_register_global(17, Base_Int_math, "Base__Int_math");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Popcount
//# unitInfo: Requires: Assert_failure, Stdlib__Nativeint
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    m1 = runtime.caml_int64_create_lo_mi_hi(5592405, 5592405, 21845),
    m2 = runtime.caml_int64_create_lo_mi_hi(3355443, 3355443, 13107),
    m4 = runtime.caml_int64_create_lo_mi_hi(986895, 986895, 3855),
    h01 = runtime.caml_int64_create_lo_mi_hi(65793, 65793, 257),
    mask = runtime.caml_int64_create_lo_mi_hi(16777215, 255, 0),
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Assert_failure = global_data.Assert_failure;
   function int64_popcount(x$1){
    var
     x$0 =
       runtime.caml_int64_sub
        (x$1, caml_int64_and(caml_int64_shift_right_unsigne(x$1, 1), m1)),
     x =
       caml_int64_add
        (caml_int64_and(x$0, m2),
         caml_int64_and(caml_int64_shift_right_unsigne(x$0, 2), m2)),
     x$2 =
       caml_int64_and
        (caml_int64_add(x, caml_int64_shift_right_unsigne(x, 4)), m4);
    return runtime.caml_int64_to_int32
            (caml_int64_shift_right_unsigne
              (runtime.caml_int64_mul(x$2, h01), 56));
   }
   function int32_popcount(x){
    return int64_popcount(caml_int64_and(caml_int64_of_int32(x), mask));
   }
   var _a_ = Stdlib_Nativeint[9], _b_ = [0, "src/popcount.ml", 45, 9];
   if(32 === _a_)
    var nativeint_popcount = function(x){return int32_popcount(x);};
   else{
    if(64 !== _a_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var
     nativeint_popcount =
       function(x){return int64_popcount(caml_int64_of_int32(x));};
   }
   var
    Base_Popcount =
      [0,
       function(_c_){return runtime.Base_int_math_int_popcount(_c_);},
       int32_popcount,
       int64_popcount,
       nativeint_popcount];
   runtime.caml_register_global(8, Base_Popcount, "Base__Popcount");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign
//# unitInfo: Requires: Base__Identifiable, Base__Import, Base__Sign0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Sign0 = global_data.Base__Sign0,
    Base_Identifiable = global_data.Base__Identifiable,
    t_sexp_grammar = Base_Sign0[3],
    all = Base_Sign0[6],
    Replace_polymorphic_compare = Base_Sign0[7],
    to_int = Base_Sign0[10],
    of_int = Base_Sign0[13],
    _a_ =
      caml_call1
       (Base_Identifiable[1],
        [0,
         Base_Sign0[4],
         Base_Sign0[5],
         Base_Sign0[11],
         Base_Sign0[1],
         Base_Sign0[2],
         Base_Sign0[8],
         Base_Sign0[9],
         Base_Sign0[12]]),
    hash_fold_t = _a_[1],
    hash = _a_[2],
    t_of_sexp = _a_[3],
    sexp_of_t = _a_[4],
    of_string = _a_[5],
    to_string = _a_[6],
    between = _a_[19],
    clamp_exn = _a_[20],
    clamp = _a_[21],
    comparator = _a_[22],
    pp = _a_[23],
    hashable = _a_[24];
   function to_float(param){
    switch(param){case 0: return -1.;case 1: return 0.;default: return 1.;
    }
   }
   function flip(param){
    switch(param){case 0: return 2;case 1: return 1;default: return 0;
    }
   }
   function symbol(t$0, t){
    var _b_ = caml_call1(to_int, t), _c_ = caml_call1(to_int, t$0);
    return caml_call1(of_int, caml_call2(Base_Import[87], _c_, _b_));
   }
   var
    symbol$0 = Replace_polymorphic_compare[1],
    symbol$1 = Replace_polymorphic_compare[2],
    symbol$2 = Replace_polymorphic_compare[3],
    symbol$3 = Replace_polymorphic_compare[4],
    symbol$4 = Replace_polymorphic_compare[5],
    symbol$5 = Replace_polymorphic_compare[6],
    ascending = Replace_polymorphic_compare[7],
    descending = Replace_polymorphic_compare[8],
    compare = Replace_polymorphic_compare[9],
    equal = Replace_polymorphic_compare[10],
    max = Replace_polymorphic_compare[11],
    min = Replace_polymorphic_compare[12],
    Base_Sign =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       of_string,
       to_string,
       symbol$5,
       symbol$1,
       symbol$3,
       symbol$4,
       symbol$0,
       symbol$2,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       of_int,
       to_int,
       to_float,
       flip,
       symbol];
   runtime.caml_register_global(6, Base_Sign, "Base__Sign");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int0, Base__Int_conversions, Base__Int_intf, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Sign, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_x = "%x",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_div = runtime.caml_div,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int.Hex",
    module_name$0 = "Base.Int",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Float0 = global_data.Base__Float0,
    Base_Int0 = global_data.Base__Int0,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Int_math = global_data.Base__Int_math,
    Base_Error = global_data.Base__Error,
    Base_Sign = global_data.Base__Sign,
    Base_Popcount = global_data.Base__Popcount,
    to_string = Base_Int0[1],
    of_string = Base_Int0[2],
    hash_fold_t = Base_Import[206],
    func = Base_Import[220];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[165],
    sexp_of_t = Base_Import[141],
    t_sexp_grammar = Base_Import[185],
    hashable = [0, hash, caml_int_compare, sexp_of_t],
    compare = caml_int_compare,
    _a_ = [0, [11, "Int.of_string: ", [3, 0, 0]], "Int.of_string: %S"];
   function of_string$0(s){
    try{var _an_ = caml_call1(of_string, s); return _an_;}
    catch(_ao_){return caml_call3(Base_Printf[6], _a_, s, 0);}
   }
   var
    num_bits = Base_Int_conversions[29],
    float_lower_bound = caml_call1(Base_Float0[25], num_bits),
    float_upper_bound = caml_call1(Base_Float0[23], num_bits),
    _b_ =
      [0,
       [11,
        "Int.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int.of_float: argument (%f) is out of range or NaN"];
   function to_float(_am_){return _am_;}
   function of_float_unchecked(_al_){return _al_ | 0;}
   function of_float(f){
    if
     (caml_call2(Base_Import[107][6], f, float_lower_bound)
      && caml_call2(Base_Import[107][2], f, float_upper_bound))
     return f | 0;
    var _ak_ = caml_call1(Base_Float0[27], f);
    return caml_call3(Base_Printf[7], _b_, _ak_, 0);
   }
   var
    zero = 0,
    comparator = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t])[1],
    _c_ = caml_call1(Base_Comparable[13], [0, compare, sexp_of_t, zero]),
    is_positive = _c_[1],
    is_non_negative = _c_[2],
    is_negative = _c_[3],
    is_non_positive = _c_[4],
    include = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include[1],
    sexp_of_t$0 = include[2],
    compare$0 = Base_Import[228],
    hash_fold_t$0 = Base_Import[206],
    func$0 = Base_Import[220];
   function hash$0(x){return caml_call1(func$0, x);}
   var
    neg = Base_Import[112],
    _d_ = [0, [4, 6, 0, 0, 0], cst_x],
    _e_ = [0, [4, 6, 0, 0, 0], cst_x];
   function symbol(_aj_, _ai_){return _aj_ < _ai_ ? 1 : 0;}
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$1(s){
    return caml_call3(Stdlib_Scanf[4], s, _e_, function(_ah_){return _ah_;});
   }
   var
    include$0 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$0,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$1,
         zero,
         symbol,
         neg,
         module_name]),
    Hex = include$0[1],
    include$1 =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string]),
    pp = include$1[1],
    _f_ = [0, "src/int.ml", 108, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function invariant(param){return 0;}
   function between(t, low, high){
    var _af_ = low <= t ? 1 : 0, _ag_ = _af_ ? t <= high ? 1 : 0 : _af_;
    return _ag_;
   }
   function clamp_unchecked(t, min, max){
    return t < min ? min : t <= max ? t : max;
   }
   function clamp_exn(t, min, max){
    if(min <= max) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   }
   function clamp(t, min, max){
    if(max >= min) return [0, clamp_unchecked(t, min, max)];
    var
     _ac_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _ad_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _ac_],
     _ae_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _ad_);
    return caml_call1(Base_Or_error[35], _ae_);
   }
   function pred(i){return caml_call2(Base_Import[92], i, 1);}
   function succ(i){return caml_call2(Base_Import[90], i, 1);}
   function to_int(i){return i;}
   function of_int_exn(i){return i;}
   var
    max_value = Base_Import[84][18],
    min_value = Base_Import[84][19],
    of_int32 = Base_Int_conversions[6],
    of_int32_exn = Base_Int_conversions[7],
    to_int32 = Base_Int_conversions[1],
    to_int32_exn = Base_Int_conversions[2],
    of_int64 = Base_Int_conversions[11],
    of_int64_exn = Base_Int_conversions[12],
    to_int64 = Base_Int_conversions[4],
    of_nativeint = Base_Int_conversions[22],
    of_nativeint_exn = Base_Int_conversions[23],
    to_nativeint = Base_Int_conversions[5];
   function abs(x){return caml_call1(Base_Import[122], x);}
   function rem(a, b){return caml_call2(Base_Import[121], a, b);}
   function incr(_ab_){_ab_[1]++; return 0;}
   function decr(_aa_){_aa_[1]--; return 0;}
   function shift_right(a, b){return caml_call2(Base_Import[114], a, b);}
   function shift_right_logical(a, b){
    return caml_call2(Base_Import[119], a, b);
   }
   function shift_left(a, b){return caml_call2(Base_Import[118], a, b);}
   function bit_not(a){return caml_call1(Base_Import[116], a);}
   function bit_or(a, b){return caml_call2(Base_Import[117], a, b);}
   function bit_and(a, b){return caml_call2(Base_Import[115], a, b);}
   function bit_xor(a, b){return caml_call2(Base_Import[120], a, b);}
   var pow = Base_Int_math[2][1];
   function symbol$0(b, e){return caml_call2(pow, b, e);}
   var
    raise_s = Base_Error[30],
    _g_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_Int_floor_log2_got_invalid = "[Int.floor_log2] got invalid input",
    cst_Int_ceil_log2_got_invalid_ = "[Int.ceil_log2] got invalid input";
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _g_, 0);
   }
   function ceil_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var
     x$0 = caml_call2(Base_Import[92], x, 1),
     _W_ = caml_call2(Base_Import[119], x$0, 1),
     x$1 = caml_call2(Base_Import[117], x$0, _W_),
     _X_ = caml_call2(Base_Import[119], x$1, 2),
     x$2 = caml_call2(Base_Import[117], x$1, _X_),
     _Y_ = caml_call2(Base_Import[119], x$2, 4),
     x$3 = caml_call2(Base_Import[117], x$2, _Y_),
     _Z_ = caml_call2(Base_Import[119], x$3, 8),
     x$4 = caml_call2(Base_Import[117], x$3, _Z_),
     ___ = caml_call2(Base_Import[119], x$4, 16),
     x$5 = caml_call2(Base_Import[117], x$4, ___),
     _$_ = caml_call2(Base_Import[119], x$5, 32),
     x$6 = caml_call2(Base_Import[117], x$5, _$_);
    return caml_call2(Base_Import[90], x$6, 1);
   }
   function floor_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var
     _P_ = caml_call2(Base_Import[119], x, 1),
     x$0 = caml_call2(Base_Import[117], x, _P_),
     _Q_ = caml_call2(Base_Import[119], x$0, 2),
     x$1 = caml_call2(Base_Import[117], x$0, _Q_),
     _R_ = caml_call2(Base_Import[119], x$1, 4),
     x$2 = caml_call2(Base_Import[117], x$1, _R_),
     _S_ = caml_call2(Base_Import[119], x$2, 8),
     x$3 = caml_call2(Base_Import[117], x$2, _S_),
     _T_ = caml_call2(Base_Import[119], x$3, 16),
     x$4 = caml_call2(Base_Import[117], x$3, _T_),
     _U_ = caml_call2(Base_Import[119], x$4, 32),
     x$5 = caml_call2(Base_Import[117], x$4, _U_),
     _V_ = caml_call2(Base_Import[119], x$5, 1);
    return caml_call2(Base_Import[92], x$5, _V_);
   }
   function is_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var _O_ = caml_call2(Base_Import[92], x, 1);
    return 0 === caml_call2(Base_Import[115], x, _O_) ? 1 : 0;
   }
   function floor_log2(i){
    if(i <= 0){
     var _L_ = [0, [0, cst, caml_call1(Base_Import[141], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int_floor_log2_got_invalid, _L_));
    }
    var
     _M_ = runtime.Base_int_math_int_clz(i),
     _N_ = caml_call2(Base_Import[92], num_bits, 1);
    return caml_call2(Base_Import[92], _N_, _M_);
   }
   function ceil_log2(i){
    if(i <= 0){
     var _J_ = [0, [0, cst$0, caml_call1(Base_Import[141], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int_ceil_log2_got_invalid_, _J_));
    }
    if(1 === i) return 0;
    var
     _K_ = runtime.Base_int_math_int_clz(caml_call2(Base_Import[92], i, 1));
    return caml_call2(Base_Import[92], num_bits, _K_);
   }
   var
    sign = Base_Sign[27],
    popcount = Base_Popcount[1],
    F =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string$0,
         to_string,
         function(_I_, _H_){return _I_ + _H_ | 0;},
         function(_G_, _F_){return _G_ - _F_ | 0;},
         runtime.caml_mul,
         caml_div,
         function(_E_){return - _E_ | 0;},
         function(_D_, _C_){return _C_ <= _D_ ? 1 : 0;},
         function(_B_, _A_){return _B_ <= _A_ ? 1 : 0;},
         function(_z_, _y_){return _z_ === _y_ ? 1 : 0;},
         function(_x_, _w_){return _w_ < _x_ ? 1 : 0;},
         function(_v_, _u_){return _v_ < _u_ ? 1 : 0;},
         function(_t_, _s_){return _t_ !== _s_ ? 1 : 0;},
         abs,
         function(_r_){return - _r_ | 0;},
         zero,
         of_int_exn,
         rem]),
    round = F[4],
    round_towards_zero = F[5],
    round_down = F[6],
    round_up = F[7],
    round_nearest = F[8],
    _h_ =
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: modulus should be positive", 0]]]]]],
       "%s %% %s in core_int.ml: modulus should be positive"],
    _i_ =
      [0,
       [2,
        0,
        [11,
         " /",
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: divisor should be positive", 0]]]]]],
       "%s /%% %s in core_int.ml: divisor should be positive"];
   function symbol$1(x, y){
    if(y <= 0){
     var _p_ = caml_call1(to_string, y), _q_ = caml_call1(to_string, x);
     caml_call4(Base_Printf[7], _h_, _q_, _p_, 0);
    }
    var rval = rem(x, y);
    return rval < 0 ? rval + y | 0 : rval;
   }
   function symbol$2(x, y){
    if(y <= 0){
     var _n_ = caml_call1(to_string, y), _o_ = caml_call1(to_string, x);
     caml_call4(Base_Printf[7], _i_, _o_, _n_, 0);
    }
    return x < 0 ? caml_div(x + 1 | 0, y) - 1 | 0 : caml_div(x, y);
   }
   function symbol$3(x, y){return caml_call2(Base_Import[95], x, y);}
   var
    lnot = Base_Import[116],
    include$2 = Base_Import[96],
    ascending = include$2[1],
    descending = include$2[2],
    max = include$2[3],
    min = include$2[4],
    Base_Int =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string$0,
       to_string,
       function(_m_, _l_){return _m_ === _l_ ? 1 : 0;},
       caml_int_compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       1,
       -1,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_k_){return runtime.Base_int_math_int_clz(_k_);},
       function(_j_){return runtime.Base_int_math_int_ctz(_j_);},
       [0, symbol$0, lnot, abs, zero, symbol$1, symbol$2, symbol$3],
       symbol$0,
       lnot,
       abs,
       zero,
       symbol$1,
       symbol$2,
       symbol$3,
       1073741823,
       of_int_exn,
       to_int,
       of_int32,
       to_int32,
       of_int64,
       of_nativeint,
       to_nativeint,
       [0, [0, F[1], F[2], F[3]]]];
   runtime.caml_register_global(33, Base_Int, "Base__Int");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar
//# unitInfo: Requires: Base__Comparable, Base__Hash, Base__Import, Base__Pretty_printer, Base__Printf, Base__String, Base__Uchar0, Sexplib0__Sexp_grammar, Stdlib, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_U = "U+",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Uchar",
    Base_Uchar0 = global_data.Base__Uchar0,
    Stdlib = global_data.Stdlib,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Hash = global_data.Base__Hash,
    Base_String = global_data.Base__String,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Comparable = global_data.Base__Comparable,
    failwithf = Base_Printf[6],
    is_valid = Base_Uchar0[3],
    is_char = Base_Uchar0[4],
    unsafe_to_char = Base_Uchar0[5],
    unsafe_of_int = Base_Uchar0[6],
    to_int = Base_Uchar0[8],
    of_char = Base_Uchar0[9],
    compare = Base_Uchar0[10],
    min_value = Base_Uchar0[12],
    max_value = Base_Uchar0[13],
    _a_ = [0, [11, cst_U, [4, 8, [0, 2, 4], 0, 0]], "U+%04X"],
    cst_Uchar_t_of_sexp_atom_of_th =
      "Uchar.t_of_sexp: atom of the form U+XXXX needed",
    _b_ = [0, [11, cst_U, [4, 8, 0, 0, 0]], "U+%X"],
    cst_Uchar_t_of_sexp_atom_neede = "Uchar.t_of_sexp: atom needed";
   function hash_fold_t(state, t){
    var _s_ = caml_call1(to_int, t);
    return caml_call2(Base_Hash[3], state, _s_);
   }
   function hash(t){return caml_call3(Base_Hash[14], 0, hash_fold_t, t);}
   function to_string(t){
    var _r_ = caml_call1(to_int, t);
    return caml_call2(Base_Printf[2], _a_, _r_);
   }
   function sexp_of_t(t){return [0, to_string(t)];}
   function t_of_sexp(sexp){
    if(0 !== sexp[0])
     return caml_call2(Base_Import[158], cst_Uchar_t_of_sexp_atom_neede, sexp);
    var s = sexp[1];
    try{
     var
      _p_ =
        caml_call3
         (Stdlib_Scanf[4],
          s,
          _b_,
          function(i){return caml_call1(Base_Uchar0[7], i);});
     return _p_;
    }
    catch(_q_){
     return caml_call2(Base_Import[158], cst_Uchar_t_of_sexp_atom_of_th, sexp);
    }
   }
   var
    t_sexp_grammar = caml_call1(Sexplib0_Sexp_grammar[1], Base_String[1]),
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name, to_string])[1],
    _c_ = caml_call1(Base_Comparable[10], [0, compare, sexp_of_t]),
    between = _c_[13],
    clamp_exn = _c_[14],
    clamp = _c_[15],
    comparator = _c_[16],
    _d_ = [0, [11, "Uchar.succ_exn: ", [2, 0, 0]], "Uchar.succ_exn: %s"],
    _e_ = [0, [11, "Uchar.pred_exn: ", [2, 0, 0]], "Uchar.pred_exn: %s"],
    _f_ =
      [0,
       [11,
        "Uchar.of_int_exn got a invalid Unicode scalar value: ",
        [4, 8, [0, 2, 4], 0, 0]],
       "Uchar.of_int_exn got a invalid Unicode scalar value: %04X"],
    _g_ =
      [0,
       [11,
        "Uchar.to_char_exn got a non latin-1 character: U+",
        [4, 8, [0, 2, 4], 0, 0]],
       "Uchar.to_char_exn got a non latin-1 character: U+%04X"];
   function invariant(param){return 0;}
   function succ_exn(c){
    try{var _o_ = caml_call1(Base_Uchar0[1], c); return _o_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return caml_call3(failwithf, _d_, msg, 0);
    }
   }
   function succ(c){
    try{var _m_ = [0, caml_call1(Base_Uchar0[1], c)]; return _m_;}
    catch(_n_){
     var _l_ = caml_wrap_exception(_n_);
     if(_l_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_l_, 0);
    }
   }
   function pred_exn(c){
    try{var _k_ = caml_call1(Base_Uchar0[2], c); return _k_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return caml_call3(failwithf, _e_, msg, 0);
    }
   }
   function pred(c){
    try{var _i_ = [0, caml_call1(Base_Uchar0[2], c)]; return _i_;}
    catch(_j_){
     var _h_ = caml_wrap_exception(_j_);
     if(_h_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_h_, 0);
    }
   }
   function of_scalar(i){
    return caml_call1(is_valid, i) ? [0, caml_call1(unsafe_of_int, i)] : 0;
   }
   function of_scalar_exn(i){
    return caml_call1(is_valid, i)
            ? caml_call1(unsafe_of_int, i)
            : caml_call3(failwithf, _f_, i, 0);
   }
   function to_scalar(t){return caml_call1(Base_Uchar0[8], t);}
   function to_char(c){
    return caml_call1(is_char, c) ? [0, caml_call1(unsafe_to_char, c)] : 0;
   }
   function to_char_exn(c){
    return caml_call1(is_char, c)
            ? caml_call1(unsafe_to_char, c)
            : caml_call3(failwithf, _g_, caml_call1(to_int, c), 0);
   }
   function utf8_byte_length(uchar){
    var codepoint = to_scalar(uchar);
    return 128 <= codepoint
            ? 2048 <= codepoint ? 65536 <= codepoint ? 4 : 3 : 2
            : 1;
   }
   var
    include = Base_Import[106],
    symbol = include[2],
    symbol$0 = include[3],
    symbol$1 = include[4],
    symbol$2 = include[5],
    symbol$3 = include[6],
    symbol$4 = include[7],
    ascending = include[8],
    descending = include[9],
    compare$0 = include[10],
    equal = include[11],
    max = include[12],
    min = include[13],
    Base_Uchar =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       invariant,
       succ,
       succ_exn,
       pred,
       pred_exn,
       is_char,
       to_char,
       to_char_exn,
       of_char,
       is_valid,
       of_scalar,
       of_scalar_exn,
       to_scalar,
       utf8_byte_length,
       min_value,
       max_value];
   runtime.caml_register_global(19, Base_Uchar, "Base__Uchar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Type_equal
//# unitInfo: Requires: Base__Error, Base__Import, Base__Int, Base__Option, Base__Sexp, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    some_t = [0, 0],
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Base_Option = global_data.Base__Option,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Int = global_data.Base__Int,
    _a_ = [0, "T"];
   function sexp_of_t(of_a_001, of_b_002, param){return _a_;}
   var
    _b_ = [0, 0, 0],
    _c_ = [0, "type_witness"],
    cst_Key = "Key",
    _d_ = [0, "witness"],
    _e_ = [0, "name"],
    cst_Type_equal_Id_same_witness =
      "Type_equal.Id.same_witness_exn got different ids";
   function sym(param){return 0;}
   function trans(param, _H_){return 0;}
   function conv(param, a){return a;}
   function Lift(X){function lift(param){return 0;} return [0, lift];}
   function Lift2(X){function lift(param, _G_){return 0;} return [0, lift];}
   function Lift3(X){
    function lift(param, _F_, _E_){return 0;}
    return [0, lift];
   }
   function detuple2(param){return _b_;}
   function tuple2(param, _D_){return 0;}
   function Composition_preserves_injectiv(M1, M2){
    function strip(e){
     var _C_ = caml_call1(M2[1], e);
     return caml_call1(M1[1], _C_);
    }
    return [0, strip];
   }
   function sexp_of_t$0(param, _B_){
    var name = _B_[2], witness = _B_[1];
    if(Base_Import[131]) return [0, name];
    var
     t = witness[1],
     _A_ = caml_call1(Stdlib_Obj[22][1], t),
     v_005 = caml_call1(Stdlib_Obj[22][3], _A_);
    return [1,
            [0,
             [1, [0, _e_, [0, [0, name], 0]]],
             [0,
              [1,
               [0,
                _d_,
                [0,
                 [1, [0, _c_, [0, caml_call1(Base_Import[141], v_005), 0]]],
                 0]]],
              0]]];
   }
   function to_sexp(t){return t[3];}
   function name(t){return t[2];}
   function create(name, to_sexp){
    var Key = [248, cst_Key, runtime.caml_fresh_oo_id(0)];
    return [0, [0, Key], name, to_sexp];
   }
   function uid(t){
    var M = t[1], _z_ = caml_call1(Stdlib_Obj[22][1], M[1]);
    return caml_call1(Stdlib_Obj[22][3], _z_);
   }
   function hash(t){return uid(t);}
   function hash_fold_t(s, t){
    var _y_ = uid(t);
    return caml_call2(Base_Import[206], s, _y_);
   }
   function same_witness(t1, t2){
    var b = t2[1], a = t1[1];
    return a[1] === b[1] ? some_t : 0;
   }
   function same(t1, t2){
    var _x_ = same_witness(t1, t2);
    return caml_call1(Base_Option[50], _x_);
   }
   function same_witness_exn(t1, t2){
    var match = same_witness(t1, t2);
    if(match){var w = match[1]; return w;}
    var
     _r_ = Base_Import[154],
     _s_ = Base_Import[154],
     _t_ =
       [0,
        [0,
         cst,
         caml_call3
          (Base_Import[149],
           function(_w_){return sexp_of_t$0(_s_, _w_);},
           function(_v_){return sexp_of_t$0(_r_, _v_);},
           [0, t1, t2])],
        0],
     _u_ = caml_call2(Base_Sexp[9], cst_Type_equal_Id_same_witness, _t_);
    return caml_call1(Base_Error[30], _u_);
   }
   var
    Base_Type_equal =
      [0,
       sexp_of_t,
       0,
       sym,
       trans,
       conv,
       Lift,
       Lift2,
       Lift3,
       detuple2,
       tuple2,
       Composition_preserves_injectiv,
       [0,
        sexp_of_t$0,
        [0,
         Base_Int[6],
         Base_Int[7],
         Base_Int[8],
         Base_Int[9],
         function(_q_, _p_){return _p_ <= _q_ ? 1 : 0;},
         function(_o_, _n_){return _o_ <= _n_ ? 1 : 0;},
         function(_m_, _l_){return _m_ === _l_ ? 1 : 0;},
         function(_k_, _j_){return _j_ < _k_ ? 1 : 0;},
         function(_i_, _h_){return _i_ < _h_ ? 1 : 0;},
         function(_g_, _f_){return _g_ !== _f_ ? 1 : 0;},
         Base_Int[12],
         Base_Int[13],
         Base_Int[14],
         Base_Int[15],
         Base_Int[16],
         Base_Int[17],
         Base_Int[18],
         Base_Int[19],
         Base_Int[20],
         Base_Int[21]],
        uid,
        create,
        hash,
        name,
        to_sexp,
        hash_fold_t,
        same,
        same_witness,
        same_witness_exn]];
   runtime.caml_register_global(15, Base_Type_equal, "Base__Type_equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__T
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_T = [0];
   runtime.caml_register_global(0, Base_T, "Base__T");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stack_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Stack_intf = [0];
   runtime.caml_register_global(0, Base_Stack_intf, "Base__Stack_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Option_array
//# unitInfo: Requires: Base__Array, Base__Blit, Base__Import, Base__Indexed_container, Base__Option, Base__Sexpable, Base__Uniform_array, Sexplib0__Sexp_grammar, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array = global_data.Base__Array,
    Base_Import = global_data.Base__Import,
    Base_Uniform_array = global_data.Base__Uniform_array,
    Base_Option = global_data.Base__Option,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Indexed_container = global_data.Base__Indexed_container,
    Base_Blit = global_data.Base__Blit,
    none_substitute = runtime.caml_obj_block(Stdlib_Obj[12], 1),
    none = 24791911,
    cst_Option_array_get_some_exn_ =
      "Option_array.get_some_exn: the element is [None]";
   function is_none(x){return caml_call2(Base_Import[127], x, none);}
   function is_some(x){return 1 - caml_call2(Base_Import[127], x, none);}
   function some(x){
    return caml_call2(Base_Import[127], x, none) ? none_substitute : x;
   }
   function value_unsafe(x){
    return caml_call2(Base_Import[127], x, none_substitute) ? none : x;
   }
   function value_exn(x){
    return is_some(x)
            ? value_unsafe(x)
            : caml_call1(Base_Import[123], cst_Option_array_get_some_exn_);
   }
   function of_sexpable(param){
    if(! param) return none;
    var x = param[1];
    return some(x);
   }
   function to_sexpable(x){return is_some(x) ? [0, value_unsafe(x)] : 0;}
   var
    include =
      caml_call1
       (caml_call1(Base_Sexpable[2], [0, Base_Option[6], Base_Option[7]]),
        [0, to_sexpable, of_sexpable]),
    t_of_sexp = include[1],
    sexp_of_t = include[2];
   function t_of_sexp$0(of_a_001, x_003){
    var _w_ = caml_call1(t_of_sexp, of_a_001);
    return caml_call2(Base_Uniform_array[1], _w_, x_003);
   }
   function sexp_of_t$0(of_a_004, x_005){
    var _v_ = caml_call1(sexp_of_t, of_a_004);
    return caml_call2(Base_Uniform_array[2], _v_, x_005);
   }
   function t_sexp_grammar(a_sexp_grammar){
    var
     _t_ = caml_call1(Base_Option[3], a_sexp_grammar),
     _u_ = caml_call1(Sexplib0_Sexp_grammar[1], _t_);
    return caml_call1(Base_Uniform_array[3], _u_);
   }
   var empty = Base_Uniform_array[6];
   function create(len){return caml_call2(Base_Uniform_array[7], len, none);}
   function init(n, f){
    return caml_call2
            (Base_Uniform_array[9],
             n,
             function(i){return of_sexpable(caml_call1(f, i));});
   }
   function init_some(n, f){
    return caml_call2
            (Base_Uniform_array[9],
             n,
             function(i){return some(caml_call1(f, i));});
   }
   var _a_ = Base_Uniform_array[10];
   function get(t, i){
    return to_sexpable(caml_call2(Base_Uniform_array[11], t, i));
   }
   function get_some_exn(t, i){
    return value_exn(caml_call2(Base_Uniform_array[11], t, i));
   }
   function is_none$0(t, i){
    return is_none(caml_call2(Base_Uniform_array[11], t, i));
   }
   function is_some$0(t, i){
    return is_some(caml_call2(Base_Uniform_array[11], t, i));
   }
   function set(t, i, x){
    var _s_ = of_sexpable(x);
    return caml_call3(Base_Uniform_array[13], t, i, _s_);
   }
   function set_some(t, i, x){
    var _r_ = some(x);
    return caml_call3(Base_Uniform_array[13], t, i, _r_);
   }
   function set_none(t, i){
    return caml_call3(Base_Uniform_array[13], t, i, none);
   }
   function swap(t, i, j){return caml_call3(Base_Uniform_array[15], t, i, j);}
   function unsafe_get(t, i){
    return to_sexpable(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_get_some_exn(t, i){
    return value_exn(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_get_some_assuming_some(t, i){
    return value_unsafe(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_is_some(t, i){
    return is_some(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_set(t, i, x){
    var _q_ = of_sexpable(x);
    return caml_call3(Base_Uniform_array[14], t, i, _q_);
   }
   function unsafe_set_some(t, i, x){
    var _p_ = some(x);
    return caml_call3(Base_Uniform_array[14], t, i, _p_);
   }
   function unsafe_set_none(t, i){
    return caml_call3(Base_Uniform_array[14], t, i, none);
   }
   function clear(t){
    var
     _m_ = caml_call1(_a_, t),
     _n_ = caml_call2(Base_Import[92], _m_, 1),
     _l_ = 0;
    if(_n_ >= 0){
     var i = _l_;
     for(;;){
      unsafe_set_none(t, i);
      var _o_ = i + 1 | 0;
      if(_n_ === i) break;
      i = _o_;
     }
    }
    return 0;
   }
   function _b_(input, f){
    var
     _i_ = caml_call1(_a_, input),
     _j_ = caml_call2(Base_Import[92], _i_, 1),
     _h_ = 0;
    if(_j_ >= 0){
     var i = _h_;
     for(;;){
      caml_call2(f, i, unsafe_get(input, i));
      var _k_ = i + 1 | 0;
      if(_j_ === i) break;
      i = _k_;
     }
    }
    return 0;
   }
   function _c_(input, init, f){
    var acc = [0, init];
    _b_
     (input,
      function(i, elem){acc[1] = caml_call3(f, i, acc[1], elem); return 0;});
    return acc[1];
   }
   function fold(input, init, f){
    return _c_
            (input,
             init,
             function(param, acc, x){return caml_call2(f, acc, x);});
   }
   var
    foldi = [0, -198771759, _c_],
    iter =
      [0,
       -198771759,
       function(input, f){
        return _b_(input, function(param, x){return caml_call1(f, x);});
       }],
    iteri = [0, -198771759, _b_],
    length = [0, -198771759, _a_],
    include$0 =
      caml_call1
       (Base_Indexed_container[10], [0, fold, iter, length, iteri, foldi]),
    length$0 = include$0[1],
    is_empty = include$0[2],
    iter$0 = include$0[3],
    fold$0 = include$0[4],
    fold_result = include$0[5],
    fold_until = include$0[6],
    exists = include$0[7],
    for_all = include$0[8],
    count = include$0[9],
    sum = include$0[10],
    find = include$0[11],
    find_map = include$0[12],
    to_list = include$0[13],
    min_elt = include$0[15],
    max_elt = include$0[16],
    foldi$0 = include$0[17],
    iteri$0 = include$0[18],
    existsi = include$0[19],
    for_alli = include$0[20],
    counti = include$0[21],
    findi = include$0[22],
    find_mapi = include$0[23];
   function map(input, f){
    var output = create(caml_call1(length$0, input));
    caml_call2
     (iteri$0,
      input,
      function(i, elem){return unsafe_set(output, i, caml_call1(f, elem));});
    return output;
   }
   function map_some(input, f){
    var
     len = caml_call1(length$0, input),
     output = create(len),
     _f_ = caml_call2(Base_Import[92], len, 1),
     _e_ = 0;
    if(_f_ >= 0){
     var i = _e_;
     for(;;){
      var opt = caml_call2(Base_Uniform_array[12], input, i);
      if(is_some(opt)){
       var x = value_unsafe(opt);
       unsafe_set_some(output, i, caml_call1(f, x));
      }
      var _g_ = i + 1 | 0;
      if(_f_ === i) break;
      i = _g_;
     }
    }
    return output;
   }
   function of_array(array){
    return init(array.length - 1, function(i){return array[1 + i];});
   }
   function of_array_some(array){
    return init_some(array.length - 1, function(i){return array[1 + i];});
   }
   function to_array(t){
    var _d_ = caml_call1(length$0, t);
    return caml_call2
            (Base_Array[27], _d_, function(i){return unsafe_get(t, i);});
   }
   function create_like(len, param){return create(len);}
   var
    unsafe_blit = Base_Uniform_array[30],
    include$1 =
      caml_call1(Base_Blit[5], [0, create_like, length$0, unsafe_blit]),
    blit = include$1[1],
    blito = include$1[2],
    unsafe_blit$0 = include$1[3],
    sub = include$1[4],
    subo = include$1[5],
    copy = Base_Uniform_array[33],
    Base_Option_array =
      [0,
       t_of_sexp$0,
       sexp_of_t$0,
       t_sexp_grammar,
       empty,
       create,
       length$0,
       is_empty,
       iter$0,
       fold$0,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       min_elt,
       max_elt,
       foldi$0,
       iteri$0,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       init_some,
       init,
       of_array,
       of_array_some,
       to_array,
       get,
       get_some_exn,
       is_none$0,
       is_some$0,
       unsafe_get,
       unsafe_get_some_exn,
       unsafe_get_some_assuming_some,
       unsafe_is_some,
       set,
       set_some,
       set_none,
       swap,
       clear,
       map,
       map_some,
       unsafe_set,
       unsafe_set_some,
       unsafe_set_none,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       copy,
       [0,
        [0,
         t_of_sexp,
         sexp_of_t,
         none,
         some,
         is_none,
         is_some,
         value_exn,
         value_unsafe,
         to_sexpable,
         of_sexpable]]];
   runtime.caml_register_global(10, Base_Option_array, "Base__Option_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stack
//# unitInfo: Requires: Assert_failure, Base__Container, Base__Error, Base__Exn, Base__Import, Base__List, Base__Option_array, Base__Sexp, Base__Stack_intf, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_stack_ml = "src/stack.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Option_array = global_data.Base__Option_array,
    Base_Error = global_data.Base__Error,
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Assert_failure = global_data.Assert_failure,
    Base_Exn = global_data.Base__Exn,
    Base_Sexp = global_data.Base__Sexp,
    Base_Container = global_data.Base__Container,
    raise_s = Base_Error[30],
    _a_ = [0, "elts"],
    _b_ = [0, "length"],
    cst_stack = "stack",
    cst_exn = "exn",
    cst_Stack_invariant_failed = "Stack.invariant failed",
    _c_ = [0, cst_src_stack_ml, 46, 6],
    _d_ = [0, cst_src_stack_ml, 39, 4];
   function capacity(t){return caml_call1(Base_Option_array[6], t[2]);}
   function invariant(invariant_a, t){
    var length = t[1], elts = t[2];
    try{
     if(0 <= length && length <= caml_call1(Base_Option_array[6], elts)){
      var _B_ = caml_call2(Base_Import[92], length, 1), _A_ = 0;
      if(_B_ >= 0){
       var i$0 = _A_;
       for(;;){
        caml_call1(invariant_a, caml_call2(Base_Option_array[34], elts, i$0));
        var _G_ = i$0 + 1 | 0;
        if(_B_ === i$0) break;
        i$0 = _G_;
       }
      }
      var
       _C_ = caml_call1(Base_Option_array[6], elts),
       _D_ = caml_call2(Base_Import[92], _C_, 1);
      if(_D_ >= length){
       var i = length;
       for(;;){
        if(caml_call2(Base_Option_array[36], elts, i))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
        var _F_ = i + 1 | 0;
        if(_D_ === i) break;
        i = _F_;
       }
      }
      var _E_ = 0;
      return _E_;
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      of_a_001 = Base_Import[154],
      length_003 = t[1],
      elts_005 = t[2],
      arg_006 = caml_call2(Base_Option_array[2], of_a_001, elts_005),
      bnds_002 = [0, [1, [0, _a_, [0, arg_006, 0]]], 0],
      arg_004 = caml_call1(Base_Import[141], length_003),
      bnds_002$0 = [0, [1, [0, _b_, [0, arg_004, 0]]], bnds_002],
      _z_ =
        [0,
         [0, cst_exn, caml_call1(Base_Exn[1], exn)],
         [0, [0, cst_stack, [1, bnds_002$0]], 0]];
     return caml_call1
             (raise_s,
              caml_call2(Base_Sexp[9], cst_Stack_invariant_failed, _z_));
    }
   }
   function create(param){return [0, 0, Base_Option_array[4]];}
   function length(t){return t[1];}
   function is_empty(t){return 0 === t[1] ? 1 : 0;}
   function fold(t, init, f){
    var r = [0, init], _w_ = caml_call2(Base_Import[92], t[1], 1);
    if(_w_ >= 0){
     var i = _w_;
     for(;;){
      var _x_ = caml_call2(Base_Option_array[34], t[2], i);
      r[1] = caml_call2(f, r[1], _x_);
      var _y_ = i - 1 | 0;
      if(0 === i) break;
      i = _y_;
     }
    }
    return r[1];
   }
   function iter(t, f){
    var _u_ = caml_call2(Base_Import[92], t[1], 1);
    if(_u_ >= 0){
     var i = _u_;
     for(;;){
      caml_call1(f, caml_call2(Base_Option_array[34], t[2], i));
      var _v_ = i - 1 | 0;
      if(0 === i) break;
      i = _v_;
     }
    }
    return 0;
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C = caml_call1(Base_Container[16], [0, fold, iter$0, length$0]),
    mem = C[1],
    exists = C[8],
    for_all = C[9],
    count = C[10],
    sum = C[11],
    find = C[12],
    find_map = C[13],
    to_list = C[14],
    to_array = C[15],
    min_elt = C[16],
    max_elt = C[17],
    fold_result = C[6],
    fold_until = C[7],
    _e_ = [0, cst_src_stack_ml, 107, 14];
   function of_list(l){
    if(caml_call1(Base_List[8], l)) return create(0);
    var
     length = caml_call1(Base_List[7], l),
     _r_ = caml_call2(Base_Import[87], 2, length),
     elts = caml_call1(Base_Option_array[5], _r_),
     r = [0, l],
     _s_ = caml_call2(Base_Import[92], length, 1);
    if(_s_ >= 0){
     var i = _s_;
     for(;;){
      var match = r[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      var l$0 = match[2], a = match[1];
      caml_call3(Base_Option_array[42], elts, i, a);
      r[1] = l$0;
      var _t_ = i - 1 | 0;
      if(0 === i) break;
      i = _t_;
     }
    }
    return [0, length, elts];
   }
   function sexp_of_t(sexp_of_a, t){
    var _q_ = caml_call1(to_list, t);
    return caml_call2(Base_List[4], sexp_of_a, _q_);
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_List[3], a_of_sexp, sexp));
   }
   function t_sexp_grammar(grammar){
    var _p_ = caml_call1(Base_List[5], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _p_);
   }
   function resize(t, size){
    var arr = caml_call1(Base_Option_array[5], size);
    caml_call5(Base_Option_array[51], t[2], 0, arr, 0, t[1]);
    t[2] = arr;
    return 0;
   }
   function set_capacity(t, new_capacity){
    var
     new_capacity$0 = caml_call2(Base_Import[99], new_capacity, t[1]),
     _o_ = new_capacity$0 !== capacity(t) ? 1 : 0;
    return _o_ ? resize(t, new_capacity$0) : _o_;
   }
   function push(t, a){
    var _m_ = caml_call1(Base_Option_array[6], t[2]);
    if(t[1] === _m_){
     var _n_ = caml_call2(Base_Import[90], t[1], 1);
     resize(t, caml_call2(Base_Import[87], 2, _n_));
    }
    caml_call3(Base_Option_array[42], t[2], t[1], a);
    t[1] = caml_call2(Base_Import[90], t[1], 1);
    return 0;
   }
   function pop_nonempty(t){
    var
     i = caml_call2(Base_Import[92], t[1], 1),
     result = caml_call2(Base_Option_array[34], t[2], i);
    caml_call2(Base_Option_array[43], t[2], i);
    t[1] = i;
    return result;
   }
   var pop_error = caml_call1(Base_Error[12], "Stack.pop of empty stack");
   function pop(t){return is_empty(t) ? 0 : [0, pop_nonempty(t)];}
   function pop_exn(t){
    return is_empty(t)
            ? caml_call1(Base_Error[29], pop_error)
            : pop_nonempty(t);
   }
   function top_nonempty(t){
    var _l_ = caml_call2(Base_Import[92], t[1], 1);
    return caml_call2(Base_Option_array[34], t[2], _l_);
   }
   var top_error = caml_call1(Base_Error[12], "Stack.top of empty stack");
   function top(t){return is_empty(t) ? 0 : [0, top_nonempty(t)];}
   function top_exn(t){
    return is_empty(t)
            ? caml_call1(Base_Error[29], top_error)
            : top_nonempty(t);
   }
   function copy(param){
    var length = param[1], elts = param[2];
    return [0, length, caml_call1(Base_Option_array[56], elts)];
   }
   function clear(t){
    var _g_ = 0 < t[1] ? 1 : 0;
    if(_g_){
     var _i_ = caml_call2(Base_Import[92], t[1], 1), _h_ = 0;
     if(_i_ >= 0){
      var i = _h_;
      for(;;){
       caml_call2(Base_Option_array[43], t[2], i);
       var _k_ = i + 1 | 0;
       if(_i_ === i) break;
       i = _k_;
      }
     }
     t[1] = 0;
     var _j_ = 0;
    }
    else
     var _j_ = _g_;
    return _j_;
   }
   function until_empty(t, f){
    for(;;){
     var _f_ = 0 < t[1] ? 1 : 0;
     if(! _f_) return _f_;
     caml_call1(f, pop_nonempty(t));
    }
   }
   function singleton(x){var t = create(0); push(t, x); return t;}
   var
    Base_Stack =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       of_list,
       create,
       singleton,
       push,
       pop,
       pop_exn,
       top,
       top_exn,
       clear,
       copy,
       until_empty,
       capacity,
       set_capacity];
   runtime.caml_register_global(19, Base_Stack, "Base__Stack");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Source_code_position
//# unitInfo: Requires: Base__Comparable, Base__Import, Base__Int, Base__Source_code_position0, Base__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Int = global_data.Base__Int,
    Base_Import = global_data.Base__Import,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Comparable = global_data.Base__Comparable;
   function hash_override(param){
    var
     pos_cnum = param[4],
     pos_bol = param[3],
     pos_lnum = param[2],
     pos_fname = param[1],
     _a_ = caml_call1(Base_Int[7], pos_cnum),
     _b_ = caml_call1(Base_Int[7], pos_bol),
     _c_ = caml_call1(Base_Int[7], pos_lnum),
     _d_ = runtime.Base_hash_string(pos_fname),
     _e_ = caml_call2(Base_Import[120], _d_, _c_),
     _f_ = caml_call2(Base_Import[120], _e_, _b_);
    return caml_call2(Base_Import[120], _f_, _a_);
   }
   var
    hash_fold_t = Base_Source_code_position0[3],
    comparator = Base_Source_code_position0[5],
    to_string = Base_Source_code_position0[7],
    sexp_of_t = Base_Source_code_position0[8],
    include = caml_call1(Base_Comparable[11], [0, sexp_of_t, comparator]),
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    ascending = include[11],
    descending = include[12],
    between = include[13],
    clamp_exn = include[14],
    clamp = include[15],
    comparator$0 = include[16];
   function of_pos(param){
    var pos_cnum = param[3], pos_lnum = param[2], pos_fname = param[1];
    return [0, pos_fname, pos_lnum, 0, pos_cnum];
   }
   var
    Base_Source_code_position =
      [0,
       hash_fold_t,
       hash_override,
       sexp_of_t,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator$0,
       to_string,
       of_pos];
   runtime.caml_register_global
    (4, Base_Source_code_position, "Base__Source_code_position");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign_or_nan
//# unitInfo: Requires: Base__Hash, Base__Identifiable, Base__Import, Base__Poly0, Base__Sign, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Nan = "Nan",
    cst_Neg = "Neg",
    cst_Pos = "Pos",
    cst_Zero = "Zero",
    cst_nan = "nan",
    cst_neg = "neg",
    cst_pos = "pos",
    cst_zero = "zero",
    caml_int_compare = runtime.caml_int_compare;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "sign_or_nan.ml.T.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Neg, 0]],
         [0,
          [1, [0, cst_Zero, 0]],
          [0, [1, [0, cst_Pos, 0]], [0, [1, [0, cst_Nan, 0]], 0]]]]]],
    all = [0, 0, [0, 1, [0, 2, [0, 3, 0]]]],
    module_name = "Base.Sign_or_nan",
    Base_Sign = global_data.Base__Sign,
    Base_Import = global_data.Base__Import,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Identifiable = global_data.Base__Identifiable,
    _a_ = [0, cst_Neg],
    _b_ = [0, cst_Zero],
    _c_ = [0, cst_Pos],
    _d_ = [0, cst_Nan];
   function t_of_sexp(sexp_004){
    a:
    {
     if(0 === sexp_004[0]){
      var _k_ = sexp_004[1];
      b:
      if(_k_ !== cst_Nan){
       c:
       if(_k_ !== cst_Neg){
        d:
        if(_k_ !== cst_Pos){
         if(_k_ !== cst_Zero){
          if(_k_ === cst_nan) break b;
          if(_k_ === cst_neg) break c;
          if(_k_ === cst_pos) break d;
          if(_k_ !== cst_zero) break a;
         }
         return 1;
        }
        return 2;
       }
       return 0;
      }
      return 3;
     }
     var _l_ = sexp_004[1];
     if(! _l_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
     var _m_ = _l_[1];
     if(0 !== _m_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_003, sexp_004);
     var _n_ = _m_[1];
     b:
     if(_n_ !== cst_Nan){
      c:
      if(_n_ !== cst_Neg){
       d:
       if(_n_ !== cst_Pos){
        if(_n_ !== cst_Zero){
         if(_n_ === cst_nan) break b;
         if(_n_ === cst_neg) break c;
         if(_n_ === cst_pos) break d;
         if(_n_ !== cst_zero) break a;
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_003, sexp_004);
   }
   function sexp_of_t(param){
    switch(param){
      case 0:
       return _a_;
      case 1:
       return _b_;
      case 2:
       return _c_;
      default: return _d_;
    }
   }
   var compare = caml_int_compare;
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      case 2:
       return caml_call2(Base_Hash[3], hsv, 2);
      default: return caml_call2(Base_Hash[3], hsv, 3);
    }
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _j_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _j_);
   }
   function of_string(s){return t_of_sexp(caml_call1(Base_Import[138], s));}
   function to_string(t){
    var _i_ = sexp_of_t(t);
    return caml_call1(Base_Import[162], _i_);
   }
   function symbol(x, y){return x < y ? 1 : 0;}
   function symbol$0(x, y){return x <= y ? 1 : 0;}
   function symbol$1(x, y){return x !== y ? 1 : 0;}
   function symbol$2(x, y){return x === y ? 1 : 0;}
   function symbol$3(x, y){return y < x ? 1 : 0;}
   function symbol$4(x, y){return y <= x ? 1 : 0;}
   function ascending(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare;
   function equal(x, y){return x === y ? 1 : 0;}
   function max(x, y){return y <= x ? x : y;}
   function min(x, y){return x <= y ? x : y;}
   var
    _e_ =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = _e_[1],
    hash$0 = _e_[2],
    t_of_sexp$0 = _e_[3],
    sexp_of_t$0 = _e_[4],
    of_string$0 = _e_[5],
    to_string$0 = _e_[6],
    between = _e_[19],
    clamp_exn = _e_[20],
    clamp = _e_[21],
    comparator = _e_[22],
    pp = _e_[23],
    hashable = _e_[24],
    cst_Base_Sign_or_nan_to_sign_e = "Base.Sign_or_nan.to_sign_exn: Nan";
   function of_sign(param){
    switch(param){case 0: return 0;case 1: return 1;default: return 2;
    }
   }
   function to_sign_exn(param){
    switch(param){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      default:
       return caml_call1(Base_Import[125], cst_Base_Sign_or_nan_to_sign_e);
    }
   }
   function of_int(n){return of_sign(caml_call1(Base_Sign[27], n));}
   function to_int_exn(t){
    var _h_ = to_sign_exn(t);
    return caml_call1(Base_Sign[28], _h_);
   }
   function flip(param){
    switch(param){
      case 0:
       return 2;
      case 1:
       return 1;
      case 2:
       return 0;
      default: return 3;
    }
   }
   function symbol$5(t$0, t){
    if(3 > t$0 && 3 > t){
     var _f_ = to_sign_exn(t), _g_ = to_sign_exn(t$0);
     return of_sign(caml_call2(Base_Sign[31], _g_, _f_));
    }
    return 3;
   }
   var
    Base_Sign_or_nan =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       of_int,
       to_int_exn,
       of_sign,
       to_sign_exn,
       flip,
       symbol$5];
   runtime.caml_register_global(31, Base_Sign_or_nan, "Base__Sign_or_nan");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexp_with_comparable
//# unitInfo: Requires: Base__Comparable, Base__Sexp
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Sexp = global_data.Base__Sexp,
    Base_Comparable = global_data.Base__Comparable,
    hash_fold_t = Base_Sexp[1],
    hash = Base_Sexp[2],
    t_of_sexp = Base_Sexp[3],
    sexp_of_t = Base_Sexp[4],
    Not_found_s = Base_Sexp[7],
    Of_sexp_error = Base_Sexp[8],
    message = Base_Sexp[9],
    default_indent = Base_Sexp[10],
    pp_hum = Base_Sexp[11],
    pp_hum_indent = Base_Sexp[12],
    pp_mach = Base_Sexp[13],
    pp = Base_Sexp[14],
    to_string_hum = Base_Sexp[15],
    to_string_mach = Base_Sexp[16],
    to_string = Base_Sexp[17],
    of_float_style = Base_Sexp[18],
    of_int_style = Base_Sexp[19],
    t_sexp_grammar = Base_Sexp[21],
    invariant = Base_Sexp[22],
    of_string = Base_Sexp[23],
    include = caml_call1(Base_Comparable[10], [0, Base_Sexp[6], Base_Sexp[4]]),
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    ascending = include[11],
    descending = include[12],
    between = include[13],
    clamp_exn = include[14],
    clamp = include[15],
    comparator = include[16],
    Base_Sexp_with_comparable =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator];
   runtime.caml_register_global
    (2, Base_Sexp_with_comparable, "Base__Sexp_with_comparable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hasher
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hasher = [0];
   runtime.caml_register_global(0, Base_Hasher, "Base__Hasher");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Maybe_bound
//# unitInfo: Requires: Base__Hash, Base__Import, Base__List, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Above_upper_bound = "Above_upper_bound",
    cst_Below_lower_bound = "Below_lower_bound",
    cst_Excl$0 = "Excl",
    cst_In_range = "In_range",
    cst_Incl$0 = "Incl",
    cst_Unbounded = "Unbounded",
    cst_above_upper_bound = "above_upper_bound",
    cst_below_lower_bound = "below_lower_bound",
    cst_excl = "excl",
    cst_in_range = "in_range",
    cst_incl = "incl",
    cst_unbounded = "unbounded";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_006 = "maybe_bound.ml.t",
    error_source_027 = "maybe_bound.ml.interval_comparison",
    interval_comparison_sexp_gramm =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Below_lower_bound, 0]],
         [0,
          [1, [0, cst_In_range, 0]],
          [0, [1, [0, cst_Above_upper_bound, 0]], 0]]]]],
    Base_Import = global_data.Base__Import,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_List = global_data.Base__List,
    _a_ = [0, 0, 0],
    _b_ = [0, cst_Unbounded],
    _c_ = [0, cst_Incl$0],
    _d_ = [0, cst_Excl$0],
    _e_ = [0, [1, [0, cst_Unbounded, 0]], 0],
    cst_Excl = cst_Excl$0,
    cst_Incl = cst_Incl$0,
    _f_ = [0, cst_Below_lower_bound],
    _g_ = [0, cst_In_range],
    _h_ = [0, cst_Above_upper_bound];
   function all(all_of_a){
    var l = all_of_a, acc = 0;
    for(;;){
     if(! l) break;
     var
      l$0 = l[2],
      enumerate_002 = l[1],
      acc$0 = [0, [1, enumerate_002], acc];
     l = l$0;
     acc = acc$0;
    }
    var
     _q_ = caml_call1(Base_List[38], acc),
     l$1 = all_of_a,
     acc$1 = 0,
     _r_ = caml_call2(Base_List[75], _q_, _a_);
    for(;;){
     if(! l$1){
      var _s_ = caml_call1(Base_List[38], acc$1);
      return caml_call2(Base_List[75], _s_, _r_);
     }
     var
      l$2 = l$1[2],
      enumerate_001 = l$1[1],
      acc$2 = [0, [0, enumerate_001], acc$1];
     l$1 = l$2;
     acc$1 = acc$2;
    }
   }
   function t_of_sexp(of_a_003, sexp_008){
    a:
    {
     if(0 === sexp_008[0]){
      var _n_ = sexp_008[1];
      b:
      if(_n_ !== cst_Excl$0){
       c:
       if(_n_ !== cst_Incl$0){
        if(_n_ !== cst_Unbounded){
         if(_n_ === cst_excl) break b;
         if(_n_ === cst_incl) break c;
         if(_n_ !== cst_unbounded) break a;
        }
        return 0;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_006, sexp_008);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_006, sexp_008);
     }
     var _o_ = sexp_008[1];
     if(! _o_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_006, sexp_008);
     var _p_ = _o_[1];
     if(0 !== _p_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_006, sexp_008);
     var tag_009 = _p_[1];
     b:
     if(tag_009 !== cst_Excl$0){
      c:
      if(tag_009 !== cst_Incl$0){
       if(tag_009 !== cst_Unbounded){
        if(tag_009 === cst_excl) break b;
        if(tag_009 === cst_incl) break c;
        if(tag_009 !== cst_unbounded) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_008);
      }
      var sexp_args_010 = _o_[2];
      if(sexp_args_010 && ! sexp_args_010[2]){
       var
        arg0_011 = sexp_args_010[1],
        res0_012 = caml_call1(of_a_003, arg0_011);
       return [0, res0_012];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_006,
               tag_009,
               sexp_008);
     }
     var sexp_args_015 = _o_[2];
     if(sexp_args_015 && ! sexp_args_015[2]){
      var
       arg0_016 = sexp_args_015[1],
       res0_017 = caml_call1(of_a_003, arg0_016);
      return [1, res0_017];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_006,
              tag_009,
              sexp_008);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_006, sexp_008);
   }
   function sexp_of_t(of_a_019, param){
    if(typeof param === "number") return _b_;
    if(0 === param[0]){
     var arg0_020 = param[1], res0_021 = caml_call1(of_a_019, arg0_020);
     return [1, [0, _c_, [0, res0_021, 0]]];
    }
    var arg0_022 = param[1], res0_023 = caml_call1(of_a_019, arg0_022);
    return [1, [0, _d_, [0, res0_023, 0]]];
   }
   function t_sexp_grammar(a_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Incl, [0, [0, a_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Excl, [0, [0, a_sexp_grammar, 0]]]], _e_]]]];
   }
   function interval_comparison_of_sexp(sexp_028){
    a:
    {
     if(0 === sexp_028[0]){
      var _j_ = sexp_028[1];
      b:
      if(_j_ !== cst_Above_upper_bound){
       c:
       if(_j_ !== cst_Below_lower_bound){
        if(_j_ !== cst_In_range){
         if(_j_ === cst_above_upper_bound) break b;
         if(_j_ === cst_below_lower_bound) break c;
         if(_j_ !== cst_in_range) break a;
        }
        return 1;
       }
       return 0;
      }
      return 2;
     }
     var _k_ = sexp_028[1];
     if(! _k_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_027, sexp_028);
     var _l_ = _k_[1];
     if(0 !== _l_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_027, sexp_028);
     var _m_ = _l_[1];
     b:
     if(_m_ !== cst_Above_upper_bound){
      c:
      if(_m_ !== cst_Below_lower_bound){
       if(_m_ !== cst_In_range){
        if(_m_ === cst_above_upper_bound) break b;
        if(_m_ === cst_below_lower_bound) break c;
        if(_m_ !== cst_in_range) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_027, sexp_028);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_027, sexp_028);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_027, sexp_028);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_027, sexp_028);
   }
   function sexp_of_interval_comparison(param){
    switch(param){case 0: return _f_;case 1: return _g_;default: return _h_;
    }
   }
   var
    compare_interval_comparison = runtime.caml_int_compare,
    cst_Maybe_bound_compare_to_int =
      "Maybe_bound.compare_to_interval_exn: lower bound > upper bound";
   function hash_fold_interval_comparison(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      default: return caml_call2(Base_Hash[3], hsv, 2);
    }
   }
   function hash_interval_comparison(arg){
    var
     hsv = caml_call2(Base_Hash[11], 0, 0),
     _i_ = hash_fold_interval_comparison(hsv, arg);
    return caml_call1(Base_Hash[9], _i_);
   }
   function map(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var incl = t[1]; return [0, caml_call1(f, incl)];}
    var excl = t[1];
    return [1, caml_call1(f, excl)];
   }
   function is_lower_bound(t, a, compare){
    if(typeof t === "number") return 1;
    if(0 === t[0]){
     var incl = t[1];
     return caml_call2(compare, incl, a) <= 0 ? 1 : 0;
    }
    var excl = t[1];
    return caml_call2(compare, excl, a) < 0 ? 1 : 0;
   }
   function is_upper_bound(t, a, compare){
    if(typeof t === "number") return 1;
    if(0 === t[0]){
     var incl = t[1];
     return caml_call2(compare, a, incl) <= 0 ? 1 : 0;
    }
    var excl = t[1];
    return caml_call2(compare, a, excl) < 0 ? 1 : 0;
   }
   function bounds_crossed(lower, upper, compare){
    if(typeof lower === "number") return 0;
    var lower$0 = lower[1];
    if(typeof upper === "number") return 0;
    var upper$0 = upper[1];
    return 0 < caml_call2(compare, lower$0, upper$0) ? 1 : 0;
   }
   function compare_to_interval_exn(lower, upper, a, compare){
    if(bounds_crossed(lower, upper, compare))
     caml_call1(Base_Import[123], cst_Maybe_bound_compare_to_int);
    return is_lower_bound(lower, a, compare)
            ? is_upper_bound(upper, a, compare) ? 1 : 2
            : 0;
   }
   function interval_contains_exn(lower, upper, a, compare){
    return 1 === compare_to_interval_exn(lower, upper, a, compare) ? 1 : 0;
   }
   var
    Base_Maybe_bound =
      [0,
       all,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       map,
       is_lower_bound,
       is_upper_bound,
       interval_contains_exn,
       bounds_crossed,
       sexp_of_interval_comparison,
       interval_comparison_of_sexp,
       interval_comparison_sexp_gramm,
       compare_interval_comparison,
       hash_fold_interval_comparison,
       hash_interval_comparison,
       compare_to_interval_exn];
   runtime.caml_register_global(42, Base_Maybe_bound, "Base__Maybe_bound");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Map_intf
//# unitInfo: Requires: Base__Ppx_compare_lib, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Left$0 = "Left",
    cst_Right$0 = "Right",
    cst_Unequal$0 = "Unequal",
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_057 = "map_intf.ml.Symmetric_diff_element.t",
    all = [0, 0, [0, 1, 0]],
    all$0 = [0, 0, [0, 1, 0]],
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    _a_ = [0, "Duplicate"],
    _b_ = [0, "Ok"];
   function compare(cmp_a, a_001, b_002){
    if(caml_call2(Base_Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(typeof a_001 === "number"){
     if(-1024851605 === b_002) return 0;
    }
    else if(typeof b_002 !== "number" && 17724 === b_002[1]){
     var right_004 = b_002[2], left_003 = a_001[2];
     return caml_call2(cmp_a, left_003, right_004);
    }
    return caml_compare(a_001, b_002);
   }
   function equal(cmp_a, a_005, b_006){
    if(caml_call2(Base_Ppx_compare_lib[1], a_005, b_006)) return 1;
    if(typeof a_005 === "number"){
     if(-1024851605 === b_006) return 1;
    }
    else if(typeof b_006 !== "number" && 17724 === b_006[1]){
     var right_008 = b_006[2], left_007 = a_005[2];
     return caml_call2(cmp_a, left_007, right_008);
    }
    return caml_equal(a_005, b_006);
   }
   function sexp_of_t(of_a_009, param){
    if(typeof param === "number") return _a_;
    var v_010 = param[2];
    return [1, [0, _b_, [0, caml_call1(of_a_009, v_010), 0]]];
   }
   var
    Or_duplicate = [0, compare, equal, sexp_of_t],
    Without_comparator = [0],
    With_comparator = [0],
    With_first_class_module = [0],
    _c_ = [0, cst_Left$0],
    _d_ = [0, cst_Unequal$0],
    _e_ = [0, cst_Right$0],
    cst_Unequal = cst_Unequal$0,
    cst_Right = cst_Right$0,
    cst_Left = cst_Left$0;
   function compare$0(cmp_k, cmp_v, a_011, b_012){
    var
     t_014 = a_011[2],
     t_013 = a_011[1],
     t_016 = b_012[2],
     t_015 = b_012[1],
     n = caml_call2(cmp_k, t_013, t_015);
    if(0 !== n) return n;
    if(caml_call2(Base_Ppx_compare_lib[1], t_014, t_016)) return 0;
    var _O_ = t_014[1];
    if(847852583 === _O_){
     if(typeof t_016 !== "number" && 847852583 === t_016[1]){
      var right_018 = t_016[2], left_017 = t_014[2];
      return caml_call2(cmp_v, left_017, right_018);
     }
    }
    else
     if(1013247643 <= _O_){
      if(typeof t_016 !== "number" && 1013247643 === t_016[1]){
       var
        right_022 = t_016[2],
        left_021 = t_014[2],
        t_024 = left_021[2],
        t_023 = left_021[1],
        t_026 = right_022[2],
        t_025 = right_022[1],
        n$0 = caml_call2(cmp_v, t_023, t_025);
       return 0 === n$0 ? caml_call2(cmp_v, t_024, t_026) : n$0;
      }
     }
     else if(typeof t_016 !== "number" && -57574468 === t_016[1]){
      var right_020 = t_016[2], left_019 = t_014[2];
      return caml_call2(cmp_v, left_019, right_020);
     }
    return caml_compare(t_014, t_016);
   }
   function equal$0(cmp_k, cmp_v, a_027, b_028){
    var
     t_030 = a_027[2],
     t_029 = a_027[1],
     t_032 = b_028[2],
     t_031 = b_028[1],
     _K_ = caml_call2(cmp_k, t_029, t_031);
    if(_K_){
     if(caml_call2(Base_Ppx_compare_lib[1], t_030, t_032)) return 1;
     var _L_ = t_030[1];
     if(847852583 === _L_){
      if(typeof t_032 !== "number" && 847852583 === t_032[1]){
       var right_034 = t_032[2], left_033 = t_030[2];
       return caml_call2(cmp_v, left_033, right_034);
      }
     }
     else
      if(1013247643 <= _L_){
       if(typeof t_032 !== "number" && 1013247643 === t_032[1]){
        var
         right_038 = t_032[2],
         left_037 = t_030[2],
         t_040 = left_037[2],
         t_039 = left_037[1],
         t_042 = right_038[2],
         t_041 = right_038[1],
         _N_ = caml_call2(cmp_v, t_039, t_041);
        return _N_ ? caml_call2(cmp_v, t_040, t_042) : _N_;
       }
      }
      else if(typeof t_032 !== "number" && -57574468 === t_032[1]){
       var right_036 = t_032[2], left_035 = t_030[2];
       return caml_call2(cmp_v, left_035, right_036);
      }
     var _M_ = caml_equal(t_030, t_032);
    }
    else
     var _M_ = _K_;
    return _M_;
   }
   function t_of_sexp(of_k_043, of_v_044, sexp_071){
    if(1 === sexp_071[0]){
     var _v_ = sexp_071[1];
     if(_v_){
      var _w_ = _v_[2];
      if(_w_ && ! _w_[2]){
       var
        arg1_068 = _w_[1],
        arg0_067 = _v_[1],
        res0_069 = caml_call1(of_k_043, arg0_067);
       try{
        if(0 === arg1_068[0])
         var
          atom_047 = arg1_068[1],
          _y_ =
            atom_047 !== cst_Left$0
             ? atom_047
               !== cst_Right$0
               ? atom_047
                 !== cst_Unequal$0
                 ? caml_call1(Sexplib0_Sexp_conv_error[19], 0)
                 : caml_call2
                   (Sexplib0_Sexp_conv_error[23], error_source_057, arg1_068)
               : caml_call2
                 (Sexplib0_Sexp_conv_error[23], error_source_057, arg1_068)
             : caml_call2
               (Sexplib0_Sexp_conv_error[23], error_source_057, arg1_068),
          _z_ = _y_;
        else{
         var _A_ = arg1_068[1];
         if(_A_){
          var match = _A_[1];
          if(0 === match[0]){
           var sexp_args_050 = _A_[2], atom_047$0 = match[1];
           if(atom_047$0 !== cst_Left$0)
            if(atom_047$0 !== cst_Right$0)
             if(atom_047$0 !== cst_Unequal$0)
              var _B_ = caml_call1(Sexplib0_Sexp_conv_error[19], 0);
             else{
              a:
              {
               if(sexp_args_050 && ! sexp_args_050[2]){
                var arg0_058 = sexp_args_050[1];
                b:
                {
                 if(1 === arg0_058[0]){
                  var _F_ = arg0_058[1];
                  if(_F_){
                   var _G_ = _F_[2];
                   if(_G_ && ! _G_[2]){
                    var
                     arg1_053 = _G_[1],
                     arg0_052 = _F_[1],
                     res0_054 = caml_call1(of_v_044, arg0_052),
                     res1_055 = caml_call1(of_v_044, arg1_053),
                     res0_059 = [0, res0_054, res1_055];
                    break b;
                   }
                  }
                 }
                 var
                  res0_059 =
                    caml_call3
                     (Sexplib0_Sexp_conv_error[2], error_source_057, 2, arg0_058);
                }
                var _E_ = [0, 1013247643, res0_059];
                break a;
               }
               var
                _E_ =
                  caml_call3
                   (Sexplib0_Sexp_conv_error[22],
                    error_source_057,
                    atom_047$0,
                    arg1_068);
              }
              var _B_ = _E_;
             }
            else{
             a:
             {
              if(sexp_args_050 && ! sexp_args_050[2]){
               var
                arg0_061 = sexp_args_050[1],
                res0_062 = caml_call1(of_v_044, arg0_061),
                _H_ = [0, -57574468, res0_062];
               break a;
              }
              var
               _H_ =
                 caml_call3
                  (Sexplib0_Sexp_conv_error[22],
                   error_source_057,
                   atom_047$0,
                   arg1_068);
             }
             var _B_ = _H_;
            }
           else{
            a:
            {
             if(sexp_args_050 && ! sexp_args_050[2]){
              var
               arg0_064 = sexp_args_050[1],
               res0_065 = caml_call1(of_v_044, arg0_064),
               _I_ = [0, 847852583, res0_065];
              break a;
             }
             var
              _I_ =
                caml_call3
                 (Sexplib0_Sexp_conv_error[22],
                  error_source_057,
                  atom_047$0,
                  arg1_068);
            }
            var _B_ = _I_;
           }
           var _C_ = _B_;
          }
          else
           var
            _C_ =
              caml_call2
               (Sexplib0_Sexp_conv_error[24], error_source_057, arg1_068);
          var _D_ = _C_;
         }
         else
          var
           _D_ =
             caml_call2
              (Sexplib0_Sexp_conv_error[25], error_source_057, arg1_068);
         var _z_ = _D_;
        }
        var res1_070 = _z_;
       }
       catch(_J_){
        var _x_ = caml_wrap_exception(_J_);
        if(_x_ !== Sexplib0_Sexp_conv_error[18])
         throw caml_maybe_attach_backtrace(_x_, 0);
        var
         res1_070 =
           caml_call2
            (Sexplib0_Sexp_conv_error[20], error_source_057, arg1_068);
       }
       return [0, res0_069, res1_070];
      }
     }
    }
    return caml_call3
            (Sexplib0_Sexp_conv_error[2], error_source_057, 2, sexp_071);
   }
   function sexp_of_t$0(of_k_072, of_v_073, param){
    var
     arg1_082 = param[2],
     arg0_081 = param[1],
     res0_083 = caml_call1(of_k_072, arg0_081),
     _u_ = arg1_082[1];
    if(847852583 === _u_)
     var
      v_074 = arg1_082[2],
      res1_084 = [1, [0, _c_, [0, caml_call1(of_v_073, v_074), 0]]];
    else if(1013247643 <= _u_)
     var
      v_076 = arg1_082[2],
      arg1_078 = v_076[2],
      arg0_077 = v_076[1],
      res0_079 = caml_call1(of_v_073, arg0_077),
      res1_080 = caml_call1(of_v_073, arg1_078),
      res1_084 = [1, [0, _d_, [0, [1, [0, res0_079, [0, res1_080, 0]]], 0]]];
    else
     var
      v_075 = arg1_082[2],
      res1_084 = [1, [0, _e_, [0, caml_call1(of_v_073, v_075), 0]]];
    return [1, [0, res0_083, [0, res1_084, 0]]];
   }
   function t_sexp_grammar(k_sexp_grammar, v_sexp_grammar){
    return [2,
            [0,
             k_sexp_grammar,
             [0,
              [3,
               [0,
                1,
                [0,
                 [1, [0, cst_Left, [0, [0, v_sexp_grammar, 0]]]],
                 [0,
                  [1, [0, cst_Right, [0, [0, v_sexp_grammar, 0]]]],
                  [0,
                   [1,
                    [0,
                     cst_Unequal,
                     [0,
                      [0, [2, [0, v_sexp_grammar, [0, v_sexp_grammar, 0]]], 0]]]],
                   0]]]]],
              0]]];
   }
   var
    Symmetric_diff_element =
      [0, compare$0, equal$0, t_of_sexp, sexp_of_t$0, t_sexp_grammar],
    _f_ = [0, "Both"],
    _g_ = [0, cst_Left$0],
    _h_ = [0, cst_Right$0];
   function compare$1(cmp_left, cmp_right, a_085, b_086){
    if(caml_call2(Base_Ppx_compare_lib[1], a_085, b_086)) return 0;
    var _t_ = a_085[1];
    if(737457313 === _t_){
     if(typeof b_086 !== "number" && 737457313 === b_086[1]){
      var
       right_092 = b_086[2],
       left_091 = a_085[2],
       t_094 = left_091[2],
       t_093 = left_091[1],
       t_096 = right_092[2],
       t_095 = right_092[1],
       n = caml_call2(cmp_left, t_093, t_095);
      return 0 === n ? caml_call2(cmp_right, t_094, t_096) : n;
     }
    }
    else
     if(847852583 <= _t_){
      if(typeof b_086 !== "number" && 847852583 === b_086[1]){
       var right_088 = b_086[2], left_087 = a_085[2];
       return caml_call2(cmp_left, left_087, right_088);
      }
     }
     else if(typeof b_086 !== "number" && -57574468 === b_086[1]){
      var right_090 = b_086[2], left_089 = a_085[2];
      return caml_call2(cmp_right, left_089, right_090);
     }
    return caml_compare(a_085, b_086);
   }
   function equal$1(cmp_left, cmp_right, a_097, b_098){
    if(caml_call2(Base_Ppx_compare_lib[1], a_097, b_098)) return 1;
    var _r_ = a_097[1];
    if(737457313 === _r_){
     if(typeof b_098 !== "number" && 737457313 === b_098[1]){
      var
       right_104 = b_098[2],
       left_103 = a_097[2],
       t_106 = left_103[2],
       t_105 = left_103[1],
       t_108 = right_104[2],
       t_107 = right_104[1],
       _s_ = caml_call2(cmp_left, t_105, t_107);
      return _s_ ? caml_call2(cmp_right, t_106, t_108) : _s_;
     }
    }
    else
     if(847852583 <= _r_){
      if(typeof b_098 !== "number" && 847852583 === b_098[1]){
       var right_100 = b_098[2], left_099 = a_097[2];
       return caml_call2(cmp_left, left_099, right_100);
      }
     }
     else if(typeof b_098 !== "number" && -57574468 === b_098[1]){
      var right_102 = b_098[2], left_101 = a_097[2];
      return caml_call2(cmp_right, left_101, right_102);
     }
    return caml_equal(a_097, b_098);
   }
   function sexp_of_t$1(of_left_109, of_right_110, param){
    var _q_ = param[1];
    if(737457313 === _q_){
     var
      v_113 = param[2],
      arg1_115 = v_113[2],
      arg0_114 = v_113[1],
      res0_116 = caml_call1(of_left_109, arg0_114),
      res1_117 = caml_call1(of_right_110, arg1_115);
     return [1, [0, _f_, [0, [1, [0, res0_116, [0, res1_117, 0]]], 0]]];
    }
    if(847852583 <= _q_){
     var v_111 = param[2];
     return [1, [0, _g_, [0, caml_call1(of_left_109, v_111), 0]]];
    }
    var v_112 = param[2];
    return [1, [0, _h_, [0, caml_call1(of_right_110, v_112), 0]]];
   }
   var
    Merge_element = [0, compare$1, equal$1, sexp_of_t$1],
    compare$2 = caml_int_compare,
    _i_ = [0, "Stop"],
    _j_ = [0, "Continue"];
   function equal$2(_p_, _o_){return _p_ === _o_ ? 1 : 0;}
   function sexp_of_t$2(param){return param ? _i_ : _j_;}
   var
    Continue_or_stop = [0, compare$2, all, equal$2, sexp_of_t$2],
    compare$3 = caml_int_compare,
    _k_ = [0, "Unfinished"],
    _l_ = [0, "Finished"];
   function equal$3(_n_, _m_){return _n_ === _m_ ? 1 : 0;}
   function sexp_of_t$3(param){return param ? _k_ : _l_;}
   var Finished_or_unfinished = [0, compare$3, all$0, equal$3, sexp_of_t$3];
   function Check_accessors(T, Tree, Key, Cmp, Options, symbol){return [0];}
   function Check_accessors1(M){return [0];}
   function Check_accessors2(M){return [0];}
   function Check_accessors3(M){return [0];}
   function Check_accessors3_with_comparat(M){return [0];}
   function Check_creators(T, Tree, Key, Cmp, Options, symbol){return [0];}
   function Check_creators1(M){return [0];}
   function Check_creators2(M){return [0];}
   function Check_creators3_with_comparato(M){return [0];}
   var
    Base_Map_intf =
      [0,
       Or_duplicate,
       Without_comparator,
       With_comparator,
       With_first_class_module,
       Symmetric_diff_element,
       Merge_element,
       Continue_or_stop,
       Finished_or_unfinished,
       Check_accessors,
       Check_accessors1,
       Check_accessors2,
       Check_accessors3,
       Check_accessors3_with_comparat,
       Check_creators,
       Check_creators1,
       Check_creators2,
       Check_creators3_with_comparato];
   runtime.caml_register_global(26, Base_Map_intf, "Base__Map_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Set_intf
//# unitInfo: Requires: Base__Map_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data();
   global_data.Base__Map_intf;
   function Check_accessors(T, Tree, Elt, Named, Cmp, Options, symbol){return [0];
   }
   function Check_accessors0(M){return [0];}
   function Check_accessors1(M){return [0];}
   function Check_accessors2(M){return [0];}
   function Check_accessors2_with_comparat(M){return [0];}
   function Check_creators(T, Tree, Elt, Cmp, Options, symbol){return [0];}
   function Check_creators0(M){return [0];}
   function Check_creators1(M){return [0];}
   function Check_creators2(M){return [0];}
   function Check_creators2_with_comparato(M){return [0];}
   var
    Base_Set_intf =
      [0,
       Check_accessors,
       Check_accessors0,
       Check_accessors1,
       Check_accessors2,
       Check_accessors2_with_comparat,
       Check_creators,
       Check_creators0,
       Check_creators1,
       Check_creators2,
       Check_creators2_with_comparato];
   runtime.caml_register_global(1, Base_Set_intf, "Base__Set_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Set
//# unitInfo: Requires: Assert_failure, Base__Array, Base__Comparator, Base__Container, Base__Fn, Base__Hash, Base__Import, Base__List, Base__Option, Base__Or_error, Base__Sequence, Base__Set_intf, Base__Sexp, Base__With_return, Sexplib0__Sexp_conv, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_of_sorted_array_duplicated$1 = "of_sorted_array: duplicated elements",
    cst_src_set_ml = "src/set.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Or_error = global_data.Base__Or_error,
    Base_Container = global_data.Base__Container,
    Base_List = global_data.Base__List,
    Base_Sexp = global_data.Base__Sexp,
    Assert_failure = global_data.Assert_failure,
    Base_Array = global_data.Base__Array,
    Base_Sequence = global_data.Base__Sequence,
    Base_Fn = global_data.Base__Fn,
    Base_Option = global_data.Base__Option,
    Base_With_return = global_data.Base__With_return,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Comparator = global_data.Base__Comparator,
    with_return = Base_With_return[1],
    cst_of_sorted_array_duplicated = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_duplicated$0 = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_elements_a =
      "of_sorted_array: elements are not ordered",
    _a_ = [0, cst_src_set_ml, 199, 17],
    _b_ = [0, cst_src_set_ml, 200, 18],
    _c_ = [0, cst_src_set_ml, 206, 21],
    _d_ = [0, cst_src_set_ml, 208, 12],
    _e_ = [0, cst_src_set_ml, 214, 17],
    _f_ = [0, cst_src_set_ml, 215, 18],
    _g_ = [0, cst_src_set_ml, 221, 21],
    _h_ = [0, cst_src_set_ml, 223, 12];
   function height(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var h = param[4];
    return h;
   }
   function length(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var s = param[5];
    return s;
   }
   function in_range(lower, upper, compare_elt, v){
    if(lower)
     var
      lower$0 = lower[1],
      _bC_ = caml_call2(compare_elt, lower$0, v) < 0 ? 1 : 0;
    else
     var _bC_ = 1;
    if(_bC_){
     if(upper){
      var upper$0 = upper[1];
      return caml_call2(compare_elt, v, upper$0) < 0 ? 1 : 0;
     }
     var _bD_ = 1;
    }
    else
     var _bD_ = _bC_;
    return _bD_;
   }
   function loop(lower, upper, compare_elt, t){
    var lower$0 = lower, t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){
      var v = t$0[1];
      return in_range(lower$0, upper, compare_elt, v);
     }
     var
      n = t$0[5],
      h = t$0[4],
      r = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      hl = height(l),
      hr = height(r),
      _br_ = caml_call2(Base_Import[92], hl, hr),
      _bs_ = caml_call1(Base_Import[122], _br_) <= 2 ? 1 : 0;
     if(_bs_){
      var
       _bt_ = caml_call2(Base_Import[99], hl, hr),
       _bu_ = h === caml_call2(Base_Import[90], _bt_, 1) ? 1 : 0;
      if(_bu_){
       var
        _bv_ = length(r),
        _bw_ = length(l),
        _bx_ = caml_call2(Base_Import[90], _bw_, _bv_),
        _by_ = n === caml_call2(Base_Import[90], _bx_, 1) ? 1 : 0;
       if(_by_){
        var _bz_ = in_range(lower$0, upper, compare_elt, v$0);
        if(_bz_){
         var _bA_ = loop(lower$0, [0, v$0], compare_elt, l);
         if(_bA_){
          var lower$1 = [0, v$0];
          lower$0 = lower$1;
          t$0 = r;
          continue;
         }
         var _bB_ = _bA_;
        }
        else
         var _bB_ = _bz_;
       }
       else
        var _bB_ = _by_;
      }
      else
       var _bB_ = _bu_;
     }
     else
      var _bB_ = _bs_;
     return _bB_;
    }
   }
   function invariants(t, compare_elt){return loop(0, 0, compare_elt, t);}
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function create(l, v, r){
    if(typeof l === "number")
     var hl = 0;
    else if(0 === l[0]) var hl = 1; else var h$1 = l[4], hl = h$1;
    if(typeof r === "number")
     var hr = 0;
    else if(0 === r[0]) var hr = 1; else var h$0 = r[4], hr = h$0;
    var
     h =
       hr <= hl
        ? caml_call2(Base_Import[90], hl, 1)
        : caml_call2(Base_Import[90], hr, 1);
    if(1 === h) return [0, v];
    if(typeof l === "number")
     var sl = 0;
    else if(0 === l[0]) var sl = 1; else var s$0 = l[5], sl = s$0;
    if(typeof r === "number")
     var sr = 0;
    else if(0 === r[0]) var sr = 1; else var s = r[5], sr = s;
    var _bq_ = caml_call2(Base_Import[90], sl, sr);
    return [1, l, v, r, h, caml_call2(Base_Import[90], _bq_, 1)];
   }
   function of_increasing_iterator_uncheck(len, f){
    function loop(n, f, i){
     if(3 >= n >>> 0)
      switch(n){
        case 0:
         return 0;
        case 1:
         var k$0 = caml_call1(f, i); return [0, k$0];
        case 2:
         var
          kl = caml_call1(f, i),
          k$1 = caml_call1(f, caml_call2(Base_Import[90], i, 1));
         return create([0, kl], k$1, 0);
        default:
         var
          kl$0 = caml_call1(f, i),
          k$2 = caml_call1(f, caml_call2(Base_Import[90], i, 1)),
          kr = caml_call1(f, caml_call2(Base_Import[90], i, 2));
         return create([0, kl$0], k$2, [0, kr]);
      }
     var
      left_length = caml_call2(Base_Import[119], n, 1),
      _bo_ = caml_call2(Base_Import[92], n, left_length),
      right_length = caml_call2(Base_Import[92], _bo_, 1),
      left = loop(left_length, f, i),
      k = caml_call1(f, caml_call2(Base_Import[90], i, left_length)),
      _bp_ = caml_call2(Base_Import[90], i, left_length),
      right = loop(right_length, f, caml_call2(Base_Import[90], _bp_, 1));
     return create(left, k, right);
    }
    return loop(len, f, 0);
   }
   function of_sorted_array_unchecked(array, compare_elt){
    var array_length = array.length - 1;
    a:
    {
     if(2 <= array_length){
      var _bl_ = caml_check_bound(array, 1)[2];
      if(0 <= caml_call2(compare_elt, caml_check_bound(array, 0)[1], _bl_)){
       var
        next =
          function(i){
           var
            _bm_ = caml_call2(Base_Import[92], array_length, 1),
            _bn_ = caml_call2(Base_Import[92], _bm_, i);
           return caml_check_bound(array, _bn_)[1 + _bn_];
          };
       break a;
      }
     }
     var next = function(i){return caml_check_bound(array, i)[1 + i];};
    }
    return of_increasing_iterator_uncheck(array_length, next);
   }
   function of_sorted_array(array, compare_elt){
    var len = array.length - 1;
    if(1 !== len && len)
     return caml_call1
             (with_return,
              function(r){
               var
                _bf_ = caml_check_bound(array, 1)[2],
                i =
                  caml_call2(compare_elt, caml_check_bound(array, 0)[1], _bf_),
                increasing =
                  0 === i
                   ? caml_call1
                     (r,
                      caml_call1
                       (Base_Or_error[36], cst_of_sorted_array_duplicated))
                   : i < 0 ? 1 : 0,
                _bh_ = caml_call2(Base_Import[92], array.length - 1, 2),
                _bg_ = 1;
               if(_bh_ >= 1){
                var i$0 = _bg_;
                for(;;){
                 var
                  _bi_ = caml_call2(Base_Import[90], i$0, 1),
                  _bj_ = caml_check_bound(array, _bi_)[1 + _bi_],
                  i$1 =
                    caml_call2
                     (compare_elt, caml_check_bound(array, i$0)[1 + i$0], _bj_);
                 if(0 === i$1)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_duplicated$0));
                 else if((i$1 < 0 ? 1 : 0) !== increasing)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_elements_a));
                 var _bk_ = i$0 + 1 | 0;
                 if(_bh_ === i$0) break;
                 i$0 = _bk_;
                }
               }
               return [0, of_sorted_array_unchecked(array, compare_elt)];
              });
    return [0, of_sorted_array_unchecked(array, compare_elt)];
   }
   function bal(l, v, r){
    if(typeof l === "number")
     var hl = 0;
    else if(0 === l[0]) var hl = 1; else var h$1 = l[4], hl = h$1;
    if(typeof r === "number")
     var hr = 0;
    else if(0 === r[0]) var hr = 1; else var h$0 = r[4], hr = h$0;
    if(caml_call2(Base_Import[90], hr, 2) < hl){
     if(typeof l === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     if(0 === l[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     var lr = l[3], lv = l[2], ll = l[1], _a__ = height(lr);
     if(_a__ <= height(ll)) return create(ll, lv, create(lr, v, r));
     if(typeof lr === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     if(0 !== lr[0]){
      var lrr = lr[3], lrv$0 = lr[2], lrl = lr[1], _ba_ = create(lrr, v, r);
      return create(create(ll, lv, lrl), lrv$0, _ba_);
     }
     var lrv = lr[1];
     if(! is_empty(ll))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     var _a$_ = create(0, v, r);
     return create(create(ll, lv, 0), lrv, _a$_);
    }
    if(caml_call2(Base_Import[90], hl, 2) < hr){
     if(typeof r === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
     if(0 === r[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     var rr = r[3], rv = r[2], rl = r[1], _bb_ = height(rl);
     if(_bb_ <= height(rr)) return create(create(l, v, rl), rv, rr);
     if(typeof rl === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     if(0 !== rl[0]){
      var rlr = rl[3], rlv$0 = rl[2], rll = rl[1], _bd_ = create(rlr, rv, rr);
      return create(create(l, v, rll), rlv$0, _bd_);
     }
     var rlv = rl[1];
     if(! is_empty(rr))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
     var _bc_ = create(0, rv, rr);
     return create(create(l, v, 0), rlv, _bc_);
    }
    var
     h =
       hr <= hl
        ? caml_call2(Base_Import[90], hl, 1)
        : caml_call2(Base_Import[90], hr, 1);
    if(typeof l === "number")
     var sl = 0;
    else if(0 === l[0]) var sl = 1; else var s$0 = l[5], sl = s$0;
    if(typeof r === "number")
     var sr = 0;
    else if(0 === r[0]) var sr = 1; else var s = r[5], sr = s;
    if(1 === h) return [0, v];
    var _be_ = caml_call2(Base_Import[90], sl, sr);
    return [1, l, v, r, h, caml_call2(Base_Import[90], _be_, 1)];
   }
   var Same = [248, "Base__Set.Tree0.Same", caml_fresh_oo_id(0)];
   function add(t, x, compare_elt){
    function aux(param){
     if(typeof param === "number") return [0, x];
     if(0 === param[0]){
      var v = param[1], c = caml_call2(compare_elt, x, v);
      if(0 === c) throw caml_maybe_attach_backtrace(Same, 1);
      return 0 <= c ? create(0, v, [0, x]) : create([0, x], v, 0);
     }
     var
      r = param[3],
      v$0 = param[2],
      l = param[1],
      c$0 = caml_call2(compare_elt, x, v$0);
     if(0 === c$0) throw caml_maybe_attach_backtrace(Same, 1);
     return 0 <= c$0 ? bal(l, v$0, aux(r)) : bal(aux(l), v$0, r);
    }
    try{var _a8_ = aux(t); return _a8_;}
    catch(_a9_){
     var _a7_ = caml_wrap_exception(_a9_);
     if(_a7_ === Same) return t;
     throw caml_maybe_attach_backtrace(_a7_, 0);
    }
   }
   function join(l, v, r, compare_elt){
    if(typeof l === "number") return add(r, v, compare_elt);
    if(1 === l[0]){
     var lh = l[4], lr = l[3], lv$0 = l[2], ll = l[1];
     if(typeof r !== "number"){
      if(0 === r[0]){
       var rv = r[1];
       return add(add(l, v, compare_elt), rv, compare_elt);
      }
      var rh = r[4], rr = r[3], rv$0 = r[2], rl = r[1];
      return caml_call2(Base_Import[90], rh, 2) < lh
              ? bal(ll, lv$0, join(lr, v, r, compare_elt))
              : caml_call2
                 (Base_Import[90], lh, 2)
                < rh
                ? bal(join(l, v, rl, compare_elt), rv$0, rr)
                : create(l, v, r);
     }
    }
    if(typeof r === "number") return add(l, v, compare_elt);
    var lv = l[1];
    return add(add(r, v, compare_elt), lv, compare_elt);
   }
   function min_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0])
      var v = param$0[1];
     else{
      var l = param$0[1];
      if(typeof l !== "number"){param$0 = l; continue;}
      var v = param$0[2];
     }
     return [0, v];
    }
   }
   var
    Set_min_elt_exn_of_empty_set =
      [248,
       "Base__Set.Tree0.Set_min_elt_exn_of_empty_set",
       caml_fresh_oo_id(0)],
    _i_ = [0, "set.ml.Tree0.Set_min_elt_exn_of_empty_set"],
    _j_ = [0, cst_src_set_ml, 296, 15];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Set_min_elt_exn_of_empty_set,
     function(param){
      if(param === Set_min_elt_exn_of_empty_set) return _i_;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
     });
   var
    Set_max_elt_exn_of_empty_set =
      [248,
       "Base__Set.Tree0.Set_max_elt_exn_of_empty_set",
       caml_fresh_oo_id(0)],
    _k_ = [0, "set.ml.Tree0.Set_max_elt_exn_of_empty_set"],
    _l_ = [0, cst_src_set_ml, 309, 15];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Set_max_elt_exn_of_empty_set,
     function(param){
      if(param === Set_max_elt_exn_of_empty_set) return _k_;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     });
   var cst_Set_remove_min_elt = "Set.remove_min_elt", _m_ = [0, 0, 0, 0];
   function min_elt_exn(t){
    var match = min_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Set_min_elt_exn_of_empty_set, 1);
    var v = match[1];
    return v;
   }
   function fold_until(t, init, f, finish){
    function fold_until_helper(f, t, acc){
     var t$0 = t, acc$0 = acc;
     for(;;){
      if(typeof t$0 === "number") return [0, acc$0];
      if(0 === t$0[0]){
       var value = t$0[1];
       return caml_call2(f, acc$0, value);
      }
      var
       right = t$0[3],
       value$0 = t$0[2],
       left = t$0[1],
       x = fold_until_helper(f, left, acc$0);
      if(0 !== x[0]) return x;
      var acc$1 = x[1], x$0 = caml_call2(f, acc$1, value$0);
      if(0 !== x$0[0]) return x$0;
      var acc$2 = x$0[1];
      t$0 = right;
      acc$0 = acc$2;
     }
    }
    var match = fold_until_helper(f, t, init);
    if(0 === match[0]){var x = match[1]; return caml_call1(finish, x);}
    var x$0 = match[1];
    return x$0;
   }
   function max_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0])
      var v = param$0[1];
     else{
      if(typeof param$0[3] !== "number"){
       var r = param$0[3];
       param$0 = r;
       continue;
      }
      var v = param$0[2];
     }
     return [0, v];
    }
   }
   function max_elt_exn(t){
    var match = max_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Set_max_elt_exn_of_empty_set, 1);
    var v = match[1];
    return v;
   }
   function remove_min_elt(param){
    if(typeof param === "number")
     return caml_call1(Base_Import[125], cst_Set_remove_min_elt);
    if(0 === param[0]) return 0;
    var l = param[1];
    if(typeof l === "number"){var r = param[3]; return r;}
    var r$0 = param[3], v = param[2];
    return bal(remove_min_elt(l), v, r$0);
   }
   function merge(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var _a6_ = remove_min_elt(t2);
    return bal(t1, min_elt_exn(t2), _a6_);
   }
   function concat(t1, t2, compare_elt){
    if(typeof t1 === "number")
     var t = t2;
    else{
     if(typeof t2 !== "number"){
      var _a5_ = remove_min_elt(t2);
      return join(t1, min_elt_exn(t2), _a5_, compare_elt);
     }
     var t = t1;
    }
    return t;
   }
   function split(t, x, compare_elt){
    function split(t){
     if(typeof t === "number") return _m_;
     if(0 === t[0]){
      var v = t[1], c = caml_call2(compare_elt, x, v);
      return 0 === c
              ? [0, 0, [0, v], 0]
              : 0 <= c ? [0, [0, v], 0, 0] : [0, 0, 0, [0, v]];
     }
     var
      r = t[3],
      v$0 = t[2],
      l = t[1],
      c$0 = caml_call2(compare_elt, x, v$0);
     if(0 === c$0) return [0, l, [0, v$0], r];
     if(0 <= c$0){
      var
       match = split(r),
       rr = match[3],
       maybe_elt = match[2],
       lr = match[1];
      return [0, join(l, v$0, lr, compare_elt), maybe_elt, rr];
     }
     var
      match$0 = split(l),
      rl = match$0[3],
      maybe_elt$0 = match$0[2],
      ll = match$0[1];
     return [0, ll, maybe_elt$0, join(rl, v$0, r, compare_elt)];
    }
    return split(t);
   }
   var empty_without_value_restrictio = 0, _n_ = [0, 0, 0];
   function mem(t, x, compare_elt){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[1], c = caml_call2(compare_elt, x, v);
      return 0 === c ? 1 : 0;
     }
     var
      r = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c$0 = caml_call2(compare_elt, x, v$0),
      _a4_ = 0 === c$0 ? 1 : 0;
     if(_a4_) return _a4_;
     var r$0 = 0 <= c$0 ? r : l;
     t$0 = r$0;
    }
   }
   function remove(t, x, compare_elt){
    function aux(t){
     if(typeof t === "number") throw caml_maybe_attach_backtrace(Same, 1);
     if(0 !== t[0]){
      var r = t[3], v$0 = t[2], l = t[1], c = caml_call2(compare_elt, x, v$0);
      return 0 === c
              ? merge(l, r)
              : 0 <= c ? bal(l, v$0, aux(r)) : bal(aux(l), v$0, r);
     }
     var v = t[1];
     if(0 === caml_call2(compare_elt, x, v)) return 0;
     throw caml_maybe_attach_backtrace(Same, 1);
    }
    try{var _a2_ = aux(t); return _a2_;}
    catch(_a3_){
     var _a1_ = caml_wrap_exception(_a3_);
     if(_a1_ === Same) return t;
     throw caml_maybe_attach_backtrace(_a1_, 0);
    }
   }
   function remove_index(t, i, param){
    function aux(t, i){
     if(typeof t === "number") throw caml_maybe_attach_backtrace(Same, 1);
     if(0 === t[0]){
      if(0 === i) return 0;
      throw caml_maybe_attach_backtrace(Same, 1);
     }
     var
      r = t[3],
      v = t[2],
      l = t[1],
      l_size = length(l),
      c = caml_int_compare(i, l_size);
     if(0 === c) return merge(l, r);
     if(0 > c) return bal(aux(l, i), v, r);
     var _a0_ = caml_call2(Base_Import[92], i, l_size);
     return bal(l, v, aux(r, caml_call2(Base_Import[92], _a0_, 1)));
    }
    try{var _aY_ = aux(t, i); return _aY_;}
    catch(_aZ_){
     var _aX_ = caml_wrap_exception(_aZ_);
     if(_aX_ === Same) return t;
     throw caml_maybe_attach_backtrace(_aX_, 0);
    }
   }
   function union(s1, s2, compare_elt){
    function union(s1, s2){
     var s1$0 = s1, s2$0 = s2;
     for(;;){
      if(caml_call2(Base_Import[127], s1$0, s2$0)) return s1$0;
      if(typeof s1$0 === "number")
       var t = s2$0;
      else{
       if(1 === s1$0[0]){
        var h1 = s1$0[4], r1 = s1$0[3], v1$0 = s1$0[2], l1 = s1$0[1];
        if(typeof s2$0 !== "number"){
         if(0 === s2$0[0]){
          var v2 = s2$0[1], s2$1 = [1, 0, v2, 0, 1, 1];
          s2$0 = s2$1;
          continue;
         }
         var h2 = s2$0[4], r2 = s2$0[3], v2$0 = s2$0[2], l2 = s2$0[1];
         if(h2 <= h1){
          if(1 === h2) return add(s1$0, v2$0, compare_elt);
          var
           match = split(s2$0, v1$0, compare_elt),
           r2$0 = match[3],
           l2$0 = match[1],
           _aV_ = union(r1, r2$0);
          return join(union(l1, l2$0), v1$0, _aV_, compare_elt);
         }
         if(1 === h1) return add(s2$0, v1$0, compare_elt);
         var
          match$0 = split(s1$0, v2$0, compare_elt),
          r1$0 = match$0[3],
          l1$0 = match$0[1],
          _aW_ = union(r1$0, r2);
         return join(union(l1$0, l2), v2$0, _aW_, compare_elt);
        }
       }
       if(typeof s2$0 !== "number"){
        var v1 = s1$0[1], s1$1 = [1, 0, v1, 0, 1, 1];
        s1$0 = s1$1;
        continue;
       }
       var t = s1$0;
      }
      return t;
     }
    }
    return union(s1, s2);
   }
   function union_list(comparator, to_tree, xs){
    var compare_elt = comparator[1];
    return caml_call3
            (Base_List[10],
             xs,
             empty_without_value_restrictio,
             function(ac, x){
              return union(ac, caml_call1(to_tree, x), compare_elt);
             });
   }
   function inter(s1, s2, compare_elt){
    function inter(s1, s2){
     if(caml_call2(Base_Import[127], s1, s2)) return s1;
     if(typeof s1 !== "number" && typeof s2 !== "number"){
      a:
      {
       if(typeof s1 !== "number" && 0 !== s1[0]){
        if(typeof s2 !== "number" && 0 !== s2[0]){
         var
          r1 = s1[3],
          v1 = s1[2],
          l1 = s1[1],
          _aS_ = split(s2, v1, compare_elt),
          match = _aS_[2],
          l2 = _aS_[1];
         if(match){
          var r2 = _aS_[3], v1$0 = match[1], _aT_ = inter(r1, r2);
          return join(inter(l1, l2), v1$0, _aT_, compare_elt);
         }
         var r2$0 = _aS_[3], _aU_ = inter(r1, r2$0);
         return concat(inter(l1, l2), _aU_, compare_elt);
        }
        var other_set = s1, singleton = s2, elt = s2[1];
        break a;
       }
       var other_set = s2, singleton = s1, elt = s1[1];
      }
      return mem(other_set, elt, compare_elt) ? singleton : 0;
     }
     return 0;
    }
    return inter(s1, s2);
   }
   function diff(s1, s2, compare_elt){
    function diff(s1, s2){
     var s1$0 = s1;
     for(;;){
      if(caml_call2(Base_Import[127], s1$0, s2)) return 0;
      if(typeof s1$0 === "number") return 0;
      if(typeof s2 === "number") return s1$0;
      if(typeof s1$0 !== "number" && 0 !== s1$0[0]){
       var
        r1 = s1$0[3],
        v1$0 = s1$0[2],
        l1 = s1$0[1],
        _aP_ = split(s2, v1$0, compare_elt),
        l2 = _aP_[1];
       if(_aP_[2]){
        var r2 = _aP_[3], _aQ_ = diff(r1, r2);
        return concat(diff(l1, l2), _aQ_, compare_elt);
       }
       var r2$0 = _aP_[3], _aR_ = diff(r1, r2$0);
       return join(diff(l1, l2), v1$0, _aR_, compare_elt);
      }
      var v1 = s1$0[1], s1$1 = [1, 0, v1, 0, 1, 1];
      s1$0 = s1$1;
     }
    }
    return diff(s1, s2);
   }
   function cons(s, e){
    var s$0 = s, e$0 = e;
    for(;;){
     if(typeof s$0 === "number") return e$0;
     if(0 === s$0[0]){var v = s$0[1]; return [0, v, 0, e$0];}
     var r = s$0[3], v$0 = s$0[2], l = s$0[1], e$1 = [0, v$0, r, e$0];
     s$0 = l;
     e$0 = e$1;
    }
   }
   function cons_right(s, e){
    var s$0 = s, e$0 = e;
    for(;;){
     if(typeof s$0 === "number") return e$0;
     if(0 === s$0[0]){var v = s$0[1]; return [0, v, 0, e$0];}
     var r = s$0[3], v$0 = s$0[2], l = s$0[1], e$1 = [0, v$0, l, e$0];
     s$0 = r;
     e$0 = e$1;
    }
   }
   function of_set(s){return cons(s, 0);}
   function iter(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var enum$0 = param$0[3], tree = param$0[2], a = param$0[1];
     caml_call1(f, a);
     param$0 = cons(tree, enum$0);
    }
   }
   function symmetric_diff(t1, t2, compare_elt){
    function step(state){
     var left = state[1];
     if(! left){
      var match = state[2];
      if(! match) return 0;
      var enum$0 = match[3], tree = match[2], elt$0 = match[1];
      return [1, [1, elt$0], [0, 0, cons(tree, enum$0)]];
     }
     var right = state[2], enum1 = left[3], tree1 = left[2], elt = left[1];
     if(! right) return [1, [0, elt], [0, cons(tree1, enum1), 0]];
     var
      enum2 = right[3],
      tree2 = right[2],
      a2 = right[1],
      compare_result = caml_call2(compare_elt, elt, a2);
     if(0 !== compare_result)
      return 0 <= compare_result
              ? [1, [1, a2], [0, left, cons(tree2, enum2)]]
              : [1, [0, elt], [0, cons(tree1, enum1), right]];
     if(caml_call2(Base_Import[127], tree1, tree2))
      var next_state = [0, enum1, enum2];
     else
      var
       _aO_ = cons(tree2, enum2),
       next_state = [0, cons(tree1, enum1), _aO_];
     return [0, next_state];
    }
    var _aM_ = of_set(t2), _aN_ = [0, of_set(t1), _aM_];
    return caml_call2(Base_Sequence[41], _aN_, step);
   }
   function to_sequence
   (comparator, opt, greater_or_equal_to, less_or_equal_to, t$3){
    if(opt) var sth = opt[1], order = sth; else var order = 608542111;
    function inclusive_bound(side, t, bound){
     var
      compare_elt = comparator[1],
      match = split(t, bound, compare_elt),
      r = match[3],
      maybe = match[2],
      l = match[1],
      t$0 = caml_call1(side, [0, l, r]);
     if(! maybe) return t$0;
     var elt = maybe[1];
     return add(t$0, elt, compare_elt);
    }
    if(608542111 <= order){
     var
      _aG_ = Base_Import[124],
      t$4 =
        caml_call3
         (Base_Option[31],
          less_or_equal_to,
          t$3,
          function(_aK_, _aL_){return inclusive_bound(_aG_, _aK_, _aL_);}),
      next =
        function(enum$0){
         if(! enum$0) return 0;
         var e = enum$0[3], t = enum$0[2], k = enum$0[1];
         return [1, k, cons(t, e)];
        };
     if(greater_or_equal_to){
      var
       key = greater_or_equal_to[1],
       compare = comparator[1],
       t = t$4,
       e = 0;
      for(;;){
       if(typeof t === "number"){var init = e; break;}
       if(0 === t[0]){
        var v = t[1], t$0 = [1, 0, v, 0, 1, 1];
        t = t$0;
       }
       else{
        var l = t[1], r = t[3], v$0 = t[2];
        if(0 <= caml_call2(compare, v$0, key)){
         var r$0 = t[3], v$1 = t[2], e$0 = [0, v$1, r$0, e];
         t = l;
         e = e$0;
        }
        else
         t = r;
       }
      }
     }
     else
      var init = of_set(t$4);
     return caml_call2(Base_Sequence[41], init, next);
    }
    var
     _aH_ = Base_Import[126],
     t$5 =
       caml_call3
        (Base_Option[31],
         greater_or_equal_to,
         t$3,
         function(_aI_, _aJ_){return inclusive_bound(_aH_, _aI_, _aJ_);});
    function next$0(enum$0){
     if(! enum$0) return 0;
     var e = enum$0[3], t = enum$0[2], k = enum$0[1];
     return [1, k, cons_right(t, e)];
    }
    if(less_or_equal_to){
     var
      key$0 = less_or_equal_to[1],
      compare$0 = comparator[1],
      t$1 = t$5,
      e$1 = 0;
     for(;;){
      if(typeof t$1 === "number"){var init$0 = e$1; break;}
      if(0 === t$1[0]){
       var v$2 = t$1[1], t$2 = [1, 0, v$2, 0, 1, 1];
       t$1 = t$2;
      }
      else{
       var l$0 = t$1[1], v$3 = t$1[2];
       if(0 < caml_call2(compare$0, v$3, key$0))
        t$1 = l$0;
       else{
        var r$1 = t$1[3], v$4 = t$1[2], e$2 = [0, v$4, l$0, e$1];
        t$1 = r$1;
        e$1 = e$2;
       }
      }
     }
    }
    else
     var init$0 = cons_right(t$5, 0);
    return caml_call2(Base_Sequence[41], init$0, next$0);
   }
   function find_first_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)){
      var x = find_first_satisfying(l, f);
      return x ? x : [0, v$0];
     }
     t$0 = r;
    }
   }
   function find_last_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)){
      var x = find_last_satisfying(r, f);
      return x ? x : [0, v$0];
     }
     t$0 = l;
    }
   }
   function binary_search(t, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (t,
                  function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;})
               : find_last_satisfying
                 (t,
                  function(x){return caml_call2(compare, x, v) < 0 ? 1 : 0;})
             : -253007807
               <= how
               ? find_last_satisfying
                 (t,
                  function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;})
               : find_first_satisfying
                 (t,
                  function(x){return 0 < caml_call2(compare, x, v) ? 1 : 0;});
    if(-1055410545 <= how){
     var
      elt =
        find_last_satisfying
         (t, function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;});
     if(elt){var x = elt[1]; if(0 === caml_call2(compare, x, v)) return elt;}
     return 0;
    }
    var
     elt$0 =
       find_first_satisfying
        (t, function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;});
    if(elt$0){
     var x$0 = elt$0[1];
     if(0 === caml_call2(compare, x$0, v)) return elt$0;
    }
    return 0;
   }
   function binary_search_segmented(t, segment_of, how){
    function is_left(x){
     return 847852583 <= caml_call1(segment_of, x) ? 1 : 0;
    }
    function is_right(x){return 1 - is_left(x);}
    return 125585502 <= how
            ? find_last_satisfying(t, is_left)
            : find_first_satisfying(t, is_right);
   }
   function merge_to_sequence
   (comparator, opt, greater_or_equal_to, less_or_equal_to, t$0, t){
    if(opt) var sth = opt[1], order = sth; else var order = 608542111;
    var
     _aD_ =
       608542111 <= order
        ? comparator[1]
        : caml_call1(Base_Fn[6], comparator[1]),
     _aE_ =
       to_sequence
        (comparator, [0, order], greater_or_equal_to, less_or_equal_to, t),
     _aF_ =
       to_sequence
        (comparator, [0, order], greater_or_equal_to, less_or_equal_to, t$0);
    return caml_call3(Base_Sequence[56], _aF_, _aE_, _aD_);
   }
   function compare(compare_elt, s1, s2){
    var e2$2 = of_set(s2), e1$2 = of_set(s1), e1 = e1$2, e2 = e2$2;
    for(;;){
     if(! e1) return e2 ? -1 : 0;
     if(! e2) return 1;
     var
      e2$0 = e2[3],
      r2 = e2[2],
      v2 = e2[1],
      e1$0 = e1[3],
      r1 = e1[2],
      v1 = e1[1],
      c = caml_call2(compare_elt, v1, v2);
     if(0 !== c) return c;
     if(caml_call2(Base_Import[127], r1, r2)){e1 = e1$0; e2 = e2$0;}
     else{
      var e2$1 = cons(r2, e2$0), e1$1 = cons(r1, e1$0);
      e1 = e1$1;
      e2 = e2$1;
     }
    }
   }
   function iter2(s1, s2, compare_elt){
    var t2 = of_set(s2), t1 = of_set(s1);
    return function(f){
     a:
     {
      var t1$0 = t1, t2$0 = t2;
      for(;;){
       if(! t1$0) break;
       if(! t2$0) break a;
       var
        enum2 = t2$0[3],
        tree2 = t2$0[2],
        a2 = t2$0[1],
        enum1 = t1$0[3],
        tree1 = t1$0[2],
        a1 = t1$0[1],
        compare_result = caml_call2(compare_elt, a1, a2);
       if(0 === compare_result){
        caml_call1(f, [0, 737457313, [0, a1, a2]]);
        var t2$1 = cons(tree2, enum2), t1$1 = cons(tree1, enum1);
        t1$0 = t1$1;
        t2$0 = t2$1;
       }
       else if(0 <= compare_result){
        caml_call1(f, [0, -57574468, a2]);
        var t2$2 = cons(tree2, enum2);
        t2$0 = t2$2;
       }
       else{
        caml_call1(f, [0, 847852583, a1]);
        var t1$2 = cons(tree1, enum1);
        t1$0 = t1$2;
       }
      }
      return t2$0
              ? iter
                (function(a){return caml_call1(f, [0, -57574468, a]);}, t2$0)
              : 0;
     }
     return iter(function(a){return caml_call1(f, [0, 847852583, a]);}, t1$0);};
   }
   function equal(s1, s2, compare_elt){
    return 0 === compare(compare_elt, s1, s2) ? 1 : 0;
   }
   function is_subset(s1, s2, compare_elt){
    function is_subset(s1, s2){
     var s1$0 = s1, s2$0 = s2;
     for(;;){
      if(typeof s1$0 === "number") return 1;
      if(1 === s1$0[0]){
       var r1 = s1$0[3], v1$0 = s1$0[2], l1 = s1$0[1];
       if(typeof s2$0 !== "number"){
        if(0 === s2$0[0]){
         var v2 = s2$0[1];
         if(typeof l1 === "number" && typeof r1 === "number")
          return 0 === caml_call2(compare_elt, v1$0, v2) ? 1 : 0;
         return 0;
        }
        var
         r2 = s2$0[3],
         v2$0 = s2$0[2],
         l2 = s2$0[1],
         c = caml_call2(compare_elt, v1$0, v2$0);
        if(0 !== c){
         if(0 <= c){
          var _aB_ = is_subset([1, 0, v1$0, r1, 0, 0], r2);
          if(! _aB_) return _aB_;
          s1$0 = l1;
          continue;
         }
         var _aC_ = is_subset([1, l1, v1$0, 0, 0, 0], l2);
         if(! _aC_) return _aC_;
         s1$0 = r1;
         continue;
        }
        var _ay_ = caml_call2(Base_Import[127], s1$0, s2$0);
        if(_ay_)
         var _az_ = _ay_;
        else{
         var _aA_ = is_subset(l1, l2);
         if(_aA_){s1$0 = r1; s2$0 = r2; continue;}
         var _az_ = _aA_;
        }
        return _az_;
       }
      }
      if(typeof s2$0 === "number") return 0;
      var v1 = s1$0[1];
      return mem(s2$0, v1, compare_elt);
     }
    }
    return is_subset(s1, s2);
   }
   function are_disjoint(s1, s2, compare_elt){
    var s1$0 = s1, s2$0 = s2;
    for(;;){
     if(typeof s1$0 !== "number" && typeof s2$0 !== "number"){
      a:
      {
       if(typeof s1$0 !== "number" && 0 !== s1$0[0]){
        if(typeof s2$0 !== "number" && 0 !== s2$0[0]){
         var r1 = s1$0[3], v1 = s1$0[2], l1 = s1$0[1];
         if(caml_call2(Base_Import[127], s1$0, s2$0)) return 0;
         var _aw_ = split(s2$0, v1, compare_elt), l2 = _aw_[1];
         if(_aw_[2]) return 0;
         var r2 = _aw_[3], _ax_ = are_disjoint(l1, l2, compare_elt);
         if(! _ax_) return _ax_;
         s1$0 = r1;
         s2$0 = r2;
         continue;
        }
        var other_set = s1$0, elt = s2$0[1];
        break a;
       }
       var other_set = s2$0, elt = s1$0[1];
      }
      return 1 - mem(other_set, elt, compare_elt);
     }
     return 1;
    }
   }
   function iter$0(t, f){
    function iter(param){
     var param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return 0;
      if(0 === param$0[0]){var v = param$0[1]; return caml_call1(f, v);}
      var r = param$0[3], v$0 = param$0[2], l = param$0[1];
      iter(l);
      caml_call1(f, v$0);
      param$0 = r;
     }
    }
    return iter(t);
   }
   function fold(s, accu, f){
    var s$0 = s, accu$0 = accu;
    for(;;){
     if(typeof s$0 === "number") return accu$0;
     if(0 === s$0[0]){var v = s$0[1]; return caml_call2(f, accu$0, v);}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      accu$1 = caml_call2(f, fold(l, accu$0, f), v$0);
     s$0 = r;
     accu$0 = accu$1;
    }
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function fold_right(s, accu, f){
    var s$0 = s, accu$0 = accu;
    for(;;){
     if(typeof s$0 === "number") return accu$0;
     if(0 === s$0[0]){var v = s$0[1]; return caml_call2(f, v, accu$0);}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      accu$1 = caml_call2(f, v$0, fold_right(r, accu$0, f));
     s$0 = l;
     accu$0 = accu$1;
    }
   }
   function for_all(t, p){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(p, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], _at_ = caml_call1(p, v$0);
     if(_at_){
      var _au_ = for_all(l, p);
      if(_au_){t$0 = r; continue;}
      var _av_ = _au_;
     }
     else
      var _av_ = _at_;
     return _av_;
    }
   }
   function exists(t, p){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(p, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], _aq_ = caml_call1(p, v$0);
     if(_aq_)
      var _ar_ = _aq_;
     else{
      var _as_ = exists(l, p);
      if(! _as_){t$0 = r; continue;}
      var _ar_ = _as_;
     }
     return _ar_;
    }
   }
   function filter(s, p, compare_elt){
    function filt(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return accu$0;
      if(0 === param$0[0]){
       var v = param$0[1];
       return caml_call1(p, v) ? add(accu$0, v, compare_elt) : accu$0;
      }
      var
       r = param$0[3],
       v$0 = param$0[2],
       l = param$0[1],
       _ap_ = caml_call1(p, v$0) ? add(accu$0, v$0, compare_elt) : accu$0,
       accu$1 = filt(_ap_, l);
      accu$0 = accu$1;
      param$0 = r;
     }
    }
    return filt(0, s);
   }
   function filter_map(s, p, compare_elt){
    function filt(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return accu$0;
      if(0 === param$0[0]){
       var v = param$0[1], match = caml_call1(p, v);
       if(! match) return accu$0;
       var v$0 = match[1];
       return add(accu$0, v$0, compare_elt);
      }
      var
       r = param$0[3],
       v$1 = param$0[2],
       l = param$0[1],
       match$0 = caml_call1(p, v$1);
      if(match$0)
       var v$2 = match$0[1], _ao_ = add(accu$0, v$2, compare_elt);
      else
       var _ao_ = accu$0;
      var accu$1 = filt(_ao_, l);
      accu$0 = accu$1;
      param$0 = r;
     }
    }
    return filt(0, s);
   }
   function partition_tf(s, p, compare_elt){
    function part(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      var f = accu$0[2], t = accu$0[1];
      if(typeof param$0 === "number") return accu$0;
      if(0 === param$0[0]){
       var v = param$0[1];
       return caml_call1(p, v)
               ? [0, add(t, v, compare_elt), f]
               : [0, t, add(f, v, compare_elt)];
      }
      var
       r = param$0[3],
       v$0 = param$0[2],
       l = param$0[1],
       _an_ =
         caml_call1(p, v$0)
          ? [0, add(t, v$0, compare_elt), f]
          : [0, t, add(f, v$0, compare_elt)],
       accu$1 = part(_an_, l);
      accu$0 = accu$1;
      param$0 = r;
     }
    }
    return part(_n_, s);
   }
   function elements_aux(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return accu$0;
     if(0 === param$0[0]){var v = param$0[1]; return [0, v, accu$0];}
     var
      r = param$0[3],
      v$0 = param$0[2],
      l = param$0[1],
      accu$1 = [0, v$0, elements_aux(accu$0, r)];
     accu$0 = accu$1;
     param$0 = l;
    }
   }
   function elements(s){return elements_aux(0, s);}
   function choose(t){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var v = t[1]; return [0, v];}
    var v$0 = t[2];
    return [0, v$0];
   }
   var
    not_found = [0, Base_Import[251], [0, "Set.choose_exn: empty set"]],
    cst_Set_find_exn_failed_to_fin =
      "Set.find_exn failed to find a matching element",
    cst_Set_t_of_sexp_list_needed = "Set.t_of_sexp: list needed",
    cst_Set_t_of_sexp_duplicate_el = "Set.t_of_sexp: duplicate element in set",
    _o_ = [0, cst_src_set_ml, 1047, 8],
    _p_ = [0, 0],
    cst_invalid_elements = "invalid_elements",
    cst_is_not_a_subset_of = " is not a subset of ";
   function choose_exn(t){
    var match = choose(t);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var v = match[1];
    return v;
   }
   function of_list(lst, compare_elt){
    return caml_call3
            (Base_List[10],
             lst,
             empty_without_value_restrictio,
             function(t, x){return add(t, x, compare_elt);});
   }
   function of_sequence(sequence, compare_elt){
    return caml_call3
            (Base_Sequence[8],
             sequence,
             empty_without_value_restrictio,
             function(t, x){return add(t, x, compare_elt);});
   }
   function of_array(a, compare_elt){
    return caml_call3
            (Base_Array[10],
             a,
             empty_without_value_restrictio,
             function(t, x){return add(t, x, compare_elt);});
   }
   function to_array(param){
    if(typeof param === "number") return [0];
    if(0 === param[0]){var v = param[1]; return [0, v];}
    var
     s = param[5],
     r = param[3],
     v$0 = param[2],
     l = param[1],
     res = caml_call2(Base_Array[25], s, v$0),
     pos_ref = [0, 0];
    function loop(param){
     var param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return;
      if(0 === param$0[0]){
       var v = param$0[1], _al_ = pos_ref[1];
       caml_check_bound(res, _al_)[1 + _al_] = v;
       return caml_call1(Base_Import[129], pos_ref);
      }
      var r = param$0[3], v$0 = param$0[2], l = param$0[1];
      loop(l);
      var _am_ = pos_ref[1];
      caml_check_bound(res, _am_)[1 + _am_] = v$0;
      caml_call1(Base_Import[129], pos_ref);
      param$0 = r;
     }
    }
    loop(l);
    caml_call1(Base_Import[129], pos_ref);
    loop(r);
    return res;
   }
   function map(t, f, compare_elt){
    return fold
            (t,
             empty_without_value_restrictio,
             function(t, x){return add(t, caml_call1(f, x), compare_elt);});
   }
   function group_by(set, equiv, compare_elt){
    var set$0 = set, equiv_classes = 0;
    for(;;){
     if(is_empty(set$0)) return equiv_classes;
     var x = choose_exn(set$0);
     let x$0 = x;
     var
      match =
        partition_tf
         (set$0,
          function(elt){
           var _ak_ = caml_call2(Base_Import[127], x$0, elt);
           return _ak_ ? _ak_ : caml_call2(equiv, x$0, elt);
          },
          compare_elt),
      not_equiv_x = match[2],
      equiv_x = match[1],
      equiv_classes$0 = [0, equiv_x, equiv_classes];
     set$0 = not_equiv_x;
     equiv_classes = equiv_classes$0;
    }
   }
   function find(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)) return [0, v$0];
     var r$0 = find(l, f);
     if(r$0) return r$0;
     t$0 = r;
    }
   }
   function find_map(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], r$0 = caml_call1(f, v$0);
     if(r$0) return r$0;
     var r$1 = find_map(l, f);
     if(r$1) return r$1;
     t$0 = r;
    }
   }
   function find_exn(t, f){
    var match = find(t, f);
    if(! match)
     return caml_call1(Base_Import[123], cst_Set_find_exn_failed_to_fin);
    var e = match[1];
    return e;
   }
   function nth(t, i){
    var t$0 = t, i$0 = i;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return 0 === i$0 ? [0, v] : 0;}
     var s = t$0[5], r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(s <= i$0) return 0;
     var l_size = length(l), c = caml_int_compare(i$0, l_size);
     if(0 <= c){
      if(0 === c) return [0, v$0];
      var
       _aj_ = caml_call2(Base_Import[92], i$0, l_size),
       i$1 = caml_call2(Base_Import[92], _aj_, 1);
      t$0 = r;
      i$0 = i$1;
     }
     else
      t$0 = l;
    }
   }
   function stable_dedup_list(xs, compare_elt){
    var
     xs$0 = xs,
     leftovers = 0,
     already_seen = empty_without_value_restrictio;
    for(;;){
     if(! xs$0) return caml_call1(Base_List[38], leftovers);
     var tl = xs$0[2], hd = xs$0[1];
     if(mem(already_seen, hd, compare_elt))
      xs$0 = tl;
     else{
      var
       already_seen$0 = add(already_seen, hd, compare_elt),
       leftovers$0 = [0, hd, leftovers];
      xs$0 = tl;
      leftovers = leftovers$0;
      already_seen = already_seen$0;
     }
    }
   }
   function t_of_sexp_direct(a_of_sexp, sexp, compare_elt){
    if(0 === sexp[0])
     return caml_call2(Base_Import[158], cst_Set_t_of_sexp_list_needed, sexp);
    var
     lst = sexp[1],
     elt_lst = caml_call2(Base_List[76], lst, a_of_sexp),
     set = of_list(elt_lst, compare_elt),
     _ai_ = caml_call1(Base_List[7], lst);
    if(length(set) === _ai_) return set;
    var set$0 = [0, empty_without_value_restrictio];
    caml_call3
     (Base_List[42],
      lst,
      elt_lst,
      function(el_sexp, el){
       return mem(set$0[1], el, compare_elt)
               ? caml_call2
                 (Base_Import[158], cst_Set_t_of_sexp_duplicate_el, el_sexp)
               : (set$0[1] = add(set$0[1], el, compare_elt), 0);
      });
    throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
   }
   function sexp_of_t(sexp_of_a, t){
    return [1,
            fold_right
             (t,
              0,
              function(el, acc){return [0, caml_call1(sexp_of_a, el), acc];})];
   }
   function is_subset$0(subset, superset, sexp_of_elt, compare_elt){
    var invalid_elements = diff(subset[1], superset[1], compare_elt);
    if(is_empty(invalid_elements)) return _p_;
    var
     invalid_elements_sexp = sexp_of_t(sexp_of_elt, invalid_elements),
     _af_ = caml_call2(Base_Import[111], cst_is_not_a_subset_of, superset[2]),
     _ag_ = caml_call2(Base_Import[111], subset[2], _af_),
     _ah_ =
       caml_call2
        (Base_Sexp[9],
         _ag_,
         [0, [0, cst_invalid_elements, invalid_elements_sexp], 0]);
    return caml_call1(Base_Or_error[35], _ah_);
   }
   function like(param, tree){
    var comparator = param[1];
    return [0, comparator, tree];
   }
   function compare_elt(t){return t[1][1];}
   function comparator(t){return t[1];}
   function invariants$0(t){
    var _ae_ = compare_elt(t);
    return invariants(t[2], _ae_);
   }
   function length$0(t){return length(t[2]);}
   function is_empty$0(t){return is_empty(t[2]);}
   function elements$0(t){return elements(t[2]);}
   function min_elt$0(t){return min_elt(t[2]);}
   function min_elt_exn$0(t){return min_elt_exn(t[2]);}
   function max_elt$0(t){return max_elt(t[2]);}
   function max_elt_exn$0(t){return max_elt_exn(t[2]);}
   function choose$0(t){return choose(t[2]);}
   function choose_exn$0(t){return choose_exn(t[2]);}
   function to_list(t){var s = t[2]; return elements(s);}
   function to_array$0(t){return to_array(t[2]);}
   function fold$0(t, init, f){return fold(t[2], init, f);}
   function fold_until$0(t, init, f){
    var _ac_ = t[2];
    return function(_ad_){return fold_until(_ac_, init, f, _ad_);};
   }
   function fold_right$0(t, init, f){return fold_right(t[2], init, f);}
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold$0, init, f, t);
   }
   function iter$1(t, f){return iter$0(t[2], f);}
   function iter2$0(a, b, f){
    var _ab_ = compare_elt(a);
    return iter2(a[2], b[2], _ab_)(f);
   }
   function exists$0(t, f){return exists(t[2], f);}
   function for_all$0(t, f){return for_all(t[2], f);}
   function count$0(t, f){return count(t[2], f);}
   function sum$0(m, t, f){return sum(m, t[2], f);}
   function find$0(t, f){return find(t[2], f);}
   function find_exn$0(t, f){return find_exn(t[2], f);}
   function find_map$0(t, f){return find_map(t[2], f);}
   function mem$0(t, a){var _aa_ = compare_elt(t); return mem(t[2], a, _aa_);}
   function filter$0(t, f){
    var _$_ = compare_elt(t);
    return like(t, filter(t[2], f, _$_));
   }
   function add$0(t, a){
    var ___ = compare_elt(t);
    return like(t, add(t[2], a, ___));
   }
   function remove$0(t, a){
    var _Z_ = compare_elt(t);
    return like(t, remove(t[2], a, _Z_));
   }
   function union$0(t1, t2){
    var _Y_ = compare_elt(t1);
    return like(t1, union(t1[2], t2[2], _Y_));
   }
   function inter$0(t1, t2){
    var _X_ = compare_elt(t1);
    return like(t1, inter(t1[2], t2[2], _X_));
   }
   function diff$0(t1, t2){
    var _W_ = compare_elt(t1);
    return like(t1, diff(t1[2], t2[2], _W_));
   }
   function symmetric_diff$0(t1, t2){
    var _V_ = compare_elt(t1);
    return symmetric_diff(t1[2], t2[2], _V_);
   }
   function compare_direct(t1, t2){
    var _T_ = t2[2], _U_ = t1[2];
    return compare(compare_elt(t1), _U_, _T_);
   }
   function equal$0(t1, t2){
    var _S_ = compare_elt(t1);
    return equal(t1[2], t2[2], _S_);
   }
   function is_subset$1(t, of){
    var _R_ = compare_elt(t);
    return is_subset(t[2], of[2], _R_);
   }
   function are_disjoint$0(t1, t2){
    var _Q_ = compare_elt(t1);
    return are_disjoint(t1[2], t2[2], _Q_);
   }
   function to_named_tree(param){
    var name = param[2], set = param[1];
    return [0, set[2], name];
   }
   function is_subset$2(subset, superset){
    var
     _N_ = compare_elt(subset[1]),
     _O_ = subset[1][1][2],
     _P_ = to_named_tree(superset);
    return is_subset$0(to_named_tree(subset), _P_, _O_, _N_);
   }
   function equal$1(t1, t2){
    var
     _L_ = [0, is_subset$2(t2, t1), 0],
     _M_ = [0, is_subset$2(t1, t2), _L_];
    return caml_call1(Base_Or_error[47], _M_);
   }
   function partition_tf$0(t, f){
    var
     _J_ = compare_elt(t),
     match = partition_tf(t[2], f, _J_),
     tree_f = match[2],
     tree_t = match[1],
     _K_ = like(t, tree_f);
    return [0, like(t, tree_t), _K_];
   }
   function split$0(t, a){
    var
     _H_ = compare_elt(t),
     match = split(t[2], a, _H_),
     tree2 = match[3],
     b = match[2],
     tree1 = match[1],
     _I_ = like(t, tree2);
    return [0, like(t, tree1), b, _I_];
   }
   function group_by$0(t, equiv){
    var _E_ = compare_elt(t), _F_ = group_by(t[2], equiv, _E_);
    return caml_call2(Base_List[76], _F_, function(_G_){return like(t, _G_);});
   }
   function nth$0(t, i){return nth(t[2], i);}
   function remove_index$0(t, i){
    var _D_ = compare_elt(t);
    return like(t, remove_index(t[2], i, _D_));
   }
   function sexp_of_t$0(sexp_of_a, param, t){return sexp_of_t(sexp_of_a, t[2]);
   }
   function to_sequence$0(order, greater_or_equal_to, less_or_equal_to, t){
    return to_sequence
            (t[1], order, greater_or_equal_to, less_or_equal_to, t[2]);
   }
   function binary_search$0(t, compare, how, v){
    return binary_search(t[2], compare, how, v);
   }
   function binary_search_segmented$0(t, segment_of, how){
    return binary_search_segmented(t[2], segment_of, how);
   }
   function merge_to_sequence$0
   (order, greater_or_equal_to, less_or_equal_to, t$0, t){
    return merge_to_sequence
            (t$0[1],
             order,
             greater_or_equal_to,
             less_or_equal_to,
             t$0[2],
             t[2]);
   }
   function hash_fold_direct(hash_fold_elem, state, t){
    var t$0 = t[2], _C_ = length(t$0);
    return fold(t$0, caml_call2(Base_Import[206], state, _C_), hash_fold_elem);
   }
   function compare$0(param, _B_, t1, t2){return compare_direct(t1, t2);}
   function t_of_sexp_direct$0(comparator, a_of_sexp, sexp){
    return t_of_sexp_direct(a_of_sexp, sexp, comparator[1]);
   }
   function empty(param){return empty_without_value_restrictio;}
   function singleton(param, e){return [0, e];}
   function length$1(t){return length(t);}
   function invariants$1(comparator, t){return invariants(t, comparator[1]);}
   function is_empty$1(t){return is_empty(t);}
   function elements$1(t){return elements(t);}
   function min_elt$1(t){return min_elt(t);}
   function min_elt_exn$1(t){return min_elt_exn(t);}
   function max_elt$1(t){return max_elt(t);}
   function max_elt_exn$1(t){return max_elt_exn(t);}
   function choose$1(t){return choose(t);}
   function choose_exn$1(t){return choose_exn(t);}
   function to_list$0(t){return elements(t);}
   function to_array$1(t){return to_array(t);}
   function iter$2(t, f){return iter$0(t, f);}
   function exists$1(t, f){return exists(t, f);}
   function for_all$1(t, f){return for_all(t, f);}
   function count$1(t, f){return count(t, f);}
   function sum$1(m, t, f){return sum(m, t, f);}
   function find$1(t, f){return find(t, f);}
   function find_exn$1(t, f){return find_exn(t, f);}
   function find_map$1(t, f){return find_map(t, f);}
   function fold$1(t, init, f){return fold(t, init, f);}
   function fold_until$1(t, init, f){
    return function(_A_){return fold_until(t, init, f, _A_);};
   }
   function fold_right$1(t, init, f){return fold_right(t, init, f);}
   function map$0(comparator, t, f){return map(t, f, comparator[1]);}
   function filter$1(comparator, t, f){return filter(t, f, comparator[1]);}
   function filter_map$0(comparator, t, f){
    return filter_map(t, f, comparator[1]);
   }
   function partition_tf$1(comparator, t, f){
    return partition_tf(t, f, comparator[1]);
   }
   function iter2$1(comparator, a, b, f){
    return iter2(a, b, comparator[1])(f);
   }
   function mem$1(comparator, t, a){return mem(t, a, comparator[1]);}
   function add$1(comparator, t, a){return add(t, a, comparator[1]);}
   function remove$1(comparator, t, a){return remove(t, a, comparator[1]);}
   function union$1(comparator, t1, t2){return union(t1, t2, comparator[1]);}
   function inter$1(comparator, t1, t2){return inter(t1, t2, comparator[1]);}
   function diff$1(comparator, t1, t2){return diff(t1, t2, comparator[1]);}
   function symmetric_diff$1(comparator, t1, t2){
    return symmetric_diff(t1, t2, comparator[1]);
   }
   function compare_direct$0(comparator, t1, t2){return compare(comparator[1], t1, t2);
   }
   function equal$2(comparator, t1, t2){return equal(t1, t2, comparator[1]);}
   function is_subset$3(comparator, t, of){
    return is_subset(t, of, comparator[1]);
   }
   function are_disjoint$1(comparator, t1, t2){
    return are_disjoint(t1, t2, comparator[1]);
   }
   function of_list$0(comparator, l){return of_list(l, comparator[1]);}
   function of_sequence$0(comparator, s){
    return of_sequence(s, comparator[1]);
   }
   function of_array$0(comparator, a){return of_array(a, comparator[1]);}
   function of_sorted_array_unchecked$0(comparator, a){
    return of_sorted_array_unchecked(a, comparator[1]);
   }
   function of_increasing_iterator_uncheck$0(param, len, f){return of_increasing_iterator_uncheck(len, f);
   }
   function of_sorted_array$0(comparator, a){
    return of_sorted_array(a, comparator[1]);
   }
   function union_list$0(comparator, l){
    return union_list(comparator, function(_z_){return _z_;}, l);
   }
   function stable_dedup_list$0(comparator, xs){
    return stable_dedup_list(xs, comparator[1]);
   }
   function group_by$1(comparator, t, equiv){
    return group_by(t, equiv, comparator[1]);
   }
   function split$1(comparator, t, a){return split(t, a, comparator[1]);}
   function nth$1(t, i){return nth(t, i);}
   function remove_index$1(comparator, t, i){
    return remove_index(t, i, comparator[1]);
   }
   function sexp_of_t$1(sexp_of_a, param, t){return sexp_of_t(sexp_of_a, t);}
   function to_tree(t){return t;}
   function of_tree(param, t){return t;}
   function to_sequence$1
   (comparator, order, greater_or_equal_to, less_or_equal_to, t){
    return to_sequence
            (comparator, order, greater_or_equal_to, less_or_equal_to, t);
   }
   function binary_search$1(param, t, compare, how, v){return binary_search(t, compare, how, v);
   }
   function binary_search_segmented$1(param, t, segment_of, how){return binary_search_segmented(t, segment_of, how);
   }
   function merge_to_sequence$1
   (comparator, order, greater_or_equal_to, less_or_equal_to, t$0, t){
    return merge_to_sequence
            (comparator, order, greater_or_equal_to, less_or_equal_to, t$0, t);
   }
   function fold_result$0(t, init, f){
    return caml_call4(Base_Container[8], fold$1, init, f, t);
   }
   function is_subset$4(comparator, t1, t2){
    return is_subset$0(t1, t2, comparator[2], comparator[1]);
   }
   function equal$3(comparator, t1, t2){
    var
     compare_elt = comparator[1],
     sexp_of_elt = comparator[2],
     _x_ = [0, is_subset$0(t2, t1, sexp_of_elt, compare_elt), 0],
     _y_ = [0, is_subset$0(t1, t2, sexp_of_elt, compare_elt), _x_];
    return caml_call1(Base_Or_error[47], _y_);
   }
   var Named = [0, is_subset$4, equal$3], _q_ = [0, "_"];
   function to_tree$0(t){return t[2];}
   function of_tree$0(comparator, tree){return [0, comparator, tree];}
   function t_of_sexp_direct$1(comparator, a_of_sexp, sexp){
    var tree = t_of_sexp_direct(a_of_sexp, sexp, comparator[1]);
    return [0, comparator, tree];
   }
   function empty$0(comparator){
    return [0, comparator, empty_without_value_restrictio];
   }
   function Empty_without_value_restrictio(Elt){
    var empty = [0, Elt[1], empty_without_value_restrictio];
    return [0, empty];
   }
   function singleton$0(comparator, e){return [0, comparator, [0, e]];}
   function union_list$1(comparator, l){
    var tree = union_list(comparator, to_tree$0, l);
    return [0, comparator, tree];
   }
   function of_sorted_array_unchecked$1(comparator, array){
    var tree = of_sorted_array_unchecked(array, comparator[1]);
    return [0, comparator, tree];
   }
   function of_increasing_iterator_uncheck$1(comparator, len, f){
    var tree = of_increasing_iterator_uncheck(len, f);
    return [0, comparator, tree];
   }
   function of_sorted_array$1(comparator, array){
    var _w_ = of_sorted_array(array, comparator[1]);
    return caml_call2
            (Base_Or_error[18][2],
             _w_,
             function(tree){return [0, comparator, tree];});
   }
   function of_list$1(comparator, l){
    return [0, comparator, of_list(l, comparator[1])];
   }
   function of_sequence$1(comparator, s){
    return [0, comparator, of_sequence(s, comparator[1])];
   }
   function of_array$1(comparator, a){
    return [0, comparator, of_array(a, comparator[1])];
   }
   function stable_dedup_list$1(comparator, xs){
    return stable_dedup_list(xs, comparator[1]);
   }
   function map$1(comparator, t, f){
    return [0, comparator, map(t[2], f, comparator[1])];
   }
   function filter_map$1(comparator, t, f){
    return [0, comparator, filter_map(t[2], f, comparator[1])];
   }
   function comparator_s(t){var comparator = t[1]; return [0, comparator];}
   function empty$1(m){
    var comparator = m[1];
    return [0, comparator, empty_without_value_restrictio];
   }
   function singleton$1(m, a){return singleton$0(m[1], a);}
   function union_list$2(m, a){return union_list$1(m[1], a);}
   function of_sorted_array_unchecked$2(m, a){
    return of_sorted_array_unchecked$1(m[1], a);
   }
   function of_increasing_iterator_uncheck$2(m, len, f){
    return of_increasing_iterator_uncheck$1(m[1], len, f);
   }
   function of_sorted_array$2(m, a){return of_sorted_array$1(m[1], a);}
   function of_list$2(m, a){return of_list$1(m[1], a);}
   function of_sequence$2(m, a){return of_sequence$1(m[1], a);}
   function of_array$2(m, a){return of_array$1(m[1], a);}
   function stable_dedup_list$2(m, a){return stable_dedup_list$1(m[1], a);}
   function map$2(m, a, f){return map$1(m[1], a, f);}
   function filter_map$2(m, a, f){return filter_map$1(m[1], a, f);}
   function M(Elt){return [0];}
   function sexp_of_m_t(Elt){
    return function(t){
     return sexp_of_t$0(Elt[1], function(param){return _q_;}, t);};
   }
   function m_t_of_sexp(Elt){
    return function(sexp){return t_of_sexp_direct$1(Elt[2], Elt[1], sexp);};
   }
   function m_t_sexp_grammar(Elt){
    var _v_ = caml_call1(Base_Import[194], Elt[1]);
    return caml_call1(Sexplib0_Sexp_grammar[1], _v_);
   }
   function compare_m_t(param, t1, t2){return compare_direct(t1, t2);}
   function equal_m_t(param, t1, t2){return equal$0(t1, t2);}
   function hash_fold_m_t(Elt){
    return function(state){
     var _t_ = Elt[1];
     return function(_u_){return hash_fold_direct(_t_, state, _u_);};};
   }
   function hash_m_t(folder, t){
    var
     _s_ = caml_call2(Base_Hash[11], 0, 0),
     state = caml_call1(hash_fold_m_t(folder)(_s_), t);
    return caml_call1(Base_Hash[9], state);
   }
   var
    comparator$0 = Base_Comparator[2][1],
    include = Empty_without_value_restrictio(Base_Comparator[2]),
    empty$2 = include[1];
   function singleton$2(a){return singleton$0(comparator$0, a);}
   function union_list$3(a){return union_list$1(comparator$0, a);}
   function of_sorted_array_unchecked$3(a){
    return of_sorted_array_unchecked$1(comparator$0, a);
   }
   function of_increasing_iterator_uncheck$3(len, f){
    return of_increasing_iterator_uncheck$1(comparator$0, len, f);
   }
   function of_sorted_array$3(a){return of_sorted_array$1(comparator$0, a);}
   function of_list$3(a){return of_list$1(comparator$0, a);}
   function of_sequence$3(a){return of_sequence$1(comparator$0, a);}
   function of_array$3(a){return of_array$1(comparator$0, a);}
   function stable_dedup_list$3(a){
    return stable_dedup_list$1(comparator$0, a);
   }
   function map$3(a, f){return map$1(comparator$0, a, f);}
   function filter_map$3(a, f){return filter_map$1(comparator$0, a, f);}
   function of_tree$1(tree){return [0, comparator$0, tree];}
   function to_tree$1(t){return t[2];}
   var
    _r_ = Base_Sequence[55],
    Base_Set =
      [0,
       compare$0,
       invariants$0,
       comparator_s,
       comparator,
       empty$1,
       singleton$1,
       length$0,
       is_empty$0,
       mem$0,
       add$0,
       remove$0,
       union$0,
       union_list$2,
       inter$0,
       diff$0,
       symmetric_diff$0,
       compare_direct,
       hash_fold_direct,
       equal$0,
       exists$0,
       for_all$0,
       count$0,
       sum$0,
       find$0,
       find_map$0,
       find_exn$0,
       nth$0,
       remove_index$0,
       is_subset$1,
       are_disjoint$0,
       [0, is_subset$2, equal$1],
       of_list$2,
       of_sequence$2,
       of_array$2,
       to_list,
       to_array$0,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       stable_dedup_list$2,
       map$2,
       filter_map$2,
       filter$0,
       fold$0,
       fold_result,
       fold_until$0,
       fold_right$0,
       iter$1,
       iter2$0,
       partition_tf$0,
       elements$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       choose$0,
       choose_exn$0,
       split$0,
       group_by$0,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       [0, _r_[1], _r_[3], _r_[4]],
       merge_to_sequence$0,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       hash_m_t,
       [0,
        length$0,
        is_empty$0,
        iter$1,
        fold$0,
        fold_result,
        exists$0,
        for_all$0,
        count$0,
        sum$0,
        find$0,
        find_map$0,
        to_list,
        to_array$0,
        invariants$0,
        mem$0,
        add$0,
        remove$0,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$0,
        is_subset$1,
        are_disjoint$0,
        [0, is_subset$2, equal$1],
        fold_until$0,
        fold_right$0,
        iter2$0,
        filter$0,
        partition_tf$0,
        elements$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$0,
        group_by$0,
        find_exn$0,
        nth$0,
        remove_index$0,
        to_tree$1,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        merge_to_sequence$0,
        empty$2,
        singleton$2,
        union_list$3,
        of_list$3,
        of_sequence$3,
        of_array$3,
        of_sorted_array$3,
        of_sorted_array_unchecked$3,
        of_increasing_iterator_uncheck$3,
        stable_dedup_list$3,
        map$3,
        filter_map$3,
        of_tree$1],
       [0,
        sexp_of_t$0,
        t_of_sexp_direct$1,
        [0,
         sexp_of_t$1,
         t_of_sexp_direct$0,
         Named,
         length$1,
         is_empty$1,
         iter$2,
         fold$1,
         fold_result$0,
         exists$1,
         for_all$1,
         count$1,
         sum$1,
         find$1,
         find_map$1,
         to_list$0,
         to_array$1,
         invariants$1,
         mem$1,
         add$1,
         remove$1,
         union$1,
         inter$1,
         diff$1,
         symmetric_diff$1,
         compare_direct$0,
         equal$2,
         is_subset$3,
         are_disjoint$1,
         fold_until$1,
         fold_right$1,
         iter2$1,
         filter$1,
         partition_tf$1,
         elements$1,
         min_elt$1,
         min_elt_exn$1,
         max_elt$1,
         max_elt_exn$1,
         choose$1,
         choose_exn$1,
         split$1,
         group_by$1,
         find_exn$1,
         nth$1,
         remove_index$1,
         to_tree,
         to_sequence$1,
         binary_search$1,
         binary_search_segmented$1,
         merge_to_sequence$1,
         empty,
         singleton,
         union_list$0,
         of_list$0,
         of_sequence$0,
         of_array$0,
         of_sorted_array$0,
         of_sorted_array_unchecked$0,
         of_increasing_iterator_uncheck$0,
         stable_dedup_list$0,
         map$0,
         filter_map$0,
         of_tree,
         empty_without_value_restrictio],
        length$0,
        is_empty$0,
        iter$1,
        fold$0,
        fold_result,
        exists$0,
        for_all$0,
        count$0,
        sum$0,
        find$0,
        find_map$0,
        to_list,
        to_array$0,
        invariants$0,
        mem$0,
        add$0,
        remove$0,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$0,
        is_subset$1,
        are_disjoint$0,
        [0, is_subset$2, equal$1],
        fold_until$0,
        fold_right$0,
        iter2$0,
        filter$0,
        partition_tf$0,
        elements$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$0,
        group_by$0,
        find_exn$0,
        nth$0,
        remove_index$0,
        to_tree$0,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        merge_to_sequence$0,
        empty$0,
        singleton$0,
        union_list$1,
        of_list$1,
        of_sequence$1,
        of_array$1,
        of_sorted_array$1,
        of_sorted_array_unchecked$1,
        of_increasing_iterator_uncheck$1,
        stable_dedup_list$1,
        map$1,
        filter_map$1,
        of_tree$0,
        comparator,
        hash_fold_direct,
        Empty_without_value_restrictio]];
   runtime.caml_register_global(45, Base_Set, "Base__Set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ref
//# unitInfo: Requires: Base__Exn, Base__Import, Base__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Exn = global_data.Base__Exn,
    Base_List = global_data.Base__List,
    Base_Import = global_data.Base__Import,
    compare = Base_Import[237],
    equal = Base_Import[250],
    t_of_sexp = Base_Import[170],
    sexp_of_t = Base_Import[146];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[191], a_sexp_grammar);
   }
   function swap(t1, t2){
    var tmp = t1[1];
    t1[1] = t2[1];
    t2[1] = tmp;
    return 0;
   }
   function replace(t, f){t[1] = caml_call1(f, t[1]); return 0;}
   function set_temporarily(t, a, f){
    var restore_to = t[1];
    t[1] = a;
    return caml_call2
            (Base_Exn[13], f, function(param){t[1] = restore_to; return 0;});
   }
   function set(param){var a = param[2], r = param[1]; r[1] = a; return 0;}
   function sets(ts){return caml_call2(Base_List[9], ts, set);}
   function snapshot(param){var r = param[1]; return [0, r, r[1]];}
   function sets_temporarily(and_values, f){
    var restore_to = caml_call2(Base_List[76], and_values, snapshot);
    sets(and_values);
    return caml_call2
            (Base_Exn[13], f, function(param){return sets(restore_to);});
   }
   var
    Base_Ref =
      [0,
       compare,
       equal,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       swap,
       replace,
       set_temporarily,
       [0, set, sets, snapshot],
       sets_temporarily];
   runtime.caml_register_global(3, Base_Ref, "Base__Ref");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Queue_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Queue_intf = [0];
   runtime.caml_register_global(0, Base_Queue_intf, "Base__Queue_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Queue
//# unitInfo: Requires: Assert_failure, Base__Array, Base__Error, Base__Import, Base__Indexed_container, Base__Int, Base__List, Base__Option_array, Base__Sexp, Sexplib0__Sexp_grammar, Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_length$2 = "length",
    cst_src_queue_ml = "src/queue.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Import = global_data.Base__Import,
    Base_Option_array = global_data.Base__Option_array,
    Base_Array = global_data.Base__Array,
    Base_Int = global_data.Base__Int,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Base_Indexed_container = global_data.Base__Indexed_container,
    _a_ = [0, "elts"],
    _b_ = [0, cst_length$2],
    _c_ = [0, "mask"],
    _d_ = [0, "front"],
    _e_ = [0, "num_mutations"],
    cst_length = cst_length$2,
    cst_index = "index",
    cst_Queue_index_out_of_bounds = "Queue index out of bounds",
    _f_ = [0, "_"],
    cst_mutation_of_queue_during_i = "mutation of queue during iteration",
    _g_ = [0, cst_src_queue_ml, 165, 9],
    _h_ = [0, cst_src_queue_ml, 159, 2],
    _i_ = [0, cst_src_queue_ml, 158, 2],
    _j_ = [0, cst_src_queue_ml, 157, 2],
    _k_ = [0, cst_src_queue_ml, 156, 2],
    _l_ = [0, cst_src_queue_ml, 155, 2],
    _m_ = [0, cst_src_queue_ml, 153, 2],
    _n_ = [0, cst_src_queue_ml, 152, 2],
    cst_capacity = "capacity",
    cst_cannot_have_queue_with_neg =
      "cannot have queue with negative capacity",
    _o_ = [0, cst_src_queue_ml, 193, 2],
    cst_length$0 = cst_length$2,
    cst_Queue_blit_transfer_negati = "Queue.blit_transfer: negative length";
   function inc_num_mutations(t){
    t[1] = caml_call2(Base_Import[90], t[1], 1);
    return;
   }
   function capacity(t){return caml_call2(Base_Import[90], t[3], 1);}
   function elts_index(t, i){
    var _aX_ = t[3], _aY_ = caml_call2(Base_Import[90], t[2], i);
    return caml_call2(Base_Import[115], _aY_, _aX_);
   }
   function unsafe_get(t, i){
    var _aW_ = elts_index(t, i);
    return caml_call2(Base_Option_array[38], t[5], _aW_);
   }
   function unsafe_set(t, i, a){
    var _aV_ = elts_index(t, i);
    return caml_call3(Base_Option_array[49], t[5], _aV_, a);
   }
   function check_index_exn(t, i){
    var _aQ_ = i < 0 ? 1 : 0, _aR_ = _aQ_ || (t[4] <= i ? 1 : 0);
    if(! _aR_) return _aR_;
    var
     _aS_ = [0, [0, cst_length, caml_call1(Base_Int[9], t[4])], 0],
     _aT_ = [0, [0, cst_index, caml_call1(Base_Int[9], i)], _aS_],
     _aU_ = caml_call2(Base_Sexp[9], cst_Queue_index_out_of_bounds, _aT_);
    return caml_call1(Base_Error[30], _aU_);
   }
   function get(t, i){check_index_exn(t, i); return unsafe_get(t, i);}
   function set(t, i, a){
    check_index_exn(t, i);
    inc_num_mutations(t);
    return unsafe_set(t, i, a);
   }
   function is_empty(t){return 0 === t[4] ? 1 : 0;}
   function length(param){var length = param[4]; return length;}
   function ensure_no_mutation(t, num_mutations){
    var _aO_ = t[1] !== num_mutations ? 1 : 0;
    if(! _aO_) return _aO_;
    function of_a_001(param){return _f_;}
    var
     num_mutations_003 = t[1],
     front_005 = t[2],
     mask_007 = t[3],
     length_009 = t[4],
     elts_011 = t[5],
     arg_012 = caml_call2(Base_Option_array[2], of_a_001, elts_011),
     bnds_002 = [0, [1, [0, _a_, [0, arg_012, 0]]], 0],
     arg_010 = caml_call1(Base_Import[141], length_009),
     bnds_002$0 = [0, [1, [0, _b_, [0, arg_010, 0]]], bnds_002],
     arg_008 = caml_call1(Base_Import[141], mask_007),
     bnds_002$1 = [0, [1, [0, _c_, [0, arg_008, 0]]], bnds_002$0],
     arg_006 = caml_call1(Base_Import[141], front_005),
     bnds_002$2 = [0, [1, [0, _d_, [0, arg_006, 0]]], bnds_002$1],
     arg_004 = caml_call1(Base_Import[141], num_mutations_003),
     bnds_002$3 = [0, [1, [0, _e_, [0, arg_004, 0]]], bnds_002$2],
     _aP_ =
       caml_call2
        (Base_Sexp[9],
         cst_mutation_of_queue_during_i,
         [0, [0, cst, [1, bnds_002$3]], 0]);
    return caml_call1(Base_Error[30], _aP_);
   }
   function compare(compare_elt, t1, t2){
    if(caml_call2(Base_Import[127], t1, t2)) return 0;
    var mut2 = t2[1], mut1 = t1[1], len2 = t2[4], len1 = t1[4], pos = 0;
    for(;;){
     var match = pos === len2 ? 1 : 0;
     if(pos === len1) return match ? 0 : -1;
     if(match) return 1;
     var
      _aN_ = unsafe_get(t2, pos),
      x = caml_call2(compare_elt, unsafe_get(t1, pos), _aN_);
     ensure_no_mutation(t1, mut1);
     ensure_no_mutation(t2, mut2);
     if(0 !== x) return x;
     var pos$0 = caml_call2(Base_Import[90], pos, 1);
     pos = pos$0;
    }
   }
   function equal(equal_elt, t1, t2){
    var _aK_ = caml_call2(Base_Import[127], t1, t2);
    if(_aK_)
     var _aL_ = _aK_;
    else{
     var len1 = t1[4], len2 = t2[4], _aM_ = len1 === len2 ? 1 : 0;
     if(_aM_){
      var mut2 = t2[1], mut1 = t1[1], pos = 0;
      for(;;){
       var _aH_ = pos === len1 ? 1 : 0;
       if(_aH_)
        var _aI_ = _aH_;
       else{
        var
         _aJ_ = unsafe_get(t2, pos),
         b = caml_call2(equal_elt, unsafe_get(t1, pos), _aJ_);
        ensure_no_mutation(t1, mut1);
        ensure_no_mutation(t2, mut2);
        if(b){
         var pos$0 = caml_call2(Base_Import[90], pos, 1);
         pos = pos$0;
         continue;
        }
        var _aI_ = b;
       }
       return _aI_;
      }
     }
     var _aL_ = _aM_;
    }
    return _aL_;
   }
   function invariant(invariant_a, t){
    var num_mutations = t[1], front = t[2], length = t[4], elts = t[5];
    if(0 > front)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
    if(front >= capacity(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
    var capacity$0 = capacity(t);
    if(capacity$0 !== caml_call1(Base_Option_array[6], elts))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    if(1 > capacity$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
    if(! caml_call1(Base_Int[67], capacity$0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
    if(0 > length)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
    if(length > capacity$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    var _aF_ = caml_call2(Base_Import[92], capacity$0, 1), _aE_ = 0;
    if(_aF_ >= 0){
     var i = _aE_;
     for(;;){
      if(i < t[4]){
       caml_call1(invariant_a, unsafe_get(t, i));
       ensure_no_mutation(t, num_mutations);
      }
      else{
       var _aD_ = elts_index(t, i);
       if(caml_call2(Base_Option_array[40], t[5], _aD_))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
      }
      var _aG_ = i + 1 | 0;
      if(_aF_ === i) break;
      i = _aG_;
     }
    }
    return 0;
   }
   function create(capacity, param){
    if(capacity){
     var capacity$0 = capacity[1];
     if(0 <= capacity$0)
      var _az_ = 0 === capacity$0 ? 1 : caml_call1(Base_Int[63], capacity$0);
     else
      var
       _aB_ = [0, [0, cst_capacity, caml_call1(Base_Int[9], capacity$0)], 0],
       _aC_ = caml_call2(Base_Sexp[9], cst_cannot_have_queue_with_neg, _aB_),
       _az_ = caml_call1(Base_Error[30], _aC_);
     var capacity$1 = _az_;
    }
    else
     var capacity$1 = 1;
    var _aA_ = caml_call1(Base_Option_array[5], capacity$1);
    return [0, 0, 0, caml_call2(Base_Import[92], capacity$1, 1), 0, _aA_];
   }
   function blit_to_array(src, dst){
    var _av_ = caml_call1(Base_Option_array[6], dst);
    if(src[4] > _av_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
    var
     _aw_ = src[2],
     _ax_ = capacity(src),
     _ay_ = caml_call2(Base_Import[92], _ax_, _aw_),
     front_len = caml_call2(Base_Int[14], src[4], _ay_),
     rest_len = caml_call2(Base_Import[92], src[4], front_len);
    caml_call5(Base_Option_array[51], src[5], src[2], dst, 0, front_len);
    return caml_call5
            (Base_Option_array[51], src[5], 0, dst, front_len, rest_len);
   }
   function set_capacity(t, desired_capacity){
    inc_num_mutations(t);
    var
     _ar_ = caml_call2(Base_Import[99], desired_capacity, t[4]),
     _as_ = caml_call2(Base_Import[99], 1, _ar_),
     new_capacity = caml_call1(Base_Int[63], _as_),
     _at_ = new_capacity !== capacity(t) ? 1 : 0;
    if(_at_){
     var dst = caml_call1(Base_Option_array[5], new_capacity);
     blit_to_array(t, dst);
     t[2] = 0;
     t[3] = caml_call2(Base_Import[92], new_capacity, 1);
     t[5] = dst;
     var _au_ = 0;
    }
    else
     var _au_ = _at_;
    return _au_;
   }
   function enqueue(t, a){
    inc_num_mutations(t);
    var _aq_ = capacity(t);
    if(t[4] === _aq_) set_capacity(t, caml_call2(Base_Import[87], 2, t[4]));
    unsafe_set(t, t[4], a);
    t[4] = caml_call2(Base_Import[90], t[4], 1);
    return 0;
   }
   function dequeue_nonempty(t){
    inc_num_mutations(t);
    var
     elts = t[5],
     front = t[2],
     res = caml_call2(Base_Option_array[34], elts, front);
    caml_call2(Base_Option_array[43], elts, front);
    t[2] = elts_index(t, 1);
    t[4] = caml_call2(Base_Import[92], t[4], 1);
    return res;
   }
   function dequeue_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return dequeue_nonempty(t);
   }
   function dequeue(t){return is_empty(t) ? 0 : [0, dequeue_nonempty(t)];}
   function front_nonempty(t){
    return caml_call2(Base_Option_array[38], t[5], t[2]);
   }
   function last_nonempty(t){
    return unsafe_get(t, caml_call2(Base_Import[92], t[4], 1));
   }
   function peek(t){return is_empty(t) ? 0 : [0, front_nonempty(t)];}
   function peek_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return front_nonempty(t);
   }
   function last(t){return is_empty(t) ? 0 : [0, last_nonempty(t)];}
   function last_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return last_nonempty(t);
   }
   function clear(t){
    inc_num_mutations(t);
    var _al_ = 0 < t[4] ? 1 : 0;
    if(_al_){
     var _an_ = caml_call2(Base_Import[92], t[4], 1), _am_ = 0;
     if(_an_ >= 0){
      var i = _am_;
      for(;;){
       var _ak_ = elts_index(t, i);
       caml_call2(Base_Option_array[50], t[5], _ak_);
       var _ap_ = i + 1 | 0;
       if(_an_ === i) break;
       i = _ap_;
      }
     }
     t[4] = 0;
     t[2] = 0;
     var _ao_ = 0;
    }
    else
     var _ao_ = _al_;
    return _ao_;
   }
   function blit_transfer(src, dst, len, param){
    inc_num_mutations(src);
    inc_num_mutations(dst);
    if(len){
     var len$0 = len[1];
     if(len$0 < 0){
      var
       _W_ = [0, [0, cst_length$0, caml_call1(Base_Int[9], len$0)], 0],
       _X_ = caml_call2(Base_Sexp[9], cst_Queue_blit_transfer_negati, _W_);
      caml_call1(Base_Error[30], _X_);
     }
     var len$1 = caml_call2(Base_Import[100], len$0, src[4]);
    }
    else
     var len$1 = src[4];
    var _Y_ = 0 < len$1 ? 1 : 0;
    if(_Y_){
     var
      _Z_ = caml_call2(Base_Import[90], dst[4], len$1),
      ___ = capacity(dst);
     set_capacity(dst, caml_call2(Base_Import[99], ___, _Z_));
     var
      dst_start = caml_call2(Base_Import[90], dst[2], dst[4]),
      _aa_ = caml_call2(Base_Import[92], len$1, 1),
      _$_ = 0;
     if(_aa_ >= 0){
      var i = _$_;
      for(;;){
       var
        _ae_ = src[3],
        _af_ = caml_call2(Base_Import[90], src[2], i),
        src_i = caml_call2(Base_Import[115], _af_, _ae_),
        _ag_ = dst[3],
        _ah_ = caml_call2(Base_Import[90], dst_start, i),
        dst_i = caml_call2(Base_Import[115], _ah_, _ag_),
        _ai_ = caml_call2(Base_Option_array[38], src[5], src_i);
       caml_call3(Base_Option_array[49], dst[5], dst_i, _ai_);
       caml_call2(Base_Option_array[50], src[5], src_i);
       var _aj_ = i + 1 | 0;
       if(_aa_ === i) break;
       i = _aj_;
      }
     }
     dst[4] = caml_call2(Base_Import[90], dst[4], len$1);
     var _ab_ = src[3], _ac_ = caml_call2(Base_Import[90], src[2], len$1);
     src[2] = caml_call2(Base_Import[115], _ac_, _ab_);
     src[4] = caml_call2(Base_Import[92], src[4], len$1);
     var _ad_ = 0;
    }
    else
     var _ad_ = _Y_;
    return _ad_;
   }
   function enqueue_all(t, l){
    var
     _T_ = caml_call1(Base_List[7], l),
     _U_ = caml_call2(Base_Import[90], t[4], _T_),
     _V_ = capacity(t);
    set_capacity(t, caml_call2(Base_Int[15], _V_, _U_));
    return caml_call2(Base_List[9], l, function(x){return enqueue(t, x);});
   }
   function fold(t, init, f){
    if(0 === t[4]) return init;
    var
     num_mutations = t[1],
     r = [0, init],
     _Q_ = caml_call2(Base_Import[92], t[4], 1),
     _P_ = 0;
    if(_Q_ >= 0){
     var i = _P_;
     for(;;){
      var _R_ = unsafe_get(t, i);
      r[1] = caml_call2(f, r[1], _R_);
      ensure_no_mutation(t, num_mutations);
      var _S_ = i + 1 | 0;
      if(_Q_ === i) break;
      i = _S_;
     }
    }
    return r[1];
   }
   function foldi(t, init, f){
    var i = [0, 0];
    return fold
            (t,
             init,
             function(acc, a){
              var acc$0 = caml_call3(f, i[1], acc, a);
              i[1] = caml_call2(Base_Import[90], i[1], 1);
              return acc$0;
             });
   }
   function iter(t, f){
    var
     num_mutations = t[1],
     _N_ = caml_call2(Base_Import[92], t[4], 1),
     _M_ = 0;
    if(_N_ >= 0){
     var i = _M_;
     for(;;){
      caml_call1(f, unsafe_get(t, i));
      ensure_no_mutation(t, num_mutations);
      var _O_ = i + 1 | 0;
      if(_N_ === i) break;
      i = _O_;
     }
    }
    return 0;
   }
   function iteri(t, f){
    var
     num_mutations = t[1],
     _K_ = caml_call2(Base_Import[92], t[4], 1),
     _J_ = 0;
    if(_K_ >= 0){
     var i = _J_;
     for(;;){
      caml_call2(f, i, unsafe_get(t, i));
      ensure_no_mutation(t, num_mutations);
      var _L_ = i + 1 | 0;
      if(_K_ === i) break;
      i = _L_;
     }
    }
    return 0;
   }
   function to_list(t){
    var result = [0, 0], _G_ = caml_call2(Base_Import[92], t[4], 1);
    if(_G_ >= 0){
     var i = _G_;
     for(;;){
      var _H_ = result[1];
      result[1] = [0, unsafe_get(t, i), _H_];
      var _I_ = i - 1 | 0;
      if(0 === i) break;
      i = _I_;
     }
    }
    return result[1];
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    foldi$0 = [0, -198771759, foldi],
    iteri$0 = [0, -198771759, iteri],
    C =
      caml_call1
       (Base_Indexed_container[8],
        [0, fold, iter$0, length$0, iteri$0, foldi$0]),
    count = C[10],
    exists = C[8],
    find = C[12],
    find_map = C[13],
    fold_result = C[6],
    fold_until = C[7],
    for_all = C[9],
    max_elt = C[17],
    mem = C[1],
    min_elt = C[16],
    sum = C[11],
    counti = C[22],
    existsi = C[20],
    find_mapi = C[24],
    findi = C[23],
    for_alli = C[21],
    cst_length$1 = cst_length$2,
    cst_Queue_init_negative_length = "Queue.init: negative length",
    _p_ = [0, cst_src_queue_ml, 451, 2];
   function concat_map(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var _F_ = caml_call1(f, a);
       return caml_call2
               (Base_List[9], _F_, function(b){return enqueue(t_result, b);});
      });
    return t_result;
   }
   function concat_mapi(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var _E_ = caml_call2(f, i, a);
       return caml_call2
               (Base_List[9], _E_, function(b){return enqueue(t_result, b);});
      });
    return t_result;
   }
   function filter_map(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var match = caml_call1(f, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(t_result, b);
      });
    return t_result;
   }
   function filter_mapi(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var match = caml_call2(f, i, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(t_result, b);
      });
    return t_result;
   }
   function filter(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var _D_ = caml_call1(f, a);
       return _D_ ? enqueue(t_result, a) : _D_;
      });
    return t_result;
   }
   function filteri(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var _C_ = caml_call2(f, i, a);
       return _C_ ? enqueue(t_result, a) : _C_;
      });
    return t_result;
   }
   function filter_inplace(t, f){
    var t2 = filter(t, f);
    clear(t);
    return blit_transfer(t2, t, 0, 0);
   }
   function filteri_inplace(t, f){
    var t2 = filteri(t, f);
    clear(t);
    return blit_transfer(t2, t, 0, 0);
   }
   function copy(src){
    var dst = create([0, src[4]], 0);
    blit_to_array(src, dst[5]);
    dst[4] = src[4];
    return dst;
   }
   function of_list(l){
    var t = create([0, caml_call1(Base_List[7], l)], 0);
    caml_call2(Base_List[9], l, function(x){return enqueue(t, x);});
    return t;
   }
   function init(len, f){
    if(len < 0){
     var
      _w_ = [0, [0, cst_length$1, caml_call1(Base_Int[9], len)], 0],
      _x_ = caml_call2(Base_Sexp[9], cst_Queue_init_negative_length, _w_);
     caml_call1(Base_Error[30], _x_);
    }
    var t = create([0, len], 0);
    if(len > caml_call1(Base_Option_array[6], t[5]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
    var _z_ = caml_call2(Base_Import[92], len, 1), _y_ = 0;
    if(_z_ >= 0){
     var i = _y_;
     for(;;){
      var _A_ = caml_call1(f, i);
      caml_call3(Base_Option_array[49], t[5], i, _A_);
      var _B_ = i + 1 | 0;
      if(_z_ === i) break;
      i = _B_;
     }
    }
    t[4] = len;
    return t;
   }
   function of_array(a){
    return init(a.length - 1, function(_v_){return a[1 + _v_];});
   }
   function to_array(t){
    return caml_call2
            (Base_Array[27], t[4], function(i){return unsafe_get(t, i);});
   }
   function map(ta, f){
    var num_mutations = ta[1], tb = create([0, ta[4]], 0);
    tb[4] = ta[4];
    var _t_ = caml_call2(Base_Import[92], ta[4], 1), _s_ = 0;
    if(_t_ >= 0){
     var i = _s_;
     for(;;){
      var b = caml_call1(f, unsafe_get(ta, i));
      ensure_no_mutation(ta, num_mutations);
      caml_call3(Base_Option_array[49], tb[5], i, b);
      var _u_ = i + 1 | 0;
      if(_t_ === i) break;
      i = _u_;
     }
    }
    return tb;
   }
   function mapi(t, f){
    var i = [0, 0];
    return map
            (t,
             function(a){
              var result = caml_call2(f, i[1], a);
              i[1] = caml_call2(Base_Import[90], i[1], 1);
              return result;
             });
   }
   function singleton(x){var t = create(0, 0); enqueue(t, x); return t;}
   function sexp_of_t(sexp_of_a, t){
    var _r_ = to_list(t);
    return caml_call1(caml_call1(Base_List[4], sexp_of_a), _r_);
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_List[3], a_of_sexp, sexp));
   }
   function t_sexp_grammar(grammar){
    var _q_ = caml_call1(Base_List[5], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _q_);
   }
   var
    Base_Queue =
      [0,
       compare,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       singleton,
       of_list,
       of_array,
       init,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       peek,
       peek_exn,
       clear,
       copy,
       map,
       mapi,
       concat_map,
       concat_mapi,
       filter_map,
       filter_mapi,
       filter,
       filteri,
       filter_inplace,
       filteri_inplace,
       equal,
       invariant,
       create,
       last,
       last_exn,
       blit_transfer,
       get,
       set,
       capacity,
       set_capacity];
   runtime.caml_register_global(38, Base_Queue, "Base__Queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Nothing
//# unitInfo: Requires: Base__Identifiable, Base__Import, Match_failure, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    t_sexp_grammar = [4, 0],
    module_name = "Base.Nothing",
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Match_failure = global_data.Match_failure,
    Base_Identifiable = global_data.Base__Identifiable,
    _a_ = [0, "src/nothing.ml", 6, 25];
   function unreachable_code(param){
    throw caml_maybe_attach_backtrace([0, Match_failure, _a_], 1);
   }
   var
    cst_Base_Nothing_t = "Base.Nothing.t",
    cst_Base_Nothing_of_string_not = "Base.Nothing.of_string: not supported";
   function hash_fold_t(param, t){return unreachable_code(t);}
   function compare(a, param){return unreachable_code(a);}
   function t_of_sexp(sexp){
    return caml_call2(Sexplib0_Sexp_conv_error[26], cst_Base_Nothing_t, sexp);
   }
   function of_string(param){
    return caml_call1(Base_Import[123], cst_Base_Nothing_of_string_not);
   }
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         unreachable_code,
         t_of_sexp,
         unreachable_code,
         of_string,
         unreachable_code,
         module_name]),
    hash_fold_t$0 = include[1],
    hash = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t = include[4],
    of_string$0 = include[5],
    to_string = include[6],
    symbol = include[7],
    symbol$0 = include[8],
    symbol$1 = include[9],
    symbol$2 = include[10],
    symbol$3 = include[11],
    symbol$4 = include[12],
    equal = include[13],
    compare$0 = include[14],
    min = include[15],
    max = include[16],
    ascending = include[17],
    descending = include[18],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    pp = include[23],
    hashable = include[24],
    Base_Nothing =
      [0,
       0,
       t_sexp_grammar,
       unreachable_code,
       hash_fold_t$0,
       hash,
       t_of_sexp$0,
       sexp_of_t,
       of_string$0,
       to_string,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable];
   runtime.caml_register_global(9, Base_Nothing, "Base__Nothing");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Nativeint
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Word_size, Stdlib__Nativeint, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_nx = "%nx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_lessequal = runtime.caml_lessequal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Nativeint.Hex",
    module_name$0 = "Base.Nativeint",
    Base_Int_math = global_data.Base__Int_math,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Base_Printf = global_data.Base__Printf,
    Base_Float0 = global_data.Base__Float0,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Word_size = global_data.Base__Word_size,
    Base_Error = global_data.Base__Error,
    Base_Popcount = global_data.Base__Popcount,
    include = Base_Import[103],
    compare = include[9],
    hash_fold_t = Base_Import[202],
    func = Base_Import[216];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[169],
    sexp_of_t = Base_Import[145],
    t_sexp_grammar = Base_Import[189],
    hashable = [0, hash, compare, sexp_of_t],
    compare$0 = Base_Import[103][9],
    to_string = Stdlib_Nativeint[15],
    of_string = runtime.caml_int_of_string,
    comparator = caml_call1(Base_Comparator[5], [0, compare$0, sexp_of_t])[1],
    zero = Stdlib_Nativeint[1],
    _a_ = caml_call1(Base_Comparable[13], [0, compare$0, sexp_of_t, zero]),
    is_positive = _a_[1],
    is_non_negative = _a_[2],
    is_negative = _a_[3],
    is_non_positive = _a_[4],
    sign = _a_[5],
    include$0 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$0[1],
    sexp_of_t$0 = include$0[2],
    compare$1 = Base_Import[231],
    hash_fold_t$0 = Base_Import[202],
    func$0 = Base_Import[216];
   function hash$0(x){return caml_call1(func$0, x);}
   var zero$0 = Stdlib_Nativeint[1];
   function neg(_Q_){return - _Q_ | 0;}
   var
    symbol = Base_Import[103][1],
    _b_ = [0, [6, 6, 0, 0, 0], cst_nx],
    _c_ = [0, [6, 6, 0, 0, 0], cst_nx];
   function to_string$0(i){return caml_call2(Base_Printf[2], _b_, i);}
   function of_string$0(s){
    return caml_call3(Stdlib_Scanf[4], s, _c_, function(_P_){return _P_;});
   }
   var
    include$1 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$1,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero$0,
         symbol,
         neg,
         module_name]),
    Hex = include$1[1],
    include$2 =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string]),
    pp = include$2[1];
   function invariant(param){return 0;}
   var
    num_bits = caml_call1(Base_Word_size[2], Base_Word_size[3]),
    float_lower_bound = caml_call1(Base_Float0[25], num_bits),
    float_upper_bound = caml_call1(Base_Float0[23], num_bits);
   function shift_right_logical(_O_, _N_){return _O_ >>> _N_ | 0;}
   function shift_right(_M_, _L_){return _M_ >> _L_;}
   function shift_left(_K_, _J_){return _K_ << _J_;}
   var bit_not = Stdlib_Nativeint[12];
   function bit_xor(_I_, _H_){return _I_ ^ _H_;}
   function bit_or(_G_, _F_){return _G_ | _F_;}
   function bit_and(_E_, _D_){return _E_ & _D_;}
   var
    min_value = Stdlib_Nativeint[11],
    max_value = Stdlib_Nativeint[10],
    abs = Stdlib_Nativeint[8],
    pred = Stdlib_Nativeint[7],
    succ = Stdlib_Nativeint[6],
    rem = runtime.caml_mod;
   function symbol$0(_C_){return - _C_ | 0;}
   var
    minus_one = Stdlib_Nativeint[3],
    one = Stdlib_Nativeint[2],
    zero$1 = Stdlib_Nativeint[1],
    _d_ =
      [0,
       [11,
        "Nativeint.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Nativeint.of_float: argument (%f) is out of range or NaN"];
   function to_float(_B_){return _B_;}
   function of_float_unchecked(_A_){return _A_ | 0;}
   function of_float(f){
    if
     (caml_call2(Base_Import[107][6], f, float_lower_bound)
      && caml_call2(Base_Import[107][2], f, float_upper_bound))
     return f | 0;
    var _z_ = caml_call1(Base_Float0[27], f);
    return caml_call3(Base_Printf[7], _d_, _z_, 0);
   }
   var
    raise_s = Base_Error[30],
    _e_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_Nativeint_floor_log2_got_i =
      "[Nativeint.floor_log2] got invalid input",
    cst_Nativeint_ceil_log2_got_in = "[Nativeint.ceil_log2] got invalid input",
    _f_ = [0, "src/nativeint.ml", 202, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _e_, 0);
   }
   function ceil_pow2(x){
    if(caml_call2(Base_Import[103][2], x, 0)) non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Nativeint[7], x),
     x$6 = x$0 | x$0 >>> 1 | 0,
     x$5 = x$6 | x$6 >>> 2 | 0,
     x$4 = x$5 | x$5 >>> 4 | 0,
     x$3 = x$4 | x$4 >>> 8 | 0,
     x$2 = x$3 | x$3 >>> 16 | 0,
     x$1 = x$2 | x$2 >>> 32 | 0;
    return caml_call1(Stdlib_Nativeint[6], x$1);
   }
   function floor_pow2(x$0){
    if(caml_call2(Base_Import[103][2], x$0, 0)) non_positive_argument(0);
    var
     x = x$0 | x$0 >>> 1 | 0,
     x$5 = x | x >>> 2 | 0,
     x$4 = x$5 | x$5 >>> 4 | 0,
     x$3 = x$4 | x$4 >>> 8 | 0,
     x$2 = x$3 | x$3 >>> 16 | 0,
     x$1 = x$2 | x$2 >>> 32 | 0;
    return x$1 - (x$1 >>> 1 | 0) | 0;
   }
   function is_pow2(x){
    if(caml_call2(Base_Import[103][2], x, 0)) non_positive_argument(0);
    var _y_ = x & caml_call1(Stdlib_Nativeint[7], x);
    return caml_call2(Base_Import[103][4], _y_, 0);
   }
   function floor_log2(i){
    if(caml_lessequal(i, Stdlib_Nativeint[1])){
     var _v_ = [0, [0, cst, caml_call1(Base_Import[145], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Nativeint_floor_log2_got_i, _v_));
    }
    var
     _w_ = runtime.Base_int_math_nativeint_clz(i),
     _x_ = caml_call2(Base_Import[92], num_bits, 1);
    return caml_call2(Base_Import[92], _x_, _w_);
   }
   function ceil_log2(i){
    if(caml_lessequal(i, Stdlib_Nativeint[1])){
     var _t_ = [0, [0, cst$0, caml_call1(Base_Import[145], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Nativeint_ceil_log2_got_in, _t_));
    }
    if(caml_call2(Stdlib_Nativeint[18], i, Stdlib_Nativeint[2])) return 0;
    var
     _u_ =
       runtime.Base_int_math_nativeint_clz(caml_call1(Stdlib_Nativeint[7], i));
    return caml_call2(Base_Import[92], num_bits, _u_);
   }
   function between(t, low, high){
    var _s_ = caml_call2(Base_Import[103][2], low, t);
    return _s_ ? caml_call2(Base_Import[103][2], t, high) : _s_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[103][1], t, min)
            ? min
            : caml_call2(Base_Import[103][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[103][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[103][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _p_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _q_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _p_],
     _r_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _q_);
    return caml_call1(Base_Or_error[35], _r_);
   }
   var symbol$1 = runtime.caml_div, symbol$2 = runtime.caml_mul;
   function symbol$3(_o_, _n_){return _o_ - _n_ | 0;}
   function symbol$4(_m_, _l_){return _m_ + _l_ | 0;}
   function incr(r){r[1] = r[1] + one | 0; return 0;}
   function decr(r){r[1] = r[1] - one | 0; return 0;}
   function of_nativeint(t){return t;}
   function to_nativeint(t){return t;}
   var
    popcount = Base_Popcount[4],
    of_int_exn = Base_Int_conversions[5],
    to_int = Base_Int_conversions[22],
    to_int_exn = Base_Int_conversions[23],
    to_int_trunc = Base_Int_conversions[24],
    of_int32 = Base_Int_conversions[10],
    to_int32 = Base_Int_conversions[25],
    to_int32_exn = Base_Int_conversions[26],
    to_int32_trunc = Base_Int_conversions[27],
    of_int64 = Base_Int_conversions[17],
    of_int64_exn = Base_Int_conversions[18],
    of_int64_trunc = Base_Int_conversions[19],
    to_int64 = Base_Int_conversions[28];
   function pow(b, e){
    var _j_ = caml_call1(to_int_exn, e), _k_ = caml_call1(to_int_exn, b);
    return caml_call1(of_int_exn, caml_call2(Base_Int_math[2][1], _k_, _j_));
   }
   function symbol$5(b, e){return pow(b, e);}
   var
    _g_ = Base_Import[103],
    symbol$6 = _g_[3],
    symbol$7 = _g_[1],
    symbol$8 = _g_[5],
    symbol$9 = _g_[4],
    symbol$10 = _g_[2],
    symbol$11 = _g_[6],
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol$4,
         symbol$3,
         symbol$2,
         symbol$1,
         symbol$0,
         symbol$11,
         symbol$10,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         abs,
         symbol$0,
         zero$1,
         of_int_exn,
         rem]),
    symbol$12 = include$3[1],
    symbol$13 = include$3[2],
    symbol$14 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    include$4 = Base_Import[103],
    symbol$15 = include$4[1],
    symbol$16 = include$4[2],
    symbol$17 = include$4[3],
    symbol$18 = include$4[4],
    symbol$19 = include$4[5],
    symbol$20 = include$4[6],
    ascending = include$4[7],
    descending = include$4[8],
    compare$2 = include$4[9],
    equal = include$4[10],
    max = include$4[11],
    min = include$4[12],
    Base_Nativeint =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       symbol$20,
       symbol$16,
       symbol$18,
       symbol$19,
       symbol$15,
       symbol$17,
       equal,
       compare$2,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       zero$1,
       one,
       minus_one,
       symbol$4,
       symbol$3,
       symbol$2,
       symbol$5,
       symbol$0,
       symbol$0,
       symbol$13,
       symbol$12,
       symbol$1,
       rem,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_i_){return runtime.Base_int_math_nativeint_clz(_i_);},
       function(_h_){return runtime.Base_int_math_nativeint_ctz(_h_);},
       [0,
        symbol$4,
        symbol$3,
        symbol$2,
        symbol$1,
        symbol$0,
        symbol$5,
        symbol$11,
        symbol$10,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        abs,
        symbol$0,
        zero$1,
        symbol$12,
        symbol$13,
        symbol$14,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        shift_left,
        shift_right,
        shift_right_logical],
       of_int_exn,
       to_int,
       of_int32,
       to_int32,
       of_nativeint,
       to_nativeint,
       of_int64,
       to_int_trunc,
       to_int32_trunc,
       of_int64_trunc,
       runtime.caml_int32_bswap];
   runtime.caml_register_global(34, Base_Nativeint, "Base__Nativeint");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Map
//# unitInfo: Requires: Assert_failure, Base__Comparator, Base__Error, Base__Exn, Base__Import, Base__List0, Base__Map_intf, Base__Maybe_bound, Base__Option, Base__Or_error, Base__Result, Base__Sequence, Base__Sexp, Base__Uniform_array, Base__With_return, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Map_bal$3 = "Map.bal",
    cst_Map_of$1 = "Map.of_",
    cst_key$1 = "key",
    cst_of_sorted_array_duplicated$1 = "of_sorted_array: duplicated elements",
    cst_src_map_ml = "src/map.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    empty = [0, 0],
    name = "alist",
    name$0 = "sequence",
    Base_Result = global_data.Base__Result,
    Base_Or_error = global_data.Base__Or_error,
    Base_Error = global_data.Base__Error,
    Base_Import = global_data.Base__Import,
    Base_Option = global_data.Base__Option,
    Base_Exn = global_data.Base__Exn,
    Base_Sexp = global_data.Base__Sexp,
    Base_List0 = global_data.Base__List0,
    Assert_failure = global_data.Assert_failure,
    Base_Uniform_array = global_data.Base__Uniform_array,
    Base_Sequence = global_data.Base__Sequence,
    Base_Maybe_bound = global_data.Base__Maybe_bound,
    Base_Map_intf = global_data.Base__Map_intf,
    Base_With_return = global_data.Base__With_return,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Comparator = global_data.Base__Comparator,
    Symmetric_diff_element = Base_Map_intf[5],
    include = Base_Map_intf[8],
    compare = include[1],
    all = include[2],
    equal = include[3],
    sexp_of_t = include[4];
   function of_continue_or_stop(_dh_){return _dh_;}
   function to_continue_or_stop(_dg_){return _dg_;}
   var
    Finished_or_unfinished =
      [0,
       compare,
       all,
       equal,
       sexp_of_t,
       of_continue_or_stop,
       to_continue_or_stop],
    include$0 = Base_Map_intf[6],
    compare$0 = include$0[1],
    equal$0 = include$0[2],
    sexp_of_t$0 = include$0[3];
   function left(param){
    var _df_ = param[1];
    if(737457313 === _df_)
     var left = param[2][1];
    else{if(847852583 > _df_) return 0; var left = param[2];}
    return [0, left];
   }
   function right(param){
    var _de_ = param[1];
    if(737457313 === _de_)
     var right = param[2][2];
    else{if(847852583 <= _de_) return 0; var right = param[2];}
    return [0, right];
   }
   function left_value(t, default$0){
    var _dd_ = t[1];
    if(737457313 === _dd_)
     var left = t[2][1];
    else{if(847852583 > _dd_) return default$0; var left = t[2];}
    return left;
   }
   function right_value(t, default$0){
    var _dc_ = t[1];
    if(737457313 === _dc_)
     var right = t[2][2];
    else{if(847852583 <= _dc_) return default$0; var right = t[2];}
    return right;
   }
   function values(t, left_default, right_default){
    var _db_ = t[1];
    if(737457313 === _db_){
     var match = t[2], right = match[2], left = match[1];
     return [0, left, right];
    }
    if(847852583 <= _db_){
     var left$0 = t[2];
     return [0, left$0, right_default];
    }
    var right$0 = t[2];
    return [0, left_default, right$0];
   }
   var
    Merge_element =
      [0,
       compare$0,
       equal$0,
       sexp_of_t$0,
       left,
       right,
       left_value,
       right_value,
       values],
    with_return = Base_With_return[1],
    Duplicate = [248, "Base__Map.Duplicate", caml_fresh_oo_id(0)],
    _a_ = [0, "map.ml.Duplicate"],
    _b_ = [0, cst_src_map_ml, 67, 11];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Duplicate,
     function(param){
      if(param === Duplicate) return _a_;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     });
   var
    cst_of_sorted_array_duplicated = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_duplicated$0 = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_elements_a =
      "of_sorted_array: elements are not ordered",
    cst_Map_bal = cst_Map_bal$3,
    _c_ = [0, cst_src_map_ml, 196, 18],
    cst_Map_bal$0 = cst_Map_bal$3,
    cst_Map_bal$1 = cst_Map_bal$3,
    _d_ = [0, cst_src_map_ml, 210, 18],
    cst_Map_bal$2 = cst_Map_bal$3;
   function height(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var h = param[5];
    return h;
   }
   function in_range(lower, upper, compare_key, k){
    if(lower)
     var
      lower$0 = lower[1],
      _c$_ = caml_call2(compare_key, lower$0, k) < 0 ? 1 : 0;
    else
     var _c$_ = 1;
    if(_c$_){
     if(upper){
      var upper$0 = upper[1];
      return caml_call2(compare_key, k, upper$0) < 0 ? 1 : 0;
     }
     var _da_ = 1;
    }
    else
     var _da_ = _c$_;
    return _da_;
   }
   function loop(lower, upper, compare_key, t){
    var lower$0 = lower, t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){
      var k = t$0[1];
      return in_range(lower$0, upper, compare_key, k);
     }
     var
      h = t$0[5],
      r = t$0[4],
      k$0 = t$0[2],
      l = t$0[1],
      hl = height(l),
      hr = height(r),
      _c4_ = caml_call2(Base_Import[92], hl, hr),
      _c5_ = caml_call1(Base_Import[122], _c4_) <= 2 ? 1 : 0;
     if(_c5_){
      var
       _c6_ = caml_call2(Base_Import[99], hl, hr),
       _c7_ = h === caml_call2(Base_Import[90], _c6_, 1) ? 1 : 0;
      if(_c7_){
       var _c8_ = in_range(lower$0, upper, compare_key, k$0);
       if(_c8_){
        var _c9_ = loop(lower$0, [0, k$0], compare_key, l);
        if(_c9_){
         var lower$1 = [0, k$0];
         lower$0 = lower$1;
         t$0 = r;
         continue;
        }
        var _c__ = _c9_;
       }
       else
        var _c__ = _c8_;
      }
      else
       var _c__ = _c7_;
     }
     else
      var _c__ = _c5_;
     return _c__;
    }
   }
   function invariants(t, compare_key){return loop(0, 0, compare_key, t);}
   function create(l, x, d, r){
    var hl = height(l), hr = height(r);
    if(0 === hl && 0 === hr) return [0, x, d];
    var
     _c3_ =
       hr <= hl
        ? caml_call2(Base_Import[90], hl, 1)
        : caml_call2(Base_Import[90], hr, 1);
    return [1, l, x, d, r, _c3_];
   }
   function of_increasing_iterator_uncheck(len, f){
    function loop(n, f, i){
     if(3 >= n >>> 0)
      switch(n){
        case 0:
         return 0;
        case 1:
         var match$0 = caml_call1(f, i), v$0 = match$0[2], k$0 = match$0[1];
         return [0, k$0, v$0];
        case 2:
         var
          match$1 = caml_call1(f, i),
          vl = match$1[2],
          kl = match$1[1],
          match$2 = caml_call1(f, caml_call2(Base_Import[90], i, 1)),
          v$1 = match$2[2],
          k$1 = match$2[1];
         return [1, [0, kl, vl], k$1, v$1, 0, 2];
        default:
         var
          match$3 = caml_call1(f, i),
          vl$0 = match$3[2],
          kl$0 = match$3[1],
          match$4 = caml_call1(f, caml_call2(Base_Import[90], i, 1)),
          v$2 = match$4[2],
          k$2 = match$4[1],
          match$5 = caml_call1(f, caml_call2(Base_Import[90], i, 2)),
          vr = match$5[2],
          kr = match$5[1];
         return [1, [0, kl$0, vl$0], k$2, v$2, [0, kr, vr], 2];
      }
     var
      left_length = caml_call2(Base_Import[119], n, 1),
      _c1_ = caml_call2(Base_Import[92], n, left_length),
      right_length = caml_call2(Base_Import[92], _c1_, 1),
      left = loop(left_length, f, i),
      match = caml_call1(f, caml_call2(Base_Import[90], i, left_length)),
      v = match[2],
      k = match[1],
      _c2_ = caml_call2(Base_Import[90], i, left_length),
      right = loop(right_length, f, caml_call2(Base_Import[90], _c2_, 1));
     return create(left, k, v, right);
    }
    return loop(len, f, 0);
   }
   function of_sorted_array_unchecked(array, compare_key){
    var array_length = array.length - 1;
    a:
    {
     if(2 <= array_length){
      var
       k0 = caml_check_bound(array, 0)[1][1],
       k1 = caml_check_bound(array, 1)[2][1];
      if(caml_call2(compare_key, k0, k1) >= 0){
       var
        next =
          function(i){
           var
            _cZ_ = caml_call2(Base_Import[92], array_length, 1),
            _c0_ = caml_call2(Base_Import[92], _cZ_, i);
           return caml_check_bound(array, _c0_)[1 + _c0_];
          };
       break a;
      }
     }
     var next = function(i){return caml_check_bound(array, i)[1 + i];};
    }
    return [0,
            of_increasing_iterator_uncheck(array_length, next),
            array_length];
   }
   function of_sorted_array(array, compare_key){
    var len = array.length - 1;
    if(1 !== len && len)
     return caml_call1
             (with_return,
              function(r){
               var
                _cP_ = caml_check_bound(array, 1)[2],
                _cQ_ = caml_call1(Base_Import[124], _cP_),
                _cR_ = caml_check_bound(array, 0)[1],
                i =
                  caml_call2
                   (compare_key, caml_call1(Base_Import[124], _cR_), _cQ_),
                increasing =
                  0 === i
                   ? caml_call1
                     (r,
                      caml_call1
                       (Base_Or_error[36], cst_of_sorted_array_duplicated))
                   : i < 0 ? 1 : 0,
                _cT_ = caml_call2(Base_Import[92], array.length - 1, 2),
                _cS_ = 1;
               if(_cT_ >= 1){
                var i$0 = _cS_;
                for(;;){
                 var
                  _cU_ = caml_call2(Base_Import[90], i$0, 1),
                  _cV_ = caml_check_bound(array, _cU_)[1 + _cU_],
                  _cW_ = caml_call1(Base_Import[124], _cV_),
                  _cX_ = caml_check_bound(array, i$0)[1 + i$0],
                  i$1 =
                    caml_call2
                     (compare_key, caml_call1(Base_Import[124], _cX_), _cW_);
                 if(0 === i$1)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_duplicated$0));
                 else if((i$1 < 0 ? 1 : 0) !== increasing)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_elements_a));
                 var _cY_ = i$0 + 1 | 0;
                 if(_cT_ === i$0) break;
                 i$0 = _cY_;
                }
               }
               return [0, of_sorted_array_unchecked(array, compare_key)];
              });
    return [0, of_sorted_array_unchecked(array, compare_key)];
   }
   function bal(l, x, d, r){
    var hl = height(l), hr = height(r);
    if(caml_call2(Base_Import[90], hr, 2) < hl){
     if(typeof l === "number")
      return caml_call1(Base_Import[125], cst_Map_bal);
     if(0 === l[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     var lr = l[4], ld = l[3], lv = l[2], ll = l[1], _cJ_ = height(lr);
     if(_cJ_ <= height(ll)) return create(ll, lv, ld, create(lr, x, d, r));
     if(typeof lr === "number")
      return caml_call1(Base_Import[125], cst_Map_bal$0);
     if(0 === lr[0]){
      var lrd = lr[2], lrv = lr[1], _cK_ = create(0, x, d, r);
      return create(create(ll, lv, ld, 0), lrv, lrd, _cK_);
     }
     var
      lrr = lr[4],
      lrd$0 = lr[3],
      lrv$0 = lr[2],
      lrl = lr[1],
      _cL_ = create(lrr, x, d, r);
     return create(create(ll, lv, ld, lrl), lrv$0, lrd$0, _cL_);
    }
    if(caml_call2(Base_Import[90], hl, 2) >= hr) return create(l, x, d, r);
    if(typeof r === "number")
     return caml_call1(Base_Import[125], cst_Map_bal$1);
    if(0 === r[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    var rr = r[4], rd = r[3], rv = r[2], rl = r[1], _cM_ = height(rl);
    if(_cM_ <= height(rr)) return create(create(l, x, d, rl), rv, rd, rr);
    if(typeof rl === "number")
     return caml_call1(Base_Import[125], cst_Map_bal$2);
    if(0 === rl[0]){
     var rld = rl[2], rlv = rl[1], _cN_ = create(0, rv, rd, rr);
     return create(create(l, x, d, 0), rlv, rld, _cN_);
    }
    var
     rlr = rl[4],
     rld$0 = rl[3],
     rlv$0 = rl[2],
     rll = rl[1],
     _cO_ = create(rlr, rv, rd, rr);
    return create(create(l, x, d, rll), rlv$0, rld$0, _cO_);
   }
   var
    empty_without_value_restrictio = 0,
    cst_key = cst_key$1,
    cst_Map_add_exn_got_key_alread = "[Map.add_exn] got key already present",
    _e_ = [1, 0],
    cst_Map_singleton_to_tree_exn_ =
      "Map.singleton_to_tree_exn: not a singleton",
    cst_of_increasing_sequence_non =
      "of_increasing_sequence: non-increasing key",
    _f_ = [0, 0, 0, 0],
    _g_ = [0, "Map.find_exn: not found"];
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function raise_key_already_present(key, sexp_of_key){
    var
     _cH_ = [0, [0, cst_key, caml_call1(sexp_of_key, key)], 0],
     _cI_ = caml_call2(Base_Sexp[9], cst_Map_add_exn_got_key_alread, _cH_);
    return caml_call1(Base_Error[30], _cI_);
   }
   function find_and_add_or_set
   (t, length, x, data, compare_key, sexp_of_key, add_or_set){
    if(typeof t === "number")
     return [0, [0, x, data], caml_call2(Base_Import[90], length, 1)];
    if(0 === t[0]){
     var d = t[2], v = t[1], c = caml_call2(compare_key, x, v);
     if(0 === c)
      switch(add_or_set){
        case 0:
         return caml_call1(Base_Exn[6], Duplicate);
        case 1:
         return raise_key_already_present(x, sexp_of_key);
        default: return [0, [0, x, data], length];
      }
     return 0 <= c
             ? [0,
               [1, 0, v, d, [0, x, data], 2],
               caml_call2(Base_Import[90], length, 1)]
             : [0,
               [1, [0, x, data], v, d, 0, 2],
               caml_call2(Base_Import[90], length, 1)];
    }
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     c$0 = caml_call2(compare_key, x, v$0);
    if(0 === c$0)
     switch(add_or_set){
       case 0:
        return caml_call1(Base_Exn[6], Duplicate);
       case 1:
        return raise_key_already_present(x, sexp_of_key);
       default: return [0, [1, l, x, data, r, h], length];
     }
    if(0 <= c$0){
     var
      match =
        find_and_add_or_set
         (r, length, x, data, compare_key, sexp_of_key, add_or_set),
      length$0 = match[2],
      r$0 = match[1];
     return [0, bal(l, v$0, d$0, r$0), length$0];
    }
    var
     match$0 =
       find_and_add_or_set
        (l, length, x, data, compare_key, sexp_of_key, add_or_set),
     length$1 = match$0[2],
     l$0 = match$0[1];
    return [0, bal(l$0, v$0, d$0, r), length$1];
   }
   function add_exn(t, length, key, data, compare_key, sexp_of_key){
    return find_and_add_or_set
            (t, length, key, data, compare_key, sexp_of_key, 1);
   }
   function add_exn_internal(t, length, key, data, compare_key, sexp_of_key){
    return find_and_add_or_set
            (t, length, key, data, compare_key, sexp_of_key, 0);
   }
   function set(t, length, key, data, compare_key){
    return find_and_add_or_set
            (t,
             length,
             key,
             data,
             compare_key,
             function(param){return _e_;},
             2);
   }
   function set$0(t, key, data, compare_key){
    var _cG_ = set(t, 0, key, data, compare_key);
    return caml_call1(Base_Import[124], _cG_);
   }
   function singleton_to_tree_exn(param){
    if(typeof param[1] !== "number")
     return caml_call1(Base_Import[123], cst_Map_singleton_to_tree_exn_);
    var data = param[3], key = param[2];
    return [0, key, data];
   }
   function collapse(l, r){return create(l[1], l[2], l[3], r);}
   function join(l, r){
    var _cE_ = r[3], _cF_ = r[2];
    return [0, collapse(l, r[1]), _cF_, _cE_];
   }
   function go(t, x){
    switch(t[0]){
      case 0:
       return [1, t, x];
      case 1:
       var y = t[2], t$0 = t[1]; return [2, t$0, y, x];
      default:
       var y$0 = t[3], z = t[2], t$1 = t[1];
       return [1, go(t$1, join(z, y$0)), x];
    }
   }
   function add_unchecked(t, key, data){return go(t, [0, 0, key, data]);}
   function go$0(t, r){
    var t$0 = t, r$0 = r;
    for(;;)
     switch(t$0[0]){
       case 0:
        return r$0;
       case 1:
        var l = t$0[2], t$1 = t$0[1], r$1 = collapse(l, r$0);
        t$0 = t$1;
        r$0 = r$1;
        break;
       default:
        var
         l$0 = t$0[3],
         ll = t$0[2],
         t$2 = t$0[1],
         r$2 = collapse(join(ll, l$0), r$0);
        t$0 = t$2;
        r$0 = r$2;
     }
   }
   function to_tree_unchecked(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       var r = param[2], t = param[1];
       return go$0(t, singleton_to_tree_exn(r));
      default:
       var r$0 = param[3], l = param[2], t$0 = param[1];
       return go$0([1, t$0, l], singleton_to_tree_exn(r$0));
    }
   }
   function max_key(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       var r = param[2]; break;
      default: var r = param[3];
    }
    return [0, r[2]];
   }
   function of_increasing_sequence(seq, compare_key){
    return caml_call1
            (with_return,
             function(param){
              var
               match =
                 caml_call3
                  (Base_Sequence[8],
                   seq,
                   [0, empty, 0],
                   function(param$0, _cC_){
                    var
                     data = _cC_[2],
                     key = _cC_[1],
                     length = param$0[2],
                     builder = param$0[1],
                     match = max_key(builder);
                    if(match){
                     var prev_key = match[1];
                     if(0 <= caml_call2(compare_key, prev_key, key))
                      return caml_call1
                              (param,
                               caml_call1
                                (Base_Or_error[36], cst_of_increasing_sequence_non));
                    }
                    var _cD_ = caml_call2(Base_Import[90], length, 1);
                    return [0, add_unchecked(builder, key, data), _cD_];
                   }),
               length = match[2],
               builder = match[1];
              return [0, [0, to_tree_unchecked(builder), length]];
             });
   }
   function join$0(l, k, d, r, compare_key){
    if(typeof l === "number") return set$0(r, k, d, compare_key);
    if(1 === l[0]){
     var lh = l[5], lr = l[4], ld$0 = l[3], lk$0 = l[2], ll = l[1];
     if(typeof r !== "number"){
      if(0 === r[0]){
       var rd = r[2], rk = r[1];
       return set$0(set$0(l, k, d, compare_key), rk, rd, compare_key);
      }
      var rh = r[5], rr = r[4], rd$0 = r[3], rk$0 = r[2], rl = r[1];
      return caml_call2(Base_Import[90], rh, 3) < lh
              ? bal(ll, lk$0, ld$0, join$0(lr, k, d, r, compare_key))
              : caml_call2
                 (Base_Import[90], lh, 3)
                < rh
                ? bal(join$0(l, k, d, rl, compare_key), rk$0, rd$0, rr)
                : bal(l, k, d, r);
     }
    }
    if(typeof r === "number") return set$0(l, k, d, compare_key);
    var ld = l[2], lk = l[1];
    return set$0(set$0(r, k, d, compare_key), lk, ld, compare_key);
   }
   function split(t, x, compare_key){
    if(typeof t === "number") return _f_;
    if(0 === t[0]){
     var d = t[2], k = t[1], cmp = caml_call2(compare_key, x, k);
     return 0 === cmp
             ? [0, 0, [0, [0, k, d]], 0]
             : 0 <= cmp ? [0, t, 0, 0] : [0, 0, 0, t];
    }
    var
     r = t[4],
     d$0 = t[3],
     k$0 = t[2],
     l = t[1],
     cmp$0 = caml_call2(compare_key, x, k$0);
    if(0 === cmp$0) return [0, l, [0, [0, k$0, d$0]], r];
    if(0 <= cmp$0){
     var
      match = split(r, x, compare_key),
      rr = match[3],
      maybe = match[2],
      rl = match[1];
     return [0, join$0(l, k$0, d$0, rl, compare_key), maybe, rr];
    }
    var
     match$0 = split(l, x, compare_key),
     lr = match$0[3],
     maybe$0 = match$0[2],
     ll = match$0[1];
    return [0, ll, maybe$0, join$0(lr, k$0, d$0, r, compare_key)];
   }
   function split_and_reinsert_boundary(t, into, x, compare_key){
    var
     match = split(t, x, compare_key),
     right = match[3],
     boundary_opt = match[2],
     left = match[1];
    if(! boundary_opt) return [0, left, right];
    var match$0 = boundary_opt[1], data = match$0[2], key = match$0[1];
    function insert_into(tree){
     var _cB_ = set(tree, 0, key, data, compare_key);
     return caml_call1(Base_Import[124], _cB_);
    }
    return 847852583 <= into
            ? [0, insert_into(left), right]
            : [0, left, insert_into(right)];
   }
   function split_range(t, lower_bound, upper_bound, compare_key){
    if(caml_call3(Base_Maybe_bound[9], lower_bound, upper_bound, compare_key))
     return [0,
             empty_without_value_restrictio,
             empty_without_value_restrictio,
             empty_without_value_restrictio];
    if(typeof lower_bound === "number")
     var mid_and_right = t, left = empty_without_value_restrictio;
    else if(0 === lower_bound[0])
     var
      lb$1 = lower_bound[1],
      _cz_ = split_and_reinsert_boundary(t, -57574468, lb$1, compare_key),
      mid_and_right = _cz_[2],
      left = _cz_[1];
    else
     var
      lb$2 = lower_bound[1],
      _cA_ = split_and_reinsert_boundary(t, 847852583, lb$2, compare_key),
      mid_and_right$0 = _cA_[2],
      left$0 = _cA_[1],
      mid_and_right = mid_and_right$0,
      left = left$0;
    if(typeof upper_bound === "number")
     var right = empty_without_value_restrictio, mid = mid_and_right;
    else if(0 === upper_bound[0])
     var
      lb = upper_bound[1],
      _cx_ =
        split_and_reinsert_boundary(mid_and_right, 847852583, lb, compare_key),
      right = _cx_[2],
      mid = _cx_[1];
    else
     var
      lb$0 = upper_bound[1],
      _cy_ =
        split_and_reinsert_boundary
         (mid_and_right, -57574468, lb$0, compare_key),
      right$0 = _cy_[2],
      mid$0 = _cy_[1],
      right = right$0,
      mid = mid$0;
    return [0, left, mid, right];
   }
   function find(t, x, compare_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return 0 === caml_call2(compare_key, x, v) ? [0, d] : 0;
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c) return [0, d$0];
     var r$0 = 0 <= c ? r : l;
     t$0 = r$0;
    }
   }
   function add_multi(t, length, key, data, compare_key){
    var
     _cw_ = find(t, key, compare_key),
     data$0 = [0, data, caml_call2(Base_Option[27], _cw_, 0)];
    return set(t, length, key, data$0, compare_key);
   }
   function find_multi(t, x, compare_key){
    var match = find(t, x, compare_key);
    if(! match) return 0;
    var l = match[1];
    return l;
   }
   function if_not_found(key, sexp_of_key){
    var _cv_ = [1, [0, _g_, [0, caml_call1(sexp_of_key, key), 0]]];
    throw caml_maybe_attach_backtrace([0, Base_Import[251], _cv_], 1);
   }
   function find_exn(t, x, compare_key, sexp_of_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return if_not_found(x, sexp_of_key);
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return 0 === caml_call2(compare_key, x, v)
              ? d
              : if_not_found(x, sexp_of_key);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c) return d$0;
     var r$0 = 0 <= c ? r : l;
     t$0 = r$0;
    }
   }
   function mem(t, x, compare_key){
    var _cu_ = find(t, x, compare_key);
    return caml_call1(Base_Option[50], _cu_);
   }
   function min_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var d = param$0[2], k = param$0[1];
      return [0, [0, k, d]];
     }
     var l = param$0[1];
     if(typeof l === "number"){
      var d$0 = param$0[3], k$0 = param$0[2];
      return [0, [0, k$0, d$0]];
     }
     param$0 = l;
    }
   }
   var
    Map_min_elt_exn_of_empty_map =
      [248,
       "Base__Map.Tree0.Map_min_elt_exn_of_empty_map",
       caml_fresh_oo_id(0)],
    _h_ = [0, "map.ml.Tree0.Map_min_elt_exn_of_empty_map"],
    _i_ = [0, cst_src_map_ml, 534, 15];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Map_min_elt_exn_of_empty_map,
     function(param){
      if(param === Map_min_elt_exn_of_empty_map) return _h_;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     });
   var
    Map_max_elt_exn_of_empty_map =
      [248,
       "Base__Map.Tree0.Map_max_elt_exn_of_empty_map",
       caml_fresh_oo_id(0)],
    _j_ = [0, "map.ml.Tree0.Map_max_elt_exn_of_empty_map"],
    _k_ = [0, cst_src_map_ml, 547, 15];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Map_max_elt_exn_of_empty_map,
     function(param){
      if(param === Map_max_elt_exn_of_empty_map) return _j_;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
     });
   var cst_Map_remove_min_elt = "Map.remove_min_elt";
   function min_elt_exn(t){
    var match = min_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Map_min_elt_exn_of_empty_map, 1);
    var v = match[1];
    return v;
   }
   function max_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var d = param$0[2], k = param$0[1];
      return [0, [0, k, d]];
     }
     if(typeof param$0[4] === "number"){
      var d$0 = param$0[3], k$0 = param$0[2];
      return [0, [0, k$0, d$0]];
     }
     var r = param$0[4];
     param$0 = r;
    }
   }
   function max_elt_exn(t){
    var match = max_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Map_max_elt_exn_of_empty_map, 1);
    var v = match[1];
    return v;
   }
   function remove_min_elt(t){
    if(typeof t === "number")
     return caml_call1(Base_Import[125], cst_Map_remove_min_elt);
    if(0 === t[0]) return 0;
    var l = t[1];
    if(typeof l === "number"){var r = t[4]; return r;}
    var r$0 = t[4], d = t[3], x = t[2];
    return bal(remove_min_elt(l), x, d, r$0);
   }
   function append(lower_part, upper_part, compare_key){
    var match = max_elt(lower_part), match$0 = min_elt(upper_part);
    if(! match) return [0, 17724, upper_part];
    if(! match$0) return [0, 17724, lower_part];
    var
     _ct_ = match$0[1],
     v = _ct_[2],
     min_upper = _ct_[1],
     max_lower = match[1][1];
    if(0 <= caml_call2(compare_key, max_lower, min_upper)) return 838882908;
    var upper_part_without_min = remove_min_elt(upper_part);
    return [0,
            17724,
            join$0
             (lower_part, min_upper, v, upper_part_without_min, compare_key)];
   }
   function go$1(t, min, max, init, f, compare_key){
    var t$0 = t, init$0 = init;
    for(;;){
     if(typeof t$0 === "number") return init$0;
     if(0 === t$0[0]){
      var d = t$0[2], k = t$0[1];
      if
       (0 <= caml_call2(compare_key, k, min)
        && 0 >= caml_call2(compare_key, k, max))
       return caml_call3(f, k, d, init$0);
      return init$0;
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      k$0 = t$0[2],
      l = t$0[1],
      c_min = caml_call2(compare_key, k$0, min);
     if(0 <= c_min)
      if(0 === c_min){
       var init$1 = caml_call3(f, k$0, d$0, init$0);
       t$0 = r;
       init$0 = init$1;
      }
      else{
       var
        z = go$1(l, min, max, init$0, f, compare_key),
        c_max = caml_call2(compare_key, k$0, max);
       if(0 < c_max) return z;
       var init$2 = caml_call3(f, k$0, d$0, z);
       if(0 === c_max) return init$2;
       t$0 = r;
       init$0 = init$2;
      }
     else
      t$0 = r;
    }
   }
   function fold_range_inclusive(t, min, max, init, f, compare_key){
    return 0 < caml_call2(compare_key, min, max)
            ? init
            : go$1(t, min, max, init, f, compare_key);
   }
   function range_to_alist(t, min, max, compare_key){
    var
     _cs_ =
       fold_range_inclusive
        (t,
         min,
         max,
         0,
         function(key, data, l){return [0, [0, key, data], l];},
         compare_key);
    return caml_call1(Base_List0[21], _cs_);
   }
   function concat_unchecked(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var match = min_elt_exn(t2), d = match[2], x = match[1];
    return bal(t1, x, d, remove_min_elt(t2));
   }
   var
    Remove_no_op = [248, "Base__Map.Tree0.Remove_no_op", caml_fresh_oo_id(0)];
   function remove(t, x, length, compare_key){
    function remove_loop(t, x, length, compare_key){
     if(typeof t === "number") return caml_call1(Base_Exn[6], Remove_no_op);
     if(0 === t[0]){
      var v = t[1];
      return 0 === caml_call2(compare_key, x, v)
              ? [0, 0, caml_call2(Base_Import[92], length, 1)]
              : caml_call1(Base_Exn[6], Remove_no_op);
     }
     var
      r = t[4],
      d = t[3],
      v$0 = t[2],
      l = t[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c){
      var _cr_ = caml_call2(Base_Import[92], length, 1);
      return [0, concat_unchecked(l, r), _cr_];
     }
     if(0 <= c){
      var
       match = remove_loop(r, x, length, compare_key),
       length$0 = match[2],
       r$0 = match[1];
      return [0, bal(l, v$0, d, r$0), length$0];
     }
     var
      match$0 = remove_loop(l, x, length, compare_key),
      length$1 = match$0[2],
      l$0 = match$0[1];
     return [0, bal(l$0, v$0, d, r), length$1];
    }
    try{var _cp_ = remove_loop(t, x, length, compare_key); return _cp_;}
    catch(_cq_){
     var _co_ = caml_wrap_exception(_cq_);
     if(_co_ === Remove_no_op) return [0, t, length];
     throw caml_maybe_attach_backtrace(_co_, 0);
    }
   }
   var
    Change_no_op = [248, "Base__Map.Tree0.Change_no_op", caml_fresh_oo_id(0)],
    _l_ = [0, 0, 0],
    _m_ = [0, 0, 0],
    _n_ = [0, 0, 0],
    _o_ = [0, 0, 0],
    _p_ = [0, 0, 0],
    _q_ = [0, [0, 0, 0], [0, 0, 0]],
    cst_or_error_duplicate_key = "_or_error: duplicate key",
    cst_Map_of = cst_Map_of$1,
    cst_exn_duplicate_key = "_exn: duplicate key",
    cst_Map_of$0 = cst_Map_of$1;
   function change(t, key, f, length, compare_key){
    function change_core(t, key, f){
     if(typeof t === "number"){
      var match = caml_call1(f, 0);
      if(! match) throw caml_maybe_attach_backtrace(Change_no_op, 1);
      var data = match[1];
      return [0, [0, key, data], caml_call2(Base_Import[90], length, 1)];
     }
     if(0 === t[0]){
      var d = t[2], v = t[1], c = caml_call2(compare_key, key, v);
      if(0 === c){
       var match$0 = caml_call1(f, [0, d]);
       if(! match$0) return [0, 0, caml_call2(Base_Import[92], length, 1)];
       var d$0 = match$0[1];
       return [0, [0, v, d$0], length];
      }
      if(0 <= c){
       var
        match$1 = change_core(0, key, f),
        length$0 = match$1[2],
        r = match$1[1];
       return [0, bal(0, v, d, r), length$0];
      }
      var
       match$2 = change_core(0, key, f),
       length$1 = match$2[2],
       l = match$2[1];
      return [0, bal(l, v, d, 0), length$1];
     }
     var
      h = t[5],
      r$0 = t[4],
      d$1 = t[3],
      v$0 = t[2],
      l$0 = t[1],
      c$0 = caml_call2(compare_key, key, v$0);
     if(0 === c$0){
      var match$3 = caml_call1(f, [0, d$1]);
      if(match$3){
       var data$0 = match$3[1];
       return [0, [1, l$0, key, data$0, r$0, h], length];
      }
      var _cn_ = caml_call2(Base_Import[92], length, 1);
      return [0, concat_unchecked(l$0, r$0), _cn_];
     }
     if(0 <= c$0){
      var
       match$4 = change_core(r$0, key, f),
       length$2 = match$4[2],
       r$1 = match$4[1];
      return [0, bal(l$0, v$0, d$1, r$1), length$2];
     }
     var
      match$5 = change_core(l$0, key, f),
      length$3 = match$5[2],
      l$1 = match$5[1];
     return [0, bal(l$1, v$0, d$1, r$0), length$3];
    }
    try{var _cl_ = change_core(t, key, f); return _cl_;}
    catch(_cm_){
     var _ck_ = caml_wrap_exception(_cm_);
     if(_ck_ === Change_no_op) return [0, t, length];
     throw caml_maybe_attach_backtrace(_ck_, 0);
    }
   }
   function update(t, key, f, length, compare_key){
    function update_core(t, key, f){
     if(typeof t === "number"){
      var data = caml_call1(f, 0);
      return [0, [0, key, data], caml_call2(Base_Import[90], length, 1)];
     }
     if(0 === t[0]){
      var d = t[2], v = t[1], c = caml_call2(compare_key, key, v);
      if(0 === c){
       var d$0 = caml_call1(f, [0, d]);
       return [0, [0, v, d$0], length];
      }
      if(0 <= c){
       var match = update_core(0, key, f), length$0 = match[2], r = match[1];
       return [0, bal(0, v, d, r), length$0];
      }
      var
       match$0 = update_core(0, key, f),
       length$1 = match$0[2],
       l = match$0[1];
      return [0, bal(l, v, d, 0), length$1];
     }
     var
      h = t[5],
      r$0 = t[4],
      d$1 = t[3],
      v$0 = t[2],
      l$0 = t[1],
      c$0 = caml_call2(compare_key, key, v$0);
     if(0 === c$0){
      var data$0 = caml_call1(f, [0, d$1]);
      return [0, [1, l$0, key, data$0, r$0, h], length];
     }
     if(0 <= c$0){
      var
       match$1 = update_core(r$0, key, f),
       length$2 = match$1[2],
       r$1 = match$1[1];
      return [0, bal(l$0, v$0, d$1, r$1), length$2];
     }
     var
      match$2 = update_core(l$0, key, f),
      length$3 = match$2[2],
      l$1 = match$2[1];
     return [0, bal(l$1, v$0, d$1, r$0), length$3];
    }
    return update_core(t, key, f);
   }
   function remove_multi(t, key, length, compare_key){
    return change
            (t,
             key,
             function(param){
              if(param){
               var _cj_ = param[1];
               if(_cj_){
                var non_empty_tail = _cj_[2];
                if(non_empty_tail) return [0, non_empty_tail];
               }
              }
              return 0;
             },
             length,
             compare_key);
   }
   function iter_keys(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v);}
     var r = t$0[4], v$0 = t$0[2], l = t$0[1];
     iter_keys(l, f);
     caml_call1(f, v$0);
     t$0 = r;
    }
   }
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2]; return caml_call1(f, d);}
     var r = t$0[4], d$0 = t$0[3], l = t$0[1];
     iter(l, f);
     caml_call1(f, d$0);
     t$0 = r;
    }
   }
   function iteri(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return caml_call2(f, v, d);}
     var r = t$0[4], d$0 = t$0[3], v$0 = t$0[2], l = t$0[1];
     iteri(l, f);
     caml_call2(f, v$0, d$0);
     t$0 = r;
    }
   }
   function iteri_until_loop(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return caml_call2(f, v, d);}
     var r = t$0[4], d$0 = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(iteri_until_loop(l, f)) return 1;
     if(caml_call2(f, v$0, d$0)) return 1;
     t$0 = r;
    }
   }
   function iteri_until(t, f){
    var _ci_ = iteri_until_loop(t, f);
    return caml_call1(Finished_or_unfinished[5], _ci_);
   }
   function map(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var d = t[2], v = t[1]; return [0, v, caml_call1(f, d)];}
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = map(l, f),
     d$1 = caml_call1(f, d$0),
     r$0 = map(r, f);
    return [1, l$0, v$0, d$1, r$0, h];
   }
   function mapi(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return [0, v, caml_call2(f, v, d)];
    }
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = mapi(l, f),
     d$1 = caml_call2(f, v$0, d$0),
     r$0 = mapi(r, f);
    return [1, l$0, v$0, d$1, r$0, h];
   }
   function fold(t, accu, f){
    var t$0 = t, accu$0 = accu;
    for(;;){
     if(typeof t$0 === "number") return accu$0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return caml_call3(f, v, d, accu$0);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      accu$1 = caml_call3(f, v$0, d$0, fold(l, accu$0, f));
     t$0 = r;
     accu$0 = accu$1;
    }
   }
   function fold_until(t, init, f, finish){
    function fold_until_loop(t, acc, f){
     var t$0 = t, acc$0 = acc;
     for(;;){
      if(typeof t$0 === "number") return [0, acc$0];
      if(0 === t$0[0]){
       var d = t$0[2], v = t$0[1];
       return caml_call3(f, v, d, acc$0);
      }
      var
       r = t$0[4],
       d$0 = t$0[3],
       v$0 = t$0[2],
       l = t$0[1],
       match = fold_until_loop(l, acc$0, f);
      if(0 !== match[0]){var final$1 = match[1]; return [1, final$1];}
      var acc$1 = match[1], match$0 = caml_call3(f, v$0, d$0, acc$1);
      if(0 !== match$0[0]){var final$0 = match$0[1]; return [1, final$0];}
      var acc$2 = match$0[1];
      t$0 = r;
      acc$0 = acc$2;
     }
    }
    var match = fold_until_loop(t, init, f);
    if(0 === match[0]){var acc = match[1]; return caml_call1(finish, acc);}
    var stop = match[1];
    return stop;
   }
   function fold_right(t, accu, f){
    var t$0 = t, accu$0 = accu;
    for(;;){
     if(typeof t$0 === "number") return accu$0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return caml_call3(f, v, d, accu$0);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      accu$1 = caml_call3(f, v$0, d$0, fold_right(r, accu$0, f));
     t$0 = l;
     accu$0 = accu$1;
    }
   }
   function filter_keys(t, f, compare_key){
    return fold
            (t,
             _l_,
             function(key, data, param){
              var length = param[2], accu = param[1];
              return caml_call1(f, key)
                      ? set(accu, length, key, data, compare_key)
                      : [0, accu, length];
             });
   }
   function filter(t, f, compare_key){
    return fold
            (t,
             _m_,
             function(key, data, param){
              var length = param[2], accu = param[1];
              return caml_call1(f, data)
                      ? set(accu, length, key, data, compare_key)
                      : [0, accu, length];
             });
   }
   function filteri(t, f, compare_key){
    return fold
            (t,
             _n_,
             function(key, data, param){
              var length = param[2], accu = param[1];
              return caml_call2(f, key, data)
                      ? set(accu, length, key, data, compare_key)
                      : [0, accu, length];
             });
   }
   function filter_map(t, f, compare_key){
    return fold
            (t,
             _o_,
             function(key, data, param){
              var
               length = param[2],
               accu = param[1],
               match = caml_call1(f, data);
              if(! match) return [0, accu, length];
              var b = match[1];
              return set(accu, length, key, b, compare_key);
             });
   }
   function filter_mapi(t, f, compare_key){
    return fold
            (t,
             _p_,
             function(key, data, param){
              var
               length = param[2],
               accu = param[1],
               match = caml_call2(f, key, data);
              if(! match) return [0, accu, length];
              var b = match[1];
              return set(accu, length, key, b, compare_key);
             });
   }
   function partition_mapi(t, f, compare_key){
    return fold
            (t,
             _q_,
             function(key, data, param){
              var
               pair2 = param[2],
               pair1 = param[1],
               match = caml_call2(f, key, data);
              if(0 === match[0]){
               var x = match[1], length = pair1[2], t = pair1[1];
               return [0, set(t, length, key, x, compare_key), pair2];
              }
              var y = match[1], length$0 = pair2[2], t$0 = pair2[1];
              return [0, pair1, set(t$0, length$0, key, y, compare_key)];
             });
   }
   function partition_map(t, f, compare_key){
    return partition_mapi
            (t,
             function(param, data){return caml_call1(f, data);},
             compare_key);
   }
   function partitioni_tf(t, f, compare_key){
    return partition_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : [1, data];
             },
             compare_key);
   }
   function partition_tf(t, f, compare_key){
    return partition_mapi
            (t,
             function(param, data){
              return caml_call1(f, data) ? [0, data] : [1, data];
             },
             compare_key);
   }
   function cons(t, e){
    var t$0 = t, e$0 = e;
    for(;;){
     if(typeof t$0 === "number") return e$0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return [0, v, d, 0, e$0];}
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      e$1 = [0, v$0, d$0, r, e$0];
     t$0 = l;
     e$0 = e$1;
    }
   }
   function cons_right(t, e){
    var t$0 = t, e$0 = e;
    for(;;){
     if(typeof t$0 === "number") return e$0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return [0, v, d, 0, e$0];}
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      e$1 = [0, v$0, d$0, l, e$0];
     t$0 = r;
     e$0 = e$1;
    }
   }
   function of_tree(tree){return cons(tree, 0);}
   function fold$0(init, f, param){
    var init$0 = init, param$0 = param;
    for(;;){
     if(! param$0) return init$0;
     var
      enum$0 = param$0[4],
      tree = param$0[3],
      data = param$0[2],
      key = param$0[1],
      next = caml_call3(f, key, data, init$0);
     init$0 = next;
     param$0 = cons(tree, enum$0);
    }
   }
   function fold2(compare_key, t1, t2, init, f){
    a:
    {
     var t1$0 = t1, t2$0 = t2, curr = init;
     for(;;){
      if(! t1$0) break;
      if(! t2$0) break a;
      var
       enum2 = t2$0[4],
       tree2 = t2$0[3],
       v2 = t2$0[2],
       k2 = t2$0[1],
       enum1 = t1$0[4],
       tree1 = t1$0[3],
       v1 = t1$0[2],
       k1 = t1$0[1],
       compare_result = caml_call2(compare_key, k1, k2);
      if(0 === compare_result){
       var
        next = caml_call3(f, k1, [0, 737457313, [0, v1, v2]], curr),
        t2$1 = cons(tree2, enum2),
        t1$1 = cons(tree1, enum1);
       t1$0 = t1$1;
       t2$0 = t2$1;
       curr = next;
      }
      else if(0 <= compare_result){
       var
        next$0 = caml_call3(f, k2, [0, -57574468, v2], curr),
        t2$2 = cons(tree2, enum2);
       t2$0 = t2$2;
       curr = next$0;
      }
      else{
       var
        next$1 = caml_call3(f, k1, [0, 847852583, v1], curr),
        t1$2 = cons(tree1, enum1);
       t1$0 = t1$2;
       curr = next$1;
      }
     }
     return t2$0
             ? fold$0
               (curr,
                function(key, data, acc){
                 return caml_call3(f, key, [0, -57574468, data], acc);
                },
                t2$0)
             : curr;
    }
    return fold$0
            (curr,
             function(key, data, acc){
              return caml_call3(f, key, [0, 847852583, data], acc);
             },
             t1$0);
   }
   function symmetric_diff(t1, t2, compare_key, data_equal){
    function step(state){
     var left = state[1];
     if(! left){
      var match = state[2];
      if(! match) return 0;
      var
       enum$0 = match[4],
       tree = match[3],
       data$0 = match[2],
       key$0 = match[1];
      return [1,
              [0, key$0, [0, -57574468, data$0]],
              [0, 0, cons(tree, enum$0)]];
     }
     var
      right = state[2],
      enum1 = left[4],
      tree1 = left[3],
      data = left[2],
      key = left[1];
     if(! right)
      return [1, [0, key, [0, 847852583, data]], [0, cons(tree1, enum1), 0]];
     var
      enum2 = right[4],
      tree2 = right[3],
      v2 = right[2],
      k2 = right[1],
      compare_result = caml_call2(compare_key, key, k2);
     if(0 !== compare_result)
      return 0 <= compare_result
              ? [1,
                [0, k2, [0, -57574468, v2]],
                [0, left, cons(tree2, enum2)]]
              : [1,
                [0, key, [0, 847852583, data]],
                [0, cons(tree1, enum1), right]];
     if(caml_call2(Base_Import[127], tree1, tree2))
      var next_state = [0, enum1, enum2];
     else
      var
       _ch_ = cons(tree2, enum2),
       next_state = [0, cons(tree1, enum1), _ch_];
     return caml_call2(data_equal, data, v2)
             ? [0, next_state]
             : [1, [0, key, [0, 1013247643, [0, data, v2]]], next_state];
    }
    var _cf_ = of_tree(t2), _cg_ = [0, of_tree(t1), _cf_];
    return caml_call2(Base_Sequence[41], _cg_, step);
   }
   function to_sequence
   (comparator, opt, keys_greater_or_equal_to, keys_less_or_equal_to, t$3){
    if(opt) var sth = opt[1], order = sth; else var order = -542431297;
    function inclusive_bound(side, t, bound){
     var
      compare_key = comparator[1],
      match = split(t, bound, compare_key),
      r = match[3],
      maybe = match[2],
      l = match[1],
      t$0 = caml_call1(side, [0, l, r]);
     if(! maybe) return t$0;
     var match$0 = maybe[1], data = match$0[2], key = match$0[1];
     return set$0(t$0, key, data, compare_key);
    }
    if(511974747 <= order){
     var
      _b$_ = Base_Import[126],
      tree =
        caml_call3
         (Base_Option[31],
          keys_greater_or_equal_to,
          t$3,
          function(_cd_, _ce_){return inclusive_bound(_b$_, _cd_, _ce_);}),
      next$0 =
        function(enum$0){
         if(! enum$0) return 0;
         var e = enum$0[4], t = enum$0[3], v = enum$0[2], k = enum$0[1];
         return [1, [0, k, v], cons_right(t, e)];
        };
     if(keys_less_or_equal_to){
      var
       key$0 = keys_less_or_equal_to[1],
       compare$0 = comparator[1],
       t$1 = tree,
       e$1 = 0;
      for(;;){
       if(typeof t$1 === "number"){var init$0 = e$1; break;}
       if(0 === t$1[0]){
        var d$1 = t$1[2], v$2 = t$1[1], t$2 = [1, 0, v$2, d$1, 0, 1];
        t$1 = t$2;
       }
       else{
        var l$0 = t$1[1], v$3 = t$1[2];
        if(0 < caml_call2(compare$0, v$3, key$0))
         t$1 = l$0;
        else{
         var
          r$1 = t$1[4],
          d$2 = t$1[3],
          v$4 = t$1[2],
          e$2 = [0, v$4, d$2, l$0, e$1];
         t$1 = r$1;
         e$1 = e$2;
        }
       }
      }
     }
     else
      var init$0 = cons_right(tree, 0);
     return caml_call2(Base_Sequence[41], init$0, next$0);
    }
    var
     _ca_ = Base_Import[124],
     t$4 =
       caml_call3
        (Base_Option[31],
         keys_less_or_equal_to,
         t$3,
         function(_cb_, _cc_){return inclusive_bound(_ca_, _cb_, _cc_);});
    function next(enum$0){
     if(! enum$0) return 0;
     var e = enum$0[4], t = enum$0[3], v = enum$0[2], k = enum$0[1];
     return [1, [0, k, v], cons(t, e)];
    }
    if(keys_greater_or_equal_to){
     var
      key = keys_greater_or_equal_to[1],
      compare = comparator[1],
      t = t$4,
      e = 0;
     for(;;){
      if(typeof t === "number"){var init = e; break;}
      if(0 === t[0]){
       var d = t[2], v = t[1], t$0 = [1, 0, v, d, 0, 1];
       t = t$0;
      }
      else{
       var l = t[1], r = t[4], v$0 = t[2];
       if(0 <= caml_call2(compare, v$0, key)){
        var r$0 = t[4], d$0 = t[3], v$1 = t[2], e$0 = [0, v$1, d$0, r$0, e];
        t = l;
        e = e$0;
       }
       else
        t = r;
      }
     }
    }
    else
     var init = of_tree(t$4);
    return caml_call2(Base_Sequence[41], init, next);
   }
   function compare$1(compare_key, compare_data, t1$1, t2$1){
    var t2$2 = of_tree(t2$1), t1$2 = of_tree(t1$1), t1 = t1$2, t2 = t2$2;
    for(;;){
     if(! t1) return t2 ? -1 : 0;
     if(! t2) return 1;
     var
      e2 = t2[4],
      r2 = t2[3],
      d2 = t2[2],
      v2 = t2[1],
      e1 = t1[4],
      r1 = t1[3],
      d1 = t1[2],
      v1 = t1[1],
      c = caml_call2(compare_key, v1, v2);
     if(0 !== c) return c;
     var c$0 = caml_call2(compare_data, d1, d2);
     if(0 !== c$0) return c$0;
     if(caml_call2(Base_Import[127], r1, r2)){t1 = e1; t2 = e2;}
     else{var t2$0 = cons(r2, e2), t1$0 = cons(r1, e1); t1 = t1$0; t2 = t2$0;}
    }
   }
   function equal$1(compare_key, compare_data, t1$1, t2$1){
    var t2$2 = of_tree(t2$1), t1$2 = of_tree(t1$1), t1 = t1$2, t2 = t2$2;
    for(;;){
     if(t1){
      if(t2){
       var
        e2 = t2[4],
        r2 = t2[3],
        d2 = t2[2],
        v2 = t2[1],
        e1 = t1[4],
        r1 = t1[3],
        d1 = t1[2],
        v1 = t1[1],
        _b8_ = 0 === caml_call2(compare_key, v1, v2) ? 1 : 0;
       if(_b8_){
        var _b9_ = caml_call2(compare_data, d1, d2);
        if(_b9_){
         if(caml_call2(Base_Import[127], r1, r2)){t1 = e1; t2 = e2; continue;}
         var t2$0 = cons(r2, e2), t1$0 = cons(r1, e1);
         t1 = t1$0;
         t2 = t2$0;
         continue;
        }
        var _b__ = _b9_;
       }
       else
        var _b__ = _b8_;
       return _b__;
      }
     }
     else if(! t2) return 1;
     return 0;
    }
   }
   function iter2(t1, t2, f, compare_key){
    var _b7_ = of_tree(t2);
    return fold2
            (compare_key,
             of_tree(t1),
             _b7_,
             0,
             function(key, data, param){return caml_call2(f, key, data);});
   }
   function fold2$0(t1, t2, init, f, compare_key){
    var _b6_ = of_tree(t2);
    return fold2(compare_key, of_tree(t1), _b6_, init, f);
   }
   function fold_symmetric_diff(t1, t2, compare_key, data_equal, init, f){
    function add(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, -57574468, v]]);
    }
    function remove(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, 847852583, v]]);
    }
    function delta(acc, k, v$0, v){
     return caml_call2(data_equal, v$0, v)
             ? acc
             : caml_call2(f, acc, [0, k, [0, 1013247643, [0, v$0, v]]]);
    }
    function loop(t$0, t, acc$3){
     var t1 = t$0, t2 = t, init = acc$3;
     for(;;){
      if(caml_call2(Base_Import[127], t1, t2)) return init;
      if(typeof t1 === "number")
       return fold
               (t2,
                init,
                function(key, data, acc){return add(acc, key, data);});
      a:
      {
       if(0 === t1[0]){
        var v = t1[2], k = t1[1];
        if(typeof t2 === "number") break a;
        if(0 === t2[0]){
         var v$0 = t2[2], k$0 = t2[1], x = caml_call2(compare_key, k, k$0);
         if(0 === x) return delta(init, k, v, v$0);
         if(0 <= x){
          var acc$4 = add(init, k$0, v$0);
          return remove(acc$4, k, v);
         }
         var acc$5 = remove(init, k, v);
         return add(acc$5, k$0, v$0);
        }
       }
       else{
        var r = t1[4], v$1 = t1[3], k$1 = t1[2], l = t1[1];
        if(typeof t2 === "number") break a;
        if(0 !== t2[0]){
         var l$0 = t2[1], r$0 = t2[4], v$2 = t2[3], k$2 = t2[2];
         if(0 === caml_call2(compare_key, k$1, k$2)){
          var acc$6 = loop(l, l$0, init), acc$7 = delta(acc$6, k$1, v$1, v$2);
          t1 = r;
          t2 = r$0;
          init = acc$7;
          continue;
         }
        }
       }
       var
        add$0 =
          function(acc, k, v){
           return caml_call2(f, acc, [0, k, [0, -57574468, v]]);
          },
        remove$0 =
          function(acc, k, v){
           return caml_call2(f, acc, [0, k, [0, 847852583, v]]);
          },
        right$2 = of_tree(t2),
        left$2 = of_tree(t1);
       b:
       {
        var left = left$2, right = right$2, acc = init;
        for(;;){
         if(! left) break;
         if(! right) break b;
         var
          enum2 = right[4],
          tree2 = right[3],
          v2 = right[2],
          k2 = right[1],
          enum1 = left[4],
          tree1 = left[3],
          v1 = left[2],
          k1 = left[1],
          compare_result = caml_call2(compare_key, k1, k2);
         if(0 === compare_result){
          var
           acc$0 =
             caml_call2(data_equal, v1, v2)
              ? acc
              : caml_call2(f, acc, [0, k1, [0, 1013247643, [0, v1, v2]]]);
          if(caml_call2(Base_Import[127], tree1, tree2)){left = enum1; right = enum2; acc = acc$0;}
          else{
           var right$0 = cons(tree2, enum2), left$0 = cons(tree1, enum1);
           left = left$0;
           right = right$0;
           acc = acc$0;
          }
         }
         else if(0 <= compare_result){
          var acc$1 = add$0(acc, k2, v2), right$1 = cons(tree2, enum2);
          right = right$1;
          acc = acc$1;
         }
         else{
          var acc$2 = remove$0(acc, k1, v1), left$1 = cons(tree1, enum1);
          left = left$1;
          acc = acc$2;
         }
        }
        return fold$0
                (acc,
                 function(key, data, acc){return add$0(acc, key, data);},
                 right);
       }
       return fold$0
               (acc,
                function(key, data, acc){return remove$0(acc, key, data);},
                left);
      }
      return fold
              (t1,
               init,
               function(key, data, acc){return remove(acc, key, data);});
     }
    }
    return loop(t1, t2, init);
   }
   function length(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var
     r = param[4],
     l = param[1],
     _b3_ = length(r),
     _b4_ = length(l),
     _b5_ = caml_call2(Base_Import[90], _b4_, _b3_);
    return caml_call2(Base_Import[90], _b5_, 1);
   }
   function keys(t){
    return fold_right
            (t, 0, function(key, param, list){return [0, key, list];});
   }
   function data(t){
    return fold_right
            (t, 0, function(param, data, list){return [0, data, list];});
   }
   function Of_foldable(M){
    function of_foldable_fold(foldable, init, f, compare_key){
     return caml_call3
             (M[2],
              foldable,
              [0, empty_without_value_restrictio, 0],
              function(param, _b2_){
               var
                data = _b2_[2],
                key = _b2_[1],
                length = param[2],
                accum = param[1],
                match = find(accum, key, compare_key);
               if(match)
                var prev = match[1], prev_data = prev;
               else
                var prev_data = init;
               var data$0 = caml_call2(f, prev_data, data);
               return set(accum, length, key, data$0, compare_key);
              });
    }
    function of_foldable_reduce(foldable, f, compare_key){
     return caml_call3
             (M[2],
              foldable,
              [0, empty_without_value_restrictio, 0],
              function(param, _b1_){
               var
                data = _b1_[2],
                key = _b1_[1],
                length = param[2],
                accum = param[1],
                match = find(accum, key, compare_key);
               if(match)
                var prev = match[1], new_data = caml_call2(f, prev, data);
               else
                var new_data = data;
               return set(accum, length, key, new_data, compare_key);
              });
    }
    function of_foldable(foldable, compare_key){
     return caml_call1
             (with_return,
              function(r){
               var
                map =
                  caml_call3
                   (M[2],
                    foldable,
                    [0, empty_without_value_restrictio, 0],
                    function(param, _b0_){
                     var
                      data = _b0_[2],
                      key = _b0_[1],
                      length = param[2],
                      t = param[1],
                      acc = set(t, length, key, data, compare_key),
                      length$0 = acc[2];
                     return length === length$0
                             ? caml_call1(r, [0, -1048878709, key])
                             : acc;
                    });
               return [0, 17724, map];
              });
    }
    function of_foldable_or_error(foldable, comparator){
     var match = of_foldable(foldable, comparator[1]);
     if(17724 <= match[1]){var x = match[2]; return [0, x];}
     var
      key = match[2],
      _bX_ = comparator[2],
      _bY_ = caml_call2(Base_Import[111], M[1], cst_or_error_duplicate_key),
      _bZ_ = caml_call2(Base_Import[111], cst_Map_of, _bY_);
     return caml_call5(Base_Or_error[34], 0, 0, _bZ_, key, _bX_);
    }
    function of_foldable_exn(foldable, comparator){
     var match = of_foldable(foldable, comparator[1]);
     if(17724 <= match[1]){var x = match[2]; return x;}
     var
      key = match[2],
      _bT_ = comparator[2],
      _bU_ = caml_call2(Base_Import[111], M[1], cst_exn_duplicate_key),
      _bV_ = caml_call2(Base_Import[111], cst_Map_of$0, _bU_),
      _bW_ = caml_call5(Base_Error[17], 0, 0, _bV_, key, _bT_);
     return caml_call1(Base_Error[29], _bW_);
    }
    return [0,
            of_foldable_fold,
            of_foldable_reduce,
            of_foldable,
            of_foldable_or_error,
            of_foldable_exn];
   }
   var
    fold$1 = Base_List0[8],
    Of_alist = Of_foldable([0, name, fold$1]),
    of_alist_fold = Of_alist[1],
    of_alist_reduce = Of_alist[2],
    of_alist = Of_alist[3],
    of_alist_or_error = Of_alist[4],
    of_alist_exn = Of_alist[5];
   function of_foldable_multi(foldable, fold, compare_key){
    var
     alist = caml_call3(fold, foldable, 0, function(l, x){return [0, x, l];});
    return of_alist_fold
            (alist, 0, function(l, x){return [0, x, l];}, compare_key);
   }
   function of_alist_multi(alist, compare_key){
    return of_foldable_multi(alist, Base_List0[8], compare_key);
   }
   var
    fold$2 = Base_Sequence[8],
    Of_sequence = Of_foldable([0, name$0, fold$2]),
    of_sequence_fold = Of_sequence[1],
    of_sequence_reduce = Of_sequence[2],
    of_sequence = Of_sequence[3],
    of_sequence_or_error = Of_sequence[4],
    of_sequence_exn = Of_sequence[5],
    _r_ = [0, 0],
    _s_ = [0, 0],
    cst_Map_of_iteri_exn_duplicate = "Map.of_iteri_exn: duplicate key",
    cst_Map_t_of_sexp_direct_dupli = "Map.t_of_sexp_direct: duplicate key",
    _t_ = [0, cst_src_map_ml, 1639, 6],
    cst_key$0 = cst_key$1,
    cst_Map_map_keys_exn_duplicate = "Map.map_keys_exn: duplicate key",
    _u_ = [0, 0, 0],
    _v_ = [0, "Map.Build_increasing.add: non-increasing key"];
   function of_sequence_multi(sequence, compare_key){
    return of_foldable_multi(sequence, Base_Sequence[8], compare_key);
   }
   function for_all(t, f){
    return caml_call1
            (with_return,
             function(r){
              iter
               (t,
                function(data){
                 var _bS_ = 1 - caml_call1(f, data);
                 return _bS_ ? caml_call1(r, 0) : _bS_;
                });
              return 1;
             });
   }
   function for_alli(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _bR_ = 1 - caml_call2(f, key, data);
                 return _bR_ ? caml_call1(r, 0) : _bR_;
                });
              return 1;
             });
   }
   function exists(t, f){
    return caml_call1
            (with_return,
             function(r){
              iter
               (t,
                function(data){
                 var _bQ_ = caml_call1(f, data);
                 return _bQ_ ? caml_call1(r, 1) : _bQ_;
                });
              return 0;
             });
   }
   function existsi(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _bP_ = caml_call2(f, key, data);
                 return _bP_ ? caml_call1(r, 1) : _bP_;
                });
              return 0;
             });
   }
   function count(t, f){
    return fold
            (t,
             0,
             function(param, data, acc){
              return caml_call1(f, data)
                      ? caml_call2(Base_Import[90], acc, 1)
                      : acc;
             });
   }
   function counti(t, f){
    return fold
            (t,
             0,
             function(key, data, acc){
              return caml_call2(f, key, data)
                      ? caml_call2(Base_Import[90], acc, 1)
                      : acc;
             });
   }
   function to_alist(opt, t){
    if(opt) var sth = opt[1], key_order = sth; else var key_order = 608542111;
    return 608542111 <= key_order
            ? fold_right
              (t, 0, function(key, data, x){return [0, [0, key, data], x];})
            : fold
              (t, 0, function(key, data, x){return [0, [0, key, data], x];});
   }
   function merge(t1, t2, f, compare_key){
    var
     _bM_ = length(t2),
     _bN_ = length(t1),
     _bO_ = caml_call2(Base_Import[90], _bN_, _bM_),
     elts = caml_call1(Base_Uniform_array[34], _bO_),
     i = [0, 0];
    iter2
     (t1,
      t2,
      function(key, values){
       var match = caml_call2(f, key, values);
       if(! match) return 0;
       var value = match[1];
       caml_call3(Base_Uniform_array[13], elts, i[1], [0, key, value]);
       return caml_call1(Base_Import[129], i);
      },
      compare_key);
    var len = i[1];
    function get(i){return caml_call2(Base_Uniform_array[11], elts, i);}
    var tree = of_increasing_iterator_uncheck(len, get);
    return [0, tree, len];
   }
   function merge_large_first
   (length_large, t_large, t_small, call, combine, compare_key){
    return fold
            (t_small,
             [0, t_large, length_large],
             function(key, data, param){
              var length = param[2], t = param[1];
              return update
                      (t,
                       key,
                       function(param){
                        if(! param) return data;
                        var data$0 = param[1];
                        return caml_call4(call, combine, key, data$0, data);
                       },
                       length,
                       compare_key);
             });
   }
   function call(f, key, x, y){return caml_call3(f, key, x, y);}
   function swap(f, key, x, y){return caml_call3(f, key, y, x);}
   function merge_skewed(t1, t2, length1, length2, combine, compare_key){
    return length2 <= length1
            ? merge_large_first(length1, t1, t2, call, combine, compare_key)
            : merge_large_first(length2, t2, t1, swap, combine, compare_key);
   }
   function repackage(marker, k, v){return marker ? [0, [0, k, v]] : 0;}
   function closest_key(t$0, dir, k$0, compare_key){
    var t = t$0, found_marker = 0, found_key = 0, found_value = 0;
    for(;;){
     if(typeof t === "number")
      return repackage(found_marker, found_key, found_value);
     if(0 === t[0]) break;
     var
      r = t[4],
      found_value$0 = t[3],
      found_key$0 = t[2],
      l = t[1],
      c$0 = caml_call2(compare_key, found_key$0, k$0);
     if(0 === c$0)
      return -640801497 === dir
              ? is_empty
                 (l)
                ? repackage(found_marker, found_key, found_value)
                : max_elt(l)
              : -779285465
                <= dir
                ? [0, [0, found_key$0, found_value$0]]
                : is_empty
                   (r)
                  ? repackage(found_marker, found_key, found_value)
                  : min_elt(r);
     if(-640801497 !== dir && 927731004 > dir){
      if(0 < c$0){
       t = l;
       found_marker = 1;
       found_key = found_key$0;
       found_value = found_value$0;
       continue;
      }
      t = r;
      continue;
     }
     if(0 <= c$0)
      t = l;
     else{
      t = r;
      found_marker = 1;
      found_key = found_key$0;
      found_value = found_value$0;
     }
    }
    var
     v = t[2],
     k = t[1],
     c = caml_call2(compare_key, k, k$0),
     _bL_ =
       521507869 <= dir
        ? 927731004 <= dir ? c <= 0 ? 1 : 0 : 0 <= c ? 1 : 0
        : -640801497 <= dir ? c < 0 ? 1 : 0 : 0 < c ? 1 : 0;
    return _bL_
            ? [0, [0, k, v]]
            : repackage(found_marker, found_key, found_value);
   }
   function rank(t, k, compare_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var k$0 = t$0[1];
      return 0 === caml_call2(compare_key, k$0, k) ? _r_ : 0;
     }
     var
      r = t$0[4],
      k$1 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, k$1, k);
     if(0 === c) return [0, length(l)];
     if(0 >= c){
      var _bI_ = rank(r, k, compare_key);
      return caml_call2
              (Base_Option[21],
               _bI_,
               function(rank){
                var
                 _bJ_ = length(l),
                 _bK_ = caml_call2(Base_Import[90], rank, 1);
                return caml_call2(Base_Import[90], _bK_, _bJ_);
               });
     }
     t$0 = l;
    }
   }
   function nth(num_to_search, param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var v = param$0[2], k = param$0[1];
      return 0 === num_to_search[1]
              ? [0, [0, k, v]]
              : (caml_call1(Base_Import[128], num_to_search), 0);
     }
     var
      r = param$0[4],
      v$0 = param$0[3],
      k$0 = param$0[2],
      l = param$0[1],
      some = nth(num_to_search, l);
     if(some) return some;
     if(0 === num_to_search[1]) return [0, [0, k$0, v$0]];
     caml_call1(Base_Import[128], num_to_search);
     param$0 = r;
    }
   }
   function nth$0(t, n){return nth([0, n], t);}
   function find_first_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[2], k = t$0[1];
      return caml_call2(f, k, v) ? [0, [0, k, v]] : 0;
     }
     var r = t$0[4], v$0 = t$0[3], k$0 = t$0[2], l = t$0[1];
     if(caml_call2(f, k$0, v$0)){
      var x = find_first_satisfying(l, f);
      return x ? x : [0, [0, k$0, v$0]];
     }
     t$0 = r;
    }
   }
   function find_last_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[2], k = t$0[1];
      return caml_call2(f, k, v) ? [0, [0, k, v]] : 0;
     }
     var r = t$0[4], v$0 = t$0[3], k$0 = t$0[2], l = t$0[1];
     if(caml_call2(f, k$0, v$0)){
      var x = find_last_satisfying(r, f);
      return x ? x : [0, [0, k$0, v$0]];
     }
     t$0 = l;
    }
   }
   function binary_search(t, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (t,
                  function(key, data){
                   return 0 <= caml_call3(compare, key, data, v) ? 1 : 0;
                  })
               : find_last_satisfying
                 (t,
                  function(key, data){
                   return caml_call3(compare, key, data, v) < 0 ? 1 : 0;
                  })
             : -253007807
               <= how
               ? find_last_satisfying
                 (t,
                  function(key, data){
                   return caml_call3(compare, key, data, v) <= 0 ? 1 : 0;
                  })
               : find_first_satisfying
                 (t,
                  function(key, data){
                   return 0 < caml_call3(compare, key, data, v) ? 1 : 0;
                  });
    if(-1055410545 <= how){
     var
      pair =
        find_last_satisfying
         (t,
          function(key, data){
           return caml_call3(compare, key, data, v) <= 0 ? 1 : 0;
          });
     if(pair){
      var match = pair[1], data = match[2], key = match[1];
      if(0 === caml_call3(compare, key, data, v)) return pair;
     }
     return 0;
    }
    var
     pair$0 =
       find_first_satisfying
        (t,
         function(key, data){
          return 0 <= caml_call3(compare, key, data, v) ? 1 : 0;
         });
    if(pair$0){
     var match$0 = pair$0[1], data$0 = match$0[2], key$0 = match$0[1];
     if(0 === caml_call3(compare, key$0, data$0, v)) return pair$0;
    }
    return 0;
   }
   function binary_search_segmented(t, segment_of, how){
    function is_left(key, data){
     return 847852583 <= caml_call2(segment_of, key, data) ? 1 : 0;
    }
    function is_right(key, data){return 1 - is_left(key, data);}
    return 125585502 <= how
            ? find_last_satisfying(t, is_left)
            : find_first_satisfying(t, is_right);
   }
   function binary_search_one_sided_bound
   (t, maybe_bound, compare, if_exclusive, if_inclusive){
    function find_bound(t, how, bound, compare){
     var match = binary_search(t, compare, how, bound);
     if(! match) return 0;
     var bound$0 = match[1][1];
     return [0, [0, bound$0]];
    }
    if(typeof maybe_bound === "number") return _s_;
    if(0 === maybe_bound[0]){
     var bound = maybe_bound[1];
     return find_bound(t, if_inclusive, bound, compare);
    }
    var bound$0 = maybe_bound[1];
    return find_bound(t, if_exclusive, bound$0, compare);
   }
   function binary_search_two_sided_bounds
   (t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_one_sided_bound
        (t, lower_bound, compare, -839473056, 926943384);
    if(! match) return 0;
    var
     lower_bound$0 = match[1],
     match$0 =
       binary_search_one_sided_bound
        (t, upper_bound, compare, 200870407, -253007807);
    if(! match$0) return 0;
    var upper_bound$0 = match$0[1];
    return [0, [0, lower_bound$0, upper_bound$0]];
   }
   function of_iteri(iteri, compare_key){
    var acc = [0, 0, [0, empty_without_value_restrictio, 0]];
    caml_call1
     (iteri,
      function(key, data){
       var
        match = acc[2],
        length = match[2],
        map = match[1],
        pair = set(map, length, key, data, compare_key),
        length$0 = pair[2];
       if(length === length$0 && caml_call1(Base_Option[49], acc[1])){acc[1] = [0, key]; return 0;}
       acc[2] = pair;
       return 0;
      });
    var match = acc[1];
    if(! match) return [0, 17724, acc[2]];
    var key = match[1];
    return [0, -1048878709, key];
   }
   function of_iteri_exn(iteri, comparator){
    var match = of_iteri(iteri, comparator[1]);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var
     key = match[2],
     _bH_ =
       caml_call5
        (Base_Error[17],
         0,
         0,
         cst_Map_of_iteri_exn_duplicate,
         key,
         comparator[2]);
    return caml_call1(Base_Error[29], _bH_);
   }
   function t_of_sexp_direct(key_of_sexp, value_of_sexp, sexp, comparator){
    var
     _bA_ = caml_call2(Base_Import[173], key_of_sexp, value_of_sexp),
     alist = caml_call2(Base_Import[175], _bA_, sexp),
     compare_key = comparator[1],
     match = of_alist(alist, compare_key);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var
     k = match[2],
     _bB_ =
       caml_call2
        (Base_Import[173],
         function(_bG_){return _bG_;},
         function(_bF_){return _bF_;}),
     alist_sexps = caml_call2(Base_Import[175], _bB_, sexp),
     found_first_k = [0, 0];
    caml_call3
     (Base_List0[13],
      alist,
      alist_sexps,
      function(param, _bC_){
       var
        k2_sexp = _bC_[1],
        k2 = param[1],
        _bD_ = 0 === caml_call2(compare_key, k, k2) ? 1 : 0;
       if(_bD_){
        if(found_first_k[1])
         return caml_call2
                 (Base_Import[158], cst_Map_t_of_sexp_direct_dupli, k2_sexp);
        found_first_k[1] = 1;
        var _bE_ = 0;
       }
       else
        var _bE_ = _bD_;
       return _bE_;
      });
    throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
   }
   function sexp_of_t$1(sexp_of_key, sexp_of_value, t){
    function f(key, data, acc){
     var _bz_ = [0, caml_call1(sexp_of_value, data), 0];
     return [0, [1, [0, caml_call1(sexp_of_key, key), _bz_]], acc];
    }
    return [1, fold_right(t, 0, f)];
   }
   function combine_errors(t, compare_key, sexp_of_key){
    var
     _bx_ = partition_map(t, Base_Result[35], compare_key),
     error_tree = _bx_[2][1],
     oks = _bx_[1];
    if(is_empty(error_tree)) return [0, oks];
    var _by_ = sexp_of_t$1(sexp_of_key, Base_Error[6], error_tree);
    return caml_call1(Base_Or_error[35], _by_);
   }
   function map_keys(t1, f, param){
    var sexp_of_key = param[2], compare_key = param[1];
    return caml_call1
            (with_return,
             function(param){
              return [0,
                      17724,
                      fold
                       (t1,
                        [0, empty_without_value_restrictio, 0],
                        function(key, data, param$0){
                         var
                          length = param$0[2],
                          t2 = param$0[1],
                          key$0 = caml_call1(f, key);
                         try{
                          var
                           _bv_ =
                             add_exn_internal
                              (t2, length, key$0, data, compare_key, sexp_of_key);
                          return _bv_;
                         }
                         catch(_bw_){
                          var _bu_ = caml_wrap_exception(_bw_);
                          if(_bu_ === Duplicate)
                           return caml_call1(param, [0, -1048878709, key$0]);
                          throw caml_maybe_attach_backtrace(_bu_, 0);
                         }
                        })];
             });
   }
   function map_keys_exn(t, f, comparator){
    var match = map_keys(t, f, comparator);
    if(17724 <= match[1]){var result = match[2]; return result;}
    var
     key = match[2],
     sexp_of_key = comparator[2],
     _bs_ = [0, [0, cst_key$0, caml_call1(sexp_of_key, key)], 0],
     _bt_ = caml_call2(Base_Sexp[9], cst_Map_map_keys_exn_duplicate, _bs_);
    return caml_call1(Base_Error[30], _bt_);
   }
   function compare_key(t){return t[1][1];}
   function like(param, _br_){
    var length = _br_[2], tree = _br_[1], comparator = param[1];
    return [0, comparator, tree, length];
   }
   function like2(x, param){
    var z = param[2], y = param[1], _bq_ = like(x, z);
    return [0, like(x, y), _bq_];
   }
   function like_maybe_no_op(old_t, param){
    var
     length = param[2],
     tree = param[1],
     old_tree = old_t[2],
     comparator = old_t[1];
    return caml_call2(Base_Import[127], old_tree, tree)
            ? old_t
            : [0, comparator, tree, length];
   }
   function with_same_length(param, tree){
    var length = param[3], comparator = param[1];
    return [0, comparator, tree, length];
   }
   function of_tree$0(comparator, tree){
    return [0, comparator, tree, length(tree)];
   }
   function comparator(t){return t[1];}
   function to_tree(t){return t[2];}
   function invariants$0(t){
    var _bm_ = compare_key(t), _bn_ = invariants(t[2], _bm_);
    if(_bn_)
     var _bo_ = t[3], _bp_ = length(t[2]) === _bo_ ? 1 : 0;
    else
     var _bp_ = _bn_;
    return _bp_;
   }
   function is_empty$0(t){return is_empty(t[2]);}
   function length$0(t){return t[3];}
   function set$1(t, key, data){
    var _bl_ = compare_key(t);
    return like(t, set(t[2], t[3], key, data, _bl_));
   }
   function add_exn$0(t, key, data){
    var _bj_ = t[1][2], _bk_ = compare_key(t);
    return like(t, add_exn(t[2], t[3], key, data, _bk_, _bj_));
   }
   function add(t, key, data){
    try{
     var
      _bf_ = t[1][2],
      _bg_ = compare_key(t),
      result = like(t, add_exn_internal(t[2], t[3], key, data, _bg_, _bf_));
    }
    catch(_bi_){
     var _bh_ = caml_wrap_exception(_bi_);
     if(_bh_ === Duplicate) return -1024851605;
     throw caml_maybe_attach_backtrace(_bh_, 0);
    }
    return [0, 17724, result];
   }
   function add_multi$0(t, key, data){
    var _be_ = compare_key(t);
    return like(t, add_multi(t[2], t[3], key, data, _be_));
   }
   function remove_multi$0(t, key){
    var _bd_ = compare_key(t);
    return like(t, remove_multi(t[2], key, t[3], _bd_));
   }
   function find_multi$0(t, key){
    var _bc_ = compare_key(t);
    return find_multi(t[2], key, _bc_);
   }
   function change$0(t, key, f){
    var _bb_ = compare_key(t);
    return like(t, change(t[2], key, f, t[3], _bb_));
   }
   function update$0(t, key, f){
    var _ba_ = compare_key(t);
    return like(t, update(t[2], key, f, t[3], _ba_));
   }
   function find_exn$0(t, key){
    var _a__ = t[1][2], _a$_ = compare_key(t);
    return find_exn(t[2], key, _a$_, _a__);
   }
   function find$0(t, key){
    var _a9_ = compare_key(t);
    return find(t[2], key, _a9_);
   }
   function remove$0(t, key){
    var _a8_ = compare_key(t);
    return like_maybe_no_op(t, remove(t[2], key, t[3], _a8_));
   }
   function mem$0(t, key){
    var _a7_ = compare_key(t);
    return mem(t[2], key, _a7_);
   }
   function iter_keys$0(t, f){return iter_keys(t[2], f);}
   function iter$0(t, f){return iter(t[2], f);}
   function iteri$0(t, f){return iteri(t[2], f);}
   function iteri_until$0(t, f){return iteri_until(t[2], f);}
   function iter2$0(t1, t2, f){
    var _a6_ = compare_key(t1);
    return iter2(t1[2], t2[2], f, _a6_);
   }
   function map$0(t, f){return with_same_length(t, map(t[2], f));}
   function mapi$0(t, f){return with_same_length(t, mapi(t[2], f));}
   function fold$3(t, init, f){return fold(t[2], init, f);}
   function fold_until$0(t, init, f){
    var _a4_ = t[2];
    return function(_a5_){return fold_until(_a4_, init, f, _a5_);};
   }
   function fold_right$0(t, init, f){return fold_right(t[2], init, f);}
   function fold2$1(t1, t2, init, f){
    var _a3_ = compare_key(t1);
    return fold2$0(t1[2], t2[2], init, f, _a3_);
   }
   function filter_keys$0(t, f){
    var _a2_ = compare_key(t);
    return like(t, filter_keys(t[2], f, _a2_));
   }
   function filter$0(t, f){
    var _a1_ = compare_key(t);
    return like(t, filter(t[2], f, _a1_));
   }
   function filteri$0(t, f){
    var _a0_ = compare_key(t);
    return like(t, filteri(t[2], f, _a0_));
   }
   function filter_map$0(t, f){
    var _aZ_ = compare_key(t);
    return like(t, filter_map(t[2], f, _aZ_));
   }
   function filter_mapi$0(t, f){
    var _aY_ = compare_key(t);
    return like(t, filter_mapi(t[2], f, _aY_));
   }
   function partition_mapi$0(t, f){
    var _aX_ = compare_key(t);
    return like2(t, partition_mapi(t[2], f, _aX_));
   }
   function partition_map$0(t, f){
    var _aW_ = compare_key(t);
    return like2(t, partition_map(t[2], f, _aW_));
   }
   function partitioni_tf$0(t, f){
    var _aV_ = compare_key(t);
    return like2(t, partitioni_tf(t[2], f, _aV_));
   }
   function partition_tf$0(t, f){
    var _aU_ = compare_key(t);
    return like2(t, partition_tf(t[2], f, _aU_));
   }
   function combine_errors$0(t){
    var
     _aQ_ = t[1][2],
     _aR_ = compare_key(t),
     _aS_ = combine_errors(t[2], _aR_, _aQ_);
    return caml_call2
            (Base_Or_error[43], _aS_, function(_aT_){return like(t, _aT_);});
   }
   function compare_direct(compare_data, t1, t2){
    var _aO_ = t2[2], _aP_ = t1[2];
    return compare$1(compare_key(t1), compare_data, _aP_, _aO_);
   }
   function equal$2(compare_data, t1, t2){
    var _aM_ = t2[2], _aN_ = t1[2];
    return equal$1(compare_key(t1), compare_data, _aN_, _aM_);
   }
   function keys$0(t){return keys(t[2]);}
   function data$0(t){return data(t[2]);}
   function to_alist$0(key_order, t){return to_alist(key_order, t[2]);}
   function symmetric_diff$0(t1, t2, data_equal){
    var _aL_ = compare_key(t1);
    return symmetric_diff(t1[2], t2[2], _aL_, data_equal);
   }
   function fold_symmetric_diff$0(t1, t2, data_equal, init, f){
    var _aK_ = compare_key(t1);
    return fold_symmetric_diff(t1[2], t2[2], _aK_, data_equal, init, f);
   }
   function merge$0(t1, t2, f){
    var _aJ_ = compare_key(t1);
    return like(t1, merge(t1[2], t2[2], f, _aJ_));
   }
   function merge_skewed$0(t1, t2, combine){
    var
     _aH_ = compare_key(t1),
     _aI_ = merge_skewed(t1[2], t2[2], t1[3], t2[3], combine, _aH_),
     t1$0 = t2[3] <= t1[3] ? t1 : t2;
    return like_maybe_no_op(t1$0, _aI_);
   }
   function min_elt$0(t){return min_elt(t[2]);}
   function min_elt_exn$0(t){return min_elt_exn(t[2]);}
   function max_elt$0(t){return max_elt(t[2]);}
   function max_elt_exn$0(t){return max_elt_exn(t[2]);}
   function for_all$0(t, f){return for_all(t[2], f);}
   function for_alli$0(t, f){return for_alli(t[2], f);}
   function exists$0(t, f){return exists(t[2], f);}
   function existsi$0(t, f){return existsi(t[2], f);}
   function count$0(t, f){return count(t[2], f);}
   function counti$0(t, f){return counti(t[2], f);}
   function split$0(t, k){
    var
     _aF_ = compare_key(t),
     match = split(t[2], k, _aF_),
     tree = match[3],
     maybe = match[2],
     tree$0 = match[1],
     comparator = t[1],
     both_len =
       caml_call1(Base_Option[50], maybe)
        ? caml_call2(Base_Import[92], t[3], 1)
        : t[3],
     _aG_ = height(tree);
    if(height(tree$0) < _aG_){
     var
      l = of_tree$0(comparator, tree$0),
      length = caml_call2(Base_Import[92], both_len, l[3]);
     return [0, l, maybe, [0, comparator, tree, length]];
    }
    var
     r = of_tree$0(comparator, tree),
     length$0 = caml_call2(Base_Import[92], both_len, r[3]);
    return [0, [0, comparator, tree$0, length$0], maybe, r];
   }
   function subrange(t, lower_bound, upper_bound){
    var
     _aB_ = compare_key(t),
     match = split_range(t[2], lower_bound, upper_bound, _aB_),
     right = match[3],
     tree = match[2],
     left = match[1],
     h_l = height(left),
     h_r = height(right),
     outer_joined_height =
       h_l === h_r
        ? caml_call2(Base_Import[90], h_l, 1)
        : caml_call2(Base_Import[99], h_l, h_r);
    if(outer_joined_height >= height(tree)) return of_tree$0(t[1], tree);
    var
     _aC_ = length(right),
     _aD_ = length(left),
     _aE_ = caml_call2(Base_Import[90], _aD_, _aC_),
     mid_length = caml_call2(Base_Import[92], t[3], _aE_),
     comparator = t[1];
    return [0, comparator, tree, mid_length];
   }
   function append$0(lower_part, upper_part){
    var
     _aA_ = compare_key(lower_part),
     match = append(lower_part[2], upper_part[2], _aA_);
    if(typeof match === "number") return 838882908;
    var
     tree = match[2],
     length = caml_call2(Base_Import[90], lower_part[3], upper_part[3]),
     comparator = lower_part[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function fold_range_inclusive$0(t, min, max, init, f){
    var _az_ = compare_key(t);
    return fold_range_inclusive(t[2], min, max, init, f, _az_);
   }
   function range_to_alist$0(t, min, max){
    var _ay_ = compare_key(t);
    return range_to_alist(t[2], min, max, _ay_);
   }
   function closest_key$0(t, dir, key){
    var _ax_ = compare_key(t);
    return closest_key(t[2], dir, key, _ax_);
   }
   function nth$1(t, n){return nth$0(t[2], n);}
   function nth_exn(t, n){
    var _aw_ = nth$1(t, n);
    return caml_call4(Base_Option[28], 0, 0, 0, _aw_);
   }
   function rank$0(t, key){
    var _av_ = compare_key(t);
    return rank(t[2], key, _av_);
   }
   function sexp_of_t$2(sexp_of_k, sexp_of_v, param, t){return sexp_of_t$1(sexp_of_k, sexp_of_v, t[2]);
   }
   function to_sequence$0
   (order, keys_greater_or_equal_to, keys_less_or_equal_to, t){
    return to_sequence
            (t[1],
             order,
             keys_greater_or_equal_to,
             keys_less_or_equal_to,
             t[2]);
   }
   function binary_search$0(t, compare, how, v){
    return binary_search(t[2], compare, how, v);
   }
   function binary_search_segmented$0(t, segment_of, how){
    return binary_search_segmented(t[2], segment_of, how);
   }
   function hash_fold_direct(hash_fold_key, hash_fold_data, state, t){
    var t$0 = t[2], _au_ = length(t$0);
    return fold
            (t$0,
             caml_call2(Base_Import[206], state, _au_),
             function(key, data, state){
              return caml_call2
                      (hash_fold_data,
                       caml_call2(hash_fold_key, state, key),
                       data);
             });
   }
   function binary_search_subrange(t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_two_sided_bounds(t[2], compare, lower_bound, upper_bound);
    if(! match) return like_maybe_no_op(t, _u_);
    var
     match$0 = match[1],
     upper_bound$0 = match$0[2],
     lower_bound$0 = match$0[1];
    return subrange(t, lower_bound$0, upper_bound$0);
   }
   function empty$0(param){return empty_without_value_restrictio;}
   function of_tree$1(param, tree){return tree;}
   function singleton(param, key, data){return [0, key, data];}
   function of_sorted_array_unchecked$0(comparator, array){
    var _at_ = of_sorted_array_unchecked(array, comparator[1]);
    return caml_call1(Base_Import[124], _at_);
   }
   function of_sorted_array$0(comparator, array){
    var _as_ = of_sorted_array(array, comparator[1]);
    return caml_call2(Base_Or_error[43], _as_, Base_Import[124]);
   }
   function of_alist$0(comparator, alist){
    var d = of_alist(alist, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_alist_or_error$0(comparator, alist){
    var _ar_ = of_alist_or_error(alist, comparator);
    return caml_call2(Base_Or_error[43], _ar_, Base_Import[124]);
   }
   function of_alist_exn$0(comparator, alist){
    var _aq_ = of_alist_exn(alist, comparator);
    return caml_call1(Base_Import[124], _aq_);
   }
   function of_alist_multi$0(comparator, alist){
    var _ap_ = of_alist_multi(alist, comparator[1]);
    return caml_call1(Base_Import[124], _ap_);
   }
   function of_alist_fold$0(comparator, alist, init, f){
    var _ao_ = of_alist_fold(alist, init, f, comparator[1]);
    return caml_call1(Base_Import[124], _ao_);
   }
   function of_alist_reduce$0(comparator, alist, f){
    var _an_ = of_alist_reduce(alist, f, comparator[1]);
    return caml_call1(Base_Import[124], _an_);
   }
   function of_iteri$0(comparator, iteri){
    var d = of_iteri(iteri, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_iteri_exn$0(comparator, iteri){
    var _am_ = of_iteri_exn(iteri, comparator);
    return caml_call1(Base_Import[124], _am_);
   }
   function of_increasing_iterator_uncheck$0(required_by_intf, len, f){return of_increasing_iterator_uncheck(len, f);
   }
   function of_increasing_sequence$0(comparator, seq){
    var
     _ak_ = Base_Import[124],
     _al_ = of_increasing_sequence(seq, comparator[1]);
    return caml_call2(Base_Or_error[43], _al_, _ak_);
   }
   function of_sequence$0(comparator, seq){
    var d = of_sequence(seq, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_sequence_or_error$0(comparator, seq){
    var _aj_ = of_sequence_or_error(seq, comparator);
    return caml_call2(Base_Or_error[43], _aj_, Base_Import[124]);
   }
   function of_sequence_exn$0(comparator, seq){
    var _ai_ = of_sequence_exn(seq, comparator);
    return caml_call1(Base_Import[124], _ai_);
   }
   function of_sequence_multi$0(comparator, seq){
    var _ah_ = of_sequence_multi(seq, comparator[1]);
    return caml_call1(Base_Import[124], _ah_);
   }
   function of_sequence_fold$0(comparator, seq, init, f){
    var _ag_ = of_sequence_fold(seq, init, f, comparator[1]);
    return caml_call1(Base_Import[124], _ag_);
   }
   function of_sequence_reduce$0(comparator, seq, f){
    var _af_ = of_sequence_reduce(seq, f, comparator[1]);
    return caml_call1(Base_Import[124], _af_);
   }
   function to_tree$0(t){return t;}
   function invariants$1(comparator, t){return invariants(t, comparator[1]);}
   function is_empty$1(t){return is_empty(t);}
   function length$1(t){return length(t);}
   function set$2(comparator, t, key, data){
    var _ae_ = set(t, 0, key, data, comparator[1]);
    return caml_call1(Base_Import[124], _ae_);
   }
   function add_exn$1(comparator, t, key, data){
    var _ad_ = add_exn(t, 0, key, data, comparator[1], comparator[2]);
    return caml_call1(Base_Import[124], _ad_);
   }
   function add$0(comparator, t, key, data){
    try{
     var _ab_ = [0, 17724, add_exn$1(comparator, t, key, data)];
     return _ab_;
    }
    catch(_ac_){return -1024851605;}
   }
   function add_multi$1(comparator, t, key, data){
    var _aa_ = add_multi(t, 0, key, data, comparator[1]);
    return caml_call1(Base_Import[124], _aa_);
   }
   function remove_multi$1(comparator, t, key){
    var _$_ = remove_multi(t, key, 0, comparator[1]);
    return caml_call1(Base_Import[124], _$_);
   }
   function find_multi$1(comparator, t, key){
    return find_multi(t, key, comparator[1]);
   }
   function change$1(comparator, t, key, f){
    var ___ = change(t, key, f, 0, comparator[1]);
    return caml_call1(Base_Import[124], ___);
   }
   function update$1(comparator, t, key, f){
    return change$1
            (comparator,
             t,
             key,
             function(data){return [0, caml_call1(f, data)];});
   }
   function find_exn$1(comparator, t, key){
    return find_exn(t, key, comparator[1], comparator[2]);
   }
   function find$1(comparator, t, key){return find(t, key, comparator[1]);}
   function remove$1(comparator, t, key){
    var _Z_ = remove(t, key, 0, comparator[1]);
    return caml_call1(Base_Import[124], _Z_);
   }
   function mem$1(comparator, t, key){return mem(t, key, comparator[1]);}
   function iter_keys$1(t, f){return iter_keys(t, f);}
   function iter$1(t, f){return iter(t, f);}
   function iteri$1(t, f){return iteri(t, f);}
   function iteri_until$1(t, f){return iteri_until(t, f);}
   function iter2$1(comparator, t1, t2, f){
    return iter2(t1, t2, f, comparator[1]);
   }
   function map$1(t, f){return map(t, f);}
   function mapi$1(t, f){return mapi(t, f);}
   function fold$4(t, init, f){return fold(t, init, f);}
   function fold_until$1(t, init, f, finish){return fold_until(t, init, f, finish);
   }
   function fold_right$1(t, init, f){return fold_right(t, init, f);}
   function fold2$2(comparator, t1, t2, init, f){
    return fold2$0(t1, t2, init, f, comparator[1]);
   }
   function filter_keys$1(comparator, t, f){
    var _Y_ = filter_keys(t, f, comparator[1]);
    return caml_call1(Base_Import[124], _Y_);
   }
   function filter$1(comparator, t, f){
    var _X_ = filter(t, f, comparator[1]);
    return caml_call1(Base_Import[124], _X_);
   }
   function filteri$1(comparator, t, f){
    var _W_ = filteri(t, f, comparator[1]);
    return caml_call1(Base_Import[124], _W_);
   }
   function filter_map$1(comparator, t, f){
    var _V_ = filter_map(t, f, comparator[1]);
    return caml_call1(Base_Import[124], _V_);
   }
   function filter_mapi$1(comparator, t, f){
    var _U_ = filter_mapi(t, f, comparator[1]);
    return caml_call1(Base_Import[124], _U_);
   }
   function partition_mapi$1(comparator, t, f){
    var
     _T_ = partition_mapi(t, f, comparator[1]),
     b = _T_[2][1],
     a = _T_[1][1];
    return [0, a, b];
   }
   function partition_map$1(comparator, t, f){
    var
     _S_ = partition_map(t, f, comparator[1]),
     b = _S_[2][1],
     a = _S_[1][1];
    return [0, a, b];
   }
   function partitioni_tf$1(comparator, t, f){
    var
     _R_ = partitioni_tf(t, f, comparator[1]),
     b = _R_[2][1],
     a = _R_[1][1];
    return [0, a, b];
   }
   function partition_tf$1(comparator, t, f){
    var _Q_ = partition_tf(t, f, comparator[1]), b = _Q_[2][1], a = _Q_[1][1];
    return [0, a, b];
   }
   function combine_errors$1(comparator, t){
    var
     _O_ = Base_Import[124],
     _P_ = combine_errors(t, comparator[1], comparator[2]);
    return caml_call2(Base_Or_error[43], _P_, _O_);
   }
   function compare_direct$0(comparator, compare_data, t1, t2){return compare$1(comparator[1], compare_data, t1, t2);
   }
   function equal$3(comparator, compare_data, t1, t2){
    return equal$1(comparator[1], compare_data, t1, t2);
   }
   function keys$1(t){return keys(t);}
   function data$1(t){return data(t);}
   function to_alist$1(key_order, t){return to_alist(key_order, t);}
   function symmetric_diff$1(comparator, t1, t2, data_equal){
    return symmetric_diff(t1, t2, comparator[1], data_equal);
   }
   function fold_symmetric_diff$1(comparator, t1, t2, data_equal, init, f){
    return fold_symmetric_diff(t1, t2, comparator[1], data_equal, init, f);
   }
   function merge$1(comparator, t1, t2, f){
    var _N_ = merge(t1, t2, f, comparator[1]);
    return caml_call1(Base_Import[124], _N_);
   }
   function merge_skewed$1(comparator, t1, t2, combine){
    var
     _K_ = comparator[1],
     _M_ = length(t2),
     _L_ = merge_skewed(t1, t2, length(t1), _M_, combine, _K_);
    return caml_call1(Base_Import[124], _L_);
   }
   function min_elt$1(t){return min_elt(t);}
   function min_elt_exn$1(t){return min_elt_exn(t);}
   function max_elt$1(t){return max_elt(t);}
   function max_elt_exn$1(t){return max_elt_exn(t);}
   function for_all$1(t, f){return for_all(t, f);}
   function for_alli$1(t, f){return for_alli(t, f);}
   function exists$1(t, f){return exists(t, f);}
   function existsi$1(t, f){return existsi(t, f);}
   function count$1(t, f){return count(t, f);}
   function counti$1(t, f){return counti(t, f);}
   function split$1(comparator, t, k){return split(t, k, comparator[1]);}
   function append$1(comparator, lower_part, upper_part){
    return append(lower_part, upper_part, comparator[1]);
   }
   function subrange$0(comparator, t, lower_bound, upper_bound){
    var ret = split_range(t, lower_bound, upper_bound, comparator[1])[2];
    return ret;
   }
   function fold_range_inclusive$1(comparator, t, min, max, init, f){
    return fold_range_inclusive(t, min, max, init, f, comparator[1]);
   }
   function range_to_alist$1(comparator, t, min, max){
    return range_to_alist(t, min, max, comparator[1]);
   }
   function closest_key$1(comparator, t, dir, key){
    return closest_key(t, dir, key, comparator[1]);
   }
   function nth$2(t, n){return nth$0(t, n);}
   function nth_exn$0(t, n){
    var _J_ = nth$0(t, n);
    return caml_call4(Base_Option[28], 0, 0, 0, _J_);
   }
   function rank$1(comparator, t, key){return rank(t, key, comparator[1]);}
   function sexp_of_t$3(sexp_of_k, sexp_of_v, param, t){return sexp_of_t$1(sexp_of_k, sexp_of_v, t);
   }
   function t_of_sexp_direct$0(comparator, k_of_sexp, v_of_sexp, sexp){
    var _I_ = t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator);
    return caml_call1(Base_Import[124], _I_);
   }
   function to_sequence$1
   (comparator, order, keys_greater_or_equal_to, keys_less_or_equal_to, t){
    return to_sequence
            (comparator,
             order,
             keys_greater_or_equal_to,
             keys_less_or_equal_to,
             t);
   }
   function binary_search$1(param, t, compare, how, v){return binary_search(t, compare, how, v);
   }
   function binary_search_segmented$1(param, t, segment_of, how){return binary_search_segmented(t, segment_of, how);
   }
   function binary_search_subrange$0
   (comparator, t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_two_sided_bounds(t, compare, lower_bound, upper_bound);
    if(! match) return 0;
    var
     match$0 = match[1],
     upper_bound$0 = match$0[2],
     lower_bound$0 = match$0[1];
    return subrange$0(comparator, t, lower_bound$0, upper_bound$0);
   }
   function map_keys$0(comparator, t, f){
    var dup = map_keys(t, f, comparator);
    if(17724 > dup[1]) return dup;
    var t$0 = dup[2][1];
    return [0, 17724, t$0];
   }
   function map_keys_exn$0(comparator, t, f){
    var _H_ = map_keys_exn(t, f, comparator);
    return caml_call1(Base_Import[124], _H_);
   }
   function add_exn$2(t, comparator, key, data){
    var match = max_key(t);
    if(match){
     var prev_key = match[1];
     if(0 <= caml_call2(comparator[1], prev_key, key))
      return caml_call1(Base_Error[30], _v_);
    }
    return add_unchecked(t, key, data);
   }
   function to_tree$1(t){return to_tree_unchecked(t);}
   var Build_increasing = [0, empty, add_exn$2, to_tree$1], _w_ = [0, "_"];
   function empty$1(comparator){
    return [0, comparator, empty_without_value_restrictio, 0];
   }
   function singleton$0(comparator, key, data){return [0, comparator, [0, key, data], 1];
   }
   function of_tree0(comparator, param){
    var length = param[2], tree = param[1];
    return [0, comparator, tree, length];
   }
   function of_tree$2(comparator, tree){
    return of_tree0(comparator, [0, tree, length(tree)]);
   }
   function of_sorted_array_unchecked$1(comparator, array){
    return of_tree0
            (comparator, of_sorted_array_unchecked(array, comparator[1]));
   }
   function of_sorted_array$1(comparator, array){
    var _G_ = of_sorted_array(array, comparator[1]);
    return caml_call2
            (Base_Or_error[43],
             _G_,
             function(tree){return of_tree0(comparator, tree);});
   }
   function of_alist$1(comparator, alist){
    var z = of_alist(alist, comparator[1]);
    if(17724 > z[1]) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_alist_or_error$1(comparator, alist){
    var _F_ = of_alist_or_error(alist, comparator);
    return caml_call2
            (Base_Result[30],
             _F_,
             function(tree){return of_tree0(comparator, tree);});
   }
   function of_alist_exn$1(comparator, alist){
    return of_tree0(comparator, of_alist_exn(alist, comparator));
   }
   function of_alist_multi$1(comparator, alist){
    return of_tree0(comparator, of_alist_multi(alist, comparator[1]));
   }
   function of_alist_fold$1(comparator, alist, init, f){
    return of_tree0(comparator, of_alist_fold(alist, init, f, comparator[1]));
   }
   function of_alist_reduce$1(comparator, alist, f){
    return of_tree0(comparator, of_alist_reduce(alist, f, comparator[1]));
   }
   function of_iteri$1(comparator, iteri){
    var z = of_iteri(iteri, comparator[1]);
    if(17724 > z[1]) return z;
    var tree_length = z[2];
    return [0, 17724, of_tree0(comparator, tree_length)];
   }
   function of_iteri_exn$1(comparator, iteri){
    return of_tree0(comparator, of_iteri_exn(iteri, comparator));
   }
   function of_increasing_iterator_uncheck$1(comparator, len, f){
    return of_tree0
            (comparator, [0, of_increasing_iterator_uncheck(len, f), len]);
   }
   function of_increasing_sequence$1(comparator, seq){
    var _D_ = of_increasing_sequence(seq, comparator[1]);
    return caml_call2
            (Base_Or_error[43],
             _D_,
             function(_E_){return of_tree0(comparator, _E_);});
   }
   function of_sequence$1(comparator, seq){
    var z = of_sequence(seq, comparator[1]);
    if(17724 > z[1]) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_sequence_or_error$1(comparator, seq){
    var _C_ = of_sequence_or_error(seq, comparator);
    return caml_call2
            (Base_Result[30],
             _C_,
             function(tree){return of_tree0(comparator, tree);});
   }
   function of_sequence_exn$1(comparator, seq){
    return of_tree0(comparator, of_sequence_exn(seq, comparator));
   }
   function of_sequence_multi$1(comparator, seq){
    return of_tree0(comparator, of_sequence_multi(seq, comparator[1]));
   }
   function of_sequence_fold$1(comparator, seq, init, f){
    return of_tree0(comparator, of_sequence_fold(seq, init, f, comparator[1]));
   }
   function of_sequence_reduce$1(comparator, seq, f){
    return of_tree0(comparator, of_sequence_reduce(seq, f, comparator[1]));
   }
   function t_of_sexp_direct$1(comparator, k_of_sexp, v_of_sexp, sexp){
    return of_tree0
            (comparator,
             t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator));
   }
   function map_keys$1(comparator, t, f){
    var dup = map_keys(t[2], f, comparator);
    if(17724 > dup[1]) return dup;
    var pair = dup[2];
    return [0, 17724, of_tree0(comparator, pair)];
   }
   function map_keys_exn$1(comparator, t, f){
    return of_tree0(comparator, map_keys_exn(t[2], f, comparator));
   }
   function Empty_without_value_restrictio(K){
    var empty = [0, K[1], empty_without_value_restrictio, 0];
    return [0, empty];
   }
   function comparator_s(t){var comparator = t[1]; return [0, comparator];}
   function of_tree$3(M){
    return function(tree){return of_tree$0(M[1], tree);};
   }
   function empty$2(m){return empty$1(m[1]);}
   function singleton$1(m, a){
    var _A_ = m[1];
    return function(_B_){return singleton$0(_A_, a, _B_);};
   }
   function of_alist$2(m, a){return of_alist$1(m[1], a);}
   function of_alist_or_error$2(m, a){return of_alist_or_error$1(m[1], a);}
   function of_alist_exn$2(m, a){return of_alist_exn$1(m[1], a);}
   function of_alist_multi$2(m, a){return of_alist_multi$1(m[1], a);}
   function of_alist_fold$2(m, a, init, f){
    return of_alist_fold$1(m[1], a, init, f);
   }
   function of_alist_reduce$2(m, a, f){return of_alist_reduce$1(m[1], a, f);}
   function of_sorted_array_unchecked$2(m, a){
    return of_sorted_array_unchecked$1(m[1], a);
   }
   function of_sorted_array$2(m, a){return of_sorted_array$1(m[1], a);}
   function of_iteri$2(m, iteri){return of_iteri$1(m[1], iteri);}
   function of_iteri_exn$2(m, iteri){return of_iteri_exn$1(m[1], iteri);}
   function of_increasing_iterator_uncheck$2(m, len, f){
    return of_increasing_iterator_uncheck$1(m[1], len, f);
   }
   function of_increasing_sequence$2(m, seq){
    return of_increasing_sequence$1(m[1], seq);
   }
   function of_sequence$2(m, s){return of_sequence$1(m[1], s);}
   function of_sequence_or_error$2(m, s){
    return of_sequence_or_error$1(m[1], s);
   }
   function of_sequence_exn$2(m, s){return of_sequence_exn$1(m[1], s);}
   function of_sequence_multi$2(m, s){return of_sequence_multi$1(m[1], s);}
   function of_sequence_fold$2(m, s, init, f){
    return of_sequence_fold$1(m[1], s, init, f);
   }
   function of_sequence_reduce$2(m, s, f){
    return of_sequence_reduce$1(m[1], s, f);
   }
   function map_keys$2(m, t, f){return map_keys$1(m[1], t, f);}
   function map_keys_exn$2(m, t, f){return map_keys_exn$1(m[1], t, f);}
   function M(K){return [0];}
   function sexp_of_m_t(K){
    return function(sexp_of_v, t){
     return sexp_of_t$2(K[1], sexp_of_v, function(param){return _w_;}, t);};
   }
   function m_t_of_sexp(K){
    return function(v_of_sexp, sexp){
     return t_of_sexp_direct$1(K[2], K[1], v_of_sexp, sexp);};
   }
   function m_t_sexp_grammar(K){
    return function(v_grammar){
     return [2, [1, [2, [0, K[1], [0, v_grammar, 0]]]]];};
   }
   function compare_m_t(param, compare_v, t1, t2){return compare_direct(compare_v, t1, t2);
   }
   function equal_m_t(param, equal_v, t1, t2){return equal$2(equal_v, t1, t2);
   }
   function hash_fold_m_t(K){
    return function(hash_fold_v, state){
     var _y_ = K[1];
     return function(_z_){
      return hash_fold_direct(_y_, hash_fold_v, state, _z_);};};
   }
   var comparator$0 = Base_Comparator[2][1];
   function of_tree$4(tree){return [0, comparator$0, tree, length(tree)];}
   var
    include$1 = Empty_without_value_restrictio(Base_Comparator[2]),
    empty$3 = include$1[1];
   function singleton$2(a){
    return function(_x_){return singleton$0(comparator$0, a, _x_);};
   }
   function of_alist$3(a){return of_alist$1(comparator$0, a);}
   function of_alist_or_error$3(a){
    return of_alist_or_error$1(comparator$0, a);
   }
   function of_alist_exn$3(a){return of_alist_exn$1(comparator$0, a);}
   function of_alist_multi$3(a){return of_alist_multi$1(comparator$0, a);}
   function of_alist_fold$3(a, init, f){
    return of_alist_fold$1(comparator$0, a, init, f);
   }
   function of_alist_reduce$3(a, f){
    return of_alist_reduce$1(comparator$0, a, f);
   }
   function of_sorted_array_unchecked$3(a){
    return of_sorted_array_unchecked$1(comparator$0, a);
   }
   function of_sorted_array$3(a){return of_sorted_array$1(comparator$0, a);}
   function of_iteri$3(iteri){return of_iteri$1(comparator$0, iteri);}
   function of_iteri_exn$3(iteri){return of_iteri_exn$1(comparator$0, iteri);}
   function of_increasing_iterator_uncheck$3(len, f){
    return of_increasing_iterator_uncheck$1(comparator$0, len, f);
   }
   function of_increasing_sequence$3(seq){
    return of_increasing_sequence$1(comparator$0, seq);
   }
   function of_sequence$3(s){return of_sequence$1(comparator$0, s);}
   function of_sequence_or_error$3(s){
    return of_sequence_or_error$1(comparator$0, s);
   }
   function of_sequence_exn$3(s){return of_sequence_exn$1(comparator$0, s);}
   function of_sequence_multi$3(s){
    return of_sequence_multi$1(comparator$0, s);
   }
   function of_sequence_fold$3(s, init, f){
    return of_sequence_fold$1(comparator$0, s, init, f);
   }
   function of_sequence_reduce$3(s, f){
    return of_sequence_reduce$1(comparator$0, s, f);
   }
   function map_keys$3(t, f){return map_keys$1(comparator$0, t, f);}
   function map_keys_exn$3(t, f){return map_keys_exn$1(comparator$0, t, f);}
   var
    Base_Map =
      [0,
       Finished_or_unfinished,
       Merge_element,
       invariants$0,
       comparator_s,
       comparator,
       empty$2,
       singleton$1,
       of_alist$2,
       of_alist_or_error$2,
       of_alist_exn$2,
       of_alist_multi$2,
       of_alist_fold$2,
       of_alist_reduce$2,
       of_iteri$2,
       of_iteri_exn$2,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       of_increasing_sequence$2,
       of_sequence$2,
       of_sequence_or_error$2,
       of_sequence_exn$2,
       of_sequence_multi$2,
       of_sequence_fold$2,
       of_sequence_reduce$2,
       is_empty$0,
       length$0,
       set$1,
       add,
       add_exn$0,
       add_multi$0,
       remove_multi$0,
       find_multi$0,
       change$0,
       update$0,
       find$0,
       find_exn$0,
       remove$0,
       mem$0,
       iter_keys$0,
       iter$0,
       iteri$0,
       iteri_until$0,
       iter2$0,
       map$0,
       mapi$0,
       map_keys$2,
       map_keys_exn$2,
       fold$3,
       fold_until$0,
       fold_right$0,
       fold2$1,
       filter_keys$0,
       filter$0,
       filteri$0,
       filter_map$0,
       filter_mapi$0,
       partition_mapi$0,
       partition_map$0,
       partitioni_tf$0,
       partition_tf$0,
       combine_errors$0,
       compare_direct,
       hash_fold_direct,
       equal$2,
       keys$0,
       data$0,
       to_alist$0,
       merge$0,
       merge_skewed$0,
       Symmetric_diff_element,
       symmetric_diff$0,
       fold_symmetric_diff$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       for_all$0,
       for_alli$0,
       exists$0,
       existsi$0,
       count$0,
       counti$0,
       split$0,
       append$0,
       subrange,
       fold_range_inclusive$0,
       range_to_alist$0,
       closest_key$0,
       nth$1,
       nth_exn,
       rank$0,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       binary_search_subrange,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       [0,
        sexp_of_t$2,
        t_of_sexp_direct$1,
        [0,
         sexp_of_t$3,
         t_of_sexp_direct$0,
         empty$0,
         singleton,
         map_keys$0,
         map_keys_exn$0,
         of_alist$0,
         of_alist_or_error$0,
         of_alist_exn$0,
         of_alist_multi$0,
         of_alist_fold$0,
         of_alist_reduce$0,
         of_sorted_array$0,
         of_sorted_array_unchecked$0,
         of_increasing_iterator_uncheck$0,
         of_increasing_sequence$0,
         of_sequence$0,
         of_sequence_or_error$0,
         of_sequence_exn$0,
         of_sequence_multi$0,
         of_sequence_fold$0,
         of_sequence_reduce$0,
         of_iteri$0,
         of_iteri_exn$0,
         of_tree$1,
         invariants$1,
         is_empty$1,
         length$1,
         add$0,
         add_exn$1,
         set$2,
         add_multi$1,
         remove_multi$1,
         find_multi$1,
         change$1,
         update$1,
         find$1,
         find_exn$1,
         remove$1,
         mem$1,
         iter_keys$1,
         iter$1,
         iteri$1,
         iteri_until$1,
         iter2$1,
         map$1,
         mapi$1,
         fold$4,
         fold_until$1,
         fold_right$1,
         fold2$2,
         filter_keys$1,
         filter$1,
         filteri$1,
         filter_map$1,
         filter_mapi$1,
         partition_mapi$1,
         partition_map$1,
         partitioni_tf$1,
         partition_tf$1,
         combine_errors$1,
         compare_direct$0,
         equal$3,
         keys$1,
         data$1,
         to_alist$1,
         merge$1,
         merge_skewed$1,
         symmetric_diff$1,
         fold_symmetric_diff$1,
         min_elt$1,
         min_elt_exn$1,
         max_elt$1,
         max_elt_exn$1,
         for_all$1,
         for_alli$1,
         exists$1,
         existsi$1,
         count$1,
         counti$1,
         split$1,
         append$1,
         subrange$0,
         fold_range_inclusive$1,
         range_to_alist$1,
         closest_key$1,
         nth$2,
         nth_exn$0,
         rank$1,
         to_tree$0,
         to_sequence$1,
         binary_search$1,
         binary_search_segmented$1,
         binary_search_subrange$0,
         empty_without_value_restrictio,
         Build_increasing],
        invariants$0,
        is_empty$0,
        length$0,
        add,
        add_exn$0,
        set$1,
        add_multi$0,
        remove_multi$0,
        find_multi$0,
        change$0,
        update$0,
        find$0,
        find_exn$0,
        remove$0,
        mem$0,
        iter_keys$0,
        iter$0,
        iteri$0,
        iteri_until$0,
        iter2$0,
        map$0,
        mapi$0,
        fold$3,
        fold_until$0,
        fold_right$0,
        fold2$1,
        filter_keys$0,
        filter$0,
        filteri$0,
        filter_map$0,
        filter_mapi$0,
        partition_mapi$0,
        partition_map$0,
        partitioni_tf$0,
        partition_tf$0,
        combine_errors$0,
        compare_direct,
        equal$2,
        keys$0,
        data$0,
        to_alist$0,
        merge$0,
        merge_skewed$0,
        symmetric_diff$0,
        fold_symmetric_diff$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        for_all$0,
        for_alli$0,
        exists$0,
        existsi$0,
        count$0,
        counti$0,
        split$0,
        append$0,
        subrange,
        fold_range_inclusive$0,
        range_to_alist$0,
        closest_key$0,
        nth$1,
        nth_exn,
        rank$0,
        to_tree,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        binary_search_subrange,
        empty$1,
        singleton$0,
        map_keys$1,
        map_keys_exn$1,
        of_alist$1,
        of_alist_or_error$1,
        of_alist_exn$1,
        of_alist_multi$1,
        of_alist_fold$1,
        of_alist_reduce$1,
        of_sorted_array$1,
        of_sorted_array_unchecked$1,
        of_increasing_iterator_uncheck$1,
        of_increasing_sequence$1,
        of_sequence$1,
        of_sequence_or_error$1,
        of_sequence_exn$1,
        of_sequence_multi$1,
        of_sequence_fold$1,
        of_sequence_reduce$1,
        of_iteri$1,
        of_iteri_exn$1,
        of_tree$2,
        comparator,
        hash_fold_direct,
        Empty_without_value_restrictio],
       [0,
        empty$3,
        singleton$2,
        map_keys$3,
        map_keys_exn$3,
        of_alist$3,
        of_alist_or_error$3,
        of_alist_exn$3,
        of_alist_multi$3,
        of_alist_fold$3,
        of_alist_reduce$3,
        of_sorted_array$3,
        of_sorted_array_unchecked$3,
        of_increasing_iterator_uncheck$3,
        of_increasing_sequence$3,
        of_sequence$3,
        of_sequence_or_error$3,
        of_sequence_exn$3,
        of_sequence_multi$3,
        of_sequence_fold$3,
        of_sequence_reduce$3,
        of_iteri$3,
        of_iteri_exn$3,
        of_tree$4,
        invariants$0,
        is_empty$0,
        length$0,
        add,
        add_exn$0,
        set$1,
        add_multi$0,
        remove_multi$0,
        find_multi$0,
        change$0,
        update$0,
        find$0,
        find_exn$0,
        remove$0,
        mem$0,
        iter_keys$0,
        iter$0,
        iteri$0,
        iteri_until$0,
        iter2$0,
        map$0,
        mapi$0,
        fold$3,
        fold_until$0,
        fold_right$0,
        fold2$1,
        filter_keys$0,
        filter$0,
        filteri$0,
        filter_map$0,
        filter_mapi$0,
        partition_mapi$0,
        partition_map$0,
        partitioni_tf$0,
        partition_tf$0,
        combine_errors$0,
        compare_direct,
        equal$2,
        keys$0,
        data$0,
        to_alist$0,
        merge$0,
        merge_skewed$0,
        symmetric_diff$0,
        fold_symmetric_diff$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        for_all$0,
        for_alli$0,
        exists$0,
        existsi$0,
        count$0,
        counti$0,
        split$0,
        append$0,
        subrange,
        fold_range_inclusive$0,
        range_to_alist$0,
        closest_key$0,
        nth$1,
        nth_exn,
        rank$0,
        to_tree,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        binary_search_subrange],
       of_tree$3,
       to_tree];
   runtime.caml_register_global(67, Base_Map, "Base__Map");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Linked_queue0
//# unitInfo: Requires: Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Queue = global_data.Stdlib__Queue,
    create = Stdlib_Queue[2],
    clear = Stdlib_Queue[11],
    copy = Stdlib_Queue[12],
    is_empty = Stdlib_Queue[13],
    length = Stdlib_Queue[14],
    peek = Stdlib_Queue[8],
    pop = Stdlib_Queue[7],
    push = Stdlib_Queue[4],
    transfer = Stdlib_Queue[17];
   function iter(t, f){return caml_call2(Stdlib_Queue[15], f, t);}
   function fold(t, init, f){return caml_call3(Stdlib_Queue[16], f, init, t);}
   var
    Base_Linked_queue0 =
      [0,
       create,
       clear,
       copy,
       is_empty,
       length,
       peek,
       pop,
       push,
       transfer,
       iter,
       fold];
   runtime.caml_register_global(1, Base_Linked_queue0, "Base__Linked_queue0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Linked_queue
//# unitInfo: Requires: Base__Array, Base__Import, Base__Indexed_container, Base__Linked_queue0, Base__List, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Import = global_data.Base__Import,
    Base_Array = global_data.Base__Array,
    Base_Linked_queue0 = global_data.Base__Linked_queue0,
    Base_Indexed_container = global_data.Base__Indexed_container,
    create = Base_Linked_queue0[1],
    clear = Base_Linked_queue0[2],
    copy = Base_Linked_queue0[3],
    is_empty = Base_Linked_queue0[4],
    length = Base_Linked_queue0[5],
    iter = Base_Linked_queue0[10],
    fold = Base_Linked_queue0[11];
   function enqueue(t, x){return caml_call2(Base_Linked_queue0[8], x, t);}
   function dequeue(t){
    return caml_call1(is_empty, t)
            ? 0
            : [0, caml_call1(Base_Linked_queue0[7], t)];
   }
   var dequeue_exn = Base_Linked_queue0[7];
   function peek(t){
    return caml_call1(is_empty, t)
            ? 0
            : [0, caml_call1(Base_Linked_queue0[6], t)];
   }
   var
    peek_exn = Base_Linked_queue0[6],
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C =
      caml_call1
       (Base_Indexed_container[8],
        [0, fold, iter$0, length$0, -304398144, -304398144]),
    count = C[10],
    exists = C[8],
    find = C[12],
    find_map = C[13],
    fold_result = C[6],
    fold_until = C[7],
    for_all = C[9],
    max_elt = C[17],
    mem = C[1],
    min_elt = C[16],
    sum = C[11],
    to_list = C[14],
    counti = C[22],
    existsi = C[20],
    find_mapi = C[24],
    findi = C[23],
    foldi = C[18],
    for_alli = C[21],
    iteri = C[19];
   function transfer(src, dst){
    return caml_call2(Base_Linked_queue0[9], src, dst);
   }
   function concat_map(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       var _k_ = caml_call1(f, a);
       return caml_call2
               (Base_List[9], _k_, function(b){return enqueue(res, b);});
      });
    return res;
   }
   function concat_mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var _j_ = caml_call2(f, i, a);
       return caml_call2
               (Base_List[9], _j_, function(b){return enqueue(res, b);});
      });
    return res;
   }
   function filter_map(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       var match = caml_call1(f, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(res, b);
      });
    return res;
   }
   function filter_mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var match = caml_call2(f, i, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(res, b);
      });
    return res;
   }
   function filter(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       var _i_ = caml_call1(f, a);
       return _i_ ? enqueue(res, a) : _i_;
      });
    return res;
   }
   function filteri(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var _h_ = caml_call2(f, i, a);
       return _h_ ? enqueue(res, a) : _h_;
      });
    return res;
   }
   function map(t, f){
    var res = caml_call1(create, 0);
    caml_call2(iter, t, function(a){return enqueue(res, caml_call1(f, a));});
    return res;
   }
   function mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri, t, function(i, a){return enqueue(res, caml_call2(f, i, a));});
    return res;
   }
   function filter_inplace(q, f){
    var q$0 = filter(q, f);
    caml_call1(clear, q);
    return transfer(q$0, q);
   }
   function filteri_inplace(q, f){
    var q$0 = filteri(q, f);
    caml_call1(clear, q);
    return transfer(q$0, q);
   }
   function enqueue_all(t, list){
    return caml_call2(Base_List[9], list, function(x){return enqueue(t, x);});
   }
   function of_list(list){
    var t = caml_call1(create, 0);
    caml_call2(Base_List[9], list, function(x){return enqueue(t, x);});
    return t;
   }
   function of_array(array){
    var t = caml_call1(create, 0);
    caml_call2(Base_Array[9], array, function(x){return enqueue(t, x);});
    return t;
   }
   function init(len, f){
    var
     t = caml_call1(create, 0),
     _f_ = caml_call2(Base_Import[92], len, 1),
     _e_ = 0;
    if(_f_ >= 0){
     var i = _e_;
     for(;;){
      enqueue(t, caml_call1(f, i));
      var _g_ = i + 1 | 0;
      if(_f_ === i) break;
      i = _g_;
     }
    }
    return t;
   }
   function to_array(t){
    var len = caml_call1(length, t);
    if(0 === len) return [0];
    var
     _c_ = caml_call1(peek_exn, t),
     arr = caml_call2(Base_Array[25], len, _c_),
     i = [0, 0];
    caml_call2
     (iter,
      t,
      function(v){
       var _d_ = i[1];
       runtime.caml_check_bound(arr, _d_)[1 + _d_] = v;
       return caml_call1(Base_Import[129], i);
      });
    return arr;
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_Import[175], a_of_sexp, sexp));
   }
   function sexp_of_t(sexp_of_a, t){
    var _b_ = caml_call1(to_list, t);
    return caml_call2(Base_Import[151], sexp_of_a, _b_);
   }
   function t_sexp_grammar(grammar){
    var _a_ = caml_call1(Base_List[5], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _a_);
   }
   function singleton(a){
    var t = caml_call1(create, 0);
    enqueue(t, a);
    return t;
   }
   var
    Base_Linked_queue =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       singleton,
       of_list,
       of_array,
       init,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       peek,
       peek_exn,
       clear,
       copy,
       map,
       mapi,
       concat_map,
       concat_mapi,
       filter_map,
       filter_mapi,
       filter,
       filteri,
       filter_inplace,
       filteri_inplace,
       create,
       transfer];
   runtime.caml_register_global(6, Base_Linked_queue, "Base__Linked_queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int64
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Stdlib__Int64, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Lx = "%Lx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_float = runtime.caml_int64_of_float,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int64.Hex",
    module_name$0 = "Base.Int64",
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Int_math = global_data.Base__Int_math,
    Base_Comparable = global_data.Base__Comparable,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Error = global_data.Base__Error,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    hash_fold_t = Base_Import[203],
    func = Base_Import[217];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[168],
    sexp_of_t = Base_Import[144],
    t_sexp_grammar = Base_Import[188],
    hashable = [0, hash, Stdlib_Int64[15], sexp_of_t];
   function compare(_y_, _x_){return caml_int64_compare(_y_, _x_);}
   var
    to_string = Stdlib_Int64[14],
    of_string = runtime.caml_int64_of_string,
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1],
    num_bits = 64,
    float_lower_bound = caml_call1(Base_Float0[25], num_bits),
    float_upper_bound = caml_call1(Base_Float0[23], num_bits),
    float_of_bits = runtime.caml_int64_float_of_bits,
    bits_of_float = runtime.caml_int64_bits_of_float,
    shift_right_logical = caml_int64_shift_right_unsigne,
    shift_right = runtime.caml_int64_shift_right,
    shift_left = runtime.caml_int64_shift_left,
    bit_not = Stdlib_Int64[11],
    bit_xor = runtime.caml_int64_xor,
    bit_or = caml_int64_or,
    bit_and = caml_int64_and,
    min_value = Stdlib_Int64[10],
    max_value = Stdlib_Int64[9],
    abs = Stdlib_Int64[8],
    pred = Stdlib_Int64[7],
    succ = Stdlib_Int64[6],
    pow = Base_Int_math[2][2],
    rem = runtime.caml_int64_mod,
    neg = caml_int64_neg,
    minus_one = Stdlib_Int64[3],
    one = Stdlib_Int64[2],
    zero = Stdlib_Int64[1],
    to_float = runtime.caml_int64_to_float,
    of_float_unchecked = caml_int64_of_float,
    _a_ =
      [0,
       [11,
        "Int64.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int64.of_float: argument (%f) is out of range or NaN"];
   function of_float(f){
    if
     (caml_call2(Base_Import[107][6], f, float_lower_bound)
      && caml_call2(Base_Import[107][2], f, float_upper_bound))
     return caml_int64_of_float(f);
    var _w_ = caml_call1(Base_Float0[27], f);
    return caml_call3(Base_Printf[7], _a_, _w_, 0);
   }
   function symbol(b, e){return caml_call2(pow, b, e);}
   function bswap16(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 48);
   }
   function bswap32(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 32);
   }
   function bswap48(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 16);
   }
   var
    include$0 = caml_call1(Base_Comparable[13], [0, compare, sexp_of_t, zero]),
    is_positive = include$0[1],
    is_non_negative = include$0[2],
    is_negative = include$0[3],
    is_non_positive = include$0[4],
    sign = include$0[5],
    _b_ = [0, "src/int64.ml", 100, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function invariant(param){return 0;}
   function between(t, low, high){
    var
     _u_ = caml_lessequal(low, t),
     _v_ = _u_ ? caml_lessequal(t, high) : _u_;
    return _v_;
   }
   function clamp_unchecked(t, min, max){
    return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _r_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _s_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _r_],
     _t_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _s_);
    return caml_call1(Base_Or_error[35], _t_);
   }
   function incr(r){r[1] = caml_int64_add(r[1], one); return 0;}
   function decr(r){r[1] = caml_int64_sub(r[1], one); return 0;}
   function of_int64_exn(_q_){return _q_;}
   function to_int64(t){return t;}
   var
    popcount = Base_Popcount[3],
    of_int_exn = caml_int64_of_int32,
    to_int = Base_Int_conversions[11],
    to_int_exn = Base_Int_conversions[12],
    of_int32_exn = caml_int64_of_int32,
    to_int32 = Base_Int_conversions[14],
    to_int32_exn = Base_Int_conversions[15],
    of_nativeint = Base_Int_conversions[28],
    to_nativeint = Base_Int_conversions[17],
    to_nativeint_exn = Base_Int_conversions[18],
    raise_s = Base_Error[30],
    _c_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_Int64_floor_log2_got_inval = "[Int64.floor_log2] got invalid input",
    cst_Int64_ceil_log2_got_invali = "[Int64.ceil_log2] got invalid input";
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _c_, 0);
   }
   function ceil_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Int64[7], x),
     x$6 = caml_int64_or(x$0, caml_int64_shift_right_unsigne(x$0, 1)),
     x$5 = caml_int64_or(x$6, caml_int64_shift_right_unsigne(x$6, 2)),
     x$4 = caml_int64_or(x$5, caml_int64_shift_right_unsigne(x$5, 4)),
     x$3 = caml_int64_or(x$4, caml_int64_shift_right_unsigne(x$4, 8)),
     x$2 = caml_int64_or(x$3, caml_int64_shift_right_unsigne(x$3, 16)),
     x$1 = caml_int64_or(x$2, caml_int64_shift_right_unsigne(x$2, 32));
    return caml_call1(Stdlib_Int64[6], x$1);
   }
   function floor_pow2(x$0){
    if(caml_lessequal(x$0, Stdlib_Int64[1])) non_positive_argument(0);
    var
     x = caml_int64_or(x$0, caml_int64_shift_right_unsigne(x$0, 1)),
     x$5 = caml_int64_or(x, caml_int64_shift_right_unsigne(x, 2)),
     x$4 = caml_int64_or(x$5, caml_int64_shift_right_unsigne(x$5, 4)),
     x$3 = caml_int64_or(x$4, caml_int64_shift_right_unsigne(x$4, 8)),
     x$2 = caml_int64_or(x$3, caml_int64_shift_right_unsigne(x$3, 16)),
     x$1 = caml_int64_or(x$2, caml_int64_shift_right_unsigne(x$2, 32));
    return caml_int64_sub(x$1, caml_int64_shift_right_unsigne(x$1, 1));
   }
   function is_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var _p_ = Stdlib_Int64[1];
    return caml_equal(caml_int64_and(x, caml_call1(Stdlib_Int64[7], x)), _p_);
   }
   function floor_log2(i){
    if(caml_lessequal(i, Stdlib_Int64[1])){
     var _m_ = [0, [0, cst, caml_call1(Base_Import[144], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int64_floor_log2_got_inval, _m_));
    }
    var
     _n_ = runtime.Base_int_math_int64_clz(i),
     _o_ = caml_call2(Base_Import[92], num_bits, 1);
    return caml_call2(Base_Import[92], _o_, _n_);
   }
   function ceil_log2(i){
    if(caml_lessequal(i, Stdlib_Int64[1])){
     var _k_ = [0, [0, cst$0, caml_call1(Base_Import[144], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int64_ceil_log2_got_invali, _k_));
    }
    if(caml_call2(Stdlib_Int64[17], i, Stdlib_Int64[2])) return 0;
    var _l_ = runtime.Base_int_math_int64_clz(caml_call1(Stdlib_Int64[7], i));
    return caml_call2(Base_Import[92], num_bits, _l_);
   }
   var
    include$1 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$0 = include$1[2],
    compare$0 = Base_Import[230],
    hash_fold_t$0 = Base_Import[203],
    func$0 = Base_Import[217];
   function hash$0(x){return caml_call1(func$0, x);}
   var
    symbol$0 = caml_lessthan,
    _d_ = [0, [7, 6, 0, 0, 0], cst_Lx],
    _e_ = [0, [7, 6, 0, 0, 0], cst_Lx];
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$0(s){
    return caml_call3(Stdlib_Scanf[4], s, _e_, function(_j_){return _j_;});
   }
   var
    include$2 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$0,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$0,
         neg,
         module_name]),
    Hex = include$2[1],
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string])[1],
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         caml_int64_add,
         caml_int64_sub,
         runtime.caml_int64_mul,
         runtime.caml_int64_div,
         caml_int64_neg,
         runtime.caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         runtime.caml_notequal,
         abs,
         caml_int64_neg,
         zero,
         of_int_exn,
         rem]),
    symbol$1 = include$3[1],
    symbol$2 = include$3[2],
    symbol$3 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    include$4 = Base_Import[102],
    ascending = include$4[1],
    descending = include$4[2],
    max = include$4[3],
    min = include$4[4],
    Base_Int64 =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       caml_equal,
       function(_i_, _h_){return caml_int64_compare(_i_, _h_);},
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       one,
       minus_one,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint,
       to_nativeint_exn,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_g_){return runtime.Base_int_math_int64_clz(_g_);},
       function(_f_){return runtime.Base_int_math_int64_ctz(_f_);},
       [0, symbol, bit_not, abs, zero, symbol$1, symbol$2, symbol$3],
       symbol,
       bit_not,
       abs,
       zero,
       symbol$1,
       symbol$2,
       symbol$3,
       to_int,
       to_int32,
       of_nativeint,
       to_nativeint,
       bits_of_float,
       float_of_bits,
       bswap16,
       bswap32,
       bswap48];
   runtime.caml_register_global(29, Base_Int64, "Base__Int64");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int63_emul
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Float0, Base__Import, Base__Int64, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String, Stdlib__Int64, Stdlib__MoreLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_int63_emul_ml = "src/int63_emul.ml",
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_float = runtime.caml_int64_of_float,
    caml_int64_of_string = runtime.caml_int64_of_string,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_notequal = runtime.caml_notequal,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    _c_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    mask = runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
    module_name = "Base.Int63.Hex",
    module_name$0 = "Base.Int63",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Int64 = global_data.Base__Int64,
    Base_String = global_data.Base__String,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    Base_Popcount = global_data.Base__Popcount,
    Base_Comparator = global_data.Base__Comparator,
    Base_Int_math = global_data.Base__Int_math,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    compare = Base_Import[230],
    hash_fold_t = Base_Import[203],
    sexp_of_t = Base_Import[144],
    t_sexp_grammar = Base_Import[188],
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1],
    _a_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _e_ = [0, cst_src_int63_emul_ml, 114, 20];
   function wrap_exn(x){
    caml_call1(Base_Int_conversions[20], x);
    return caml_int64_mul(x, _a_);
   }
   function unwrap(x){return caml_int64_shift_right(x, 1);}
   function invariant(t){
    if(caml_equal(caml_int64_and(t, mask), t)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   var
    symbol = caml_int64_add,
    symbol$0 = caml_int64_sub,
    symbol$1 = caml_int64_neg;
   function abs(x){return caml_call1(Stdlib_Int64[8], x);}
   var one = wrap_exn(runtime.caml_int64_create_lo_mi_hi(1, 0, 0));
   function succ(a){return caml_int64_add(a, one);}
   function pred(a){return caml_int64_sub(a, one);}
   var
    x = Stdlib_Int64[10],
    min_value = caml_int64_and(x, mask),
    x$0 = Stdlib_Int64[9],
    max_value = caml_int64_and(x$0, mask);
   function bit_not(x){
    var x$0 = caml_call1(Stdlib_Int64[11], x);
    return caml_int64_and(x$0, mask);
   }
   var
    bit_and = caml_int64_and,
    bit_xor = runtime.caml_int64_xor,
    bit_or = runtime.caml_int64_or,
    shift_left = runtime.caml_int64_shift_left;
   function shift_right(x, i){
    var x$0 = caml_int64_shift_right(x, i);
    return caml_int64_and(x$0, mask);
   }
   function shift_right_logical(x, i){
    var x$0 = caml_int64_shift_right_unsigne(x, i);
    return caml_int64_and(x$0, mask);
   }
   var
    f = Base_Int_math[2][3],
    _d_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0);
   function pow(a, b){
    return caml_int64_mul
            (caml_call2
              (f, caml_int64_shift_right(a, 1), caml_int64_shift_right(b, 1)),
             _d_);
   }
   function symbol$2(a, b){
    return caml_int64_mul(a, caml_int64_shift_right(b, 1));
   }
   function symbol$3(a, b){
    var x = runtime.caml_int64_div(a, b);
    return caml_int64_mul(x, _c_);
   }
   var
    rem = runtime.caml_int64_mod,
    _b_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0);
   function popcount(x){return caml_call1(Base_Popcount[3], x);}
   function to_int64(t){return caml_int64_shift_right(t, 1);}
   function of_int64(t){
    return caml_call1(Base_Int_conversions[21], t)
            ? [0, caml_int64_mul(t, _b_)]
            : 0;
   }
   function of_int64_exn(t){return wrap_exn(t);}
   function of_int64_trunc(t){return caml_int64_mul(t, _c_);}
   function t_of_sexp(x){return wrap_exn(caml_call1(Base_Import[168], x));}
   function sexp_of_t$0(x){
    return caml_call1(Base_Import[144], caml_int64_shift_right(x, 1));
   }
   function compare$0(x, y){return caml_call2(compare, x, y);}
   function is_pow2(x){
    return caml_call1(Base_Int64[67], caml_int64_shift_right(x, 1));
   }
   function clz(x){return caml_call1(Base_Int64[68], x);}
   function ctz(x){
    return caml_call1(Base_Int64[69], caml_int64_shift_right(x, 1));
   }
   function floor_pow2(x){
    return wrap_exn(caml_call1(Base_Int64[64], caml_int64_shift_right(x, 1)));
   }
   function ceil_pow2(x){
    return wrap_exn(caml_call1(Base_Int64[64], caml_int64_shift_right(x, 1)));
   }
   function floor_log2(x){
    return caml_call1(Base_Int64[66], caml_int64_shift_right(x, 1));
   }
   function ceil_log2(x){
    return caml_call1(Base_Int64[65], caml_int64_shift_right(x, 1));
   }
   function hash(x){return caml_call1(Stdlib_MoreLabels[1][28], x);}
   var
    hashable = [0, hash, compare$0, sexp_of_t$0],
    _f_ =
      [0,
       [11, "Int63.of_string: invalid input ", [3, 0, 0]],
       "Int63.of_string: invalid input %S"],
    _g_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0);
   function invalid_str(x){return caml_call3(Base_Printf[6], _f_, x, 0);}
   function to_string(x){
    return caml_call1(Stdlib_Int64[14], caml_int64_shift_right(x, 1));
   }
   function of_string(str){
    try{
     var len = caml_ml_string_length(str);
     a:
     if(0 < len){
      var switcher = caml_string_get(str, 0) - 43 | 0;
      if(2 >= switcher >>> 0)
       switch(switcher){
         case 0:
          var sign = 4003188, pos = 1; break a;
         case 1: break;
         default: var sign = 3901488, pos = 1; break a;
       }
      var sign = 4003188, pos = 0;
     }
     else
      var sign = 4003188, pos = 0;
     if(caml_call2(Base_Import[90], pos, 2) < len)
      var
       c1 = caml_string_get(str, pos),
       c2 = caml_string_get(str, caml_call2(Base_Import[90], pos, 1)),
       match = 48 === c1 ? 9 < c2 - 48 >>> 0 ? [0, , 0] : [0, , 1] : [0, , 1];
     else
      var match = [0, , 1];
     var signedness = match[2];
     if(signedness)
      var t = caml_int64_of_string(str), _t_ = wrap_exn(t);
     else{
      if(4003188 <= sign)
       var pos_str = str;
      else
       var
        _u_ = caml_call2(Base_Import[92], caml_ml_string_length(str), 1),
        pos_str = caml_call3(Base_String[2], str, 1, _u_);
      var int64 = caml_int64_of_string(pos_str);
      if(caml_lessthan(int64, _g_)) invalid_str(str);
      var
       int63$0 = caml_int64_mul(int64, _c_),
       int63 = 4003188 <= sign ? int63$0 : caml_int64_neg(int63$0),
       _t_ = int63;
     }
     return _t_;
    }
    catch(_v_){return invalid_str(str);}
   }
   function bswap16(t){
    var x = caml_call1(Base_Int64[84], caml_int64_shift_right(t, 1));
    return caml_int64_mul(x, _c_);
   }
   function bswap32(t){
    var x = caml_call1(Base_Int64[85], caml_int64_shift_right(t, 1));
    return caml_int64_mul(x, _c_);
   }
   function bswap48(t){
    var x = caml_call1(Base_Int64[86], caml_int64_shift_right(t, 1));
    return caml_int64_mul(x, _c_);
   }
   var
    num_bits = 63,
    float_lower_bound = caml_call1(Base_Float0[25], num_bits),
    float_upper_bound = caml_call1(Base_Float0[23], num_bits),
    minus_one = wrap_exn(Stdlib_Int64[3]),
    one$0 = wrap_exn(Stdlib_Int64[2]),
    zero = wrap_exn(Stdlib_Int64[1]),
    _h_ =
      [0,
       [11,
        "Int63.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int63.of_float: argument (%f) is out of range or NaN"];
   function to_float(x){
    return runtime.caml_int64_to_float(caml_int64_shift_right(x, 1));
   }
   function of_float_unchecked(x){
    var x$0 = caml_int64_of_float(x);
    return caml_int64_mul(x$0, _c_);
   }
   function of_float(t){
    if
     (caml_call2(Base_Import[107][6], t, float_lower_bound)
      && caml_call2(Base_Import[107][2], t, float_upper_bound)){
     var x = caml_int64_of_float(t);
     return caml_int64_mul(x, _c_);
    }
    var _s_ = caml_call1(Base_Float0[27], t);
    return caml_call3(Base_Printf[7], _h_, _s_, 0);
   }
   var
    _i_ = caml_call1(Base_Comparable[13], [0, compare$0, sexp_of_t$0, zero]),
    is_positive = _i_[1],
    is_non_negative = _i_[2],
    is_negative = _i_[3],
    is_non_positive = _i_[4],
    sign = _i_[5],
    _j_ = [0, cst_src_int63_emul_ml, 317, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function between(t, low, high){
    var
     _q_ = caml_lessequal(low, t),
     _r_ = _q_ ? caml_lessequal(t, high) : _q_;
    return _r_;
   }
   function clamp_unchecked(t, min, max){
    return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _n_ = [0, [0, cst_max, sexp_of_t$0(max)], 0],
     _o_ = [0, [0, cst_min, sexp_of_t$0(min)], _n_],
     _p_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _o_);
    return caml_call1(Base_Or_error[35], _p_);
   }
   function symbol$4(b, e){return pow(b, e);}
   function incr(r){var x = r[1]; r[1] = caml_int64_add(x, one$0); return 0;}
   function decr(r){var x = r[1]; r[1] = caml_int64_sub(x, one$0); return 0;}
   function of_int(x){
    return wrap_exn(caml_call1(Base_Int_conversions[4], x));
   }
   function of_int_exn(x){return of_int(x);}
   function to_int(x){
    return caml_call1(Base_Int_conversions[11], caml_int64_shift_right(x, 1));
   }
   function to_int_exn(x){
    return caml_call1(Base_Int_conversions[12], caml_int64_shift_right(x, 1));
   }
   function to_int_trunc(x){
    return caml_call1(Base_Int_conversions[13], caml_int64_shift_right(x, 1));
   }
   function of_int32(x){
    return wrap_exn(caml_call1(Base_Int_conversions[9], x));
   }
   function of_int32_exn(x){return of_int32(x);}
   function to_int32(x){
    return caml_call1(Base_Int_conversions[14], caml_int64_shift_right(x, 1));
   }
   function to_int32_exn(x){
    return caml_call1(Base_Int_conversions[15], caml_int64_shift_right(x, 1));
   }
   function to_int32_trunc(x){
    return caml_call1(Base_Int_conversions[16], caml_int64_shift_right(x, 1));
   }
   function of_nativeint(x){
    return of_int64(caml_call1(Base_Int_conversions[28], x));
   }
   function of_nativeint_exn(x){
    return wrap_exn(caml_call1(Base_Int_conversions[28], x));
   }
   function of_nativeint_trunc(x){
    var t = caml_call1(Base_Int_conversions[28], x);
    return caml_int64_mul(t, _c_);
   }
   function to_nativeint(x){
    return caml_call1(Base_Int_conversions[17], caml_int64_shift_right(x, 1));
   }
   function to_nativeint_exn(x){
    return caml_call1(Base_Int_conversions[18], caml_int64_shift_right(x, 1));
   }
   function to_nativeint_trunc(x){
    return caml_call1(Base_Int_conversions[19], caml_int64_shift_right(x, 1));
   }
   var
    include$0 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$0[1],
    sexp_of_t$1 = include$0[2];
   function hash$0(x){return hash(x);}
   var
    symbol$5 = caml_lessthan,
    _k_ = [0, [7, 6, 0, 0, 0], "%Lx"],
    cst_0x = "0x";
   function to_string$0(i){
    return caml_call2
            (Base_Printf[2], _k_, caml_int64_shift_right_unsigne(i, 1));
   }
   function of_string$0(s){
    return of_string(caml_call2(Base_Import[111], cst_0x, s));
   }
   var
    include$1 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$0,
         hash_fold_t,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$5,
         symbol$1,
         module_name]),
    Hex = include$1[1];
   function to_string$1(x){return to_string(x);}
   var
    pp =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string$1])[1],
    symbol$6 = caml_notequal,
    symbol$7 = caml_lessthan,
    symbol$8 = caml_greaterthan,
    symbol$9 = caml_equal,
    symbol$10 = caml_lessequal,
    symbol$11 = caml_greaterequal,
    include$2 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol,
         symbol$0,
         symbol$2,
         symbol$3,
         symbol$1,
         symbol$11,
         symbol$10,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         abs,
         symbol$1,
         zero,
         of_int_exn,
         rem]),
    symbol$12 = include$2[1],
    symbol$13 = include$2[2],
    symbol$14 = include$2[3],
    round = include$2[4],
    round_towards_zero = include$2[5],
    round_down = include$2[6],
    round_up = include$2[7],
    round_nearest = include$2[8],
    Repr = [0],
    include$3 = Base_Import[102],
    ascending = include$3[1],
    descending = include$3[2],
    max = include$3[3],
    min = include$3[4],
    Base_Int63_emul =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$1,
       of_string,
       to_string,
       caml_greaterequal,
       caml_lessequal,
       caml_equal,
       caml_greaterthan,
       caml_lessthan,
       caml_notequal,
       caml_equal,
       function(_m_, _l_){return runtime.caml_int64_compare(_m_, _l_);},
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       zero,
       one$0,
       minus_one,
       symbol,
       symbol$0,
       symbol$2,
       symbol$4,
       symbol$1,
       symbol$1,
       symbol$13,
       symbol$12,
       symbol$3,
       rem,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint_exn,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       clz,
       ctz,
       [0,
        symbol,
        symbol$0,
        symbol$2,
        symbol$3,
        symbol$1,
        symbol$4,
        symbol$11,
        symbol$10,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        abs,
        symbol$1,
        zero,
        symbol$12,
        symbol$13,
        symbol$14,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        shift_left,
        shift_right,
        shift_right_logical],
       of_int,
       to_int,
       to_int_trunc,
       of_int32,
       to_int32,
       to_int32_trunc,
       of_int64,
       of_int64_trunc,
       of_nativeint,
       to_nativeint,
       of_nativeint_trunc,
       to_nativeint_trunc,
       bswap16,
       bswap32,
       bswap48,
       [0, wrap_exn, unwrap],
       Repr,
       1];
   runtime.caml_register_global(34, Base_Int63_emul, "Base__Int63_emul");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bool
//# unitInfo: Requires: Assert_failure, Base__Comparator, Base__Import, Base__Or_error, Base__Pretty_printer, Base__Printf, Base__Sexp
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_bool_ml = "src/bool.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, 0]],
    module_name = "Base.Bool",
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Printf = global_data.Base__Printf,
    Base_Comparator = global_data.Base__Comparator,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    invalid_argf = Base_Printf[7],
    compare = Base_Import[225],
    hash_fold_t = Base_Import[207],
    func = Base_Import[221];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[161],
    sexp_of_t = Base_Import[137],
    t_sexp_grammar = Base_Import[181],
    hashable = [0, hash, compare, sexp_of_t],
    _a_ =
      [0,
       [11, "Bool.of_string: expected true or false but got ", [2, 0, 0]],
       "Bool.of_string: expected true or false but got %s"];
   function of_string(s){
    return s !== "false"
            ? s !== "true" ? caml_call3(invalid_argf, _a_, s, 0) : 1
            : 0;
   }
   var
    to_string = Base_Import[84][29],
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1],
    include$0 =
      caml_call1(Base_Pretty_printer[2], [0, module_name, to_string]),
    pp = include$0[1],
    _b_ = [0, cst_src_bool_ml, 56, 2],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function invariant(param){return 0;}
   function between(t, low, high){
    var _k_ = caml_call2(Base_Import[104][2], low, t);
    return _k_ ? caml_call2(Base_Import[104][2], t, high) : _k_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[104][1], t, min)
            ? min
            : caml_call2(Base_Import[104][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[104][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[104][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _h_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _i_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _h_],
     _j_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _i_);
    return caml_call1(Base_Or_error[35], _j_);
   }
   function to_int(x){return caml_call1(Base_Import[85], x);}
   function symbol(a, b){
    var
     _f_ = to_int(b),
     _g_ = to_int(a),
     x = caml_call2(Base_Import[117], _g_, _f_);
    return x;
   }
   function symbol$0(a, b){
    var
     _d_ = to_int(b),
     _e_ = to_int(a),
     x = caml_call2(Base_Import[115], _e_, _d_);
    return x;
   }
   var _c_ = [0, cst_src_bool_ml, 83, 9];
   if(1 === to_int(1) && 0 === to_int(0)){
    var
     include$1 = Base_Import[104],
     symbol$1 = include$1[1],
     symbol$2 = include$1[2],
     symbol$3 = include$1[3],
     symbol$4 = include$1[4],
     symbol$5 = include$1[5],
     symbol$6 = include$1[6],
     ascending = include$1[7],
     descending = include$1[8],
     compare$0 = include$1[9],
     equal = include$1[10],
     max = include$1[11],
     min = include$1[12],
     Base_Bool =
       [0,
        all,
        t_sexp_grammar,
        hash_fold_t,
        hash,
        t_of_sexp,
        sexp_of_t,
        of_string,
        to_string,
        symbol$6,
        symbol$2,
        symbol$4,
        symbol$5,
        symbol$1,
        symbol$3,
        equal,
        compare$0,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator,
        pp,
        hashable,
        invariant,
        to_int,
        [0, symbol$0, symbol]];
    runtime.caml_register_global(17, Base_Bool, "Base__Bool");
    return;
   }
   throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
  }
  (globalThis));

//# unitInfo: Provides: Base__Int32
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Stdlib__Int32, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_lx = "%lx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int32.Hex",
    module_name$0 = "Base.Int32",
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Int_math = global_data.Base__Int_math,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Error = global_data.Base__Error,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    hash_fold_t = Base_Import[204],
    func = Base_Import[218];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[167],
    sexp_of_t = Base_Import[143],
    t_sexp_grammar = Base_Import[187],
    hashable = [0, hash, Stdlib_Int32[15], sexp_of_t];
   function ascending(x, y){return caml_call2(Stdlib_Int32[15], x, y);}
   var
    to_string = Stdlib_Int32[14],
    of_string = runtime.caml_int_of_string,
    include = caml_call1(Base_Comparator[5], [0, ascending, sexp_of_t]),
    comparator = include[1],
    num_bits = 32,
    float_lower_bound = caml_call1(Base_Float0[25], num_bits),
    float_upper_bound = caml_call1(Base_Float0[23], num_bits),
    float_of_bits = runtime.caml_int32_float_of_bits,
    bits_of_float = runtime.caml_int32_bits_of_float;
   function shift_right_logical(_O_, _N_){return _O_ >>> _N_ | 0;}
   function shift_right(_M_, _L_){return _M_ >> _L_;}
   function shift_left(_K_, _J_){return _K_ << _J_;}
   var bit_not = Stdlib_Int32[11];
   function bit_xor(_I_, _H_){return _I_ ^ _H_;}
   function bit_or(_G_, _F_){return _G_ | _F_;}
   function bit_and(_E_, _D_){return _E_ & _D_;}
   var
    min_value = Stdlib_Int32[10],
    max_value = Stdlib_Int32[9],
    abs = Stdlib_Int32[8],
    pred = Stdlib_Int32[7],
    succ = Stdlib_Int32[6],
    rem = runtime.caml_mod;
   function symbol(_C_){return - _C_ | 0;}
   var
    minus_one = Stdlib_Int32[3],
    one = Stdlib_Int32[2],
    zero = Stdlib_Int32[1],
    _a_ =
      [0,
       [11,
        "Int32.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int32.of_float: argument (%f) is out of range or NaN"];
   function to_float(_B_){return _B_;}
   function of_float_unchecked(_A_){return _A_ | 0;}
   function of_float(f){
    if
     (caml_call2(Base_Import[107][6], f, float_lower_bound)
      && caml_call2(Base_Import[107][2], f, float_upper_bound))
     return f | 0;
    var _z_ = caml_call1(Base_Float0[27], f);
    return caml_call3(Base_Printf[7], _a_, _z_, 0);
   }
   var
    include$0 =
      caml_call1(Base_Comparable[13], [0, ascending, sexp_of_t, zero]),
    is_positive = include$0[1],
    is_non_negative = include$0[2],
    is_negative = include$0[3],
    is_non_positive = include$0[4],
    sign = include$0[5],
    symbol$0 = runtime.caml_greaterequal,
    symbol$1 = caml_lessequal,
    symbol$2 = caml_equal,
    symbol$3 = caml_greaterthan,
    symbol$4 = caml_lessthan,
    symbol$5 = runtime.caml_notequal,
    _b_ = [0, "src/int32.ml", 97, 4],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]";
   function descending(x, y){return ascending(y, x);}
   function min(x, y){return caml_lessthan(x, y) ? x : y;}
   function max(x, y){return caml_greaterthan(x, y) ? x : y;}
   function equal(x, y){return caml_equal(x, y);}
   function between(t, low, high){
    var _y_ = caml_lessequal(low, t);
    return _y_ ? caml_lessequal(t, high) : _y_;
   }
   function clamp_unchecked(t, min, max){
    return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _v_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _w_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _v_],
     _x_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _w_);
    return caml_call1(Base_Or_error[35], _x_);
   }
   function invariant(param){return 0;}
   var symbol$6 = runtime.caml_div, symbol$7 = runtime.caml_mul;
   function symbol$8(_u_, _t_){return _u_ - _t_ | 0;}
   function symbol$9(_s_, _r_){return _s_ + _r_ | 0;}
   function incr(r){r[1] = r[1] + one | 0; return 0;}
   function decr(r){r[1] = r[1] - one | 0; return 0;}
   function of_int32(t){return t;}
   function to_int32(t){return t;}
   var
    popcount = Base_Popcount[2],
    of_int = Base_Int_conversions[1],
    of_int_exn = Base_Int_conversions[2],
    of_int_trunc = Base_Int_conversions[3],
    to_int = Base_Int_conversions[6],
    to_int_exn = Base_Int_conversions[7],
    to_int_trunc = Base_Int_conversions[8],
    of_int64 = Base_Int_conversions[14],
    of_int64_exn = Base_Int_conversions[15],
    of_int64_trunc = Base_Int_conversions[16],
    to_int64 = Base_Int_conversions[9],
    of_nativeint = Base_Int_conversions[25],
    of_nativeint_exn = Base_Int_conversions[26],
    of_nativeint_trunc = Base_Int_conversions[27],
    to_nativeint = Base_Int_conversions[10];
   function pow(b, e){
    var _p_ = caml_call1(to_int_exn, e), _q_ = caml_call1(to_int_exn, b);
    return caml_call1(of_int_exn, caml_call2(Base_Int_math[2][1], _q_, _p_));
   }
   function symbol$10(b, e){return pow(b, e);}
   function bswap16(x){return caml_int32_bswap(x) >>> 16 | 0;}
   var
    raise_s = Base_Error[30],
    _c_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_Int32_floor_log2_got_inval = "[Int32.floor_log2] got invalid input",
    cst_Int32_ceil_log2_got_invali = "[Int32.ceil_log2] got invalid input";
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _c_, 0);
   }
   function ceil_pow2(x){
    if(caml_call2(Base_Import[101][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Int32[7], x),
     x$5 = x$0 | x$0 >>> 1 | 0,
     x$4 = x$5 | x$5 >>> 2 | 0,
     x$3 = x$4 | x$4 >>> 4 | 0,
     x$2 = x$3 | x$3 >>> 8 | 0,
     x$1 = x$2 | x$2 >>> 16 | 0;
    return caml_call1(Stdlib_Int32[6], x$1);
   }
   function floor_pow2(x$0){
    if(caml_call2(Base_Import[101][2], x$0, Stdlib_Int32[1]))
     non_positive_argument(0);
    var
     x = x$0 | x$0 >>> 1 | 0,
     x$4 = x | x >>> 2 | 0,
     x$3 = x$4 | x$4 >>> 4 | 0,
     x$2 = x$3 | x$3 >>> 8 | 0,
     x$1 = x$2 | x$2 >>> 16 | 0;
    return x$1 - (x$1 >>> 1 | 0) | 0;
   }
   function is_pow2(x){
    if(caml_call2(Base_Import[101][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var _o_ = Stdlib_Int32[1], _n_ = x & caml_call1(Stdlib_Int32[7], x);
    return caml_call2(Base_Import[101][4], _n_, _o_);
   }
   function floor_log2(i){
    if(caml_call2(Base_Import[101][2], i, Stdlib_Int32[1])){
     var _k_ = [0, [0, cst, caml_call1(Base_Import[143], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int32_floor_log2_got_inval, _k_));
    }
    var
     _l_ = runtime.Base_int_math_int32_clz(i),
     _m_ = caml_call2(Base_Import[92], num_bits, 1);
    return caml_call2(Base_Import[92], _m_, _l_);
   }
   function ceil_log2(i){
    if(caml_call2(Base_Import[101][2], i, Stdlib_Int32[1])){
     var _i_ = [0, [0, cst$0, caml_call1(Base_Import[143], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int32_ceil_log2_got_invali, _i_));
    }
    if(caml_call2(Stdlib_Int32[17], i, Stdlib_Int32[2])) return 0;
    var _j_ = runtime.Base_int_math_int32_clz(caml_call1(Stdlib_Int32[7], i));
    return caml_call2(Base_Import[92], num_bits, _j_);
   }
   var
    include$1 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$0 = include$1[2],
    compare = Base_Import[229],
    hash_fold_t$0 = Base_Import[204],
    func$0 = Base_Import[218],
    _d_ = [0, [5, 6, 0, 0, 0], cst_lx],
    _e_ = [0, [5, 6, 0, 0, 0], cst_lx];
   function hash$0(x){return caml_call1(func$0, x);}
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$0(s){
    return caml_call3(Stdlib_Scanf[4], s, _e_, function(_h_){return _h_;});
   }
   var
    include$2 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$4,
         symbol,
         module_name]),
    Hex = include$2[1],
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string])[1],
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         symbol,
         symbol$0,
         symbol$1,
         symbol$2,
         symbol$3,
         symbol$4,
         symbol$5,
         abs,
         symbol,
         zero,
         of_int_exn,
         rem]),
    symbol$11 = include$3[1],
    symbol$12 = include$3[2],
    symbol$13 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    Base_Int32 =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       equal,
       ascending,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       zero,
       one,
       minus_one,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$10,
       symbol,
       symbol,
       symbol$12,
       symbol$11,
       symbol$6,
       rem,
       symbol$13,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32,
       to_int32,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_g_){return runtime.Base_int_math_int32_clz(_g_);},
       function(_f_){return runtime.Base_int_math_int32_ctz(_f_);},
       [0,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        symbol,
        symbol$10,
        symbol$0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol$5,
        abs,
        symbol,
        zero,
        symbol$11,
        symbol$12,
        symbol$13,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        shift_left,
        shift_right,
        shift_right_logical],
       of_int,
       to_int,
       of_int32,
       to_int32,
       of_nativeint,
       to_nativeint,
       of_int64,
       of_int_trunc,
       to_int_trunc,
       of_nativeint_trunc,
       of_int64_trunc,
       bits_of_float,
       float_of_bits,
       bswap16,
       caml_int32_bswap];
   runtime.caml_register_global(29, Base_Int32, "Base__Int32");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int63
//# unitInfo: Requires: Assert_failure, Base__Bool, Base__Error, Base__Import, Base__Int, Base__Int63_emul, Base__Int64, Base__Random, Base__Sexp, Base__Word_size
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_product$1 = "product",
    cst_t$3 = "t",
    cst_u$3 = "u",
    caml_div = runtime.caml_div,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Word_size = global_data.Base__Word_size,
    Base_Int = global_data.Base__Int,
    Base_Sexp = global_data.Base__Sexp,
    Base_Random = global_data.Base__Random,
    Base_Import = global_data.Base__Import,
    Base_Bool = global_data.Base__Bool,
    Base_Int64 = global_data.Base__Int64,
    Base_Error = global_data.Base__Error,
    Base_Int63_emul = global_data.Base__Int63_emul,
    Assert_failure = global_data.Assert_failure,
    raise_s = Base_Error[30],
    cst_Int_floor_log2_got_invalid = "[Int.floor_log2] got invalid input",
    cst_neg_overflow = "neg overflow",
    cst_abs_overflow = "abs overflow",
    cst_product$0 = cst_product$1,
    cst_u$2 = cst_u$3,
    cst_t$2 = cst_t$3,
    cst_overflow$2 = "( / ) overflow",
    cst_product = cst_product$1,
    cst_u$1 = cst_u$3,
    cst_t$1 = cst_t$3,
    cst_overflow$1 = "( * ) overflow",
    cst_diff = "diff",
    cst_u$0 = cst_u$3,
    cst_t$0 = cst_t$3,
    cst_overflow$0 = "( - ) overflow",
    cst_sum = "sum",
    cst_u = cst_u$3,
    cst_t = cst_t$3,
    cst_overflow = "( + ) overflow",
    _b_ = [0, "src/int63.ml", 155, 9],
    repr = Base_Word_size[3] ? 0 : 1,
    t_sexp_grammar = Base_Int[1],
    of_float = Base_Int[2],
    to_float = Base_Int[3],
    of_int_exn = Base_Int[4],
    to_int_exn = Base_Int[5],
    hash_fold_t = Base_Int[6],
    hash = Base_Int[7],
    t_of_sexp = Base_Int[8],
    sexp_of_t = Base_Int[9],
    of_string = Base_Int[10],
    to_string = Base_Int[11],
    equal = Base_Int[12],
    compare = Base_Int[13],
    min = Base_Int[14],
    max = Base_Int[15],
    ascending = Base_Int[16],
    descending = Base_Int[17],
    between = Base_Int[18],
    clamp_exn = Base_Int[19],
    clamp = Base_Int[20],
    comparator = Base_Int[21],
    pp = Base_Int[22],
    hashable = Base_Int[23],
    is_positive = Base_Int[24],
    is_non_negative = Base_Int[25],
    is_negative = Base_Int[26],
    is_non_positive = Base_Int[27],
    sign = Base_Int[28],
    invariant = Base_Int[29],
    Hex = Base_Int[30],
    to_string_hum = Base_Int[31],
    one = Base_Int[32],
    minus_one = Base_Int[33],
    rem = Base_Int[34],
    round = Base_Int[35],
    round_towards_zero = Base_Int[36],
    round_down = Base_Int[37],
    round_up = Base_Int[38],
    round_nearest = Base_Int[39],
    succ = Base_Int[40],
    pred = Base_Int[41],
    pow = Base_Int[42],
    bit_and = Base_Int[43],
    bit_or = Base_Int[44],
    bit_xor = Base_Int[45],
    bit_not = Base_Int[46],
    popcount = Base_Int[47],
    shift_left = Base_Int[48],
    shift_right = Base_Int[49],
    decr = Base_Int[50],
    incr = Base_Int[51],
    of_int32_exn = Base_Int[52],
    to_int32_exn = Base_Int[53],
    of_int64_exn = Base_Int[54],
    to_int64 = Base_Int[55],
    of_nativeint_exn = Base_Int[56],
    to_nativeint_exn = Base_Int[57],
    of_float_unchecked = Base_Int[58],
    num_bits = Base_Int[59],
    max_value = Base_Int[60],
    min_value = Base_Int[61],
    shift_right_logical = Base_Int[62],
    ceil_pow2 = Base_Int[63],
    floor_pow2 = Base_Int[64],
    ceil_log2 = Base_Int[65],
    is_pow2 = Base_Int[67],
    clz = Base_Int[68],
    ctz = Base_Int[69],
    O = Base_Int[70],
    symbol = Base_Int[71],
    lnot = Base_Int[72],
    abs = Base_Int[73],
    zero = Base_Int[74],
    symbol$0 = Base_Int[75],
    symbol$1 = Base_Int[76],
    symbol$2 = Base_Int[77],
    of_int = Base_Int[79],
    to_int32 = Base_Int[82],
    of_int64 = Base_Int[83],
    of_nativeint = Base_Int[84],
    _a_ = Base_Int[85];
   function to_int(x){return [0, x];}
   function to_int_trunc(x){return x;}
   function to_nativeint_trunc(x){return caml_call1(_a_, x);}
   function to_nativeint(x){return [0, caml_call1(_a_, x)];}
   function bswap32(t){
    return caml_int64_to_int32
            (caml_call1(Base_Int64[85], caml_int64_of_int32(t)));
   }
   function bswap48(t){
    return caml_int64_to_int32
            (caml_call1(Base_Int64[86], caml_int64_of_int32(t)));
   }
   var
    repr$0 = 0,
    include =
      repr
       ? [0,
         Base_Int63_emul[1],
         Base_Int63_emul[2],
         Base_Int63_emul[3],
         Base_Int63_emul[4],
         Base_Int63_emul[5],
         Base_Int63_emul[6],
         Base_Int63_emul[7],
         Base_Int63_emul[8],
         Base_Int63_emul[9],
         Base_Int63_emul[10],
         Base_Int63_emul[11],
         Base_Int63_emul[12],
         Base_Int63_emul[13],
         Base_Int63_emul[14],
         Base_Int63_emul[15],
         Base_Int63_emul[16],
         Base_Int63_emul[17],
         Base_Int63_emul[18],
         Base_Int63_emul[19],
         Base_Int63_emul[20],
         Base_Int63_emul[21],
         Base_Int63_emul[22],
         Base_Int63_emul[23],
         Base_Int63_emul[24],
         Base_Int63_emul[25],
         Base_Int63_emul[26],
         Base_Int63_emul[27],
         Base_Int63_emul[28],
         Base_Int63_emul[29],
         Base_Int63_emul[30],
         Base_Int63_emul[31],
         Base_Int63_emul[32],
         Base_Int63_emul[33],
         Base_Int63_emul[34],
         Base_Int63_emul[35],
         Base_Int63_emul[36],
         Base_Int63_emul[37],
         Base_Int63_emul[38],
         Base_Int63_emul[39],
         Base_Int63_emul[40],
         Base_Int63_emul[41],
         Base_Int63_emul[42],
         Base_Int63_emul[43],
         Base_Int63_emul[44],
         Base_Int63_emul[45],
         Base_Int63_emul[46],
         Base_Int63_emul[47],
         Base_Int63_emul[48],
         Base_Int63_emul[49],
         Base_Int63_emul[50],
         Base_Int63_emul[51],
         Base_Int63_emul[52],
         Base_Int63_emul[53],
         Base_Int63_emul[54],
         Base_Int63_emul[55],
         Base_Int63_emul[56],
         Base_Int63_emul[57],
         Base_Int63_emul[58],
         Base_Int63_emul[59],
         Base_Int63_emul[60],
         Base_Int63_emul[61],
         Base_Int63_emul[62],
         Base_Int63_emul[63],
         Base_Int63_emul[64],
         Base_Int63_emul[65],
         Base_Int63_emul[66],
         Base_Int63_emul[67],
         Base_Int63_emul[68],
         Base_Int63_emul[69],
         Base_Int63_emul[70],
         Base_Int63_emul[71],
         Base_Int63_emul[72],
         Base_Int63_emul[73],
         Base_Int63_emul[74],
         Base_Int63_emul[75],
         Base_Int63_emul[76],
         Base_Int63_emul[77],
         Base_Int63_emul[78],
         Base_Int63_emul[79],
         Base_Int63_emul[80],
         Base_Int63_emul[81],
         Base_Int63_emul[83],
         Base_Int63_emul[84],
         Base_Int63_emul[85],
         Base_Int63_emul[86],
         Base_Int63_emul[87],
         Base_Int63_emul[88],
         Base_Int63_emul[89],
         Base_Int63_emul[90],
         ,
         Base_Int63_emul[92],
         Base_Int63_emul[93],
         Base_Int63_emul[94],
         Base_Int63_emul[95],
         Base_Int63_emul[96],
         Base_Int63_emul[97],
         Base_Int63_emul[98],
         Base_Int63_emul[99],
         Base_Int63_emul[100],
         Base_Int63_emul[101],
         Base_Int63_emul[102],
         Base_Int63_emul[103],
         Base_Int63_emul[104],
         Base_Int63_emul[105],
         Base_Int63_emul[106],
         Base_Int63_emul[107],
         Base_Int63_emul[82],
         Base_Int63_emul[113],
         Base_Int63_emul[108],
         Base_Int63_emul[109],
         Base_Int63_emul[110]]
       : [0,
         t_sexp_grammar,
         of_float,
         to_float,
         of_int_exn,
         to_int_exn,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         function(_aG_, _aF_){return _aF_ <= _aG_ ? 1 : 0;},
         function(_aE_, _aD_){return _aE_ <= _aD_ ? 1 : 0;},
         function(_aC_, _aB_){return _aC_ === _aB_ ? 1 : 0;},
         function(_aA_, _az_){return _az_ < _aA_ ? 1 : 0;},
         function(_ay_, _ax_){return _ay_ < _ax_ ? 1 : 0;},
         function(_aw_, _av_){return _aw_ !== _av_ ? 1 : 0;},
         equal,
         compare,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator,
         pp,
         hashable,
         is_positive,
         is_non_negative,
         is_negative,
         is_non_positive,
         sign,
         invariant,
         Hex,
         to_string_hum,
         zero,
         one,
         minus_one,
         function(_au_, _at_){return _au_ + _at_ | 0;},
         function(_as_, _ar_){return _as_ - _ar_ | 0;},
         caml_mul,
         symbol,
         function(_aq_){return - _aq_ | 0;},
         function(_ap_){return - _ap_ | 0;},
         symbol$1,
         symbol$0,
         caml_div,
         rem,
         symbol$2,
         function(_ao_, _an_){return _ao_ & _an_;},
         function(_am_, _al_){return _am_ | _al_;},
         function(_ak_, _aj_){return _ak_ ^ _aj_;},
         lnot,
         function(_ai_, _ah_){return _ai_ << _ah_;},
         function(_ag_, _af_){return _ag_ >> _af_;},
         round,
         round_towards_zero,
         round_down,
         round_up,
         round_nearest,
         abs,
         succ,
         pred,
         pow,
         bit_and,
         bit_or,
         bit_xor,
         bit_not,
         popcount,
         shift_left,
         shift_right,
         decr,
         incr,
         of_int32_exn,
         to_int32_exn,
         of_int64_exn,
         to_int64,
         of_nativeint_exn,
         to_nativeint_exn,
         num_bits,
         max_value,
         min_value,
         function(_ae_, _ad_){return _ae_ >>> _ad_ | 0;},
         shift_right_logical,
         ceil_pow2,
         floor_pow2,
         ceil_log2,
         ,
         is_pow2,
         clz,
         ctz,
         [0,
          function(_ac_, _ab_){return _ac_ + _ab_ | 0;},
          function(_aa_, _$_){return _aa_ - _$_ | 0;},
          caml_mul,
          caml_div,
          function(___){return - ___ | 0;},
          O[1],
          function(_Z_, _Y_){return _Y_ <= _Z_ ? 1 : 0;},
          function(_X_, _W_){return _X_ <= _W_ ? 1 : 0;},
          function(_V_, _U_){return _V_ === _U_ ? 1 : 0;},
          function(_T_, _S_){return _S_ < _T_ ? 1 : 0;},
          function(_R_, _Q_){return _R_ < _Q_ ? 1 : 0;},
          function(_P_, _O_){return _P_ !== _O_ ? 1 : 0;},
          O[3],
          function(_N_){return - _N_ | 0;},
          O[4],
          O[5],
          O[6],
          O[7],
          function(_M_, _L_){return _M_ & _L_;},
          function(_K_, _J_){return _K_ | _J_;},
          function(_I_, _H_){return _I_ ^ _H_;},
          O[2],
          function(_G_, _F_){return _G_ << _F_;},
          function(_E_, _D_){return _E_ >> _D_;},
          function(_C_, _B_){return _C_ >>> _B_ | 0;}],
         of_int,
         to_int,
         to_int_trunc,
         of_int32_exn,
         to_int32,
         function(_A_){return _A_;},
         of_int64,
         caml_int64_to_int32,
         of_nativeint,
         to_nativeint,
         function(_z_){return _z_;},
         to_nativeint_trunc,
         of_float_unchecked,
         repr$0,
         runtime.caml_bswap16,
         bswap32,
         bswap48],
    t_sexp_grammar$0 = include[1],
    of_float$0 = include[2],
    to_float$0 = include[3],
    of_int_exn$0 = include[4],
    to_int_exn$0 = include[5],
    hash_fold_t$0 = include[6],
    hash$0 = include[7],
    t_of_sexp$0 = include[8],
    sexp_of_t$0 = include[9],
    of_string$0 = include[10],
    to_string$0 = include[11],
    symbol$3 = include[12],
    symbol$4 = include[13],
    symbol$5 = include[14],
    symbol$6 = include[15],
    symbol$7 = include[16],
    symbol$8 = include[17],
    equal$0 = include[18],
    compare$0 = include[19],
    min$0 = include[20],
    max$0 = include[21],
    ascending$0 = include[22],
    descending$0 = include[23],
    between$0 = include[24],
    clamp_exn$0 = include[25],
    clamp$0 = include[26],
    comparator$0 = include[27],
    pp$0 = include[28],
    hashable$0 = include[29],
    is_positive$0 = include[30],
    is_non_negative$0 = include[31],
    is_negative$0 = include[32],
    is_non_positive$0 = include[33],
    sign$0 = include[34],
    invariant$0 = include[35],
    Hex$0 = include[36],
    to_string_hum$0 = include[37],
    zero$0 = include[38],
    one$0 = include[39],
    minus_one$0 = include[40],
    symbol$9 = include[41],
    symbol$10 = include[42],
    symbol$11 = include[43],
    symbol$12 = include[44],
    neg = include[45],
    symbol$13 = include[46],
    symbol$14 = include[47],
    symbol$15 = include[48],
    symbol$16 = include[49],
    rem$0 = include[50],
    symbol$17 = include[51],
    land = include[52],
    lor = include[53],
    lxor = include[54],
    lnot$0 = include[55],
    lsl = include[56],
    asr = include[57],
    round$0 = include[58],
    round_towards_zero$0 = include[59],
    round_down$0 = include[60],
    round_up$0 = include[61],
    round_nearest$0 = include[62],
    abs$0 = include[63],
    succ$0 = include[64],
    pred$0 = include[65],
    pow$0 = include[66],
    bit_and$0 = include[67],
    bit_or$0 = include[68],
    bit_xor$0 = include[69],
    bit_not$0 = include[70],
    popcount$0 = include[71],
    shift_left$0 = include[72],
    shift_right$0 = include[73],
    decr$0 = include[74],
    incr$0 = include[75],
    of_int32_exn$0 = include[76],
    to_int32_exn$0 = include[77],
    of_int64_exn$0 = include[78],
    to_int64$0 = include[79],
    of_nativeint_exn$0 = include[80],
    to_nativeint_exn$0 = include[81],
    num_bits$0 = include[82],
    max_value$0 = include[83],
    min_value$0 = include[84],
    lsr = include[85],
    shift_right_logical$0 = include[86],
    ceil_pow2$0 = include[87],
    floor_pow2$0 = include[88],
    ceil_log2$0 = include[89],
    is_pow2$0 = include[91],
    clz$0 = include[92],
    ctz$0 = include[93],
    O$0 = include[94],
    of_int$0 = include[95],
    to_int$0 = include[96],
    to_int_trunc$0 = include[97],
    of_int32 = include[98],
    to_int32$0 = include[99],
    to_int32_trunc = include[100],
    of_int64$0 = include[101],
    of_int64_trunc = include[102],
    of_nativeint$0 = include[103],
    to_nativeint$0 = include[104],
    of_nativeint_trunc = include[105],
    to_nativeint_trunc$0 = include[106],
    of_float_unchecked$0 = include[107],
    repr$1 = include[108],
    bswap16 = include[109],
    bswap32$0 = include[110],
    bswap48$0 = include[111];
   function symbol$18(t, u){
    var
     sum = caml_call2(symbol$9, t, u),
     _v_ = caml_call2(bit_xor$0, t, caml_call1(bit_not$0, sum));
    if
     (caml_call2
       (symbol$7,
        caml_call2(bit_or$0, caml_call2(bit_xor$0, t, u), _v_),
        zero$0))
     return sum;
    var
     _w_ = [0, [0, cst_sum, caml_call1(sexp_of_t$0, sum)], 0],
     _x_ = [0, [0, cst_u, caml_call1(sexp_of_t$0, u)], _w_],
     _y_ = [0, [0, cst_t, caml_call1(sexp_of_t$0, t)], _x_];
    return caml_call1(raise_s, caml_call2(Base_Sexp[9], cst_overflow, _y_));
   }
   function symbol$19(t, u){
    var
     diff = caml_call2(symbol$10, t, u),
     pos_diff = caml_call2(symbol$6, t, u);
    if(caml_call2(symbol$8, t, u)){
     var _r_ = caml_call1(is_positive$0, diff);
     if(caml_call2(Base_Bool[14], pos_diff, _r_)){
      var
       _s_ = [0, [0, cst_diff, caml_call1(sexp_of_t$0, diff)], 0],
       _t_ = [0, [0, cst_u$0, caml_call1(sexp_of_t$0, u)], _s_],
       _u_ = [0, [0, cst_t$0, caml_call1(sexp_of_t$0, t)], _t_];
      return caml_call1
              (raise_s, caml_call2(Base_Sexp[9], cst_overflow$0, _u_));
     }
    }
    return diff;
   }
   var negative_one = caml_call1(of_int$0, -1);
   function div_would_overflow(t, u){
    var _q_ = caml_call2(symbol$5, t, min_value$0);
    return _q_ ? caml_call2(symbol$5, u, negative_one) : _q_;
   }
   function symbol$20(t, u){
    var product = caml_call2(symbol$11, t, u);
    a:
    if(caml_call2(symbol$8, u, zero$0)){
     if
      (!
       div_would_overflow(product, u)
       && ! caml_call2(symbol$8, caml_call2(symbol$16, product, u), t))
      break a;
     var
      _n_ = [0, [0, cst_product, caml_call1(sexp_of_t$0, product)], 0],
      _o_ = [0, [0, cst_u$1, caml_call1(sexp_of_t$0, u)], _n_],
      _p_ = [0, [0, cst_t$1, caml_call1(sexp_of_t$0, t)], _o_];
     return caml_call1(raise_s, caml_call2(Base_Sexp[9], cst_overflow$1, _p_));
    }
    return product;
   }
   function symbol$21(t, u){
    if(! div_would_overflow(t, u)) return caml_call2(symbol$16, t, u);
    var
     _k_ =
       [0,
        [0,
         cst_product$0,
         caml_call1(sexp_of_t$0, caml_call2(symbol$16, t, u))],
        0],
     _l_ = [0, [0, cst_u$2, caml_call1(sexp_of_t$0, u)], _k_],
     _m_ = [0, [0, cst_t$2, caml_call1(sexp_of_t$0, t)], _l_];
    return caml_call1(raise_s, caml_call2(Base_Sexp[9], cst_overflow$2, _m_));
   }
   function abs$1(t){
    return caml_call2(symbol$5, t, min_value$0)
            ? caml_call1(Base_Import[123], cst_abs_overflow)
            : caml_call1(abs$0, t);
   }
   function neg$0(t){
    return caml_call2(symbol$5, t, min_value$0)
            ? caml_call1(Base_Import[123], cst_neg_overflow)
            : caml_call1(neg, t);
   }
   if(63 !== num_bits$0)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   function random_of_int(opt, bound){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[18][1];
    var _j_ = caml_call1(to_int_exn$0, bound);
    return caml_call1(of_int$0, caml_call2(Base_Random[18][6], state, _j_));
   }
   function random_of_int64(opt, bound){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[18][1];
    var _i_ = caml_call1(to_int64$0, bound);
    return caml_call1
            (of_int64_exn$0, caml_call2(Base_Random[18][9], state, _i_));
   }
   var random_of_int$0 = Base_Word_size[3] ? random_of_int : random_of_int64;
   function random_incl_of_int(opt, lo, hi){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[18][1];
    var
     _g_ = caml_call1(to_int_exn$0, hi),
     _h_ = caml_call1(to_int_exn$0, lo);
    return caml_call1
            (of_int$0, caml_call3(Base_Random[18][11], state, _h_, _g_));
   }
   function random_incl_of_int64(opt, lo, hi){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[18][1];
    var _e_ = caml_call1(to_int64$0, hi), _f_ = caml_call1(to_int64$0, lo);
    return caml_call1
            (of_int64_exn$0, caml_call3(Base_Random[18][14], state, _f_, _e_));
   }
   var
    random_incl =
      Base_Word_size[3] ? random_incl_of_int : random_incl_of_int64;
   function floor_log2(t){
    if(Base_Word_size[3]){
     var _c_ = caml_call1(to_int_exn$0, t);
     return caml_call1(Base_Int[66], _c_);
    }
    if(caml_call2(symbol$4, t, zero$0)){
     var _d_ = [0, [0, cst, caml_call1(sexp_of_t$0, t)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int_floor_log2_got_invalid, _d_));
    }
    var floor_log2 = [0, num_bits$0 - 2 | 0];
    for(;;){
     if
      (!
       caml_call2
        (equal$0,
         zero$0,
         caml_call2
          (bit_and$0, t, caml_call2(shift_left$0, one$0, floor_log2[1]))))
      return floor_log2[1];
     floor_log2[1] = floor_log2[1] - 1 | 0;
    }
   }
   var
    Base_Int63 =
      [0,
       t_sexp_grammar$0,
       of_float$0,
       to_float$0,
       of_int_exn$0,
       to_int_exn$0,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       equal$0,
       compare$0,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator$0,
       pp$0,
       hashable$0,
       is_positive$0,
       is_non_negative$0,
       is_negative$0,
       is_non_positive$0,
       sign$0,
       invariant$0,
       Hex$0,
       to_string_hum$0,
       zero$0,
       one$0,
       minus_one$0,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       neg,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       rem$0,
       symbol$17,
       land,
       lor,
       lxor,
       lnot$0,
       lsl,
       asr,
       round$0,
       round_towards_zero$0,
       round_down$0,
       round_up$0,
       round_nearest$0,
       abs$0,
       succ$0,
       pred$0,
       pow$0,
       bit_and$0,
       bit_or$0,
       bit_xor$0,
       bit_not$0,
       popcount$0,
       shift_left$0,
       shift_right$0,
       decr$0,
       incr$0,
       of_int32_exn$0,
       to_int32_exn$0,
       of_int64_exn$0,
       to_int64$0,
       of_nativeint_exn$0,
       to_nativeint_exn$0,
       of_float_unchecked$0,
       num_bits$0,
       max_value$0,
       min_value$0,
       lsr,
       shift_right_logical$0,
       ceil_pow2$0,
       floor_pow2$0,
       ceil_log2$0,
       is_pow2$0,
       clz$0,
       ctz$0,
       O$0,
       [0, symbol$18, symbol$19, symbol$20, symbol$21, abs$1, neg$0],
       of_int$0,
       to_int$0,
       of_int32,
       to_int32$0,
       of_int64$0,
       of_nativeint$0,
       to_nativeint$0,
       to_int_trunc$0,
       to_int32_trunc,
       of_int64_trunc,
       of_nativeint_trunc,
       to_nativeint_trunc$0,
       bswap16,
       bswap32$0,
       bswap48$0,
       random_of_int$0,
       random_incl,
       floor_log2,
       [0, Base_Int63_emul[112], repr$1]];
   runtime.caml_register_global(31, Base_Int63, "Base__Int63");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashtbl_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Key = [0],
    Merge_into_action = [0],
    Base_Hashtbl_intf = [0, Key, Merge_into_action];
   runtime.caml_register_global(0, Base_Hashtbl_intf, "Base__Hashtbl_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Avltree
//# unitInfo: Requires: Assert_failure, Base__Error, Base__Import, Base__Sexp
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_avltree_ml = "src/avltree.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Sexp = global_data.Base__Sexp,
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Error = global_data.Base__Error,
    raise_s = Base_Error[30];
   function max(x, y){return y < x ? x : y;}
   var
    _a_ = [0, cst_src_avltree_ml, 50, 6],
    _b_ = [0, cst_src_avltree_ml, 56, 6],
    _c_ = [0, cst_src_avltree_ml, 67, 6],
    _d_ = [0, cst_src_avltree_ml, 66, 6],
    _e_ = [0, cst_src_avltree_ml, 87, 22],
    _f_ = [0, cst_src_avltree_ml, 110, 26],
    _g_ = [0, cst_src_avltree_ml, 129, 30],
    _h_ = [0, cst_src_avltree_ml, 145, 26],
    _i_ = [0, cst_src_avltree_ml, 163, 30],
    _j_ = [0, cst_src_avltree_ml, 193, 9],
    _k_ = [0, cst_src_avltree_ml, 205, 9],
    _l_ = [0, cst_src_avltree_ml, 417, 15],
    _m_ = [0, cst_src_avltree_ml, 436, 18],
    cst_Avltree_choose_exn_of_empt = "[Avltree.choose_exn] of empty hashtbl";
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function height(param){
    if(typeof param === "number") return 0;
    if(0 !== param[0]) return 1;
    var height = param[4];
    return height;
   }
   function invariant(t, compare){
    function inv(param){
     if(typeof param !== "number" && 0 === param[0]){
      var
       left = param[1],
       key = param[2],
       h = param[4],
       right = param[5],
       hr = height(right),
       hl = height(left);
      inv(left);
      inv(right);
      if(typeof left !== "number"){
       var left_key = 0 === left[0] ? left[2] : left[1];
       if(0 <= caml_call2(compare, left_key, key))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      }
      if(typeof right !== "number"){
       var right_key = 0 === right[0] ? right[2] : right[1];
       if(0 >= caml_call2(compare, right_key, key))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
      }
      var _B_ = max(hl, hr);
      if(h !== caml_call2(Base_Import[90], _B_, 1))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      var _C_ = caml_call2(Base_Import[92], hl, hr);
      if(2 < caml_call1(Base_Import[122], _C_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
      return 0;
     }
     return 0;
    }
    return inv(t);
   }
   function update_height(x){
    if(typeof x !== "number" && 0 === x[0]){
     var
      left = x[1],
      old_height = x[4],
      right = x[5],
      _z_ = height(right),
      _A_ = max(height(left), _z_),
      new_height = caml_call2(Base_Import[90], _A_, 1);
     if(new_height !== old_height) x[4] = new_height;
     return;
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function balance(root_node){
    if(typeof root_node !== "number" && 0 === root_node[0]){
     var
      left_node = root_node[1],
      right_node = root_node[5],
      hl = height(left_node),
      hr = height(right_node);
     if(caml_call2(Base_Import[90], hr, 2) < hl){
      if(typeof left_node !== "number" && 0 === left_node[0]){
       var
        left_node_left = left_node[1],
        left_node_right = left_node[5],
        _x_ = height(left_node_right);
       if(_x_ <= height(left_node_left)){
        root_node[1] = left_node_right;
        left_node[5] = root_node;
        update_height(root_node);
        update_height(left_node);
        return left_node;
       }
       if(typeof left_node_right !== "number" && 0 === left_node_right[0]){
        var lr_left = left_node_right[1], lr_right = left_node_right[5];
        left_node[5] = lr_left;
        root_node[1] = lr_right;
        left_node_right[5] = root_node;
        left_node_right[1] = left_node;
        update_height(left_node);
        update_height(root_node);
        update_height(left_node_right);
        return left_node_right;
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     }
     if(caml_call2(Base_Import[90], hl, 2) >= hr){update_height(root_node); return root_node;
     }
     if(typeof right_node !== "number" && 0 === right_node[0]){
      var
       right_node_left = right_node[1],
       right_node_right = right_node[5],
       _y_ = height(right_node_left);
      if(_y_ <= height(right_node_right)){
       root_node[5] = right_node_left;
       right_node[1] = root_node;
       update_height(root_node);
       update_height(right_node);
       return right_node;
      }
      if(typeof right_node_left !== "number" && 0 === right_node_left[0]){
       var rl_left = right_node_left[1], rl_right = right_node_left[5];
       right_node[1] = rl_right;
       root_node[5] = rl_left;
       right_node_left[1] = root_node;
       right_node_left[5] = right_node;
       update_height(right_node);
       update_height(root_node);
       update_height(right_node_left);
       return right_node_left;
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    }
    return root_node;
   }
   function set_left(node, tree){
    var tree$0 = balance(tree);
    if(typeof node !== "number" && 0 === node[0]){
     var left = node[1];
     if(! caml_call2(Base_Import[127], left, tree$0)) node[1] = tree$0;
     return update_height(node);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   }
   function set_right(node, tree){
    var tree$0 = balance(tree);
    if(typeof node !== "number" && 0 === node[0]){
     var right = node[5];
     if(! caml_call2(Base_Import[127], right, tree$0)) node[5] = tree$0;
     return update_height(node);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   function add(t, replace, added, compare, k, v){
    if(typeof t === "number"){added[1] = 1; return [1, k, v];}
    if(0 !== t[0]){
     var k$1 = t[1], c$0 = caml_call2(compare, k$1, k);
     if(0 !== c$0){
      added[1] = 1;
      return 0 <= c$0 ? [0, 0, k, v, 2, t] : [0, t, k, v, 2, 0];
     }
     added[1] = 0;
     if(replace) t[2] = v;
     return t;
    }
    var
     left = t[1],
     k$0 = t[2],
     right = t[5],
     c = caml_call2(compare, k, k$0);
    if(0 === c){
     added[1] = 0;
     if(replace) t[3] = v;
    }
    else if(0 <= c)
     set_right(t, add(right, replace, added, compare, k, v));
    else
     set_left(t, add(left, replace, added, compare, k, v));
    return t;
   }
   function add$0(t, replace, compare, added, key, data){
    var t$0 = add(t, replace, added, compare, key, data);
    return added[1] ? balance(t$0) : t$0;
   }
   function first(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var l = t$0[1];
      if(typeof l !== "number"){t$0 = l; continue;}
      var v = t$0[3], k = t$0[2];
     }
     else
      var k$0 = t$0[1], v$0 = t$0[2], v = v$0, k = k$0;
     return [0, [0, k, v]];
    }
   }
   function last(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var _v_ = t$0[2], _w_ = t$0[3];
      if(typeof t$0[5] !== "number"){var r = t$0[5]; t$0 = r; continue;}
      var v = _w_, k = _v_;
     }
     else
      var k$0 = t$0[1], v$0 = t$0[2], v = v$0, k = k$0;
     return [0, [0, k, v]];
    }
   }
   function findi_and_call_impl
   (t,
    compare,
    k,
    arg1,
    arg2,
    call_if_found,
    call_if_not_found,
    if_found,
    if_not_found){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number")
      return caml_call4(call_if_not_found, if_not_found, k, arg1, arg2);
     if(0 !== t$0[0]){
      var k$1 = t$0[1], v$0 = t$0[2];
      return 0 === caml_call2(compare, k, k$1)
              ? caml_call5(call_if_found, if_found, k$1, v$0, arg1, arg2)
              : caml_call4(call_if_not_found, if_not_found, k, arg1, arg2);
     }
     var
      left = t$0[1],
      k$0 = t$0[2],
      v = t$0[3],
      right = t$0[5],
      c = caml_call2(compare, k, k$0);
     if(0 === c)
      return caml_call5(call_if_found, if_found, k$0, v, arg1, arg2);
     var right$0 = 0 <= c ? right : left;
     t$0 = right$0;
    }
   }
   function call_if_found(if_found, param, data, _u_, _t_){return caml_call1(if_found, data);
   }
   function call_if_not_found(if_not_found, key, param, _s_){return caml_call1(if_not_found, key);
   }
   function find_and_call(t, compare, k, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             0,
             0,
             call_if_found,
             call_if_not_found,
             if_found,
             if_not_found);
   }
   function call_if_found$0(if_found, key, data, param, _r_){return caml_call2(if_found, key, data);
   }
   function call_if_not_found$0(if_not_found, key, param, _q_){return caml_call1(if_not_found, key);
   }
   function findi_and_call(t, compare, k, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             0,
             0,
             call_if_found$0,
             call_if_not_found$0,
             if_found,
             if_not_found);
   }
   function call_if_found$1(if_found, param, data, arg, _p_){return caml_call2(if_found, data, arg);
   }
   function call_if_not_found$1(if_not_found, key, arg, param){return caml_call2(if_not_found, key, arg);
   }
   function find_and_call1(t, compare, k, a, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             0,
             call_if_found$1,
             call_if_not_found$1,
             if_found,
             if_not_found);
   }
   function call_if_found$2(if_found, key, data, arg, param){return caml_call3(if_found, key, data, arg);
   }
   function call_if_not_found$2(if_not_found, key, arg, param){return caml_call2(if_not_found, key, arg);
   }
   function findi_and_call1(t, compare, k, a, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             0,
             call_if_found$2,
             call_if_not_found$2,
             if_found,
             if_not_found);
   }
   function call_if_found$3(if_found, param, data, arg1, arg2){return caml_call3(if_found, data, arg1, arg2);
   }
   function call_if_not_found$3(if_not_found, key, arg1, arg2){return caml_call3(if_not_found, key, arg1, arg2);
   }
   function find_and_call2(t, compare, k, a, b, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             b,
             call_if_found$3,
             call_if_not_found$3,
             if_found,
             if_not_found);
   }
   function call_if_found$4(if_found, key, data, arg1, arg2){return caml_call4(if_found, key, data, arg1, arg2);
   }
   function call_if_not_found$4(if_not_found, key, arg1, arg2){return caml_call3(if_not_found, key, arg1, arg2);
   }
   function findi_and_call2(t, compare, k, a, b, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             b,
             call_if_found$4,
             call_if_not_found$4,
             if_found,
             if_not_found);
   }
   function if_found(v){return [0, v];}
   function if_not_found(param){return 0;}
   function find(t, compare, k){
    return find_and_call(t, compare, k, if_found, if_not_found);
   }
   function if_found$0(param){return 1;}
   function if_not_found$0(param){return 0;}
   function mem(t, compare, k){
    return find_and_call(t, compare, k, if_found$0, if_not_found$0);
   }
   function remove_min_elt(tree){
    if(typeof tree === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    if(0 !== tree[0]) return 0;
    var left = tree[1];
    if(typeof left === "number"){var right = tree[5]; return right;}
    if(0 === left[0]){set_left(tree, remove_min_elt(left)); return tree;}
    var k = tree[2], v = tree[3];
    return typeof tree[5] === "number" ? [1, k, v] : (set_left(tree, 0), tree);
   }
   function remove(t, removed, compare, k$0){
    if(typeof t === "number"){removed[1] = 0; return 0;}
    if(0 !== t[0]){
     var k$2 = t[1];
     return 0 === caml_call2(compare, k$0, k$2)
             ? (removed[1] = 1, 0)
             : (removed[1] = 0, t);
    }
    var
     left$0 = t[1],
     k$1 = t[2],
     right = t[5],
     c = caml_call2(compare, k$0, k$1);
    if(0 !== c)
     return 0 <= c
             ? (set_right(t, remove(right, removed, compare, k$0)), t)
             : (set_left(t, remove(left$0, removed, compare, k$0)), t);
    removed[1] = 1;
    if(typeof left$0 === "number") return right;
    if(typeof right === "number") return left$0;
    var tree = right;
    for(;;){
     if(typeof tree === "number")
      var tree$0 = 0;
     else if(0 === tree[0]){
      var left = tree[1];
      if(typeof left !== "number"){tree = left; continue;}
      var tree$0 = tree;
     }
     else
      var tree$0 = tree;
     if(typeof tree$0 === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
     if(0 === tree$0[0]){
      set_right(tree$0, remove_min_elt(right));
      set_left(tree$0, left$0);
      return tree$0;
     }
     var
      k = tree$0[1],
      v = tree$0[2],
      t2 = balance(remove_min_elt(right)),
      _n_ = height(t2),
      _o_ = max(height(left$0), _n_);
     return [0, left$0, k, v, caml_call2(Base_Import[90], _o_, 1), t2];
    }
   }
   function remove$0(t, removed, compare, k){
    return balance(remove(t, removed, compare, k));
   }
   function fold(t, init, f){
    var t$0 = t, init$0 = init;
    for(;;){
     if(typeof t$0 === "number") return init$0;
     if(0 !== t$0[0]){
      var key$4 = t$0[1], data$4 = t$0[2];
      return caml_call3(f, key$4, data$4, init$0);
     }
     var left = t$0[1];
     if(typeof left === "number"){
      var key = t$0[2], data = t$0[3], match = t$0[5];
      if(typeof match !== "number" && 0 !== match[0]){
       var rkey = match[1], rdata = match[2];
       return caml_call3(f, rkey, rdata, caml_call3(f, key, data, init$0));
      }
     }
     else{
      if(0 === left[0]){
       var key$1 = t$0[2], data$1 = t$0[3], match$0 = t$0[5];
       if(typeof match$0 !== "number" && 0 !== match$0[0]){
        var rkey$0 = match$0[1], rdata$0 = match$0[2];
        return caml_call3
                (f,
                 rkey$0,
                 rdata$0,
                 caml_call3(f, key$1, data$1, fold(left, init$0, f)));
       }
      }
      else{
       var
        lkey$0 = left[1],
        ldata$0 = left[2],
        key$3 = t$0[2],
        data$3 = t$0[3],
        match$1 = t$0[5];
       if(typeof match$1 === "number")
        return caml_call3
                (f, key$3, data$3, caml_call3(f, lkey$0, ldata$0, init$0));
       if(0 !== match$1[0]){
        var rkey$1 = match$1[1], rdata$1 = match$1[2];
        return caml_call3
                (f,
                 rkey$1,
                 rdata$1,
                 caml_call3
                  (f, key$3, data$3, caml_call3(f, lkey$0, ldata$0, init$0)));
       }
      }
      if(typeof left !== "number" && 1 === left[0]){
       var
        lkey = left[1],
        ldata = left[2],
        key$2 = t$0[2],
        data$2 = t$0[3],
        right$0 = t$0[5],
        init$2 =
          caml_call3(f, key$2, data$2, caml_call3(f, lkey, ldata, init$0));
       t$0 = right$0;
       init$0 = init$2;
       continue;
      }
     }
     var
      key$0 = t$0[2],
      data$0 = t$0[3],
      right = t$0[5],
      init$1 = caml_call3(f, key$0, data$0, fold(left, init$0, f));
     t$0 = right;
     init$0 = init$1;
    }
   }
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 !== t$0[0]){
      var key$0 = t$0[1], data$0 = t$0[2];
      return caml_call2(f, key$0, data$0);
     }
     var left = t$0[1], key = t$0[2], data = t$0[3], right = t$0[5];
     iter(left, f);
     caml_call2(f, key, data);
     t$0 = right;
    }
   }
   function mapi_inplace(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 !== t$0[0]){
      var key$0 = t$0[1], value$0 = t$0[2];
      t$0[2] = caml_call2(f, key$0, value$0);
      return 0;
     }
     var left = t$0[1], key = t$0[2], value = t$0[3], right = t$0[5];
     mapi_inplace(left, f);
     t$0[3] = caml_call2(f, key, value);
     t$0 = right;
    }
   }
   function choose_exn(param){
    if(typeof param === "number")
     return caml_call1
             (raise_s,
              caml_call2(Base_Sexp[9], cst_Avltree_choose_exn_of_empt, 0));
    if(0 === param[0])
     var value = param[3], key = param[2];
    else
     var key$0 = param[1], value$0 = param[2], value = value$0, key = key$0;
    return [0, key, value];
   }
   var
    Base_Avltree =
      [0,
       0,
       is_empty,
       invariant,
       add$0,
       first,
       last,
       find,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       mem,
       remove$0,
       fold,
       iter,
       mapi_inplace,
       choose_exn];
   runtime.caml_register_global(18, Base_Avltree, "Base__Avltree");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashtbl
//# unitInfo: Requires: Assert_failure, Base__Array, Base__Avltree, Base__Error, Base__Hashable, Base__Hashtbl_intf, Base__Import, Base__Int, Base__List, Base__Option, Base__Or_error, Base__Sexp, Base__With_return, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_hashtbl_ml = "src/hashtbl.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Avltree = global_data.Base__Avltree,
    Base_Import = global_data.Base__Import,
    Base_Hashable = global_data.Base__Hashable,
    Base_Array = global_data.Base__Array,
    Base_List = global_data.Base__List,
    Base_Or_error = global_data.Base__Or_error,
    Base_Sexp = global_data.Base__Sexp,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Assert_failure = global_data.Assert_failure,
    Base_Error = global_data.Base__Error,
    Base_Option = global_data.Base__Option,
    Base_Int = global_data.Base__Int,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1],
    hash_param = Base_Hashable[5],
    hash = Base_Hashable[6],
    raise_s = Base_Error[30],
    cst_Hashtbl_mutation_not_allow =
      "Hashtbl: mutation not allowed during iteration";
   function sexp_of_key(t){return t[5][3];}
   function compare_key(t){return t[5][2];}
   function ensure_mutation_allowed(t){
    var _aC_ = 1 - t[6];
    return _aC_
            ? caml_call1(Base_Import[123], cst_Hashtbl_mutation_not_allow)
            : _aC_;
   }
   function without_mutating(t, f){
    if(! t[6]) return caml_call1(f, 0);
    t[6] = 0;
    try{var x = caml_call1(f, 0);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[6] = 1;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[6] = 1;
    return x;
   }
   var
    max_table_length = caml_call1(Base_Int[64], Base_Array[24]),
    cst_Hashtbl_add_exn_got_key_al = "Hashtbl.add_exn got key already present",
    cst_Hashtbl_choose_exn_of_empt = "[Hashtbl.choose_exn] of empty hashtbl",
    _a_ = [0, cst_src_hashtbl_ml, 323, 2],
    _b_ = [0, "Hashtbl.find_exn: not found"],
    cst_Hashtbl_of_alist_exn_dupli = "Hashtbl.of_alist_exn: duplicate key",
    cst_Hashtbl_t_of_sexp_duplicat = "Hashtbl.t_of_sexp: duplicate key",
    _c_ = [0, cst_src_hashtbl_ml, 575, 4],
    cst_keys = "keys",
    cst_Hashtbl_create_with_key_du = "Hashtbl.create_with_key: duplicate keys",
    cst_Hashtbl_merge_different_ha =
      "Hashtbl.merge: different 'hashable' values";
   function create(opt, _aA_, hashable, param){
    if(opt)
     var sth = opt[1], growth_allowed = sth;
    else
     var growth_allowed = 1;
    if(_aA_) var sth$0 = _aA_[1], size = sth$0; else var size = 0;
    var
     _aB_ = caml_call2(Base_Int[15], 1, size),
     size$0 = caml_call2(Base_Int[14], _aB_, max_table_length),
     size$1 = caml_call1(Base_Int[63], size$0);
    return [0,
            caml_call2(Base_Array[25], size$1, Base_Avltree[1]),
            0,
            [0, 0],
            growth_allowed,
            hashable,
            1];
   }
   function slot(t, key){
    var
     hash = caml_call1(t[5][1], key),
     _az_ = caml_call2(Base_Import[92], t[1].length - 1, 1);
    return caml_call2(Base_Import[115], hash, _az_);
   }
   function add_worker(t, replace, key, data){
    var
     i = slot(t, key),
     root = caml_check_bound(t[1], i)[1 + i],
     added = t[3];
    added[1] = 0;
    var
     _aw_ = compare_key(t),
     new_root =
       caml_call6(Base_Avltree[4], root, replace, _aw_, added, key, data);
    if(added[1]) t[2] = caml_call2(Base_Import[90], t[2], 1);
    var
     _ax_ = 1 - caml_call2(Base_Import[127], new_root, root),
     _ay_ = _ax_ ? (caml_check_bound(t[1], i)[1 + i] = new_root, 0) : _ax_;
    return _ay_;
   }
   function maybe_resize_table(t){
    var
     len = t[1].length - 1,
     should_grow = len < t[2] ? 1 : 0,
     _an_ = should_grow ? t[4] : should_grow;
    if(_an_){
     var
      _ao_ = caml_call2(Base_Import[87], len, 2),
      new_array_length = caml_call2(Base_Int[14], _ao_, max_table_length),
      _ap_ = len < new_array_length ? 1 : 0;
     if(_ap_){
      var
       new_table =
         caml_call2(Base_Array[25], new_array_length, Base_Avltree[1]),
       old_table = t[1];
      t[1] = new_table;
      t[2] = 0;
      var
       f = function(key, data){return add_worker(t, 1, key, data);},
       _ar_ = caml_call2(Base_Import[92], old_table.length - 1, 1),
       _aq_ = 0;
      if(_ar_ >= 0){
       var i = _aq_;
       for(;;){
        var _au_ = caml_check_bound(old_table, i)[1 + i];
        caml_call2(Base_Avltree[17], _au_, f);
        var _av_ = i + 1 | 0;
        if(_ar_ === i) break;
        i = _av_;
       }
      }
      var _as_ = 0;
     }
     else
      var _as_ = _ap_;
     var _at_ = _as_;
    }
    else
     var _at_ = _an_;
    return _at_;
   }
   function set(t, key, data){
    ensure_mutation_allowed(t);
    add_worker(t, 1, key, data);
    return maybe_resize_table(t);
   }
   function add(t, key, data){
    ensure_mutation_allowed(t);
    add_worker(t, 0, key, data);
    return t[3][1] ? (maybe_resize_table(t), 17724) : -1024851605;
   }
   function add_exn(t, key, data){
    if(17724 <= add(t, key, data)) return 0;
    var
     sexp_of_key$0 = sexp_of_key(t),
     error =
       caml_call5
        (Base_Error[17],
         0,
         0,
         cst_Hashtbl_add_exn_got_key_al,
         key,
         sexp_of_key$0);
    return caml_call1(Base_Error[29], error);
   }
   function clear(t){
    ensure_mutation_allowed(t);
    var _ak_ = caml_call2(Base_Import[92], t[1].length - 1, 1), _aj_ = 0;
    if(_ak_ >= 0){
     var i = _aj_;
     for(;;){
      var _al_ = Base_Avltree[1];
      caml_check_bound(t[1], i)[1 + i] = _al_;
      var _am_ = i + 1 | 0;
      if(_ak_ === i) break;
      i = _am_;
     }
    }
    t[2] = 0;
    return 0;
   }
   function find_and_call(t, key, if_found, if_not_found){
    var _ah_ = slot(t, key), tree = caml_check_bound(t[1], _ah_)[1 + _ah_];
    if(typeof tree === "number") return caml_call1(if_not_found, key);
    if(0 === tree[0]){
     var _ai_ = compare_key(t);
     return caml_call5
             (Base_Avltree[8], tree, _ai_, key, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call1(if_found, v)
            : caml_call1(if_not_found, key);
   }
   function find_and_call1(t, key, a, if_found, if_not_found){
    var _af_ = slot(t, key), tree = caml_check_bound(t[1], _af_)[1 + _af_];
    if(typeof tree === "number") return caml_call2(if_not_found, key, a);
    if(0 === tree[0]){
     var _ag_ = compare_key(t);
     return caml_call6
             (Base_Avltree[9], tree, _ag_, key, a, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call2(if_found, v, a)
            : caml_call2(if_not_found, key, a);
   }
   function find_and_call2(t, key, a, b, if_found, if_not_found){
    var _ad_ = slot(t, key), tree = caml_check_bound(t[1], _ad_)[1 + _ad_];
    if(typeof tree === "number") return caml_call3(if_not_found, key, a, b);
    if(0 === tree[0]){
     var _ae_ = compare_key(t);
     return caml_call7
             (Base_Avltree[10], tree, _ae_, key, a, b, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call3(if_found, v, a, b)
            : caml_call3(if_not_found, key, a, b);
   }
   function findi_and_call(t, key, if_found, if_not_found){
    var _ab_ = slot(t, key), tree = caml_check_bound(t[1], _ab_)[1 + _ab_];
    if(typeof tree === "number") return caml_call1(if_not_found, key);
    if(0 === tree[0]){
     var _ac_ = compare_key(t);
     return caml_call5
             (Base_Avltree[11], tree, _ac_, key, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call2(if_found, k, v)
            : caml_call1(if_not_found, key);
   }
   function findi_and_call1(t, key, a, if_found, if_not_found){
    var _$_ = slot(t, key), tree = caml_check_bound(t[1], _$_)[1 + _$_];
    if(typeof tree === "number") return caml_call2(if_not_found, key, a);
    if(0 === tree[0]){
     var _aa_ = compare_key(t);
     return caml_call6
             (Base_Avltree[12], tree, _aa_, key, a, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call3(if_found, k, v, a)
            : caml_call2(if_not_found, key, a);
   }
   function findi_and_call2(t, key, a, b, if_found, if_not_found){
    var _Z_ = slot(t, key), tree = caml_check_bound(t[1], _Z_)[1 + _Z_];
    if(typeof tree === "number") return caml_call3(if_not_found, key, a, b);
    if(0 === tree[0]){
     var ___ = compare_key(t);
     return caml_call7
             (Base_Avltree[13], tree, ___, key, a, b, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call4(if_found, k, v, a, b)
            : caml_call3(if_not_found, key, a, b);
   }
   function if_found(v){return [0, v];}
   function if_not_found(param){return 0;}
   function find(t, key){
    return find_and_call(t, key, if_found, if_not_found);
   }
   function mem(t, key){
    var _X_ = slot(t, key), tree = caml_check_bound(t[1], _X_)[1 + _X_];
    if(typeof tree === "number") return 0;
    if(0 === tree[0]){
     var _Y_ = compare_key(t);
     return caml_call3(Base_Avltree[14], tree, _Y_, key);
    }
    var k = tree[1];
    return 0 === caml_call2(compare_key(t), k, key) ? 1 : 0;
   }
   function remove(t, key){
    ensure_mutation_allowed(t);
    var
     i = slot(t, key),
     root = caml_check_bound(t[1], i)[1 + i],
     added_or_removed = t[3];
    added_or_removed[1] = 0;
    var
     _U_ = compare_key(t),
     new_root = caml_call4(Base_Avltree[15], root, added_or_removed, _U_, key);
    if(1 - caml_call2(Base_Import[127], root, new_root))
     caml_check_bound(t[1], i)[1 + i] = new_root;
    var
     _V_ = added_or_removed[1],
     _W_ = _V_ ? (t[2] = caml_call2(Base_Import[92], t[2], 1), 0) : _V_;
    return _W_;
   }
   function length(t){return t[2];}
   function is_empty(t){return 0 === t[2] ? 1 : 0;}
   function fold(t, init, f){
    if(0 === t[2]) return init;
    var n = t[1].length - 1, acc = [0, init], m = t[6];
    try{
     t[6] = 0;
     var _S_ = caml_call2(Base_Import[92], n, 1), _R_ = 0;
     if(_S_ >= 0){
      var i = _R_;
      for(;;){
       var bucket = t[1][1 + i];
       if(typeof bucket !== "number")
        if(0 === bucket[0])
         acc[1] = caml_call3(Base_Avltree[16], bucket, acc[1], f);
        else{
         var key = bucket[1], data = bucket[2];
         acc[1] = caml_call3(f, key, data, acc[1]);
        }
       var _T_ = i + 1 | 0;
       if(_S_ === i) break;
       i = _T_;
      }
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[6] = m;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[6] = m;
    return acc[1];
   }
   function iteri(t, f){
    if(0 === t[2]) return 0;
    var n = t[1].length - 1, m = t[6];
    try{
     t[6] = 0;
     var _P_ = caml_call2(Base_Import[92], n, 1), _O_ = 0;
     if(_P_ >= 0){
      var i = _O_;
      for(;;){
       var bucket = t[1][1 + i];
       if(typeof bucket !== "number")
        if(0 === bucket[0])
         caml_call2(Base_Avltree[17], bucket, f);
        else{var key = bucket[1], data = bucket[2]; caml_call2(f, key, data);}
       var _Q_ = i + 1 | 0;
       if(_P_ === i) break;
       i = _Q_;
      }
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[6] = m;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[6] = m;
    return 0;
   }
   function iter(t, f){
    return iteri(t, function(param, data){return caml_call1(f, data);});
   }
   function iter_keys(t, f){
    return iteri(t, function(key, param){return caml_call1(f, key);});
   }
   function choose_nonempty(table, i){
    var i$0 = i;
    for(;;){
     var avltree = caml_check_bound(table, i$0)[1 + i$0];
     if(! caml_call1(Base_Avltree[2], avltree))
      return caml_call1(Base_Avltree[19], avltree);
     var i$1 = caml_call2(Base_Import[90], i$0, 1);
     i$0 = i$1;
    }
   }
   function choose_exn(t){
    if(0 === t[2])
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Hashtbl_choose_exn_of_empt, 0));
    return choose_nonempty(t[1], 0);
   }
   function choose(t){return is_empty(t) ? 0 : [0, choose_nonempty(t[1], 0)];}
   function invariant(invariant_key, invariant_data, t){
    var _K_ = caml_call2(Base_Import[92], t[1].length - 1, 1), _J_ = 0;
    if(_K_ >= 0){
     var i = _J_;
     for(;;){
      var _L_ = compare_key(t), _M_ = caml_check_bound(t[1], i)[1 + i];
      caml_call2(Base_Avltree[3], _M_, _L_);
      var _N_ = i + 1 | 0;
      if(_K_ === i) break;
      i = _N_;
     }
    }
    var
     real_len =
       fold
        (t,
         0,
         function(key, data, i){
          caml_call1(invariant_key, key);
          caml_call1(invariant_data, data);
          return caml_call2(Base_Import[90], i, 1);
         });
    if(real_len === t[2]) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function if_found$0(v, param){return v;}
   function if_not_found$0(k, t){
    var _I_ = [1, [0, _b_, [0, caml_call1(t[5][3], k), 0]]];
    throw caml_maybe_attach_backtrace([0, Base_Import[251], _I_], 1);
   }
   function find_exn(t, key){
    return find_and_call1(t, key, t, if_found$0, if_not_found$0);
   }
   function existsi(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _H_ = caml_call2(f, key, data);
                 return _H_ ? caml_call1(r, 1) : _H_;
                });
              return 0;
             });
   }
   function exists(t, f){
    return existsi(t, function(param, data){return caml_call1(f, data);});
   }
   function for_alli(t, f){
    return 1
           -
            existsi
             (t, function(key, data){return 1 - caml_call2(f, key, data);});
   }
   function for_all(t, f){
    return 1
           -
            existsi(t, function(param, data){return 1 - caml_call1(f, data);});
   }
   function counti(t, f){
    return fold
            (t,
             0,
             function(key, data, acc){
              return caml_call2(f, key, data)
                      ? caml_call2(Base_Import[90], acc, 1)
                      : acc;
             });
   }
   function count(t, f){
    return fold
            (t,
             0,
             function(param, data, acc){
              return caml_call1(f, data)
                      ? caml_call2(Base_Import[90], acc, 1)
                      : acc;
             });
   }
   function mapi(t, f){
    var new_t = create([0, t[4]], [0, t[2]], t[5], 0);
    iteri
     (t,
      function(key, data){return set(new_t, key, caml_call2(f, key, data));});
    return new_t;
   }
   function map(t, f){
    return mapi(t, function(param, data){return caml_call1(f, data);});
   }
   function copy(t){return map(t, function(_G_){return _G_;});}
   function filter_mapi(t, f){
    var new_t = create([0, t[4]], [0, t[2]], t[5], 0);
    iteri
     (t,
      function(key, data){
       var match = caml_call2(f, key, data);
       if(! match) return 0;
       var new_data = match[1];
       return set(new_t, key, new_data);
      });
    return new_t;
   }
   function filter_map(t, f){
    return filter_mapi(t, function(param, data){return caml_call1(f, data);});
   }
   function filteri(t, f){
    return filter_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : 0;
             });
   }
   function filter(t, f){
    return filteri(t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys(t, f){
    return filteri(t, function(key, param){return caml_call1(f, key);});
   }
   function partition_mapi(t, f){
    var
     t0 = create([0, t[4]], [0, t[2]], t[5], 0),
     t1 = create([0, t[4]], [0, t[2]], t[5], 0);
    iteri
     (t,
      function(key, data){
       var match = caml_call2(f, key, data);
       if(0 === match[0]){
        var new_data = match[1];
        return set(t0, key, new_data);
       }
       var new_data$0 = match[1];
       return set(t1, key, new_data$0);
      });
    return [0, t0, t1];
   }
   function partition_map(t, f){
    return partition_mapi
            (t, function(param, data){return caml_call1(f, data);});
   }
   function partitioni_tf(t, f){
    return partition_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : [1, data];
             });
   }
   function partition_tf(t, f){
    return partitioni_tf
            (t, function(param, data){return caml_call1(f, data);});
   }
   function find_or_add(t, id, default$0){
    return find_and_call2
            (t,
             id,
             t,
             default$0,
             function(data, param, _F_){return data;},
             function(key, t, default$0){
              var default$1 = caml_call1(default$0, 0);
              set(t, key, default$1);
              return default$1;
             });
   }
   function findi_or_add(t, id, default$0){
    return find_and_call2
            (t,
             id,
             t,
             default$0,
             function(data, param, _E_){return data;},
             function(key, t, default$0){
              var default$1 = caml_call1(default$0, key);
              set(t, key, default$1);
              return default$1;
             });
   }
   function find_and_remove(t, key){
    var result = find_and_call(t, key, if_found, if_not_found);
    if(caml_call1(Base_Option[50], result)) remove(t, key);
    return result;
   }
   function change(t, key, f){
    var match = caml_call1(f, find_and_call(t, key, if_found, if_not_found));
    if(! match) return remove(t, key);
    var data = match[1];
    return set(t, key, data);
   }
   function update_and_return(t, key, f){
    var data = caml_call1(f, find_and_call(t, key, if_found, if_not_found));
    set(t, key, data);
    return data;
   }
   function update(t, id, f){update_and_return(t, id, f); return 0;}
   function incr_by(remove_if_zero, t, key, by){
    return remove_if_zero
            ? change
              (t,
               key,
               function(opt){
                var
                 _D_ = caml_call2(Base_Option[27], opt, 0),
                 n = caml_call2(Base_Import[90], by, _D_);
                return 0 === n ? 0 : [0, n];
               })
            : update
              (t,
               key,
               function(param){
                if(! param) return by;
                var i = param[1];
                return caml_call2(Base_Import[90], by, i);
               });
   }
   function incr(opt, _C_, t, key){
    if(opt) var sth = opt[1], by = sth; else var by = 1;
    if(_C_)
     var sth$0 = _C_[1], remove_if_zero = sth$0;
    else
     var remove_if_zero = 0;
    return incr_by(remove_if_zero, t, key, by);
   }
   function decr(opt, _B_, t, key){
    if(opt) var sth = opt[1], by = sth; else var by = 1;
    if(_B_)
     var sth$0 = _B_[1], remove_if_zero = sth$0;
    else
     var remove_if_zero = 0;
    return incr_by(remove_if_zero, t, key, caml_call1(Base_Import[112], by));
   }
   function add_multi(t, key, data){
    return update
            (t,
             key,
             function(param){
              if(! param) return [0, data, 0];
              var l = param[1];
              return [0, data, l];
             });
   }
   function remove_multi(t, key){
    var match = find_and_call(t, key, if_found, if_not_found);
    if(! match) return 0;
    var _A_ = match[1];
    if(_A_ && _A_[2]){var tl = _A_[2]; return set(t, key, tl);}
    return remove(t, key);
   }
   function find_multi(t, key){
    var match = find_and_call(t, key, if_found, if_not_found);
    if(! match) return 0;
    var l = match[1];
    return l;
   }
   function create_mapped
   (growth_allowed, size, hashable, get_key, get_data, rows){
    if(size)
     var s = size[1], size$0 = s;
    else
     var size$0 = caml_call1(Base_List[7], rows);
    var
     res = create(growth_allowed, [0, size$0], hashable, 0),
     dupes = [0, 0];
    caml_call2
     (Base_List[9],
      rows,
      function(r){
       var key = caml_call1(get_key, r), data = caml_call1(get_data, r);
       return mem(res, key)
               ? (dupes[1] = [0, key, dupes[1]], 0)
               : set(res, key, data);
      });
    var keys = dupes[1];
    return keys
            ? [0, 175765640, caml_call2(Base_List[114], keys, hashable[2])]
            : [0, 17724, res];
   }
   function of_alist(growth_allowed, size, hashable, lst){
    var
     match =
       create_mapped
        (growth_allowed,
         size,
         hashable,
         Base_Import[124],
         Base_Import[126],
         lst);
    if(175765640 <= match[1]){
     var k = match[2];
     return [0, -1048878709, caml_call1(Base_List[67], k)];
    }
    var t = match[2];
    return [0, 17724, t];
   }
   function of_alist_report_all_dups(growth_allowed, size, hashable, lst){
    return create_mapped
            (growth_allowed,
             size,
             hashable,
             Base_Import[124],
             Base_Import[126],
             lst);
   }
   function of_alist_or_error(growth_allowed, size, hashable, lst){
    var match = of_alist(growth_allowed, size, hashable, lst);
    if(17724 <= match[1]){var v = match[2]; return [0, v];}
    var key = match[2], sexp_of_key = hashable[3];
    return caml_call5
            (Base_Or_error[34],
             0,
             0,
             cst_Hashtbl_of_alist_exn_dupli,
             key,
             sexp_of_key);
   }
   function of_alist_exn(growth_allowed, size, hashable, lst){
    var match = of_alist_or_error(growth_allowed, size, hashable, lst);
    if(0 === match[0]){var v = match[1]; return v;}
    var e = match[1];
    return caml_call1(Base_Error[29], e);
   }
   function of_alist_multi(growth_allowed, size$0, hashable, rows){
    var get_data = Base_Import[126], get_key = Base_Import[124];
    if(size$0)
     var s = size$0[1], size = s;
    else
     var size = caml_call1(Base_List[7], rows);
    var res = create(growth_allowed, [0, size], hashable, 0);
    caml_call2
     (Base_List[9],
      rows,
      function(r){
       var key = caml_call1(get_key, r), data = caml_call1(get_data, r);
       return add_multi(res, key, data);
      });
    return res;
   }
   function to_alist(t){
    return fold
            (t,
             0,
             function(key, data, list){return [0, [0, key, data], list];});
   }
   function sexp_of_t(sexp_of_key, sexp_of_data, t){
    var
     _w_ = to_alist(t),
     _x_ =
       caml_call2
        (Base_List[62],
         _w_,
         function(param, _z_){
          var k2 = _z_[1], k1 = param[1];
          return caml_call2(t[5][2], k1, k2);
         }),
     _y_ = caml_call2(Base_Import[149], sexp_of_key, sexp_of_data);
    return caml_call1(caml_call1(Base_Import[151], _y_), _x_);
   }
   function t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp){
    var
     _p_ = caml_call2(Base_Import[173], k_of_sexp, d_of_sexp),
     alist = caml_call2(Base_Import[175], _p_, sexp),
     match =
       of_alist(0, [0, caml_call1(Base_List[7], alist)], hashable, alist);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var
     k = match[2],
     _q_ =
       caml_call2
        (Base_Import[173],
         function(_v_){return _v_;},
         function(_u_){return _u_;}),
     alist_sexps = caml_call2(Base_Import[175], _q_, sexp),
     found_first_k = [0, 0];
    caml_call3
     (Base_List[42],
      alist,
      alist_sexps,
      function(param, _r_){
       var
        k2_sexp = _r_[1],
        k2 = param[1],
        _s_ = 0 === caml_call2(hashable[2], k, k2) ? 1 : 0;
       if(_s_){
        if(found_first_k[1])
         return caml_call2
                 (Base_Import[158], cst_Hashtbl_t_of_sexp_duplicat, k2_sexp);
        found_first_k[1] = 1;
        var _t_ = 0;
       }
       else
        var _t_ = _s_;
       return _t_;
      });
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   function t_sexp_grammar(k_grammar, v_grammar){
    var _o_ = caml_call2(Base_List[129][3], k_grammar, v_grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _o_);
   }
   function keys(t){
    return fold(t, 0, function(key, param, acc){return [0, key, acc];});
   }
   function data(t){
    return fold(t, 0, function(param, data, list){return [0, data, list];});
   }
   function group
   (growth_allowed, size, hashable, get_key, get_data, combine, rows){
    var groups = create(growth_allowed, size, hashable, 0);
    caml_call2
     (Base_List[9],
      rows,
      function(row){
       var
        key = caml_call1(get_key, row),
        data = caml_call1(get_data, row),
        match = find_and_call(groups, key, if_found, if_not_found);
       if(match)
        var old = match[1], data$0 = caml_call2(combine, old, data);
       else
        var data$0 = data;
       return set(groups, key, data$0);
      });
    return groups;
   }
   function create_with_key(growth_allowed, size, hashable, get_key, rows){
    return create_mapped
            (growth_allowed,
             size,
             hashable,
             get_key,
             function(_n_){return _n_;},
             rows);
   }
   function create_with_key_or_error
   (growth_allowed, size, hashable, get_key, rows){
    var
     match = create_with_key(growth_allowed, size, hashable, get_key, rows);
    if(175765640 <= match[1]){
     var
      keys = match[2],
      sexp_of_key = hashable[3],
      _l_ =
        [0, [0, cst_keys, caml_call2(Base_Import[151], sexp_of_key, keys)], 0],
      _m_ = caml_call2(Base_Sexp[9], cst_Hashtbl_create_with_key_du, _l_);
     return caml_call1(Base_Or_error[35], _m_);
    }
    var t = match[2];
    return [0, t];
   }
   function create_with_key_exn(growth_allowed, size, hashable, get_key, rows){
    var
     _k_ =
       create_with_key_or_error(growth_allowed, size, hashable, get_key, rows);
    return caml_call1(Base_Or_error[31], _k_);
   }
   function maybe_set(t, key, f, d){
    var match = caml_call2(f, key, d);
    if(! match) return 0;
    var v = match[1];
    return set(t, key, v);
   }
   function merge(t_left, t_right, f){
    if(1 - caml_call2(Base_Hashable[1], t_left[5], t_right[5]))
     caml_call1(Base_Import[125], cst_Hashtbl_merge_different_ha);
    var new_t = create([0, t_left[4]], [0, t_left[2]], t_left[5], 0);
    without_mutating
     (t_left,
      function(param){
       return without_mutating
               (t_right,
                function(param){
                 iteri
                  (t_left,
                   function(key, left){
                    var
                     match = find_and_call(t_right, key, if_found, if_not_found);
                    if(! match)
                     return maybe_set(new_t, key, f, [0, 847852583, left]);
                    var right = match[1];
                    return maybe_set
                            (new_t, key, f, [0, 737457313, [0, left, right]]);
                   });
                 return iteri
                         (t_right,
                          function(key, right){
                           return find_and_call(t_left, key, if_found, if_not_found)
                                   ? 0
                                   : maybe_set(new_t, key, f, [0, -57574468, right]);
                          });
                });
      });
    return new_t;
   }
   function merge_into(src, dst, f){
    return iteri
            (src,
             function(key, data){
              var
               dst_data$0 = find_and_call(dst, key, if_found, if_not_found),
               action =
                 without_mutating
                  (dst,
                   function(param){
                    return caml_call3(f, key, data, dst_data$0);
                   });
              if(! action) return remove(dst, key);
              var data$0 = action[1];
              if(! dst_data$0) return set(dst, key, data$0);
              var
               dst_data = dst_data$0[1],
               _j_ = 1 - caml_call2(Base_Import[127], dst_data, data$0);
              return _j_ ? set(dst, key, data$0) : _j_;
             });
   }
   function filteri_inplace(t, f){
    var
     to_remove =
       fold
        (t,
         0,
         function(key, data, ac){
          return caml_call2(f, key, data) ? ac : [0, key, ac];
         });
    return caml_call2
            (Base_List[9], to_remove, function(key){return remove(t, key);});
   }
   function filter_inplace(t, f){
    return filteri_inplace
            (t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys_inplace(t, f){
    return filteri_inplace
            (t, function(key, param){return caml_call1(f, key);});
   }
   function filter_mapi_inplace(t, f){
    var
     map_results =
       fold
        (t,
         0,
         function(key, data, ac){
          return [0, [0, key, caml_call2(f, key, data)], ac];
         });
    return caml_call2
            (Base_List[9],
             map_results,
             function(param){
              var result = param[2], key = param[1];
              if(! result) return remove(t, key);
              var data = result[1];
              return set(t, key, data);
             });
   }
   function filter_map_inplace(t, f){
    return filter_mapi_inplace
            (t, function(param, data){return caml_call1(f, data);});
   }
   function mapi_inplace(t, f){
    ensure_mutation_allowed(t);
    return without_mutating
            (t,
             function(param){
              var _h_ = Base_Avltree[18];
              return caml_call2
                      (Base_Array[9],
                       t[1],
                       function(_i_){return caml_call2(_h_, _i_, f);});
             });
   }
   function map_inplace(t, f){
    return mapi_inplace(t, function(param, data){return caml_call1(f, data);});
   }
   function similar(equal, t$0, t){
    var _f_ = t$0[2] === t[2] ? 1 : 0;
    return _f_
            ? caml_call1
              (with_return,
               function(r){
                without_mutating
                 (t,
                  function(param){
                   return iteri
                           (t$0,
                            function(key, data){
                             var match = find_and_call(t, key, if_found, if_not_found);
                             if(! match) return caml_call1(r, 0);
                             var
                              data$0 = match[1],
                              _g_ = 1 - caml_call2(equal, data, data$0);
                             return _g_ ? caml_call1(r, 0) : _g_;
                            });
                  });
                return 1;
               })
            : _f_;
   }
   function Creators(Key){
    var hashable = Key[1];
    function create$0(growth_allowed, size, param){
     return create(growth_allowed, size, hashable, 0);
    }
    function of_alist$0(growth_allowed, size, l){
     return of_alist(growth_allowed, size, hashable, l);
    }
    function of_alist_report_all_dups$0(growth_allowed, size, l){
     return of_alist_report_all_dups(growth_allowed, size, hashable, l);
    }
    function of_alist_or_error$0(growth_allowed, size, l){
     return of_alist_or_error(growth_allowed, size, hashable, l);
    }
    function of_alist_exn$0(growth_allowed, size, l){
     return of_alist_exn(growth_allowed, size, hashable, l);
    }
    function t_of_sexp$0(k_of_sexp, d_of_sexp, sexp){
     return t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp);
    }
    function of_alist_multi$0(growth_allowed, size, l){
     return of_alist_multi(growth_allowed, size, hashable, l);
    }
    function create_mapped$0(growth_allowed, size, get_key, get_data, l){
     return create_mapped
             (growth_allowed, size, hashable, get_key, get_data, l);
    }
    function create_with_key$0(growth_allowed, size, get_key, l){
     return create_with_key(growth_allowed, size, hashable, get_key, l);
    }
    function create_with_key_or_error$0(growth_allowed, size, get_key, l){
     return create_with_key_or_error
             (growth_allowed, size, hashable, get_key, l);
    }
    function create_with_key_exn$0(growth_allowed, size, get_key, l){
     return create_with_key_exn(growth_allowed, size, hashable, get_key, l);
    }
    function group$0(growth_allowed, size, get_key, get_data, combine, l){
     return group
             (growth_allowed, size, hashable, get_key, get_data, combine, l);
    }
    return [0,
            t_of_sexp$0,
            create$0,
            of_alist$0,
            of_alist_report_all_dups$0,
            of_alist_or_error$0,
            of_alist_exn$0,
            of_alist_multi$0,
            create_mapped$0,
            create_with_key$0,
            create_with_key_or_error$0,
            create_with_key_exn$0,
            group$0];
   }
   var
    hashable = Base_Hashable[2],
    _d_ = Creators([0, hashable]),
    t_of_sexp$0 = _d_[1],
    create$0 = _d_[2],
    of_alist$0 = _d_[3],
    of_alist_report_all_dups$0 = _d_[4],
    of_alist_or_error$0 = _d_[5],
    of_alist_exn$0 = _d_[6],
    of_alist_multi$0 = _d_[7],
    create_mapped$0 = _d_[8],
    create_with_key$0 = _d_[9],
    create_with_key_or_error$0 = _d_[10],
    create_with_key_exn$0 = _d_[11],
    group$0 = _d_[12];
   function hashable$0(t){return t[5];}
   var Private = [0, hashable$0];
   function create$1(growth_allowed, size, m){
    return create(growth_allowed, size, caml_call1(Base_Hashable[3], m), 0);
   }
   function of_alist$1(growth_allowed, size, m, l){
    return of_alist(growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_report_all_dups$1(growth_allowed, size, m, l){
    return of_alist_report_all_dups
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_or_error$1(growth_allowed, size, m, l){
    return of_alist_or_error
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_exn$1(growth_allowed, size, m, l){
    return of_alist_exn
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_multi$1(growth_allowed, size, m, l){
    return of_alist_multi
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function create_mapped$1(growth_allowed, size, m, get_key, get_data, l){
    return create_mapped
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             get_data,
             l);
   }
   function create_with_key$1(growth_allowed, size, m, get_key, l){
    return create_with_key
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function create_with_key_or_error$1(growth_allowed, size, m, get_key, l){
    return create_with_key_or_error
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function create_with_key_exn$1(growth_allowed, size, m, get_key, l){
    return create_with_key_exn
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function group$1(growth_allowed, size, m, get_key, get_data, combine, l){
    return group
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             get_data,
             combine,
             l);
   }
   function hashable_s(t){return caml_call1(Base_Hashable[4], t[5]);}
   function M(K){return [0];}
   function sexp_of_m_t(K){
    return function(sexp_of_v, t){return sexp_of_t(K[1], sexp_of_v, t);};
   }
   function m_t_of_sexp(K){
    return function(v_of_sexp, sexp){
     var _e_ = K[1];
     return t_of_sexp
             (caml_call1(Base_Hashable[3], [0, K[2], K[3], K[4]]),
              _e_,
              v_of_sexp,
              sexp);};
   }
   function m_t_sexp_grammar(K){
    return function(v_grammar){return t_sexp_grammar(K[1], v_grammar);};
   }
   function equal_m_t(param, equal_v, t1, t2){return similar(equal_v, t1, t2);
   }
   var
    Base_Hashtbl =
      [0,
       hash,
       hash_param,
       sexp_of_t,
       create$1,
       of_alist$1,
       of_alist_report_all_dups$1,
       of_alist_or_error$1,
       of_alist_exn$1,
       of_alist_multi$1,
       create_mapped$1,
       create_with_key$1,
       create_with_key_or_error$1,
       create_with_key_exn$1,
       group$1,
       sexp_of_key,
       clear,
       copy,
       fold,
       iter_keys,
       iter,
       iteri,
       existsi,
       exists,
       for_alli,
       for_all,
       counti,
       count,
       length,
       is_empty,
       mem,
       remove,
       choose,
       choose_exn,
       set,
       add,
       add_exn,
       change,
       update,
       update_and_return,
       map,
       mapi,
       filter_map,
       filter_mapi,
       filter_keys,
       filter,
       filteri,
       partition_map,
       partition_mapi,
       partition_tf,
       partitioni_tf,
       find_or_add,
       findi_or_add,
       find,
       find_exn,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       find_and_remove,
       merge,
       merge_into,
       keys,
       data,
       filter_keys_inplace,
       filter_inplace,
       filteri_inplace,
       map_inplace,
       mapi_inplace,
       filter_map_inplace,
       filter_mapi_inplace,
       similar,
       similar,
       to_alist,
       incr,
       decr,
       add_multi,
       remove_multi,
       find_multi,
       hashable_s,
       invariant,
       Creators,
       [0,
        t_of_sexp$0,
        sexp_of_t,
        t_sexp_grammar,
        hashable,
        invariant,
        create$0,
        of_alist$0,
        of_alist_report_all_dups$0,
        of_alist_or_error$0,
        of_alist_exn$0,
        of_alist_multi$0,
        create_mapped$0,
        create_with_key$0,
        create_with_key_or_error$0,
        create_with_key_exn$0,
        group$0,
        sexp_of_key,
        clear,
        copy,
        fold,
        iter_keys,
        iter,
        iteri,
        existsi,
        exists,
        for_alli,
        for_all,
        counti,
        count,
        length,
        is_empty,
        mem,
        remove,
        choose,
        choose_exn,
        set,
        add,
        add_exn,
        change,
        update,
        update_and_return,
        map,
        mapi,
        filter_map,
        filter_mapi,
        filter_keys,
        filter,
        filteri,
        partition_map,
        partition_mapi,
        partition_tf,
        partitioni_tf,
        find_or_add,
        findi_or_add,
        find,
        find_exn,
        find_and_call,
        find_and_call1,
        find_and_call2,
        findi_and_call,
        findi_and_call1,
        findi_and_call2,
        find_and_remove,
        merge,
        merge_into,
        keys,
        data,
        filter_keys_inplace,
        filter_inplace,
        filteri_inplace,
        map_inplace,
        mapi_inplace,
        filter_map_inplace,
        filter_mapi_inplace,
        similar,
        similar,
        to_alist,
        incr,
        decr,
        add_multi,
        remove_multi,
        find_multi],
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       equal_m_t,
       Private];
   runtime.caml_register_global(24, Base_Hashtbl, "Base__Hashtbl");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_set_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hash_set_intf = [0];
   runtime.caml_register_global(0, Base_Hash_set_intf, "Base__Hash_set_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_set
//# unitInfo: Requires: Base__Array, Base__Container, Base__Hash_set_intf, Base__Hashable, Base__Hashtbl, Base__Import, Base__List, Base__Or_error, Base__With_return, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_List = global_data.Base__List,
    Base_Hashable = global_data.Base__Hashable,
    Base_Hashtbl = global_data.Base__Hashtbl,
    Base_Array = global_data.Base__Array,
    Base_Container = global_data.Base__Container,
    Base_Or_error = global_data.Base__Or_error,
    Base_With_return = global_data.Base__With_return,
    hashable_s = Base_Hashtbl[81],
    hashable = Base_Hashtbl[90][1],
    poly_hashable = Base_Hashtbl[84][4],
    with_return = Base_With_return[1],
    clear = Base_Hashtbl[16],
    length = Base_Hashtbl[28],
    mem = Base_Hashtbl[30],
    cst_element_already_exists = "element already exists",
    _a_ = [0, 0];
   function is_empty(t){return caml_call1(Base_Hashtbl[29], t);}
   function find_map(t, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (Base_Hashtbl[19],
                t,
                function(elt){
                 var o = caml_call1(f, elt);
                 return o ? caml_call1(r, o) : 0;
                });
              return 0;
             });
   }
   function find(t, f){
    return find_map(t, function(a){return caml_call1(f, a) ? [0, a] : 0;});
   }
   function add(t, k){return caml_call3(Base_Hashtbl[34], t, k, 0);}
   function strict_add(t, k){
    return caml_call2(mem, t, k)
            ? caml_call1(Base_Or_error[36], cst_element_already_exists)
            : (caml_call3(Base_Hashtbl[34], t, k, 0), _a_);
   }
   function strict_add_exn(t, k){
    var _r_ = strict_add(t, k);
    return caml_call1(Base_Or_error[31], _r_);
   }
   var
    remove = Base_Hashtbl[31],
    _b_ = [0, 0],
    cst_element_not_in_set = "element not in set";
   function strict_remove(t, k){
    if(caml_call2(mem, t, k)){caml_call2(remove, t, k); return _b_;}
    var _q_ = caml_call1(Base_Hashtbl[15], t);
    return caml_call5(Base_Or_error[34], 0, 0, cst_element_not_in_set, k, _q_);
   }
   function strict_remove_exn(t, k){
    var _p_ = strict_remove(t, k);
    return caml_call1(Base_Or_error[31], _p_);
   }
   function fold(t, init, f){
    return caml_call3
            (Base_Hashtbl[18],
             t,
             init,
             function(key, param, acc){return caml_call2(f, acc, key);});
   }
   function iter(t, f){return caml_call2(Base_Hashtbl[19], t, f);}
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f){
    var _n_ = caml_call3(Base_Container[9], fold, init, f);
    return function(_o_){return caml_call2(_n_, _o_, t);};
   }
   var
    to_list = Base_Hashtbl[64],
    _c_ = [0, 0],
    cst_Hash_set_t_of_sexp_require = "Hash_set.t_of_sexp requires a list",
    cst_Hash_set_t_of_sexp_got_a_d =
      "Hash_set.t_of_sexp got a duplicate element";
   function sexp_of_t(sexp_of_e, t){
    var
     _l_ = caml_call1(to_list, t),
     func = Base_List[62],
     _m_ = caml_call2(func, _l_, caml_call1(hashable, t)[2]);
    return caml_call2(Base_Import[151], sexp_of_e, _m_);
   }
   function to_array(t){
    var
     len = caml_call1(length, t),
     index = [0, caml_call2(Base_Import[92], len, 1)];
    return fold
            (t,
             [0],
             function(acc, key){
              if(0 === acc.length - 1)
               return caml_call2(Base_Array[25], len, key);
              index[1] = caml_call2(Base_Import[92], index[1], 1);
              var _k_ = index[1];
              runtime.caml_check_bound(acc, _k_)[1 + _k_] = key;
              return acc;
             });
   }
   function exists(t, f){
    return caml_call2
            (Base_Hashtbl[22],
             t,
             function(key, param){return caml_call1(f, key);});
   }
   function for_all(t, f){
    return 1
           -
            caml_call2
             (Base_Hashtbl[22],
              t,
              function(key, param){return 1 - caml_call1(f, key);});
   }
   function equal(t1, t2){
    return caml_call3
            (Base_Hashtbl[73], function(param, _j_){return 1;}, t1, t2);
   }
   function copy(t){return caml_call1(Base_Hashtbl[17], t);}
   function filter(t, f){
    return caml_call2
            (Base_Hashtbl[46],
             t,
             function(key, param){return caml_call1(f, key);});
   }
   function union(t1, t2){
    return caml_call3
            (Base_Hashtbl[62], t1, t2, function(param, _i_){return _c_;});
   }
   function diff(t1, t2){
    return filter
            (t1,
             function(key){return 1 - caml_call2(Base_Hashtbl[30], t2, key);});
   }
   function inter(t1, t2){
    var _h_ = caml_call1(length, t2);
    if(_h_ < caml_call1(length, t1))
     var larger = t1, smaller = t2;
    else
     var larger = t2, smaller = t1;
    return caml_call2
            (Base_Hashtbl[46],
             smaller,
             function(key, param){
              return caml_call2(Base_Hashtbl[30], larger, key);
             });
   }
   function filter_inplace(t, f){
    var
     to_remove =
       fold(t, 0, function(ac, x){return caml_call1(f, x) ? ac : [0, x, ac];});
    return caml_call2
            (Base_List[9],
             to_remove,
             function(x){return caml_call2(remove, t, x);});
   }
   function of_hashtbl_keys(hashtbl){
    return caml_call2(Base_Hashtbl[40], hashtbl, function(_g_){return 0;});
   }
   function to_hashtbl(t, f){
    return caml_call2
            (Base_Hashtbl[41],
             t,
             function(key, param){return caml_call1(f, key);});
   }
   function create(growth_allowed, size, m){
    return caml_call3(Base_Hashtbl[4], growth_allowed, size, m);
   }
   function of_list(growth_allowed, size, m, l){
    if(size)
     var x = size[1], size$0 = x;
    else
     var size$0 = caml_call1(Base_List[7], l);
    var t = caml_call3(Base_Hashtbl[4], growth_allowed, [0, size$0], m);
    caml_call2(Base_List[9], l, function(k){return add(t, k);});
    return t;
   }
   function t_of_sexp(m, e_of_sexp, sexp){
    if(0 === sexp[0])
     return caml_call2(Base_Import[158], cst_Hash_set_t_of_sexp_require, sexp);
    var list = sexp[1], t = create(0, [0, caml_call1(Base_List[7], list)], m);
    caml_call2
     (Base_List[9],
      list,
      function(sexp){
       var e = caml_call1(e_of_sexp, sexp);
       return 0 === strict_add(t, e)[0]
               ? 0
               : caml_call2
                 (Base_Import[158], cst_Hash_set_t_of_sexp_got_a_d, sexp);
      });
    return t;
   }
   function Creators(Elt){
    function create$0(growth_allowed, size, param){
     return create(growth_allowed, size, caml_call1(Base_Hashable[4], Elt[1]));
    }
    function of_list$0(growth_allowed, size, l){
     return of_list
             (growth_allowed, size, caml_call1(Base_Hashable[4], Elt[1]), l);
    }
    function t_of_sexp$0(e_of_sexp, sexp){
     return t_of_sexp(caml_call1(Base_Hashable[4], Elt[1]), e_of_sexp, sexp);
    }
    return [0, t_of_sexp$0, create$0, of_list$0];
   }
   var
    _d_ = Creators([0, poly_hashable]),
    t_of_sexp$0 = _d_[1],
    create$0 = _d_[2],
    of_list$0 = _d_[3];
   function t_sexp_grammar(grammar){
    var _f_ = caml_call1(Base_List[5], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _f_);
   }
   function M(Elt){return [0];}
   function sexp_of_m_t(Elt){
    return function(t){return sexp_of_t(Elt[1], t);};
   }
   function m_t_of_sexp(Elt){
    return function(sexp){
     return t_of_sexp([0, Elt[2], Elt[3], Elt[4]], Elt[1], sexp);};
   }
   function m_t_sexp_grammar(Elt){
    var _e_ = caml_call1(Base_Import[194], Elt[1]);
    return caml_call1(Sexplib0_Sexp_grammar[1], _e_);
   }
   function equal_m_t(param, t1, t2){return equal(t1, t2);}
   var
    hashable$0 = Base_Hashtbl[90][1],
    Private = [0, hashable$0],
    Base_Hash_set =
      [0,
       sexp_of_t,
       create,
       of_list,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       mem,
       copy,
       add,
       strict_add,
       strict_add_exn,
       remove,
       strict_remove,
       strict_remove_exn,
       clear,
       equal,
       filter,
       filter_inplace,
       inter,
       union,
       diff,
       of_hashtbl_keys,
       to_hashtbl,
       hashable_s,
       [0,
        t_of_sexp$0,
        sexp_of_t,
        t_sexp_grammar,
        create$0,
        of_list$0,
        length,
        is_empty,
        iter,
        fold,
        fold_result,
        fold_until,
        exists,
        for_all,
        count,
        sum,
        find,
        find_map,
        to_list,
        to_array,
        min_elt,
        max_elt,
        mem,
        copy,
        add,
        strict_add,
        strict_add_exn,
        remove,
        strict_remove,
        strict_remove_exn,
        clear,
        equal,
        filter,
        filter_inplace,
        inter,
        union,
        diff,
        of_hashtbl_keys,
        to_hashtbl],
       Creators,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       equal_m_t,
       Private];
   runtime.caml_register_global(16, Base_Hash_set, "Base__Hash_set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Float
//# unitInfo: Requires: Assert_failure, Base__Bytes0, Base__Char, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int, Base__Int63, Base__Int64, Base__Int_conversions, Base__Or_error, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String, Base__Word_size, Sexplib0__Sexp_conv_error, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_out_of_range_0 = " out of range [0, ",
    cst_s_1e = "%s%.1e",
    cst_is_too_large = ") is too large",
    cst_is_too_small_or_NaN = ") is too small or NaN",
    cst$5 = ".",
    cst_Float_int63_round_down_exn = "Float.int63_round_down_exn: argument (",
    cst_Float_int63_round_nearest_ =
      "Float.int63_round_nearest_portable_alloc_exn: argument (",
    cst_Float_int63_round_up_exn_a = "Float.int63_round_up_exn: argument (",
    cst_Float_iround_down_exn_argu = "Float.iround_down_exn: argument (",
    cst_Float_iround_nearest_exn_a = "Float.iround_nearest_exn: argument (",
    cst_Float_iround_nearest_exn_a$0 =
      "Float.iround_nearest_exn: argument (%f) is too large",
    cst_Float_iround_up_exn_argume = "Float.iround_up_exn: argument (",
    cst_Infinite = "Infinite",
    cst_Nan = "Nan",
    cst_Normal = "Normal",
    cst_Subnormal = "Subnormal",
    cst_Zero = "Zero",
    cst_infinite = "infinite",
    cst_nan$1 = "nan",
    cst_normal = "normal",
    cst_src_float_ml = "src/float.ml",
    cst_subnormal = "subnormal",
    cst_zero = "zero",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_format_float = runtime.caml_format_float,
    caml_int64_bits_of_float = runtime.caml_int64_bits_of_float,
    caml_int64_or = runtime.caml_int64_or,
    caml_log10_float = runtime.caml_log10_float,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_compare = runtime.caml_string_compare;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = cst$4,
    cst$2 = cst$4,
    cst$1 = "-",
    cst$0 = cst$5,
    cst = cst$5,
    all = [0, 0, [0, 1, [0, 2, [0, 3, [0, 4, 0]]]]],
    error_source_006 = "float.ml.Class.t",
    t_sexp_grammar$0 =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Infinite, 0]],
         [0,
          [1, [0, cst_Nan, 0]],
          [0,
           [1, [0, cst_Normal, 0]],
           [0, [1, [0, cst_Subnormal, 0]], [0, [1, [0, cst_Zero, 0]], 0]]]]]]],
    module_name = "Base.Float",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Or_error = global_data.Base__Or_error,
    Base_Int = global_data.Base__Int,
    Base_Int63 = global_data.Base__Int63,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Int64 = global_data.Base__Int64,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Assert_failure = global_data.Assert_failure,
    Base_String = global_data.Base__String,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Char = global_data.Base__Char,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Word_size = global_data.Base__Word_size,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    round_up = Base_Float0[1],
    round_down = Base_Float0[2],
    mod_float = Base_Float0[3],
    modf = Base_Float0[4],
    float_of_string = Base_Float0[5],
    nan = Base_Float0[6],
    max_value = Base_Float0[7],
    neg_infinity = Base_Float0[8],
    max_finite_value = Base_Float0[9],
    epsilon_float = Base_Float0[10],
    classify_float = Base_Float0[11],
    abs_float = Base_Float0[12],
    is_integer = Base_Float0[13],
    symbol = Base_Float0[14],
    symbol$0 = Base_Float0[15],
    frexp = Base_Float0[16],
    ldexp = Base_Float0[17],
    is_nan = Base_Float0[18],
    to_int64_preserve_order = Base_Float0[19],
    to_int64_preserve_order_exn = Base_Float0[20],
    of_int64_preserve_order = Base_Float0[21],
    one_ulp = Base_Float0[22],
    upper_bound_for_int = Base_Float0[23],
    lower_bound_for_int = Base_Float0[25],
    clamp_unchecked = Base_Float0[26],
    box = Base_Float0[27],
    compare = Base_Float0[36],
    raise_s = Base_Error[30],
    hash_fold_t = Base_Import[209],
    func = Base_Import[223];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[166],
    sexp_of_t = Base_Import[142],
    t_sexp_grammar = Base_Import[186],
    hashable = [0, hash, compare, sexp_of_t],
    compare$0 = Base_Import[107][9],
    include = caml_call1(Base_Comparator[5], [0, compare$0, sexp_of_t]),
    comparator = include[1],
    _a_ = [0, [11, "Float.of_string ", [2, 0, 0]], "Float.of_string %s"];
   function invariant(param){return 0;}
   function to_float(x){return x;}
   function of_float(x){return x;}
   function of_string(s){
    try{var _aV_ = caml_call1(float_of_string, s); return _aV_;}
    catch(_aW_){return caml_call3(Base_Printf[7], _a_, s, 0);}
   }
   function to_string(x){
    var
     y = caml_format_float("%.15g", x),
     _aU_ = caml_call1(float_of_string, y),
     y$0 =
       caml_call2(Base_Import[107][4], _aU_, x)
        ? y
        : caml_format_float("%.17g", x),
     l = runtime.caml_ml_string_length(y$0),
     i = 0;
    for(;;){
     if(l <= i) return caml_call2(Base_Import[111], y$0, cst);
     var match = runtime.caml_string_get(y$0, i);
     a:
     {
      if(48 <= match){if(58 > match) break a;} else if(45 === match) break a;
      return y$0;
     }
     var i$0 = caml_call2(Base_Import[90], i, 1);
     i = i$0;
    }
   }
   var
    min_positive_subnormal_value = caml_call2(symbol, 2., -1074.),
    min_positive_normal_value = caml_call2(symbol, 2., -1022.),
    zero = 0.,
    of_int = Base_Int[3],
    to_int = Base_Int[2];
   function of_int63(i){return caml_call1(Base_Int63[3], i);}
   var
    of_int64 = runtime.caml_int64_to_float,
    to_int64 = runtime.caml_int64_of_float,
    iround_lbound = caml_call1(lower_bound_for_int, Base_Int[59]),
    iround_ubound = caml_call1(upper_bound_for_int, Base_Int[59]),
    _b_ =
      [0,
       [11,
        cst_Float_iround_up_exn_argume,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.iround_up_exn: argument (%f) is too large"],
    _c_ =
      [0,
       [11,
        cst_Float_iround_up_exn_argume,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_up_exn: argument (%f) is too small or NaN"],
    _d_ =
      [0,
       [11,
        cst_Float_iround_down_exn_argu,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.iround_down_exn: argument (%f) is too large"],
    _e_ =
      [0,
       [11,
        cst_Float_iround_down_exn_argu,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_down_exn: argument (%f) is too small or NaN"],
    _f_ =
      [0,
       [11,
        "Float.iround_towards_zero_exn: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Float.iround_towards_zero_exn: argument (%f) is out of range or NaN"];
   function iround_up(t){
    if(! caml_call2(Base_Import[107][5], t, 0.))
     return caml_call2(Base_Import[107][6], t, iround_lbound)
             ? [0, caml_call1(Base_Int[58], t)]
             : 0;
    var t$0 = caml_call1(round_up, t);
    return caml_call2(Base_Import[107][2], t$0, iround_ubound)
            ? [0, caml_call1(Base_Int[58], t$0)]
            : 0;
   }
   function iround_up_exn(t){
    if(caml_call2(Base_Import[107][5], t, 0.)){
     var t$0 = caml_call1(round_up, t);
     if(caml_call2(Base_Import[107][2], t$0, iround_ubound))
      return caml_call1(Base_Int[58], t$0);
     var _aS_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _b_, _aS_, 0);
    }
    if(caml_call2(Base_Import[107][6], t, iround_lbound))
     return caml_call1(Base_Int[58], t);
    var _aT_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _c_, _aT_, 0);
   }
   function iround_down(t){
    if(caml_call2(Base_Import[107][6], t, 0.))
     return caml_call2(Base_Import[107][2], t, iround_ubound)
             ? [0, caml_call1(Base_Int[58], t)]
             : 0;
    var t$0 = caml_call1(round_down, t);
    return caml_call2(Base_Import[107][6], t$0, iround_lbound)
            ? [0, caml_call1(Base_Int[58], t$0)]
            : 0;
   }
   function iround_down_exn(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     if(caml_call2(Base_Import[107][2], t, iround_ubound))
      return caml_call1(Base_Int[58], t);
     var _aQ_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _d_, _aQ_, 0);
    }
    var t$0 = caml_call1(round_down, t);
    if(caml_call2(Base_Import[107][6], t$0, iround_lbound))
     return caml_call1(Base_Int[58], t$0);
    var _aR_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _e_, _aR_, 0);
   }
   function iround_towards_zero(t){
    if
     (caml_call2(Base_Import[107][6], t, iround_lbound)
      && caml_call2(Base_Import[107][2], t, iround_ubound))
     return [0, caml_call1(Base_Int[58], t)];
    return 0;
   }
   function iround_towards_zero_exn(t){
    if
     (caml_call2(Base_Import[107][6], t, iround_lbound)
      && caml_call2(Base_Import[107][2], t, iround_ubound))
     return caml_call1(Base_Int[58], t);
    var _aP_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _f_, _aP_, 0);
   }
   var
    _g_ = caml_call2(symbol, 2., 52.),
    round_nearest_lb = caml_call1(Base_Import[113], _g_),
    round_nearest_ub = caml_call2(symbol, 2., 52.),
    one_ulp_less_than_half = caml_call2(one_ulp, 759637122, 0.5);
   function add_half_for_round_nearest(t){
    var
     _aO_ =
       caml_call2(Base_Import[107][4], t, one_ulp_less_than_half)
        ? one_ulp_less_than_half
        : 0.5;
    return caml_call2(Base_Import[91], t, _aO_);
   }
   function iround_nearest_32(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     var t$0 = add_half_for_round_nearest(t);
     return caml_call2(Base_Import[107][2], t$0, iround_ubound)
             ? [0, caml_call1(Base_Int[58], t$0)]
             : 0;
    }
    var t$1 = caml_call1(round_down, caml_call2(Base_Import[91], t, 0.5));
    return caml_call2(Base_Import[107][6], t$1, iround_lbound)
            ? [0, caml_call1(Base_Int[58], t$1)]
            : 0;
   }
   function iround_nearest_64(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     if(! caml_call2(Base_Import[107][1], t, round_nearest_ub))
      return caml_call2(Base_Import[107][2], t, iround_ubound)
              ? [0, caml_call1(Base_Int[58], t)]
              : 0;
     var _aM_ = add_half_for_round_nearest(t);
     return [0, caml_call1(Base_Int[58], _aM_)];
    }
    if(! caml_call2(Base_Import[107][5], t, round_nearest_lb))
     return caml_call2(Base_Import[107][6], t, iround_lbound)
             ? [0, caml_call1(Base_Int[58], t)]
             : 0;
    var _aN_ = caml_call1(round_down, caml_call2(Base_Import[91], t, 0.5));
    return [0, caml_call1(Base_Int[58], _aN_)];
   }
   var
    _R_ = [0, [8, [0, 0, 4], 0, [0, 8], 0], "%.8G"],
    _P_ =
      [0,
       [11,
        "exponent ",
        [4, 0, 0, 0, [11, cst_out_of_range_0, [4, 0, 0, 0, [12, 93, 0]]]]],
       "exponent %d out of range [0, %d]"],
    _Q_ =
      [0,
       [11,
        "mantissa ",
        [2, 0, [11, cst_out_of_range_0, [2, 0, [12, 93, 0]]]]],
       "mantissa %s out of range [0, %s]"],
    cst_Float_sign_exn_of_NAN = "Float.sign_exn of NAN",
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _L_ = [0, cst_src_float_ml, 859, 2],
    _K_ =
      [0,
       [11,
        "Float.round_significant: invalid argument significant_digits:",
        [4, 0, 0, 0, 0]],
       "Float.round_significant: invalid argument significant_digits:%d"],
    _J_ = [0, [8, [0, 0, 3], 0, 1, 0], "%.*g"],
    _I_ = [0, "p"],
    cst_t = "t",
    cst_g = "g",
    cst_m = "m",
    cst_k = "k",
    _F_ = [0, cst_src_float_ml, 697, 8],
    _E_ = [0, cst_src_float_ml, 700, 8],
    _A_ = [0, cst_src_float_ml, 707, 8],
    _B_ = [0, cst_src_float_ml, 708, 8],
    _C_ = [0, [2, 0, [4, 0, 0, 0, [2, 0, [12, 32, 0]]]], "%s%d%s "],
    _D_ = [0, [2, 0, [4, 0, 0, 0, [2, 0, [4, 0, 0, 0, 0]]]], "%s%d%s%d"],
    _z_ = [0, cst_src_float_ml, 684, 8],
    cst_0 = ".0",
    _G_ = [0, [2, 0, [8, [0, 0, 1], 0, [0, 1], 0]], cst_s_1e],
    _H_ = [0, [2, 0, [8, [0, 0, 1], 0, [0, 1], 0]], cst_s_1e],
    cst_inf$1 = "-inf  ",
    cst_inf$2 = "inf  ",
    cst_nan$0 = "nan  ",
    cst_sexp = "sexp",
    cst_sexp_of_float_produced_str = "[sexp_of_float] produced strange sexp",
    _w_ =
      [0,
       [11, "to_string_hum: invalid argument ~decimals=", [4, 0, 0, 0, 0]],
       "to_string_hum: invalid argument ~decimals=%d"],
    _x_ = [0, [8, [0, 1, 0], 0, 1, 0], "%+.*f"],
    _y_ = [0, [8, [0, 0, 0], 0, 1, 0], "%.*f"],
    cst_inf = "inf",
    cst_inf$0 = "-inf",
    cst_nan = cst_nan$1,
    _r_ = [0, cst_Infinite],
    _s_ = [0, cst_Nan],
    _t_ = [0, cst_Normal],
    _u_ = [0, cst_Subnormal],
    _v_ = [0, cst_Zero],
    _p_ =
      [0,
       [11,
        cst_Float_int63_round_nearest_,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too large"],
    _q_ =
      [0,
       [11,
        cst_Float_int63_round_nearest_,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too small or NaN"],
    _n_ =
      [0,
       [11,
        cst_Float_int63_round_down_exn,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_down_exn: argument (%f) is too large"],
    _o_ =
      [0,
       [11,
        cst_Float_int63_round_down_exn,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_down_exn: argument (%f) is too small or NaN"],
    _l_ =
      [0,
       [11,
        cst_Float_int63_round_up_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_up_exn: argument (%f) is too large"],
    _m_ =
      [0,
       [11,
        cst_Float_int63_round_up_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_up_exn: argument (%f) is too small or NaN"],
    _j_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       cst_Float_iround_nearest_exn_a$0],
    _k_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_nearest_exn: argument (%f) is too small or NaN"],
    _h_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       cst_Float_iround_nearest_exn_a$0],
    _i_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, ") is too small", 0]]],
       "Float.iround_nearest_exn: argument (%f) is too small"],
    one = 1.,
    minus_one = -1.,
    pi = 3.141592653589793,
    sqrt_pi = 1.772453850905516,
    sqrt_2pi = 2.5066282746310007,
    euler = 0.5772156649015329,
    iround_nearest_64$0 =
      Base_Word_size[3] ? iround_nearest_64 : iround_nearest_32;
   function iround_nearest_exn_32(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     var t$0 = add_half_for_round_nearest(t);
     if(caml_call2(Base_Import[107][2], t$0, iround_ubound))
      return caml_call1(Base_Int[58], t$0);
     var _aK_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _h_, _aK_, 0);
    }
    var t$1 = caml_call1(round_down, caml_call2(Base_Import[91], t, 0.5));
    if(caml_call2(Base_Import[107][6], t$1, iround_lbound))
     return caml_call1(Base_Int[58], t$1);
    var _aL_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _i_, _aL_, 0);
   }
   function iround_nearest_exn_64(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     if(caml_call2(Base_Import[107][1], t, round_nearest_ub)){
      var _aG_ = add_half_for_round_nearest(t);
      return caml_call1(Base_Int[58], _aG_);
     }
     if(caml_call2(Base_Import[107][2], t, iround_ubound))
      return caml_call1(Base_Int[58], t);
     var _aH_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _j_, _aH_, 0);
    }
    if(caml_call2(Base_Import[107][5], t, round_nearest_lb)){
     var _aI_ = caml_call1(round_down, caml_call2(Base_Import[91], t, 0.5));
     return caml_call1(Base_Int[58], _aI_);
    }
    if(caml_call2(Base_Import[107][6], t, iround_lbound))
     return caml_call1(Base_Int[58], t);
    var _aJ_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _k_, _aJ_, 0);
   }
   var
    iround_nearest_exn =
      Base_Word_size[3] ? iround_nearest_exn_64 : iround_nearest_exn_32;
   function iround_exn(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    return 857423934 <= dir
            ? 1003109192
              <= dir
              ? iround_towards_zero_exn(t)
              : iround_nearest_exn(t)
            : 759637122 <= dir ? iround_down_exn(t) : iround_up_exn(t);
   }
   function iround(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    try{var _aE_ = [0, iround_exn([0, dir], t)]; return _aE_;}
    catch(_aF_){return 0;}
   }
   function is_inf(t){
    var _aD_ = caml_call2(Base_Import[95], 1., t);
    return caml_call2(Base_Import[107][4], _aD_, 0.);
   }
   function is_finite(t){
    var _aC_ = caml_call2(Base_Import[93], t, t);
    return caml_call2(Base_Import[107][4], _aC_, 0.);
   }
   function min_inan(x, y){
    return caml_call1(is_nan, y)
            ? x
            : caml_call1
               (is_nan, x)
              ? y
              : caml_call2(Base_Import[107][1], x, y) ? x : y;
   }
   function max_inan(x, y){
    return caml_call1(is_nan, y)
            ? x
            : caml_call1
               (is_nan, x)
              ? y
              : caml_call2(Base_Import[107][5], x, y) ? x : y;
   }
   var
    add = Base_Import[91],
    sub = Base_Import[93],
    neg = Base_Import[113],
    scale = Base_Import[89];
   function square(x){return caml_call2(Base_Import[89], x, x);}
   function fractional(t){return caml_call1(Base_Import[124], t);}
   function integral(t){return caml_call1(Base_Import[126], t);}
   function round_towards_zero(t){
    return caml_call2(Base_Import[107][6], t, 0.)
            ? caml_call1(round_down, t)
            : caml_call1(round_up, t);
   }
   function round_nearest_inline(t){
    if
     (caml_call2(Base_Import[107][5], t, round_nearest_lb)
      && caml_call2(Base_Import[107][1], t, round_nearest_ub))
     return caml_call1(round_down, add_half_for_round_nearest(t));
    return caml_call2(Base_Import[91], t, 0.);
   }
   function round_nearest(t){return round_nearest_inline(t);}
   function round_nearest_half_to_even(t){
    if
     (!
      caml_call2(Base_Import[107][2], t, round_nearest_lb)
      && ! caml_call2(Base_Import[107][6], t, round_nearest_ub)){
     var
      floor = caml_call1(round_down, t),
      ceil_or_succ = caml_call2(Base_Import[91], floor, 1.),
      diff_floor = caml_call2(Base_Import[93], t, floor),
      diff_ceil = caml_call2(Base_Import[93], ceil_or_succ, t);
     if(caml_call2(Base_Import[107][1], diff_floor, diff_ceil)) return floor;
     if(caml_call2(Base_Import[107][5], diff_floor, diff_ceil))
      return ceil_or_succ;
     var _aB_ = caml_call2(mod_float, floor, 2.);
     return caml_call2(Base_Import[107][4], _aB_, 0.) ? floor : ceil_or_succ;
    }
    return caml_call2(Base_Import[91], t, 0.);
   }
   var
    int63_round_lbound = caml_call1(lower_bound_for_int, Base_Int63[83]),
    int63_round_ubound = caml_call1(upper_bound_for_int, Base_Int63[83]);
   function int63_round_up_exn(t){
    if(caml_call2(Base_Import[107][5], t, 0.)){
     var t$0 = caml_call1(round_up, t);
     if(caml_call2(Base_Import[107][2], t$0, int63_round_ubound))
      return caml_call1(Base_Int63[82], t$0);
     var _az_ = caml_call1(Base_Float0[27], t);
     return caml_call3(Base_Printf[7], _l_, _az_, 0);
    }
    if(caml_call2(Base_Import[107][6], t, int63_round_lbound))
     return caml_call1(Base_Int63[82], t);
    var _aA_ = caml_call1(Base_Float0[27], t);
    return caml_call3(Base_Printf[7], _m_, _aA_, 0);
   }
   function int63_round_down_exn(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     if(caml_call2(Base_Import[107][2], t, int63_round_ubound))
      return caml_call1(Base_Int63[82], t);
     var _ax_ = caml_call1(Base_Float0[27], t);
     return caml_call3(Base_Printf[7], _n_, _ax_, 0);
    }
    var t$0 = caml_call1(round_down, t);
    if(caml_call2(Base_Import[107][6], t$0, int63_round_lbound))
     return caml_call1(Base_Int63[82], t$0);
    var _ay_ = caml_call1(Base_Float0[27], t);
    return caml_call3(Base_Printf[7], _o_, _ay_, 0);
   }
   function int63_round_nearest_portable_a(t0){
    var t = round_nearest_inline(t0);
    if(caml_call2(Base_Import[107][5], t, 0.)){
     if(caml_call2(Base_Import[107][2], t, int63_round_ubound))
      return caml_call1(Base_Int63[82], t);
     var _av_ = caml_call1(box, t0);
     return caml_call3(Base_Printf[7], _p_, _av_, 0);
    }
    if(caml_call2(Base_Import[107][6], t, int63_round_lbound))
     return caml_call1(Base_Int63[82], t);
    var _aw_ = caml_call1(box, t0);
    return caml_call3(Base_Printf[7], _q_, _aw_, 0);
   }
   function int63_round_nearest_arch64_noa(f){
    var _au_ = iround_nearest_exn(f);
    return caml_call1(Base_Int63[96], _au_);
   }
   var
    int63_round_nearest_exn =
      Base_Word_size[3]
       ? int63_round_nearest_arch64_noa
       : int63_round_nearest_portable_a;
   function round(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    return 857423934 <= dir
            ? 1003109192
              <= dir
              ? round_towards_zero(t)
              : round_nearest_inline(t)
            : 759637122
              <= dir
              ? caml_call1(round_down, t)
              : caml_call1(round_up, t);
   }
   var compare$1 = runtime.caml_int_compare;
   function t_of_sexp$0(sexp_007){
    a:
    {
     if(0 === sexp_007[0]){
      var _ao_ = sexp_007[1], _ap_ = caml_string_compare(_ao_, cst_infinite);
      b:
      {
       c:
       {
        d:
        {
         e:
         {
          if(0 <= _ap_){
           if(0 < _ap_){
            if(_ao_ === cst_nan$1) break e;
            if(_ao_ === cst_normal) break d;
            if(_ao_ === cst_subnormal) break c;
            if(_ao_ !== cst_zero) break a;
            break b;
           }
          }
          else if(_ao_ !== cst_Infinite){
           if(_ao_ === cst_Nan) break e;
           if(_ao_ === cst_Normal) break d;
           if(_ao_ === cst_Subnormal) break c;
           if(_ao_ !== cst_Zero) break a;
           break b;
          }
          return 0;
         }
         return 1;
        }
        return 2;
       }
       return 3;
      }
      return 4;
     }
     var _aq_ = sexp_007[1];
     if(! _aq_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_006, sexp_007);
     var _ar_ = _aq_[1];
     if(0 !== _ar_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_006, sexp_007);
     var _as_ = _ar_[1], _at_ = caml_string_compare(_as_, cst_infinite);
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         if(0 <= _at_){
          if(0 < _at_){
           if(_as_ === cst_nan$1) break e;
           if(_as_ === cst_normal) break d;
           if(_as_ === cst_subnormal) break c;
           if(_as_ !== cst_zero) break a;
           break b;
          }
         }
         else if(_as_ !== cst_Infinite){
          if(_as_ === cst_Nan) break e;
          if(_as_ === cst_Normal) break d;
          if(_as_ === cst_Subnormal) break c;
          if(_as_ !== cst_Zero) break a;
          break b;
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_006, sexp_007);
   }
   function sexp_of_t$0(param){
    switch(param){
      case 0:
       return _r_;
      case 1:
       return _s_;
      case 2:
       return _t_;
      case 3:
       return _u_;
      default: return _v_;
    }
   }
   function to_string$0(t){
    var _an_ = sexp_of_t$0(t);
    return caml_call1(Base_Import[162], _an_);
   }
   function of_string$0(s){
    return t_of_sexp$0(caml_call1(Base_Import[138], s));
   }
   function classify(t){
    switch(caml_call1(classify_float, t)){
      case 0:
       return 2;
      case 1:
       return 3;
      case 2:
       return 4;
      case 3:
       return 0;
      default: return 1;
    }
   }
   function insert_underscores(opt, _al_, string){
    if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
    if(_al_) var sth$0 = _al_[1], strip_zero = sth$0; else var strip_zero = 0;
    var match = caml_call2(Base_String[84], string, 46);
    if(! match)
     return caml_call2(Base_Int_conversions[37], string, delimiter);
    var
     match$0 = match[1],
     right = match$0[2],
     left = match$0[1],
     left$0 = caml_call2(Base_Int_conversions[37], left, delimiter),
     right$0 =
       strip_zero
        ? caml_call2
          (Base_String[92],
           [0, function(c){return caml_call2(Base_Char[11], c, 48);}],
           right)
        : right;
    if(right$0 === cst$4) return left$0;
    var _am_ = caml_call2(Base_Import[111], cst$0, right$0);
    return caml_call2(Base_Import[111], left$0, _am_);
   }
   function to_string_hum(delimiter, opt, strip_zero, _ak_, f){
    if(opt) var sth = opt[1], decimals = sth; else var decimals = 3;
    if(_ak_)
     var sth$0 = _ak_[1], explicit_plus = sth$0;
    else
     var explicit_plus = 0;
    if(decimals < 0) caml_call3(Base_Printf[7], _w_, decimals, 0);
    var match = classify(f);
    if(1 === match) return cst_nan;
    if(! match)
     return caml_call2(Base_Import[107][5], f, 0.) ? cst_inf : cst_inf$0;
    var
     s =
       explicit_plus
        ? caml_call3(Base_Printf[2], _x_, decimals, f)
        : caml_call3(Base_Printf[2], _y_, decimals, f);
    return insert_underscores(delimiter, strip_zero, s);
   }
   function sexp_of_t$1(t){
    var sexp = caml_call1(sexp_of_t, t);
    if(1009018843 <= Base_Sexp[18][1]) return sexp;
    if(0 === sexp[0]){
     var string = sexp[1];
     return caml_call4(Base_String[56], 0, 0, string, 69)
             ? sexp
             : [0, insert_underscores(0, 0, string)];
    }
    var _aj_ = [0, [0, cst_sexp, caml_call1(Base_Sexp[4], sexp)], 0];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[9], cst_sexp_of_float_produced_str, _aj_));
   }
   function to_padded_compact_string_custo
   (t, opt, kilo, mega, giga, tera, peta, param){
    if(opt) var sth = opt[1], prefix = sth; else var prefix = cst$2;
    var match = classify(t);
    if(1 === match) return cst_nan$0;
    if(! match)
     return caml_call2(Base_Import[107][1], t, 0.) ? cst_inf$1 : cst_inf$2;
    function go(t){
     function conv(mag, numerator, denominator){
      a:
      {
       if
        (caml_call2(Base_Import[107][4], denominator, 100.)
         && caml_call2(Base_Import[107][6], numerator, 999.95))
        break a;
       if(caml_call2(Base_Import[107][6], denominator, 100000.)){
        var
         t$0 = caml_call2(Base_Import[89], denominator, 9.9995),
         _ai_ = round_nearest_inline(t$0);
        if(caml_call2(Base_Import[107][6], numerator, _ai_)) break a;
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
      }
      var
       t = caml_call2(Base_Import[89], denominator, 9999.5),
       _ah_ = round_nearest_inline(t);
      if(! caml_call2(Base_Import[107][1], numerator, _ah_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
      var
       k =
         caml_call1
          (round_down, caml_call2(Base_Import[95], numerator, denominator)),
       lower = caml_call2(Base_Import[89], denominator, k),
       _ag_ = caml_call2(Base_Import[91], k, 1.),
       higher = caml_call2(Base_Import[89], denominator, _ag_),
       diff_right = caml_call2(Base_Import[93], higher, numerator),
       diff_left = caml_call2(Base_Import[93], numerator, lower),
       k$0 = iround_nearest_exn(k),
       k$1 =
         caml_call2(Base_Import[107][1], diff_right, diff_left)
          ? caml_call2(Base_Import[90], k$0, 1)
          : caml_call2
             (Base_Import[107][5], diff_right, diff_left)
            ? k$0
            : 0
              === caml_call2(Base_Import[121], k$0, 2)
              ? k$0
              : caml_call2(Base_Import[90], k$0, 1),
       d = caml_call2(Base_Import[121], k$1, 10),
       i = caml_call2(Base_Import[94], k$1, 10);
      if(0 <= i && 1000 > i){
       if(0 <= d && 10 > d)
        return 0 === d
                ? caml_call4(Base_Printf[2], _C_, prefix, i, mag)
                : caml_call5(Base_Printf[2], _D_, prefix, i, mag, d);
       throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
     }
     if(! caml_call2(Base_Import[107][1], t, 999.95)){
      if(caml_call2(Base_Import[107][1], t, 999950.))
       return conv(kilo, t, 100.);
      if(caml_call2(Base_Import[107][1], t, 999950000.))
       return conv(mega, t, 100000.);
      if(caml_call2(Base_Import[107][1], t, 999950000000.))
       return conv(giga, t, 100000000.);
      if(caml_call2(Base_Import[107][1], t, 999950000000000.))
       return conv(tera, t, 100000000000.);
      if(! peta) return caml_call3(Base_Printf[2], _H_, prefix, t);
      var peta$0 = peta[1];
      return caml_call2(Base_Import[107][1], t, 999950000000000000.)
              ? conv(peta$0, t, 100000000000000.)
              : caml_call3(Base_Printf[2], _G_, prefix, t);
     }
     if
      (caml_call2(Base_Import[107][2], 0., t)
       && caml_call2(Base_Import[107][1], t, 999.95)){
      var
       x = caml_call2(Base_Import[111], prefix, caml_format_float("%.1f", t));
      if(! caml_call2(Base_String[80], x, cst_0)) return x;
      var
       x$0 = caml_call1(Base_Bytes0[15], x),
       n = runtime.caml_ml_bytes_length(x$0);
      caml_bytes_set(x$0, caml_call2(Base_Import[92], n, 1), 32);
      caml_bytes_set(x$0, caml_call2(Base_Import[92], n, 2), 32);
      return caml_call1(Base_Bytes0[16], x$0);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
    }
    if(caml_call2(Base_Import[107][6], t, 0.)) return go(t);
    var _af_ = go(caml_call1(Base_Import[113], t));
    return caml_call2(Base_Import[111], cst$1, _af_);
   }
   function to_padded_compact_string(t){
    return to_padded_compact_string_custo
            (t, 0, cst_k, cst_m, cst_g, cst_t, _I_, 0);
   }
   function int_pow(x, n){
    if(0 === n) return 1.;
    var
     x$0 = [0, caml_call2(Base_Import[91], x, -0.)],
     n$0 = [0, n],
     accum = [0, 1.];
    if(n$0[1] < 0){
     x$0[1] = caml_call2(Base_Import[95], 1., x$0[1]);
     n$0[1] = caml_call1(Base_Import[112], n$0[1]);
     if(n$0[1] < 0){accum[1] = x$0[1]; caml_call1(Base_Import[128], n$0);}
    }
    for(;;){
     if(1 >= n$0[1]) return caml_call2(Base_Import[89], x$0[1], accum[1]);
     if(0 !== caml_call2(Base_Import[115], n$0[1], 1))
      accum[1] = caml_call2(Base_Import[89], x$0[1], accum[1]);
     x$0[1] = caml_call2(Base_Import[89], x$0[1], x$0[1]);
     n$0[1] = caml_call2(Base_Import[119], n$0[1], 1);
    }
   }
   function round_gen(x, how){
    if(caml_call2(Base_Import[107][4], x, 0.)) return 0.;
    if(! is_finite(x)) return x;
    if(555917426 <= how[1])
     var
      sd = how[2],
      _ab_ =
        caml_call1
         (to_int,
          caml_call1(round_up, caml_log10_float(caml_call1(abs_float, x)))),
      dd = caml_call2(Base_Import[92], sd, _ab_),
      dd$0 = dd,
      sd$0 = sd;
    else
     var
      dd$1 = how[2],
      _ae_ =
        caml_call1
         (to_int,
          caml_call1(round_up, caml_log10_float(caml_call1(abs_float, x)))),
      sd$1 = caml_call2(Base_Import[90], dd$1, _ae_),
      dd$0 = dd$1,
      sd$0 = sd$1;
    if(0 > sd$0) return 0.;
    if(17 <= sd$0) return x;
    var abs_dd = caml_call1(Base_Int[73], dd$0);
    if(22 >= abs_dd && 16 > sd$0){
     var order = int_pow(10., abs_dd);
     if(0 <= dd$0){
      var
       _ac_ =
         round_nearest_half_to_even(caml_call2(Base_Import[89], x, order));
      return caml_call2(Base_Import[95], _ac_, order);
     }
     var
      _ad_ = round_nearest_half_to_even(caml_call2(Base_Import[95], x, order));
     return caml_call2(Base_Import[89], _ad_, order);
    }
    return of_string(caml_call3(Base_Printf[2], _J_, sd$0, x));
   }
   function round_significant(x, significant_digits){
    return 0 < significant_digits
            ? round_gen(x, [0, 555917426, significant_digits])
            : caml_call3(Base_Printf[7], _K_, significant_digits, 0);
   }
   function round_decimal(x, decimal_digits){
    return round_gen(x, [0, -352548012, decimal_digits]);
   }
   function between(t, low, high){
    var _aa_ = caml_call2(Base_Import[107][2], low, t);
    return _aa_ ? caml_call2(Base_Import[107][2], t, high) : _aa_;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[107][2], min, max))
     return caml_call3(clamp_unchecked, t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
   }
   function clamp(t, min, max){
    if(caml_call2(Base_Import[107][2], min, max))
     return [0, caml_call3(clamp_unchecked, t, min, max)];
    var
     _Z_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     ___ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _Z_],
     _$_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, ___);
    return caml_call1(Base_Or_error[35], _$_);
   }
   var
    symbol$1 = Base_Import[91],
    symbol$2 = Base_Import[93],
    symbol$3 = Base_Import[89],
    symbol$4 = Base_Import[95],
    symbol$5 = Base_Import[113];
   function sign_exn(t){
    if(caml_call2(Base_Import[107][5], t, 0.)) return 2;
    if(caml_call2(Base_Import[107][1], t, 0.)) return 0;
    if(caml_call2(Base_Import[107][4], t, 0.)) return 1;
    var
     _X_ = [0, [0, cst$3, sexp_of_t$1(t)], 0],
     _Y_ = caml_call2(Base_Sexp[9], cst_Float_sign_exn_of_NAN, _X_);
    return caml_call1(Base_Error[30], _Y_);
   }
   function sign_or_nan(t){
    return caml_call2(Base_Import[107][5], t, 0.)
            ? 2
            : caml_call2
               (Base_Import[107][1], t, 0.)
              ? 0
              : caml_call2(Base_Import[107][4], t, 0.) ? 1 : 3;
   }
   function ieee_negative(t){
    var bits = caml_int64_bits_of_float(t);
    return runtime.caml_lessthan(bits, Stdlib_Int64[1]);
   }
   var
    mantissa_bits = 52,
    _M_ = Base_Int64[32],
    exponent_mask64 =
      runtime.caml_int64_sub
       (caml_call2(Base_Int64[48], Base_Int64[32], 11), _M_),
    exponent_mask = caml_call1(Base_Int64[5], exponent_mask64),
    _N_ = Base_Int63[39],
    _O_ = caml_call2(Base_Int63[72], Base_Int63[39], mantissa_bits),
    mantissa_mask = caml_call2(Base_Int63[42], _O_, _N_),
    mantissa_mask64 = caml_call1(Base_Int63[79], mantissa_mask);
   function ieee_exponent(t){
    var
     bits = caml_int64_bits_of_float(t),
     _W_ = caml_call2(Base_Int64[62], bits, mantissa_bits);
    return runtime.caml_int64_to_int32
            (caml_call2(Base_Int64[43], _W_, exponent_mask64));
   }
   function ieee_mantissa(t){
    var bits = caml_int64_bits_of_float(t);
    return caml_call1
            (Base_Int63[78], runtime.caml_int64_and(bits, mantissa_mask64));
   }
   function create_ieee_exn(negative, exponent, mantissa){
    if(caml_call2(Base_Int[43], exponent, exponent_mask) !== exponent)
     return caml_call4(Base_Printf[6], _P_, exponent, exponent_mask, 0);
    var _T_ = caml_call2(Base_Int63[67], mantissa, mantissa_mask);
    if(caml_call2(Base_Int63[17], _T_, mantissa)){
     var
      _U_ = caml_call1(Base_Int63[11], mantissa_mask),
      _V_ = caml_call1(Base_Int63[11], mantissa);
     return caml_call4(Base_Printf[6], _Q_, _V_, _U_, 0);
    }
    var
     sign_bits = negative ? Stdlib_Int64[10] : Stdlib_Int64[1],
     expt_bits =
       runtime.caml_int64_shift_left
        (runtime.caml_int64_of_int32(exponent), 52),
     mant_bits = caml_call1(Base_Int63[79], mantissa),
     bits = caml_int64_or(sign_bits, caml_int64_or(expt_bits, mant_bits));
    return runtime.caml_int64_float_of_bits(bits);
   }
   function create_ieee(negative, exponent, mantissa){
    return caml_call2
            (Base_Or_error[28],
             0,
             function(param){
              return create_ieee_exn(negative, exponent, mantissa);
             });
   }
   function to_string$1(x){return caml_call2(Base_Printf[2], _R_, x);}
   function sexp_of_t$2(x){return [0, to_string$1(x)];}
   function of_string$1(x){return of_string(x);}
   var
    include$0 =
      caml_call1(Base_Comparable[13], [0, compare$0, sexp_of_t, zero]),
    sign = include$0[5];
   function is_positive(t){return caml_call2(Base_Import[107][5], t, 0.);}
   function is_non_negative(t){return caml_call2(Base_Import[107][6], t, 0.);}
   function is_negative(t){return caml_call2(Base_Import[107][1], t, 0.);}
   function is_non_positive(t){return caml_call2(Base_Import[107][2], t, 0.);}
   var
    include$1 =
      caml_call1(Base_Pretty_printer[2], [0, module_name, to_string]),
    pp = include$1[1],
    _S_ = Base_Import[107],
    symbol$6 = _S_[3],
    symbol$7 = _S_[1],
    symbol$8 = _S_[5],
    symbol$9 = _S_[4],
    symbol$10 = _S_[2],
    symbol$11 = _S_[6];
   function of_float$0(x){return x;}
   var
    specialized_hash = Base_Import[223],
    Private =
      [0,
       box,
       clamp_unchecked,
       lower_bound_for_int,
       upper_bound_for_int,
       specialized_hash,
       one_ulp_less_than_half,
       int63_round_nearest_portable_a,
       int63_round_nearest_arch64_noa,
       iround_nearest_exn_64],
    include$2 = Base_Import[107],
    symbol$12 = include$2[1],
    symbol$13 = include$2[2],
    symbol$14 = include$2[3],
    symbol$15 = include$2[4],
    symbol$16 = include$2[5],
    symbol$17 = include$2[6],
    ascending = include$2[7],
    descending = include$2[8],
    compare$2 = include$2[9],
    equal = include$2[10];
   function min(x, y){
    if(! caml_call2(symbol$12, x, y) && ! caml_call1(is_nan, x)) return y;
    return x;
   }
   function max(x, y){
    if(! caml_call2(symbol$16, x, y) && ! caml_call1(is_nan, x)) return y;
    return x;
   }
   var
    Base_Float =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$1,
       of_string,
       symbol$17,
       symbol$13,
       symbol$15,
       symbol$16,
       symbol$12,
       symbol$14,
       equal,
       compare$2,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       invariant,
       nan,
       max_value,
       neg_infinity,
       max_value,
       neg_infinity,
       zero,
       one,
       minus_one,
       pi,
       sqrt_pi,
       sqrt_2pi,
       euler,
       epsilon_float,
       max_finite_value,
       min_positive_subnormal_value,
       min_positive_normal_value,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       of_int,
       to_int,
       of_int63,
       of_int64,
       to_int64,
       round,
       iround,
       iround_exn,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       round_nearest_half_to_even,
       iround_towards_zero,
       iround_down,
       iround_up,
       iround_nearest_64$0,
       iround_towards_zero_exn,
       iround_down_exn,
       iround_up_exn,
       iround_nearest_exn,
       int63_round_down_exn,
       int63_round_up_exn,
       int63_round_nearest_exn,
       iround_lbound,
       iround_ubound,
       int63_round_lbound,
       int63_round_ubound,
       round_significant,
       round_decimal,
       is_nan,
       is_inf,
       is_finite,
       is_integer,
       min_inan,
       max_inan,
       symbol$1,
       symbol$2,
       symbol$4,
       symbol$0,
       symbol$3,
       symbol,
       symbol$5,
       [0, fractional, integral],
       modf,
       mod_float,
       add,
       sub,
       neg,
       scale,
       abs_float,
       [0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol$0,
        symbol,
        symbol$5,
        symbol$11,
        symbol$10,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        abs_float,
        neg,
        zero,
        of_int,
        of_float$0],
       [0, symbol$1, symbol$2, symbol$3, symbol$4, symbol$0, symbol, symbol$5],
       to_string,
       to_string_hum,
       to_padded_compact_string,
       to_padded_compact_string_custo,
       int_pow,
       square,
       ldexp,
       frexp,
       [0,
        compare$1,
        all,
        t_of_sexp$0,
        sexp_of_t$0,
        t_sexp_grammar$0,
        of_string$0,
        to_string$0],
       classify,
       sign,
       sign_exn,
       sign_or_nan,
       create_ieee,
       create_ieee_exn,
       ieee_negative,
       ieee_exponent,
       ieee_mantissa,
       [0, t_of_sexp, sexp_of_t$2, t_sexp_grammar, of_string$1, to_string$1],
       Private];
   runtime.caml_register_global(191, Base_Float, "Base__Float");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Fieldslib
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Fieldslib = [0];
   runtime.caml_register_global(0, Base_Fieldslib, "Base__Fieldslib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Buffer_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Buffer_intf = [0];
   runtime.caml_register_global(0, Base_Buffer_intf, "Base__Buffer_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Buffer
//# unitInfo: Requires: Base__Blit, Base__Buffer_intf, Base__Bytes, Base__Import, Stdlib__Buffer
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Base_Bytes = global_data.Base__Bytes,
    Base_Import = global_data.Base__Import,
    Base_Blit = global_data.Base__Blit,
    create = Stdlib_Buffer[1],
    contents = Stdlib_Buffer[2],
    to_bytes = Stdlib_Buffer[3],
    nth = Stdlib_Buffer[6],
    length = Stdlib_Buffer[7],
    clear = Stdlib_Buffer[8],
    reset = Stdlib_Buffer[9],
    add_char = Stdlib_Buffer[12],
    add_string = Stdlib_Buffer[16],
    add_bytes = Stdlib_Buffer[17],
    add_buffer = Stdlib_Buffer[21],
    _a_ = Stdlib_Buffer[18],
    _b_ = Stdlib_Buffer[19];
   function add_substring(t, s, pos, len){
    return caml_call4(_a_, t, s, pos, len);
   }
   function add_subbytes(t, s, pos, len){
    return caml_call4(_b_, t, s, pos, len);
   }
   function sexp_of_t(t){
    var _c_ = caml_call1(contents, t);
    return caml_call1(Base_Import[138], _c_);
   }
   function create$0(len){return caml_call1(Base_Bytes[31], len);}
   var length$0 = runtime.caml_ml_bytes_length;
   function unsafe_blit(src, src_pos, dst, dst_pos, len){
    return caml_call5(Stdlib_Buffer[5], src, src_pos, dst, dst_pos, len);
   }
   var
    To_bytes =
      caml_call1
       (caml_call1(Base_Blit[2], [0, length]),
        [0, length$0, create$0, unsafe_blit]),
    blit = To_bytes[1],
    blito = To_bytes[2],
    unsafe_blit$0 = To_bytes[3],
    sub = To_bytes[4],
    subo = To_bytes[5],
    To_string = caml_call1(caml_call1(Base_Blit[3], [0]), To_bytes),
    Base_Buffer =
      [0,
       sexp_of_t,
       create,
       contents,
       to_bytes,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       To_string,
       nth,
       length,
       clear,
       reset,
       add_char,
       add_string,
       add_substring,
       add_bytes,
       add_subbytes,
       add_buffer];
   runtime.caml_register_global(4, Base_Buffer, "Base__Buffer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Backtrace
//# unitInfo: Requires: Base__Exn, Base__Int, Base__List, Base__String, Base__Sys0, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    elided_message = "<backtrace elided in test>",
    Base_Exn = global_data.Base__Exn,
    Base_Sys0 = global_data.Base__Sys0,
    Base_String = global_data.Base__String,
    Base_List = global_data.Base__List,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Int = global_data.Base__Int,
    elide = [0, 0];
   function get(opt, param){
    if(opt)
     var sth = opt[1], at_most_num_frames = sth;
    else
     var at_most_num_frames = Base_Int[60];
    return runtime.caml_get_current_callstack(at_most_num_frames);
   }
   function to_string(t){
    return elide[1] ? elided_message : caml_call1(Stdlib_Printexc[14], t);
   }
   function to_string_list(t){
    var _f_ = to_string(t);
    return caml_call1(Base_String[88], _f_);
   }
   function sexp_of_t(t){
    var _e_ = to_string_list(t);
    return [1, caml_call2(Base_List[76], _e_, function(x){return [0, x];})];
   }
   var
    set_recording = Stdlib_Printexc[7],
    am_recording = Stdlib_Printexc[8],
    cst_OCAMLRUNPARAM = "OCAMLRUNPARAM",
    cst_b = "b";
   function most_recent(param){return caml_call1(Stdlib_Printexc[12], 0);}
   function most_recent_for_exn(exn){
    return caml_call1(Base_Exn[18], exn) ? [0, most_recent(0)] : 0;
   }
   function with_recording(b, f){
    var saved = caml_call1(am_recording, 0);
    caml_call1(set_recording, b);
    return caml_call2
            (Base_Exn[13],
             f,
             function(param){return caml_call1(set_recording, saved);});
   }
   function initialize_module(param){
    var match = caml_call1(Base_Sys0[20], cst_OCAMLRUNPARAM);
    if(match)
     var
      x = match[1],
      _a_ = Base_String[81],
      _b_ = caml_call2(Base_String[86], x, 44),
      ocamlrunparam_mentions_backtra =
        caml_call2
         (Base_List[13],
          _b_,
          function(_d_){return caml_call2(_a_, _d_, cst_b);});
    else
     var ocamlrunparam_mentions_backtra = 0;
    var _c_ = 1 - ocamlrunparam_mentions_backtra;
    return _c_ ? caml_call1(set_recording, 1) : _c_;
   }
   var
    Base_Backtrace =
      [0,
       sexp_of_t,
       get,
       to_string,
       to_string_list,
       elide,
       [0,
        am_recording,
        set_recording,
        with_recording,
        most_recent,
        most_recent_for_exn],
       initialize_module];
   runtime.caml_register_global(9, Base_Backtrace, "Base__Backtrace");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base
//# unitInfo: Requires: Base__Array, Base__Backtrace, Base__Bool, Base__Bytes, Base__Char, Base__Container_intf, Base__Error, Base__Exn, Base__Float, Base__Import, Base__Int, Base__Int32, Base__Int64, Base__List, Base__Nativeint, Base__Option, Base__Ref, Base__Sexp_with_comparable, Base__String, Base__T, Base__Unit, Shadow_stdlib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Ref = global_data.Base__Ref,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Array = global_data.Base__Array,
    Shadow_stdlib = global_data.Shadow_stdlib,
    Base_Sexp_with_comparable = global_data.Base__Sexp_with_comparable,
    Base_Import = global_data.Base__Import,
    Base_Bool = global_data.Base__Bool,
    Base_Char = global_data.Base__Char,
    Base_Exn = global_data.Base__Exn,
    Base_Float = global_data.Base__Float,
    Base_Int = global_data.Base__Int,
    Base_Int32 = global_data.Base__Int32,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_String = global_data.Base__String,
    Base_Bytes = global_data.Base__Bytes,
    Base_Unit = global_data.Base__Unit,
    Base_Error = global_data.Base__Error,
    Base_Container_intf = global_data.Base__Container_intf,
    Base_Backtrace = global_data.Base__Backtrace,
    do_at_exit = Shadow_stdlib[91],
    unsafe_really_input = Shadow_stdlib[90],
    valid_float_lexem = Shadow_stdlib[89],
    at_exit = Shadow_stdlib[88],
    exit = Shadow_stdlib[87],
    symbol = Shadow_stdlib[86],
    string_of_format = Shadow_stdlib[85],
    set_binary_mode_in = Shadow_stdlib[84],
    close_in_noerr = Shadow_stdlib[83],
    close_in = Shadow_stdlib[82],
    in_channel_length = Shadow_stdlib[81],
    pos_in = Shadow_stdlib[80],
    seek_in = Shadow_stdlib[79],
    input_value = Shadow_stdlib[78],
    input_binary_int = Shadow_stdlib[77],
    input_byte = Shadow_stdlib[76],
    really_input_string = Shadow_stdlib[75],
    really_input = Shadow_stdlib[74],
    input = Shadow_stdlib[73],
    input_line = Shadow_stdlib[72],
    input_char = Shadow_stdlib[71],
    open_in_gen = Shadow_stdlib[70],
    open_in_bin = Shadow_stdlib[69],
    open_in = Shadow_stdlib[68],
    set_binary_mode_out = Shadow_stdlib[67],
    close_out_noerr = Shadow_stdlib[66],
    close_out = Shadow_stdlib[65],
    out_channel_length = Shadow_stdlib[64],
    pos_out = Shadow_stdlib[63],
    seek_out = Shadow_stdlib[62],
    output_value = Shadow_stdlib[61],
    output_binary_int = Shadow_stdlib[60],
    output_byte = Shadow_stdlib[59],
    output_substring = Shadow_stdlib[58],
    output = Shadow_stdlib[57],
    output_bytes = Shadow_stdlib[56],
    output_string = Shadow_stdlib[55],
    output_char = Shadow_stdlib[54],
    flush_all = Shadow_stdlib[53],
    flush = Shadow_stdlib[52],
    open_out_gen = Shadow_stdlib[51],
    open_out_bin = Shadow_stdlib[50],
    open_out = Shadow_stdlib[49],
    read_float = Shadow_stdlib[48],
    read_float_opt = Shadow_stdlib[47],
    read_int = Shadow_stdlib[46],
    read_int_opt = Shadow_stdlib[45],
    read_line = Shadow_stdlib[44],
    prerr_newline = Shadow_stdlib[43],
    prerr_endline = Shadow_stdlib[42],
    prerr_float = Shadow_stdlib[41],
    prerr_int = Shadow_stdlib[40],
    prerr_bytes = Shadow_stdlib[39],
    prerr_string = Shadow_stdlib[38],
    prerr_char = Shadow_stdlib[37],
    print_newline = Shadow_stdlib[36],
    print_endline = Shadow_stdlib[35],
    print_float = Shadow_stdlib[34],
    print_int = Shadow_stdlib[33],
    print_bytes = Shadow_stdlib[32],
    print_string = Shadow_stdlib[31],
    print_char = Shadow_stdlib[30],
    stderr = Shadow_stdlib[29],
    stdout = Shadow_stdlib[28],
    stdin = Shadow_stdlib[27],
    float_of_string_opt = Shadow_stdlib[25],
    string_of_float = Shadow_stdlib[24],
    int_of_string_opt = Shadow_stdlib[23],
    string_of_int = Shadow_stdlib[22],
    bool_of_string = Shadow_stdlib[21],
    bool_of_string_opt = Shadow_stdlib[20],
    string_of_bool = Shadow_stdlib[19],
    char_of_int = Shadow_stdlib[18],
    epsilon_float = Shadow_stdlib[16],
    min_float = Shadow_stdlib[15],
    max_float = Shadow_stdlib[14],
    nan = Shadow_stdlib[13],
    neg_infinity = Shadow_stdlib[12],
    infinity = Shadow_stdlib[11],
    min_int = Shadow_stdlib[9],
    max_int = Shadow_stdlib[8],
    Not_found = Shadow_stdlib[4],
    Exit = Shadow_stdlib[3],
    hash_fold_t = Base_Sexp_with_comparable[1],
    hash = Base_Sexp_with_comparable[2],
    t_of_sexp = Base_Sexp_with_comparable[3],
    sexp_of_t = Base_Sexp_with_comparable[4],
    Not_found_s = Base_Sexp_with_comparable[5],
    Of_sexp_error = Base_Sexp_with_comparable[6],
    message = Base_Sexp_with_comparable[7],
    default_indent = Base_Sexp_with_comparable[8],
    pp_hum = Base_Sexp_with_comparable[9],
    pp_hum_indent = Base_Sexp_with_comparable[10],
    pp_mach = Base_Sexp_with_comparable[11],
    pp = Base_Sexp_with_comparable[12],
    to_string_hum = Base_Sexp_with_comparable[13],
    to_string_mach = Base_Sexp_with_comparable[14],
    to_string = Base_Sexp_with_comparable[15],
    of_float_style = Base_Sexp_with_comparable[16],
    of_int_style = Base_Sexp_with_comparable[17],
    t_sexp_grammar = Base_Sexp_with_comparable[18],
    invariant = Base_Sexp_with_comparable[19],
    of_string = Base_Sexp_with_comparable[20],
    symbol$0 = Base_Sexp_with_comparable[21],
    symbol$1 = Base_Sexp_with_comparable[22],
    symbol$2 = Base_Sexp_with_comparable[23],
    symbol$3 = Base_Sexp_with_comparable[24],
    symbol$4 = Base_Sexp_with_comparable[25],
    symbol$5 = Base_Sexp_with_comparable[26],
    equal = Base_Sexp_with_comparable[27],
    compare = Base_Sexp_with_comparable[28],
    min = Base_Sexp_with_comparable[29],
    max = Base_Sexp_with_comparable[30],
    ascending = Base_Sexp_with_comparable[31],
    descending = Base_Sexp_with_comparable[32],
    between = Base_Sexp_with_comparable[33],
    clamp_exn = Base_Sexp_with_comparable[34],
    clamp = Base_Sexp_with_comparable[35],
    comparator = Base_Sexp_with_comparable[36],
    Sexp =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator],
    am_testing = Base_Import[131],
    Exported_for_specific_uses = [0, am_testing],
    compare_array = Base_Array[1],
    equal_array = Base_Array[100],
    array_of_sexp = Base_Array[2],
    sexp_of_array = Base_Array[3];
   function array_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Array[4], a_sexp_grammar);
   }
   var
    compare_bool = Base_Bool[16],
    equal_bool = Base_Bool[15],
    hash_fold_bool = Base_Bool[3],
    func = Base_Bool[4];
   function hash_bool(x){return caml_call1(func, x);}
   var
    bool_of_sexp = Base_Bool[5],
    sexp_of_bool = Base_Bool[6],
    bool_sexp_grammar = Base_Bool[2],
    compare_char = Base_Char[16],
    equal_char = Base_Char[15],
    hash_fold_char = Base_Char[3],
    func$0 = Base_Char[4];
   function hash_char(x){return caml_call1(func$0, x);}
   var
    char_of_sexp = Base_Char[5],
    sexp_of_char = Base_Char[6],
    char_sexp_grammar = Base_Char[2],
    sexp_of_exn = Base_Exn[1],
    compare_float = Base_Float[16],
    equal_float = Base_Float[15],
    hash_fold_float = Base_Float[4],
    func$1 = Base_Float[5];
   function hash_float(x){return caml_call1(func$1, x);}
   var
    float_of_sexp = Base_Float[6],
    sexp_of_float = Base_Float[7],
    float_sexp_grammar = Base_Float[1],
    compare_int = Base_Int[13],
    equal_int = Base_Int[12],
    hash_fold_int = Base_Int[6],
    func$2 = Base_Int[7];
   function hash_int(x){return caml_call1(func$2, x);}
   var
    int_of_sexp = Base_Int[8],
    sexp_of_int = Base_Int[9],
    int_sexp_grammar = Base_Int[1],
    compare_int32 = Base_Int32[19],
    equal_int32 = Base_Int32[18],
    hash_fold_int32 = Base_Int32[6],
    func$3 = Base_Int32[7];
   function hash_int32(x){return caml_call1(func$3, x);}
   var
    int32_of_sexp = Base_Int32[8],
    sexp_of_int32 = Base_Int32[9],
    int32_sexp_grammar = Base_Int32[1],
    compare_int64 = Base_Int64[13],
    equal_int64 = Base_Int64[12],
    hash_fold_int64 = Base_Int64[6],
    func$4 = Base_Int64[7];
   function hash_int64(x){return caml_call1(func$4, x);}
   var
    int64_of_sexp = Base_Int64[8],
    sexp_of_int64 = Base_Int64[9],
    int64_sexp_grammar = Base_Int64[1],
    compare_list = Base_List[1],
    equal_list = Base_List[147],
    hash_fold_list = Base_List[2],
    list_of_sexp = Base_List[3],
    sexp_of_list = Base_List[4];
   function list_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_List[5], a_sexp_grammar);
   }
   var
    compare_nativeint = Base_Nativeint[19],
    equal_nativeint = Base_Nativeint[18],
    hash_fold_nativeint = Base_Nativeint[6],
    func$5 = Base_Nativeint[7];
   function hash_nativeint(x){return caml_call1(func$5, x);}
   var
    nativeint_of_sexp = Base_Nativeint[8],
    sexp_of_nativeint = Base_Nativeint[9],
    nativeint_sexp_grammar = Base_Nativeint[1],
    compare_option = Base_Option[1],
    equal_option = Base_Option[4],
    hash_fold_option = Base_Option[2],
    option_of_sexp = Base_Option[6],
    sexp_of_option = Base_Option[7];
   function option_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Option[3], a_sexp_grammar);
   }
   var
    compare_ref = Base_Ref[1],
    equal_ref = Base_Ref[2],
    ref_of_sexp = Base_Ref[3],
    sexp_of_ref = Base_Ref[4];
   function ref_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Ref[5], a_sexp_grammar);
   }
   var
    compare_string = Base_String[37],
    equal_string = Base_String[121],
    hash_fold_string = Base_String[26];
   function hash_string(x){return runtime.Base_hash_string(x);}
   var
    string_of_sexp = Base_String[27],
    sexp_of_string = Base_String[28],
    string_sexp_grammar = Base_String[1],
    compare_bytes = Base_Bytes[16],
    equal_bytes = Base_Bytes[15],
    bytes_of_sexp = Base_Bytes[1],
    sexp_of_bytes = Base_Bytes[2],
    bytes_sexp_grammar = Base_Bytes[3],
    compare_unit = Base_Unit[16],
    equal_unit = Base_Unit[15],
    hash_fold_unit = Base_Unit[3],
    func$6 = Base_Unit[4];
   function hash_unit(x){return caml_call1(func$6, x);}
   var
    unit_of_sexp = Base_Unit[5],
    sexp_of_unit = Base_Unit[6],
    unit_sexp_grammar = Base_Unit[2],
    symbol$6 = Base_List[148][1],
    _a_ = Base_Int[70],
    symbol$7 = _a_[1],
    lnot = _a_[2],
    abs = _a_[3],
    zero = _a_[4],
    symbol$8 = _a_[5],
    symbol$9 = _a_[6],
    symbol$10 = _a_[7],
    _b_ = Base_Import[96],
    ascending$0 = _b_[1],
    descending$0 = _b_[2],
    max$0 = _b_[3],
    min$0 = _b_[4],
    include = Base_Float[104],
    symbol$11 = include[1],
    symbol$12 = include[2],
    symbol$13 = include[3],
    symbol$14 = include[4],
    symbol$15 = include[5],
    symbol$16 = include[6],
    symbol$17 = include[7],
    symbol_concat = Base_String[53],
    fst = Base_Import[124],
    snd = Base_Import[126],
    failwith = Base_Import[123],
    invalid_arg = Base_Import[125],
    raise_s = Base_Error[30],
    phys_equal = Base_Import[127],
    Export =
      [0,
       compare_array,
       equal_array,
       array_of_sexp,
       sexp_of_array,
       array_sexp_grammar,
       compare_bool,
       equal_bool,
       hash_fold_bool,
       hash_bool,
       bool_of_sexp,
       sexp_of_bool,
       bool_sexp_grammar,
       compare_char,
       equal_char,
       hash_fold_char,
       hash_char,
       char_of_sexp,
       sexp_of_char,
       char_sexp_grammar,
       sexp_of_exn,
       compare_float,
       equal_float,
       hash_fold_float,
       hash_float,
       float_of_sexp,
       sexp_of_float,
       float_sexp_grammar,
       compare_int,
       equal_int,
       hash_fold_int,
       hash_int,
       int_of_sexp,
       sexp_of_int,
       int_sexp_grammar,
       compare_int32,
       equal_int32,
       hash_fold_int32,
       hash_int32,
       int32_of_sexp,
       sexp_of_int32,
       int32_sexp_grammar,
       compare_int64,
       equal_int64,
       hash_fold_int64,
       hash_int64,
       int64_of_sexp,
       sexp_of_int64,
       int64_sexp_grammar,
       compare_list,
       equal_list,
       hash_fold_list,
       list_of_sexp,
       sexp_of_list,
       list_sexp_grammar,
       compare_nativeint,
       equal_nativeint,
       hash_fold_nativeint,
       hash_nativeint,
       nativeint_of_sexp,
       sexp_of_nativeint,
       nativeint_sexp_grammar,
       compare_option,
       equal_option,
       hash_fold_option,
       option_of_sexp,
       sexp_of_option,
       option_sexp_grammar,
       compare_ref,
       equal_ref,
       ref_of_sexp,
       sexp_of_ref,
       ref_sexp_grammar,
       compare_string,
       equal_string,
       hash_fold_string,
       hash_string,
       string_of_sexp,
       sexp_of_string,
       string_sexp_grammar,
       compare_bytes,
       equal_bytes,
       bytes_of_sexp,
       sexp_of_bytes,
       bytes_sexp_grammar,
       compare_unit,
       equal_unit,
       hash_fold_unit,
       hash_unit,
       unit_of_sexp,
       sexp_of_unit,
       unit_sexp_grammar,
       symbol$6,
       symbol$7,
       lnot,
       abs,
       zero,
       symbol$8,
       symbol$9,
       symbol$10,
       ascending$0,
       descending$0,
       max$0,
       min$0,
       symbol$11,
       symbol$12,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol_concat,
       fst,
       snd,
       failwith,
       invalid_arg,
       raise_s,
       phys_equal],
    compare_array$0 = Export[1],
    equal_array$0 = Export[2],
    array_of_sexp$0 = Export[3],
    sexp_of_array$0 = Export[4],
    array_sexp_grammar$0 = Export[5],
    compare_bool$0 = Export[6],
    equal_bool$0 = Export[7],
    hash_fold_bool$0 = Export[8],
    hash_bool$0 = Export[9],
    bool_of_sexp$0 = Export[10],
    sexp_of_bool$0 = Export[11],
    bool_sexp_grammar$0 = Export[12],
    compare_char$0 = Export[13],
    equal_char$0 = Export[14],
    hash_fold_char$0 = Export[15],
    hash_char$0 = Export[16],
    char_of_sexp$0 = Export[17],
    sexp_of_char$0 = Export[18],
    char_sexp_grammar$0 = Export[19],
    sexp_of_exn$0 = Export[20],
    compare_float$0 = Export[21],
    equal_float$0 = Export[22],
    hash_fold_float$0 = Export[23],
    hash_float$0 = Export[24],
    float_of_sexp$0 = Export[25],
    sexp_of_float$0 = Export[26],
    float_sexp_grammar$0 = Export[27],
    compare_int$0 = Export[28],
    equal_int$0 = Export[29],
    hash_fold_int$0 = Export[30],
    hash_int$0 = Export[31],
    int_of_sexp$0 = Export[32],
    sexp_of_int$0 = Export[33],
    int_sexp_grammar$0 = Export[34],
    compare_int32$0 = Export[35],
    equal_int32$0 = Export[36],
    hash_fold_int32$0 = Export[37],
    hash_int32$0 = Export[38],
    int32_of_sexp$0 = Export[39],
    sexp_of_int32$0 = Export[40],
    int32_sexp_grammar$0 = Export[41],
    compare_int64$0 = Export[42],
    equal_int64$0 = Export[43],
    hash_fold_int64$0 = Export[44],
    hash_int64$0 = Export[45],
    int64_of_sexp$0 = Export[46],
    sexp_of_int64$0 = Export[47],
    int64_sexp_grammar$0 = Export[48],
    compare_list$0 = Export[49],
    equal_list$0 = Export[50],
    hash_fold_list$0 = Export[51],
    list_of_sexp$0 = Export[52],
    sexp_of_list$0 = Export[53],
    list_sexp_grammar$0 = Export[54],
    compare_nativeint$0 = Export[55],
    equal_nativeint$0 = Export[56],
    hash_fold_nativeint$0 = Export[57],
    hash_nativeint$0 = Export[58],
    nativeint_of_sexp$0 = Export[59],
    sexp_of_nativeint$0 = Export[60],
    nativeint_sexp_grammar$0 = Export[61],
    compare_option$0 = Export[62],
    equal_option$0 = Export[63],
    hash_fold_option$0 = Export[64],
    option_of_sexp$0 = Export[65],
    sexp_of_option$0 = Export[66],
    option_sexp_grammar$0 = Export[67],
    compare_ref$0 = Export[68],
    equal_ref$0 = Export[69],
    ref_of_sexp$0 = Export[70],
    sexp_of_ref$0 = Export[71],
    ref_sexp_grammar$0 = Export[72],
    compare_string$0 = Export[73],
    equal_string$0 = Export[74],
    hash_fold_string$0 = Export[75],
    hash_string$0 = Export[76],
    string_of_sexp$0 = Export[77],
    sexp_of_string$0 = Export[78],
    string_sexp_grammar$0 = Export[79],
    compare_bytes$0 = Export[80],
    equal_bytes$0 = Export[81],
    bytes_of_sexp$0 = Export[82],
    sexp_of_bytes$0 = Export[83],
    bytes_sexp_grammar$0 = Export[84],
    compare_unit$0 = Export[85],
    equal_unit$0 = Export[86],
    hash_fold_unit$0 = Export[87],
    hash_unit$0 = Export[88],
    unit_of_sexp$0 = Export[89],
    sexp_of_unit$0 = Export[90],
    unit_sexp_grammar$0 = Export[91],
    symbol$18 = Export[92],
    symbol$19 = Export[93],
    lnot$0 = Export[94],
    abs$0 = Export[95],
    zero$0 = Export[96],
    symbol$20 = Export[97],
    symbol$21 = Export[98],
    symbol$22 = Export[99],
    ascending$1 = Export[100],
    descending$1 = Export[101],
    max$1 = Export[102],
    min$1 = Export[103],
    symbol$23 = Export[104],
    symbol$24 = Export[105],
    symbol$25 = Export[106],
    symbol$26 = Export[107],
    symbol$27 = Export[108],
    symbol$28 = Export[109],
    symbol$29 = Export[110],
    symbol_concat$0 = Export[111],
    fst$0 = Export[112],
    snd$0 = Export[113],
    failwith$0 = Export[114],
    invalid_arg$0 = Export[115],
    raise_s$0 = Export[116],
    phys_equal$0 = Export[117],
    include$0 = Base_Container_intf[1],
    Continue_or_stop = include$0[1],
    Not_found_s$0 = Base_Import[251];
   caml_call1(Base_Backtrace[7], 0);
   var
    Base =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       Sexp,
       Exported_for_specific_uses,
       Export,
       compare_array$0,
       equal_array$0,
       array_of_sexp$0,
       sexp_of_array$0,
       array_sexp_grammar$0,
       compare_bool$0,
       equal_bool$0,
       hash_fold_bool$0,
       hash_bool$0,
       bool_of_sexp$0,
       sexp_of_bool$0,
       bool_sexp_grammar$0,
       compare_char$0,
       equal_char$0,
       hash_fold_char$0,
       hash_char$0,
       char_of_sexp$0,
       sexp_of_char$0,
       char_sexp_grammar$0,
       sexp_of_exn$0,
       compare_float$0,
       equal_float$0,
       hash_fold_float$0,
       hash_float$0,
       float_of_sexp$0,
       sexp_of_float$0,
       float_sexp_grammar$0,
       compare_int$0,
       equal_int$0,
       hash_fold_int$0,
       hash_int$0,
       int_of_sexp$0,
       sexp_of_int$0,
       int_sexp_grammar$0,
       compare_int32$0,
       equal_int32$0,
       hash_fold_int32$0,
       hash_int32$0,
       int32_of_sexp$0,
       sexp_of_int32$0,
       int32_sexp_grammar$0,
       compare_int64$0,
       equal_int64$0,
       hash_fold_int64$0,
       hash_int64$0,
       int64_of_sexp$0,
       sexp_of_int64$0,
       int64_sexp_grammar$0,
       compare_list$0,
       equal_list$0,
       hash_fold_list$0,
       list_of_sexp$0,
       sexp_of_list$0,
       list_sexp_grammar$0,
       compare_nativeint$0,
       equal_nativeint$0,
       hash_fold_nativeint$0,
       hash_nativeint$0,
       nativeint_of_sexp$0,
       sexp_of_nativeint$0,
       nativeint_sexp_grammar$0,
       compare_option$0,
       equal_option$0,
       hash_fold_option$0,
       option_of_sexp$0,
       sexp_of_option$0,
       option_sexp_grammar$0,
       compare_ref$0,
       equal_ref$0,
       ref_of_sexp$0,
       sexp_of_ref$0,
       ref_sexp_grammar$0,
       compare_string$0,
       equal_string$0,
       hash_fold_string$0,
       hash_string$0,
       string_of_sexp$0,
       sexp_of_string$0,
       string_sexp_grammar$0,
       compare_bytes$0,
       equal_bytes$0,
       bytes_of_sexp$0,
       sexp_of_bytes$0,
       bytes_sexp_grammar$0,
       compare_unit$0,
       equal_unit$0,
       hash_fold_unit$0,
       hash_unit$0,
       unit_of_sexp$0,
       sexp_of_unit$0,
       unit_sexp_grammar$0,
       symbol$18,
       symbol$19,
       lnot$0,
       abs$0,
       zero$0,
       symbol$20,
       symbol$21,
       symbol$22,
       ascending$1,
       descending$1,
       max$1,
       min$1,
       symbol$23,
       symbol$24,
       symbol$25,
       symbol$26,
       symbol$27,
       symbol$28,
       symbol$29,
       symbol_concat$0,
       fst$0,
       snd$0,
       failwith$0,
       invalid_arg$0,
       raise_s$0,
       phys_equal$0,
       Continue_or_stop,
       Not_found_s$0];
   runtime.caml_register_global(21, Base, "Base");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJkZXNjZW5kaW5nIiwieCIsInkiLCJtYXgiLCJtaW4iLCJkb19hdF9leGl0IiwidW5zYWZlX3JlYWxseV9pbnB1dCIsInZhbGlkX2Zsb2F0X2xleGVtIiwiYXRfZXhpdCIsImV4aXQiLCJzeW1ib2wiLCJzdHJpbmdfb2ZfZm9ybWF0Iiwic2V0X2JpbmFyeV9tb2RlX2luIiwiY2xvc2VfaW5fbm9lcnIiLCJjbG9zZV9pbiIsImluX2NoYW5uZWxfbGVuZ3RoIiwicG9zX2luIiwic2Vla19pbiIsImlucHV0X3ZhbHVlIiwiaW5wdXRfYmluYXJ5X2ludCIsImlucHV0X2J5dGUiLCJyZWFsbHlfaW5wdXRfc3RyaW5nIiwicmVhbGx5X2lucHV0IiwiaW5wdXQiLCJpbnB1dF9saW5lIiwiaW5wdXRfY2hhciIsIm9wZW5faW5fZ2VuIiwib3Blbl9pbl9iaW4iLCJvcGVuX2luIiwic2V0X2JpbmFyeV9tb2RlX291dCIsImNsb3NlX291dF9ub2VyciIsImNsb3NlX291dCIsIm91dF9jaGFubmVsX2xlbmd0aCIsInBvc19vdXQiLCJzZWVrX291dCIsIm91dHB1dF92YWx1ZSIsIm91dHB1dF9iaW5hcnlfaW50Iiwib3V0cHV0X2J5dGUiLCJvdXRwdXRfc3Vic3RyaW5nIiwib3V0cHV0Iiwib3V0cHV0X2J5dGVzIiwib3V0cHV0X3N0cmluZyIsIm91dHB1dF9jaGFyIiwiZmx1c2hfYWxsIiwiZmx1c2giLCJvcGVuX291dF9nZW4iLCJvcGVuX291dF9iaW4iLCJvcGVuX291dCIsInJlYWRfZmxvYXQiLCJyZWFkX2Zsb2F0X29wdCIsInJlYWRfaW50IiwicmVhZF9pbnRfb3B0IiwicmVhZF9saW5lIiwicHJlcnJfbmV3bGluZSIsInByZXJyX2VuZGxpbmUiLCJwcmVycl9mbG9hdCIsInByZXJyX2ludCIsInByZXJyX2J5dGVzIiwicHJlcnJfc3RyaW5nIiwicHJlcnJfY2hhciIsInByaW50X25ld2xpbmUiLCJwcmludF9lbmRsaW5lIiwicHJpbnRfZmxvYXQiLCJwcmludF9pbnQiLCJwcmludF9ieXRlcyIsInByaW50X3N0cmluZyIsInByaW50X2NoYXIiLCJzdGRlcnIiLCJzdGRvdXQiLCJzdGRpbiIsImZsb2F0X29mX3N0cmluZ19vcHQiLCJzdHJpbmdfb2ZfZmxvYXQiLCJpbnRfb2Zfc3RyaW5nX29wdCIsInN0cmluZ19vZl9pbnQiLCJib29sX29mX3N0cmluZyIsImJvb2xfb2Zfc3RyaW5nX29wdCIsInN0cmluZ19vZl9ib29sIiwiY2hhcl9vZl9pbnQiLCJlcHNpbG9uX2Zsb2F0IiwibWluX2Zsb2F0IiwibWF4X2Zsb2F0IiwibmFuIiwibmVnX2luZmluaXR5IiwiaW5maW5pdHkiLCJtaW5faW50IiwibWF4X2ludCIsImJvb2xfdG9faW50Iiwic3ltYm9sJDIiLCJzeW1ib2wkMyIsInN5bWJvbCQ0Iiwic3ltYm9sJDUiLCJzeW1ib2wkNiIsInN5bWJvbCQ3Iiwic3ltYm9sJDgiLCJzeW1ib2wkOSIsInN5bWJvbCQxMCIsInN5bWJvbCQxMSIsImFzY2VuZGluZyIsIm1heCQwIiwibWluJDAiLCJhc2NlbmRpbmckMCIsImRlc2NlbmRpbmckMCIsIm1heCQxIiwibWluJDEiLCJzeW1ib2wkMTIiLCJzeW1ib2wkMTMiLCJzeW1ib2wkMTQiLCJzeW1ib2wkMTUiLCJzeW1ib2wkMTYiLCJzeW1ib2wkMTciLCJhc2NlbmRpbmckMSIsImRlc2NlbmRpbmckMSIsImNvbXBhcmUiLCJlcXVhbCIsIm1heCQyIiwibWluJDIiLCJhc2NlbmRpbmckMiIsImRlc2NlbmRpbmckMiIsIm1heCQzIiwibWluJDMiLCJzeW1ib2wkMTgiLCJzeW1ib2wkMTkiLCJzeW1ib2wkMjAiLCJzeW1ib2wkMjEiLCJzeW1ib2wkMjIiLCJzeW1ib2wkMjMiLCJhc2NlbmRpbmckMyIsImRlc2NlbmRpbmckMyIsImNvbXBhcmUkMCIsImVxdWFsJDAiLCJtYXgkNCIsIm1pbiQ0Iiwic3ltYm9sJDI0Iiwic3ltYm9sJDI1Iiwic3ltYm9sJDI2Iiwic3ltYm9sJDI3Iiwic3ltYm9sJDI4Iiwic3ltYm9sJDI5IiwiYXNjZW5kaW5nJDQiLCJkZXNjZW5kaW5nJDQiLCJjb21wYXJlJDEiLCJlcXVhbCQxIiwibWF4JDUiLCJtaW4kNSIsInN5bWJvbCQzMCIsInN5bWJvbCQzMSIsInN5bWJvbCQzMiIsInN5bWJvbCQzMyIsInN5bWJvbCQzNCIsInN5bWJvbCQzNSIsImFzY2VuZGluZyQ1IiwiZGVzY2VuZGluZyQ1IiwiY29tcGFyZSQyIiwiZXF1YWwkMiIsIm1heCQ2IiwibWluJDYiLCJpIiwic3ltYm9sJDM2Iiwic3ltYm9sJDM3Iiwic3ltYm9sJDM4Iiwic3ltYm9sJDM5Iiwic3ltYm9sJDQwIiwic3ltYm9sJDQxIiwiYXNjZW5kaW5nJDYiLCJkZXNjZW5kaW5nJDYiLCJjb21wYXJlJDMiLCJlcXVhbCQzIiwibWF4JDciLCJtaW4kNyIsInN5bWJvbCQ0MiIsInN5bWJvbCQ0MyIsInN5bWJvbCQ0NCIsInN5bWJvbCQ0NSIsInN5bWJvbCQ0NiIsInN5bWJvbCQ0NyIsImFzY2VuZGluZyQ3IiwiZGVzY2VuZGluZyQ3IiwiY29tcGFyZSQ0IiwiZXF1YWwkNCIsIm1heCQ4IiwibWluJDgiLCJzeW1ib2wkNDgiLCJzeW1ib2wkNDkiLCJzeW1ib2wkNTAiLCJzeW1ib2wkNTEiLCJzeW1ib2wkNTIiLCJzeW1ib2wkNTMiLCJhc2NlbmRpbmckOCIsImRlc2NlbmRpbmckOCIsImNvbXBhcmUkNSIsImVxdWFsJDUiLCJtYXgkOSIsIm1pbiQ5Iiwic3ltYm9sJDU0Iiwic3ltYm9sJDU1Iiwic3ltYm9sJDU2Iiwic3ltYm9sJDU3Iiwic3ltYm9sJDU4Iiwic3ltYm9sJDU5IiwiYXNjZW5kaW5nJDkiLCJkZXNjZW5kaW5nJDkiLCJjb21wYXJlJDYiLCJlcXVhbCQ2IiwibWF4JDEwIiwibWluJDEwIiwic3ltYm9sJDYwIiwic3ltYm9sX2NvbmNhdCQwIiwic3ltYm9sJDYxIiwic3ltYm9sJDYyIiwiYXNyIiwibGFuZCIsImxub3QkMCIsImxvciIsImxzbCIsImxzciIsImx4b3IiLCJtb2QiLCJhYnMkMCIsImZhaWx3aXRoJDAiLCJmc3QiLCJpbnZhbGlkX2FyZyQwIiwic25kIiwicGh5c19lcXVhbCIsImRlY3IiLCJpbmNyIiwiZmxvYXRfb2Zfc3RyaW5nIiwiYW1fdGVzdGluZyIsImZhaWx3aXRoZiIsImZtdCIsInMiLCJpbnZhbGlkX2FyZ2YiLCJiYWNrZW5kX3R5cGUiLCJpbnRlcmFjdGl2ZSIsIm9zX3R5cGUiLCJ1bml4Iiwid2luMzIiLCJjeWd3aW4iLCJ3b3JkX3NpemVfaW5fYml0cyIsImludF9zaXplX2luX2JpdHMiLCJiaWdfZW5kaWFuIiwibWF4X3N0cmluZ19sZW5ndGgiLCJtYXhfYXJyYXlfbGVuZ3RoIiwicnVudGltZV92YXJpYW50IiwicnVudGltZV9wYXJhbWV0ZXJzIiwiYXJndiIsImdldF9hcmd2Iiwib2NhbWxfdmVyc2lvbiIsImVuYWJsZV9ydW50aW1lX3dhcm5pbmdzIiwicnVudGltZV93YXJuaW5nc19lbmFibGVkIiwiZ2V0ZW52X2V4biIsInZhciQwIiwiZ2V0ZW52IiwibWF4X2xlbmd0aCIsImNyZWF0ZSIsImxlbiIsImNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIiwiYXBwZW5kIiwiYmxpdCIsImNvbmNhdCIsImNvcHkiLCJmaWxsIiwiaW5pdCIsIm1ha2VfbWF0cml4Iiwib2ZfbGlzdCIsInN1YiIsInRvX2xpc3QiLCJmb2xkIiwidCIsImYiLCJmb2xkX3JpZ2h0IiwiaXRlciIsIml0ZXJpIiwibWFwIiwibWFwaSIsInN0YWJsZV9zb3J0Iiwic3dhcCIsImoiLCJlbHRfaSIsImVsdF9qIiwiZXNjYXBlZCIsImxvd2VyY2FzZSIsInRvX2ludCIsInVuc2FmZV9vZl9pbnQiLCJ1cHBlcmNhc2UiLCJpbnRfaXNfb2siLCJvZl9pbnQiLCJvZl9pbnRfZXhuIiwidDEiLCJ0MiIsInRvX3N0cmluZyIsIm9mX3N0cmluZyIsInRvX2Zsb2F0Iiwib2ZfZmxvYXQiLCJtYXhfdmFsdWUiLCJtaW5fdmFsdWUiLCJzdWNjIiwiaGRfZXhuIiwibGVuZ3RoIiwicmV2X2FwcGVuZCIsInRsX2V4biIsInVuemlwIiwiZXhpc3RzIiwiZXhpc3RzMl9vayIsImwxIiwibDIiLCJmb2xkMl9vayIsImZvcl9hbGwiLCJmb3JfYWxsMl9vayIsIml0ZXIyX29rIiwibm9udGFpbF9tYXAiLCJub250YWlsX21hcGkiLCJwYXJ0aXRpb24iLCJyZXZfbWFwIiwicmV2X21hcDJfb2siLCJzb3J0IiwibCIsInJldiIsInJlcyIsInJlc3QiLCJhIiwiYiIsImhhc2hfZm9sZF91bml0IiwiaGFzaF9mb2xkX2ludCIsImhhc2hfZm9sZF9pbnQ2NCIsImhhc2hfZm9sZF9mbG9hdCIsImhhc2hfZm9sZF9zdHJpbmciLCJhc19pbnQiLCJoYXNoX2ZvbGRfaW50MzIiLCJoYXNoX2ZvbGRfY2hhciIsImhhc2hfZm9sZF9ib29sIiwiaGFzaF9mb2xkX25hdGl2ZWludCIsImhhc2hfZm9sZF9vcHRpb24iLCJoYXNoX2ZvbGRfZWxlbSIsImhhc2hfZm9sZF9saXN0IiwicyQxIiwibGlzdCQxIiwicyQyIiwibGlzdCIsImxpc3QkMCIsInMkMCIsImhhc2hfZm9sZF9sYXp5X3QiLCJoYXNoX2ZvbGRfcmVmX2Zyb3plbiIsImhhc2hfZm9sZF9hcnJheV9mcm96ZW4iLCJhcnJheSIsImUiLCJpJDAiLCJoYXNoX25hdGl2ZWludCIsImhhc2hfaW50NjQiLCJoYXNoX2ludDMyIiwiaGFzaF9jaGFyIiwiaGFzaF9pbnQiLCJoYXNoX2Jvb2wiLCJoYXNoX3N0cmluZyIsImhhc2hfZmxvYXQiLCJoYXNoX3VuaXQiLCJzZWVkIiwib2ZfZm9sZCIsImhhc2hfZm9sZF90IiwicnVuIiwiZm9sZGVyIiwib3B0Iiwic3RoIiwiY29tcGFyZV9zdGF0ZSIsInN0YXRlX3RvX3N0cmluZyIsInN0YXRlIiwidCQwIiwidCQxIiwidCQyIiwidCQzIiwidCQ0IiwidCQ1IiwiY29tcGFyZV9hYnN0cmFjdCIsInR5cGVfbmFtZSIsImVxdWFsX2Fic3RyYWN0IiwiY29tcGFyZV9ib29sIiwiY29tcGFyZV9jaGFyIiwiY29tcGFyZV9mbG9hdCIsImNvbXBhcmVfaW50IiwiY29tcGFyZV9pbnQzMiIsImNvbXBhcmVfaW50NjQiLCJjb21wYXJlX25hdGl2ZWludCIsImNvbXBhcmVfc3RyaW5nIiwiY29tcGFyZV91bml0IiwiY29tcGFyZV9hcnJheSIsImNvbXBhcmVfZWx0IiwibGVuX2EiLCJsZW5fYiIsInJldCIsInIiLCJjb21wYXJlX2xpc3QiLCJhJDAiLCJiJDAiLCJ5cyIsInhzIiwiY29tcGFyZV9vcHRpb24iLCJjb21wYXJlX3JlZiIsImVxdWFsX2Jvb2wiLCJlcXVhbF9jaGFyIiwiZXF1YWxfaW50IiwiZXF1YWxfaW50MzIiLCJlcXVhbF9pbnQ2NCIsImVxdWFsX25hdGl2ZWludCIsImVxdWFsX3N0cmluZyIsImVxdWFsX3VuaXQiLCJlcXVhbF9mbG9hdCIsImVxdWFsX2FycmF5IiwiZXF1YWxfZWx0IiwiZXF1YWxfbGlzdCIsImVxdWFsX29wdGlvbiIsImVxdWFsX3JlZiIsImFfMDAxIiwiYl8wMDIiLCJhXzAwMyIsImJfMDA0IiwiYV8wMDUiLCJiXzAwNiIsImhhc2giLCJoc3YiLCJhcmciLCJhMCIsImhzdiQwIiwiYTAkMCIsImhzdiQxIiwidF9zZXhwX2dyYW1tYXIiLCJpbnZhcmlhbnQiLCJzZXhwX29mX3QiLCJudW1fYml0cyIsIndvcmRfc2l6ZSIsImFsbCIsInJlZ2lzdGVyIiwicCIsInBwIiwibW9kdWxlX25hbWUiLCJmb3JtYXR0ZXIiLCJhcmcxXzAwMiIsImFyZzBfMDAxIiwicmVzMF8wMDMiLCJyZXMxXzAwNCIsImFyZzFfMDA2IiwiYXJnMF8wMDUiLCJyZXMwXzAwNyIsInJlczFfMDA4IiwiY3JlYXRlX3MiLCJzZXhwIiwicmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UiLCJiYWNrdHJhY2UiLCJyZXJhaXNlIiwiZXhuIiwic3RyIiwiZXhuJDAiLCJidCIsInJlcmFpc2VmIiwiZXhjIiwiZm9ybWF0IiwidG9fc3RyaW5nX21hY2giLCJzZXhwX29mX3QkMCIsInByb3RlY3R4IiwiZmluYWxseSQwIiwiZmluYWxfZXhuJDAiLCJmaW5hbF9leG4iLCJwcm90ZWN0IiwiZG9lc19yYWlzZSIsInBwZiIsInByaW50X3dpdGhfYmFja3RyYWNlIiwicmF3X2JhY2t0cmFjZSIsImhhbmRsZV91bmNhdWdodF9hdXgiLCJleGMkMCIsImhhbmRsZV91bmNhdWdodF9hbmRfZXhpdCIsImhhbmRsZV91bmNhdWdodCIsIm11c3RfZXhpdCIsImV4aXQkMCIsInJlcmFpc2VfdW5jYXVnaHQiLCJmdW5jIiwicmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UiLCJpbml0aWFsaXplX21vZHVsZSIsImNsZWFyX2JhY2t0cmFjZSIsIndpdGhfcmV0dXJuIiwiaXNfYWxpdmUiLCJyZXR1cm4kMCIsIndpdGhfcmV0dXJuX29wdGlvbiIsInByZXBlbmQiLCJwYXJhbSIsInN5bWJvbF9iaW5kIiwic3ltYm9sX21hcCIsImJpbmQiLCJqb2luIiwiaWdub3JlX20iLCJhbGxfdW5pdCIsIm1hcF92aWFfYmluZCIsIm1hIiwic3ltYm9sX2JpbmQkMCIsInN5bWJvbF9tYXAkMCIsInN5bWJvbF9iaW5kJDEiLCJzeW1ib2xfbWFwJDEiLCJib3RoIiwibG9vcCIsInZzIiwidHMiLCJ2IiwiYmluZCQwIiwicmV0dXJuJDEiLCJtYXAkMCIsInRvX21vbmFkIiwib2ZfbW9uYWQiLCJkZXJpdmVkX21hcCIsIm1hcDIiLCJ0YSIsInRiIiwibWFwMyIsInRjIiwic3ltYm9sJDAiLCJ1Iiwic3ltYm9sJDEiLCJ0ZiIsImZhYiIsImMiLCJhcHBseSIsIm1mIiwibXgiLCJ0eCIsImN1c3RvbV9tYXAiLCJhcHBseSQwIiwiYmxpdF9zdHJpbmciLCJtYWtlIiwidW5zYWZlX2JsaXQiLCJ1bnNhZmVfdG9fc3RyaW5nIiwidW5zYWZlX29mX3N0cmluZ19wcm9taXNlX25vX211IiwiY29tcGFyYXRvciIsImVycm9yX3NvdXJjZV8wMTEiLCJjbXBfZiIsImNtcF9zIiwiaGFzaF9mb2xkX2YiLCJoYXNoX2ZvbGRfcyIsInRfb2Zfc2V4cCIsIm9mX2ZfMDA3Iiwib2Zfc18wMDgiLCJzZXhwXzAxMyIsInRhZ18wMTQiLCJzZXhwX2FyZ3NfMDIwIiwiYXJnMF8wMjEiLCJyZXMwXzAyMiIsInNleHBfYXJnc18wMTUiLCJhcmcwXzAxNiIsInJlczBfMDE3Iiwib2ZfZl8wMjUiLCJvZl9zXzAyNiIsImFyZzBfMDI3IiwicmVzMF8wMjgiLCJhcmcwXzAyOSIsInJlczBfMDMwIiwiZl9zZXhwX2dyYW1tYXIiLCJzX3NleHBfZ3JhbW1hciIsIm9wYXF1ZV9pZGVudGl0eSIsIm5hbWUiLCJnZXQiLCJmc2V0Iiwic2V0dGVyIiwidXBkYXRlciIsImZpZWxkIiwic3ltYm9sX2NvbmNhdCIsImNhcGl0YWxpemUiLCJ1bmNhcGl0YWxpemUiLCJzZXAiLCJuIiwibiQwIiwibiQxIiwiaHN2JDIiLCJwb3NfY251bV8wMTAiLCJwb3NfYm9sXzAwOCIsInBvc19sbnVtXzAwNiIsInBvc19mbmFtZV8wMDQiLCJhcmdfMDExIiwiYm5kc18wMDMiLCJhcmdfMDA5IiwiYm5kc18wMDMkMCIsImFyZ18wMDciLCJibmRzXzAwMyQxIiwiYXJnXzAwNSIsImJuZHNfMDAzJDIiLCJoYXNoX2ZvbGRfdCQwIiwiaGFzaCQwIiwibWFrZV9sb2NhdGlvbl9zdHJpbmciLCJwb3NfZm5hbWUiLCJwb3NfbG51bSIsInBvc19jbnVtIiwicG9zX2JvbCIsImlzX2VtcHR5IiwicGFydGl0aW9uX21hcCIsImZzdCQwIiwieSQwIiwic25kJDAiLCJlcnJvcl9zb3VyY2VfMDA1Iiwib2ZfYV8wMDEiLCJvZl9iXzAwMiIsInNleHBfMDA3IiwidGFnXzAwOCIsInNleHBfYXJnc18wMDkiLCJhcmcwXzAxMCIsInJlczBfMDExIiwic2V4cF9hcmdzXzAxNCIsImFyZzBfMDE1IiwicmVzMF8wMTYiLCJvZl9hXzAxOSIsIm9mX2JfMDIwIiwiYXJnMF8wMjMiLCJyZXMwXzAyNCIsImFfc2V4cF9ncmFtbWFyIiwiYl9zZXhwX2dyYW1tYXIiLCJjbXBfYSIsImNtcF9iIiwiYV8wMjciLCJiXzAyOCIsImFfMDI5IiwiYl8wMzAiLCJhXzAzMSIsImJfMDMyIiwiYV8wMzMiLCJiXzAzNCIsImFfMDM1IiwiYl8wMzYiLCJhXzAzNyIsImJfMDM4IiwiaGFzaF9mb2xkX2EiLCJoYXNoX2ZvbGRfYiIsIngkMCIsImNoZWNrX29rIiwiY2hlY2tfZXJyb3IiLCJvayIsImVycm9yIiwiZmFpbCIsImZhaWxmIiwibWFwX2Vycm9yIiwiYmluZCQxIiwibWFwJDEiLCJyZXR1cm4kMiIsImlzX29rIiwiaXNfZXJyb3IiLCJvZl9vcHRpb24iLCJpdGVyX2Vycm9yIiwidG9fZWl0aGVyIiwib2ZfZWl0aGVyIiwib2tfaWZfdHJ1ZSIsImJvb2wiLCJ0cnlfd2l0aCIsIm9rX2V4biIsIm9rX29yX2ZhaWx3aXRoIiwiY29tYmluZSIsImVyciIsIm9rMSIsIm9rMiIsImVycjEiLCJlcnIyIiwiY29tYmluZV9lcnJvcnMiLCJlcnJzIiwiY29tYmluZV9lcnJvcnNfdW5pdCIsImNvdW50Iiwic3VtIiwiTSIsImZvbGRfcmVzdWx0IiwiYWNjIiwiaXRlbSIsImZvbGRfdW50aWwiLCJmaW5pc2giLCJtaW5fZWx0IiwiZWx0IiwibWF4X2VsdCIsImZpbmRfbWFwIiwiZmluZCIsInRvX2FycmF5IiwiaXRlciQwIiwiaXRlciQxIiwibGVuZ3RoJDAiLCJsZW5ndGgkMSIsImlzX2VtcHR5JDAiLCJzdW0kMCIsIm0iLCJjb3VudCQwIiwiZXhpc3RzJDAiLCJmb3JfYWxsJDAiLCJmaW5kX21hcCQwIiwiZmluZCQwIiwidG9fbGlzdCQwIiwidG9fYXJyYXkkMCIsIm1pbl9lbHQkMCIsIm1heF9lbHQkMCIsImZvbGRfcmVzdWx0JDAiLCJmb2xkX3VudGlsJDAiLCJmb2xkJDAiLCJtZW0iLCJjb21wYXJlX2EiLCJlcXVhbF9hIiwic2V4cF9vZl9hIiwic2xvd19jaGVja19wb3NfbGVuX2V4biIsInBvcyIsInRvdGFsX2xlbmd0aCIsImNoZWNrX3Bvc19sZW5fZXhuIiwic3RvcCIsImdldF9wb3NfbGVuX2V4biIsImxlbiQwIiwib2Zfc3RhdGUiLCJhc3NpZ24iLCJ0MSQwIiwidDIkMCIsIm1ha2VfZGVmYXVsdCIsImRlZmF1bHQkMCIsImdldF9zdGF0ZSIsImZvcmJpZF9ub25kZXRlcm1pbmlzbV9pbl90ZXN0cyIsImFsbG93X2luX3Rlc3RzIiwiYml0cyIsImludCQwIiwiaW50MzIiLCJpbnQ2NCIsIm5hdGl2ZWludCIsImNoYXIkMCIsImFzY2lpIiwibWFrZV9zZWxmX2luaXQiLCJpbnRfb25fNjRiaXRzIiwiYm91bmQiLCJpbnRfb25fMzJiaXRzIiwiaW50JDEiLCJiaXRzJDAiLCJmdWxsX3JhbmdlX2ludDY0IiwiZnVsbF9yYW5nZV9pbnQzMiIsImZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0cyIsImZ1bGxfcmFuZ2VfaW50X29uXzMyYml0cyIsImZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0cyQwIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fNjRiaXRzIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fMzJiaXRzIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnQiLCJyYWlzZV9jcm9zc2VkX2JvdW5kcyIsImxvd2VyX2JvdW5kIiwidXBwZXJfYm91bmQiLCJzdHJpbmdfb2ZfYm91bmQiLCJpbnRfaW5jbCIsImxvIiwiaGkiLCJkaWZmIiwiaW50MzJfaW5jbCIsIm5hdGl2ZWludF9pbmNsIiwiaW50NjRfaW5jbCIsImZsb2F0JDAiLCJzY2FsZSIsInIxIiwicjIiLCJyZXN1bHQiLCJmbG9hdF9yYW5nZSIsImRlZmF1bHQkMSIsImJpdHMkMSIsImludCQyIiwiaW50MzIkMCIsIm5hdGl2ZWludCQwIiwiaW50NjQkMCIsImZsb2F0JDEiLCJpbnRfaW5jbCQwIiwiaW50MzJfaW5jbCQwIiwibmF0aXZlaW50X2luY2wkMCIsImludDY0X2luY2wkMCIsImZsb2F0X3JhbmdlJDAiLCJib29sJDAiLCJjaGFyJDEiLCJhc2NpaSQwIiwiZnVsbF9pbml0Iiwic2VsZl9pbml0Iiwic2V0X3N0YXRlIiwicGVybXV0ZSIsInJhbmRvbV9zdGF0ZSIsInN0aCQwIiwibnVtX3N3YXBzIiwidGhpc19pIiwicmFuZG9tX2kiLCJjb25zdCQwIiwibm9uIiwiZm9yZXZlciIsImUkMCIsImNvbXBvc2UiLCJnIiwiZmxpcCIsImFwcGx5X25fdGltZXMiLCJ4JDEiLCJzZXhwXzAwNiIsImVycm9yX3NvdXJjZV8wMjIiLCJmb2xkX2xlZnQiLCJhXzAwNiIsImJfMDA3IiwiYV8wMDgiLCJiXzAwOSIsIm9mX2FfMDEwIiwiYXJnMF8wMTEiLCJyZXMwXzAxMiIsInJhbmdlIiwic3RyaWRlIiwic3RhcnRfaSIsInN0b3BfaSIsInN0YXJ0IiwibmV4dF9pIiwib3JkZXIiLCJyYWlzZV9zdHJpZGVfY2Fubm90X3JldHVybl9zYW0iLCJpbml0aWFsX3N0cmlkZV9vcmRlciIsInN0YXJ0X2kkMCIsImFjY3VtIiwiaV90b19zdG9wX29yZGVyIiwibmV4dF9pJDAiLCJhY2N1bSQwIiwicmFuZ2UkMCIsInN0aCQxIiwiaGQiLCJ0bCIsIm50aCIsIm50aF9leG4iLCJ1bm9yZGVyZWRfYXBwZW5kIiwib2ZfbGlzdHMiLCJzaGFyZWRfbGVuZ3RoIiwic2hhcmVkX2xlbmd0aCQwIiwiY2hlY2tfbGVuZ3RoMl9leG4iLCJ0YWlsX29mX2IiLCJ0YWlsX29mX2EiLCJjaGVja19sZW5ndGgyIiwib2ZfbGlzdHMkMCIsImwzIiwiYyQwIiwiY2hlY2tfbGVuZ3RoM19leG4iLCJ0YWlsX29mX2MiLCJuMSIsIm4yIiwibjMiLCJjaGVja19sZW5ndGgzIiwiaXRlcjIiLCJpdGVyMl9leG4iLCJyZXZfbWFwMiIsInJldl9tYXAyX2V4biIsImZvbGQyIiwiZm9sZDJfZXhuIiwiZm9yX2FsbDIiLCJmb3JfYWxsMl9leG4iLCJleGlzdHMyIiwiZXhpc3RzMl9leG4iLCJicyIsInJldl9maWx0ZXIiLCJhY2N1IiwiZmlsdGVyIiwibm90X2ZvdW5kIiwiZmluZF9tYXBfZXhuIiwibm90X2ZvdW5kJDAiLCJmaW5kX2V4biIsImZpbmRpIiwibm90X2ZvdW5kJDEiLCJmaW5kaV9leG4iLCJmaW5kX21hcGkiLCJub3RfZm91bmQkMiIsImZpbmRfbWFwaV9leG4iLCJmb3JfYWxsaSIsImV4aXN0c2kiLCJtYXhfbm9uX3RhaWxjYWxsIiwiY291bnRfYXBwZW5kIiwieDEiLCJ4MiIsIngzIiwieDQiLCJ4NSIsImNvdW50X21hcCIsImN0ciIsIngxJDAiLCJmMSQzIiwieDIkMCIsImYxJDIiLCJmMiQyIiwieDMkMCIsImYxJDEiLCJmMiQxIiwiZjMkMSIsIng0JDAiLCJmMSQwIiwiZjIkMCIsImYzJDAiLCJmNCQwIiwieDUkMCIsImYxIiwiZjIiLCJmMyIsImY0IiwiZjUiLCJicyQwIiwieHMkMCIsIng4IiwieDciLCJ4NiIsIngwIiwieTAkMCIsInkxJDAiLCJ5MiQwIiwieTMkMCIsInk0JDAiLCJ5NSQwIiwieTYkMCIsInk3JDAiLCJ5OCQwIiwieTgiLCJ5NyIsInk2IiwieTUiLCJ5NCIsInkzIiwieTIiLCJ5MSIsInkwIiwiZm9sZGluZ19tYXAiLCJuZXdfYWNjIiwiZm9sZF9tYXAiLCJtYXAyX29rIiwibWFwMl9leG4iLCJyZXZfbWFwM19vayIsImwxJDAiLCJsMiQwIiwibDMkMCIsImFjIiwibDMkMSIsImwyJDEiLCJsMSQxIiwiYWMkMCIsInJldl9tYXAzIiwicmV2X21hcDNfZXhuIiwibWFwM19vayIsIm1hcDNfZXhuIiwicmV2X21hcF9hcHBlbmQiLCJoIiwibGlzdCQyIiwidW56aXAzIiwieiIsInppcF9leG4iLCJ6aXAiLCJyZXZfbWFwaSIsImZvbGRpbmdfbWFwaSIsImZvbGRfbWFwaSIsImZvbGRpIiwiZmlsdGVyaSIsInJlZHVjZSIsInJlZHVjZV9leG4iLCJyZWR1Y2VfYmFsYW5jZWQiLCJzdGVwX2FjY3VtIiwibnVtIiwibnVtJDAiLCJhY2MkMCIsImFjYyQxIiwibnVtJDEiLCJyZWR1Y2VfYmFsYW5jZWRfZXhuIiwiZ3JvdXBpIiwiYnJlYWskMCIsImdyb3VwcyIsImN1cnJlbnRfZ3JvdXAiLCJncm91cCIsInNvcnRfYW5kX2dyb3VwIiwiY29uY2F0X21hcCIsImNvbmNhdF9tYXBpIiwiY29udCIsIm1lcmdlIiwiaDIiLCJoMSIsIm1hcDIkMCIsIm1hcDMkMCIsImxhc3RfZXhuIiwibGFzdCIsImlzX3ByZWZpeCIsInByZWZpeCIsInByZWZpeCQwIiwicHJlZml4JDEiLCJoZCQwIiwiZmluZF9jb25zZWN1dGl2ZV9kdXBsaWNhdGUiLCJhMSIsImExJDAiLCJhMiIsInJlbW92ZV9jb25zZWN1dGl2ZV9kdXBsaWNhdGVzIiwid2hpY2hfdG9fa2VlcCIsInRsJDAiLCJ0b19rZWVwJDIiLCJ0b19rZWVwIiwidG9fa2VlcCQwIiwidG9fa2VlcCQxIiwiZGVkdXBfYW5kX3NvcnQiLCJzb3J0ZWQiLCJmaW5kX2FfZHVwIiwibCQwIiwiaGQyIiwiaGQxIiwiY29udGFpbnNfZHVwIiwibHN0IiwiZmluZF9hbGxfZHVwcyIsInNvcnRlZCQyIiwicHJldiQxIiwic29ydGVkJDAiLCJwcmV2IiwiYWxyZWFkeV9yZWNvcmRlZCIsInNvcnRlZCQxIiwicHJldiQwIiwiYWxsX2VxdWFsIiwiY291bnRpIiwiaWR4IiwicmV2X2ZpbHRlcl9tYXAiLCJmaWx0ZXJfbWFwIiwicmV2X2ZpbHRlcl9tYXBpIiwiaSQxIiwiZmlsdGVyX21hcGkiLCJmaWx0ZXJfb3B0IiwicGFydGl0aW9uM19tYXAiLCJ0cmQiLCJ0cmQkMCIsInkkMSIsInBhcnRpdGlvbl90ZiIsImYkMCIsInBhcnRpdGlvbl9yZXN1bHQiLCJ0X29mX3NleHAkMCIsIm9mX2FfMDE0Iiwib2ZfYl8wMTUiLCJ4XzAyMyIsInNleHBfMDIxIiwiYXJnMV8wMTgiLCJhcmcwXzAxNyIsInJlczBfMDE5IiwicmVzMV8wMjAiLCJzZXhwX29mX3QkMSIsIm9mX2FfMDI0Iiwib2ZfYl8wMjUiLCJ4XzAzMCIsImFyZzFfMDI3IiwiYXJnMF8wMjYiLCJyZXMxXzAyOSIsInRfc2V4cF9ncmFtbWFyJDAiLCJwYWlyX29mX2dyb3VwIiwiayIsImdyb3VwJDAiLCJhbGlzdCIsInNvcnRfYW5kX2dyb3VwJDAiLCJrZXkiLCJrZXkkMCIsIm5vdF9mb3VuZCQzIiwiZmluZF9leG4kMCIsInZhbHVlIiwibWVtJDAiLCJyZW1vdmUiLCJhZGQiLCJpbnZlcnNlIiwibWFwJDIiLCJlbCIsInNwbGl0X24iLCJ0X29yaWciLCJ0YWtlIiwiZHJvcCIsImNodW5rc19vZiIsImwkMSIsInN1Ymxpc3QiLCJzcGxpdF93aGlsZSIsInRha2Vfd2hpbGUiLCJkcm9wX3doaWxlIiwiZHJvcF9sYXN0IiwiZHJvcF9sYXN0X2V4biIsImNhcnRlc2lhbl9wcm9kdWN0IiwibGlzdDEiLCJsaXN0MiIsImNvbmNhdF9ub19vcmRlciIsImNvbnMiLCJpc19zb3J0ZWQiLCJpc19zb3J0ZWRfc3RyaWN0bHkiLCJhcnIiLCJyYW5kb21fZWxlbWVudF9leG4iLCJyYW5kb21fZWxlbWVudCIsImNtcCIsInQyJDEiLCJ0MSQxIiwidHJhbnNwb3NlIiwicm93cyQwIiwicm93cyIsImNvbHVtbnMiLCJkb19yZXYiLCJjb2x1bW5fYWNjIiwidHJpbW1lZF9yb3dzIiwiZm91bmRfZW1wdHkiLCJ0cmltbWVkIiwiY29sdW1uX2FjYyQwIiwiY29sdW1uIiwiZG9fcmV2JDAiLCJjb2x1bW5zJDAiLCJhcmcwXzAzMSIsInJlczBfMDMyIiwidHJhbnNwb3NlX2V4biIsImludGVyc3BlcnNlIiwiaXNfc3VmZml4Iiwic3VmZml4IiwibGlzdF9sZW4iLCJzdWZmaXhfbGVuIiwicmVzMF8wMDIiLCJhcmcwXzAwMyIsInJlczBfMDA0IiwicmVzMF8wMDYiLCJhcmcwXzAwNyIsInJlczBfMDA4IiwiYXJnMl8wMTEiLCJhcmcxXzAxMCIsImFyZzBfMDA5IiwicmVzMV8wMTMiLCJyZXMyXzAxNCIsImFyZzFfMDE2IiwicmVzMV8wMTgiLCJhcmcyXzAyMSIsImFyZzFfMDIwIiwiYXJnMF8wMTkiLCJyZXMxXzAyMyIsInJlczJfMDI0IiwiYXJnMV8wMjYiLCJhcmcwXzAyNSIsInJlczBfMDI3IiwicmVzMV8wMjgiLCJhcmcxXzAzMCIsInJlczBfMDMxIiwicmVzMV8wMzIiLCJ0b19zdHJpbmdzX2h1bSIsInN0cmluZyIsInNleHAkMCIsInNleHAkMSIsInRhZyIsInRhZyQwIiwic2V4cCQyIiwidGFnJDEiLCJib2R5IiwidHJ1bmNfYWZ0ZXIiLCJ0cyQwIiwidHMkMSIsImFjJDEiLCJ0b19zZXhwc19odW0iLCJoZXJlIiwiaGVyZSQwIiwidG9fc2V4cF9odW0iLCJzZXhwcyIsInRvX21lc3NhZ2UiLCJpbmZvIiwib2ZfbWVzc2FnZSIsInRvX3N0cmluZ19odW0iLCJtZXNzYWdlIiwidG9fc3RyaW5nX2h1bV9kZXByZWNhdGVkIiwib2ZfbGF6eSIsIm9mX2xhenlfc2V4cCIsIm9mX2xhenlfdCIsImxhenlfdCIsImNyZWF0ZWYiLCJvZl90aHVuayIsInN0cmljdCIsInNleHBfb2ZfeCIsInRhZ19zX2xhenkiLCJ0YWdfcyIsInRhZ19hcmciLCJ0b19leG4iLCJvZl9leG4iLCJiYWNrdHJhY2UkMCIsImJhY2t0cmFjZSQxIiwiYmFja3RyYWNlJDIiLCJyYWlzZSIsInJhaXNlX3MiLCJ0b19pbmZvIiwib2ZfaW5mbyIsImNoZWNrX2ZpZWxkIiwiYV8wMDciLCJiXzAwOCIsIm9mX2FfMDEzIiwieF8wMTUiLCJvZl9hXzAxNiIsInhfMDE3IiwiaW52YXJpYW50X2EiLCJlMSIsImUyIiwidHJ5X3dpdGhfam9pbiIsIm9mX2V4bl9yZXN1bHQiLCJlcnJvcl9zIiwiZXJyb3Jfc3RyaW5nIiwiZXJyb3JmIiwidW5pbXBsZW1lbnRlZCIsImZpbHRlcl9va19hdF9sZWFzdF9vbmUiLCJmaW5kX29rIiwiZmluZF9tYXBfb2siLCJlcnJvcl9zb3VyY2VfMDAzIiwic2V4cF8wMDQiLCJnZXEiLCJsZXEiLCJiZXR3ZWVuIiwibG93IiwiaGlnaCIsImNsYW1wX3VuY2hlY2tlZCIsImNsYW1wX2V4biIsImNsYW1wIiwibGV4aWNvZ3JhcGhpYyIsImNtcHMiLCJjbXBzJDAiLCJsaWZ0IiwicmV2ZXJzZSIsImlzX3Bvc2l0aXZlIiwiaXNfbm9uX25lZ2F0aXZlIiwiaXNfbmVnYXRpdmUiLCJpc19ub25fcG9zaXRpdmUiLCJzaWduIiwiaGFzaF9wYXJhbSIsInBvbHkiLCJvZl9rZXkiLCJLZXkiLCJ0b19rZXkiLCJoYXNoX3BhcmFtJDAiLCJwb2x5JDAiLCJvZl9rZXkkMCIsInRvX2tleSQwIiwiaGFzaGFibGUiLCJnZXRfcG9zX2xlbiIsImZpbmRfZmlyc3Rfc2F0aXNmeWluZyIsInByZWQiLCJwb3MkMCIsImhpJDAiLCJsbyQxIiwibWlkIiwibG8kMiIsImxvJDAiLCJmaW5kX2xhc3Rfc2F0aXNmeWluZyIsImJpbmFyeV9zZWFyY2giLCJob3ciLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCIsInNlZ21lbnRfb2YiLCJpc19sZWZ0IiwiaXNfcmlnaHQiLCJhbGwkMCIsInNyYyIsInNyY19wb3MiLCJkc3QiLCJkc3RfcG9zIiwiYmxpdG8iLCJzcmNfbGVuIiwic3VibyIsImNyZWF0ZV9saWtlIiwidW5zYWZlX2JsaXQkMCIsImlzX25vbmUiLCJpc19zb21lIiwidmFsdWVfbWFwIiwibyIsImNhbGwiLCJ2YWx1ZV9leG4iLCJlcnJvciQwIiwibSQwIiwibSQxIiwidmFsdWVfb3JfdGh1bmsiLCJzb21lIiwiZmlyc3Rfc29tZSIsInNvbWVfaWYiLCJjb25kIiwiYV9vZl9zZXhwIiwiYl9vZl9zZXhwIiwic2V4cF9vZl9iIiwiY19vZl9zZXhwIiwic2V4cF9vZl9jIiwiaXNfZmlyc3QiLCJpc19zZWNvbmQiLCJmaXJzdCIsInNlY29uZCIsImVxMSIsImVxMiIsIm90aGVyIiwiZWl0aGVyIiwib3RoZXJfbG9vcCIsInJldHVybl9sb29wIiwiY29tYmluZV9hbGwiLCJvdGhlcl9sb29wJDAiLCJyZXR1cm5fbG9vcCQwIiwiY29tYmluZV9hbGxfdW5pdCIsInRvX29wdGlvbiIsImVpdGhlciQwIiwiY29tYmluZSQwIiwiaXRlcmkkMCIsIml0ZXJpJDEiLCJmb2xkaSQwIiwiZm9sZGkkMSIsImNvdW50aSQwIiwiZXhpc3RzaSQwIiwiZm9yX2FsbGkkMCIsImZpbmRfbWFwaSQwIiwiZmluZGkkMCIsImVycm9yX3NvdXJjZV8wMjUiLCJvZl9zXzAwMiIsIm5leHRfc3RlcCIsImRlbGF5ZWRfZm9sZF9zdGVwIiwibmV4dCIsInVuZm9sZF9zdGVwIiwidW5mb2xkIiwidW5mb2xkX3dpdGgiLCJzZWVkJDAiLCJzZWVkJDEiLCJ1bmZvbGRfd2l0aF9hbmRfZmluaXNoIiwicnVubmluZ19zdGVwIiwiaW5uZXJfZmluaXNoZWQiLCJmaW5pc2hpbmdfc3RlcCIsInN0YXRlJDAiLCJzdGF0ZSQxIiwic3RhdGUkMiIsImlubmVyX3N0YXRlIiwic3RhdGUkMyIsImlubmVyX3N0YXRlJDAiLCJpbm5lcl9zdGF0ZSQxIiwic3RhdGUkNCIsInN0YXRlJDUiLCJzZWVkJDIiLCJ2JDAiLCJ0b19saXN0X3JldiIsInN0YXJ0X3YiLCJzdG9wX3YiLCJzdGVwIiwidF9sYXp5IiwibCQyIiwic29tZV9iIiwiZW1wdHkiLCJuZXh0JDAiLCJzJDMiLCJhXzAxMSIsImJfMDEyIiwiYV8wMTMiLCJiXzAxNCIsImFfMDE1IiwiYl8wMTYiLCJhXzAxOSIsImFfMDE3IiwiYl8wMjAiLCJiXzAxOCIsImEwJDEiLCJoc3YkMyIsIm9mX2FfMDIxIiwib2ZfYl8wMjIiLCJzZXhwXzAyNyIsInRhZ18wMjgiLCJzZXhwX2FyZ3NfMDM0IiwiYXJnMF8wMzUiLCJyZXMwXzAzNiIsInNleHBfYXJnc18wMjkiLCJhcmcwXzAzMCIsInNleHBfYXJnc18wMzkiLCJhcmcxXzA0MSIsImFyZzBfMDQwIiwicmVzMF8wNDIiLCJyZXMxXzA0MyIsIm9mX2FfMDQ2Iiwib2ZfYl8wNDciLCJhcmcwXzA0OCIsInJlczBfMDQ5IiwiYXJnMF8wNTAiLCJyZXMwXzA1MSIsImFyZzFfMDUzIiwiYXJnMF8wNTIiLCJyZXMwXzA1NCIsInJlczFfMDU1IiwibWVyZ2Vfd2l0aF9kdXBsaWNhdGVzIiwibmV4dDIiLCJzMiIsIm5leHQxIiwiczEiLCJzMiQwIiwiczIkMSIsInMxJDAiLCJzMiQyIiwiczEkMSIsInMyJDMiLCJjb21wYXJpc29uIiwibWVyZ2VfZGVkdXBlZF9hbmRfc29ydGVkIiwibWVyZ2Vfc29ydGVkIiwidGxfZWFnZXJseV9leG4iLCJsaWZ0X2lkZW50aXR5IiwiY2h1bmtzX2V4biIsInppcF9mdWxsIiwiYm91bmRlZF9sZW5ndGgiLCJhdF9tb3N0IiwibGVuZ3RoX2lzX2JvdW5kZWRfYnkiLCJjdXIiLCJjdXIkMCIsImxhc3RfZWx0IiwibGFzdF9lbHQkMCIsInNoaWZ0X3JpZ2h0Iiwic2hpZnRfcmlnaHRfd2l0aF9saXN0IiwicyQ1IiwiYSQxIiwicyQ0IiwicmVwZWF0IiwiY3ljbGVfbGlzdF9leG4iLCJzYSIsInNiIiwic2luZ2xldG9uIiwiZGVsYXllZF9mb2xkIiwib3B0aW9uIiwiZm9sZF9tIiwiaXRlcl9tIiwiZm9yY2VfZWFnZXJseSIsIm1lbW9pemUiLCJkcm9wX2VhZ2VybHkiLCJkcm9wX3doaWxlX29wdGlvbiIsInYyIiwidjEiLCJyb3VuZF9yb2JpbiIsImRvbmVfc3RhY2siLCJ0b2RvX3N0YWNrIiwidG9kb19zdGFjayQwIiwiaW50ZXJsZWF2ZSIsImludGVybGVhdmVkX2NhcnRlc2lhbl9wcm9kdWN0Iiwib2Zfc2VxIiwic2VxIiwidG9fc2VxIiwieWllbGQkMCIsIm9mX3NlcXVlbmNlIiwic2VxdWVuY2UiLCJ0aHVuayIsInNldCIsInN3YXAkMCIsInRtcCIsImxlZnQiLCJyaWdodCIsImZpbmFsX3BvcyIsImlfbmV4dCIsImhlYXBpZnkiLCJyb290Iiwicm9vdCQwIiwicmVsYXRpdmVfcm9vdCIsImxlZnRfY2hpbGQiLCJyaWdodF9jaGlsZCIsImxhcmdlc3QiLCJsYXJnZXN0JDAiLCJzb3J0JDAiLCJmaXZlX2VsZW1lbnRfc29ydCIsIm0xIiwibTIiLCJtMyIsIm00IiwibTUiLCJjb21wYXJlX2FuZF9zd2FwIiwiaW50cm9fc29ydCIsIm1heF9kZXB0aCIsIm1heF9kZXB0aCQwIiwibGVmdCQwIiwibWF4X2RlcHRoJDEiLCJzaXh0aCIsIm0yX3ZhbCIsIm0zX3ZhbCIsIm00X3ZhbCIsIm1pZGRsZV9zb3J0ZWQiLCJwaXZvdDIiLCJwaXZvdDEiLCJwJDEiLCJyJDIiLCJwdiIsInIkMCIsInIkMSIsInAkMCIsImxlZnQkMSIsInNvcnQkMSIsInNvcnQkMiIsImVsdF9pX21pbnVzXzEiLCJtZXJnZWQiLCJhMV9pbmRleCIsImEyX2luZGV4IiwidXNlX2ExIiwiY29weV9tYXRyaXgiLCJyZXZfaW5wbGFjZSIsIm9mX2xpc3RfcmV2Iiwib2ZfbGlzdF9tYXAiLCJvZl9saXN0X21hcGkiLCJvZl9saXN0X3Jldl9tYXAiLCJvZl9saXN0X3Jldl9tYXBpIiwibWFwX2lucGxhY2UiLCJmaW5kaV9pbnRlcm5hbCIsImlmX2ZvdW5kIiwiaWZfbm90X2ZvdW5kIiwiZm91bmQiLCJ2YWx1ZV9mb3VuZCIsInJlczEiLCJyZXMyIiwic29ydGVkX2NvcHkiLCJwYXJ0aXRpb25pX3RmIiwidHJ1ZXMiLCJmYWxzZXMiLCJ0b19zZXF1ZW5jZV9tdXRhYmxlIiwidG9fc2VxdWVuY2UiLCJpMSIsImkyIiwidHQiLCJ3aWR0aCIsImRlcHRoIiwiZCIsInciLCJ0dCQwIiwiZ2V0JDAiLCJ6ZXJvX29iaiIsImNyZWF0ZV96ZXJvIiwidW5zYWZlX2dldCIsInVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSIsIm9iaiIsInNldF93aXRoX2NhbWxfbW9kaWZ5IiwidW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVuIiwib2xkX29iaiIsInVuc2FmZV9zZXQiLCJ1bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGUiLCJ1bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV8iLCJ1bnNhZmVfc2V0X2ludCIsInVuc2FmZV9jbGVhcl9pZl9wb2ludGVyIiwiaSQyIiwidW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIiwiY3JlYXRlX29ial9hcnJheSIsIm9mX2FycmF5IiwiZ3JhbW1hciIsImNlaWwiLCJmbG9vciIsIm1vZF9mbG9hdCIsIm1vZGYiLCJtYXhfZmluaXRlX3ZhbHVlIiwiY2xhc3NpZnlfZmxvYXQiLCJhYnNfZmxvYXQiLCJpc19pbnRlZ2VyIiwiZnJleHAiLCJsZGV4cCIsImlzX25hbiIsInRvX2ludDY0X3ByZXNlcnZlX29yZGVyIiwidG9faW50NjRfcHJlc2VydmVfb3JkZXJfZXhuIiwib2ZfaW50NjRfcHJlc2VydmVfb3JkZXIiLCJvbmVfdWxwIiwiZGlyIiwidXBwZXJfYm91bmRfZm9yX2ludCIsImV4cCIsImlzX3hfbWludXNfb25lX2V4YWN0IiwibG93ZXJfYm91bmRfZm9yX2ludCIsIm1pbl9pbnRfYXNfZmxvYXQiLCJib3giLCJpc19sb3dlcmNhc2UiLCJpc191cHBlcmNhc2UiLCJpc19wcmludCIsImlzX3doaXRlc3BhY2UiLCJpc19kaWdpdCIsImlzX2FscGhhIiwiaXNfYWxwaGFudW0iLCJnZXRfZGlnaXRfdW5zYWZlIiwiZ2V0X2RpZ2l0X2V4biIsImdldF9kaWdpdCIsImlzX2hleF9kaWdpdCIsImlzX2hleF9kaWdpdF9sb3dlciIsImlzX2hleF9kaWdpdF91cHBlciIsImdldF9oZXhfZGlnaXRfZXhuIiwiZ2V0X2hleF9kaWdpdCIsInRfb2Zfc2V4cCQxIiwiYzEiLCJjMiIsImhhc2hfZm9sZF90JDEiLCJoYXNoJDEiLCJ0cl9jcmVhdGVfbWFwIiwidGFyZ2V0IiwicmVwbGFjZW1lbnQiLCJ0cl9tYXAiLCJpJDMiLCJpbmRleCQwIiwibGFzdF9yZXBsYWNlbWVudCIsImluZGV4IiwiZmlyc3RfdGFyZ2V0Iiwic3RhZ2UiLCJ1bnN0YWdlIiwiY29udGFpbnMiLCJwb3MkMSIsImVuZCIsImluZGV4X2Zyb21fZXhuX2ludGVybmFsIiwiaW5kZXhfZXhuX2ludGVybmFsIiwiaW5kZXhfZXhuIiwiaW5kZXhfZnJvbV9leG4iLCJyaW5kZXhfZnJvbV9leG5faW50ZXJuYWwiLCJyaW5kZXhfZXhuX2ludGVybmFsIiwicmluZGV4X2V4biIsInJpbmRleF9mcm9tX2V4biIsInJpbmRleCIsImluZGV4X2Zyb20iLCJyaW5kZXhfZnJvbSIsImNhc2Vfc2Vuc2l0aXZlIiwicGF0dGVybiIsImttcF9pbnRlcm5hbF9sb29wIiwibWF0Y2hlZF9jaGFycyIsIm5leHRfdGV4dF9jaGFyIiwia21wX2FycmF5IiwiY2hhcl9lcXVhbCIsIm1hdGNoZWRfY2hhcnMkMCIsImdldF9jaGFyX2VxdWFsIiwiaW5kZXhfaW50ZXJuYWwiLCJ0ZXh0IiwibWF0Y2hlcyIsImluJDAiLCJpbmRleF9leG4kMCIsImluZGV4X2FsbCIsIm1heV9vdmVybGFwIiwicmVwbGFjZV9maXJzdCIsIndpdGgkMCIsImxlbl9zIiwibGVuX3QiLCJsZW5fd2l0aCIsInJlcGxhY2VfYWxsIiwibnVtX21hdGNoZXMiLCJuZXh0X2RzdF9wb3MiLCJuZXh0X3NyY19wb3MiLCJzcGxpdF9vbiIsInBhdHRlcm5fbGVuIiwiYV8wMDIiLCJiXzAwMyIsImttcF9hcnJheV8wMTEiLCJjYXNlX3NlbnNpdGl2ZV8wMDkiLCJwYXR0ZXJuXzAwNyIsImFyZ18wMTIiLCJibmRzXzAwNiIsImFyZ18wMTAiLCJibmRzXzAwNiQwIiwiYXJnXzAwOCIsImJuZHNfMDA2JDEiLCJyZXByZXNlbnRhdGlvbiIsInN1YnN0cl9pbmRleF9nZW4iLCJzdWJzdHJfaW5kZXhfZXhuX2dlbiIsInN1YnN0cl9pbmRleF9hbGxfZ2VuIiwic3Vic3RyX3JlcGxhY2VfZmlyc3RfZ2VuIiwic3Vic3RyX3JlcGxhY2VfYWxsX2dlbiIsImlzX3N1YnN0cmluZ19nZW4iLCJzdWJzdHJpbmciLCJzdWJzdHJfaW5kZXgiLCJzdWJzdHJfaW5kZXhfZXhuIiwic3Vic3RyX2luZGV4X2FsbCIsInN1YnN0cl9yZXBsYWNlX2ZpcnN0Iiwic3Vic3RyX3JlcGxhY2VfYWxsIiwiaXNfc3Vic3RyaW5nIiwiaXNfc3Vic3RyaW5nX2F0X2dlbiIsInN0cl9wb3MkMSIsInN0cl9sZW4iLCJzdWJfbGVuIiwic3RyX3BvcyIsInN1Yl9wb3MiLCJzdWJfcG9zJDAiLCJzdHJfcG9zJDAiLCJpc19zdWZmaXhfZ2VuIiwic3RyaW5nX2xlbiIsImlzX3ByZWZpeF9nZW4iLCJwcmVmaXhfbGVuIiwic2V4cF9vZl90JDIiLCJzdHJpbmcxIiwic3RyaW5nMiIsImxlbjIiLCJsZW4xIiwic3Vic3RyX2luZGV4JDAiLCJzdWJzdHJfaW5kZXhfZXhuJDAiLCJzdWJzdHJfaW5kZXhfYWxsJDAiLCJzdWJzdHJfcmVwbGFjZV9maXJzdCQwIiwic3Vic3RyX3JlcGxhY2VfYWxsJDAiLCJpc19zdWJzdHJpbmckMCIsImlzX3N1YnN0cmluZ19hdCIsImxzcGxpdDJfZXhuIiwibGluZSIsImRlbGltIiwibm90X2ZvdW5kJDQiLCJyc3BsaXQyX2V4biIsImxzcGxpdDIiLCJvbiIsInJzcGxpdDIiLCJjaGFyX2xpc3RfbWVtIiwic3BsaXRfZ2VuIiwiaXNfZGVsaW0iLCJsYXN0X3BvcyIsImxhc3RfcG9zJDEiLCJsYXN0X3BvcyQwIiwicG9zMSIsInN1Yl9zdHIiLCJzcGxpdCIsInNwbGl0X29uX2NoYXJzIiwiY2hhcnMiLCJiYWNrX3VwX2F0X25ld2xpbmUiLCJlb2wiLCJzcGxpdF9saW5lcyIsImlzX3N1ZmZpeCQwIiwiaXNfcHJlZml4JDAiLCJpc19zdWJzdHJpbmdfYXQkMCIsIndyYXBfc3ViX24iLCJvbl9lcnJvciIsImRyb3BfcHJlZml4IiwiZHJvcF9zdWZmaXgiLCJsZmluZGkiLCJyZmluZGkiLCJsYXN0X25vbl9kcm9wIiwicnN0cmlwIiwiZmlyc3Rfbm9uX2Ryb3AiLCJsc3RyaXAiLCJzdHJpcCIsInRyIiwidHJfbXVsdGkiLCJjb25jYXRfYXJyYXkiLCJhciIsIm91dCIsIm91dF9wb3MiLCJvdXQkMCIsImNob3BfcHJlZml4IiwiY2hvcF9wcmVmaXhfaWZfZXhpc3RzIiwiY2hvcF9wcmVmaXhfZXhuIiwiY2hvcF9zdWZmaXgiLCJjaG9wX3N1ZmZpeF9pZl9leGlzdHMiLCJjaG9wX3N1ZmZpeF9leG4iLCJzaG9ydGVyIiwic2hvcnRlc3QiLCJwb3NfZnJvbV9sZWZ0IiwicG9zX2Zyb21fcmlnaHQiLCJjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AiLCJnZXRfcG9zIiwibWF4X2xlbiIsImxlbl9zb19mYXIiLCJsZW5fc29fZmFyJDAiLCJsZW5fc29fZmFyJDEiLCJjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIiwiY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AiLCJmaXJzdCQwIiwibWF4X2xlbiQwIiwibWF4X2xlbiQxIiwiY29tbW9uX2dlbmVyaWNfbGVuZ3RoIiwiY29tbW9uX2dlbmVyaWMyIiwiY29tbW9uX2dlbmVyaWMiLCJjb21tb25fcHJlZml4IiwiY29tbW9uX3N1ZmZpeCIsImNvbW1vbl9wcmVmaXgyIiwiY29tbW9uX3N1ZmZpeDIiLCJjb21tb25fcHJlZml4X2xlbmd0aCIsImNvbW1vbl9zdWZmaXhfbGVuZ3RoIiwiY29tbW9uX3ByZWZpeDJfbGVuZ3RoIiwiY29tbW9uX3N1ZmZpeDJfbGVuZ3RoIiwib2ZfY2hhciIsIm9mX2NoYXJfbGlzdCIsImJ1aWxkX2FuZF92YWxpZGF0ZV9lc2NhcGV3b3J0aCIsImVzY2FwZXdvcnRoeV9tYXAiLCJlc2NhcGVfY2hhciIsImVzY2FwZXdvcnRoeV9tYXAkMCIsInZhbHMiLCJjX3RvIiwiY19mcm9tIiwiayQwIiwiZXNjYXBlX2dlbiIsImVzY2FwZXdvcnRoeSIsInRvX2VzY2FwZV9sZW4iLCJ0b19lc2NhcGUiLCJsYXN0X2lkeCIsImxhc3RfZHN0X3BvcyIsImxhc3RfaWR4JDAiLCJsYXN0X2RzdF9wb3MkMCIsInRvX2VzY2FwZSQwIiwiZXNjYXBlZF9jaGFyIiwibGFzdF9pZHgkMSIsImxhc3RfZHN0X3BvcyQxIiwiZXNjYXBlX2dlbl9leG4iLCJlc2NhcGUiLCJ1bmVzY2FwZV9nZW4iLCJzdGF0dXMiLCJ0b191bmVzY2FwZSIsInN0YXR1cyQwIiwidG9fdW5lc2NhcGUkMCIsInVuZXNjYXBlX2dlbl9leG4iLCJ1bmVzY2FwZSIsInByZWNlZGluZ19lc2NhcGVfY2hhcnMiLCJjbnQiLCJjbnQkMCIsInVwZGF0ZV9lc2NhcGVfc3RhdHVzIiwiZXNjYXBlX3N0YXR1cyIsIm9kZCIsImNoZWNrX2JvdW5kIiwiZnVuY3Rpb25fbmFtZSIsImlzX2NoYXJfZXNjYXBpbmciLCJpc19jaGFyX2VzY2FwZWQiLCJpc19jaGFyX2xpdGVyYWwiLCJpbmRleF9mcm9tJDAiLCJzdGF0dXMkMSIsImluZGV4X2Zyb21fZXhuJDAiLCJpbmRleCQxIiwiaW5kZXhfZXhuJDEiLCJyaW5kZXhfZnJvbSQwIiwiZXNjYXBlX2NoYXJzIiwicmluZGV4X2Zyb21fZXhuJDAiLCJyaW5kZXgkMCIsInJpbmRleF9leG4kMCIsInNwbGl0X2dlbiQwIiwic3BsaXQkMCIsInNwbGl0X29uX2NoYXJzJDAiLCJzcGxpdF9hdCIsImxzcGxpdDIkMCIsInJzcGxpdDIkMCIsImxzcGxpdDJfZXhuJDAiLCJyc3BsaXQyX2V4biQwIiwibGFzdF9ub25fZHJvcF9saXRlcmFsIiwiZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbCIsInJzdHJpcF9saXRlcmFsIiwibHN0cmlwX2xpdGVyYWwiLCJzdHJpcF9saXRlcmFsIiwiYmV0d2VlbiQwIiwiY2xhbXBfZXhuJDAiLCJjbGFtcCQwIiwiY3JlYXRlJDAiLCJjcmVhdGUkMSIsInVuc2FmZV9ibGl0JDEiLCJtYXBpJDAiLCJvY2FtbF9sZXhfdGFibGVzIiwicGFyc2VfaGV4IiwibGV4YnVmIiwib2NhbWxfbGV4X3N0YXRlIiwib2NhbWxfbGV4X3N0YXRlJDAiLCJjb252ZXJ0X2ZhaWx1cmUiLCJudW1fYml0c19pbnQiLCJudW1fYml0c19uYXRpdmVpbnQiLCJudW1fYml0c19pbnQzMiIsIm51bV9iaXRzX2ludDY0IiwibWluX2ludDMyIiwibWF4X2ludDMyIiwibWluX2ludDY0IiwibWF4X2ludDY0IiwibWluX25hdGl2ZWludCIsIm1heF9uYXRpdmVpbnQiLCJpbnQ2NF90b19zdHJpbmciLCJuYXRpdmVpbnRfdG9fc3RyaW5nIiwiaW50MzJfdG9faW50X3RydW5jIiwiaW50X3RvX2ludDMyX3RydW5jIiwiaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIiLCJpbnRfdG9faW50MzIiLCJpbnQzMl90b19pbnQiLCJpbnRfdG9faW50MzJfZXhuIiwiaW50MzJfdG9faW50X2V4biIsImludF90b19pbnQ2NCIsImludDY0X3RvX2ludF90cnVuYyIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IiwiaW50NjRfdG9faW50IiwiaW50NjRfdG9faW50X2V4biIsImludF90b19uYXRpdmVpbnQiLCJuYXRpdmVpbnRfdG9faW50X3RydW5jIiwibmF0aXZlaW50X3RvX2ludCIsIm5hdGl2ZWludF90b19pbnRfZXhuIiwiaW50MzJfdG9faW50NjQiLCJpbnQ2NF90b19pbnQzMl90cnVuYyIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MyIsImludDY0X3RvX2ludDMyIiwiaW50NjRfdG9faW50MzJfZXhuIiwiaW50MzJfdG9fbmF0aXZlaW50IiwibmF0aXZlaW50X3RvX2ludDMyX3RydW5jIiwibmF0aXZlaW50X3RvX2ludDMyIiwibmF0aXZlaW50X3RvX2ludDMyX2V4biIsImludDY0X3RvX25hdGl2ZWludF90cnVuYyIsIm5hdGl2ZWludF90b19pbnQ2NCIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfbmF0aSIsImludDY0X3RvX25hdGl2ZWludCIsImludDY0X3RvX25hdGl2ZWludF9leG4iLCJpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDYiLCJpbnQ2NF9maXRfb25faW50NjNfZXhuIiwiaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSIsImRlbGltaXRlciIsImNoYXJzX3Blcl9kZWxpbWl0ZXIiLCJpbnB1dF9sZW5ndGgiLCJoYXNfc2lnbiIsIm51bV9kaWdpdHMiLCJudW1fZGVsaW1pdGVycyIsIm91dHB1dF9sZW5ndGgiLCJpbnB1dF9wb3MiLCJvdXRwdXRfcG9zIiwibnVtX2NoYXJzX3VudGlsX2RlbGltaXRlciIsImZpcnN0X2RpZ2l0X3BvcyIsImluc2VydF9kZWxpbWl0ZXIiLCJpbnNlcnRfdW5kZXJzY29yZXMiLCJzZXhwX29mX2ludF9zdHlsZSIsImRlbGltaXRlciQwIiwibWFrZV9zdWZmaXgiLCJ0b19zdHJpbmckMCIsImludmFsaWQiLCJvZl9zdHJpbmdfd2l0aF9kZWxpbWl0ZXIiLCJsZXgiLCJib2R5JDAiLCJvdmVyZmxvd19ib3VuZF9tYXhfaW50NjNfb25faW4iLCJvdmVyZmxvd19ib3VuZF9tYXhfaW50NjRfdmFsdWUiLCJpbnQzMl9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMiLCJvdmVyZmxvd19ib3VuZF9tYXhfaW50X3ZhbHVlIiwib3ZlcmZsb3dfYm91bmRfbWF4X2ludDMyX3ZhbHVlIiwiaW50X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyIsImludDYzX29uX2ludDY0X3Bvc2l0aXZlX292ZXJmbCIsImludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyIsImludDY0X25lZ2F0aXZlX292ZXJmbG93X2JvdW5kcyIsIm5lZ2F0aXZlX2V4cG9uZW50Iiwib3ZlcmZsb3ciLCJpbnRfcG93IiwiYmFzZSIsImV4cG9uZW50IiwiaW50NjRfcG93IiwiaW50NjNfcG93X29uX2ludDY0IiwicnZhbCIsIm9uZSIsInJvdW5kX2Rvd24iLCJtb2R1bHVzIiwicm91bmRfdXAiLCJyZW1haW5kZXIiLCJyb3VuZF90b3dhcmRzX3plcm8iLCJ0b19tdWx0aXBsZV9vZiIsInJvdW5kX25lYXJlc3QiLCJtb2R1bHVzX21pbnVzX3JlbWFpbmRlciIsInJvdW5kIiwiaDAxIiwibWFzayIsImludDY0X3BvcGNvdW50IiwieCQyIiwiaW50MzJfcG9wY291bnQiLCJuYXRpdmVpbnRfcG9wY291bnQiLCJtb2R1bGVfbmFtZSQwIiwib2Zfc3RyaW5nJDAiLCJmbG9hdF9sb3dlcl9ib3VuZCIsImZsb2F0X3VwcGVyX2JvdW5kIiwib2ZfZmxvYXRfdW5jaGVja2VkIiwiemVybyIsImZ1bmMkMCIsIm5lZyIsIm9mX3N0cmluZyQxIiwib2ZfaW50MzIiLCJvZl9pbnQzMl9leG4iLCJ0b19pbnQzMiIsInRvX2ludDMyX2V4biIsIm9mX2ludDY0Iiwib2ZfaW50NjRfZXhuIiwidG9faW50NjQiLCJvZl9uYXRpdmVpbnQiLCJvZl9uYXRpdmVpbnRfZXhuIiwidG9fbmF0aXZlaW50IiwiYWJzIiwicmVtIiwic2hpZnRfcmlnaHRfbG9naWNhbCIsInNoaWZ0X2xlZnQiLCJiaXRfbm90IiwiYml0X29yIiwiYml0X2FuZCIsImJpdF94b3IiLCJwb3ciLCJub25fcG9zaXRpdmVfYXJndW1lbnQiLCJjZWlsX3BvdzIiLCJ4JDMiLCJ4JDQiLCJ4JDUiLCJ4JDYiLCJmbG9vcl9wb3cyIiwiaXNfcG93MiIsImZsb29yX2xvZzIiLCJjZWlsX2xvZzIiLCJwb3Bjb3VudCIsImxub3QiLCJzdWNjX2V4biIsIm1zZyIsInByZWRfZXhuIiwib2Zfc2NhbGFyIiwib2Zfc2NhbGFyX2V4biIsInRvX3NjYWxhciIsInRvX2NoYXIiLCJ0b19jaGFyX2V4biIsInV0ZjhfYnl0ZV9sZW5ndGgiLCJ1Y2hhciIsImNvZGVwb2ludCIsInNvbWVfdCIsInN5bSIsInRyYW5zIiwiY29udiIsImRldHVwbGUyIiwidHVwbGUyIiwid2l0bmVzcyIsInZfMDA1IiwidG9fc2V4cCIsInVpZCIsInNhbWVfd2l0bmVzcyIsInNhbWUiLCJzYW1lX3dpdG5lc3NfZXhuIiwibm9uZV9zdWJzdGl0dXRlIiwibm9uZSIsInZhbHVlX3Vuc2FmZSIsIm9mX3NleHBhYmxlIiwidG9fc2V4cGFibGUiLCJ4XzAwMyIsIm9mX2FfMDA0IiwieF8wMDUiLCJpbml0X3NvbWUiLCJnZXRfc29tZV9leG4iLCJpc19ub25lJDAiLCJpc19zb21lJDAiLCJzZXRfc29tZSIsInNldF9ub25lIiwidW5zYWZlX2dldF9zb21lX2V4biIsInVuc2FmZV9nZXRfc29tZV9hc3N1bWluZ19zb21lIiwidW5zYWZlX2lzX3NvbWUiLCJ1bnNhZmVfc2V0X3NvbWUiLCJ1bnNhZmVfc2V0X25vbmUiLCJjbGVhciIsImVsZW0iLCJtYXBfc29tZSIsIm9mX2FycmF5X3NvbWUiLCJjYXBhY2l0eSIsImVsdHMiLCJsZW5ndGhfMDAzIiwiZWx0c18wMDUiLCJhcmdfMDA2IiwiYm5kc18wMDIiLCJhcmdfMDA0IiwiYm5kc18wMDIkMCIsInJlc2l6ZSIsInNpemUiLCJzZXRfY2FwYWNpdHkiLCJuZXdfY2FwYWNpdHkiLCJuZXdfY2FwYWNpdHkkMCIsInB1c2giLCJwb3Bfbm9uZW1wdHkiLCJwb3BfZXJyb3IiLCJwb3AiLCJwb3BfZXhuIiwidG9wX25vbmVtcHR5IiwidG9wX2Vycm9yIiwidG9wIiwidG9wX2V4biIsInVudGlsX2VtcHR5IiwiaGFzaF9vdmVycmlkZSIsIm9mX3BvcyIsIm9mX3NpZ24iLCJ0b19zaWduX2V4biIsInRvX2ludF9leG4iLCJlcnJvcl9zb3VyY2VfMDA2IiwiZXJyb3Jfc291cmNlXzAyNyIsImludGVydmFsX2NvbXBhcmlzb25fc2V4cF9ncmFtbSIsImFsbF9vZl9hIiwiZW51bWVyYXRlXzAwMiIsImVudW1lcmF0ZV8wMDEiLCJhY2MkMiIsIm9mX2FfMDAzIiwic2V4cF8wMDgiLCJ0YWdfMDA5Iiwic2V4cF9hcmdzXzAxMCIsImFyZzBfMDIwIiwicmVzMF8wMjEiLCJhcmcwXzAyMiIsInJlczBfMDIzIiwiaW50ZXJ2YWxfY29tcGFyaXNvbl9vZl9zZXhwIiwic2V4cF8wMjgiLCJzZXhwX29mX2ludGVydmFsX2NvbXBhcmlzb24iLCJjb21wYXJlX2ludGVydmFsX2NvbXBhcmlzb24iLCJoYXNoX2ZvbGRfaW50ZXJ2YWxfY29tcGFyaXNvbiIsImhhc2hfaW50ZXJ2YWxfY29tcGFyaXNvbiIsImluY2wiLCJleGNsIiwiaXNfbG93ZXJfYm91bmQiLCJpc191cHBlcl9ib3VuZCIsImJvdW5kc19jcm9zc2VkIiwibG93ZXIiLCJ1cHBlciIsImxvd2VyJDAiLCJ1cHBlciQwIiwiY29tcGFyZV90b19pbnRlcnZhbF9leG4iLCJpbnRlcnZhbF9jb250YWluc19leG4iLCJlcnJvcl9zb3VyY2VfMDU3IiwicmlnaHRfMDA0IiwibGVmdF8wMDMiLCJyaWdodF8wMDgiLCJsZWZ0XzAwNyIsIm9mX2FfMDA5Iiwidl8wMTAiLCJjbXBfayIsImNtcF92IiwidF8wMTQiLCJ0XzAxMyIsInRfMDE2IiwidF8wMTUiLCJyaWdodF8wMTgiLCJsZWZ0XzAxNyIsInJpZ2h0XzAyMiIsImxlZnRfMDIxIiwidF8wMjQiLCJ0XzAyMyIsInRfMDI2IiwidF8wMjUiLCJyaWdodF8wMjAiLCJsZWZ0XzAxOSIsInRfMDMwIiwidF8wMjkiLCJ0XzAzMiIsInRfMDMxIiwicmlnaHRfMDM0IiwibGVmdF8wMzMiLCJyaWdodF8wMzgiLCJsZWZ0XzAzNyIsInRfMDQwIiwidF8wMzkiLCJ0XzA0MiIsInRfMDQxIiwicmlnaHRfMDM2IiwibGVmdF8wMzUiLCJvZl9rXzA0MyIsIm9mX3ZfMDQ0Iiwic2V4cF8wNzEiLCJhcmcxXzA2OCIsImFyZzBfMDY3IiwicmVzMF8wNjkiLCJhdG9tXzA0NyIsInNleHBfYXJnc18wNTAiLCJhdG9tXzA0NyQwIiwiYXJnMF8wNTgiLCJyZXMwXzA1OSIsImFyZzBfMDYxIiwicmVzMF8wNjIiLCJhcmcwXzA2NCIsInJlczBfMDY1IiwicmVzMV8wNzAiLCJvZl9rXzA3MiIsIm9mX3ZfMDczIiwiYXJnMV8wODIiLCJhcmcwXzA4MSIsInJlczBfMDgzIiwidl8wNzQiLCJyZXMxXzA4NCIsInZfMDc2IiwiYXJnMV8wNzgiLCJhcmcwXzA3NyIsInJlczBfMDc5IiwicmVzMV8wODAiLCJ2XzA3NSIsImtfc2V4cF9ncmFtbWFyIiwidl9zZXhwX2dyYW1tYXIiLCJjbXBfbGVmdCIsImNtcF9yaWdodCIsImFfMDg1IiwiYl8wODYiLCJyaWdodF8wOTIiLCJsZWZ0XzA5MSIsInRfMDk0IiwidF8wOTMiLCJ0XzA5NiIsInRfMDk1IiwicmlnaHRfMDg4IiwibGVmdF8wODciLCJyaWdodF8wOTAiLCJsZWZ0XzA4OSIsImFfMDk3IiwiYl8wOTgiLCJyaWdodF8xMDQiLCJsZWZ0XzEwMyIsInRfMTA2IiwidF8xMDUiLCJ0XzEwOCIsInRfMTA3IiwicmlnaHRfMTAwIiwibGVmdF8wOTkiLCJyaWdodF8xMDIiLCJsZWZ0XzEwMSIsIm9mX2xlZnRfMTA5Iiwib2ZfcmlnaHRfMTEwIiwidl8xMTMiLCJhcmcxXzExNSIsImFyZzBfMTE0IiwicmVzMF8xMTYiLCJyZXMxXzExNyIsInZfMTExIiwidl8xMTIiLCJzZXhwX29mX3QkMyIsImhlaWdodCIsImluX3JhbmdlIiwiaGwiLCJociIsImxvd2VyJDEiLCJpbnZhcmlhbnRzIiwiaCQxIiwiaCQwIiwic2wiLCJzciIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayIsImtsIiwiayQxIiwia2wkMCIsImskMiIsImtyIiwibGVmdF9sZW5ndGgiLCJyaWdodF9sZW5ndGgiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIiwiYXJyYXlfbGVuZ3RoIiwib2Zfc29ydGVkX2FycmF5IiwiaW5jcmVhc2luZyIsImJhbCIsImxyIiwibHYiLCJsbCIsImxyciIsImxydiQwIiwibHJsIiwibHJ2IiwicnIiLCJydiIsInJsIiwicmxyIiwicmx2JDAiLCJybGwiLCJybHYiLCJhdXgiLCJsaCIsImx2JDAiLCJyaCIsInJ2JDAiLCJtaW5fZWx0X2V4biIsImZvbGRfdW50aWxfaGVscGVyIiwidmFsdWUkMCIsIm1heF9lbHRfZXhuIiwicmVtb3ZlX21pbl9lbHQiLCJtYXliZV9lbHQiLCJtYXliZV9lbHQkMCIsImVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3RpbyIsInJlbW92ZV9pbmRleCIsImxfc2l6ZSIsInVuaW9uIiwidjEkMCIsInYyJDAiLCJyMiQwIiwicjEkMCIsInVuaW9uX2xpc3QiLCJ0b190cmVlIiwiaW50ZXIiLCJvdGhlcl9zZXQiLCJlJDEiLCJjb25zX3JpZ2h0Iiwib2Zfc2V0IiwiZW51bSQwIiwidHJlZSIsInN5bW1ldHJpY19kaWZmIiwiZWx0JDAiLCJlbnVtMSIsInRyZWUxIiwiZW51bTIiLCJ0cmVlMiIsImNvbXBhcmVfcmVzdWx0IiwibmV4dF9zdGF0ZSIsImdyZWF0ZXJfb3JfZXF1YWxfdG8iLCJsZXNzX29yX2VxdWFsX3RvIiwiaW5jbHVzaXZlX2JvdW5kIiwic2lkZSIsIm1heWJlIiwidiQxIiwiaW5pdCQwIiwidiQyIiwidiQzIiwidiQ0IiwiZSQyIiwibWVyZ2VfdG9fc2VxdWVuY2UiLCJlMiQyIiwiZTEkMiIsImUyJDAiLCJlMSQwIiwiZTIkMSIsImUxJDEiLCJ0MiQyIiwidDEkMiIsImlzX3N1YnNldCIsImFyZV9kaXNqb2ludCIsImFjY3UkMCIsImFjY3UkMSIsImZpbHQiLCJwYXJ0IiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJjaG9vc2UiLCJjaG9vc2VfZXhuIiwicG9zX3JlZiIsImdyb3VwX2J5IiwiZXF1aXYiLCJzZXQkMCIsImVxdWl2X2NsYXNzZXMiLCJub3RfZXF1aXZfeCIsImVxdWl2X3giLCJlcXVpdl9jbGFzc2VzJDAiLCJzdGFibGVfZGVkdXBfbGlzdCIsImxlZnRvdmVycyIsImFscmVhZHlfc2VlbiIsImFscmVhZHlfc2VlbiQwIiwibGVmdG92ZXJzJDAiLCJ0X29mX3NleHBfZGlyZWN0IiwiZWx0X2xzdCIsImVsX3NleHAiLCJpc19zdWJzZXQkMCIsInN1YnNldCIsInN1cGVyc2V0Iiwic2V4cF9vZl9lbHQiLCJpbnZhbGlkX2VsZW1lbnRzIiwiaW52YWxpZF9lbGVtZW50c19zZXhwIiwibGlrZSIsImludmFyaWFudHMkMCIsImVsZW1lbnRzJDAiLCJtaW5fZWx0X2V4biQwIiwibWF4X2VsdF9leG4kMCIsImNob29zZSQwIiwiY2hvb3NlX2V4biQwIiwiZm9sZF9yaWdodCQwIiwiaXRlcjIkMCIsImZpbHRlciQwIiwiYWRkJDAiLCJyZW1vdmUkMCIsInVuaW9uJDAiLCJpbnRlciQwIiwiZGlmZiQwIiwic3ltbWV0cmljX2RpZmYkMCIsImNvbXBhcmVfZGlyZWN0IiwiaXNfc3Vic2V0JDEiLCJvZiIsImFyZV9kaXNqb2ludCQwIiwidG9fbmFtZWRfdHJlZSIsImlzX3N1YnNldCQyIiwicGFydGl0aW9uX3RmJDAiLCJ0cmVlX2YiLCJ0cmVlX3QiLCJncm91cF9ieSQwIiwibnRoJDAiLCJyZW1vdmVfaW5kZXgkMCIsInRvX3NlcXVlbmNlJDAiLCJiaW5hcnlfc2VhcmNoJDAiLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCQwIiwibWVyZ2VfdG9fc2VxdWVuY2UkMCIsImhhc2hfZm9sZF9kaXJlY3QiLCJ0X29mX3NleHBfZGlyZWN0JDAiLCJpbnZhcmlhbnRzJDEiLCJpc19lbXB0eSQxIiwiZWxlbWVudHMkMSIsIm1pbl9lbHQkMSIsIm1pbl9lbHRfZXhuJDEiLCJtYXhfZWx0JDEiLCJtYXhfZWx0X2V4biQxIiwiY2hvb3NlJDEiLCJjaG9vc2VfZXhuJDEiLCJ0b19hcnJheSQxIiwiaXRlciQyIiwiZXhpc3RzJDEiLCJmb3JfYWxsJDEiLCJjb3VudCQxIiwic3VtJDEiLCJmaW5kJDEiLCJmaW5kX2V4biQxIiwiZmluZF9tYXAkMSIsImZvbGQkMSIsImZvbGRfdW50aWwkMSIsImZvbGRfcmlnaHQkMSIsImZpbHRlciQxIiwiZmlsdGVyX21hcCQwIiwicGFydGl0aW9uX3RmJDEiLCJpdGVyMiQxIiwibWVtJDEiLCJhZGQkMSIsInJlbW92ZSQxIiwidW5pb24kMSIsImludGVyJDEiLCJkaWZmJDEiLCJzeW1tZXRyaWNfZGlmZiQxIiwiY29tcGFyZV9kaXJlY3QkMCIsImlzX3N1YnNldCQzIiwiYXJlX2Rpc2pvaW50JDEiLCJvZl9saXN0JDAiLCJvZl9zZXF1ZW5jZSQwIiwib2ZfYXJyYXkkMCIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQkMCIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQwIiwib2Zfc29ydGVkX2FycmF5JDAiLCJ1bmlvbl9saXN0JDAiLCJzdGFibGVfZGVkdXBfbGlzdCQwIiwiZ3JvdXBfYnkkMSIsInNwbGl0JDEiLCJudGgkMSIsInJlbW92ZV9pbmRleCQxIiwib2ZfdHJlZSIsInRvX3NlcXVlbmNlJDEiLCJiaW5hcnlfc2VhcmNoJDEiLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCQxIiwibWVyZ2VfdG9fc2VxdWVuY2UkMSIsImlzX3N1YnNldCQ0IiwidG9fdHJlZSQwIiwib2ZfdHJlZSQwIiwidF9vZl9zZXhwX2RpcmVjdCQxIiwiZW1wdHkkMCIsInNpbmdsZXRvbiQwIiwidW5pb25fbGlzdCQxIiwib2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCQxIiwib2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrJDEiLCJvZl9zb3J0ZWRfYXJyYXkkMSIsIm9mX2xpc3QkMSIsIm9mX3NlcXVlbmNlJDEiLCJvZl9hcnJheSQxIiwic3RhYmxlX2RlZHVwX2xpc3QkMSIsImZpbHRlcl9tYXAkMSIsImNvbXBhcmF0b3JfcyIsImVtcHR5JDEiLCJzaW5nbGV0b24kMSIsInVuaW9uX2xpc3QkMiIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQkMiIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQyIiwib2Zfc29ydGVkX2FycmF5JDIiLCJvZl9saXN0JDIiLCJvZl9zZXF1ZW5jZSQyIiwib2ZfYXJyYXkkMiIsInN0YWJsZV9kZWR1cF9saXN0JDIiLCJmaWx0ZXJfbWFwJDIiLCJzZXhwX29mX21fdCIsIkVsdCIsIm1fdF9vZl9zZXhwIiwibV90X3NleHBfZ3JhbW1hciIsImNvbXBhcmVfbV90IiwiZXF1YWxfbV90IiwiaGFzaF9mb2xkX21fdCIsImhhc2hfbV90IiwiY29tcGFyYXRvciQwIiwiZW1wdHkkMiIsInNpbmdsZXRvbiQyIiwidW5pb25fbGlzdCQzIiwib2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCQzIiwib2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrJDMiLCJvZl9zb3J0ZWRfYXJyYXkkMyIsIm9mX2xpc3QkMyIsIm9mX3NlcXVlbmNlJDMiLCJvZl9hcnJheSQzIiwic3RhYmxlX2RlZHVwX2xpc3QkMyIsIm1hcCQzIiwiZmlsdGVyX21hcCQzIiwib2ZfdHJlZSQxIiwidG9fdHJlZSQxIiwicmVwbGFjZSIsInNldF90ZW1wb3JhcmlseSIsInJlc3RvcmVfdG8iLCJzZXRzIiwic25hcHNob3QiLCJzZXRzX3RlbXBvcmFyaWx5IiwiYW5kX3ZhbHVlcyIsImluY19udW1fbXV0YXRpb25zIiwiZWx0c19pbmRleCIsImNoZWNrX2luZGV4X2V4biIsImVuc3VyZV9ub19tdXRhdGlvbiIsIm51bV9tdXRhdGlvbnMiLCJudW1fbXV0YXRpb25zXzAwMyIsImZyb250XzAwNSIsIm1hc2tfMDA3IiwibGVuZ3RoXzAwOSIsImVsdHNfMDExIiwiYm5kc18wMDIkMSIsImJuZHNfMDAyJDIiLCJibmRzXzAwMiQzIiwibXV0MiIsIm11dDEiLCJmcm9udCIsImNhcGFjaXR5JDAiLCJjYXBhY2l0eSQxIiwiYmxpdF90b19hcnJheSIsImZyb250X2xlbiIsInJlc3RfbGVuIiwiZGVzaXJlZF9jYXBhY2l0eSIsImVucXVldWUiLCJkZXF1ZXVlX25vbmVtcHR5IiwiZGVxdWV1ZV9leG4iLCJkZXF1ZXVlIiwiZnJvbnRfbm9uZW1wdHkiLCJsYXN0X25vbmVtcHR5IiwicGVlayIsInBlZWtfZXhuIiwiYmxpdF90cmFuc2ZlciIsImxlbiQxIiwiZHN0X3N0YXJ0Iiwic3JjX2kiLCJkc3RfaSIsImVucXVldWVfYWxsIiwidF9yZXN1bHQiLCJmaWx0ZXJfaW5wbGFjZSIsImZpbHRlcmlfaW5wbGFjZSIsInVucmVhY2hhYmxlX2NvZGUiLCJ6ZXJvJDAiLCJtaW51c19vbmUiLCJ6ZXJvJDEiLCJ0b19pbnRfdHJ1bmMiLCJ0b19pbnQzMl90cnVuYyIsIm9mX2ludDY0X3RydW5jIiwibmFtZSQwIiwib2ZfY29udGludWVfb3Jfc3RvcCIsInRvX2NvbnRpbnVlX29yX3N0b3AiLCJsZWZ0X3ZhbHVlIiwicmlnaHRfdmFsdWUiLCJ2YWx1ZXMiLCJsZWZ0X2RlZmF1bHQiLCJyaWdodF9kZWZhdWx0IiwicmlnaHQkMCIsImNvbXBhcmVfa2V5IiwidmwiLCJ2bCQwIiwidnIiLCJrMCIsImsxIiwibGQiLCJscmQiLCJscmQkMCIsInJkIiwicmxkIiwicmxkJDAiLCJyYWlzZV9rZXlfYWxyZWFkeV9wcmVzZW50Iiwic2V4cF9vZl9rZXkiLCJmaW5kX2FuZF9hZGRfb3Jfc2V0IiwiZGF0YSIsImFkZF9vcl9zZXQiLCJkJDAiLCJhZGRfZXhuIiwiYWRkX2V4bl9pbnRlcm5hbCIsInNpbmdsZXRvbl90b190cmVlX2V4biIsImNvbGxhcHNlIiwiZ28iLCJhZGRfdW5jaGVja2VkIiwiZ28kMCIsInRvX3RyZWVfdW5jaGVja2VkIiwibWF4X2tleSIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UiLCJidWlsZGVyIiwicHJldl9rZXkiLCJqb2luJDAiLCJsZCQwIiwibGskMCIsInJrIiwicmQkMCIsInJrJDAiLCJsayIsImNtcCQwIiwibWF5YmUkMCIsInNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSIsImludG8iLCJib3VuZGFyeV9vcHQiLCJpbnNlcnRfaW50byIsInNwbGl0X3JhbmdlIiwibWlkX2FuZF9yaWdodCIsImxiJDEiLCJsYiQyIiwibWlkX2FuZF9yaWdodCQwIiwibGIiLCJsYiQwIiwibWlkJDAiLCJhZGRfbXVsdGkiLCJkYXRhJDAiLCJmaW5kX211bHRpIiwibG93ZXJfcGFydCIsInVwcGVyX3BhcnQiLCJtaW5fdXBwZXIiLCJtYXhfbG93ZXIiLCJ1cHBlcl9wYXJ0X3dpdGhvdXRfbWluIiwiZ28kMSIsImNfbWluIiwiaW5pdCQxIiwiY19tYXgiLCJpbml0JDIiLCJmb2xkX3JhbmdlX2luY2x1c2l2ZSIsInJhbmdlX3RvX2FsaXN0IiwiY29uY2F0X3VuY2hlY2tlZCIsInJlbW92ZV9sb29wIiwiY2hhbmdlIiwiY2hhbmdlX2NvcmUiLCJkJDEiLCJsZW5ndGgkMiIsImxlbmd0aCQzIiwidXBkYXRlIiwidXBkYXRlX2NvcmUiLCJyZW1vdmVfbXVsdGkiLCJub25fZW1wdHlfdGFpbCIsIml0ZXJfa2V5cyIsIml0ZXJpX3VudGlsX2xvb3AiLCJpdGVyaV91bnRpbCIsImZvbGRfdW50aWxfbG9vcCIsImZpbmFsJDEiLCJmaW5hbCQwIiwiZmlsdGVyX2tleXMiLCJwYXJ0aXRpb25fbWFwaSIsInBhaXIyIiwicGFpcjEiLCJjdXJyIiwiazIiLCJuZXh0JDEiLCJkYXRhX2VxdWFsIiwia2V5c19ncmVhdGVyX29yX2VxdWFsX3RvIiwia2V5c19sZXNzX29yX2VxdWFsX3RvIiwiZCQyIiwiY29tcGFyZV9kYXRhIiwiZDIiLCJkMSIsImZvbGQyJDAiLCJmb2xkX3N5bW1ldHJpY19kaWZmIiwiZGVsdGEiLCJhY2MkMyIsImFjYyQ0IiwiYWNjJDUiLCJhY2MkNiIsImFjYyQ3IiwicmlnaHQkMiIsImxlZnQkMiIsInJpZ2h0JDEiLCJrZXlzIiwib2ZfZm9sZGFibGVfZm9sZCIsImZvbGRhYmxlIiwicHJldl9kYXRhIiwib2ZfZm9sZGFibGVfcmVkdWNlIiwibmV3X2RhdGEiLCJvZl9mb2xkYWJsZSIsIm9mX2ZvbGRhYmxlX29yX2Vycm9yIiwib2ZfZm9sZGFibGVfZXhuIiwib2ZfYWxpc3RfZm9sZCIsIm9mX2FsaXN0X3JlZHVjZSIsIm9mX2FsaXN0Iiwib2ZfYWxpc3Rfb3JfZXJyb3IiLCJvZl9hbGlzdF9leG4iLCJvZl9mb2xkYWJsZV9tdWx0aSIsIm9mX2FsaXN0X211bHRpIiwiZm9sZCQyIiwib2Zfc2VxdWVuY2VfZm9sZCIsIm9mX3NlcXVlbmNlX3JlZHVjZSIsIm9mX3NlcXVlbmNlX29yX2Vycm9yIiwib2Zfc2VxdWVuY2VfZXhuIiwib2Zfc2VxdWVuY2VfbXVsdGkiLCJ0b19hbGlzdCIsImtleV9vcmRlciIsIm1lcmdlX2xhcmdlX2ZpcnN0IiwibGVuZ3RoX2xhcmdlIiwidF9sYXJnZSIsInRfc21hbGwiLCJtZXJnZV9za2V3ZWQiLCJsZW5ndGgxIiwibGVuZ3RoMiIsInJlcGFja2FnZSIsIm1hcmtlciIsImNsb3Nlc3Rfa2V5IiwiZm91bmRfbWFya2VyIiwiZm91bmRfa2V5IiwiZm91bmRfdmFsdWUiLCJmb3VuZF92YWx1ZSQwIiwiZm91bmRfa2V5JDAiLCJyYW5rIiwibnVtX3RvX3NlYXJjaCIsInBhaXIiLCJwYWlyJDAiLCJiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZCIsIm1heWJlX2JvdW5kIiwiaWZfZXhjbHVzaXZlIiwiaWZfaW5jbHVzaXZlIiwiZmluZF9ib3VuZCIsImJvdW5kJDAiLCJiaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMiLCJsb3dlcl9ib3VuZCQwIiwidXBwZXJfYm91bmQkMCIsIm9mX2l0ZXJpIiwib2ZfaXRlcmlfZXhuIiwia2V5X29mX3NleHAiLCJ2YWx1ZV9vZl9zZXhwIiwiYWxpc3Rfc2V4cHMiLCJmb3VuZF9maXJzdF9rIiwiazJfc2V4cCIsInNleHBfb2ZfdmFsdWUiLCJlcnJvcl90cmVlIiwib2tzIiwibWFwX2tleXMiLCJtYXBfa2V5c19leG4iLCJsaWtlMiIsImxpa2VfbWF5YmVfbm9fb3AiLCJvbGRfdCIsIm9sZF90cmVlIiwid2l0aF9zYW1lX2xlbmd0aCIsInNldCQxIiwiYWRkX2V4biQwIiwiYWRkX211bHRpJDAiLCJyZW1vdmVfbXVsdGkkMCIsImZpbmRfbXVsdGkkMCIsImNoYW5nZSQwIiwidXBkYXRlJDAiLCJpdGVyX2tleXMkMCIsIml0ZXJpX3VudGlsJDAiLCJmb2xkJDMiLCJmb2xkMiQxIiwiZmlsdGVyX2tleXMkMCIsImZpbHRlcmkkMCIsImZpbHRlcl9tYXBpJDAiLCJwYXJ0aXRpb25fbWFwaSQwIiwicGFydGl0aW9uX21hcCQwIiwicGFydGl0aW9uaV90ZiQwIiwiY29tYmluZV9lcnJvcnMkMCIsImtleXMkMCIsInRvX2FsaXN0JDAiLCJmb2xkX3N5bW1ldHJpY19kaWZmJDAiLCJtZXJnZSQwIiwibWVyZ2Vfc2tld2VkJDAiLCJ0cmVlJDAiLCJib3RoX2xlbiIsInN1YnJhbmdlIiwiaF9sIiwiaF9yIiwib3V0ZXJfam9pbmVkX2hlaWdodCIsIm1pZF9sZW5ndGgiLCJhcHBlbmQkMCIsImZvbGRfcmFuZ2VfaW5jbHVzaXZlJDAiLCJyYW5nZV90b19hbGlzdCQwIiwiY2xvc2VzdF9rZXkkMCIsInJhbmskMCIsInNleHBfb2ZfayIsInNleHBfb2ZfdiIsImhhc2hfZm9sZF9rZXkiLCJoYXNoX2ZvbGRfZGF0YSIsImJpbmFyeV9zZWFyY2hfc3VicmFuZ2UiLCJvZl9hbGlzdCQwIiwib2ZfYWxpc3Rfb3JfZXJyb3IkMCIsIm9mX2FsaXN0X2V4biQwIiwib2ZfYWxpc3RfbXVsdGkkMCIsIm9mX2FsaXN0X2ZvbGQkMCIsIm9mX2FsaXN0X3JlZHVjZSQwIiwib2ZfaXRlcmkkMCIsIm9mX2l0ZXJpX2V4biQwIiwicmVxdWlyZWRfYnlfaW50ZiIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UkMCIsIm9mX3NlcXVlbmNlX29yX2Vycm9yJDAiLCJvZl9zZXF1ZW5jZV9leG4kMCIsIm9mX3NlcXVlbmNlX211bHRpJDAiLCJvZl9zZXF1ZW5jZV9mb2xkJDAiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UkMCIsInNldCQyIiwiYWRkX2V4biQxIiwiYWRkX211bHRpJDEiLCJyZW1vdmVfbXVsdGkkMSIsImZpbmRfbXVsdGkkMSIsImNoYW5nZSQxIiwidXBkYXRlJDEiLCJpdGVyX2tleXMkMSIsIml0ZXJpX3VudGlsJDEiLCJtYXBpJDEiLCJmb2xkJDQiLCJmb2xkMiQyIiwiZmlsdGVyX2tleXMkMSIsImZpbHRlcmkkMSIsImZpbHRlcl9tYXBpJDEiLCJwYXJ0aXRpb25fbWFwaSQxIiwicGFydGl0aW9uX21hcCQxIiwicGFydGl0aW9uaV90ZiQxIiwiY29tYmluZV9lcnJvcnMkMSIsImtleXMkMSIsImRhdGEkMSIsInRvX2FsaXN0JDEiLCJmb2xkX3N5bW1ldHJpY19kaWZmJDEiLCJtZXJnZSQxIiwibWVyZ2Vfc2tld2VkJDEiLCJmb3JfYWxsaSQxIiwiZXhpc3RzaSQxIiwiY291bnRpJDEiLCJhcHBlbmQkMSIsInN1YnJhbmdlJDAiLCJmb2xkX3JhbmdlX2luY2x1c2l2ZSQxIiwicmFuZ2VfdG9fYWxpc3QkMSIsImNsb3Nlc3Rfa2V5JDEiLCJudGgkMiIsIm50aF9leG4kMCIsInJhbmskMSIsImtfb2Zfc2V4cCIsInZfb2Zfc2V4cCIsImJpbmFyeV9zZWFyY2hfc3VicmFuZ2UkMCIsIm1hcF9rZXlzJDAiLCJkdXAiLCJtYXBfa2V5c19leG4kMCIsImFkZF9leG4kMiIsIm9mX3RyZWUwIiwib2ZfdHJlZSQyIiwib2ZfYWxpc3QkMSIsIm9mX2FsaXN0X29yX2Vycm9yJDEiLCJvZl9hbGlzdF9leG4kMSIsIm9mX2FsaXN0X211bHRpJDEiLCJvZl9hbGlzdF9mb2xkJDEiLCJvZl9hbGlzdF9yZWR1Y2UkMSIsIm9mX2l0ZXJpJDEiLCJ0cmVlX2xlbmd0aCIsIm9mX2l0ZXJpX2V4biQxIiwib2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSQxIiwib2Zfc2VxdWVuY2Vfb3JfZXJyb3IkMSIsIm9mX3NlcXVlbmNlX2V4biQxIiwib2Zfc2VxdWVuY2VfbXVsdGkkMSIsIm9mX3NlcXVlbmNlX2ZvbGQkMSIsIm9mX3NlcXVlbmNlX3JlZHVjZSQxIiwibWFwX2tleXMkMSIsIm1hcF9rZXlzX2V4biQxIiwib2ZfdHJlZSQzIiwib2ZfYWxpc3QkMiIsIm9mX2FsaXN0X29yX2Vycm9yJDIiLCJvZl9hbGlzdF9leG4kMiIsIm9mX2FsaXN0X211bHRpJDIiLCJvZl9hbGlzdF9mb2xkJDIiLCJvZl9hbGlzdF9yZWR1Y2UkMiIsIm9mX2l0ZXJpJDIiLCJvZl9pdGVyaV9leG4kMiIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UkMiIsIm9mX3NlcXVlbmNlX29yX2Vycm9yJDIiLCJvZl9zZXF1ZW5jZV9leG4kMiIsIm9mX3NlcXVlbmNlX211bHRpJDIiLCJvZl9zZXF1ZW5jZV9mb2xkJDIiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UkMiIsIm1hcF9rZXlzJDIiLCJtYXBfa2V5c19leG4kMiIsIksiLCJ2X2dyYW1tYXIiLCJjb21wYXJlX3YiLCJlcXVhbF92IiwiaGFzaF9mb2xkX3YiLCJvZl90cmVlJDQiLCJlbXB0eSQzIiwib2ZfYWxpc3QkMyIsIm9mX2FsaXN0X29yX2Vycm9yJDMiLCJvZl9hbGlzdF9leG4kMyIsIm9mX2FsaXN0X211bHRpJDMiLCJvZl9hbGlzdF9mb2xkJDMiLCJvZl9hbGlzdF9yZWR1Y2UkMyIsIm9mX2l0ZXJpJDMiLCJvZl9pdGVyaV9leG4kMyIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UkMyIsIm9mX3NlcXVlbmNlX29yX2Vycm9yJDMiLCJvZl9zZXF1ZW5jZV9leG4kMyIsIm9mX3NlcXVlbmNlX211bHRpJDMiLCJvZl9zZXF1ZW5jZV9mb2xkJDMiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UkMyIsIm1hcF9rZXlzJDMiLCJtYXBfa2V5c19leG4kMyIsInRyYW5zZmVyIiwicSIsInEkMCIsImZsb2F0X29mX2JpdHMiLCJiaXRzX29mX2Zsb2F0IiwiYnN3YXAxNiIsImJzd2FwMzIiLCJic3dhcDQ4IiwidG9fbmF0aXZlaW50X2V4biIsIndyYXBfZXhuIiwidW53cmFwIiwiY2x6IiwiY3R6IiwiaW52YWxpZF9zdHIiLCJzaWduZWRuZXNzIiwicG9zX3N0ciIsImludDYzJDAiLCJpbnQ2MyIsIm9uZSQwIiwib2ZfbmF0aXZlaW50X3RydW5jIiwidG9fbmF0aXZlaW50X3RydW5jIiwidG9fc3RyaW5nJDEiLCJvZl9pbnRfdHJ1bmMiLCJyZXByIiwicmVwciQwIiwiaW5jbHVkZSIsIm9mX2Zsb2F0JDAiLCJ0b19mbG9hdCQwIiwib2ZfaW50X2V4biQwIiwidG9faW50X2V4biQwIiwicHAkMCIsImhhc2hhYmxlJDAiLCJpc19wb3NpdGl2ZSQwIiwiaXNfbm9uX25lZ2F0aXZlJDAiLCJpc19uZWdhdGl2ZSQwIiwiaXNfbm9uX3Bvc2l0aXZlJDAiLCJzaWduJDAiLCJpbnZhcmlhbnQkMCIsInRvX3N0cmluZ19odW0kMCIsIm1pbnVzX29uZSQwIiwicmVtJDAiLCJyb3VuZCQwIiwicm91bmRfdG93YXJkc196ZXJvJDAiLCJyb3VuZF9kb3duJDAiLCJyb3VuZF91cCQwIiwicm91bmRfbmVhcmVzdCQwIiwic3VjYyQwIiwicHJlZCQwIiwicG93JDAiLCJiaXRfYW5kJDAiLCJiaXRfb3IkMCIsImJpdF94b3IkMCIsImJpdF9ub3QkMCIsInBvcGNvdW50JDAiLCJzaGlmdF9sZWZ0JDAiLCJzaGlmdF9yaWdodCQwIiwiZGVjciQwIiwiaW5jciQwIiwib2ZfaW50MzJfZXhuJDAiLCJ0b19pbnQzMl9leG4kMCIsIm9mX2ludDY0X2V4biQwIiwidG9faW50NjQkMCIsIm9mX25hdGl2ZWludF9leG4kMCIsInRvX25hdGl2ZWludF9leG4kMCIsIm51bV9iaXRzJDAiLCJtYXhfdmFsdWUkMCIsIm1pbl92YWx1ZSQwIiwic2hpZnRfcmlnaHRfbG9naWNhbCQwIiwiY2VpbF9wb3cyJDAiLCJmbG9vcl9wb3cyJDAiLCJjZWlsX2xvZzIkMCIsImlzX3BvdzIkMCIsImNseiQwIiwiY3R6JDAiLCJvZl9pbnQkMCIsInRvX2ludCQwIiwidG9faW50X3RydW5jJDAiLCJ0b19pbnQzMiQwIiwib2ZfaW50NjQkMCIsIm9mX25hdGl2ZWludCQwIiwidG9fbmF0aXZlaW50JDAiLCJ0b19uYXRpdmVpbnRfdHJ1bmMkMCIsIm9mX2Zsb2F0X3VuY2hlY2tlZCQwIiwicmVwciQxIiwiYnN3YXAzMiQwIiwiYnN3YXA0OCQwIiwicG9zX2RpZmYiLCJuZWdhdGl2ZV9vbmUiLCJkaXZfd291bGRfb3ZlcmZsb3ciLCJwcm9kdWN0IiwiYWJzJDEiLCJuZWckMCIsInJhbmRvbV9vZl9pbnQiLCJyYW5kb21fb2ZfaW50NjQiLCJyYW5kb21fb2ZfaW50JDAiLCJyYW5kb21faW5jbF9vZl9pbnQiLCJyYW5kb21faW5jbF9vZl9pbnQ2NCIsInJhbmRvbV9pbmNsIiwiaW52IiwibGVmdF9rZXkiLCJyaWdodF9rZXkiLCJ1cGRhdGVfaGVpZ2h0Iiwib2xkX2hlaWdodCIsIm5ld19oZWlnaHQiLCJiYWxhbmNlIiwicm9vdF9ub2RlIiwibGVmdF9ub2RlIiwicmlnaHRfbm9kZSIsImxlZnRfbm9kZV9sZWZ0IiwibGVmdF9ub2RlX3JpZ2h0IiwibHJfbGVmdCIsImxyX3JpZ2h0IiwicmlnaHRfbm9kZV9sZWZ0IiwicmlnaHRfbm9kZV9yaWdodCIsInJsX2xlZnQiLCJybF9yaWdodCIsInNldF9sZWZ0Iiwibm9kZSIsInNldF9yaWdodCIsImFkZGVkIiwiZmluZGlfYW5kX2NhbGxfaW1wbCIsImFyZzEiLCJhcmcyIiwiY2FsbF9pZl9mb3VuZCIsImNhbGxfaWZfbm90X2ZvdW5kIiwiZmluZF9hbmRfY2FsbCIsImNhbGxfaWZfZm91bmQkMCIsImNhbGxfaWZfbm90X2ZvdW5kJDAiLCJmaW5kaV9hbmRfY2FsbCIsImNhbGxfaWZfZm91bmQkMSIsImNhbGxfaWZfbm90X2ZvdW5kJDEiLCJmaW5kX2FuZF9jYWxsMSIsImNhbGxfaWZfZm91bmQkMiIsImNhbGxfaWZfbm90X2ZvdW5kJDIiLCJmaW5kaV9hbmRfY2FsbDEiLCJjYWxsX2lmX2ZvdW5kJDMiLCJjYWxsX2lmX25vdF9mb3VuZCQzIiwiZmluZF9hbmRfY2FsbDIiLCJjYWxsX2lmX2ZvdW5kJDQiLCJjYWxsX2lmX25vdF9mb3VuZCQ0IiwiZmluZGlfYW5kX2NhbGwyIiwiaWZfZm91bmQkMCIsImlmX25vdF9mb3VuZCQwIiwicmVtb3ZlZCIsImtleSQ0IiwiZGF0YSQ0IiwicmtleSIsInJkYXRhIiwia2V5JDEiLCJya2V5JDAiLCJyZGF0YSQwIiwibGtleSQwIiwibGRhdGEkMCIsImtleSQzIiwiZGF0YSQzIiwicmtleSQxIiwicmRhdGEkMSIsImxrZXkiLCJsZGF0YSIsImtleSQyIiwiZGF0YSQyIiwibWFwaV9pbnBsYWNlIiwiZW5zdXJlX211dGF0aW9uX2FsbG93ZWQiLCJ3aXRob3V0X211dGF0aW5nIiwibWF4X3RhYmxlX2xlbmd0aCIsImdyb3d0aF9hbGxvd2VkIiwic2l6ZSQwIiwic2l6ZSQxIiwic2xvdCIsImFkZF93b3JrZXIiLCJuZXdfcm9vdCIsIm1heWJlX3Jlc2l6ZV90YWJsZSIsInNob3VsZF9ncm93IiwibmV3X2FycmF5X2xlbmd0aCIsIm5ld190YWJsZSIsIm9sZF90YWJsZSIsInNleHBfb2Zfa2V5JDAiLCJhZGRlZF9vcl9yZW1vdmVkIiwiYnVja2V0IiwiY2hvb3NlX25vbmVtcHR5IiwidGFibGUiLCJhdmx0cmVlIiwiaW52YXJpYW50X2tleSIsImludmFyaWFudF9kYXRhIiwicmVhbF9sZW4iLCJuZXdfdCIsInQwIiwibmV3X2RhdGEkMCIsImZpbmRfb3JfYWRkIiwiaWQiLCJmaW5kaV9vcl9hZGQiLCJmaW5kX2FuZF9yZW1vdmUiLCJ1cGRhdGVfYW5kX3JldHVybiIsImluY3JfYnkiLCJyZW1vdmVfaWZfemVybyIsImJ5IiwiY3JlYXRlX21hcHBlZCIsImdldF9rZXkiLCJnZXRfZGF0YSIsImR1cGVzIiwib2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzIiwic2V4cF9vZl9kYXRhIiwiZF9vZl9zZXhwIiwia19ncmFtbWFyIiwicm93Iiwib2xkIiwiY3JlYXRlX3dpdGhfa2V5IiwiY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yIiwiY3JlYXRlX3dpdGhfa2V5X2V4biIsIm1heWJlX3NldCIsInRfbGVmdCIsInRfcmlnaHQiLCJtZXJnZV9pbnRvIiwiZHN0X2RhdGEkMCIsImFjdGlvbiIsImRzdF9kYXRhIiwidG9fcmVtb3ZlIiwiZmlsdGVyX2tleXNfaW5wbGFjZSIsImZpbHRlcl9tYXBpX2lucGxhY2UiLCJtYXBfcmVzdWx0cyIsImZpbHRlcl9tYXBfaW5wbGFjZSIsInNpbWlsYXIiLCJvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMkMCIsImNyZWF0ZV9tYXBwZWQkMCIsImNyZWF0ZV93aXRoX2tleSQwIiwiY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yJDAiLCJjcmVhdGVfd2l0aF9rZXlfZXhuJDAiLCJvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMkMSIsImNyZWF0ZV9tYXBwZWQkMSIsImNyZWF0ZV93aXRoX2tleSQxIiwiY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yJDEiLCJjcmVhdGVfd2l0aF9rZXlfZXhuJDEiLCJncm91cCQxIiwiaGFzaGFibGVfcyIsInBvbHlfaGFzaGFibGUiLCJzdHJpY3RfYWRkIiwic3RyaWN0X2FkZF9leG4iLCJzdHJpY3RfcmVtb3ZlIiwic3RyaWN0X3JlbW92ZV9leG4iLCJzZXhwX29mX2UiLCJsYXJnZXIiLCJzbWFsbGVyIiwib2ZfaGFzaHRibF9rZXlzIiwiaGFzaHRibCIsInRvX2hhc2h0YmwiLCJlX29mX3NleHAiLCJtaW5fcG9zaXRpdmVfc3Vibm9ybWFsX3ZhbHVlIiwibWluX3Bvc2l0aXZlX25vcm1hbF92YWx1ZSIsIm9mX2ludDYzIiwiaXJvdW5kX2xib3VuZCIsImlyb3VuZF91Ym91bmQiLCJpcm91bmRfdXAiLCJpcm91bmRfdXBfZXhuIiwiaXJvdW5kX2Rvd24iLCJpcm91bmRfZG93bl9leG4iLCJpcm91bmRfdG93YXJkc196ZXJvIiwiaXJvdW5kX3Rvd2FyZHNfemVyb19leG4iLCJyb3VuZF9uZWFyZXN0X2xiIiwicm91bmRfbmVhcmVzdF91YiIsIm9uZV91bHBfbGVzc190aGFuX2hhbGYiLCJhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCIsImlyb3VuZF9uZWFyZXN0XzMyIiwiaXJvdW5kX25lYXJlc3RfNjQiLCJwaSIsInNxcnRfcGkiLCJzcXJ0XzJwaSIsImV1bGVyIiwiaXJvdW5kX25lYXJlc3RfNjQkMCIsImlyb3VuZF9uZWFyZXN0X2V4bl8zMiIsImlyb3VuZF9uZWFyZXN0X2V4bl82NCIsImlyb3VuZF9uZWFyZXN0X2V4biIsImlyb3VuZF9leG4iLCJpcm91bmQiLCJpc19pbmYiLCJpc19maW5pdGUiLCJtaW5faW5hbiIsIm1heF9pbmFuIiwic3F1YXJlIiwiZnJhY3Rpb25hbCIsImludGVncmFsIiwicm91bmRfbmVhcmVzdF9pbmxpbmUiLCJyb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiIsImNlaWxfb3Jfc3VjYyIsImRpZmZfZmxvb3IiLCJkaWZmX2NlaWwiLCJpbnQ2M19yb3VuZF9sYm91bmQiLCJpbnQ2M19yb3VuZF91Ym91bmQiLCJpbnQ2M19yb3VuZF91cF9leG4iLCJpbnQ2M19yb3VuZF9kb3duX2V4biIsImludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYSIsImludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYSIsImludDYzX3JvdW5kX25lYXJlc3RfZXhuIiwiY2xhc3NpZnkiLCJzdHJpcF96ZXJvIiwiZGVjaW1hbHMiLCJleHBsaWNpdF9wbHVzIiwidG9fcGFkZGVkX2NvbXBhY3Rfc3RyaW5nX2N1c3RvIiwia2lsbyIsIm1lZ2EiLCJnaWdhIiwidGVyYSIsInBldGEiLCJtYWciLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsImhpZ2hlciIsImRpZmZfcmlnaHQiLCJkaWZmX2xlZnQiLCJwZXRhJDAiLCJ0b19wYWRkZWRfY29tcGFjdF9zdHJpbmciLCJyb3VuZF9nZW4iLCJzZCIsImRkIiwiZGQkMCIsInNkJDAiLCJkZCQxIiwic2QkMSIsImFic19kZCIsInJvdW5kX3NpZ25pZmljYW50Iiwic2lnbmlmaWNhbnRfZGlnaXRzIiwicm91bmRfZGVjaW1hbCIsImRlY2ltYWxfZGlnaXRzIiwic2lnbl9leG4iLCJzaWduX29yX25hbiIsImllZWVfbmVnYXRpdmUiLCJtYW50aXNzYV9iaXRzIiwiZXhwb25lbnRfbWFzazY0IiwiZXhwb25lbnRfbWFzayIsIm1hbnRpc3NhX21hc2siLCJtYW50aXNzYV9tYXNrNjQiLCJpZWVlX2V4cG9uZW50IiwiaWVlZV9tYW50aXNzYSIsImNyZWF0ZV9pZWVlX2V4biIsIm5lZ2F0aXZlIiwibWFudGlzc2EiLCJzaWduX2JpdHMiLCJleHB0X2JpdHMiLCJtYW50X2JpdHMiLCJjcmVhdGVfaWVlZSIsInNwZWNpYWxpemVkX2hhc2giLCJhZGRfc3Vic3RyaW5nIiwiYWRkX3N1YmJ5dGVzIiwiZWxpZGVkX21lc3NhZ2UiLCJlbGlkZSIsImF0X21vc3RfbnVtX2ZyYW1lcyIsInRvX3N0cmluZ19saXN0Iiwic2V0X3JlY29yZGluZyIsImFtX3JlY29yZGluZyIsIm1vc3RfcmVjZW50IiwibW9zdF9yZWNlbnRfZm9yX2V4biIsIndpdGhfcmVjb3JkaW5nIiwic2F2ZWQiLCJvY2FtbHJ1bnBhcmFtX21lbnRpb25zX2JhY2t0cmEiLCJhcnJheV9vZl9zZXhwIiwic2V4cF9vZl9hcnJheSIsImFycmF5X3NleHBfZ3JhbW1hciIsImJvb2xfb2Zfc2V4cCIsInNleHBfb2ZfYm9vbCIsImJvb2xfc2V4cF9ncmFtbWFyIiwiY2hhcl9vZl9zZXhwIiwic2V4cF9vZl9jaGFyIiwiY2hhcl9zZXhwX2dyYW1tYXIiLCJzZXhwX29mX2V4biIsImZ1bmMkMSIsImZsb2F0X29mX3NleHAiLCJzZXhwX29mX2Zsb2F0IiwiZmxvYXRfc2V4cF9ncmFtbWFyIiwiZnVuYyQyIiwiaW50X29mX3NleHAiLCJzZXhwX29mX2ludCIsImludF9zZXhwX2dyYW1tYXIiLCJmdW5jJDMiLCJpbnQzMl9vZl9zZXhwIiwic2V4cF9vZl9pbnQzMiIsImludDMyX3NleHBfZ3JhbW1hciIsImZ1bmMkNCIsImludDY0X29mX3NleHAiLCJzZXhwX29mX2ludDY0IiwiaW50NjRfc2V4cF9ncmFtbWFyIiwibGlzdF9vZl9zZXhwIiwic2V4cF9vZl9saXN0IiwibGlzdF9zZXhwX2dyYW1tYXIiLCJmdW5jJDUiLCJuYXRpdmVpbnRfb2Zfc2V4cCIsInNleHBfb2ZfbmF0aXZlaW50IiwibmF0aXZlaW50X3NleHBfZ3JhbW1hciIsIm9wdGlvbl9vZl9zZXhwIiwic2V4cF9vZl9vcHRpb24iLCJvcHRpb25fc2V4cF9ncmFtbWFyIiwicmVmX29mX3NleHAiLCJzZXhwX29mX3JlZiIsInJlZl9zZXhwX2dyYW1tYXIiLCJzdHJpbmdfb2Zfc2V4cCIsInNleHBfb2Zfc3RyaW5nIiwic3RyaW5nX3NleHBfZ3JhbW1hciIsImNvbXBhcmVfYnl0ZXMiLCJlcXVhbF9ieXRlcyIsImJ5dGVzX29mX3NleHAiLCJzZXhwX29mX2J5dGVzIiwiYnl0ZXNfc2V4cF9ncmFtbWFyIiwiZnVuYyQ2IiwidW5pdF9vZl9zZXhwIiwic2V4cF9vZl91bml0IiwidW5pdF9zZXhwX2dyYW1tYXIiLCJmYWlsd2l0aCIsImludmFsaWRfYXJnIiwiY29tcGFyZV9hcnJheSQwIiwiZXF1YWxfYXJyYXkkMCIsImFycmF5X29mX3NleHAkMCIsInNleHBfb2ZfYXJyYXkkMCIsImFycmF5X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9ib29sJDAiLCJlcXVhbF9ib29sJDAiLCJoYXNoX2ZvbGRfYm9vbCQwIiwiaGFzaF9ib29sJDAiLCJib29sX29mX3NleHAkMCIsInNleHBfb2ZfYm9vbCQwIiwiYm9vbF9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfY2hhciQwIiwiZXF1YWxfY2hhciQwIiwiaGFzaF9mb2xkX2NoYXIkMCIsImhhc2hfY2hhciQwIiwiY2hhcl9vZl9zZXhwJDAiLCJzZXhwX29mX2NoYXIkMCIsImNoYXJfc2V4cF9ncmFtbWFyJDAiLCJzZXhwX29mX2V4biQwIiwiY29tcGFyZV9mbG9hdCQwIiwiZXF1YWxfZmxvYXQkMCIsImhhc2hfZm9sZF9mbG9hdCQwIiwiaGFzaF9mbG9hdCQwIiwiZmxvYXRfb2Zfc2V4cCQwIiwic2V4cF9vZl9mbG9hdCQwIiwiZmxvYXRfc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX2ludCQwIiwiZXF1YWxfaW50JDAiLCJoYXNoX2ZvbGRfaW50JDAiLCJoYXNoX2ludCQwIiwiaW50X29mX3NleHAkMCIsInNleHBfb2ZfaW50JDAiLCJpbnRfc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX2ludDMyJDAiLCJlcXVhbF9pbnQzMiQwIiwiaGFzaF9mb2xkX2ludDMyJDAiLCJoYXNoX2ludDMyJDAiLCJpbnQzMl9vZl9zZXhwJDAiLCJzZXhwX29mX2ludDMyJDAiLCJpbnQzMl9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfaW50NjQkMCIsImVxdWFsX2ludDY0JDAiLCJoYXNoX2ZvbGRfaW50NjQkMCIsImhhc2hfaW50NjQkMCIsImludDY0X29mX3NleHAkMCIsInNleHBfb2ZfaW50NjQkMCIsImludDY0X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9saXN0JDAiLCJlcXVhbF9saXN0JDAiLCJoYXNoX2ZvbGRfbGlzdCQwIiwibGlzdF9vZl9zZXhwJDAiLCJzZXhwX29mX2xpc3QkMCIsImxpc3Rfc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX25hdGl2ZWludCQwIiwiZXF1YWxfbmF0aXZlaW50JDAiLCJoYXNoX2ZvbGRfbmF0aXZlaW50JDAiLCJoYXNoX25hdGl2ZWludCQwIiwibmF0aXZlaW50X29mX3NleHAkMCIsInNleHBfb2ZfbmF0aXZlaW50JDAiLCJuYXRpdmVpbnRfc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX29wdGlvbiQwIiwiZXF1YWxfb3B0aW9uJDAiLCJoYXNoX2ZvbGRfb3B0aW9uJDAiLCJvcHRpb25fb2Zfc2V4cCQwIiwic2V4cF9vZl9vcHRpb24kMCIsIm9wdGlvbl9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfcmVmJDAiLCJlcXVhbF9yZWYkMCIsInJlZl9vZl9zZXhwJDAiLCJzZXhwX29mX3JlZiQwIiwicmVmX3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9zdHJpbmckMCIsImVxdWFsX3N0cmluZyQwIiwiaGFzaF9mb2xkX3N0cmluZyQwIiwiaGFzaF9zdHJpbmckMCIsInN0cmluZ19vZl9zZXhwJDAiLCJzZXhwX29mX3N0cmluZyQwIiwic3RyaW5nX3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9ieXRlcyQwIiwiZXF1YWxfYnl0ZXMkMCIsImJ5dGVzX29mX3NleHAkMCIsInNleHBfb2ZfYnl0ZXMkMCIsImJ5dGVzX3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV91bml0JDAiLCJlcXVhbF91bml0JDAiLCJoYXNoX2ZvbGRfdW5pdCQwIiwiaGFzaF91bml0JDAiLCJ1bml0X29mX3NleHAkMCIsInNleHBfb2ZfdW5pdCQwIiwidW5pdF9zZXhwX2dyYW1tYXIkMCIsInJhaXNlX3MkMCIsInBoeXNfZXF1YWwkMCJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9wb2x5MC5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9pbXBvcnQwLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3ByaW50Zi5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9zeXMwLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2FycmF5MC5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9jaGFyMC5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9pbnQwLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2xpc3QwLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2hhc2gubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvcHB4X2NvbXBhcmVfbGliLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3BweF9oYXNoX2xpYi5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9zZXhwLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3dvcmRfc2l6ZS5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9wcmV0dHlfcHJpbnRlci5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9leG4ubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvd2l0aF9yZXR1cm4ubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvbW9uYWRfaW50Zi5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9tb25hZC5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9hcHBsaWNhdGl2ZS5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9ieXRlczAubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvY29tcGFyYXRvci5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9laXRoZXIwLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2ZpZWxkLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3N0cmluZzAubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvc291cmNlX2NvZGVfcG9zaXRpb24wLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2xpc3QxLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3Jlc3VsdC5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9jb250YWluZXJfaW50Zi5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9jb250YWluZXIubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvbGF6eS5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9vcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMC5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9yYW5kb21fcmVwci5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9yYW5kb20ubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvYXJyYXlfcGVybXV0ZS5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9mbi5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9vcmRlcmluZy5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9saXN0Lm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2luZm8ubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvZXJyb3IubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvaW52YXJpYW50Lm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL29yX2Vycm9yLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3NpZ24wLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2NvbXBhcmFibGUubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvaGFzaGFibGVfaW50Zi5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9pZGVudGlmaWFibGUubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvdW5pdC5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9vcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2JpbmFyeV9zZWFyY2gubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvYmluYXJ5X3NlYXJjaGFibGVfaW50Zi5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9iaW5hcnlfc2VhcmNoYWJsZS5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9ibGl0Lm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL29wdGlvbi5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9zZXhwYWJsZS5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9laXRoZXIubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvaW5kZXhlZF9jb250YWluZXIubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvc2VxdWVuY2UubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvYXJyYXkubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvb2JqX2FycmF5Lm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3VuaWZvcm1fYXJyYXkubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvZmxvYXQwLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2NoYXIubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvcHB4X2VudW1lcmF0ZV9saWIubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvYnl0ZXNfdHIubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvc3RhZ2VkLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3N0cmluZy5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9ieXRlcy5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9oZXhfbGV4ZXIubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvaW50X2NvbnZlcnNpb25zLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3Bvd19vdmVyZmxvd19ib3VuZHMubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvaW50X21hdGgubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvcG9wY291bnQubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvc2lnbi5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9pbnQubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvdWNoYXIubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvdHlwZV9lcXVhbC5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9vcHRpb25fYXJyYXkubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvc3RhY2subWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvc291cmNlX2NvZGVfcG9zaXRpb24ubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvc2lnbl9vcl9uYW4ubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvbWF5YmVfYm91bmQubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvbWFwX2ludGYubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvc2V0X2ludGYubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2Uvc2V0Lm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL3JlZi5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9xdWV1ZS5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9ub3RoaW5nLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL25hdGl2ZWludC5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9tYXAubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvbGlua2VkX3F1ZXVlMC5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9saW5rZWRfcXVldWUubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvaW50NjQubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvaW50NjNfZW11bC5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9ib29sLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2ludDMyLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2ludDYzLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2hhc2h0YmxfaW50Zi5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9hdmx0cmVlLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2hhc2h0YmwubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvaGFzaF9zZXQubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvZmxvYXQubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2UvYnVmZmVyLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlL2JhY2t0cmFjZS5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZS9iYXNlLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7WUFnQklBLFdBQVdDLEdBQUVDLEdBQUksT0FBQSxhQUFKQSxHQUFGRCxHQUFpQjs7SUFDNUJFO0lBQ0FDO21DQUZBSixZQUVBSSxLQURBRDs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0dDNEJVOzs7Ozs7SUF2Q1ZFO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF1Q1U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBd0ZWQyxZQUFhckYsR0FBa0IsT0FBbEJBLEVBQWtDO1lBSy9Dc0YsbUI7T0FDQUM7WUFDQUMsbUI7WUFDQUMsbUI7WUFDQUMsbUI7WUFDQUMsbUI7WUFDQUMsbUI7WUFDQUMsbUI7T0FDQUM7WUFDQUMsb0I7T0FnQkVDO1lBQ0FqRyxXQUFZQyxHQUFTQyxHQUFJLHdCQUFKQSxHQUFURCxHQUF3QjtZQUNwQ2lHLE1BQUtqRyxHQUFTQyxHQUFJLE9BQUpBLEtBQVRELElBQUFBLElBQVNDLEVBQTJCO1lBQ3pDaUcsTUFBS2xHLEdBQVNDLEdBQUksT0FBYkQsS0FBU0MsSUFBVEQsSUFBU0MsRUFBMkI7R0FmTjtJQUFBLHFDQVluQytGLFdBQ0FqRyxZQUNBa0csT0FDQUM7SUFIQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFNQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7WUFDQUMsWUFBVzdHLEdBQWtCQyxHQUFJLE9BQUEsMEJBQXRCRCxHQUFrQkMsR0FBc0I7WUFDbkQ2RyxhQUFZOUcsR0FBa0JDLEdBQUksT0FBQSwwQkFBdEJELEdBQWtCQyxHQUF1QjtPQUNyRDhHLDRCQUNBQztZQUNBQyxNQUxRakgsR0FBa0JDLEdBS0MsT0FMRyxrQkFBdEJELEdBQWtCQyxLQUFsQkQsSUFBa0JDLEVBS3dCO1lBQ2xEaUgsTUFWUWxILEdBQWtCQyxHQVVDLE9BVkcsZUFBdEJELEdBQWtCQyxLQUFsQkQsSUFBa0JDLEVBVXdCO0dBWmI7OztPQUNyQ3NHO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO1lBZUFDLFlBQVduSCxHQUFrQkMsR0FBSSxPQUFBLDBCQUF0QkQsR0FBa0JDLEdBQXNCO1lBQ25EbUgsYUFBWXBILEdBQWtCQyxHQUFJLE9BQUEsMEJBQXRCRCxHQUFrQkMsR0FBdUI7WUFDckRvSCxNQUFLckgsR0FBa0JDLEdBQUksT0FBRyxrQkFBekJELEdBQWtCQyxLQUFsQkQsSUFBa0JDLEVBQTJCO1lBQ2xEcUgsTUFBS3RILEdBQWtCQyxHQUFJLE9BQUcsZUFBekJELEdBQWtCQyxLQUFsQkQsSUFBa0JDLEVBQTJCO0dBZmI7SUFBQTtVQVlyQ2tILGFBQ0FDLGNBQ0FDLE9BQ0FDO0lBSUFDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO1lBQ0FDLFlBQVc3SCxHQUFzQkMsR0FBSSxPQUFBLDBCQUExQkQsR0FBc0JDLEdBQXNCO1lBQ3ZENkgsYUFBWTlILEdBQXNCQyxHQUFJLE9BQUEsMEJBQTFCRCxHQUFzQkMsR0FBdUI7T0FDekQ4SCw4QkFDQUM7WUFDQUMsTUFMUWpJLEdBQXNCQyxHQUtDLE9BTEcsa0JBQTFCRCxHQUFzQkMsS0FBdEJELElBQXNCQyxFQUt3QjtZQUN0RGlJLE1BVlFsSSxHQUFzQkMsR0FVQyxPQVZHLGVBQTFCRCxHQUFzQkMsS0FBdEJELElBQXNCQyxFQVV3QjtHQVpiOzs7T0FDekNzSDtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztZQUlBQyxVQUFPbkksR0FBVUMsR0FBSSxPQUFkRCxJQUFVQyxVQUFrQjtZQUNuQ21JLFVBQVFwSSxHQUFVQyxHQUFJLE9BQWRELEtBQVVDLFVBQW1CO1lBQ3JDb0ksVUFBUXJJLEdBQVVDLEdBQUksT0FBZEQsTUFBVUMsVUFBbUI7WUFDckNxSSxVQUFPdEksR0FBVUMsR0FBSSxPQUFkRCxNQUFVQyxVQUFrQjtZQUNuQ3NJLFVBQU92SSxHQUFVQyxHQUFJLE9BQUpBLElBQVZELFVBQTRCO1lBQ25Dd0ksVUFBUXhJLEdBQVVDLEdBQUksT0FBSkEsS0FBVkQsVUFBNkI7WUFDckN5SSxZQUFXekksR0FBVUMsR0FBSSxPQUFBLDBCQUFkRCxHQUFVQyxHQUFzQjtZQUMzQ3lJLGFBQVkxSSxHQUFVQyxHQUFJLE9BQUEsMEJBQWRELEdBQVVDLEdBQXVCO09BQzdDMEk7WUFDQUMsUUFBTzVJLEdBQVVDLEdBQUksT0FBZEQsTUFBVUMsVUFBa0I7WUFDbkM0SSxNQUxRN0ksR0FBVUMsR0FLQyxPQUxEQSxLQUFWRCxJQUFBQSxJQUFVQyxFQUt3QjtZQUMxQzZJLE1BVlE5SSxHQUFVQyxHQVVDLE9BVlhELEtBQVVDLElBQVZELElBQVVDLEVBVXdCO0dBWk47OztPQUNwQ2tJO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO1lBSUFDLFVBQU8vSSxHQUFVQyxHQUFJLE9BQWRELElBQVVDLFVBQWtCO1lBQ25DK0ksVUFBUWhKLEdBQVVDLEdBQUksT0FBZEQsS0FBVUMsVUFBbUI7WUFDckNnSixVQUFRakosR0FBVUMsR0FBSSxPQUFkRCxNQUFVQyxVQUFtQjtZQUNyQ2lKLFVBQU9sSixHQUFVQyxHQUFJLE9BQWRELE1BQVVDLFVBQWtCO1lBQ25Da0osVUFBT25KLEdBQVVDLEdBQUksT0FBSkEsSUFBVkQsVUFBNEI7WUFDbkNvSixVQUFRcEosR0FBVUMsR0FBSSxPQUFKQSxLQUFWRCxVQUE2QjtZQUNyQ3FKLFlBQVdySixHQUFVQyxHQUFJLE9BQUEsMEJBQWRELEdBQVVDLEdBQXNCO1lBQzNDcUosYUFBWXRKLEdBQVVDLEdBQUksT0FBQSwwQkFBZEQsR0FBVUMsR0FBdUI7T0FDN0NzSjtZQUNBQyxRQUFPeEosR0FBVUMsR0FBSSxPQUFkRCxNQUFVQyxVQUFrQjtZQUNuQ3dKLE1BTFF6SixHQUFVQyxHQUtDLE9BTERBLEtBQVZELElBQUFBLElBQVVDLEVBS3dCO1lBQzFDeUosTUFWUTFKLEdBQVVDLEdBVUMsT0FWWEQsS0FBVUMsSUFBVkQsSUFBVUMsRUFVd0I7R0FaTjs7O09BQ3BDOEk7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7WUFJQUMsRUFBRTNKLEdBQUksT0FBQSw2QkFBSkEsR0FBdUI7WUFDekI0SixVQUFPNUosR0FBa0JDLEdBQWdELFVBRHpFMEosRUFDeUIxSixJQUEwQyxPQURuRTBKLEVBQ08zSixpQkFBdUU7WUFDOUU2SixVQUFRN0osR0FBa0JDLEdBQWlELFVBRjNFMEosRUFFMEIxSixJQUEyQyxPQUZyRTBKLEVBRVEzSixrQkFBd0U7WUFDaEY4SixVQUFROUosR0FBa0JDLEdBQWlELFVBSDNFMEosRUFHMEIxSixJQUEyQyxPQUhyRTBKLEVBR1EzSixtQkFBd0U7WUFDaEYrSixVQUFPL0osR0FBa0JDLEdBQWdELFVBSnpFMEosRUFJeUIxSixJQUEwQyxPQUpuRTBKLEVBSU8zSixtQkFBdUU7WUFDOUVnSyxVQUFPaEssR0FBa0JDLEdBQWdELFVBTHpFMEosRUFLeUIxSixJQUEwQyxhQUxuRTBKLEVBS08zSixXQUF1RTtZQUM5RWlLLFVBQVFqSyxHQUFrQkMsR0FBaUQsVUFOM0UwSixFQU0wQjFKLElBQTJDLGNBTnJFMEosRUFNUTNKLFdBQXdFO1lBRWhGa0ssWUFBV2xLLEdBQWtCQztJQUMvQixJQUFnRCxNQVQ5QzBKLEVBUTZCMUosSUFDVyxNQVR4QzBKLEVBUVczSjtJQUNtQyxPQUFBO0dBQUs7WUFHbkRtSyxhQUFZbkssR0FBa0JDO0lBQ2hDLElBQWlELE1BYi9DMEosRUFZOEIxSixJQUNXLE1BYnpDMEosRUFZWTNKO0lBQ21DLE9BQUE7R0FBSztZQUdwRG9LLFVBQVNwSyxHQUFrQkM7SUFBa0QsVUFoQjdFMEosRUFnQjJCMUo7SUFBNEMsT0FBQSxpQkFoQnZFMEosRUFnQlMzSjtHQUF5RTtZQUNsRnFLLFFBQU9ySyxHQUFrQkMsR0FBZ0QsVUFqQnpFMEosRUFpQnlCMUosSUFBMEMsT0FqQm5FMEosRUFpQk8zSixtQkFBdUU7WUFDOUVzSyxNQUFLdEssR0FBa0JDLEdBQUksT0FaM0JnSyxVQVlLakssR0FBa0JDLEtBQWxCRCxJQUFrQkMsRUFBMkI7WUFDbERzSyxNQUFLdkssR0FBa0JDLEdBQUksT0FqQjNCNEosVUFpQks3SixHQUFrQkMsS0FBbEJELElBQWtCQyxFQUEyQjtHQXBCYjs7O09BQ3JDMEo7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FFQUM7T0FJQUM7T0FJQUM7T0FDQUM7T0FDQUM7T0FDQUM7WUFJQUMsVUFBT3hLLEdBQVdDLEdBQUksT0FBZkQsSUFBV0MsVUFBa0I7WUFDcEN3SyxVQUFRekssR0FBV0MsR0FBSSxPQUFmRCxLQUFXQyxVQUFtQjtZQUN0Q3lLLFVBQVExSyxHQUFXQyxHQUFJLE9BQWZELEtBQVdDLFVBQW1CO1lBQ3RDMEssVUFBTzNLLEdBQVdDLEdBQUksT0FBZkQsS0FBV0MsVUFBa0I7WUFDcEMySyxVQUFPNUssR0FBV0MsR0FBSSxPQUFKQSxJQUFYRCxVQUE2QjtZQUNwQzZLLFVBQVE3SyxHQUFXQyxHQUFJLE9BQUpBLEtBQVhELFVBQThCO1lBQ3RDOEssWUFBVzlLLEdBQVdDLEdBQUksT0FBQSwwQkFBZkQsR0FBV0MsR0FBc0I7WUFDNUM4SyxhQUFZL0ssR0FBV0MsR0FBSSxPQUFBLDBCQUFmRCxHQUFXQyxHQUF1QjtPQUM5QytLO1lBQ0FDLFFBQU9qTCxHQUFXQyxHQUFJLE9BQWZELEtBQVdDLFVBQWtCO1lBQ3BDaUwsTUFMUWxMLEdBQVdDLEdBS0MsT0FMREEsS0FBWEQsSUFBQUEsSUFBV0MsRUFLd0I7WUFDM0NrTCxNQVZRbkwsR0FBV0MsR0FVQyxPQVZaRCxLQUFXQyxJQUFYRCxJQUFXQyxFQVV3QjtHQVpOO0lBQUE7O09BQ3JDdUs7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7SUFJQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7WUFDQUMsWUFBVzFMLEdBQVlDLEdBQUksT0FBQSwwQkFBaEJELEdBQVlDLEdBQXNCO1lBQzdDMEwsYUFBWTNMLEdBQVlDLEdBQUksT0FBQSwwQkFBaEJELEdBQVlDLEdBQXVCO09BQy9DMkwseUNBQ0FDO1lBQ0FDLE1BTFE5TCxHQUFZQyxHQUtDLE9BTEcseUJBQWhCRCxHQUFZQyxLQUFaRCxJQUFZQyxFQUt3QjtZQUM1QzhMLE1BVlEvTCxHQUFZQyxHQVVDLE9BVkcsc0JBQWhCRCxHQUFZQyxLQUFaRCxJQUFZQyxFQVV3QjtHQVpOO0lBQUE7O09BQ3RDbUw7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7SUFJQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7WUFDQUMsWUFBV3RNLEdBQVdDLEdBQUksT0FBQSwwQkFBZkQsR0FBV0MsR0FBc0I7WUFDNUNzTSxhQUFZdk0sR0FBV0MsR0FBSSxPQUFBLDBCQUFmRCxHQUFXQyxHQUF1QjtPQUM5Q3VNLHdDQUNBQztZQUNBQyxPQUxRMU0sR0FBV0MsR0FLQyxPQUxHLHdCQUFmRCxHQUFXQyxLQUFYRCxJQUFXQyxFQUt3QjtZQUMzQzBNLE9BVlEzTSxHQUFXQyxHQVVDLE9BVkcscUJBQWZELEdBQVdDLEtBQVhELElBQVdDLEVBVXdCO0dBWk47SUFBQTs7T0FDckMrTDtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztJQVlGQztJQUNBQztZQUNBQyxlO1lBQ0FDLGU7WUFDQUMsYztZQUNBQyxlO09BQ0FDO1lBQ0FDLGM7WUFDQUMsYztZQUNBQyxjO1lBQ0FDLGU7T0FDQUMsd0JBQ0FDLG9CQUNBQztZQUNBQyxTO09BQ0FDO1lBQ0FDLFM7WUFNQUMscUI7WUFDQUMsVTtZQUNBQyxVO0dBV2E7SUFSYkM7SUFRQUMsYUFBYTs7Ozs7T0FuV2I3STtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDs7T0ErSEFpRjtPQUtBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQzs7T0FnQkVJO09BQ0FDO09BQ0FDO09BQ0FDOzs7Ozs7Ozs7O09BZ0tGc0c7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FNQUM7T0FDQUM7T0FDQUM7T0FHQUM7T0FRQUM7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7WUNwV0FDLFVBQVVDO0lBQU0sT0FBQTs7c0JBQWNDLFVBQVEsT0FBQSw4QkFBUkEsR0FBa0I7YUFBdENEO0dBQTJDO1lBQ3JERSxhQUFhRjtJQUFNLE9BQUE7O3NCQUFjQyxVQUFRLE9BQUEsOEJBQVJBLEdBQXFCO2FBQXpDRDtHQUE4Qzs7Ozs7Ozs7O09BRDNERDtPQUNBRzs7O0U7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7Ozs7Ozs7SUNVQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7WUFDQUMsZ0JBQWMsd0JBQWE7O0lBQzNCQztJQUNBQztJQUNBQzs7Ozs7OztZQUVBQyxXQUFXQztJQUNiLElBQUksVUFBQSxnQkFEU0EsUUFDVDs7OztNQUVGLE9BQUEsZ0NBSFdBOzs7R0FHaUU7WUFHNUVDLE9BQU9EO0lBQ1QsSUFBTSxJQUNKelAsSUFESSxnQkFER3lQOzs7dUNBR3FCOzs7SUFEdkIsV0FBTHpQO0dBQ2dDOzs7OztPQTVCaENzTztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUVBQztPQU1BRTs7OztFOzs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7R0MxQlc7OztJQUZYckI7SUFFVztJQXFCWHNCO1lBRUFDLE9BQVFDLEtBQUk3UCxHQUNkLE9BQUksdUJBRE02UCxLQUFJN1AsR0FFb0U7WUFHaEY4UCwyQkFBNEJEO0lBQzlCLE9BQUksNkJBRDBCQTtHQUdrRDs7SUFHOUVFO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO1lBSUFDLEtBQUtDLEdBQUdOLE1BQU1PO0lBQUksT0FBQSxtQ0FBSkEsR0FBTlAsTUFBSE07R0FBNEM7WUFDakRFLFdBQVdGLEdBQUdDLEdBQUdQO0lBQU8sT0FBQSxtQ0FBVk8sR0FBSEQsR0FBTU47R0FBdUM7WUFDeERTLEtBQUtILEdBQUdDLEdBQUksT0FBQSxtQ0FBSkEsR0FBSEQsR0FBMkI7WUFDaENJLE1BQU1KLEdBQUdDLEdBQUksT0FBQSxtQ0FBSkEsR0FBSEQsR0FBNEI7WUFDbENLLElBQUlMLEdBQUdDLEdBQUksT0FBQSxtQ0FBSkEsR0FBSEQsR0FBMEI7WUFDOUJNLEtBQUtOLEdBQUdDLEdBQUksT0FBQSxtQ0FBSkEsR0FBSEQsR0FBMkI7WUFDaENPLFlBQVlQLEdBQUczSjtJQUFVLE9BQUEsbUNBQVZBLFNBQUgySjtHQUFrRDtZQUU5RFEsS0FBS1IsR0FBRS9HLEdBQUV3SDtJQUNYO0tBQUlDLHlCQURHVixHQUFFL0csT0FBQUE7S0FFTDBILHlCQUZHWCxHQUFJUyxPQUFBQTtJQUFKVCxNQUFFL0csS0FFTDBIO0lBRkdYLE1BQUlTLEtBQ1BDO0lBR0o7R0FBb0I7Ozs7T0E3RGxCL0M7O09BdUJBc0I7T0FFQUM7T0FLQUU7T0FNQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FJQUM7T0FDQUc7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FFQUM7OztFOzs7Ozs7Ozs7Rzs7Ozs7Ozs7O0lDNURBaEQ7SUFDQW9EO0lBQ0FDO1lBQ0FDLFk7WUFDQUMsbUI7R0FBZ0IsSUFDaEJDO1lBS0FDLFVBQVVoSTtJQUFJLGVBQUpBLHVCQUFBQTs7R0FBc0I7Ozs7OztZQUdoQ2lJLE9BQU9qSSxHQUFJLE9BSFhnSSxVQUdPaEksU0FBQUEsT0FBd0Q7WUFFL0RrSSxXQUFXbEk7SUFDYixPQU5FZ0ksVUFLV2hJLEtBQUFBLElBR1IsV0FsQkh1RSxnQkFlV3ZFO0dBR3FEO1lBR2hFM0MsTUFBTzhLLElBQVdDLElBQUssT0FBaEJELE9BQVdDLFdBQXFCOzs7O09BckJ2QzdEO09BQ0FvRDtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUtBQzs7O09BR0FDO09BRUFDO09BTUE3Szs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7SUNmQWdMO0lBQ0FDO1lBQ0FDLGM7WUFDQUMsYztHQUFXLElBQ1hDLHNCQUNBQztZQUNBQyxVOzs7O09BTkFOO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDOzs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7O0lDWkFDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO1lBSUFDLE9BQU9sQyxHQUFHQyxHQUFJLE9BQUEsa0NBQUpBLEdBQUhELEdBQTRCO1lBQ25DbUMsV0FBV0MsSUFBR0MsSUFBSXBDO0lBQUksT0FBQSxrQ0FBSkEsR0FBUG1DLElBQUdDO0dBQWtDO1lBQ2hEdEMsS0FBS0MsR0FBR04sTUFBTU87SUFBSSxPQUFBLGtDQUFKQSxHQUFOUCxNQUFITTtHQUEyQztZQUNoRHNDLFNBQVNGLElBQUdDLElBQUkzQyxNQUFNTztJQUFJLE9BQUEsa0NBQUpBLEdBQU5QLE1BQVAwQyxJQUFHQztHQUFpRDtZQUM3REUsUUFBUXZDLEdBQUdDLEdBQUksT0FBQSxrQ0FBSkEsR0FBSEQsR0FBNkI7WUFDckN3QyxZQUFZSixJQUFHQyxJQUFJcEM7SUFBSSxPQUFBLGtDQUFKQSxHQUFQbUMsSUFBR0M7R0FBbUM7WUFDbERsQyxLQUFLSCxHQUFHQyxHQUFJLE9BQUEsa0NBQUpBLEdBQUhELEdBQTBCO1lBQy9CeUMsU0FBU0wsSUFBR0MsSUFBSXBDO0lBQUksT0FBQSxrQ0FBSkEsR0FBUG1DLElBQUdDO0dBQWdDO1lBQzVDSyxZQUFZMUMsR0FBR0MsR0FBSSxPQUFBLGtDQUFKQSxHQUFIRCxHQUF5QjtZQUNyQzJDLGFBQWEzQyxHQUFHQztJQUFJLE9BQUEsa0NBQUpBLEdBQUhEO0dBQTBCO1lBQ3ZDNEMsVUFBVTVDLEdBQUdDLEdBQUksT0FBQSxrQ0FBSkEsR0FBSEQsR0FBK0I7WUFDekM2QyxRQUFRN0MsR0FBR0MsR0FBSSxPQUFBLGtDQUFKQSxHQUFIRCxHQUE2QjtZQUNyQzhDLFlBQVlWLElBQUdDLElBQUlwQztJQUFJLE9BQUEsa0NBQUpBLEdBQVBtQyxJQUFHQztHQUFtQztZQUNsRFUsS0FBS0MsR0FBRzNNO0lBQVUsT0FBQSxrQ0FBVkEsU0FBSDJNO0dBQTBDO1lBQy9DekMsWUFBWXlDLEdBQUczTTtJQUFVLE9BQUEsa0NBQVZBLFNBQUgyTTtHQUFpRDtZQUU3REMsSUFDQUM7SUFETSxHQUNOQTtpQkFBQUE7O1VBQ1VDLGlCQUFMNVQsY0FBTEQsSUFEQTRUO01BQ2tDLE9BQUEsV0F4QmxDbkIsWUF3QlVvQixVQUFMNVQsT0FBTEQ7OztJQUR1QixPQUF2QjRUO0dBQzBDO1lBRzFDaEQsV0FBVzhDLEdBQUcvQyxHQUFHUDtJQUNuQixPQURhc0Q7Y0FuQlhqRCxLQWNBa0QsSUFLV0QsSUFBTXRELGVBR0MwRCxHQUFFQyxHQUFLLE9BQUEsV0FIWHBELEdBR01vRCxHQUFGRCxHQUFZO2NBSGIxRDtHQUc0Qjs7OztPQWhDN0NtQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUlBQztPQUNBQztPQUNBcEM7T0FDQXVDO09BQ0FDO09BQ0FDO09BQ0FyQztPQUNBc0M7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQXhDO09BRUEwQztPQUtBL0M7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7YUNIRW9ELGVBQWU1RixVQUFPLE9BQVBBLEVBQVE7O0tBQ3ZCNkY7S0FDQUM7S0FDQUM7S0FDQUM7YUFDQUMsT0FBTzFELEdBQUV2QyxHQUFFcE87S0FBSSxPQUFnQixXQUovQmlVLGVBSVM3RixHQUFzQixXQUF4QnVDLEdBQUkzUTtJQUF5Qjt1QjtJQUlsQixTQUFsQnNVLDRCLE9BSkFEO0lBSWtCO0lBQ0QsU0FBakJFLDJCLE9BTEFGO3dCQVFLLHFCQUVRO0lBRmYsU0FERUcsMkIsT0FQQUg7YUFhQUksb0JBQW9CckcsR0FBRXBPO0tBQUksT0FBa0IsV0FoQjVDa1UsaUJBZ0JvQjlGLEdBQXdCLDRCQUF0QnBPO0lBQWlEO2FBRXZFMFUsaUJBQWlCQyxnQkFBZXZHO0ssWUFDeEIsT0FBQSxXQXBCUjZGLGVBbUJnQzdGO1NBRTNCcE87S0FBSyxPQUFBLFdBRk8yVSxnQkFFUSxXQXJCekJWLGVBbUJnQzdGLE9BRTNCcE87O2FBU0w0VSxlQUFlRCxnQkFBZUUsS0FBRUM7S0FLbEM7TUFYeUNDLE1BV2pDLFdBbkNOZCxlQThCOEJZLEtBS1IsMEJBTFVDO01BTk8xRyxJQUFBMkc7TUFBRUMsT0FNVEY7S0FMbEM7V0FEMkNFLE1BRW5DLE9BRmlDNUc7TUFHTztPQUhMNkcsU0FBQUQ7T0FHekNoVixJQUh5Q2dWO09BQUZFLE1BR08sV0FHL0JQLGdCQU53QnZHLEdBR3ZDcE87TUFIdUNvTyxJQUFBOEc7TUFBRUYsT0FBQUM7O0lBYTFDO2FBR0NFLGlCQUFpQlIsZ0JBQWV2RyxHQUFFcE87S0FBSTtpQ0FBSkE7OztXQUFBQTt5REFBQUEsS0FBQUE7S0FBcUIsT0FBQSxXQUF0QzJVLGdCQUFldkc7SUFBMEM7YUFDMUVnSCxxQkFBcUJULGdCQUFldkcsR0FBRXBPLEdBQUksa0JBQXJCMlUsZ0JBQWV2RyxHQUFFcE87SUFBdUI7YUFVN0RxVix1QkFBdUJWLGdCQUFlRSxLQUFFUztLQUMxQztNQVQ4Q1AsTUFZNUMsV0F2REFkLGVBbURzQ1ksS0FBRVM7TUFSSWxILElBQUEyRztNQUFRcEw7S0FDdEQ7U0FEc0RBLE1BUVoyTCxrQkFOckMsT0FGeUNsSDtNQUlwQztPQUFKbUgsSUFJb0NELFVBUlkzTDtPQUFBNkwsTUFLZSw2QkFMZjdMO09BQVJ1TCxNQUtKLFdBR2pCUCxnQkFScUJ2RyxHQUl4Q21IO01BSndDbkgsSUFBQThHO01BQVF2TCxJQUFBNkw7O0lBY25EO2FBS0RDLGVBQWV6VjtLQUNqQjtNQUFxRCxNQUFBO01BQWpDLE1BOUNsQnlVLG9CQThDdUMsNkJBRHhCelU7S0FDRyxPQUFBO0lBQW9EO2FBR3RFMFYsV0FBVzFWO0tBQUk7TUFBaUQsTUFBQTtNQUE3QixNQUFBLFdBakVuQ2tVLGlCQWlFb0QsNkJBQXpDbFU7S0FBd0IsT0FBQTtJQUFnRDthQUNuRjJWLFdBQVczVjtLQUFJO01BQWlELE1BQUE7WUEvRGhFcVUsWUErRG9ELDZCQUF6Q3JVO0tBQXdCLE9BQUE7SUFBZ0Q7YUFDbkY0VixVQUFVNVY7S0FBSTtNQUFnRCxNQUFBO1lBaEU5RHFVLFlBZ0VrRCw2QkFBeENyVTtLQUF3QixPQUFBO0lBQStDO2FBQ2pGNlYsU0FBUzdWO0tBQUk7TUFBK0MsTUFBQTtNQUEzQixNQUFBLFdBckVqQ2lVLGVBcUVnRCw2QkFBdkNqVTtLQUF3QixPQUFBO0lBQThDO2FBQy9FOFYsVUFBVTlWO0tBQUk7TUFBZ0QsTUFBQTtZQWxFOURxVSxZQWtFa0QsNkJBQXhDclU7S0FBd0IsT0FBQTtJQUErQzthQUVqRitWLFlBQVkvVjtLQUNkO01BQWtELE1BQUE7TUFBOUIsTUFBQSxXQXRFbEJvVSxrQkFzRW9DLDZCQUR4QnBVO0tBQ00sT0FBQTtJQUFpRDthQUduRWdXLFdBQVdoVztLQUFJO01BQWlELE1BQUE7TUFBN0IsTUFBQSxXQTFFbkNtVSxpQkEwRW9ELDZCQUF6Q25VO0tBQXdCLE9BQUE7SUFBZ0Q7YUFDbkZpVyxVQUFValc7S0FBSSxJQUFnRCxNQUFBLHdCQTlFL0NvTyxJQThFbUM7S0FBaEIsT0FBQSxvQkE5RW5CQTtJQThFa0U7SUFuRjVDO1lBdUJyQ3FHO1lBaEJBUDtZQU9BSTtZQUNBQztZQVRBTjtZQVdBTztZQVJBSjtZQURBRDtZQUhBSDtZQW9CQVU7WUFXQUU7WUFVQU87WUFDQUM7WUFVQUM7WUFXQUk7WUFJQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFFQUM7WUFJQUM7WUFDQUM7Ozs7Ozs7Ozs7Ozs7YUFZQXJHLE9BQVFzRztLQUFVLE9BQVksa0JBQXRCQSxNQUFzQjtJQUFVO2FBQ3hDQyxRQUFRQyxhQUFZMUY7S0FBSSxPQUFlOzhCQUFBLFdBQS9CMEYsYUFEUnhHLGNBQ29CYztJQUE4Qzs7YUFJbEUyRixJQUFLSCxNQUFLSSxRQUFPdFc7S0FDbkI7TUFBOEMsTUFBQTtNQUExQixNQUFBLFdBRFJzVyxRQUNnQixvQkFEckJKLFlBQVlsVztLQUNDLE9BQUE7SUFBNkM7SUFYdEM7Ozs7Ozs7Ozs7WUFLekI0UDtZQUNBdUc7O1lBSUFFOzt5QkFpQ1csU0FBZTtrQkFDbEJFLEtBQVU3RjtJQUFLLEdBQWY2RixTQUFPQyxNQUFQRCxRQUFBTCxPQUFPTSxjQUFQTjtJQUFlLE9BQWZBO0dBQWlDO09BR3ZDTztZQUNBQyxnQkFBaUJDLE9BQWlCLE9BQUEseUJBQWpCQSxPQUE2QztHQUZqRCxvQkFDYkYsZUFDQUM7WUFTRjlHLE9BQVFzRyxhQUFVLGFBQVZBLFNBQWdDO1lBQ3hDRyxJQUFLSCxNQUFLSSxRQUFPdFc7SUFBSSxPQUFBO2FBQWUsV0FBMUJzVyxjQUFMSixVQUFZbFc7R0FBc0Q7WUFDdkVtVyxRQUFRQyxhQUFZMUY7SUFBSSxPQUFBO2FBQWUsV0FBL0IwRixhQUZSeEcsY0FFb0JjO0dBQThDOzs7Ozs7O1U7OztVOzs7VTs7O1U7Ozs7dUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBV2hFa0Y7WUFhZ0JDLFNBQVVuRjtJQUM1QjtLQUFpQixNQUFBLDhCQURXQTtLQUNwQixNQUFBLDhCQURvQkE7S0FDeEJrRyxNQUFJO0tBQ08sTUFBQSw4QkFEWEE7S0FDQUMsTUFBSSw4QkFESkQ7S0FFb0IsTUFBQSw4QkFEcEJDO0tBQ1EsTUFBQSw4QkFEUkE7S0FDSSxNQUFBLDZCQURKQTtLQUNBQyxNQUFJO0tBQ08sTUFBQSw4QkFEWEE7S0FDQUMsTUFBSSw4QkFESkQ7S0FFb0IsTUFBQSw4QkFEcEJDO0tBQ1EsTUFBQSw4QkFEUkE7S0FDSSxNQUFBLDZCQURKQTtLQUNBQyxNQUFJO0tBQ08sTUFBQSw4QkFEWEE7S0FDQUMsTUFBSSw4QkFESkQ7S0FFQSxNQUFBLDhCQURBQztJQUNBLE9BQUEsNkJBREFBO0dBQ1U7WUFHWm5CLFVBQVU5VixHQUFJLE9BQUpBLFVBQXNCO1lBSWhDaVcsaUJBQWUsU0FBQzs7Ozs7OztROzs7UTs7O1E7OztROzs7O3FCOztPQXhDbEJyRztPQUVBdUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFXRVA7UUFhZ0JDO1FBVWhCQzs7c0I7UUFJQUc7T0F2Q0ZJOzs7RTs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7OztJQ2pMRnhJOzs7Ozs7Ozs7Ozs7O1lBTUFxSixpQkFBa0JDO0lBQ3BCLE9BQUEsbURBRG9CQTtHQUlUO1lBR1RDLGVBQWdCRDtJQUNsQixPQUFBLG1EQURrQkE7R0FJUDtHQU1PO0lBQUE7SUEwQkw7SUEyQlRFO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO1lBQ0FDO0k7OztJQUNBQztJQUNBQztJQUNBQztZQUVBQyxjQUFjQyxhQUFZakUsR0FBRUM7SUFDOUIsR0FBRyxXQXZGSGxHLFlBc0Y0QmlHLEdBQUVDLElBRXpCO0lBR0g7S0FESWlFLFFBSnNCbEU7S0FLdEJtRSxRQUx3QmxFO0tBTXhCbUUsdUJBRkFGLE9BQ0FDO0lBRUosU0FESUMsS0FFQyxPQUZEQTtRQUlXdk87SUFDWDtRQURXQSxNQU5YcU8sT0FRSztLQUVLLElBQUp0RSxJQWRnQkksTUFVWG5LLElBS0x3TyxJQWZrQnBFLE1BVWJwSyxJQU1MaUssTUFBTSxXQWhCRm1FLGFBY0pyRSxHQUNBeUU7S0FFSixTQURJdkUsS0FDYSxPQURiQTtLQUMyQixJQVB0QjRCLE1BT3NCLDZCQVB0QjdMO0tBQUFBLElBQUE2TDs7R0FTTDtZQUdONEMsYUFBYUwsYUFBWWpFLEdBQUVDO0lBQ2pDLElBRCtCc0UsTUFBQXZFLEdBQUV3RSxNQUFBdkU7SUFDakM7VUFEK0JzRSxZQUFFQztVQUFBQSxLQUl0QjtLQUVDO01BTnFCQyxLQUFBRDtNQUt0QnJZLElBTHNCcVk7TUFBRkUsS0FBQUg7TUFLN0JyWSxJQUw2QnFZO01BTXpCekUsTUFBTSxXQU5PbUUsYUFLakIvWCxHQUFTQztLQUVULFNBREkyVCxLQUNhLE9BRGJBO0tBTnlCeUUsTUFBQUc7S0FBRUYsTUFBQUM7O0dBT3lCO1lBR3hERSxlQUFlVixhQUFZakUsR0FBRUM7SUFDL0IsS0FENkJELFVBQUVDO1FBS3hCc0UsTUFMc0J2RTtTQUFFQyxHQUliO1FBQ0h1RSxNQUxnQnZFO0lBS1gsT0FBQSxXQUxIZ0UsYUFLVk0sS0FBUUM7R0FBb0I7WUFHakNJLFlBQVlYLGFBQVlqRSxHQUFFQztJQUFJLGtCQUFsQmdFLGFBQVlqRSxNQUFFQztHQUFxQjtZQUMvQzRFLHFCO1lBQ0FDLHFCO1lBQ0FDLG9COztJQUNBQztJQUNBQztJQUNBQztJQUNBQztZQUNBQyxxQjtZQUdBQyxZQUFZblosR0FBRUMsR0FBSSwwQkFBTkQsR0FBRUMsaUJBQW1DO1lBRWpEbVosWUFBWUMsV0FBVXZGLEdBQUVDO0lBQzFCLFVBQUEsV0E1SUFsRyxZQTJJd0JpRyxHQUFFQztJQUMxQjs7O0tBR0E7TUFESWlFLFFBSG9CbEU7TUFJcEJtRSxRQUpzQmxFO1lBR3RCaUUsVUFDQUM7O1VBR1N0TztNQUNYO2lCQURXQSxNQUpUcU87Ozs7UUFPTSxJQUFKdEUsSUFWa0JJLE1BT1huSyxJQUlQd08sSUFYb0JwRSxNQU9icEssSUFLWCxNQUFBLFdBWlkwUCxXQVVSM0YsR0FDQXlFO1FBQ0o7U0FBc0IsSUFMWDNDLE1BS1csNkJBTFg3TDtTQUFBQSxJQUFBNkw7Ozs7Ozs7Ozs7SUFOYjtHQWFNO1lBR0E4RCxXQUFXRCxXQUFVdkYsR0FBRUM7SUFDN0IsSUFEMkJzRSxNQUFBdkUsR0FBRXdFLE1BQUF2RTtJQUM3QjtRQUQyQnNFO1NBQUVDO09BSVA7UUFKT0MsS0FBQUQ7UUFJbEJyWSxJQUprQnFZO1FBQUZFLEtBQUFIO1FBSXpCclksSUFKeUJxWTtRQUlMLE1BQUEsV0FKTGdCLFdBSWZyWixHQUFTQztPQUFXLFVBQUE7T0FKS29ZLE1BQUFHO09BQUVGLE1BQUFDOzs7O2VBQUFELEtBRWpCO0tBQ087O0dBQzhDO1lBRy9EaUIsYUFBYUYsV0FBVXZGLEdBQUVDO0lBQzNCLEdBRHlCRDtRQUFFQztVQUladUUsTUFKWXZFLE1BSXBCc0UsTUFKa0J2RTtNQUlMLE9BQUEsV0FKTHVGLFdBSVJoQixLQUFRQzs7O2NBSll2RSxHQUVYO0lBQ2lCO0dBQ0E7WUFHL0J5RixVQUFVSCxXQUFVdkYsR0FBRUM7SUFBSSxrQkFBaEJzRixXQUFVdkYsTUFBRUM7R0FBbUI7Ozs7T0ExSzNDbEc7T0FNQXFKO09BT0FFOzs7O1FBK0RFQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUVBQztRQXNCSU07UUFVSks7UUFRQUM7UUFDQUM7UUFDQUM7UUFTQU87UUFSQU47UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFLQUU7UUFpQklFO1FBT0pDO1FBT0FDOzs7O0U7Ozs7OztHQzNLTzs7SUFBQTtJQU1LOzs7O0U7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNHVnpTLFFBQ0QwUyxPQUFRQztJQUNWLEdBQUcsb0NBRERELE9BQVFDLFFBRUw7YUFGSEQ7U0FLT0UsUUFMUEY7Y0FBUUMsVUFNTztTQURPRSxRQUxkRjtLQUswQixPQUFBLHVDQUEzQkMsT0FBZUM7O1FBR2ZDLFFBUlBKO2FBQVFDLFVBT087UUFDT0ksUUFSZEo7SUFRMEIsT0FBQSx3Q0FUakMzUyxTQVNNOFMsT0FBZUM7R0FBbUQ7O0lBSXZFMUQ7SUFhSjJEOztLQWJJM0Q7Y0FDRjRELEtBQUlDO01BQ04sU0FETUE7T0FHTSxJQURMQyxLQUZERCxRQUlBRSxRQURNLHlCQUhWSDtPQUtBLE9BQUEsNkJBRElHLE9BRkNEOztNQUtLLElBRExFLE9BTkRILFFBUUFJLFFBRE0seUJBUFZMO01BU0EsT0FBQSw4QkFWRTVELGFBU0VpRSxPQUZDRDtLQUc2Qjs7S0FHcENMO2NBTUNFO01BQUs7T0FIQUQsTUFBTTtPQUNWLE1BQUEsV0FqQkU1RCxhQWdCRTRELEtBR0xDO01BRkMsT0FBQTtLQUVVO09BS2JLO1lBRUFDLGlCQUFvQixTQUFFOzs7O09BMUJqQm5FO09BYUoyRDs7OztPQTFCR2hUOzs7Ozs7Ozs7Ozs7Ozs7T0FxQ0p1VDtPQUVBQzs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Ozs7Ozs7WUN6Q0FDLGlCQUNELHlCQUVrQztZQU1qQ0MsZ0JBQVcsdUJBRUY7R0FGRTtJQUFBOztJQUtYQzs7OzBCQUlLO3lCQWxCTEYsV0FTQUMsVUFLQUM7OztFOzs7Ozs7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0dDcEJJOzs7O0lBQUp2Qzs7WUFDQXdDLFdBQVMsT0FEVHhDLEtBQ1c7WUFDWHlDLFNBQVNDLEdBRlQxQyxXQUVTMEMsR0FGVDFDLGdCQUV5Qjs7UUFLM0IyQztJQUxFRixTQWdCZ0I7SUFIcEIsV0FSRUU7Ozs7O09BTkVIOztZQXVCQUk7aUJBTUlELEdBQUdFLFdBQVV0SztTQUEwQyxVQUFBLGlCQUExQ0E7U0FBMEMsT0FBQSw4QkFBcERzSztRQUFtRTttQ0FBdEVGLElBTkpDOztxQjtPQXRCQUg7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0dDTUo7O0lBcUdRRzs7Ozs7Ozs7OztJQTNHSlA7SUFJQWhhO0lBRUo7OztHQUdFOzs7Ozs7TUFBc0U7T0FLN0QsTUFBQTtNQUhZO09BREl5YTtPQUFaQztPQUNMQyxXQUFhLFdBWG5CWCxXQVVXVTtPQUVMRSxXQUFhLFdBWm5CWixXQVV1QlM7TUFHckIsd0JBRklFLGNBQ0FDO0tBRWM7R0FLeEI7SUFBQTs7O0dBR0U7Ozs7OztNQUF1RTtPQU05RCxNQUFBO01BSlk7T0FES0M7T0FBWkM7T0FDTkMsV0FBYSw2QkFEUEQ7T0FFTkUsV0FBYSxXQXpCbkJoQixXQXVCd0JhO01BR3RCLHdCQUZJRSxjQUNBQztLQUdjO0dBS3hCO0lBQUE7O0dBWUU7Ozs7OztNQUFtRTtPQUkvRCxNQUFBO1VBSEs5SztNQUFLLE9BQUxBO0tBR1E7O1lBR2YrSyxTQUFTQyxNQUFPLGlCQUFQQSxNQUFnQjtZQUV6QkMsOEJBQThCakwsR0FBRWtMO0lBQ2xDLG1DQURnQ2xMLEdBQUVrTDtJQUNsQyxNQUFBLDRCQURnQ2xMO0dBQ2M7WUFLNUNtTCxRQUFRQyxLQUFJQztJQUNILElBQVBDLHNCQURVRCxLQUFKRDtJQUVQLEtBQUEseUNBRk9BO0tBTUwsTUFBQSw0QkFMREU7SUFHTyxJQUFMQyxLQUFLO0lBQ1QsT0FYQU4sOEJBT0VLLE9BR0VDO0dBRVM7WUFHYkMsU0FBU0MsS0FBSUM7SUFBUyxPQUFBOztzQkFBcUJMLFlBQVUsT0FUckRGLFFBU1NNLEtBQWtDSixLQUF5QjthQUF2REs7R0FBK0Q7WUFDNUVwSyxVQUFVbUs7SUFBbUMsVUFBQSw2QkFBbkNBO0lBQW1DLE9BQUE7R0FBaUI7WUFDOURFLGVBQWVGO0lBQTBCLFVBQUEsNkJBQTFCQTtJQUEwQixPQUFBO0dBQWlCO09BQzFERztZQUVBQyxTQUFVNUwsR0FBRTNRLEdBQUl3YztJQUNsQixJQUFNLElBQ0o1SSxNQURJLFdBRE1qRCxHQUFFM1E7VUFLRmdjO0tBQ0Q7TUFEQ0YsMEJBQUFFO01BQ05DLEtBQUs7S0FDVCxJQUFPLFdBUFNPLFdBQUp4YztXQVNDeWM7VUFBQUMsZ0NBQUFEO01BRVYsT0EvQkhkLDJDQXlCVUcsS0FJR1ksWUFIVFQ7O0tBRUssT0E1QlROLDhCQXlCVUcsS0FDTkc7O0lBSEosV0FIZ0JPLFdBQUp4YztJQUdaLE9BREE0VDtHQVMrRDtZQUcvRCtJLFFBQVNoTSxHQUFHNkwsV0FBVSxPQWR0QkQsU0FjUzVMLE1BQUc2TCxXQUFpQztZQUU3Q0ksV0FBcUJqTTtJQUN2QixJQUNVLFdBRmFBLE9BR3JCLGFBQUEsdUJBRUs7R0FBSTtZQU1MbUssR0FBRytCLEtBQUluTTtJQUNILFlBQUEsNkJBREdBOztTQUVGZ0w7S0FBUSxPQUFBLDBCQUZWbUIsS0FFRW5COztJQUNtQyxVQUFBLCtCQUhqQ2hMO0lBR2lDLE9BQUEsOEJBSHJDbU07R0FHZ0U7O3FEQUhuRS9CLElBTUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFHSitCLHFCQUFxQlgsS0FBSVk7SUFDM0IsMENBRHVCWjtJQUVwQixHQUFBO0tBQ0UscURBSHNCWTs7R0FJTDtZQU9wQkMsb0JBQXFCNWMsWUFBWUksTUFBS21RO0lBQ3hDLElBQUksVUFBQSxXQURvQ0EsT0FDcEM7VUFDRnNNO0tBQ29CO01BRHBCZCwwQkFBQWM7TUFDSUYsZ0JBQWdCO0tBS3BCLEdBUnFCM2MsWUFTaEIsSUFDQztLQUVOLElBdkJBMGMscUJBYUFYLEtBQ0lZO2dCQVdELElBQ0c7S0FHTixPQUFBLFdBbEJpQ3ZjOztHQWtCM0I7WUFHTjBjLHlCQUF5QnZNO0lBQUksT0FyQjdCcU0sdUJBckhBeGMsTUEwSXlCbVE7R0FBZ0Q7WUFFekV3TSxnQkFBc0JDLFdBQVV6TTtJQUNsQyxJQTdJRTBNLFNBNElzQkQsWUE1SXRCNWMscUI7SUE2SUYsT0F4QkV3YyxvQkF1QnNCSSxXQTVJdEJDLFFBNElnQzFNO0dBQ29EO1lBR3BGMk0saUJBQWlCdkIsS0FBSXdCO0lBQ3ZCLElBQUksVUFBQSxXQURtQkEsVUFDbkI7VUFDRnZCO0tBQ1M7TUFEVEYsMEJBQUFFO01BQ0lDLEtBQUs7S0FDVCxPQWxHQU4sNENBOEZpQkksS0FFakJELE1BQ0lHOztHQUNrRDtZQUt0RHVCLHdCQUF3QmpJO0lBRzFCO0lBQ0EsTUFKMEJBO0dBSU47WUFHbEJrSTtJQUF1Qix1Q0F0RHZCWDtHQXNEd0Q7WUFHdERZO0k7O0dBRFc7SUFBQSxjQUNYQTs7O09BL0ZGcEI7Ozs7T0FwQkFiO09BeUdBK0I7T0F2R0E3QjtPQU1BRTtPQVNBSztPQUNBbEs7T0FDQXFLO09BR0FFO09BY0FJO09Bd0RBUTtPQUZBRDtPQU1BSTtPQTFEQVY7cUI7T0EwRUFhOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7Ozs7Ozs7Ozs7WUNsS0FFLFlBQXFCaE47SUFDdkI7S0FHRTtLQUdFaU47YUFDQUMsU0FBTy9KO0tBQ1QsT0FGRThKO01BR0c7S0FDdUIsT0FBQSxvQ0FIbkI5SjtJQUcrQjtJQUUxQyxJQUNVLElBQUp1RSxNQUFJLFdBZGExSCxHQVFuQmtOLFdBREFELGlCQVNGLE9BRkl2RjtVQUlKMkQ7U0FBQUYsMEJBQUFFO0tBWEU0QjtRQVdGOUIsbUJBSVEsTUFBQSw0QkFKUkE7U0FHWWhJLElBSFpnSTtLQUdpQixPQUFMaEk7O0dBQ007WUFHbEJnSyxtQkFBbUJuTjtJQUNyQixPQTFCRWdOO3NCQTBCZUU7Y0FDZixXQUZtQmxOLFlBRURtRCxHQUFLLE9BQWMsV0FEdEIrSixjQUNHL0osSUFBMkI7Y0FBN0M7YUFDSTtHQUFDO1lBR0xpSyxRQUFVQyxPQUFVck47SUFBZSxnQkFBSzNRLEdBQUssT0FBTyxXQUExQ2dlLE9BQTBDLFdBQWhDck4sR0FBb0IzUSxJQUFpQjs7OEJBL0J6RDJkLGFBeUJBRyxvQkFNQUM7OztFOzs7Ozs7Ozs7RTs7Ozs7Ozs7O0U7Ozs7Ozs7OztLQzJETUU7S0FBQUM7O0tBQUFDO0tBQUFOO0tBQUE5TTtLQUFBcU47S0FBQUM7S0FBQTFEO0tBQUEyRDs7SUErTWtEO1lBL01sREw7WUFBQUM7OztZQUFBQztZQUFBTjtZQUFBOU07WUFBQXFOO1lBQUFDO1lBQUExRDtZQUFBMkQ7Ozs7S0FtREFMO0tBQUFDOzs7S0FJUkM7S0FDQU47S0FDQTlNO0tBQ0FxTjtLQUNBQztLQUNBMUQ7S0FDQTJEO0lBd0pzRTtZQWxLOURMO1lBQUFDOzs7WUFJUkM7WUFDQU47WUFDQTlNO1lBQ0FxTjtZQUNBQztZQUNBMUQ7WUFDQTJEOzs7O0tBN0RRTDtLQUFBQzs7S0FBQUM7S0FBQU47S0FBQTlNO0tBQUFxTjtLQUFBQztLQUFBMUQ7S0FBQTJEOztJQTJOb0U7WUEzTnBFTDtZQUFBQzs7O1lBQUFDO1lBQUFOO1lBQUE5TTtZQUFBcU47WUFBQUM7WUFBQTFEO1lBQUEyRDs7OztLQW1EQUw7S0FBQUM7OztLQUlSQztLQUNBTjtLQUNBOU07S0FDQXFOO0tBQ0FDO0tBQ0ExRDtLQUNBMkQ7SUFvSzREO1lBOUtwREw7WUFBQUM7O1lBSVJDO1lBQ0FOO1lBQ0E5TTtZQUNBcU47WUFDQUM7WUFDQTFEO1lBQ0EyRDs7Ozs7S0FvRFFMO0tBQUFDOzs7S0FJUkM7S0FDQU47S0FDQTlNO0tBQ0FxTjtLQUNBQztLQUNBMUQ7S0FDQTJEO0lBNEd3RTtZQXRIaEVMO1lBQUFDOzs7WUFJUkM7WUFDQU47WUFDQTlNO1lBQ0FxTjtZQUNBQztZQUNBMUQ7WUFDQTJEOzs7O0tBdUVRTDtLQUFBQzs7O0tBSVJDO0tBQ0FOO0tBQ0E5TTtLQUNBcU47S0FDQUM7S0FDQTFEO0tBQ0EyRDtJQWtDRjtZQTVDVUw7WUFBQUM7OztZQUlSQztZQUNBTjtZQUNBOU07WUFDQXFOO1lBQ0FDO1lBQ0ExRDtZQUNBMkQ7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7UUN2UklILGVBQ0FOO2FBQ0FVLGFBQWFDLElBQUk3TjtLQUFJLE9BQWE7O2NBQXJCNk47dUJBQTBCMUs7ZUFBYyxVQUFBLFdBQXBDbkQsR0FBc0JtRDtlQUFjLE9BQUE7Y0FBSztJQUFDOzs7U0FFM0QvQyxNQUZBd047O1NBS1F2ZSxjQUhSK1EsTUFHUS9RO2FBSU5pZSxZQUFRdk4sR0FBRUMsR0FBSSxPQUFBLFdBWGhCd04sTUFXVXpOLEdBQUVDLEdBQWE7YUFDdkJ1TixXQUFReE4sR0FBRUMsR0FBSSxPQUFBLFdBUmhCSSxLQVFVTCxHQUFFQyxHQUFZO0lBRlA7S0FBQSxrQkFDZnNOLGFBQ0FDO0tBREFPO0tBQ0FDO0tBREFDO0tBQ0FDO2FBY0VDLEtBQUsvSyxHQUFFQztLQUFJLE9BQU07Y0FmbkI0SztjQWVPN0s7dUJBQWdCQTtlQUFLLE9BQU07d0JBZGxDOEssY0FjUzdLLFlBQTZCQSxHQUFLLFdBQXBCRCxHQUFlQyxHQUFTO2NBQUE7SUFBQTtJQUU1QjtLQUFBO0tBTkgsaUJBckJsQjhKLFVBREFNLE1BSUFwTixLQXNCSThOO0tBVFksbUJBaEJoQmhCLFVBVUVjLGVBQ0FDO2FBb0JGUixLQUFLMU47S0FBSSxPQUFNLFdBckJiK04sZUFxQkcvTixZQUFjQSxHQUFNLE9BQU5BLEVBQVE7SUFBQTthQUMzQjJOLFNBQVMzTjtLQUFJLE9BQVMsV0E3QnRCSyxLQTZCU0wsbUJBQXVCLFNBQUU7SUFBQzthQUc3Qm9PLEtBQUtDO0ssWUFDSSxPQUFBLFdBcENmbEIsVUFvQ2UsMkJBREprQjtTQUVKQyxlQUFMdE87S0FBaUIsT0FBQTtjQTNCakIrTixlQTJCQS9OLFlBQXFCdU8sR0FBSyxPQUZ0QkgsU0FFaUJHLEdBRlpGLEtBRUpDLElBQXNDOzthQUg3Q3JFLElBS0VxRSxJQUFNLE9BSkZGLFFBSUpFLElBQWdCO2FBR2RWO0tBQVcsWUFDVCxPQUFBLFdBM0NOVDtTQTRDS21CLGVBQUx0TztLQUFpQixPQUFBO2NBbENmK04sZUFrQ0YvTixtQkFBMkIsT0FGdkI0TixTQUVDVSxJQUFpQztJQUFBO0lBOUNGO1lBQ3BDYjtZQUNBTjs7WUFHQTlNOztZQU9FME47WUFDQUM7O1lBb0JGTjtZQUNBQztZQUVBMUQ7WUFRSTJEOzs7Ozs7OztJQU9pRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQU96RDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQU1vRTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQU1mOzs7Ozs7Ozs7Ozs7OzthQXlCL0NULFNBQU8vSjtLQUFlLFVBQUEscUJBQWZBO0tBQWUsT0FBQTtJQUFnQjthQUN0Q3FLLEtBQUt6TixHQUFHQztLQUFJO01BQXVCLE1BQUEsaUJBQTlCRDtNQUFrQjtRQUFBOzs7bUJBQW1Db0Q7V0FBZ0IsVUFBQSxXQUFsRW5ELEdBQWtEbUQ7V0FBZ0IsT0FBQTtVQUFLO0tBQXhELE9BQUE7SUFBMEQ7SUFDM0U7S0FBTi9DOzs7aUJBQW1CTCxHQUFHQztTQUFLLElBQXNCLE1BQUEsaUJBQTlCRCxJQUFtQixNQUFBLDBCQUFoQkM7U0FBZ0IsT0FBQTtRQUE2QjtJQUwzRCx3QkFJUndOLE1BQ0FwTixLQUZBOE07O1lBdUZFTSxLQUFLckssR0FBR25ELEdBQUksT0FBQSxXQUFKQSxHQUFIbUQsR0FBVTtZQUNmK0osU0FBTy9KLEdBQUksT0FBSkEsRUFBSztHQUNOO0lBQU4vQywrQkFBbUIrQyxHQUFHbkQsR0FBSyxPQUFBLFdBQUxBLEdBQUhtRCxHQUFXO3VCQUY5QnFLLE1BQ0FOLFVBQ0E5TTtJQWxIZ0JrTjtJQUFBQzs7SUFBQWdCO0lBQUFDO0lBQUFDO0lBQUFoQjtJQUFBQztJQUFBMUQ7SUFBQTJEOztJQTBHWDs7T0ExR1dMO09BQUFDOztPQUFBZ0I7T0FBQUM7T0FBQUM7T0FBQWhCO09BQUFDO09BQUExRDtPQUFBMkQ7Ozs7Ozs7Ozs7U0EyRlBlO1NBQ0FDOzs7OzswREFEQUQsVUFDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7U0FwQkNEO1NBQ0FDOzs7OzswREFEQUQsVUFDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7U0FwQkFEO1NBQ0FDOzs7OzswREFEQUQsVUFDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7U0FwQk9EO1NBQ0FDOzs7OzswREFEQUQsVUFDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ3ZIaUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQU1FOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFNVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBTUU7Ozs7Ozs7Ozs7Ozs7Ozs7MkJBU3BFN2U7YUFDQThlLFlBQVk3TyxHQUFHQztLQUFJLE9BQUEsV0FEbkJsUSxRQUNtQixxQkFBSmtRLElBQUhEO0lBQXFCOzs7U0FFakNLLE1BRkF3Tzs7U0FLUXZmLGNBSFIrUSxNQUdRL1E7YUFHUmtlLFdBQVF4TixHQUFFQyxHQUFJLE9BQUEsV0FOZEksS0FNUUwsR0FBRUMsR0FBWTthQUN0QjZPLEtBQUtDLElBQUdDLElBQUkvTztLQUFJLE9BQUEsV0FWaEJsUSxRQVVnQixXQVBoQnNRLEtBT0swTyxJQUFPOU8sSUFBSitPO0lBQXdCO2FBQ2hDQyxLQUFLRixJQUFHQyxJQUFHRSxJQUFJalA7S0FBSSxPQUFBO2NBWG5CbFEsUUFXbUIsV0FYbkJBLFFBV21CLFdBUm5Cc1EsS0FRSzBPLElBQVU5TyxJQUFQK08sS0FBR0U7SUFBK0I7YUFDMUNqRixJQUFJcUU7a0JBQTJEaGYsR0FBRXdZLElBQU0sV0FBUnhZLEdBQUV3WSxJQUFhO0tBQTVDLFVBQUE7S0FBQSxPQUFBOztjQUE5QndHOztlQUE2QyxxQixPQUZqRFE7OztJQUVnRjthQUNoRlgsS0FBS1ksSUFBR0M7S0FBSyxPQUhiRixLQUdLQyxJQUFHQyxhQUF3QjVMLEdBQUVDLEdBQUssV0FBUEQsR0FBRUMsR0FBUztJQUFDO2FBQzVDOEwsU0FBT0MsR0FBRWI7S0FBSSxPQUFBO2NBZGJ4ZTtjQWNhO2dCQWRiQTtnQkFjYSxxQ0FBZVIsR0FBSyxPQUFMQSxFQUFNO2dCQUEzQjZmO2NBQUViO0lBQXNDO2FBQy9DYyxTQUFPRCxHQUFFYjtLQUFJLE9BQUE7Y0FmYnhlO2NBZWE7Z0JBZmJBO2dCQWVhLDhCQUFZVCxVQUFRLE9BQVJBLEVBQVM7Z0JBQTNCOGY7Y0FBRWI7SUFBc0M7YUFDL0NYLFNBQVNVO0tBQXdCLFVBQUE7c0NBQXhCQSxTQUZUYTtJQUVzRDtJQW5Ca0I7O1lBTXhFOU87WUFVQThOO1lBYkFwZTtZQWVBc2Y7WUFEQUY7WUFMQTNCO1lBVEF6ZDtZQVVBK2U7WUFDQUc7WUFDQWhGO1lBSUEyRDtnQkFoQkE3ZCxRQWVBc2YsVUFEQUYsVUFMQTNCOzs7O0lBaUJ1RTs7OztJQU1mOzs7SUFldEM7Ozs7Ozs7Ozs7Ozs7OztLQUFBOzs7Ozs7Ozs7O0tBSEY7Ozs7Ozs7Ozs7SUFEdEI7Ozs7Ozs7Ozs7Ozs7Ozs7OzthQWtETXpkLE9BRE11ZixJQUFHUDtLQUFLLE9BQWMsaUJBQXRCTyxJQUFHUCxhQUF3QjlPLEdBQUVtRCxHQUFLLE9BQUEsV0FBUG5ELEdBQUVtRCxHQUFRO0lBQUM7YUFFNUN5TCxZQUFZN08sR0FBR0MsR0FBSSxPQURuQmxRLE9BQ21CLHFCQUFKa1EsSUFBSEQsR0FBcUI7OztTQUVqQ0ssTUFGQXdPOztTQUtRdmYsY0FIUitRLE1BR1EvUTthQUdSa2UsV0FBUXhOLEdBQUVDLEdBQUksT0FBQSxXQU5kSSxLQU1RTCxHQUFFQyxHQUFZO2FBQ3RCa08sS0FBS1ksSUFBR0M7S0FBSyxPQUFjLGlCQUF0QkQsSUFBR0MsYUFBd0I1TCxHQUFFQyxHQUFLLFdBQVBELEdBQUVDLEdBQVM7SUFBQzthQUM1QzRMLEtBQUtGLElBQUdDLElBQUdFLElBQUlqUDtLQUFJLE9BQTJCOztjQUF0QixpQkFBbkI4TyxJQUFHQyxJQUFPL087Y0FBSmlQO3VCQUF3Q0ssS0FBSUMsR0FBSyxPQUFBLFdBQVRELEtBQUlDLEdBQVU7SUFBQzthQUNsRXZGLElBQUlxRTtrQkFBMkRoZixHQUFFd1ksSUFBTSxXQUFSeFksR0FBRXdZLElBQWE7S0FBNUMsVUFBQTtLQUFBLE9BQUE7O2NBQTlCd0c7OztlQUE2QyxxQkFBUyxPQUFBOzs7SUFBc0I7YUFDaEZhLFNBQU9DLEdBQUViO0tBQUksT0FBWSxpQkFBbEJhLEdBQUViLG1CQUF3QmhmLEdBQUssT0FBTEEsRUFBTTtJQUFDO2FBQ3hDOGYsU0FBT0QsR0FBRWI7S0FBSSxPQUFZLGlCQUFsQmEsR0FBRWIsWUFBcUJqZixVQUFRLE9BQVJBLEVBQVM7SUFBQzthQUN4Q3NlLFNBQVNVO0tBQXdCLFVBQUE7c0NBQXhCQSxTQUZUYTtJQUVzRDtJQW5CUjs7WUFPOUM5TztZQU9BOE47WUFWQXBlO1lBY0FzZjtZQURBRjtZQUpBM0I7WUFUQXpkOztZQVdBa2Y7WUFDQWhGO1lBR0EyRDtnQkFmQTdkLFFBY0FzZixVQURBRixVQUpBM0I7Ozs7SUFpQndEOzs7O0lBTzFDOzs7UUFTWkw7YUFDQXNDLE1BQU1DLElBQUdDO0tBQUssT0FBYSxpQkFBckJELGFBQTBCelAsR0FBSyxPQUFBLGlCQUE1QjBQLElBQXVCMVAsR0FBZ0I7SUFBQztJQUMzQyxJQUFOSTtJQUwyRSxpQkFHM0U4TSxVQUNBc0MsT0FDQXBQOzs7Ozs7Ozs7Ozs7Ozs7SUFHZ0U7Ozs7Ozs7Ozs7Ozs7OzthQVk5RDhNLFNBQU8vSjtLQUFhLFVBQUEsaUJBQWJBO0tBQWEsT0FBQTtJQUFZO2FBQ2hDcU0sTUFBTUgsSUFBR007S0FBYSxVQUFBLGlCQUFoQk47S0FBUSxPQUFBLHNCQUFMTTtJQUFxQzthQUM5Q0MsV0FBVzdQLEdBQUdDO0tBQUk7S0FBUyxPQUFBO29CQUFoQkQsaUIsNEJBQUdDO0lBQXlCO0lBQ2pDO0tBQU5JLHNCQURBd1A7d0JBRkExQyxVQUNBc0MsT0FFQXBQO0tBM0hnQm9PO0tBQUFDO0tBQUFQO0tBQUFwZTtLQUFBb2Y7S0FBQUU7S0FBQTdCO0tBQUFzQztLQUFBaEI7S0FBQUc7S0FBQWhGO0tBQUEyRDs7SUFrSHVDO1lBbEh2Q2E7WUFBQUM7WUFBQVA7WUFBQXBlO1lBQUFvZjtZQUFBRTtZQUFBN0I7WUFBQXNDO1lBQUFoQjtZQUFBRztZQUFBaEY7WUFBQTJEOzs7O2FBcUloQlQsU0FBTy9KO0tBQWdCLFVBQUEsaUJBQWhCQTtLQUFJLFdBQUEsaUJBQUpBO0lBQTBCO2FBQ2pDcU0sTUFBTUgsSUFBR007S0FBSztNQUE0QyxNQUFBLDZCQUFqREE7TUFBd0MsTUFBQSw2QkFBM0NOO01BQW1DLE1BQUE7TUFBVixNQUFBLDZCQUF0Qk07TUFBYSxNQUFBLDZCQUFoQk47S0FBUSxXQUFBO0lBQW9EO2FBQ2xFTyxXQUFXN1AsR0FBR0M7S0FBSTtNQUEyQixNQUFBLDZCQUFsQ0Q7TUFBeUIsTUFBQSxzQkFBdEJDO01BQWEsTUFBQSw2QkFBaEJEO0tBQU8sV0FBQSxzQkFBSkM7SUFBc0M7SUFDOUM7S0FBTkksc0JBREF3UDt3QkFGQTFDLFVBQ0FzQyxPQUVBcFA7S0F4SWdCb087S0FBQUM7S0FBQVA7S0FBQXBlO0tBQUFvZjtLQUFBRTtLQUFBN0I7S0FBQXNDO0tBQUFoQjtLQUFBRztLQUFBaEY7S0FBQTJEOztJQStIeUM7WUEvSHpDYTtZQUFBQztZQUFBUDtZQUFBcGU7WUFBQW9mO1lBQUFFO1lBQUE3QjtZQUFBc0M7WUFBQWhCO1lBQUFHO1lBQUFoRjtZQUFBMkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7R0M5Q047Ozs7SUFBQTtJQXdCaEIzTztJQUNBSztJQUNBeVE7SUFDQTFaO0lBQ0FtSjtJQUNBTjtJQUNBTztJQUNBdVE7SUFDQTNQO0lBQ0FDO0lBQ0FUO0lBQ0FvUTtJQUNBM087SUFDQUM7WUFDQTJPLGlCQUFxRHhTLEdBQUksT0FBQSxtQ0FBSkEsR0FBaUM7O0lBQ3RGeVM7Ozs7T0FmQWxSO09BQ0FLO09BQ0F5UTtPQUNBMVo7T0FDQW1KO09BQ0FOO09BQ0FPO09BQ0F1UTtPQUNBM1A7T0FDQUM7T0FDQVQ7T0FDQW9RO09BQ0EzTztPQUNBQztPQUNBMk87T0FDQUM7OztFOzs7Ozs7O0c7Ozs7O0c7Ozs7O0dDN0JZO1lBSVpILEtBQWUzWixTQUFTeVQ7SUFLUCxJQUFic0csaUJBTFcvWixTQUFTeVQ7SUFDbEIsV0FJRnNHOzsyQkFXRkEsbUJBTm1CLFdBTW5CQTs7SUE2QmUsSUFBZkE7SUFITixXQUdNQTs7T0FTSS9aO1lBQ0F5VCxpQkFBYyxXQUFhO0dBUHZCO3dCQU1KelQsU0FDQXlUO0lBVkpzRztJQUdRLFdBSFJBOzthQWlDQUEsV0FBV2hOO0tBQ2dDLFVBQUEsaUJBRGhDQTtLQUNiLFdBQVksaUJBRENBO0lBQ3lEO0lBSjFFLFdBR01nTjs7O2FBK0JBQSxXQUFXaE4sR0FBRUM7S0FFRCxVQUFBLGlCQUZERCxNQUFFQztLQUNmLFdBQVksaUJBRENELE1BQUVDO0lBR2Q7SUFOTCxXQUdNK007OzthQXlCQUEsV0FBV2hOO0tBQ2dDLFVBQUEsaUJBRGhDQTtLQUNiLFdBQVksaUJBRENBO0lBQ3lEO0lBSjFFLFdBR01nTjs7Ozs7T0F0SUZKOzs7O21CQWlDaUIsSUFBZkkseUNBQUFBOzs7Ozs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7O0lDbEJFQzs7Ozs7Ozs7WUF6Q0poYSxRQUdFaWEsT0FBUUMsT0FBUXhILE9BQVFDO0lBQzVCLEdBQUcsb0NBRGlCRCxPQUFRQyxRQUV2QjthQUZlRDtTQUtWRSxRQUxVRjtjQUFRQyxVQU1WO1NBRFFFLFFBTEVGO0tBS1UsT0FBQSxXQUxsQ3NILE9BS01ySCxPQUFnQkM7O1FBR2ZDLFFBUlNKO2FBQVFDLFVBT1Y7UUFDVUksUUFSQUo7SUFRWSxPQUFBLFdBUjVCdUgsT0FRRHBILE9BQWlCQztHQUFzQztZQUdoRTFELFlBUUU4SyxhQUFhQyxhQUFhbkgsS0FBSUM7SUFDbEMsU0FEa0NBO0tBR3RCLElBREpDLEtBRjBCRCxRQUk1QkUsUUFETSx5QkFIa0JIO0tBSzVCLE9BQUEsV0FMRWtILGFBSUUvRyxPQUZFRDs7SUFLSSxJQURIRSxPQU55QkgsUUFRNUJJLFFBRE0seUJBUGtCTDtJQVM1QixPQUFBLFdBVGVtSCxhQVFYOUcsT0FGR0Q7R0FHYTtHQVdwQixTQVJBZ0gsVUFRSUMsVUFBWUMsVUErQlpDO0lBL0JKOztjQStCSUE7Z0JBQUFBOzs7Ozs7O09BSEEsT0FBQTs2Q0E3QkFSLGtCQWdDQVE7O01BTEEsT0FBQTs0Q0EzQkFSLGtCQWdDQVE7O2VBQUFBOztNQUNBLE9BQUE7NENBakNBUixrQkFnQ0FROzs7TUFEQSxPQUFBOzRDQS9CQVIsa0JBZ0NBUTtTQTdCc0JDOztRQUFBQTtTQUFBQTtVQUFBQTtVQUFBQTs7VUFZeUNDO1NBQUFBLG1CQUFBQTtPQUkzQztRQURmQyxXQUgwREQ7UUFJeERFLFdBQWEsV0FsQlJMLFVBaUJQSTtPQUVGLFdBRElDOztNQUdKLE9BQUE7O2VBdEJIWjtlQUdzQlM7ZUE2QnRCRDs7U0E3QjZESztRQUFBQSxtQkFBQUE7TUFJekM7T0FEZkMsV0FId0REO09BSXRERSxXQUFhLFdBTnBCVCxVQUtLUTtNQUVGLFdBRElDOztLQUdKLE9BQUE7O2NBVkhmO2NBR3NCUztjQTZCdEJEOztJQUdBLE9BQUEsd0NBbkNBUixrQkFnQ0FRO0dBR3NFO1lBRzFFL0csVUFPSXVILFVBQVlDO0lBSGxCO0tBS3VCLElBRFhDLHFCQUNGQyxXQUFhLFdBRmpCSCxVQUNNRTtLQUVOLHdCQURJQzs7SUFHYSxJQURWQyxxQkFDSEMsV0FBYSxXQUxMSixVQUlMRztJQUVQLHdCQURJQztHQUMwRDtZQUdqRTlILGVBS0MrSCxnQkFBaUJDO0lBQ3JCOzs7O3lDQURJRDs4Q0FBaUJDO0dBaUJwQjs7O1VBckhDdmIsU0FjQXFQLGFBb0JBZ0wsV0E2Q0E1RyxXQWdCQ0Y7OztFOzs7Ozs7O0c7Ozs7O0c7Ozs7O1lDMURDaUkscUI7R0FYc0IsNkJBV3RCQTtZQVVGQyxLQUFZeEUsT0FBUyxPQUFUQTtZQUNaeUUsSUFBV3pFLE9BQU83RixHQUFJLE9BQUEsV0FBWDZGLFVBQU83RjtZQUNsQnVLLEtBQVkxRSxPQUFPN0YsR0FBRThHLEdBQUksT0FBQSxXQUFiakIsVUFBTzdGLEdBQUU4RztZQUNyQjBELE9BQWMzRSxPQUFTLE9BQVRBO1lBS2RqTixJQUFXaU4sT0FBTzdGLEdBQUd4SDtJQUFpQixVQUFBLFdBQWpCQSxHQUFvQixXQUE5QnFOLFVBQU83RjtJQUFvQixPQUFBLFdBQTNCNkYsVUFBTzdGOztZQUVsQnlLLFFBQWVDO0lBQ2pCLFlBRGlCQTtnQkFFUDtRQUNIRjtJQUFVO3FCQUFVeEssR0FBR3hIO2FBQUssT0FBUztzQkFBckNnUyxRQUFvQnhLLEdBQWlCLFdBQWR4SCxHQUFpQixXQUg5QmtTLFVBR1UxSztZQUFxQzs7Ozs4QkFiOURxSyxNQUNBQyxLQUNBQyxNQUNBQyxRQUtBNVIsS0FFQTZSOzs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0dDM0NZOzs7Ozs7OztJQUFBO0lBVVpqVDtJQUNBbVQ7SUFDQUM7SUFDQWhjO1lBRUFtSixLQUFLbFE7SUFHSCxVQUFBLDRCQUhHQTtJQUdILE9BQUE7R0FBbUI7R0FRUDtJQUxkc1I7SUFDQUM7SUFDQW1QO0lBQ0FuUTtJQUNBeVM7SUFDQXJDO0lBQ0FqUDtZQUVBekIsT0FBU3NHLEtBQVU3QztJQUNyQixHQURXNkMsU0FBTUMsTUFBTkQsUUFBQTBNLE1BQU16TSxjQUFOeU07SUFDWCxLQURxQnZQLEdBRWI7T0FGYUEsTUFLZCxPQUFBLG1DQUxJdVAsS0FBVXZQO1FBSWpCMVQsSUFKaUIwVDtJQUlWLE9BQVAxVDtHQUM0QjtZQUs5QjZRLEtBQUtILEdBQUdDLEdBQUksT0FBQSxvQ0FBSkEsR0FBSEQsR0FBNEI7Ozs7O09BN0JqQ2Y7T0FDQW1UO09BQ0FDO09BQ0FoYztPQUVBbUo7T0FNQW9CO09BQ0FDO09BQ0FtUDtPQUNBblE7T0FDQXlTO09BQ0FyQztPQUNBalA7T0FFQXpCO09BVUFZOzs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUMvQ0U5SixRQUNHMFMsT0FBUUM7SUFDVixHQUFHLG9DQURERCxPQUFRQyxRQUVMO0lBRUcsSUFRSndKLElBUkksNkJBSk56SixVQUFRQzthQVlOd0osR0FBSyxPQUFMQTtJQU5PLElBS0pDLE1BTEksNkJBTlQxSixVQUFRQzthQVdIeUosS0FBSyxPQUFMQTtJQUhPLElBRUpDLE1BRkksNkJBUlozSixVQUFRQztpQkFVQTBKLG1DQVZSM0osVUFBUUMsWUFVQTBKO0dBRUM7WUFJWGhOLFlBS1M0RCxLQUpKQztJQUNOO0tBRVFFLFFBRUYsNkJBRElILEtBSkpDO0tBRUFJLFFBS0YsNkJBSklGLE9BSEZGO0tBQ0ZvSixRQVFGLDZCQVBJaEosT0FGQUo7SUFXTixPQUFBLDZCQVZJb0osT0FERXBKO0dBV3dCO0dBU2hDLFNBTkdGLEtBTUNFO0lBQUssSUFIQUQsTUFBTSxpQ0FDVixNQW5CRjVELFlBa0JNNEQsS0FHTEM7SUFGQyxPQUFBO0dBRVU7WUFHYk87SUFDRDtLQUdpQjhJO0tBRERDO0tBRENDO0tBRENDO0tBT1hDLFVBQVksNkJBSkZKO0tBR1pLLGdDQUNFRDtLQUlBRSxVQUFZLDZCQVRITDtLQVFYTSxrQ0FDRUQsZUFMRkQ7S0FTRUcsVUFBWSw2QkFkRk47S0FhWk8sa0NBQ0VELGVBTEZEO0tBU0VHLFVBQVksNkJBbkJEUDtLQWtCYlEsa0NBQ0VELGVBTEZEO0lBUUosV0FKSUU7R0FJeUI7R0F6RXhCO0lBQUEsUUFTTGxkLFNBaUJDcVAsYUFlQTJELE1BU0RTO0lBekNBelM7SUFpQkNtYztJQWVBQzs7O1lBMkNIQyxxQkFBc0JDLFdBQVdDLFVBQVVDLFVBQVVDO0lBQ3ZEO0tBQytELE1BQUEsNEJBRmxCRCxVQUFVQzt3QkFFTjtLQUEvQzs7UUFGc0JIO3VCQUVKLHlCQUZlQztJQUVqQyxPQUFBO0dBQW1GO1lBR25GdFM7O0tBQTZDdVM7S0FBVUM7S0FBcEJGO0tBQXZCRDtJQUNkLE9BTkVELHFCQUtZQyxXQUF1QkMsVUFBVUMsVUFBVUM7O1lBSXZEbEksWUFBVTVMLEdBQUksV0FKZHNCLFVBSVV0QixJQUEyQjs7Ozs7T0FwRm5DM0k7T0FpQkNtYztPQWVBQzs7T0EyQ0hDO09BS0FwUztPQUlBc0s7Ozs7RTs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDOUZBbUksZ0JBQVcscUJBRUQ7WUFHVkMsY0FDV2hVLEdBRE1DO0lBQ25CLElBQWFpRyxNQUFBbEcsR0FBRWhELFNBQUlFO0lBQ2pCO1VBRFdnSjtNQUVNLFVBQUEsZ0JBRkFoSjtNQUVULFdBQUEsZ0JBRktGOztLQUlILElBSkNtSixNQUFBRCxRQUdUNVcsSUFIUzRXLFFBSUQsUUFBQSxXQUxPakcsR0FJZjNROztNQUVxQixJQUFaQyxjQUxFMGtCLFlBS0Yxa0IsR0FMRXlOO01BQUZrSixNQUFBQztNQUFFbkosTUFBQWlYOztVQU1lLElBQWhCQyxnQkFOS0MsWUFNTEQsS0FOS2hYLE1BQU5nSixNQUFBQyxLQUFNakosTUFBQWlYOztHQVFQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWRWSjtPQUtBQzs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7OztJQ09JSTs7Ozs7Ozs7Ozs7O0dBQ0osU0FSQTFELFVBUUkyRCxVQUFZQyxVQStCWkM7SUEvQko7O2NBK0JJQTtnQkFBQUE7Ozs7Ozs7T0FMQSxPQUFBOzZDQTNCQUgsa0JBZ0NBRzs7TUFIQSxPQUFBOzRDQTdCQUgsa0JBZ0NBRzs7ZUFBQUE7O01BQ0EsT0FBQTs0Q0FqQ0FILGtCQWdDQUc7OztNQURBLE9BQUE7NENBL0JBSCxrQkFnQ0FHO1NBakJzQkM7O1FBQUFBO1NBQUFBO1VBQUFBO1VBQUFBOztVQVppQ0M7U0FBQUEsbUJBQUFBO09BSW5DO1FBRGZDLFdBSGtERDtRQUloREUsV0FBYSxXQU5wQk4sVUFLS0s7T0FFRixXQURJQzs7TUFHSixPQUFBOztlQVZIUDtlQWVzQkk7ZUFpQnRCRDs7U0FqQjZESztRQUFBQSxtQkFBQUE7TUFJekM7T0FEZkMsV0FId0REO09BSXRERSxXQUFhLFdBbEJSUixVQWlCUE87TUFFRixXQURJQzs7S0FHSixPQUFBOztjQXRCSFY7Y0Flc0JJO2NBaUJ0QkQ7O0lBR0EsT0FBQSx3Q0FuQ0FILGtCQWdDQUc7R0FHc0U7WUFHMUV6SyxVQU9JaUwsVUFBWUM7SUFIbEI7S0FLdUIsSUFEZGhFLHFCQUNDQyxXQUFhLFdBRmpCOEQsVUFDRy9EO0tBRUgsd0JBRElDOztJQUdhLElBRFhnRSxxQkFDRkMsV0FBYSxXQUxMRixVQUlOQztJQUVOLHdCQURJQztHQUN5RDtZQUdoRXRMLGVBS0N1TCxnQkFBaUJDO0lBQ3JCOzs7O3NDQURJRDs2Q0FBaUJDO0dBaUJwQjtZQUdDL2UsUUFHRWdmLE9BQVFDLE9BQVFDLE9BQVFDO0lBQzVCLEdBQUcsb0NBRGlCRCxPQUFRQyxRQUV2QjthQUZlRDtTQUtiRSxRQUxhRjtjQUFRQyxVQU1iO1NBREtFLFFBTFFGO0tBS0ksT0FBQSxXQUw1QkgsT0FLR0ksT0FBYUM7O1FBR1ZDLFFBUlVKO2FBQVFDLFVBT2I7UUFDV0ksUUFSRUo7SUFRVSxPQUFBLFdBUjFCRixPQVFGSyxPQUFnQkM7R0FBc0M7WUFHOUR0ZixNQUdFK2UsT0FBUUMsT0FBUU8sT0FBUUM7SUFDNUIsR0FBRyxvQ0FEaUJELE9BQVFDLFFBRXZCO2FBRmVEO1NBS2JFLFFBTGFGO2NBQVFDLFVBTWI7U0FES0UsUUFMUUY7S0FLSSxPQUFBLFdBTDVCVCxPQUtHVSxPQUFhQzs7UUFHVkMsUUFSVUo7YUFBUUMsVUFPYjtRQUNXSSxRQVJFSjtJQVFVLE9BQUEsV0FSMUJSLE9BUUZXLE9BQWdCQztHQUFzQztZQUc5RHhRLFlBUUV5USxhQUFhQyxhQUFhOU0sS0FBSUM7SUFDbEMsU0FEa0NBO0tBR3RCLElBRFBDLEtBRjZCRCxRQUk1QkUsUUFETSx5QkFIa0JIO0tBSzVCLE9BQUEsV0FMRTZNLGFBSUUxTSxPQUZERDs7SUFLTyxJQURKRSxPQU4wQkgsUUFRNUJJLFFBRE0seUJBUGtCTDtJQVM1QixPQUFBLFdBVGU4TSxhQVFYek0sT0FGRUQ7R0FHYztZQVFoQitELEtBRUFuZSxHQUZRMlE7SUFDVixTQUNFM1EsTUFBZ0IsT0FBaEJBO1FBQ0crbUIsTUFESC9tQjtJQUNRLE9BQUEsV0FIQTJRLEdBR0xvVztHQUFRO0dBU0w7SUFBTmhXOzs7Z0JBSkEvUSxHQUZPMlE7UUFDVCxTQUNFM1EsTUFBZ0IsT0FBaEJBO1lBQ0crbUIsTUFESC9tQjtRQUNRLFdBQUcsV0FISjJRLEdBR0pvVztPQUFhO1lBSWhCbEosU0FBTzdkLEdBQUksV0FBSkEsR0FBUTs7NENBYmZtZSxNQVlBcE4sS0FDQThNOzs7Ozs7Ozs7Ozs7WUFHSnRELFVBQVV5TSxVQUFTQyxhQUFZdlc7SUFDakMsU0FEaUNBLFVBRTVCd1csS0FGNEJ4VyxNQUV0QixPQUFBLFdBRkNzVyxVQUVQRTtRQUNHQyxRQUh5QnpXO0lBR2hCLE9BQUEsV0FISXVXLGFBR2JFO0dBQTBCO1lBR2hDQyxLQUFLcG5CLEdBQUksV0FBSkEsR0FBVztZQUNoQnFuQixNQUFNakwsUUFBUyxPQUFBLDJCQURmZ0wsTUFDTWhMLFFBQW9DO1lBRTFDa0wsVUFBVTVXLEdBQUdDO0lBQ2YsU0FEWUQsTUFFRyxPQUZIQTtRQUdKMVEsSUFISTBRO0lBR0MsV0FBTSxXQUhKQyxHQUdQM1E7R0FBZ0I7WUFNbEJ1bkIsT0FBS3ZuQixHQUFHMlE7SUFDVixTQURPM1EsTUFFUyxPQUZUQTtRQUdDdVYsSUFIRHZWO0lBR00sT0FBQSxXQUhIMlEsR0FHRjRFO0dBQVE7R0FHUixJQUFOaVMsd0JBZkpGO1lBZ0JJRyxTQUFPbFMsR0FBSSxXQUFKQSxHQUFXOzswQ0FQbEJnUyxRQU1BQyxPQUNBQzs7WUFHSkMsYUFBUSw4QkFFUTtZQUdoQkMsZ0JBQVcsOEJBRUk7WUFHZlQ7SUFBSyxtQkFFTTtRQURSbG5CO0lBQUssV0FBTEE7R0FDWTtZQUdmbW5CO0lBQVEsbUJBQ0E7UUFDRm5uQjtJQUFLLFdBQUxBO0dBQVc7WUFHakI0bkIsVUFBVXJSLEtBQUs0UTtJQUNqQixLQURZNVEsS0FHRixXQUhPNFE7UUFFVm5uQixJQUZLdVc7SUFFQSxXQUFMdlc7R0FDYztZQUduQjZRLEtBQUtvTyxHQUFHdE87SUFDVixTQURPc08sTUFHTTtRQURSamYsSUFGRWlmO0lBRUcsT0FBQSxXQUZBdE8sR0FFTDNRO0dBQ1U7WUFHYjZuQixXQUFXNUksR0FBR3RPO0lBQ2hCLFNBRGFzTyxNQUVIO1FBQ0ZqZixJQUhLaWY7SUFHQSxPQUFBLFdBSEd0TyxHQUdSM1E7R0FBUTtZQUdkOG5CO0lBQWdDLHVCQUM3QjluQixjQUFLLFdBQUxBO1FBQ0crbUI7SUFBSyxXQUFMQTtHQUFhO1lBR25CZ0I7SUFBZ0MsdUJBQzFCL25CLGNBQUssV0FBTEE7UUFDQyttQjtJQUFLLFdBQUxBO0dBQVk7WUFHbkJpQixXQUFXQyxNQUFNZCxPQUFRLE9BQWRjLGlCQUFNZCxPQUEyQztZQUU1RGUsU0FBU3ZYO0lBQ1gsSUFBSSxjQUFHLFdBRElBLFFBQ1A7VUFDRnFMLFdBQUFGLDBCQUFBRSxRQUFPLFdBQVBGO0dBQWdCO1lBR2hCcU07SUFBUyx1QkFDTm5vQixjQUFLLE9BQUxBO1FBQ0c4YjtJQUFPLE1BQUEsNEJBQVBBO0dBQWdCO1lBR3RCc007SUFBaUIsdUJBQ2Rwb0IsY0FBSyxPQUFMQTtRQUNHK2I7SUFBTyxPQUFBLDZCQUFQQTtHQUFtQjtZQVl6QnNNLFFBQVF2VyxJQUFHQyxJQUFJbVYsSUFBSW9CO0lBQ3JCLFNBRFV4VztTQUdMeVcsTUFIS3pXO2NBQUdDLFdBR0F5VyxNQUhBelcsT0FHTyxXQUFHLFdBSE5tVixJQUdacUIsS0FBUUM7U0FEQ2pULElBRkR4RDs7O1NBSUwwVyxPQUpFM1c7Y0FBR0M7VUFJTzJXLE9BSlAzVztNQUllLFdBQU0sV0FKYnVXLEtBSWJHLE1BQVlDOztTQUZOblQsSUFFTmtUOztJQUYyQixXQUFyQmxUO0dBRW1DO1lBRy9Db1QsZUFBZWpWO0lBQ2pCO0tBQWUsUUFBQSwyQkFERUEsR0EzQ2ZvVTtLQTRDTWM7S0FBSjFCO0lBQ0osT0FEUTBCLFdBQUFBLFlBQUoxQjtHQUdrQjtZQUdwQjJCLG9CQUFvQm5WO0lBQUksT0FBMEIsa0JBUGxEaVYsZUFPb0JqVixvQkFBc0QsU0FBRTtHQUFDOzs7O09BL1E3RTBOO09BNkNBNUc7T0FnQkNGO09BeUJEdlQ7T0FjQUM7T0FjQW9QOzs7Ozs7Ozs7Ozs7T0F5Q0FtRTtPQU1BNk07T0FDQUM7T0FxQkFLO09BS0FDO09BS0FUO09BNkNBaUI7T0FLQUM7T0E3Q0FqQjtPQUtBUztPQU1BL1c7T0FNQWdYOztPQW5EQVA7T0E2RkFlO09BT0FNO09BT0FFO09BbERBZjtPQUtBQztPQUxBRDtPQVVBRTtPQUVBRTtXQWxEQVIsT0FLQUM7OztFOzs7Ozs7R0NyTHdCOztJQUFBO0lBTlo7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7SUNKWmhLO1lBTUE5TSxLQUFNSixNQUFLQyxHQUFHQztJQUFJLE9BQW1CO2FBQS9CRixNQUFLQyxzQkFBa0NvRCxHQUFLLE9BQUEsV0FBcENuRCxHQUErQm1ELEdBQVE7R0FBQztZQUN0RGdWLE1BQU9yWSxNQUFLQyxHQUFHQztJQUFJLE9BQWtCO2FBQTlCRjthQUFLQzs7c0JBQThCd1MsR0FBRXBQO2NBQUssT0FBRyxXQUFyQ25ELEdBQTZCbUQsS0FBaUIsNEJBQW5Cb1AsUUFBQUE7YUFBK0I7R0FBQztZQUUxRTZGLElBQWN0WSxNQUFhdVk7SSxnQkFBOEJ0WSxHQUFHQztLQUM5RCxPQUF1QjtjQURQRjtjQUEyQ0M7Y0FBOUJzWTt1QkFDRDlGLEdBQUVwUDtlQUFlLFVBQUEsV0FEaUJuRCxHQUNoQ21EO2VBQWUsT0FBQSxXQURoQmtWLE1BQ0Q5RjtjQUFzQixHQUFDOztZQUdqRCtGLFlBQWF4WSxNQUFNTCxNQUFNTyxHQUFFRDtJQUM3QixPQUFZO2FBZFZpTjtzQkFjaUJLO2NBQVA7c0JBRVI7d0JBSFd2Tjt3QkFBY0M7d0JBQVJOO2lDQUdLOFksS0FBSUM7eUJBQ2pCLElBRUo1VCxJQUZJLFdBSmM1RSxHQUdEdVksS0FBSUM7a0NBR3JCNVQsTUFBZ0IsT0FBQSxXQUxOeUksT0FLVnpJOzZCQURVdlYsSUFDVnVWO3lCQURlLE9BQUx2Vjt3QkFDYzthQUFHO0dBQUE7WUFHbENvcEIsV0FBWTNZLE1BQU1MLE1BQU1PLEdBQUcwWSxRQUFPM1k7SUFDcEMsT0FBWTthQXZCVmlOO3NCQXVCaUJLO2NBQVAsT0FFUjt1QkFIeUJxTDt1QkFHekI7eUJBSFU1WTt5QkFBc0JDO3lCQUFoQk47a0NBR004WSxLQUFJQzswQkFDakIsWUFBQSxXQUpheFksR0FHQXVZLEtBQUlDO2lEQUVLbnBCLGNBQUssT0FBTEE7OEJBQ3JCK21COzBCQUFLLE9BQUEsV0FMQS9JLE9BS0wrSTt5QkFBYTthQUFHO0dBQUE7WUFHNUJ1QyxRQUFTN1ksTUFBS0MsR0FBRzNKO0lBQ25CLE9BQXFCO2FBRFYwSjthQUFLQzs7c0JBQ1V3WSxLQUFJSztjQUM1QixLQUR3QkwsS0FFZCxXQUZrQks7a0JBR3JCcHBCLE1BSGlCK29CO2NBR1AsV0FBQSxXQUpBbmlCLFNBSVY1RyxLQUhxQm9wQixXQUFBQSxPQUFKTDthQUdtQztHQUFDO1lBRzVETSxRQUFTL1ksTUFBS0MsR0FBRzNKO0lBQ25CLE9BQXFCO2FBRFYwSjthQUFLQzs7c0JBQ1V3WSxLQUFJSztjQUM1QixLQUR3QkwsS0FFZCxXQUZrQks7a0JBR3JCcnBCLE1BSGlCZ3BCO2NBR1AsWUFBQSxXQUpBbmlCLFNBSVY3RyxLQUhxQnFwQixPQUFKTCxVQUFJSzthQUcrQjtHQUFDO1lBRzVEL1csT0FBUS9CLE1BQUt5UDtJQUFJLE9BQWtCO2FBQTNCelA7YUFBS3lQOztzQkFBMkJnSixZQUFTLE9BQUEsNEJBQVRBLFFBQWdCO0dBQUM7WUFFekR6RSxTQUFVNVQsTUFBS3FQO0lBQ2pCLE9BQVk7YUFoRFZ2QztzQkFnRGV4RjtjQUNmLFdBRlV0SCxNQUFLcVAsbUJBRUssT0FBQSxXQURML0gsTUFDbUI7Y0FBbEM7YUFDSTtHQUFDO1lBR0x2RixPQUFRL0IsTUFBS3FQLEdBQUd2UDtJQUNsQixPQUFZO2FBdERWZ047c0JBc0RleEY7Y0FDZjtnQkFGUXRIO2dCQUFLcVA7eUJBRUVsZ0I7aUJBQVEsVUFBQSxXQUZQMlEsR0FFRDNRO2lCQUFRLGFBQVMsV0FEakJtWTtnQkFDOEI7Y0FBN0M7YUFDSztHQUFDO1lBR05sRixRQUFTcEMsTUFBS3FQLEdBQUd2UDtJQUNuQixPQUFZO2FBNURWZ047c0JBNERleEY7Y0FDZjtnQkFGU3RIO2dCQUFLcVA7eUJBRUNsZ0I7aUJBQVksY0FBQSxXQUZWMlEsR0FFRjNROzhCQUF1QixXQUR2Qm1ZO2dCQUNxQztjQUFwRDthQUNJO0dBQUM7WUFHTHNSLFNBQVU1WSxNQUFLSCxHQUFHQztJQUNwQixPQUFZO2FBbEVWZ047c0JBa0VleEY7Y0FDZjtnQkFGVXRIO2dCQUFLSDt5QkFFQTFRO2lCQUNQLElBRUo0VCxNQUZJLFdBSFVqRCxHQUVIM1E7d0JBR1g0VCxNQUFpQixXQUpOdUUsR0FJWHZFO2dCQUE2QjtjQUhqQzthQUlJO0dBQUM7WUFHTDhWLEtBQU03WSxNQUFLcVAsR0FBR3ZQO0lBQ2hCLE9BQVk7YUEzRVZnTjtzQkEyRWV4RjtjQUNmO2dCQUZNdEg7Z0JBQUtxUDt5QkFFSWxnQjtpQkFBUSxVQUFBLFdBRlQyUSxHQUVDM1E7aUJBQVEsYUFBa0IsV0FEMUJtWSxPQUNBblk7Z0JBQWtDO2NBQWpEO2FBQ0k7R0FBQztZQUdMd1EsUUFBU0MsTUFBS3lQO0lBQWEsVUFBQSxXQUFsQnpQLE1BQUt5UCxlQUFzQ2dKLEtBQUlscEIsR0FBSyxXQUFMQSxHQUFKa3BCLEtBQWlCO0lBQTFDLE9BQUE7R0FBNEM7WUFFdkVTLFNBQVVuWCxRQUFRM0IsTUFBS3FQO0lBQ3pCLElBQUk1SyxrQkFDQTNMO0lBQ0o7TUFIb0JrSDtNQUFLcVA7ZUFHVmxnQjtPQUNiLFNBRkUySjtRQUV3QyxVQUFBLFdBSmhDNkksUUFBYTBOO1FBQ3JCNUssV0FHc0IsZ0NBRFh0Vjs7aUJBRFgySjtPQUdGLHlCQUpFMkwsMEJBRVd0VjtPQUFmLE9BQUEsNkJBREkySjtNQUlJO1dBTEoyTDtHQU1FOztRQU1GN0U7O1NBRUFtWixrQkFHMEJsWixHQUFHQyxHQUFLLE9BOUZwQ0UsS0F5RkVKLE1BSzBCQyxHQUFHQyxHQUFvQjs7U0FEekNrWixtQkFGUkQsU0FFUUM7OztTQUlSQyxvQkFHMEJwWixHQUFLLE9BN0RqQzhCLE9Ba0RFL0IsTUFXMEJDLEdBQW1COztTQURyQ3FaLHVCQUZSRCxXQUVRQzthQUlSQyxXQUFTdFosR0FBSSxPQTlEZitULFNBa0RFbUYsUUFZU2xaLEdBQW9CO2FBQzdCdVosTUFBSUMsR0FBRXhaO0tBQUksVUFyR1pxWSxJQXNGRXRZLE1BZUl5WjtLQUFNLCtDQUFKeFo7SUFBaUI7YUFDdkJ5WixRQUFNelosR0FBR0MsR0FBSSxPQXhHZm1ZLE1Bd0ZFclksTUFnQk1DLEdBQUdDLEdBQW9CO2FBQzdCeVosU0FBTzFaLEdBQUdDLEdBQUksT0EzRGhCaUMsT0E0Q0VnWCxRQWVPbFosR0FBR0MsR0FBcUI7YUFDL0IwWixVQUFRM1osR0FBR0MsR0FBSSxPQXREakJzQyxRQXNDRTJXLFFBZ0JRbFosR0FBR0MsR0FBc0I7YUFDakMyWixXQUFTNVosR0FBR0MsR0FBSSxPQWpEbEI4WSxTQWdDRUcsUUFpQlNsWixHQUFHQyxHQUF1QjthQUNuQzRaLE9BQUs3WixHQUFHQyxHQUFJLE9BekNkK1ksS0F1QkVFLFFBa0JLbFosR0FBR0MsR0FBbUI7YUFDM0I2WixVQUFROVosR0FBSSxPQXBDZEYsUUFlRUMsTUFxQlFDLEdBQW1CO2FBQzNCK1osV0FBUy9aLEdBQUksT0FuQ2ZpWixTQXFCRUcsVUFOQUYsUUFvQlNsWixHQUE0QjthQUNyQ2dhLFVBQVFoYSxHQUFHM0osU0FBVSxPQXZGdkJ1aUIsUUFnRUU3WSxNQXVCUUMsR0FBRzNKLFNBQWtDO2FBQzdDNGpCLFVBQVFqYSxHQUFHM0osU0FBVSxPQWpGdkJ5aUIsUUF5REUvWSxNQXdCUUMsR0FBRzNKLFNBQWtDO2FBQzdDNmpCLGNBQVlsYSxHQUFHTixNQUFNTyxHQUFJLE9BM0czQnNZLFlBa0ZFeFksTUF5QmVMLE1BQU1PLEdBQVRELEdBQXlDO2FBQ3JEbWEsYUFBV25hLEdBQUdOLE1BQU1PLEdBQUcwWTtLQUFTLE9BbkdsQ0QsV0F5RUUzWSxNQTBCY0wsTUFBTU8sR0FBRzBZLFFBQVozWTtJQUF3RDtJQTNCbkU7WUFTQW9aO1lBTUFFO1lBWkFKO1lBRkFuWjtZQXlCQW1hO1lBQ0FDO1lBVEFUO1lBQ0FDO1lBRkFGO1lBREFGO1lBS0FNO1lBREFEO1lBRUFFO1lBQ0FDO1lBQ0FDO1lBQ0FDOzs7OztPQWpIRjlaO09BQ0FpWTtPQXdCQVE7T0FPQUU7T0FPQWhYO09BbUNBaEM7T0F2RUF1WTtPQUlBRTtPQVNBRztPQXlCQTNFO09BTUE3UjtPQU1BSztPQWVBeVc7T0FUQUQ7T0FpQkFFOzs7Ozs7O1NBV01HO1NBQUFyRjtTQUFBbUY7U0FBQWtCO1NBQUE3QjtTQUFBRztTQUFBeFc7U0FBQUs7U0FBQTZWO1NBQUFDO1NBQUFXO1NBQUFEO1NBQUFqWjtTQUFBbVo7U0FBQUw7U0FBQUU7aUJBc0NKdUIsSUFBSXJhLEdBQUVvRCxHQUFHOU07U0FBUSxPQUFZLFdBdEN6QjRMLFFBc0NBbEMsR0FBeUIsV0FBcEIxSixPQUFIOE07UUFBZ0M7O2dCQUF0Q2lYO2dCQXRDSWpCO2dCQUFBckY7Z0JBQUFtRjtnQkFBQWtCO2dCQUFBN0I7Z0JBQUFHO2dCQUFBeFc7Z0JBQUFLO2dCQUFBNlY7Z0JBQUFDO2dCQUFBVztnQkFBQUQ7Z0JBQUFqWjtnQkFBQW1aO2dCQUFBTDtnQkFBQUU7Ozs7Ozs7O1NBQUFNO1NBQUFyRjtTQUFBbUY7U0FBQWtCO1NBQUE3QjtTQUFBRztTQUFBeFc7U0FBQUs7U0FBQTZWO1NBQUFDO1NBQUFXO1NBQUFEO1NBQUFqWjtTQUFBbVo7U0FBQUw7U0FBQUU7aUJBaURKdUIsSUFBSXJhLEdBQUU2WTtTQUFNLE9BQVksV0FqRHBCM1csUUFpREFsQyxHQUFvQixvQkFBbEI2WTtRQUFtQzs7Z0JBQXpDd0I7Z0JBakRJakI7Z0JBQUFyRjtnQkFBQW1GO2dCQUFBa0I7Z0JBQUE3QjtnQkFBQUc7Z0JBQUF4VztnQkFBQUs7Z0JBQUE2VjtnQkFBQUM7Z0JBQUFXO2dCQUFBRDtnQkFBQWpaO2dCQUFBbVo7Z0JBQUFMO2dCQUFBRTs7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDN0ZOcEk7SUFDQTVHO1lBRUNGLGVBQ0N1TDtJQUFvQixPQUFBLDZCQUFwQkE7R0FBd0Q7WUFPMUQ5ZSxRQUFRaWtCLFdBQVVsWixJQUFHQztJQUN2QixHQUFHLDZCQURpQkQsSUFBR0MsS0FDRTs7d0JBREZBOzs7VUFBQUE7d0RBQUFBLE1BQUFBO3dCQUFIRDs7O1VBQUFBO3dEQUFBQSxNQUFBQTtJQUNpQyxPQUFBLFdBRDNDa1o7R0FDcUQ7WUFHN0Roa0IsTUFBTWlrQixTQUFRblosSUFBR0M7SUFBSyxHQUFHLDZCQUFYRCxJQUFHQyxLQUE4Qjs7d0JBQTlCQTs7O1VBQUFBO3dEQUFBQSxNQUFBQTt3QkFBSEQ7OztVQUFBQTt3REFBQUEsTUFBQUE7SUFBOEQsT0FBQSxXQUF0RW1aO0dBQWdGO09BQ3RGN1U7WUFLSXlILFNBQU83ZCxHQUFJLE9BQUEscUJBQUpBLEdBQWM7WUFDckJtZSxLQUFLek4sR0FBR0M7SUFBSTs7YUFBWTtpQ0FBbkJEOzs7bUJBQUFBO2lFQUFBQSxLQUFBQTtjQUFtQixNQUFBLFdBQWhCQzs7OztxQ0FBZ0I7O0dBQWM7R0FFaEM7SUFBTkk7OztnQkFmQUwsR0FBR0M7UUFBSTs7O3FDQUFQRDs7O3VCQUFBQTtxRUFBQUEsS0FBQUE7aUJBQWUsT0FBQSxXQUFaQzs7T0FBc0I7NENBYXpCd04sTUFEQU4sVUFHQTlNOzs7Ozs7Ozs7Ozs7O1lBTUZ1TCxZQUFVNE8sV0FBVXhhO0lBQ3RCLEtBQUcsbUJBRG1CQTtLQUNvQixPQUFBOzt3QkFEcEJBOzs7VUFBQUE7d0RBQUFBLEtBQUFBO0lBQ0ssT0FBQSxXQURmd2E7R0FDOEQ7R0FKekQ7SUFBQSxrQkFHZjVPOzs7T0FuQkZ2VjtPQUlBQztPQUNBb1A7T0FoQkFnTDtPQUNBNUc7T0FFQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7O0lDSkRqTTs7Ozs7Ozs7Ozs7OztZQUVBOGMsdUJBQXdCQyxLQUFLdmIsS0FBS3diO0lBQ3BDLEdBRDBCRCxTQUNWLFdBSGQvYyxtQkFFd0IrYztPQUFLdmIsU0FFZixXQUpkeEIsbUJBRTZCd0I7Y0FLdEIsNEJBTDJCd2IsY0FBTHhiLE9BQUx1Yjs7Y0FNckIsV0FSSC9jLG1CQUV3QitjLEtBQUt2YixLQUFLd2I7O0dBTXdDO1lBSTFFQyxrQkFBbUJGLEtBQUt2YixLQUFLd2I7SUFZL0I7S0FBSUUsT0FBTyw0QkFaVUgsS0FBS3ZiO0tBYUUsTUFBQSw0QkFiR3diLGNBWTNCRTtLQUNELE1BQUEsNkJBYmtCSCxLQUFLdmI7S0FhdkIsTUFBQSxrQ0FEQzBiO1dBQ0Q7aUJBdkJESix1QkFVbUJDLEtBQUt2YixLQUFLd2I7R0Fjb0I7WUFHakRHLGdCQUFrQmpWLEtBQVUxRyxZQUFRd2I7SUFDdEMsR0FEb0I5VSxTQUFNQyxNQUFORCxRQUFBNlUsTUFBTTVVLGNBQU40VTtJQUNwQixHQUQ4QnZiO1NBR3JCbEcsSUFIcUJrRyxRQUMxQjRiLFFBRUs5aEI7O1NBRkw4aEIsUUFHUSw0QkFKMEJKLGNBQWxCRDtJQWpCbEJFLGtCQWlCa0JGLEtBQ2hCSyxPQURrQ0o7SUFPdEMsV0FQb0JELEtBQ2hCSztHQU1JO0dBR087SUFBQSxjQXJDYk47O1VBMkJBSyxpQkFqQkFGOzs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7WUNQRUksYztHQU5RLGVBTVJBO1lBR0ZDLE9BQU83WixJQUFHQztJQUNaO3dCQURTRDs7O1VBQUFBO3dEQUFBQSxNQUFBQTtLQUNMOFosT0FBSzt3QkFERzdaOzs7VUFBQUE7d0RBQUFBLE1BQUFBO0tBRVI4WixPQUFLO0lBQ1QsMkJBRElBLFlBREFELFlBQUFBO0lBQUFBLFVBQ0FDOztHQUVZO1lBRWRDLGFBQWFDLFdBQVUsT0FBVkEsVUFBaUI7WUFFZEMsVUFBVXJWLE9BQVEsT0FBUkEsTUFBYTtvQ0FSdkNnVixRQU1BRyxjQUVnQkU7OztFOzs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDRmhCQywrQkFBZ0NDO0lBQ2xDO2NBQUE7T0FEa0NBLGtCQUFBQSxtQkFJakI7SUFFYixPQUFBO0dBQ2tGO1lBZWxGQyxLQUFLemI7SUFBSTt3QkFBSkE7OztVQUFBQTt3REFBQUEsS0FBQUE7SUFBMkIsT0FBQTtHQUFjO1lBQzlDdVgsS0FBS3ZYO0lBQUk7d0JBQUpBOzs7VUFBQUE7d0RBQUFBLEtBQUFBO0lBQTJCLE9BQUE7R0FBYztZQUM5QzBiLE1BQUkxYixHQUFFMVE7SUFBSTt3QkFBTjBROzs7VUFBQUE7d0RBQUFBLEtBQUFBO0lBQU0sT0FBQSxzQ0FBSjFRO0dBQTBDO1lBQ2hEcXNCLE1BQU0zYixHQUFFMVE7SUFBSTt3QkFBTjBROzs7VUFBQUE7d0RBQUFBLEtBQUFBO0lBQU0sT0FBQSxzQ0FBSjFRO0dBQTRDO1lBQ3BEc3NCLE1BQU01YixHQUFFMVE7SUFBSTt3QkFBTjBROzs7VUFBQUE7d0RBQUFBLEtBQUFBO0lBQU0sT0FBQSxzQ0FBSjFRO0dBQTRDO1lBQ3BEdXNCLFVBQVU3YixHQUFFMVE7SUFBSTt3QkFBTjBROzs7VUFBQUE7d0RBQUFBLEtBQUFBO0lBQU0sT0FBQSxzQ0FBSjFRO0dBQWdEO1lBQzVEMGdCLEtBQUt4SztJQUFxQixVQUFBLGlDQUFyQkE7SUFBcUIsT0FBQTtHQUE2QjtZQUN2RGhHLEtBQUtRO0lBQUk7d0JBQUpBOzs7VUFBQUE7d0RBQUFBLEtBQUFBO0tBQWtCLE1BQUE7SUFBQSxPQUFBO0dBQXVDO1lBQzlEOGIsT0FBSzliO0lBQUksVUFOVDBiLE1BTUsxYjtJQUFJLE9BQUE7R0FBK0I7WUFDeEMrYixNQUFNL2I7SUFBSSxVQVBWMGIsTUFPTTFiO0lBQUksT0FBQTtHQUErQjtZQUV6Q2djLGVBQWdCUjtJQWpDbEJELCtCQWlDa0JDO0lBRUosVUFBQTtJQUFBLE9BQUE7R0FBcUM7O0lBR2pEUDs7Ozs7Ozs7Ozs7Ozs7OztJQWNRLElBQUpqYixJQUFJO0lBQ1I7UUFYQXFiLFlBWUEsMEJBRklyYjs7OztLQVZKcWI7OztTQWtCYyxJQUFBLE1BM0JkVzs7O2lDQTJCYzs7WUFHZEMsY0FBY2pjLEdBQUVrYztJQUNsQixvQkFEa0JBO2NBR0ssb0JBeENyQk4sTUFxQ2M1YixHQUdnQixvQkFIZGtjO2NBdkNoQlIsTUF1Q2MxYixHQUFFa2M7R0FHd0M7WUFHeERDLGNBQWNuYyxHQUFFa2M7SUFFbEIsb0JBRmtCQSxRQTVDaEJQLE1BNENjM2IsR0FBRWtjLFNBN0NoQlIsTUE2Q2MxYixHQUFFa2M7R0FJd0M7T0FHeERFLDRCQWJBSCxnQkFNQUU7WUFlRUUsT0FBS3BXLE9BQVEsT0FBQSxvQkE5RGZ3VixLQThET3hWLFFBQTJCO0dBQ3BDLFNBSEVxVyxpQkFHRXJXO0lBQ0Y7S0FFdUMsTUFBQSxzQkFKckNvVyxPQUNBcFc7S0FHQSxNQUFBLGVBQVEsc0JBSlJvVyxPQUNBcFc7SUFDRixPQUFBLGVBRkVvVyxPQUNBcFc7R0FHa0U7R0FNdEUsU0FIRXNXLGlCQUVPdFc7SUFDd0IsVUF4RS9Cd1YsS0F1RU94VjtJQUNJLE9BeEVYd1YsS0F1RU94VjtHQUNvRDtZQUczRHVXLHlCQUF5QnZXO0lBQVEsT0FBa0Isb0JBZm5EcVcsaUJBZXlCclc7R0FBa0Q7WUFDM0V3Vyx5QkFBeUJ4VyxPQUFRLE9BUGpDc1csaUJBT3lCdFcsT0FBa0Q7O0lBRTNFeVc7MEJBSEFGLDJCQUNBQztZQVFBRSwrQkFBK0IxVztJQUNqQyxPQUFBLG9CQXpCRXFXLGlCQXdCK0JyVztHQUNlO1lBRzlDMlcsK0JBQStCM1csT0FDakMsT0FwQkVzVyxpQkFtQitCdFc7R0FDZTs7SUFHOUM0Vzs7U0FSQUY7U0FJQUM7WUFVQUU7SUFBcUJoTCxNQUFLaUwsYUFBWUMsYUFBWUM7SUFDcEQ7S0FJRSxNQUFBLFdBTGtEQSxpQkFBWkQ7S0FJdEMsTUFBQSxXQUprREMsaUJBQXhCRjtJQUM1QixPQUFBLGdDQUR1QmpMO0dBTW5CO1lBSUZvTCxTQUtFalgsT0FBTWtYLElBQUdDO0lBQ1gsR0FEV0EsS0FBSEQsSUFmUkwsOEJBZVFLLElBQUdDO0lBRUEsSUFBUEMsT0FBTyw0QkFGQUQsSUFBSEQ7T0FFSkU7S0FFQztNQUFBO01BQU0sTUF2Q1hYLDJCQW1DRXpXO01BSVEsTUFBQTtLQUFBLE9BQUEsNEJBSkZrWDs7WUFFSkU7S0FJTSxVQWpFVmpCLE1BMkRFblcsT0FNa0IseUJBSmhCb1g7S0FJTSxPQUFBLDRCQU5GRjs7SUFIUjtLQUFVLElBQU56QixRQWhDSmdCLDJCQW1DRXpXO1FBQU1rWCxNQUhKekIsU0FBQUEsU0FHTzBCLElBRm9CLE9BRDNCMUI7O0dBVXFCO1lBR3pCNEIsV0FPRXJYLE9BQU1rWCxJQUFHQztJQUNYLEdBQUcsZ0NBREtELElBQUdDO0tBaENYTixnQ0FnQ1FLLElBQUdDO0lBRUEsSUFBUEMsT0FGT0QsS0FBSEQ7SUFHTCxHQUFBLGdDQURDRTtLQUVDO0tBQUEsT0FKR0YsTUE3RFJaLGlCQTZERXRXOztJQUtNLEdBQUEsZ0NBSEpvWDtLQUlDLE9BTkdGLEtBL0hSeEIsTUErSEUxVixPQU11Qiw0QkFKckJvWDtJQU5KO0tBQVUsSUFBTjNCLFFBekRKYSxpQkE2REV0VztLQUhjO09BQWIsZ0NBREN5VixPQUlJeUI7VUFIUSxnQ0FEWnpCLE9BSU8wQjtNQUhvQixPQUQzQjFCOztHQVdxQjtZQUd6QjZCLGVBT0V0WCxPQUFNa1gsSUFBR0M7SUFDWCxHQUFHLGdDQURLRCxJQUFHQztLQWpEWE4sb0NBaURRSyxJQUFHQztJQUVBLElBQVBDLE9BRk9ELEtBQUhEO0lBR0wsR0FBQSxnQ0FEQ0U7S0FFQztLQUFBLE9BSkdGLE1BdkRSTixxQkF1REU1Vzs7SUFLTSxHQUFBLGdDQUhKb1g7S0FJQyxPQU5HRixLQTlJUnRCLFVBOElFNVYsT0FNMkIsZ0NBSnpCb1g7SUFOSjtLQUFVLElBQU4zQixRQW5ESm1CLHFCQXVERTVXO0tBSGM7T0FBYixnQ0FEQ3lWLE9BSUl5QjtVQUhRLGdDQURaekIsT0FJTzBCO01BSG9CLE9BRDNCMUI7O0dBV3FCO1lBR3pCOEIsV0FPRXZYLE9BQU1rWCxJQUFHQztJQUNYLEdBQUcseUJBREtELElBQUdDO0tBbEVYTixnQ0FrRVFLLElBQUdDO0lBRUEsSUFBUEMsT0FBTyx1QkFGQUQsSUFBSEQ7SUFHTCxHQUFBLG1CQURDRTtLQUVDO0tBQUEsT0FBQTtjQUpHRixJQUlJLHVCQTVHWmIsaUJBd0dFclc7O0lBS00sR0FBQSxrQkFISm9YO0tBSUMsT0FBQTtjQU5HRixJQWhLUnZCLE1BZ0tFM1YsT0FNdUIsNEJBSnJCb1g7SUFOSjtLQUFVLElBQU4zQixRQXBHSlksaUJBd0dFclc7S0FIYyxHQUFiLGtCQURDeVYsT0FJSXlCLE9BSFEsdUJBRFp6QixPQUlPMEI7TUFIb0IsT0FEM0IxQjs7R0FXcUI7WUFnQnpCK0IsUUFBTXhYLE9BQU1tWDtJQUFLO0tBWG5CO01BQ0lNO01BRUFDLEtBbkxGbEMsS0EyTE14VjtNQVBKMlgsS0FwTEZuQyxLQTJMTXhWO01BTk0sTUFBQSw0QkFGVjBYLElBRkFEO01BSVMsTUFBQSxpQ0FEVEU7TUFDQUMsU0FBUyxpQ0FKVEg7S0FPRCxHQUFBLGdDQUhDRztNQU1lLE9BQUEsNEJBTmZBLFFBTVVUOztHQUF5QjtZQUVyQ1UsWUFBWTdYLE9BQU1rWCxJQUFHQztJQUN2QixHQUNHLGdDQUZpQkQsSUFBR0M7S0EzRnJCTixnQ0EyRmtCSyxJQUFHQztJQUdqQixVQUxKSyxRQUVZeFgsT0FHSSw0QkFIS21YLElBQUhEO0lBR2QsT0FBQSw0QkFIY0E7R0FHUTtHQUlsQixJQUFWWSxZQUFVLGdDQWhMUjFDO1lBa0xGMkM7SUFBVSxPQXRNUnZDLEtBc01tQixnQ0FGckJzQztHQUVvRDtZQUNwREUsTUFBSTN1QjtJQUFJLE9BakpOOHNCLE1BaUpnQixnQ0FIbEIyQixZQUdJenVCO0dBQStDO1lBQ25ENHVCLFFBQU01dUI7SUFBSSxPQXJNUnFzQixNQXFNb0IsZ0NBSnRCb0MsWUFJTXp1QjtHQUFpRDtZQUN2RDZ1QixZQUFVN3VCO0lBQUksT0FwTVp1c0IsVUFvTTRCLGdDQUw5QmtDLFlBS1V6dUI7R0FBcUQ7WUFDL0Q4dUIsUUFBTTl1QjtJQUFJLE9BdE1Sc3NCLE1Bc01vQixnQ0FOdEJtQyxZQU1NenVCO0dBQWlEO1lBQ3ZEK3VCLFFBQU0vdUI7SUFBSSxPQWhCUm11QixRQWdCb0IsZ0NBUHRCTSxZQU9NenVCO0dBQWlEO1lBQ3ZEZ3ZCLFdBQVNodkIsR0FBRUM7SUFBSSxPQWhHYjJ0QixTQWdHNEIsZ0NBUjlCYSxZQVFTenVCLEdBQUVDO0dBQXNEO1lBQ2pFZ3ZCLGFBQVdqdkIsR0FBRUM7SUFBSSxPQWxGZit0QixXQWtGZ0MsZ0NBVGxDUyxZQVNXenVCLEdBQUVDO0dBQXdEO1lBQ3JFaXZCLGlCQUFlbHZCLEdBQUVDO0lBQUksT0FsRW5CZ3VCLGVBa0V3QyxnQ0FWMUNRLFlBVWV6dUIsR0FBRUM7R0FBNEQ7WUFDN0VrdkIsYUFBV252QixHQUFFQztJQUFJLE9BbERmaXVCLFdBa0RnQyxnQ0FYbENPLFlBV1d6dUIsR0FBRUM7R0FBd0Q7WUFDckVtdkIsY0FBWXB2QixHQUFFQztJQUFJLE9BbkJoQnV1QixZQW1Ca0MsZ0NBWnBDQyxZQVlZenVCLEdBQUVDO0dBQXlEO1lBQ3ZFb3ZCO0lBQVUsT0FoTlJwSCxLQWdObUIsZ0NBYnJCd0c7R0Fhb0Q7WUFDcERhO0lBQVUsT0ExTVI5QyxPQTBNbUIsZ0NBZHJCaUM7R0Fjb0Q7WUFDcERjO0lBQVcsT0ExTVQ5QyxNQTBNcUIsZ0NBZnZCZ0M7R0Flc0Q7WUFDdERlLFVBQVV0WjtJQUF1QixJQWxNckJ4RixJQWtNcUIsZ0NBaEJqQytkO0lBbEw4QixPQUFBLFdBRjVCOUMsUUFFVWpiLEdBWlZnUSxLQThNUXhLO0dBQTJEO1lBQ3JFOUYsS0FBSzhGLE1BQU8sT0FEWnNaLGNBQ0t0WixPQUEyQjtZQUNoQ3VaLFVBQVd2RDtJQTVPWEQsK0JBNE9XQztJQUE4QixPQUZ6Q3NELFVBNU5GO0dBOE4yRTtZQUN6RUUsVUFBVXRoQjtJQUFJLE9BQUEsV0F2TVp1ZCxRQXVNeUIsZ0NBbkIzQjhDLFlBbUJVcmdCO0dBQWtEOzs7O09BRjVEZ0M7T0FEQW9mO09BRUFDO09BaEJBZjtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQzs7UUEvTEV4RDtRQWRBckw7UUFLQWdNO1FBSkF4YztRQVBBaWM7UUFzREFXO1FBbkRBVDtRQUVBRTtRQURBRDtRQXVMQTZCO1FBL0VBUDtRQWVBSTtRQWlCQUM7UUFpQkFDO1FBZ0NBTTtRQTVMQXZHO1FBT0F1RTtRQUNBQztPQThNRmlEOzs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDelBBQyxRQUFVcFosVUFBaUQxRyxLQUFJYTtJQUdqRSxHQUhZNkY7U0FBZUMsTUFBZkQsUUFBQXFaLGVBQWVwWjs7U0FBZm9aO0lBR1osWUFIeURDLGdCQUFOekUsTUFBTXlFLGdCQUFOekU7SUFHbkQsSUFBSUMsZUFINkQzYTtJQUlqRSxHQUo2RGI7U0FNcEQ2RCxJQU5vRDdELFFBSXpENGIsUUFFSy9YOztTQUZMK1gsUUFHUSw0QkFKUkosY0FIK0NEO0lBU25ELDhDQVRtREEsS0FJL0NLLE9BREFKO0lBT1ksSUFBWnlFLFlBQVksNEJBTlpyRTtPQU1BcUU7U0FDSm5tQixJQURJbW1COztNQUVXO09BQVRDLFNBQVMsNEJBWm9DM0UsS0FXbkR6aEI7T0FHcUQsTUFBQSw0QkFIckRBO09BR3VCLE1BQUEsK0JBZFhpbUI7T0FjTkksV0FBVyw0QkFka0M1RTtNQWVqRCxpQkFmK0QxYSxHQVkzRHFmLFFBRUFDO01BSE4sVUFBQXJtQjtlQUFBQTtNQUFBQTs7OztHQUtJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FoQkZnbUI7OztFOzs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7WUNKQU0sUUFBTS9QLFVBQU0sT0FBTkEsRUFBTztZQU1iZ1EsSUFBSXZmLEdBQUUzUSxHQUFJLFdBQUksV0FBVjJRLEdBQUUzUSxHQUFhO1lBRW5CbXdCLFFBQVF4ZjtJQUNWLElBQ0UsUUFBQSxXQUZRQTtVQU1SeWYsU0FBQTdhLHdCQUFBNmEsTUFBSyxPQUFMN2E7R0FBTTtZQVFOOGEsUUFBUTFmLEdBQUUyZixHQUFFdHdCLEdBQUksT0FBRSxXQUFWMlEsR0FBVSxXQUFSMmYsR0FBRXR3QixJQUFXO1lBQ3ZCdXdCLEtBQUs1ZixHQUFFM1EsR0FBRUMsR0FBSSxPQUFBLFdBQVIwUSxHQUFJMVEsR0FBRkQsR0FBVztZQUNkd3dCLGNBQWV0TixHQUFFdlMsR0FBRTNRO0lBQUksSUFBUm1qQixNQUFBRCxHQUFJNkQsTUFBQS9tQjtJQUFJO2FBQVJtakIsS0FBdUIsT0FBbkI0RDtLQUFxRCxJQUFyRDBKLE1BQXFELFdBQXZEOWYsR0FBRW9XLE1BQUozRCxNQUErQyw0QkFBL0NEO0tBQUFBLE1BQUFDO0tBQUkyRCxNQUFBMEo7O0dBQTBEO3FCQXhCakZSLFNBTUFDLEtBRUFDLFNBZ0JJSyxlQUZKSCxTQUNBRTs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7SUNHQTVWO0lBR0dtSztJQTJCRnhLOzs7Ozs7Ozs7SUFsRER2VDs7OztZQUVDcVAsWUFDRTRELEtBQUlDO0lBQ04sT0FETUE7O09BRUksT0FBQSx5QkFGUkQ7O09BR1MsT0FBQSx5QkFIVEE7ZUFJVyxPQUFBLHlCQUpYQTs7R0FJK0M7R0FVcEQsU0FOR0QsS0FNQ0U7SUFBSyxJQUhBRCxNQUFNLGlDQUNWLE1BYkY1RCxZQVlNNEQsS0FHTEM7SUFGQyxPQUFBO0dBRVU7R0FPZCxTQUZDbUgsVUFjQ3NQO0lBWkY7O2NBWUVBO2dCQUFBQTs7Ozs7Ozs7OztRQVh3Qzs7T0FFTTs7TUFESjs7ZUFVMUNBOztNQUNBLE9BQUE7NENBZEU1TCxrQkFhRjRMOzs7TUFEQSxPQUFBOzRDQVpFNUwsa0JBYUY0TDs7Ozs7Ozs7Ozs7T0FQQSxPQUFBOzZDQU5FNUwsa0JBYUY0TDs7TUFIQSxPQUFBOzRDQVZFNUwsa0JBYUY0TDs7S0FMQSxPQUFBOzJDQVJFNUwsa0JBYUY0TDs7SUFFYyxPQUFBLHdDQWZaNUwsa0JBYUY0TDtHQUVvRjtZQUlyRmxXO0lBQ0Qsc0JBQ1csbUJBQ0Msb0JBQ0U7O0dBQTRCO1lBbUJ6Q3hULE1BQU04TSxHQUFFQyxHQUFJLDhCQUFORCxHQUFFQyxXQUFtQjtHQUVmO1lBT1puQyxPQUFPc1IsR0FBSSxZQUFKQSxVQUFBQSxjQUE0RDtZQUVuRTFSO0lBQVMsc0JBQ0Qsa0JBQ0Msa0JBQ0U7O0dBQUM7Ozs7T0EvRVp6SztPQUVDcVA7T0FTQTJEO09BV0RxSDtPQW9CQTVHO09BUUNGO09BOUJESztPQTZDQTNUO09BU0E0SztPQUVBSjs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7SUNpNUJJbWY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBOW1CSkM7Ozs7Ozs7Ozs7Ozs7OztJQTlXQXZpQjtJQUtFK1M7SUFDQTVHOzs7WUFFQ0YsZUFDQ3VMO0lBQW9CLE9BQUEsNkJBQXBCQTtHQUFzRDtZQVl4RDllLFFBQ0VnZixPQUFROEssT0FBUUM7SUFDcEIsR0FBRyxvQ0FEU0QsT0FBUUMsUUFFZjtTQUZPRCxjQUFRQztRQUtiQyxRQUxLRjtTQUFRQyxPQU1MO1FBREtFLFFBTEFGO0lBS1ksT0FBQSxXQUw1Qi9LLE9BS0dnTCxPQUFhQztHQUdzQjtZQUd4QzFVLFlBRUUyVTtJQURKLFlBS3VCO0lBRkYsSUFEZEMscUJBQ0NDLFdBQWEsV0FGakJGLFVBQ0dDO0lBRUgsd0JBRElDO0dBRW1EO0dBeEJuQztJQUFBLHlCQU10QnBxQixTQVlBdVY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFjRi9CLFVBQVU1SixHQUFFRCxHQUFJLE9BQUEsaUJBQUpBLEdBQUZDLEdBQWU7WUFDekJMLFFBQVFJLEdBQUksT0FBSkEsRUFBSztZQUViMGdCLE1BQVFycUIsU0FBU3NxQixRQUFTOWEsV0FBeUMrYSxTQUFRQztJQUM3RSxHQUQ0QmhiLFNBQVFDLE1BQVJELFFBQUFpYixRQUFRaGIsY0FBUmdiO0lBQzVCLGFBRHlEM0IsaUJBQVB0RSxPQUFPc0UsZ0JBQVB0RTtJQUNyQyxJQUFUa0csU0FBUyxXQURNSixRQUFrREM7SUFFckUsU0FBSUksTUFBTTF4QixHQUFFQztLQUFvQixXQUFBLFdBRnRCOEcsU0FFQS9HLEdBQUVDO0tBQW9CLE9BQUE7SUFBYTtJQUM3QyxTQUFJMHhCO0tBQ0YsT0FBQTtJQUF1RTtXQUZyRUQsTUFGaUVKLFNBQ2pFRzs7V0FLQUc7O1dBQUFBLHVCQUhBRDttQkFHQUM7OztLQU1TQyx5QkFaZUwsUUFBeUNGLFVBQ2pFRztLQVdTOW5CLElBQUFrb0I7S0FBRUM7SUFDYjtLQUFzQixJQUFsQkMsa0JBWEZMLE1BVVMvbkIsR0FaZ0U0bkI7Ozs7O09BYzNFLE9BRElROzt5QkFQRkg7OzBCQU44Q3JHLHFCQVlyQzVoQixHQUFFbW9CO3FCQUFBQTs7a0NBTlhGOztPQVdhLElBQVRJLFdBQVMsV0FqQkVYLFFBWU4xbkI7OztlQVZUK25CLE1BVVMvbkIsR0FLTHFvQjs7MEJBWEpKOztzQkFIQUQ7bUNBR0FDOztRQWdCa0QsSUFWdkNLLGNBQUZ0b0IsR0FBRW1vQjtRQUFGbm9CLElBS0xxb0I7UUFMT0YsUUFBQUc7Ozs7ZUFTUjs7O2lCQVRRSDs7S0F5QlgsT0FBQTs7R0FBaUI7WUFHbkJJLFFBQVEzYixpQkFBdUQrYSxTQUFRQztJQUN6RSxHQURVaGIsU0FBU0MsTUFBVEQsUUFBQThhLFNBQVM3YSxjQUFUNmE7SUFDVixhQURnQ3hCLGlCQUFSMkIsUUFBUTNCLGdCQUFSMkI7SUFDeEIsYUFEcURXLGlCQUFQNUcsT0FBTzRHLGdCQUFQNUc7YUFBcEM4RjtLQUNTO0lBQUEsT0F6Q2pCRDs7c0JBMEMyQnB4QixHQUFLLE9BQWEsNEJBQWxCQSxHQUZuQnF4QixRQUVrQztpQkFGcEJHO2lCQUFzQmpHO2FBQW1CK0Y7YUFBUUM7R0FFQTtZQUd2RWEsR0FBRzFoQixHQUNMLEtBREtBLEdBRUcsY0FDTjFRLElBSEcwUSxNQUdPLFdBQVYxUSxHQUFnQjtZQUdoQnF5QixHQUFHM2hCLEdBQ0wsS0FES0EsR0FFRyxjQUNEa0csTUFIRmxHLE1BR1EsV0FBTmtHLEtBQWE7WUFHbEIwYixJQUlnQjVoQixHQUFFd1M7SUFIcEIsT0FHb0JBLEdBRmY7UUFFYXRNLE1BQUFsRyxHQUFFeVMsTUFBQUQ7SUFDaEI7VUFEY3RNLEtBRU47U0FGTUMsTUFBQUQsUUFHWjlDLElBSFk4QztLQUdGLFNBSEl1TSxLQUdVLFdBQXhCclA7S0FBOEMsSUFIaENzUCxNQUdnQyw0QkFIaENEO0tBQUZ2TSxNQUFBQztLQUFFc00sTUFBQUM7O0dBS047WUFHWm1QLFFBQVE3aEIsR0FBRXdTO0lBQ04sWUFiSm9QLElBWVE1aEIsR0FBRXdTOztLQUVGLE9BQUEsV0F6SFI3VSxtQkF1SFU2VSxHQUUyRCxtQkFGN0R4UztRQUdIb0Q7SUFBSyxPQUFMQTtHQUFNO1lBR1gwZSxpQkFBaUIxZixJQUFHQztJQUN0QixHQURtQkQ7UUFBR0MsSUFHZixPQUFBLHVCQUhZRCxJQUFHQztTQUVoQlcsSUFGYVo7OztTQUViWSxJQUZnQlg7SUFFSCxPQUFiVztHQUNpQjtZQWFuQitlLFNBQ1czZixJQUFFQztJQUFmLElBQWFlLElBQUFoQixJQUFFaUIsSUFBQWhCLElBQUUyZjtJQUNmO1FBRFc1ZTtTQUFFQztPQUdnQjtRQUhoQnVFLE1BQUF2RTtRQUFGc0UsTUFBQXZFO1FBQUk2ZSxrQkFHYyw0QkFIZEQ7T0FBSjVlLElBQUF1RTtPQUFFdEUsSUFBQXVFO09BQUVvYSxnQkFBQUM7Ozs7ZUFBRjVlLEdBRUQsV0FGRzJlO0tBSW9CLFdBSnBCQSxlQUFKNWUsR0FBRUM7O0dBTUg7WUFJWjZlLGtCQUFrQnBRLE1BQUsxUCxJQUFHQztJQUN0QixZQVpGMGYsU0FXcUIzZixJQUFHQzt1QkFFVDtJQU1FO0tBTHlCOGY7S0FBWEM7S0FBZko7S0FLQyxPQUFBLG1CQUx5Qkc7S0FLMUMsT0FBQSw0QkFMZ0JIO0tBSUMsT0FBQSxtQkFKY0k7SUFDakMsT0FBQTthQTVKQXprQjs7YUF3SmtCbVU7YUFPaEIsNEJBSmdCa1E7OztHQU1kO1lBR0pLLGNBQWNqZ0IsSUFBR0MsSUFBSXBDO0lBQ3ZCLGFBeEJJOGhCLFNBdUJZM2YsSUFBR0MsYUFFc0IsV0FGbEJwQyxHQUFQbUMsSUFBR0M7R0FHbUI7WUFjbENpZ0IsV0FDV2xnQixJQUFFQyxJQUFFa2dCO0lBQWpCLElBQWFuZixJQUFBaEIsSUFBRWlCLElBQUFoQixJQUFFbU4sSUFBQStTLElBQUVQO0lBQ2pCO1FBRFc1ZTtTQUFFQyxLQUFFbU07T0FHd0I7UUFIeEJnVCxNQUFBaFQ7UUFBRjVILE1BQUF2RTtRQUFGc0UsTUFBQXZFO1FBQU02ZSxrQkFHc0IsNEJBSHRCRDtPQUFONWUsSUFBQXVFO09BQUV0RSxJQUFBdUU7T0FBRTRILElBQUFnVDtPQUFFUixnQkFBQUM7Ozs7ZUFBSjVlLE9BQUVtTSxHQUVDLFdBRkN3UztLQUtDLFdBTERBLGVBQU41ZSxHQUFFQyxHQUFFbU07O0dBT0Y7WUFJZmlULGtCQUFrQjNRLE1BQUsxUCxJQUFHQyxJQUFHa2dCO0lBQ3pCLFlBYkZELFdBWXFCbGdCLElBQUdDLElBQUdrZ0I7dUJBRVo7SUFFUTtLQUQ4Qkc7S0FBWFA7S0FBWEM7S0FBZko7S0FDTyxPQUFBLG1CQURRSTtLQUM3Qk8sS0FBSyw0QkFEU1g7S0FFTyxPQUFBLG1CQUZtQkc7S0FFeENTLEtBQUssNEJBRlNaO0tBR08sT0FBQSxtQkFIOEJVO0tBR25ERyxLQUFLLDRCQUhTYjtJQUlsQixPQUFBLFdBeE1BcmtCLG1CQWlNa0JtVSxNQUlkNlEsSUFDQUMsSUFBQUEsSUFDQUM7R0FDMEU7WUFHOUVDLGNBQWMxZ0IsSUFBR0MsSUFBR2tnQixJQUFJdGlCO0lBQzFCLGFBdkJJcWlCLFdBc0JZbGdCLElBQUdDLElBQUdrZ0I7a0JBRW1CLFdBRmZ0aUIsR0FBVm1DLElBQUdDLElBQUdrZ0I7O0dBR2dCO1lBR3BDUSxNQUFNM2dCLElBQUdDLElBQUlwQztJQUFJLE9BN0NqQm9pQjthQTZDTWpnQjthQUFHQzs7O2NBQStCLHNCQUF2QixPQUFBLHVCQUFKcEM7O0dBQXdDO1lBRXJEK2lCLFVBQVU1Z0IsSUFBR0MsSUFBSXBDO0lBM0RqQmlpQixpQ0EyRFU5ZixJQUFHQztJQUNmLE9BQUEscUJBRFlELElBQUdDLElBQUlwQztHQUVGO1lBR2ZnakIsU0FBUzdnQixJQUFHQyxJQUFJcEM7SUFBSSxPQXBEcEJvaUI7YUFvRFNqZ0I7YUFBR0M7OztjQUErQixzQkFBdkIsT0FBQSx1QkFBSnBDOztHQUEyQztZQUUzRGlqQixhQUFhOWdCLElBQUdDLElBQUlwQztJQWxFcEJpaUIsb0NBa0VhOWYsSUFBR0M7SUFDbEIsT0FBQSx3QkFEZUQsSUFBR0MsSUFBSXBDO0dBRUY7WUFHbEJrakIsTUFBTS9nQixJQUFHQyxJQUFJM0MsTUFBTU87SUFBSSxPQTNEdkJvaUI7YUEyRE1qZ0I7YUFBR0M7OztjQUFxQyxzQkFBdkIsT0FBQSx1QkFBVjNDLE1BQU1POztHQUE4QztZQUVqRW1qQixVQUFVaGhCLElBQUdDLElBQUkzQyxNQUFNTztJQXpFdkJpaUIsaUNBeUVVOWYsSUFBR0M7SUFDZixPQUFBLHFCQURZRCxJQUFHQyxJQUFJM0MsTUFBTU87R0FFRjtZQUdyQm9qQixTQUFTamhCLElBQUdDLElBQUlwQztJQUFJLE9BbEVwQm9pQjthQWtFU2pnQjthQUFHQzs7O2NBQStCLHNCQUF2QixPQUFBLHVCQUFKcEM7O0dBQTJDO1lBRTNEcWpCLGFBQWFsaEIsSUFBR0MsSUFBSXBDO0lBaEZwQmlpQixvQ0FnRmE5ZixJQUFHQztJQUNsQixPQUFBLHdCQURlRCxJQUFHQyxJQUFJcEM7R0FFRjtZQUdsQnNqQixRQUFRbmhCLElBQUdDLElBQUlwQztJQUFJLE9BekVuQm9pQjthQXlFUWpnQjthQUFHQzs7O2NBQStCLHNCQUF2QixPQUFBLHVCQUFKcEM7O0dBQTBDO1lBRXpEdWpCLFlBQVlwaEIsSUFBR0MsSUFBSXBDO0lBdkZuQmlpQixtQ0F1Rlk5ZixJQUFHQztJQUNqQixPQUFBLHVCQURjRCxJQUFHQyxJQUFJcEM7R0FFRjtZQUdqQm9hLElBQUlyYSxHQUNhb0QsR0FBTjlNO0lBQWIsWUFETTBKOztpQkFFSTtLQUNLLElBQU55akIsZUFBTHBnQixjQUFXLE9BQUEsV0FGRi9NLE9BQU04TSxHQUVmQztLQUFXLFNBQUE7YUFBTm9nQjs7R0FFSztZQUtaQyxXQUFXMWpCLEdBQ0NDO0lBQWQsSUFBZ0IwakIsa0JBREgzakI7O2lCQUVILE9BRE0yakI7U0FFUDNnQixjQUFMMVQ7S0FBYSxHQUFBLFdBRkgyUSxHQUVWM1E7TUFBOEIsaUJBQTlCQSxHQUZZcTBCO01BQUFBO2NBRVAzZ0I7OztjQUFBQTs7R0FFRztZQUdWNGdCLE9BQU81akIsR0FBR0MsR0FBSSxPQUFJLGdCQVJsQnlqQixXQVFPMWpCLEdBQUdDLElBQXlCO1lBRW5DOFksU0FBUy9ZLEdBQUdDO0lBQ2QsWUFEV0Q7SUFDSTtpQkFDTDtLQUVDLElBREZnRCxjQUFMMVQsY0FHR21ZLElBRkksV0FKR3hILEdBR1YzUTtRQUdHbVksR0FBZSxPQUFmQTthQUhFekU7O0dBS0g7R0FJVSxJQUFaNmdCO1lBREZDLGFBRWU5akIsR0FBR0M7SUFDWixZQWROOFksU0FhZS9ZLEdBQUdDO2dCQUVSLE1BQUEsNEJBSFI0akI7UUFJS3YwQjtJQUFLLE9BQUxBO0dBQU07WUFNYjBwQixLQUFLaFosR0FBR0M7SUFDVixZQURPRDtJQUNRO2lCQUNMO1NBQ0RnRCxjQUFMMVQ7S0FBYSxHQUFBLFdBSFAyUSxHQUdOM1EsSUFBc0IsV0FBdEJBO2FBQUswVDs7R0FFSDtHQUlVLElBQVorZ0I7R0FDSixTQUZFQyxTQUVlaGtCLEdBQUdDO0lBQ2xCLElBRGVpRyxNQUFBbEc7SUFDZjtVQURla0csS0FFUCxNQUFBLDRCQUhONmQ7U0FDYTVkLE1BQUFELFFBR2I1VyxJQUhhNFc7S0FHQSxHQUFBLFdBSEdqRyxHQUdoQjNRLElBQXNCLE9BQXRCQTtLQUhhNFcsTUFBQUM7O0dBRzZCO1lBTTVDOGQsTUFDYWprQixHQURKQztJQUNYLElBQWFoSCxPQUFFaU4sTUFBQWxHO0lBQ2I7VUFEYWtHLEtBRUw7U0FGS2xELElBQUFrRCxRQUdYNVcsSUFIVzRXO0tBR0UsR0FBQSxXQUpOakcsR0FDRWhILEdBR1QzSixJQUF3QixlQUhmMkosR0FHVDNKO0tBQThDLElBSHJDd1YsTUFHcUMsNEJBSHJDN0w7S0FBQUEsSUFBQTZMO0tBQUVvQixNQUFBbEQ7O0dBS1A7R0FJUSxJQUFaa2hCO1lBREZDLFVBRVlua0IsR0FBR0M7SUFDVCxZQVpOZ2tCLE1BV1lqa0IsR0FBR0M7Z0JBRUwsTUFBQSw0QkFIUmlrQjtRQUlLNTBCO0lBQUssT0FBTEE7R0FBTTtZQUtiODBCLFVBQ2Fwa0IsR0FEQUM7SUFDZixJQUFhaEgsT0FBRWlOLE1BQUFsRztJQUNiO1VBRGFrRyxLQUVMO0tBRUMsSUFKSWxELElBQUFrRCxRQUdYNVcsSUFIVzRXLFFBS1IyWCxTQURJLFdBTEk1ZCxHQUNGaEgsR0FHVDNKO1FBRUd1dUIsUUFBb0IsT0FBcEJBO0tBQ2EsSUFOUC9ZLE1BTU8sNEJBTlA3TDtLQUFBQSxJQUFBNkw7S0FBRW9CLE1BQUFsRDs7R0FRUDtHQUlRO0lBQVpxaEI7WUFERkMsY0FFZ0J0a0IsR0FBR0M7SUFDYixZQWZObWtCLFVBY2dCcGtCLEdBQUdDO2dCQUVULE1BQUEsNEJBSFJva0I7UUFJSy8wQjtJQUFLLE9BQUxBO0dBQU07WUFNYmkxQixTQUNhdmtCLEdBRERDO0lBQ2QsSUFBYWhILE9BQUVpTixNQUFBbEc7SUFDYjtVQURha0csS0FFTDtLQUNNLElBSER5YixLQUFBemIsUUFHWHdiLEtBSFd4YixRQUdDLE9BQUEsV0FKRmpHLEdBQ0RoSCxHQUdUeW9CO0tBQVksV0FBQTtLQUFlLElBSGxCNWMsTUFHa0IsNEJBSGxCN0w7S0FBQUEsSUFBQTZMO0tBQUVvQixNQUFBeWI7O0dBS1A7WUFHTjZDLFFBQ2F4a0IsR0FERkM7SUFDYixJQUFhaEgsT0FBRWlOLE1BQUFsRztJQUNiO1VBRGFrRyxLQUVMO0tBQ00sSUFIRHliLEtBQUF6YixRQUdYd2IsS0FIV3hiLFFBR0MsT0FBQSxXQUpIakcsR0FDQWhILEdBR1R5b0I7S0FBWSxTQUFBO0tBQWUsSUFIbEI1YyxNQUdrQiw0QkFIbEI3TDtLQUFBQSxJQUFBNkw7S0FBRW9CLE1BQUF5Yjs7R0FLUDtPQU1OMUk7WUFDQW5aLFFBQVFFLEdBQUksT0FBSkEsRUFBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUVieWtCO1lBeUJJQyxhQUFhdGlCLElBQUdDLElBQUcrVjtJQUN6QixLQURzQi9WLElBRWQsT0FGV0Q7U0FBQUEsSUFLUixPQUxXQztlQUFIRCxPQU1adWlCLEtBTll2aUI7ZUFNSixXQUFSdWlCLElBTmV0aUI7d0JBT1h1aUI7ZUFBUSxXQURaRCxRQUNJQyxJQVBXdmlCO3dCQVFQd2lCO2VBQVEsV0FGaEJGLFFBQ0lDLFFBQ0lDLElBUk94aUI7eUJBU0h5aUI7Z0JBQVEsV0FIcEJILFFBQ0lDLFFBQ0lDLFFBQ0lDLElBVEd6aUI7O0tBVWFzZjtLQUFOb0Q7O09BbkMzQk4sbUJBeUJ1QnJNO1VBZEgsdUJBQVcsZ0JBd0JFdUosS0FWYnRmO1VBQWhCcWlCLGFBVTZCL0MsSUFWYnRmLElBbUJRLDRCQW5CTCtWO0lBV3BCLFdBTEV1TSxRQUNJQyxRQUNJQyxRQUNJQyxRQUNVQztHQVNjO1lBR3pDMWxCLE9BQU8rQyxJQUFHQyxJQUFLLE9BdEJYcWlCLGFBc0JHdGlCLElBQUdDLE9BQXlCO1lBOEIvQjJpQixVQUFXL2tCLEdBQUUrQyxHQUFFaWlCO0lBQ3JCLEtBRG1CamlCLEdBRVg7ZUFGV0EsTUFHZmtpQixPQUhlbGlCO2VBSVIsSUFBTG1pQixPQUFLLFdBSk1sbEIsR0FHYmlsQixPQUVGLFdBRElDO3dCQUVFQzs7S0FDRyxJQUFMQyxPQUFLLFdBUE1wbEIsR0FHYmlsQixPQUtFSSxPQUFLLFdBUk1ybEIsR0FNVG1sQjtLQUdOLFdBRklDLFVBQ0FDOzt3QkFFTUM7O0tBQ0Q7TUFBTEMsT0FBSyxXQVhNdmxCLEdBR2JpbEI7TUFTRU8sT0FBSyxXQVpNeGxCLEdBTVRtbEI7TUFPRk0sT0FBSyxXQWJNemxCLEdBVUxzbEI7S0FJVixXQUhJQyxVQUNBQyxVQUNBQzs7MkJBRVVDOztLQUNMO01BQUxDLE9BQUssV0FoQk0zbEIsR0FHYmlsQjtNQWNFVyxPQUFLLFdBakJNNWxCLEdBTVRtbEI7TUFZRlUsT0FBSyxXQWxCTTdsQixHQVVMc2xCO01BU05RLE9BQUssV0FuQk05bEIsR0FlRDBsQjtLQUtkLFdBSklDLFVBQ0FDLFVBQ0FDLFVBQ0FDOztJQUdLO0tBRHFCcEU7S0FBTnFFO0tBQ3BCQyxLQUFLLFdBdEJNaG1CLEdBR2JpbEI7S0FvQkVnQixLQUFLLFdBdkJNam1CLEdBTVRtbEI7S0FrQkZlLEtBQUssV0F4Qk1sbUIsR0FVTHNsQjtLQWVOYSxLQUFLLFdBekJNbm1CLEdBZUQwbEI7S0FXVlUsS0FBSyxXQTFCTXBtQixHQXFCUytsQjtPQWxHeEJ2QixtQkE2RW1CUTs7Ozs7Ozs7Ozs7Ozs7OztnQkFqQlJxQixVQVlUeGUsS0EwQjRCNlo7O2tCQTFCNUI3Wjt3QkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7YUFWUztjQUQ2Q3llO2NBQU5DO2NBQU5DO2NBQU5DO2NBQU4zQjtjQUFORDtjQUFORDtjQUFORDtjQUFORDtjQUFOZ0MsS0FXQTdlO2NBVkk4ZSxPQUFLLFdBZUkzbUIsR0FoQmIwbUI7Y0FFSUUsT0FBSyxXQWNJNW1CLEdBaEJQMGtCO2NBR0ZtQyxPQUFLLFdBYUk3bUIsR0FoQkQya0I7Y0FJUm1DLE9BQUssV0FZSTltQixHQWhCSzRrQjtjQUtkbUMsT0FBSyxXQVdJL21CLEdBaEJXNmtCO2NBTXBCbUMsT0FBSyxXQVVJaG5CLEdBaEJpQjhrQjtjQU8xQm1DLE9BQUssV0FTSWpuQixHQWhCdUJ5bUI7Y0FRaENTLE9BQUssV0FRSWxuQixHQWhCNkJ3bUI7Y0FTdENXLE9BQUssV0FPSW5uQixHQWhCbUN1bUI7Y0FVM0M7O3FCQVRESSxNQUNBQyxNQUNBQyxNQUNBQyxNQUNBQyxNQUNBQyxNQUNBQyxNQUNBQyxNQUNBQztpQkFWS2Q7YUFBQUE7YUFZVHhlLEtBWHNEeWU7Ozs7Ozs7Ozs7Ozs7Ozs7S0FXM0MsSUFBQSxPQUFBLHdCQUFYemUsSUFLYTdILElBdEJKNEgsbUJBS0F5ZTs7NkJBTEF6ZTtNQUdKO09BRG1DNGI7O09BQVA0RDtPQUFKQztPQUFKQztPQUFKQztPQUFKQztPQUFKQztPQUFKQztPQUFKQztPQUFKQztPQUNJOztVQURKQTs7V0FBSUQ7ZUFBSUQsUUFBSUQsUUFBSUQsUUFBSUQsUUFBSUQsUUFBSUQsUUFBSUQsSUFGeEJ4ZjtNQUFBQTtjQUUrQjRiOzs7O2dCQW9CdEN1QixVQUFXL2tCLEdBcUJlMGhCLElBV3lDLDRCQWhDcERzRDtJQTJCbkIsV0FMSWdCLFFBQ0FDLFFBQ0FDLFFBQ0FDLFFBQ0FDO0dBTTZFO1lBd1R4RGhtQixJQXJUckIyQyxHQUFHL0MsR0FBSSxPQW5DUCtrQixVQW1DRy9rQixHQUFIK0MsTUFBdUI7WUFFM0I4a0IsWUFBWTluQixHQUFHTixNQUFNTztJQUNiLElBQU51WSxVQURhOVk7SUFFUixPQWlUa0JXO2FBblRiTDtzQkFFQTFRO2NBQ1o7ZUFBaUIsUUFBQSxXQUhJMlEsR0FDbkJ1WSxRQUNVbHBCO2VBQ0NDO2VBQVR3NEI7Y0FGRnZQLFNBRUV1UDtjQUVKLE9BRmF4NEI7YUFFWjtHQUFDO1lBR0Z5NEIsU0FBU2hvQixHQUFHTixNQUFNTztJQUNwQjtLQUFJdVksVUFEVTlZO0tBRVZtZTtPQXlTdUJ4ZDtTQTNTaEJMO2tCQUdLMVE7VUFDWjtXQUFpQixRQUFBLFdBSkQyUSxHQUNoQnVZLFFBRVlscEI7V0FDQ0M7V0FBVHc0QjtVQUhKdlAsU0FHSXVQO1VBRUosT0FGYXg0QjtTQUVaO0lBRUwsV0FQSWlwQixRQUNBcUY7R0FNUTtZQW1TZXJRLFdBaFNqQnhLLEdBQUUvQyxHQUFJLE9BZ1NXSSxJQWhTakIyQyxHQUFFL0MsR0FBWTtZQUN0QmdvQixRQUFRN2xCLElBQUdDLElBQUlwQztJQUFJLE9BQUksZ0JBQUEsd0JBQWZtQyxJQUFHQyxJQUFJcEM7R0FBOEI7WUFDN0M2TyxLQUFLMU0sSUFBR0MsSUFBSXBDO0lBQUksT0F0VmhCb2lCO2FBc1ZLamdCO2FBQUdDOztjQUErQixxQixPQUR2QzRsQixrQkFDWWhvQjs7R0FBdUM7WUFFbkRpb0IsU0FBUzlsQixJQUFHQyxJQUFJcEM7SUFwV2hCaWlCLGdDQW9XUzlmLElBQUdDO0lBQ2QsT0FKRTRsQixRQUdTN2xCLElBQUdDLElBQUlwQztHQUVGO1lBR2Rrb0IsWUFDVy9sQixJQUFHQyxJQUFHa2dCLElBREt0aUI7SUFDeEIsSUFBYW1vQixPQUFBaG1CLElBQUdpbUIsT0FBQWhtQixJQUFHaW1CLE9BQUEvRixJQUFHZ0c7SUFDcEI7UUFEV0g7U0FBR0MsUUFBR0M7T0FHK0I7UUFIL0JFLE9BQUFGO1FBR0t6RCxLQUhMeUQ7UUFBSEcsT0FBQUo7UUFHRnpELEtBSEV5RDtRQUFISyxPQUFBTjtRQUdUekQsS0FIU3lEO1FBQVNPLFdBRzZCLFdBSjNCMW9CLEdBSXBCMGtCLElBQVVDLElBQVVDLEtBSEYwRDtPQUFUSCxPQUFBTTtPQUFHTCxPQUFBSTtPQUFHSCxPQUFBRTtPQUFHRCxLQUFBSTs7OztlQUFOTixVQUFHQyxNQUVELE9BRklDO0tBSWIsTUFBQTs7R0FFTztZQUdkSyxTQUFTeG1CLElBQUdDLElBQUdrZ0IsSUFBSXRpQjtJQUFJLE9BaFV2QjZpQjthQWdVUzFnQjthQUFHQzthQUFHa2dCOztjQUFrQztlQUFBLHFCLE9BVmpENEYsMkJBVW1CbG9COztHQUE4QztZQUVqRTRvQixhQUFhem1CLElBQUdDLElBQUdrZ0IsSUFBSXRpQjtJQTVVdkJ3aUIsb0NBNFVhcmdCLElBQUdDLElBQUdrZ0I7SUFDckIsT0FiRTRGLFlBWWEvbEIsSUFBR0MsSUFBR2tnQixJQUFJdGlCO0dBRUY7WUFHckI2b0IsUUFBUTFtQixJQUFHQyxJQUFHa2dCLElBQUl0aUI7SUFBSSxPQUFJLGdCQWpCMUJrb0IsWUFpQlEvbEIsSUFBR0MsSUFBR2tnQixJQUFJdGlCO0dBQWlDO1lBQ25EZ1AsS0FBSzdNLElBQUdDLElBQUdrZ0IsSUFBSXRpQjtJQUFJLE9BeFVuQjZpQjthQXdVSzFnQjthQUFHQzthQUFHa2dCOztjQUFrQztlQUFBLHFCLE9BRDdDdUcsdUJBQ2U3b0I7O0dBQTBDO1lBRXpEOG9CLFNBQVMzbUIsSUFBR0MsSUFBR2tnQixJQUFJdGlCO0lBcFZuQndpQixnQ0FvVlNyZ0IsSUFBR0MsSUFBR2tnQjtJQUNqQixPQUpFdUcsUUFHUzFtQixJQUFHQyxJQUFHa2dCLElBQUl0aUI7R0FFRjtZQUdiK29CLGVBQWU1bUIsSUFBR0MsSUFBSXBDO0lBQzVCLElBRHFCbW9CLE9BQUFobUIsSUFBR2ltQixPQUFBaG1CO0lBQ3hCO1VBRHFCK2xCLE1BRWIsT0FGZ0JDO0tBR1EsSUFIWEssT0FBQU4sU0FHbkJhLElBSG1CYixTQUFHSyxXQUdTLFdBSEx4b0IsR0FHMUJncEIsSUFIc0JaO0tBQUhELE9BQUFNO0tBQUdMLE9BQUFJOztHQUdtQjtZQUd6Q3htQixNQUFNcUM7SUFDUixJQUFhNGtCLFNBS1IsZ0JBTkc1a0IsT0FDS0MsU0FBQTJrQixRQUFLOW1CLFFBQUdDO0lBQ25CO1VBRFdrQyxRQUVILFdBRlFuQyxJQUFHQztLQUdpQjtNQUh6QitCLFNBQUFHO2NBQUFBO01BR0xoVjtNQUFIRDtNQUhnQis0QixXQUdiOTRCLEdBSGE4UztNQUFIK2xCLFdBR2I5NEIsR0FIYThTO0tBQUxtQyxTQUFBSDtLQUFLaEMsS0FBQWdtQjtLQUFHL2xCLEtBQUFnbUI7O0dBS0E7WUFHbkJjLE9BQU83a0I7SUFDVDtLQUFhNGtCLFNBS1IsZ0JBTkk1a0I7S0FDSUMsU0FBQTJrQjtLQUFLOW1CO0tBQUdDO0tBQUdrZ0I7SUFDdEI7VUFEV2hlLFFBRUgsV0FGUW5DLElBQUdDLElBQUdrZ0I7S0FHMkI7TUFIdENuZSxTQUFBRztjQUFBQTtNQUdGNmtCO01BQUg3NUI7TUFBSEQ7TUFIbUJnNUIsV0FHYmMsR0FIYTdHO01BQUg4RixXQUdiOTRCLEdBSGE4UztNQUFIK2xCLFdBR2I5NEIsR0FIYThTO0tBQUxtQyxTQUFBSDtLQUFLaEMsS0FBQWdtQjtLQUFHL2xCLEtBQUFnbUI7S0FBRzlGLEtBQUErRjs7R0FLQTtZQUd0QmUsUUFBUWpuQixJQUFHQztJQUNiO0tBQUksVUExREY0bEIsUUF5RFE3bEIsSUFBR0MsYUFDT2UsR0FBRUMsR0FBSyxXQUFQRCxHQUFFQyxHQUFTO0tBQTNCOzs7S0FDbUUsVUFBQSxtQkFGMURoQjtLQUVOLE9BQUEsV0FwakJMMUUsbUJBb2pCeUQsbUJBRmpEeUU7O0dBRTJFO1lBR25Ga25CLElBQUlsbkIsSUFBR0M7SUFBSyxPQTdEWnlNLEtBNkRJMU0sSUFBR0MsYUFBa0JlLEdBQUVDLEdBQUssV0FBUEQsR0FBRUMsR0FBUztHQUFPO1lBSTNDa21CLFNBQVN2bUIsR0FBRy9DO0lBQ2QsSUFBYWhILE9BQUV1ZixpQkFESnhWOztpQkFFRCxPQURLd1Y7S0FFWTtNQUFsQnhZO01BQUxpcEI7TUFBdUIsWUFBQyxXQUhkaHBCLEdBQ0RoSCxHQUVUZ3dCLElBRld6UTtNQUVJLE1BQUEsNEJBRk52ZjtLQUFBQTtLQUFFdWY7YUFFTnhZOztHQUVFO1lBR1RNLEtBQUswQyxHQUFHL0MsR0FBSSxPQUFJLGdCQVJoQnNwQixTQVFLdm1CLEdBQUcvQyxJQUF1QjtZQUUvQnVwQixhQUFheHBCLEdBQUdOLE1BQU1PO0lBQ2QsSUFBTnVZLFVBRGM5WTtJQUVSLE9BSlJZO2FBRWFOO3NCQUVBL0csR0FBRTNKO2NBQ2Y7ZUFBaUIsUUFBQSxXQUhLMlEsR0FFVGhILEdBRFh1ZixRQUNhbHBCO2VBQ0ZDO2VBQVR3NEI7Y0FGRnZQLFNBRUV1UDtjQUVKLE9BRmF4NEI7YUFFWjtHQUFDO1lBR0ZrNkIsVUFBVXpwQixHQUFHTixNQUFNTztJQUNyQjtLQUFJdVksVUFEVzlZO0tBRVhtZTtPQVpGdmQ7U0FVVU47a0JBR0svRyxHQUFFM0o7VUFDZjtXQUFpQixRQUFBLFdBSkEyUSxHQUdKaEgsR0FGYnVmLFFBRWVscEI7V0FDRkM7V0FBVHc0QjtVQUhKdlAsU0FHSXVQO1VBRUosT0FGYXg0QjtTQUVaO0lBRUwsV0FQSWlwQixRQUNBcUY7R0FNUTtZQUdWemQsTUFBTTRDLEdBQUcvQztJQUVSO01BNU9EaWdCO01BME9NbGQ7O2VBRWtCL0osR0FBRTNKO09BQ3ZCLFdBSE0yUSxHQUVlaEgsR0FBRTNKO09BQ3ZCLE9BQUEsNEJBRHFCMko7TUFFaEI7SUFGUDtHQUdNO1lBR1B5d0IsTUFBTTFwQixHQUFHTixNQUFNTztJQUNiOztPQUFBO1NBblBGaWdCO1NBa1BNbGdCO2dCQUFHTjt5QkFDa0M2TztVQUFkLElBQVNpSyxnQkFBSHZmLGNBQW9CLE1BQUEsV0FEeENnSCxHQUNvQmhILEdBQUd1ZixLQUFLaks7VUFBSyxXQUFBLDRCQUFidFY7U0FBOEI7SUFBL0QsT0FBQTtHQUFnRTtZQUdsRTB3QixRQUFRM21CLEdBQUcvQztJQUNiLE9BQUk7O2FBTEZ5cEI7ZUFJUTFtQjs7d0JBQ1cwWCxLQUFJbEMsS0FBSWxwQjtnQkFBSyxPQUFHLFdBRHhCMlEsR0FDUXlhLEtBQVFwckIsU0FBQUEsR0FBSmtwQixPQUFBQTtlQUEwQztHQUFXO1lBRzVFb1IsT0FBTzVtQixHQUFHL0M7SUFDWixLQURTK0MsR0FFRDtRQUNBMmUsS0FIQzNlLE1BR1AwZSxLQUhPMWU7SUFHSyxXQUFLLFdBN1BqQmtkLFdBNlBNeUIsSUFBTkQsSUFIVXpoQjtHQUc0QjtZQUd0QzRwQixXQUFXN21CLEdBQUcvQztJQUNWLFlBUEoycEIsT0FNVzVtQixHQUFHL0M7Z0JBRU4sT0FBQTtRQUNIc087SUFBSyxPQUFMQTtHQUFNO1lBR1h1YixnQkFBZ0I5bUIsR0FBRy9DO2FBa0JiOHBCLFdBQVdDLEtBQUl4UixLQUFJbHBCO0tBQ3pCLElBRGlCMjZCLFFBQUFELEtBQUlFLFFBQUExUixLQUFJbkMsTUFBQS9tQjtLQUN6QjtNQUFHLFNBQUEsNkJBRGMyNkIsV0FFWixXQUZvQjVULEtBQUo2VDtXQUFBQTtPQUtYLE1BQUE7TUFJK0I7T0FUcEJDLFFBQUFEO09BU2pCMzZCLElBVGlCMjZCO09BQUluSyxNQVNnQixXQTNCdEI5ZixHQTJCZjFRLEdBVHFCOG1CO09BQVIrVCxRQVNTLDZCQVRUSDtNQUFBQSxRQUFBRztNQUFJRixRQUFBQztNQUFJOVQsTUFBQTBKOztJQVN3QjtJQVE3QyxZQXZESjJKLE1Bb0JnQjFtQixNQWtCVittQjtnQkFrQkE7UUFDRGppQixlQUFMeFk7SUFBVztZQUFLO2NBM1NoQjR3QixXQTJTS3BZLElBQUx4WSxZQUF5Q0EsR0FBRUMsR0FBSyxPQUFBLFdBckM3QjBRLEdBcUN3QjFRLEdBQUZELEdBQVk7R0FBRTtZQUd2RCs2QixvQkFBb0JybkIsR0FBRy9DO0lBQ25CLFlBekNKNnBCLGdCQXdDb0I5bUIsR0FBRy9DOztLQUVmLE9BQUE7UUFDSHNPO0lBQUssT0FBTEE7R0FBTTtZQUdYK2IsT0FBT3RuQixHQUFHdW5CO0lBRVY7S0FERUM7T0FuRUZkO1NBa0VPMW1COztrQkFFa0IvSixHQUFFdWYsS0FBSWxwQjtVQUM3QixLQUR5QmtwQixLQUVqQixlQUZxQmxwQjtjQUdWcXlCLEtBSE1uSixRQUd2QmlTLGdCQUh1QmpTO1VBSXBCLE9BQUEsV0FORytSLFNBRWV0eEIsR0FJVixtQkFEWHd4QixnQkFIMkJuN0I7NEJBQUFBLFdBRzNCbTdCLGVBQWlCOUk7NEJBSFVyeUIsR0FHM0JtN0IsZ0JBQWlCOUk7U0FHYztJQUdyQyxPQVZJNkksU0FZRyxvQkFaSEE7R0FZbUI7WUFHckJFLE1BQU0xbkIsR0FBR3VuQjtJQUFRLE9BaEJqQkQsT0FnQk10bkIsbUJBQWtDMVQsR0FBRUMsR0FBSyxPQUFBLFdBQXRDZzdCLFNBQStCajdCLEdBQUVDLEdBQWM7R0FBQztZQUV6RG83QixlQUFlM25CLEdBQUczTTtJQUNwQixPQUhFcTBCO3FDQUVlMW5CLEdBQUczTTtzQkFDMkIvRyxHQUFFQyxHQUFLLGFBQUEsV0FEbEM4RyxTQUMyQi9HLEdBQUVDLFdBQXFCO0dBQUM7WUFtRzVDcTdCLFdBaEdkNW5CLEdBQUcvQztJQUNoQixJQUFZdVksaUJBREN4Vjs7aUJBRUgsT0FBQSxnQkFERXdWO0tBRVE7TUFBVm1KO01BQU5EO01BQWdCLFFBQUEsdUJBQVksV0FIaEJ6aEIsR0FHWnloQixLQUZRbEo7S0FBQUE7YUFFRm1KOztHQUVGO1lBR05rSixZQUFZN25CLEdBQUcvQztJQUNqQixJQUFZNnFCLFVBQUt0UyxpQkFESHhWOztpQkFFSixPQUFBLGdCQURPd1Y7S0FFYztNQUFyQm1KO01BQU5EO01BQTJCLFFBQUEsdUJBQVksV0FIMUJ6aEIsR0FDTDZxQixNQUVScEosS0FGYWxKO01BRUcsU0FBQSw0QkFGUnNTO0tBQUFBO0tBQUt0UzthQUVQbUo7O0dBRUE7WUFHUm9KLE1BQ2Uzb0IsSUFBR0MsSUFETGhNO0lBQ2YsSUFBYW1pQixTQUdUNFAsT0FIYWhtQixJQUVUaW1CLE9BRllobUI7SUFDbEI7VUFFRStsQixNQURVLE9BQUEsdUJBRkQ1UCxLQUVMNlA7VUFBQUEsTUFDTSxPQUFBLHVCQUhEN1AsS0FHVDRQO1NBSGdCL21CLEtBRVpnbkIsU0FFTTJDLEtBRk4zQyxTQUZTam5CLEtBR2JnbkIsU0FDQTZDLEtBREE3QztLQUVHLE9BQUEsV0FOUS94QixTQUtYNDBCLElBQVVEO01BQ2tELElBTG5EZCxZQUlDYyxJQUpEeFM7TUFBQUEsTUFBQTBSO01BRUw3QixPQUZZaG5COztVQUtnQixJQUx2QjhvQixZQUlUYyxJQUpTelMsTUFBQUEsTUFBQTJSLE9BR1QvQixPQUhhaG5COztHQU9KO1lBU1Q4cEIsT0FBSzluQixHQUFFQyxHQUFHcEQ7SUFBSSxPQStEUzJxQjthQS9EbEJ4bkI7c0JBQThCOVQ7Y0FBSyxPQStEakIrUSxJQS9EaEJnRCxZQUErQzlULEdBQUssT0FBQSxXQUFqRDBRLEdBQXlCM1EsR0FBbUJDLEdBQVU7YUFBQztHQUFDO1lBK0QzQzRkLFNBOURoQjdkLEdBQUksV0FBSkEsTUFBUztZQThET2llLFlBNURmdk4sR0FBRUMsR0FBSSxPQTREUzJxQixXQTVEZjVxQixHQUFFQyxHQUFhO0dBT1g7SUFBTnlPLHdCQXFEaUJyTzs7MkNBQUE4TSxVQS9EdkIrZCxRQVVNeGM7SUFRQW9JLHdCQTZDaUJ6VzswQ0FBQXVxQixZQUFBemQsVUE3Q2pCMko7SUE2Q2lCN007SUFBQTJEO0lBQUFEO0lBQUFEO0lBOUJ2QitCO0lBQ0F0QjtJQUNBZ2Q7SUFDQXA3QjtJQUNBb2Y7SUFDQUU7SUFJRXphO0lBQ0FDO0lBQ0FDO0lBY21CO0lBTkgsaUJBV0txWSxVQUFBeWQsWUFBQXZxQixLQTdCdkI4TjtJQTZCRyxtQkFBb0JoQixVQUFBSSxhQUFBQztJQUFwQixrQkFBb0JELGFBQUFDO1lBR3JCNGQsU0FBUzltQjtJQUNmLElBRGVDLFNBQUFEO0lBQ2Y7VUFEZUMsUUFJUCxPQUFBO1NBRkpqVixJQUZXaVY7VUFBQUEsV0FFSixPQUFQalY7U0FGVzhVLFNBQUFHO0tBQUFBLFNBQUFIOztHQUlnQjtZQUl6QmluQixLQUFLL21CO0lBQ1gsSUFEV0MsU0FBQUQ7SUFDWDtVQURXQyxRQUlIO1NBRkpqVixJQUZPaVY7VUFBQUEsV0FFQSxXQUFQalY7U0FGTzhVLFNBQUFHO0tBQUFBLFNBQUFIOztHQUlDO1lBR05rbkIsVUFBVWhuQixNQUFNaW5CLFFBQVFqMUI7SUFDOUIsSUFEZ0JpTyxTQUFBRCxNQUFNa25CLFdBQUFEO0lBQ3RCO1VBRHNCQyxVQUVkO1NBRmNDLFdBQUFELGFBR3BCOUosS0FIb0I4SjtLQUlwQixLQUpjam5CLFFBS0w7S0FDUTtNQU5ISCxTQUFBRztNQU1YbW5CLE9BTldubkI7TUFNRyxNQUFBLFdBTldqTyxPQUc1Qm9yQixJQUdHZ0s7S0FBYyxVQUFBO0tBTkhubkIsU0FBQUg7S0FBTW9uQixXQUFBQzs7R0FNNkM7WUFHakVFLDJCQUEyQjNyQixHQUFHMUo7SUFDaEMsS0FENkIwSixHQUVyQjtRQUVVa0csTUFKV2xHLE1BSWQ0ckIsS0FKYzVyQixNQUlkNnJCLE9BQUFELElBQUd6bEIsTUFBQUQ7SUFDZDtVQURjQyxLQUVOO1NBRk1DLE1BQUFELFFBQUgybEIsS0FBRzNsQjtLQUdFLEdBQUEsV0FQWTdQLE9BSWpCdTFCLE1BQUFDLEtBR3NCLGVBSHRCRCxNQUFBQztLQUFBRCxPQUFBQztLQUFHM2xCLE1BQUFDOztHQUtQO1lBSVQybEIsOEJBQWdDbG1CLEtBQXVCdkIsTUFBTWhPO0lBQy9ELEdBRGtDdVA7U0FBZ0JDLE1BQWhCRCxRQUFBbW1CLGdCQUFnQmxtQjs7U0FBaEJrbUI7U0FBdUIxbkIsTUFlakQ7O0tBQ0EybkIsT0FoQmlEM25CO0tBZ0J2RDRuQixZQWhCdUQ1bkI7S0FDNUM2bkIsVUFlWEQ7S0FmbUI5SzthQWViNks7O2lCQUFVLE9BQUEsb0JBZkxFLFNBQVEvSztTQUVYTyxlQUFOeUs7S0FDRyxHQUFBLFdBSndEOTFCLE9BRzNEODFCLFdBRlNEO1VBS0hFLHlCQU53QkwsZ0JBRzlCSSxZQUZTRDtNQUFBQSxVQUtIRTtjQUhBMUs7OztNQVNPLGtCQVhKd0ssU0FBUS9LO01BQVIrSyxVQUVUQztNQUZpQmhMO2NBRVhPOzs7R0FhdUI7WUFJL0IySyxlQUFlaG9CLE1BQU1qTztJQUN2QixHQURpQmlPLFFBQUFBO0tBS0Y7TUFEVGhPO2lCQUFNK2YsS0FBRS9tQixHQUFLLGFBQUEsV0FKSStHLFNBSVhnZ0IsS0FBRS9tQixXQUFxQjtNQUM3Qmk5QixTQUFTLGlCQUxFam9CLE1BQU1qTztLQU1yQixPQTFCQTAxQixpQ0F5QklRLFFBREFqMkI7O0lBRlUsT0FGQ2dPO0dBTTRCO1lBRzNDa29CLFdBQVd4cEIsR0FBRzNNO0lBQ2hCLElBQ2FrMkIsU0FEQSxpQkFEQXZwQixHQUFHM00sVUFFSG8yQixNQUFBRjtJQUNYO1FBRFdFO1VBQUE5SyxLQUFBOEs7U0FBQTlLO1dBR0QrSyxNQUhDL0ssT0FHVGdMLE1BSFNGO09BR3FCLFNBQUEsV0FMbEJwMkIsU0FLWnMyQixLQUFRRCxNQUErQyxXQUF2REM7T0FIU0YsTUFBQTlLOzs7O0tBRUs7O0dBR1A7WUFHVGlMLGFBQWFDLEtBQUt4MkI7SUFDcEIsT0FYRW0yQixXQVVhSyxLQUFLeDJCO0dBR0w7WUFHYnkyQixjQUFjOXBCLEdBQUczTTthQUlmZ0IsVUFBUStMLEdBQUVDO0tBQVMsVUFBQSxXQUpKaE4sU0FJUCtNLEdBQUVDO0tBQVMsT0FBQTtJQUFXO0lBQ3JCLElBQVRrcEIsU0FBUyxpQkFMR3ZwQixHQUlaM0w7U0FDQWsxQixRQWFJOztLQVhLUSxXQUZUUjtLQUVnQlMsU0FGaEJUO0tBRVNVLFdBQUFGO0tBQU9HLE9BQUFGO0tBQU1HO0tBQWlCM1U7SUFDekM7VUFEV3lVLFVBRUgsT0FGaUN6VTtTQUE5QjRVLFdBQUFILGFBQU9JLFNBQVBKO0tBSU4sU0FQSDUxQixVQUdnQjYxQixNQUFBRztTQUFNRjtPQUFiRixXQUFBRztPQUFPRixPQUFBRztPQUFNRjs7O09BUWlCLElBUkFqRCxZQUF2Qm1ELFFBQXVCN1U7T0FBOUJ5VSxXQUFBRztPQUFPRixPQUFBRztPQUFNRjtPQUFpQjNVLE1BQUEwUjs7VUFBOUIrQyxXQUFBRyxVQUFPRixPQUFBRyxRQUFNRjs7R0FZeUI7WUFTakRHLFVBQVVwbkIsS0FBRzVQO0lBQ2YsS0FEWTRQLEtBRUo7UUFSV3FnQixPQU1QcmdCLFFBR1ZtUSxNQUhVblEsUUFOT2xHLElBQUF1bUI7SUFDbkI7UUFEbUJ2bUI7TUFHTixJQUhNOEgsS0FBQTlILE1BR2pCMVEsSUFIaUIwUSxNQUdOLE1BQUEsV0FHRTFKLE9BSGJoSCxHQU1BK21CO01BTlcsUUFITXJXLElBQUE4SDs7Ozs7S0FTSCxpQkFBZHVPOztHQUE0RDtZQUc1RCtCLE1BQU1wWSxHQUFHQztJQUFJLE9BQUEsOEJBamlCYmlnQixXQWlpQk1sZ0IsR0FBR0M7R0FBOEI7WUFDdkNvWSxJQUFJbUIsR0FBRXhaLEdBQUdDO0lBQUksT0FBQSw4QkFsaUJiaWdCLFdBa2lCSTFHLEdBQUV4WixHQUFHQztHQUE4QjtZQUN2QzJZLFFBQVE1WSxHQUFHM0o7SUFBVSxPQUFBLDhCQW5pQnJCNnBCLFdBbWlCUWxnQixHQUFHM0o7R0FBNEM7WUFDdkR5aUIsUUFBUTlZLEdBQUczSjtJQUFVLE9BQUEsOEJBcGlCckI2cEIsV0FvaUJRbGdCLEdBQUczSjtHQUE0QztZQUV2RGszQixPQUFPdnRCLEdBQUdDO0lBQ1osT0FyVEV5cEI7YUFvVE8xcEI7O3NCQUNld3RCLEtBQUlwVixPQUFNaFY7Y0FBSyxPQUFHLFdBRDlCbkQsR0FDWXV0QixLQUFVcHFCO3dCQUFxQiw0QkFBM0JnVjt3QkFBQUE7YUFBK0M7R0FBQztZQUcxRTFZLEtBRVc4UyxHQUZIdlM7SUFDVixHQUNhdVMsT0FEQyxXQXo1Qlo3VSxtQkEwNUJXNlU7UUFBQXZaLElBQUF1WixHQUFFNE87SUFDYjtZQURXbm9CLEdBQ1gsTUFBQTtjQURXQSxHQUVHLE9BRkRtb0I7S0FFeUI7TUFGekJHLGNBRTBCLFdBSi9CdGhCLEdBSWlDLDRCQUY5QmhILFFBQUVtb0I7TUFBRnRjLE1BRW1CLDRCQUZuQjdMO0tBQUFBLElBQUE2TDtLQUFFc2MsUUFBQUc7O0dBSU47WUFHUGtNLGVBQ1d6cUIsR0FETy9DO0lBQ3BCLElBQWF3c0IsTUFBQXpwQixHQUFFb2U7SUFDYjtVQURXcUwsS0FFSCxPQUZLckw7S0FJSixJQUpFTyxLQUFBOEssUUFHVC9LLEtBSFMrSyxRQUlGLFFBQUEsV0FMU3hzQixHQUloQnloQjs7TUFFcUIsSUFBYnB5QixjQUxHaXlCLGNBS0hqeUIsR0FMRzh4QjtNQUFGcUwsTUFBQTlLO01BQUVQLFFBQUFHOzs7TUFBRmtMLE1BQUE5Szs7R0FRSjtZQUdQK0wsV0FBVzFxQixHQUFHL0MsR0FBSSxPQUFJLGdCQVp0Qnd0QixlQVlXenFCLEdBQUcvQyxJQUE2QjtZQUUzQzB0QixnQkFDYTNxQixHQURNL0M7SUFDckIsSUFBYWhILE9BQUV3ekIsTUFBQXpwQixHQUFFb2U7SUFDZjtVQURhcUwsS0FFTCxPQUZPckw7S0FJTixJQUpJTyxLQUFBOEssUUFHWC9LLEtBSFcrSyxRQUlKLFFBQUEsV0FMVXhzQixHQUNSaEgsR0FHVHlvQjs7TUFFNkI7T0FBckJweUI7T0FMS2l5QixjQUtManlCLEdBTEs4eEI7T0FBSnRjLE1BS1MsNEJBTFQ3TDtNQUFBQSxJQUFBNkw7TUFBRTJuQixNQUFBOUs7TUFBRVAsUUFBQUc7O1VBTUcsSUFOUHFNLE1BTU8sNEJBTlAzMEIsT0FBQUEsSUFBQTIwQixLQUFFbkIsTUFBQTlLOztHQVFKO1lBR1RrTSxZQUFZN3FCLEdBQUcvQyxHQUFJLE9BQUksZ0JBWnZCMHRCLGdCQVlZM3FCLEdBQUcvQyxJQUE4QjtZQUM3QzZ0QixXQUFXOXFCLEdBQUksT0FmZjBxQixXQWVXMXFCLGlCQUFJLGNBQXFCO1lBRXBDK3FCLGVBQ1cvdEIsR0FET0M7SUFDcEIsSUFBYWlHLE1BQUFsRyxHQUFFaEQsU0FBSUUsU0FBSTh3QjtJQUNyQjtVQURXOW5CO01BRWUsSUFBQSxNQUFBLGdCQUZMOG5CLE1BRUosTUFBQSxnQkFGQTl3QjtNQUVULFdBQUEsZ0JBRktGOztLQUlKLElBSkVtSixNQUFBRCxRQUdUNVcsSUFIUzRXLFFBSUYsUUFBQSxXQUxTakcsR0FJaEIzUTs7TUFHd0IsSUFBaEJDLGNBTk80a0IsWUFNUDVrQixHQU5PMk47TUFBTmdKLE1BQUFDO01BQU1qSixNQUFBaVg7OztNQU9hLElBQXBCRCxnQkFQVytaLFlBT1gvWixLQVBXOFo7TUFBVjluQixNQUFBQztNQUFVNm5CLE1BQUFDOztVQUtDLElBQVpDLGdCQUxHamEsWUFLSGlhLEtBTEdseEIsTUFBRmtKLE1BQUFDLEtBQUVuSixNQUFBaVg7O0dBU0E7WUFHYmthLGFBQWFudUIsR0FBR0M7YUFDZG11QixJQUFFOStCLEdBQWlCLE9BQUcsV0FEUjJRLEdBQ1ozUSxTQUFBQSxTQUFBQSxHQUFrRDtJQUN4RCxPQUFBLDBCQUZlMFEsR0FDWG91QjtHQUNjO1lBR2hCQyxpQkFBaUJydUI7SUFBSSxPQUFBLDBCQUFKQTtHQUF1QztHQWF4RCxTQVJFc3VCLFlBUUVDLFVBQVlDLFVBQVlDO0lBQzFCLE9BQUE7O3NCQU1NQztjQUxKLFNBS0lBO3lCQUFBQTs7OztpQkFIaUI7a0JBRGdCQztrQkFBWkM7a0JBQ2pCQyxXQUFhLFdBSnJCTixVQUd5Qks7a0JBRWpCRSxXQUFhLFdBTFROLFVBR3lCRztpQkFHakMsV0FGSUUsVUFDQUM7Ozs7Y0FHSixPQUFBO29EQVRKN08scUJBUUl5TzthQUlhO2FBWE9EO0dBWWpCO1lBR1RNLFlBT0VDLFVBQVlDLFVBQVlDO0lBQzFCLE9BQUE7OztjQUNFO2VBQWtCQztlQUFaQztlQUNDNWQsV0FBYSxXQUhwQndkLFVBRU1JO2VBRUNDLFdBQWEsV0FKUkosVUFFTUU7Y0FHZixlQUZJM2QsY0FDQTZkO2FBQzBDO2FBTHpCSDtHQU1qQjtZQUdSSSxpQkFLQ25hLGdCQUFpQkM7SUFDbkIsT0FFTTs7cUJBSEpELG9CQUFpQkM7R0FJaEI7WUFLSG1hLGNBRUFqckI7SUFGZ0IsS0FFaEJBLE1BRE0sTUFBQTtRQUNMa3JCLElBQURsckI7SUFBdUIsV0FBdEJrckIsR0FwUHNCbnZCLElBb1B2QmlFO0dBQXlDO1lBR3pDbXJCLFFBQU1DLE9BQU9wNUI7SUFDZixPQXhQeUIrSjthQXRHekJxcUI7ZUE2VlFnRjs7Z0JBQ1csSUFBYW5nQyxZQUFQRDtnQkFBb0IsV0FBQSxXQUQ5QmdILE9BQ1VoSCxHQUFPQztlQUF5QjthQU52RGdnQztHQU0rRTtZQUcvRUksaUJBQWVELE9BQU9yNUI7SUFDeEIsT0E1UHlCZ0s7YUFwR3pCc3FCO2VBK1ZpQitFOztnQkFDYSxJQUFhbmdDLFlBQVBEO2dCQUFnQixPQUFBLFdBRDVCK0csU0FDWS9HLEdBQU9DO2VBQXFCO2FBVjlEZ2dDO0dBV3FCO1lBR3JCMVYsT0FBSzdaLEdBQUcxSixPQUFNczVCO0lBQ1Y7O09BM3ZCTjVXO1NBMHZCT2haOztVQUNTLElBQU02dkI7VUFBWSxPQUFBLFdBRHhCdjVCLE9BQU1zNUIsS0FDTUM7U0FBMkI7Z0JBQ3ZDO1FBQ0h2Z0M7SUFBSyxXQUFLLDZCQUFWQTtHQUFpQjtHQUlSLElBQVp3Z0M7WUFERkMsV0FFVy92QixHQUFHMUosT0FBTXM1QjtJQUNkLFlBVE4vVixPQVFXN1osR0FBRzFKLE9BQU1zNUI7Z0JBRVYsTUFBQSw0QkFIUkU7UUFJS0U7SUFBUyxPQUFUQTtHQUFjO1lBTXJCQyxNQUFJandCLEdBQUcxSixPQUFNczVCLEtBQ2YsT0FsQkUvVixPQWlCSTdaLEdBQUcxSixPQUFNczVCLGFBR0M7WUFHZE0sT0FBT2x3QixHQUFHMUosT0FBTXM1QjtJQUFNLE9BenlCeEJoTTthQXl5QlM1akI7O2NBQTJCLElBQU02dkI7Y0FBZ0IsV0FBQSxXQUE5Q3Y1QixPQUFNczVCLEtBQXdCQzthQUFpQztHQUFBO1lBRXpFTSxJQUFJbndCLEdBQUcxSixPQUFNczVCLEtBQUlJO0lBRW5CLGVBRmVKLEtBQUlJLFFBRmpCRSxPQUVJbHdCLEdBQUcxSixPQUFNczVCO0dBRW9CO1lBR2pDUSxRQUFRcHdCO0lBQUksT0E5UldLO2FBOFJmTDs7Y0FBYSxJQUFTelEsY0FBSEQ7Y0FBUyxXQUFOQyxHQUFIRDthQUFjO0dBQUE7WUFDekMrZ0MsTUFBSXJ3QixHQUFHQztJQUFJLE9BL1JZSTthQStSbkJMOztjQUFnQixJQUFXZ3dCLGtCQUFMSjtjQUFlLFdBQWZBLEtBQW9CLFdBQXZDM3ZCLEdBQXdCK3ZCO2FBQXVCO0dBQUE7WUFHeERud0IsSUFBSW1ELEdBQUcwWCxLQUFLdmI7SUFHZCxVQUhTdWI7Ozs7ZUFBS3ZiOzs7O01BR2lCO09BQUEsTUFBQSxtQkFIekI2RDthQUd5QixpQ0FIakI3RCxPQUFMdWI7O1lBRzBDO0lBRWpELE9BQUE7O2FBL2RBZ1A7ZUEwZEkxbUI7O3dCQUtzQi9KLEdBQUV1ZixLQUFJOFg7Z0JBQzdCLEdBTkk1VixPQUttQnpoQixLQUFBQSxJQUNKLDRCQU5meWhCLEtBQUt2YjtpQkFNeUIsV0FETG14QixJQUFKOVg7Z0JBQ3dCLE9BRHhCQTtlQUMyQjtHQUFFO1lBR3pEK1gsUUFBUUMsUUFJS2hlO0lBSGYsUUFHZUEsR0FGVixjQUZLZ2U7UUFJSy9kLE1BQUFELEdBQUV4UyxJQUpQd3dCLFFBSVNwUDtJQUNmO2NBRFczTyxLQUVOLFdBQUEsZ0JBRlUyTyxRQUFGcGhCO1VBQUFBLEdBS0gsV0FUSnd3QjtLQVUwQjtNQU5uQjdPLEtBQUEzaEI7TUFNVDBoQixLQU5TMWhCO01BQUV1aEIsY0FNWEcsSUFOV047TUFBSjFPLE1BTVUsNEJBTlZEO0tBQUFBLE1BQUFDO0tBQUUxUyxJQUFBMmhCO0tBQUVQLFFBQUFHOztHQVFBO1lBSWpCa1AsS0FJZUQsUUFBRmhlO0lBSGYsUUFHZUEsR0FGVjtRQUVVQyxNQUFBRCxHQUFFeFMsSUFBQXd3QixRQUFFcFA7SUFDZjtjQURXM08sS0FFTixPQUFBLGdCQUZVMk87VUFBRnBoQixHQURaLE9BQ1l3d0I7S0FNbUI7TUFObkI3TyxLQUFBM2hCO01BTVQwaEIsS0FOUzFoQjtNQUFFdWhCLGNBTVhHLElBTldOO01BQUoxTyxNQU1VLDRCQU5WRDtLQUFBQSxNQUFBQztLQUFFMVMsSUFBQTJoQjtLQUFFUCxRQUFBRzs7R0FRQTtZQUdibVAsS0FBSzF3QixHQUFFd1M7SUFDYixJQUVFdE0sTUFIU2xHLEdBQUV5UyxNQUFBRDtJQUNiO1FBRUV0TTtVQUhTeWIsS0FHVHpiO01BRGEsT0FGRnVNO09BRW1CLElBRm5CQyxNQUVtQiw0QkFGbkJEO09BR1h2TSxNQUhTeWI7T0FBRWxQLE1BQUFDOzs7O0tBR04sT0FBTHhNOztHQUFNO1lBR055cUIsVUFFd0IzdEIsR0FGWGxCO0lBQ2YsR0FEZUEsYUFDSyxXQXptQ2xCbkUsbUJBd21DYW1FO1FBRU8wVyxTQUFJaVUsTUFBQXpwQjtJQUN4QjtVQUR3QnlwQixLQUVoQixPQUFBLGdCQUZZalU7S0FJRDtNQUFBLFFBM0NuQitYLFFBdUN3QjlELEtBRlgzcUI7TUFFVzh1QjtNQUlsQkM7TUFKYzNHLFlBSWQyRyxTQUpjclk7S0FBQUEsTUFBQTBSO0tBQUl1QyxNQUFBbUU7O0dBT1g7WUFHYkUsWUFBWWhwQixJQUFJN0g7SUFDbEIsSUFBYXVZLFNBRVR4WSxJQUhVOEg7O1FBR1Y5SDtVQURNMmhCLEtBQ04zaEIsTUFEQTBoQixLQUNBMWhCO01BRGMsR0FBQSxXQUZBQyxHQUVkeWhCO09BQTJCLGdCQUEzQkEsSUFEU2xKO09BQUFBO09BRVR4WSxJQURNMmhCOzs7O0tBQ0QsV0FBQSxnQkFGSW5KLE1BRVR4WTs7R0FFTTtZQUlSK3dCLFdBQVdqcEIsSUFBSTdIO0lBQ2pCLElBQWF1WSxpQkFEQTFROzs7VUFFSDZaLGVBQU5EO01BQWMsR0FBQSxXQUZEemhCLEdBRWJ5aEI7T0FBMkIsZ0JBQTNCQSxJQURTbEo7T0FBQUE7ZUFDSG1KOzs7O0tBQ0QsT0FBQSxnQkFGSW5KOztHQUlIO1lBR0p3WSxXQUFXaHhCLEdBQUdDO0lBQ3BCLElBRUVpRyxNQUhlbEc7SUFDakI7UUFFRWtHO1VBSGV5YixLQUdmemIsUUFEQXdiLEtBQ0F4YjtNQURjLEdBQUEsV0FGSWpHLEdBRWxCeWhCLEtBQ0F4YixNQUhleWI7O0tBR1YsT0FBTHpiOztHQUFNO1lBR04rcUIsVUFBVWp4QjtJQUNOLFlBQUEsZ0JBRE1BO2dCQUVKO1FBQ0Q2c0I7SUFBTyxXQUFLLGdCQUFaQTtHQUFxQjtZQUcxQnFFLGNBQWNseEI7SUFDVixZQVBKaXhCLFVBTWNqeEI7O0tBRU4sT0FBQTtRQUNINnNCO0lBQU8sT0FBUEE7R0FBVTtZQUdmc0Usa0JBSWFDLE9BQUdDO0lBSGxCLEdBQUcscUJBR2VBLFFBRmI7UUFFVWp2QixLQUFBZ3ZCLE9BQU1oUTtJQUNqQjtVQURXaGYsSUFLVCxPQUFBLGdCQUxlZ2Y7U0FBTk8sS0FBQXZmLE9BR1RzZixLQUhTdGY7U0FHVHNwQixPQUFBaEs7S0FBdUI7TUFIUkg7UUFHUTtzQkF0WUZsaEIsSUFtWVRneEIsZ0JBR29DL2hDLEdBQUssV0FBckRvOEIsTUFBZ0RwOEIsR0FBVSxJQUgzQzh4QjtLQUFOaGYsS0FBQXVmO0tBQU1QLFFBQUFHOztHQUtPO1lBRzFCaGlCLE9BQU95RCxHQUFJLE9BQUEsdUJBQUpBLEdBandCUDNELFdBaXdCMEM7WUFDMUNpeUIsZ0JBQWdCdHVCO0lBQUksT0FBbUI7YUF0ekJ2Q2tkO2FBc3pCZ0JsZDs7c0JBQTRCd1YsS0FBSXhWLEdBQUssT0FBQSx1QkFBTEEsR0FBSndWLEtBQXlCO0dBQUM7WUFDdEUrWSxLQUFLamlDLEdBQUUwVCxHQUFJLFdBQU4xVCxHQUFFMFQsR0FBVTtZQUVqQnd1QixVQUNXeHVCLEdBREUzTTtJQUNmLElBQWFvMkIsTUFBQXpwQjtJQUNYO1FBRFd5cEI7VUFBQXRwQixPQUFBc3BCO1NBQUF0cEI7O1FBR0Z5aEIsS0FIRXpoQjtRQUdUd2hCLEtBSFM4SDtjQUdrQixXQUpoQnAyQixTQUlYc3VCLElBQU9DOztPQUhFNkgsTUFBQXRwQjs7OztLQUVLOztHQUdaO1lBR0pzdUIsbUJBQ1d6dUIsR0FEVzNNO0lBQ3hCLElBQWFvMkIsTUFBQXpwQjtJQUNYO1FBRFd5cEI7VUFBQXRwQixPQUFBc3BCO1NBQUF0cEI7O1FBR0Z5aEIsS0FIRXpoQjtRQUdUd2hCLEtBSFM4SDtjQUdrQixXQUpQcDJCLFNBSXBCc3VCLElBQU9DOztPQUhFNkgsTUFBQXRwQjs7OztLQUVLOztHQUdaO0dBR08sZ0JBdnhCWDlEO1lBMnhCQTRmLFFBQVVwWixLQUFxQ3ZCO0lBQ2pELEdBRFl1QjtTQUFlQyxNQUFmRCxRQUFBcVosZUFBZXBaOztTQUFmb1o7SUFDWixHQURpRDVhO2VBQUFBOzs7T0FNckMsSUFBTm90QixNQUFNLDRCQU5xQ3B0QjtPQU8vQyx1Q0FQVTRhLHFCQU1Od1M7T0FDSixPQUFBLDRCQURJQTs7VUFGQ25pQyxZQUFIRCxJQUo2Q2dWO01BSWhDLE9BQUEsZ0NBSkw0YTtvQkFJTDN2QixPQUFIRDtnQkFKNkNnVjs7O0lBR2pDLE9BSGlDQTtHQVE5QjtZQUdqQnF0QixtQkFBcUI5ckIsS0FBcUN2QjtJQUM1RCxHQUR1QnVCO1NBQWVDLE1BQWZELFFBQUFxWixlQUFlcFo7O1NBQWZvWjtJQUNwQixHQUFBLHFCQUR5RDVhO0tBRXZELE9BQUE7SUFDNEMsVUFBQSxtQkFIV0E7SUFHMUMsT0FwbENoQnVkLFFBaWxDMER2ZCxNQUcxQywrQkFISzRhO0dBR3dDO1lBRzdEMFMsZUFBaUIvckIsS0FBcUN2QjtJQUN4RCxHQURtQnVCO1NBQWVDLE1BQWZELFFBQUFxWixlQUFlcFo7O1NBQWZvWjtJQUNuQjtLQUFJLGNBUEZ5Uyx1QkFNaUJ6UyxlQUFxQzVhO0tBQ3BEOztlQUNHO0dBQUk7WUFHTGpOLFVBQVF3NkIsS0FBSXp1QixHQUFFQztJQUNwQixJQURrQnNFLE1BQUF2RSxHQUFFd0UsTUFBQXZFO0lBQ3BCO1VBRGtCc0UsWUFBRUM7VUFBQUEsS0FJVDtLQUVEO01BTlVDLEtBQUFEO01BS1RyWSxJQUxTcVk7TUFBRkUsS0FBQUg7TUFLaEJyWSxJQUxnQnFZO01BTVo2SyxJQUFJLFdBTklxZixLQUtadmlDLEdBQVNDO0tBRVQsU0FESWlqQixHQUNpQyxPQURqQ0E7S0FOWTdLLE1BQUFHO0tBQUVGLE1BQUFDOztHQU9vQjtPQUd0Q25DO1lBRUFwUCxNQUNZQSxPQUFNOEssSUFBR0M7SUFBdkIsSUFBb0I2WixPQUFBOVosSUFBRytaLE9BQUE5WjtJQUNyQjtRQURrQjZaO1NBQUdDO09BR0c7UUFISDJXLE9BQUEzVztRQUdUeUosS0FIU3pKO1FBQUg0VyxPQUFBN1c7UUFHaEJ5SixLQUhnQnpKO1FBR00sTUFBQSxXQUhaNWtCLE9BR1ZxdUIsSUFBVUM7T0FBWSxVQUFBO09BSE4xSixPQUFBNlc7T0FBRzVXLE9BQUEyVzs7OztlQUFBM1csTUFFVDtLQUVMOztHQUVRO1lBR2Y2VyxVQW1CRUM7SUFBSyxJQVhrQkMsT0FXdkJELFFBVmNFLGFBQVFDO0lBQ3hCO1NBVDZCcHlCLElBT0preUIsTUFJdkJHLGdCQUFRQyxrQkFBY0M7S0FWeEI7V0FENkJ2eUI7a0JBQUFBOztPQUtpQjtRQUxqQjJoQixLQUFBM2hCO1FBSXJCOEg7UUFBTHhZO1FBSnVDa2pDLGNBSWxDMXFCLElBT0V3cUI7UUFYcUJHLG1CQUk1Qm5qQyxHQU9EK2lDO09BWDJCcnlCLElBQUEyaEI7T0FXM0IwUSxhQVg2Qkk7T0FXckJILGVBWGdDRTs7ZUFBYnZHLE9BQUFqc0IsTUFBQUEsSUFBQWlzQixNQVdMc0c7O1VBQXRCRixnQkFBUUMsY0FESyxXQUFLLGdCQUZKSDtLQUlkLEdBRHNCSSxhQUVqQjtLQUdIO01BRElHLFNBUGdCTixTQU9RLGdCQUo5QkMsY0FBQUE7TUFIc0JNLGVBQUFQO01BQVJRLGdCQU9SRixRQVBRUDtLQURTRCxPQUlmSTtLQUhNSCxVQUFBUztLQUFRUixTQUFBTzs7R0FVSDtHQUd6Qjs7O0dBR0U7Ozs7OztNQUVFO09BT1MsTUFBQTtNQUxZO09BRHdCRTtPQUNyQ0MsV0FBYSwrQ0FEd0JEO01BRXpDLHdCQURJQztLQUtjO1lBS3RCQyxjQUFjL3ZCO0lBQ1YsWUF4Q0pndkIsVUF1Q2NodkI7O0tBR04sTUFBQTtpREEzZmlCM0MsSUF3ZlgyQztRQUVUeXBCO0lBQUssT0FBTEE7R0FDcUU7WUFHMUV1RyxZQUFZaHpCLEdBQUd1UztJQUNqQixLQURjdlMsR0FFTjtRQUNEOEgsS0FITzlILE1BR1oxUSxJQUhZMFE7SUFHRDtZQUFYMVE7WUFBZ0I7O2NBQVh3WTt1QkFBMEN2WSxHQUFFaXBCLEtBQU8sV0FIekNqRyxTQUdnQ2hqQixHQUFFaXBCLE1BQXNCOztHQUFDO1lBR3hFRCxZQUFZdlksR0FBR04sTUFBTU87SUFBSSxPQUFBLDhCQTk2QnpCaWdCLFdBODZCZXhnQixNQUFNTyxHQUFURDtHQUFtRDtZQUMvRDBZLFdBQVcxWSxHQUFHTixNQUFNTztJQUFJLHdDQS82QnhCaWdCLFdBKzZCY3hnQixNQUFNTztJQUFJLHFCLDRCQUFiRDtHQUFrRDtZQUU3RGl6QixVQUFVM3VCLE1BQU00dUIsUUFBY3ZxQjtJQUNoQztLQUFJd3FCLFdBQVcsbUJBREg3dUI7S0FFUjh1QixhQUFhLG1CQUZDRjtXQUVkRSxjQURBRDs7Y0FqRUY3OEI7ZUFnRThCcVM7ZUE3TDFCK25CLEtBNkxNcHNCLE1BR3lDLDRCQUZqRDZ1QixVQUNBQztlQUZjRjs7R0FHa0U7Ozs7T0EvRTlFNzdCO09BVUpxTztPQXh0Q0VnTDtPQUNBNUc7T0FFQ0Y7T0E0T0h5UTs7OztPQTBIQTZGO09BODZCQTNIO09BQ0FHOzs7T0E3WUFMO09BbG5CQVc7T0F0QkFEO09BeUdBalo7T0FEQW1aO09BaWlCQUw7T0FDQUU7T0FuMkJBalA7O1FBNHNCRXNFO1FBRUFwZTtRQUVBc2Y7UUFEQUY7UUFKQU07UUFqQ0F5YjtRQW1DQUM7WUFPRXYyQixVQUVBRSxVQURBRCxVQW9CcUIyWTtRQUFBRDtRQUFBQztZQUFBRCxhQUFBQztRQUFBb2Q7UUFBQXpkO1FBQUE5TTtRQUFBcU47UUFBQUM7UUFBQTFEO1FBQUEyRDtZQUFBVCxVQUFBSSxhQUFBQztPQUFBRDtPQUFBQzs7T0FBQW9kO09BQUF6ZDtPQUFBTztPQUFBQztPQUFBMUQ7T0FBQTJEOzs7T0F4dUJ6QmhPO09BMkRBZ2lCO09BWUFDOzs7T0FNQUM7O09Bc0ZBa0I7T0FGQUQ7T0FTQUc7T0FGQUQ7T0FTQUc7T0FGQUQ7T0E0SEFvQjtPQW5IQWpCO09BRkFEO09BOEhBbUI7T0FySEFoQjtPQUZBRDtPQXlCQUs7T0FSQUY7T0FzV0FpRzs7T0EwVkFvRTtPQWFBSTtPQUtBRTtPQW1IQWtDOzs7T0EzWEF4RjtPQXptQkFySjtPQU1BQzs7O09BNE1Bc0M7T0FTQUU7T0FwQkFIO09BbkJBRjtPQWlEQU07T0FZQUU7T0FrRkFqbEI7T0FzWHlCZ0I7T0FuVHpCeW5CO09BZ0dBMEI7T0F4RkF4QjtPQWdHQXlCO09BMk15Qm1CO09BeEZ6QkM7T0FwTUEzQztPQUZBcFo7T0FtQkErWjtPQUZBRDtPQVVBRztPQUZBOVo7T0FPSStaOztPQTVLSjlJO09Ba0xBamU7T0FTQWtuQjtPQWNBRztPQUxBRDtPQWlCQS9vQjtPQVJBaXBCO09BNkJBbnBCO09BUUFzcEI7T0FjQUc7T0FOQUQ7T0FZQUU7T0F3Q0FPO09Bc0JBSztPQWhCQUo7T0FrQkFLO09Bb2JBZ0c7T0FyVUl0RjtPQVJBRDtPQWVBRTtPQXFmSjJIO09BNWVBdEg7T0FhQUk7T0FvQkFPO09BU0FFO09BVUFJO09BTUFFO09BNEJBUTtPQU1BbFY7T0FLQW1WO09BMXpCQS9MO09BeENBZDtPQXMyQkFoaEI7T0FTQSt0QjtPQWNBRTtPQUZBRDtPQWNBRztPQUNBQzs7UUF5QkVRO1FBdUJBUztRQWdCQ087UUFxRERhO1FBekJBdFc7UUFNQWtXO1FBV0FFO1FBTUFDO1FBUUFHO1FBREFEO1FBdkNBWDtRQUlBRTtPQXVDRjl2QjtPQXlCQTR3QjtPQWVJQztPQTJCSks7T0FRSUM7T0FqQkpGO09BdUJBRztPQU1BQztPQWtCQTN4QjtPQUNBK3hCO09BQ0FDO09BZEFKO09Bc0NBbFM7T0FpQkEyUztPQU5BRDtPQWpDQUg7T0FTQUM7T0ErQ0FuN0I7O09BVUEwN0I7T0F1Q0FlO09BTUFDOzs7RTs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7SUN4b0NDcHBCO0lBaUZHUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQW5ORVA7SUFDTDs7T0FFb0IsSUFER1UscUJBQ2hCNm9CLFdBQWEseUJBREc3b0I7T0FFcEIsd0JBREk2b0I7O09BR2E7UUFEVkM7UUFDSEMsV0FBYSw2QkFEVkQ7T0FFUCx3QkFESUM7O09BR2E7UUFEYjNvQjtRQUNBNG9CLFdBQWEsNkJBRGI1b0I7T0FFSix3QkFESTRvQjs7T0FHYSxJQURaQyxxQkFDREMsV0FBYSx5QkFEWkQ7T0FFTCx3QkFESUM7O09BR2E7UUFEaUJDO1FBQVpDO1FBQVpDO1FBQ05wVCxXQUFhLDZCQURQb1Q7UUFFTkMsV0FBYSx5QkFGS0Y7UUFHbEJHO1VBQWE7NkRBSGlCSjtPQUlsQyx3QkFISWxULGNBQ0FxVCxjQUNBQzs7T0FJYTtRQURFQztRQUFabmY7UUFDSHpELFdBQWEsNkJBRFZ5RDtRQUVIb2YsV0F0QkZucUIsVUFvQmlCa3FCO09BR25CLHdCQUZJNWlCLGNBQ0E2aUI7O09BR2E7UUFEZ0JDO1FBQVpDO1FBQVpDO1FBQ0xuakIsV0FBYSw2QkFEUm1qQjtRQUVMQyxXQUFhLHlCQUZJRjtRQUdqQkcsV0EzQkZ4cUIsVUF3QitCb3FCO09BSWpDLHdCQUhJampCLGNBQ0FvakIsY0FDQUM7O09BSWE7UUFESUM7UUFBWkM7UUFDTEMsV0FBYSwrQ0FEUkQ7UUFFTEUsV0FBYSw2QkFoQ2Y1cUIsV0E4Qm1CeXFCO09BR3JCLHdCQUZJRSxjQUNBQzs7T0FHYTtRQURXQztRQUFabGpCO1FBQ1ptakIsV0FuQ0Y5cUIsVUFrQ2MySDtRQUVab2pCLFdBQWEsNkJBRldGO09BRzVCLHdCQUZJQyxjQUNBQzs7R0FDOEU7WUFNaEZDLGVBQWU5MEIsR0FBRXVvQjtJQUt2QixJQUxxQnJpQixNQUFBbEcsR0FBRTJvQixPQUFBSjtJQUt2QjtZQUxxQnJpQjs7WUFNQzhFLE9BTkQ5RTtRQU9uQjs7b0JBQWdDLDBCQURaOEUsT0FOQzJkOztZQVFkb00sU0FSWTd1QixRQVFGLFdBQVY2dUIsUUFSY3BNOztRQVNVLElBQTNCdmQsTUFUZWxGLFFBU1ksTUFBQSx3QkFBM0JrRjtRQUFPLFdBQUEsZ0NBVFV1ZDs7WUFVaEJxTSxTQVZjOXVCO1FBVU4sV0FBQSwwQkFBUjh1QixTQVZnQnJNOztZQVdOc00sU0FYSS91QixRQVdUZ3ZCLE1BWFNodkI7UUFXUTtnQkFBakJndkI7NkJBQWdDLDBCQUEzQkQsU0FYTXRNOztZQVlUeGlCLE1BWk9ELFFBWVppdkIsUUFaWWp2QjtRQVlELFdBQVhpdkIsa0JBWkhMLGVBWVEzdUIsS0FaU3dpQjs7UUFja0I7U0FEbkJ2aUIsTUFiREY7U0FhTGt2QixTQWJLbHZCO1NBYVZtdkIsUUFiVW52QjtTQWNvQixpQkFkbkM0dUIsZUFhZ0IxdUIsS0FiQ3VpQjtTQWNqQjJNLFdBQU8sMEJBREdGO3FCQUVkLHNCQUZTQztrQkFDTEM7c0JBREtELGtCQUNMQzs7WUFJa0JobkIsS0FsQkhwSSxRQWtCVnF2QixjQWxCVXJ2QjtRQW1CbkIsR0FEU3F2QjtTQUtHLElBREgvbEMsTUFKQStsQyxnQkFLRC9pQixJQUFJLHlCQUxVbEU7WUFLZGtFLEtBRENoakI7Y0FKYWdtQyxPQUFBbG5COztVQVFrRDtXQUFBLE1BQUEsNEJBSGhFa0UsR0FEQ2hqQjtXQUltQixjQUFTO1dBQTVCLE1BQUEsMkJBUmE4ZSxJQUliOWU7V0FKYWdtQyxPQVFiO2FBUExDLE9BRGtCRDs7O2FBQ2xCQyxPQURrQm5uQjtRQVVaLFVBQUEsMEJBVE5tbkI7UUFTZ0MsT0FBQTs7O2lCQTVCZjlNOzBCQTRCb0JKLElBQUd2b0I7a0JBQ3JCO21CQURrQjJvQixPQUNsQix5QkFEa0JKLE1BQUFBLGdCQUFBQTtrQkFDWSxPQTdCakR1TSxlQTRCd0M5MEIsR0FBSDJvQjtpQkFDdUI7O1FBWi9DO1NBREV6ZCxZQWhCQWhGO1NBQUFHLE1BQUFIO1NBQUV3dkIsOEJBZ0JGeHFCLFdBaEJFeWQ7UUFBRnppQixNQUFBRztRQUFFc2lCLE9BQUErTTs7R0E2QjRDO1lBSzdEQyxhQUFhMzFCLEdBQUV1b0I7SUFDckIsT0FEbUJ2b0I7O09BRWEsV0EvRTFCOEosVUE2RWE5SixJQUFFdW9COztXQUdad00sU0FIVS8wQixNQUdBLGVBQVYrMEIsU0FIWXhNOztXQUlmbmQsTUFKYXBMLE1BSU4sV0FBQSx3QkFBUG9MLE1BSmVtZDs7V0FLZHZkLE9BTFloTCxNQUtKLFdBQVJnTCxNQUxjdWQ7O1dBTUVxTixPQU5KNTFCLE1BTUZnMUIsU0FORWgxQixNQU1QazFCLE1BTk9sMUI7VUFNSTQxQjs7U0FPVkMsU0FQVUQ7bUJBT0EsMENBQVZDOzs7T0FOWCx1QkFEVVgsVUFBS0YsZ0JBTkl6TTs7V0FlUHJpQixNQWZLbEcsTUFlVm0xQixRQWZVbjFCO09BZUMsdUJBQVhtMUIsUUFmSFEsYUFlUXp2QixXQWZPcWlCOztPQWlCUjtRQURTcGlCLE1BaEJIbkc7UUFnQkhpMUIsU0FoQkdqMUI7UUFnQlJxMUIsUUFoQlFyMUI7UUFpQmJzMUIsV0FEVUwsUUFoQlZVLGFBZ0JnQnh2QjtvQkFFcEIsc0JBRlNrdkI7eUJBQ0xDLE9BakJlL007aUNBZ0JWOE0sUUFDTEMsUUFqQmUvTTs7T0FzQlQsSUFERWphLEtBckJLdE8sTUFzQlAsTUFBQSwwQkFERXNPO09BQ3dCLE9BQUE7OztnQkF0QmpCaWE7eUJBc0JzQkEsSUFBR3ZvQixHQUFLLE9BdEI3QzIxQixhQXNCd0MzMUIsR0FBSHVvQixJQUF5Qjs7V0FIL0NyZCxZQW5CRmxMLE1BbUJEb0csTUFuQkNwRztPQW9CakIsbUJBSUE4MUIsWUFMZ0IxdkIsY0FBRzhFLGtCQW5CQXFkOztHQXNCZ0Q7WUFFbkV1TixZQUFZOTFCO0lBQ1IsSUFFSisxQixRQTNCSUosYUF3QlEzMUI7T0FHWisxQixXQUFBQSxjQURFL3FCLE9BQ0YrcUIsVUFEWSxPQUFWL3FCO0lBQ08sV0FBVCtxQjtHQUF3QjtZQUt4QjlwQixRQUFRaE07SUFDVixJQUFJLFVBQUEsV0FETUEsT0FDTjtVQUNGcUw7U0FBQUYsMEJBQUFFO0tBQU8sV0FBb0Isd0JBQTNCRjs7R0FBOEM7WUFZaEQ0cUIsV0FUVUM7SUFBTyxPQUxmaHFCOztjQUtrQyx1QkFBMUJncUI7O3dCQUFBQTtzQ0FBTyxnQ0FBUEEsUUFBQUE7YUFBeUM7R0FBQztZQVVwREMsV0FUVWwyQixHQUFJLGFBQUpBLEdBQVU7WUFPcEI2SixpQkFBYyxTQUFFO1lBTWhCK0IsWUFBVTVMLEdBQUksT0EzQlo4MUIsWUFzQkZFLFdBS1VoMkIsSUFBc0M7WUFDaEQwUSxVQUFVMUYsTUFBTywyQkFBSyxXQUFaQSxTQUErQjtZQUV6QzNVLFFBQVErSyxJQUFHQztJQUFLLElBQTRCLE1BSDVDdUssWUFHV3ZLLEtBQWtCLE1BSDdCdUssWUFHUXhLO0lBQW9DLE9BQUE7R0FBYztZQUMxRDlLLE1BQU04SyxJQUFHQztJQUFLLElBQTBCLE1BSnhDdUssWUFJU3ZLLEtBQWdCLE1BSnpCdUssWUFJTXhLO0lBQWtDLE9BQUE7R0FBYztZQUN0RHNFLFlBQVlPLE9BQU1qRztJQUEyQixVQUw3QzRMLFlBS2tCNUw7SUFBMkIsT0FBQSx5QkFBakNpRztHQUE4QztZQUMxRG9ELEtBQUtySixHQUFJLE9BQUEsNkJBRFQwRixhQUNLMUYsR0FBMEI7WUFFL0JtMkIsY0FBY24yQjtJQUNWLElBRUpvMkIsVUFoQkFKLFdBYWNoMkI7YUFHZG8yQixnQkFETzE0QixJQUNQMDRCLFlBRFksT0FBTDE0QjtJQUN1QixVQXRDNUJvNEIsWUFzQ0ZNO0lBQThCLE9BQUE7R0FBNkI7WUFHM0RDLHlCQUF5QnIyQjtJQUFJLElBbkVGa0csTUFnRDNCOHZCLFdBbUJ5QmgyQixJQW5Fb0IsTUFoQ3ZDODBCLGVBZ0NxQjV1QjtJQUFrQixPQUFBO0dBbUUrQjtZQUM1RXlGLGVBQWUzTDtJQUF3QixVQWZ2QzRMLFlBZWU1TDtJQUF3QixPQUFBO0dBQWE7WUFDcERzMkIsUUFBUXR6QjtJQUFJOzthQUFjLE9BbkN4QmlKOzt1QkFtQ21DOzJDQUE3QmpKOzs7NkJBQUFBOzJFQUFBQSxLQUFBQTt1QkFBNkI7c0JBQXFCOztHQUFFO1lBQzVEdXpCLGFBQWF2ekI7SUFBSTs7YUFBYyxPQXBDN0JpSjs7dUJBb0N3QzsyQ0FBN0JqSjs7OzZCQUFBQTsyRUFBQUEsS0FBQUE7dUJBQTZCO3NCQUFtQjs7R0FBRTtZQUMvRHd6QixVQUFVQyxRQUFTLE9BQUEsMEJBQVRBLFFBQXlCO1lBQ25DbDFCLFVBQVU2MEI7SUFBVSxPQUFjLDhCQUF4QkE7R0FBd0M7WUFDbERNLFFBQVFockI7SUFBUyxPQUFBLDJCQURqQm5LLFdBQ1FtSztHQUF5QztZQUNqRGlyQixTQUFTMTJCO0lBQUk7O2FBQWMsT0F4Q3pCZ00sd0JBd0NvQyxXQUFPLFdBQXBDaE0sT0FBMEM7O0dBQUU7WUFFckRmLE9BQVEwMkIsTUFBTWdCLFFBQU8xQixLQUFJNWxDLEdBQUV1bkM7SUFDN0IsS0FEZ0JEO0tBRUQ7O2NBQVMsT0E1Q3BCM3FCOzt3QkE0QytCLFdBRlppcEIsS0FFMkIsV0FGckIyQixXQUFGdm5DLElBQWpCc21DO3VCQUUwRDs7SUFDNUMsSUF2Q1o1MUIsUUFvQ1drMUIsS0FHaUIsV0FIWDJCLFdBQUZ2bkMsSUFBakJzbUM7SUFwQ1csYUFBVDUxQjtHQXVDK0M7WUFHekQrSyxTQUFTQyxNQUFPLE9BQWMsOEJBQXJCQSxPQUFnQztZQUN6Q2txQixJQUFJbDFCLEdBQUdrMUI7SUFBTSw2QkFBSyxXQUFYQSxLQW5DUGMsV0FtQ0loMkI7R0FBeUM7WUFFN0M4MkIsV0FBVzkyQixHQUFHazFCO0lBQ2hCOzthQUFjLE9BcERWanBCOzt1QkFvRHFCO3dCQUE2QixNQXRDcEQrcEIsV0FxQ1doMkI7MkNBQUdrMUI7Ozs2QkFBQUE7MkVBQUFBLE9BQUFBO3VCQUNTO3NCQUEwQzs7R0FBRTtZQUduRTZCLE1BQU0vMkIsR0FBR2sxQjtJQUFNLE9BSmY0QixXQUlNOTJCLEdBQTJCLDBCQUF4QmsxQjtHQUEyQztZQUVwRDhCLFFBQVFoM0IsR0FBRWsxQixLQUFJNWxDLEdBQUV1bkM7SUFDbEI7O2FBQWMsT0ExRFY1cUI7O3VCQTBEZ0QsVUE1Q2xEK3BCLFdBMkNRaDJCO3VCQUNlLFdBRGJrMUIsS0FDMkIsV0FEckIyQixXQUFGdm5DO3NCQUNpRDs7R0FBRTtZQUdqRXNRLFFBQVMyMUIsYUFBWWpuQjtJQUFLOzthQUFLO3FCQUF0QmluQjtxQkFBNkMsMEJBQWpDam5CLElBL0NyQjBuQjs7R0ErQ2lGO0dBRXJGO0lBQUE7O0dBTUU7Ozs7OztNQUFrRTtPQUk5RCxNQUFBO1VBSEloMkI7TUFBSyxPQW5EWDRMLFlBbURNNUw7S0FHUztZQUdmaTNCLE9BQU9qM0I7SUFDVCxLQUFPLDBCQURFQSxJQUVKLGdCQUZJQTs7d0JBQUFBOzs7VUFBQUE7d0RBQUFBLEtBQUFBO3VCQU1BLGdCQU5BQTtRQUtPb0w7SUFBTyxPQUFQQTtHQUNEO1lBR2I4ckIsT0FBUWhzQixXQUFVRTtJQUNwQixHQURVRjtpQkFBQUE7O29CQUlZOztVQUNOeE4sd0JBQUFBO1NBSlp5NUI7OztTQUFBQTtPQURnQi9yQjtTQVFkcEwsSUFSY29MO1VBQ2hCK3JCLGFBT2EsT0FBWG4zQjtTQUNRbzNCLGNBUlZEO0tBUTRCLDZCQUFBLFdBaEY5Qm5CLFdBK0VJaDJCLElBQ1FvM0I7O1NBUlZELGFBU3VCLE9BQUEsOEJBVlAvckI7UUFXVmlzQixjQVZORjtJQVV3Qjs7YUFBQSxlQUFzQix3QkFYOUIvckIsT0FXVmlzQjs7R0FBd0U7WUFPNUVqdEIsR0FBRytCLEtBQUluTTtJQUFvQyxVQTVFL0NtMkIsY0E0RVduMkI7SUFBb0MsT0FBQSw4QkFBeENtTTtHQUF5RDs7cURBQTVEL0IsSUFEQUM7Ozs7T0FoRkpoVTtPQUNBQztPQUNBb1A7T0FDQTJEO09BTEFxSDtPQURBOUU7T0FFQ2hDO09BUkRDO09BY0Fzc0I7T0FPQXhxQjtPQURBMHFCO09BS0E5MEI7T0FIQSswQjtPQUNBQztPQUlBSTtPQUhBSDtPQUtBdDNCO09BTUE2TDtPQVRBMnJCO09BVUF4QjtPQU1BNkI7T0FKQUQ7T0FNQUU7T0FJQXAzQjtPQXdCQXMzQjtPQVRBRDs7V0F6TE1udEIsV0EySE5rc0IsWUFDQUU7OztFOzs7Ozs7Ozs7OztHOzs7Ozs7O0lDMUlBdHNCO0lBU0lTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBQ0FEOztZQVRKa3RCLE1BQU10M0I7SUFBSSxNQUFNLDRCQUFBLG1CQUFWQTtHQUFvQjtZQUMxQnUzQixRQUFRdnNCLE1BQU8sT0FEZnNzQixNQUNxQixxQkFBYnRzQixPQUE0QjtZQUNwQ3dzQixRQUFReDNCLEdBQUksT0FBSkEsRUFBSztZQUNieTNCLFFBQVF6M0IsR0FBSSxPQUFKQSxFQUFLOztxREFNVG9LLElBREFDOzs7Ozs7Ozs7O09BVEpUOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BQ0EwdEI7T0FDQUM7T0FDQUM7T0FDQUM7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7O0lDUkFGOzs7Ozs7WUFFQTF0QixVQUFVK3JCLE1BQUs1MUIsR0FBRThKLFdBQVU3SjtJQUM3QixJQUFJLFVBQUEsV0FEeUJBLE9BQ3pCO1VBQ0ZxTDtLQUlLO01BSkxGLDBCQUFBRTt5QkFNVyxXQVJNeEIsV0FBRjlKOzZCQU9ELDZCQUxkb0w7TUFJSzt1QkFBTSwwQ0FORHdxQjtLQUlSLE9BQUE7Y0FORjJCLFNBTUU7O0dBS0s7WUFHUEcsWUFBWTEzQixHQUFFQyxHQUFFa1M7SUFDbEI7S0FBSSxVQUFBLFdBRFlsUyxHQUNWLDBCQURZa1MsT0FBSm5TO0tBQ1Y7O1VBQ0ZzTDtLQUkrQjtNQUovQkYsMEJBQUFFOytCQUkwRCw2QkFKMURGO01BSStCLE1BQUEsMEJBTmYrRztNQU1YLHlCQUFXO0tBRmQsT0FBQTtjQWxCRm9sQixTQWtCRTs7R0FFMEU7NEJBbEI1RTF0QixXQVlBNnRCOzs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7OztJQ2JBL3BCO0lBQUFEO0lBaURJUDtJQWpESk07SUFBQUY7WUFRQWxYLFFBQ0VnZixPQUFRdE0sT0FBUUM7SUFBVyxPQUFBLDJCQUEzQnFNLHNCQUFRdE0sT0FBUUM7R0FBK0Q7WUFHakYxUyxNQUNFK2UsT0FBUXNpQixPQUFRQztJQUFXLE9BQUEsMkJBQTNCdmlCLHNCQUFRc2lCLE9BQVFDO0dBQTJEO1lBRzdFbHlCLFlBT0V5USxhQUFhN00sS0FBSUM7SUFBTyxPQUFBLDJCQUF4QjRNLDRCQUFhN00sS0FBSUM7R0FBZ0U7WUFHbkZtSCxVQUNFbW5CLFVBQVlDO0lBQVcsT0FBQSwyQkFBdkJELHlCQUFZQztHQUErRDtZQUc3RWh1QixVQUNFaXVCLFVBQVlDO0lBQVcsT0FBQSwyQkFBdkJELHlCQUFZQztHQUErRDtZQUc1RXB1QixlQUNDdUw7SUFBb0IsT0FBQSwyQkFBcEJBO0dBQStFO1lBS2pGdEwsVUFBVW91QixhQUFZajRCO0lBQ3hCLFNBRHdCQSxVQUVuQm9ELElBRm1CcEQsTUFFZCxPQUFBLFdBRkVpNEIsYUFFUDcwQjtRQUNHcVQsUUFIZ0J6VztJQUdQLE9BQUEsMEJBQVR5VztHQUE4QjtZQVFoQ2hILE1BQU14UCxHQUFFM1E7SUFDVixPQUE2Qzs7YUFEckMyUTthQUFFM1E7c0JBQ2tCMlEsR0FBRTNRLEdBQUssT0FBQSxXQUFQMlEsR0FBRTNRLEdBQVE7c0JBQVk0b0MsSUFBR0M7Y0FBTSxPQUFjLGtDQUF2QkQsUUFBR0M7YUFBOEI7R0FBQztHQUc1RTtJQUFOOTNCO2tEQU5BOE0sVUFFQXNDLE9BSUFwUDs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFlaUI7SUFJckJtVztJQUNBUTtJQUNBQzs7OztZQUVBTyxTQUFXM1IsS0FBbUI1RjtJQUNoQyxHQURhNEYsU0FBWUMsTUFBWkQsUUFBQXFGLFlBQVlwRixjQUFab0Y7SUFDYixJQUFJLGNBQUcsV0FEeUJqTCxRQUM1QjtVQUNGcUw7U0FBQUYsMEJBQUFFLGNBRldKO0tBRUosV0FBTSxnQ0FBYkU7O0dBQWtGO1lBR2xGZ3RCLGNBQWVsdEIsV0FBVWpMO0lBQUksT0FBSyxXQW5GbEN5TixNQThFQThKLFNBS2V0TSxXQUFVakw7R0FBZ0M7WUFFekR3WDtJQUFTLHVCQUNObm9CLGNBQUssT0FBTEE7UUFDR3NvQjtJQUFPLE9BQUEsMkJBQVBBO0dBQXNCO1lBRzVCc2YsT0FBUWhzQixXQUFVRTtJQUFNLFdBQU0sMkJBQXRCRixXQUFVRTtHQUF5QztZQUUzRGl0QixjQUFlbnRCLFdBQ2ZrZTtJLFNBQUFBLE1BQWEsT0FBYkE7UUFDTWhlLE1BRE5nZTtJQUNhLE9BSmI4TixPQUVlaHNCLFdBRVRFOztZQUdOcUwsTUFBT21mLE1BQU1nQixRQUFPUixTQUFRaHpCLEdBQUVvWDtJQUNoQztZQUFNLDJCQURHb2IsTUFBTWdCLFFBQU9SLFNBQVFoekIsR0FBRW9YO0dBQ3NCO1lBR3BEOGQsUUFBUXR0QixNQUFPLFdBQU0sMkJBQWJBLE9BQWtDO1lBQzFDdXRCLGFBQWFuQztJQUFVLFdBQU0sMkJBQWhCQTtHQUF5QztZQUN0RG9DLE9BQU85c0I7SUFBUyxPQUFBLDJCQURoQjZzQixjQUNPN3NCO0dBQTRDO1lBQ25Ed3BCLElBQUlsMUIsR0FBR2sxQjtJQUFNO0lBQXNCLE9BQUE7O2FBQS9CbDFCOzJCQUFTLE9BQUEscUJBQU5rMUI7R0FBNEM7WUFDbkQ2QixNQUFNLzJCLEdBQUdrMUI7SUFBTTtJQUFzQixPQUFBOzthQUEvQmwxQjsyQkFBUyxPQUFBLHFCQUFOazFCO0dBQThDO1lBQ3ZENEIsV0FBVzkyQixHQUFHazFCO0lBQU07SUFBc0IsT0FBQTs7YUFBL0JsMUI7MkJBQVMsT0FBQSxxQkFBTmsxQjtHQUFtRDtZQUVqRThCLFFBQVFoM0IsR0FBRW8yQixTQUFRaHpCLEdBQUVvWDtJQUN0QixPQUFzQjs7YUFEWnhhO3NCQUNpQjZFO2NBQUssT0FBaEMsMkJBQTJCQSxHQURmdXhCLFNBQVFoekIsR0FBRW9YO2FBQzZDO0dBQUM7WUFHbEVpZSxjQUFjLzZCO0lBQUksT0FmbEIrWSwrQkFlYy9ZO0dBQTBDO1lBQ3hEdWEsZUFBZWpWO0lBQUksSUFBQSxzQkFBaUIsTUFBQSw0QkFBckJBOzs7OzJCO0dBQStEO1lBQzlFbVYsb0JBQW9CblY7SUFBZSxVQURuQ2lWLGVBQ29CalY7SUFBcUMsT0FBQSxpREFBd0IsU0FBRTtHQUFDO1lBRXBGMDFCLHVCQUF1QjExQjtJQUN6QjtLQUFlLFFBQUEsMEJBRFVBO0tBQ2pCa1Y7S0FBSjFCO0lBQ0osT0FESUEsU0FBQUEsVUFFVSw4QkFGTjBCO0dBR0k7WUFHVnlnQixRQUFRMzFCO0lBQ0osWUFBQSwwQkFESUE7a0JBRUgxVCxjQUFLLFdBQUxBO0lBSUE7O09BQUE7O1NBTkcwVDs7VUFNWTtXQUNGLE1BQUE7Y0FDRjRVO1VBQU8sT0FBUEE7U0FBVztJQUozQixXQUNFO0dBRzJCO1lBRzdCZ2hCLFlBQVk1MUIsR0FBRy9DO0lBQ2pCLE9BQXdCOztzQkFBT3FOO2NBR3hCOztpQkFBQTs7bUJBSk90Szs0QkFJYTZWO29CQUNYLElBQ0p2cEIsSUFESSxXQUxDMlEsR0FJVTRZOzZCQUVmdnBCLE1BQWEsT0FBQSxXQUxNZ2UsT0FLbkJoZTt3QkFDTXNvQixNQUROdG9CO29CQUNhLE9BQVBzb0I7bUJBQVU7Y0FMMUIsV0FDRTthQUk0QjtHQUFBOztJQUc5QmQ7SUFDQTNXO0lBQ0FnWDs7O09BMUlBOWdCO09BSUFDO09BSUFvUDtPQVVBZ0w7T0FJQTVHO09BSUNGOzs7Ozs7Ozs7T0FNREM7T0F4Q0EwRDs7O09BQUFFOztPQUFBQztPQUFBQzs7Ozs7OztzQkFBQUY7T0EyRUF1SjtPQUNBQztPQUVBTztPQUtBNGdCO09BVEE1aEI7T0FXQWlCO09BS0F5ZjtPQUVBbUI7T0FLQTVoQjtPQUlBNmhCO09BQ0FDO09BQ0FDO09BQ0F0RDtPQUNBNkI7T0FDQUQ7T0FFQUU7T0FJQXlCO09BZ0NBM2hCO09BQ0EzVztPQUNBZ1g7T0FqQ0FjO09BQ0FFO09BRUF1Z0I7T0FPQUM7T0FXQUM7OztFOzs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7O0lDL0hHQztJQTJCRmp2Qjs7Ozs7OztJQWlDREs7SUFnQ0FJOzs7Ozs7OztHQTNGRCxTQUZDcUcsVUFjQ29vQjtJQVpGOztjQVlFQTtnQkFBQUE7Ozs7Ozs7Ozs7UUFWd0M7O09BQ0Y7O01BRkE7O2VBV3RDQTs7TUFDQSxPQUFBOzRDQWRFRCxrQkFhRkM7OztNQURBLE9BQUE7NENBWkVELGtCQWFGQzs7Ozs7Ozs7Ozs7T0FMQSxPQUFBOzZDQVJFRCxrQkFhRkM7O01BSEEsT0FBQTs0Q0FWRUQsa0JBYUZDOztLQVBBLE9BQUE7MkNBTkVELGtCQWFGQzs7SUFFYyxPQUFBLHdDQWZaRCxrQkFhRkM7R0FFb0Y7WUFJckZodkI7SUFDRCxzQkFDVSxtQkFDQyxvQkFDRDs7R0FBd0I7T0FpQmpDelQ7WUFFQ3FQLFlBQ0U0RCxLQUFJQztJQUNOLE9BRE1BOztPQUVHLE9BQUEseUJBRlBEOztPQUdRLE9BQUEseUJBSFJBO2VBSU8sT0FBQSx5QkFKUEE7O0dBSTJDO1lBa0I1Q3ZaLE9BQU9ULEdBQU9DLEdBQUksT0FBWEQsSUFBT0MsVUFBa0I7WUFDaEM0ZixTQUFRN2YsR0FBT0MsR0FBSSxPQUFYRCxLQUFPQyxVQUFtQjtZQUNsQzhmLFNBQVEvZixHQUFPQyxHQUFJLE9BQVhELE1BQU9DLFVBQW1CO1lBQ2xDcUYsU0FBT3RGLEdBQU9DLEdBQUksT0FBWEQsTUFBT0MsVUFBa0I7WUFDaENzRixTQUFPdkYsR0FBT0MsR0FBSSxPQUFKQSxJQUFQRCxVQUF5QjtZQUNoQ3dGLFNBQVF4RixHQUFPQyxHQUFJLE9BQUpBLEtBQVBELFVBQTBCO1lBQ2xDZ0csVUFBV2hHLEdBQU9DLEdBQUksT0FBQSwwQkFBWEQsR0FBT0MsR0FBc0I7WUFDeENGLFdBQVlDLEdBQU9DLEdBQUksT0FBQSwwQkFBWEQsR0FBT0MsR0FBdUI7T0FDMUM4SDtZQUNBZixNQUFPaEgsR0FBT0MsR0FBSSxPQUFYRCxNQUFPQyxVQUFrQjtZQUNoQ0MsSUFMUUYsR0FBT0MsR0FLQyxPQUxEQSxLQUFQRCxJQUFBQSxJQUFPQyxFQUt3QjtZQUN2Q0UsSUFWUUgsR0FBT0MsR0FVQyxPQVZSRCxLQUFPQyxJQUFQRCxJQUFPQyxFQVV3QjtHQVpSOzs7T0FDL0JRO09BQ0FvZjtPQUNBRTtPQUNBemE7T0FDQUM7T0FDQUM7T0FDQVE7T0FDQWpHO09BQ0FnSTtPQUNBZjtPQUNBOUc7T0FDQUM7WUFHRjhSLFVBQVU3RCxHQUFJLE9BaEZkZ1QsVUFnRndCLDZCQUFkaFQsSUFBZ0M7WUFDMUM0RCxVQUFVdEI7SUFBbUIsVUE3RDdCOEosVUE2RFU5SjtJQUFtQixPQUFBO0dBQWE7WUFFMUNjO0lBQVMsc0JBQ0Ysa0JBQ0Msa0JBQ0Q7O0dBQUM7WUFRUkksT0FBT3NSLEdBQUksWUFBSkEsVUFBQUEsY0FBc0Q7Ozs7T0E5RjdEOUI7T0FvQkE1RztPQVFDRjtPQWFEdlQ7T0FFQ3FQO09Ba0JEdUU7O09BbUJBMUk7T0FDQUQ7T0FFQVI7T0FBQUE7T0FVQXVKO09BQ0FuSjs7O0U7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDbENBNjNCLElBQUlsSCxLQUFJenVCLEdBQUVDLEdBQUksWUFBQSxXQUFWd3VCLEtBQUl6dUIsR0FBRUMsV0FBZ0I7WUFDMUIyMUIsSUFBSW5ILEtBQUl6dUIsR0FBRUMsR0FBSSxPQUFBLFdBQVZ3dUIsS0FBSXp1QixHQUFFQyxnQkFBZ0I7WUFDMUIvTSxNQUFNdTdCLEtBQUl6dUIsR0FBRUMsR0FBSSxhQUFBLFdBQVZ3dUIsS0FBSXp1QixHQUFFQyxXQUFlO1lBRTNCNVQsSUFBSW9pQyxLQUFJM3JCLEtBQUVsRyxHQUFLLE9BSGZnNUIsSUFHSW5ILEtBQUkzckIsS0FBRWxHLEtBQUZrRyxNQUFFbEcsRUFBbUM7WUFDN0N4USxJQUFJcWlDLEtBQUkzckIsS0FBRWxHLEdBQUssT0FMZis0QixJQUtJbEgsS0FBSTNyQixLQUFFbEcsS0FBRmtHLE1BQUVsRyxFQUFtQzs7YUFTM0NqUSxPQUFNcVQsR0FBRUM7S0FBSSxJQWhCWHd1QjtnQkFBVSxXQUFWQSxLQWdCS3p1QixHQUFFQztJQUFvQjthQUM1QjhMLFNBQU0vTCxHQUFFQztLQUFJLElBaEJYd3VCO1lBQVUsV0FBVkEsS0FnQkt6dUIsR0FBRUM7SUFBb0I7YUFDNUJnTSxTQUFPak0sR0FBRUMsR0FBSSxPQWhCZjAxQixVQWdCUzMxQixHQUFFQyxHQUFxQjthQUM5QnpPLFNBQU93TyxHQUFFQyxHQUFJLE9BaEJmMjFCLFVBZ0JTNTFCLEdBQUVDLEdBQXFCO2FBQzlCeE8sU0FBTXVPLEdBQUVDLEdBQUksT0FoQmQvTSxZQWdCUThNLEdBQUVDLEdBQXVCO2FBQy9Cdk8sU0FBT3NPLEdBQUVDO0tBQUksSUFoQkx3dUI7a0JBQVUsV0FBVkEsS0FnQkR6dUIsR0FBRUM7SUFBMkI7SUFOTixXQUc5QmdNLFVBQ0F6YSxVQUNBQyxVQUpBOUUsUUFDQW9mLFVBSUFyYTs7Ozs7S0FORy9FO0tBQUFvZjtLQUFBRTtLQUFBemE7S0FBQUM7S0FBQUM7S0FrQkh1QjthQUVBYixNQUFJMFEsS0FBRWxHLEdBQUssT0E3QmJ2USxJQTJCRTRHLFNBRUk2UCxLQUFFbEcsR0FBcUI7YUFDM0J6SyxNQUFJMlEsS0FBRWxHLEdBQUssT0E3QmJ4USxJQTBCRTZHLFNBR0k2UCxLQUFFbEcsR0FBcUI7SUFOaUI7WUFmekNqUTtZQUFBb2Y7WUFBQUU7WUFBQXphO1lBQUFDO1lBQUFDO1lBQUF1YTtZQWtCSGhaO1lBRUFiO1lBQ0FEOzs7O0tBTUZ1VTtLQUlRc0c7S0FLSi9aLFVBTEkrWjsyREFLSi9aO0tBckJDdEc7S0FBQW9mO0tBQUFFO0tBQUF6YTtLQUFBQztLQUFBQztLQUFBd0I7S0FBQWU7S0FBQTVIO0tBQUFEO2FBNkJISCxXQUFXNlcsS0FBRWxHLEdBQUssT0FBQSxXQTdCZjNJLFdBNkJVMkksR0FBRmtHLEtBQW1CO2FBQzlCK3lCLFFBQVFqNUIsR0FBR2s1QixLQUFLQztLQUFPLFVBQUEsV0E5QnBCaHFCLFVBOEJRK3BCLEtBQUhsNUI7S0FBZSx3QkE5QnBCbVAsVUE4QktuUCxHQUFRbTVCO0lBQTRCO2FBQzVDQyxnQkFBZ0JwNUIsR0FBR3ZRLEtBQUtEO0tBQU0sT0FBRyxXQS9COUJxRixVQStCYW1MLEdBQUd2UTtlQUFBQTtlQUF1QyxXQS9CdkQwZixVQStCYW5QLEdBQVF4USxPQUFSd1EsSUFBUXhRO0lBQTBEO2FBRWxGNnBDLFVBQVVyNUIsR0FBR3ZRLEtBQUtEO0tBQ3BCLEdBQU8sV0FsQ0YyZixVQWlDVTFmLEtBQUtELE1BRXBCLE9BSkU0cEMsZ0JBRVVwNUIsR0FBR3ZRLEtBQUtEO0tBQ3BCLE1BQUE7SUFDMkI7YUFHekI4cEMsTUFBTXQ1QixHQUFHdlEsS0FBS0Q7S0FDaEIsS0FBRyxXQXZDRW9GLFVBc0NNbkYsS0FBS0Q7TUFPWCxXQWRINHBDLGdCQU9NcDVCLEdBQUd2USxLQUFLRDtLQU1UOytCQUFpQyxXQWhDeENzYSxXQTBCZ0J0YTtNQU1ULHlCQUFTLFdBaENoQnNhLFdBMEJXcmE7TUFJUCxNQUFBO0tBQUEsT0FBQTtJQUdpQztJQTVCMEM7WUFqQjFFTTtZQUFBb2Y7WUFBQUU7WUFBQXphO1lBQUFDO1lBQUFDO1lBQUF3QjtZQUFBZTtZQUFBNUg7WUFBQUQ7WUFBQTZIO1lBNkJIaEk7WUFDQTRwQztZQUdBSTtZQUtBQztZQXRCTWxwQjs7OztLQXNDUnRHOzs7SUFJcUIsaUNBSnJCQTs7O1FBMkJJQTthQUlBelQsUUFBUTZQLEtBQUVsRztLQUFLLElBQTBCLE1BQUEsaUJBQS9CQSxJQUFlLE1BQUEsaUJBQWpCa0c7S0FBaUMsT0FBQTtJQUFnQjtJQVB6RCxnQkFPQTdQLFNBSkF5VDs7WUFRSnl2QixjQUFjQyxNQUFLbHFDLEdBQUVDO0lBQ3ZCLFlBRGdCaXFDO0lBQ0Q7aUJBSUw7S0FGSSxJQURIQyxtQkFBUDVILGdCQUNJM3VCLE1BQU0sV0FEVjJ1QixLQUZpQnZpQyxHQUFFQztLQUluQixTQURJMlQsS0FDMkIsT0FEM0JBO2FBREd1MkI7O0dBS0Y7WUFHUEMsS0FBSzdILEtBQUs1eEIsR0FBRTNRLEdBQUVDO0lBQWMsVUFBQSxXQUFsQjBRLEdBQUkxUTtJQUFjLE9BQUEsV0FBdkJzaUMsS0FBaUIsV0FBWjV4QixHQUFFM1E7R0FBcUI7WUFDakNxcUMsUUFBUTlILEtBQUl2aUMsR0FBRUMsR0FBSSxPQUFBLFdBQVZzaUMsS0FBTXRpQyxHQUFGRCxHQUFhOzs7O09BWHpCaXFDO09BVUFHO09BQ0FDO09BOUhBcmpDO09BR0E5RztPQURBQzs7Ozs7Ozs7U0F6Q0lxYTs7Ozs7aUJBU0ZtdkIsUUFBUWo1QixHQUFHazVCLEtBQUtDO1NBQU87VUFBQSxNQUFBLGVBQVpELEtBQUhsNUI7VUFBZSxZQUFZLGVBQTNCQSxHQUFRbTVCO1NBQW1CO1FBQVM7aUJBQzVDQyxnQkFBZ0JwNUIsR0FBR3ZRLEtBQUtEO1NBQU0sT0FBRyxjQUFqQndRLEdBQUd2USxPQUFBQSxNQUF1QyxlQUExQ3VRLEdBQVF4USxPQUFSd1EsSUFBUXhRO1FBQTBEO2lCQUVsRjZwQyxVQUFVcjVCLEdBQUd2USxLQUFLRDtTQUNwQixHQUFPLGVBRFFDLEtBQUtELE1BRXBCLE9BSkU0cEMsZ0JBRVVwNUIsR0FBR3ZRLEtBQUtEO1NBQ3BCLE1BQUE7UUFDMkI7aUJBR3pCOHBDLE1BQU10NUIsR0FBR3ZRLEtBQUtEO1NBQ2hCLEtBQUcsaUJBRFFDLEtBQUtEO1VBT1gsV0FkSDRwQyxnQkFPTXA1QixHQUFHdlEsS0FBS0Q7U0FNVDtpQ0FBaUMsaUJBTnhCQTtVQU1ULHVCQUFTLGlCQU5MQztVQUlQLE1BQUE7U0FBQSxPQUFBO1FBR2lDOzs7NERBeEJqQ3FhOzs7Ozs7Ozs7Ozs7Ozs7Z0JBU0ZtdkI7Z0JBR0FJO2dCQUtBQzs7Ozs7aUJBbkNBTSxZQUFZNTVCLEdBQUksV0FBQSxnQkFBSkEsZ0JBQXNCO2lCQUNsQzY1QixnQkFBZ0I3NUI7U0FBSSxZQUFBLGdCQUFKQTtRQUF1QjtpQkFDdkM4NUIsWUFBWTk1QixHQUFJLE9BQUEsZ0JBQUpBLG9CQUFzQjtpQkFDbEMrNUIsZ0JBQWdCLzVCO1NBQUksT0FBQSxnQkFBSkE7UUFBdUI7aUJBQ3ZDZzZCLEtBQUtoNkI7U0FBaUIsVUFBQSxnQkFBakJBO1NBQWlCLE9BQUE7UUFBZ0I7UUFQNUM7Z0JBR000NUI7Z0JBQ0FDO2dCQUNBQztnQkFDQUM7Z0JBQ0FDOzs7O0U7Ozs7Ozs7OztHOzs7Ozs7Ozs7WUN1QkExakMsTUFBTThNLEdBQUVDO0lBQ1YsVUFBQSw2QkFEUUQsR0FBRUM7SUFDVjs7O0tBQ0ksVUFBQSw2QkFGSUQsTUFBRUM7S0FFTjtNQUNHLFVBQUEsNkJBSENELE1BQUVDO01BR0gsNENBSENELE1BQUVDOzs7Ozs7SUFDVjtHQUcwQztHQUtqQztJQUZQNDJCO0lBQ0E1d0I7O0lBQ0E2d0IsV0FEQTd3Qiw0Q0FDNkQsV0FBYTtZQUUxRTh3QixPQUF3QkMsS0FDMUIsV0FEMEJBLFFBQUFBLFFBQUFBO1lBSXhCQztJQUFPLElBTUh2d0Isc0JBREF6VCxvQkFEQWdUO0lBSEUsV0FJRmhULFNBQ0F5VCxXQUZBVDtHQUlZO0dBaERKO0lBQUEsZUF5QlovUyxPQU9BMmpDLFlBQ0E1d0IsTUFDQTZ3QixNQUVBQyxRQUlBRTtJQWZBL2lDO0lBT0FnakM7SUFDQTdtQjtJQUNBOG1CO0lBRUFDO0lBSUFDOztvQkFmQW5qQyxTQU9BZ2pDLGNBQ0E3bUIsUUFDQThtQixRQUVBQyxVQUlBQzs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7RTs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Ozs7Ozs7O1FDakQwQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0FBMUJDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQUFBQTs7O1FBUTBCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTQUExQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBQUFBOzs7O0U7Ozs7Ozs7OztHOzs7Ozs7OztJQ1hBendCO0lBd0JBSTs7O0lBdEJDM0U7SUFJQ21IO0dBQ0osU0FGR3hELEtBRUMvWixHQUFLLE9BQUEsV0FETHVkLE1BQ0F2ZCxHQUFXOztJQUdib2hCO0lBQ0E1RztJQUNDRjs7WUFJRHZULG9CQUFjLFNBQUM7WUFFZmtMO0lBQVk7Y0FFUDs7R0FBMkM7WUFHaERELGlCQUFlLFdBQUk7Ozs7OztTQVBuQmpMO1NBZENxUDtTQUdBMkQ7U0FLRHFIO1NBQ0E1RztTQU9Bdkk7U0FLQUQ7U0FDQStJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBTUZSLGlCQUFlLFNBQUU7Ozs7T0E5QmZJO09BWUNMOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Ba0JIQzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7OztZQ2hDQTh3QixZQUFhamdCLEtBQUt2YixZQUFRd2I7SUFDNUI7S0FBSSxjQUFVLDRCQURDRCxLQUFLdmIsUUFBUXdiO0tBQ3hCOzs7OztTQUNlamQ7S0FBSyxPQUFBLDhCQUFMQTs7R0FBNEI7Ozt1REFGN0NpOUI7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7O1lDc0NBQyxzQkFBdUJsZ0IsS0FBS3ZiLEtBQUlhLEdBQUcrUixLQUFLalEsUUFBUSs0QjtJQUNsRDtLQUN1RSxNQUFBLFdBRjdCLzRCLFFBQVI5QjtLQUVoQyxRQUFBLDhDQUZ1QjBhLEtBQUt2YjtLQUNyQjRiO0tBakJzQytmO0tBcUJ0QyxNQUFBLDRCQXJCc0NBLE9BaUJ0Qy9mO0tBakIwQ2dnQixPQXFCMUM7S0FyQ29DQyxPQWdCRUY7S0FoQkUxZCxLQWdCRTJkO0lBR25EO0tBQUcsUUFBQSw0QkFuQjhDM2QsSUFBSjRkO0tBc0IzQjtNQUFBLE1BQUEsNEJBdEIrQjVkLElBQUo0ZDtNQXNCNUIsTUFBQTtNQUFYQyxNQUFNLDRCQXRCaUNEO0tBdUJ4QyxHQUFBLFdBUzZDSCxNQVR4QyxXQVMyQjlvQixLQUFIL1IsR0FWNUJpN0I7TUF0QjJDN2QsS0FzQjNDNmQ7VUFPNkMsSUFiSkMsT0FhSSw0QkFQN0NELFNBdEJ1Q0QsT0FnQkVFOztRQWhCRi9kLEtBQUE2ZDtJQUM3QztRQURpRDVkLEtBQUpELElBRXhDO0tBQ0csR0FBQSxXQTZCMEMwZCxNQTdCckMsV0E2QndCOW9CLEtBQUgvUixHQWhDV21kLE1BSXhDLFdBSndDQTtLQUtFLElBTEZnZSxPQUtFLDRCQUxGaGU7S0FBQUEsS0FBQWdlOztHQXVDTTtZQU1qREMscUJBQXNCMWdCLEtBQUt2YixLQUFJYSxHQUFHNjZCLE1BQU05b0IsS0FBS2pRO0lBQy9DO0tBQ3VFLE1BQUEsV0FGeEJBLFFBQWQ5QjtLQUUvQixRQUFBLDhDQUZzQjBhLEtBQUt2YjtLQUNwQjRiO0tBQUwrZjtJQUdKLFNBSFMvZixPQUlKO0lBR0c7O09BckJONmY7YUFjRUUsWUFBSy9mLFFBRHdCL2EsR0FBUytSLEtBQUtqUSxRQVFjLHVCQVJ6Qis0Qjs7U0FhM0I1aEM7WUFBQUEsTUFaTDZoQyxnQkFZZSw0QkFBVjdoQzs7SUFKUyxVQUFBLDRCQVJkNmhDLE9BQUsvZjtJQVFHLFdBQUs7R0FJVTtZQUd6QnNnQixjQUFlM2dCLEtBQUt2YixLQUFJYSxHQUFHOEIsUUFBUWlRLEtBQUsxYixTQUFRaWxDLEtBQUkvc0I7SUFDdEQsaUJBRGtEK3NCO3lCQUFBQTs7a0JBQUFBO2lCQTdCaERWO2tCQTZCZWxnQjtrQkFBS3ZiO2tCQUFJYTtrQkFBVytSO2tCQUFSalE7MkJBbUIrQnhTLEdBQUssWUFBQSxXQW5CdkIrRyxTQW1Ca0IvRyxHQW5CTmlmLFdBbUIyQjtpQkFuQy9FNnNCO2tCQWdCZTFnQjtrQkFBS3ZiO2tCQUFJYTsyQkFHaUMxUSxHQUFLLE9BQUEsV0FIdEIrRyxTQUdpQi9HLEdBSExpZixlQUd5QjtrQkFIMUN3RDtrQkFBUmpROztrQkFBcUJ3NUI7aUJBaEJoREY7a0JBZ0JlMWdCO2tCQUFLdmI7a0JBQUlhOzJCQUtpQzFRLEdBQUssT0FBQSxXQUx0QitHLFNBS2lCL0csR0FMTGlmLGdCQUswQjtrQkFMM0N3RDtrQkFBUmpRO2lCQTdCM0I4NEI7a0JBNkJlbGdCO2tCQUFLdmI7a0JBQUlhO2tCQUFXK1I7a0JBQVJqUTsyQkFxQitCeFMsR0FBSyxXQUFBLFdBckJ2QitHLFNBcUJrQi9HLEdBckJOaWYsV0FxQjBCO3NCQXJCOUIrc0I7S0FjN0M7O1FBOUJIRjtVQWdCZTFnQjtVQUFLdmI7VUFBSWE7bUJBY29DMVEsR0FBSyxPQUFBLFdBZHpCK0csU0Fjb0IvRyxHQWRSaWYsZ0JBYzZCO1VBZDlDd0Q7VUFBUmpROztVQWdCbkJ4UztNQUFPLFNBQUEsV0FoQnlCK0csU0FnQmpCLFdBaEJZMGIsS0FBWC9SLEdBZ0JoQjFRLElBaEI0Q2lmLElBZ0JWLFdBQWxDamY7O0tBQ1k7O0lBVGpCOztPQXJDSHNyQztTQTZCZWxnQjtTQUFLdmI7U0FBSWE7U0FBVytSO1NBQVJqUTtrQkFRa0N4UyxHQUFLLFlBQUEsV0FSMUIrRyxTQVFxQi9HLEdBUlRpZixXQVE4Qjs7U0FFMUU4SDtLQUFPLFNBQUEsV0FWeUJoZ0IsU0FVakIsV0FWWTBiLEtBQVgvUixHQVVoQnFXLE1BVjRDOUg7TUFVVixXQUFsQzhIOztJQUNZO0dBVTJEO1lBRy9Fa2xCLHdCQUF5QjdnQixLQUFLdmIsS0FBSWEsR0FBRzhCLFFBQVFpUSxLQUFLeXBCLFlBQVdGO2FBQzNERyxRQUFRbnNDO0tBQ1Ysb0JBQU0sV0FGNENrc0MsWUFDeENsc0M7SUFHTztJQUVuQixTQUFJb3NDLFNBQVNwc0MsR0FBSSxXQUxibXNDLFFBS1Nuc0MsR0FBbUI7SUFDaEMsb0JBUCtEZ3NDO2NBeEM3REYscUJBd0N5QjFnQixLQUFLdmIsS0FBSWEsR0FDaEN5N0IsU0FEMkMxcEIsS0FBUmpRO2NBckRyQzg0QixzQkFxRHlCbGdCLEtBQUt2YixLQUFJYSxHQUFXK1IsS0FBUmpRLFFBTW5DNDVCO0dBRzhFO2dDQWpDaEZMLGVBd0JBRTs7O0U7Ozs7OztHQ3ZFeUI7O0lBV3ZCdHhCOzs7Ozs7SUFxQkEweEI7SUFoQ3VCLDBCQVd2QjF4QjtJQWMyQiw4QkFPM0IweEI7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7OztRQzNDQTVwQixZQUNBalE7YUFFQXU1QixjQUFlM2dCLEtBQUt2YixLQUFJYSxHQUFHM0osU0FBUWlsQyxLQUFJL3NCO0tBQ3pDLE9BQUE7O2NBRGlCbU07Y0FBS3ZiO2NBQUlhO2NBRnhCOEI7Y0FEQWlRO2NBRzJCMWI7Y0FBUWlsQztjQUFJL3NCO0lBQzBCO2FBR2pFZ3RCLHdCQUF5QjdnQixLQUFLdmIsS0FBSWEsR0FBR3c3QixZQUFXRjtLQUNsRCxPQUFBOztjQUQyQjVnQjtjQUFLdmI7Y0FBSWE7Y0FObEM4QjtjQURBaVE7Y0FPcUN5cEI7Y0FBV0Y7SUFDNEI7SUFUdEQsZUFJdEJELGVBSUFFOzs7Ozs7UUFLa0MsK0JBQUE7Ozs7UUFPRSxJQUlsQ3hwQixZQUNBalEsZUFMa0MsbUJBSWxDaVEsS0FDQWpROzs7Ozs7RTs7Ozs7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7UUNuQkZtTzthQUVBM1EsS0FBTXM4QixLQUFLQyxTQUFTQyxLQUFLQyxTQUFTNThCO0tBSXBCLFVBQUEsbUJBSlJ5OEI7S0FDUiw4Q0FEYUMsU0FBdUIxOEI7S0FRcEIsVUFBQSxtQkFSTTI4QjtLQUt0Qiw4Q0FMMkJDLFNBQVM1OEI7bUJBQUFBOztlQVNwQixXQVhkOFEsYUFFTTJyQixLQUFLQyxTQUFTQyxLQUFLQyxTQUFTNThCOztJQVN3QjthQUcxRDY4QixNQUNHSixLQUNDLzFCLFVBRURpMkI7S0FJTCxHQU5NajJCLFNBQVVDLE1BQVZELFFBQUFnMkIsVUFBVS8xQixjQUFWKzFCO0tBTU47VUFMZ0IxYyxnQkFBVjhjLFVBQVU5Yzs7TUFBQTtPQUFBLE1BQUEsbUJBRlh5YztPQUVDSyxVQUFVLGlDQURWSjtLQU1OLFlBSGdCcGEsZ0JBQVZzYSxVQUFVdGEsZ0JBQVZzYTtLQUdOLE9BcEJFejhCLEtBYUdzOEIsS0FDQ0MsU0FFREMsS0FDQ0MsU0FGQUU7SUFLdUM7YUFNM0NwOEIsSUFBSSs3QixLQUFLbGhCLEtBQUt2YjtLQUNvRCxVQUFBLG1CQUQ5RHk4QjtLQUNOLDhDQURXbGhCLEtBQUt2YjtLQUVOLElBQU4yOEIsTUFBTSxtQkFGTTM4QixLQUFWeThCO1lBQVV6OEIsS0FHQSxXQS9CZDhRLGFBNEJJMnJCLEtBQUtsaEIsS0FFUG9oQixRQUZZMzhCO0tBR0EsT0FEWjI4QjtJQUVEO2FBR0RJLEtBQU9yMkIsS0FBVTFHLEtBQUl5OEI7S0FDdkIsR0FEUy8xQixTQUFNQyxNQUFORCxRQUFBNlUsTUFBTTVVLGNBQU40VTtLQUNULEdBRG1CdmI7VUFNUGxHLElBTk9rRyxRQU1QMkYsTUFBQTdMOztNQUNHO09BQUEsTUFBQSxtQkFQUTJpQztPQU1YOTJCLE1BQ0csaUNBUE40VjtLQU9NLE9BZGI3YSxJQU9xQis3QixLQUFkbGhCLEtBTUc1VjtJQUN3QjtJQTNDeEMsV0FDTW1MLGFBRUEzUSxNQVlBMDhCLE9BY0FuOEIsS0FPQXE4Qjs7O2FBeUVBcjhCLElBQUkrN0IsS0FBS2xoQixLQUFLdmI7S0FDNEMsVUFBQSx3QkFEdER5OEIsS0FBS2xoQixLQUFLdmI7S0FDNEMsT0FBQTtJQUFtQjthQUc3RSs4QixLQUFNeGhCLEtBQUt2YixLQUFJeThCO0tBQzJDLFVBQUEsd0JBRHBEbGhCLEtBQUt2YixLQUFJeThCO0tBQzJDLE9BQUE7SUFBb0I7SUFScEYsV0FHTS83QixLQUlBcThCOzs7Ozs7aUJBNUNFQyxZQUFhaDlCLFlBQVEsT0FBQSx3QkFBUkEsS0FBbUI7O1NBQ2hDMkM7U0FDQW1POzt3QkFEQW5PLGFBQUFBLFFBREFxNkIsYUFFQWxzQjtTQXRFRm1zQjtTQUVBOThCO1NBWUEwOEI7U0FjQW44QjtTQU9BcThCO21CQWpDQTU4QixNQVlBMDhCLE9BZEFJLGVBNEJBdjhCLEtBT0FxOEI7OztZQTZESXA2QjtpQkFDQXE2QixZQUFhaDlCLFlBQVEsT0FBQSxtQkFBUkEsS0FBbUI7O1NBQ2hDOFE7U0FUQW1KOzRCQUFBQSxlQU9BdFgsUUFDQXE2QixhQUNBbHNCOzs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7SUNoRkE1WjtJQUNBcVA7SUFDQWdMO0lBQUE1Rzs7O1lBRVJGLGVBWk11TDtJQUFvQixPQUFBLDZCQUFwQkE7R0FBd0Q7WUFxQjVEa25CLGVBQVUscUJBRUE7WUFHVkMsZUFBVSxxQkFFQTtZQUdWQyxVQUFVQyxHQUFHbmhCLFdBQVNwYjtJQUN4QixLQURZdThCLEdBR0YsT0FIS25oQjtRQUVSL3JCLElBRktrdEM7SUFFQSxPQUFBLFdBRll2OEIsR0FFakIzUTtHQUNVO1lBR2Y2USxLQUFLcThCLEdBQUd2OEI7SUFDVixLQURPdThCLEdBRUc7UUFDSHA1QixJQUhBbzVCO0lBR0ssT0FBQSxXQUhGdjhCLEdBR0htRDtHQUFRO1lBR2J5RyxVQUFVNUosR0FBRUQsR0FBSSxPQU5oQkcsS0FNWUgsR0FBRkMsR0FBZTtZQUV6Qnc4QixLQUFLbnRDLEdBQUcyUTtJQUNWLEtBRFVBLEdBRUE7UUFDSG11QixNQUhHbnVCO0lBR0UsT0FBQSxXQUFMbXVCLEtBSEE5K0I7R0FHUTtZQUdiMGdDLE1BQU1od0IsR0FBR3FiO0lBQ1gsS0FEUXJiLEdBRUUsT0FGQ3FiO1FBR0ovckIsSUFIQzBRO0lBR0ksT0FBTDFRO0dBQU07WUFHWG90QyxVQUFXOUcsTUFBTW5mLE9BQU8yZixTQUFRcDJCO0lBQ2xDLEdBRGtDQSxPQUUzQjFRLElBRjJCMFEsTUFFdEIsT0FBTDFRO09BRk1zbUM7U0FVRnpyQixJQVZFeXJCO1FBQU1uZjtNQWlCWDtPQUpXNVIsSUFiQTRSO09BaUJYO1NBQUE7O09BRkEsTUFyQk51WixNQU13Qm9HO2FBY3BCLDBDQURhdnhCLEdBSFJzRjthQVZlaXNCOztPQVlENWMsSUFaQzRjOztTQVlJLGlDQUFMNWMsR0FGZHJQOzs7O1NBQ0w7Ozs7O1dBREtBOztTQU5Md3lCOztZQUphbG1CO1NBUUZpSixNQVJFako7UUFBTzJmO1VBU0R3RyxNQVRDeEcsa0JBU0ksMkJBRGIxVyxLQUNRa2Q7O2dCQURSbGQ7U0FKWGlkOztZQUpvQnZHO1NBT0h5RyxNQVBHekcsWUFJcEJ1RyxVQUdzQiwyQkFBTEU7O1NBSGpCRixVQUVvQjtJQWF4QixPQUFBLDJCQWZJQTtHQWVhO1lBR2pCRyxlQUFlTixHQUFHbmhCO0lBQ3BCLEtBRGlCbWhCLEdBR1AsT0FBQSxXQUhVbmhCO1FBRWIvckIsSUFGVWt0QztJQUVMLE9BQUxsdEM7R0FDYTtZQUdsQjJwQixTQUFTalosR0FDWCxLQURXQSxHQUVELGdCQUNIMVEsSUFISTBRLE1BR0MsV0FBTDFRLEdBQVk7WUFHakJ3USxRQUFRRSxHQUNWLEtBRFVBLEdBRUEsY0FDSDFRLElBSEcwUSxNQUdFLFdBQUwxUSxNQUFVO1lBR2ZzcEIsUUFBUTVZLFVBQWUsT0FBZkEsRUFBZ0I7WUFDeEI4WSxRQUFROVksVUFBZSxPQUFmQSxFQUFnQjtZQUV4QnFZLElBQXFCQyxHLGdCQUF3Q3RZLEdBQUdDLEdBQ2xFLE9BdEVFczhCLFVBcUU2RHY4QixHQUF4Q3NZLE1BQTJDclksR0FDcEM7WUFHNUJzQyxRQUFRdkMsR0FBR0M7SUFDYixLQURVRCxHQUVBO1FBQ0gxUSxJQUhHMFE7SUFHRSxPQUFBLFdBSENDLEdBR04zUTtHQUFRO1lBR2I0UyxPQUFPbEMsR0FBR0M7SUFDWixLQURTRCxHQUVDO1FBQ0gxUSxJQUhFMFE7SUFHRyxPQUFBLFdBSEFDLEdBR0wzUTtHQUFRO1lBR2IrcUIsSUFBSXJhLEdBQUVvRCxHQUFHOU07SUFDWCxLQURNMEosR0FFSTtRQUNIMkgsTUFIRDNIO0lBR08sT0FBQSxXQUhGMUosT0FBSDhNLEdBR0R1RTtHQUFnQjtZQUdyQjdGLE9BQU85QixHQUNULE9BRFNBLFVBR0k7WUFLWEQsS0FBS0MsR0FBR04sTUFBTU87SUFDaEIsS0FET0QsR0FFRyxPQUZBTjtRQUdIcFEsSUFIQTBRO0lBR0ssT0FBQSxXQUhJQyxHQUFOUCxNQUdIcFE7R0FBYTtZQUdsQjhvQixNQUFNcFksR0FBR0M7SUFDWCxLQURRRCxHQUVFO1FBQ0hvRCxJQUhDcEQ7SUFHTyxPQUFBLFdBSEpDLEdBR0ptRDtHQUF5QjtZQUc5QjRWLEtBQUtoWixHQUFHQztJQUNWLEtBRE9ELEdBRUc7UUFDSDFRLElBSEEwUTtJQUdRLE9BQUEsV0FITEMsR0FHSDNRLEtBSEEwUTtHQUc0QjtZQUdqQytZLFNBQVMvWSxHQUFHQztJQUNkLEtBRFdELEdBRUQ7UUFDSG9ELElBSElwRDtJQUdDLE9BQUEsV0FIRUMsR0FHUG1EO0dBQVE7WUFHYjlNLE1BQU0ySixHQUFFaUcsS0FBRWxHO0lBQ1osR0FEVWtHO1FBQUVsRyxPQUdHMVEsSUFISDBRLE1BR0xxVyxNQUhHblEsUUFHVyxPQUFBLFdBSGJqRyxHQUdEb1csS0FBUS9tQjs7Y0FISDBRLEdBRUk7SUFFVDtHQUFLO1lBR1YrOEIsS0FBS3p0QyxHQUFJLFdBQUpBLEdBQVU7WUFFZjB0QyxXQUFXMXRDLEdBQUVDLEdBQ2YsT0FEYUQsSUFBQUEsSUFBRUMsRUFHSjtZQUdUMHRDLFFBQVFDLE1BQUs1dEMsR0FBSSxPQUFUNHRDLFdBQUs1dEMsT0FBaUM7WUFFOUN5N0IsTUFBTTNuQixHQUFFQyxHQUFHcEQ7SUFDYixHQURRbUQ7UUFBRUMsT0FHS3VFLE1BSEx2RSxNQUdIc0UsTUFIQ3ZFLE1BR1ksV0FBSyxXQUhabkQsR0FHTjBILEtBQVFDO1NBRFB0WSxJQUZBOFQ7OztTQUVBOVQsSUFGRStUO0lBRWEsT0FBZi9UO0dBQ3dCO1lBRzlCczBCLE9BRUE1akIsR0FGVUM7SUFDWixHQUNFRCxPQUFLdU8sSUFBTHZPLE1BQWlCLEdBQUEsV0FGUEMsR0FFTHNPLElBQW1CLE9BQXhCdk87SUFDSztHQUFJO1lBR1R3WCxTQUFTdlg7SUFDWCxJQUFNLElBQ0ozUSxJQURJLFdBREsyUSxrQkFHTTtJQURWLFdBQUwzUTtHQUNtQjtZQUduQjhvQyxjQUFjbjRCO0lBQ2hCLElBQU0sSUFDSjNRLElBREksV0FEVTJRLE9BRVQsT0FBTDNRLGNBQ2U7R0FBSTtnQkFHZjBRLEdBQUdDO0lBQ1QsS0FETUQsR0FFSTtRQUNIb0QsSUFIRHBEO0lBR00sV0FBSyxXQUhSQyxHQUdGbUQ7R0FBZTtZQWFsQnFNLE1BVkl4UCxHQUFFM1EsR0FDVixLQURRMlEsR0FFRSxjQUNIbXVCLE1BSENudUIsTUFHSSxXQUhGM1EsR0FHSDgrQixLQUFhO1lBTWhCamhCLFNBQU83ZCxHQUFJLFdBQUpBLEdBQVU7R0FFWCxJQUFOK1E7WUFFQW9OLEtBQUsrdUIsR0FBR3Y4QjtJQUNWLEtBRE91OEIsR0FFRztRQUNIbHRDLElBSEFrdEM7SUFHSyxPQUFBLFdBSEZ2OEIsR0FHSDNRO0dBQVE7O3dDQUhibWUsTUFKQU4sVUFFQTlNOzs7Ozs7O2tEQUZBOE0sVUFDQXNDLE9BQ0FwUDs7Ozs7Ozs7Ozs7Ozs7WUFZRmtZLFlBQVl2WSxHQUFHTixNQUFNTztJQUFJLE9BQUEsOEJBOUZ6QkYsTUE4RmVMLE1BQU1PLEdBQVREO0dBQW1EO1lBQy9EMFksV0FBVzFZLEdBQUdOLE1BQU1PO0lBQUksd0NBL0Z4QkYsTUErRmNMLE1BQU1PO0lBQUkscUIsNEJBQWJEO0dBQWtEOzs7O09Bek52RDNKO09BQ0FxUDtPQUdSa0U7T0E4SUV0VDtPQS9HQXVUO09BakNNNkc7T0FBQTVHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXlDTmttQjtPQU1BME07T0ExQkFIO09BZ0RBTztPQW1EQS84QjtPQWRBc2E7T0FNQXZZO09BckZBM0I7T0F5RUErQjtPQU5BSztPQXNDQXlXO09BTUFEO09BekRBalo7T0FOQW1aO09BeENBd2pCO09BOEhBMVI7T0FNQW5IO09BTUFwTTtPQU1BNGdCO09BNUJBMkU7T0FFQUM7T0FNQUM7T0FwSkFaO09BS0FDO09BTEFEO09BMk1BOWpCO09BQ0FHO09BaElBRTtPQUNBRTtPQXNDQVY7T0FwQ0FDOzs7RTs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7YUNySEUzSCxVQUFVMUY7S0FDSixJQUFKdE4sSUFBSSx3QkFESXNOO0tBRVosSUFBSSxVQUFBLGlCQURBdE4sSUFDQTtXQUNGNE47VUFBQUYsMEJBQUFFO01BQU8sT0FBQSw2QkFBUEYsS0FIVUo7O0lBR3VCO2FBR2pDbEIsVUFBVTlKO0tBQXVCLFVBQUEsaUJBQXZCQTtLQUF1QixPQUFBO0lBQWlCO0lBUE4sV0FDNUMwUSxXQU1BNUc7OzthQVVBNEcsVUFBVXlzQixXQUFVbnlCO0tBQ2QsSUFBSnROLElBQUksd0JBREl5L0IsV0FBVW55QjtLQUV0QixJQUFJLFVBQUEsaUJBREF0TixJQUNBO1dBQ0Y0TjtVQUFBRiwwQkFBQUU7TUFBTyxPQUFBLDZCQUFQRixLQUhvQko7O0lBR2E7YUFHakNsQixVQUFVMFEsV0FBVXhhO0tBQWlDLFVBQUEsaUJBQWpDQTtLQUFpQyxPQUFBLHdCQUEzQ3dhO0lBQTREO0lBUGxCLFdBQ3BEOUosV0FNQTVHOzs7YUFVQTRHLFVBQVV5c0IsV0FBVUMsV0FBVXB5QjtLQUN4QixJQUFKdE4sSUFBSSx3QkFESXkvQixXQUFVQyxXQUFVcHlCO0tBRWhDLElBQUksVUFBQSxpQkFEQXROLElBQ0E7V0FDRjROO1VBQUFGLDBCQUFBRTtNQUFPLE9BQUEsNkJBQVBGLEtBSDhCSjs7SUFHRzthQUdqQ2xCLFVBQVUwUSxXQUFVNmlCLFdBQVVyOUI7S0FDTyxVQUFBLGlCQURQQTtLQUNPLE9BQUEsd0JBRDNCd2EsV0FBVTZpQjtJQUNrQztJQVJVLFdBQ2hFM3NCLFdBTUE1Rzs7O2FBWUE0RyxVQUFVeXNCLFdBQVVDLFdBQVVFLFdBQVV0eUI7S0FDbEMsSUFBSnROLElBQUksd0JBREl5L0IsV0FBVUMsV0FBVUUsV0FBVXR5QjtLQUUxQyxJQUFJLFVBQUEsaUJBREF0TixJQUNBO1dBQ0Y0TjtVQUFBRiwwQkFBQUU7TUFBTyxPQUFBLDZCQUFQRixLQUh3Q0o7O0lBR1A7YUFHakNsQixVQUFVMFEsV0FBVTZpQixXQUFVRSxXQUFVdjlCO0tBQ08sVUFBQSxpQkFEUEE7S0FDTyxPQUFBLHdCQURyQ3dhLFdBQVU2aUIsV0FBVUU7SUFDa0M7SUFSUSxXQUN4RTdzQixXQU1BNUc7OzthQU1BNEcsVUFBVTFGO0tBQ1osU0FEWUE7TUFNVixPQUFBO2lFQU5VQTtTQUVBdE4sSUFGQXNOO0tBR1YsSUFBSyxVQUFBLGlCQURLdE4sSUFDTDtXQUNGNE47VUFBQUYsMEJBQUFFO01BQU8sT0FBQSw2QkFBUEYsS0FKT0o7O0lBUUo7YUFHTmxCLFVBQVU5SixHQUFJLFdBQVUsaUJBQWRBLElBQTZCO0lBWm9CLFdBQzNEMFEsV0FXQTVHOzs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUM5RUZ0SjtJQUFPLHVCQUNEbFIsY0FBSyxXQUFMQTtRQUNDK21CO0lBQUssV0FBTEE7R0FBWTtZQUduQm1uQixnQkFBVyw4QkFFTTtZQUdqQkMsaUJBQVksOEJBRUk7WUFHaEJ6TixpQkFBYTFnQyxjQUFnQixPQUFoQkE7WUFFYml0QyxVQUFVdjhCLEdBQUcwOUIsT0FBT0M7SUFDdEIsU0FEWTM5QixVQUVKMVEsSUFGSTBRLE1BRUMsT0FBQSxXQUZFMDlCLE9BRVBwdUM7UUFDQyttQixNQUhHclc7SUFHRSxPQUFBLFdBSFEyOUIsUUFHYnRuQjtHQUFhO1lBS3BCaFcsSUFBSUwsR0FBRzA5QixPQUFPQztJQUNoQixTQURNMzlCLFVBRUUxUSxJQUZGMFEsTUFFTyxXQUFNLFdBRlYwOUIsT0FFRHB1QztRQUNDK21CLE1BSEhyVztJQUdRLFdBQU8sV0FITDI5QixRQUdQdG5CO0dBQXNCO1lBRzdCcW5CLE1BQU1wdUMsR0FBSSxXQUFKQSxHQUFXO1lBQ2pCcXVDLE9BQU9ydUMsR0FBSSxXQUFKQSxHQUFZO1lBRW5CZ0gsTUFBTXNuQyxLQUFJQyxLQUFJejhCLElBQUdDO0lBQ25CLFNBRGdCRDtTQUVSOVIsSUFGUThSO2NBQUdDLFdBRUY5UixJQUZFOFIsT0FFRyxPQUFBLFdBRmR1OEIsS0FFQXR1QyxHQUFTQzs7O1NBQ1I4bUIsTUFIT2pWO2NBQUdDLFdBR0E2UyxNQUhBN1MsT0FHSyxPQUFBLFdBSFp3OEIsS0FHSHhuQixLQUFVbkM7O0lBQ3dCO0dBQUs7WUFHOUNySyxVQUFVNUosR0FBRXZDO0ksdUJBQ05wTyxjQUFLLE9BQUEsV0FERDJRLEdBQ0ozUTtRQUNDQztJQUFLLE9BQUEsV0FGQW1PLEdBRUxuTzs7O0lBOEJLO0tBRk40ZDtLQXJCTjJ3QjtLQUNBQztLQUVBcG1CO0tBbUJNbEs7S0FDQXBOOzs7aUJBUEFMLEdBQUdDO1NBQUksT0FBVTtrQkFNakJ3TjtrQkFOQXpOOzJCQUFzQjFRLEdBQUssT0FBTyxXQUtsQzZkLFVBTGtDLFdBQS9CbE4sR0FBbUIzUSxJQUFpQjtRQUFDOzZDQU14Q21lLE1BQ0FwTixLQUZBOE07Ozs7O0tBUUFzQjs7O2FBQ0FnQixNQUFNck8sSUFBR0M7S0FBSyxPQUFXOztjQUFuQkQ7dUJBQXdCbkI7ZUFBSyxPQUFXOzt3QkFBckNvQjtpQ0FBMEMvUixHQUFLLE9BQU8sV0FEL0RtZixVQUMrRCxXQUFqQ3hPLEdBQXFCM1EsSUFBaUI7Y0FBQztJQUFDO0lBQ2hFO0tBQU5vZjsrQ0FGQUQsVUFDQWdCLE9BQ0FmOzs7Ozs7Ozs7Ozs7OzthQU1Fc3ZCLFdBQVcvOUIsR0FBRXVZO0ssWUFDWCxPQUFBLFdBdENWc2xCLE9BcUNxQnRsQjtTQUVabEssZUFBTHRPO0tBSVMsT0FBQTtjQTFDYis5QjtjQXNDSS85Qjs4QkFHb0IsT0FMaEJnK0IsV0FBVy85QixHQUFFdVksS0FFWmxLLElBR2tDO3VCQUN6Qmt1QixHQUFLLE9BTmZ3QixXQUFXLzlCLEdBTWlCLFdBTmpCQSxHQUFFdVksS0FNSGdrQixJQUpUbHVCLElBSXVDOzthQUV4QzJ2QixZQUFZaCtCLEdBQUV1WTtLLFlBQ0wsT0FBQSxxQkFBQSwyQkFES0E7U0FFYmxLLGVBQUx0TztLQUlTLE9BQUE7Y0FsRGIrOUI7Y0E4Q0kvOUI7dUJBR2UxUSxHQUFLLE9BTGhCMnVDLFlBQVloK0IsT0FLRDNRLEdBTEdrcEIsTUFFYmxLLElBRzBDO3VCQUNqQ2t1QixHQUFLLE9BZGZ3QixXQVFZLzlCLEdBTUZ1OEIsR0FKVGx1QixJQUkrQjs7YUFmdEM0dkIsWUFpQkU1dkIsSUFBSXJPLEdBQUssT0FSTGcrQixZQVFBaCtCLE1BQUpxTyxJQUE0QjthQUl4QjZ2QixhQUFXbCtCLEdBQUV1WTtLLFlBQ1gsT0FBQSxXQTFEVnNsQixPQXlEcUJ0bEI7U0FFWmxLLGVBQUx0TztLQUlTLE9BQUE7Y0E5RGIrOUI7Y0EwREkvOUI7OEJBR3FCLE9BTGpCbStCLGFBQVdsK0IsR0FBRXVZLEtBRVpsSyxJQUdtQzt1QkFDMUJrdUIsR0FBSyxPQU5mMkIsYUFBV2wrQixHQU1pQixXQU5qQkEsR0FBRXVZLEtBTUhna0IsSUFKVGx1QixJQUl1Qzs7YUFFeEM4dkIsY0FBWW4rQjtLLFlBQ1YsT0FBQTtTQUNEcU8sZUFBTHRPO0tBQ3FELE9BQUE7Y0FuRXpEKzlCO2NBa0VJLzlCOzhCQUM0QixPQUh4Qm8rQixjQUFZbitCLEdBRVhxTyxJQUN1Qzt1QkFBY2t1QixHQUFLLE9BWDNEMkIsYUFRWWwrQixHQUcwQ3U4QixHQURyRGx1QixJQUMyRTs7YUFabEYrdkIsaUJBY0UvdkIsSUFBSXJPLEdBQUssT0FMTG0rQixjQUtBbitCLEdBQUpxTyxJQUF5QjthQUczQmd3QixVQUFVdCtCO0tBQUksT0FBb0MsV0F4RXBEKzlCLFFBd0VZLzlCLG9DQUFrRCxTQUFJO0lBQUM7YUFDakVnd0IsTUFBTWh3QixHQUFHcWI7S0FBVSxPQUE4QjtjQXpFbkQwaUI7Y0F5RVEvOUI7NEI7OEJBQXFELE9BQWxEcWIsVUFBeUQ7SUFBQzthQUVuRXBPLFlBQVloTjtLQUNkLE9BQVk7O3VCQUFLdUg7ZUFBTyxPQUFNO3dCQTdFOUJzMkI7d0JBNkU4QjswQkFEaEI3OUIsR0FDbUIsZ0NBQWhCdUg7Y0FBb0Q7SUFBQztJQWpFMUU7OztZQVRJbVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQWlDRXVtQjtZQW9CQUc7WUFpQkFDO1lBQ0F0TztZQUVBL2lCOztZQVdFOHdCLE9BQU8vOUIsR0FBR21OLFVBQVEyd0I7SUFDcEIsU0FEUzk5QixVQUVEMVEsSUFGQzBRLE1BRUksT0FBQSxXQUZEbU4sVUFFSjdkO1FBQ0NDLElBSEF5UTtJQUdLLE9BQUEsV0FITTg5QixPQUdYdnVDO0dBQVk7WUFHbkJvb0IsUUFBUXZXLElBQUdDLElBQUlwQixHQUFHNjlCO0lBQ3BCLFNBRFUxOEI7U0FFRjlSLElBRkU4UjtjQUFHQyxXQUVJOVIsSUFGSjhSLE9BRVMsV0FBTSxXQUZYcEIsR0FFVDNRLEdBQVNDO1NBRVI4bUIsTUFKSWhWOzs7U0FHSjBlLE1BSEMzZTtjQUFHQztVQUdNNlMsTUFITjdTO01BR1csV0FBTyxXQUhYeThCLE9BR1gvZCxLQUFVN0w7O1NBQ1ZtQyxNQURBMEo7O0lBQ3NCLFdBQXRCMUo7R0FBOEI7WUFHckM1SSxLQUFLek4sR0FBR0M7SUFDVixTQURPRCxNQUlZLE9BSlpBO1FBRUMxUSxJQUZEMFE7SUFFTSxPQUFBLFdBRkhDLEdBRUYzUTtHQUVZO2dDQTNIdEJvdUMsT0FDQUMsUUF5R0lJLFFBTUFwbUIsU0FPQWxLO1lBY0E4d0IsU0FBT3YrQixHQUFHbU4sVUFBUTJ3QjtJQUNwQixTQURTOTlCLFVBR0QxUSxJQUhDMFEsTUFHSSxPQUFBLFdBSE84OUIsT0FHWnh1QztRQURDQyxJQUZBeVE7SUFFSyxPQUFBLFdBRkZtTixVQUVINWQ7R0FDVztZQUdsQml2QyxVQUFRcDlCLElBQUdDLElBQUlwQixHQUFHNjlCO0lBQ3BCLFNBRFUxOEI7U0FHRjlSLElBSEU4UjtjQUFHQyxXQUdJOVIsSUFISjhSLE9BR1MsV0FBTSxXQUhSeThCLE9BR1p4dUMsR0FBU0M7U0FDVDhtQixNQURBL21COzs7U0FEQ3l3QixNQUZDM2U7Y0FBR0MsV0FFTTZTLE1BRk43UyxPQUVXLFdBQU8sV0FGZHBCLEdBRVI4ZixLQUFVN0w7U0FFWG1DLE1BSktoVjs7SUFJZ0IsV0FBckJnVjtHQUE0QjtZQUdsQzdILE9BQUt4TyxHQUFHQztJQUNWLFNBRE9ELE1BSVcsT0FKWEE7UUFFRTFRLElBRkYwUTtJQUVPLE9BQUEsV0FGSkMsR0FFRDNRO0dBRVU7R0FJVDs4QkF6SlpxdUMsUUFEQUQsT0FxSUlhLFVBTUFDLFdBT0Fod0I7SUFRUTs7Ozs7Ozs7T0FoSlozRTtPQXpDQXJKO09BZUF3dkI7T0FFQXVNO09BQUFBO09BUUFsOEI7T0FTQS9KOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTdCQWtuQztPQUtBQztPQXFCQUM7T0FDQUM7Ozs7RTs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7O0lDbkNBMXdCO1lBRUE3TSxNQUFPTCxNQUFLQyxHQUFHQztJQUVkO01BRk1GLE1BQUtDLGVBRVkvRyxHQUFFM0osR0FDdkIsV0FIWTJRLEdBRVNoSCxHQUFFM0osSUFDdkIsT0FEcUIySixVQUVoQjtJQUZQO0dBR007WUFHUHl3QixNQUFPM3BCLE1BQUtDLEdBQUdOLE1BQU1PO0lBQ2YsSUFBSmhIO0lBQ1ksT0FBQTthQUZQOEc7YUFBS0M7YUFBR047c0JBRUk4WSxLQUFJaks7Y0FDYixJQUFOMmIsUUFBTSxXQUhXanFCLEdBQ25CaEgsTUFDaUJ1ZixLQUFJaks7Y0FEckJ0VixPQUFBQTtjQUlGLE9BRklpeEI7YUFFRDtHQUFDO1lBR0pxRCxPQUFRN0QsT0FBTTFwQixHQUFHQztJQUFJLE9BQW1CO2FBQWhDeXBCO2FBQU0xcEI7O3NCQUErQi9HLEdBQUV1WixHQUFFcFAsR0FBSyxPQUFHLFdBQXhDbkQsR0FBNEJoSCxHQUFJbUssS0FBRm9QLFlBQUFBLEVBQWlDO0dBQUM7WUFFakZnUyxRQUFTcGtCLE9BQU1vUCxHQUFHdlA7SUFDcEIsT0FBWTthQXJCVmdOO3NCQXFCZXhGO2NBQ2Y7Z0JBRlNySDtnQkFBTW9QO3lCQUVDdlcsR0FBRTNKO2lCQUFRLFVBQUEsV0FGUjJRLEdBRUZoSCxHQUFFM0o7aUJBQVEsYUFBVyxXQUR0Qm1ZO2dCQUNtQztjQUFsRDthQUNLO0dBQUM7WUFHTjhjLFNBQVVua0IsT0FBTW9QLEdBQUd2UDtJQUNyQixPQUFZO2FBM0JWZ047c0JBMkJleEY7Y0FDZjtnQkFGVXJIO2dCQUFNb1A7eUJBRUF2VyxHQUFFM0o7aUJBQVksY0FBQSxXQUZYMlEsR0FFSGhILEdBQUUzSjs4QkFBeUIsV0FENUJtWTtnQkFDMEM7Y0FBekQ7YUFDSTtHQUFDO1lBR0wyYyxVQUFXaGtCLE9BQU1KLEdBQUdDO0lBQ3RCLE9BQVk7YUFqQ1ZnTjtzQkFpQ2V4RjtjQUNmO2dCQUZXckg7Z0JBQU1KO3lCQUVEL0csR0FBRTNKO2lCQUNWLElBRUo0VCxNQUZJLFdBSFlqRCxHQUVKaEgsR0FBRTNKO3dCQUdkNFQsTUFBaUIsV0FKTnVFLEdBSVh2RTtnQkFBNkI7Y0FIakM7YUFJSTtHQUFDO1lBR0wrZ0IsTUFBTzdqQixPQUFNb1AsR0FBR3ZQO0lBQ2xCLE9BQVk7YUExQ1ZnTjtzQkEwQ2V4RjtjQUNmO2dCQUZPckg7Z0JBQU1vUDt5QkFFR3ZXLEdBQUUzSjtpQkFBUSxVQUFBLFdBRlYyUSxHQUVBaEgsR0FBRTNKO2lCQUFRLGFBQW9CLFdBRC9CbVksV0FDQ3hPLEdBQUUzSjtnQkFBeUM7Y0FBM0Q7YUFDSTtHQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBV0htdkMsbUJBRzBCeitCLEdBQUdDLEdBQUssT0F4RHBDRyxZQXdENEJKLEdBQUdDLEdBQXFCOztTQUQxQ3krQixvQkFGUkQsVUFFUUM7OztTQUlSQyxtQkFHMEIzK0IsR0FBR04sTUFBTU8sR0FBSyxPQXREMUN5cEIsWUFzRDRCMXBCLEdBQUdOLE1BQU1PLEdBQTJCOztTQUR0RDIrQixzQkFGUkQsVUFFUUM7YUFJUkMsU0FBTzcrQixHQUFHQyxHQUFJLE9BakRoQnN0QixPQTJDRW9SLFNBTU8zK0IsR0FBR0MsR0FBc0I7YUFDaEM2K0IsVUFBUTkrQixHQUFHQyxHQUFJLE9BaERqQnVrQixRQW1DRWlhLFNBYVF6K0IsR0FBR0MsR0FBdUI7YUFDbEM4K0IsV0FBUy8rQixHQUFHQyxHQUFJLE9BM0NsQnNrQixTQTZCRWthLFNBY1N6K0IsR0FBR0MsR0FBd0I7YUFDcEMrK0IsWUFBVWgvQixHQUFHQyxHQUFJLE9BdENuQm1rQixVQXVCRXFhLFNBZVV6K0IsR0FBR0MsR0FBeUI7YUFDdENnL0IsUUFBTWovQixHQUFHQyxHQUFJLE9BOUJmZ2tCLE1BY0V3YSxTQWdCTXorQixHQUFHQyxHQUFxQjtJQW5CcUM7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBU25FMCtCO1lBTkFGO1lBYUFLO1lBQ0FDO1lBRkFGO1lBSUFJO1lBREFEOzs7OztPQTVERnRWO09BUkF0cEI7T0FnQkFtdEI7T0FFQS9JO09BTUFEO09BZUFOO09BVEFHOzs7O1NBOENFL0o7Ozs7Ozs7U0ExQkdqQjtTQUFBckY7U0FBQW1GO1NBQUFrQjtTQUFBN0I7U0FBQUc7U0FBQXhXO1NBQUFLO1NBQUE2VjtTQUFBQztTQUFBVztTQUFBRDtTQUFBalo7U0FBQW1aO1NBQUFMO1NBQUFFO1NBQUE2bEI7U0FBQUY7U0FBQWphO1NBQUFEO1NBQUFnSjtTQUFBdEo7U0FBQUc7O2dCQTBCSC9KO2dCQTFCR2pCO2dCQUFBckY7Z0JBQUFtRjtnQkFBQWtCO2dCQUFBN0I7Z0JBQUFHO2dCQUFBeFc7Z0JBQUFLO2dCQUFBNlY7Z0JBQUFDO2dCQUFBVztnQkFBQUQ7Z0JBQUFqWjtnQkFBQW1aO2dCQUFBTDtnQkFBQUU7Z0JBQUE2bEI7Z0JBQUFGO2dCQUFBamE7Z0JBQUFEO2dCQUFBZ0o7Z0JBQUF0SjtnQkFBQUc7Ozs7O1NBd0NIL0o7Ozs7Ozs7U0F4Q0dqQjtTQUFBckY7U0FBQW1GO1NBQUFrQjtTQUFBN0I7U0FBQUc7U0FBQXhXO1NBQUFLO1NBQUE2VjtTQUFBQztTQUFBVztTQUFBRDtTQUFBalo7U0FBQW1aO1NBQUFMO1NBQUFFO1NBQUE2bEI7U0FBQUY7U0FBQWphO1NBQUFEO1NBQUFnSjtTQUFBdEo7U0FBQUc7O2dCQXdDSC9KO2dCQXhDR2pCO2dCQUFBckY7Z0JBQUFtRjtnQkFBQWtCO2dCQUFBN0I7Z0JBQUFHO2dCQUFBeFc7Z0JBQUFLO2dCQUFBNlY7Z0JBQUFDO2dCQUFBVztnQkFBQUQ7Z0JBQUFqWjtnQkFBQW1aO2dCQUFBTDtnQkFBQUU7Z0JBQUE2bEI7Z0JBQUFGO2dCQUFBamE7Z0JBQUFEO2dCQUFBZ0o7Z0JBQUF0SjtnQkFBQUc7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7SUNzY0M4YTs7Ozs7Ozs7Ozs7Ozs7OztZQTllSnAxQixVQVVJdUssVUFBWThxQjtJQUhsQiw4QkFJYzs7S0FFUyxJQURaN0wscUJBQ0RDLFdBQWEsV0FITDRMLFVBRVA3TDtLQUVMLHdCQURJQzs7SUFHYTtLQURFNW9CO0tBQVpDO0tBQ0hDLFdBQWEsV0FOakJ3SixVQUtPeko7S0FFSEUsV0FBYSxXQVBMcTBCLFVBS094MEI7SUFHbkIsd0JBRklFLGNBQ0FDO0dBQ3FFO0dBM0JyRSxlQVNSaEI7WUFnQ0FzMUI7SUFDSSxJQURvQm4vQixjQUFIdkMsY0FDakIsUUFBQSxXQURvQnVDLEdBQUh2QztrQ0FFYjsyQkFDSDhHLGdCQUFLLGVBQUxBLEtBSG1CdkU7UUFJZGtFLGdCQUFIZjtJQUFTLFdBQVRBLE9BQUdlLEtBSmNsRTs7WUFPeEJvL0Isa0JBQWtCM2hDLEdBQUdnQyxNQUFNTyxHQUFHMFk7SUFDaEMsU0FBUXZLLEtBQUsxUSxHQUFFNGhDLE1BQUszbUIsUUFBTzFZLEdBQUV1WTtLQUNyQixZQUFBLFdBRE84bUIsTUFBRjVoQzttQ0FFRCxPQUFBLFdBRlFpYixRQUFTSDs7VUFHcEJoVTtNQUFtQixPQUFBO2VBSER2RTtlQUFFdVk7OzZCLE9BQXJCcEssS0FHQzVKLEtBSE04NkIsTUFBSzNtQixRQUFPMVk7O1NBSWJrRSxnQkFBSGY7S0FBMkIsT0FBQTtjQUpYbkQ7Y0FBRXVZO2tCQUlsQnBWOzRCLE9BSkhnTCxLQUlNakssS0FKQ203QixNQUFLM21CLFFBQU8xWTtJQUlpQztRQUc3Q3EvQixPQVJLNWhDLE1BUVI4RyxNQVJROUc7SUFRSSxPQVBoQjBRLEtBT0k1SixLQUFHODZCLE1BUmlCM21CLFFBQUgxWSxHQUFOUDtHQVEwQjtHQWhCckM7SUFBQSxhQUNWMC9CLFdBT0FDOzs7WUFZRkUsWUFBYTcvQixNQUFNTyxHQUFJLFdBQVZQLE1BQU1PLEdBQXNCO1lBRXpDdS9CLE9BRmE5L0IsTUFFQ087YUFGS211QixJQUdLMXdCO0tBQ2xCLFlBQUEsV0FGUXVDLEdBQ1V2QztpQkFFZDs2QkFDQzhHLGtCQUFIcEI7S0FBUyxXQUFUQSxHQUFHb0I7SUFBdUI7SUFOWCxXQUFWOUUsTUFBTTB1QjtHQU1nQjtZQUduQ3FSLFlBQVkvaEMsR0FBR2dDLE1BQU1PO0lBQ3ZCLElBQ2VxL0IsT0FGRDVoQyxNQUVGOEcsTUFGRTlHO0lBR1o7Z0JBSGVnQyxNQUVMOEU7O2FBR04sSUFBVzlHLGNBQU44SCxpQkFDQyxRQUFBLFdBSkc4NUIsTUFHRTVoQzsyQ0FFRDs7a0JBQ0g4RztjQUFLLGVBSFBnQixNQUdFaEI7O2FBRUU7Y0FER0w7Y0FBSGY7Y0FDQSxVQUFBLFdBVlFuRCxHQUtadUYsTUFJSXBDOzZDQUVJOztrQkFDSHM4QjtjQUFRLGVBQVJBLFFBSEV2N0I7O2lCQUlHdzdCLHFCQUFIaDRCO2FBQVksV0FBWkEsU0FBR2c0QixRQUpIeDdCO1lBSWlDO0dBQUU7WUFHbkR5N0I7SUFBdUJsaUMsR0FBR2dDLE1BQU1tZ0MsY0FBY0MsZ0JBQWdCQztJQUNoRSxJQUNlVCxPQUZVNWhDLE1BRWI4RyxNQUZhOUc7SUFHdkI7Z0NBSDBCZ0MsTUFFaEI4RTtxQkFHRnlCO2FBQ0osZ0JBRElBO2NBWUs7ZUFEUys1QixVQVhkLzVCO2VBWUssUUFBQSxXQWpCaUQ4NUIsZ0JBZ0J4Q0M7NENBRUw7O21CQUNIQztlQUFTLDBCQUFUQTs7a0JBQ0tDLG9CQUFIM3dDO2NBQWEsV0FBYkEsa0JBQUcyd0M7O2FBWk47d0JBSExqNkI7Y0FFcUJrNkI7Y0FBUEM7Y0FDVCxVQUFBLFdBTkFkLE1BS2dCYTs7Y0FFWiwwQkFBc0IsV0FUT0wsZ0JBT3hCTTs7a0JBR1JDO2NBQWUsK0JBSFBELFNBR1JDOzthQUVFO2NBREdDO2NBQUhoeEM7Y0FDQSxVQUFBLFdBWmdCdXdDLGNBT1ZPLFNBSU45d0M7NkNBRUk7O2tCQUNIaXhDO2NBQVMsK0JBQVRBLFNBSEVEOztpQkFJR0Usc0JBQUh0c0I7YUFBYSxXQUFiQSx5QkFBR3NzQixTQUpIRjtZQVMyQztHQUFFO1lBR2hFMWdDLFFBaERhRjtJQWlEZixTQWpEcUJPO0tBaURFLFlBQ2I7U0FDRCtDLGNBQUwxVDtLQUFVLFdBQVZBLEdBQUswVDtJQUFrQjtJQW5ERixXQUFWdEQsTUFBTU87R0FtRE07WUFJekJGLEtBQUtDLEdBQ1dOLE1BQU9PO0lBQXpCLElBQW9CcS9CLE9BRGJ0L0IsTUFDTXlnQyxTQUROemdDLE1BQ013RixPQUFBaTdCLFFBQUtseUIsSUFBQTdPO0lBQ2hCO0tBQU0sWUFBQSxXQURZNC9CLE1BQVA5NUI7bUNBRUQsT0FGTStJOztVQUFMbXhCO01BQUFsNkIsT0FBQWs2Qjs7O01BSWMsSUFKZEMsbUJBSUZ2OEIsY0FKT3M5QixNQUlTLFdBSkZ6Z0MsR0FBUHNPLEdBSVBuTDtNQUpFb0MsT0FBQW02QjtNQUFLcHhCLElBQUFteUI7OztHQU84QjtZQUc5Q0MsWUFBWTNnQztJQUFJLE9BWGhCRCxLQVdZQyxlQUE0QmdELEdBQUUxVCxHQUFLLFdBQUxBLEdBQUYwVCxHQUFhO0dBQUM7WUFHdERsRDtRQUFzQncvQixpQkFBSDVoQztJQUVyQixTQUFRb0MsUUFBUXBDLEdBQUU0aEMsTUFBS3JtQztLQUNyQixJQURjdUwsTUFBQTlHO0tBQ2Q7ZUFEcUJ6RTtPQUVILElBSEgrRyxRQUNEd0UsS0FBRTg2QixPQURZLE1BSjVCcUIsWUFJZTNnQztPQUFhLE9BQUE7O01BS3BCLFlBQUEsV0FKUXMvQixNQUFGOTZCO29DQUtGOztXQUVFSCxnQkFBSGpCO09BQVMsV0FBVEEsR0FQTHRELFFBT1F1RSxLQVBFaTdCLE1BT3dCLDRCQVBuQnJtQzs7VUFBUGtMO01BQUFLLE1BQUFMOztJQU9rQztJQUVsRCxPQVRRckUsUUFGYXBDLEdBQUc0aEM7O1lBY3RCMXpCLFlBQVU0TyxXQUFVeGE7SUFBMkIsVUFkL0NGLFFBY29CRTtJQUEyQixPQUFBLDZCQUFyQ3dhO0dBQWdEO1lBRTFEa0csTUFBUTdhLGVBQXVEKzZCLFNBQVFDO0lBQ3pFLEdBRFVoN0IsU0FBU0MsTUFBVEQsUUFBQThhLFNBQVM3YSxjQUFUNmE7SUFDVixZQURnQ3hCLGdCQUFSMkIsUUFBUTNCLGdCQUFSMkI7SUFDeEIsWUFEcURXLGdCQUFQNUcsT0FBTzRHLGdCQUFQNUc7SUFDOUM7S0F0RnFCaW1CO29CQXFGeUJqbUI7O2FBQXBDOEY7O1lBSUYxbkI7WUFBSyxPQUo0RDRuQyxTQUlqRTVuQzs7MEJBQUFBLEdBQTRDLDRCQUE1Q0EsR0FKRTBuQjtXQUlxRDs7WUFDekMxbkI7WUFBSyxPQUFMQSxJQUxtRDRuQzs7MEJBS25ENW5DLEdBQTRDLDRCQUE1Q0EsR0FMWjBuQjtXQUttRTs7YUFMbkVBOztZQU9GMW5CO1lBQUssT0FQNEQ0bkMsVUFPakU1bkM7OzBCQUFBQSxHQUE2Qyw0QkFBN0NBLEdBUEUwbkI7V0FPc0Q7O1lBQzFDMW5CO1lBQUssT0FBTEEsS0FSbUQ0bkM7OzBCQVFuRDVuQyxHQUE2Qyw0QkFBN0NBLEdBUlowbkI7V0FRb0U7S0E3Ri9EamhCO29CQXFGU29oQjtVQUF5QzhmO1VBYS9DLDRCQWIrQ0EsU0FBdkRqZ0I7SUFyRmUsV0FBVmpoQixNQUFNb2hDO0dBb0dJO1lBR3ZCeEssUUF2R2F5SztJQXdHZixTQXhHcUI5Z0MsRUF3R1k4Z0M7S0FDL0I7eUJBRCtCQTs7O1dBQUFBO3lEQUFBQSxVQUFBQTtNQUNiekI7TUFBSDVoQztNQUNULFVBQUEsV0FEWTRoQyxNQUFINWhDO3FDQUVMOztNQUdHLElBRk44RyxrQkFFRStKLFFBRkYvSixLQUhXODZCO01BSWhCLFdBQ08vd0I7O0tBS0ssSUFIRnBLLGtCQUFIN1UsZ0JBR0NveEMsVUFIRXY4QixLQVBNbTdCO0tBUWhCLFdBRE9od0MsR0FHQ294QztJQUNJO0lBcEhTLFdBQVZLLFFBQU05Z0M7R0FvSEo7Z0JBR1hELEdBQUdDO0lBQ1QsSUFDa0JxL0IsT0FGWnQvQixNQUVNd0YsT0FGTnhGO0lBR0o7WUFEVXdGO3FCQUdGQTthQUNFLFlBQUEsV0FKTTg1QixNQUdSOTVCOzJDQUVNO29DQUNIOUgsY0FBSyxXQUFMQTtpQkFDSzhHLGdCQUFIcEI7YUFBUyxXQUFPLFdBVHRCbkQsR0FTTW1ELElBQUdvQjtZQUFvQjtHQUFFO1lBR3RDbEUsS0FBS04sR0FBR0M7SUFDVixJQUNlcS9CLE9BRlJ0L0IsTUFFS3RDLElBRkxzQztJQUdMO21CQURVdEM7O2FBR04sSUFBUUEsY0FBSHpFLGNBQ0MsUUFBQSxXQUpHcW1DLE1BR0Q1aEM7MkNBRUU7b0NBQ0g4RyxnQkFBSyxlQUhQdkwsR0FHRXVMO2FBQ3lCO2NBQXBCTDtjQUFIZjtjQUF1QixVQUFDLDRCQUo1Qm5LLE9BSU9rTDthQUFNLFdBQU8sV0FUckJsRSxHQUtDaEgsR0FJSW1LO1lBQWtDO0dBQUU7WUFHakQwa0IsWUFBWTluQixHQUFHTixNQUFNTztJQUN2QixPQXZJRXcvQjthQXNJWXovQjthQUFHTjtzQkFDVzhZLEtBQUlscEI7Y0FDOUI7ZUFBYSxRQUFBLFdBRlEyUSxHQUNLdVksS0FBSWxwQjtlQUNyQittQjtlQUFMNlQ7Y0FDSixXQURTN1QsS0FBTDZUO2FBQ1U7R0FBQztZQUdmVixhQUFheHBCLEdBQUdOLE1BQU1PO0lBQ3hCLE9BN0lFdy9CO2FBNElhei9CO29CQUFHTjs2QkFDNkJwUTtjQUFkO2VBQVNrcEI7ZUFBSHZmO2VBQ3hCLFFBQUEsV0FGU2dILEdBQ2VoSCxHQUFHdWYsS0FBS2xwQjtlQUNwQyttQjtlQUFMNlQ7Y0FDSixXQURTN1QsU0FDRSw0QkFGMEJwZCxPQUNqQ2l4QjthQUNvQjtHQUFBO1lBR3hCdEcsT0FBTzVqQixHQUFHQztJQUNaLElBQ2tCcS9CLE9BRlR0L0IsTUFFR3dGLE9BRkh4RjtJQUdQO1lBRFV3RjtxQkFHRkE7YUFDRSxZQUFBLFdBSk04NUIsTUFHUjk1QjsyQ0FFTTtvQ0FDSDlILGNBQUssV0FBTEE7aUJBQ0UwRixjQUFHb0I7YUFBUSxHQUFBLFdBVGR2RSxHQVNHbUQsSUFBa0IsV0FBbEJBLEdBQUdvQjtpQkFDQUw7YUFBTSxXQUFOQTtZQUFZO0dBQUU7WUFHOUJ3bEIsUUFBUTNwQixHQUFHQztJQUNiO0lBQUE7YUFkRTJqQjtlQXhCQXRqQixLQXFDUU4sWUFDeUIvRyxHQUFFeUUsR0FBSyxXQUFQekUsR0FBRXlFLEdBQVM7O2dCQUFNLElBQVNBLGNBQUh6RTtnQkFBUyxPQUFBLFdBRHREZ0gsR0FDNkNoSCxHQUFHeUU7ZUFBWTs7R0FBQztZQUd4RW9FLE9BQU85QjtJQUNULElBQWlCcy9CLE9BRFJ0L0IsTUFDTXdGLE9BRE54RixNQUNJL0csT0FBRXlFLElBQUE4SDtJQUNiO0tBQU0sWUFBQSxXQURTODVCLE1BQUY1aEM7bUNBRUgsT0FGQ3pFOztVQUFFdUw7TUFBQTlHLElBQUE4Rzs7O01BSVUsSUFKVkwsZ0JBQUZXLE1BSVksNEJBSlo3TDtNQUFBQSxJQUFBNkw7TUFBRXBILElBQUF5Rzs7O0dBTzRCO1lBS3pDOFUsU0FBU2paO0lBQ1g7S0FIc0Q7T0FoSXBERDtTQWtJU0M7O3lCQUZ1RDFRO1VBQVosSUFBUzJKLGNBQUgrSjtVQUFXLGVBQUwxVCxHQUFOMFQsSUFBbUIsNEJBQWhCL0o7U0FBc0I7S0FHOUVrRztLQUFINkQ7SUFDSixLQURJQSxHQUVJO0lBRUU7S0FDT3lwQixNQUxienBCO0tBR0YxVCxJQUhFMFQ7S0FJRUksSUFBSSwyQkFKSGpFLEtBR0w3UDtLQUVhcytCLE1BT1IsNEJBWkF6dUI7S0FLUWxHLElBQUEyMEI7S0FBRWdELE1BQUFuRTtJQUNiO1VBRGFtRTtnQkFBRjMzQixHQU9iLE9BUkltSztNQUdNLE1BQUE7O1NBRks0OUIsTUFBQXBRLFFBR1h2YSxNQUhXdWE7S0FJWCx5QkFMQXh0QixHQUNTbkssT0FBQUEsS0FHVG9kO0tBRUssSUFMSXZSLE1BS0osNEJBTEk3TDtLQUFBQSxJQUFBNkw7S0FBRThyQixNQUFBb1E7O0dBUWQ7WUFHRGhvQixLQUFLaFosR0FDYUM7SUFBcEIsSUFBZXEvQixPQURSdC9CLE1BQ013RixPQUROeEYsTUFDTXRDLElBQUE4SDtJQUNYO0tBQU0sWUFBQSxXQURPODVCLE1BQUY1aEM7bUNBRUQ7O1VBRkM4Rzs7VUFHRnBCO01BQVcsR0FBQSxXQUhGbkQsR0FHVG1ELElBQWtCLFdBQWxCQTtVQUhFb0I7O0tBQUE5RyxJQUFBOEc7O0dBTzhCO1lBR3pDdVUsU0FBUy9ZLEdBQ1NDO0lBQXBCLElBQWVxL0IsT0FESnQvQixNQUNFd0YsT0FERnhGLE1BQ0V0QyxJQUFBOEg7SUFDWDtLQUFNLFlBQUEsV0FETzg1QixNQUFGNWhDO21DQUVEOztVQUZDOEc7TUFBQTlHLElBQUE4Rzs7O01BSUYsSUFKRUwsZ0JBR0ZmLGNBR0o2OUIsU0FGSSxXQUpTaGhDLEdBR1RtRDtTQUdKNjlCLFFBQVUsT0FBVkE7TUFOTXZqQyxJQUFBeUc7OztHQVU4QjtZQUl6Q2lnQixVQUFVcGtCLEdBQ1FDO0lBQXBCLElBQWVxL0IsT0FESHQvQixNQUNDd0YsT0FERHhGLE1BQ0N0QyxJQUFBOEgsTUFBU3ZNO0lBQ3BCO0tBQU0sWUFBQSxXQURPcW1DLE1BQUY1aEM7bUNBRUQ7O1VBRkM4RztNQUFBOUcsSUFBQThHOzs7TUFJRixJQUpFTCxnQkFHRmYsY0FHSjY5QixTQUZJLFdBSlNoaEMsR0FBRWhILEdBR1htSztTQUdKNjlCLFFBQVUsT0FBVkE7TUFEc0IsSUFMUG44QixNQUtPLDRCQUxQN0w7TUFBVHlFLElBQUF5RztNQUFTbEwsSUFBQTZMOzs7R0FVdUI7WUFHM0N2QyxRQUFRdkMsR0FDVUM7SUFBcEIsSUFBZXEvQixPQURMdC9CLE1BQ0d3RixPQURIeEYsTUFDR3RDLElBQUE4SDtJQUNYO0tBQU0sWUFBQSxXQURPODVCLE1BQUY1aEM7bUNBRUQ7O1VBRkM4Rzs7VUFHRnBCO01BQWUsS0FBQSxXQUhObkQsR0FHVG1ELElBQXdCO1VBSHRCb0I7O0tBQUE5RyxJQUFBOEc7O0dBTzhCO1lBR3pDK2YsU0FBU3ZrQixHQUNTQztJQUFwQixJQUFlcS9CLE9BREp0L0IsTUFDRXdGLE9BREZ4RixNQUNFdEMsSUFBQThILE1BQVN2TTtJQUNwQjtLQUFNLFlBQUEsV0FET3FtQyxNQUFGNWhDO21DQUVEOztVQUZDOEc7TUFBQTlHLElBQUE4Rzs7O1VBR0ZwQjtNQUFlLEtBQUEsV0FITm5ELEdBQUVoSCxHQUdYbUssSUFBMEI7TUFDSCxJQUpyQmUsZ0JBQVNXLE1BSVksNEJBSlo3TDtNQUFUeUUsSUFBQXlHO01BQVNsTCxJQUFBNkw7OztHQVF1QjtZQUczQzVDLE9BQU9sQyxHQUNXQztJQUFwQixJQUFlcS9CLE9BRE50L0IsTUFDSXdGLE9BREp4RixNQUNJdEMsSUFBQThIO0lBQ1g7S0FBTSxZQUFBLFdBRE84NUIsTUFBRjVoQzttQ0FFRDs7VUFGQzhHO2NBR0ZwQixjQUFXLEdBQUEsV0FIRm5ELEdBR1RtRCxJQUFrQixjQUhoQm9COztLQUFBOUcsSUFBQThHOztHQU84QjtZQUd6Q2dnQixRQUFReGtCLEdBQ1VDO0lBQXBCLElBQWVxL0IsT0FETHQvQixNQUNHd0YsT0FESHhGLE1BQ0d0QyxJQUFBOEgsTUFBU3ZNO0lBQ3BCO0tBQU0sWUFBQSxXQURPcW1DLE1BQUY1aEM7bUNBRUQ7O1VBRkM4RztNQUFBOUcsSUFBQThHOzs7VUFHRnBCO01BQVcsR0FBQSxXQUhGbkQsR0FBRWhILEdBR1htSyxJQUFvQjtNQUNHLElBSnJCZSxnQkFBU1csTUFJWSw0QkFKWjdMO01BQVR5RSxJQUFBeUc7TUFBU2xMLElBQUE2TDs7O0dBUXVCO1lBRzNDM0UsS0FBS0gsR0FDZ0JDO0lBQXZCLElBQWtCcS9CLE9BRFh0L0IsTUFDTXlnQyxTQUROemdDLE1BQ013RixPQUFBaTdCO0lBQ1g7S0FBTSxZQUFBLFdBRFVuQixNQUFMOTVCO21DQUVEOztVQUZDazZCO01BQUFsNkIsT0FBQWs2Qjs7O1VBQUFDLG1CQUlGdjhCO01BQ1AsV0FMbUJuRCxHQUlabUQ7TUFKRW9DLE9BQUFtNkI7OztHQVM4QjtZQUd6QzVyQixTQUFTL1Q7SUFDWCxJQUFlcy9CLE9BREp0L0IsTUFDRXdGLE9BREZ4RixNQUNFdEMsSUFBQThIO0lBQ1g7S0FBTSxZQUFBLFdBRE84NUIsTUFBRjVoQzttQ0FFRDt3QkFFRztTQUpGOEc7S0FBQTlHLElBQUE4Rzs7R0FPNEI7WUFHdkM2VixJQUFJcmEsR0FDY29ELEdBRFQ5TTtJQUNYLElBQWVncEMsT0FEVHQvQixNQUNPd0YsT0FEUHhGLE1BQ090QyxJQUFBOEg7SUFDWDtLQUFNLFlBQUEsV0FETzg1QixNQUFGNWhDO21DQUVEOztVQUZDOEc7O1VBR0ZuQjtNQUFXLEdBQUEsV0FKWC9NLE9BQ1M4TSxHQUdUQyxJQUF3QjtVQUh0Qm1COztLQUFBOUcsSUFBQThHOztHQU84QjtHQUdqQyxJQUFSMDhCLCtCQUFnQyxTQUFJO1lBNkJoQ3p6QixLQTNCQ3pOLEdBQUdDO2FBclVXbXVCO0tBdVVoQjtNQUN3QmpyQjs7TUFBUG04QjtNQUFOOTVCO01BQ0gsVUFBQSxXQURTODVCLE1BQU45NUI7O01BS0c7T0FEUzI3QixTQUpDaCtCO09BSVB1OEIsU0FKT3Y4QjtPQUtWLFVBQUEsV0FEU2crQixRQUFOekI7c0NBRUM7O1dBQ0hoaUM7T0FBSyxlQVp2QndqQyxXQVlrQnhqQyxHQUhReWpDOztVQUlIMzhCLGtCQUFIcEI7TUFBUyxlQUFNLFdBWDNCbkQsR0FXWW1ELFFBQUdvQixLQUpHMjhCOzs7VUFLZGg5QjtNQUFLLG1CQUFMQSxLQVRRbTdCLE9BQU9uOEI7O1NBVVZrQixrQkFBSHNEO0tBQVMsV0FBVEEsYUFBR3RELEtBVkdpN0IsT0FBT244QjtJQVVtQztJQUN4RCxJQW5WT3pELFdBbVVid2hDLE9BRUtsaEM7SUFyVWtCLFdBQVZOLE1BQU0wdUI7R0FtVkg7WUFjWmpoQixTQVhHN2Q7SUFDVCxTQXZWcUIyUTtLQXVWUyxZQUNsQjtTQUNIM1E7S0FBSyxXQUFMQTtJQUFxQjtJQUZaLElBdlZIb1EsV0FzVk5wUTtJQXRWZ0IsV0FBVm9RLE1BQU1PO0dBeVZTO0dBTWxCO0lBQU5JOzRDQUNBb04sTUFDQU4sVUFGQTlNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQUtKdWhCLElBQUlsa0IsR0FJUzhVO0lBSGYsT0FHZUEsR0FGVjtRQUVjOHNCLE9BSmI1aEMsTUFJVzBqQyxNQUpYMWpDLE1BSVN6RSxJQUFBdVosR0FBRWhPLE1BQUE0OEI7SUFDYjtLQUFNLFlBQUEsV0FEUzlCLE1BQUY5NkI7bUNBRUg7O1VBRkdMO01BQUFLLE1BQUFMOzs7VUFBQUUsZ0JBSUpqQjtNQUFZLEdBQUEsNkJBSlZuSyxPQUk4QixXQUFoQ21LO01BQWlELElBSi9DMEIsTUFJK0MsNEJBSi9DN0w7TUFBQUEsSUFBQTZMO01BQUVOLE1BQUFIOzs7R0FPdUI7WUFHdEN3ZCxRQUFRbmtCLEdBQUU4VTtJQUNaLE9BRFlBLEdBRVAsT0FBQTtJQUVHLFlBbEJOb1AsSUFjUWxrQixHQUFFOFU7Z0JBS0EsT0FBQTtRQUNIbGpCO0lBQUssT0FBTEE7R0FBTztZQVVaK0csUUFHRWdmLE9BQVFDLE9BQVErckIsT0FBUUM7SUFDNUIsR0FBRyxvQ0FEaUJELE9BQVFDLFFBRXZCO1dBRmVEOztXQUtYRSxRQUxXRjtnQkFBUUMsVUFNWDtXQURPRSxRQUxJRjtPQUtRLE9BQUEsV0FMaENqc0IsT0FLS2tzQixPQUFlQzs7V0FHZEMsUUFSVUo7Y0FBUUM7OztjQVFGSSxRQVJFSixVQVFVLE9BQUEsV0FSMUJoc0IsT0FRRm1zQixPQUFnQkM7a0JBQ1I7Ozs7V0FFRUMsUUFYQU4sVUFXVk8sUUFYVVA7Y0FBUUM7OztVQVVWOztVQUVQO1dBRG9DTyxRQVhuQlA7V0FXU1EsUUFYVFI7V0FjckI5dUIsSUFGSSxXQVpQNkMsT0FXTXVzQixPQUEyQkU7dUJBRzlCdHZCLElBREssV0FiQThDLE9BV1Fxc0IsT0FBMkJFLFNBR3hDcnZCOzs7SUFQVTtHQU9GO1lBR2I5TSxZQVFFeVEsYUFBYUMsYUFBYTlNLEtBQUlDO0lBQ2hDLE9BRGdDQTs7T0FHcEIsSUFETEMsS0FGeUJELFFBSTFCRSxRQURNLHlCQUhnQkg7T0FLMUIsT0FBQSxXQUxBNk0sYUFJSTFNLE9BRkNEOztPQUtLLElBREpFLE9BTndCSCxRQVExQkksUUFETSx5QkFQZ0JMO09BUzFCLE9BQUEsV0FUYThNLGFBUVR6TSxPQUZFRDs7T0FLSTtRQURDa2lCLEtBVm1CcmlCO1FBVXhCdzRCLE9BVndCeDRCO1FBYXhCb0osUUFGSSx5QkFYZ0JySjtRQVl0QjA0QixRQUVGLFdBZEY3ckIsYUFhTXhELE9BSEFvdkI7T0FNTixPQUFBLFdBaEJhM3JCLGFBWVQ0ckIsT0FGT3BXOztHQU1TO0dBY3RCLFNBWEFsYixVQVdJdXhCLFVBQVlDLFVBOENaQztJQTlDSjs7Y0E4Q0lBO2dCQUFBQTs7Ozs7Ozs7OztRQUxBLE9BQUE7OENBMUNBakQsa0JBK0NBaUQ7O09BUEEsT0FBQTs2Q0F4Q0FqRCxrQkErQ0FpRDs7TUFIQSxPQUFBOzRDQTVDQWpELGtCQStDQWlEOztlQUFBQTs7TUFDQSxPQUFBOzRDQWhEQWpELGtCQStDQWlEOzs7TUFEQSxPQUFBOzRDQTlDQWpELGtCQStDQWlEO1NBcEJzQkM7O1FBQUFBOztTQUFBQTtVQUFBQTtXQUFBQTtXQUFBQTtXQUFBQTs7V0FadUNDO1VBQUFBLG1CQUFBQTtRQUl6QztTQURmQyxXQUh3REQ7U0FJdERFLFdBQWEsV0FsQlJMLFVBaUJQSTtRQUVGLFdBRElDOztPQUdKLE9BQUE7O2dCQXRCSHJEO2dCQTJCc0JrRDtnQkFvQnRCRDs7VUE1QzJESztTQUFBQSxtQkFBQUE7T0FJdkM7UUFEZkMsV0FIc0REO1FBSXBENU4sV0FBYSxXQU5wQnFOLFVBS0tRO09BRUYsV0FESTdOOztNQUdKLE9BQUE7O2VBVkhzSztlQTJCc0JrRDtlQW9CdEJEOztTQXBCMkRPO0tBRTNELEdBRjJEQTtnQkFBQUE7O09BSXZDO1FBREhDO1FBQVpDLFdBSHNERjtRQUlwREcsV0FBYSxXQTlCcEJaLFVBNkJLVztRQUVFRSxXQUFhLFdBL0JSWixVQTZCS1M7T0FHZCxXQUZJRSxVQUNBQzs7O0tBR0osT0FBQTs7Y0FuQ0g1RDtjQTJCc0JrRDtjQW9CdEJEOztJQUdBLE9BQUEsd0NBbERBakQsa0JBK0NBaUQ7R0FHc0U7WUFHMUVwVCxZQVVJZ1UsVUFBWUM7SUFIbEI7O09BS3VCLElBRFpDLHFCQUNEQyxXQUFhLFdBRmpCSCxVQUNLRTtPQUVMLHdCQURJQzs7T0FHYSxJQURYQyxxQkFDRkMsV0FBYSxXQUxMSixVQUlORztPQUVOLHdCQURJQzs7T0FHYTtRQURDQztRQUFaQztRQUNGQyxXQUFhLFdBUmpCUixVQU9NTztRQUVGRSxXQUFhLFdBVExSLFVBT01LO09BR2xCLHdCQUZJRSxjQUNBQzs7R0FDb0U7WUFHM0U1NUIsZUFLQ3VMLGdCQUFpQkM7SUFDbkI7Ozs7d0NBREVEOzswQ0FBaUJDOzs7OzswQkFBakJELG9CQUFpQkM7O0dBMkJsQjtHQTVLZ0M7SUFBQTtVQU9qQy9lLFNBb0JBcVAsYUEyQkFnTCxXQStEQXFlLGFBdUJDbmxCOzs7Ozs7Ozs7WUFzQ0g2NUIsa0NBQXFFcHRDO1FBQVRxdEMsZ0JBQUpDLGFBQW5CQyxrQkFBSkM7YUFHL0J2RTtLQUFPLElBR1B1RTtlQUFBQTs7b0NBT2M7O1dBRUVDLGlCQUFIemdDO09BQVUsZUFBVkEsZUFBR3lnQzs7OztlQVRoQkQ7V0FGU0UsaUJBQUpDLE9BRUxIO09BRmUsZUFBTSxXQUpjRCxPQUk5QkksT0FBSUQ7O1VBRWVFLGlCQUFiQyxPQUFYTCxPQUFRemdDLElBQVJ5Z0M7Z0JBQXdCSSxtQkFRRCxlQVJmN2dDLFlBQUc4Z0M7ZUFBYUQ7T0FDUDtRQURrQkUsT0FBWEY7UUFBUXI4QixNQUFScThCO1FBQ3BCRyxhQUFhLFdBUGtEL3RDLFNBTTNEK00sR0FBd0J3RTtPQUVoQyxZQURJdzhCOztxQkFBQUE7MkJBREloaEMsR0FBd0J3RSxjQUFyQnM4QixXQUF3QkM7MkJBQUh2OEIsVUFBaENpOEIsUUFBbUNNO3lCQUEzQi9nQyxZQUFHOGdDLE9BQWFEOzs7U0FEZk47S0FBTSxlQUNmRSxJQUR5QixXQUxpQ0gsT0FLakRDO0lBVThDO0lBRTNELG1CQWpCbUNFLFNBQXVCRixNQUd0RHJFOztZQWlCRitFLHlCQUF5QlIsSUFBR0YsSUFBSXR0QztJQUNsQyxPQUE4Qzs7YUFyQjVDb3RDLHNCQW9CeUJJLElBQUdGLElBQUl0dEM7NkJBQ1ksSUFDckMvRyxjQUE2QixPQUE3QkEsRUFBK0I7R0FBQTtZQVd0Q2cxQyx5QkFBNERqdUM7UUFBVHF0QyxnQkFBSkMsYUFBbkJDLGtCQUFKQzthQUN0QnZFO0tBQU8sSUFHUHVFO2VBQUFBOztvQ0FHYzs7V0FFRUMsaUJBQUh6Z0M7T0FBVSxXQUFWQSxjQUFHeWdDOzs7O2VBTGhCRDtXQUZTRSxpQkFBSkMsT0FFTEg7T0FGZSxlQUFNLFdBRktELE9BRXJCSSxPQUFJRDs7VUFFZUUsaUJBQWJDLE9BQVhMLE9BQVF6Z0MsSUFBUnlnQztnQkFBd0JJLG1CQUlELFdBSmY3Z0MsV0FBRzhnQztlQUFhRDtPQUNQO1FBRGtCRSxPQUFYRjtRQUFRcjhCLE1BQVJxOEI7UUFDcEJHLGFBQWEsV0FMeUMvdEMsU0FJbEQrTSxHQUF3QndFO09BRWhDLFdBREl3OEI7cUJBRDRCeDhCLFNBQWhDaThCLFFBQW1DTTtxQkFBM0IvZ0MsV0FBRzhnQyxPQUFhRDs7O1NBRGZOO0tBQU0sZUFDZkUsSUFEeUIsV0FId0JILE9BR3hDQztJQU13QztJQUVyRCxtQkFYMEJFLFNBQXVCRixNQUM3Q3JFOztZQWFGNWQsR0FBR2hrQjtJQUNMLElBQWU0aEMsT0FEVjVoQyxNQUNRMkcsTUFEUjNHLE1BQ1E4RyxNQUFBSDtJQUNYO0tBQU0sWUFBQSxXQURPaTdCLE1BQUY5NkI7bUNBRUQ7NEJBRURwQixjQUFTLFdBQVRBO1NBSkVlO0tBQUFLLE1BQUFMOztHQU9zQjtZQUdqQ3RDLE9BQU9uRTtJQUNILFlBWkpna0IsR0FXT2hrQjtnQkFFQyxPQUFBO1FBQ0gwRjtJQUFLLE9BQUxBO0dBQU07WUFHWHVlLEdBQUdqa0I7SUFDTCxJQU9lNGhDLE9BUlY1aEMsTUFDUTJHLE1BRFIzRyxNQUNROEcsTUFBQUg7SUFDWDtLQUFNLFlBQUEsV0FNT2k3QixNQVBGOTZCOzs7OzZCQUFBTCxnQkFBQUssTUFBQUw7VUFJQ2YsNEJBQUFBOzttQkFLRDtTQUNIZytCO0tBQUssZUFBTEEsS0FISzlCOztHQUcwQjtZQUd2Q2lGLGVBQWU3bUM7SUFDWCxZQWZKaWtCLEdBY2Vqa0I7Z0JBRVAsT0FBQTtRQUNIOEc7SUFBSyxPQUFMQTtHQUFNO1lBR1hnZ0MsY0FBY2xGLE1BQUs1aEM7SUFDZixZQUFBLFdBRFU0aEMsTUFBSzVoQztrQ0FFWDsyQkFDSDhHLGdCQUFLLDBCQUFMQTtRQUNLTCxnQkFBSGY7SUFBUyxXQUFUQSxrQkFBR2U7R0FBNEI7WUFHdENtN0IsS0FBSzVoQztJQUNQLElBQWU0aEMsT0FEUjVoQyxNQUNNMGpDLE1BRE4xakMsTUFDTThHLE1BQUE0OEI7SUFDWDtLQUFNLFlBQUEsV0FETzlCLE1BQUY5NkI7bUNBRUQ7O1VBRUVILGdCQUFIakI7TUFBUyxlQUFUQSxPQUFHaUIsS0FKQ2k3Qjs7U0FBRm43QjtLQUFBSyxNQUFBTDs7R0FPc0I7WUFHakMycEIsV0FBV3B3QjtJQUNiLElBQ2U0aEMsT0FGRjVoQyxNQUVEOEcsTUFGQzlHO0lBR1g7WUFEVThHO3FCQUdGOUc7YUFDRSxZQUFBLFdBSkc0aEMsTUFHTDVoQzsyQ0FFTTtvQ0FDSDhHLGdCQUFLLFdBQUxBOzs7a0JBRVVMLGdCQUFIZjtjQUFTLFdBQVRBLEdBQUdlOztpQkFERkU7YUFBTSxXQUFOQTtZQUNvQjtHQUFFO1lBR3pDcXBCLFdBQVdod0IsR0FBR3VDLEdBQUksT0FibEI2dEIsV0FhNkIsa0JBQWxCcHdCLEdBQUd1QyxJQUF5QjtZQUN2QzR0QixZQUFZbndCLEdBQUd1QztJQUFJLE9BRG5CeXRCO2FBN2hCQXB0QixLQThoQlk1QyxZQUFrQ3pFLEdBQUV5RSxHQUFLLFdBQVB6RSxHQUFFeUUsR0FBUzs7Y0FBTSxJQUFTQSxjQUFIekU7Y0FBUyxPQUFBLFdBQS9EZ0gsR0FBc0RoSCxHQUFHeUU7YUFBWTtHQUFBO1lBRXBGNnlCLFFBQVE3eUIsR0FDSzhVO0lBQWYsSUFBdUI4c0IsT0FEYjVoQyxNQUNHMGpDLE1BREgxakMsTUFDRzhHLE1BQUE0OEIsS0FBRW5vQyxJQUFBdVosR0FBRTRPO0lBQ2Y7YUFEYW5vQixHQUVSLFdBQUEsMkJBRlVtb0IsWUFBSjVjLEtBQVU4NkI7S0FJYixZQUFBLFdBSmFBLE1BQVY5NkI7O01BS0MsV0FBQSwyQkFMRzRjLFFBaldmOGY7O1VBaVdXLzhCO01BQUFLLE1BQUFMOzs7TUFPd0I7T0FQeEJFO09BT0FqQjtPQVBJbWUsY0FPSm5lLEdBUElnZTtPQUFGdGMsTUFPYyw0QkFQZDdMO01BQUZ1TCxNQUFBSDtNQUFFcEwsSUFBQTZMO01BQUVzYyxRQUFBRzs7O0dBVXVCO1lBR3RDa2pCLFdBanJCYS9rQyxNQWlyQkE4UztJQUNmLFFBRGVBLEdBRVYsT0FBQTthQW5yQmdCdlMsRUFxckJTRDtLQUMxQixJQUFNLFFBbkJSdXdCLFFBa0I0QnZ3QixHQUpmd1MsSUFPVDFLO1VBQUFBLElBRGM7U0FDRTVCO0tBQUssV0FBckI0QixJQUFnQjVCO0lBQWtCO0lBeHJCZixXQUFWeEcsTUFBTU87R0F3ckJvQjtZQUd2Q2drQixNQUFNdm1CLEdBQUd1QztJQUFJLE9BamZiK1k7YUF2RUExWSxLQXdqQk01QyxZQUE0QnpFLEdBQUV5RSxHQUFLLFdBQVB6RSxHQUFFeUUsR0FBUzs7Y0FBTSxJQUFTQSxjQUFIekU7Y0FBUyxPQUFBLFdBQXpEZ0gsR0FBZ0RoSCxHQUFHeUU7YUFBWTtHQUFBO1lBRXhFc21CLFNBQVN0bUIsR0FBR3VDO0lBQ1IsWUFwZkorWSxLQW1mU3RiLEdBQUd1QztnQkFFSixPQUFBO1FBQ0gzUTtJQUFLLE9BQUxBO0dBQU07WUFHWCtQLE9BQU93a0MsSUFBR0Y7SUFDWixJQUNzQ0QsUUFGMUJDLE9BRXNCRyxPQUZ0QkgsT0FFSUMsUUFGUEMsT0FFR0csT0FGSEg7SUFHUDsyQkFEVUc7O2FBR047Y0FFUyxJQURLSCxlQUNMLFFBQUEsV0FMQ0QsT0FJSUM7NENBRUQsMkJBTmVDOzttQkFPbEJFO2VBQU0sMEJBQU5BOztrQkFDS0UsaUJBQUg5Z0M7Y0FBVSxXQUFWQSxrQkFBRzhnQzs7YUFFTixJQURNUCxlQUNOLFVBQUEsV0FWdUJELE9BU2pCQzs2Q0FFRjs7a0JBQ0hJO2NBQU0sMkJBQU5BOztpQkFDS0UsbUJBQUh0OEI7YUFBVSxXQUFWQSxxQkFBR3M4QjtZQUFrQztHQUFFO1lBR3ZEclosV0FBV2x0QixHQUFHdUMsR0FBSSxPQUFBLG1CQUFQdkMsR0FBR3VDLEdBQWE7WUFDM0JWLE9BRFc3QjtJQUNBLFNBREd1QyxPQUNIO0lBRE8sT0FBQSxtQkFBUHZDLEdBQUd1QztHQUNrQjtZQUNoQzRxQixZQUFZbnRCLEdBQUd1QzthQUZEbXVCO0tBRWlELElBQVMxd0IsY0FBSHpFO0tBQVMsT0FBQSxXQUEvRGdILEdBQXNEaEgsR0FBR3lFO0lBQVk7SUFBdEQsSUFGbkI4RyxNQWxsQlhsRSxLQW9sQlk1QyxZQUFrQ3pFLEdBQUV5RSxHQUFLLFdBQVB6RSxHQUFFeUUsR0FBUztJQUZ2QyxPQUFBLG1CQUFQOEcsS0FBRzRwQjtHQUVzRTtZQUVwRjlFO1FBQTBDb2EsZ0JBQUpDLGFBQW5CQyxrQkFBSkM7YUFDYnZFO0tBQU87Ozs2QkFDRzBFLGVBQUg1Z0M7OzthQUdFMGdDO1NBQU0sb0JBQVUsV0FMZUosT0FLL0JJOztZQUhnQkMsaUJBQUgxZ0M7UUFBVSxlQUF6QkQsR0FBZUMsWUFBWjJnQyxXQUFlRDs7OztXQUVoQkosZUFBSkU7T0FBVSxlQUFNLFdBSkpELE9BSVpDLEtBQUlGOzs7S0FEWTtJQUVhO0lBRXRDLG1CQVBpQkUsU0FBdUJGLE1BQ3BDckU7O1lBU0ZvRjtRQUErQ2hCLGdCQUFKQyxhQUFuQkMsa0JBQUpDO2FBQ2xCdkU7S0FBTyxJQUlQdUU7ZUFBQUE7O29DQUZjOztXQUdFQyxpQkFBSHpnQztPQUFVLDBCQUFWQSxXQUFrQyxXQU5GcWdDLE9BTTdCSTs7OztlQURoQkQ7V0FEU0UsaUJBQUpDLE9BQ0xIO09BRGUsZUFBTSxXQUpDRCxPQUlqQkksT0FBSUQ7OzhCQUZDRyxPQUdWTCxPQUhPemdDLElBR1B5Z0M7O09BRXVCLDBCQUxoQnpnQyxRQUtpQyxXQVBsQndnQyxPQUVaTTs7V0FBZUQsbUJBQUhyOEI7T0FBVSw4QkFBekJ4RSxHQUFld0UsZUFBWnM4QixXQUFlRDs7O1NBR2hCTjtLQUFNLGVBQWZFLElBQXlCLFdBTG9CSCxPQUtwQ0M7SUFFK0M7SUFFNUQsbUJBVHNCRSxTQUF1QkYsTUFDekNyRTs7WUFXRnFGLHNCQUF3Q0M7UUFDdEJ0RixpQkFBTDk1QixpQkFBRnZNLE9BQUV5bUMsU0FBQWw2QjtJQUNiO1FBRndDby9CLFVBQzdCM3JDLEdBRU47S0FFRyxZQUFBLFdBSlVxbUMsTUFBTEk7bUNBS0Qsa0JBTER6bUM7O1VBQUUwbUM7TUFBQUQsU0FBQUM7OztNQU9lLElBUGZjLG1CQUFGMzdCLE1BT2lCLDRCQVBqQjdMO01BQUFBLElBQUE2TDtNQUFFNDZCLFNBQUFlOzs7O1lBWWJvRSxxQkFBdUJoL0IsS0FBV3JXLEtBQUl3UTtJQUN4QyxHQUR5QjZGLFNBQU1DLE1BQU5ELFFBQUFwVyxNQUFNcVcsY0FBTnJXO0lBYXpCLEdBYm9DRDtLQWdCM0IsSUFERitGLFFBZjZCL0YsUUFnQjNCLFVBN0JQbTFDLGVBYXNDM2tDLEdBZWpDeks7aUVBRUU0SixxQkFqQmdCMVAsT0FpQmhCMFAsS0FBdUI7S0FDdEI7O1FBakIyQm1nQyxPQURHdC9CLE1BRXpCdEMsSUFGeUJzQyxNQUV6QndFLE1BQUE5RyxHQUFFOGE7SUFDYjtRQUhxQi9vQixPQUVSK29CLEtBRVI7S0FFRyxZQUFBLFdBTHlCOG1CLE1BQ3RCOTZCO21DQUtDOztVQUxETDtNQUFBSyxNQUFBTDs7O01BT2dCLElBUGhCRSxnQkFBRTZsQixRQU9jLDRCQVBkMVI7TUFBRmhVLE1BQUFIO01BQUVtVSxNQUFBMFI7OztHQWdCRDtZQUdkOXBCLE1BQU0xQyxHQUFHdUM7SUFBSSxPQWpmYkU7YUE3SkFHLEtBOG9CTTVDLFlBQTRCekUsR0FBRXlFLEdBQUssV0FBUHpFLEdBQUV5RSxHQUFTOztjQUFNLElBQVNBLGNBQUh6RTtjQUFTLE9BQUEsV0FBekRnSCxHQUFnRGhILEdBQUd5RTthQUFZO0dBQUE7WUFFeEVnc0IsTUFBTWhzQixHQUFHZ0MsTUFBTU87SUFDakIsT0E3dEJFRjthQTRFQU8sS0FncEJNNUMsWUFDbUJ6RSxHQUFFeUUsR0FBSyxXQUFQekUsR0FBRXlFLEdBQVM7YUFEM0JnQztzQkFDc0M4WTtjQUFMLElBQWE5YSxjQUFIekU7Y0FBUyxPQUFBLFdBRDlDZ0gsR0FDcUNoSCxHQUFMdWYsS0FBUTlhO2FBQWdCO0dBQUE7WUFHdkVrc0IsT0FBT2xzQixHQUFHdUM7SUFDTixZQWhKSnEvQixLQStJTzVoQztnQkFFQzs0QkFDQzhHLGtCQUFIcEI7SUFBUyxXQW51QmZyRCxLQW11QlN5RSxLQUFIcEIsR0FISW5EO0dBRzZCO1lBR3ZDNHBCLFdBQVduc0IsR0FBR3VDO0lBQ1YsWUFQSjJwQixPQU1XbHNCLEdBQUd1QztnQkFFTixPQUFBO1FBQ0hpRDtJQUFPLE9BQVBBO0dBQVU7WUFHZnduQixhQUE0Qkg7UUFBUitVLGlCQUFINWhDO2FBbnlCRXVDO0tBc3lCaEIsWUFDUztLQUVJOztNQUREdkM7TUFBTDhhO01BQ00sVUFBQSxXQU5JOG1CLE1BS0w1aEM7O1VBRUEyRztNQUFLLG1CQUZWbVUsS0FFS25VOztRQUZMbVU7O09BSVUsV0FBTywyQkFKakJBO1VBTTZCaFUsa0JBQUxzZ0Msa0JBQTFCNVgsT0FORTFVO01BT0EsT0FBQSxXQVprQitSLFNBV3BCMkMsTUFBMEI0WDs7Z0JBRWYsMkJBUlR0c0I7NEJBTXdCc3NCLFNBQUt0Z0M7Z0NBQUxzZ0MsS0FOeEJ0c0IsTUFNNkJoVTs7cUNBSHBCO1NBRUlMLGtCQUFMNGdDO0tBQVcsdUJBQVhBLFdBQUs1Z0M7SUFJa0I7SUFabkMsSUFyeUJPekUsa0JBbXlCSWhDO0lBbnlCTSxXQUFWZ0MsTUFBTU87O1lBb3pCbkIwckIsa0NBQWlEcjFCO1FBQVJncEMsaUJBQ3JCNWhDLGNBQVRzbkMsY0FBU3hnQyxNQUFBOUc7SUFDcEI7S0FBTSxZQUFBLFdBRm1DNGhDLE1BQ3JCOTZCO21DQUVWOztVQUZVTDtNQUFBSyxNQUFBTDs7O1VBQUFFLGdCQUlYakI7TUFDUCxHQUxTNGhDO1dBTUQzaEMsSUFOQzJoQztPQU1NLEdBQUEsV0FQZ0MxdUMsT0FLeEM4TSxHQUVDQyxJQUFvQixlQUFwQkEsR0FGREQ7O01BR2tCLElBUGhCNmhDLGlCQUlGN2hDO01BSkU0aEMsV0FBQUM7TUFBU3pnQyxNQUFBSDs7OztZQVlwQjBuQiw4QkFBOEJydUIsR0FBR3BIO0lBQ25DLE9BenpCRW1wQzthQXd6QjhCL2hDOztzQkFDQ3d2QixNQUFLOXBCO2NBQ3BDLEdBRCtCOHBCO21CQUV4QjdwQixJQUZ3QjZwQjtlQUVqQixHQUFBLFdBSG1CNTJCLE9BQ0c4TSxHQUU3QkMsSUFBb0IsZUFGU0Q7O2NBR2pCLFdBSGlCQSxPQUFBQTthQUdBO0dBQUM7WUFHckNnVixNQUFNMWEsR0FBR3VDLEdBQUksT0E1cEJiNkIsT0FqQkE4aEIsT0E2cUJNbG1CLEdBQUd1QyxJQUF3QjtZQUNqQ3N0QixPQUFPdnRCLEdBQUdDLEdBQUksT0E3cEJkNkIsT0FKQTZuQixRQWlxQk8zcEIsR0FBR0MsSUFBeUI7WUFDbkNvWSxJQUFJbUIsR0FBRXhaLEdBQUdDLEdBQUksT0FBQSw4QkFueEJiRixNQW14Qkl5WixHQUFFeFosR0FBR0MsR0FBOEI7WUFDdkMyWSxRQUFRNVksR0FBRzNKO0lBQVUsT0FBQSw4QkFweEJyQjBKLE1Bb3hCUUMsR0FBRzNKO0dBQTRDO1lBQ3ZEeWlCLFFBQVE5WSxHQUFHM0o7SUFBVSxPQUFBLDhCQXJ4QnJCMEosTUFxeEJRQyxHQUFHM0o7R0FBNEM7WUFFdkRxSixLQUFLOFMsR0FBR3ZTO2FBOTBCV211QixJQSswQk9uMUI7S0FBSyxHQUQxQnVaLEtBQ3FCdlosR0FBb0I7S0FBc0IsVUFBQSw0QkFBMUNBO0tBQThCLFdBQU8sV0FEdkRnSCxHQUNrQmhIO0lBQWdEO0lBLzBCbkQsY0FBSm0xQjtHQSswQndEO1lBRzNFdnVCLElBQUluQyxHQUFHZ2QsS0FBS3ZiO0lBQ2QsVUFEU3ViLCtCQUFLdmI7WUFDYTtRQUVabWdDLE9BSFQ1aEMsTUFHTThHLE1BSE45RztJQUlKO21CQURVOEc7O2FBR04sSUFBUTlHLGNBQUh6RTtnQkFOR2tHLE9BT0wsNEJBREVsRyxHQU5GeWhCLE1BUUU7YUFFRyxZQUFBLFdBUEM0a0IsTUFHRDVoQzsyQ0FLSTtvQ0FDSDhHLGdCQUFLLGVBTlR2TCxHQU1JdUw7aUJBQ0VwQixjQUFHZTtnQkFiWHVXLE9BTUV6aEI7Y0FPNkIsV0FBdkJtSyxPQUFrQyw0QkFQeENuSyxPQU9Ta0w7aUJBQ0FFO2FBQU0sZUFBTSw0QkFSckJwTCxPQVFTb0w7WUFBc0I7R0FBRTtZQUcxQ29zQixLQUFLL3lCLEdBQUV5QjtJQUNULEdBRFNBLFNBQ087UUFFRG1nQyxPQUhSNWhDLE1BR0s4RyxNQUhMOUc7SUFJTDttQkFEVThHOzthQUdOLElBQVE5RyxjQUFIekU7Z0JBTkZrRyxPQU1FbEcsR0FFQTthQUVHLFlBQUEsV0FQQ3FtQyxNQUdENWhDOzJDQUtJO29DQUNIOEcsZ0JBQUssZUFOVHZMLEdBTUl1TDtpQkFDS0wsZ0JBQUhmO2FBQVMsV0FBVEEsT0FBb0IsNEJBUDFCbkssT0FPU2tMO1lBQTRCO0dBQUU7WUFHaER1c0IsS0FBS2h6QixHQUFFeUI7SUFDVCxHQURTQSxTQUNPO1FBRURtZ0MsT0FIUjVoQyxNQUdLOEcsTUFITDlHO0lBSUw7bUJBRFU4Rzs7YUFHTixJQUFROUcsY0FBSHpFLGNBQ0MsUUFBQSxXQUpHcW1DLE1BR0Q1aEM7MkNBRUU7b0NBQ0g4RyxnQkFBSyxlQUhQdkwsR0FHRXVMO2lCQUNFcEIsY0FBR2U7Z0JBVlRoRixPQU1FbEc7Y0FJMkIsV0FBdkJtSyxPQUFrQyw0QkFKdENuSyxPQUlPa0w7aUJBQ0FFO2FBQU0sZUFBTSw0QkFMbkJwTCxPQUtPb0w7WUFBcUI7R0FBRTtZQUd2QzBzQixXQUFXcnpCLEdBQUd1QztJQUNoQixJQUNlcS9CLE9BRkY1aEMsTUFFRDhHLE1BRkM5RztJQUdYO1lBRFU4RztxQkFHRjlHO2FBQ0UsWUFBQSxXQUpHNGhDLE1BR0w1aEM7MkNBRU07b0NBQ0g4RyxnQkFBSyxXQUFMQTtpQkFDRXBCLGNBQUdlO2FBQVEsT0FBQSxXQVRWbEUsR0FTRG1ELFNBQUFBLEdBQUdlO1lBQ1U7R0FBRTtZQUc1QjZzQixXQUFXdHpCLEdBQUd1QztJQUNoQixJQUNlcS9CLE9BRkY1aEMsTUFFRDhHLE1BRkM5RztJQUdYOzRCQURVOEc7O2FBR047a0JBT1k5RztjQUFLLE9BelJyQjhtQyxjQStRYWxGLE1BVUc1aEM7O2FBTEgsSUFERzhHLGdCQUNILFFBQUEsV0FMQTg2QixNQUlHOTZCOzJDQUVDOztrQkFDSEw7Y0FBSywyQkFBTEE7O2lCQUVFZixjQURHaUI7YUFBUSxHQUFBLFdBVmJwRSxHQVdFbUQsSUFEa0IsMkJBQWZpQjtpQkFDQSs4QjthQUFNLFdBQVRoK0Isa0JBQUdnK0I7WUFDc0I7R0FBRTtZQUczQzhELFlBQVl4bkMsR0FBRXBPO0lBQ2hCLElBQ2tCZ3dDLE9BRko1aEMsTUFFRjhILE9BRkU5SDtJQUdaO2dDQURVOEgsTUFGSWxXOzthQUtWO2tCQUVZb087Y0FBSyxPQW5TckI4bUMsY0E4UmdCbEYsTUFLQTVoQzs7bUNBRE1wTyxjQUFOa1c7YUFBWSxXQUFObFcsa0JBQU5rVztZQUN5QjtHQUFFO1lBRzNDMi9CLHNCQUFzQnpuQyxHQUFFc0YsR0FBSSxPQXBPNUIzRCxPQW5wQkFPLFFBdTNCd0JvRCxJQUFGdEYsR0FBMEI7R0FHckM7SUFBQSxZQXZPWDJCOztZQTJPQTJ6QixZQUFZdDFCLEdBQUc2VTtJQUNqQixJQUNlK3NCLE9BRkQ1aEMsTUFFRjhHLE1BRkU5RztJQUdaOzJCQURVOEc7O2FBR047O2NBRVMsSUFERDlHLGNBQ0MsUUFBQSxXQUxBNGhDLE1BSUQ1aEM7NENBRUs7O21CQUNIOEc7ZUFBSywwQkFBTEE7O2tCQUNLTCxnQkFBSGY7Y0FBUyxXQUFUQSxrQkFBR2U7OztzQ0FNQWloQyxrQkFBSEM7Y0FBUyxXQUFUQSxvQkFBR0Q7O2FBSk4sSUFERS9nQyxnQkFDRixVQUFBLFdBVkFpN0IsTUFTRWo3Qjs2Q0FFRTs7a0JBQ0grOEI7Y0FBSywwQkFBTEE7O2lCQUNLa0Usa0JBQUgzOUI7YUFBUyxXQWZWNEsseUJBZUM1SyxLQUFHMjlCO1lBQzJCO0dBQUU7WUFHaERDLE9BajhCYTdsQztJQWk4QkYsU0FqOEJRTyxFQWk4Qm9CM1EsR0FBSyxXQUFMQSxHQUFBQSxHQUFpQjtJQWo4QmpDLFdBQVZvUSxNQUFNTztHQWk4QnNDO1lBRXpEdWxDLGVBQWUxOUI7SUFDakIsR0FBRywyQkFEY0E7S0FDUTtJQUNqQixJQUFKcEssSUFyNUJGa0MsUUFtNUJla0k7SUFHakIsU0FqUGdCN0gsU0FpUFMsT0FEckJ2QyxFQUNzQjtJQUFFLElBalBmOEcsTUE0T1grZ0M7SUE1T2tCLE9BQUEsbUJBQVAvZ0MsS0FBR3ZFO0dBaVB1QjtZQUdyQ2t4QixrQkFwUFdzVSxJQW9QVUM7YUFwUFB6bEMsRUFvUGtDbUQsR0FBSyxPQWhQckRrbUIsSUF3T0FpYyxPQVFnRG5pQyxJQUEzQnNpQyxJQUFpRDtJQXBQcEQsT0FBQSxtQkFBUEQsSUFBR3hsQztHQW9QeUQ7WUFDdkUwbEMsVUFBVXIyQyxHQUFJLE9BQUEscUJBQUpBLEdBQVk7WUFFdEJzMkMsYUFBYWxvQyxHQUFHZ0MsTUFBTU8sR0FBRzBZO0lBQzNCLE9BQUE7O2FBRGVqYjthQUFHZ0M7c0JBQytCOFksS0FBSXF0QixRQUFRclc7Y0FDM0QsS0FEbURxVyxRQUV6QyxPQUFBLFdBRmlEclcsR0FBWmhYO2tCQUd4Q3BWLElBSDRDeWlDO2NBR3ZDLE9BQUEsV0FKVTVsQyxHQUN5QnVZLEtBR3hDcFYsR0FIb0Rvc0I7YUFHckM7YUFKRzdXO0dBSUY7WUFHdkJtdEIsT0FBUXI0QixNQUFNTixVQUFPbk4sR0FBR04sTUFBTU87SUFDaEMsT0FBQTs7YUFEdUJEO2FBQUdOO3NCQUloQjhZLEtBQUlxdEIsUUFBUXJXO2NBQ2xCLEtBRFVxVztlQUVBLE9BQUEsV0FOSnA0QixNQU1TLFdBTkhOLFVBSU5xTCxNQUFZZ1g7a0JBR1hwc0IsSUFIR3lpQztjQUdFLE9BQUEsV0FQTnA0QixNQU9XLFdBUFd4TixHQUl0QnVZLEtBR0NwVixJQUhXb3NCO2FBR2E7YUFQbkJyaUI7R0FRQTtZQUdkNDRCLE9BQVF0NEIsTUFBTU4sVUFBT25OLEdBQUdDO0lBQzFCLE9BQUE7O2FBRHVCRDs7NkJBSVY2bEMsUUFBUXJXO2NBQ2pCLEtBRFNxVztlQUVDLE9BQUEsV0FOSnA0QixNQU1TLFdBTkhOLGNBSUtxaUI7a0JBR1Zwc0IsSUFIRXlpQztjQUdHLE9BQUEsV0FQTnA0QixNQU9XLFdBUEt4TixHQU9mbUQsSUFIVW9zQjthQUdVO2FBUGZyaUI7R0FRQTtZQUdkdUwsV0FBV2hiLEdBQ1NnQyxNQUFGTyxHQURLMFk7SUFDekIsSUFBZTJtQixPQURGNWhDLE1BQ0EwakMsTUFEQTFqQyxNQUNBOEcsTUFBQTQ4QixLQUFTNW9CLE1BQUE5WTtJQUNwQjtLQUFNLFlBQUEsV0FETzQvQixNQUFGOTZCO21DQUVELE9BQUEsV0FIYW1VLFFBQ0hIOztVQUFUclU7TUFBQUssTUFBQUw7OztNQUtELElBTENFLGdCQUlGakIsY0FDQyxVQUFBLFdBTFFuRCxHQUFFdVksS0FJWHBWOytCQUVDOVQsZ0JBQUssT0FBTEE7VUFOVTQ2QjtNQUFUMWxCLE1BQUFIO01BQVNtVSxNQUFBMFI7OztHQVVvQjtZQUd4QzNSLFlBQVk3YSxHQUNRZ0MsTUFBRk87SUFBcEIsSUFBZXEvQixPQURENWhDLE1BQ0QwakMsTUFEQzFqQyxNQUNEOEcsTUFBQTQ4QixLQUFTNW9CLE1BQUE5WTtJQUNwQjtLQUFNLFlBQUEsV0FETzQvQixNQUFGOTZCO21DQUVELE9BQUEsNEJBRlVnVTs7VUFBVHJVO01BQUFLLE1BQUFMOzs7TUFLRCxJQUxDRSxnQkFJRmpCLGNBRUp5QixJQURLLFdBTFE1RSxHQUFFdVksS0FJWHBWO2VBRUp5QixNQUFnQixPQUFoQkE7VUFOZXFsQixRQU1mcmxCO01BTk1MLE1BQUFIO01BQVNtVSxNQUFBMFI7OztHQVVvQjtZQUd4QzhiLGNBQWNobUMsR0FBSSxPQXI5QmxCSixRQXFCQUUsUUFnOEJjRSxJQUF1QjtZQUVyQ2ltQztJQUFRLElBQXVCM0csaUJBQUg1aEM7YUFLdEJ1b0MsUUFDTXZvQztLQURNOzs7bUJBQ044RyxNQUFBOUc7ZUFDWjtnQkFBTSxZQUFBLFdBUHlCNGhDLE1BTW5COTZCOzhDQUVGOztxQkFFRUgsZ0JBQUhqQjtpQkFBUyxXQUFUQSxHQUxINmlDLFFBS001aEM7O29CQUpBRjtnQkFBQUssTUFBQUw7OztJQUQ4QjtJQU81QztZQVBROGhDLFFBTHNCdm9DOzthQVlULElBQVNzRixpQ0FBQUE7O3VCQUFBQTtxQ0FBTSxnQ0FBTkEsS0FBQUE7WUFBa0I7R0FBQztZQUcvQ2tqQyxhQUFheG9DLEdBQ0N5QjtJQUFoQixJQUFzQm1nQyxPQURQNWhDLE1BQ0swakMsTUFETDFqQyxNQUNGekUsT0FBT3VMLE1BQUE0OEI7SUFDbEI7UUFEY2ppQyxPQUFIbEcsR0FFTixXQUZhdUwsS0FBRTg2QjtLQUlaLFlBQUEsV0FKWUEsTUFBRjk2QjttQ0FoQlYsT0Fwc0JSMDhCOztVQW90QmtCLzhCO01BQUFLLE1BQUFMOzs7TUFPTyxJQVBQRSxnQkFBUFMsTUFPYyw0QkFQZDdMO01BQUFBLElBQUE2TDtNQUFPTixNQUFBSDs7O0dBVXNCO1lBR3hDOGhDLHlCQUF3Q2xtQztRQUFScS9CLGlCQUNyQjVoQyxjQUFBOEcsTUFBQTlHO0lBQ1g7S0FBTSxZQUFBLFdBRjBCNGhDLE1BQ3JCOTZCO21DQUVEOztVQUZDTDtNQUFBSyxNQUFBTDs7O1VBSUNFLGdCQUFIL1U7TUFBWSxLQUFBLFdBTG1CMlEsR0FLL0IzUSxJQUFpQyxlQUFqQ0EsT0FBRytVLEtBTG9CaTdCO01BQ3JCOTZCLE1BSUNIOzs7O1lBS1poTixVQUFRaWpCLFdBQVVsWixJQUFHQztJQUN2QixPQUF3Qjs7c0JBQUtvRztjQS93QjNCdEg7Z0JBbWNBdWtDLFNBMlVrQnRqQyxJQUFHQzs7aUJBRUk7Ozs0QkFDVixXQUZZb0c7NEJBR1gsV0FIV0E7aUJBS2Y7O2tCQURHMitCO2tCQUFKQztrQkFDSDcyQixJQUFJLFdBTko4SyxXQUtHK3JCLElBQUlEOzhCQUNQNTJCOzhCQUNXLFdBTlEvSCxHQUtuQitIO2dCQUNzQjtjQUw5QjthQU1DO0dBQUM7WUFHRmxaLE1BQU1pa0IsU0FBUW5aLElBQUdDO0lBQ25CLE9BeDBCRWtCO2FBaWZBbWlDLFNBc1ZjdGpDLElBQUdDOztjQUNTLDJCQUVGO29DQURYeXFCLGVBQUpGO2NBQVcsT0FBQSxXQUZkclIsU0FFR3FSLElBQUlFO2FBQ2lCO0dBQUE7WUFHOUJ3YSxZQUFZaGlDO0lBQ2QsU0FBSWc3QjtTQUFrQmlILHVCQUFaQztLQUNSLEtBRFFBO01BT0csT0FBQSwyQkFQU0Q7O3dCQU9xQywyQkFQckNBO0tBR1g7TUFEWUUsZUFGYkQ7Y0FBQUE7TUFFT3ZtQztNQUFIdkM7TUFDSCxVQUFBLFdBRE11QyxHQUFIdkM7O01BSUMsZUFKUStvQyxjQUZERjs7VUFLVi9oQztNQUFLLHVCQUFMQSxLQUhLdkUsSUFBTXdtQyxlQUZERjs7U0FJTHBpQyxrQkFBSDdVO0tBQVMsV0FBVEEsT0FGU20zQyxzQkFFTnRpQyxLQUZBbEUsSUFGS3NtQzs7SUFTVixJQUFSdGdDLFlBVlUzQjtJQVdkLFdBREkyQixPQVRBcTVCO0dBVWtCO1lBR3BCb0g7UUFBMEJ6Z0IsZUFBSjRkO0lBQ3hCLFNBQUl2RTtTQUE4QnVFLGVBQVowQyx1QkFBWkM7S0FDUixHQURRQTtNQUdDO09BRGNDLGVBRmZEO2VBQUFBO09BRVF0Z0I7T0FBSnlkO09BQ0gsVUFBQSxXQURPemQsSUFBSnlkOztPQUlDLGVBSlU4QyxjQUZIRixZQUFZMUM7O1dBS3RCQztPQUFNLGVBSE8yQyxzQkFHYjNDLE1BSE01ZCxLQUZJcWdCLGFBQVkxQzs7VUFJakJFLG1CQUFIejBDO01BQVUsV0FBVkEsT0FGV20zQyxzQkFFUjFDLE1BRkM3ZCxLQUZJcWdCLGFBQVkxQzs7S0FRdkIsY0FBQSxXQVRpQjVkLElBQ000ZDs7YUFBWjBDO3dCQVdPLDJCQVhQQSxnQkFBWTFDOzs7VUFVdEJHO01BQVMsZUFBTSwyQkFWTHVDLGdCQVVWdkM7O1NBREtFLG1CQUFIbGtDO0tBQWEsZUFBTSwrQkFBbkJBLEdBVFF1bUMsaUJBU0xyQzs7SUFLTCxJQUFSaitCLGtCQWZvQjQ5QjtJQWdCeEIsV0FESTU5QixPQWRBcTVCOztZQWtCRnFILDhCQUE4QjlDLElBQUdGO0lBQ25DLE9BcEJFK0M7YUFvQkY7O2VBRGdDN0M7d0JBQ2pCbGY7Z0JBQU0sT0FBVTtnQ0FESWdmLGFBQ0MvZSxJQUFNLFdBQTNCRCxJQUFxQkMsSUFBWTtlQUFDO0dBQWU7WUFHOURnaUIsT0FwbUNhbG5DO0lBcW1DZixTQXJtQ3FCTyxFQXFtQ1M0bUM7S0FDdEIsWUFBQSxXQURzQkE7aUJBRW5CO1NBQ0dsbEIsZUFBSkQ7S0FBVyxXQUFYQSxJQUFJQztJQUFxQjtJQXhtQ1YsV0FBVmppQixNQUFNTztHQXdtQ2U7WUFHbEM2bUM7UUFBeUJ4SCxpQkFBUHI1QjtJQUNwQixTQUFRbUksS0FBS25JO0tBQ1gsSUFEVys1QixVQUFBLzVCO0tBQ1g7TUFBTSxZQUFBLFdBRm1CcTVCLE1BQ2RVO29DQUVEOztXQUVHRSxvQkFBSnhlO09BQWMsV0FBZEEsb0JBQTJDLE9BSjlDdFQsS0FJTzh4QixTQUFpRDs7VUFKbkREO01BQUFELFVBQUFDOztJQUlvRDtJQUVqRSx1QkFBVSxPQU5GN3hCLEtBRFluSSxPQU9BOztZQVdkOFEsU0FBT3puQixHQUFFa2dDLEdBQUksT0FBQSxXQUFKQSxHQUFGbGdDLEdBQVM7WUFFaEJ1bkIsT0FBSzJDLEdBQUd2WixHQUFFdXZCO0lBQ1osT0FBRTthQURLaFc7c0JBQ0FwVyxHQUNJLElBQUxvVyxJQUFLLFdBRkR2WixHQUNIbUQsSUFFTCxPQUFBLFdBRElvVyxHQUZNZ1csR0FHTjtHQUFDO0dBSUM7SUFBTjFZOzs7Z0JBREkwQyxHQUFHdlosR0FBRXV2QjtRQUFJLE9BQUU7aUJBQVhoVyxZQUFnQnBXLEdBQUssT0FBRSxXQUFsQm9zQixHQUFrQixXQUFwQnZ2QixHQUFhbUQsSUFBWTtPQUFDOzhDQU5qQ3lULFFBT0FDLE9BVEFDOzs7Ozs7Ozs7Ozs7O1lBZUZnd0IsUUFBTWxpQyxHQUFFMnFCLEdBQUksZUFBTjNxQixHQUFFMnFCLElBQXVCO1lBRy9Cd1gsWUFBWUM7SUFDZCxPQXBNQXJCO2FBbU1jcUI7OzZCQUlEMzNDLEdBQUdrZ0MsR0FBRXZ2QjtjQUFLLGVBQVYzUSxtQkFBb0MsT0FBMUIsV0FBUGtnQyxNQUFFdnZCLEdBQXFDO2FBQUU7O0dBQ3pDO1lBR2QwRixJQUFJM0Y7YUF2cENPTixZQXdwQ0MsT0FYRyxXQVVYTSxtQkFWc0IsV0FBUyxHQVdiO0lBQ3hCLFNBenBDbUJDLEVBeXBDYmluQyxPQUFRLElBakNDcEcsT0FpQ00sV0FBZm9HLGNBakNpQixPQUFScEcsS0FpQ2dCO0lBenBDUixXQUFWcGhDLE1BQU1PO0dBMHBDQzs7OztPQXZrQ3BCMkw7T0FzK0JBdFY7T0FYQWU7T0F0dkJBZ2pCO09BNUlBdlk7T0FpSUFpUztPQWJBNVQ7T0F6T0FKO09BZzhCQXdZO09BZEFHO09BaHVCQXhXO09BdkJBSztPQXNsQkE2VjtPQUVBQztPQWhvQkFXO09BV0FEO09BaEpBalo7T0FvSEFtWjtPQWtwQkFMO09BQ0FFO09BekRBNFE7T0FGQXRwQjtPQTdmQW9rQjtPQXFqQkErSTtPQTlJQXRKO09BdmRBRzs7Ozs7Ozs7Ozs7O09BK0ZBOGM7T0FxVUE1Qjs7T0F4b0JBQztPQUVBQztPQU9BQztPQWdCQUc7T0EyVUFoZTtPQWNBQztPQW5PQWlHO09BTUEwQjtPQWxCQWxwQjtPQXFDQXFwQjtPQWJBL0Y7T0FzYUF5Z0I7T0FBQUE7T0FhQUM7O09BakNBYjtPQStDQS9oQjtPQVdBN2Y7T0FNQThmO09BY0E0aUI7T0FrRUF2Z0I7T0FoY0FPO09Bc2NBbGxCO09BbUJBRTtPQURBcXJCO09BRUFDO09Bc1hBNmI7T0FkQUo7T0F0V0FoZDtPQVVBb2I7T0EwREE3YTtPQU5BRDtPQVlBYztPQWlCQWlCO09BYUFJO09BNXVCQXJMO09BeXZCQWhoQjtPQTlLQWd1QjtPQUNBRztPQWRBQztPQStMQWp1QjtPQWlCQTR3QjtPQWdCQUM7T0FtS0F3VjtPQXJKQW5WO09BYUFDO09Bc0pBbVY7T0FqWUE1VjtPQWNBa1U7T0E0T0FTO09BVUFDO09BcERBelU7O09Bc0ZBUztPQXVKQXdWO09BbExBM1Q7T0FxQkF3UztPQUZBRDtPQVNBSTtPQUVBQztPQU9BRTtPQVdBQztPQTU1QkFwRjtPQWxCQS9nQztPQXVEQTAyQjtPQWc2QkEyUDtPQUZBRDtPQXRSQXJCO09BYUFFO09Bd1dBK0I7T0FPQUU7Ozs7Ozs7Ozs7Ozs7UUFpQ0VDO1FBR0FDO1FBUUFyaEM7Ozs7RTs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ250Q0Z0UDtJQUNBcWE7SUFDQTVHO1lBRUNGLGVBQ0N1TDtJQUFvQixPQUFBLDZCQUFwQkE7R0FBdUQ7WUFvQ3ZEcEQsZ0I7WUFDQW8xQjtJOzs7WUFFQUMsT0FBSzFWLEtBQUl6NEIsR0FBRXdIO0lBQ0gsSUFBTjRtQyxNQUpGdDFCLElBR0syZixLQUFJejRCO0lBRlRrdUMsSUFFS3pWLEtBQUl6NEIsR0FIVDhZLElBR0syZixLQUFNanhCO0lBRWIsT0FKRTBtQyxJQUVLelYsS0FBTWp4QixHQUNUNG1DO0dBRVM7WUFjVHRrQyxLQVdhMnVCLEtBQVdyN0IsU0FBTml4QyxNQVhPQztJQUdqQixXQUFBLDRCQVFVRDtPQVhPQztTQVdPN3NCOztNQVF4QixJQVIwQm5NLElBL0JwQ3dELElBK0JlMmYsS0FBbUJoWCxNQVM1QjhzQixZQVQ0QjlzQjtNQUM5QjtPQUFhLElBQVQrc0IsU0FBUyw0QkFRWEQ7VUFUY0YsT0FDWkc7T0FDaUIsUUFBQSxXQUZDcHhDLFNBL0IxQjBiLElBK0JlMmYsS0FDUCtWLFNBRDRCbDVCO09BOUJwQzQ0QixJQThCZXpWLEtBU1Q4VixXQXhDTnoxQixJQStCZTJmLEtBQ1ArVjtPQVFGRCxZQVJFQzs7TUEvQlJOLElBOEJlelYsS0FTVDhWLFdBVDhCajVCO01BUjFCLFdBUXdCbU07U0FYUDZzQixVQVdPN3NCO01BQUFBOzs7O0dBVzlCO0dBdkJ1Qix5QkFDekIzWDtZQThCSTJrQyxRQUFRaFcsS0FBS3I3QixTQUFRc3hDLE1BQU1MLE1BQU1DO0lBQ3ZDLElBRDJCSyxTQUFBRDtJQUMzQjtLQUFvQjtNQUFoQkUsZ0JBQWdCLDRCQURPRCxRQUFNTjtNQUVoQixPQUFBLCtCQURiTztNQUNhLE9BQUEsa0NBRmdCUDtNQUU3QlEsYUFBYTtNQUNDLE9BQUEsK0JBRmREO01BRWMsT0FBQSxrQ0FIZVA7TUFHN0JTLGNBQWM7OztTQURkRCxjQUZtQ1A7T0FLa0IsV0F2RHpEeDFCLElBa0RjMmYsS0FBYWtXO09BS0MsT0FBQSxXQUxUdnhDLFNBbERuQjBiLElBa0RjMmYsS0FFVm9XLHdCQUVBRSxVQUZBRjs7VUFFQUUsVUFKdUJKOzs7O1NBR3ZCRyxlQUhtQ1I7T0FVb0IsV0E1RDNEeDFCLElBa0RjMmYsS0FJVnNXO09BTXlCLE9BQUEsV0FWVjN4QyxTQWxEbkIwYixJQWtEYzJmLEtBR1ZxVyx5QkFIdUJFLFlBR3ZCRjs7VUFIdUJFLFlBSXZCRDs7Z0JBSnVCQyxjQUFBTDs7S0EvQzNCUixPQStDYzFWLEtBQWFrVyxRQUFBSztLQUFBTCxTQUFBSzs7R0FpQmlCO1lBWTFDQyxPQUFLeFcsS0FBS3I3QixTQUFTaXhDLE1BQU1DO0lBQzNCO0tBTlEsT0FBQSw0QkFLYUQsTUFBTUM7S0FMbkIsT0FBQTtlQUthRDtTQUxyQnJ1Qzs7TUF4Qk15dUMsUUE2QkNoVyxLQUFLcjdCLFNBTFo0QyxHQUtxQnF1QyxNQUFNQztNQUp6QixXQURGdHVDO1NBS3FCcXVDLFNBTHJCcnVDO01BQUFBOzs7SUFXcUIsV0FBQSw0QkFOQXF1QztPQUFNQztTQU0zQnppQyxNQU4yQnlpQzs7TUE1RTNCSCxPQTRFTzFWLEtBQWM0VixNQU1yQnhpQztNQW5DTTRpQyxRQTZCQ2hXLEtBQUtyN0IsU0FBU2l4QyxNQUFBQSxNQVFvQiw0QkFGekN4aUM7TUFFRSxXQUZGQTtrQkFBQUE7TUFBQUE7Ozs7R0FHSTtHQXpDa0Isb0JBZ0NwQm9qQztZQTJCQUMsa0JBQWtCelcsS0FBS3I3QixTQUFRK3hDLElBQUdDLElBQUdDLElBQUdDLElBQUdDO2FBQ3pDQyxpQkFBaUJ4dkMsR0FBRXdIO0tBQ3JCO01BQXVCLE9BNUd6QnNSLElBMEdvQjJmLEtBQ0dqeEI7aUJBQ2xCLFdBRm9CcEssU0ExR3pCMGIsSUEwR29CMmYsS0FDQ3o0QjttQkF4R3JCbXVDLE9BdUdvQjFWLEtBQ0N6NEIsR0FBRXdIO0lBQ21DO0lBRHREZ29DLGlCQUQ2QkwsSUFBR0M7SUFDaENJLGlCQURzQ0YsSUFBR0M7SUFDekNDLGlCQUQ2QkwsSUFBTUU7SUFDbkNHLGlCQURnQ0osSUFBR0M7SUFDbkNHLGlCQUQ2QkwsSUFBU0c7SUFDdENFLGlCQURtQ0gsSUFBR0M7SUFDdENFLGlCQURnQ0osSUFBU0c7SUFDekNDLGlCQURnQ0osSUFBR0M7SUF3QnZDLE9BdkJJRyxpQkFEc0NGLElBQUdDO0dBeUJ2QjtZQTJEaEJFLFdBQVdoWCxLQUFLaVgsV0FBV3R5QyxTQUFTaXhDLE1BTDdCQztJQU1iLElBRHNCcUIsY0FBQUQsV0FMYkUsU0FLaUN2QjtJQUMxQztLQUFVO01BQUEsT0FBQSw0QkFOR0MsT0FBSnNCO01BTUwxcEMsTUFBTTtLQUlWLFNBSklBO01BS0MsT0FBQSw4QkFOWXV5QixLQUFnQnI3QixTQUx4Qnd5QyxRQUFJdEI7WUFLU3FCO01BUWpCLE9BQUEseUJBUllsWCxLQUFnQnI3QixTQUx4Qnd5QyxRQUFJdEI7S0FlSztNQVZJdUIsY0FVSiw0QkFWSUY7TUEvQ1YsT0FBQSw0QkEwQ0NyQixPQUFKc0I7TUExQ0xFLFFBQVE7TUFDUlgsS0FBSyw0QkF5Q0FTLFFBMUNMRTtNQUVBVixLQUFLLDRCQURMRCxJQURBVztNQUdBVCxLQUFLLDRCQURMRCxJQUZBVTtNQUlBUixLQUFLLDRCQURMRCxJQUhBUztNQUtBUCxLQUFLLDRCQURMRCxJQUpBUTtLQXJDRlosa0JBb0ZlelcsS0FBZ0JyN0IsU0E5QzdCK3hDLElBQ0FDLElBQ0FDLElBQ0FDLElBQ0FDO0tBRVM7TUFBVFEsU0F0SkpqM0IsSUE4TGlCMmYsS0E3Q2IyVztNQU1BWSxTQXZKSmwzQixJQThMaUIyZixLQTVDYjRXO01BTUFZLFNBeEpKbjNCLElBOExpQjJmLEtBM0NiNlc7TUFNRDtjQUFBLFdBcUM4Qmx5QyxTQXhDN0IyeUMsUUFDQUM7ZUFEQUQsUUFDQUM7O2VBSUksV0FtQ3lCNXlDLFNBdkM3QjR5QyxRQUNBQztpQkFEQUQsUUFDQUM7aUJBRkFGLFFBRUFFO01BaURRQztNQXhDQUM7TUFBUkM7TUF3Q0U1YyxNQWhCR29jO01BQUVTLE1BQUZUO01BZ0JBVSxNQWhCSWhDO0tBQUk7U0FnQlJnQyxNQWhCRUQ7TUFmQSxJQUFMRSxLQTFLTnozQixJQThMaUIyZixLQUxONFg7TUFkTixRQUFBLFdBbUI0Qmp6QyxTQXBCM0JtekMsSUFURkg7T0FjTSxPQUFBLFdBZXVCaHpDLFNBcEIzQm16QyxJQVRNSjtZQW9CSjNoQyxJQW9CQzhoQztRQXRCSDtZQU1LRCxPQUpIN2hDO1NBRlUsUUFBQSxXQVdlcFIsU0E5TGpDMGIsSUE4TGlCMmYsS0FUVGpxQixJQXBCSTJoQztTQWtCeUQsSUFEMUNLLE1BQzBDLDRCQUU3RGhpQztTQUFBQSxJQUhtQmdpQzs7UUEvSzNCckMsT0EyTGlCMVYsS0FUVGpxQixHQUlHNmhDO1FBRkUsSUFFQUksTUFGQSw0QkFGTGppQztRQW9CQzhoQyxNQWhCSUc7O1lBREMsSUFDSHYvQixJQURHLDRCQUNIbS9CLFNBQUFBLE1BQUFuL0I7O09BdExYaTlCLE9BMkxpQjFWLEtBTE40WCxLQWdCTDdjO09BM0JXO1FBV05rZCxNQVhNLDRCQVdOTDtRQUFGdG1DLElBWEEsNEJBMkJIeXBCO09BQUFBLE1BaEJHenBCO09BQUVzbUMsTUFBQUs7OztLQUtMakI7T0FBV2hYLEtBQUtvWCxhQUFXenlDLFNBTHhCd3lDLFFBaUJ5Qyw0QkFENUNwYztZQUFNMGMsZUFYTlQsV0FBV2hYLEtBQUtvWCxhQUFXenlDLFNBVzNCbzJCLEtBQUc4YztLQUdrQyxJQWRESyxTQWNDLDRCQUhsQ0w7S0FYYVgsY0FBQUU7S0FMYkQsU0FLaUNlOztHQWNnQjtZQUd4REMsT0FBS25ZLEtBQUtyN0IsU0FBU2l4QyxNQUFNQztJQUMzQixPQWxCTW1CLFdBaUJDaFgsU0FBS3I3QixTQUFTaXhDLE1BQU1DO0dBbUIyQztHQXpIcEU7SUFBQSxpQkFzR0FzQyxRQXJHQTFCOzs7Ozs7Ozs7Ozs7Ozs7WUE2SEoyQixPQUFNcHZCLEtBQUt2YixLQUFJdXlCLEtBQUtyN0I7SUFDdEI7S0FDRTtPQUFBOzRDQUZNcWtCLEtBQUt2YixRQUFJdXlCO0tBQ1IzVztLQUFMK2Y7S0FHZ0QsT0FBQSw0QkFIaERBLE9BQUsvZjtLQUcwQyxPQUFBO0lBQUEsT0FBQSwwQkFKbEMyVyxLQUFLcjdCLFNBQ2xCeWtDO0dBRzhEO1lBR2hFN2hCLFNBQVNqWixHQUFJLE9BQUpBLEVBQUs7WUFDZCtULFNBQVMvVCxHQUFJLGFBQUpBLHFCQUFnQjtZQUV6Qnd4QixVQUFVeHhCLEdBQUczSjtJQUNmO0tBQUk0QyxRQUFRLDRCQURBK0c7S0FFUjZkOztZQURBNWtCLFFBQ0E0a0I7TUFFVTtPQUFSbmQsUUFKTVYsTUFDUi9HO09BSUU4d0MsZ0JBTE0vcEMsTUFLdUIsNEJBSi9CL0c7YUFLQyxXQU5VNUMsU0FLVDB6QyxlQURBcnBDLFFBRkZtZDtNQUtGLDZCQU5FNWtCOzs7WUFDQTRrQjs7R0FPRztZQUdMNFQsbUJBQW1CenhCLEdBQUczSjtJQUN4QjtLQUFJNEMsUUFBUSw0QkFEUytHO0tBRWpCNmQ7O1lBREE1a0IsUUFDQTRrQjtNQUVVO09BQVJuZCxRQUplVixNQUNqQi9HO09BSUU4d0MsZ0JBTGUvcEMsTUFLYyw0QkFKL0IvRztjQUtDLFdBTm1CNUMsU0FLbEIwekMsZUFEQXJwQyxRQUZGbWQ7TUFLRiw2QkFORTVrQjs7O1lBQ0E0a0I7O0dBT0c7WUFHTGtOLE1BQU1hLElBQUdFLElBQUl6MUI7SUFDZixJQUFJK0wsS0FESXdwQixlQUVKdnBCLEtBRk95cEI7SUFHWCxTQUZJMXBCLElBR0MsT0FBQSxpQkFKTTBwQjthQUVQenBCLElBSUMsT0FBQSxpQkFOR3VwQjtJQU8wQixXQVAxQkEsT0FPeUMsNEJBTjdDeHBCO0lBTUksUUFBQSxXQVBPL0wsU0FBSnkxQjtLQVFOLE9BQUEsbUJBUkdGLElBQUdFO0lBU3VCLFdBVHZCQSxPQVNzQyw0QkFQN0N6cEI7SUFPSSxPQUFBLFdBVE9oTSxTQUFQdTFCO0tBVUgsT0FBQSxtQkFWTUUsSUFBSEY7SUFZSTtLQUFOenNCLE1BQU0sNEJBWFJpRCxJQUNBQztLQVdFMm5DLFNBQVMsbUJBRFQ3cUMsS0FaRXlzQjtLQWNGcWU7S0FDQUM7S0FDUyxPQUFBLDRCQUpUL3FDO0tBR1c7O1NBQ2ZsRzs7O09BQ01reEM7U0FoQkovbkMsT0FhRTZuQzs7WUFaRjVuQztnQkFhRTZuQzs7Y0FPSztnQkF0Qkk3ekMsU0FBUHUxQixPQWNGcWUsY0FkS25lLE9BZUxvZTs7OztNQVNGLEdBUElDO09BSkZILFdBR0ovd0MsS0FoQk0yeUIsT0FjRnFlO09BQUFBLGNBYVksNEJBYlpBOzs7T0FEQUQsV0FHSi93QyxLQWhCUzZ5QixPQWVMb2U7T0FBQUEsY0FlWSw0QkFmWkE7O01BQ0osV0FBQWp4QztrQkFBQUE7TUFBQUE7OztJQWdCQSxPQW5CSSt3QztHQW1CRztZQUdQSSxpQjtZQUVBdGlCLFlBQVk5bkIsR0FBR04sTUFBTU87SUFDYixJQUFOdVksVUFEYTlZO0lBRVIsT0FBQTs7YUFGS007c0JBRUExUTtjQUNaO2VBQWlCLFFBQUEsV0FISTJRLEdBQ25CdVksUUFDVWxwQjtlQUNDQztlQUFUdzRCO2NBRkZ2UCxTQUVFdVA7Y0FFSixPQUZheDRCO2FBRVo7R0FBQztZQUdGeTRCLFNBQVNob0IsR0FBR04sTUFBTU87SUFDcEI7S0FBSXVZLFVBRFU5WTtLQUVWbWU7T0FDRjs7U0FIUzdkO2tCQUdLMVE7VUFDWjtXQUFpQixRQUFBLFdBSkQyUSxHQUNoQnVZLFFBRVlscEI7V0FDQ0M7V0FBVHc0QjtVQUhKdlAsU0FHSXVQO1VBRUosT0FGYXg0QjtTQUVaO0lBRUwsV0FQSWlwQixRQUNBcUY7R0FNUTtZQUdWdEYsWUFBWXZZLEdBQUdOLE1BQU1PO0lBQUksT0FBQSxvQ0FBVlAsTUFBTU8sR0FBVEQ7R0FBbUQ7WUFDL0QwWSxXQUFXMVksR0FBR04sTUFBTU87SUFBSSw4Q0FBVlAsTUFBTU87SUFBSSxxQiw0QkFBYkQ7R0FBa0Q7WUFDN0RvWSxNQUFNcFksR0FBR0MsR0FBSSxPQUFBLG9DQUFQRCxHQUFHQyxHQUE4QjtZQUN2Q29ZLElBQUltQixHQUFFeFosR0FBR0MsR0FBSSxPQUFBLG9DQUFUdVosR0FBRXhaLEdBQUdDLEdBQThCO1lBQ3ZDMlksUUFBUTVZLEdBQUczSjtJQUFVLE9BQUEsb0NBQWIySixHQUFHM0o7R0FBNEM7WUFDdkR5aUIsUUFBUTlZLEdBQUczSjtJQUFVLE9BQUEsb0NBQWIySixHQUFHM0o7R0FBNEM7WUFFdkRxekIsTUFBTTFwQixHQUFHTixNQUFNTztJQUNqQjtLQUFJdVksVUFETzlZO0tBRUUsTUFBQSw0QkFGTE07S0FDRTs7U0FDVi9HOztNQURJdWYsU0FFSyxXQUhRdlksR0FFakJoSCxHQURJdWYsUUFESXhZLE1BRVIvRztNQUFBLFVBQUFBO2lCQUFBQTtNQUFBQTs7O1dBREl1ZjtHQUlBO1lBR0ZnUixhQUFheHBCLEdBQUdOLE1BQU1PO0lBQ2QsSUFBTnVZLFVBRGM5WTtJQUVSLE9BQUE7O2FBRktNO3NCQUVBL0csR0FBRTNKO2NBQ2Y7ZUFBaUIsUUFBQSxXQUhLMlEsR0FFVGhILEdBRFh1ZixRQUNhbHBCO2VBQ0ZDO2VBQVR3NEI7Y0FGRnZQLFNBRUV1UDtjQUVKLE9BRmF4NEI7YUFFWjtHQUFDO1lBR0ZrNkIsVUFBVXpwQixHQUFHTixNQUFNTztJQUNyQjtLQUFJdVksVUFEVzlZO0tBRVhtZTtPQUNGOztTQUhVN2Q7a0JBR0svRyxHQUFFM0o7VUFDZjtXQUFpQixRQUFBLFdBSkEyUSxHQUdKaEgsR0FGYnVmLFFBRWVscEI7V0FDRkM7V0FBVHc0QjtVQUhKdlAsU0FHSXVQO1VBRUosT0FGYXg0QjtTQUVaO0lBRUwsV0FQSWlwQixRQUNBcUY7R0FNUTtZQUdWMFAsT0FBT3Z0QixHQUFHQztJQUNaLE9BNUJFeXBCO2FBMkJPMXBCOztzQkFDZXd0QixLQUFJcFYsT0FBTWhWO2NBQUssT0FBRyxXQUQ5Qm5ELEdBQ1l1dEIsS0FBVXBxQjt3QkFBcUIsNEJBQTNCZ1Y7d0JBQUFBO2FBQStDO0dBQUM7WUFHMUV3UyxXQUFXNXFCLEdBQUdDO0lBQUksT0FBTyxtQkFBQSxvQkFBUyxnQkFBdkJELEdBQUdDO0dBQStCO1lBQzdDNHFCLFlBQVk3cUIsR0FBR0M7SUFBSSxPQUFPLG1CQUFBLG9CQUFTLGlCQUF2QkQsR0FBR0M7R0FBZ0M7WUFFL0NvcUMsWUFBWXJxQztJQUNkLElBQUkvRyxZQUNBd0gsUUFBUSw0QkFGRVQ7SUFNWjtRQUxFL0csUUFDQXdIO0tBRUYsaUJBSllULEdBQ1YvRyxNQUNBd0g7S0FHRiw2QkFKRXhIO0tBS0YsNkJBSkV3SDs7R0FLQTtZQUdGd0MsSUFBSWpEO0lBQ0UsSUFBSmtHLE1BQUksaUJBREZsRztJQVZKcXFDLFlBV0Vua0M7SUFDSixPQURJQTtHQUVIO1lBR0Nva0MsWUFBWXRuQztJQUNkLEtBRGNBLEdBRU47SUFFUTtLQURUeXBCLE1BSE96cEI7S0FHWkksSUFIWUo7S0FJRSxNQUFBLHlCQURUeXBCO0tBQ0R0dEIsTUFBTTtLQUNOYSxJQUFJLG1CQURKYixLQURKaUU7S0FHSXFFLFFBSENnbEI7S0FLRyxNQUFBLDRCQUpKdHRCOztTQUlKbEc7O2tCQUZJd087O09BSU0sTUFBQTtVQUNEbXBCLGdCQUFManBCO01BQ0EsaUJBUEEzSCxHQUdKL0csT0FBQUEsS0FHSTBPO01BTEFGLE9BS0ttcEI7TUFIRCxVQUFSMzNCO2VBQUFBO01BQUFBOzs7SUFPQSxPQVZJK0c7R0FVSDtZQU1EdXFDLFlBQVl6aUMsSUFBSTdIO0lBQ2xCLEtBRGM2SCxJQUVOO0lBRW1DO0tBRG5DNlosS0FITTdaO0tBR1o0WixLQUhZNVo7S0FJNkIsTUFBQSxXQUp6QjdILEdBR2hCeWhCO0tBQ3lCLE1BQUEseUJBRG5CQztLQUNGdmUsSUFBSSxtQkFBWTtLQUNQbks7YUFGUDBvQjs7aUJBRU4sT0FESXZlO1NBR002b0IsaUJBQU5QO0tBSEF0b0IsTUFDU25LLEtBR00sV0FSSGdILEdBT1p5ckI7S0FFSyxVQUFBLDRCQUpJenlCO0tBQUFBO2FBRUhnekI7O0dBSUQ7WUFHVHVlLGFBQWExaUMsSUFBSTdIO0lBQ25CLEtBRGU2SCxJQUVQO0lBRW1DO0tBRG5DNlosS0FITzdaO0tBR2I0WixLQUhhNVo7S0FJNEIsTUFBQSxXQUp4QjdILE1BR2pCeWhCO0tBQ3lCLE1BQUEseUJBRG5CQztLQUVPdmUsSUFETCxtQkFBWTtLQUNMbks7YUFGVDBvQjs7aUJBR0ksT0FER3ZlO1NBRUg2b0IsaUJBQU5QO0tBRlN0b0IsTUFBRW5LLEtBR0ksV0FSRmdILEdBS0ZoSCxHQUVYeXlCO0tBRU8sVUFBQSw0QkFKSXp5QjtLQUFBQTthQUVMZ3pCOztHQUlDO1lBR1h3ZSxnQkFBZ0IzaUMsSUFBSTdIO0lBQ2QsSUFBSkQsSUE3QkZ1cUMsWUE0QmdCemlDLElBQUk3SDtJQWpFcEJvcUMsWUFrRUVycUM7SUFDSixPQURJQTtHQUVIO1lBR0MwcUMsaUJBQWlCNWlDLElBQUk3SDtJQUNmLElBQUpELElBckJGd3FDLGFBb0JpQjFpQyxJQUFJN0g7SUF2RXJCb3FDLFlBd0VFcnFDO0lBQ0osT0FESUE7R0FFSDtZQUdDNnRCLFlBQVk3dEIsR0FBR0M7SUFDakI7S0FBSXdIO0tBQ0ErbkI7S0FDUyxNQUFBLDRCQUhDeHZCO0tBRU47O1NBQ1IvRzs7TUFDUSxZQUFBLFdBSlNnSCxHQUdqQmhILEdBSGMrRyxNQUdkL0c7O1dBR1NtSztnQkFKTG9zQixNQURBL25CLE9BTW9CLG1CQVBWekgsY0FNTG9EO09BTExxRSxTQUNBK25CLFFBSUtwc0I7T0FHTCw2QkFQQW9zQjs7TUFDSixVQUFBdjJCO2lCQUFBQTtNQUFBQTs7O1dBREl1MkIsU0FGVXh2QjtjQUNWeUg7a0JBQ0ErbkIsdUJBREEvbkIsU0FDQStuQjtHQVN3RTtZQUcxRTlCLFdBQVcxdEIsR0FBR0M7SUFBSSxPQWRsQjR0QixZQWNXN3RCLFlBQTZCL0csR0FBR21LLEdBQUssT0FBQSxXQUFsQ25ELEdBQTZCbUQsR0FBUTtHQUFDO1lBQ3BEMHFCLFdBQVc5dEIsR0FBSSxPQURmMHRCLFdBQ1cxdEIsaUJBQUksY0FBcUI7WUFPcENraUIsa0JBQWtCcFEsTUFBSzFRLElBQUdDO0lBQzVCLElBTjZCc2hCLEtBS0p2aEIsZUFMT3doQixLQUtKdmhCLHFCQUxDc2hCLE9BQUdDO2lCQUNoQyw4QkFJb0I5USxNQUxTNlEsSUFBR0M7R0FRaUI7WUFHL0NJLFVBQVU1aEIsSUFBR0MsSUFBSXBCO0lBTmpCaWlCLHVDQU1VOWdCLElBQUdDO0lBRUgsT0FBQTtvQkFGQUQsYUFFS25JLEdBQUUwckIsSUFBTSxPQUFLLFdBRlgxa0IsR0FFQTBrQixJQUZKdGpCLE9BRUVwSSxJQUE4QjtHQUFDO1lBRzlDaXZCLFNBQVM5bUIsSUFBR0MsSUFBSXBCO0lBWGhCaWlCLHNDQVdTOWdCLElBQUdDO0lBRU0sT0FBQTs7YUFGVEQ7c0JBRWNuSSxHQUFLLE9BQW9CLFdBRmhDZ0gsR0FBUG1CLE9BRWNuSSxJQUZYb0ksT0FFV3BJLElBQTBDO0dBQUM7WUFHbEVtcUIsVUFBVWhpQixJQUFHQyxJQUFJM0IsTUFBTU87SUFoQnZCaWlCLHVDQWdCVTlnQixJQUFHQztJQUVHLE9BdkpoQnFvQjthQXFKVXRvQjthQUFPMUI7c0JBRUl6RyxHQUFFc3ZCLElBQUdqNUIsR0FBSyxPQUFPLFdBRmYyUSxHQUVBc29CLElBQUdqNUIsR0FGYitSLE9BRVFwSSxJQUFrQztHQUFDO1lBR3hEMnFCLE9BQU81akIsR0FBR0M7SUFBSSxPQTdCZHl0QixXQTZCTzF0QixZQUE0QjFRLEdBQUssT0FBRyxXQUFqQzJRLEdBQXlCM1EsU0FBQUEsT0FBaUM7R0FBQztZQUNyRXE2QixRQUFRM3BCLEdBQUdDO0lBQUksT0E1Q2Y0dEI7YUE0Q1E3dEIsWUFBNkIvRyxHQUFFM0osR0FBSyxPQUFHLFdBQXBDMlEsR0FBMEJoSCxHQUFFM0osU0FBQUEsT0FBbUM7R0FBQztZQUczRTRTLE9BQU9sQyxHQUFHQztJQUNaO0tBQUloSCxRQUFRLDRCQURIK0c7S0FFTDZkO0lBRThDO2FBSDlDNWtCLFVBQ0E0a0I7TUFFQyxHQUFBLFdBSk81ZCxHQUFIRCxNQUNML0csUUFDQTRrQjtNQUU4Qyw2QkFIOUM1a0I7OztZQUNBNGtCOztHQUlHO1lBR0wyRyxRQUFReGtCLEdBQUdDO0lBQ2I7S0FBSWhILFFBQVEsNEJBREYrRztLQUVONmQ7SUFFaUQ7YUFIakQ1a0IsVUFDQTRrQjtNQUVDLEdBQUEsV0FKUTVkLEdBQ1RoSCxNQURNK0csTUFDTi9HLFFBQ0E0a0I7TUFFaUQsNkJBSGpENWtCOzs7WUFDQTRrQjs7R0FJRztZQUdMeEQsSUFBSXJhLEdBQUVvRCxHQUFHOU0sT0FBUSxPQWxCakI0TCxPQWtCSWxDLEdBQXlCLFdBQXBCMUosT0FBSDhNLElBQWdDO1lBRXRDYixRQUFRdkMsR0FBR0M7SUFDYjtLQUFJaEgsUUFBUSw0QkFERitHO0tBRU42ZDtJQUVxRDthQUhyRDVrQixRQUNBNGtCO01BRUssR0FBQSxXQUpJNWQsR0FBSEQsTUFDTi9HO09BR3FELDZCQUhyREE7OztNQUNBNGtCOzs7WUFBQUE7O0dBSUc7WUFHTDBHLFNBQVN2a0IsR0FBR0M7SUFDZDtLQUFJNkIsU0FETzlCO0tBRVAvRyxRQUFRLDRCQURSNkk7S0FFQStiO0lBRXdEO2FBSHhENWtCLFFBQ0E0a0I7TUFFSyxHQUFBLFdBTEs1ZCxHQUVWaEgsTUFGTytHLE1BRVAvRztPQUd3RCw2QkFIeERBOzs7TUFDQTRrQjs7O1lBQUFBOztHQUlHO1lBR0wyRixZQUFZcGlCLElBQUdDLElBQUlwQjtJQWhFbkJpaUIseUNBZ0VZOWdCLElBQUdDO0lBRVQ7S0FBSnBJLFFBQVEsNEJBRkVtSTtLQUdWeWM7SUFFa0U7YUFIbEU1a0IsVUFDQTRrQjtNQUVDLEdBQUEsV0FMZ0I1ZCxHQUFQbUIsT0FFVm5JLE9BRmFvSSxPQUVicEksUUFDQTRrQjtNQUVrRSw2QkFIbEU1a0I7OztZQUNBNGtCOztHQUlHO1lBR0x5RixhQUFhbGlCLElBQUdDLElBQUlwQjtJQTFFcEJpaUIsMENBMEVhOWdCLElBQUdDO0lBRVY7S0FBSnBJLFFBQVEsNEJBRkdtSTtLQUdYeWM7SUFFeUU7YUFIekU1a0IsUUFDQTRrQjtNQUVLLEdBQUEsV0FMYTVkLEdBQVBtQixPQUVYbkksT0FGY29JLE9BRWRwSSxRQUd5RSw2QkFIekVBO01BQ0E0a0I7OztZQUFBQTs7R0FJRztZQUdMdm5CLE1BQU1BLE9BQU04SyxJQUFHQztJQUFLLFVBQVJELGtCQUFHQztpQkFWZmlpQixhQVVZbGlCLElBQUdDLElBQVQvSztHQUFrRTtZQUd4RXEwQyxZQUFZM3FDLEdBQUdDO0lBQ2pCLElBQWEsTUFBQSw0QkFEQ0Qsa0JBQ2Q7O1NBQUEvRzs7TUFEYytHLE1BQ2QvRyxLQUNpQixXQUZBZ0gsR0FBSEQsTUFDZC9HO01BQ0UsVUFERkE7aUJBQUFBO01BQUFBOzs7O0dBRUk7WUFHYzJ4QyxlQUFlNXFDLEdBQUdDLEdBQUc0cUMsVUFBVUM7SUFDakQsSUFBSWhwQyxTQUQ2QjlCO0lBRWpDLFNBREk4QixRQUVDLE9BQUEsV0FINENncEM7SUFLdkMsSUFBSjd4QyxZQUNBOHhDLGdCQUNBQyxrQkFQMkJockM7O1VBTTNCK3FDLFlBREE5eEMsT0FKRjZJO01BUVksSUFBUmt1QixRQVR5Qmh3QixNQUszQi9HO01BS0MsR0FBQSxXQVY2QmdILEdBSzlCaEgsTUFJRSsyQjtPQUZGZ2IsaUJBRUVoYjtPQUhGK2E7OztPQVFHLDZCQVRIOXhDOzs7WUFDQTh4QzswQkFOaUNGLFVBS2pDNXhDLE1BRUEreEM7ZUFTbUQsV0FoQlJGOztHQWdCd0I7WUFHdkU3bUIsTUFBTWprQixHQUFHQztJQUNYLE9BcEJrQjJxQzthQW1CVjVxQzthQUFHQztzQkFJT2hILEdBQUcrMkIsT0FBUyxlQUFaLzJCLEdBQUcrMkIsUUFBd0I7NkJBQ2xCLFNBQUk7R0FBQztZQUc5QjdMLFVBQVVua0IsR0FBR0M7SUFDZixPQTVCa0IycUM7YUEyQk41cUM7YUFBR0M7c0JBSUdoSCxHQUFHKzJCLE9BQVMsV0FBWi8yQixHQUFHKzJCLE9BQWlCOztjQUNYLE1BQUE7YUFBdUQ7R0FBQztZQUdqRmhNLFNBQVNoa0IsR0FBR0M7SUFDZCxPQXBDa0IycUM7YUFtQ1A1cUM7c0JBR0QvRyxHQUFHM0osR0FBSyxPQUFBLFdBSEoyUSxHQUdEM1EsR0FBUTs2QkFDRTBnQyxPQUFTLE9BQVRBLE1BQWM7O2NBQ1YsTUFBQTthQUFzRDtHQUFDO1lBR2hGaFgsS0FBS2haLEdBQUdDO0lBQWUsVUF4QnZCZ2tCLE1Bd0JLamtCLFlBQW1DL0csR0FBRzNKLEdBQUssT0FBQSxXQUF4QzJRLEdBQW1DM1EsR0FBUTtJQUFNLE9BQUE7Ozs2QkFBQSxJQUFVQSxjQUFNLE9BQU5BLEVBQVE7R0FBQTtZQUUzRXlwQixTQUFTL1ksR0FBR0M7SUFDZCxJQUFJNkIsU0FETzlCO0lBRVgsU0FESThCLFFBRUM7SUFFSyxJQUFKN0ksWUFDQSt4Qzs7UUFDRSw0QkFERkEsbUJBREEveEMsT0FKRjZJO01BT1ksSUFBUmt1QixRQVJHaHdCLE1BS0wvRztNQUNBK3hDLGlCQUdhLFdBVEwvcUMsR0FRTit2QjtNQUVKLDZCQUxFLzJCOzs7WUFDQSt4Qzs7R0FNUztHQUlDO0lBQVpubkI7WUFERkMsYUFFZTlqQixHQUFHQztJQUNaLFlBbEJOOFksU0FpQmUvWSxHQUFHQztnQkFFUixNQUFBLDRCQUhSNGpCO1FBSUt2MEI7SUFBSyxPQUFMQTtHQUFNO1lBTWI4MEIsVUFBVXBrQixHQUFHQztJQUNmLElBQUk2QixTQURROUI7SUFFWixTQURJOEIsUUFFQztJQUVLLElBQUo3SSxZQUNBK3hDOztRQUNFLDRCQURGQSxtQkFEQS94QyxPQUpGNkk7TUFPWSxJQUFSa3VCLFFBUklod0IsTUFLTi9HO01BQ0EreEMsaUJBR2EsV0FUSi9xQyxHQUtUaEgsTUFHRSsyQjtNQUVKLDZCQUxFLzJCOzs7WUFDQSt4Qzs7R0FNUztHQUlDO0lBQVpqbkI7O1lBREZPLGNBRWdCdGtCLEdBQUdDO0lBQ2IsWUFsQk5ta0IsVUFpQmdCcGtCLEdBQUdDO2dCQUVULE1BQUEsNEJBSFI4akI7UUFJS3owQjtJQUFLLE9BQUxBO0dBQU07WUFNYnE4QiwyQkFBMkIzckIsR0FBRzFKO0lBQ2hDLElBQUlrYyxJQUR5QnhTO0lBRTdCLFFBREl3UyxHQUVDO0lBRVUsSUFBVHFMLGlCQUNBNWtCLFlBQ0FpMEIsV0FQdUJsdEI7O1FBTXZCL0csUUFMRnVaLFVBSUVxTDtLQUlRLElBQU5pbkIsTUFUcUI5a0MsTUFNdkIvRztLQUlDLEdBQUEsV0FWeUIzQyxPQVN4Qnd1QyxLQUZGNVg7TUFGQXJQLG9CQUVBcVAsU0FFRTRYO01BSEY3ckMsT0FMRnVaOztVQU1FMGEsVUFFRTRYLEtBT0YsNkJBVkE3ckM7O0dBWUk7WUFHUjJ3QixPQUFPNXBCLEdBQUdDO0lBQ1osU0FEU0QsY0FFSjtJQUVLO0tBQUp5SCxRQUpHekg7S0FLTSxNQUFBLDRCQUxOQTtLQUlDOztTQUNSL0c7O01BREl3TyxPQUVHLFdBTkd4SCxHQUlOd0gsTUFKR3pILE1BS1AvRztNQUFBLFVBQUFBO2lCQUFBQTtNQUFBQTs7O0lBR0EsV0FKSXdPO0dBSUk7WUFHUm9pQixXQUFXN3BCLEdBQUdDO0lBQ1YsWUFaSjJwQixPQVdXNXBCLEdBQUdDO2dCQUVOLE9BQUE7UUFDSHNPO0lBQUssT0FBTEE7R0FBTTs7SUFHWDBROzs7O1lBRUEwUyxtQkFBcUI5ckIsS0FBcUM3RjtJQUM1RCxHQUR1QjZGO1NBQWVDLE1BQWZELFFBQUFxWixlQUFlcFo7O1NBQWZvWjtJQUNwQixHQXJjRG5MLFNBb2MwRC9UO0tBRXZELE9BQUE7SUFDRyxVQUFBLCtCQUhla2YsY0FBcUNsZjtJQUd2RCx3QkFIdURBO0dBR1g7WUFHL0M0eEIsZUFBaUIvckIsS0FBcUM3RjtJQUN4RCxHQURtQjZGO1NBQWVDLE1BQWZELFFBQUFxWixlQUFlcFo7O1NBQWZvWjtJQUNuQixJQUFJLGNBUEZ5Uyx1QkFNaUJ6UyxlQUFxQ2xmLEtBQ3BEO2VBQ0c7R0FBSTtZQUdUc3BCLElBQUlsb0IsSUFBR0M7SUFDVCxPQURNRCxrQkFBR0M7O2tCQXRPUDZtQixTQXNPSTltQixJQUFHQyxhQUM2RHNqQixJQUFHQyxJQUFNLFdBQVRELElBQUdDLElBQVk7R0FBRTtZQUdyRnlFLFFBQVFqb0IsSUFBR0M7SUFDYixPQURVRCxrQkFBR0M7Y0FFUjtjQTVPSDZtQixTQTBPUTltQixJQUFHQyxhQUdlc2pCLElBQUdDLElBQU0sV0FBVEQsSUFBR0MsSUFBWTtHQUFDO1lBRzFDM2lCLE1BQU1qQztJQUNSLElBQUl3UyxJQURJeFM7SUFFUixTQURJd1MsR0FFQztJQUVRO0tBQUEseUJBTEx4UztLQUtDelE7S0FBSEQ7S0FDQTI3QyxPQUFPLG1CQUxUejRCLEdBSUVsakI7S0FFQTQ3QyxPQUFPLG1CQU5UMTRCLEdBSUtqakI7S0FHTSxNQUFBLDRCQVBYaWpCO0tBTVM7O1NBQ1h2Wjs7TUFDYTtPQUFBLDJCQVRQK0csR0FRTi9HLE9BQUFBO09BQ1NpYjtPQUFIbUM7TUFDSixpQkFKRTQwQixNQUVKaHlDLE9BQUFBLEtBQ01vZDtNQUVKLGlCQUpFNjBCLE1BQ0pqeUMsT0FBQUEsS0FDU2liO01BRFQsVUFBQWpiO2lCQUFBQTtNQUFBQTs7O0lBS0EsV0FQSWd5QyxNQUNBQztHQU1PO1lBR1hDLFlBQVluckMsR0FBRzNKO0lBQ1IsSUFBTCtLLEtBQUssaUJBREtwQjtJQWpmWjhwQyxhQWtmRTFvQyxJQURhL0s7SUFFakIsT0FESStLO0dBRUY7WUFHQWdxQyxjQUFjcHJDLEdBQUdDO0lBQ25CO0tBQUlrTztPQUFPOztTQURLbk87a0JBQ1UvRyxHQUFFM0osR0FBSyxPQUFHLFdBRGpCMlEsR0FDT2hILEdBQUUzSixTQUFBQSxTQUFBQSxHQUFzRDtLQUM5RSs3QztPQTNSRjNkO1NBMFJFdmY7O1VBRWlCLG1CQUVIO2NBRE43ZTtVQUFLLFdBQUxBO1NBQ1c7S0FFbkJnOEM7T0FoU0Y1ZDtTQTBSRXZmOztVQU9pQixtQkFDSjtjQUNKN2U7VUFBSyxXQUFMQTtTQUFZO0lBRXpCLFdBVkkrN0MsT0FLQUM7R0FLUztZQUdYbmQsYUFBYW51QixHQUFHQztJQUFJLE9BZnBCbXJDLGNBZWFwckMsWUFBK0IvRyxHQUFHM0osR0FBSyxPQUFBLFdBQXBDMlEsR0FBK0IzUSxHQUFRO0dBQUM7WUFDeEQrN0IsS0FBS3JyQjtJQUFPLFVBQUEsNEJBQVBBO0lBQUksd0JBQUpBO0dBQW9CO1lBSXpCdXJDLG9CQUFvQnZyQztJQUN0QixPQUFnQzs7O3NCQUFLL0c7Y0FDbkMsR0FGb0IrRyxnQkFDZS9HLEdBQ2I7Y0FBb0QsVUFBQSw0QkFEdkNBO2NBQ1csNEJBRjFCK0csR0FDZS9HLE9BQUFBO2FBQzZDO0dBQUM7WUFHakZ1eUMsWUFBWXhyQyxHQUFJLE9BTGhCdXJDLG9CQUtvQyxpQkFBeEJ2ckMsSUFBZ0M7WUFFNUNteEIsa0JBQWtCL3ZCLElBQUdDO0lBQ3ZCLEtBM2dCRTBTLFNBMGdCa0IzUyxTQTFnQmxCMlMsU0EwZ0JxQjFTO0tBS3JCO01BRElzaEIsS0FKY3ZoQjtNQUtkd2hCLEtBTGlCdmhCO01BTWtCLHVCQU5sQkE7TUFNUywyQkFOWkQ7TUFNZHBCLElBQUksbUJBQVksNEJBRmhCMmlCLElBQ0FDO01BRUFuYjtNQUNVLE1BQUEsNEJBSlZrYjtNQUdJOztVQUNSOG9COztPQUNnQixJQUFBLE1BQUEsNEJBSlo3b0IsUUFJRjs7WUFBQThvQjs7U0FDcUI7VUFBQSx1QkFWRnJxQyxJQVNuQnFxQyxRQUFBQTtVQUNZLDJCQVZJdHFDLElBUWxCcXFDLFFBQUFBO2dCQURJaGtDO1NBR0EsaUJBSkF6SDtTQUtBLDZCQUpBeUg7U0FJQSxVQUZGaWtDO29CQUFBQTtTQUFBQTs7O09BREYsVUFBQUQ7a0JBQUFBO09BQUFBOzs7S0FNQSxPQVJJenJDOztJQUpEO0dBWUQ7WUFHRmd5QixVQUFVMlo7SUFDWixTQURZQSxlQUVQO0lBR2dCLElBRGZDLFFBSk1ELGVBS05FLHlCQUxNRjtJQU1QLE9BMVNIenBDLE9Bb1NVeXBDLGFBTVczckMsR0FBSyxPQUFMQSxpQkFEakI2ckMsY0FDdUM7OztjQUVqQzs7Z0JBSE5BO3lCQUcwQkM7aUJBQUssT0FBYzs7MEJBSjdDRjttQ0FJa0RHOzJCQUFLLHlDQVJqREosSUFRNENJLE9BQUFBLElBQXhCRDt3Q0FBQUE7MEJBQXVDO2dCQUFDO0dBQUc7WUFHekUvWSxjQUFjNFk7SUFDVixZQVpKM1osVUFXYzJaO2dCQUVOLE9BQUE7UUFDSEs7SUFBTyxPQUFQQTtHQUFVO1lBTVhDLGdCO1lBQ0FucUMsWTs7d0RBREFtcUMsT0FDQW5xQzs7OztZQU1Bc1gsYztZQUVBK2lCLFlBQWFoOUIsS0FBSWE7SUFDbkIsU0FEZWIsS0FFVjtJQUVLLE9BSlNhO0tBS0wsT0FBQSxtQkFMQ2Isc0JBQUlhO0lBSWpCLE1BQUE7R0FDa0I7O0lBR2xCaVE7O21DQVJBa3NCLGFBRkEvaUIsVUFVQW5KOzs7Ozs7WUFHSnBHLFVBQVVvdUIsYUFBWWo0QjtJQUFJLE9BQUEsaUJBQUpBLEdBQVppNEI7R0FBcUM7Ozs7T0EzMUIvQzVoQztPQUNBcWE7T0FDQTVHO09BRUNGOzs7T0E2aEJEeVE7T0F6UUF0Rzs7O09Ba0ZBd0U7T0FDQUc7T0FvS0F4VztPQW9CQUs7T0F2TEE2VjtPQUNBQztPQWlSQVc7T0FFQUQ7O09BeldBRTtPQXVGQUw7T0FDQUU7T0E0ZUFqUDs7Ozs7O09BdGdCQXVnQzs7Ozs7Ozs7Ozs7O09BRUF0aUI7T0FrQ0EwQjtPQTFCQXhCO09Ba0NBeUI7OztPQWhCQUM7O09BakdBb2dCOztPQVVBdFk7T0FZQUM7T0FZQTFHO09BOEZBSDtPQUNBQztPQXFZQXNEO09BZkFpZDtPQTJCQWphO09BaUJBYTtPQVdBZTtPQS9VQWpGO09BREFKO09BZEFHO09BNEVBdEo7T0FwQkFDO09BNUlBK0k7T0FnSEF2SztPQUtBa0Y7T0FLQTlFO09BMERBRTtPQVZBRTtPQTNDQUk7T0FDQStGOztPQXpIQTBnQjtPQVVBcG5DO09BTUFxbkM7T0FxQkFDO09BY0FDO09BY0FDO09BTUFDO09BbUhBQztPQXlDQTNtQjtPQXlCQUY7T0F6Q0FHO09BUUFFO09BNENBQztPQWVBRTtPQVdBcUg7T0FxQkEvQjtPQVdBQztPQU1BNUs7T0FRQTJTO09BTkFEO09BV0FySTtPQUlBRDtPQU1BcG5CO09BZ0JBa3BDO09Bc0JBOWY7T0E3TUEvMEI7T0FzTkFrMUM7T0FMQUQ7Ozs7RTs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7WUN0eEJBMWhDLFVBQVU3SjtJQUFJO09BQVEsYUFBWkE7SUFBSSxNQUFBO0dBQW9FO1lBQ2xGOEIsWTtZQUVBZ0ksVUFBVTlKO0lBRWE7Ozs7WUFBNkIseUJBRjFDQTtJQUNaLFdBQ0U7R0FBb0Y7T0FHcEZrc0M7WUFJQUMsWUFBYWh0QztJQUFNLGtDQUFOQSxLQUpiK3NDO0dBSTZDO09BQzdDaEw7WUFTQW52QixJQUFJL1IsR0FBRS9HLEdBS1Isd0JBTE0rRyxHQUFFL0csT0FBQUEsR0FLc0U7WUFHNURtekMsV0FBV3BzQyxHQUFFL0csR0FHL0IsT0FINkIrRyxNQUFFL0csR0FJa0Q7WUFHL0RvekMsNEJBQTRCcnNDLEdBQUUvRyxHQUFFcXpDLEtBQUp0c0MsTUFBRS9HLEtBQUVxekMsY0FTTTtZQUd0Q0MscUJBQXFCdnNDLEdBQUUvRyxHQUFFcXpDO0lBRTNDLGlCQUZ1Q3RzQyxHQUFFL0csT0FBQUEsS0FBRXF6QztJQUUzQztHQUN5RDtZQUd2Q0UsK0JBQXNDeHNDLEdBQUUvRyxHQUFFeWlCLE9BQUoxYixNQUFFL0csS0FBRXlpQjtHQUVxQjtZQVMvRXlyQixJQUFJbm5DLEdBQUUvRyxHQUFFcXpDO0lBR0ksSUFBVkcsVUEvQ0YxNkIsSUE0Q0kvUixHQUFFL0c7Y0FHSnd6QywrQkFITUg7S0FLTCxPQWhCYUUsK0JBV1p4c0MsR0FBRS9HLEdBQUVxekM7SUFNRSxjQUFBLDZCQUhSRyxTQUhNSDtpQkE3QlFELDRCQTZCWnJzQyxHQUFFL0csR0FBRXF6QztHQU84QjtZQUd0QkksV0E5Q1cxc0MsR0FBRS9HLEdBOENFcXpDO0lBQ2pDLElBQUlHLFVBL0N5QnpzQyxNQUFFL0c7Y0ErQzNCd3pDLCtCQUQ2Qkg7S0FHNUIsT0F4QmFFLCtCQXpCV3hzQyxHQUFFL0csR0E4Q0VxekM7SUFJckIsY0FBQSw2QkFIUkcsU0FENkJIO2lCQXZDZkQsNEJBUFdyc0MsR0FBRS9HLEdBOENFcXpDO0dBS087WUFHdEJLLCtCQXREVzNzQyxHQUFFL0csR0FzRHdCcXpDO0lBQ3ZELElBQUlHLFVBdkR5QnpzQyxNQUFFL0c7Y0F1RDNCd3pDLCtCQURtREg7S0FHbEQsT0FoQ2FFLCtCQXpCV3hzQyxHQUFFL0csR0FzRHdCcXpDO0lBSWxELE9BbkRhRCw0QkFQV3JzQyxHQUFFL0csR0FzRHdCcXpDO0dBSWY7WUFHdEM5ckMsS0FBS1IsR0FBRS9HLEdBQUV3SDtJQUNYLElBQUkyQyxJQXRFRjJPLElBcUVLL1IsR0FBRS9HLElBRUxvSyxJQXZFRjBPLElBcUVLL1IsR0FBSVM7SUFmT2lzQyxXQWVYMXNDLEdBQUUvRyxHQUVMb0s7SUFDSixPQWxCa0JxcEMsV0FlWDFzQyxHQUFJUyxHQUNQMkM7R0FHWTtZQUdkbEUsT0FBUUMsS0FPSjdQO0lBTE47T0FBRyxhQUtHQSxZQUpELE9BQUEsMkJBSEs2UCxLQU9KN1A7SUFESTtLQUFKMFEsSUE1Rkptc0MsWUFzRlFodEM7S0FRSyxNQUFBLDRCQVJMQTtLQU9SOztTQUNBbEc7O01BckVnQm96Qyw0QkFtRVpyc0MsR0FFSi9HLEdBREkzSjtNQUVGLFVBREYySjtpQkFBQUE7TUFBQUE7OztJQUdBLE9BTEkrRztHQUtGO1lBR0YybEMsVUFBVTJHLEtBQU0sT0FkaEJwdEMsVUFjVW90QyxLQUF1QjtZQUdqQ00sK0JBQWtDNXNDLEdBQUUvRyxHQUFFcXpDO0lBQ3hDLGNBRHdDQTtjQTVEdEJFLCtCQTREa0J4c0MsR0FBRS9HLEdBQUVxekM7Y0E5RXRCRCw0QkE4RWtCcnNDLEdBQUUvRyxHQUFFcXpDO0dBTUg7WUFHbkNPLGVBOUYyQjdzQyxHQUFFL0csR0E4RlZ5aUI7SUFDckIsSUFBSSt3QixVQS9GeUJ6c0MsTUFBRS9HO2tCQStGM0J3ekM7Y0F0RWNELCtCQXpCV3hzQyxHQUFFL0csR0E4RlZ5aUI7Y0F2Rkgyd0IsNEJBUFdyc0MsR0FBRS9HLEdBOEZWeWlCO0dBSW1DO1lBR3REb3hCLHdCQXJHMkI5c0MsR0FBRS9HO0lBc0cvQixJQUFJd3pDLFVBdEd5QnpzQyxNQUFFL0csc0JBc0czQnd6QztpQkEvRmNKLDRCQVBXcnNDLEdBQUUvRztHQXVHd0Q7WUE2QmpGZ1gsWUFwSXVCMnJCLEtBNEdUQyxTQUFTQyxLQUFLQyxTQUFTNThCO0lBUTNDLEdBUmtDNDhCLFVBQWRGO0tBVUwsSUFBQSxNQUFBLDRCQVY0QjE4QixTQVV6Qzs7VUFBQWxHOztPQUMrQyxJQXZIbEI2TCxNQXVIa0IsNEJBWDdCKzJCLFNBVWxCNWlDLFVBdEgyQjJpQyxRQUFFOTJCO09BOENiNG5DLFdBOERXNVEsS0FXViw0QkFYZUMsU0FVaEM5aUM7T0FDRSxVQURGQTtrQkFBQUE7T0FBQUE7Ozs7O0lBSVEsVUFBQSw0QkFkaUNrRzs7U0FjekN5dUI7O01BQytDLElBM0hsQm1mLE1BMkhrQiw0QkFmN0JsUixTQWNsQmpPLFlBMUgyQmdPLFFBQUVtUjtNQThDYkwsV0E4RFc1USxLQWVWLDRCQWZlQyxTQWNoQ25PO01BQ0UsVUFERkE7ZUFBQUE7TUFBQUE7Ozs7R0FFSTs7MkNBekpKOXJCLFFBV0FxcUMsYUFzSklsOEI7Ozs7OztZQUdKelEsS0FBS284QjtJQUNHLElBQU5FLE1BMUpGcVEsWUF5Skt2UTtJQUVQLGtCQUZPQSxXQUNIRTtJQUNKLE9BRElBO0dBRUQ7Ozs7T0FyS0RoeUI7Ozs7OztPQUhBRDtPQWtHQTNLO09BdEZBaXRDO09BeUpBM3NDO09BckRBbW1DO09BbkdBekU7T0FaQXAvQjtPQXFCQWlRO09BUWdCcTZCO09Bb0NoQmpGO09BVWdCdUY7T0FlaEJsc0M7T0ExQ2dCK3JDO09Ba0VoQks7T0E1RGdCSjtPQXFFaEJLO09BeENnQkY7T0EvQ0FOO09BOEZoQlM7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNwSUY1TDtZQUNBOEwsNEJBdUJpQzd0QztJQUFNLE9BQUEsOEJBQU5BO0dBQWdDO1lBdEJqRTh0QyxpQkF1QnNCOXRDLEtBQU0sT0FBQSw4QkFBTkEsS0FBZ0M7WUF0QnRERCxPQXVCWUMsS0FBSTdQLEdBQUksT0FBQSw4QkFBUjZQLEtBQUk3UCxHQUEyQztZQXRCM0RxMkMsVUF1QmNyMkMsR0FBSSxPQUFBLCtCQUFKQSxHQUF5QztZQXBCdkRrUixLQXFCU1IsR0FBRS9HLEdBQUV3SCxHQUFJLE9BQUEsK0JBQVJULEdBQUUvRyxHQUFFd0gsR0FBd0I7WUF2QnJDc1IsSUF3QlEyZixLQUFJejRCLEdBQUksT0FBQSwrQkFBUnk0QixLQUFJejRCLEdBQXNDO1lBdkJsRGt1QyxJQXdCUXpWLEtBQUl6NEIsR0FBRTNKLEdBQUksT0FBQSwrQkFBVm9pQyxLQUFJejRCLEdBQUUzSixHQUF5QztZQXRCdkQ4OEMsV0F1QmUxYSxLQUFJejRCLEdBQUksT0FBQSwrQkFBUnk0QixLQUFJejRCLEdBQTZDO1lBdEJoRXl6QyxXQXVCZWhiLEtBQUl6NEIsR0FBRTNKO0lBQUksT0FBQSwrQkFBVm9pQyxLQUFJejRCLEdBQUUzSjtHQUFnRDtZQXJCckV1OUMsZUFzQm1CbmIsS0FBSXo0QixHQUFFM0o7SUFBSSxPQUFBLCtCQUFWb2lDLEtBQUl6NEIsR0FBRTNKO0dBQW9DO1lBckI3RGs5QywrQkF1QjBDOWEsS0FBSXo0QixHQUFFM0osR0FDOUMsT0FBQSwrQkFEd0NvaUMsS0FBSXo0QixHQUFFM0o7R0FDUztZQXZCekRzOUMsK0JBMEJzQ2xiLEtBQUl6NEIsR0FBRTNKLEdBQzFDLE9BQUEsK0JBRG9Db2lDLEtBQUl6NEIsR0FBRTNKO0dBQ3lCOztJQXhCckV3UztJQThJTW1PO0lBNUlOelE7WUFSQW10QywrQkFxQ3FDM3NDLEdBQUUvRyxHQUFFM0osR0FDdkMsT0FBQSwrQkFEbUMwUSxHQUFFL0csR0FBRTNKO0dBQ3lCO1lBbENsRSs4Qyw0QkFxQ2dDcnNDLEdBQUUvRyxHQUFFM0o7SUFDbEMsT0FBQSwrQkFEOEIwUSxHQUFFL0csR0FBRTNKO0dBQ3lCO1lBckM3RGk5QyxxQkF3Q3lCdnNDLEdBQUUvRyxHQUFFM0o7SUFBSSxPQUFBLCtCQUFSMFEsR0FBRS9HLEdBQUUzSjtHQUF3RDs7SUFwQ3JGdzlDOzs7O1lBMENFampDLFVBQVU3SjtJQUFJO09BQVEscUJBQVpBO0lBQUksTUFBQTtHQUFvRTtZQUVsRk4sS0FBS3NELEdBQUcvQztJQUNWLE9BRE8rQyxHQUVGLE9BQUE7SUFFTztLQUFORSxNQWxFTjhwQyw0QkE4RE9ocUM7S0FLUSxNQUFBLDRCQUxSQTtLQUlLOztTQUNWL0o7O01BM0RGeXpDLFdBMERNeHBDLEtBQ0pqSyxHQUNtQixXQU5YZ0gsR0FLUmhIO01BQ0UsVUFERkE7aUJBQUFBO01BQUFBOzs7SUFHQSxPQUpJaUs7R0FJQTtZQUdKZ3FDLFNBQVN4YjtJQUFNLE9BWGZoeUIsS0FXU2d5Qiw4QixPQUFBQTtHQUF1RDtZQUNoRXJ4QixJQUFJK0MsR0FBR25EO0lBQUksT0FaWFA7YUFZaUQsV0EzRG5Eb0MsUUEyRE1zQjtzQkFBb0JuSyxHQUFLLE9BQUUsV0FBeEJnSCxHQW5FVG1zQyxXQW1FTWhwQyxHQUFvQm5LLElBQXVCO0dBQVk7WUFDM0RxSCxLQUFLOEMsR0FBR25EO0lBQUksT0FiWlA7YUFhb0QsV0E1RHREb0MsUUE0RE9zQjtzQkFBb0JuSyxHQUFLLE9BQUksV0FBMUJnSCxHQUFpQmhILEdBcEUzQm16QyxXQW9FT2hwQyxHQUFvQm5LLElBQXlCO0dBQVk7WUFFOURrSCxLQUFLaUQsR0FBR25EO0lBQ1Y7S0FBYSxNQUFBLFdBL0RiNkIsUUE4RE9zQjtLQUNNLE1BQUE7S0FBYjs7U0FBQW5LOztNQUNFLFdBRlFnSCxHQXRFVm1zQyxXQXNFT2hwQyxHQUNQbks7TUFDRSxVQURGQTtpQkFBQUE7TUFBQUE7Ozs7R0FFSTtZQUdGbUgsTUFBTWdELEdBQUduRDtJQUNYO0tBQWEsTUFBQSxXQXJFYjZCLFFBb0VRc0I7S0FDSyxNQUFBO0tBQWI7O1NBQUFuSzs7TUFDRSxXQUZTZ0gsR0FDWGhILEdBN0VBbXpDLFdBNEVRaHBDLEdBQ1JuSztNQUNFLFVBREZBO2lCQUFBQTtNQUFBQTs7OztHQUVJO1lBR0Z5d0IsTUFBTXRtQixHQUFHMUQsTUFBTU87SUFDakI7S0FBSXVZLFVBRE85WTtLQUVFLE1BQUEsV0E1RWJvQyxRQTBFUXNCO0tBRUssTUFBQTtLQURIOztTQUNWbks7O01BQ2tCLFVBckZsQm16QyxXQWtGUWhwQyxHQUVSbks7TUFESXVmLFNBRUssV0FIUXZZLEdBRWpCaEgsR0FESXVmO01BQ0osVUFBQXZmO2lCQUFBQTtNQUFBQTs7O1dBREl1ZjtHQUlBO1lBR0YxWSxRQUFRRTtJQUF5QixVQUFBLFdBbEZuQzhCLFFBa0ZVOUI7SUFBaUIsT0FBQSw4QyxPQTdGM0IrUixJQTZGVS9SO0dBQW1DO1lBRTNDSixRQUFRb0Q7SUFDVjtLQUFJN0QsTUFBTSx5QkFEQTZEO0tBRU5FLE1BckdKOHBDLDRCQW9HSTd0QztJQUVKLDBCQUhVNkQsWUFHVy9KLEdBQUUzSixHQUFLLE9Bakc1QjYzQyxJQWdHSWprQyxLQUNpQmpLLEdBQUUzSixHQUFnQjtJQUF2QyxPQURJNFQ7R0FFRDtZQUtEK1YsU0FBU2paO0lBQWUsVUFBQSxXQTdGMUI4QixRQTZGVzlCO0lBQTZCLE9BQUE7MkNBQUsvRyxHQUFLLE9BckdsRG16QyxXQXFHV3BzQyxHQUFrQy9HLEdBQW1CO0dBQUM7WUFFL0RpSixPQUNXbEMsR0FBR0M7SUFBaEI7S0FHVyxNQUFBLFdBbkdYNkIsUUFnR2E5QjtLQUFLNHRCLE1BR1I7S0FIUTMwQixJQUFBMjBCO0lBQ2hCO1lBRGdCMzBCLEdBQ0Y7S0FBVyxVQUFBLFdBRFhnSCxHQXhHaEJtc0MsV0F3R2Fwc0MsR0FBSy9HO0tBQ1MsUUFBQTtLQUFnQyxJQUR6QzZMLE1BQ3lDLDRCQUR6QzdMO0tBQUFBLElBQUE2TDs7R0FHTTtZQUd0QnZDLFFBQ1d2QyxHQUFHQztJQUFoQjtLQUNXLE1BQUEsV0F4R1g2QixRQXVHYTlCO0tBQUs0dEIsTUFDUjtLQURRMzBCLElBQUEyMEI7SUFBSTtZQUFKMzBCLEdBQWtCO0tBQVUsVUFBQSxXQUE5QmdILEdBL0doQm1zQyxXQStHYXBzQyxHQUFLL0c7S0FBNEIsVUFBQTtLQUFnQyxJQUE1RDZMLE1BQTRELDRCQUE1RDdMO0tBQUFBLElBQUE2TDs7R0FDTTtZQUd0Qm9qQixTQUFTOW1CLElBQUdDLElBQUlwQjtJQUNSLElBQU5kLE1BQU0sV0E1R1YyQyxRQTJHV1Y7T0FFUixXQTdHSFUsUUEyR2NULFFBQ1ZsQztLQUNxQjtJQUNiLE9BL0RWTzthQTZERVA7c0JBRWFsRztjQUF5QixVQXRIMUNtekMsV0FtSGMvcUMsSUFHR3BJO2NBQXlCLE9BQUEsV0FIeEJnSCxHQW5IbEJtc0MsV0FtSFdockMsSUFHTW5JO2FBQTBDO0dBQUM7WUFHMUQyUSxlQUEyQnVqQztJQUdBLFVBQUEsMEJBSEFBO0lBR0EsT0FBQTtHQUE4Qjs7Ozs7WUF2QnpEbDBCLFVBbkNBaTBCOzs7O1lBNEVJL1EsWUFBYWg5QixLQUFJYTtJQUNuQixTQURlYixZQXRKbkIraEM7SUEwSmMsT0FBQSxXQTFJZHAvQixRQXNJdUI5QixJQUtMLE9BeEpsQmQsT0FtSm1CQyxLQWpKbkI0UyxJQWlKdUIvUjtJQUlqQixNQUFBO0dBQ3NCOzs7bUNBTHRCbThCLGFBdElOcjZCLFFBOElNbU87Ozs7OztZQUdKbFEsS0FBS0MsR0FBR04sTUFBTU87SUFDaEI7S0FBSXdILFFBRE0vSDtLQUVHLE1BQUEsV0FuSmJvQyxRQWlKTzlCO0tBRU0sTUFBQTtLQURMOztTQUNSL0c7O01BQ1ksVUE1SlptekMsV0F5Sk9wc0MsR0FFUC9HO01BREl3TyxPQUVHLFdBSFN4SCxHQUNad0g7TUFDSixVQUFBeE87aUJBQUFBO01BQUFBOzs7V0FESXdPO0dBSUY7WUFHQW1SLFFBQVE1WSxHQUFHM0o7SUFBVSxPQUFBLDhCQVJyQjBKLE1BUVFDLEdBQUczSjtHQUE0QztZQUN2RHlpQixRQUFROVksR0FBRzNKO0lBQVUsT0FBQSw4QkFUckIwSixNQVNRQyxHQUFHM0o7R0FBNEM7WUFHdkRBLFFBQVFnUixhQUFZakUsR0FBRUM7SUFDeEIsR0FBRyw2QkFEbUJELEdBQUVDLElBRW5CO0lBRVM7S0FBUmlFLFFBQVEsV0FqS2R4RixRQTZKc0JzQjtLQUtoQm1FLFFBQVEsV0FsS2R6RixRQTZKd0J1QjtLQU1sQm1FLCtCQUZBRixPQUNBQztJQUVKLFNBRElDLEtBRUMsT0FGREE7UUFJV3ZPO0lBQ1g7UUFEV0EsTUFOWHFPLE9BUUs7S0FFSztNQUFKdEUsSUFuTFpvcEMsV0FxS3NCaHBDLEdBVUxuSztNQUtMd08sSUFwTFoya0MsV0FxS3dCL29DLEdBVVBwSztNQU1MaUssTUFBTSxXQWhCUm1FLGFBY0VyRSxHQUNBeUU7S0FFSixTQURJdkUsS0FDYSxPQURiQTtLQUMyQixJQVB0QjRCLE1BT3NCLDRCQVB0QjdMO0tBQUFBLElBQUE2TDs7R0FTTDs7Ozs7O09BL0RWOEU7T0E0Q0F2VDtPQWhIQXdUO09BN0RGcTNCO09BR0FoaUM7T0FDQXltQztPQTJERWptQztPQS9DRm9DO09BWEFpUTtPQUdBcTZCO09BRkFqRjtPQUdBdUY7T0FGQWxzQztPQUdBbXNDO09BSUFOO09BQ0FFO09BNERFbHNDO09BQ0FDO09BRUFIO09BTUFDO09BTUFzcEI7T0FoQkF3akI7T0FtQ0FqMEI7T0FUQXJaO09BRkFFOzs7Ozs7T0FoRkZOO09BakJBd3RDO09BQ0FDO09BV0FMO09BREFKO09BREFLO09BUUFDO09BNEZFNXFDO09BT0FLO09BS0EybEI7T0E4Q0F0UDtPQUNBRTs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7OztZQzVLQXMwQixVO1lBQ0FDLFc7WUFDQUMsb0I7O0lBQ0FDO0lBQ0Fqd0M7SUFDQWhKO0lBQ0FFO0lBQ0FEO0lBQ0FpNUM7SUFDQXI1QztJQUNBczVDO1lBQ0FDLGU7R0FBWTtJQUNaQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQUNBNTlDLGlCO1lBRUFvZixTQUFPL0wsR0FBRUM7SUFFWCxHQUFHLGdDQUZRQTtLQUdOLGdDQUhJRCxHQUFFQztJQUlILElBQUptVyxJQUpLcFcsSUFBRUM7SUFNUixPQUFBLGdDQUZDbVc7Y0FFVyw0QkFGWEEsR0FKT25XO2NBSVBtVztHQUV3Qjs7SUFrRDFCbzBCO0lBQ0FDOzs7Ozs7O1lBQ0FDLE9BQU94K0MsR0FBSSxPQUFBLGdDQUFKQSxHQUFBQSxHQUFvQjtZQWEzQnkrQyx3QkFBd0IvdEM7SUFDMUIsT0FkRTh0QyxPQWF3Qjl0Qzs7Y0FHbEI7cUNBSGtCQTs7Z0JBTWxCO3VDQU5rQkE7c0JBT2hCLHlCQVBnQkE7O2tCQVFoQjtvQkFBZ0IseUJBQTBCLDZCQVIxQkE7R0FRaUM7WUFHekRndUMsNEJBQTRCMStDO0lBQXFCLFVBWGpEeStDLHdCQVc0QnorQztJQUFxQixPQUFBO0dBQTJCO1lBRTVFMitDLHdCQUF3QjMrQztJQUMxQixPQUFHLDBCQUR1QkE7Y0FFckIseUJBRnFCQTtjQUdsQjtpQ0FBQSx5QkFBMEIsZUFIUkE7R0FHMkI7WUFHbkQ0K0MsUUFBUUMsS0FBSW51QztJQUNSLFlBcEJKK3RDLHdCQW1CWS90Qzs7SUFJWixJQURLMVEsY0FDTCxtQkFKUTYrQztJQUtOLE9BWEZGLHdCQVdFLHVCQUZHMytDO0dBTWlCO1lBd0J0QjgrQyxvQkFBb0Jya0M7SUFDTSxJQUF4QnNrQyxNQUF3Qiw0QkFETnRrQztJQUVSLE9BbkNabWtDLGdDQWtDRUc7R0FDcUI7WUFHdkJDLHFCQUFxQmgvQztJQU92Qjs7WUFDSTtjQUFDLHlCQVJrQkE7Y0FRVyx5QkFBeUIsNEJBUnBDQTtHQVE4QztZQUduRWkvQyxvQkFBb0J4a0M7SUFDdEI7S0FBSXNrQyxNQUF3Qiw0QkFETnRrQztLQUVsQnlrQyxtQkFBbUIsMENBRG5CSDtJQUdELFNBQUEsNEJBSm1CdGtDO0tBWVIsR0F2Qlp1a0MscUJBYUVFO01BVUYsTUFBQTtLQUNBLE9BWEVBOztJQU1LLEdBbkJQRixxQkFhRUU7S0FPVSxPQTFEWk4sZUEwRFksNEJBUFZNO0lBTUYsTUFBQTtHQUtpQjtZQU9qQnBWLGdCQUFpQnA1QixHQUFZdlEsS0FBS0Q7SUFDcEMsT0FBRyxnQ0FEZ0J3USxHQUFZdlE7Y0FBQUE7Y0FDSCxnQ0FEUUQsS0FBakJ3USxLQUFpQnhRLE1BQWpCd1E7R0FDZ0M7T0FLL0MxUTtHQUNKLFNBSEVtL0MsSUFHRXh1QyxHQUFLLE9BQVQsNEJBQUlBLEdBREEzUSxHQUNXOzs7Ozs7Ozs7Ozs7Ozs7OztPQXJMYjg5QztPQUNBQztPQUNBQztPQUNBQztPQUNBandDO09BQ0FoSjtPQUNBRTtPQUNBRDtPQUNBaTVDO09BQ0FyNUM7T0FDQXM1QztPQUNBQztPQUNBQztPQUNBNTlDO09BRUFvZjtPQXdEQXkrQjtPQUNBQztPQUNBQztPQWFBQztPQVdBQztPQUVBQztPQU1BQztPQWlDQUU7T0FLQUU7T0FXQUM7T0FvQkFuVjtPQUlBcVY7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7OztJQ25KSXBrQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBOUJGaFU7SUFFQ3FQO0lBSUNtSDtHQUNKLFNBRkd4RCxLQUVDL1osR0FBSyxPQUFBLFdBREx1ZCxNQUNBdmQsR0FBVzs7SUFHYm9oQjtJQUNBNUc7SUFDQ0Y7O1lBSUR0SSxVQUFVdEIsR0FBSSxPQUFBLCtCQUFKQSxHQUFtQjtZQUU3QnVCLFVBQVU3RDtJQUNaLDJDQURZQTtjQUVMLHdCQUZLQTtjQUdMLDJCQUhLQTtHQUc4Qjs7Ozs7O1NBckJ4Q3JIO1NBRUNxUDtTQUdBMkQ7U0FLRHFIO1NBQ0E1RztTQU9Bdkk7U0FGQUQ7U0FjRStJOzs7Ozs7Ozs7Ozs7O1lBR0pELEdBQUczTSxLQUFJK1IsR0FBSSxPQUFBLCtCQUFSL1IsVUFBSStSLEdBQWtDO1lBT3pDM0YsaUJBQW9CLFNBQUU7R0FDaEI7SUFBQSxNQUFBO0lBQU5JLE1BQU07Ozs7Ozs7O1lBRU55a0Msb0JBQWUscUNBRUw7WUFHVkMsb0JBQWUscUNBRUw7WUFHVkMsZ0JBQVcscUNBRUQ7WUFHVkM7SUFBZ0I7OztLQUVYOztJQUQ0RTtHQUN2RTtZQUdWQyxnQkFBVyxvQ0FFRDtZQUdWQztJQUFXOzs7Ozs7S0FDZ0I7O0lBQ3RCO0dBQUs7WUFLVkM7SUFBYzs7Ozs7OztLQUMwQjs7SUFDbkM7R0FBSztZQUdWQyxpQkFBaUJqdkM7SUFBSSxJQUFXLE1BQUEsd0JBQVgsTUFBQSxtQkFBSkE7SUFBZSxPQUFBO0dBQVU7WUFFMUNrdkMsY0FBY2x2QztJQUNoQixPQXBCRTh1QyxTQW1CYzl1QztjQUZkaXZDLGlCQUVjanZDO2NBR1gsMkJBSFdBO0dBR3dDO1lBR3REbXZDLFVBQVVudkMsR0FBSSxPQXpCZDh1QyxTQXlCVTl1QyxTQVJWaXZDLGlCQVFVanZDLFFBQTBEO1lBRXBFb3ZDO0lBQWU7Ozs7Ozs7S0FDeUI7O0lBQ25DO0dBQUs7WUFHVkM7SUFBcUI7Ozs7OztLQUNNOztJQUN0QjtHQUFLO1lBR1ZDO0lBQXFCOzs7Ozs7S0FDTTs7SUFDdEI7R0FBSztZQUdWQyxrQkFDQXZ2QztJQURvQixTQUNwQkE7Y0FBQUE7ZUFBQUE7T0FDOEI7UUFBQSxNQUFBO1FBQVgsTUFBQSxtQkFEbkJBO1FBQ21CLE1BQUE7T0FBQSxPQUFBOzs7a0JBRG5CQTtNQUU4QjtPQUFBLE1BQUE7T0FBWCxNQUFBLG1CQUZuQkE7T0FFbUIsTUFBQTtNQUFBLE9BQUE7OztpQkFGbkJBO0tBQThCLElBQUEsTUFBQSx3QkFBWCxNQUFBLG1CQUFuQkE7S0FBOEIsT0FBQTs7SUFPekI7S0FBQSx3QkFBVSx3QkFQZkE7S0FLRSxNQUFBO0lBQUEsT0FBQTtHQUUyQjtZQUc3Qnd2QyxjQUFjeHZDO0lBQUksT0ExQmxCb3ZDLGFBMEJjcHZDLFNBWGR1dkMsa0JBV2N2dkM7R0FBK0Q7R0FFdEU7SUFDTGpRO0lBQ0FvZjtJQUNBRTtJQUNBemE7SUFDQUM7SUFDQUM7SUFOSyxRQUNML0UsUUFDQW9mLFVBQ0FFLFVBQ0F6YSxVQUNBQyxVQUNBQztJQU9FMjZDO0lBQ0ExZ0I7SUFDQ087WUFJRGo0QixVQUFRcTRDLElBQUdDO0lBQUssSUFBdUIsTUFBQSxzQkFBNUJBLEtBQWEsTUFBQSxzQkFBaEJEO0lBQStCLE9BQUE7R0FBYztZQUNyREUsY0FBWTNwQyxPQUFNakc7SUFBeUIsVUFBQSxzQkFBekJBO0lBQXlCLE9BQUEsNkJBQS9CaUc7R0FBNEM7WUFDeEQ0cEMsT0FBSzd2QyxHQUFJLE9BQUEsNkJBRFQ0dkMsZUFDSzV2QyxHQUEwQjs7b0RBRi9CM0ksV0FMQTAzQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EzRko5a0I7T0E3QkdMOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXFCSFE7O09BT0FQOzs7Ozs7Ozs7T0F1QkFpbEM7T0FwQkFKO09BS0FDO09Bb0JBSTtPQU9BQztPQXRCQUo7T0FLQUM7T0E4QkFNO09BTkFEO09BUUFFO09BS0FDO09BS0FDO09BZ0JBRTtPQVhBRDs7OztRQWlDSUs7UUFDQUM7UUFSQUo7UUFDQTFnQjtRQUNDTzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7R0MzSVc7O0lBQUE7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7WUNTaEJ3Z0IsY0FBZUMsUUFBUUM7SUFDekIsSUFlMkJDLFNBZmQsaUNBQ2JDOzsyQkFjMkJELFFBZDNCQyxLQUM0QiwwQkFENUJBO0tBQUEsVUFBQUE7Z0JBQUFBO0tBQUFBOztJQUdhO0tBQUE7T0FBQTs7K0JBTElIOytCQUFRQzs7O0tBS3pCOztTQUFBakQ7O01BQ2M7T0FBUm9EO1NBQVEsaURBTkdKLFFBS2pCaEQ7O1FBVzJCa0QsUUFWckJFLGdDQU5tQkgsYUFLekJqRDtNQUFBLFVBQUFBO2lCQUFBQTtNQUFBQTs7O0lBTU07S0FGRnFEOztTQVRxQkosbUNBQUFBO0tBV25CO09BQUE7OytCQVhXRDtTQVVqQixzQkFWeUJDO2lDQUFSRDs7U0FVakJuaUI7O01BR2M7T0FBUnlpQixRQUFRLGlEQWJHTixRQVVqQm5pQjs0QkFNMkJxaUIsUUFIckJJLE9BSkZEO01BRUUsVUFETnhpQjtpQkFBQUE7TUFBQUE7OztJQWNtQjtLQUFmMGlCLGVBQWUsd0JBeEJGUDs7NkJBZ0JVRSxRQVNjLDBCQURyQ0s7SUFDRCxLQUFBLCtCQURDQTtTQVI4QnIzQztLQUNoQztpQkFEZ0NBOzs7T0FHaUIsVUFBQSwwQkFIakJBO09BR3hCLEtBQUEsZ0RBSGlCZzNDLFFBQU9oM0MsVUFLM0IsSUFMMkI2TCxNQUFBN0wsV0FBQUEsSUFBQTZMOzs7TUFVL0I7TUFFRTs7O0lBREEsV0FBSyw0QkFYaUJtckM7R0FZbEI7MkJBNUJQSDs7O0U7Ozs7Ozs7WUNQQVMsVztZQUNBQyxhO3lCQURBRCxPQUNBQzs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lDRUE3eUM7SUFDQTQ1QjtJQUNBZ1o7SUFLRzdxQztJQUlDbUg7R0FDSixTQUZHeEQsS0FFQy9aLEdBQUssT0FBQSxXQURMdWQsTUFDQXZkLEdBQVc7R0FTYTtJQU4xQm9oQjtJQUNBNUc7SUFDQ0Y7SUFJRDh3QixlQVhDcnhCLGVBTURTOzBEQUFBQTs7WUFjRkQsaUJBQW9CLFNBQUU7WUFNdEJoSyxJQUFJKzdCLEtBQUtsaEIsS0FBS3ZiO0lBQ2hCLFNBRFd1YixPQUFLdmIsOEJBQVZ5OEIsTUFFRCxPQUZDQTtJQUlKO3lDQUpTbGhCLEtBQUt2YiwyQkFBVnk4QjthQUFVejhCLEtBTVQ7SUFFTyxJQUFOMjhCLE1BQU0sMkJBUkUzOEI7SUFTWix5QkFURXk4QixLQUFLbGhCLEtBUUhvaEIsUUFSUTM4QjtJQVNaLE9BQUEsNEJBREkyOEI7R0FFNEQ7WUFHbEVJLEtBQU9yMkIsS0FBVTFHLEtBQUl5OEI7SUFDdkIsR0FEUy8xQixTQUFNQyxNQUFORCxRQUFBNlUsTUFBTTVVLGNBQU40VTtJQUNULEdBRG1CdmI7U0FNUGxHLElBTk9rRyxRQU1QMkYsTUFBQTdMOztTQUFBNkwsTUFDRyxrREFQUTgyQixNQUFkbGhCO0lBT00sT0FwQmI3YSxJQWFxQis3QixLQUFkbGhCLEtBTUc1VjtHQUNvQjtZQVE5QjJyQyxTQUFXNXFDLEtBQVUxRyxLQUFJYSxHQUFFOGI7SUFDN0IsR0FEYWpXLFNBQU1DLE1BQU5ELFFBTFk2cUMsUUFLTjVxQyxjQUxNNHFDO0lBTXpCO0tBQUkvMUIsZUFBSixzQkFEMkIzYTtLQUVTLE9BQUEsNEJBRGhDMmEsY0FOcUIrMUI7S0FPckIzMUIsUUFBTSw0QkFGYTViO0lBR3ZCLDhDQVJ5QnV4QyxPQU9yQjMxQixPQURBSjtJQUd5QixJQVRDZzJCLE1BU0QsNEJBVEpELE9BT3JCMzFCLFFBUHFCTCxNQUFBZzJCO0lBQ3pCO2dCQUR5QmgyQixNQUFLaTJCOztNQUUxQjs7U0FBQSxpREFHdUIzd0MsR0FMRjBhLE1BS0lvQjtNQUh6QjtPQUE2RCxJQUZ4Q2dmLFFBRXdDLDRCQUZ4Q3BnQjtPQUFBQSxNQUFBb2dCOzs7Ozs7O0tBRXJCOztHQU95QztZQUczQy9tQixTQUFTL1QsR0FBSSxtQ0FBSkEsV0FBZ0I7WUFFckI0d0Msd0JBQXdCN2IsUUFBUXJhLEtBQUt2YixLQUFLMGtCLFdBQVUvSDtJQUMxRCxJQURzQ2dmLFFBQUFwZ0I7SUFDdEM7UUFEMkN2YixPQUFMMjdCLE9BRWpDLE1BQUEsNEJBRjJDalg7S0FHeEM7T0FBQTsrQ0FIc0JrUixRQUFRK0YsUUFBb0JoZjtNQUlyRCxPQUppQ2dmO0tBS0csSUFMSDRWLFFBS0csNEJBTEg1VjtLQUFBQSxRQUFBNFY7O0dBS2lDO1lBR3JFRyxtQkFBbUI3d0MsR0FBRzZqQixXQUFVL0g7SUFDbEMsT0FUTTgwQjthQVFlNXdDLDRCQUFBQSxJQUFHNmpCLFdBQVUvSDtHQUM4QjtHQUloRCxJQUFaK0g7WUFERml0QixVQUVZOXdDLEdBQUU4YjtJQUFPLE9BTnJCKzBCLG1CQU1ZN3dDLEdBRFY2akIsV0FDWS9IO0dBQTJDO0dBTTNDO0lBQVppSTs7O1lBREZndEIsZUFFaUIvd0MsR0FBRTBhLEtBQUlvQjtJQUN2QixJQUFJM2MsNEJBRGFhO1lBQUUwYSxPQUNmdmIsT0FEZXViO0tBSWQsT0F6QkRrMkIsd0JBcUJhNXdDLEdBQUUwYSxLQUNmdmIsS0FGRjRrQixhQUNxQmpJO0lBR2xCLE9BQUE7R0FDbUQ7WUFNcERrMUIseUJBQXlCamMsUUFBUXJhLEtBQUt2YixLQUFLMGtCLFdBQVUvSDtJQUMzRCxJQUR1Q2dmLFFBQUFwZ0I7SUFDdkM7WUFEdUNvZ0IsT0FFbEMsTUFBQSw0QkFGNENqWDtLQUd6QztPQUFBOytDQUh1QmtSLFFBQVErRixRQUFvQmhmO01BSXRELE9BSmtDZ2Y7S0FLRyxJQUxINFYsUUFLRyw0QkFMSDVWO0tBQUFBLFFBQUE0Vjs7R0FLaUM7WUFHdEVPLG9CQUFvQmp4QyxHQUFHNmpCLFdBQVUvSDtJQUNuQyxJQUFJM2MsNEJBRGtCYTtJQUV0QixPQVZNZ3hDO2FBUWdCaHhDLEdBRVUsNEJBRDVCYixTQUFBQSxLQURxQjBrQixXQUFVL0g7R0FFMkI7R0FJOUM7SUFBWm9JO1lBREZndEIsV0FFYWx4QyxHQUFFOGI7SUFBTyxPQVB0Qm0xQixvQkFPYWp4QyxHQURYa2tCLGFBQ2FwSTtHQUE0QztHQU03QztJQUFadUk7Ozs7Ozs7Ozs7WUFERjhzQixnQkFFa0JueEMsR0FBRTBhLEtBQUlvQjtJQUN4QixJQUFJM2MsNEJBRGNhO2FBQUUwYSxPQUNoQnZiLE1BRGdCdWI7S0FJZixPQTFCRHMyQix5QkFzQmNoeEMsR0FBRTBhLEtBQ2hCdmIsS0FGRmtsQixhQUNzQnZJO0lBR25CLE9BQUE7R0FDb0Q7WUFNekR1MEIsTUFqRFlyd0MsR0FBRThiO0lBa0RoQixJQUFJLGVBeERGKzBCLG1CQU1ZN3dDLEdBRFY2akIsV0FDWS9ILFVBa0RaOzs7Ozs7S0FDZ0M7O0dBQUk7WUFHdENzMUIsT0F0QmFweEMsR0FBRThiO0lBdUJqQjtLQUFJLGVBOUJGbTFCLG9CQU9hanhDLEdBRFhra0IsYUFDYXBJO0tBdUJiOzs7Ozs7S0FDZ0M7O0dBQUk7WUFHdEN1MUIsV0FBV3J4QyxHQUFFMGEsS0FBSW9CO0lBQ25CLElBQUksZUF2REZpMUIsZUFzRFcvd0MsR0FBRTBhLEtBQUlvQixVQUNmOzs7OztLQUNnQzs7R0FBSTtZQUd0Q3cxQixZQUFZdHhDLEdBQUUwYSxLQUFJb0I7SUFDcEIsSUFBSSxlQTVCRnExQixnQkEyQllueEMsR0FBRTBhLEtBQUlvQixVQUNoQjs7Ozs7S0FDZ0M7O0dBQUk7WUFVcENsUTs7S0FBcUIybEM7S0FBVEM7Ozt5QkFHb0IsNkJBSFhEOztJQUN2Qjs7OEJBQzJCLDZCQUZiQzs7O1lBT1pBLFFBQVF4eEMsR0FBSSxPQUFKQSxLQUFhO1lBQ3JCdXhDLGVBQWV2eEMsR0FBSSxPQUFKQSxLQUFvQjtZQUtuQ3l4QztJQUFtQkMsZUFBZUMsZ0JBQWdCSCxTQUFTSSxXQUFXQztJQUNwRCxJQUFoQkMsc0JBRGlCSjs7S0FJWjtXQUhMSTs7O1FBR0s7VUFKK0REO1VBQXBDRjtpQ0FBZ0JILFNBQ2hETTtNQUFBQTtPQUR5REYsY0FNZiw0QkFMMUNFOzs7S0FPRDtPQUFBO1NBUnFFRDtTQUFwQ0Y7Z0NBQWdCSCxTQUNoRE07TUFBQUEscUJBUWtCLDRCQVJsQkE7WUFBQUE7O0dBU1U7WUFHWkMsZUFBZ0JSO0lBQ2xCLE9BRGtCQTtHQUdZO1lBTTVCcnlDLE9BQU9zeUMsU0FBU0Q7SUFDbEI7S0FBSS8rQiwwQkFES2cvQjtLQUVMSSxZQUFZLDJCQURacC9CO1dBQUFBO0tBSWUsSUFBYnEvQixhQWRKRSxlQVNnQlI7S0FFZEs7S0FLa0I7TUFBaEJGO01BQ1MsT0FBQSw0QkFQWGwvQjtNQU1rQjs7VUFDcEJ2Wjs7T0FESXk0QztRQTdCSkQ7VUE2QklDO2lDQVBHRixTQVFQdjRDO1VBUk91NEM7VUFFTEk7VUFHRUM7T0FIRkQsY0FNRjM0QyxLQURJeTRDO09BQ0osV0FBQXo0QzttQkFBQUE7T0FBQUE7Ozs7SUFVRixXQWxCU3U0QyxTQUFTRCxnQkFFZEs7R0FnQmtDO1lBS3BDSSxlQUFpQm5zQztJLEdBQUFBLFNBQU1DLE1BQU5ELFFBQUE2VSxNQUFNNVUsY0FBTjRVO1FBQW9DazNCLHNCQUFoQkwsMkJBQVRDO29CQUEwQ1M7S0FDeEU7WUFEbUJ2M0I7O1FBQ0M7O2dDQURvRHUzQjtnQ0FBMUNUO1dBQVg5MkI7TUFJQTtPQUFibTNCLGFBcENKRSxlQWdDcUNSO09BS2pDOXdDLFFBTGFpYTtPQU1iZzNCO09BQ0FsaUIsSUFBSixzQkFQNEJnaUI7T0FReEJoL0IsSUFBSixzQkFSc0V5L0I7O1VBS2xFeHhDLE9BR0ErUixLQUZBay9CLG1CQUNBbGlCO1lBR0VtaUIsd0NBVmdFTSxNQUtsRXh4QztRQUNBaXhDO1NBbkRKRDtXQW1ESUMsa0JBSUVDLGdCQVZzQkgsU0FBeUJJLFdBSWpEQztRQUNBcHhDLE9BYUcsNEJBYkhBOzs7Y0FDQWl4QyxxQkFDQWxpQjtpQkFhdUIsNEJBZnZCL3VCLE1BRUErdUI7Ozs7S0FMRCxVQWtCdUM7O1lBRzFDMGlCLFFBQVFseUMsR0FBRXFMLEtBQU0sWUF2QmhCMm1DLGtCQXVCUWh5QyxHQUFFcUwsYUFBb0M7WUFFOUM4a0MsUUFBT3oxQixLQUFJMWEsR0FBR215QztJQUNSLElBQUpob0MsSUExQkY2bkMsZUF5Qk90M0IsS0FBSTFhLEdBQUdteUM7SUFFaEIsWUFESWhvQyxRQUFBQTtHQUMwQjtZQUc1QmlvQyxZQUFXMTNCLEtBQUkxYSxHQUFHbXlDO0lBQ1osSUFBSmhvQyxJQS9CRjZuQyxlQThCV3QzQixLQUFJMWEsR0FBR215QztJQUVwQixRQURJaG9DLEdBRUMsT0FGREE7SUFLb0Msa0NBQWUsNkJBTnRDbks7SUFNYixPQUFBO2FBaFFKdTNCLFNBZ1FJO0dBQThFO1lBR2hGOGEsaUJBQWtEQyxhQUFpQkw7UUFBOUJMLHNCQUFoQkwsMkJBQVRDO2FBQ2Qsc0JBRGNBO0tBRUMsV0FBQSxxREFGc0RTO0tBRWpDLE9BQUEsZ0RBQS9COztJQUVjO0tBQWJKLGFBM0VKRSxlQXVFcUJSO0tBS2pCRztLQUNBbGlCLElBQUosc0JBTllnaUI7S0FPUmgvQixJQUFKLHNCQVBtRXkvQjtLQVEvRGxIO0tBQVE7T0FEUnY0QjtTQUVKL1I7O1NBSklpeEMscUJBQ0FsaUI7a0JBRUF1YjtPQUFBQSxlQUlTLDRCQUhidHFDLEdBSEkrdUI7T0FEQWtpQjtRQUw4Q1ksY0FBYlYsY0FlcUIsNEJBVHREcGlCOztTQUdKL3VCLElBRkkrUjtXQVlJbS9CLHdDQW5CMkRNLE1BU25FeHhDO09BSklpeEM7UUF6RkpEO1VBeUZJQyxrQkFjSUMsZ0JBbkJJSCxTQUF5QkksV0FJakNDOztNQUtKLFdBQUFweEM7U0FGSStSLE1BRUovUjtNQUFBQTs7O3FDQURJc3FDOztZQXVCSndILGNBQWU3M0IsS0FBSTFhLEdBQU90QyxHQUFHODBDO0lBQ3pCLFlBOUNKckMsUUE2Q2V6MUIsS0FBSTFhLEdBQU90QztnQkFFbEIsT0FGa0JBO0lBSTFCO0tBREt6RTtLQUNEdzVDLFFBQUosc0JBSjBCLzBDO0tBS3RCZzFDLDhCQUxlMXlDO0tBTWYyeUMsV0FBSixzQkFONkJIO0tBT0wsT0FBQSw0QkFIcEJDLE9BRUFFO0tBQ21CLE9BQUEsa0NBRm5CRDtLQUVBNVcsTUFBTTtJQUNWLDJCQVIwQnArQixNQU90Qm8rQixRQUpDN2lDO0lBTUwsMkJBVDZCdTVDLFdBT3pCMVcsS0FKQzdpQyxHQUdEMDVDO0lBU0k7S0FBQSxPQUFBLDRCQVhKRixPQURDeDVDO0tBWUUsT0FBQSxrQ0FWSHk1QztLQVNPLE9BQUEsNEJBWE56NUMsR0FHRDA1QztLQU1PLE9BQUEsNEJBVE4xNUMsR0FFRHk1QztJQUtKLDJCQVYwQmgxQyxTQU90Qm8rQjtJQUdKLE9BQUEsNEJBSElBO0dBUzBEO1lBSTlEOFcsWUFBWTV5QyxHQUFPdEMsR0FBRzgwQztJQUNWLElBQVZOLFVBcERGRyxVQW1EWXJ5QyxNQUFPdEM7SUFFckIsS0FESXcwQyxTQUVJLE9BSGF4MEM7SUFPbkI7S0FGSSswQyw4QkFMZS8wQztLQU1mZzFDLDhCQU5RMXlDO0tBT1IyeUMsV0FBSixzQkFQc0JIO0tBUWxCSyxjQUFjLHlCQVBoQlg7S0FRK0IsT0FBQSw0QkFGN0JTLFVBREFEO0tBRzRCLE9BQUEsa0NBRDVCRztLQUNtQixPQUFBLDRCQUpuQko7S0FJQTNXLE1BQU07S0FDTmdYO0tBQ0FDO0lBQ0o7O01BWEViO2VBV3dCajVDO09BQ2QsSUFBTmtHLE1BQU0sNEJBRGNsRyxHQUR0Qjg1QztPQUdGO3lCQWRpQnIxQyxHQVdmcTFDLGlCQUZBalgsS0FDQWdYLGlCQUdFM3pDO09BTU8sV0FBQSw0QkFUVDJ6QyxpQkFHRTN6QztPQUVKLDJCQWZvQnF6QyxXQVNsQjFXLFdBRkE2VztPQWNjLFdBQUEsNEJBWGRHLGlCQUdFM3pDO09BSEYyekMsa0JBV2Msa0NBZGRIO09BZWMsV0FBQSw0QkFYZEksaUJBRUU1ekM7T0FGRjR6QyxrQkFXYyxrQ0FoQmRMOztNQWdCeUM7SUFNdEMsV0FBQSw0QkF2QkhELE9BTUFNO0lBWUosMkJBdkJtQnIxQyxHQVdmcTFDLGlCQUZBalgsS0FDQWdYO0lBYUosT0FBQSw0QkFkSWhYO0dBb0IwRDtZQUc5RGtYLFNBQVNoekMsR0FBRXRDO0lBQ2I7S0FBSXUxQyxvQ0FET2p6QztLQUVQa3lDLFVBckZGRyxVQW1GU3J5QyxNQUFFdEM7S0FLWDtPQUFBLDZCQUhFdzBDLG1DQUZTeDBDO0tBSVgsV0FBQyw2QkFIQ3UxQyxjQUNBZjtJQUlDLE9BQUE7Ozs7c0JBQUtqNUMsR0FBRXdIO2NBQUs7ZUFBbUMsT0FBQSw0QkFBeENBLEdBQUZ4SDtlQUF5QyxPQUFBLGtDQUwvQ2c2QztjQUsrQyxPQXpUbkRwekMsSUFtVGFuQyxHQU1lLDRCQUFsQnpFLEdBTE5nNkM7YUFLb0U7R0FBQztZQWFyRTM4QyxNQUNHNDhDLE9BQVFDO0lBQ1YsR0FBRyxvQ0FEREQsT0FBUUMsUUFFTDtJQUdELFdBQUEsNkJBTEZELFVBQVFDO0lBS047S0FFRyxXQUFBLDZCQVBMRCxVQUFRQztLQU9IOzttREFQTEQsVUFBUUM7Ozs7O0lBT0g7R0FDNEQ7WUFJcEVwa0I7SUFDRDtLQUVrQnFrQjtLQURLQztLQURQQztLQU1UQyxVQUFZLCtDQUpESDtLQUdiSSxnQ0FDRUQ7S0FJQUUsVUFBWSw2QkFUSUo7S0FRbEJLLGtDQUNFRCxlQUxGRDtLQVVFRyxVQUFZLDZCQWZITDtLQWNYTSxrQ0FDRUQsZUFORkQ7SUFTSixXQUpJRTtHQUl5QjtZQU03QkMscUI7R0FoRFcsa0JBVVh2OUMsT0FhQXk0QixhQXlCQThrQjtZQVVKQyxpQkFBa0J2QyxnQkFBZ0I3MkIsS0FBSTFhLEdBQUd3eEMsU0FDM0MsT0FyS0lyQixRQW9LZ0N6MUIsS0FwTmhDeGIsT0FvTnVDc3lDLFNBQXZCRCxpQkFBb0J2eEM7R0FDd0M7WUFHOUUrekMscUJBQXNCeEMsZ0JBQWdCNzJCLEtBQUkxYSxHQUFHd3hDLFNBQy9DLE9BcEtJWSxZQW1Lb0MxM0IsS0F4TnBDeGIsT0F3TjJDc3lDLFNBQXZCRCxpQkFBb0J2eEM7R0FDd0M7WUFHbEZnMEMscUJBQXNCekMsZ0JBQWV2eEMsR0FBR3N5QyxhQUFhZCxTQUN2RCxPQS9KSWEsVUE5REFuekMsT0E0Tm1Ec3lDLFNBQS9CRCxpQkFBa0JlLGFBQUh0eUM7R0FJL0I7WUFHTmkwQyx5QkFBMEIxQyxnQkFBZ0I3MkIsS0FBSTFhLEdBQUd3eEM7SUFDakIsV0FwTzlCdHlDLE9BbU8rQ3N5QyxTQUF2QkQ7SUFDNUIsc0IsT0F2SUlnQixjQXNJd0M3M0IsV0FBSTFhO0dBQ3dDO1lBR3RGazBDLHVCQUF3QjNDLGdCQUFldnhDLEdBQUd3eEM7SUFDakIsV0F4T3ZCdHlDLE9BdU93Q3N5QyxTQUFsQkQ7SUFDMUIsc0IsT0F2SElxQixrQkFzSHFDNXlDO0dBQ3dDO1lBRy9FbTBDLGlCQUFrQjVDLGdCQUFldnhDLEdBQUdvMEM7SUFDdkIsV0F4QmJOLGlCQXVCa0J2QyxtQkFBZXZ4QyxHQUFHbzBDO0lBQ3ZCLE9BQUE7R0FBdUQ7O0dBR3JELFNBQWZDO0ksT0EzQkFQOztHQTJCZTtHQUNJLFNBQW5CUTtJLE9BeEJBUDs7R0F3Qm1CO0dBQ0EsU0FBbkJRO0ksT0FyQkFQOztHQXFCbUI7R0FDSSxTQUF2QlE7SSxPQWZBUDs7R0FldUI7R0FDRixTQUFyQlE7SSxPQVpBUDs7O0lBWXFCOzs7Ozs7O0dBQ04sU0FBZlE7SSxPQVRBUDs7WUFXQVEsb0JBUUV0cEMsS0FBU3VwQyxXQUFtQi8wQyxLQUFLZ3lDO0lBQ25DO0tBQUlnRCxnQ0FERnhwQztLQVBzQ3lwQyxVQVN4QyxzQkFGOEJqMUM7WUFBbkIrMEM7cUJBQ1BDLFVBRE9EO2FBS1QsV0F6Y0ZqM0MsbUJBb2NXaTNDLFdBQ1BDO0lBU0o7WUFBQSw0QkFWV0QsV0FQNkJFLFlBUXBDRDtlQVNKO1FBakJpQkUsVUFPTkgsV0FQb0JJO0lBQy9CO1FBRCtCQSxZQUFTRixTQUVuQztLQUNHOztPQUFBO1NBSTJCakQ7Z0NBQWpDeG1DLEtBUGUwcEM7Z0NBT2FsMUMsS0FQQ20xQztNQUsxQjtLQUQrQztNQUpyQkMsWUFJcUIsNEJBSnJCRDtNQUFkRSxZQUlPLDRCQUpQSDtLQUFBQSxVQUFBRztLQUFjRixVQUFBQzs7R0FrQjJCO1lBRzFERSxjQUFjcGdCLFFBQVE3QixRQUFRMmU7SUFDaEM7S0FBSXVELG1DQURZcmdCO0tBRVozQixhQUFKLHNCQUZ3QkY7WUFFcEJFLGNBREFnaUI7O2NBdkJGVDtlQXNCYzVmO2VBTU4sNEJBTE5xZ0IsWUFDQWhpQjtlQUZvQkY7ZUFBUTJlOztHQVFoQjtZQUdkd0QsY0FBY3RnQixRQUFReEosUUFBUXNtQjtJQUNoQztLQUFJdUQsbUNBRFlyZ0I7S0FFWnVnQixhQUFKLHNCQUZ3Qi9wQjtZQUVwQitwQixjQURBRjtrQkFsQ0ZULG9CQWlDYzVmLFdBQVF4SixRQUFRc21CO0dBSWtDOztJQU81RHZqQjtJQUNBaW5CO0lBQ0NqbUI7WUFrQkRqNEIsVUFadUJtK0MsU0FBZUM7SUFheEMsR0FBRyw2QkFic0JELFNBQWVDLFVBY25DOztLQWQ0Q0MsNkJBQVREO0tBQU5FLDZCQUFUSDtLQUFMOTZCO0lBQ3BCO1FBRG9CQSxRQUFjaTdCLGFBQWRqN0IsUUFBNkJnN0I7UUFBN0JoN0IsUUFBNkJnN0IsTUFJNUM7S0FONEQ7TUFBdEMvRiw0QkFFYThGLFNBQXBCLzZCO01BRklnMUIsNEJBRUM4RixTQUFMOTZCO01BRjZDLE9BQUEsMEJBQXRDaTFCO01BQWtCLE9BQUEsMEJBQXJCRDtNQVFsQmxnQyxJQVIyRDtLQVMvRCxTQURJQSxHQUdHLE9BSEhBO0tBRXFCLElBUlBzckIsUUFRTyw0QkFSUHBnQjtLQUFBQSxNQUFBb2dCOztHQXFCYTtZQUcvQnRuQixjQUFZdk4sT0FBTWpHO0lBQ3BCO0tBQUliLDRCQURnQmE7S0FFaEJnZ0MsY0FBWSw2QkFGRi81QixPQUNWOUc7S0FFVyxPQUFBLDRCQUZYQTtLQUNROztTQUNadWI7O01BQ2lDLFdBQUEsaURBSmIxYSxHQUdwQjBhO01BRElzbEIsYUFFTyw2QkFGUEE7TUFDSixXQUFBdGxCO2tCQUFBQTtNQUFBQTs7O1dBRElzbEI7R0FJRTtZQUdKdnNCLE9BQUt6VCxHQUFJLE9BQUEsNkJBVFR3VCxlQVNLeFQsR0FBMEI7WUFDL0JpekIsVUFBVXYxQixHQUFHdzFCO0lBQVMsT0FoRTFCaWlCLGNBZ0VjejNDLEdBQUd3MUI7R0FBZ0U7WUFDN0U1SCxVQUFVNXRCLEdBQUc2dEI7SUFBUyxPQXREMUI4cEIsY0FzRGMzM0MsR0FBRzZ0QjtHQUFnRTs7R0FDOUQsU0FBZnFxQjtJLE9BMUhKOUI7O0dBMEhtQjtHQUNJLFNBQW5CK0I7SSxPQXZISjlCOztHQXVIdUI7R0FDQSxTQUFuQitCO0ksT0FwSEo5Qjs7R0FvSHVCO0dBQ0ksU0FBdkIrQjtJLE9BOUdKOUI7O0dBOEcyQjtHQUNGLFNBQXJCK0I7SSxPQTNHSjlCOztHQTJHeUI7R0FDTixTQUFmK0I7SSxPQXhHSjlCOzs7WUF5R0krQjtJQUFrQjtLQUFBO00sT0E5RnRCdkI7OztvREFnRUl0OUMsV0FuQkFrK0M7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQXdESmgwQyxnQjtZQUNBRCxnQjtZQUVBNUIsS0FBSzhTLEdBQUd2UztJQUNWLEdBRE91UyxPQUNPLFdBcmlCWjdVLG1CQW9pQks2VTtJQUVDO0tBQUp4UyxJQUFJLDJCQUZEd1M7S0FHTSxPQUFBLDRCQUhOQTtLQUVDOztTQUNSdlo7O01BQ0UsZUFGRStHLEdBQ0ovRyxHQUNnQixXQUpOZ0gsR0FHVmhIO01BQ0UsV0FERkE7a0JBQUFBO01BQUFBOzs7SUFHQSxPQUFBLDRCQUpJK0c7R0FJd0Q7WUFHMURGLFFBQVFwQztJQUNWO0tBQWlCa3dCLE1BQ1Qsa0RBRkVsd0I7S0FDRzhhO0tBQUl2ZixJQUFBMjBCO0lBQUk7WUFBSjMwQixHQUFrQixPQUF0QnVmO0tBQW1EO01BQS9DMVQsTUFBK0MsNEJBQS9DN0w7TUFBSml4QixZQUFxQyxnQkFEeEN4c0IsR0FDT3pFLElBQUp1ZjtLQUFBQSxNQUFBMFI7S0FBSWp4QixJQUFBNkw7O0dBQ0s7WUFHcEI2N0IsWUFBWWpqQztJQUNkLElBQUl5Qiw0QkFEVXpCLElBRUQ4YSxTQUFJdmY7SUFBSTtRQUFKQSxNQURia0csS0FDaUMsT0FBeEJxWjtLQUFxRDtNQUFqRDFULE1BQWlELDRCQUFqRDdMO01BQUppeEIsWUFBdUMsZ0JBRnRDeHNCLEdBRUd6RSxJQUFKdWY7S0FBQUEsTUFBQTBSO0tBQUlqeEIsSUFBQTZMOztHQUNSO1lBR1A3QixJQUFJakQ7SUFDTjtLQUFJYiw0QkFERWE7S0FFRmtELE1BQU0sMkJBRE4vRDtLQUVTLE9BQUEsNEJBRlRBO0tBQ007O1NBQ1ZsRzs7TUFDa0MsV0FBQSw0QkFIOUJrRzs7UUFDQStEO1FBQ0pqSzsrQkFITStHLEdBSTJCLGtDQURqQy9HO01BQUEsV0FBQUE7a0JBQUFBO01BQUFBOzs7SUFHQSxPQUFBLDRCQUpJaUs7R0FJMEQ7R0FNOUM7SUFBWjRzQjtZQURGcW1CLFlBRWNDLE1BQVNDO0lBQ3ZCO0tBQUkzN0IsTUFyZkptMkIsbUJBb2ZjdUYsTUFEWnRtQixhQUNxQnVtQjtLQUVpQyxPQUFBLGtEQUYxQ0QsT0FDVjE3QjtLQUNtRCxPQUFBO0tBQTdCLE9BbmlCMUI3YSxJQWlpQmN1MkMsTUFFMEIsNEJBRHBDMTdCO0lBQ0osV0FuaUJBN2EsSUFpaUJjdTJDLFNBQ1YxN0I7R0FDMEU7R0FPaEU7SUFBWjQ3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBREZDLFlBRWNILE1BQVNDO0lBQ3ZCO0tBQUkzN0IsTUFoZUp1MkIsb0JBK2RjbUYsTUFEWkUsYUFDcUJEO0tBRWlDLE9BQUEsa0RBRjFDRCxPQUNWMTdCO0tBQ21ELE9BQUE7S0FBN0IsT0E3aUIxQjdhLElBMmlCY3UyQyxNQUUwQiw0QkFEcEMxN0I7SUFDSixXQTdpQkE3YSxJQTJpQmN1MkMsU0FDVjE3QjtHQUMwRTtZQU05RTg3QixRQUFRSixNQUFNSztJQUNoQixJQUFJLGVBckJGTixZQW9CUUMsTUFBTUssTUFDWjs7Ozs7S0FDZ0M7O0dBQUk7WUFHdENDLFFBQVFOLE1BQU1LO0lBQ2hCLElBQUksZUFoQkZGLFlBZVFILE1BQU1LLE1BQ1o7Ozs7O0tBQ2dDOztHQUFJO1lBR2xDRSxjQUFjM3pDLEdBQUd3TTtJQUN2QixJQURvQmlkLE1BQUF6cEI7SUFDcEI7VUFEb0J5cEIsS0FFWjtLQUNNLElBSE05SyxLQUFBOEssUUFHbEIvSyxLQUhrQitLLFFBR04sT0FBQSwwQkFBWi9LLElBSHFCbFM7S0FHVCxTQUFBO0tBSE1pZCxNQUFBOUs7O0dBRytCO1lBR2pEaTFCLFVBQVV2ckMsS0FBS29yQztJQUNqQixnQkFEaUJBO1NBSUZ6ekMsSUFKRXl6QyxPQUNiSSxvQkFHb0JybkMsR0FBSyxPQVZ2Qm1uQyxjQVVTM3pDLEdBQVN3TSxHQUFzQjs7O01BRHBDQSxJQUhPaW5DO01BQ2JJLG9CQUVnQnIwQixLQUFLLE9BQVQsMEJBQUlBLEtBQVZoVCxHQUE4QjtJQUd4QztLQUNpQnNuQyxXQURqQixzQkFOWXpyQztLQU9jcWxDLFFBVWQsNEJBVktvRztLQUFKdCtCO0tBQUl1K0IsYUFBQUQ7S0FBU0UsYUFBQXRHO0lBQ3hCO2VBRHdCc0csWUFFbkIsV0E1a0JMbjNDLElBbWtCVXdMLFFBT0swckMsYUFBSnYrQjtLQUdILEdBVE5xK0IsU0FTZSxnQkFWUHhyQyxLQU9jMnJDO01BS1g7T0FBUEMsT0FBTyw0QkFMV0Q7T0FNbEJFLFVBaGxCTnIzQyxJQW1rQlV3TCxLQVlKNHJDLE1BQ2lDLDRCQU54QkYsWUFLVEU7T0FMa0J2OEIsTUFPSSw0QkFQSnM4QjtPQUFiOXNCLFlBTUxndEIsU0FOSzErQjtNQUFBQSxNQUFBMFI7TUFBSTZzQixhQUFTQztNQUFBQSxhQUFBdDhCOzs7TUFRRCxJQVJDb2dCLFFBUUQsNEJBUkNrYztNQUFBQSxhQUFBbGM7OztHQVVMO1lBR25CcWMsTUFBTTlyQyxLQUFLb3JDLElBQUssT0FwQmhCRyxVQW9CTXZyQyxzQkFBS29yQyxLQUFpQztZQUM1Q1csZUFBZS9yQyxLQUFRZ3NDO0lBQVEsT0FyQi9CVCxVQXFCZXZyQyxvQkFBUWdzQztHQUE0QztZQUdqRUMsbUJBQW9CdDNDLEdBQUcwYSxLQUFLNjhCO0lBQzlCOztZQUR5Qjc4QjtNQUNlLFdBQUEsZ0JBRGxCMWEsR0FDcUIsNEJBRGxCMGE7TUFDSSxHQUFBOzs7O0lBREpBLFNBQ2xCLDRCQURrQkE7SUFBSzY4QixTQUV2Qiw0QkFGa0I3OEI7O0dBRVY7WUFIZjg4QixZQUtFeDNDO0lBQ0YsSUFBSXdTLDBCQURGeFM7SUFFRixTQURJd1MsR0FFQztJQUdPO0tBQU5rSSxVQUFVLDRCQUxabEk7S0FNRStrQyxVQU5GL2tDO0tBT0UrVjtLQUdVLE9BQUEsZ0JBWGR2b0IsR0FNSTBhO0lBS0QsR0FBQSxxQ0FmSDQ4QixtQkFJQXQzQyxHQU1JMGEsS0FDQTY4Qjs7WUFEQTc4QixtQkFFQTZOLE9BYUosV0FwbkJGMW9CLElBK2xCRUcsTUFPSXUzQztLQU1hLFdBQUEsZ0JBYmpCdjNDLEdBTUkwYTtLQU9DLEdBQUE7TUFDRSw2QkFSSEE7O01BV1ksSUFBUm9HLFFBQVEsNEJBWFpwRyxZQVlBLE9BVkE2TjtNQUFBQTtXQXZtQk4xb0IsSUErbEJFRyxHQWlCUThnQixPQUN3Qiw0QkFYNUJ5MkIsUUFVSXoyQjtNQXJCUncyQixtQkFJQXQzQyxHQU1JMGEsS0FDQTY4Qjs7O0dBYzBCO1lBR2hDRSxZQUFVLzVDLEdBQUd3MUI7SUFBUyxPQXpNdEJpaUIsY0F5TVV6M0MsR0FBR3cxQjtHQUF1RDtZQUNwRXdrQixZQUFVaDZDLEdBQUc2dEI7SUFBUyxPQS9MdEI4cEIsY0ErTFUzM0MsR0FBRzZ0QjtHQUF1RDtZQUVwRW9zQixrQkFBZ0JqNkMsR0FBR2dkLEtBQUswNUI7SUFDMUIsT0FuT0VPLG9CQWtPZ0JqM0MsR0FBR2dkLEtBQUswNUI7R0FDa0M7WUFHMUR3RCxXQUFXNTNDLEdBQUV3UyxHQUFHVixNQUFNNEksS0FBS3ZiLEtBQUswNEM7SUFDbEMsUUFEZXJsQztLQUdWLElBQ0MsV0Fsb0JKM1MsSUE4bkJXRyxHQUFXMGEsS0FBS3ZiLE1BSXZCO2lCQUNHLE9BTHlCMDRDO0lBRWpCO1lBQUEsMEJBRkMvbEM7SUFFRCxPQUFBO0dBR0M7WUFHaEJnbUMsWUFBWTkzQyxHQUFFd1M7SUFDaEIsT0FURW9sQzthQVFZNTNDO2FBQUV3Uzs7YUFBQUE7YUFDK0Isa0RBRGpDeFMsSUFBRXdTOztHQUMwRDtZQUd4RXVsQyxZQUFZLzNDLEdBQUV3UztJQUNoQixPQWJFb2xDO2FBWVk1M0M7YUFBRXdTOzs7YUFDK0Isa0RBRGpDeFMsSUFBRXdTOztHQUMwRDtZQUd4RStZLE9BQU92ckIsR0FBRXdTLEdBQUksT0FoQmJvbEMsV0FnQk81M0MsR0FBRXdTLGtCQUFBQSxHQUFGeFMsR0FBNkQ7WUFDcEVrekIsT0FBT2x6QixHQUFFd1M7SUFBSSxPQWpCYm9sQzthQWlCTzUzQzthQUFFd1M7O2FBQXVDLGtEQUF6Q3hTLElBQUV3UzthQUFBQTthQUFGeFM7R0FBMEU7WUFFakZnNEMsT0FBU255QyxLQUFTN0YsR0FBR0M7SUFDdkIsR0FEVzRGLFNBQU1DLE1BQU5ELFFBRUU2VSxNQUZJNVUsY0FFSjRVO0lBRGIsSUFBSWxJLElBQUosc0JBRG9CeFMsSUFFUC9HLElBQUF5aEI7SUFBSTtRQUFKemhCLE1BRFR1WixHQUMyQjtLQUFhLEdBQUEsV0FGckJ2UyxHQUVWaEgsR0FBbUMsZ0JBRjVCK0csR0FFUC9HLEtBQThDLFdBQTlDQTtLQUErRCxJQUEvRDZMLE1BQStELDRCQUEvRDdMO0tBQUFBLElBQUE2TDs7R0FDTDtZQUdOa1UsS0FBS2haLEdBQUdDO0lBQ0osWUFQSiszQyxVQU1LaDRDLG1CQUNrQndQLEdBQUssT0FBQSxXQURwQnZQLEdBQ2V1UCxHQUFRO2dCQUN2QjtRQUNIdlc7SUFBSyxXQUFLLGdCQUhWK0csR0FHQS9HO0dBQWU7WUFHcEI4ZixTQUFTL1ksR0FBR0M7SUFDZCxJQUFJdVMsMEJBRE94UyxJQUVFL0c7SUFDWDtRQURXQSxNQURUdVosR0FHRztLQUVHLElBRUp0UCxNQUZJLFdBTklqRCxHQU1GLGdCQU5ERCxHQUVFL0c7UUFNUGlLLEtBQWlCLE9BQWpCQTtLQURhLElBTE40QixNQUtNLDRCQUxON0w7S0FBQUEsSUFBQTZMOztHQVFQO1lBR0ptekMsT0FBUXY5QixLQUFJMWEsR0FBR0M7SUFDakIsR0FEVXlhO1NBSURvZ0IsUUFKQ3BnQixRQUNHZzJCLFFBR0o1Vjs7U0FISTRWLFFBSUQsa0RBTEUxd0M7UUFDRC9HLElBQUF5M0M7SUFBSTtZQUFKejNDLEdBQWtCO0tBQWEsR0FBQSxXQUQzQmdILEdBQ0poSCxHQUFtQyxnQkFEbEMrRyxHQUNEL0csS0FBOEMsV0FBOUNBO0tBQStELElBQS9ENkwsTUFBK0QsNEJBQS9EN0w7S0FBQUEsSUFBQTZMOztHQU1MO1lBR05vekMsY0FBZXhuQixNQUFLMXdCO0lBQUksT0FWeEJpNEMsVUFVb0JqNEMsbUJBQXVCd1AsR0FBSyxXQUFJLFdBQXJDa2hCLE1BQTRCbGhCLEdBQWlCO0dBQUM7WUFFN0Qyb0MsT0FBU3R5QyxLQUEyQjdGO0lBQ3RDLEdBRFc2RixTQUFPQyxNQUFQRCxRQUFBNnFCLE9BQU81cUIsY0FBUDRxQjtJQUNMLFlBSEp3bkIsY0FFU3huQixNQUEyQjF3QjtnQkFFNUI7UUFDSC9HO1dBQUFBLE1BQVksa0RBSG1CK0c7Y0FBQUE7Y0F4Q3BDdXJCLE9Bd0NvQ3ZyQixHQUdlLDRCQUE5Qy9HO0dBQXFEO1lBRzFEbS9DLGVBQWdCMW5CLE1BQUsxd0I7SUFBSSxPQTNDekJnNEMsVUEyQ3FCaDRDLG1CQUF1QndQLEdBQUssV0FBSSxXQUFyQ2toQixNQUE0QmxoQixHQUFpQjtHQUFDO1lBRTlENm9DLE9BQVN4eUMsS0FBMkI3RjtJQUN0QyxHQURXNkYsU0FBT0MsTUFBUEQsUUFBQTZxQixPQUFPNXFCLGNBQVA0cUI7SUFDTCxZQUhKMG5CLGVBRVMxbkIsTUFBMkIxd0I7Z0JBRTVCO1FBRUh3UztpQkFBQUEsSUFKK0J4UyxJQXhEcEM4M0MsWUF3RG9DOTNDLEdBSS9Cd1M7R0FBb0I7WUFNekI4bEMsTUFBUXp5QyxLQUEyQjdGO0lBQ3JDLEdBRFU2RixTQUFPQyxNQUFQRCxRQUFBNnFCLE9BQU81cUIsY0FBUDRxQjtJQUNWLElBQUk1dUIsU0FBSixzQkFEcUM5Qjs7YUFDakM4QjtLQUNnQzs7T0FBZCxXQUZaNHVCLE1BRWlCLGdCQUZVMXdCOzs7UUFFRDtVQUYxQjB3QixNQUUrQixnQkFGSjF3QixHQUVPLDRCQUR4QzhCOztLQUlJLFlBakJOczJDLGVBWVExbkIsTUFBMkIxd0I7aUJBTXpCO0tBRUQsSUFERjA5QixrQkFDRSxVQTVCVHdhLGNBb0JReG5CLE1BQTJCMXdCOztNQVN0QixNQUFBO0tBQzRCLElBQS9CcXJCLG1CQUErQixPQUFBLDRCQUEvQkEsTUFISHFTO0tBR2lDLE9BbHRCeEM3OUIsSUF3c0JtQ0csR0FPNUIwOUIsT0FHaUM7O0lBUHJDLE9BSGdDMTlCO0dBVXlCO1lBRzVETSxLQUFLTixHQUFHQztJQUNWO0tBQUkrQywwQkFER2hEO0tBRUhrRyxNQUFLLDJCQURMbEQ7S0FFUyxPQUFBLDRCQUZUQTtLQUNLOztTQUNUL0o7OzRCQURJaU4sS0FDSmpOLEdBQ3dCLFdBSmRnSCxHQUdWaEgsR0FDNkIsZ0JBSnRCK0csR0FHUC9HO01BQUEsV0FBQUE7a0JBQUFBO01BQUFBOzs7SUFHQSxPQUFBLDRCQUpJaU47R0FJeUQ7WUFJM0Q3RixJQUFJTCxHQUFHQztJQUNUO0tBQUkrQywwQkFERWhEO0tBRUZrRyxNQUFLLDJCQURMbEQ7S0FFUyxPQUFBLDRCQUZUQTtLQUNLOztTQUNUL0o7OzRCQURJaU4sS0FDSmpOLEdBQ3dCLFdBSmZnSCxHQUlrQixnQkFKckJELEdBR04vRztNQUFBLFdBQUFBO2tCQUFBQTtNQUFBQTs7O0lBR0EsT0FBQSw0QkFKSWlOO0dBSXlEO1lBRzNEK1MsU0FBU3ZiO0lBQUksT0FBeUI7O21DQUE3QkE7c0JBQWtDekUsR0FBSyxPQUFBLGdCQUF2Q3lFLEdBQWtDekUsR0FBVTtHQUFDO1lBRXREaUosT0FFRXhFLEdBQUd1QztJQUFLLElBRE1kLDRCQUNkekIsSUFEV3pFO0lBQVk7Z0JBQVpBLElBQUdrRzs7TUFBcUIsV0FBQSxXQUNoQ2MsR0FEa0MsZ0JBQ3JDdkMsR0FEV3pFO01BQXdCO09BQWtCLElBQTFDNkwsTUFBMEMsNEJBQTFDN0w7T0FBQUEsSUFBQTZMOzs7Ozs7O0tBQXdCOztHQUNBO1lBR3JDdkMsUUFFRTdFLEdBQUd1QztJQUFLLElBRE1kLDRCQUNkekIsSUFEV3pFO0lBQVk7Z0JBQVpBLE1BQUdrRzs7OztNQUFxQixXQUFBLFdBQ2hDYyxHQURrQyxnQkFDckN2QyxHQURXekU7TUFBd0I7T0FBa0IsSUFBMUM2TCxNQUEwQyw0QkFBMUM3TDtPQUFBQSxJQUFBNkw7Ozs7Ozs7R0FDd0I7WUFHckMvRSxLQUlFQyxHQUFHTixNQUFNTztJQUFLLElBSE1kLDRCQUdwQmEsSUFIVy9HLE9BQUVzdkIsS0FHVjdvQjtJQUZMO1FBRGF6RyxNQUFTa0csS0FDTixPQUREb3BCO0tBQ3dCO01BRHhCSSxPQUN3QixXQUU1QjFvQixHQUhJc29CLElBQzhCLGdCQUUzQ3ZvQixHQUhXL0c7TUFBQTZMLE1BQ2tCLDRCQURsQjdMO0tBQUFBLElBQUE2TDtLQUFFeWpCLEtBQUFJOztHQUdpQztZQUdoRGUsTUFJRTFwQixHQUFHTixNQUFNTztJQUFLLElBSE1kLDRCQUdwQmEsSUFIVy9HLE9BQUVzdkIsS0FHVjdvQjtJQUZMO1FBRGF6RyxNQUFTa0csS0FDTixPQUREb3BCO0tBQ3dCO01BRHhCSSxPQUN3QixXQUU1QjFvQixHQUhFaEgsR0FBRXN2QixJQUNnQyxnQkFFN0N2b0IsR0FIVy9HO01BQUE2TCxNQUNrQiw0QkFEbEI3TDtLQUFBQSxJQUFBNkw7S0FBRXlqQixLQUFBSTs7R0FHaUM7WUFHaER2b0IsTUFBTUosR0FBR0M7SUFDWDtLQUFhLE9BQUEsa0RBRExEO0tBQ1I7O1NBQUEvRzs7TUFDRSxXQUZTZ0gsR0FDWGhILDBCQURRK0csR0FDUi9HO01BQ0UsV0FERkE7a0JBQUFBO01BQUFBOzs7O0dBRUk7WUFHRm1mLE1BQU1wWSxHQUFHQyxHQUFJLE9BQUEsOEJBcEJiRixNQW9CTUMsR0FBR0MsR0FBOEI7WUFDdkNvWSxJQUFJbUIsR0FBRXhaLEdBQUdDLEdBQUksT0FBQSw4QkFyQmJGLE1BcUJJeVosR0FBRXhaLEdBQUdDLEdBQThCO1lBQ3ZDMlksUUFBUTVZLEdBQUksT0FBQSw4QkF0QlpELE1Bc0JRQyxHQUE2QjtZQUNyQzhZLFFBQVE5WSxHQUFJLE9BQUEsOEJBdkJaRCxNQXVCUUMsR0FBNkI7WUFDckN1WSxZQUFZdlksR0FBR04sTUFBTU87SUFBSSxPQUFBLDhCQXhCekJGLE1Bd0JlTCxNQUFNTyxHQUFURDtHQUFtRDtZQUMvRDBZLFdBQVcxWSxHQUFHTixNQUFNTztJQUFJLHlDQXpCeEJGLE1BeUJjTCxNQUFNTztJQUFJLHNCLDhCQUFiRDtHQUFrRDtZQUM3RG9rQixVQUFVcGtCLEdBQUdDO0lBQUksT0FBQSxzQ0FaakJHLE9BWVVKLEdBQUdDO0dBQTJDO1lBQ3hEZ2tCLE1BQU1qa0IsR0FBR0M7SUFBSSxPQUFBLHNDQWJiRyxPQWFNSixHQUFHQztHQUF1QztZQUNoRHN0QixPQUFPdnRCLEdBQUdDO0lBQUksT0FBQSxzQ0FyQmR5cEIsT0FxQk8xcEIsR0FBR0M7R0FBd0M7WUFDbERza0IsU0FBU3ZrQixHQUFHQztJQUFJLE9BQUEsc0NBZmhCRyxPQWVTSixHQUFHQztHQUEwQztZQUN0RHVrQixRQUFReGtCLEdBQUdDO0lBQUksT0FBQSxzQ0FoQmZHLE9BZ0JRSixHQUFHQztHQUF5QztZQUVwRG9hLElBSUVyYSxHQUFFd1A7SUFBSyxJQUhjclEsNEJBR3JCYSxJQUhrQi9HO0lBQ3BCO2dCQURvQkEsSUFBR2tHOztNQUNYLFdBQUEsMEJBRVJxUSwwQkFBRnhQLEdBSGtCL0c7TUFDUjtPQUErQyxJQUR2QzZMLE1BQ3VDLDRCQUR2QzdMO09BQUFBLElBQUE2TDs7Ozs7OztLQUNSOztHQUU0QjtZQUd4Q3l6QyxHQUFJeEksUUFBUUMsYUFBWXR5QztJQUMxQixPQUFHLDBCQURHcXlDLFFBQVFDO2NBQVl0eUM7Y0FQeEIyYztnQkFPd0IzYyxHQUFwQnF5QztnQkE1REoxdkM7aUJBNER3QjNDOzBCQUlQOFI7a0JBQUssT0FBRywwQkFBUkEsR0FKYnVnQzs0QkFBUUM7NEJBSUt4Z0M7aUJBQW1EO2dCQUo1QzlSO0dBS3BCO1lBR0o4NkMsU0FBVXpJLFFBQVFDO0lBQ3BCLEdBandCRWo4QixTQWd3QlVnOEI7S0FFRCxPQUFBLFdBdjBCVFEsc0JBdTBCRztJQUNHLEdBbndCTng4QixTQWd3QmtCaThCO0tBSWYsT0FBQTtJQUVHLFlBQUEsNkJBTklELFFBQVFDO2dCQU9GLE9BQUEsV0E1MEJoQk8sc0JBNDBCVTtRQUNITjtJQUNDLE9BQUE7YUE5MEJSTTtzQkE4MEJhN3lDO2NBQ1QsT0FuRUp3RTt3QkFrRWF4RTtpQ0FDVzhSO3lCQUFLOzttREFGdEJ5Z0MsUUFFdUQsMEJBQXRDemdDOzBEQUFBQTt3QkFBc0Q7d0JBOUU5RW5QO3lCQTZFYTNDO2tDQUVVOFI7MEJBQUs7bUNBSHJCeWdDLFFBR3VDLDBCQUF2QnpnQzt5QkFBc0M7d0JBRmhEOVI7YUFHSDtHQUFFO1lBK0JaKzZDLGFBQWNsbUMsS0FBSW1tQztJQUFLLE9BQVksbUJBQXJCbm1DLEtBQXFCLDRCQUFqQm1tQztHQUFtQztZQUNyRDl0QixXQUFZclksS0FBSTdVLEdBQUd1QztJQUFpQyxXQXZHcERnWixTQXVHZ0J2YjtJQUF5QixPQUR6Qys2QyxhQUNZbG1DLEtBQTZCLGtDQUF0QnRTO0dBQWlEO1lBd0JwRTJqQixPQUFPNWpCLEdBQUdDO0lBQ1osSUFBSXVTLDBCQURLeFMsSUFFTC9HO0lBRUY7UUFGRUEsUUFEQXVaO0tBRVksS0FBQSxXQUhKdlMsR0FHTSxnQkFIVEQsR0FFTC9HO0tBRUYsNkJBRkVBOztPQUFBQSxTQURBdVosR0FNQyxPQVBJeFM7SUFTZ0I7S0FBQSxPQUFBLDRCQVJyQndTO0tBUUVtbUMsTUFBTTtJQUNWLDJCQVZPMzRDLE1BU0gyNEMsUUFQRjEvQztJQVNZLElBQVYyL0MsY0FURjMvQztJQVVGLDZCQVZFQTs7UUFBQUEsUUFEQXVaO01Bb0JRO09BQU5xbUMsUUFBTSw0QkFaTkY7T0FhVSxPQUFBLDRCQXJCWm5tQzthQVVFb21DLHNCQVVBQyxRQTUzQkpoNUMsSUE0M0JJZzVDLFVBVkFEOztLQUdNLElBQUpwcEMsSUFBSSxnQkFkSHhQLEdBRUwvRztLQWFHLEdBQUEsV0FmS2dILEdBY0p1UDtNQUdGLGVBUkFtcEMsS0FFQUMsWUFHRXBwQztNQUlGLDZCQVBBb3BDOztLQVFGLDZCQWpCQTMvQzs7R0FvQjZEO1lBSS9EMHdCLFFBQVEzcEIsR0FBR0M7SUFDYixJQUFJdVMsMEJBRE14UyxJQUVOL0c7SUFFRjtRQUZFQSxRQURBdVo7S0FFaUIsV0FBQSxnQkFIWHhTLEdBRU4vRztLQUNZLEtBQUEsV0FISGdILEdBRVRoSDtLQUVGLDZCQUZFQTs7T0FBQUEsU0FEQXVaLEdBTUMsT0FQS3hTO0lBU2U7S0FBQSxPQUFBLDRCQVJyQndTO0tBUUVtbUMsTUFBTTtJQUNWLDJCQVZRMzRDLE1BU0oyNEMsUUFQRjEvQztJQVNZLElBQVYyL0MsY0FURjMvQztJQVVGLDZCQVZFQTs7UUFBQUEsUUFEQXVaO01Bb0JRO09BQU5xbUMsUUFBTSw0QkFaTkY7T0FhVSxPQUFBLDRCQXJCWm5tQzthQVVFb21DLHNCQVVBQyxRQXQ1QkpoNUMsSUFzNUJJZzVDLFVBVkFEOztLQUdNLElBQUpwcEMsSUFBSSxnQkFkRnhQLEdBRU4vRztLQWFHLEdBQUEsV0FmTWdILEdBRVRoSCxNQVlJdVc7TUFHRixlQVJBbXBDLEtBRUFDLFlBR0VwcEM7TUFJRiw2QkFQQW9wQzs7S0FRRiw2QkFqQkEzL0M7O0dBb0I2RDtZQUcvRDYvQyxZQUFZcDdDLEdBQUc2dEI7SUFDakIsT0FuU0Vtc0IsWUFrU1loNkMsR0FBRzZ0QjtrQkFwUmZ1c0IsWUFvUllwNkMseUJBQUc2dEI7O0dBQ3lEO1lBR3hFd3RCLHNCQUFzQnI3QyxHQUFHNnRCO0lBQzNCLE9BdlNFbXNCLFlBc1NzQmg2QyxHQUFHNnRCO2NBeFJ6QnVzQixZQXdSc0JwNkMseUJBQUc2dEI7Y0FBSDd0QjtHQUN3QztZQUc5RHM3QyxnQkFBZ0J0N0MsR0FBRzZ0QjtJQUNmLFlBVEp1dEIsWUFRZ0JwN0MsR0FBRzZ0QjtnQkFHWCxPQUFBLFdBejhCUjV0QixtQkFzOEJnQkQsR0FBRzZ0QjtRQUVkbGdCO0lBQU8sT0FBUEE7R0FDMEQ7WUFHL0Q0dEMsWUFBWXY3QyxHQUFHdzFCO0lBQ2pCLE9BbFRFdWtCLFlBaVRZLzVDLEdBQUd3MUI7a0JBOVJmNmtCLFlBOFJZcjZDLHlCQUFHdzFCOztHQUN5RDtZQUd4RWdtQixzQkFBc0J4N0MsR0FBR3cxQjtJQUMzQixPQXRURXVrQixZQXFUc0IvNUMsR0FBR3cxQjtjQWxTekI2a0IsWUFrU3NCcjZDLHlCQUFHdzFCO2NBQUh4MUI7R0FDd0M7WUFHOUR5N0MsZ0JBQWdCejdDLEdBQUd3MUI7SUFDZixZQVRKK2xCLFlBUWdCdjdDLEdBQUd3MUI7Z0JBR1gsT0FBQSxXQXY5QlJ2MUIsbUJBbzlCZ0JELEdBQUd3MUI7UUFFZDduQjtJQUFPLE9BQVBBO0dBQzBEO1lBTzdEK3RDLFFBQVFoMkMsR0FBRUM7SUFBSSw2QkFBTkQsNEJBQUVDLEtBQUZELElBQUVDO0dBQXlDO1lBRW5EZzJDLFNBQVMvMEM7SUFDWCxLQURXQSxNQUVIO1FBQ0duQixPQUhBbUIsU0FHVG81QixRQUhTcDVCO0lBR1EsT0FBQSwwQkFBUm5CLE1BQVR1NkIsT0FMQTBiO0dBS3NEO1lBTXRERSxxQkFBdUJyZ0QsR0FBVyxPQUFYQSxFQUFZO1lBQ25Dc2dELGVBQWV2NUMsR0FBRS9HO0lBQUksV0FBQSxrREFBTitHLElBQUUvRztJQUFJLE9BQUE7R0FBZ0I7WUFFakN1Z0QsNEJBQTRCcDJDLEdBQUVDLEdBQUdvMkMsU0FBU0MsU0FBU0M7SUFDekQsSUFEeURDLGVBQUFEO0lBQ3pEO1FBRGdERCxXQUFTRSxjQUVwRCxPQUYyQ0Y7O29DQUFacjJDLEdBS1osV0FMZW8yQyxTQUFIcDJDLEdBQXFCdTJDO29DQUF2QngyQyxHQUlWLFdBSmVxMkMsU0FBTHIyQyxHQUF1QncyQztLQUdqRCxLQUFBLHVDQUlILE9BUG9EQTtLQU1VLElBTlZDLGVBTVUsNEJBTlZEO0tBQUFBLGVBQUFDOztHQU8xQztZQUdiQyx1QkFBdUIxMkMsR0FBRUMsR0FBR28yQztJQUNoQjtLQUFWQztPQUFVO2lEQURXdDJDLDBCQUFFQztJQUUzQixPQVpNbTJDLDRCQVVtQnAyQyxHQUFFQyxHQUFHbzJDLFNBQzFCQztHQUMyRDtZQUd6REssMkJBQTJCcmMsT0FBTXA1QixNQUFNbTFDLFNBQVNDO0lBQ3RELElBRGlDTSxVQUFBdGMsT0FBTW41QixTQUFBRCxNQUFlMjFDLFlBQUFQO0lBQ3REO1VBRHVDbjFDLFFBRS9CLE9BRjhDMDFDO0tBT2xEO01BUG1DOTJDLE9BQUFvQjtNQUFObzVCLFNBQU1wNUI7TUFBZTIxQztRQWZoRFYsNEJBZTJCUSxTQUFBcmMsUUFBWThiLFNBQVNRO0tBQXJCRCxVQUFBcmM7S0FBTXA1QixTQUFBcEI7S0FBZTgyQyxZQUFBQzs7R0FTSTtZQUd4REMsc0JBQXNCNzFDLE1BQU1tMUM7SUFDOUIsS0FEd0JuMUMsTUFFaEI7SUFjZTtLQWJabkIsT0FIYW1CO0tBR3RCbzVCLFFBSHNCcDVCO0tBZ0JsQm8xQyxVQUFpQixzQkF2RHJCTCxTQXVDc0IvMEM7SUFpQnRCLE9BN0JJeTFDLDJCQWVKcmMsT0FBU3Y2QixNQUhtQnMyQyxTQWdCeEJDO0dBQ21EO1lBTXZEVSxnQkFBZ0JoM0MsR0FBRUMsR0FBR28yQyxTQUFTaHBCO0lBQ3RCLElBQU50eEIsTUF6Q0YyNkMsdUJBd0NnQjEyQyxHQUFFQyxHQUFHbzJDO0lBSXZCLE9BQUEsV0FKZ0NocEIsTUFoRTlCMm9CLFFBZ0VnQmgyQyxHQUFFQyxJQUNoQmxFO0dBR2tCO1lBR3BCazdDLGVBQWUvMUMsTUFBTW0xQyxTQUFTaHBCO0lBQ2hDLEtBRGlCbnNCLE1BRVQ7SUFJRTtLQUhDbkIsT0FITW1CO0tBR2ZvNUIsUUFIZXA1QjtLQU1YNUcsSUEzRUoyN0MsU0FxRWUvMEM7S0FPWG8xQyxVQUFKLHNCQURJaDhDO0lBRUosU0FESWc4QyxTQUVDO0lBS0QsSUFIRXY2QyxNQXJERjQ2QywyQkE2Q0pyYyxPQUFTdjZCLE1BSFlzMkMsU0FPakJDO0lBU0YsT0FBQSxXQWhCNEJqcEIsTUFNMUIveUIsR0FLRXlCO0dBS087WUFPYm03QyxjQUFjaDJDO0lBQU8sT0F2QnJCKzFDLGVBdUJjLzFDLE1BbkZkZzFDLGVBdlRGL3RCO0dBMFk4RTtZQUM1RWd2QixjQUFjajJDO0lBQU8sT0F4QnJCKzFDLGVBd0JjLzFDLE1BbkZkaTFDLGdCQXZURnJtQjtHQTBZK0U7WUFDN0VzbkIsZUFBZXAzQyxHQUFFQztJQUFJLE9BaENyQisyQyxnQkFnQ2VoM0MsR0FBRUMsR0FyRmpCaTJDLGVBdlRGL3RCO0dBNFk4RTtZQUM1RWt2QixlQUFlcjNDLEdBQUVDO0lBQUksT0FqQ3JCKzJDLGdCQWlDZWgzQyxHQUFFQyxHQXJGakJrMkMsZ0JBdlRGcm1CO0dBNFkrRTtZQUM3RXduQixxQkFBcUJwMkM7SUFBTyxPQXpENUI2MUMsc0JBeURxQjcxQyxNQXZGckJnMUM7R0F1RjZFO1lBQzdFcUIscUJBQXFCcjJDO0lBQU8sT0ExRDVCNjFDLHNCQTBEcUI3MUMsTUF2RnJCaTFDO0dBdUY4RTtZQUM5RXFCLHNCQUFzQngzQyxHQUFFQztJQUFJLE9BNUU1QnkyQyx1QkE0RXNCMTJDLEdBQUVDLEdBekZ4QmkyQztHQXlGNkU7WUFDN0V1QixzQkFBc0J6M0MsR0FBRUM7SUFBSSxPQTdFNUJ5MkMsdUJBNkVzQjEyQyxHQUFFQyxHQXpGeEJrMkM7R0F5RjhFO1lBd0JoRm52QyxHQUFHK0IsS0FBSTRvQjtJQUFTLE9BQUEsK0JBQWI1b0IsVUFBSTRvQjtHQUE0QztZQUNuRCtsQixRQUFRdHJDLEdBQUksT0FBQSxvQkFBSkEsR0FBWTtZQUVwQnVyQyxhQUFhLzNDO0lBQ2Y7S0FBcUIsT0FBQSx5QkFETkE7S0FDWGhELElBQUk7SUFDUjtxQkFGZWdELFlBRU0vSixHQUFFdVcsR0FBSyxPQUFBLGVBRHhCeFAsR0FDaUIvRyxHQUFFdVcsR0FBb0I7SUFBM0MsT0FBQSw0QkFESXhQO0dBRXdEO1lBTXhEZzdDO0lBQW9DQyxrQkFBaUJDLGFBQVlydUM7SUFDbkU7S0FBSXN1QztPQUNDOzZCQUZpQ0YsaUNBQWlCQztVQUFqQkQ7a0JBQWlCQyxhQUFBQSxjQUFqQkQ7S0FNbEN2cEIsTUFBTTtLQUNOMHBCLE9BQU87YUFOUEQ7SUFPVztpQkFDTCxXQUhOenBCO1NBSWtCMXVCLGdDQUFUcTRDLGlCQUFSQztxQkFWOER6dUM7VUFXeEQwQixJQUROK3NDLFFBQ0c5ckIsSUFHYSwwQkFKUjZyQjs7TUFHTSxJQUZYRSxNQUVXLDBCQUhkRCxTQUNNL3NDLElBREU4c0MsTUFDTDdyQixJQUFBK3JCO0tBS0QsMkJBVkg3cEIsS0FLSWxDLE9BQUFBO0tBS3NCLFdBQUEsMEJBTG5CamhCO0tBS2Esb0JBVHBCNnNDO0tBcUJhLFdBQUEsMEJBakJON3NDO0tBaUJMLGlCQXRCRm1qQixLQUtJbEMsT0FBQUE7S0FrQkksV0FBQSwwQkFsQkRqaEI7S0FrQkwsaUJBdEJGNnNDO2FBR2tCcDRDOztJQWNNO0tBQUEsT0FBQTs7Ozs7U0FBYixtQ0F2QlhtNEM7OzhCQXFCaUIsNkJBWlJFO0tBV0YsMkJBQVksNkJBWGxCQztLQVNHLE9BQUE7SUFBQSxPQUFBO0dBYWE7WUFHbkJFLFdBQVlQLGtCQUFrQkM7SUFDMUI7S0FDSjVyRDtPQXJDQTByRDtTQW1DWUMsa0JBQWtCQzthQUU5QjVyRCxNQUFnQixPQUFoQkE7UUFDR21zRCxlQURIbnNEO0lBRUE7cUJBQ09zc0M7YUFHRjtjQUFJOGY7Y0FDQUM7Z0JBcFhYanlCO2tCQWdYU2tTOzsyQkFLMkIzaUMsR0FBRXVmLEtBQUloSjttQkFDL0I7b0JBQW9CLE9BQUEsMEJBRFdBO29CQUc3QmdELHFCQVZSaXBDO2lDQVVRanBDOzZCQUh5QmdHOzhCQUt6QjtpREFQRmtqQztxQ0FFeUJ6aUQsR0FNbkIsMEJBSEp1WixLQUh5QmdHO2tCQU1PO2FBRXRDLEtBVEltakMsV0FVSSxPQWROL2Y7YUF1Q2M7Y0FEVmdnQixpQ0F0Q0poZ0I7Y0F1Q0lpZ0I7Z0JBQVUsNEJBRFZELFVBbkNGRjtjQXFDRTVmLE1BQU0sMkJBRE4rZjtjQUVTQyxhQUhURjtjQUdrQkcsaUJBRmxCRjtzQkFuQ0ZGOzs7ZUF3Q0UsMkJBNUNKL2YsUUF3Q0lFLFFBQ1NnZ0I7ZUFvQmIsT0FBQSw0QkFyQkloZ0I7O2NBU1U7ZUFKYWtnQjs7ZUFBakJDO2VBQUxDO2VBSVMsT0FBQSw0QkFSREosWUFJUkk7ZUFJRy84QyxNQUFNO2VBRU40OEIsVUFBVSw0QkFWSWdnQixnQkFRZDU4QztlQUk0QixPQUFBLDRCQVIvQis4QztjQVFELDJCQXJESnRnQixXQXdDSUUsS0FXSUMsU0FGQTU4QjtjQU1VLElBQVZnOUMsaUJBQVUsNEJBSlZwZ0I7Y0FLSixlQWhCQUQsS0FlSXFnQixnQkE1RGVqQjtjQThEbkI7Z0JBakJBcGY7Z0JBaUJjLDRCQUZWcWdCO2dCQVZFRjtjQUpHSCxhQUlSSTtjQUppQkgsaUJBY2RJO3NCQVZtQkg7O1lBaUJtQztHQUFDO1lBR3RFSSxlQUFnQm5CLGtCQUFrQkM7SUFDcEIsV0F2RWRNLFdBc0VnQlAsa0JBQWtCQztJQUNwQyxPQUFBLFdBL3NDQTNLLE9BK3NDQTtHQUFvRTtZQUdsRThMLE9BQVFaLGNBQWNQO0lBS3hCO3VDQUxVTztLQUtOUjtPQUdhLHlDQUFLenJDLEdBQUssV0FBTEEsR0FBQUEsR0FBUztJQUUvQixPQWRFNHNDLGVBU0VuQixrQkFMb0JDO0dBVXFCO1lBb0IzQ29CLGFBQWNyQixrQkFBa0JDO0lBQzVCO0tBQ0o1ckQ7T0E3SUEwckQ7U0EySWNDLGtCQUFrQkM7YUFFaEM1ckQsTUFBZ0IsT0FBaEJBO1FBQ0dtc0QsZUFESG5zRDtJQUVBO3FCQUNPc3NDO2FBZUYsSUFDZTNpQyxPQUFFc2pELHFCQURiQzthQUVBO3VDQWpCRjVnQixRQWdCYTNpQzsrQkFBRXNqRDtlQXhCUjtnQkFBQSxPQUFBLGdCQVFQM2dCLEtBZ0JhM2lDO2dCQUlMd2pEO2tCQTVCWixnQ0FHNkJ2Qjs7OzttQkF5QmpCdUI7Y0FDSjtlQUxrQmprQzsrQkFJZGlrQyxXQUxORCxrQkFDV3ZqRCxHQURYdWpEO2VBQ1cxM0MsTUFNUCw0QkFOTzdMO2NBQUFBLElBQUE2TDtjQUFFeTNDLFNBSVBFO2NBTE5ELGNBQ29CaGtDOzthQWN4QixLQWZJZ2tDLGFBZ0JJLE9BL0JONWdCO2FBaUNxQztjQUQ5QjhnQixnQkFqQkxGO2NBaUJGaHZCLE1BakJFZ3ZCO2NBa0JtQyxPQUFBLHlCQWxCbkNBO2NBa0JxQjtnQkFBQSxrREFqQ3ZCNWdCO2NBaUNJRSxNQUFNO3NCQUNGMXRCOztlQUFLMHRDO2VBQVNDOzs7O2dCQUdsQixPQUFBLDJCQXJDSm5nQixRQWlDSUUsUUFDU2dnQjtlQVFDO2dCQUpIVTtnQkFBUE47Z0JBSVUsT0FBQSw0QkFSREosWUFJVEk7Z0JBSUkvOEMsTUFBTTtnQkFFTjQ4QixVQUFVLDRCQVZJZ2dCLGdCQVFkNThDO2dCQUk0QixPQUFBLDRCQVJoQys4QztlQVFBLDJCQTlDSnRnQixXQWlDSUUsS0FXSUMsU0FGQTU4QjtlQU1VO2dCQUFWZzlDLGlCQUFVLDRCQUpWcGdCO2dCQVErQjtrQkFBQTtvQkFwRHZDSCxLQW9ENEMsNEJBZHhDc2dCO2dCQWN1QixPQUFBO2dCQUVsQjFwQyxxQkF4RGJpcEM7O3lCQXdEYWpwQztxQkFETTtzQkFyRGZvcEIsS0FxRG9CLDRCQWZoQnNnQjtxQkFnQlUsMEJBQUwxcEM7ZUFMTCxlQWhCQXNwQixLQWVJcWdCO2VBZEtMLGFBSVRJO2VBSmtCSCxpQkFjZEk7eUJBVkdLOzs7O2VBTlhodkI7aUJBMEJTLGtEQTFEVG9PO2NBa0NReHRCO3NDQWxDUnd0QjtxQ0FpQ0lFO2dCQWxCRjBnQjs7Y0FtQk1wdUM7Z0JBK0JELGtEQWpFUHd0QjtxQ0FpQ0lFO2dCQURHNGdCO2FBaUNMLE9BQUEsNEJBaENFNWdCO1lBaUMwRDtHQUFDO1lBR3RFNmdCLGlCQUFrQjFCLGtCQUFrQkM7SUFDdEIsV0EzRWRvQixhQTBFa0JyQixrQkFBa0JDO0lBQ3RDLE9BQUEsV0EzekNBM0ssT0EyekNBO0dBQXNFO1lBR3BFcU0sU0FBVTFCLGFBQWMsT0FKeEJ5QixvQkFJVXpCLGFBQWdFO1lBRTFFMkIsdUJBQXVCeHhDLEtBQUs2dkMsYUFBWXhnQztJQUMxQyxJQUFhNHVCLE1BR1IsNEJBSnFDNXVCLFNBQzdCdlEsSUFBQW0vQixLQUFFd1Q7SUFDYjthQURXM3lDO01BQ2EsV0FBQSxnQkFGRGtCLEtBQ1psQjtNQUNDLEtBQUEsZ0NBRmdCK3dDO09BRTJDO1FBRDFENkIsUUFDMEQsNEJBRDFERDtRQUFGblQsTUFDb0QsNEJBRHBEeC9CO09BQUFBLElBQUF3L0I7T0FBRW1ULE1BQUFDOzs7O0tBQ29DLE9BRHBDRDs7R0FHQztZQWNkRSxxQkFBcUIzeEMsS0FBSzZ2QyxhQUFZamlEO0ksdUJBQ3pCO0lBRUMsV0FBQSxnQkFIT29TLEtBQWlCcFM7SUFHbkMsT0FBQSxnQ0FIdUJpaUQ7Ozs7WUFNMUIrQixjQUFjNXhDLEtBQUs2dkMsYUFBWXhnQztJQUNqQztLQUFVLE9BekJSbWlDLHVCQXdCY3h4QyxLQUFLNnZDLGFBQVl4Z0M7S0FDN0J3aUMsWUFBTTtLQUNZLE9BQUEsZ0JBRk43eEMsS0FBaUJxUDtLQUV0QixRQUFBLGdDQUZVd2dDO1dBQ2pCZ0M7R0FJc0I7WUFHeEJDLFlBQVk5eEMsS0FBSXFQLEtBQUkwaUM7SUFDdEI7a0NBRGMveEMsUUFBSXFQO3FCQUFBQTtrQkFDbUIsV0FuMkNyQy9jLG1CQWsyQ3NCeS9DO0dBQ2dFO1lBR3BGQyxpQkFBaUJoeUMsS0FBSzZ2QyxhQUFZeGdDO0lBSmxDeWlDLFlBSWlCOXhDLEtBQWlCcVA7eUJBWmxDdWlDLGNBWWlCNXhDLEtBQUs2dkMsYUFBWXhnQztHQUlOO1lBRzVCNGlDLGdCQUFnQmp5QyxLQUFLNnZDLGFBQVl4Z0M7SUFYakN5aUMsWUFXZ0I5eEMsS0FBaUJxUDt5QkFuQmpDdWlDLGNBbUJnQjV4QyxLQUFLNnZDLGFBQVl4Z0M7R0FJSjtZQUc3QjZpQyxnQkFBZ0JseUMsS0FBSzZ2QyxhQUFZeGdDO0lBbEJqQ3lpQyxZQWtCZ0I5eEMsS0FBaUJxUDswQkExQmpDdWlDLGNBMEJnQjV4QyxLQUFLNnZDLGFBQVl4Z0M7R0FJSjtZQUc3QjhpQyxhQUFXbnlDLEtBQUs2dkMsYUFFTHhnQyxLQUZxQm9CO0lBekJoQ3FoQyxZQXlCVzl4QyxLQUVBcVA7SUFhSjtLQWJNK2lDLFdBbkNiUixjQWlDVzV4QyxLQUFLNnZDLGFBRUx4Z0M7S0FBQXpoQixJQUFBeWhCO0tBQUU2aEMsU0FBQWtCO0lBQ2I7UUFEVy9pQyxPQUFBemhCO2dDQUFFc2pEOztPQUtDLFdBQUEsZ0JBUEhseEMsS0FFQXBTO09BS1IsR0FBQSxnQ0FQNkI2aUIsU0FRM0IsV0FOTTdpQjs7O0tBUUQsSUFSQzZMLE1BUUQsNEJBUkM3TDtRQVNULHNCQVhTb1MsUUFFQXZHLEtBVUo7S0FDTyxJQVhEMjNDLFdBekNiTyxxQkF1Q1czeEMsS0FBSzZ2QyxhQUVMcDJDLEtBQUV5M0M7S0FBRnRqRCxJQUFBNkw7S0FBRXkzQyxTQUFBRTs7R0FhOEI7WUFHM0NpQixpQkFBZXJ5QyxLQUFLNnZDLGFBQVl4Z0MsS0FBSW9CO0lBQ2hDLFlBbkJKMGhDLGFBa0JlbnlDLEtBQUs2dkMsYUFBWXhnQyxLQUFJb0I7a0JBVy9CZ2Ysa0JBQU8sT0FBUEE7SUFMQTs4QkFHVSw2QkFUcUJoZjs2QkFRdEIsNkJBUmtCcEI7Ozs2QkFPViw2QkFQRndnQzs7S0FNZix3QkFBUyxXQW40Q2RweEMsV0E2M0NldUI7SUFJYixPQUFBO2FBaDVDSmtzQjthQWc1Q0k7R0FPYTtZQUdmb21CLFFBQU10eUMsS0FBSzZ2QyxhQUFZcC9CO0lBQU8sT0FoQzlCMGhDLGFBZ0NNbnlDLEtBQUs2dkMsZ0JBQVlwL0I7R0FBeUM7WUFDaEU4aEMsWUFBVXZ5QyxLQUFLNnZDLGFBQVlwL0I7SUFBTyxPQWZsQzRoQyxpQkFlVXJ5QyxLQUFLNnZDLGdCQUFZcC9CO0dBQTZDO1lBRXhFK2hDLGNBQVl4eUMsS0FBSzZ2QyxhQU9KeGdDLEtBUG9Cb0I7SUE1RGpDcWhDLFlBNERZOXhDLEtBT0NxUDtJQUhaLEdBQUEsMEJBSmdDb0IsUUFBaEJvL0IsY0FLZDtRQUVVcGdCLFFBQUFwZ0I7SUFDWDtZQURXb2dCLE9BRU47S0FFZ0IsSUFBZmdqQixlQXZHUmpCLHVCQTRGWXh4QyxLQUFLNnZDLGFBT0pwZ0I7S0FLTixTQUFBLDZCQURDZ2pCO01BQ29DLFVBQUEsZ0JBWmhDenlDLEtBT0N5dkI7TUFLb0IsR0FBQSwrQkFaQWhmLFNBYXhCLFdBTklnZjs7S0FPRTtNQUFBLE9BQUEsNEJBUEZBLE9BSUxnakI7TUFKS3BOLFFBT0M7S0FQRDVWLFFBQUE0Vjs7R0FTSjtZQUdUcU4sa0JBQWdCMXlDLEtBQUs2dkMsYUFBWXhnQyxLQUFJb0I7SUFDakMsWUFwQkoraEMsY0FtQmdCeHlDLEtBQUs2dkMsYUFBWXhnQyxLQUFJb0I7a0JBV2hDZ2Ysa0JBQU8sT0FBUEE7SUFMQTsrQkFHVSw2QkFUc0JoZjs4QkFRdkIsNkJBUm1CcEI7OzsrQkFPWCw2QkFQRHdnQzs7S0FNaEIseUJBQVMsV0F2NkNkcHhDLFdBaTZDZ0J1QjtJQUlkLE9BQUE7YUFwN0NKa3NCO2FBbzdDSTtHQU9hO1lBR2Z5bUIsU0FBTzN5QyxLQUFLNnZDLGFBQVlwL0I7SUFDMUIsT0F6M0NBL0gsU0F3M0NTMUk7O2NBakNQd3lDO2VBaUNPeHlDO2VBQUs2dkM7ZUFDOEMsa0RBRG5EN3ZDO2VBQWlCeVE7R0FDdUQ7WUFHL0VtaUMsYUFBVzV5QyxLQUFLNnZDLGFBQVlwL0I7SUFDOUIsT0FuQkVpaUM7YUFrQlcxeUM7YUFBSzZ2QzthQUNlLGtEQURwQjd2QzthQUFpQnlRO0dBQ3dCO1lBS3BEb2lDLFlBQVU3eUMsS0FBSzZ2QyxhQUFhekU7SUFDOUIsZ0JBRDhCQTtTQUlmenpDLElBSmV5ekMsT0FDMUJJLG9CQUdvQnJuQyxHQUFLLE9BNTJCekJtbkMsY0E0MkJXM3pDLEdBQVN3TSxHQUFzQjs7O01BRHBDQSxJQUhvQmluQztNQUMxQkksb0JBRWdCcjBCLEtBQUssT0FBVCwwQkFBSUEsS0FBVmhULEdBQThCO0lBR3hDO0tBQUlyUSxNQUFKLHNCQU5Za007S0FPQ21OO0tBQUkrakM7S0FBT3pGO0tBQVNwOEI7SUFDL0I7UUFEK0JBLFFBRDdCdmI7TUFHWTs7O1VBOTZDaEJVLElBcTZDWXdMLEtBT1l5ckMsVUFFb0IsNEJBSHhDMzNDLEtBQ29CMjNDO1VBQVh0K0I7TUFFRyxPQUFBOztLQUVDO01BQVRpa0MsV0FoSU5PLHFCQXFIVTN4QyxLQUFLNnZDLGFBT2dCeGdDLEtBQWhCNmhDO01BS2IscUJBRElFO0tBSUQsVUFkSDVGLFNBY1ksZ0JBZkp4ckMsS0FPcUJxUDtNQVViO09BQVZ3OEI7U0F0N0NWcjNDLElBcTZDWXdMLEtBT1l5ckMsVUFVdUIsNEJBVmRwOEIsS0FBVG84QjtPQUFTaGMsUUFXWSw0QkFYWnBnQjtPQUFUczhCLGFBV1csNEJBWEZ0OEI7T0FBcEJ3UCxZQVVIZ3RCLFNBVkcxK0I7TUFBQUEsTUFBQTBSO01BQUlxeUIsU0FJVEU7TUFKZ0IzRixXQUFBRTtNQUFTdDhCLE1BQUFvZ0I7OztLQVlDLElBWkQ0VixRQVlDLDRCQVpEaDJCO0tBQWhCNmhDLFNBSVRFO0tBSnlCL2hDLE1BQUFnMkI7O0dBY2I7WUFHbEJ5TixRQUFNOXlDLEtBQUtvckM7SUFBdUIsMkJBQXZCQTtJQUFLLHFCLE9BeEJoQnlILFlBd0JNN3lDO0dBQXNDO1lBQzVDK3lDLGlCQUFlL3lDLEtBQVFnc0M7SUFBMEIseUJBQTFCQTtJQUFRLHFCLE9BekIvQjZHLFlBeUJlN3lDO0dBQW9EO1lBRW5FZ3pDLFNBQVNoekMsS0FBSXFQO0lBQ2Y7S0FBc0QsTUFBQSxrREFEM0NyUCxNQUFJcVA7S0FDc0MsTUFBQTtLQUE1QixNQWo4Q3pCN2EsSUFnOENXd0wsS0FDMkIsNEJBRHZCcVA7SUFDZixXQWo4Q0E3YSxJQWc4Q1d3TCxRQUFJcVA7R0FDNEQ7WUFHekU0akMsVUFBUWp6QyxLQUFLb3JDLElBQUl5RTtJQUNSLFVBOUVUeUMsUUE2RVF0eUMsS0FBUzZ2QyxhQUFKekU7SUFDMkIsT0FBQTs0Q0FBS25uRCxHQUFLLE9BTGxEK3VELFNBSVFoekMsS0FDcUMvYixHQUFtQjtHQUFDO1lBR2pFaXZELFVBQVFsekMsS0FBS29yQyxJQUFJeUU7SUFDUixVQTlDVDhDLFNBNkNRM3lDLEtBQVM2dkMsYUFBSnpFO0lBQzRCLE9BQUE7NENBQUtubkQsR0FBSyxPQVRuRCt1RCxTQVFRaHpDLEtBQ3NDL2IsR0FBbUI7R0FBQztZQUdsRWt2RCxjQUFZbnpDLEtBQUtvckMsSUFBSXlFO0lBQWMsT0FabkNtRCxTQVlZaHpDLEtBcEZadXlDLFlBb0ZZdnlDLEtBQVM2dkMsYUFBSnpFO0dBQThEO1lBQy9FZ0ksY0FBWXB6QyxLQUFLb3JDLElBQUl5RTtJQUFjLE9BYm5DbUQsU0FhWWh6QyxLQTlDWjR5QyxhQThDWTV5QyxLQUFTNnZDLGFBQUp6RTtHQUErRDtZQUloRmlJLHNCQUF1Qmh1QixNQUFNd3FCLGFBQVlsN0M7SUFDM0MsT0F4eUJBaTRDOzthQXV5QjJDajRDO3NCQUMxQi9HLEdBQUV1VztjQUNaLGNBQUEsV0FGa0JraEIsTUFDTmxoQjtjQUNaOzs7ZUFDRixVQWxKSDZ0QyxpQkErSXlDcjlDLEdBQVprN0MsYUFDZGppRDtlQUVaLFVBRkwsT0F6SUVxa0QsZ0JBd0l5Q3Q5QyxHQUFaazdDLGFBQ2RqaUQ7OztjQUNWO2FBRThCO0dBQUM7WUFHcEMwbEQsdUJBQXdCanVCLE1BQU13cUIsYUFBWWw3QztJQUM1QyxPQXgwQkFnNEM7O2FBdTBCNENoNEM7c0JBQzNCL0csR0FBRXVXO2NBQ1osY0FBQSxXQUZtQmtoQixNQUNQbGhCO2NBQ1o7OztlQUNGLFVBekpINnRDLGlCQXNKMENyOUMsR0FBWms3QyxhQUNmamlEO2VBRVosVUFGTCxPQWhKRXFrRCxnQkErSTBDdDlDLEdBQVprN0MsYUFDZmppRDs7O2NBQ1Y7YUFFOEI7R0FBQztZQUdwQzJsRCxlQUFpQi80QyxLQUEyQjdGLEdBQUdrN0M7SUFDakQsR0FEbUJyMUMsU0FBT0MsTUFBUEQsUUFBQTZxQixPQUFPNXFCLGNBQVA0cUI7SUFDYixZQWZKZ3VCLHNCQWNpQmh1QixNQUE4QndxQixhQUFIbDdDO2dCQUVwQztRQUNIL0c7V0FBQUEsTUFBWSxrREFIMkIrRztjQUFBQTtjQWoxQjlDdXJCLE9BaTFCOEN2ckIsR0FHTyw0QkFBOUMvRztHQUFxRDtZQUcxRDRsRCxlQUFpQmg1QyxLQUEyQjdGLEdBQUdrN0M7SUFDakQsR0FEbUJyMUMsU0FBT0MsTUFBUEQsUUFBQTZxQixPQUFPNXFCLGNBQVA0cUI7SUFDYixZQWRKaXVCLHVCQWFpQmp1QixNQUE4QndxQixhQUFIbDdDO2dCQUVwQztRQUVId1M7aUJBQUFBLElBSnVDeFMsSUEvMUI5QzgzQyxZQSsxQjhDOTNDLEdBSXZDd1M7R0FBb0I7WUFNekJzc0MsY0FBZ0JqNUMsS0FBMkI3RixHQUFHazdDO0lBQ2hELEdBRGtCcjFDLFNBQU9DLE1BQVBELFFBQUE2cUIsT0FBTzVxQixjQUFQNHFCO0lBQ2xCLElBQUk1dUIsU0FBSixzQkFENkM5Qjs7YUFDekM4QjtLQUVnQzs7T0FBZCxXQUhKNHVCLE1BR1MsZ0JBSGtCMXdCOzs7UUFHVDtVQUhsQjB3QixNQUd1QixnQkFISTF3QixHQUdELDRCQUZ4QzhCOztLQUtJLFlBN0JONjhDLHVCQXVCZ0JqdUIsTUFBOEJ3cUIsYUFBSGw3QztpQkFPakM7S0FFRDtNQURGMDlCO01BQ0UsVUF2Q1RnaEIsc0JBOEJnQmh1QixNQUE4QndxQixhQUFIbDdDOztNQVU5QixNQUFBO0tBQzRCLElBQS9CcXJCLG1CQUErQixNQUFBLDRCQUEvQkEsTUFISHFTO0tBR2lDLE9BMS9DMUM3OUIsSUErK0M2Q0csR0FRcEMwOUIsT0FHaUM7O0lBUHJDLE9BSndDMTlCO0dBV2lCO1lBUzlEKytDLFVBQVEvK0MsR0FBR2s1QixLQUFLQztJQUFPLFVBQUEsZ0NBQVpELEtBQUhsNUI7SUFBZSw2Q0FBZkEsR0FBUW01QjtHQUE0QjtZQUM1Q0MsZ0JBQWdCcDVCLEdBQUd2USxLQUFLRDtJQUFNLE9BQUcsZ0NBQWpCd1EsR0FBR3ZRO2NBQUFBO2NBQXVDLGdDQUExQ3VRLEdBQVF4USxPQUFSd1EsSUFBUXhRO0dBQTBEO1lBRWxGd3ZELFlBQVVoL0MsR0FBR3ZRLEtBQUtEO0lBQ3BCLEdBQU8sZ0NBRFFDLEtBQUtEO0tBRXBCLE9BSkU0cEMsZ0JBRVVwNUIsR0FBR3ZRLEtBQUtEO0lBQ3BCLE1BQUE7R0FDMkI7WUFHekJ5dkQsUUFBTWovQyxHQUFHdlEsS0FBS0Q7SUFDaEIsS0FBRyxnQ0FEUUMsS0FBS0Q7S0FPWCxXQWRINHBDLGdCQU9NcDVCLEdBQUd2USxLQUFLRDtJQU1UOzRCQUFpQyxXQXJpRHBDc2EsV0EraERZdGE7S0FNVCx1QkFBUyxXQXJpRFpzYSxXQStoRE9yYTtLQUlQLE1BQUE7SUFBQSxPQUFBO0dBR2lDO1lBUWpDeXZELFNBQVNyNUMsS0FBdUIyckM7SUFBVSxHQUFqQzNyQztTQUFpQkMsTUFBakJELFFBQUEwckMsaUJBQWlCenJDOztTQUFqQnlyQztJQUFpQyxPQXgzQzFDcnlDLE9BdzNDZ0NzeUMsU0FBdkJEO0dBQStEOzs7Ozs7Ozs7Ozs7Ozs7OztPQTdpRHZFM25DO09BbUJIL0o7T0FhQXE4QjtPQXV3QkE3aEI7T0FqdkJBdEc7O09BaXRCQWhVO09Bd0JBd1k7T0FDQUc7T0FuQ0F4VztPQUtBSztPQXlCQTZWO09BQ0FDO09BbEhBVztPQU1BRDtPQXBKQWpaO09BK05BbVo7T0FrQ0FMO09BQ0FFO09BVEExWTtPQWdCQW9rQjtPQURBRDtPQURBZ0o7T0FEQXRKO09BREFHO09BM3lCRzFlO09BUURnTDtPQUNBNUc7T0FpaEJGdkk7T0FDQUQ7Ozs7Ozs7Ozs7OztPQXFnQ0F5OUM7T0FHQUM7T0FLQUM7O09BcGRBNzBDO09BdGtDRXN3QjtPQVNGN3dCOzs7O09Bc2dCQW5LOzs7O09BcGVBK3dDOzs7Ozs7UUF3Y0lqOUI7UUFTQUM7UUF6Q0E2YTtRQUNBaW5CO1FBQ0NqbUI7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBd0NEMkQ7UUFDQTNIO1FBTUEycUI7UUFDQUM7UUFOQU47UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7T0FoWkozRjtPQW5EQVM7T0E2REFPO09BdERBTjtPQWlEQUs7T0F4QkFGO09Ba0NBSTtPQTNCQUg7O1FBdUNFdmxDO1FBMjVDQXN6QztRQXA1Q0ExTjtRQUNBRDtRQXlFQVc7UUFFQS9CO1FBS0FpQztRQVNBQztRQStCQUU7UUFvQkFLO1FBZ0NBSTs7T0E4RkZxQjtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQW9PQWlEO09BNUdBaFg7T0FNQTE5QjtPQW1HQXcwQztPQUNBQztPQXpGQXZCO09BVUFJO09BVUFDO09BS0FFO09BK0JBUztPQUNBQztPQUVBSTtPQXVEQVE7T0F5QkFDO09Bb0JBSTtPQVJBRjtPQWtCQUc7T0F1QkFqNEM7T0FWQUM7T0FzQ0FvcEI7T0FvRkFrQjtPQXdCQWhIO09BMEJBK0Y7T0F0R0E0dUI7T0FRQUM7T0E2SUFXO09BZEFIO09BTUFDO09BZEFIO09Ba0JBSTtPQWRBSDtPQS9RQTdsQjtPQURBM0g7T0FKQXdzQjtPQUpBRDtPQW1aRXlDO09BREFEO09BS0FLO09BREFEO09BREFEO09BREFEO09BS0FLO09BREFEO09BaE5GbkM7O09BME9BcUM7T0FFQUM7O1FBa0hFcUI7UUF0RUFaO1FBMEVBYTtRQXdHQU07UUExRUFMO1FBOEVBTTtRQXNDQVM7UUFPQUM7UUFPQUM7UUF1Q0FJO1FBQ0FDO1FBbUNBSTtRQUlBQztRQXhFQVQ7UUFrQkFFO1FBaUJBRztRQW1CQUU7UUFnREFJO1FBQ0FDO1FBTUFFO1FBUUFFO1FBSkFEO1FBS0FFO1FBd0JBSTtRQU5BRDtRQWdCQUU7OztFOzs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7O0lDMWdEQXowQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBYkZrbUM7SUFLRTcvQjtJQUNBNUc7SUFDQ0Y7STlDaUNIM0s7SUFHQTVJO0lBQ0FtSjtJQUNBTjtJQUNBTztJQUNBdVE7SUFDQTNQO0lBQ0FDO0lBRUEyUDtJQUNBM087SUFDQUM7SUFDQTJPO0lBQ0FDOztZOEN6Q0UvRixHQUFHM00sS0FBSXVDO0lBQWlDLFVBQUEsVzlDc0MxQ3NCLFc4Q3RDU3RCO0lBQWlDLE9BQUEsK0JBQXJDdkM7R0FBa0Q7WUFRbkR5aEQsU0FBUS8vQyxLQUFNLE9BQUEsVzlDdUJsQkQsUThDdkJZQyxLQUFnQjs7OztnREFBeEIrL0MsVTlDNkJKanZDOzs7Ozs7b0RBUkE1WixTOENyQ0V5VDtxREFRQU0sSUFEQUM7OztZQWdDSTgwQyxTQUFRaGdELEtBQU0sT0FBQSxXOUNBcEJELFE4Q0FjQyxLQUFnQjs7SUFDeEIyQztJQUNBczlDO0lBUEFobUM7OztxQ0FBQUE7WUFNQXRYLFFBREFxOUMsVUFFQUM7Ozs7Ozs7O1lBR052MUMsaUJBQW9CLFNBQUU7WUFFdEJuSyxLQUFLOFMsR0FBR3ZTO0lBQ1YsR0FET3VTLE9BRUYsZ0NBRkVBO0lBR0M7S0FBSnhTLElBQUksVzlDVk5kLFE4Q09Lc1Q7S0FJTSxNQUFBLDRCQUpOQTtLQUdDOztTQUNSdlo7OzRCQURJK0csR0FDSi9HLEdBQ2lCLFdBTFBnSCxHQUlWaEg7TUFBQSxVQUFBQTtpQkFBQUE7TUFBQUE7OztJQUdBLE9BSkkrRztHQUlIO1lBR0MrNkMsYUFBYS8zQztJQUNQLElBQUpoRCxJQUFJLFc5Q2xCTmQsUThDa0JhLHlCQURBOEQ7SUFFZjtxQkFGZUEsWUFFTS9KLEdBQUV1VyxHQUFLLE9BQUEsZUFEeEJ4UCxHQUNpQi9HLEdBQUV1VyxHQUFjO0lBQXJDLE9BREl4UDtHQUVIO1lBR0NGLFFBQ1dFO0lBQWI7S0FBZTR0QixNQUtSLGlEQUxNNXRCO0tBQUUvRyxJQUFBMjBCO0tBQUVwVjtJQUNmO1lBRGF2ZixHQUVSLE9BRlV1ZjtLQUdLO01BSEwwUixrQ0FBSmxxQixHQUFFL0csSUFBRXVmO01BQUYxVCxNQUdELDRCQUhDN0w7S0FBQUEsSUFBQTZMO0tBQUUwVCxNQUFBMFI7O0dBS087WUFHdEJqUixTQUFTalo7SUFBSSxPQUF5Qjs7a0NBQTdCQTtzQkFBa0MvRyxHQUFLLDZCQUF2QytHLEdBQWtDL0csR0FBbUI7R0FBQztZQUMvRHlWLE1BQUkxTyxHQUFHQyxHQUFJLE9BQUEsVzlDOUJYSSxLOEM4Qk9KLEdBQUhELEdBQWU7WUFDbkJxL0MsT0FBS3IvQyxHQUFHQyxHQUFJLE9BQUEsVzlDOUJaSyxNOEM4QlFMLEdBQUhELEdBQWdCO1lBRXJCRCxLQU1FQyxHQUFHTixNQUFNTztJQUFLLElBTENkLDJCQUtmYSxJQUxvQjBhLFNBQUlsQyxNQUtyQjlZO0lBSkw7UUFEc0JnYixRQUFMdmIsS0FFWixPQUZxQnFaO0tBR1M7TUFIVDBSLFFBR1MsV0FFeEJqcUIsR0FMZXVZLDJCQUt4QnhZLEdBTG9CMGE7TUFBQW9nQixRQUdHLDRCQUhIcGdCO0tBQUFBLE1BQUFvZ0I7S0FBSXRpQixNQUFBMFI7O0dBSzJCO1lBR3JEUixNQU1FMXBCLEdBQUdOLE1BQU1PO0lBQUssSUFMQ2QsMkJBS2ZhLElBTG9CMGEsU0FBSWxDLE1BS3JCOVk7SUFKTDtRQURzQmdiLFFBQUx2YixLQUVaLE9BRnFCcVo7S0FHUztNQUhUMFIsUUFHUyxXQUV4QmpxQixHQUxXeWEsS0FBSWxDLDJCQUt4QnhZLEdBTG9CMGE7TUFBQW9nQixRQUdHLDRCQUhIcGdCO0tBQUFBLE1BQUFvZ0I7S0FBSXRpQixNQUFBMFI7O0dBSzJCO1lBR3JEcXVCLEdBQUl4SSxRQUFRQyxhQUFZdHlDO0lBQzFCO0tBQWEsTUFBQSxpREFEYUE7S0FDMUI7O1NBQUF6RTs7TUFDSyxHQUFBLGdEQUZxQnlFLEdBQzFCekUsSUFETTgyQzs2QkFBb0JyeUMsR0FDMUJ6RSxHQURjKzJDO01BQ2QsVUFBQS8yQztpQkFBQUE7TUFBQUE7Ozs7R0FFSTtZQUdGdS9DLFNBQVV6SSxRQUFRQztJQUNwQiwrQkFEWUQ7S0FFRCxPQUFBLFdBM0dUUSxxQjttQ0F5R2tCUDtLQUlmLE9BQUE7SUFFRyxZQUFBLDZCQU5JRCxRQUFRQztnQkFPRixPQUFBLFdBaEhoQk8scUI7UUFpSE9OO0lBQ0MsT0FBQTthQWxIUk07c0JBa0hhN3lDO2NBQ1Q7ZUFBYSxNQUFBLGlEQURKQTtlQUNUOzttQkFBQXpFOzs7a0JBRFN5RTtrQkFDVHpFOztvQkFGR2czQztvQkFHd0MsZ0RBRmxDdnlDLEdBQ1R6RTtnQkFBQSxVQUFBQTsyQkFBQUE7Z0JBQUFBOzs7O2FBRUk7R0FBRTtZQUdWZ2dDLFFBQVFqNUIsR0FBR2s1QixLQUFLQztJQUFPLFVBQUEsZ0NBQVpELEtBQUhsNUI7SUFBZSw2Q0FBZkEsR0FBUW01QjtHQUE0QjtZQUM1Q0MsZ0JBQWdCcDVCLEdBQUd2USxLQUFLRDtJQUFNLE9BQUcsZ0NBQWpCd1EsR0FBR3ZRO2NBQUFBO2NBQXVDLGdDQUExQ3VRLEdBQVF4USxPQUFSd1EsSUFBUXhRO0dBQTBEO1lBRWxGNnBDLFVBQVVyNUIsR0FBR3ZRLEtBQUtEO0lBQ3BCLEdBQU8sZ0NBRFFDLEtBQUtEO0tBRXBCLE9BSkU0cEMsZ0JBRVVwNUIsR0FBR3ZRLEtBQUtEO0lBQ3BCLE1BQUE7R0FDMkI7WUFHekI4cEMsTUFBTXQ1QixHQUFHdlEsS0FBS0Q7SUFDaEIsS0FBRyxnQ0FEUUMsS0FBS0Q7S0FPWCxXQWRINHBDLGdCQU9NcDVCLEdBQUd2USxLQUFLRDtJQU1UOzRCQUFpQyxXQWhJcENzYSxXQTBIWXRhO0tBTVQsdUJBQVMsV0FoSVpzYSxXQTBIT3JhO0tBSVAsTUFBQTtJQUFBLE9BQUE7R0FHaUM7WUFHbkNnaEQsU0FBVS8xQixLQUFLdmIsS0FBSWEsR0FBRThiO0lBQ3ZCO0tBQ0U7T0FBQTs7U0FGVXBCO1NBQUt2Yjs7OEJBQUlhO0tBQ1orYTtLQUlJK2Y7S0FEVHpQLE9BQU8sNEJBQ0V5UCxPQUpKL2Y7S0FJSTloQixJQUFBNmhDO0lBQ1g7ZUFEVzdoQyxJQURUb3lCOztNQUdhO09BQUEsTUFBQSxlQVBJcnJCLEdBS1IvRztPQUVQLE1BQUEsK0JBUGlCNmlCO01BT2pCO09BQWtDLElBRjNCaFgsTUFFMkIsNEJBRjNCN0w7T0FBQUEsSUFBQTZMOzs7Ozs7O0tBRVA7O0dBRUU7Ozs7Ozs7Ozs7Ozs7Ozs7O09BOUlKNEw7T0FDQTVHO09BQ0NGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FpSEhxdkI7T0FHQUk7T0FLQUM7O085QzNFQS8zQjtPQURBRDs7TzhDRkF1STs7O085Q0xBM0s7T0FFQThRO084QytCQXRCO09BQ0Eyd0M7TzlDbkNBNy9DO084Q1FBRTtPQVVBcTdDOzs7TzlDaEJBdDdDO084Q3FEQTg0QztPQU1BQztPQXJDQTE0QztPQVNBbVo7T0FJQWxaO09BU0EycEI7T0FnREErbUI7TzlDbEdBeHhDO09BY0FpUjtPQUNBQzs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7O0krQ25EQW12Qzs7Ozs7Ozs7Ozs7Ozs7WUFzSElDLFVBRXNCQztJQUQzQixJQUNrQ0M7SUFDbkM7S0FBTTtNQUQ2QkM7UUFDN0I7NkJBekhKSixrQkF3SGlDRyxpQkFBUEQ7Y0FBT0U7TUFPbkM7O1NBQUEsOEJBUDRCRixRQUFBQSxtQkFBQUE7TTs7Y0FBT0U7TUFpQm5DOztTQUFBLDhCQWpCNEJGLFFBQUFBLG1CQUFBQTtNOztLQXNCTCxXQXRCS0EsV0FBQUE7S0FBT0Msa0JBQUFDOztHQURBOzRCQUQ3Qkg7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQ3pISkksZ0JBQWdCcndELEdBQUU4VCxHQUFFQyxHQUFFL0I7SUFLdEIsVUFBQSxXQUxzQkEsV0FBTmhTO0lBQ2xCLE9BQUEsZ0NBRG9COFQsR0FBRUM7R0FNbEI7R0FPbUI7SUFIckJ1OEM7SUFHQUMscUJBQXFCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRnJCQztJQUNBQzthQUZBSCx1QkFBQUEsdUJBQUFBO0lBSUssTUFBQTs7SUF1QkRJO0lBQ0FDO0lBckJKQztJQUNBQztJQUNBQztJQUNBQztJQUdBQztJQUNBQztZQU1BQyx3QjtZQUNBQyx3Qjs7OztJQUVBQztNQXZCQWQ7eUJBeUJZLFNBQUk7O1NBSVp0d0Q7U0FBSztnQkFBQSw2QkFGTDB3RCxXQUVBMXdEOzs7ZUFBK0IsNkJBQS9CQSxHQURBMndEOzs7UUFDcUQ7WUE3QnpETDs4QkFrQ1ksU0FBSTs7SUFDYjtLQUNDaHFEO0tBQ0FEOztnQkFDQXJHO1FBQUs7ZUFBQSw2QkFGTHNHLE9BRUF0RztxQkFBaUMsNkJBQWpDQSxHQURBcUc7O09BQ3lEO1lBRzdEZ3JELGFBQWFyeEQ7SUFDZixPQW5CRW94RCw4QkFrQmFweEQsU0FBQUE7R0FDOEQ7WUFHM0VzeEQsYUFBYXR4RCxHQUNmLFdBRGVBLFNBQUFBLE9BQzhEO1lBRzNFdXhELGlCQUFpQnZ4RDtJQUNuQixPQTNCRW94RCw4QkEwQmlCcHhEO2NBQUFBO2NBM0RqQnF3RCxnQkEyRGlCcndEO0dBQ3FFO1lBR3RGd3hELGlCQUFpQnh4RDtJQUNuQixXQURtQkEsS0FBQUEsSUEvRGpCcXdELGdCQStEaUJyd0Q7R0FDcUU7TUF0RHRGc3dEO0lBNERLLE1BQUE7O0lBQ0xtQjtJQUNBQztJQUdFeHBEO0lBQ0FEO1lBRkYwcEQsOEJBR0UzeEQ7SUFBSztXQUFBLDZCQUZMa0ksT0FFQWxJO2lCQUFpQyw2QkFBakNBLEdBREFpSTs7R0FDeUQ7WUFHM0QycEQsYUFBYTV4RDtJQUNmLE9BUEUyeEQsOEJBTWEzeEQsNkJBQUFBO0dBQzhEO1lBRzNFNnhELGlCQUFpQjd4RDtJQUNuQixPQVhFMnhELDhCQVVpQjN4RDtrQ0FBQUE7Y0FwRmpCcXdELGdCQW9GaUJyd0QseUJBN0RqQmd4RDtHQThEc0Y7TUEzRXRGVixlQUdBQztJQThFSyxNQUFBO1lBQ0x1QixzQjtZQUNBQyw0QjtNQWhGQXhCLHNCQUhBRDs4QkF1RlksU0FBSTs7SUFDYjtLQUNDcHFEO0tBQ0FEOztnQkFDQWpHO1FBQUs7ZUFBQSw2QkFGTGtHLE9BRUFsRztxQkFBcUMsNkJBQXJDQSxHQURBaUc7O09BQ2lFO1lBR3JFK3JELGlCQUFpQmh5RCxHQUNuQixXQURtQkEsU0FBQUEsT0FDa0U7WUFHbkZpeUQscUJBQXFCanlEO0lBQ3ZCLFdBRHVCQTtjQUFBQTtjQTVHckJxd0Q7ZUE0R3FCcndELDZCQXBGckJpeEQ7R0F1RjZCOztJQU83QmlCO0lBQ0FDO0lBR0U3cUQsNEJBckZFb3BEO0lBc0ZGcnBELDRCQXJGRXNwRDtZQW1GSnlCLCtCQUdFcHlEO0lBQUs7V0FBQSw2QkFGTHNILE9BRUF0SDtpQkFBaUMsNkJBQWpDQSxHQURBcUg7O0dBQ3lEO1lBRzNEZ3JELGVBQWVyeUQ7SUFDakIsT0FQRW95RCwrQkFNZXB5RCw2QkFBQUE7R0FDZ0U7WUFHL0VzeUQsbUJBQW1CdHlEO0lBQ3JCLE9BWEVveUQsK0JBVW1CcHlEO2tDQUFBQTtjQW5JbkJxd0QsZ0JBbUltQnJ3RCw2QkE1R25CZ3hEO0dBK0cyQjtXQXpIM0JUO0lBa0lLLE1BQUE7WUFDTGdDLHdCO1lBQ0FDLDhCOzs7TUFwSUFqQzt5QkF3SVksU0FBSTs7U0FJWnZ3RDtTQUFLO2dCQUFBLDZCQXBITDB3RCxXQW9IQTF3RDs7O2VBQXFDLDZCQUFyQ0EsR0FuSEEyd0Q7OztRQW1IaUU7WUFHckU4QixtQkFBbUJ6eUQsR0FDckIsV0FEcUJBLFNBQUFBLE9BR1o7WUFHUDB5RCx1QkFBdUIxeUQ7SUFDekIsV0FEeUJBO2NBQUFBO2NBbEt2QnF3RDtlQWtLdUJyd0QsaUNBMUl2Qml4RDtHQTZJK0I7TUF4Si9CVjtJQThKSyxNQUFBOztJQUNMb0M7SUFDQUM7WUFoS0FyQztRQWtLQXNDLGlEQUVZLFNBQUk7OztLQUVaM3JELDRCQWhLSjRwRDtLQWlLSTdwRCw0QkFoS0o4cEQ7S0EySkE4QjtnQkFNSTd5RDtRQUFLO2VBQUEsNkJBRkxrSCxPQUVBbEg7cUJBQWlDLDZCQUFqQ0EsR0FEQWlIOztPQUN5RDtZQUc3RDZyRCxtQkFBbUI5eUQ7SUFDckIsT0FWRTZ5RCwrQkFTbUI3eUQsNkJBQUFBO0dBR1o7WUFHUCt5RCx1QkFBdUIveUQ7SUFDekIsT0FoQkU2eUQsK0JBZXVCN3lEO2tDQUFBQTtjQTlMdkJxd0Q7ZUE4THVCcndELGlDQXZLdkJneEQ7R0EwSytCO0dBUXZCO0lBQU43d0QsTUFBTSx1QkF4TFJ5d0Q7SUF5TEUxd0QsTUFBTSx1QkF4TFIyd0Q7WUFzTEFtQywrQkFHRWh6RDtJQUFLO1dBQUEsNkJBRkxHLEtBRUFIO2lCQUFpQyw2QkFBakNBLEdBREFFOztHQUN5RDtZQUczRCt5RCx1QkFBdUJqekQ7SUFDekIsT0FQRWd6RCwrQkFNdUJoekQ7O2NBOU12QnF3RCxnQkE4TXVCcndELDJCQXZMdkJneEQ7R0F3THdFO1lBS3hFa0MsdUJBQXVCNXhELE9BQU82eEQsV0FBV0M7SUFDM0MsSUFBSUMsNkNBRHFCL3hEO09BQ3JCK3hELGdCQUR1Q0QscUJBR3RDLE9BSG9COXhEO0lBTWYsWUFBQSxnQkFOZUE7OzswQ0FLbkJneUQ7U0FBQUE7O0lBS0o7S0FBSUM7T0FMQUQsV0FLOEIsNEJBVGhDRCxtQkFBQUE7S0FVbUIsTUFBQSw0QkFEakJFO0tBQ0FDLGlCQUFpQixpQ0FYb0JKO0tBWXJDSyxnQkFBZ0IsNEJBWGxCSixjQVVFRztLQUVBbHhELFNBQVMsMkJBRFRteEQ7S0FFQUMsZ0JBQWdCLDRCQWJsQkw7S0FjRU0saUJBQWlCLDRCQUhqQkY7S0FJQUcsZ0NBaEJxQ1I7S0FpQnJDUyxrQkFaQVA7SUFzQkY7UUFWRU8sa0JBSEFIO1NBVEFKO09Bd0JnQyxVQUFBLGdCQTdCYmh5RDtPQTZCTiwyQkFoQmJnQjs7TUFnQmEsT0FBQSwyQkFoQmJBOztjQUdBc3hEO01BS0EsMkJBUkF0eEQsUUFFQXF4RCxlQWYwQlI7TUFzQjFCLDZCQVBBUTtNQUNBQywrQkFoQnFDUjs7S0F3QlYsVUFBQSxnQkF4QlI5eEQsT0FjbkJveUQ7S0FVRiwyQkFYRXB4RCxRQUVBcXhEO0tBVUYsNkJBWEVEO0tBWUYsNkJBWEVDO0tBWUYsNkJBWEVDOztHQWM4RDtZQUdsRUUsaUJBQWlCeHlELE9BQU82eEQ7SUFDMUIsT0FsQ0VELHVCQWlDaUI1eEQsT0FBTzZ4RDtHQUNvQztZQUc1RFksbUJBQW1CenlELE9BQVEsT0FKM0J3eUQsaUJBSW1CeHlELFdBQTZDOztJQUNoRTB5RDs7O09Bdk1BM0M7T0FRQUU7T0E1QkFKO09Bd0NBTTtPQXFCQUs7T0FyQ0FSO09BUUFFO09BakNBTjtPQXdGQWdCO09BMEJBSztPQWhFQVg7T0FJQUM7T0FaQUg7T0F1REFXO09BSUFDO09BWkFIO09BaUVBVztPQU1BQztPQWxCQUo7T0FrQ0FNO09BTkFEO09BaEdBaEI7T0FJQUM7T0FmQUY7T0ErREFVO09BTUFDO09BakJBRjtPQTRCQUk7T0FuS0F0QztPQUNBRTtPQUNBQztPQUNBRjs7WUF1UEU2QztpQkFFQXZzQixjQUFnQnR3QixLQUFpQjdGO1NBQ25DLEdBRGtCNkYsU0FBWUMsTUFBWkQsUUFBQTQ4QyxZQUFZMzhDLGNBQVoyOEM7U0FDbEIsT0FuREFEO2tCQW1EdUIsaUJBRFl4aUQsSUFBakJ5aUQsV0FGaEJDO1FBR2tFO2lCQUdsRTU0QyxVQUFVOUo7U0FDWjtVQUFJdEMsSUFBSSxpQkFESXNDO1VBQ1J3RTswQkFqQko4K0M7ZUFpQkk1bEQ7ZUF2REo4a0QsdUJBdURJOWtELE9BUEZnbEQ7U0FRRixXQURJbCtDO1FBSXNCO21CQVR4QjJ4QixlQUlBcnNCOzs7WUE0QkV6VCxnQkFFQ3FQLG9CQUlDbUg7UUFDSixTQUZHeEQsS0FFQy9aLEdBQUssT0FBQSxXQURMdWQsTUFDQXZkLEdBQVc7WUFLYm96RDtpQkFFQXBoRCxVQUFZbWhELFdBQVV6aUQ7U0FDeEIsR0FEY3lpRDs7V0FJTGMsY0FKS2Q7V0FDVmU7c0JBSUl4akQ7Y0FBSyxPQXJHZndpRDt1QkFxR3NDLGlCQUE1QnhpRCxJQURDdWpELGFBTlBiO2FBT2lGOztjQUovRWM7U0FNRCxHQUFBLGlCQVBxQnhqRDtVQU9TLFVBQUEsV0FON0J3akQsYUFNeUMsaUJBUHJCeGpEO1VBT1MsT0FBQTs7U0FBa0MsVUFBQSxXQU4vRHdqRCxhQURvQnhqRDtTQU8yQyxPQUFBO1FBQWE7aUJBRzlFeWpELFlBQVV6akQsR0FBSSxPQVZkc0IsYUFVVXRCLEdBQWdDO2lCQUMxQ20yQixjQUFnQnR3QixLQUFpQjdGO1NBQUksR0FBckI2RixTQUFZQyxNQUFaRCxRQUFBNDhDLFlBQVkzOEMsY0FBWjI4QztTQUFxQixPQVhyQ25oRCxjQVdnQm1oRCxZQUFpQnppRDtRQUEyQjtpQkFFNUQwakQsUUFBUXI0QztTQUNWLE9BQUEsc0NBRFVBO1FBQzREO2lCQUdwRXM0Qyx5QkFBeUJ0NEM7U0FDZjs7WUFBQTs7Y0FEZUE7dUJBQ1ltRSxHQUFLLE9BQUEsMEJBQUxBLE9BQXNCO1NBQWpELE9BQUE7UUFBbUQ7aUJBRzdEak8sVUFBVThKO1NBQ1o7VUFDSXU0QyxNQUFNLGdDQUZFdjRDO1VBR1J3UztZQUFTOzs4QkFBMkIsT0FBeEMsOEJBREkrbEMsS0FDbUQ7WUFEbkRBLFdBQUFBLFFBUUMsT0FsQkhGLFFBUVVyNEM7Y0FHUndTLFFBSVEsT0FmVjZsQyxRQVFVcjRDO3FCQUdSd1M7O1VBS3lCLElBQWZ5WCxpQkFBZSxNQVozQnF1Qix5QkFZWXJ1QjtVQUFlLE9BQUE7O2FBQ2Z1dUI7U0FBUyxPQWJyQkYseUJBYVlFO1FBQ0U7UUFJaEI7U0FER2o2QyxpQkFDSDtvREFkRXJJLFdBWEFraUQ7Ozs7Ozs7aUJBd0JDNzVDO2lCQWhERHZUO2lCQUVDcVA7aUJBR0EyRDtpQkE4QkQ5SDtpQkFYQWtpRDtpQkFDQXR0Qjs7T0FyRUptdEI7T0F0Q0FkO09BaUNBWTtPQUlBQzs7OztFOzs7Ozs7Ozs7RTs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHQzdLRjs7SUEySUVTOztJQXNFQUM7Ozs7OztJQXJSQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFtRUFDLCtCQUNGO0lBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBdkVFQzs7O0tBZ05LLE1BQUE7O0tBdklMQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBQUFBOztVQUVNOztXQXhFTkg7eUJBd0VNOzs7SUEwSU5JO0lBc0VBQztJQW1FQUM7OztPQTlWQUo7T0FHQUY7T0FtRUFDO09BR0FFO09BeUlBTDtPQUdBTTtPQW1FQUw7T0FHQU07T0FtRUFDOzs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7SUNyV0EzbUQ7Ozs7Ozs7WUFDQTRtRDtJQUF1QixPQUFBO0dBQXFEO1lBQzVFQyxnQkFBYyxPQUFBLG1DQUFnRDtZQU05REMsUUFBUUMsTUFBS0M7SUFDZixHQURlQSxjQVBiSjtrQkFTQyw2QkFGT0c7O29CQUFLQzs7OztNQUlHO09BQUE7dURBSkhBLGNBQUFBO21CQUlSLDZCQUpHRDs7OztZQU5SRjtJQVlGLE9BQUEsbUNBTlVFLE1BQUtDO0dBTWU7Ozs7Ozs7Ozs7OztZQVk1QkMsVUFBVUYsTUFBS0M7SUFDakIsR0FDRyxjQUZjQSxnQkF6QmZKO0lBNEJFO0tBQUEsTUFBQSxpQkFIUUc7S0FHUixhQUFhLGNBSExBO0lBR0s7S0FDYixVQUFBLGlCQUphQztLQUliOzs7TUFDSSxVQUFBLDBCQUxJRDtNQUtKOztrQ0FMU0M7O1VBTU47WUFOQ0Q7OztNQU1EOzs7T0FFSCxVQUFBLGNBUklBO09BUUo7O21DQVJTQzs7V0FTTjthQVRDRDs7Ozs7Ozs7O0lBU0QsUUFqQ1RGO0lBb0NGLE9BQUEscUNBWllFLE1BQUtDO0dBWWU7WUFHOUJFLG1CQUFtQkgsTUFBS0M7SUFDMUIsR0FDRyxjQUZ1QkEsZ0JBeEN4Qko7SUEyQ0MsVUFBQSxpQkFBQSxnQkFIa0JHO0lBR2xCO0tBQ0MsVUFBQSxpQkFKc0JDO0tBSXRCOzs7TUFFSztpQ0FOaUJBO09BTWpCO2FBREYsaUJBQUEsZ0JBTGNEOzs7O0lBS2QsUUE1Q0xGO0lBZ0RGLE9BQUEscUNBVHFCRSxNQUFLQztHQVNNO0dBdUZqQjtJQUFBLGNBakliRixTQWtCQUcsV0FlQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUJBb0NFOTBELE9BQU1ULEdBQUVDO1NBQ1YsR0FBRyxrQkFET0E7VUFNTixVQUFBLGlCQU5NQTtVQUdSLFdBaEZGb08sbUJBa0ZJLGlCQUxJck87O1NBUUcsSUFBUHcxRCxPQUFPLGtCQVJIeDFELEdBQUVDO1NBU1AsT0FBQSxrQkFEQ3UxRDttQkFDZ0IsaUJBRGhCQSxNQVJNdjFEO21CQVFOdTFEO1FBQ2tDO1FBRzlCLElBQU5DLE1BQU07aUJBRU41MUMsU0FBTzdmLEdBQUVDO1NBQ1gsR0FBRyxrQkFEUUE7VUFNUCxVQUFBLGlCQU5PQTtVQUdULFdBOUZGb08sbUJBZ0dJLGlCQUxLck87O1NBUU4sS0FBQSxrQkFSTUEsV0FRbUMsT0FBQSxpQkFSbkNBLEdBQUVDO1NBUU8sSUFBQSxNQUFBLGlCQVJURCxHQUZQeTFELE1BVWUsTUFBQSxzQkFSTngxRDtTQUZILE9BQUEsc0JBQU53MUQ7UUFVK0M7aUJBSS9DMTFDLFNBQU8vZixHQUFFQztTQUFJLElBQWMsTUFBQSxpQkFBbEJBLElBQUksTUFBQSxpQkFBTkQ7U0FBb0IsT0FBQTtRQUFVO2lCQUVyQzAxRCxXQUFXL3JELEdBQWtCZ3NEO1NBQWMsVUE1QjNDbDFELE9BNEJXa0osR0FBa0Jnc0Q7U0FBYyxPQUFBLGlCQUFoQ2hzRDtRQUE2QztpQkFFeERpc0QsU0FBU2pzRCxHQUFrQmdzRDtTQUNiLElBQVpFLFlBL0JGcDFELE9BOEJTa0osR0FBa0Jnc0Q7U0FFMUIsR0FBQSxrQkFEQ0UsbUJBQ3FCLE9BRmRsc0Q7U0FFcUIsVUFBQSxpQkFGckJBLEdBQWtCZ3NEO1NBRUcsT0FBQSxzQkFENUJFO1FBQ21EO2lCQUdyREMsbUJBQW1CbnNELEdBQUdvc0Q7U0FDeEIsT0FBRyxrQkFEa0Jwc0Q7O21CQUdiOzRCQUhhQTtxQkFQbkIrckQsV0FPbUIvckQsR0FBR29zRDtxQkFMdEJILFNBS21CanNELEdBQUdvc0Q7UUFLTztpQkFHN0JDLGNBQWNyc0QsR0FBa0Jnc0Q7U0FDbEM7VUFBSUUsWUE1Q0ZwMUQsT0EyQ2NrSixHQUFrQmdzRDtVQUU5Qk0sMEJBQTBCLGlCQUZJTixTQUM5QkU7U0FFRCxPQUFBLGtCQURDSSx5QkFEQUo7bUJBR0MsaUJBSldsc0QsR0FFWnNzRDttQkFHQyxpQkFMV3RzRCxHQUNaa3NEO1FBSWM7aUJBR2hCSyxNQUFRMy9DLEtBQWdCNU0sR0FBR29zRDtTQUM3QixHQURVeC9DLFNBQU1DLE1BQU5ELFFBQUFzb0MsTUFBTXJvQyxjQUFOcW9DO1NBQ1Ysb0JBRFVBOztzQkFBQUE7cUJBaEJSaVgsbUJBZ0J3Qm5zRCxHQUFHb3NEO3FCQVIzQkMsY0FRd0Jyc0QsR0FBR29zRDs7c0JBQW5CbFg7cUJBdkJSNlcsV0F1QndCL3JELEdBQUdvc0Q7cUJBckIzQkgsU0FxQndCanNELEdBQUdvc0Q7UUFLa0I7O2dCQXhEN0N0MUQ7Z0JBY0FvZjtnQkFZQUU7Z0JBeUJBbTJDO2dCQWhCQUo7Z0JBUEFKO2dCQUVBRTtnQkFhQUk7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7SUMzR0FsZDtJQUVBQztJQUVBRTtJQUVBa2Q7SUFlQUM7OztZQTVCRkMsZUFlWTVsQztJQUVaO0tBQUkxSjs7U0FGUTBKLG1EQUFBQSxTQVJWcW9CO0tBWUU5NEM7O3dCQUZBK21CLEtBUkZneUI7dURBUUVoeUIsU0FSRmd5QjtLQVlFdWQ7O3dCQUZBdDJELGtDQUFBQSxRQVJGaTVDO0lBWUssT0FBQTs7c0NBRkhxZCxLQVJGSDtHQVV1QjtZQUd6QkksZUFHWXYyRDtJQUFLLE9BN0JqQnEyRCxlQTZCZ0MsZUFBbUIsb0JBQXZDcjJELElBRFZvMkQ7R0FDOEU7OztRQUdoRkksOEJBRW9CeDJELEdBQUssT0FSekJ1MkQsZUFRb0J2MkQsR0FBK0M7OztLQUU5RCxNQUFBOztLQUpMdzJEO2dCQUdvQngyRCxHQUFLLE9BbkN6QnEyRCxlQW1Dd0Msb0JBQXBCcjJELElBQStDOzs7OztxQjtPQVRuRXUyRDtPQTFCQUY7T0FnQ0FHOzs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQy9CQXRrRDtJQUFXLHNCQUNKLG1CQUNDLG1CQUNEOztHQUFFO1lBR1RxZTtJQUFPLHNCQUNBLGlCQUNDLGtCQUNEOztHQUFHO1lBR1Y5dkIsT0FBTW1XLEtBQUVsRztJQUFLLElBQW1CLE1BQUEsbUJBQXhCQSxJQUFhLE1BQUEsbUJBQWZrRztJQUFjLE9BQUEsbUJBQUE7R0FBc0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BWjFDMUU7T0FNQXFlO09BTUE5dkI7OztFOzs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7OztJQ2tFSXNhO0lBT0EwN0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBaUxFemtEOztJQXhRSG9FO0lBSUNtSDtHQUNKLFNBRkd4RCxLQUVDL1osR0FBSyxPQUFBLFdBREx1ZCxNQUNBdmQsR0FBVztHQVNhO0lBTjFCb2hCO0lBQ0E1RztJQUNDRjtJQUlEOHdCLGVBWENyeEIsd0JBTURTO0lBTUF6VDs7WUF3UEkydkQsWUF0UE10b0Q7SUFDWixJQUFJLFdBQUEsc0JBRFFBLElBQ1I7Z0JBQ0csT0FBQSxnQ0FGS0E7R0FFb0M7R0FPNUI7SUFEcEJxTTtJQUNBazhDLG9CQUFvQiw0QkFEcEJsOEM7SUFFQW04QyxvQkFBb0IsNEJBRnBCbjhDOzs7Ozs7O1lBR0F2SSxlO1lBQ0Eya0QseUI7WUFFQTFrRCxTQUFTeEI7SUFDWDtNQUFHLGdDQURRQSxHQUxUZ21EO1NBT0MsZ0NBRlFobUQsR0FKVGltRDtZQUlTam1EO0lBT1AsV0FBQSw0QkFQT0E7SUFLVCxPQUFBO0dBR0k7O0lBaU5GbW1EO29EQXpPQS92RCxTQU5BeVQ7OENBTUF6VCxTQU5BeVQsV0ErT0FzOEM7Ozs7O3VEQWdCSTlrRDs7O0lBek1Gaks7SUFFQ21jO0lBSUM2eUM7R0FDSixTQUZHNXlDLE9BRUNua0IsR0FBSyxPQUFBLFdBREwrMkQsUUFDQS8yRCxHQUFXOztJQU1iZzNEOzs7WUFDQXYyRCxtQjtZQUNBMHpELFlBQVV4cUQsR0FBSSxPQUFBLGdDQUFKQSxHQUF5QjtZQUNuQ3N0RCxZQUFVN29EO0lBQUksT0FBeUIsNEJBQTdCQSx1QkFBSTtHQUE4Qjs7Ozs7O1NBaEI1Q3JHO1NBRUNtYztTQUdBQztTQVVEZ3dDO1NBQ0E4QztTQXlLRkg7U0EzS0VyMkQ7U0FEQXUyRDtTQUlBajhDOzs7NkNBT0EwN0MsZUFpTEV6a0Q7Ozs7OztZQXpLTnVJLGlCQUFvQixTQUFFO1lBQ3RCb3ZCLFFBQVFqNUIsR0FBR2s1QixLQUFLQztJQUFPLFdBQVpELE9BQUhsNUIseUJBQUFBLEtBQVFtNUI7O0dBQTRCO1lBQzVDQyxnQkFBZ0JwNUIsR0FBR3ZRLEtBQUtEO0lBQU0sT0FBZHdRLElBQUd2USxNQUFBQSxNQUFIdVEsS0FBUXhRLE1BQVJ3USxJQUFReFE7R0FBMEQ7WUFFbEY2cEMsVUFBVXI1QixHQUFHdlEsS0FBS0Q7SUFDcEIsR0FEZUMsT0FBS0QsS0FFcEIsT0FKRTRwQyxnQkFFVXA1QixHQUFHdlEsS0FBS0Q7SUFDcEIsTUFBQTtHQUMyQjtZQUd6QjhwQyxNQUFNdDVCLEdBQUd2USxLQUFLRDtJQUNoQixHQURnQkEsT0FBTEMsS0FPTixXQWRIMnBDLGdCQU9NcDVCLEdBQUd2USxLQUFLRDtJQU1UOzZCQUFpQyxXQXJHcENzYSxXQStGWXRhO0tBTVQsd0JBQVMsV0FyR1pzYSxXQStGT3JhO0tBSVAsT0FBQTtJQUFBLE9BQUE7R0FHaUM7WUFRbkNvckMsS0FBSzVoQyxHQUFJLE9BQUEsNEJBQUpBLE1BQVM7WUFDZDJJLEtBQUszSSxHQUFJLE9BQUEsNEJBQUpBLE1BQVM7WUFDZDZILE9BQU83SCxHQUFJLE9BQUpBLEVBQUs7WUFnSVZrSSxXQTlIS2xJLEdBQUksT0FBSkEsRUFBSzs7SUFFWnlJO0lBQ0FDO0lBRUE2a0Q7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7WUEyR0VDLElBekdFNTNELEdBQUksT0FBQSw2QkFBSkEsR0FBUztZQUdiNjNELElBQUkvakQsR0FBRUMsR0FBSSxPQUFBLDZCQUFORCxHQUFFQyxHQUFXO1lBQ2pCaEcsVztZQUNBRCxXO1lBQ0E4bkMsWUFBWTloQyxHQUFFQyxHQUFJLE9BQUEsNkJBQU5ELEdBQUVDLEdBQVc7WUFDekIrakQsb0JBQW9CaGtELEdBQUVDO0lBQUksT0FBQSw2QkFBTkQsR0FBRUM7R0FBVztZQUNqQ2drRCxXQUFXamtELEdBQUVDLEdBQUksT0FBQSw2QkFBTkQsR0FBRUMsR0FBVztZQUN4QmlrRCxRQUFRbGtELEdBQUksT0FBQSw2QkFBSkEsR0FBVTtZQUNsQm1rRCxPQUFPbmtELEdBQUVDLEdBQUksT0FBQSw2QkFBTkQsR0FBRUMsR0FBVztZQUNwQm1rRCxRQUFRcGtELEdBQUVDLEdBQUksT0FBQSw2QkFBTkQsR0FBRUMsR0FBWTtZQUN0Qm9rRCxRQUFRcmtELEdBQUVDLEdBQUksT0FBQSw2QkFBTkQsR0FBRUMsR0FBWTtPQUN0QnFrRDtZQXdGRXY0QyxTQXZGSzlMLEdBQUV3QixHQUFJLE9BQUEsV0FEYjZpRCxLQUNPcmtELEdBQUV3QixHQUFXOztJQUtsQjB5Qjs7Ozs7OztZQUVBb3dCO0lBQ0YsT0FBQTtHQUEyRDtZQUt6REMsVUFBVXQ0RDtJQUNaLEdBRFlBLFFBTlZxNEQ7SUFRTTtLQUFKdHhDLE1BQUksNEJBRkkvbUI7S0FHRSxNQUFBLDZCQURWK21CO0tBQ0EwSixNQUFJLDZCQURKMUo7S0FFVSxNQUFBLDZCQURWMEo7S0FDQTZsQyxNQUFJLDZCQURKN2xDO0tBRVUsTUFBQSw2QkFEVjZsQztLQUNBaUMsTUFBSSw2QkFESmpDO0tBRVUsTUFBQSw2QkFEVmlDO0tBQ0FDLE1BQUksNkJBREpEO0tBRVUsTUFBQSw2QkFEVkM7S0FDQUMsTUFBSSw2QkFESkQ7S0FJVSxNQUFBLDZCQUhWQztLQUdBQyxNQUFJLDZCQUhKRDtJQUlKLE9BQUEsNEJBRElDO0dBQ0M7WUFJSEMsV0FBVzM0RDtJQUNiLEdBRGFBLFFBckJYcTREO0lBdUJZO0tBQUEsTUFBQSw2QkFGRHI0RDtLQUVUK21CLE1BQUksNkJBRksvbUI7S0FHQyxNQUFBLDZCQURWK21CO0tBQ0EwSixNQUFJLDZCQURKMUo7S0FFVSxNQUFBLDZCQURWMEo7S0FDQTZsQyxNQUFJLDZCQURKN2xDO0tBRVUsTUFBQSw2QkFEVjZsQztLQUNBaUMsTUFBSSw2QkFESmpDO0tBRVUsTUFBQSw2QkFEVmlDO0tBQ0FDLE1BQUksNkJBREpEO0tBSVUsTUFBQSw2QkFIVkM7S0FHQUMsTUFBSSw2QkFISkQ7S0FJQSxNQUFBLDZCQURBQztJQUNBLE9BQUEsNEJBREFBO0dBQ1M7WUFHWEcsUUFBUTU0RDtJQUNWLEdBRFVBLFFBbENScTREO0lBb0NLLFVBQUEsNEJBRkdyNEQ7aUJBRVYsNkJBRlVBO0dBRVE7WUFtQmhCNjRELFdBQVdsdkQ7SUFDYixHQURhQTtLQUVtRCx1QkFBTSw2QkFGekRBO0tBRVI7T0EzREhzK0IsU0EyRFc7O0lBQ0U7S0FBQSxNQUFBLDhCQUhGdCtCO0tBR2IsTUFBQSw0QkFqTUE4UTtJQWlNZSxPQUFBO0dBQUs7WUFHbEJxK0MsVUFBVW52RDtJQUNaLEdBRFlBO0tBRW1ELHlCQUFNLDZCQUZ6REE7S0FFUDtPQWpFSHMrQixTQWlFVzs7YUFGRHQrQixHQUdFO0lBQWtCO1dBQUEsOEJBQUksNEJBSHhCQTtJQUdvQixPQUFBLDRCQXZNaEM4UTtHQXVNMkM7O0lBTTNDaXdCO0lBQ0FxdUI7Ozs7O1NBeE1BNW1EO1NBSEFEO1NBMk9Nd2tEO1NBQ0Exa0Q7NEI7NEI7Ozt1Qjs0Qjs0Qjs0Qjs0Qjs0Qjs0QjtTQXBCSjRsRDt1QjtTQUlBZDtTQUNBamxEO1NBM0dGZ21EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUEySUU5M0MsU0FBTS9mLEdBQUVDO0lBQ1YsR0FEVUE7S0FNTixJQUFBLE1BQUEsV0F2QkUrUixXQWlCSS9SLElBS04sTUFBQSxXQXRCRStSLFdBaUJFaFM7S0FHTjs7SUFLUyxJQUFQdzFELE9BbkpKcUMsSUEySVE3M0QsR0FBRUM7V0FRTnUxRCxXQUFBQSxPQVJNdjFELFFBUU51MUQ7R0FDa0M7WUFHcENsd0QsU0FBT3RGLEdBQUVDO0lBQ1gsR0FEV0E7S0FNUCxJQUFBLE1BQUEsV0FuQ0UrUixXQTZCSy9SLElBS1AsTUFBQSxXQWxDRStSLFdBNkJHaFM7S0FHUDs7V0FIT0EsaUJBQUFBLFdBQUVDLHNCQUFGRCxHQUFFQztHQVFzQztZQUcvQ3NGLFNBQU92RixHQUFFQyxHQUFJLE9BQWMsNEJBQXBCRCxHQUFFQyxHQUE0Qjs7SUFNckMrNEQ7O0l2RTFKQWh6RDtJQUNBakc7SUFDQUc7SUFDQUM7OztPdUVySkNtYTtPQXFCSG5JO09BSEFEO09BNk5FTDtPQWhJRkw7T0F6SEc0RTtPQUdBMkQ7T0FLRHFIOztPQStQSXMxQztPQUNBMWtEOzBCOztPdkV6R0o3UjtPQURBRDtPQUZBOEY7T0FDQWpHO091RTdERjRwQztPQUdBSTtPQUtBQzs7O09BMUZFb0I7Ozs7O09Bd05GVjtPQXZJQW53Qjs7Ozs7T0ErQ0FzOUM7Ozs7OztPQXRCQXZsRDtPQURBaTVCO09BaUNBNnNCO09BRkFGO09BREFEO09BRUFFO09BSEFIO09BbUZBZTtPQXBGQWhCO09BRkFuaUI7T0FEQTluQztPQURBQztPQWRBb3BEO09BRUFFO09BRUFFO09BQ0FDO09BRUFFO09BQ0FDO09BNUdBZDtPQUpBcDhDO09Bb0dBckk7T0FDQUM7T0FvQkF5bEQ7T0FvQkVRO09BZUFLO09Bd0NBRztPQU5BRDtPQXJCQUQ7cUI7cUI7V0E4Q0EvNEMsVUFzRUFtNUMsTUFsRUFwQixLQUlBZCxNQWlDQS8yQyxVQVlBemEsVUFXQUM7T0FoRUFzYTtPQXNFQW01QztPQWxFQXBCO09BSUFkO09BaUNBLzJDO09BWUF6YTtPQVdBQzs7T0F2REFzTTtPQWhJRkw7T0FPQTBsRDtPQUVBRTtPQUVBRTtPQUdBRztPQUVBRTs7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7SUN6SUU1OEM7Ozs7Ozs7Ozs7O0lBTEY3TTs7Ozs7Ozs7Ozs7Ozs7O1lBTUVrSSxZQUFZTyxPQUFNakc7SUFBd0IsVUFBQSxtQkFBeEJBO0lBQXdCLE9BQUEseUJBQTlCaUc7R0FBd0M7WUFDcERvRCxLQUFLckosR0FBSSxPQUFBLDZCQURUMEYsYUFDSzFGLEdBQTBCO1lBQy9Cc0IsVUFBVXRCO0lBQTRCLFVBQUEsbUJBQTVCQTtJQUE0QixPQUFBO0dBQVU7WUFJaEQ4SixVQUFVOUosR0FBSSxXQUpkc0IsVUFJVXRCLElBQTJCO1lBRXJDMFEsVUFBVTFGO0lBQ1osU0FEWUE7S0FFSyxPQUFBLDZEQUZMQTtRQUdBdE4sSUFIQXNOO0lBSVY7S0FBSzs7UUFBQTs7VUFES3ROOzttQkFDMkJ6RSxHQUFLLE9BQUEsMkJBQUxBLEdBQW9CO0tBQXBEOzs7S0FDRyxPQUFBLDZEQUxFK1I7O0dBS21FO0dBSS9FO0lBREVwQixpQkFDRjtnREFsQkVTLGFBR0EvSTt1REFJQXdJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBd0JGRCxpQkFBb0IsU0FBRTtZQUd0QjArQyxTQUFTLzRDO0lBQ1gsSUFBSSxVQUFBLDJCQURPQSxJQUNQOzs7O1NBQ2VnNUM7S0FBTyxPQUFBLFdBekN4QmhyRCxnQkF5Q2lCZ3JEOztHQUE0QztZQUc3RDVtRCxLQUFLNE47SUFDUCxJQUFJLGNBQUssMkJBREZBLEtBQ0g7Ozs4QkFDb0I7OztHQUFJO1lBRzFCaTVDLFNBQVNqNUM7SUFDWCxJQUFJLFVBQUEsMkJBRE9BLElBQ1A7Ozs7U0FDZWc1QztLQUFPLE9BQUEsV0FuRHhCaHJELGdCQW1EaUJnckQ7O0dBQTRDO1lBRzdEM3RCLEtBQUtyckI7SUFDUCxJQUFJLGNBQUssMkJBREZBLEtBQ0g7Ozs4QkFDb0I7OztHQUFJO1lBRzFCazVDLFVBQVV6dkQ7SUFBSSxPQUFHLHFCQUFQQSxTQUFpQywwQkFBakNBO0dBQTREO1lBRXRFMHZELGNBQWMxdkQ7SUFDaEIsT0FBRyxxQkFEYUE7Y0FFWCwwQkFGV0E7Y0FHWCxXQWhFSHVFLGdCQTZEY3ZFO0dBRytEO1lBRzdFMnZELFVBQVU1b0QsR0FBSSxPQUFBLDJCQUFKQSxHQUFtQjtZQUM3QjZvRCxRQUFRcjVDO0lBQUksT0FBRyxvQkFBUEEsU0FBMkIsMkJBQTNCQTtHQUF1RDtZQUUvRHM1QyxZQUFZdDVDO0lBQ2QsT0FBRyxvQkFEV0E7Y0FFVCwyQkFGU0E7Y0FHVCxXQXpFSGhTLGdCQXlFcUUsbUJBSHpEZ1M7R0FHc0U7WUFHbEZ1NUMsaUJBQWlCQztJQUNILElBQVpDLFlBVkZMLFVBU2lCSTtJQUVuQixjQURJQztzQkFBQUEscUJBQUFBOztHQU9FOzs7Ozs7Ozs7Ozs7Ozs7OztPQTlFRnZqRDtPQUNBMkQ7T0FPQXFIO09BRkE1RztPQVVBRjs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BY0ZDO09BUUFqSTtPQUxBMm1EO09BZUExdEI7T0FMQTR0Qjs7T0FtQkFJO09BRUFDOzs7T0FYQUo7T0FFQUM7T0FNQUM7T0FTQUc7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7OztJQ2lESUc7Ozs7Ozs7O1lBM0hKcC9DLFVBT0l1SyxVQUFZQyxpQkFBaUIsV0FBc0I7Ozs7Ozs7OztZQVF2RDYwQyxXQUEyQyxTQUFDO1lBQzVDQyxrQkFBOEQsU0FBQztZQUMvREMsWUFBZ0NqbUQsR0FBYSxPQUFiQSxFQUFjOzZCQU01Q3MyQixZQUFvRCxTQUFDLEVBRDNELFdBQ01BOzhCQU9BQSxpQkFHRixTQUFDLEVBSkwsV0FDTUE7O2FBV0FBLHNCQUdGLFNBQUM7SUFKTCxXQUNNQTs7WUFPRjR2QixnQkFDRixXQUFJO1lBR0ZDLG1CQUFxRixTQUFDOzthQWlCcEZqUixNQUFNenpDO0tBQWEsVUFBQSxrQkFBYkE7S0FBYSxPQUFBO0lBQVk7SUFId0MsV0FHdkV5ekM7O1lBd0VBMXNDO1FBQXVCa0csZUFBVDAzQztJQUNoQixxQkFDSyxXQUZvQjEzQztJQW5EZ0I7S0FGZDlSLElBcURYd3BEO0tBbkR5QixNQUFBLDhCQUZkeHBEO0tBUEh5cEQsUUFTbEI7SUF1REo7O2tDQUp1QjMzQzs7Ozs7O2tDQTNEc0MsNkJBRHZDMjNDOzs7O1lBc0V0QkMsUUFBUTFwRCxHQUFJLE9BQUpBLEtBQWE7WUFDckI4UixLQUFLOVIsR0FBSSxPQUFKQSxLQUFVO1lBQ2ZkLE9BQVE0UyxNQUFLNDNDO0lBNUNLO0lBNENLLHFCQUFmNTNDLE1BQUs0M0M7R0FBd0Q7WUFDckVDLElBQUkzcEQ7SUFBSSxJQXZDZXNZLElBdUNuQnRZLE1BdEM4QixNQUFBLDhCQURYc1k7SUFDVyxPQUFBO0dBc0NMO1lBQzdCalAsS0FBS3JKLEdBQUksT0FEVDJwRCxJQUNLM3BELEdBQVM7WUFDZDBGLFlBQVloSSxHQUFFc0M7SUFBb0IsVUFGbEMycEQsSUFFYzNwRDtJQUFvQixPQUFBLDZCQUF0QnRDO0dBQTZCO1lBQ3pDa3NELGFBQWF4b0QsSUFBR0M7SUFBSyxJQWhDUWdDLElBZ0NiaEMsT0FoQ0crQixJQWdDTmhDO1dBaENNZ0MsU0FBVUMsT0FGM0I2bEQ7R0FrQ3FEO1lBQ3ZEVyxLQUFLem9ELElBQUdDO0lBQW9CLFVBRDVCdW9ELGFBQ0t4b0QsSUFBR0M7SUFBb0IsT0FBQTtHQUFvQjtZQUVoRHlvRCxpQkFBaUIxb0QsSUFBR0M7SUFDaEIsWUFKSnVvRCxhQUdpQnhvRCxJQUFHQztrQkFFZjBxQyxjQUFLLE9BQUxBO0lBS0E7S0FDdUU7S0FBM0I7S0FENUM7Ozs7U0FDSTs7eUIsT0EzQlRuZ0M7eUIsT0FBQUE7ZUFtQmlCeEssSUFBR0M7O0tBS2xCLE1BQUE7SUFBQSxPQUFBO0dBS0s7Ozs7T0ExS1R5STs7T0FlQXEvQztPQUNBQztPQUNBQzs7OztPQStCQUM7T0FJQUM7OztRQXlGRTM5Qzs7Ozs7OzRCOzRCOzRCOzRCOzRCOzRCOzs7Ozs7Ozs7OztRQWFBKzlDO1FBREF6cUQ7UUFFQW1LO1FBSEF5STtRQURBNDNDO1FBS0Foa0Q7UUFFQW1rRDtRQURBRDtRQUdBRTs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0dDeEh1Qzs7Ozs7Ozs7Ozs7SUFBckNDLGtCQUFxQztJQXhCVEM7OztZQU9oQzN0QixRQWtDWS9zQyxHQUFJLE9BakJ5Qiw2QkFpQjdCQSxHQXpDb0IwNkQsTUF5Q0M7WUFqQ2pDMXRCLFFBa0NZaHRDLEdBQUksV0FBSSw2QkFBUkEsR0ExQ29CMDZELE1BMENPO1lBcEN2Q2p0QixLQXNDbUJ6dEM7SUFDakIsT0E3Q3VDLDZCQTRDdEJBLEdBNUNhMDZELFFBd0I1QkQsa0JBb0JlejZEO0dBQzZDO1lBbkNoRTI2RCxhQXNDMkIzNkQ7SUFDekIsT0FBRyw2QkFEc0JBLEdBeEJ2Qnk2RCxtQkF4QjRCQyxPQWdETDE2RDtHQUNxRDtZQXhDaEZvdEMsVUEyQ2NwdEM7SUFDWixPQTdDRmd0QyxRQTRDY2h0QztjQTFDZDI2RCxhQTBDYzM2RDtjQUdQO0dBQTJEO1lBZ0I5RDQ2RDtJQVBZLG1CQWhFZ0JGO1FBa0V2QjE2RDtJQUFLLE9BNURkeXRDLEtBNERTenRDO0dBQVc7WUFJaEI2NkQsWUFEbUI3NkQsR0FBSSxPQTdEM0JndEMsUUE2RHVCaHRDLFNBM0R2QjI2RCxhQTJEdUIzNkQsUUFBcUQ7Ozs7O1lBQ3hFNjZELGFBQ0FEOzs7WUFlSjU3QixZQUNFamEsVUFBWSsxQztJQUNRLFVBQUEsc0JBRHBCLzFDO0lBQ0osT0FBQSx1Q0FEZ0IrMUM7R0FDb0Q7WUFHbEV4K0MsWUFDRXkrQyxVQUFZQztJQUNRLFVBQUEsc0JBRHBCRDtJQUNKLE9BQUEsdUNBRGdCQztHQUNvRDtZQUdqRTFnRCxlQUNDdUw7SUFDSjtLQXRCaUMsTUFBQSwyQkFxQjdCQTtLQXJCNkIsTUFBQTtJQXNCSixPQUFBO0dBQThDO0dBRDNFLElBTUUrckI7WUFDQWhpQyxPQUFRQyxLQUFNLHlDQUFOQSxLQXhHd0I2cUQsTUF3R3lCO1lBQ3pEdHFELEtBQUs4UyxHQUFHdlM7SUFBSSxPQUF3Qjs7YUFBL0J1UztzQkFBb0N2WixHQUFLLE9BbEMxQ2l4RCxZQWtDaUUsV0FBN0RqcUQsR0FBaUNoSCxJQUFpQztHQUFDO1lBQzNFc3hELFVBQVUvM0MsR0FBR3ZTO0lBQUksT0FBd0I7O2FBQS9CdVM7c0JBQW9DdlosR0FBSyxPQXBHbkQ4akMsS0FvR3FFLFdBQXhEOThCLEdBQWlDaEgsSUFBNEI7R0FBQzs7WUFFbEU4WSxJQUFJL1IsR0FBRS9HO0lBQUksT0F0Q2ZreEQsWUFzQ3NDLG1DQUE3Qm5xRCxHQUFFL0c7R0FBa0Q7WUFDakV1eEQsYUFBYXhxRCxHQUFFL0c7SUFBSSxPQXBHbkJ5akMsVUFvRzBDLG1DQUE3QjE4QixHQUFFL0c7R0FBa0Q7WUFDakV3eEQsVUFBUXpxRCxHQUFFL0c7SUFBSSxPQXZHZG9qQyxRQXVHbUMsbUNBQTNCcjhCLEdBQUUvRztHQUFnRDtZQUMxRHl4RCxVQUFRMXFELEdBQUUvRztJQUFJLE9BdkdkcWpDLFFBdUdtQyxtQ0FBM0J0OEIsR0FBRS9HO0dBQWdEO1lBQzFEa3VDLElBQUlubkMsR0FBRS9HLEdBQUUzSjtJQUEwQixVQXpDOUI0NkQsWUF5Q0k1NkQ7SUFBMEIsT0FBQSxtQ0FBOUIwUSxHQUFFL0c7R0FBc0Q7WUFDNUQweEQsU0FBUzNxRCxHQUFFL0csR0FBRTNKO0lBQTBCLFVBM0d2Q3l0QyxLQTJHYXp0QztJQUEwQixPQUFBLG1DQUE5QjBRLEdBQUUvRztHQUFpRDtZQUM1RDJ4RCxTQUFTNXFELEdBQUUvRztJQUFJLDBDQUFOK0csR0FBRS9HLEdBbEhxQit3RDtHQWtIc0I7WUFDdER4cEQsS0FBS1IsR0FBRS9HLEdBQUV3SCxHQUFJLE9BQUEsbUNBQVJULEdBQUUvRyxHQUFFd0gsR0FBNEI7WUFDckMyckMsV0FBV3BzQyxHQUFFL0c7SUFBSSxPQTlDYmt4RCxZQThDb0MsbUNBQTdCbnFELEdBQUUvRztHQUF5RDtZQUN0RTR4RCxvQkFBb0I3cUQsR0FBRS9HO0lBQUksT0E1RzFCeWpDLFVBNEdpRCxtQ0FBN0IxOEIsR0FBRS9HO0dBQXlEO1lBRS9FNnhELDhCQUE4QjlxRCxHQUFFL0c7SUFDbEMsT0E5R0VneEQsYUE4R3dCLG1DQURNanFELEdBQUUvRztHQUNzQjtZQUd0RDh4RCxlQUFlL3FELEdBQUUvRztJQUFJLE9BbkhyQnFqQyxRQW1IMEMsbUNBQTNCdDhCLEdBQUUvRztHQUF1RDtZQUN4RXl6QyxXQUFXMXNDLEdBQUUvRyxHQUFFM0o7SUFBaUMsVUFyRDVDNDZELFlBcURXNTZEO0lBQWlDLE9BQUEsbUNBQXJDMFEsR0FBRS9HO0dBQTZEO1lBQzFFK3hELGdCQUFnQmhyRCxHQUFFL0csR0FBRTNKO0lBQWlDLFVBdkhyRHl0QyxLQXVIb0J6dEM7SUFBaUMsT0FBQSxtQ0FBckMwUSxHQUFFL0c7R0FBd0Q7WUFDMUVneUQsZ0JBQWdCanJELEdBQUUvRztJQUFJLDBDQUFOK0csR0FBRS9HLEdBOUhjK3dEO0dBOEhvQztZQUVwRWtCLE1BQU1sckQ7SUFDUjtLQUFhLE1BQUEsZ0JBRExBO0tBQ0ssTUFBQTtLQUFiOztTQUFBL0c7O01BSEVneUQsZ0JBRU1qckQsR0FDUi9HO01BQ0UsVUFERkE7aUJBQUFBO01BQUFBOzs7O0dBRUk7Z0JBR0lySSxPQUFPcVA7SUFDZjtLQUFhLE1BQUEsZ0JBRExyUDtLQUNLLE1BQUE7S0FBYjs7U0FBQXFJOztNQUNFLFdBRmFnSCxHQUNmaEgsR0FuQkVtekMsV0FrQk14N0MsT0FDUnFJO01BQ0UsVUFERkE7aUJBQUFBO01BQUFBOzs7O0dBRUk7Z0JBS0lySSxPQUFPOE8sTUFBTU87SUFDWCxJQUFOdVksVUFEVzlZO0lBRWY7TUFGUTlPO2VBRVlxSSxHQUFFa3lELE1BRGxCM3lDLFNBQ2lDLFdBRmhCdlksR0FFRGhILEdBRGhCdWYsUUFDa0IyeUMsZ0JBQTRCO1dBRDlDM3lDO0dBRUE7WUFTRXpZLEtBTkNuUCxPQUFPOE8sTUFBTU87SUFBSTthQUFqQnJQO2FBQU84Tzs2QkFBOEM4WSxLQUFJbHBCLEdBQUssT0FBQSxXQUFqRDJRLEdBQXdDdVksS0FBSWxwQixHQUFZO0dBQUM7R0FPL0Q7SUFBUm82QjtJQUNBdnBCOzs7Z0JBaEJDdlAsT0FBT3FQO1FBQUksV0FBWHJQLHVCQUF5Q3RCLEdBQUssT0FBQSxXQUF2QzJRLEdBQWtDM1EsR0FBUTtPQUFDO0lBaUJuRDhRO0lBQ0EwQjs7O3dDQUpBL0IsTUFFQUksTUFFQTJCLFFBREExQixPQUZBc3BCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQVlKcnBCLElBQUl6UCxPQUFPcVA7SUFMQSxJQUFUck8sU0ExREZzTixPQTBEdUIscUJBS25CdE87SUFKTjs7TUFJTUE7ZUFKY3FJLEdBSTBCa3lELE1BSmhCLE9BdkM1QnplLFdBc0NFOTZDLFFBQ2dCcUgsR0FJa0MsV0FBekNnSCxHQUFpQ2tyRCxPQUpjO0lBQTVELE9BREl2NUQ7R0FLeUQ7WUFFM0R3NUQsU0FBU3g2RCxPQUFPcVA7SUFDbEI7S0FBSWQsTUFBTSxxQkFEQ3ZPO0tBRVBnQixTQW5FRnNOLE9Ba0VFQztLQUdXLE1BQUEsNEJBSFhBO0tBQ1M7O1NBRVhsRzs7TUFDWSxJQXBIRTRNLE1Bb0hGLG1DQUxIalYsT0FJVHFJO01Bbkh3QixHQWxEeEJxakMsUUFrRGN6MkI7T0FBMkIsSUFxSEp2VyxJQXJLckMyNkQsYUFnRGNwa0Q7T0FtRWRtbEQsZ0JBOENFcDVELFFBRUZxSCxHQUVtRSxXQU5uRGdILEdBTXFCM1E7O01BSHZDLFVBQ0UySjtpQkFBQUE7TUFBQUE7OztJQUtGLE9BUElySDtHQU9FO1lBR0pzN0MsU0FBU3RvQztJQUFRLE9BNUVqQmxGLEtBNEVTa0YsMkJBQTBDM0wsR0FBSyxPQUEvQzJMLFVBQTBDM0wsR0FBNkI7R0FBQztZQUVqRm95RCxjQUFjem1EO0lBQ2hCLE9BOUVFMmxELFVBNkVjM2xELDJCQUN1QjNMLEdBQUssT0FENUIyTCxVQUN1QjNMLEdBQTZCO0dBQUM7WUFHbkVnZ0IsU0FBU2paO0lBQWUsVUFBQSxxQkFBZkE7SUFBNkIsT0FBQTsyQ0FBSy9HLEdBQUssT0F2RWhEbXpDLFdBdUVTcHNDLEdBQWtDL0csR0FBbUI7R0FBQztZQU0zRGtqQyxZQUFhaDlCLFlBQVEsT0F6RnpCRCxPQXlGaUJDLEtBQW1COztJQUNoQzhROzttQ0FEQWtzQix1QkFDQWxzQjs7Ozs7O0lBR0p6UTs7O09BL0dBOHVCO09BS0ExaUI7T0FLQ2hDO09BT0RzM0I7T0FDQWhpQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FFQXFyRDtPQURBN3FEO09BNEVBd3RDO09BRUFtZTtPQUlBcHlDO09BL0VTbEg7T0FDVHk0QztPQUNBQztPQUNBQztPQUtBdGU7T0FDQXllO09BRUFDO09BSUFDO09BWEE1akI7T0FDQXdqQjtPQUNBQztPQUNBcHFEO09BYUEwcUQ7T0F1Q0E3cUQ7T0FFQStxRDtPQTdDQTFlO09BQ0FzZTtPQUNBQzs7Ozs7O09BdUVBenJEOzs7OztTQXJNZ0N3cUQ7U0FNaENqdEI7U0FDQVY7U0FDQUM7U0FDQUk7U0FDQXV0QjtTQTRESUU7U0FDQUQ7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7SUN4RkozeUI7Ozs7Ozs7O1lBK0JBK3pCLFNBQVN0ckQsR0FBSSx3Q0FBSkEsTUFBOEI7WUFFdkM2SixVQUFVb3VCLGFBQVlqNEI7UUFBRzhCLFNBQUg5QixNQUFXdXJELE9BQVh2ckQ7SUFDeEI7YUFEMkI4QixVQUFBQSxVQUVRLGlDQUZBeXBEO01BR3BCLElBQUEsTUFBQSw0QkFIWXpwRCxZQUd6Qjs7V0FBQWdEOztRQUNFLFdBSlFtekIsYUFJSSxrQ0FKbUJzekIsTUFHakN6bUQ7UUFDRSxVQURGQTttQkFBQUE7UUFBQUE7OztNQUtrQjtPQUFBLE1BQUEsaUNBUmV5bUQ7T0FRZixNQUFBO2dCQVJPenBEO1dBUXpCN0ksSUFSeUI2STs7UUFTWCxHQUFBLGtDQVRtQnlwRCxNQVFqQ3R5RDtTQUNFLE1BQUE7UUFERixVQUFBQTttQkFBQUE7UUFBQUE7Ozs7OztLQU5BLE1BQUE7O1VBVUFxUztLQTdCZ0I7TUE2QmhCRiwwQkFBQUU7TUFoQ0UrSTtNQUF1Qm0zQyxhQW9CSHhyRDtNQXBCd0J5ckQsV0FvQnhCenJEO01BakJsQjByRCxVQUFZLGlDQUhkcjNDLFVBQTRDbzNDO01BRTVDRSxnQ0FDRUQ7TUFJQUUsVUFBWSw2QkFQU0o7TUFNdkJLLGtDQUNFRCxlQUxGRDtNQWtDRzs7c0JBQVMsd0JBSmR2Z0Q7Z0NBMUJFeWdEO0tBNEJBLE9BQUE7Y0EvQ0Z0MEI7Y0ErQ0U7OztZQUtGcjRCLGNBQTJCLG9DQUF5QztZQUNwRTRDLE9BQU85QixHQUFJLE9BQUpBLEtBQVk7WUFDbkIrVCxTQURPL1QsR0FDTSxhQUROQSxhQUNrQjtZQUl6QkQsS0FBS0MsR0FBR04sTUFBTU87SUFDaEIsSUFBSXdILFFBRE0vSCxPQUVGLE1BQUEsNEJBRkRNOztTQUVQL0c7O01BQ1ksVUFBQSxrQ0FITCtHLE1BRVAvRztNQURJd08sT0FFRyxXQUhTeEgsR0FDWndIO01BQ0ksVUFBUnhPO2VBQUFBO01BQUFBOzs7V0FESXdPO0dBSUY7WUFHQXRILEtBQUtILEdBQUdDO0lBQ0YsVUFBQSw0QkFEREQ7O1NBQ1AvRzs7TUFDRSxXQUZRZ0gsR0FFTixrQ0FGR0QsTUFDUC9HO01BQ0UsVUFERkE7ZUFBQUE7TUFBQUE7Ozs7R0FFSTtHQU9TO0lBQVBpZ0IseUJBVkovWTtJQVdJaVosMkJBeEJKdFg7MkNBS0EvQixNQWtCSW1aLFFBQ0FFO0lBR0ppQjtJQUNBblk7SUFDQUs7SUFDQTZWO0lBQ0FDO0lBQ0FXO0lBQ0FEO0lBQ0FqWjtJQUNBbVo7SUFDQUw7SUFDQUU7SUFDQVA7SUFDQUc7O1lBRUE5WSxRQUFrQm9EO0lBQ3BCLEdBQUcseUJBRGlCQSxJQUVmLE9BNUNIOUQ7SUE4Q2E7S0FBVDRDLFNBQVMseUJBSktrQjtLQUtrQixNQUFBLCtCQURoQ2xCO0tBQ0F5cEQsT0FBTztLQUNQOWpELFFBTmN6RTtLQU9WLE1BQUEsNEJBSEpsQjs7U0FHSjdJOztrQkFESXdPOztPQUdNLE1BQUE7VUFDRGdsQixnQkFBTHJwQjtNQUNBLGtDQU5BbW9ELE1BRUp0eUQsR0FHSW1LO01BSkFxRSxPQUlLZ2xCO01BSEQsVUFBUnh6QjtlQUFBQTtNQUFBQTs7O0lBT0EsV0FWSTZJLFFBQ0F5cEQ7R0FTYTtZQUdqQnpoRCxVQUFVMFEsV0FBVXhhO0lBQTZCLFVBQUEsV0F4QmpERixTQXdCb0JFO0lBQTZCLE9BQUEseUJBQXZDd2E7R0FBa0Q7WUFDNUQ5SixVQUFVeXNCLFdBQVVueUI7SUFBTyxPQWxCM0JwTCxRQWtCbUMseUJBQXpCdTlCLFdBQVVueUI7R0FBOEM7WUFFbEVwQixlQUF5QnVqQztJQUdFLFVBQUEseUJBSEZBO0lBR0UsT0FBQTtHQUE2QjtZQUd4RDJlLE9BQU85ckQsR0FBRStyRDtJQUNELElBQU5yNkIsTUFBTSxpQ0FEQ3E2QjtJQUVYLGtDQUZTL3JELFNBQ0wweEIsUUFESzF4QjtJQUFBQSxPQUNMMHhCOztHQUVTO1lBR1hzNkIsYUF6RU9oc0QsR0F5RVFpc0Q7SUFDakI7S0FBSUMsaUJBQWUsNEJBREZELGNBekVSanNEO1dBMEVMa3NELG1CQWhHRlosU0FzQk90ckQ7aUJBbUVQOHJELE9BbkVPOXJELEdBMEVMa3NEO0dBQ29EO1lBR3REQyxLQUFLbnNELEdBQUVvRDtJQUNLLFVBQUEsaUNBRFBwRDtPQUFBQTtLQUNxRCxVQUFBLDRCQURyREE7S0FYTDhyRCxPQVdLOXJELEdBQ2dEOztJQUN2RCxrQ0FGT0EsTUFBQUEsTUFBRW9EO0lBQUZwRCxPQUdLLDRCQUhMQTs7R0FHaUI7WUFHdEJvc0QsYUFBYXBzRDtJQUNmO0tBQUkvRyxJQUFJLDRCQURPK0c7S0FFWDZkLFNBQVMsa0NBRkU3ZCxNQUNYL0c7SUFFSixrQ0FIZStHLE1BQ1gvRztJQURXK0csT0FDWC9HO0lBSUosT0FISTRrQjtHQUdFO0dBR1EsSUFBWnd1QyxZQUFZO1lBQ1pDLElBQUl0c0QsR0FBSSxPQTVGUitULFNBNEZJL1QsYUFUSm9zRCxhQVNJcHNELElBQXNEO1lBQzFEdXNELFFBQVF2c0Q7SUFBSSxPQTdGWitULFNBNkZRL1Q7eUNBRlJxc0Q7Y0FSQUQsYUFVUXBzRDtHQUFnRTtZQUN4RXdzRCxhQUFheHNEO0lBQXFDLFVBQUEsNEJBQXJDQTtJQUFxQyxPQUFBLGtDQUFyQ0E7R0FBbUQ7R0FDcEQsSUFBWnlzRCxZQUFZO1lBQ1pDLElBQUkxc0QsR0FBSSxPQWhHUitULFNBZ0dJL1QsYUFGSndzRCxhQUVJeHNELElBQXNEO1lBQzFEMnNELFFBQVEzc0Q7SUFBSSxPQWpHWitULFNBaUdRL1Q7eUNBRlJ5c0Q7Y0FEQUQsYUFHUXhzRDtHQUFnRTtZQUN4RVI7UUFBT3NDLG1CQUFReXBEO0lBQVMsV0FBakJ6cEQsUUFBa0Msa0NBQTFCeXBEOztZQUVmTCxNQUFNbHJEO0lBQ1IsY0FEUUE7O0tBR08sSUFBQSxNQUFBLDRCQUhQQSxVQUVIOztVQUNIL0c7O09BQ0Usa0NBSkkrRyxNQUdOL0c7T0FDRSxVQURGQTtrQkFBQUE7T0FBQUE7OztLQUhNK0c7Ozs7OztHQU1RO1lBR2Q0c0QsWUFBWTVzRCxHQUFFQztJQUNoQjttQkFEY0Q7O0tBSVYsV0FKWUMsR0ExQmRtc0QsYUEwQllwc0Q7O0dBT1A7WUFHTDJsQyxVQUFVcjJDLEdBQ0osSUFBSjBRLElBMUhGZCxXQStFQWl0RCxLQTJDRW5zRCxHQURRMVEsSUFFWixPQURJMFEsRUFFSDs7OztPQWhFQzBRO09BREE1RztPQUdBRjtPQWpGQUM7T0ErQ0F3UTtPQTNCQXZZO09BQ0FpUztPQVlBNVQ7T0FSQUo7T0FpQ0F3WTtPQUNBRztPQVhBeFc7T0FDQUs7T0FDQTZWO09BQ0FDO09BQ0FXO09BQ0FEO09BQ0FqWjtPQUNBbVo7T0FDQUw7T0FDQUU7T0FJQWxaO09BMUNBVjtPQXlIQXltQztPQTFDQXdtQjtPQWVBRztPQUNBQztPQUdBRztPQUNBQztPQUdBekI7T0FGQTFyRDtPQVdBb3REO09BcElBdEI7T0ErRkFVOzs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7O1lDbkhFYTtJQU5DO0tBSnVEaDVDO0tBQVRDO0tBQVZGO0tBQXZCRDtLQUliLE1BQUEsd0JBSnVERTtLQUd2RCxNQUFBLHdCQUg4Q0M7S0FFOUMsTUFBQSx3QkFGb0NGO0tBQ3pDLE1BQUEseUJBRGtCRDtLQUNsQixNQUFBO0tBQUEsTUFBQTtJQUdLLE9BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQVlIbTVDO1FBQTZCajVDLHFCQUFWRCxxQkFBWEQ7SUFDVixXQURVQSxXQUFXQyxhQUFVQzs7Ozs7O09BTjNCZzVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BTUZDOzs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7OztJQ1RLajBCO0lBZ0NGanZCOzs7Ozs7Ozs7SUFtQ0RLO0lBTUFJOzs7Ozs7Ozs7OztHQXhFRCxTQUZDcUcsVUFpQkNvb0I7SUFmRjs7Y0FlRUE7Z0JBQUFBOzs7Ozs7Ozs7Ozs7O1NBYndDOztRQUNGOztPQUZBOztNQUdBOztlQVd0Q0E7O01BQ0EsT0FBQTs0Q0FqQkVELGtCQWdCRkM7OztNQURBLE9BQUE7NENBZkVELGtCQWdCRkM7Ozs7Ozs7Ozs7Ozs7O1FBUEEsT0FBQTs4Q0FURUQsa0JBZ0JGQzs7T0FMQSxPQUFBOzZDQVhFRCxrQkFnQkZDOztNQVRBLE9BQUE7NENBUEVELGtCQWdCRkM7O0tBSEEsT0FBQTsyQ0FiRUQsa0JBZ0JGQzs7SUFHQSxPQUFBLHdDQW5CRUQsa0JBZ0JGQztHQUdzRTtZQUl2RWh2QjtJQUNEOztPQUNVOztPQUNDOztPQUNEO2VBQ0E7O0dBQXdCO09Ba0JqQ3pUO1lBRUNxUCxZQUNFNEQsS0FBSUM7SUFDTixPQURNQTs7T0FFRyxPQUFBLHlCQUZQRDs7T0FHUSxPQUFBLHlCQUhSQTs7T0FJTyxPQUFBLHlCQUpQQTtlQUtPLE9BQUEseUJBTFBBOztHQUsyQztHQVVoRCxTQU5HRCxLQU1DRTtJQUFLLElBSEFELE1BQU0saUNBQ1YsTUFkRjVELFlBYU00RCxLQUdMQztJQUZDLE9BQUE7R0FFVTtZQU9iaEksVUFBVTdELEdBQUksT0F4RWRnVCxVQXdFd0IsNkJBQWRoVCxJQUFnQztZQUMxQzRELFVBQVV0QjtJQUFtQixVQWpEN0I4SixVQWlEVTlKO0lBQW1CLE9BQUE7R0FBYTtZQUsxQ2pRLE9BQU9ULEdBQVNDLEdBQUksT0FBYkQsSUFBU0MsVUFBa0I7WUFDbEM0ZixTQUFRN2YsR0FBU0MsR0FBSSxPQUFiRCxLQUFTQyxVQUFtQjtZQUNwQzhmLFNBQVEvZixHQUFTQyxHQUFJLE9BQWJELE1BQVNDLFVBQW1CO1lBQ3BDcUYsU0FBT3RGLEdBQVNDLEdBQUksT0FBYkQsTUFBU0MsVUFBa0I7WUFDbENzRixTQUFPdkYsR0FBU0MsR0FBSSxPQUFKQSxJQUFURCxVQUEyQjtZQUNsQ3dGLFNBQVF4RixHQUFTQyxHQUFJLE9BQUpBLEtBQVRELFVBQTRCO1lBQ3BDZ0csVUFBV2hHLEdBQVNDLEdBQUksT0FBQSwwQkFBYkQsR0FBU0MsR0FBc0I7WUFDMUNGLFdBQVlDLEdBQVNDLEdBQUksT0FBQSwwQkFBYkQsR0FBU0MsR0FBdUI7T0FDNUM4SDtZQUNBZixNQUFPaEgsR0FBU0MsR0FBSSxPQUFiRCxNQUFTQyxVQUFrQjtZQUNsQ0MsSUFMUUYsR0FBU0MsR0FLQyxPQUxEQSxLQUFURCxJQUFBQSxJQUFTQyxFQUt3QjtZQUN6Q0UsSUFWUUgsR0FBU0MsR0FVQyxPQVZWRCxLQUFTQyxJQUFURCxJQUFTQyxFQVV3Qjs7Ozs7O1NBMUN6QzhHO1NBRUNxUDtTQVVBMkQ7U0EzRERxSDtTQXdCQTVHO1NBZ0RBdkk7U0FDQUQ7U0FDQStJOzs7Ozs7Ozs7Ozs7OztZQTBCRjBpRDtJQUFVLHNCQUNFLGlCQUNDLGtCQUNEOztHQUFHO1lBR2ZDO0lBQWM7O09BQ1A7O09BQ0M7O09BQ0Q7O09BQ0EsT0FBQTs7R0FBK0M7WUFHdEQ5ckQsT0FBT3NSLEdBQUksT0FiWHU2QyxRQWFtQiwwQkFBWnY2QyxJQUEyQjtZQUNsQ3k2QyxXQUFXanREO0lBQWdCLFVBUjNCZ3RELFlBUVdodEQ7SUFBZ0IsT0FBQTtHQUFlO1lBRTFDNmY7SUFBTzs7T0FDQTs7T0FDQzs7T0FDRDtlQUNBOztHQUFHO1lBR1Y5cUIsU0FBTW1SLEtBQUVsRztJQUNWLE9BRFFrRyxXQUFFbEc7S0FHaUMsSUFBQSxNQXBCekNndEQsWUFpQlFodEQsSUFHaUIsTUFwQnpCZ3RELFlBaUJNOW1EO0tBR08sT0ExQmI2bUQsUUEwQmE7O0lBRE07R0FDdUM7Ozs7T0ExRHhEOWlEO09BbkNDTDs7Ozs7OztPQWtERDlVO09BSkFxYTtPQUVBdmE7T0FDQUM7T0FKQTlFO09BRUFzZjtPQU9BL1k7T0FEQWU7T0FHQTVIO09BREFEO09BSkE4RjtPQUNBakc7Ozs7Ozs7T0E0QkY2UjtPQUNBK3JEO09BZEFGO09BTUFDO09BVUFudEM7T0FPQTlxQjs7O0U7Ozs7Ozs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7OztJQ3hHRW00RDtJQW9GQ0M7SUE2QkZDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQXRJRG5qRCxJQUdhb2pEO0lBRGYsSUFRa0JycUQsSUFQSHFxRCxVQU9LNzBDO0lBQ1o7VUFEVXhWO0tBR3NCO01BSHRCeXBCLE1BQUF6cEI7TUFHUnNxRCxnQkFIUXRxRDtNQUFFa25CLGdCQUdWb2pDLGdCQUhVOTBDO0tBQUZ4VixJQUFBeXBCO0tBQUVqVSxNQUFBMFI7O0lBRUo7S0FBQSxNQUFBLDBCQUZJMVI7S0FQTG9ZLE1BQUF5OEI7S0FBRWxqQztLQU1mLE1BQUE7SUFMRztVQURVeUc7TUFFRixVQUFBLDBCQUZJekc7TUFNZixPQUFBOztLQUhtQztNQUh0QjZXLE1BQUFwUTtNQUdSMjhCLGdCQUhRMzhCO01BQUU0OEIsZ0JBR1ZELGdCQUhVcGpDO0tBQUZ5RyxNQUFBb1E7S0FBRTdXLFFBQUFxakM7O0dBYUU7R0FNbkIsU0FIRTk4QyxVQUdFKzhDLFVBa0NBQztJQWxDSjs7Y0FrQ0lBO2dCQUFBQTs7Ozs7Ozs7OztRQVRrRDs7T0FFbEQsT0FBQTs2Q0E1QkFSLGtCQW1DQVE7O01BTEEsT0FBQTs0Q0E5QkFSLGtCQW1DQVE7O2VBQUFBOztNQUNBLE9BQUE7NENBcENBUixrQkFtQ0FROzs7TUFEQSxPQUFBOzRDQWxDQVIsa0JBbUNBUTtTQXBCc0JDOztRQUFBQTs7U0FBQUE7VUFBQUE7V0FBQUE7V0FBQUE7V0FBQUE7O09BaUJSLE9BQUE7NkNBaENkVCxrQkFtQ0FROztVQWhDMkRFO1NBQUFBLG1CQUFBQTtPQUl2QztRQURmcHRDLFdBSHNEb3RDO1FBSXBEbnRDLFdBQWEsV0FOcEJndEMsVUFLS2p0QztPQUVGLFdBRElDOztNQUdKLE9BQUE7O2VBVkh5c0M7ZUFlc0JTO2VBb0J0QkQ7O1NBcEIyRHg4QztRQUFBQSxtQkFBQUE7TUFJdkM7T0FEZkMsV0FIc0REO09BSXBERSxXQUFhLFdBbEJwQnE4QyxVQWlCS3Q4QztNQUVGLFdBRElDOztLQUdKLE9BQUE7O2NBdEJIODdDO2NBZXNCUztjQW9CdEJEOztJQUdBLE9BQUEsd0NBdENBUixrQkFtQ0FRO0dBR3NFO1lBR3hFNWpELFVBRUVpTDtJQURKLDhCQVFpQjs7S0FMSSxJQURaODRDLHFCQUNEQyxXQUFhLFdBRmpCLzRDLFVBQ0s4NEM7S0FFTCx3QkFESUM7O0lBR2EsSUFEWkMscUJBQ0RDLFdBQWEsV0FMakJqNUMsVUFJS2c1QztJQUVMLHdCQURJQztHQUV1QztZQUc1Q3BrRCxlQUNDdUw7SUFDSjs7Ozt3Q0FESUE7NENBQUFBO0dBa0JIO0dBYUEsU0FGQzg0Qyw0QkFnQkNDO0lBZEY7O2NBY0VBO2dCQUFBQTs7Ozs7Ozs7OztRQVpnRDs7T0FEa0I7O01BRUE7O2VBV2xFQTs7TUFDQSxPQUFBOzRDQWhCRWYsa0JBZUZlOzs7TUFEQSxPQUFBOzRDQWRFZixrQkFlRmU7Ozs7Ozs7Ozs7O09BTkcsT0FBQTs2Q0FURGYsa0JBZUZlOztNQVJHLE9BQUE7NENBUERmLGtCQWVGZTs7S0FIRyxPQUFBOzJDQVpEZixrQkFlRmU7O0lBRWMsT0FBQSx3Q0FqQlpmLGtCQWVGZTtHQUVvRjtZQUlyRkM7SUFDRCxzQkFDd0IsbUJBQ1Qsb0JBQ1M7O0dBQXNDOztJQWlCN0RDOzs7WUFLQ0MsOEJBR0Uva0QsS0FBSUM7SUFDTixPQURNQTs7T0FFaUIsT0FBQSx5QkFGckJEOztPQUdZLE9BQUEseUJBSFpBO2VBSXFCLE9BQUEseUJBSnJCQTs7R0FJeUQ7R0FVOUQsU0FOR2dsRCx5QkFNQy9rRDtJQUFLO0tBSEFELE1BQU07S0FDVixNQWZGK2tELDhCQWNNL2tELEtBR0xDO0lBRkMsT0FBQTtHQUVVO1lBS2JsSixJQUFJTCxHQUFHQztJQUNULFVBRE1ELGdCQUlTO2FBSlRBLFVBRUN1dUQsT0FGRHZ1RCxNQUVTLFdBQUssV0FGWEMsR0FFRnN1RDtRQUNBQyxPQUhEeHVEO0lBR1MsV0FBSyxXQUhYQyxHQUdGdXVEO0dBQ2lCO1lBR3RCQyxlQUFlenVELEdBQU9vRCxHQUFHL007SUFDM0IsVUFEaUIySixnQkFJRjthQUpFQTtTQUVWdXVELE9BRlV2dUQ7WUFFRixXQUZZM0osU0FFcEJrNEQsTUFGaUJuckQ7O1FBR2pCb3JELE9BSFV4dUQ7V0FHRixXQUhZM0osU0FHcEJtNEQsTUFIaUJwckQ7R0FJTDtZQUdqQnNyRCxlQUFlMXVELEdBQU9vRCxHQUFHL007SUFDM0IsVUFEaUIySixnQkFJRjthQUpFQTtTQUVWdXVELE9BRlV2dUQ7WUFFRixXQUZZM0osU0FBSCtNLEdBRWpCbXJEOztRQUNBQyxPQUhVeHVEO1dBR0YsV0FIWTNKLFNBQUgrTSxHQUdqQm9yRDtHQUNZO1lBR2pCRyxlQUFnQkMsT0FBT0MsT0FBT3g0RDtJQUNoQyxVQURrQnU0RCxvQkFFSDtRQUNSRSxVQUhXRjtjQUFPQyxvQkFLUDtRQUNSRSxVQU5lRjtlQU1PLFdBTkF4NEQsU0FHekJ5NEQsU0FHR0M7R0FBOEM7WUFRdERDLHdCQUF5QkosT0FBT0MsT0FBTXpyRCxHQUFHL007SUFDM0MsR0FmRXM0RCxlQWN5QkMsT0FBT0MsT0FBU3g0RDtLQUh0QztJQUtFLE9BOUJMbzRELGVBNEJ5QkcsT0FBYXhyRCxHQUFHL007Y0FyQnpDcTRELGVBcUJnQ0csT0FBTXpyRCxHQUFHL007O0dBTTlCO1lBR1g0NEQsc0JBQXVCTCxPQUFPQyxPQUFNenJELEdBQUcvTTtJQUN6QyxhQVZFMjRELHdCQVN1QkosT0FBT0MsT0FBTXpyRCxHQUFHL007R0FHTzs7OztPQTdOOUM0VDtPQW1CQXlHO09BMkNBNUc7T0FZQ0Y7T0FvR0R2SjtPQU9Bb3VEO09BT0FDO09BOEJBTztPQXZCQU47T0FyRUFSO09BdEJBRjtPQThCQ2I7T0FhRGdCO09BS0NDO09BV0FDO09BOENEVTs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7O0lDM0dJRTtJQW9QRmpsRDtJQXFCQTB4Qjs7Ozs7WUE3V0F0bEMsUUFDRWdmLE9BQVF0TSxPQUFRQztJQUNwQixHQUFHLG9DQURTRCxPQUFRQyxRQUVmO2NBRk9EO3dCQUFRQyxPQU1VOzttQkFOVkEsZ0NBQUFBO1NBS0ttbUQsWUFMTG5tRCxVQUtab21ELFdBTElybUQ7S0FLNkIsT0FBQSxXQUxyQ3NNLE9BS0krNUMsVUFBaUJEOztJQUViLE9BQUEsYUFQQXBtRCxPQUFRQztHQU9nQztZQUdsRDFTLE1BQ0UrZSxPQUFRbE0sT0FBUUM7SUFDbEIsR0FBRyxvQ0FET0QsT0FBUUMsUUFFYjtjQUZLRDt3QkFBUUMsT0FNWTs7bUJBTlpBLGdDQUFBQTtTQUtPaW1ELFlBTFBqbUQsVUFLVmttRCxXQUxFbm1EO0tBSytCLE9BQUEsV0FMdkNrTSxPQUtNaTZDLFVBQWlCRDs7SUFFYixPQUFBLFdBUEZsbUQsT0FBUUM7R0FPZ0M7WUFHbERVLFVBQ0V5bEQ7SUFBSiw4QkFFa0I7UUFEVkM7SUFBVyx3QkFBOEMsV0FEN0RELFVBQ0lDO0dBQ3dDO0dBaEM5QjtJQUFBLG1CQU9oQm41RCxTQVdBQyxPQVdBd1Q7SUFTc0I7SUFJSDtJQUlROzs7Ozs7O1lBUTNCelMsVUFHRW80RCxPQUFRQyxPQUFRcnVCLE9BQVFDO0lBQzVCO0tBQWFxdUIsUUFET3R1QjtLQUNoQnV1QixRQURnQnZ1QjtLQUVQd3VCLFFBRmV2dUI7S0FFeEJ3dUIsUUFGd0J4dUI7S0FrQjFCOXVCLElBZkksV0FIRmk5QyxPQUNBRyxPQUNBRTthQWdCRnQ5QyxHQUFLLE9BQUxBO0lBYkcsR0FBQSxvQ0FKUW05QyxPQUNBRSxRQUlOO2NBTE1GOztlQUNBRSxvQ0FBQUE7VUFPa0JFLFlBUGxCRixVQU9ERyxXQVJDTDtNQVFrQyxPQUFBLFdBVG5DRCxPQVNBTSxVQUFtQkQ7Ozs7O2dCQVBsQkYscUNBQUFBO09BVVA7UUFEK0JJLFlBVHhCSjtRQVNFSyxXQVZGUDtRQVdNUSxRQURKRDtRQUNMRSxRQURLRjtRQUVJRyxRQUZrQko7UUFFM0JLLFFBRjJCTDtRQUs1Qng5QyxNQUZJLFdBZERpOUMsT0FZRlUsT0FDQUU7b0JBR0Q3OUMsTUFESyxXQWZGaTlDLE9BWU9TLE9BQ0FFLFNBR1Y1OUM7OztvQkFkSW85QyxvQ0FBQUE7VUFRb0JVLFlBUnBCVixVQVFBVyxXQVRBYjtNQVNvQyxPQUFBLFdBVnJDRCxPQVVDYyxVQUFvQkQ7O0lBT25CLE9BQUEsYUFoQkRaLE9BQ0FFO0dBZ0JMO1lBR052NEQsUUFJRW00RCxPQUFRQyxPQUFRbjZDLE9BQVFDO0lBQzFCO0tBQWFpN0MsUUFES2w3QztLQUNkbTdDLFFBRGNuN0M7S0FFTG83QyxRQUZhbjdDO0tBRXRCbzdDLFFBRnNCcDdDO0tBSXhCLE1BQUEsV0FKQWk2QyxPQUNFaUIsT0FDQUU7SUFFRjtLQUNJLEdBQUEsb0NBSk9ILE9BQ0FFLFFBSUw7ZUFMS0Y7O2dCQUNBRSxvQ0FBQUE7V0FPbUJFLFlBUG5CRixVQU9BRyxXQVJBTDtPQVFtQyxPQUFBLFdBVHRDZixPQVNHb0IsVUFBbUJEOzs7OztpQkFQbkJGLHFDQUFBQTtRQVVOO1NBRCtCSSxZQVR6Qko7U0FTR0ssV0FWSFA7U0FXT1EsUUFESkQ7U0FDTEUsUUFES0Y7U0FFSUcsUUFGa0JKO1NBRTNCSyxRQUYyQkw7U0FHUixNQUFBLFdBZHBCckIsT0FZQ3dCLE9BQ0FFO1FBQ21CLGFBRHZCLFdBYkcxQixPQVlVdUIsT0FDQUU7OztxQkFYUFIsb0NBQUFBO1dBUXFCVSxZQVJyQlYsVUFRQ1csV0FURGI7T0FTcUMsT0FBQSxXQVZ4Q2YsT0FVSTRCLFVBQW9CRDs7ZUFLbkIsV0FkRlosT0FDQUU7Ozs7SUFhRTtHQUF1QztHQVd4RCxTQVJFamdELFVBUUU2Z0QsVUFBWUMsVUE0RVpDO0lBNUVKLFNBNEVJQTtlQUFBQTs7OztPQTFFaUI7UUFFWEM7UUFIZUM7UUFDakJDLFdBQWEsV0FGakJMLFVBQ3FCSTtPQUluQjtpQkFESUQ7O1VBR21CRyxXQUhuQkg7O1lBR21CRztlQUFBQTs7aUJBQUFBOzttQkFRWDttQkFETDtrREFmVDNDLGtCQUtNd0M7aUJBUUc7Z0RBYlR4QyxrQkFLTXdDO2VBTUc7OENBWFR4QyxrQkFLTXdDOzs7bUJBQUFBOzs7O2VBWXFESSx3QkFHbERDO2NBQUFBO2VBQUFBO2dCQUFBQTt3QkF5Q0s7Ozs7a0JBNUM2Q0QsbUJBQUFBO29CQXlCN0NFLFdBekI2Q0Y7OztpQkEwQi9DLFNBREVFOzRCQUFBQTs7OztvQkFJbUI7cUJBRGdCM3VCO3FCQUFaQztxQkFDakJDLFdBQWEsV0E3Q3JCaXVCLFVBNEN5Qmx1QjtxQkFFakJFLFdBQWEsV0E5Q3JCZ3VCLFVBNENxQ251QjtxQkFGakM0dUIsZUFHSTF1QixVQUNBQzs7Ozs7O2tCQUpKeXVCO29CQU9BO21EQWxEaEIvQyxxQkEwQ2M4Qzs7MENBQ0VDOzs7OztrQkFjSjs7b0JBekRaL0M7b0JBb0JTNkM7b0JBZkhMOzs7Ozs7O2lCQVlxREksbUJBQUFBO2VBZ0I5QjtnQkFEZkksV0FmNkNKO2dCQWdCM0NLLFdBQWEsV0FoQ2pCWCxVQStCRVU7cUNBQ0VDOzs7OztpQkFHSjs7bUJBcENaakQ7bUJBb0JTNkM7bUJBZkhMOzs7Ozs7O2dCQVlxREksbUJBQUFBO2NBTTlCO2VBRGZNLFdBTDZDTjtlQU0zQ08sV0FBYSxXQXRCakJiLFVBcUJFWTtvQ0FDRUM7Ozs7O2dCQUdKOztrQkExQlpuRDtrQkFvQlM2QztrQkFmSEw7Ozs7Ozs7OztjQTBEQTs4Q0EvRE54QyxrQkFLTXdDOzs7Ozs7YUE4REE7NkNBbkVOeEMsa0JBS013Qzs7O1lBREZZOzs7Ozs7O1NBQUFBO1dBb0VBOzJDQXhFSnBELGtCQUtNd0M7O09BdUVOLFdBekVJRSxVQUNBVTs7OztJQTBFSixPQUFBOzBDQTlFQXBELHFCQTZFQXVDO0dBQ2lGO1lBR25GN2xELFlBT0UybUQsVUFBWUM7SUFBaEI7S0FBeUNDO0tBQVpDO0tBQ3ZCQyxXQUFhLFdBRGZKLFVBQXlCRztXQUFZRDs7O01BSTdCRyxRQUo2Qkg7TUFFbkNJLDRCQUdnRCxXQUx0Q0wsVUFJSkk7O0tBUWdCO01BSmJFLFFBUjBCTDtNQVdkTSxXQUhaRDtNQUdBRSxXQUhBRjtNQUlBRyxXQUFhLFdBWlpULFVBV0RRO01BRUFFLFdBQWEsV0FiWlYsVUFXV087TUFUckJGLG9DQVVTSSxjQUNBQzs7O01BUEZDLFFBTjRCVjtNQUVuQ0ksNEJBS2lELFdBUHZDTCxVQU1IVztJQVdYLGVBaEJJUixjQUNBRTtHQWV5QztZQUc1Q2pwRCxlQUtDd3BELGdCQUFpQkM7SUFDbkI7O2FBREVEOzs7Ozs7MkNBQWlCQzs7NkNBQUFBOzs7Ozs7a0NBQUFBLG9CQUFBQTs7O0dBc0NsQjtHQWhOeUI7SUFBQTtVQUkxQmg4RCxXQXdCQUMsU0FzQkFvWixXQXdGQTlFLGFBMkJDaEM7Ozs7WUF5REQzUixVQVFFcTdELFVBQVdDLFdBQVlDLE9BQVFDO0lBQ25DLEdBQUcsb0NBRHdCRCxPQUFRQyxRQUU5QjtjQUZzQkQ7O2VBQVFDLG9DQUFBQTtNQVEvQjtPQUR5QkMsWUFQTUQ7T0FPekJFLFdBUGlCSDtPQVFWSSxRQURQRDtPQUNGRSxRQURFRjtPQUVPRyxRQUZZSjtPQUVyQkssUUFGcUJMO09BS3RCbGhELElBRkksV0FWUDhnRCxVQVFJTyxPQUNBRTttQkFHRHZoRCxJQURLLFdBWEcrZ0QsV0FRRUssT0FDQUUsU0FHVnRoRDs7Ozs7Z0JBWjRCaWhELG9DQUFBQTtXQUtOTyxZQUxNUCxVQUt6QlEsV0FMaUJUO09BS2tCLE9BQUEsV0FMekNGLFVBS01XLFVBQW1CRDs7O29CQUxNUCxvQ0FBQUE7VUFNSlMsWUFOSVQsVUFNeEJVLFdBTmdCWDtNQU1vQixPQUFBLFdBTmhDRCxXQU1KWSxVQUFvQkQ7O0lBT25CLE9BQUEsYUFiZVYsT0FBUUM7R0FhaUI7WUFHbER2N0QsUUFRRW83RCxVQUFXQyxXQUFZYSxPQUFRQztJQUNqQyxHQUFHLG9DQURzQkQsT0FBUUMsUUFFNUI7Y0FGb0JEOztlQUFRQyxvQ0FBQUE7TUFRN0I7T0FEeUJDLFlBUElEO09BT3ZCRSxXQVBlSDtPQVFSSSxRQURQRDtPQUNGRSxRQURFRjtPQUVPRyxRQUZZSjtPQUVyQkssUUFGcUJMO09BR0YsTUFBQSxXQVZ6QmhCLFVBUU1tQixPQUNBRTtNQUNtQixhQUR2QixXQVRTcEIsV0FRSWlCLE9BQ0FFOzs7OztnQkFUZ0JMLG9DQUFBQTtXQUtKTyxZQUxJUCxVQUt2QlEsV0FMZVQ7T0FLb0IsT0FBQSxXQUwzQ2QsVUFLUXVCLFVBQW1CRDs7O29CQUxJUCxvQ0FBQUE7VUFNRlMsWUFORVQsVUFNdEJVLFdBTmNYO01BTXNCLE9BQUEsV0FObENiLFdBTUZ3QixVQUFvQkQ7O0lBS25CLE9BQUEsV0FYYVYsT0FBUUM7R0FXaUI7WUFHbER0bEMsWUFPRWltQyxhQUFlQztJQUFuQjs7S0FTMEI7TUFKaEJDO01BR2VDLFdBSGZEO01BR0dFLFdBSEhGO01BSUdHLFdBQWEsV0FUdEJMLGFBUVNJO01BRUFFLFdBQWEsV0FWUEwsY0FRTUU7S0FGckIsZ0NBR1NFLGNBQ0FDOzs7U0FUSEM7S0FDTix3QkFBZ0QsV0FGaERQLGFBQ01POztRQUVDQztJQUNQLHdCQUFpRCxXQUpsQ1AsY0FHUk87R0FTSjtHQXpFWTtJQUFBLG9CQVFqQnY5RCxXQXdCQUMsU0FzQkE2MkI7SUFnQ0FsMkI7OztZQUVBQyxrQjtZQUVBeThDLG1CQUNELHlCQUVvQztHQWJmO0lBQUEsdUJBTXBCMThDLFdBQ0FvUixLQUNBblIsU0FFQXk4QztJQWlCQTc3Qzs7O1lBRUFDLGtCO1lBRUE4N0QsbUJBQ0QseUJBRWdEO0dBYnJCLGlDQU0xQi83RCxXQUNBaWlDLE9BQ0FoaUMsU0FFQTg3RDtnRUFtcENOLFdBQVU7Z0NBQVY7Z0NBQUE7Z0NBQUE7OENBQUE7K0RBbVlBLFdBQVU7K0JBQVY7K0JBQUE7OENBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozt1RUNyMENBO0dBQVU7Z0NBQVY7Z0NBQUE7Z0NBQUE7OENBQUE7K0RBaVBBLFdBQVU7K0JBQVY7K0JBQUE7K0JBQUE7OENBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUMxeUJJeG9EOzs7Ozs7Ozs7Ozs7O1lBZUV5b0Q7SUFBUyw4QkFDQTt1QkFDQztRQUNLenNDO0lBQVMsT0FBVEE7R0FBVTtZQUd6Qm5uQjtJQUFTLDhCQUNBO3VCQUNDO1FBQ1FwRTtJQUFNLE9BQU5BO0dBQU87WUFJdkJpNEQsU0FBUy9HLE9BQU1DLE9BQU14bkQsYUFBWWtIO0lBQ25DLEdBRFdxZ0Q7O01BR0hFLFVBSEdGO2FBR00sV0FITXZuRCxhQUdmeW5ELFNBSDJCdmdEOzs7O1FBQWxCc2dEO1VBT1ZFLFVBUFVGO2FBT0QsV0FQT3huRCxhQUFZa0gsR0FPNUJ3Z0Q7Ozs7OztJQURHO0dBQzZCO1lBRWpDM2dELEtBQUt3Z0QsT0FBTUMsT0FBTXhuRCxhQUFZckg7SUFDbkMsSUFEVzh1RCxVQUFBRixPQUF3QjFvRCxNQUFBbEc7SUFDbkM7ZUFEbUNrRyxrQkFFeEI7Y0FGd0JBO1VBRzVCcUksSUFINEJySTtNQUd2QixPQVpWeXZELFNBU1M3RyxTQUFNRCxPQUFNeG5ELGFBR2hCa0g7O0tBRUk7TUFEU2lFLElBSmV0TTtNQUlsQitpQixJQUprQi9pQjtNQUFBdUIsSUFBQXZCO01BSXhCdzZCLE1BSndCeDZCO01BSTNCbEQsSUFKMkJrRDtNQUs3QjB2RCxLQTNCTkYsT0EwQlExeUQ7TUFFRjZ5RCxLQTVCTkgsT0FzQm1DanVEO01BTzdCLE9BQUEsNEJBRkFtdUQsSUFDQUM7YUFDSjs7TUFDTztPQUFBLE9BQUEsNEJBSEhELElBQ0FDO2NBRlc1c0MsTUFJUjs7T0FDVztRQUFBLE9BekJwQm5uQixPQWdCbUMyRjtRQVMxQixPQXpCVDNGLE9Bb0JRa0I7UUFLQyxPQUFBO2VBTFd3UCxNQUtYOztRQUNKLFdBbkJIbWpELFNBU1M3RyxTQUFNRCxPQUFNeG5ELGFBSVpxNUI7UUFNTjtTQUNBLFdBWEN0eUIsS0FBSzBnRCxhQUlBcHVCLE1BSllyNUIsYUFJZnJFO1NBT0g7VUFDSyxJQVpDOHlELGNBSUFwMUI7VUFKQW91QixVQUFBZ0g7VUFBd0I1dkQsTUFBQXVCOzs7Ozs7Ozs7Ozs7Ozs7O0tBVzlCOztHQUNpQztZQXRCdENzdUQsV0F3QkUvMUQsR0FBR3FILGFBQWUsT0FkZCtHLFdBY0QvRyxhQUFIckgsR0FBOEM7WUFHaEQrVCxnQkFBVyx5Q0FFYTtZQVF4QjdVLE9BQU84RCxHQUFFdUwsR0FBRTlHO0lBQ2IsVUFEU3pFO1NBQ0w0eUQ7a0JBREs1eUQsVUFDTDR5RCxpQkFJZUksTUFMVmh6RCxNQUNMNHlELEtBSWVJO0lBRW5CLFVBUGF2dUQ7U0FPVG91RDtrQkFQU3B1RCxVQU9Ub3VELGlCQUllSSxNQVhOeHVELE1BT1RvdUQsS0FJZUk7O0tBRWZodEM7T0FOQTRzQyxNQU5BRDtVQVlxQiw0QkFackJBO1VBWWlDLDRCQU5qQ0M7SUFPSixTQURJNXNDLEdBRUMsV0FmTTFhO2NBQUZ2TDtTQWlCSGt6RDtrQkFqQkdsekQsVUFpQkhrekQsaUJBSWtCMXhELE1BckJmeEIsTUFpQkhrekQsS0FJa0IxeEQ7SUFFdEIsVUF2QldpRDtTQXVCUDB1RDtrQkF2Qk8xdUQsVUF1QlAwdUQsaUJBSWtCejRELElBM0JYK0osTUF1QlAwdUQsS0FJa0J6NEQ7SUFFSixXQUFBLDRCQVpkdzRELElBTUFDO0lBTUosV0E3Qk9uekQsR0FBRXVMLEdBQUU5RyxHQWFUd2hCLEdBZ0JnQjtHQUFhO1lBSy9CbXRDLCtCQUFrQ2ozRCxLQUFLYzthQUNqQ21PLEtBQUtvRSxHQUFHdlMsR0FBRWhIO0tBQ2hCLFFBRFd1WjthQUFBQTs7U0FFSjs7U0FFRyxJQUFKK29DLE1BQUksV0FKSXQ3QyxHQUFFaEgsSUFLZCxXQURJc2lEOztTQUdLO1VBQUw4YSxLQUFLLFdBUEdwMkQsR0FBRWhIO1VBUVZxOUQsTUFBSSxXQVJJcjJELEdBUUYsNEJBUkloSDtTQVNkLE9BNUNGaUcsV0EwQ01tM0QsS0FDQUM7O1NBR0s7VUFBTEMsT0FBSyxXQVhHdDJELEdBQUVoSDtVQVlWdTlELE1BQUksV0FaSXYyRCxHQVlGLDRCQVpJaEg7VUFhVnc5RCxLQUFLLFdBYkd4MkQsR0FhRCw0QkFiR2hIO1NBY0ssT0FqRHJCaUcsV0E4Q01xM0QsT0FDQUMsU0FDQUM7O0tBR2M7TUFBZEMsY0FBYyw2QkFoQlRsa0Q7TUFpQlUsT0FBQSw0QkFqQlZBLEdBZ0JMa2tEO01BQ0FDLGVBQWU7TUFDZnJ2QixPQWxCQWw1QixLQWdCQXNvRCxhQWhCUXoyRCxHQUFFaEg7TUFtQlZ1MkIsSUFBSSxXQW5CSXZ2QixHQW1CRiw0QkFuQkloSCxHQWdCVnk5RDtNQUk4QixPQUFBLDRCQXBCcEJ6OUQsR0FnQlZ5OUQ7TUFJQW52QixRQXBCQW41QixLQWlCQXVvRCxjQWpCUTEyRCxHQW9CcUI7S0FDakMsT0F4REZmLE9BcURNb29DLE1BQ0E5WCxHQUNBK1g7SUFDZTtJQUV2QixPQXZCUW41QixLQUQ0QmpQLEtBQUtjO0dBd0I1QjtZQUdYMjJELDBCQUEwQmh5RCxPQUFPeUM7SUFDbkMsSUFBSXd2RCxlQUR3Qmp5RDs7O0tBRTVCLFFBRElpeUQ7TUFJMkMsNEJBTG5CanlEO01BS0gsUUFBQSxXQUxVeUMsOEJBQVB6Qzs7UUFFeEIwNkI7bUJBS09ybUM7V0FBSztZQUFPLE9BQUEsNEJBTm5CNDlEO1lBTW1CLE9BQUEsa0NBQVo1OUQ7V0FBSyx3QkFQWTJMO1VBT2dCOzs7O1NBTHhDMDZCLGdCQUlPcm1DLEdBQUssd0JBTlkyTCxPQU1qQjNMLE9BQUFBLEdBQWM7O0lBR3pCLE9BcENFbTlELCtCQTRCRVMsY0FDQXYzQjtHQU9zRDtZQUd4RHczQixnQkFBZ0JseUQsT0FBT3lDO0lBQ3pCLFVBRGtCekM7O0tBSUosT0FBQTtjQTdJZHFJO3VCQTZJbUJ4RjtlQUNmO2dCQUM4Qix3QkFOaEI3QztnQkFRVjNMO2tCQUZJLFdBTmFvTyw4QkFBUHpDO2dCQUtWbXlEO3dCQUdBOTlEO3FCQURLO3NCQUhNd087c0JBR0c7O3FCQUNkeE87Z0JBRVMsT0FBQSw0QkFWQzJMOzs7b0JBVWRFOztpQkFDcUM7a0JBQUEsT0FBQSw0QkFEckNBO2tCQUM4Qix3QkFYaEJGO2tCQWFWZ3BCO29CQUZJO3NCQVhhdm1CLDhCQUFQekMsT0FVZEUsU0FBQUE7MEJBR0k4b0I7a0JBREs7b0JBUk1ubUI7b0JBUUc7OzBCQUNkbW1CLHFCQVJBbXBDO2tCQVdFO29CQVpTdHZEO29CQWFQOztpQkFQUixXQUFBM0M7NkJBQUFBO2lCQUFBQTs7O2VBU0EsV0EvQkY4eEQsMEJBWWdCaHlELE9BQU95QztjQW1CbUM7SUFqQnhDLFdBZGxCdXZELDBCQVlnQmh5RCxPQUFPeUM7R0FtQm9DO1lBUTNEMnZELElBQUloMEQsR0FBRXVMLEdBQUU5RztJQUNWLFVBRE16RTtTQUNGNHlEO2tCQURFNXlELFVBQ0Y0eUQsaUJBSWVJLE1BTGJoekQsTUFDRjR5RCxLQUllSTtJQUVuQixVQVBVdnVEO1NBT05vdUQ7a0JBUE1wdUQsVUFPTm91RCxpQkFJZUksTUFYVHh1RCxNQU9Ob3VELEtBSWVJO09BRVgsNEJBTkpKLFNBTkFEO2VBREU1eUQ7TUFnQk8sTUFBQTtjQWhCUEE7TUFpQlEsTUFBQTtLQUVNLElBREZpMEQsS0FsQlpqMEQsTUFrQlFrMEQsS0FsQlJsMEQsTUFrQkltMEQsS0FsQkpuMEQsTUFtQmMsT0F4S2xCMHlELE9BdUtnQnVCO2dCQXZLaEJ2QixPQXVLUXlCLEtBRVksT0F4SHBCajRELE9Bc0hRaTRELElBQUlELElBdEhaaDRELE9Bc0hnQiszRCxJQWxCVjFvRCxHQUFFOUc7ZUFrQlF3dkQ7TUFLRCxNQUFBO2NBTENBO01BU2tELElBQTVDRyxNQVROSCxPQVNDSSxRQVRESixPQVNKSyxNQVRJTCxPQVNrRCxPQS9IbEUvM0QsT0ErSHNCazRELEtBM0JoQjdvRCxHQUFFOUc7TUEyQjBELE9BL0hsRXZJLE9BQUFBLE9Bc0hRaTRELElBQUlELElBU0FJLE1BQUtEOztTQUhORSxNQU5LTjtLQU9ILEtBdklibGpELFNBZ0lRb2pEO01BT0YsTUFBQTtLQUNnQyxXQTlIdENqNEQsVUFvR01xUCxHQUFFOUc7S0EwQjhCLE9BOUh0Q3ZJLE9BQUFBLE9Bc0hRaTRELElBQUlELFFBTURLOztPQUlBLDRCQTNCVDNCLFNBTUFDO2VBUE1wdUQ7TUErQkcsTUFBQTtjQS9CSEE7TUFnQ0ksTUFBQTtLQUVNLElBREYrdkQsS0FqQ1IvdkQsTUFpQ0lnd0QsS0FqQ0pod0QsTUFpQ0Fpd0QsS0FqQ0Fqd0QsTUFrQ1UsT0F2TGxCaXVELE9Bc0xRZ0M7Z0JBdExSaEMsT0FzTGdCOEIsS0FFVCxPQXZJUHQ0RCxPQUFBQSxPQW9HSThELEdBQUV1TCxHQWlDRW1wRCxLQUFJRCxJQUFJRDtlQUFSRTtNQUtPLE1BQUE7Y0FMUEE7TUFTd0QsSUFBMUNDLE1BVGRELE9BU1NFLFFBVFRGLE9BU0lHLE1BVEpILE9BU3dELE9BOUloRXg0RCxPQThJc0J5NEQsS0FUVkYsSUFBSUQ7TUFTZ0QsT0E5SWhFdDRELE9BQUFBLE9Bb0dJOEQsR0FBRXVMLEdBMENNc3BELE1BQUtEOztTQUhORSxNQU5ISjtLQU9LLEtBdEpiM2pELFNBK0lnQnlqRDtNQU9WLE1BQUE7S0FDOEIsV0E3SXBDdDRELFVBcUlZdTRELElBQUlEO0tBUW9CLE9BN0lwQ3Q0RCxPQUFBQSxPQW9HSThELEdBQUV1TCxPQXVDS3VwRDs7O0tBS1A3dUM7T0FyQ0Y0c0MsTUFOQUQ7VUEyQ3VCLDRCQTNDdkJBO1VBMkNtQyw0QkFyQ25DQztJQXNDRixVQTdDSTd5RDtTQTZDQWt6RDtrQkE3Q0FsekQsVUE2Q0FrekQsaUJBSWtCMXhELE1BakRsQnhCLE1BNkNBa3pELEtBSWtCMXhEO0lBRXRCLFVBbkRRaUQ7U0FtREowdUQ7a0JBbkRJMXVELFVBbURKMHVELGlCQUlrQno0RCxJQXZEZCtKLE1BbURKMHVELEtBSWtCejREO0lBRXRCLFNBYkl1ckIsR0FhVSxXQXpEUjFhO0lBeURzQyxXQUFBLDRCQVp4QzJuRCxJQU1BQztJQU1zQixXQXpEdEJuekQsR0FBRXVMLEdBQUU5RyxHQTRDSndoQixHQWF3QztHQUFhO0dBSzdEO1lBRUlrSCxJQUFJbndCLEdBQUUxUSxHQUFHK1g7YUFDSDB3RDtLQUFNLDhCQUNELFdBRkx6b0U7O01BSUksSUFESGlmLGNBQ0RpQixJQUFJLFdBSkRuSSxhQUFIL1gsR0FHQ2lmO01BRUwsU0FESWlCLEdBRUMsTUFBQTtrQkFGREEsSUF4S050USxVQXVLT3FQLE9BSERqZixNQXBLTjRQLFdBb0tNNVAsSUFHQ2lmOztLQVFHO01BREk5RztNQUFIaTVCO01BQUgxOUI7TUFDRndmLE1BQUksV0FYRG5iLGFBQUgvWCxHQVVLb3hDO0tBRVQsU0FESWxlLEtBQ1UsTUFBQTtpQkFEVkEsTUEzRU53MEMsSUEwRVFoMEQsR0FBRzA5QixLQVRMcTNCLElBU1F0d0QsTUExRWR1dkQsSUFpRU1lLElBU0UvMEQsSUFBRzA5QixLQUFHajVCO0lBRW9FO0lBRXBGLElBQUksV0FiSXN3RCxJQURGLzNELElBY0Y7Ozt1QkFDTSxPQWZKQTs7O0dBZUs7WUFLTDBOLEtBQUsxSyxHQUFFdUwsR0FBRTlHLEdBQUdKO0lBQ2xCLFVBRFdyRSxnQkFFRyxPQXRCWm10QixJQW9CYTFvQixHQUFGOEcsR0FBS2xIO2FBQVByRTtTQU1TZzFELEtBTlRoMUQsTUFNS2kwRCxLQU5MajBELE1BTUNpMUQsT0FORGoxRCxNQU1IbTBELEtBTkduMEQ7ZUFBSXlFO2VBQUFBO1dBS0xnd0QsS0FMS2h3RDtPQUtDLE9BekJkMG9CLElBQUFBLElBb0JTbnRCLEdBQUV1TCxHQUFLbEgsY0FLUm93RCxJQUxRcHdEOztVQU00QjZ3RCxLQU4vQnp3RCxNQU0yQit2RCxLQU4zQi92RCxNQU11QjB3RCxPQU52QjF3RCxNQU1tQml3RCxLQU5uQmp3RDthQU9MLDRCQURvQ3l3RCxTQUExQkY7Z0JBMUZsQmhCLElBMEZNRyxJQUFJYyxNQU5OdnFELEtBTVV1cEQsSUFOSDFvRCxHQUFFOUcsR0FBR0o7Z0JBU0g7bUNBSEsyd0Q7a0JBQTBCRTtrQkExRjVDbEIsSUFvRkl0cEQsS0FBSzFLLEdBQUV1TCxHQU1xQm1wRCxJQU5oQnJ3RCxjQU1vQjh3RCxNQUFJWDtrQkE5THhDdDRELE9Bd0xTOEQsR0FBRXVMLEdBQUU5Rzs7O2NBQUFBLGdCQUdELE9BdkJaMG9CLElBb0JTbnRCLEdBQUV1TCxHQUFLbEg7UUFJWDZ2RCxLQUpJbDBEO0lBSUssT0F4QmRtdEIsSUFBQUEsSUFvQmExb0IsR0FBRjhHLEdBQUtsSCxjQUlYNnZELElBSlc3dkQ7R0FXQztZQUlidVI7SUFBVTtJQUFBO3FDQUNMOztVQUNKcks7O1VBQ0N2TDtnQkFBQUEsMEJBQUFBO1VBRER1TDs7S0FBZ0MsV0FBaENBOztHQUM0QjtHQUdyQztJQUFBOzs7Ozs7R0FHRTs7Ozs7O01BRUUsMkNBRUk7TUFDSyxNQUFBO0tBQWE7R0FLMUI7SUFBQTs7Ozs7O0dBR0U7Ozs7OztNQUVFLDJDQUVJO01BQ0ssTUFBQTtLQUFhOztZQUt0QjZwRCxZQUFZcDREO0lBQ1IsWUFqQ0E0WSxRQWdDUTVZOztLQUVKLE1BQUE7UUFDSHVPO0lBQUssT0FBTEE7R0FBTTtZQUdYbUssV0FBVzFZLEdBQUdOLE1BQU1PLEdBQUcwWTtJQUN6QixTQUFRMC9DLGtCQUFtQnA0RCxHQUFFRCxHQUFFd1k7S0FDN0IsSUFEMkJ0UyxNQUFBbEcsR0FBRWtxQixRQUFBMVI7S0FDN0I7Z0JBRDJCdFMsa0JBRWhCLFdBRmtCZ2tCO2VBQUZoa0I7V0FHcEI4cEIsUUFIb0I5cEI7T0FHWCxPQUFBLFdBSFNqRyxHQUFJaXFCLE9BR3RCOEY7O01BRUU7T0FMa0J1WCxRQUFBcmhDO09BSWJveUQsVUFKYXB5RDtPQUluQm9oQyxPQUptQnBoQztPQU10QjVXLElBTkMrb0Usa0JBQW1CcDRELEdBSWpCcW5DLE1BSnFCcGQ7ZUFNeEI1NkIsTUFBZ0IsT0FBaEJBO01BRU8sSUFERTY2QixRQURUNzZCLE1BR0crbUIsTUFESSxXQVJhcFcsR0FPWGtxQixPQUhBbXVDO2VBS05qaUQsUUFBZ0IsT0FBaEJBO1VBVHFCbTNDLFFBU3JCbjNDO01BVG1CblEsTUFBQXFoQztNQUFFcmQsUUFBQXNqQzs7SUFVdUI7SUFFaEQsWUFaRTZLLGtCQURjcDRELEdBQVRELEdBQUdOOzJCQWNMcFEsY0FBSyxPQUFBLFdBZFNxcEIsUUFjZHJwQjtRQUNKK21CO0lBQUssT0FBTEE7R0FBTTtZQUdQeUM7SUFBVTtJQUFBO3FDQUNMOztVQUNKdks7OztXQUNPOUc7aUJBQUFBOzs7VUFEUDhHOztLQUFnQyxXQUFoQ0E7O0dBQzRCO1lBR2pDZ3FELFlBQVl2NEQ7SUFDUixZQVBBOFksUUFNUTlZOztLQUVKLE1BQUE7UUFDSHVPO0lBQUssT0FBTEE7R0FBTTtZQUtQaXFEO0lBQWlCO0tBQ1osT0FBQTt1QkFDQztRQUVKeDFEO2NBQUFBLG9CQURVeUUsY0FBWSxPQUFaQTtRQUNKZ2lDLGdCQUFIbDdCO0lBQWUsT0E3S3hCeW9ELElBeUtJd0IsZUFJRXgxRCxJQUFHdUwsR0FBR2s3QjtHQUFzQztZQUtsRDFlLE1BQU0zcEIsSUFBR0M7SUFDWCxVQURRRCxpQkFFTSxPQUZIQztjQUFBQSxpQkFHRyxPQUhORDtJQUkwQixXQWI1Qm8zRCxlQVNLbjNEO0lBSXVCLE9BdExoQzIxRCxJQWtMTTUxRCxJQS9DTmczRCxZQStDUy8yRDtHQUkwQztZQUtuRDlCLE9BQU82QixJQUFHQyxJQUFJZ0c7SUFDaEIsVUFEU2pHO1NBRUFwQixJQUZHcUI7O2VBQUFBO01BR3VCLFdBckI3Qm0zRCxlQWtCTW4zRDtNQUdGLE9BMUdKcU0sS0F1R0d0TSxJQXhEUGczRCxZQXdEVS8yRCxXQUFJZ0c7O1NBRVBySCxJQUZBb0I7O0lBRWdCLE9BQWhCcEI7R0FDMEQ7WUFHakVtM0MsTUFBTW4zQyxHQUFFMVEsR0FBRytYO2FBQ0w4dkMsTUFBTW4zQztLQUNaLFVBRFlBLGdCQUVEO2NBRkNBO01BSUYsSUFESHVPLElBSEt2TyxNQUlOd1AsSUFBSSxXQUxDbkksYUFBSC9YLEdBSURpZjtNQUVMLGFBRElpQjsyQkFEQ2pCO3FCQUNEaUIsWUFEQ2pCLDBCQUFBQTs7S0FRRztNQURJOUcsSUFWRnpIO01BVUQwZ0MsTUFWQzFnQztNQVVKZ0QsSUFWSWhEO01BV053aUIsTUFBSSxXQVpDbmIsYUFBSC9YLEdBV0dveEM7S0FFVCxTQURJbGUsS0FFQyxXQUhDeGYsT0FBRzA5QixNQUFHajVCO2FBQ1IrYTtNQVFzQjtPQUFBLFFBbkJ0QjIwQixNQVVRMXZDO09BU1MrdkQ7T0FBWGlCO09BQUp4QjtNQUNKLFdBbElBdnBELEtBd0hJMUssR0FBRzA5QixLQVNIdTJCLElBcEJHNXZELGNBb0JDb3hELFdBQVdqQjs7S0FISztNQUFBLFVBaEJ0QnJnQixNQVVFbjBDO01BTWUwMEQ7TUFBWGdCO01BQUp2QjtLQUNKLFdBRElBLElBQUl1QixhQTlIUmhyRCxLQThIbUJncUQsSUFOWmgzQixLQUFHajVCLEdBWEhKO0lBcUJpQztJQUU5QyxPQXRCUTh2QyxNQURBbjNDO0dBdUJEO09BZ25CbUIyNEQ7WUF6bUJwQnQrQyxJQUFJcmEsR0FBRTFRLEdBQUcrWDtJQUNmLElBRFVuQixNQUFBbEc7SUFDVjtlQURVa0csa0JBRUM7Y0FGREE7TUFJQSxJQURIcUksSUFIR3JJLFFBSUpzSixJQUFJLFdBSktuSSxhQUFIL1gsR0FHTGlmO21CQUNEaUI7O0tBR0k7TUFESS9ILElBTkp2QjtNQU1DdzZCLE1BTkR4NkI7TUFNRmxELElBTkVrRDtNQU9Kc2MsTUFBSSxXQVBLbmIsYUFBSC9YLEdBTURveEM7bUJBQ0xsZTs7U0FQSWluQixXQU9Kam5CLE1BRFEvYSxJQUFOekU7S0FORWtELE1BQUF1akM7O0dBUTRDO1lBS3BEdlosT0FBT2x3QixHQUFFMVEsR0FBRytYO2FBQ04wd0QsSUFBSS8zRDtLQUNWLFVBRFVBLGdCQUVDLE1BQUE7Y0FGREE7TUFLQSxJQURJeUgsSUFKSnpILE1BSUMwZ0MsTUFKRDFnQyxNQUlGZ0QsSUFKRWhELE1BS0p3UCxJQUFJLFdBTkVuSSxhQUFIL1gsR0FLRW94QztNQUVULGFBRElseEI7Z0JBaEVOdWIsTUErRFEvbkIsR0FBTXlFO3FCQUNSK0gsSUFsUE53bkQsSUFpUFFoMEQsR0FBRzA5QixLQUpMcTNCLElBSVF0d0QsTUFqUGR1dkQsSUE2T01lLElBSUUvMEQsSUFBRzA5QixLQUFHajVCOztTQURQOEcsSUFIR3ZPO0tBR0ssU0FBQSxXQUpIcUgsYUFBSC9YLEdBSUZpZixJQUFpQztLQUFXLE1BQUE7SUFHOEI7SUFFbkYsSUFBSSxXQVJJd3BELElBREMvM0QsSUFTTDs7O3VCQUNNLE9BVkRBOzs7R0FVRTtZQUdUNDRELGFBQWE1NEQsR0FBRS9HO2FBQ1Q4K0QsSUFBSS8zRCxHQUFFL0c7S0FDWixVQURVK0csZ0JBRUMsTUFBQTtjQUZEQTtlQUFFL0csR0FHYztNQUFXLE1BQUE7O0tBRXRCO01BRER3TyxJQUpKekg7TUFJQ3VPLElBSkR2TztNQUlGZ0QsSUFKRWhEO01BS0o2NEQsU0E5WU4vMkQsT0E2WVFrQjtNQUVGd00scUJBTk12VyxHQUtONC9EO0tBRUosU0FESXJwRCxHQUVDLE9BaEZQdWIsTUE0RVEvbkIsR0FBTXlFO1lBRVIrSCxHQUlDLE9BcFFQd25ELElBMFBNZSxJQUlFLzBELEdBSkkvSixJQUlEc1YsR0FBRzlHO0tBT1MsV0FBQSw0QkFYWHhPLEdBS040L0Q7S0FNUyxPQXJRZjdCLElBOFBRaDBELEdBQUd1TCxHQUpMd3BELElBSVF0d0QsR0FPUTtJQUFpQjtJQUV6QyxJQUFJLFdBYklzd0QsSUFETy8zRCxHQUFFL0csSUFjYjs7O3VCQUNNLE9BZksrRzs7O0dBZUo7WUFHVDg0RCxNQUFNajFCLElBQUdGLElBQUl0OEI7YUFDUHl4RCxNQUFNajFCLElBQUdGO0tBQ2YsSUFEWUssT0FBQUgsSUFBR0MsT0FBQUg7S0FDZjtNQUFHLEdBQUEsNkJBRFNLLE1BQUdGLE9BRVYsT0FGT0U7Z0JBQUFBO1dBS0Roa0MsSUFMSThqQzs7Z0JBQUhFO1lBUVUvWSxLQVJWK1ksU0FRTXJtQixLQVJOcW1CLFNBUUUrMEIsT0FSRi8wQixTQVFGNWhDLEtBUkU0aEM7a0JBQUdGO2tCQUFBQTtVQU9ZLElBQWZzQyxLQVBHdEMsU0FBQUMsY0FPSHFDO1VBUEd0QyxPQUFBQzs7O2FBUWlDL1ksS0FSakM4WSxTQVE2QmxtQixLQVI3QmttQixTQVF5QmsxQixPQVJ6QmwxQixTQVFxQnpoQyxLQVJyQnloQztZQVFpQzlZLE1BQTFCQzttQkFBMEJELElBUmxELE9BNU1FbUYsSUE0TVk2VCxNQVE0QmcxQixNQVQzQjN4RDtVQWVXO1dBQUEsUUF6RnhCOHZDLE1BMkVlclQsTUFRRGkxQixNQVREMXhEO1dBZU00eEQ7V0FBUDV3QztXQUNrQixPQWZ4Qnl3QyxNQVFZbjdDLElBTUNzN0M7VUFDWCxPQXZNSnZyRCxLQXdMRW9yRCxNQVFJMTJELElBTUVpbUIsT0FORTB3QyxZQVREMXhEOztrQkFTUzRqQixJQVJ4QixPQTVNRWtGLElBNE1lMlQsTUFRRGkxQixNQVREMXhEO1NBb0JTO1VBQUEsVUE5RnRCOHZDLE1BMkVZblQsTUFRNEJnMUIsTUFUM0IzeEQ7VUFvQkk2eEQ7VUFBUDl3QztVQUNrQixPQXBCdEIwd0MsTUFtQldJLE1BWDJCdDdDO1NBWXRDLE9BNU1GbFEsS0F3TEVvckQsTUFtQkkxd0MsTUFYMEIvbEIsS0FBSTIyRCxZQVQzQjN4RDs7O2lCQUNFeThCO1FBTVMsSUFBZnVDLEtBTkdyQyxTQUFBRSxjQU1IbUM7UUFOR3JDLE9BQUFFOzs7V0FLRGxrQyxJQUxDZ2tDOztNQUtlLE9BQWhCaGtDOztJQWU2QztJQUUxRCxPQXRCUTg0RCxNQURBajFCLElBQUdGO0dBdUJBO1lBR1R3MUIsV0FBWS9vRCxZQUFZZ3BELFNBQVF0eEQ7SUFDbEMsSUFBSVQsY0FEVStJO0lBRWMsT0FBQTs7YUFGTXRJO2FBbWlCUjZ3RDtzQkFqaUJPcHdDLElBQUdqNUI7Y0FBSyxPQTVCdkN3cEUsTUE0QitCdndDLElBQWlCLFdBRnhCNndDLFNBRVU5cEUsSUFEaEMrWDthQUNzRTtHQUFDO1lBR3pFZ3lELE1BQU14MUIsSUFBR0YsSUFBSXQ4QjthQUNQZ3lELE1BQU14MUIsSUFBR0Y7S0FDZixHQUFHLDZCQURTRSxJQUFHRixLQUVWLE9BRk9FO2VBQUFBLDBCQUFHRjs7O2lCQUFIRSx5QkFBQUE7a0JBQUdGLHlCQUFBQTtTQVNKO1VBRE9obUIsS0FSTmttQjtVQVFFd0MsS0FSRnhDO1VBUUZ6aEMsS0FSRXloQztVQVNELE9BbkhYc1QsTUEwR2V4VCxJQVFEMEMsSUFURGgvQjs7VUFXTmhGOztVQUN5QyxJQUE1QnViLGNBQUptN0MsaUJBQWdDLE9BWDFDTSxNQVFZMTdDLElBR0VDO1VBQU0sT0FsT3RCbFEsS0F1TkUyckQsTUFRSWozRCxJQUVIQyxLQUNTMDJELFlBWkgxeEQ7O1NBVytCLElBQTNCNHhELGdCQUEyQixPQVZ0Q0ksTUFRWTE3QyxJQUVEczdDO1NBQU0sT0ExSHZCMTVELE9BZ0hNODVELE1BUUlqM0QsSUFFSEMsV0FYTWdGOztZQU9nQml5RCxZQU5qQnoxQixJQU1SOEIsWUFOV2hDLElBTUw5cUIsTUFOSzhxQjs7O1dBTWMyMUIsWUFOZDMxQixJQU1YZ0MsWUFOUTlCLElBTUZockIsTUFORWdyQjs7TUFPTCxPQW5GSHhwQixJQWtGeUJpL0MsV0FBbkJ6Z0QsS0FQR3hSLGVBT1RzK0I7O0tBRHVCO0lBTWlEO0lBRTlFLE9BYlEwekIsTUFEQXgxQixJQUFHRjtHQWNBO1lBR1R0bUIsS0FBS3dtQixJQUFHRixJQUFJdDhCO2FBQ05nVyxLQUFLd21CLElBQUdGO0tBQ2QsSUFEV0ssT0FBQUg7S0FDWDtNQUFHLEdBQUEsNkJBRFFHLE1BQUdMLEtBRVQ7Z0JBRk1LLG1CQUtLO2dCQUxGTCxpQkFNRyxPQU5OSztnQkFBQUEsMkJBQUFBO09BU0E7UUFET3JtQixLQVJQcW1CO1FBUUcrMEIsT0FSSC8wQjtRQVFENWhDLEtBUkM0aEM7UUFTQSxPQXBJWG1ULE1BMkhjeFQsSUFRQW8xQixNQVRGMXhEO1FBV0xoRjs7UUFDc0MsSUFBMUJ1YixjQUEwQixPQVh2Q1AsS0FRWU0sSUFHQ0M7UUFBTSxPQTVJekJyZSxPQWlJTThkLEtBUUlqYixJQUVIQyxXQVhLZ0Y7O09BV2dDLElBQTNCNHhELGdCQUEyQixPQVZ0QzU3QyxLQVFZTSxJQUVEczdDO09BQU0sT0FsUG5CdnJELEtBd09FMlAsS0FRSWpiLElBRUhDLEtBRk8wMkQsWUFURjF4RDs7TUFRWSxJQUFmZy9CLEtBUEVyQyxTQUFBRSxjQU9GbUM7TUFQRXJDLE9BQUFFOztJQVc2RDtJQUUxRSxPQWJRN21CLEtBRER3bUIsSUFBR0Y7R0FjQTtZQVdGcFMsS0FBSzd6QixHQUFHbUg7SUFDZCxJQURXTCxNQUFBOUcsR0FBR2dpQixNQUFBN2E7SUFDZDtlQURXTCxrQkFFQSxPQUZHa2I7Y0FBSGxiLFlBR0orSixJQUhJL0osUUFHQyxXQUFMK0osTUFIT21SO0tBSW1CLElBQW5CalksSUFKSGpELFFBSUFrOEIsTUFKQWw4QixRQUFBeEIsSUFBQXdCLFFBQUcrMEQsVUFJSDc0QixLQUFHajVCLEdBSkFpWTtLQUFIbGIsTUFBQXhCO0tBQUcwYyxNQUFBNjVDOztHQUltQztZQUczQ0MsV0FBVzk3RCxHQUFHbUg7SUFDcEIsSUFEaUJMLE1BQUE5RyxHQUFHZ2lCLE1BQUE3YTtJQUNwQjtlQURpQkwsa0JBRU4sT0FGU2tiO2NBQUhsYixZQUdWK0osSUFIVS9KLFFBR0wsV0FBTCtKLE1BSGFtUjtLQUltQixJQUp0QmpZLElBQUFqRCxRQUlOazhCLE1BSk1sOEIsUUFJVHhCLElBSlN3QixRQUFHKzBELFVBSVQ3NEIsS0FBSDE5QixHQUpZMGM7S0FBSGxiLE1BQUFpRDtLQUFHaVksTUFBQTY1Qzs7R0FJbUM7WUFHckRFLE9BQU8vN0QsR0FBd0IsT0FkM0I2ekIsS0FjRzd6QixNQUFrQztZQTBDckN5QyxLQUFNRjs7O21CQUNIO1NBQ1F5NUQscUJBQU5DLG1CQUFIdjJEO0tBQ04sV0FIVW5ELEdBRUptRDtlQTFERm11QixLQTBES29vQyxNQUFNRDs7O1lBNk9qQkUsZUFqTmlCeDRELElBQUdDLElBQUlnRzthQUNwQnk1QixLQUFLNzZCO0tBQ1AsSUFJRXFoQyxPQUxLcmhDO1VBS0xxaEM7a0JBTEtyaEM7a0JBRU87VUFDVXl6RCxtQkFBTkMsaUJBQUxFO01BQW9CLGVBQXBCQSxlQTFGVHRvQyxLQTBGY29vQyxNQUFNRDs7U0FFYW55QixRQUw5QnRoQyxVQUlZNnpELFFBQ2pCeHlCLFNBRFd5eUIsUUFDWHp5QixTQURNenVCLE1BQ055dUI7VUFBbUNDLE9BREosZUFBekIxdUIsVUEzRkowWSxLQTJGU3dvQyxPQUFNRDtLQUVJO01BRGdDRSxRQUFsQnp5QjtNQUFXMHlCLFFBQVgxeUI7TUFBT3piLEtBQVB5YjtNQUMvQjJ5QixpQkFBaUIsV0FQRDd5RCxhQUtkd1IsS0FDb0NpVDtLQUUxQyxTQURJb3VDO2tCQUFBQTt3QkFEc0NwdUMsU0FBMUN3YixNQTVGRS9WLEtBNEY0QzBvQyxPQUFPRDt3QkFEL0NuaEQsVUEzRkowWSxLQTJGU3dvQyxPQUFNRCxRQUNrQnZ5QjtLQUs1QixHQUFBLDZCQU5Jd3lCLE9BQ21DRTtVQUl4Q0UsaUJBTFdMLE9BQ29DRTs7TUFPMUI7T0FBQSxPQW5HekJ6b0MsS0E0RjRDMG9DLE9BQU9EO09BSS9DRyxpQkFoR0o1b0MsS0EyRlN3b0MsT0FBTUQ7S0FVZixXQUxJSztJQVEwQztJQUViLElBQUEsT0E1RnJDVixPQXdFa0JwNEQsS0FvQk8sV0E1RnpCbzRELE9Bd0VlcjREO0lBb0JqQixPQUFBLG9DQW5CSTAvQjtHQW1CcUQ7WUFnQ3pEMEs7SUFDRXA3QixZQUNFdkssS0FDRHUwRCxxQkFDQUMsa0JBQ0RoMEQ7SUFFSixHQUxNUixTQUFRQyxNQUFSRCxRQUFBbWIsUUFBUWxiLGNBQVJrYjthQUtGczVDLGdCQUFnQkMsTUFBS3Y2RCxHQUFFa2M7S0FDekI7TUFBSTdVLGNBUEYrSTtNQVFnQixRQXRTbEIrbUMsTUFvU3VCbjNDLEdBQUVrYyxPQUNyQjdVO01BQ1VJO01BQVAreUQ7TUFBSHgzRDtNQUNBa0QsTUFBSSxXQUhVcTBELFVBRWR2M0QsR0FBVXlFO0tBRWQsS0FGTyt5RCxPQUdHLE9BRk50MEQ7U0FHRzJTLE1BSkEyaEQ7S0FJTyxPQTNhZHJxQyxJQXdhSWpxQixLQUdHMlMsS0FMSHhSO0lBS2dDO0lBRXRDLGdCQWJNMlo7S0FlSTtNQUFSO01BN0M0QzFhO1FBNkNwQzs7VUFiTCt6RDtVQUNEaDBEOytCLE9BRUFpMEQ7TUFsQ0FoN0I7aUJBQUtvNkI7U0FDUCxLQURPQSxRQUVPO2FBQ0s3MEQsSUFIWjYwRCxXQUdTMTVELElBSFQwNUQsV0FHTWxxQyxJQUhOa3FDO1NBR2tCLFdBQVpscUMsR0FsSFArQixLQWtIVXZ4QixHQUFHNkU7UUFBNEM7S0FFakUsR0F5Qkt1MUQ7TUF0Qlc7T0F0R2F4cUMsTUE0SHhCd3FDO09BNUg0Qi9qRSxVQTBIN0IrWjtPQXpIV3BRLElBNEYrQnNHO09BNUY3QnpCO01BQ2I7aUJBRFc3RSxvQkFrR1hOLE9BbEdhbUY7Z0JBQUY3RTtRQUdNLElBQVZ1TyxJQUhJdk8sTUFBQWtHLGFBR0pxSTtRQUhJdk8sSUFBQWtHOzs7WUFBQWxELElBQUFoRCxNQUFBeUgsSUFBQXpILE1BSUEwZ0MsTUFKQTFnQztRQUlpQixRQUFBLFdBTEMzSixTQUtsQnFxQyxLQUxjOVE7U0FNUSxJQUFuQjZaLE1BTEh6cEMsTUFLQXk2RCxNQUxBejZELE1BQUUwZixVQUtGKzZDLEtBQUdoeEIsS0FMRDVrQztTQUFGN0UsSUFBQWdEO1NBQUU2QixJQUFBNmE7OztTQUFGMWYsSUFBQXlIOzs7OztVQWtHWC9ILE9BdEdBKzVELE9BZ0cwQ256RDtLQVc5QyxPQUFBLDhCQUxJNUcsTUFMQTQvQjs7SUErQ007S0FBUjtLQWxDNEMvNEI7T0FrQ3BDOztTQWpCTDZ6RDtTQUVEL3pEOzhCLE9BRUFpMEQ7YUFwQkFuNUIsT0FBS3U0QjtLQUNQLEtBRE9BLFFBRU87U0FDSzcwRCxJQUhaNjBELFdBR1MxNUQsSUFIVDA1RCxXQUdNbHFDLElBSE5rcUM7S0FHa0IsV0FBWmxxQyxHQXpIUGdxQyxXQXlIVXg1RCxHQUFHNkU7SUFBa0Q7SUFFdkUsR0FZS3cxRDtLQVRXO01BekdheHFDLFFBa0h4QndxQztNQWxINEJoakUsWUErRzdCK1k7TUE5R1dqSyxNQStGK0JJO01BL0Y3Qmd6RDtLQUNiO2dCQURXcHpELHNCQXFHWHUwRCxTQXJHYW5CO2VBQUZwekQ7T0FHTSxJQUFWdzBELE1BSEl4MEQsUUFBQUMsYUFHSnUwRDtPQUhJeDBELE1BQUFDOzs7V0FLSHFtQixNQUxHdG1CLFFBSUF5MEQsTUFKQXowRDtPQUlpQixPQUFBLFdBTEM5TyxXQUtsQnVqRSxLQUxjL3FDO1FBQ2QxcEIsTUFLSHNtQjs7UUFBeUIsSUFMdEJpZCxNQUFBdmpDLFFBS0EwMEQsTUFMQTEwRCxRQUFFMjBELFVBS0ZELEtBQUhwdUMsS0FMSzhzQztRQUFGcHpELE1BQUF1akM7UUFBRTZ2QixNQUFBdUI7Ozs7OztTQXFHYkosU0EzSElsQixXQXFIc0NqekQ7SUFXOUMsT0FBQSw4QkFMSW0wRCxRQUxBdjVCO0dBa0M0RDtZQUkxRHZHLHNCQUFzQjU2QixHQUFHQztJQUMvQixJQUQ0QmlHLE1BQUFsRztJQUM1QjtlQUQ0QmtHLGtCQUVqQjtjQUZpQkEsWUFHckJxSSxJQUhxQnJJLFFBR2IsT0FBQSxXQUhnQmpHLEdBR3hCc08sU0FBQUE7U0FIcUI5RyxJQUFBdkIsUUFJakJ3NkIsTUFKaUJ4NkIsUUFJcEJsRCxJQUpvQmtEO0tBS3ZCLEdBQUEsV0FMMEJqRyxHQUlwQnlnQztNQUdELElBRUpweEMsSUFUQXNyQyxzQkFJRTUzQixHQUp1Qi9DO2FBU3pCM1EsSUFBQUEsUUFMS294Qzs7S0FKaUJ4NkIsTUFBQXVCOztHQVVLO1lBRzNCMnpCLHFCQUFxQnA3QixHQUFHQztJQUM5QixJQUQyQmlHLE1BQUFsRztJQUMzQjtlQUQyQmtHLGtCQUVoQjtjQUZnQkEsWUFHcEJxSSxJQUhvQnJJLFFBR1osT0FBQSxXQUhlakcsR0FHdkJzTyxTQUFBQTtTQUNPOUcsSUFKYXZCLFFBSWhCdzZCLE1BSmdCeDZCLFFBQUFsRCxJQUFBa0Q7S0FLdEIsR0FBQSxXQUx5QmpHLEdBSW5CeWdDO01BR0QsSUFFSnB4QyxJQVRBOHJDLHFCQUlRM3pCLEdBSmdCeEg7YUFTeEIzUSxJQUFBQSxRQUxLb3hDOztLQUpnQng2QixNQUFBbEQ7O0dBVUs7WUFHOUJxNEIsY0FBY3I3QixHQUFHM0osU0FBUWlsQyxLQUFJL3NCO0lBQy9CLGlCQUQyQitzQjt5QkFBQUE7O2tCQUFBQTtpQkExQnJCVjtrQkEwQlU1NkI7MkJBYWtCMVEsR0FBSyxZQUFBLFdBYnBCK0csU0FhZS9HLEdBYkhpZixXQWF3QjtpQkExQmpENnNCO2tCQWFVcDdCOzJCQUU2QzFRLEdBQUssT0FBQSxXQUYvQytHLFNBRTBDL0csR0FGOUJpZixlQUVrRDs7a0JBRnREK3NCO2lCQWJyQkY7a0JBYVVwN0I7MkJBR2dEMVEsR0FBSyxPQUFBLFdBSGxEK0csU0FHNkMvRyxHQUhqQ2lmLGdCQUdzRDtpQkE3Qi9FcXNCO2tCQTBCVTU2QjsyQkFla0IxUSxHQUFLLFdBQUEsV0FmcEIrRyxTQWVlL0csR0FmSGlmLFdBZXVCO3NCQWYzQitzQjtLQVNsQjtNQUNKemlCO1FBdkJDdWlCO1VBYVVwN0IsWUFTd0IxUSxHQUFLLE9BQUEsV0FUMUIrRyxTQVNxQi9HLEdBVFRpZixnQkFTOEI7UUFDeERzSyxTQUFLdnBCLElBQUx1cEIsUUFBbUIsU0FBQSxXQVZMeGlCLFNBVVQvRyxHQVZxQmlmLElBVVksT0FBdENzSztLQUNpQjs7SUFOYjtLQUNKZ2hEO09BaENDai9CO1NBMEJVNTZCLFlBS3lCMVEsR0FBSyxZQUFBLFdBTDNCK0csU0FLc0IvRyxHQUxWaWYsV0FLK0I7T0FDekRzckQ7U0FBS3hqRCxNQUFMd2pEO0tBQW1CLFNBQUEsV0FOTHhqRSxTQU1UZ2dCLEtBTnFCOUgsSUFNWSxPQUF0Q3NyRDs7SUFDaUI7R0FRaUM7WUFHckR0K0Isd0JBQXdCdjdCLEdBQUd3N0IsWUFBV0Y7YUFDcENHLFFBQVFuc0M7S0FDVixvQkFBTSxXQUZxQmtzQyxZQUNqQmxzQztJQUdPO0lBRW5CLFNBQUlvc0MsU0FBU3BzQyxHQUFJLFdBTGJtc0MsUUFLU25zQyxHQUFtQjtJQUNoQyxvQkFQd0Nnc0M7Y0EvQmxDRixxQkErQm9CcDdCLEdBQ3RCeTdCO2NBN0NFYixzQkE0Q29CNTZCLEdBTXRCMDdCO0dBR29EO1lBR3REcS9CO0lBQ0UzcUQsWUFDRXZLLEtBQ0R1MEQscUJBQ0FDLGtCQUNEbjBELEtBQ0FsRztJQUVKLEdBTk02RixTQUFRQyxNQUFSRCxRQUFBbWIsUUFBUWxiLGNBQVJrYjtJQU1OO0tBQUE7b0JBTk1BO1VBREY1UTtVQWFrQix1QkFibEJBO0tBU0Y7T0EzRkFvN0I7U0FrRkVwN0IsZ0JBQ0U0USxRQUNEbzVDLHFCQUNBQyxrQkFFRHI2RDtLQUdGO09BMUZBd3JDO1NBa0ZFcDdCLGdCQUNFNFEsUUFDRG81QyxxQkFDQUMsa0JBQ0RuMEQ7SUFTa0IsT0FBQTtHQUEyQjtZQUcvQzdQLFFBQVFnUixhQUFZdzhCLElBQUdGO0lBQ3pCLElBck1rQnEzQixPQTFCZHZCLE9BOE5xQjkxQixLQXBNVnMzQixPQTFCWHhCLE9BOE5rQjUxQixLQXBNUDNMLEtBQUEraUMsTUFBRzlpQyxLQUFBNmlDO0lBQ2Q7VUFEVzlpQyxXQUFHQztVQUFBQSxJQUlGO0tBRUY7TUFEeUIraUMsT0FMckIvaUM7TUFLaUJ2YSxLQUxqQnVhO01BS2FpTyxLQUxiak87TUFLRWdqQyxPQUxMampDO01BS0N2YSxLQUxEdWE7TUFLSG1PLEtBTEduTztNQU1MMW9CLElBQUksV0E4TEpuSSxhQS9MRWcvQixJQUFtQkQ7S0FFekIsU0FESTUyQixHQUVDLE9BRkRBO0tBR0ksR0FBQSw2QkFKRW1PLElBQW1CQyxLQUxwQnNhLEtBS0tpakMsTUFMRmhqQyxLQUtxQitpQzs7TUFNVixJQVhYRSxPQXhDVjdwQyxLQTZDMkIzVCxJQUFJczlDLE9BTHhCRyxPQXhDUDlwQyxLQTZDUTVULElBQUl3OUM7TUFMTGpqQyxLQUFBbWpDO01BQUdsakMsS0FBQWlqQzs7O0dBcU13QztZQUd4RHI0QyxNQUFNOGdCLElBQUdGLElBQUl0OEI7SUFBYyxJQWhMWGhHLEtBbERkbzRELE9Ba09POTFCLEtBaExJdmlDLEtBbERYcTRELE9Ba09JNTFCO0lBQTZELGdCQWpMeEM1akM7Szs7VUFDZGliLE9BQUE5WixJQUFHK1osT0FBQTlaO01BQ2Q7WUFEVzZaO1lBQUdDO09BTVM7UUFEcUI2K0MsUUFMOUI3K0M7UUFLdUI4K0MsUUFMdkI5K0M7UUFLbUIyUSxLQUxuQjNRO1FBS0syK0MsUUFMUjUrQztRQUtDNitDLFFBTEQ3K0M7UUFLSDBRLEtBTEcxUTtRQU1MZy9DLGlCQUFpQixXQTBLWjd5RCxhQTNLSHVrQixJQUF5QkU7T0FFL0IsU0FESW91QztRQUdGLFdBVnFCajZELHNCQU1qQjJyQixJQUF5QkU7UUFLTCxJQVZkZ0csT0FoRVZQLEtBcUVpQzBvQyxPQUFPRCxRQUxqQ2pvQyxPQWhFUFIsS0FxRVF3b0MsT0FBT0Q7UUFMUjUrQyxPQUFBNlc7UUFBRzVXLE9BQUEyVzs7b0JBTVJvb0M7UUFVRixXQWpCcUJqNkQsa0JBTVE2ckI7UUFZckIsSUFqQkV3dkMsT0FoRVYvcEMsS0FxRWlDMG9DLE9BQU9EO1FBTDlCNytDLE9BQUFtZ0Q7OztRQWFWLFdBZHFCcjdELGtCQU1qQjJyQjtRQVNDLElBZEUydkMsT0FoRVBocUMsS0FxRVF3b0MsT0FBT0Q7UUFMUjUrQyxPQUFBcWdEOzs7YUFBR3BnRDtnQkFSVmhiOzBCQVd3QmlELEdBQUssT0FBRSxXQUpWbkQsa0JBSUdtRCxJQUFpQixHQUgvQitYOzs7S0FJRixPQVpSaGIsY0FZd0JpRCxHQUFLLE9BQUUsV0FMVm5ELGtCQUtHbUQsSUFBZ0IsR0FKakM4WDtHQWdMc0U7WUFDbkY1a0IsTUFBTXV0QyxJQUFHRixJQUFJdDhCO0lBQWMsYUFMM0JoUixRQUthZ1IsYUFBUHc4QixJQUFHRjtHQUErQztZQUV4RDYzQixVQUFVMzNCLElBQVFGLElBQUl0OEI7YUFDaEJtMEQsVUFBVTMzQixJQUFRRjtLQUN4QixJQURnQkssT0FBQUgsSUFBUUMsT0FBQUg7S0FDeEI7Z0JBRGdCSyxtQkFFRjtlQUZFQTtXQUFBcm1CLEtBQUFxbUIsU0FZSiswQixPQVpJLzBCLFNBWVI1aEMsS0FaUTRoQztpQkFBUUY7aUJBQUFBO2FBS1FzQyxLQUxSdEM7bUJBWWhCMWhDLDBCQVpRdWI7dUJBVVgsV0FYaUJ0VyxhQWFWMHhELE1BUG9CM3lCO1NBTW5COztRQUVIO1NBRGdDeG9CLEtBWmxCa21CO1NBWWNrMUIsT0FaZGwxQjtTQVlVemhDLEtBWlZ5aEM7U0FhbEJ0MEIsSUFBSSxXQWRZbkksYUFhVjB4RCxNQUEwQkM7UUFFcEMsU0FESXhwRDtpQkFBQUE7VUFPQyxXQXBCRGdzRCxpQkFZTXpDLE1BWklwN0MsV0FZMEJDO1VBUW5DLFdBQUE7VUFwQlNvbUIsT0FZUjVoQzs7O1NBT0QsV0FuQkRvNUQsY0FZRXA1RCxJQUFJMjJELGdCQUFzQjEyRDtTQU8zQixXQUFBO1NBbkJTMmhDLE9BQUFybUI7OztRQWdCWixXQUFBLDZCQWhCWXFtQixNQUFRRjtRQWdCcEI7OztTQUFxQixXQWhCbkIwM0IsVUFZRXA1RCxJQUEwQkM7U0FJVCxTQWhCVDJoQyxPQUFBcm1CLElBQVFtbUIsT0FZa0JsbUI7OztRQUl0Qzs7O2dCQWhCb0JrbUIsbUJBR1Y7VUFDUHVDLEtBSlNyQztNQUlDLE9BN1diM3BCLElBeVdvQnlwQixNQUlqQnVDLElBTGVoL0I7O0lBcUJ1RDtJQUUvRSxPQXRCUW0wRCxVQURJMzNCLElBQVFGO0dBdUJBO1lBR2Q4M0IsYUFBYTUzQixJQUFHRixJQUFJdDhCO0lBQzFCLElBRG1CMjhCLE9BQUFILElBQUdDLE9BQUFIO0lBQ3RCO2VBRG1CSyw0QkFBR0Y7OztpQkFBSEUsMkJBQUFBO2tCQUFHRiwyQkFBQUE7YUFBSG5tQixLQUFBcW1CLFNBSVBxQyxLQUpPckMsU0FJWDVoQyxLQUpXNGhDO1NBS2QsR0FBQSw2QkFMY0EsTUFBR0YsT0FNZjtTQUVHLElBQUEsT0F4YVJxVCxNQWdhb0JyVCxNQUlWdUMsSUFKY2gvQixjQVNwQmhGO3FCQUVnQjtTQURoQixJQVZnQnViLGNBVWhCLE9BVkE2OUMsYUFJRXI1RCxJQUtGQyxJQVRvQmdGO1NBVXBCLFdBQUE7U0FWYTI4QixPQUFBcm1CO1NBQUdtbUIsT0FBQWxtQjs7O1lBR1YwN0MsWUFIT3QxQixNQUdabnJCLE1BSGVpckI7OztXQUdWdzFCLFlBSFV4MUIsTUFHZmpyQixNQUhZbXJCOztNQUdnQyxXQXJZN0MzcEIsSUFxWU1pL0MsV0FBTHpnRCxLQUhtQnhSOztLQUVEOztHQVNHO1lBRzFCNlIsT0FBS2xaLEdBQUdDO2FBQ0ZFO0tBQU87S0FBQTtzQ0FDRjsrQkFDSm9PLGdCQUFLLE9BQUEsV0FISnRPLEdBR0RzTztVQUNPOUcsZ0JBQUhpNUIsa0JBQUgxOUI7TUFIRjdDLEtBR0U2QztNQUVOLFdBTk0vQyxHQUlHeWdDO2dCQUFHajVCOztJQUdOO0lBRVYsT0FSUXRILEtBRERIO0dBU0Q7WUFLQUQsS0FBS3JDLEdBQVFpbUIsTUFBTTFqQjtJQUN6QixJQURXdUUsTUFBQTlHLEdBQVFnK0QsU0FBQS8zQztJQUNuQjtlQURXbmYsa0JBRUEsT0FGUWszRDtjQUFSbDNELFlBR0orSixJQUhJL0osUUFHQyxPQUFBLFdBSGF2RSxHQUFOeTdELFFBR1pudEQ7S0FDbUM7TUFKL0I5RyxJQUFBakQ7TUFJQWs4QixNQUpBbDhCO01BSUh4QixJQUpHd0I7TUFBUW0zRCxTQUl1QixXQUpqQjE3RCxHQUFuQkYsS0FJRWlELEdBSlcwNEQsUUFBTXo3RCxJQUlkeWdDO0tBSkFsOEIsTUFBQWlEO0tBQVFpMEQsU0FBQUM7O0dBSW1EO1lBT3BFdmpELE1BQU1wWSxHQUFHQyxHQUFJLE9BQUEsOEJBWFRGLE1BV0VDLEdBQUdDLEdBQThCO1lBQ3ZDb1ksSUFBSW1CLEdBQUV4WixHQUFHQyxHQUFJLE9BQUEsOEJBWlRGLE1BWUF5WixHQUFFeFosR0FBR0MsR0FBOEI7WUFFbkNDLFdBQVd4QyxHQUFRaW1CLE1BQU0xakI7SUFDL0IsSUFEaUJ1RSxNQUFBOUcsR0FBUWcrRCxTQUFBLzNDO0lBQ3pCO2VBRGlCbmYsa0JBRU4sT0FGY2szRDtjQUFSbDNELFlBR1YrSixJQUhVL0osUUFHTCxPQUFBLFdBSG1CdkUsR0FHeEJzTyxHQUhrQm10RDtLQUl1QjtNQUFsQ2owRCxJQUpHakQ7TUFJTms4QixNQUpNbDhCO01BQUF4QixJQUFBd0I7TUFBUW0zRCxTQUl1QixXQUpqQjE3RCxHQUlwQnlnQyxLQUpMeGdDLFdBSVF1SCxHQUpXaTBELFFBQU16N0Q7S0FBZHVFLE1BQUF4QjtLQUFRMDRELFNBQUFDOztHQUl5RDtZQUc1RXA1RCxRQUFRdkMsR0FBS21LO0lBQ25CLElBRGNqRSxNQUFBbEc7SUFDZDtlQURja0csa0JBRUg7Y0FGR0EsWUFHUHFJLElBSE9ySSxRQUdGLE9BQUEsV0FIT2lFLEdBR1pvRTtLQUNtQixJQUpaOUcsSUFBQXZCLFFBSUh3NkIsTUFKR3g2QixRQUlObEQsSUFKTWtELFFBSVksT0FBQSxXQUpQaUUsR0FJUnUyQjtLQUFlO01BQU8sV0FKM0JuK0IsUUFJRVMsR0FKV21IO01BSWMsU0FKbkJqRSxNQUFBdUI7Ozs7O0tBSW1COztHQUFnQztZQUczRHZGLE9BQU9sQyxHQUFLbUs7SUFDbEIsSUFEYWpFLE1BQUFsRztJQUNiO2VBRGFrRyxrQkFFRjtjQUZFQSxZQUdOcUksSUFITXJJLFFBR0QsT0FBQSxXQUhNaUUsR0FHWG9FO0tBQ21CLElBSmI5RyxJQUFBdkIsUUFJRnc2QixNQUpFeDZCLFFBSUxsRCxJQUpLa0QsUUFJYSxPQUFBLFdBSlJpRSxHQUlQdTJCO0tBQWU7OztNQUFPLFdBSjNCeCtCLE9BSUVjLEdBSlVtSDtNQUllLFdBSnBCakUsTUFBQXVCOzs7S0FJYTs7R0FBcUM7WUFHN0RtYyxPQUFPbG1CLEdBQUt5TSxHQUFHOUM7YUFDVHUwRDtTQUFLRjs7c0NBQ0EsT0FEQUE7O1dBRUpudEQ7T0FBUSxPQUFBLFdBSEhwRSxHQUdMb0UsS0FubUJQNGhCLElBaW1CV3VyQyxRQUVKbnRELEdBSFFsSCxlQUNKcTBEOztNQUlNO09BREhqMEQ7T0FBSGk1QjtPQUFIMTlCO09BQ1MsT0FBQSxXQUxMbUgsR0FJRHUyQixPQXBtQlh2USxJQWltQld1ckMsUUFHQWg3QixLQUpJcjVCLGVBQ0pxMEQ7T0FJSixTQUpERSxXQUdFNTREO01BSEcwNEQ7Z0JBR0dqMEQ7OztJQUdoQixPQU5RbTBELFFBRENsK0Q7R0FPRztZQUdWZ3dCLFdBQVdod0IsR0FBS3lNLEdBQUc5QzthQUNidTBEO1NBQUtGOztzQ0FDQSxPQURBQTs7T0FHRixJQURGbnRELGdCQUNFLFFBQUEsV0FKT3BFLEdBR1RvRTttQkFFTSxPQUpGbXREO1dBS0RoN0I7T0FBSyxPQWhuQmZ2USxJQTJtQld1ckMsUUFLRGg3QixLQU5TcjVCOztNQVVMO09BSEFJO09BQUhnekQ7T0FBSHozRDtPQUdNLFVBQUEsV0FWRW1ILEdBT0xzd0Q7O1dBS0lFLHlCQXRuQmZ4cUMsSUEybUJXdXJDLFFBV0lmLEtBWkl0ekQ7O2tCQUNScTBEO01BUVAsYUFSRUUsV0FNRTU0RDtNQU5HMDREO2dCQU1HajBEOzs7SUFTaEIsT0FmUW0wRCxRQURLbCtEO0dBZ0JEO1lBR1Z5d0IsYUFBYXp3QixHQUFLeU0sR0FBRzlDO2FBQ2Z3MEQ7U0FBS0g7O1VBQUt6N0QsSUFBTHk3RCxXQUFFMTdELElBQUYwN0Q7c0NBQ0EsT0FEQUE7O1dBRUpudEQ7T0FBUSxPQUFBLFdBSEdwRSxHQUdYb0U7cUJBaG9CUDRoQixJQThuQmFud0IsR0FFTnVPLEdBSGNsSCxjQUNMcEg7cUJBQUhELEdBOW5CYm13QixJQThuQmdCbHdCLEdBRVRzTyxHQUhjbEg7O01BS0o7T0FESEk7T0FBSGk1QjtPQUFIMTlCO09BQ1M7U0FBQSxXQUxDbUgsR0FJUHUyQjtnQkFqb0JYdlEsSUE4bkJhbndCLEdBR0YwZ0MsS0FKVXI1QixjQUNMcEg7Z0JBQUhELEdBOW5CYm13QixJQThuQmdCbHdCLEdBR0x5Z0MsS0FKVXI1QjtPQUtkLFNBSkR3MEQsV0FHRTc0RDtNQUhHMDREO2dCQUdHajBEOzs7SUFHaEIsT0FOUW8wRCxVQURPbitEO0dBT007WUFHZm8rRDtRQUFhSjs7cUNBQ1IsT0FEUUE7OEJBRVpudEQsZ0JBQUssV0FBTEEsR0FGWW10RDtLQUdvQjtNQUF6QmowRDtNQUFIaTVCO01BQUgxOUI7TUFBK0IsYUFBNUIwOUIsS0FITG83QixhQUFhSixRQUdMajBEO0tBSEtpMEQ7ZUFHWDE0RDs7O1lBR04rNEQsU0FBU3IrRCxHQUFJLE9BTlRvK0QsZ0JBTUtwK0QsR0FBcUI7WUFFOUJzK0QsT0FBT2g4RDtJQUNULFVBRFNBLGdCQUVFO2FBRkZBLFVBR0Z1TyxJQUhFdk8sTUFHRyxXQUFMdU87UUFDSW15QixNQUpGMWdDO0lBSWlCLFdBQWYwZ0M7R0FBcUI7R0FJaEI7SUFBWjdjOzs7Ozs7Ozs7WUFERm80QyxXQUVhajhEO0lBQ1AsWUFWTmc4RCxPQVNhaDhEO2dCQUVILE1BQUEsNEJBSFI2akI7UUFJS3RWO0lBQUssT0FBTEE7R0FBTTtZQU1iM08sUUFBUWl0QixLQUFLeGxCO0lBQ2YsT0FBNkI7O2FBRG5Cd2xCO2FBdUdnQjhyQztzQkF0R1EzNEQsR0FBRTFRLEdBQUssT0FscUJ2QzZnQyxJQWtxQmdDbndCLEdBQUUxUSxHQURyQitYLGFBQzhDO0dBQUM7WUFHNUQyL0IsWUFBWUMsVUFBVTUvQjtJQUN4QixPQUFzQzs7YUFEeEI0L0I7YUFtR1kweEI7c0JBbEdpQjM0RCxHQUFFMVEsR0FBSyxPQXRxQmhENmdDLElBc3FCeUNud0IsR0FBRTFRLEdBRHJCK1gsYUFDOEM7R0FBQztZQUtyRTZsQyxTQUFTOXBDLEdBQUdpRTtJQUNkLE9BQTRCOzthQURqQmpFO2FBNkZldTFEO3NCQTVGTzM0RCxHQUFFMVEsR0FBSyxPQTVxQnRDNmdDLElBNHFCK0Jud0IsR0FBRTFRLEdBRHJCK1gsYUFDOEM7R0FBQztZQUkzRDRSO0lBQVcsOEJBQ0Y7MkJBQ0oxSyxjQUFLLFdBQUxBO0lBRUs7S0FEUTdRO0tBQU4rSjtLQUFIaTVCO0tBQUgxOUI7S0FDRkUsTUFBTSwyQkFEUXhGLEdBQVRnakM7S0FFTHc3QjthQUNJOXREO0tBQU87S0FBQTtzQ0FHRjs7V0FDSkcsdUJBTEwydEQ7T0FNQSxpQkFQQWg1RCx1QkFNS3FMO09BSlQsT0FBQSw2QkFESTJ0RDs7VUFRWXowRCxnQkFBSGk1QixrQkFBSDE5QjtNQVBGb0wsS0FPRXBMO2lCQVJOazVEO01BVUEsaUJBWEFoNUQsdUJBU1N3OUI7TUFHVCw2QkFYQXc3QjtnQkFRWXowRDs7SUFJTjtJQVhGMkcsS0FIRnBMO0lBa0JOLDZCQWhCSWs1RDtJQUNJOXRELEtBSEkzRztJQW1CWixPQWxCSXZFO0dBbUJEO1lBR0g3QyxJQUFJTCxHQUFHQyxHQUFHb0g7SUFBYyxPQTdJcEJ0SDthQTZJQUM7YUE4RG9CMjREO3NCQTlEMkIzNEQsR0FBRTFRLEdBQUssT0Exc0IxRDZnQyxJQTBzQm1EbndCLEdBQWEsV0FBekRDLEdBQThDM1EsSUFBM0MrWCxhQUF3RTtHQUFDO1lBRW5GODBELFNBQ1doMUIsS0FER2kxQixPQUFPLzBEO0lBQ3ZCLElBQWFnMUQsUUFBQWwxQixLQUFJbTFCO0lBQ2Y7S0FBRyxHQTUzQkh2b0QsU0EyM0JXc29ELFFBRU4sT0FGVUM7S0FJTCxJQUFKaHRFLElBM0ROMnNFLFdBdURXSTtTQUlMaG1ELE1BQUEvbUI7S0FFRjtNQUFBO1FBdEZKNitCO1VBZ0ZXa3VDO21CQU1rQnhqRDtXQUFPLFdBQUEsNkJBRjlCeEMsS0FFdUJ3QztXQUFPLHFCQURsQyxXQU5ZdWpELE9BS1IvbEQsS0FFdUJ3QztVQUFzQztVQVA5Q3hSO01BQ1ZrMUQ7TUFLTEM7TUFMU0Msc0JBS1RELFNBTFNGO0tBQUpELFFBQUFFO0tBQUlELGdCQUFBRzs7R0FVTjtZQUdMempELEtBQUtoWixHQUFHQztJQUNkLElBRFdpRyxNQUFBbEc7SUFDWDtlQURXa0csa0JBRUE7Y0FGQUEsWUFHSnFJLElBSElySSxRQUdJLE9BQUEsV0FIRGpHLEdBR1BzTyxTQUFBQTtTQUhJOUcsSUFBQXZCLFFBSUF3NkIsTUFKQXg2QixRQUlIbEQsSUFKR2tEO0tBS04sR0FBQSxXQUxTakcsR0FJSHlnQyxNQUVKLFdBRklBO0tBSUQsSUFFSitJLE1BVkF6d0IsS0FJRWhXLEdBSk0vQztRQVVSd3BDLEtBQWUsT0FBZkE7S0FWS3ZqQyxNQUFBdUI7O0dBVVk7WUFHakJzUixTQUFTL1ksR0FBR0M7SUFDbEIsSUFEZWlHLE1BQUFsRztJQUNmO2VBRGVrRyxrQkFFSjtjQUZJQSxZQUdScUksSUFIUXJJLFFBR0gsT0FBQSxXQUhNakcsR0FHWHNPO0tBRUUsSUFMTTlHLElBQUF2QixRQUlKdzZCLE1BSkl4NkIsUUFJUGxELElBSk9rRCxRQU1WdWpDLE1BREksV0FMU3hwQyxHQUlQeWdDO1FBRU4rSSxLQUFlLE9BQWZBO0tBRU8sSUFFSkMsTUFWRjN3QixTQUlFL1YsR0FKVS9DO1FBVVZ5cEMsS0FBZSxPQUFmQTtLQVZPeGpDLE1BQUF1Qjs7R0FVVztZQUd4QnVjLFNBQVNoa0IsR0FBR0M7SUFDUixZQTNCQStZLEtBMEJLaFosR0FBR0M7O0tBRUosT0FBQTtRQUNINEU7SUFBSyxPQUFMQTtHQUFNO1lBR1ArYyxJQUFJNWhCLEdBQUUvRztJQUNaLElBRFVpTixNQUFBbEcsR0FBRThFLE1BQUE3TDtJQUNaO2VBRFVpTixrQkFFQztjQUZEQSxZQUdIcUksSUFIR3JJLFFBR0UsYUFIQXBCLFVBR0x5SjtTQUNhN1EsSUFKVndJLFFBQUF1QixJQUFBdkIsUUFJQ3c2QixNQUpEeDZCLFFBQUFsRCxJQUFBa0Q7UUFJVXhJLEtBSlJvSCxLQU1MO0tBRVUsSUFBVCt6RCxTQWo5Qk4vMkQsT0F5OEJRa0IsSUFTRndNLHFCQVRJMUssS0FRSit6RDtLQUVKLFFBRElycEQ7ZUFBQUEsR0FDcUMsV0FObENreEI7TUFNcUQ7T0FBQSxPQUFBLDRCQVZwRDU3QixLQVFKK3pEO09BUklqckMsTUFVbUQ7TUFWckQxbkIsTUFBQXVCO01BQUUzQyxNQUFBOG9COzs7TUFBRjFuQixNQUFBbEQ7O0dBVXNFO1lBRzlFMDVELGtCQUNXNTBELElBRFdUO0lBQ3hCO0tBQWFrZixPQUFBemU7S0FBRzYwRDtLQUFVQyxlQUFBakU7SUFDeEI7VUFEV3B5QyxNQUVILE9BQUEsMEJBRk1vMkM7U0FBSGg3QyxLQUFBNEUsU0FHVDdFLEtBSFM2RTtLQUlOLEdBN21CRGxNLElBeW1Cb0J1aUQsY0FHdEJsN0MsSUFKb0JyYTtNQUNYa2YsT0FBQTVFOztNQU1zQjtPQU5UazdDLGlCQXh3QnhCMXNDLElBd3dCd0J5c0MsY0FHdEJsN0MsSUFKb0JyYTtPQUNSeTFELGtCQUdacDdDLElBSFlpN0M7TUFBSHAyQyxPQUFBNUU7TUFBR2c3QyxZQUFBRztNQUFVRixlQUFBQzs7O0dBUVY7WUFHZEUsaUJBQWlCNS9CLFdBQVVueUIsTUFBTTNEO0lBQ25DLFNBRDZCMkQ7S0FjbkIsT0FBQSw0REFkbUJBO0lBR2I7S0FESjZoQixNQUZpQjdoQjtLQUd2Qmd5RCxVQUFVLDBCQURKbndDLEtBRk9zUTtLQUliZ0ssTUF0SEp2bkMsUUFxSElvOUQsU0FINkIzMUQ7S0FLakIsT0FBQSx5QkFITndsQjtPQXArQlYvcUIsT0FzK0JJcWxDLGVBRUMsT0FGREE7SUFJUSxJQUFOazFCLFlBbkJrQjFEO0lBb0J0Qjs7TUFQUTlyQztNQUNObXdDO2VBTWlDQyxTQUFRM3NDO09BQ3pDLE9BOW5CQWpXLElBNG5CRWdpRCxVQUN1Qy9yQyxJQVRaanBCO2lCQVd4QjtvRUFGNEI0MUQ7a0JBRC9CWixXQTN4Qk5sc0MsSUEyeEJNa3NDLFVBQ3VDL3JDLElBVFpqcEI7TUFZTztJQUN0QyxNQUFBO0dBQ3FEO1lBR3ZEeUMsVUFBVTBRLFdBQVV4YTtJQUN0QjtZQTFOTUU7Y0F5TmdCRjs7dUJBQ21Cc3dCLElBQUc5WCxLQUFPLFdBQUEsV0FEdkNnQyxXQUM2QjhWLEtBQUc5WCxLQUEwQjtHQUFFO1lBU3BFMGtELFlBQVdDLFFBQW9CQyxVQUFpQkMsYUFBYWgyRDtJQUN4QyxJQUFuQmkyRCxtQkFwakJKamdELEtBbWpCYTgvQyxXQUFvQkMsYUFBOEIvMUQ7SUFFNUQsR0E5OUJIME0sU0E2OUJJdXBELG1CQUVDO0lBRXlCO0tBQXhCQyx3QkFmTnp6RCxVQVVrRHV6RCxhQUM5Q0M7S0FPa0IsT0FBQSxxREFSV0Y7S0FRMUIsT0FBQSw2QkFSTUQ7S0FPVDtPQUFBOzs7dUNBRkVJO0lBRUYsT0FBQTtHQUVrRDtZQXVCeERDLFlBQThCN0Q7UUFBYnZwRDtJQUFvQixXQUFwQkEsWUFBYXVwRDs7WUFDOUJ0eUQsWUFBWXJILEdBQUksT0FBSkEsUUFBbUM7WUFHN0NvUSxXQUFXcFEsR0FBSSxPQUFKQSxLQUFnQjtZQUMzQnk5RCxhQUFXejlEO0lBQXlDLFdBSnREcUgsWUFJYXJIO0lBQXlDLE9BNWhDcEQrMUQsV0E0aENXLzFEO0dBQXdEO1lBQ25Fb1osU0FBT3BaLEdBQUksT0FuaUNYOEIsT0FtaUNPOUIsTUFBdUI7WUFDOUJzWixXQUFTdFosR0FBSSxPQW5nQ2IrVCxTQW1nQ1MvVCxNQUF5QjtZQUNsQzA5RCxXQUFTMTlELEdBQUksT0F6TWIrN0QsU0F5TVMvN0QsTUFBeUI7WUFDbENnYSxVQUFRaGEsR0FBSSxPQXB6QlI0WSxRQW96Qkk1WSxNQUF3QjtZQUNoQzI5RCxjQUFZMzlELEdBQUksT0FyeEJoQm80RCxZQXF4QllwNEQsTUFBNEI7WUFDeENpYSxVQUFRamEsR0FBSSxPQTl2QlI4WSxRQTh2Qkk5WSxNQUF3QjtZQUNoQzQ5RCxjQUFZNTlELEdBQUksT0F6dkJoQnU0RCxZQXl2Qll2NEQsTUFBNEI7WUFDeEM2OUQsU0FBTzc5RCxHQUFJLE9BNU1YZzhELE9BNE1PaDhELE1BQXVCO1lBQzlCODlELGFBQVc5OUQsR0FBSSxPQXRNZmk4RCxXQXNNV2o4RCxNQUEyQjtZQUN0Q0YsUUFBUUUsR0FBSSxJQXBMSnRDLElBb0xBc0MsTUFwTEksT0E1QlorN0QsU0E0QlFyK0QsR0FvTHdCO1lBQ2hDcWMsV0FBUy9aLEdBQUksT0E5S2JpWixTQThLU2paLE1BQXlCO1lBQ2xDb2EsT0FBS3BhLEdBQUdOLE1BQU1PLEdBQUksT0FsU2RGLEtBa1NDQyxNQUFHTixNQUFNTyxHQUE4QjtZQUM1Q2thLGFBQVduYSxHQUFHTixNQUFNTztJQUFJLFdBQWJEO0lBQWEsc0IsT0F2eEJ4QjBZLGlCQXV4QmNoWixNQUFNTztHQUFvQztZQUN4RDg5RCxhQUFXLzlELEdBQUdOLE1BQU1PLEdBQUksT0F0UnBCQyxXQXNST0YsTUFBR04sTUFBTU8sR0FBb0M7WUFDeERzWSxZQUFZdlksR0FBR04sTUFBTU87SUFBSSxPQUFBLDhCQUh6Qm1hLFFBR2UxYSxNQUFNTyxHQUFURDtHQUFtRDtZQUMvRG1aLE9BQUtuWixHQUFHQyxHQUFJLE9BcFRaaVosT0FvVEtsWixNQUFHQyxHQUF3QjtZQUNoQys5RCxRQUFNNTZELEdBQUVDLEdBQUdwRDtJQUE4QyxXQXJCM0RvSCxZQXFCUWpFO0lBQVMsT0FoV2YyZixNQWdXTTNmLE1BQUVDLFlBQUdwRDtHQUE2RDtZQUN4RXlaLFNBQU8xWixHQUFHQyxHQUFJLE9BNVFWaUMsT0E0UUdsQyxNQUFHQyxHQUEwQjtZQUNwQzBaLFVBQVEzWixHQUFHQyxHQUFJLE9BcFJYc0MsUUFvUkl2QyxNQUFHQyxHQUEyQjtZQUN0Q3daLFFBQU16WixHQUFHQyxHQUFJLE9BL1JibVksTUErUk1wWSxNQUFHQyxHQUF5QjtZQUNsQ3NaLE1BQUlDLEdBQUV4WixHQUFHQyxHQUFJLE9BL1Jib1ksSUErUkltQixHQUFFeFosTUFBR0MsR0FBeUI7WUFDbEM0WixPQUFLN1osR0FBR0MsR0FBSSxPQS9JUitZLEtBK0lDaFosTUFBR0MsR0FBd0I7WUFDaEM4dkIsV0FBUy92QixHQUFHQyxHQUFJLE9BdEhoQitqQixTQXNIU2hrQixNQUFHQyxHQUE0QjtZQUN4QzJaLFdBQVM1WixHQUFHQyxHQUFJLE9BcElaOFksU0FvSUsvWSxNQUFHQyxHQUE0QjtZQUN4Q2d3QixNQUFJandCLEdBQUVvRCxHQUFvQyxXQTdCNUNpRSxZQTZCTXJILElBQXNDLE9BN3NCdENxYSxJQTZzQkFyYSxNQUFFb0QsU0FBbUQ7WUFDekQ2NkQsU0FBT2orRCxHQUFHQztJQUFnRCxVQTlCNURvSCxZQThCU3JIO0lBQWMsT0EvQnZCdzlELEtBK0JTeDlELEdBN1FQNGpCLE9BNlFPNWpCLE1BQUdDO0dBQWdFO1lBQzFFaStELE1BQUlsK0QsR0FBRW9EO0lBQTRDLFVBL0JwRGlFLFlBK0JNckg7SUFBYSxPQWhDbkJ3OUQsS0FnQ014OUQsR0E5MkJKbXdCLElBODJCSW53QixNQUFFb0Q7R0FBNEQ7WUFDbEUrNkQsU0FBT24rRCxHQUFFb0Q7SUFBK0MsVUFoQzFEaUUsWUFnQ1NySDtJQUFhLE9BakN0Qnc5RCxLQWlDU3g5RCxHQW5zQlBrd0IsT0Ftc0JPbHdCLE1BQUVvRDtHQUErRDtZQUN4RWc3RCxRQUFNaDlELElBQUdDO0lBQXVELFVBakNsRWdHLFlBaUNRakc7SUFBZ0IsT0FsQ3hCbzhELEtBa0NRcDhELElBcnFCTjAzRCxNQXFxQk0xM0QsT0FBR0M7R0FBd0U7WUFDakZnOUQsUUFBTWo5RCxJQUFHQztJQUF1RCxVQWxDbEVnRyxZQWtDUWpHO0lBQWdCLE9BbkN4Qm84RCxLQW1DUXA4RCxJQXZvQk5pNEQsTUF1b0JNajRELE9BQUdDO0dBQXdFO1lBQ2pGaTlELE9BQUtsOUQsSUFBR0M7SUFBc0QsVUFuQ2hFZ0csWUFtQ09qRztJQUFnQixPQXBDdkJvOEQsS0FvQ09wOEQsSUF2bkJMaWMsS0F1bkJLamMsT0FBR0M7R0FBdUU7WUFFL0VrOUQsaUJBQWVuOUQsSUFBR0M7SUFDOEIsVUF0Q2xEZ0csWUFxQ2lCakc7SUFDaUMsT0ExVGhEdzRELGVBeVRleDRELE9BQUdDO0dBQzhDO1lBR2hFbTlELGVBQWVwOUQsSUFBR0M7SUFBSyxVQUFMQSxhQUFIRDtJQUFzQixPQXhYckMvSyxRQStVRmdSLFlBeUNpQmpHO0dBQXNEO1lBQ3JFOUosUUFBTThKLElBQUdDO0lBQThDLFVBMUN6RGdHLFlBMENRakc7SUFBaUQsT0FwWHZEOUssTUFvWE04SyxPQUFHQztHQUE4RDtZQUN2RW85RCxZQUFVeitELEdBQUcwK0Q7SUFBd0QsVUEzQ3ZFcjNELFlBMkNZckg7SUFBMkQsT0FuWHJFdzdELFVBbVhVeDdELE1BQUcwK0Q7R0FBdUU7WUFFcEZDLGVBQWF2OUQsSUFBR0M7SUFDOEIsVUE5Q2hEZ0csWUE2Q2VqRztJQUNpQyxPQTVWMUNxNkQsYUEyVlNyNkQsT0FBR0M7R0FDOEM7WUFTNUR1OUQ7UUFBcUI5c0QsaUJBQUxxMUI7SUFBYyxXQUFkQSxRQUFLcjFCOztZQUVyQitzRCxZQUFXMUIsUUFBeUJDO0lBQ3RDO0tBR2UsTUE3RGpCLzFELFlBeURlODFEO1dBQUFBO0tBR04sTUFMTHlCLGNBRW9DeEI7SUFJdkIsT0E5RmJGLFlBd0ZBMEIsY0FFV3pCO0dBS2lDO1lBRzVDamxFLFFBQU1rSixJQUFHQztJQUNYO2VBVEV3OUQsWUFRU3g5RCxJQUFIRDtLQUNxQixVQVQzQnk5RCxZQVFNejlELElBQUdDO0lBQ2tCLE9BQUE7R0FBOEM7WUFJM0V5OUQsZUFBYTkrRCxHQUFHQztJQUNsQjtLQUErRCxNQXZFL0RvSCxZQXNFZXJIO0tBQ00sUUF6Um5CbXVCLGFBd1JhbnVCLE1BQUdDO0tBQ044K0Q7S0FBUkM7S0FDVyxNQXpFZnhCLEtBdUVleDlELEdBQ0grK0Q7SUFDWixXQXpFQXZCLEtBdUVleDlELEdBQ1hnL0Q7R0FDd0I7WUFHMUI3Z0IsUUFBTW4rQyxHQUFFb0Q7SUFDVjtLQUF3RCxNQTVFeERpRSxZQTJFUXJIO0tBQ2MsUUExeEJwQm0zQyxNQXl4Qk1uM0MsTUFBRW9EO0tBQ0k2MkQ7S0FBSDUyRDtLQUFQMDJEO0tBQ2EsTUE5RWpCeUQsS0E0RVF4OUQsR0FDTWk2RDtJQUNkLFdBOUVBdUQsS0E0RVF4OUQsR0FDSis1RCxRQUFPMTJEO0dBQ2tCO1lBRzNCNDdELFdBQVNqL0QsR0FBR284RDtJQUNkLElBQW9ELE1BakZwRC8wRCxZQWdGV3JILElBQ0YsTUFwTlBtOEQsU0FtTlNuOEQsTUFBR284RDtJQUMwRCxPQUFBLDZDLE9BbEZ4RW9CLEtBaUZXeDlEO0dBQ3FFO1lBRzlFay9ELE1BQUlsL0QsR0FBRS9HLEdBQUksT0F6S04yb0IsSUF5S0E1aEIsTUFBRS9HLEdBQXNCO1lBQzVCa21FLGVBQWFuL0QsR0FBRS9HO0lBQXFELFVBckZ0RW9PLFlBcUZlckg7SUFBYSxPQXRGNUJ3OUQsS0FzRmV4OUQsR0EzdUJiNDRELGFBMnVCYTU0RCxNQUFFL0c7R0FBcUU7WUFDcEYyUyxZQUFVNE8sa0JBQVl4YSxHQUFJLE9BakkxQjhKLFVBaUlVMFEsV0FBWXhhO0dBQW9DO1lBRTFEby9ELGNBQWFwK0MsT0FBT281QyxxQkFBcUJDLGtCQUFpQnI2RDtJQUM1RCxPQTFnQkV3ckM7YUF5Z0IwRHhyQyxNQUE3Q2doQixPQUFPbzVDLHFCQUFxQkMsa0JBQWlCcjZEO0dBQ3VCO1lBR2pGcS9ELGdCQUFjci9ELEdBQUczSixTQUFRaWxDLEtBQUkvc0I7SUFBSSxPQTFkakM4c0IsY0EwZGNyN0IsTUFBRzNKLFNBQVFpbEMsS0FBSS9zQjtHQUE2QztZQUUxRSt3RCwwQkFBd0J0L0QsR0FBR3c3QixZQUFXRjtJQUN4QyxPQTNjRUMsd0JBMGN3QnY3QixNQUFHdzdCLFlBQVdGO0dBQ1k7WUFHbERpa0M7SUFBbUJ2K0MsT0FBT281QyxxQkFBcUJDLGtCQUFpQm4wRCxLQUFFbEc7SUFDcEUsT0FuY0UrNkQ7YUFrY2dFNzBEO2FBQTdDOGE7YUFBT281QzthQUFxQkM7YUFBaUJuMEQ7YUFBRWxHO0dBTzNEO1lBR1B3L0QsaUJBQWlCdjdELGdCQUFjZ0MsT0FBTWpHO0lBQ3ZDLElBeFhzRGtHLE1BdVhmbEcsTUF0WEwsTUFweEJoQzhCLE9BbXhCb0RvRTtJQUN0RCxPQVJNbkcsS0FPZ0RtRyxLQUN6Qyw2QkFzWG9CRCxhQUFkaEM7R0FDNEM7WUFNL0Q1TSxzQkFBWStKLElBQUdDLElBQUssT0ExRWxCbTlELGVBMEVVcDlELElBQUdDLElBQXlCO1lBT3RDbytELG1CQUZHcnZELFlBRTBCK3NCLFdBQVVueUI7SUFDekMsT0F2TEUreEQsaUJBc0w2QjUvQixXQUFVbnlCLE1BRnBDb0Y7R0FHNkQ7WUFJaEU4d0IsYUFBc0IsT0F0TUV5M0IsK0JBc002QjtZQUNyRGh6QixpQkFyeUJVOWdDLEdBcXlCa0IsV0FyeUJsQkEsR0FxeUJtQztZQUM3Q3dVLFNBQU9yWixHQUFJLE9BL3BDWDhCLE9BK3BDTzlCLEdBQWtCO1lBQ3pCMC9ELGFBVkd0dkQsWUFVb0JwUSxHQUFJLE9BMXBDM0IrMUQsV0EwcEN1Qi8xRCxHQVZwQm9RLGVBVXVFO1lBQzFFdXZELFdBQVMzL0QsR0FBSSxPQWhvQ2IrVCxTQWdvQ1MvVCxHQUFvQjtZQUM3QjQvRCxXQUFTNS9ELEdBQUksT0F0VWIrN0QsU0FzVVMvN0QsR0FBb0I7WUFDN0I2L0QsVUFBUTcvRCxHQUFJLE9BajdCUjRZLFFBaTdCSTVZLEdBQW1CO1lBQzNCOC9ELGNBQVk5L0QsR0FBSSxPQWw1QmhCbzRELFlBazVCWXA0RCxHQUF1QjtZQUNuQysvRCxVQUFRLy9ELEdBQUksT0EzM0JSOFksUUEyM0JJOVksR0FBbUI7WUFDM0JnZ0UsY0FBWWhnRSxHQUFJLE9BdDNCaEJ1NEQsWUFzM0JZdjRELEdBQXVCO1lBQ25DaWdFLFNBQU9qZ0UsR0FBSSxPQXpVWGc4RCxPQXlVT2g4RCxHQUFrQjtZQUN6QmtnRSxhQUFXbGdFLEdBQUksT0FuVWZpOEQsV0FtVVdqOEQsR0FBc0I7WUFDakM4WixVQUFROVosR0FBSSxPQTdVWis3RCxTQTZVUS83RCxHQUFtQjtZQUMzQm1nRSxXQUFTbmdFLEdBQUksT0EzU2JpWixTQTJTU2paLEdBQW9CO1lBQzdCb2dFLE9BQUtwZ0UsR0FBR0MsR0FBSSxPQTdhWmlaLE9BNmFLbFosR0FBR0MsR0FBbUI7WUFDM0JvZ0UsU0FBT3JnRSxHQUFHQyxHQUFJLE9BcFlWaUMsT0FvWUdsQyxHQUFHQyxHQUFxQjtZQUMvQnFnRSxVQUFRdGdFLEdBQUdDLEdBQUksT0E1WVhzQyxRQTRZSXZDLEdBQUdDLEdBQXNCO1lBQ2pDc2dFLFFBQU12Z0UsR0FBR0MsR0FBSSxPQXZaYm1ZLE1BdVpNcFksR0FBR0MsR0FBb0I7WUFDN0J1Z0UsTUFBSWhuRCxHQUFFeFosR0FBR0MsR0FBSSxPQXZaYm9ZLElBdVpJbUIsR0FBRXhaLEdBQUdDLEdBQW9CO1lBQzdCd2dFLE9BQUt6Z0UsR0FBR0MsR0FBSSxPQXZRUitZLEtBdVFDaFosR0FBR0MsR0FBbUI7WUFDM0J5Z0UsV0FBUzFnRSxHQUFHQyxHQUFJLE9BOU9oQitqQixTQThPU2hrQixHQUFHQyxHQUF1QjtZQUNuQzBnRSxXQUFTM2dFLEdBQUdDLEdBQUksT0E1UFo4WSxTQTRQSy9ZLEdBQUdDLEdBQXVCO1lBQ25DMmdFLE9BQUs1Z0UsR0FBR04sTUFBTU8sR0FBSSxPQXZhZEYsS0F1YUNDLEdBQUdOLE1BQU1PLEdBQXlCO1lBQ3ZDNGdFLGFBQVc3Z0UsR0FBR04sTUFBTU87SUFBSSxxQixPQTU1QnhCeVksV0E0NUJXMVksR0FBR04sTUFBTU87R0FBK0I7WUFDbkQ2Z0UsYUFBVzlnRSxHQUFHTixNQUFNTyxHQUFJLE9BM1pwQkMsV0EyWk9GLEdBQUdOLE1BQU1PLEdBQStCO1lBQ25EeU8sTUFoQ0cwQixZQWdDYXBRLEdBQUdDLEdBQUksT0E3UnZCSSxJQTZSZ0JMLEdBQUdDLEdBaENoQm1RLGVBZ0MrRDtZQUNsRTJ3RCxTQWpDRzN3RCxZQWlDZ0JwUSxHQUFHQyxHQUFJLE9BeFkxQjJqQixPQXdZbUI1akIsR0FBR0MsR0FqQ25CbVEsZUFpQ3FFO1lBQ3hFNHdELGFBbENHNXdELFlBa0NvQnBRLEdBQUdDO0lBQUksT0EvWDlCeXRCLFdBK1h1QjF0QixHQUFHQyxHQWxDdkJtUTtHQWtDNkU7WUFDaEY2d0QsZUFuQ0c3d0QsWUFtQ3NCcFEsR0FBR0M7SUFBSSxPQTdXaENrdUIsYUE2V3lCbnVCLEdBQUdDLEdBbkN6Qm1RO0dBbUNpRjtZQUNwRjh3RCxRQXBDRzl3RCxZQW9DZWhOLEdBQUVDLEdBQUdwRDtJQUFJLE9BdmUzQjhpQixNQXVla0IzZixHQUFFQyxHQXBDakIrTSxlQW9Db0JuUTtHQUFtRDtZQUMxRWtoRSxNQXJDRy93RCxZQXFDYXBRLEdBQUVvRCxHQUFJLE9BNzBCbEJpWCxJQTYwQllyYSxHQUFFb0QsR0FyQ2ZnTixlQXFDNkQ7WUFDaEVneEQsTUF0Q0doeEQsWUFzQ2FwUSxHQUFFb0QsR0FBSSxPQTcrQnRCK3NCLElBNitCZ0Jud0IsR0FBRW9ELEdBdENmZ04sZUFzQzZEO1lBQ2hFaXhELFNBdkNHanhELFlBdUNnQnBRLEdBQUVvRCxHQUFJLE9BbDBCekI4c0IsT0FrMEJtQmx3QixHQUFFb0QsR0F2Q2xCZ04sZUF1Q21FO1lBQ3RFa3hELFFBeENHbHhELFlBd0NlaFAsSUFBR0MsSUFBSyxPQXB5QjFCeTNELE1Bb3lCa0IxM0QsSUFBR0MsSUF4Q2xCK08sZUF3Q3FFO1lBQ3hFbXhELFFBekNHbnhELFlBeUNlaFAsSUFBR0MsSUFBSyxPQXR3QjFCZzRELE1Bc3dCa0JqNEQsSUFBR0MsSUF6Q2xCK08sZUF5Q3FFO1lBQ3hFb3hELE9BMUNHcHhELFlBMENjaFAsSUFBR0MsSUFBSyxPQXR2QnpCZ2MsS0FzdkJpQmpjLElBQUdDLElBMUNqQitPLGVBMENtRTtZQUV0RXF4RCxpQkE1Q0dyeEQsWUE0Q3dCaFAsSUFBR0M7SUFDaEMsT0F6YkV1NEQsZUF3YjJCeDRELElBQUdDLElBNUMzQitPO0dBNkNrRDtZQUdyRHN4RCxpQkFoREd0eEQsWUFnRHdCaFAsSUFBR0MsSUFBSyxPQXZmbkNoTCxRQXVjRytaLGVBZ0R3QmhQLElBQUdDO0dBQXdDO1lBQ3RFdkksUUFqREdzWCxZQWlEZWhQLElBQUdDLElBQUssT0FuZjFCL0ssTUFtZmtCOEssSUFBR0MsSUFqRGxCK08sZUFpRHFFO1lBQ3hFdXhELFlBbERHdnhELFlBa0RtQnBRLEdBQUcwK0Q7SUFBTSxPQWxmL0JsRCxVQWtmc0J4N0QsR0FBRzArRCxJQWxEdEJ0dUQ7R0FrRCtFO1lBRWxGd3hELGVBcERHeHhELFlBb0RzQmhQLElBQUdDO0lBQzlCLE9BM2RNbzZELGFBMGRxQnI2RCxJQUFHQyxJQXBEekIrTztHQXFEZ0Q7WUFHbkR5eEQsVUF4REd6eEQsWUF3RGlCcE4sR0FBSSxPQTlWeEJwRCxRQThWb0JvRCxHQXhEakJvTixlQXdEaUU7WUFDcEUweEQsY0F6REcxeEQsWUF5RHFCMVM7SUFBSSxPQTNWNUJzcEMsWUEyVndCdHBDLEdBekRyQjBTO0dBeUR5RTtZQUM1RTJ4RCxXQTFERzN4RCxZQTBEa0JoTixHQUFJLE9BdFZ6QjhwQyxTQXNWcUI5cEMsR0ExRGxCZ04sZUEwRG1FO1lBRXRFNHhELDRCQTVERzV4RCxZQTREbUNoTjtJQUN4QyxPQTNtQ0V3ekQsMEJBMG1Dc0N4ekQsR0E1RG5DZ047R0E2RHlEO1lBRzVENnhELHdDQUFnRDlpRSxLQUFLYyxHQUN2RCxPQTFvQ0VtMkQsK0JBeW9DZ0RqM0QsS0FBS2M7R0FDVDtZQUc1Q2lpRSxrQkFwRUc5eEQsWUFvRXlCaE47SUFBSSxPQXRtQ2hDMHpELGdCQXNtQzRCMXpELEdBcEV6QmdOO0dBb0VpRjtZQUNwRit4RCxhQUFZL3hELFlBQVdwTjtJQUFJLE9BdnlCM0JtMkQsV0F1eUJZL29ELDBCLGNBQVdwTjtHQUFpRDtZQUV4RW8vRCxvQkF2RUdoeUQsWUF1RTJCdEk7SUFDaEMsT0F4UUU0MEQsa0JBdVE4QjUwRCxJQXZFM0JzSTtHQXdFa0Q7WUFHckRpeUQsV0EzRUdqeUQsWUEyRWtCcFEsR0FBR284RDtJQUFRLE9BdFVoQ0QsU0FzVXFCbjhELEdBQUdvOEQsT0EzRXJCaHNEO0dBMkVpRjtZQUNwRmt5RCxRQTVFR2x5RCxZQTRFZXBRLEdBQUVvRCxHQUFJLE9BbDVCeEIrekMsTUFrNUJrQm4zQyxHQUFFb0QsR0E1RWpCZ04sZUE0RWlFO1lBQ3BFbXlELE1BQUl2aUUsR0FBRS9HLEdBQUksT0ExUk4yb0IsSUEwUkE1aEIsR0FBRS9HLEdBQWlCO1lBQ3ZCdXBFLGVBOUVHcHlELFlBOEVzQnBRLEdBQUUvRztJQUFJLE9BNTFCL0IyL0QsYUE0MUJ5QjU0RCxHQUFFL0csR0E5RXhCbVg7R0E4RStFO1lBQ2xGMmUsWUFBVXZVLGtCQUFZeGEsR0FBSSxPQWxQMUI4SixVQWtQVTBRLFdBQVl4YSxHQUErQjtZQUNyRG81RCxRQUFRcDVELEdBQUksT0FBSkEsRUFBSztZQUNieWlFLGVBQXNCemlFLEdBQUksT0FBSkEsRUFBSztZQUUzQjBpRTtJQUFhdHlELFlBQVk0USxPQUFPbzVDLHFCQUFxQkMsa0JBQWlCcjZEO0lBQ3hFLE9BN25CRXdyQzthQTRuQmFwN0IsWUFBWTRRLE9BQU9vNUMscUJBQXFCQyxrQkFBaUJyNkQ7R0FDSTtZQUcxRTJpRSx1QkFBNEIzaUUsR0FBRzNKLFNBQVFpbEMsS0FBSS9zQixHQUFJLE9BN2tCL0M4c0IsY0E2a0I0QnI3QixHQUFHM0osU0FBUWlsQyxLQUFJL3NCO0dBQXdDO1lBRW5GcTBELGlDQUFzQzVpRSxHQUFHdzdCLFlBQVdGLEtBQ3RELE9BOWpCRUMsd0JBNmpCc0N2N0IsR0FBR3c3QixZQUFXRjtHQUNQO1lBRzdDdW5DO0lBQW1CenlELFlBQVk0USxPQUFPbzVDLHFCQUFxQkMsa0JBQWlCbjBELEtBQUVsRztJQUNoRixPQXRqQkUrNkQ7YUFxakJtQjNxRCxZQUFZNFEsT0FBT281QyxxQkFBcUJDLGtCQUFpQm4wRCxLQUFFbEc7R0FDSztZQUduRmthLGNBQVlsYSxHQUFHTixNQUFNTztJQUFJLE9BQUEsOEJBcEV6QjJnRSxRQW9FZWxoRSxNQUFNTyxHQUFURDtHQUFtRDtZQUs3RDhpRSxZQXRHQzF5RCxZQXNHcUJoUCxJQUFRQztJQUNoQyxPQWhRRTY3RCxZQStQc0I5N0QsSUFBUUMsSUF0RzdCK08sZUFBQUE7R0EyRzJDO1lBRzVDelcsUUFBT3lXLFlBQVdoUCxJQUFHQztJQUN2QjtLQTVQNEJnRyxjQTJQbkIrSTtLQTNQTWl0RCxjQTJQTmp0RDtlQXZRUDhzRCxZQXVRcUI3N0QsSUFBSEQsSUEzUExpOEQsYUFBYWgyRDtLQUUxQixVQWRBNjFELFlBdVFrQjk3RCxJQUFHQyxJQTNQUmc4RCxhQUFhaDJEO0lBRTFCLE9BQUE7R0E4UDRDO0dBaEJuQyxJQUFBLFlBR1R5N0QsYUFRQW5wRTtZQWVGb3BFLFVBQVEvaUUsR0FBSSxPQUFKQSxLQUFVO1lBQ2xCZ2pFLFVBQVM1eUQsWUFBV3VwRCxNQUFPLFdBQWxCdnBELFlBQVd1cEQsTUFBMkI7WUFFL0NzSixtQkFGUzd5RCxZQUVvQitzQixXQUFVbnlCO0lBR3ZDLElBTG9CMnVELE9BbFRwQm9ELGlCQW9UNkI1L0IsV0FBVW55QixNQUY5Qm9GO0lBQWtCLFdBQWxCQSxZQUFXdXBEO0dBS21EO1lBR3ZFdUosUUFBTzl5RDtJQUFhLFdBQWJBLFlBclVpQnVvRDtHQXFVOEI7O0lBRzVDLElBQVJ6M0Isb0JBeFVzQnkzQjtJQXVVbUMsV0FDekR6M0I7O1lBR0ZpaUMsWUFBVy95RCxZQUFXdkwsR0FBSSxXQUFmdUwsZ0JBQVd2TCxJQUE0QztZQUVsRXUrRCxhQWhCU2h6RCxZQWdCY3BOO0lBQ0wsSUFqQkUyMkQsT0FoMkJwQlIsV0FnMkJTL29ELFlBRFQyeUQsV0FpQnVCLy9EO0lBaEJJLFdBQWxCb04sWUFBV3VwRDtHQWlCdUM7WUFHM0QwSiw0QkFBMkJqekQsWUFBV3hMO0lBRXRDLElBREUrMEQsT0Fqc0NGL0MsMEJBZ3NDc0NoeUQsT0FBWHdMO0lBSTdCLFdBSjZCQSxZQUN6QnVwRDtHQUdnQjtZQUdsQjJKLGlDQTNCU2x6RCxZQTJCcUNqUixLQUFLYztJQUNqQyxJQTVCRTA1RCxPQXZzQ3BCdkQsK0JBa3VDOENqM0QsS0FBS2M7SUEzQnhCLFdBQWxCbVEsWUFBV3VwRDtHQTRCOEM7WUFHbEU0SixrQkFBaUJuekQsWUFBV3hMO0lBRTVCLFVBanNDQWt5RCxnQkErckM0Qmx5RCxPQUFYd0w7SUFHYixPQUFBOzs7c0JBQUl1cEQsTUFBUSxXQUhDdnBELFlBR1R1cEQsTUFBNEI7R0FBQztZQUdyQzZKLFVBQVNwekQsWUFBV3BOO0lBQ3RCLFdBRFdvTixZQXpjVHhRLFFBeWNvQm9ELEdBQVhvTjtHQUNzRTtZQUcvRXF6RCxjQUFhcnpELFlBQVcxUztJQUMxQixXQURlMFMsWUF6Y2I0MkIsWUF5Y3dCdHBDLEdBQVgwUztHQUNzRTtZQUduRnN6RCxXQUFVdHpELFlBQVdoTjtJQUN2QixXQURZZ04sWUF2Y1Y4OEIsU0F1Y3FCOXBDLEdBQVhnTjtHQUNzRTtZQUdoRnV6RCxvQkFBbUJ2ekQsWUFBV3RJO0lBQ2hDLE9BaFhFNDBELGtCQStXOEI1MEQsSUFBWHNJO0dBQ2dEO1lBR25FMEcsTUFBSzFHLFlBQVdwUSxHQUFHQztJQUNyQixXQURPbVEsWUFoYkwvUCxJQWdiZ0JMLE1BQUdDLEdBQWRtUTtHQUM4RTtZQUduRnd6RCxhQUFZeHpELFlBQVdwUSxHQUFHQztJQUM1QixXQURjbVEsWUFwaEJac2QsV0FvaEJ1QjF0QixNQUFHQyxHQUFkbVE7R0FHYjtZQVNEeXpELGFBQTBCN2pFLEdBQzVCLElBSU1vUSxhQUxzQnBRLE1BQ3BCLFdBSUZvUSxZQUNGO1lBSUYwekQsUUFEOEJ0cUQ7SUFDcEIsSUF2RURwSixhQXNFcUJvSjtJQXRFUixXQUFicEosWUFyVWlCdW9EO0dBNFlvQztZQUM5RG9MLFlBRjhCdnFELEdBRWxCcFcsR0FBSSxPQWxFZCsvRCxZQWdFNEIzcEQsTUFFbEJwVyxHQUE4RDtZQUMxRTRnRSxhQUg4QnhxRCxHQUdqQnBXLEdBQUksT0FqRWZnZ0UsYUE4RDRCNXBELE1BR2pCcFcsR0FBK0Q7WUFFNUU2Z0UsNEJBTDhCenFELEdBS0ZwVztJQUM5QixPQWhFSWlnRSw0QkEwRDRCN3BELE1BS0ZwVztHQUM0QztZQUd4RThnRSxpQ0FUOEIxcUQsR0FTTXJhLEtBQUtjO0lBQzNDLE9BN0RJcWpFLGlDQW1ENEI5cEQsTUFTTXJhLEtBQUtjO0dBQzRDO1lBR3JGa2tFLGtCQWI4QjNxRCxHQWFacFcsR0FBSSxPQTVEcEJtZ0Usa0JBK0M0Qi9wRCxNQWFacFcsR0FBb0U7WUFDdEZnaEUsVUFkOEI1cUQsR0FjcEJwVyxHQUFJLE9BdkRab2dFLFVBeUM0QmhxRCxNQWNwQnBXLEdBQTREO1lBQ3RFaWhFLGNBZjhCN3FELEdBZWhCcFcsR0FBSSxPQXBEaEJxZ0UsY0FxQzRCanFELE1BZWhCcFcsR0FBZ0U7WUFDOUVraEUsV0FoQjhCOXFELEdBZ0JuQnBXLEdBQUksT0FqRGJzZ0UsV0FpQzRCbHFELE1BZ0JuQnBXLEdBQTZEO1lBRXhFbWhFLG9CQWxCOEIvcUQsR0FrQlZwVyxHQUN0QixPQWhESXVnRSxvQkE2QjRCbnFELE1Ba0JWcFcsR0FDNEM7WUFHaEVpdEIsTUF0QjhCN1csR0FzQnhCcFcsR0FBR25ELEdBQUksT0EvQ1g2VyxNQXlCNEIwQyxNQXNCeEJwVyxHQUFHbkQsR0FBMkQ7WUFDcEV1a0UsYUFBV2hyRCxHQUFFcFcsR0FBR25ELEdBQUksT0E1Q2xCMmpFLGFBNENTcHFELE1BQUVwVyxHQUFHbkQsR0FBa0U7bUJBTXRGLFdBRUc7WUFnQ0N3a0UsWUFBZ0NDO0ksZ0JBQW1DMWtFO0tBQ3JFLE9BOVNJNEwsWUE2UzhCODRELHdCQUNBLFdBQWEsR0FEc0Ixa0UsR0FDbkI7O1lBR2hEMmtFLFlBRVVEO0ksZ0JBQ1IxNUQsTUFFSixPQXBKSWk0RCxtQkFpSlF5QixRQUFBQSxRQUNSMTVELE1BRTJFOztZQUc3RTQ1RCxpQkFBcUNGO0lBR1YsVUFBQSw2QkFIVUE7SUFHVixPQUFBOztZQUczQkcsbUJBQW9DempFLElBQUdDLElBQUssT0E1VzFDbTlELGVBNFdrQ3A5RCxJQUFHQyxJQUF5QjtZQUNoRXlqRSxpQkFBZ0MxakUsSUFBR0MsSUFBSyxPQTVXdEMvSixRQTRXOEI4SixJQUFHQyxJQUFnQjtZQUVuRDBqRSxjQUFrQ0w7SSxnQkFBcUN6K0Q7S0FDekUsVUFEb0N5K0Q7S0FDcEMscUIsT0E3U0lsRixzQkE0U3FFdjVELGNBQ25DOztZQUdwQysrRCxTQUFVcC9ELFFBQU81RjtJQUNuQjtLQUFrQyxNQUFBO0tBQTlCaUcsUUFBUSxXQUxWOCtELGNBSVVuL0QsY0FBTzVGO0lBRW5CLE9BQUEseUJBRElpRztHQUNxQjs7SUFZckJnL0Q7O0lBektFQztZQTZLRkMsWUFBVS9oRSxHQUFJLE9BMUtkKy9ELFlBc0tBOEIsY0FJVTdoRSxHQUE0QztZQUN0RGdpRSxhQUFXaGlFLEdBQUksT0F6S2ZnZ0UsYUFvS0E2QixjQUtXN2hFLEdBQTZDO1lBRXhEaWlFLDRCQUEwQmppRTtJQUM1QixPQXhLRWlnRSw0QkFnS0E0QixjQU8wQjdoRTtHQUM0QjtZQUd0RGtpRSxpQ0FBa0NubUUsS0FBS2M7SUFDekMsT0FyS0VxakUsaUNBeUpBMkIsY0FXa0M5bEUsS0FBS2M7R0FDNEI7WUFHbkVzbEUsa0JBQWdCbmlFLEdBQUksT0FwS3BCbWdFLGtCQXFKQTBCLGNBZWdCN2hFLEdBQWtEO1lBQ2xFb2lFLFVBQVFwaUUsR0FBSSxPQS9KWm9nRSxVQStJQXlCLGNBZ0JRN2hFLEdBQTBDO1lBQ2xEcWlFLGNBQVlyaUUsR0FBSSxPQTVKaEJxZ0UsY0EySUF3QixjQWlCWTdoRSxHQUE4QztZQUMxRHNpRSxXQUFTdGlFLEdBQUksT0F6SmJzZ0UsV0F1SUF1QixjQWtCUzdoRSxHQUEyQztZQUNwRHVpRSxvQkFBa0J2aUU7SUFBSSxPQXRKdEJ1Z0Usb0JBbUlBc0IsY0FtQmtCN2hFO0dBQW9EO1lBQ3RFd2lFLE1BQUl4aUUsR0FBR25ELEdBQUksT0FuSlg2VyxNQStIQW11RCxjQW9CSTdoRSxHQUFHbkQsR0FBeUM7WUFDaEQ0bEUsYUFBV3ppRSxHQUFHbkQsR0FBSSxPQWhKbEIyakUsYUEySEFxQixjQXFCVzdoRSxHQUFHbkQsR0FBZ0Q7WUFDOUQ2bEUsVUFBUW5NLE1BQU8sV0F0QmZzTCxjQXNCUXRMLE1BQTJCO1lBQ25Db00sVUFBUS9sRSxHQUFJLE9BQUpBLEtBQVU7Ozs7O09BOVVwQjNJO09BL0dFb21FO09BdVRGb0c7T0F4VEV6ekQ7T0FrVUYwekQ7T0FDQUM7T0FqVUUzcUQ7T0FDQUU7T0F1QkEyVztPQUVBaXVDO09BQ0FDO09BQ0FDO09Bc1NGNEY7T0FyU0UzRjtPQUNBQztPQUVBQztPQUlBQztPQW1FQWdCO09BbEVBbG9FO09BcEJBb2lCO09BQ0FDO09BQ0FGO09BQ0FGO09BQ0FNO09BRUFEO09BREFtVztPQXlEQW12QztPQUNBQztPQTFDQVY7T0FFQUU7V0FZRUUsYUFRQTNtRTtPQWlSSmtzRTtPQUNBQztPQUNBQztPQXRVRXhrRTtPQUNBaWE7T0FrVUZvcUQ7T0FSQUY7T0FJQUM7T0FTQUs7T0FJQWwwQztPQUNBbTBDO09BN1RFdkc7T0FkQTdqRDtPQUdBN0I7T0FGQTRCO09BQ0E0akQ7T0FFQTVrRDtPQUNBNmtEO09BaURBYztPQS9EQXBCO09BQ0ExakQ7T0FDQTJqRDtPQUNBMWpEO09BQ0EyakQ7T0FDQUM7T0FDQUM7T0E4REEzZjtPQUtBOGdCO09BUUFHO09BSUFDO09BRUFDOztPQUlBQzs7T0FpU0ZrRjtPQUlBRTtPQVFBQztPQU1BQztPQUNBQztPQUVBQztPQUlBQzs7UUF2WkU1ckQ7UUFDQUU7UUFjQUg7UUFKQWlCO1FBR0E3QjtRQUdBbUI7UUFDQUM7UUFDQUY7UUFDQUY7UUFDQU07UUFFQUQ7UUFkQTlaO1FBQ0FpYTtRQVhBMGpEO1FBeUJBeHRDO1FBRUFpdUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFFQUM7UUFJQUM7UUFDQWxuRTtRQUNBbW5FO1FBRUFFO1lBWUVFLGFBUUEzbUU7UUFoREZpaUI7UUFDQTRqRDtRQUdBQztRQVNBQztRQXdDQWE7UUEvREFwQjtRQUNBMWpEO1FBQ0EyakQ7UUFDQTFqRDtRQUNBMmpEO1FBQ0FDO1FBQ0FDO1FBOERBM2Y7UUFLQThnQjtRQXJEQWx2QztRQXlEQW12QztRQUNBQztRQTRXQTRHO1FBeldBM0c7UUFJQUM7UUFFQUM7UUFJQUM7UUErSkUyRjtRQTZLRkM7UUFDQUM7UUFXQUk7UUFDQUM7UUFDQUM7UUFIQUg7UUFSQUY7UUFJQUM7UUFRQUs7UUFDQUM7UUFDQUM7UUFDQUM7O1FBMVdBbDZEO1FBa0tBcTNEOztTQWpEQWwwQztTQTdFQTB3Qzs7U0FPQXBtRDtTQUVBc21EO1NBVUFTO1NBUUFRO1NBb0VBMW1EO1NBM0VBbW1EO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBRUFFO1NBVEE3bUQ7U0FDQXFtRDtTQVZBVDtTQTJCQXlCO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBRUFDO1NBSUFDO1NBQ0E1b0U7U0FDQTZvRTtTQUVBQztTQXRCQWY7U0FDQUM7U0FLQUk7U0FIQUg7U0FFQUU7U0F2QkFyQjtTQUNBQztTQUNBQztTQUNBQztTQUNBQztTQUNBQztTQUNBQztTQTBEQW9DO1NBREFEO1NBaERBM0I7U0FrREE2QjtTQUNBQztTQUVBcEo7U0FHQXNKO1NBSUFDO1NBRUFDO1NBSUFDO1NBdEZBM2hDO1NBQ0F5RTtTQTZEQXc4QjtTQWJBTjtTQUNBQztTQUNBQztTQVVBRztTQVJBRjtTQUlBQztTQU9BRztTQXZDQTF6RDtTQUVBc3lEO1NBK0NBeUI7U0FoUndCOUo7UUE0RXhCdi9DO1FBQ0FFO1FBY0FIO1FBSkFpQjtRQUdBN0I7UUFHQW1CO1FBQ0FDO1FBQ0FGO1FBQ0FGO1FBQ0FNO1FBRUFEO1FBZEE5WjtRQUNBaWE7UUFYQTBqRDtRQXlCQXh0QztRQUVBaXVDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBRUFDO1FBSUFDO1FBQ0FsbkU7UUFDQW1uRTtRQUVBRTtZQVlFRSxhQVFBM21FO1FBaERGaWlCO1FBQ0E0akQ7UUFHQUM7UUFTQUM7UUF3Q0FhO1FBL0RBcEI7UUFDQTFqRDtRQUNBMmpEO1FBQ0ExakQ7UUFDQTJqRDtRQUNBQztRQUNBQztRQThEQTNmO1FBS0E4Z0I7UUFyREFsdkM7UUF5REFtdkM7UUFDQUM7UUFnS0E0RDtRQTdKQTNEO1FBSUFDO1FBRUFDO1FBSUFDO1FBNEpBMkQ7UUFNQUM7UUFFQUM7UUFxQkFJO1FBSUFDO1FBSUFDO1FBZEFIO1FBWEFGO1FBT0FDO1FBc0JBSztRQUlBN3NEO1FBSUE4c0Q7UUF6REFaO1FBblBBNXlEO1FBeUdBb3ZEOzs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7O0lDN3BDSW5wRTtJQUNBQztJQUNBb2E7SUFBQTVHO1lBRVJGLGVBWk11TDtJQUFvQixPQUFBLDZCQUFwQkE7R0FBcUQ7WUEyQnpEM1UsS0FBS1ksSUFBR0M7SUFDVixJQUFJZ21DLE1BREdqbUM7SUFBQUEsUUFBR0M7SUFBQUEsUUFDTmdtQzs7R0FFSztZQUdQMitCLFFBQVFobUUsR0FBRUMsR0FBRkQsT0FBVyxXQUFUQyxHQUFGRCxnQkFBZTtZQUV2QmltRSxnQkFBZ0JqbUUsR0FBRW9ELEdBQUduRDtJQUN2QixJQUFJaW1FLGFBRGNsbUU7SUFBQUEsT0FBRW9EO0lBR0ksT0FBQTsyQkFIRG5ELG1CQUFMRCxPQUNka21FLHFCQUU4QztHQUFDO1lBTS9DLytCLGVBQVcvakMsY0FBSHFFLGNBQUFBLE9BQUdyRTtZQUNYK2lFLEtBQUs3M0QsSUFBSyxnQ0FBTEEsSUFETDY0QixLQUM2QjtZQUM3QmkvQixvQkFBYTMrRCxjQUFTLFdBQVRBLEdBQUFBO1lBSWY0K0QsaUJBQWlCQyxZQUFZcm1FO0lBQy9CLElBQUlpbUUsdUNBRGVJLFlBSmZGO0lBREFELEtBS2VHO0lBR0ssT0FBQTsyQkFIT3JtRSxtQkFHSSxPQVIvQmttRSxLQU1BRCxZQUV3RDtHQUFDOzs7O09BN0NyRDd2RTtPQUNBQztPQUNBb2E7T0FBQTVHO09BRVJGO09BZUVwSjtPQU1Bd2xFO09BRUFDO1dBU0U5K0IsS0FDQWcvQixNQUNBQztPQUlGQzs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lDUEFFLGtCQUFrQnZtRTtJQUFBQSxPQUF1Qiw0QkFBdkJBOztHQUEwQztZQUM1RHNyRCxTQUFTdHJELEdBQUksT0FBQSw0QkFBSkEsU0FBYztZQUN2QndtRSxXQUFXeG1FLEdBQUUvRztJQUFJLFdBQU4rRyxNQUFNLE9BQUEsNEJBQU5BLE1BQUUvRztJQUFJLE9BQUE7R0FBeUI7WUFDMUNtekMsV0FBV3BzQyxHQUFFL0c7SUFBNEMsV0FEekR1dEUsV0FDV3htRSxHQUFFL0c7SUFBNEMsT0FBQSxrQ0FBOUMrRztHQUE4RDtZQUV6RTBzQyxXQUFXMXNDLEdBQUUvRyxHQUFFbUs7SUFBd0MsV0FIdkRvakUsV0FHV3htRSxHQUFFL0c7SUFBTSxPQUFBLGtDQUFSK0csWUFBSW9EO0dBQTBEO1lBR3pFcWpFLGdCQUFnQnptRSxHQUFFL0c7SUFDcEIsV0FEb0JBLCtCQUFGK0csUUFBRS9HOztJQU1iO2dDQUF5Qyx3QkFOOUIrRztLQU1YLDBCQUFXLHdCQU5FL0c7S0FJaEIsT0FBQTtJQUFBLE9BQUE7R0FFd0U7WUFHMUU4WSxJQUFJL1IsR0FBRS9HLEdBVE53dEUsZ0JBU0l6bUUsR0FBRS9HLElBQ1IsT0FmRW16QyxXQWNJcHNDLEdBQUUvRyxHQUVNO1lBR1prdUMsSUFBSW5uQyxHQUFFL0csR0FBRW1LO0lBZFJxakUsZ0JBY0l6bUUsR0FBRS9HO0lBdEJOc3RFLGtCQXNCSXZtRTtJQUVOLE9BbkJFMHNDLFdBaUJJMXNDLEdBQUUvRyxHQUFFbUs7R0FHTTtZQUdkMlEsU0FBUy9ULEdBQUksYUFBSkEsYUFBZ0I7WUFDekI4QixrQkFBU0EsbUJBQWMsT0FBZEE7WUFFVDRrRSxtQkFBbUIxbUUsR0FBRTJtRTtJQUN2QixXQURxQjNtRSxTQUFFMm1FOzthQWxFbkJ0eUQsZ0JBd0VrQyxXQUFhO0lBL0QvQjtLQVJBdXlELG9CQWlFQzVtRTtLQWhFVDZtRSxZQWdFUzdtRTtLQS9EVjhtRSxXQStEVTltRTtLQTlEUittRSxhQThEUS9tRTtLQTdEVmduRSxXQTZEVWhuRTtLQXpEYnV6QyxVQUFZLGlDQVRoQmwvQixVQUtPMnlEO0tBR0xyYixnQ0FDRXBZO0tBSUFFLFVBQVksNkJBVFBzekI7S0FRUGxiLGtDQUNFcFksZUFMRmtZO0tBU0VoWSxVQUFZLDZCQWRUbXpCO0tBYUxHLGtDQUNFdHpCLGVBTEZrWTtLQVNFSCxVQUFZLDZCQW5CUm1iO0tBa0JOSyxrQ0FDRXhiLGVBTEZ1YjtLQVNFcmIsVUFBWSw2QkF4QkFnYjtLQXVCZE8sa0NBQ0V2YixlQUxGc2I7S0FrREY7T0FBQTs7OzBCQTlDRUM7SUE4Q0YsT0FBQTtHQUVtRDtZQUdyRDl3RSxRQWNFZ1IsYUFBWWpHLElBQUdDO0lBQ2pCLEdBQUcsNkJBRFdELElBQUdDLEtBRVo7UUFmZ0UrbEUsT0FhcEQvbEUsT0FiOENnbUUsT0FhakRqbUUsT0FiMkNzMEMsT0FheENyMEMsT0Fia0NzMEMsT0FhckN2MEMsT0Fid0JzWjtJQUN0QztpQkFEc0NBLFFBQW1CZzdCO1FBQW5CaDdCLFFBQWFpN0I7ZUFJbEM7S0FFeUI7TUFBQSxPQTVDMUN2SixXQW1EaUIvcUMsSUFicUJxWjtNQU1oQ3ByQixJQUFJLFdBT1IrWCxhQW5ERitrQyxXQW1EY2hyQyxJQWJ3QnNaO0tBVnRDZ3NELG1CQXVCY3RsRSxJQWJpRGltRTtLQVYvRFgsbUJBdUJpQnJsRSxJQWJvRCtsRTtjQU0vRDkzRSxHQUtJLE9BTEpBO0tBSW9DLElBVkp3ckMsUUFVSSw0QkFWSnBnQjtLQUFBQSxNQUFBb2dCOztHQXlCWjtZQUcxQnhrQyxNQVNFcVMsV0FBVXZILElBQUdDO0lBQ2YsV0FBQSw2QkFEWUQsSUFBR0M7SUFDZjs7O0tBR0EsSUFESXMwQyxPQUhRdjBDLE9BSVJzMEMsT0FKV3IwQyxjQUdYczBDLFNBQ0FEOztVQVppRDB4QixPQVF0Qy9sRSxPQVJnQ2dtRSxPQVFuQ2ptRSxPQVJzQnNaO01BQ2xDO2tCQURrQ0EsUUFXOUJpN0I7Ozs7UUFSa0M7U0FBQSxPQXRFdEN2SixXQTJFZS9xQyxJQVJtQnFaO1NBRzlCclgsSUFBSSxXQUtOc0YsV0EzRUZ5akMsV0EyRVlockMsSUFSc0JzWjtRQXZDbENnc0QsbUJBK0NZdGxFLElBUm1DaW1FO1FBdkMvQ1gsbUJBK0NlcmxFLElBUnNDK2xFO1dBR2pEL2pFO1NBRzZCLElBTkN5M0IsUUFNRCw0QkFOQ3BnQjtTQUFBQSxNQUFBb2dCOzs7bUJBRzlCejNCOzs7Ozs7O0lBTUo7R0FZMkI7WUFHM0J3RyxVQUFVb3VCLGFBQVlqNEI7SUFDeEIsSUFBTTJtRSxnQkFEa0IzbUUsTUFDYXNuRSxRQURidG5FLE1BQ29COEIsU0FEcEI5QixNQUNPdXJELE9BRFB2ckQ7SUFFeEIsT0FEcUNzbkU7S0FDckMsTUFBQTtPQURxQ0EsU0E5Rm5DaGMsU0E2RnNCdHJEO0tBR3hCLE1BQUE7SUFDZSxJQUFYdW5FLGFBakdGamMsU0E2RnNCdHJEO09BSXBCdW5FLGVBQ2UsaUNBSlloYztLQUkvQixNQUFBO1dBRElnYztLQUVKLE1BQUE7SUFDTyxLQUFBLHlCQUhIQTtLQUdKLE1BQUE7V0FONEN6bEU7S0FPNUMsTUFBQTtPQVA0Q0EsU0FHeEN5bEU7S0FLSixNQUFBO0lBQ2EsSUFBQSxPQUFBLDRCQU5UQSxnQkFNSjs7U0FBQXR1RTs7U0FBQUEsSUFWd0IrRztPQWFwQixXQWJRaTRCLGFBM0ZWbVUsV0EyRnNCcHNDLEdBVXhCL0c7T0F6RUV5dEUsbUJBK0RzQjFtRSxHQUNsQjJtRTs7O09BM0ZtRCxXQUZ2REgsV0E0RnNCeG1FLEdBVXhCL0c7T0FLbUIsR0F6R3NDLGtDQTBGakMrRztRQWVqQixNQUFBOztNQUxQLFdBQUEvRztrQkFBQUE7TUFBQUE7Ozs7R0FNSTtZQUdGaUcsT0FBaUJvc0Q7SUFDbkIsR0FEbUJBO1NBSVZpYyxhQUpVamM7S0FLZixRQURLaWM7dUJBQUFBLGlCQVNBLHlCQVRBQTs7TUFNRTtPQUFBLDZCQUFjLHdCQU5oQkE7T0FJRCxPQUFBO2NBREY7U0FORkM7OztTQUFBQTtJQWtCSyxXQUFBLGlDQWxCTEE7SUFjSixpQkFFUyw0QkFoQkxBO0dBbUJIO1lBR0NDLGNBQWU3ckMsS0FBSUU7SUFDQyxXQUFBLGlDQUREQTtPQUFKRjtLQUNqQixNQUFBO0lBQ29DO1lBRm5CQTtLQUVtQixPQXpJbEMwdkIsU0F1SWUxdkI7S0FFa0IsT0FBQTtLQUEvQjhyQyxZQUFZLHlCQUZDOXJDO0tBR2IrckMsV0FBVyw0QkFIRS9yQyxRQUViOHJDO0lBRUosa0NBSmlCOXJDLFFBQUFBLFFBQUlFLFFBRWpCNHJDO0lBRUosT0FBQTtvQ0FKaUI5ckMsV0FBSUUsS0FFakI0ckMsV0FDQUM7R0FFNEU7WUFHOUUzYixhQUFhaHNELEdBQUU0bkU7SUFoSmZyQixrQkFnSmF2bUU7SUFJeUI7S0FBQSxPQUFBLDRCQUp2QjRuRSxrQkFBRjVuRTtLQUlrQixPQUFBO0tBQTdCaXNELGVBQWU7WUFBZkEsaUJBbkpGWCxTQStJYXRyRDs7S0FPSCxJQUFOODdCLE1BQU0saUNBSFJtd0I7S0FaRndiLGNBUWF6bkUsR0FPVDg3QjtLQVBTOTdCO0tBQUFBLE9BVUgsNEJBTlJpc0Q7S0FKV2pzRCxPQU9UODdCOzs7Ozs7R0FJVTtZQUdkK3JDLFFBQVE3bkUsR0FBRW9EO0lBOUpWbWpFLGtCQThKUXZtRTtJQUVJLFdBL0pac3JELFNBNkpRdHJEO09BQUFBLGVBZFJnc0QsYUFjUWhzRCxHQUVtQywrQkFGbkNBO0lBekpSMHNDLFdBeUpRMXNDLEdBQUFBLE1BQUVvRDtJQUFGcEQsT0FJRSw0QkFKRkE7O0dBSWM7WUFHdEI4bkUsaUJBQWlCOW5FO0lBcktqQnVtRSxrQkFxS2lCdm1FO0lBR25CO0tBREl1ckQsT0FGZXZyRDtLQUdmc25FLFFBSGV0bkU7S0FJZmtELE1BQU0sa0NBRk5xb0QsTUFDQStiO0lBRUosa0NBSEkvYixNQUNBK2I7SUFIZXRuRSxPQW5LakJ3bUUsV0FtS2lCeG1FO0lBQUFBLE9BT1AsNEJBUE9BO0lBUW5CLE9BSklrRDtHQUlEO1lBR0Q2a0UsWUFBWS9uRTtJQUFJLEdBcEpoQitULFNBb0pZL1QsSUFBdUIsTUFBQTtJQUE0QixPQVgvRDhuRSxpQkFXWTluRTtHQUFxRTtZQUNqRmdvRSxRQUFRaG9FLEdBQUksT0FySlorVCxTQXFKUS9ULGFBWlI4bkUsaUJBWVE5bkUsSUFBMEQ7WUFDbEVpb0UsZUFBZWpvRTtJQUFJLHlDQUFKQSxNQUFBQTtHQUFtRDtZQUNsRWtvRSxjQUFjbG9FO0lBQUksT0FoTGxCb3NDLFdBZ0xjcHNDLEdBQWlCLDRCQUFqQkE7R0FBK0I7WUFDN0Ntb0UsS0FBS25vRSxHQUFJLE9BeEpUK1QsU0F3SksvVCxhQUZMaW9FLGVBRUtqb0UsSUFBd0Q7WUFDN0Rvb0UsU0FBU3BvRTtJQUFJLEdBekpiK1QsU0F5SlMvVCxJQUF1QixNQUFBO0lBQTRCLE9BSDVEaW9FLGVBR1Nqb0U7R0FBbUU7WUFDNUVxckIsS0FBS3JyQixHQUFJLE9BMUpUK1QsU0EwSksvVCxhQUhMa29FLGNBR0tsb0UsSUFBdUQ7WUFDNURvckIsU0FBU3ByQjtJQUFJLEdBM0piK1QsU0EySlMvVCxJQUF1QixNQUFBO0lBQTRCLE9BSjVEa29FLGNBSVNsb0U7R0FBa0U7WUFFM0VrckQsTUFBTWxyRDtJQXpMTnVtRSxrQkF5TE12bUU7bUJBQUFBOztLQUlPLElBQUEsT0FBQSw0QkFKUEEsVUFHSDs7VUF0TFkvRzs7T0FBd0MsV0FKdkR1dEUsV0F1TE14bUUsR0FuTFMvRztPQUF3QyxrQ0FtTGpEK0c7T0FLSixXQXhMYS9HO21CQUFBQTtPQUFBQTs7O0tBbUxUK0c7S0FBQUE7Ozs7OztHQVFPO1lBR2Jxb0UsY0FBZXpzQyxLQUFLRSxLQUFLMzhCO0lBcE16Qm9uRSxrQkFvTWUzcUM7SUFwTWYycUMsa0JBb01vQnpxQztPQUFLMzhCO1NBTWxCNGIsUUFOa0I1YjtRQU1sQjRiO01BTUU7T0FBQSw0QkFBWSx3QkFOZEE7T0FJRCxNQUFBO01BREY7O1NBTkZ1dEQsUUFVQSw2QkFQS3Z0RCxPQU5RNmdCOzs7U0FHYjBzQyxRQUhhMXNDO2tCQUdiMHNDOztLQWNtQztNQUFBLE1BQUEsNEJBakJqQnhzQyxRQUdsQndzQztNQWNvQixNQXBOdEJoZCxTQW1Nb0J4dkI7S0FwRHBCa3dCLGFBb0RvQmx3QixLQWlCSDtLQUNEO01BQVp5c0MsWUFBWSw0QkFsQkl6c0MsUUFBQUE7TUFtQlAsT0FBQSw0QkFoQlh3c0M7TUFlYzs7VUFDaEJydkU7O09BRWM7ZUFyQkMyaUM7UUFxQkQsT0FBQSw0QkFyQkNBLFFBbUJmM2lDO1FBRU11dkUsUUFBUTtRQUNaLE9BdEJrQjFzQztRQXNCTixPQUFBLDRCQUpWeXNDLFdBQ0p0dkU7UUFHTXd2RSxRQUFRO1FBSVYsT0FBQSxrQ0ExQlc3c0MsUUFxQlQ0c0M7T0FFSixrQ0F2QmtCMXNDLFFBc0JkMnNDO09BS0osa0NBM0JhN3NDLFFBcUJUNHNDO09BRk4sV0FBQXZ2RTttQkFBQUE7T0FBQUE7OztLQW5Cb0I2aUMsU0E2Qk4sNEJBN0JNQSxRQUdsQndzQztLQTJCVyxXQTlCRTFzQyxRQThCRixPQUFBLDRCQTlCRUEsUUFHYjBzQztLQUhhMXNDLFNBOEJGO0tBOUJFQSxTQStCRCw0QkEvQkNBLFFBR2Iwc0M7Ozs7OztHQTRCNkI7WUFHL0JJLFlBQVkxb0UsR0FBRWdEO0lBR2hCO0tBQWlELE1BQUEseUJBSGpDQTtLQUdxQixNQUFBLDRCQUh2QmhEO0tBR1UsTUF4T3RCc3JELFNBcU9ZdHJEO0lBdEZaZ3NELGFBc0ZZaHNELEdBR0M7SUFDQSxPQUFBLHlCQUpDZ0QsWUFJSTFULEdBQUssT0E1RXZCdTRFLFFBd0VZN25FLEdBSU0xUSxHQUFnQjtHQUFDO1lBR25DeVEsS0FBS0MsR0FBR04sTUFBTU87SUFDaEIsU0FET0QsTUFFRixPQUZLTjtJQUtBO0tBREppbkUsZ0JBSkMzbUU7S0FLRHlILFFBTEkvSDtLQU1LLE1BQUEsNEJBTlJNO0tBS0c7O1NBQ1IvRzs7TUFDWSxVQWpQWm16QyxXQTBPS3BzQyxHQU1ML0c7TUFESXdPLE9BRUcsV0FQT3hILEdBS1Z3SDtNQW5OSmkvRCxtQkE4TUsxbUUsR0FJRDJtRTtNQUlGLFVBRkYxdEU7aUJBQUFBO01BQUFBOzs7V0FESXdPO0dBS0Q7WUFHSGlpQixNQUFNMXBCLEdBQUdOLE1BQU1PO0lBQ1QsSUFBSmhIO0lBQ1ksT0FmZDhHO2FBYU1DO2FBQUdOO3NCQUVVOFksS0FBSXBWO2NBQ2IsSUFBTjhtQixRQUFNLFdBSEtqcUIsR0FDYmhILE1BQ2lCdWYsS0FBSXBWO2NBRHJCbkssT0FHRyw0QkFISEE7Y0FJRixPQUZJaXhCO2FBRUQ7R0FBQztZQU1KL3BCLEtBQUtILEdBQUdDO0lBQ1Y7S0FBSTBtRSxnQkFERzNtRTtLQUVNLE1BQUEsNEJBRk5BOzs7U0FFUC9HOztNQUNFLFdBSFFnSCxHQWxRUm1zQyxXQWtRS3BzQyxHQUVQL0c7TUF4T0V5dEUsbUJBc09LMW1FLEdBQ0gybUU7TUFHRixVQUZGMXRFO2lCQUFBQTtNQUFBQTs7OztHQUdJO1lBR0ZtSCxNQUFNSixHQUFHQztJQUNYO0tBQUkwbUUsZ0JBREkzbUU7S0FFSyxNQUFBLDRCQUZMQTs7O1NBRVIvRzs7TUFDRSxXQUhTZ0gsR0FFWGhILEdBNVFFbXpDLFdBMFFNcHNDLEdBRVIvRztNQWhQRXl0RSxtQkE4T00xbUUsR0FDSjJtRTtNQUdGLFVBRkYxdEU7aUJBQUFBO01BQUFBOzs7O0dBR0k7WUFHRjZHLFFBQVFFO0lBQ1YsSUFBSTZkLGlCQUNJLE1BQUEsNEJBRkU3ZDs7U0FFVi9HOztnQkFESTRrQjtNQUFBQSxnQkFuUkZ1dUIsV0FrUlFwc0MsR0FFVi9HO01BQVEsVUFBUkE7ZUFBQUE7TUFBQUE7OztXQURJNGtCO0dBSUc7R0FPTTtJQUFQM0UseUJBNUJKL1k7SUE2QklpWiwyQkFyUUp0WDtJQXNRSTY4QiwwQkF6Q0pqVjtJQTBDSStVLDBCQXZCSnIrQjs7OztZQWhDQUwsTUFvREltWixRQUNBRSxVQUVBcWxCLFNBREFFO0lBSUp2bUI7SUFDQWxXO0lBQ0E4VztJQUNBRDtJQUNBUjtJQUNBRztJQUNBblc7SUFDQXVXO0lBQ0F1QjtJQUNBekI7SUFDQVA7SUFDQWtWO0lBQ0EvSTtJQUNBSjtJQUNBSDtJQUNBTTs7OztZQUtBcUcsV0FBVzVxQixHQUFHQztJQUNELElBQVgwb0UsV0EzTUZ6cEU7SUFvSkFpQjtNQXNEV0g7ZUFFRW9EO09BQWUsVUFBQSxXQUZkbkQsR0FFRG1EO09BQXdCLE9BQUE7NENBQUtDLEdBQUssT0EvSi9Dd2tFLFFBOEpFYyxVQUN3Q3RsRSxHQUF1QjtNQUFDO0lBQXBFLE9BRElzbEU7R0FFSTtZQUdOOTlDLFlBQVk3cUIsR0FBR0M7SUFDRixJQUFYMG9FLFdBak5GenBFO0lBNEpBa0I7TUFvRFlKO2VBRUUvRyxHQUFFbUs7T0FBZSxVQUFBLFdBRmhCbkQsR0FFRGhILEdBQUVtSztPQUEwQixPQUFBOzRDQUFLQyxHQUFLLE9BcktwRHdrRSxRQW9LRWMsVUFDNkN0bEUsR0FBdUI7TUFBQztJQUF6RSxPQURJc2xFO0dBRUk7WUFHTmo3QyxXQUFXMXRCLEdBQUdDO0lBQ0QsSUFBWDBvRSxXQXZORnpwRTtJQW9KQWlCO01Ba0VXSDtlQUVFb0Q7T0FDUCxZQUFBLFdBSFFuRCxHQUVEbUQ7bUJBRUg7V0FDSEM7T0FBSyxPQTlLWndrRSxRQTBLRWMsVUFJS3RsRTtNQUF1QjtJQUhoQyxPQURJc2xFO0dBS0k7WUFHTjk2QyxZQUFZN3RCLEdBQUdDO0lBQ0YsSUFBWDBvRSxXQWhPRnpwRTtJQTRKQWtCO01BbUVZSjtlQUVFL0csR0FBRW1LO09BQ1YsWUFBQSxXQUhTbkQsR0FFRGhILEdBQUVtSzttQkFFTjtXQUNIQztPQUFLLE9Bdkxad2tFLFFBbUxFYyxVQUlLdGxFO01BQXVCO0lBSGhDLE9BRElzbEU7R0FLSTtZQUdOL2tELE9BQU81akIsR0FBR0M7SUFDRyxJQUFYMG9FLFdBek9GenBFO0lBb0pBaUI7TUFvRk9IO2VBRU1vRDtPQUFRLFVBQUEsV0FGWG5ELEdBRUdtRDtPQUFRLGFBN0xyQnlrRSxRQTRMRWMsVUFDV3ZsRTtNQUFtQztJQUFsRCxPQURJdWxFO0dBRUk7WUFHTmgvQyxRQUFRM3BCLEdBQUdDO0lBQ0UsSUFBWDBvRSxXQS9PRnpwRTtJQTRKQWtCO01Ba0ZRSjtlQUVNL0csR0FBRW1LO09BQVEsVUFBQSxXQUZibkQsR0FFR2hILEdBQUVtSztPQUFRLGFBbk14QnlrRSxRQWtNRWMsVUFDY3ZsRTtNQUFxQztJQUF2RCxPQURJdWxFO0dBRUk7WUFHTkMsZUFBZTVvRSxHQUFHQztJQUNYLElBQUxvQixLQWJGdWlCLE9BWWU1akIsR0FBR0M7SUE1S2xCaXJELE1BNEtlbHJEO0lBRWpCLE9BbktFcW9FLGNBa0tFaG5FLElBRGFyQjtHQUdjO1lBRzdCNm9FLGdCQUFnQjdvRSxHQUFHQztJQUNaLElBQUxvQixLQWJGc29CLFFBWWdCM3BCLEdBQUdDO0lBbExuQmlyRCxNQWtMZ0JsckQ7SUFFbEIsT0F6S0Vxb0UsY0F3S0VobkUsSUFEY3JCO0dBR2E7WUFHN0JSLEtBQUtvOEI7SUFDRyxJQUFORSxNQWpRRjU4QixXQWdRSzA4QjtJQXpPTDZyQyxjQXlPSzdyQyxLQUNIRTtJQUFBQSxTQURHRjtJQUlQLE9BSElFO0dBR0Q7WUFHRGw4QixRQUFRb0Q7SUFHRixJQUFKaEQsSUExUUZkLFdBMFF1Qix5QkFIZjhEO0lBSVYseUJBSlVBLFlBSVUxVCxHQUFLLE9BOU52QnU0RSxRQTZORTduRSxHQUNnQjFRLEdBQWdCO0lBQXBDLE9BREkwUTtHQUVIO1lBUUNOLEtBQUtQLEtBQUtjO0lBQ1osR0FET2Q7S0FJeUM7TUFBQSw0QkFBWSx3QkFKckRBO01BSUgsTUFBQTtLQURGOztJQUVNLElBQUphLElBelJGZCxXQW9SS0M7T0FBQUEsTUFNQyxpQ0FESmE7S0FDSixNQUFBO0lBQ2EsSUFBQSxNQUFBLDRCQVBOYixTQU9QOztTQUFBbEc7O01BQ3dDLFVBQUEsV0FSNUJnSCxHQU9aaEg7TUFDRSxrQ0FIRStHLE1BRUovRztNQUNFLFVBREZBO2lCQUFBQTtNQUFBQTs7O0lBRkkrRyxPQUxHYjtJQVdQLE9BTklhO0dBTUg7WUFHQ2t0QyxTQUFTOXBDO0lBQUksT0FkYjFELEtBY1MwRCw0QixPQUFBQTtHQUFpRDtZQUMxRDZWLFNBQVNqWjtJQUFJLE9BQXVCOzZCQUEzQkEsZUFBZ0MvRyxHQUFLLE9Balo5Q216QyxXQWlaU3BzQyxHQUFnQy9HLEdBQW1CO0dBQUM7WUFFN0RvSCxJQUFJME8sSUFBSTlPO0lBQ1YsSUFBSTBtRSxnQkFERTUzRCxPQUVGQyxLQXZTRjlQLFdBcVNJNlA7SUFFRkMsUUFGRUQ7SUFJTyxJQUFBLE1BQUEsNEJBSlBBLFdBSU47O1NBQUE5Vjs7TUFDVSxJQUFKb0ssSUFBSSxXQUxBcEQsR0FuWlJtc0MsV0FtWklyOUIsSUFJTjlWO01BM1hFeXRFLG1CQXVYSTMzRCxJQUNGNDNEO01BTUYsa0NBTEUzM0QsT0FFSi9WLEdBQ01vSztNQUROLFVBQUFwSztpQkFBQUE7TUFBQUE7OztJQUtBLE9BUEkrVjtHQU9GO1lBR0ExTyxLQUFLTixHQUFHQztJQUNGLElBQUpoSDtJQUNLLE9BZFBvSDthQVlLTDtzQkFFT29EO2NBQ0MsSUFBVHlhLFNBQVMsV0FITDVkLEdBQ05oSCxNQUNVbUs7Y0FEVm5LLE9BR0csNEJBSEhBO2NBSUYsT0FGSTRrQjthQUVFO0dBQUM7WUFHUDhuQixVQUFVcjJDLEdBQ0osSUFBSjBRLElBMVRGZCxjQTZDQTJvRSxRQTZRRTduRSxHQURRMVEsSUFFWixPQURJMFEsRUFFSDtZQUdDOEosVUFBVTBRLFdBQVV4YTtJQUFJLFVBM0p4QkYsUUEySm9CRTtJQUFJLE9BQUEsV0FBYSx5QkFBM0J3YTtHQUFtRDtZQUM3RDlKLFVBQVV5c0IsV0FBVW55QjtJQUFPLE9BekQzQnBMLFFBeUQyQix5QkFBakJ1OUIsV0FBVW55QjtHQUErQztZQUVuRXBCLGVBQXlCdWpDO0lBR0UsVUFBQSx5QkFIRkE7SUFHRSxPQUFBO0dBQTZCOzs7O09BOVl4RDkyQztPQXlZQXFhO09BREE1RztPQUdBRjtPQXBJQXlRO09BbFJBdlk7T0FEQWlTO09BeU9BNVQ7T0F4QkFKO09BOERBd1k7T0FDQUc7T0FKQXhXO09BS0FLO09BTkE2VjtPQVVBQztPQVJBVztPQUNBRDtPQXJCQWpaO09BK0hBbVo7T0FwR0FMO09BRkFFO09BcERBNFE7T0FtQkF0cEI7T0FzQ0Fva0I7T0FHQUQ7T0FKQWdKO09BR0F0SjtPQURBRztPQXNIQXVoQjtPQWxEQS9sQztPQTJCQXN0QztPQWRBeHRDO09Bdk9BbW9FO09Bd0VBYTtPQXJEQVY7T0FEQUQ7T0FJQUk7T0FDQUM7T0FJQWxkO09Bd0xBMXJEO09BcUNBYTtPQVlBQztPQXZHQXNxQjtPQU1BQztPQU1BNkM7T0FTQUc7T0FTQWpLO09BTUErRjtPQU1BaS9DO09BTUFDO09BdFNBdnlFO09BeUJBdVQ7T0FtQkEzSztPQXFFQW1zQjtPQUNBRDtPQWFBaTlDO09BbkxBdDJEO09BS0FvMUI7T0FyQkFta0I7T0ErSUFVOzs7RTs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7OztJQ3hMR3BpRDtJQVVDUzs7Ozs7O1lBVEZ5K0Q7SUFYbUIsTUFBQTtHQUNQOzs7O1lBSVpwakUsbUJBQWMxRixHQUFJLE9BTWxCOG9FLGlCQU5jOW9FLEdBQXNCO1lBRXBDM0osUUFBUStNLFVBQU0sT0FJZDBsRSxpQkFKUTFsRSxHQUF3QjtZQUVoQ3NOLFVBQVUxRjtJQUFPLE9BQUEsNkRBQVBBO0dBQWdFO1lBRzFFeko7SUFBeUIsT0FBQTtHQUFnRDs7Ozs7O1NBTHpFbEw7U0FGQXFQO1NBTUFvakU7U0FGQXA0RDtTQUVBbzREO1NBQ0F2bkU7U0FEQXVuRTtTQVNFeitEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BVkRUO09BQ0RrL0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7O0lDNkNFeitEO0lBT0EwN0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUE3RERyZ0Q7SUFJQ21IO0dBQ0osU0FGR3hELEtBRUMvWixHQUFLLE9BQUEsV0FETHVkLE1BQ0F2ZCxHQUFXO0dBU2E7SUFOMUJvaEI7SUFDQTVHO0lBQ0NGO0lBSUQ4d0IsZUFYQ3J4QixlQU1EUztJQU1BelM7SUEwUElpSztJQURBQztvREF6UEpsSyxXQU5BeVM7SUFpQkVzOEM7OENBWEYvdUQsV0FOQXlTLFdBaUJFczhDOzs7Ozs7eURBK09FOWtEOzs7SUFwT0ZySjtJQUVDdWI7SUFJQzZ5QztHQUNKLFNBRkc1eUMsT0FFQ25rQixHQUFLLE9BQUEsV0FETCsyRCxRQUNBLzJELEdBQVc7T0FLYnk1RTtZQUNBemlCLFM7O0lBQ0F2MkQ7OztZQUNBMHpELFlBQVV4cUQsR0FBSSxPQUFBLGdDQUFKQSxHQUEwQjtZQUNwQytzRCxZQUFVdG9EO0lBQUksT0FBMEIsNEJBQTlCQSxzQkFBSTtHQUErQjs7Ozs7O1NBaEI3Q3pGO1NBRUN1YjtTQUdBQztTQVVEZ3dDO1NBQ0F1QztTQUpBK2lCO1NBRUFoNUU7U0FEQXUyRDtTQUlBajhDOzs7NkNBT0EwN0MsZUE0TUV6a0Q7O1lBcE1OdUksaUJBQW9CLFNBQUU7R0FDWDtJQUFYRSxXQUFXO0lBQ1hrOEMsb0JBQW9CLDRCQURwQmw4QztJQUVBbThDLG9CQUFvQiw0QkFGcEJuOEM7WUE0TUVxOUMsOEI7WUFEQWxpQixzQjtZQURBbWlCLHFCO0dBck1XLElBb01YQztZQURBRyxrQjtZQURBRixpQjtZQURBQyxrQjtHQTdMUTtJQUNWN2xEO0lBQ0FEO0lBc0tFd2xEO0lBcEtGcnNCO0lBQ0FqNUI7SUFDQXVsRDtZQW1LRWg0QyxjO0dBbEtJO0lBQ042NUQ7SUFDQWprQjtJQWlLRWtrQjs7Ozs7OztZQS9KRnpuRSxjO1lBQ0Eya0Qsd0I7WUFFQTFrRCxTQUFTeEI7SUFDWDtNQUFHLGdDQURRQSxHQXRCVGdtRDtTQXdCQyxnQ0FGUWhtRCxHQXJCVGltRDtLQXdCRyxPQUhNam1EO0lBT1AsVUFBQSw0QkFQT0E7SUFLVCxPQUFBO0dBR0k7O0lBT0ZzM0I7Ozs7Ozs7Ozs7OztZQUVBb3dCO0lBQ0YsT0FBQTtHQUEyRDtZQVF6REMsVUFBV3Q0RDtJQUNiLEdBQUcsZ0NBRFVBLE9BVFhxNEQ7SUFXTTtLQUFKdHhDLE1BQUksZ0NBRksvbUI7S0FHVDA0RCxNQURBM3hDLE1BQUFBO0tBRUEweEMsTUFEQUMsTUFBQUE7S0FFQUYsTUFEQUMsTUFBQUE7S0FFQUYsTUFEQUMsTUFBQUE7S0FFQWxDLE1BREFpQyxNQUFBQTtLQUlBOW5DLE1BSEE2bEMsTUFBQUE7SUFJSixPQUFBLGdDQURJN2xDO0dBQ2lCO1lBSW5Ca29DLFdBQVc1eEM7SUFDYixHQUFHLGdDQURVQSxTQXhCWHN4Qzs7S0EwQkVyNEQsSUFGUyttQixNQUFBQTtLQUdUMHhDLE1BREF6NEQsSUFBQUE7S0FFQXc0RCxNQURBQyxNQUFBQTtLQUVBRixNQURBQyxNQUFBQTtLQUVBbEMsTUFEQWlDLE1BQUFBO0tBRUE5bkMsTUFEQTZsQyxNQUFBQTtJQUVKLE9BREk3bEMsT0FBQUE7R0FDMEI7WUFHNUJtb0MsUUFBUTU0RDtJQUNWLEdBQUcsZ0NBRE9BLE9BbkNScTREO2NBbUNRcjRELElBRUgsZ0NBRkdBO0lBQ00sT0FBQTtHQUNpQjtZQWlCL0I2NEQsV0FBV2x2RDtJQUNiLEdBQUcsZUFEVUE7S0FNTix1QkFBTSw2QkFOQUE7S0FHWDtPQTNEQXMrQixTQTRERTs7SUFHVztLQUFBLE1BQUEsb0NBUEZ0K0I7S0FPYixNQUFBLDRCQXJHQThRO0lBcUdlLE9BQUE7R0FBSztZQUlsQnErQyxVQUFVbnZEO0lBQ1osR0FBRyxlQURTQTtLQU1MLHlCQUFNLDZCQU5EQTtLQUdWO09BdEVBcytCLFNBdUVFOztJQUdELEdBQUEsaUNBUFN0K0IseUJBUVA7SUFDVzs7T0FBQSxvQ0FBSSxnQ0FUUkE7SUFTSSxPQUFBLDRCQWxIaEI4UTtHQWtIMkM7WUFNM0NrdkIsUUFBUWo1QixHQUFHazVCLEtBQUtDO0lBQU8sVUFBQSxnQ0FBWkQsS0FBSGw1QjtJQUFlLDZDQUFmQSxHQUFRbTVCO0dBQTRCO1lBQzVDQyxnQkFBZ0JwNUIsR0FBR3ZRLEtBQUtEO0lBQU0sT0FBRyxnQ0FBakJ3USxHQUFHdlE7Y0FBQUE7Y0FBdUMsZ0NBQTFDdVEsR0FBUXhRLE9BQVJ3USxJQUFReFE7R0FBMEQ7WUFFbEY2cEMsVUFBVXI1QixHQUFHdlEsS0FBS0Q7SUFDcEIsR0FBTyxnQ0FEUUMsS0FBS0Q7S0FFcEIsT0FKRTRwQyxnQkFFVXA1QixHQUFHdlEsS0FBS0Q7SUFDcEIsTUFBQTtHQUMyQjtZQUd6QjhwQyxNQUFNdDVCLEdBQUd2USxLQUFLRDtJQUNoQixLQUFHLGdDQURRQyxLQUFLRDtLQU9YLFdBZEg0cEMsZ0JBT01wNUIsR0FBR3ZRLEtBQUtEO0lBTVQ7NEJBQWlDLFdBbk1wQ3NhLFdBNkxZdGE7S0FNVCx1QkFBUyxXQW5NWnNhLFdBNkxPcmE7S0FJUCxNQUFBO0lBQUEsT0FBQTtHQUdpQztPQW9DakM0Ziw2QkFEQXphO1lBREFDLG1CO1lBREFDLG1CO1lBekJGdUksS0FBS29LLEdBQUFBLE9BQUFBLE9BN0hMczlDLGtCQTZIc0I7WUFDdEIzbkQsS0FBS3FLLEdBQUFBLE9BQUFBLE9BOUhMczlDLGtCQThIc0I7WUFDdEJnQyxhQUFhL21ELEdBQUksT0FBSkEsRUFBSztZQUVsQmluRCxhQUFham5ELEdBQUksT0FBSkEsRUFBSzs7SUFFbEJxb0Q7SUErQkVsbkQ7SUE1QkZMO0lBQ0Ftc0Q7SUFDQWljO0lBQ0ExaUI7SUFFQUU7SUFDQUM7SUFDQXdpQjtJQUNBdmlCO0lBQ0FDO0lBQ0F1aUI7SUFDQXRpQjtZQUNBWSxJQUFJcmtELEdBQUV3QjtJQUFJLElBQW9ELE1BQUEsV0FYOURvb0QsWUFXTXBvRCxJQUF5QyxNQUFBLFdBWC9Db29ELFlBV0k1cEQ7SUFBaUIsT0FBQSxXQWdCbkJsQyxZQWhCbUI7R0FBd0Q7WUFTM0VwTSxTQVJLc08sR0FBRXdCLEdBQUksT0FEYjZpRCxJQUNPcmtELEdBQUV3QixHQUFXOzs7SUFVMkI3UDtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQzs7Ozs7U0F4Si9Db007U0FIQUQ7U0E4S01EO1NBQ0FEO1NBM0JKeE07U0FDQUQ7U0FDQUQ7U0FDQXlhO1NBT0FGO1NBSDZDOVo7U0FBQUQ7U0FBQUQ7U0FBQUQ7U0FBQUQ7U0FBQUQ7U0FFN0NreUQ7U0FDQS8zQztTQUNBODVEO1NBQ0E5bkU7U0FyS0ZnbUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTNFR3Y5QztPQW1GSG5JO09BSEFEO09BZ0tFTDtPQTNCRjhyRDtPQS9OR3ZuRDtPQUdBMkQ7T0FLRHFIOztPQWdRSW5QO09BQ0FEOzs7Ozs7Ozs7Ozs7O09BM0VOMjNCO09BR0FJO09BS0FDOzs7T0F4TEVvQjs7Ozs7O09BdURGN3dCOzs7T0FvTEVvL0Q7T0FqS0Zsa0I7T0FEQWlrQjtPQXVKRWwwRTtPQUNBRDtPQUNBRDtPQUdBRztPQUtBb2E7T0FBQUE7OztPQVBBRTtPQTVKRjgzQzs7T0F1TEVLO09BQ0FEO09BQ0FFO09BQ0FIO09BQ0FEO09BQ0FuaUI7Ozs7OztPQTFCQWdpQjtPQW5LRnRsRDtPQURBaTVCO09BdUpBNnNCO09Ba0NFRjtPQUNBRDtPQUNBRTtPQUNBSDtPQXBERmU7T0FxREVoQjtPQUNBbmlCO09BM0RGOW5DO09BREFDO09BWUFtcEQ7T0FHQUc7T0FHQUU7T0FFQUM7T0FsQkFDO09BRUFFO09BOUhBZDtPQXJCQXA4QztPQVdBckk7T0FEQUM7T0FrTUV5bEQ7T0FBQUE7T0EzSkFRO09BZUFLO09BeUNBRztPQVhBRDtPQW5CQUQ7cUI7cUI7O1FBNkZBcHpEO1FBQ0FEO1FBQ0FEO1FBQ0F5YTtRQU9BRjtRQUxBcGE7UUFFNkNNO1FBQUFEO1FBQUFEO1FBQUFEO1FBQUFEO1FBQUFEO1FBRTdDa3lEO1FBQ0EvM0M7UUFDQTg1RDs7OztRQW1CQXpoQjtRQUNBRDtRQUNBRTtRQUNBSDtRQUNBRDtRQUNBbmlCO1FBQ0FraUI7T0F4QkFqbUQ7T0E1QkZMO09BR0EwbEQ7T0FFQUU7T0FaQUs7T0FFQUU7T0FhQUw7T0FOQXNpQjtPQUtBQztPQUdBQzs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7SUM2aUVJbG9DO0lBbmlDRXB2QjtJQTBCQXUzRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUE3dkNKQywwQjtZQUNBQywwQjtHQU4wQjtJQUFBOzs7Ozs7T0FLMUJEO09BQ0FDOzs7OztZQU1BamlDO0lBQU87O1NBRURBOzhCQURNLGNBQ05BO0lBQTBCLFdBQTFCQTtHQUFtQztZQUd6Q0M7SUFBUTs7U0FFREE7K0JBREksY0FDSkE7SUFBNEIsV0FBNUJBO0dBQXNDO1lBRzdDaWlDLFdBQVd4cEUsR0FBR3FiO0lBQ2hCLFdBRGFyYjs7U0FHTHNuQyxPQUhLdG5DOzhCQUVDLE9BRkVxYixlQUdSaXNCLE9BSEt0bkM7SUFHcUIsT0FBMUJzbkM7R0FBOEI7WUFHcENtaUMsWUFBWXpwRSxHQUFHcWI7SUFDakIsV0FEY3JiOztTQUdMdW5DLFFBSEt2bkM7K0JBRUQsT0FGSXFiLGVBR1Jrc0IsUUFIS3ZuQztJQUd1QixPQUE1QnVuQztHQUFpQztZQUd4Q21pQyxPQUFPMXBFLEdBQUcycEUsY0FBY0M7SUFDMUIsV0FEUzVwRTs7aUJBQUFBLE1BSU11bkMsa0JBQU5EO0tBQWdCLFdBQWhCQSxNQUFNQzs7O1NBRlBzQixTQUZDN29DO0tBRU8sV0FBUjZvQyxRQUZrQitnQzs7UUFHakJDLFVBSEE3cEU7SUFHUyxXQUhOMnBFLGNBR0hFO0dBQzJCO0dBN0JqQjtJQUFBOzs7OztPQUdqQnZpQztPQUtBQztPQUtBaWlDO09BTUFDO09BTUFDO0lBUUZ6OEQ7SUFFSjs7O0dBR0U7Ozs7OztNQUF3RSx3QkFDdkQ7TUFDUixNQUFBO0tBQWE7Ozs7Ozs7Ozs7OztZQWFsQnlvRDtJQUFTLDhCQUNBO3VCQUNDO1FBQ1F6c0M7SUFBTSxPQUFOQTtHQUFPO1lBSXZCMHNDLFNBQVMvRyxPQUFNQyxPQUFNaWIsYUFBWXQ2QztJQUNuQyxHQURXby9COztNQUdIRSxVQUhHRjthQUdNLFdBSE1rYixhQUdmaGIsU0FIMkJ0L0I7Ozs7UUFBbEJxL0I7VUFPVkUsVUFQVUY7YUFPRCxXQVBPaWIsYUFBWXQ2QyxHQU81QnUvQjs7Ozs7O0lBREc7R0FDNkI7WUFFakMzZ0QsS0FBS3dnRCxPQUFNQyxPQUFNaWIsYUFBWTlwRTtJQUNuQyxJQURXOHVELFVBQUFGLE9BQXdCMW9ELE1BQUFsRztJQUNuQztlQURtQ2tHLGtCQUV4QjtjQUZ3QkE7VUFHM0JzcEIsSUFIMkJ0cEI7TUFHbEIsT0FaZnl2RCxTQVNTN0csU0FBTUQsT0FBTWliLGFBR2Z0NkM7O0tBRUc7TUFEU3ZHLElBSmUvaUI7TUFBQXVCLElBQUF2QjtNQUl4QnExQyxNQUp3QnIxQztNQUkzQmxELElBSjJCa0Q7TUFLN0IwdkQsS0FyQk5GLE9Bb0JRMXlEO01BRUY2eUQsS0F0Qk5ILE9BZ0JtQ2p1RDtNQU83QixPQUFBLDRCQUZBbXVELElBQ0FDO2FBQ0o7O01BQ087T0FBQSxPQUFBLDRCQUhIRCxJQUNBQztjQUZjNXNDLE1BSVg7O09BQ0osV0FsQkgwc0MsU0FTUzdHLFNBQU1ELE9BQU1pYixhQUladnVCO09BS047UUFDQSxXQVZDbnRDLEtBQUswZ0QsYUFJQXZULE1BSll1dUIsYUFJZjltRTtRQU1IO1NBQ0ssSUFYQzh5RCxjQUlBdmE7U0FKQXVULFVBQUFnSDtTQUF3QjV2RCxNQUFBdUI7Ozs7Ozs7Ozs7Ozs7S0FVOUI7O0dBQ2lDO1lBckJ0Q3N1RCxXQXVCRS8xRCxHQUFHOHBFLGFBQWUsT0FiZDE3RCxXQWFEMDdELGFBQUg5cEUsR0FBOEM7WUFJaERkLE9BQU84RCxHQUFFMVQsR0FBRXc4QyxHQUFFcmtDO0lBQ2YsSUFBSW11RCxLQWxDRkYsT0FpQ08xeUQsSUFFTDZ5RCxLQW5DRkgsT0FpQ2FqdUQ7YUFDWG11RCxZQUNBQyxJQUVDLFdBSk12bUUsR0FBRXc4Qzs7O09BRVQrcEIsTUFEQUQ7VUFJb0MsNEJBSnBDQTtVQUlnRCw0QkFIaERDO0lBR0MsV0FMSTd5RCxHQUFFMVQsR0FBRXc4QyxHQUFFcmtDO0dBSzRDO1lBT3pEMnVELCtCQUFrQ2ozRCxLQUFLYzthQUNqQ21PLEtBQUtvRSxHQUFHdlMsR0FBRWhIO0tBQ2hCLFFBRFd1WjthQUFBQTs7U0FFSjs7U0FFTSxJQUFBLFVBQUEsV0FKQ3ZTLEdBQUVoSCxJQUlQeW5DLGtCQUFINmE7U0FDSixXQURJQSxLQUFHN2E7O1NBR007VUFBQSxVQUFBLFdBUER6Z0MsR0FBRWhIO1VBT044d0U7VUFBSjFUO1VBQ08sVUFBQSxXQVJDcDJELEdBUUMsNEJBUkNoSDtVQVFQd2hFO1VBQUhuRTtTQUNKLGVBRklELElBQUkwVCxLQUNKelQsS0FBR21FOztTQUdNO1VBQUEsVUFBQSxXQVhEeDZELEdBQUVoSDtVQVdOK3dFO1VBQUp6VDtVQUNPLFVBQUEsV0FaQ3QyRCxHQVlDLDRCQVpDaEg7VUFZUDBoRTtVQUFIbkU7VUFDUyxVQUFBLFdBYkR2MkQsR0FhRyw0QkFiRGhIO1VBYU5neEU7VUFBSnhUO1NBQ0osZUFISUYsTUFBSXlULE9BQ0p4VCxLQUFHbUUsU0FDSGxFLElBQUl3VDs7S0FHVTtNQUFkdlQsY0FBYyw2QkFoQlRsa0Q7TUFpQlUsT0FBQSw0QkFqQlZBLEdBZ0JMa2tEO01BQ0FDLGVBQWU7TUFDZnJ2QixPQWxCQWw1QixLQWdCQXNvRCxhQWhCUXoyRCxHQUFFaEg7TUFtQkgsUUFBQSxXQW5CQ2dILEdBbUJDLDRCQW5CQ2hILEdBZ0JWeTlEO01BR0dub0Q7TUFBSGloQjtNQUM4QixPQUFBLDRCQXBCcEJ2MkIsR0FnQlZ5OUQ7TUFJQW52QixRQXBCQW41QixLQWlCQXVvRCxjQWpCUTEyRCxHQW9CcUI7S0FDakMsT0FsQ0ZmLE9BK0JNb29DLE1BQ0E5WCxHQUFHamhCLEdBQ0hnNUI7SUFDaUI7SUFFekIsT0F2QlFuNUIsS0FENEJqUCxLQUFLYztHQXdCNUI7WUFHWDIyRCwwQkFBMEJoeUQsT0FBT2tsRTtJQUNuQyxJQUFJalQsZUFEd0JqeUQ7OztLQUU1QixRQURJaXlEOztPQUlLcVQsc0JBTG1CdGxFO09BTW5CdWxFLHNCQU5tQnZsRTtTQU92QixXQVA4QmtsRSxhQUsxQkksSUFDQUM7O1FBSkw3cUM7bUJBT09ybUM7V0FBSztZQUFPLE9BQUEsNEJBUm5CNDlEO1lBUW1CLE9BQUEsa0NBQVo1OUQ7V0FBSyx3QkFUWTJMO1VBU2dCOzs7O1NBUHhDMDZCLGdCQU1Pcm1DLEdBQUssd0JBUlkyTCxPQVFqQjNMLE9BQUFBLEdBQWM7O0lBR3pCO1lBdENFbTlELCtCQTRCRVMsY0FDQXYzQjtZQURBdTNCO0dBVW9FO1lBR3RFQyxnQkFBZ0JseUQsT0FBT2tsRTtJQUN6QixVQURrQmxsRTs7S0FJSixPQUFBO2NBOUdkcUk7dUJBOEdtQnhGO2VBQ2Y7Z0JBQ3lDLHdCQU4zQjdDO2dCQU1zQixPQUFBO2dCQUFYLHdCQU5YQTtnQkFRVjNMO2tCQUZJO29CQU5hNndFLGFBTUQ7Z0JBRGhCL1M7d0JBR0E5OUQ7cUJBREs7c0JBSE13TztzQkFHRzs7cUJBQ2R4TztnQkFFUyxPQUFBLDRCQVZDMkw7OztvQkFVZEU7O2lCQUNnRDtrQkFBQSxPQUFBLDRCQURoREE7a0JBQ3lDLHdCQVgzQkY7a0JBV3NCLE9BQUE7a0JBQVgsd0JBWFhBLE9BVWRFLFNBQUFBO2tCQUdJOG9CO29CQUZJO3NCQVhhazhDLGFBV0Q7MEJBRWhCbDhDO2tCQURLO29CQVJNbm1CO29CQVFHOzswQkFDZG1tQixxQkFSQW1wQztrQkFXRTtvQkFaU3R2RDtvQkFhUDs7aUJBUFIsV0FBQTNDOzZCQUFBQTtpQkFBQUE7OztlQVNBLFdBakNGOHhELDBCQWNnQmh5RCxPQUFPa2xFO2NBbUJtQztJQWpCeEMsV0FoQmxCbFQsMEJBY2dCaHlELE9BQU9rbEU7R0FtQm9DO1lBSTNEOVMsSUFBSWgwRCxHQUFFMVQsR0FBRXc4QyxHQUFFcmtDO0lBQ1osSUFBSW11RCxLQTlHRkYsT0E2R0kxeUQsSUFFRjZ5RCxLQS9HRkgsT0E2R1VqdUQ7T0FHSiw0QkFESm91RCxTQURBRDtlQURFNXlEO01BTU8sT0FBQTtjQU5QQTtNQU9RLE1BQUE7S0FFTSxJQURFaTBELEtBUmhCajBELE1BUVlvbkUsS0FSWnBuRSxNQVFRazBELEtBUlJsMEQsTUFRSW0wRCxLQVJKbjBELE1BU2MsT0F0SGxCMHlELE9BcUhvQnVCO2dCQXJIcEJ2QixPQXFIUXlCLEtBRWUsT0F0RnZCajRELE9Bb0ZRaTRELElBQUlELElBQUlrVCxJQXBGaEJsckUsT0FvRm9CKzNELElBUmQzbkUsR0FBRXc4QyxHQUFFcmtDO2VBUVV3dkQ7TUFLTCxPQUFBO2NBTEtBO01BTTRDLElBQS9Db1QsTUFOR3BULE9BTVJNLE1BTlFOLE9BTTRDLE9BMUZoRS8zRCxVQTRFTTVQLEdBQUV3OEMsR0FBRXJrQztNQWNzRCxPQTFGaEV2SSxPQUFBQSxPQW9GUWk0RCxJQUFJRCxJQUFJa1QsUUFNSjdTLEtBQUs4Uzs7S0FFMEI7TUFEaEJqVCxNQVBQSDtNQU9FcVQsUUFQRnJUO01BT0hJLFFBUEdKO01BT1JLLE1BUFFMO01BUXVCLE9BNUYzQy8zRCxPQTJGMkJrNEQsS0FmckI5bkUsR0FBRXc4QyxHQUFFcmtDO0tBZ0JpQyxPQTVGM0N2SSxPQUFBQSxPQW9GUWk0RCxJQUFJRCxJQUFJa1QsSUFPSjlTLE1BQUtELE9BQUtpVDs7T0FFWCw0QkFoQlQxVSxVQUNBQyxJQTZCQyxPQTNHSDMyRCxPQTRFSThELEdBQUUxVCxHQUFFdzhDLEdBQUVya0M7Y0FBQUE7S0FvQkMsT0FBQTthQXBCREE7S0FxQkUsTUFBQTtJQUVNLElBREUrdkQsS0F0QlYvdkQsTUFzQk04aUUsS0F0Qk45aUUsTUFzQkVnd0QsS0F0QkZod0QsTUFzQkZpd0QsS0F0QkVqd0QsTUF1QlEsT0FwSWxCaXVELE9BbUlRZ0M7ZUFuSVJoQyxPQW1Jb0I4QixLQUViLE9BcEdQdDRELE9BQUFBLE9BNEVJOEQsR0FBRTFULEdBQUV3OEMsR0FzQkE0ckIsS0FBSUQsSUFBSThTLElBQUkvUztjQUFaRTtLQUtPLE9BQUE7YUFMUEE7S0FNcUQsSUFBNUM4UyxNQU5UOVMsT0FNSUksTUFOSkosT0FNcUQsT0F4RzdEeDRELFVBa0dZdTRELElBQUk4UyxJQUFJL1M7S0FNeUMsT0F4RzdEdDRELE9BQUFBLE9BNEVJOEQsR0FBRTFULEdBQUV3OEMsT0E0Qklnc0IsS0FBSzBTOztJQUV1QjtLQURiN1MsTUFQbkJEO0tBT2MrUyxRQVBkL1M7S0FPU0UsUUFQVEY7S0FPSUcsTUFQSkg7S0FRZ0MsT0ExR3hDeDRELE9BeUcyQnk0RCxLQVBmRixJQUFJOFMsSUFBSS9TO0lBUW9CLE9BMUd4Q3Q0RCxPQUFBQSxPQTRFSThELEdBQUUxVCxHQUFFdzhDLEdBNkJJK3JCLE1BQUtELE9BQUs2UztHQUVMOztJQXd1RGpCOVI7Ozs7Ozs7Ozs7WUFudURBNWtELGdCQUFXLHlDQUVEO1lBR1YyMkQsMEJBQTJCOTZDLEtBQUsrNkM7SUFDbEM7S0FDd0Qsd0JBQVMsV0FGL0JBLGFBQUwvNkM7S0FFM0IsT0FBQTtJQUFBLE9BQUE7R0FBb0Y7WUFXaEZnN0M7SUFDRTVxRSxHQUNDOEIsUUFDSXhTLEdBQ0p1N0UsTUFDQWYsYUFDQWEsYUFDQ0c7SUFFVixVQVJROXFFO0tBU0csZUFQRTFRLEdBQ0p1N0UsT0FNa0IsNEJBUmxCL29FO2FBREQ5QjtLQVdFLElBREM4ckMsSUFWSDlyQyxNQVVBdU8sSUFWQXZPLE1BV0Z3UCxJQUFJLFdBUERzNkQsYUFGSXg2RSxHQVFMaWY7S0FFTixTQURJaUI7YUFMSXM3RDs7U0E1TGQsT0FBQTs7U0FzTXFCLE9BOUJmSiwwQkFnQldwN0UsR0FHSnE3RTtpQkFZSSxlQWZBcjdFLEdBQ0p1N0UsT0FGQS9vRTs7aUJBVUgwTjs7c0JBREVqQixHQUFHdTlCLE9BUkV4OEMsR0FDSnU3RTtlQWlCcUMsNEJBbkJyQy9vRTs7dUJBQ0l4UyxHQUNKdTdFLE9BT0R0OEQsR0FBR3U5QjtlQVNtQyw0QkFsQnJDaHFDOztJQXFCQztLQURVbW5CLElBckJaanBCO0tBcUJTeUgsSUFyQlR6SDtLQXFCTStxRSxNQXJCTi9xRTtLQXFCRzBnQyxNQXJCSDFnQztLQXFCQWdELElBckJBaEQ7S0FzQkZ3aUIsTUFBSSxXQWxCRHNuRCxhQUZJeDZFLEdBbUJGb3hDO0lBRVQsU0FESWxlO1lBaEJJc29EOztRQTVMZCxPQUFBOztRQWlOcUIsT0F6Q2ZKLDBCQWdCV3A3RSxHQUdKcTdFO2dCQXVCSSxlQVBMM25FLEdBbkJLMVQsR0FDSnU3RSxNQWtCUXBqRSxHQUFHd2hCLElBcEJYbm5COztZQXFCSDBnQjtLQWVBO01BQUE7UUF0Q0Fvb0Q7VUFzQlduakUsR0FwQlIzRixRQUNJeFMsR0FDSnU3RSxNQUNBZixhQUNBYSxhQUNDRztNQThCQzF4RDtNQUFIcXdCO0tBR0osV0E5RkZ1dEIsSUE0RU1oMEQsR0FBRzA5QixLQUFHcXFDLEtBZU50aEMsTUFBR3J3Qjs7SUFKTDtLQUFBO09BakNBd3hEO1NBc0JFNW5FLEdBcEJDbEIsUUFDSXhTLEdBQ0p1N0UsTUFDQWYsYUFDQWEsYUFDQ0c7S0F5QkN6eEQ7S0FBSG9UO0lBR0osV0F6RkZ1cUMsSUFzRk12cUMsS0FWR2lVLEtBQUdxcUMsS0FBR3RqRSxJQVVONFI7R0FRYTtZQUd0QjJ4RCxRQUFRaHJFLEdBQUc4QixRQUFROHRCLEtBQUtpN0MsTUFBTWYsYUFBYWE7SUFDN0MsT0E1Q01DO2FBMkNJNXFFLEdBQUc4QixRQUFROHRCLEtBQUtpN0MsTUFBTWYsYUFBYWE7R0FDeUM7WUFHcEZNLGlCQUFpQmpyRSxHQUFHOEIsUUFBUTh0QixLQUFLaTdDLE1BQU1mLGFBQWFhO0lBQ3RELE9BaERNQzthQStDYTVxRSxHQUFHOEIsUUFBUTh0QixLQUFLaTdDLE1BQU1mLGFBQWFhO0dBUXhCO1lBRzVCeGpDLElBQUlubkMsR0FBRzhCLFFBQVE4dEIsS0FBS2k3QyxNQUFNZjtJQUM1QixPQTNETWM7YUEwREE1cUU7YUFBRzhCO2FBQVE4dEI7YUFBS2k3QzthQUFNZjs2QkFPSCxXQUFPOztHQUNmO1lBR2Z6TixNQUFLcjhELEdBQUU0dkIsS0FBSWk3QyxNQUFNZjtJQUFrQixXQVhuQzNpQyxJQVdLbm5DLE1BQUU0dkIsS0FBSWk3QyxNQUFNZjtJQUFrQixPQUFBO0dBQXlDO1lBVXhFb0I7SUFBd0I7S0FFbkIsT0FBQTtRQTNNS0wsaUJBQUpqN0M7SUFBVyxXQUFYQSxLQUFJaTdDO0dBMk1nRDtZQVExRE0sU0FBU25vRSxHQUFFeUUsR0FBSSxPQTNObkJ2SSxPQTJOYThELE1BQUFBLE1BQUFBLE1BQUV5RSxHQUF3QztZQUtuRGlHLEtBQUsxSyxHQUFFeUU7SUFBSSxXQUFKQSxhQUFBQTtJQUFJLFdBTFgwakUsU0FLS25vRSxHQUFFeUU7R0FBdUQ7WUFpQjFEMmpFLEdBQUdwckUsR0FBRTFRO0lBQ1gsT0FEUzBROztPQUVJLFdBRkpBLEdBQUUxUTs7V0FHREMsSUFIRHlRLE1BR0ZrRyxNQUhFbEcsTUFHTyxXQUFUa0csS0FBRzNXLEdBSENEOztXQUlFNGtCLE1BSkpsVSxNQUlDb3BCLElBSkRwcEIsTUFJRm1HLE1BSkVuRztPQUlVLFdBSmJvckUsR0FJQ2psRSxLQXJCTHVILEtBcUJRMGIsR0FBR2xWLE9BSkY1a0I7O0dBSXlDO1lBTHBEKzdFLGNBT0VyckUsR0FBRzR2QixLQUFLaTdDLE1BQVEsT0FOWk8sR0FNSnByRSxVQUFHNHZCLEtBQUtpN0MsT0FBNEM7WUFJaERTLEtBQUd0ckUsR0FBRXlIO0lBQ1gsSUFEU3ZCLE1BQUFsRyxHQUFFeXBDLE1BQUFoaUM7SUFDWDtZQURTdkI7O1FBRUksT0FGRnVqQzs7UUFHVSxJQUFYem1DLElBSERrRCxRQUFBQyxNQUFBRCxRQUFFd2pDLE1BaENUeWhDLFNBbUNRbm9FLEdBSEN5bUM7UUFBRnZqQyxNQUFBQztRQUFFc2pDLE1BQUFDOzs7UUFJYztTQUFYamQsTUFKTHZtQjtTQUlDaXhELEtBSkRqeEQ7U0FBQUUsTUFBQUY7U0FBRXFqQyxNQWhDVDRoQyxTQUtBejlELEtBK0JReXBELElBQUkxcUMsTUFKSGdkO1FBQUZ2akMsTUFBQUU7UUFBRXFqQyxNQUFBRjs7R0FJd0Q7WUFMbkVnaUM7SUFPRjs7T0FDYTs7V0FDSDlqRSxjQUFIekg7T0FBYyxPQVJic3JFLEtBUUR0ckUsR0FsREhrckUsc0JBa0RNempFOztXQUNHZ2lDLGdCQUFIem1DLGNBQUhrRDtPQUE0QixPQVQzQm9sRSxTQVNEcGxFLEtBQUdsRCxJQW5ETmtvRSxzQkFtRFN6aEM7O0dBQXdEO1lBR25FK2hDO0lBQVU7O09BQ0M7O1dBdkNEL2pFO21CQUFBQTs7SUF3Q29CLFdBeENwQkE7R0F3QzZDO1lBSXpEZ2tFLHVCQUF1QjVrQyxLQUFLaWpDO0lBQzlCLE9BQVk7YUFuVVo3OEQ7c0JBbVVtQks7Y0FBUDtlQUVSO2lCQUFBOzttQkFIcUJ1NUI7dUJBKzVEckIzRjs7b0JBejVESztxQkFBNkIycEM7cUJBQUxqN0M7cUJBQVQ5dEI7cUJBQVQ0cEU7cUJBQ0QsUUFiVkYsUUFZV0U7O3lCQUVBQztxQkFBYyxRQUFBLFdBUkM3QixhQVFmNkIsVUFGa0IvN0M7c0JBSXJCLE9BQUE7K0JBVE90aUI7K0JBU1A7OztvQkFDc0QsV0FBQSw0QkFMMUN4TDtvQkFLVCxXQXhDWHVwRSxjQW1DV0ssU0FBa0I5N0MsS0FBS2k3QzttQkFLdUM7ZUFUOUQvb0U7ZUFBVDRwRTtjQVdKLGVBaENFSCxrQkFxQkVHLFVBQVM1cEU7YUFXMkM7R0FBQTtZQU1wRDhwRSxPQUFLNW9FLEdBQUV3c0IsR0FBRXNjLEdBQUVya0MsR0FBR3FpRTtJQUNwQixVQURXOW1FLGdCQUVHLE9BM0ZacTVELE1BeUZlNTBELEdBQUorbkIsR0FBRXNjLEdBQUtnK0I7YUFBVDltRTtTQU1hZzFELEtBTmJoMUQsTUFNU2kwRCxLQU5UajBELE1BTUs2b0UsT0FOTDdvRSxNQU1DOG9FLE9BTkQ5b0UsTUFNSG0wRCxLQU5HbjBEO2VBQU15RTtlQUFBQTtXQUtGOGlFLEtBTEU5aUUsTUFLTnNrRSxLQUxNdGtFO09BS0ssT0E5RnBCNDBELE1BQUFBLE1BeUZTcjVELEdBQUV3c0IsR0FBRXNjLEdBQUtnK0IsY0FLVGlDLElBQUl4QixJQUxLVDs7VUFNK0I1UixLQU5sQ3p3RCxNQU04Qit2RCxLQU45Qi92RCxNQU0wQnVrRSxPQU4xQnZrRSxNQU1zQndrRSxPQU50QnhrRSxNQU1rQml3RCxLQU5sQmp3RDthQVFQLDRCQUZ5Q3l3RCxTQUEzQkY7Z0JBMU50QmhCLElBME5NRyxJQUFJMlUsTUFBSUQsTUFOVkQsT0FNYzNVLElBTlB6bkMsR0FBRXNjLEdBQUVya0MsR0FBR3FpRTtnQkFhTDttQ0FQUzlSO2tCQUEyQkU7a0JBMU5qRGxCLElBb05JNFUsT0FBSzVvRSxHQUFFd3NCLEdBQUVzYyxHQU1vQjRyQixJQU5mb1MsY0FNbUJtQyxNQUFJRCxNQUFJeFU7a0JBMU43Q1IsSUFvTlNoMEQsR0FBRXdzQixHQUFFc2MsR0FBRXJrQzs7O2NBQUFBLGdCQUdILE9BNUZaNDBELE1BeUZTcjVELEdBQUV3c0IsR0FBRXNjLEdBQUtnK0I7UUFJUk0sS0FKRHBuRSxNQUlIa3BFLEtBSkdscEU7SUFJVyxPQTdGcEJxNUQsTUFBQUEsTUF5RmU1MEQsR0FBSituQixHQUFFc2MsR0FBS2crQixjQUlab0MsSUFBSTlCLElBSlFOO0dBZUY7WUFHWjN5QixNQUFNbjNDLEdBQUUxUSxHQUFHdzZFO0lBQ2pCLFVBRFk5cEUsZ0JBRUQ7YUFGQ0E7S0FJQSxJQUREOHJDLElBSEM5ckMsTUFHSnd2QixJQUhJeHZCLE1BSU42eEIsTUFBTSxXQUpLaTRDLGFBQUh4NkUsR0FHTmtnQztLQUVOLGFBRElxQzs4QkFERXJDLEdBQUdzYztvQkFDTGphLFVBSk03eEIscUJBQUFBOztJQVdBO0tBREt5SCxJQVZMekg7S0FVRStxRSxNQVZGL3FFO0tBVUR1N0MsTUFWQ3Y3QztLQVVKZ0QsSUFWSWhEO0tBV05tc0UsUUFBTSxXQVhLckMsYUFBSHg2RSxHQVVIaXNEO0lBRVQsU0FESTR3QixPQUVDLFdBSENucEUsV0FBR3U0QyxLQUFHd3ZCLE9BQUd0akU7WUFDWDBrRTtLQVFrQjtNQUFBLFFBbkJsQmgxQixNQVVXMXZDLEdBVkhuWSxHQUFHdzZFO01BbUJFdFM7TUFBUGdEO01BQUo5QztLQUNKLFdBdENFa1UsT0E0QkU1b0UsR0FBR3U0QyxLQUFHd3ZCLEtBU05yVCxJQW5CU29TLGNBbUJMdFAsT0FBT2hEOztJQUhLO0tBQUEsVUFoQmxCcmdCLE1BVUVuMEMsR0FWTTFULEdBQUd3NkU7S0FnQkU3UztLQUFQbVY7S0FBSmpWO0lBQ0osV0FESUEsSUFBSWlWLFNBbENOUixPQWtDYTNVLElBTlIxYixLQUFHd3ZCLEtBQUd0akUsR0FWQXFpRTtHQW9CeUI7WUFHeEN1Qyw0QkFBNEJyc0UsR0FBR3NzRSxNQUFLaDlFLEdBQUd3NkU7SUFDekM7S0FBZ0MsUUF4QjFCM3lCLE1BdUJ3Qm4zQyxHQUFRMVEsR0FBR3c2RTtLQUNqQnZpQztLQUFkZ2xDO0tBQU5qbEM7SUFDSixLQURVaWxDLGNBRUEsV0FGTmpsQyxNQUFvQkM7a0JBQWRnbEMsaUJBR0cxQixtQkFBTGo3QzthQUNGNDhDLFlBQVk3UztLQUFXLFdBbEozQnh5QixJQWtKZ0J3eUIsU0FEVi9wQyxLQUFLaTdDLE1BSjRCZjtLQUtaLE9BQUE7SUFBNEM7SUFDdkUsb0JBTitCd0M7a0JBSzNCRSxZQUpGbGxDLE9BQW9CQztrQkFBcEJELE1BSUVrbEMsWUFKa0JqbEM7R0FPZTtZQUdyQ2tsQyxZQUNFenNFLEdBQ0UrYyxhQUNBQyxhQUNEOHNEO0lBRUwsR0FBRyxnQ0FKRy9zRCxhQUNBQyxhQUNEOHNEO0tBTUE7YUFxL0NIblI7YUFBQUE7YUFBQUE7Y0E3L0NJNTdDO1NBVU0ydkQsZ0JBWFIxc0UsR0FXRXNuQyxPQW0vQ0pxeEI7a0JBNy9DSTU3Qzs7TUFhSzR2RCxPQWJMNXZEO2FBYkpzdkQsNEJBWUVyc0UsY0FjTzJzRSxNQVhON0M7TUFRTzRDO01BQU5wbEM7OztNQUlLc2xDLE9BZEw3dkQ7YUFiSnN2RCw0QkFZRXJzRSxjQWVPNHNFLE1BWk45QztNQVFPK0M7TUFBTmhrQztNQUFNNmpDLGdCQUFBRztNQUFOdmxDLE9BQUF1QjtjQVRBN3JCO1NBZUt1cUIsUUE2K0NUb3hCLGdDQTcrQ0kxOUIsTUFOTXl4QztrQkFUTjF2RDs7TUFrQks4dkQsS0FsQkw5dkQ7O1FBZEpxdkQsNEJBdUJVSywwQkFTREksSUFqQk5oRDtNQWNNdmlDO01BQUx0TTs7O01BSUs4eEMsT0FuQkwvdkQ7O1FBZEpxdkQ7VUF1QlVLLDBCQVVESyxNQWxCTmpEO01BY01EO01BQUxtRDtNQUFLemxDLFFBQUFzaUM7TUFBTDV1QyxNQUFBK3hDO0lBT0osV0FiSTFsQyxNQU1Bck0sS0FBS3NNO0dBT1E7WUFHYnZ1QixLQUFLaFosR0FBRTFRLEdBQUd3NkU7SUFDaEIsSUFEVzVqRSxNQUFBbEc7SUFDWDtlQURXa0csa0JBRUE7Y0FGQUE7VUFHQTRsQyxJQUhBNWxDLFFBR0hxSSxJQUhHckk7TUFHUyxhQUFBLFdBSEo0akUsYUFBSHg2RSxHQUdMaWYsU0FBR3U5Qjs7S0FFRDtNQURPcmtDLElBSk52QjtNQUlHNmtFLE1BSkg3a0U7TUFJQXc2QixNQUpBeDZCO01BSUhsRCxJQUpHa0Q7TUFLTHNKLElBQUksV0FMTXM2RCxhQUFIeDZFLEdBSUZveEM7S0FFVCxTQURJbHhCLEdBQ1UsV0FGRnU3RDtTQUpIdGhDLFdBS0xqNkIsSUFEVy9ILElBQVR6RTtLQUpHa0QsTUFBQXVqQzs7R0FNNkQ7WUFHdEV3akMsVUFBVWp0RSxHQUFHOEIsUUFBUTh0QixLQUFLaTdDLE1BQU1mO0lBQ2xDO0tBQWdDLE9BVjFCOXdELEtBU01oWixHQUFXNHZCLEtBQVdrNkM7S0FDOUJvRCxhQUR3QnJDLE1BQ1Q7SUFDbkIsT0EvTEUxakMsSUE2TFVubkMsR0FBRzhCLFFBQVE4dEIsS0FDbkJzOUMsUUFEOEJwRDtHQUVHO1lBR25DcUQsV0FBV250RSxHQUFFMVEsR0FBR3c2RTtJQUNaLFlBZkE5d0QsS0FjT2haLEdBQUUxUSxHQUFHdzZFO2dCQUVSO1FBQ0g5bUU7SUFBSyxPQUFMQTtHQUFNO1lBSVQ4bkMsYUFBYWxiLEtBQUsrNkM7SUFDRCw0QkFBd0MsV0FEdkNBLGFBQUwvNkM7SUFDZixNQUFBO0dBQThFO0dBRWhGLFNBSkU1TCxTQUllaGtCLEdBQUUxUSxHQUFHdzZFLGFBQWFhO0lBQ2pDLElBRGV6a0UsTUFBQWxHO0lBQ2Y7ZUFEZWtHLGtCQUVKLE9BTFQ0a0MsYUFHZXg3QyxHQUFnQnE3RTtjQUFsQnprRTtVQUdKNGxDLElBSEk1bEMsUUFHUHFJLElBSE9ySTtNQUdLLGFBQUEsV0FIQTRqRSxhQUFIeDZFLEdBR1RpZjtnQkFBR3U5QjtnQkFOVGhCLGFBR2V4N0MsR0FBZ0JxN0U7O0tBS3ZCO01BRE9sakUsSUFKRnZCO01BSUQ2a0UsTUFKQzdrRTtNQUlKdzZCLE1BSkl4NkI7TUFJUGxELElBSk9rRDtNQUtUc0osSUFBSSxXQUxVczZELGFBQUh4NkUsR0FJTm94QztLQUVULFNBRElseEIsR0FDVSxPQUZGdTdEO1NBSkN0aEMsV0FLVGo2QixJQURXL0gsSUFBVHpFO0tBSk9rRCxNQUFBdWpDOztHQU1xRTtZQU1wRnB2QixJQUFJcmEsR0FBRTFRLEdBQUd3NkU7SUFBNkIsV0FwQ2xDOXdELEtBb0NBaFosR0FBRTFRLEdBQUd3NkU7SUFBNkIsT0FBQTtHQUF1QjtZQUV6RGx4RDtJQUFVO0lBQUE7cUNBQ0w7O1VBQ0FrekIsZ0JBQUh0YztNQUFTLGVBQVRBLEdBQUdzYzs7U0FFSDlvQztlQUFBQTtVQURVK25FLGtCQUFIeHZCO01BQWUsZUFBZkEsS0FBR3d2Qjs7ZUFDVi9uRTs7R0FBMkI7R0FHckM7SUFBQTs7Ozs7O0dBR0U7Ozs7OztNQUVFLDJDQUVJO01BQ0ssTUFBQTtLQUFhO0dBSzFCO0lBQUE7Ozs7OztHQUdFOzs7Ozs7TUFFRSwyQ0FFSTtNQUNLLE1BQUE7S0FBYTs7WUFLdEJvMUQsWUFBWXA0RDtJQUNSLFlBbENBNFksUUFpQ1E1WTs7S0FFSixNQUFBO1FBQ0h1TztJQUFLLE9BQUxBO0dBQU07WUFHUHVLO0lBQVU7SUFBQTtxQ0FDTDs7VUFDQWd6QixnQkFBSHRjO01BQVMsZUFBVEEsR0FBR3NjOzs7VUFDR2kvQixrQkFBSHh2QjtNQUFtQixlQUFuQkEsS0FBR3d2Qjs7U0FDR3RqRTtlQUFBQTs7R0FBa0I7WUFHakM4d0QsWUFBWXY0RDtJQUNSLFlBUkE4WSxRQU9ROVk7O0tBRUosTUFBQTtRQUNIdU87SUFBSyxPQUFMQTtHQUFNO1lBR1BpcUQsZUFBZXg0RDtJQUNyQixVQURxQkE7S0FFVixPQUFBO2FBRlVBLE1BR1Q7UUFFSmdELElBTGFoRDtjQUtiZ0Qsb0JBRGF5RSxJQUpBekgsTUFJUyxPQUFUeUg7UUFDSmdpQyxNQUxJenBDLE1BS1A4ckMsSUFMTzlyQyxNQUtWMVEsSUFMVTBRO0lBS0ssT0FuWXhCZzNELElBOFhJd0IsZUFLRXgxRCxJQUFHMVQsR0FBR3c4QyxHQUFHckM7R0FBcUM7WUFHcERwcUMsT0FBUSt0RSxZQUFZQyxZQUFZdkQ7SUFDbEMsSUFBTSxRQXRCQWh4RCxRQXFCSXMwRCxhQUNnQixVQTdEcEJ4MEQsUUE0RGdCeTBEO2dCQUVULGtCQUZTQTtrQkFHVCxrQkFISEQ7OztLQUk4QjcrRDtLQUFYKytEO0tBQXJCQztJQUF3QyxRQUFBLFdBSmR6RCxhQUkxQnlELFdBQXFCRCxZQUd0QjtJQUZ3QixJQUF6QkUseUJBYkFoVixlQVFnQjZVO0lBTXBCOztZQXhMSXpCO2NBa0xJd0IsWUFJbUJFLFdBQVcvK0QsR0FDbENpL0Qsd0JBTDRCMUQ7R0FPSjtZQUt0QjJELEtBQUd6dEUsR0FBR3ZRLEtBQUtELEtBQUtrUSxNQUFNTyxHQUFHNnBFO0lBQy9CLElBRFM1akUsTUFBQWxHLEdBQWEwNkQsU0FBQWg3RDtJQUN0QjtlQURTd0csa0JBRUUsT0FGV3cwRDtjQUFieDBEO1VBR0U0bEMsSUFIRjVsQyxRQUdEc3BCLElBSEN0cEI7TUFJcUI7YUFBekIsV0FKMEI0akUsYUFHdkJ0NkMsR0FISS8vQjtnQkFJa0IsV0FKQ3E2RSxhQUd2QnQ2QyxHQUhTaGdDO09BT1YsT0FBQSxXQVBxQnlRLEdBR3BCdXZCLEdBQUdzYyxHQUhXNHVCO01BTWxCLE9BTmtCQTs7S0FTUjtNQVRManpELElBQUF2QjtNQVFLNmtFLE1BUkw3a0U7TUFRRXExQyxNQVJGcjFDO01BUURsRCxJQVJDa0Q7TUFTSHduRSxRQUFRLFdBVGlCNUQsYUFRcEJ2dUIsS0FSQzlyRDtLQVVWLFFBRElpK0U7ZUFBQUE7T0FRbUIsSUFqQkhDLFNBaUJHLFdBakJHMXRFLEdBUWpCczdDLEtBQUd3dkIsS0FSUXJRO09BQWJ4MEQsTUFBQXVCO09BQWFpekQsU0FBQWlUOzs7T0FvQlY7UUFBSnZrRCxJQXBCRnFrRCxLQVFFenFFLEdBUkl2VCxLQUFLRCxLQUFLa3JFLFFBQU16NkQsR0FBRzZwRTtRQXFCdkI4RCxRQUFRLFdBckJlOUQsYUFRcEJ2dUIsS0FSTS9yRDtPQXVCYixPQUZJbytFLE9BR0MsT0FKRHhrRDtPQU1NLElBMUJReWtELFNBMEJSLFdBMUJjNXRFLEdBUWpCczdDLEtBQUd3dkIsS0FZTjNoRDtPQVFGLFNBUEV3a0QsT0FPZ0IsT0E1QkZDO09BQWIzbkUsTUFBQXVCO09BQWFpekQsU0FBQW1UOzs7TUFBYjNuRSxNQUFBdUI7O0dBNEI4RDtZQTlCdkVxbUUscUJBZ0NFOXRFLEdBQUd2USxLQUFLRCxLQUFLa1EsTUFBTU8sR0FBRzZwRTtJQUN4QixXQUFHLFdBRHFCQSxhQUFuQnI2RSxLQUFLRDtjQUFLa1E7Y0E5QlQrdEUsS0E4Qkp6dEUsR0FBR3ZRLEtBQUtELEtBQUtrUSxNQUFNTyxHQUFHNnBFO0dBQ3VEO1lBRy9FaUUsZUFBZS90RSxHQUFHdlEsS0FBS0QsS0FBS3M2RTtJQUU1Qjs7T0F0Q0FnRTtTQW9DZTl0RTtTQUFHdlE7U0FBS0Q7O2tCQU9Yb2dDLEtBQUtpN0MsTUFBSzduRSxHQUFLLGVBQWY0c0IsS0FBS2k3QyxPQUFLN25FLEdBQXFCO1NBUGY4bUU7SUFFNUIsT0FBQTtHQU1nQjtZQUdoQmtFLGlCQUFpQjVzRSxJQUFHQztJQUN0QixVQURtQkQsaUJBRUwsT0FGUUM7Y0FBQUEsaUJBR1IsT0FIS0Q7SUFLTixJQUFBLFFBekZYZzNELFlBb0ZvQi8yRCxLQUtieXFDLGNBQUh4OEM7SUFDTyxPQXJjWDBuRSxJQStiaUI1MUQsSUFLYjlSLEdBQUd3OEMsR0F0RUgwc0IsZUFpRWdCbjNEO0dBTVU7R0FHbEM7O1lBRUk2dUIsT0FBT2x3QixHQUFFMVEsR0FBR3dTLFFBQVFnb0U7YUFDZG1FLFlBQVlqdUUsR0FBRTFRLEdBQUd3UyxRQUFRZ29FO0tBQy9CLFVBRGtCOXBFLGdCQUh0QixPQUFBO2NBR3NCQTtVQUdWdU8sSUFIVXZPO01BSWIsYUFBQSxXQUowQjhwRSxhQUFYeDZFLEdBR1ppZjt1QkFFTSw0QkFMU3pNO2dCQUgzQjs7S0FXYztNQURPMkYsSUFQQ3pIO01BT0o4ckMsSUFQSTlyQztNQU9QMGdDLE1BUE8xZ0M7TUFPVmdELElBUFVoRDtNQVFad1AsSUFBSSxXQVJxQnM2RCxhQUFYeDZFLEdBT1RveEM7S0FFVCxTQURJbHhCO01BRXVCLFdBQUEsNEJBVk4xTjtNQVVoQixXQXRCUGtzRSxpQkFtQlFockUsR0FBU3lFOzthQUNYK0g7TUFRYztPQUFBLFFBaEJkeStELFlBT1d4bUUsR0FQR25ZLEdBQUd3UyxRQUFRZ29FO09BZ0JwQjF3RDtPQUFIcXdCO01BQ0osV0E1ZEp1dEIsSUFrZFFoMEQsR0FBRzA5QixLQUFHb0wsR0FTTnJDLE1BQUdyd0I7O0tBSFM7TUFBQSxVQWJkNjBELFlBT0VqckUsR0FQWTFULEdBQUd3UyxRQUFRZ29FO01BYXBCendEO01BQUhvVDtLQUNKLFdBemRKdXFDLElBd2RRdnFDLEtBTkdpVSxLQUFHb0wsR0FBR3JrQyxJQU1ONFI7SUFJYTtJQUUxQixJQUFJLFdBbkJJNDBELFlBRENqdUUsR0FBRTFRLEdBQUd3UyxRQUFRZ29FLGNBb0JsQjs7OytCQUNjLFdBckJUOXBFLEdBQUs4Qjs7O0dBcUJhO0dBSTdCO0lBQUE7Ozs7Ozs7Ozs7O1lBRUlvc0UsT0FBT2x1RSxHQUFFNHZCLEtBQUszdkIsR0FBRzZCLFFBQVFnb0U7YUFDbkJxRSxZQUFZbnVFLEdBQUU0dkIsS0FBSTN2QjtLQUN4QixVQURrQkQ7TUFHVCxZQUFBLFdBSGVDO2tCQUlYLE1BQUE7VUFDSDRxRTtNQUFRLGVBTEVqN0MsS0FLVmk3QyxPQUEwQiw0QkFObkIvb0U7O2NBQ0M5QjtNQU9SLElBREM4ckMsSUFOTzlyQyxNQU1WdU8sSUFOVXZPLE1BT1p3UCxJQUFJLFdBUmVzNkQsYUFDTGw2QyxLQU1acmhCO01BRU4sU0FESWlCO09BR0ksY0FBQSxXQVZjdlAsT0FNYjZyQztxQkFLRyxjQUFPLDRCQVpKaHFDO1dBYU5pcEU7T0FBTSxlQU5UeDhELEdBTUd3OEQsTUFiTWpwRTs7Y0FRWDBOO09BV2M7UUFBQSxVQWxCZDIrRCxlQUFjditDLEtBQUkzdkI7UUFrQmJtWjtRQUFIM1I7T0FDSixXQXpmSnV2RCxPQTRlUXpvRCxHQUFHdTlCLEdBWUhya0MsSUFBRzJSOztNQUhTO09BQUEsVUFmZCswRCxlQUFjditDLEtBQUkzdkI7T0FlYm9aO09BQUhyVztNQUNKLFdBdGZKZzBELElBcWZRaDBELEdBVEF1TCxHQUFHdTlCLE9BU0F6eUI7O0tBTUQ7TUFEVTRQLElBcEJGanBCO01Bb0JEeXBDLE1BcEJDenBDO01Bb0JKb3VFLE1BcEJJcHVFO01Bb0JQMGdDLE1BcEJPMWdDO01Bb0JWeXNCLE1BcEJVenNCO01BcUJad2lCLE1BQUksV0F0QmVzbkQsYUFDTGw2QyxLQW9CVDhRO0tBRVQsU0FESWxlO01BR0ksY0FBQSxXQXhCY3ZpQixPQW9CVm11RTs7V0FNSGxCO09BQVEsZUFOWHpnRCxLQXBCWW1ELEtBMEJUczlDLFFBTk16akMsS0FBR3hnQixJQXJCSG5uQjs7TUEwQm1CLFdBQUEsNEJBMUJuQkE7TUEwQkgsV0FoRWRrc0UsaUJBMkRRdmhELEtBQVNnZDs7YUFDWGpuQjtNQVdjO09BQUEsVUFoQ2QyckQsWUFvQlcxa0MsS0FwQkc3WixLQUFJM3ZCO09BZ0Nib3VFO09BQUgza0M7TUFDSixXQXZnQkpzdEIsSUEwZlF2cUMsS0FBR2lVLEtBQUcwdEMsS0FZTjFrQyxNQUFHMmtDOztLQUhTO01BQUEsVUE3QmRGLFlBb0JFMWhELEtBcEJZbUQsS0FBSTN2QjtNQTZCYnF1RTtNQUFIMTlDO0tBQ0osV0FwZ0JKb21DLElBbWdCUXBtQyxLQVRHOFAsS0FBRzB0QyxLQUFHM2tDLE1BU042a0M7SUFJYTtJQUUxQixJQUFJLFdBbkNJSCxZQURDbnVFLEdBQUU0dkIsS0FBSzN2QixJQW9DWjs7OytCQUNjLFdBckNURCxHQUFVOEI7OztHQXFDUTtZQUd6QnlzRSxPQUFPdnVFLEdBQUU0dkIsS0FBSzN2QixHQUFHNkIsUUFBUWdvRTthQUNuQjBFLFlBQVl4dUUsR0FBRTR2QixLQUFJM3ZCO0tBQ3hCLFVBRGtCRDtNQUdMLElBQVA2cUUsT0FBTyxXQUhXNXFFO01BSXRCLGVBSmtCMnZCLEtBR2RpN0MsT0FDYyw0QkFMSC9vRTs7Y0FDQzlCO01BTVIsSUFEQzhyQyxJQUxPOXJDLE1BS1Z1TyxJQUxVdk8sTUFNWndQLElBQUksV0FQZXM2RCxhQUNMbDZDLEtBS1pyaEI7TUFFTixTQURJaUI7T0FHTyxJQUFMdTdELE1BQUssV0FUVzlxRSxPQUtiNnJDO09BS1AsZUFMSXY5QixHQUlBdzhELE1BVlNqcEU7O2NBT1gwTjtPQVVjLElBQUEsUUFoQmRnL0QsZUFBYzUrQyxLQUFJM3ZCLElBZ0JibVoscUJBQUgzUjtPQUNKLFdBL2hCSnV2RCxPQW1oQlF6b0QsR0FBR3U5QixHQVdIcmtDLElBQUcyUjs7TUFIUztPQUFBLFVBYmRvMUQsZUFBYzUrQyxLQUFJM3ZCO09BYWJvWjtPQUFIclc7TUFDSixXQTVoQkpnMEQsSUEyaEJRaDBELEdBUkF1TCxHQUFHdTlCLE9BUUF6eUI7O0tBTUQ7TUFEVTRQLElBbEJGanBCO01Ba0JEeXBDLE1BbEJDenBDO01Ba0JKb3VFLE1BbEJJcHVFO01Ba0JQMGdDLE1BbEJPMWdDO01Ba0JWeXNCLE1BbEJVenNCO01BbUJad2lCLE1BQUksV0FwQmVzbkQsYUFDTGw2QyxLQWtCVDhRO0tBRVQsU0FESWxlO01BR1MsSUFBUDBxRCxTQUFPLFdBdEJTanRFLE9Ba0JWbXVFO01BS1YsZUFMSTNoRCxLQWxCWW1ELEtBc0JaczlDLFFBSlN6akMsS0FBR3hnQixJQW5CSG5uQjs7YUFvQlgwZ0I7TUFVYztPQUFBLFVBN0JkZ3NELFlBa0JXL2tDLEtBbEJHN1osS0FBSTN2QjtPQTZCYm91RTtPQUFIM2tDO01BQ0osV0E1aUJKc3RCLElBZ2lCUXZxQyxLQUFHaVUsS0FBRzB0QyxLQVdOMWtDLE1BQUcya0M7O0tBSFM7TUFBQSxVQTFCZEcsWUFrQkUvaEQsS0FsQlltRCxLQUFJM3ZCO01BMEJicXVFO01BQUgxOUM7S0FDSixXQXppQkpvbUMsSUF3aUJRcG1DLEtBUkc4UCxLQUFHMHRDLEtBQUcza0MsTUFRTjZrQztJQUlhO0lBRTFCLE9BaENRRSxZQURDeHVFLEdBQUU0dkIsS0FBSzN2QjtHQWlDRztZQUdqQnd1RSxhQUFhenVFLEdBQUU0dkIsS0FBSzl0QixRQUFRZ29FO0lBQzlCLE9BN0VFb0U7YUE0RWFsdUU7YUFBRTR2Qjs7Y0FDb0I7OztvQkFFdEI4K0M7bUJBQUFBLGdCQUErQixXQUEvQkE7OztjQURpQjthQUNrQzthQUg1QzVzRTthQUFRZ29FO0dBR29DO1lBRzVENkUsVUFBVTN1RSxHQUFHQztJQUNuQixJQURnQmlHLE1BQUFsRztJQUNoQjtlQURnQmtHLGtCQUVMO2NBRktBLFlBR1JxSSxJQUhRckksUUFHQyxPQUFBLFdBSEVqRyxHQUdYc087U0FIUTlHLElBQUF2QixRQUlMdzZCLE1BSkt4NkIsUUFJUmxELElBSlFrRDtLQUFWeW9FLFVBSUUzckUsR0FKVy9DO0tBTWpCLFdBTmlCQSxHQUlSeWdDO0tBSkt4NkIsTUFBQXVCOztHQU9BO1lBR1Z0SCxLQUFLSCxHQUFHQztJQUNkLElBRFdpRyxNQUFBbEc7SUFDWDtlQURXa0csa0JBRUE7Y0FGQUEsWUFHQTRsQyxJQUhBNWxDLFFBR00sT0FBQSxXQUhIakcsR0FHSDZyQztTQUhBcmtDLElBQUF2QixRQUlHNmtFLE1BSkg3a0UsUUFJSGxELElBSkdrRDtLQUFML0YsS0FJRTZDLEdBSk0vQztLQU1aLFdBTllBLEdBSUE4cUU7S0FKSDdrRSxNQUFBdUI7O0dBT0E7WUFHTHJILE1BQU1KLEdBQUdDO0lBQ2YsSUFEWWlHLE1BQUFsRztJQUNaO2VBRFlrRyxrQkFFRDtjQUZDQSxZQUdENGxDLElBSEM1bEMsUUFHSnFJLElBSElySSxRQUdLLE9BQUEsV0FIRmpHLEdBR1BzTyxHQUFHdTlCO1NBSENya0MsSUFBQXZCLFFBSUU2a0UsTUFKRjdrRSxRQUlEdzZCLE1BSkN4NkIsUUFJSmxELElBSklrRDtLQUFOOUYsTUFJRTRDLEdBSk8vQztLQU1iLFdBTmFBLEdBSUp5Z0MsS0FBR3FxQztLQUpGN2tFLE1BQUF1Qjs7R0FPQTtZQUlKbW5FLGlCQUFpQjV1RSxHQUFHQztJQUMxQixJQUR1QmlHLE1BQUFsRztJQUN2QjtlQUR1QmtHLGtCQUVaO2NBRllBLFlBR1o0bEMsSUFIWTVsQyxRQUdmcUksSUFIZXJJLFFBR04sT0FBQSxXQUhTakcsR0FHbEJzTyxHQUFHdTlCO1NBSFlya0MsSUFBQXZCLFFBSVQ2a0UsTUFKUzdrRSxRQUladzZCLE1BSll4NkIsUUFJZmxELElBSmVrRDtRQUFqQjBvRSxpQkFJRTVyRSxHQUprQi9DLElBTWI7UUFFRCxXQVJjQSxHQUlmeWdDLEtBQUdxcUMsTUFLRTtLQVRPN2tFLE1BQUF1Qjs7R0FVb0I7WUFYM0NvbkUsWUFhRTd1RSxHQUFHQztJQUFnRCxXQVovQzJ1RSxpQkFZSjV1RSxHQUFHQztJQUFnRCxPQUFBO0dBQXVCO1lBR3hFSSxJQUFJTCxHQUFHQztJQUNiLFVBRFVELGdCQUVDO2FBRkRBLFVBR0M4ckMsSUFIRDlyQyxNQUdGdU8sSUFIRXZPLE1BR08sV0FBVHVPLEdBQWtCLFdBSGJ0TyxHQUdGNnJDO0lBRUE7S0FEUzdpQixJQUpWanBCO0tBSU95SCxJQUpQekg7S0FJSStxRSxNQUpKL3FFO0tBSUMwZ0MsTUFKRDFnQztLQUlGZ0QsSUFKRWhEO0tBS0p5c0IsTUFMQXBzQixJQUlFMkMsR0FKSy9DO0tBTVBtdUUsTUFBSyxXQU5FbnVFLEdBSUM4cUU7S0FHUnRoQyxNQVBBcHBDLElBSVdvSCxHQUpKeEg7SUFRWCxXQUhJd3NCLEtBREtpVSxLQUVMMHRDLEtBQ0Eza0MsS0FIY3hnQjtHQUlLO1lBR25CM29CLEtBQUtOLEdBQUdDO0lBQ2QsVUFEV0QsZ0JBRUE7YUFGQUE7U0FHQThyQyxJQUhBOXJDLE1BR0h1TyxJQUhHdk87S0FHTSxXQUFUdU8sR0FBa0IsV0FIWnRPLEdBR05zTyxHQUFHdTlCOztJQUVBO0tBRFM3aUIsSUFKVGpwQjtLQUlNeUgsSUFKTnpIO0tBSUcrcUUsTUFKSC9xRTtLQUlBMGdDLE1BSkExZ0M7S0FJSGdELElBSkdoRDtLQUtMeXNCLE1BTEFuc0IsS0FJRTBDLEdBSk0vQztLQU1SbXVFLE1BQUssV0FOR251RSxHQUlIeWdDLEtBQUdxcUM7S0FHUnRoQyxNQVBBbnBDLEtBSVdtSCxHQUpIeEg7SUFRWixXQUhJd3NCLEtBREtpVSxLQUVMMHRDLEtBQ0Eza0MsS0FIY3hnQjtHQUlLO1lBR25CbHBCLEtBQUtDLEdBQVEyakIsTUFBTTFqQjtJQUN6QixJQURXaUcsTUFBQWxHLEdBQVEwN0QsU0FBQS8zQztJQUNuQjtlQURXemQsa0JBRUEsT0FGUXcxRDtjQUFSeDFEO1VBR0E0bEMsSUFIQTVsQyxRQUdIcUksSUFIR3JJO01BR00sT0FBQSxXQUhRakcsR0FHakJzTyxHQUFHdTlCLEdBSFE0dkI7O0tBSXVCO01BSi9CajBELElBQUF2QjtNQUlHNmtFLE1BSkg3a0U7TUFJQXc2QixNQUpBeDZCO01BSUhsRCxJQUpHa0Q7TUFBUXkxRCxTQUl1QixXQUpqQjE3RCxHQUlkeWdDLEtBQUdxcUMsS0FKUmhyRSxLQUlFaUQsR0FKVzA0RCxRQUFNejdEO0tBQWRpRyxNQUFBdUI7S0FBUWkwRCxTQUFBQzs7R0FJZ0U7WUFHakZqakQsV0FBVzFZLEdBQUdOLE1BQU1PLEdBQUcwWTtJQUN6QixTQUFRbTJELGdCQUFnQjl1RSxHQUFHd1ksS0FBS3ZZO0tBQzlCLElBRHNCaUcsTUFBQWxHLEdBQUdrcUIsUUFBQTFSO0tBQ3pCO2dCQURzQnRTLGtCQUVYLFdBRmNna0I7ZUFBSGhrQjtXQUdYNGxDLElBSFc1bEMsUUFHZHFJLElBSGNySTtPQUdMLE9BQUEsV0FIYWpHLEdBR3RCc08sR0FBR3U5QixHQUhjNWhCOztNQUtoQjtPQUxhemlCLElBQUF2QjtPQUlSNmtFLE1BSlE3a0U7T0FJWHc2QixNQUpXeDZCO09BSWRsRCxJQUpja0Q7T0FLYixRQUxING9FLGdCQUlFOXJFLEdBSmlCa25CLE9BQUtqcUI7NkJBTXBCOHVFLG9CQUFTLFdBQVRBO01BRUUsSUFERTVrRCxrQkFDRixVQUFBLFdBUmtCbHFCLEdBSW5CeWdDLEtBQUdxcUMsS0FHQTVnRDsrQkFFRDZrRCxzQkFBUyxXQUFUQTtVQVRZeGhCO01BQUh0bkQsTUFBQXVCO01BQUd5aUIsUUFBQXNqQzs7SUFVMEI7SUFFL0MsWUFaRXNoQixnQkFESzl1RSxHQUFHTixNQUFNTzsyQkFjWHVZLGdCQUFPLE9BQUEsV0FkT0csUUFjZEg7UUFDSnFDO0lBQVEsT0FBUkE7R0FBWTtZQUdiM2EsV0FBV0YsR0FBUTJqQixNQUFNMWpCO0lBQy9CLElBRGlCaUcsTUFBQWxHLEdBQVEwN0QsU0FBQS8zQztJQUN6QjtlQURpQnpkLGtCQUVOLE9BRmN3MUQ7Y0FBUngxRDtVQUdONGxDLElBSE01bEMsUUFHVHFJLElBSFNySTtNQUdBLE9BQUEsV0FIY2pHLEdBR3ZCc08sR0FBR3U5QixHQUhjNHZCOztLQUtEO01BRFBqMEQsSUFKQXZCO01BSUg2a0UsTUFKRzdrRTtNQUlOdzZCLE1BSk14NkI7TUFBQWxELElBQUFrRDtNQUFReTFELFNBS0QsV0FMTzE3RCxHQUlwQnlnQyxLQUFHcXFDLEtBSlI3cUUsV0FJV3VILEdBSlFpMEQsUUFBTXo3RDtLQUFkaUcsTUFBQWxEO0tBQVEwNEQsU0FBQUM7O0dBSzhDO1lBR3JFc1QsWUFBWWp2RSxHQUFHQyxHQUFHNnBFO0lBQ3BCLE9BbENNL3BFO2FBaUNRQzs7c0JBQ21CNHZCLEtBQUtpN0M7Y0FBWCxJQUF1Qi9vRSxtQkFBTjZoQjtjQUN2QyxPQUFBLFdBRlkxakIsR0FDZ0IydkI7d0JBN2lCL0J1WCxJQTZpQjBDeGpCLE1BQU03aEIsUUFBakI4dEIsS0FBS2k3QyxNQURsQmY7NEJBQ3dCbm1ELE1BQU03aEI7YUFDeUI7R0FBQTtZQUl6RThoQixPQUFPNWpCLEdBQUdDLEdBQUc2cEU7SUFDZixPQXhDTS9wRTthQXVDR0M7O3NCQUN3QjR2QixLQUFLaTdDO2NBQVgsSUFBdUIvb0UsbUJBQU42aEI7Y0FDdkMsT0FBQSxXQUZPMWpCLEdBQzBCNHFFO3dCQW5qQnBDMWpDLElBbWpCMEN4akIsTUFBTTdoQixRQUFqQjh0QixLQUFLaTdDLE1BRHZCZjs0QkFDNkJubUQsTUFBTTdoQjthQUMwQjtHQUFBO1lBRzFFNm5CLFFBQVEzcEIsR0FBR0MsR0FBRzZwRTtJQUNoQixPQTdDTS9wRTthQTRDSUM7O3NCQUN1QjR2QixLQUFLaTdDO2NBQVgsSUFBdUIvb0UsbUJBQU42aEI7Y0FDdkMsT0FBQSxXQUZRMWpCLEdBQ29CMnZCLEtBQUtpN0M7d0JBeGpCcEMxakMsSUF3akIwQ3hqQixNQUFNN2hCLFFBQWpCOHRCLEtBQUtpN0MsTUFEdEJmOzRCQUM0Qm5tRCxNQUFNN2hCO2FBQ2dDO0dBQUE7WUFHaEY0ckIsV0FBVzF0QixHQUFHQyxHQUFHNnBFO0lBQ25CLE9BbERNL3BFO2FBaURPQzs7c0JBQ29CNHZCLEtBQUtpN0M7Y0FBWDtlQUF1Qi9vRTtlQUFONmhCO2VBQ3BDLFFBQUEsV0FGUTFqQixHQUNzQjRxRTswQkFFMUIsV0FGZ0NsbkQsTUFBTTdoQjtrQkFHekN1QjtjQUFLLE9BaGtCWjhqQyxJQTZqQjBDeGpCLE1BQU03aEIsUUFBakI4dEIsS0FHeEJ2c0IsR0FKVXltRTthQUlzQztHQUFBO1lBR3ZEajhDLFlBQVk3dEIsR0FBR0MsR0FBRzZwRTtJQUNwQixPQXpETS9wRTthQXdEUUM7O3NCQUNtQjR2QixLQUFLaTdDO2NBQVg7ZUFBdUIvb0U7ZUFBTjZoQjtlQUNwQyxRQUFBLFdBRlMxakIsR0FDZ0IydkIsS0FBS2k3QzswQkFFMUIsV0FGZ0NsbkQsTUFBTTdoQjtrQkFHekN1QjtjQUFLLE9BdmtCWjhqQyxJQW9rQjBDeGpCLE1BQU03aEIsUUFBakI4dEIsS0FHeEJ2c0IsR0FKV3ltRTthQUlxQztHQUFBO1lBR3ZEb0YsZUFBZWx2RSxHQUFHQyxHQUFHNnBFO0lBQ3ZCLE9BaEVNL3BFO2FBK0RXQzs7c0JBSU40dkIsS0FBS2k3QztjQUFYO2VBQXdCc0U7ZUFBUEM7ZUFDWCxRQUFBLFdBTFNudkUsR0FJVDJ2QixLQUFLaTdDOztlQUdWLElBRE12N0UsY0FDQ3dTLFNBSFNzdEUsVUFHWnB2RSxJQUhZb3ZFO2VBSWhCLFdBbGxCSmpvQyxJQWlsQlFubkMsR0FBRzhCLFFBSEY4dEIsS0FFQ3RnQyxHQU5XdzZFLGNBSU1xRjs7Y0FNdkIsSUFETzUvRSxjQUNBNnBCLFdBTmdCKzFELFVBTW5CanBFLE1BTm1CaXBFO2NBT3ZCLFdBUGdCQyxPQTlrQnBCam9DLElBb2xCUWpoQyxLQUFHa1QsVUFORndXLEtBS0VyZ0MsR0FUVXU2RTthQVc4QjtHQUFBO1lBR25EOTFELGNBQWNoVSxHQUFHQyxHQUFHNnBFO0lBQ3RCLE9BZkVvRjthQWNjbHZFOzZCQUM4QjZxRSxNQUFRLE9BQUEsV0FEbkM1cUUsR0FDMkI0cUUsTUFBYzthQUR0Q2Y7R0FDdUM7WUFHM0QxK0IsY0FBY3ByQyxHQUFHQyxHQUFHNnBFO0lBQ3RCLE9BbkJFb0Y7YUFrQmNsdkU7c0JBQ3VCNHZCLEtBQUtpN0M7Y0FDMUMsT0FBRyxXQUZjNXFFLEdBQ29CMnZCLEtBQUtpN0MsWUFBQUEsWUFBQUE7YUFDTTthQUY1QmY7R0FFNkI7WUFHakQzN0MsYUFBYW51QixHQUFHQyxHQUFHNnBFO0lBQ3JCLE9BeEJFb0Y7YUF1QmFsdkU7NkJBQytCNnFFO2NBQzVDLE9BQUcsV0FGYTVxRSxHQUM0QjRxRSxZQUFBQSxZQUFBQTthQUNGO2FBRnZCZjtHQUV3QjtZQVdyQ3Y0QyxLQUFLdnhCLEdBQUc2RTtJQUNkLElBRFdxQixNQUFBbEcsR0FBRzBmLE1BQUE3YTtJQUNkO2VBRFdxQixrQkFFQSxPQUZHd1o7Y0FBSHhaLFlBR0E0bEMsSUFIQTVsQyxRQUdIcUksSUFIR3JJLFFBR00sV0FBVHFJLEdBQUd1OUIsTUFIR3BzQjtLQUltQjtNQUFoQmpZLElBSk52QjtNQUlHNmtFLE1BSkg3a0U7TUFJQXc2QixNQUpBeDZCO01BQUFsRCxJQUFBa0Q7TUFBR3F6RCxVQUlINzRCLEtBQUdxcUMsS0FBR3RqRSxHQUpIaVk7S0FBSHhaLE1BQUFsRDtLQUFHMGMsTUFBQTY1Qzs7R0FJc0M7WUFHOUNDLFdBQVd4NUQsR0FBRzZFO0lBQ3BCLElBRGlCcUIsTUFBQWxHLEdBQUcwZixNQUFBN2E7SUFDcEI7ZUFEaUJxQixrQkFFTixPQUZTd1o7Y0FBSHhaLFlBR040bEMsSUFITTVsQyxRQUdUcUksSUFIU3JJLFFBR0EsV0FBVHFJLEdBQUd1OUIsTUFIU3BzQjtLQUltQjtNQUp0QmpZLElBQUF2QjtNQUlINmtFLE1BSkc3a0U7TUFJTnc2QixNQUpNeDZCO01BSVRsRCxJQUpTa0Q7TUFBR3F6RCxVQUlUNzRCLEtBQUdxcUMsS0FBTi9uRSxHQUpZMGM7S0FBSHhaLE1BQUF1QjtLQUFHaVksTUFBQTY1Qzs7R0FJc0M7WUFHeERrSixRQUFROUksTUFBOEIsT0FkbENwb0MsS0FjSW9vQyxTQUEyQztZQTJEL0N2L0MsYUFBWW5hO1FBQU55NkQ7O21CQUNILE9BREdBO0tBR0M7TUFEWWhCO01BQU5DO01BQU5rUjtNQUFMajdDO01BQ0YwUCxPQUFPLFdBSEtyL0IsR0FFVjJ2QixLQUFLaTdDLE1BRkRuUTtLQUFBQSxTQUdOcDdCO2VBNUVBL04sS0EyRWFvb0MsTUFBTUQ7OztZQUt2QnYyQyxNQUFNMm1ELGFBQ0sxb0UsSUFBR0MsSUFBRzNCLE1BRGNPO0lBQ2pDOztTQUFhaWIsT0FBQTlaLElBQUcrWixPQUFBOVosSUFBR2d1RSxPQUFBM3ZFO0tBQ2pCO1dBRFd3YjtXQUFHQztNQVFTO09BRDZCNitDLFFBUHRDNytDO09BTytCOCtDLFFBUC9COStDO09BTzJCaXJCLEtBUDNCanJCO09BT3VCbTBELEtBUHZCbjBEO09BT1MyK0MsUUFQWjUrQztPQU9LNitDLFFBUEw3K0M7T0FPQ21yQixLQVBEbnJCO09BT0hpdkQsS0FQR2p2RDtPQVFMZy9DLGlCQUFpQixXQVRqQjRQLGFBUUVLLElBQTZCbUY7TUFFbkMsU0FESXBWO09BR1M7UUFYRTU2QixPQVdGLFdBWmdCci9CLEdBUXZCa3FFLHVCQUFJOWpDLElBQTZCRCxNQVB4QmlwQztRQUFIdjlDLE9BakZWUCxLQXdGeUMwb0MsT0FBT0Q7UUFQekNqb0MsT0FqRlBSLEtBd0ZZd29DLE9BQU9EO09BUFo1K0MsT0FBQTZXO09BQUc1VyxPQUFBMlc7T0FBR3U5QyxPQUFBL3ZDOzttQkFRWDQ2QjtPQVVTO1FBbEJFLzRCLFNBa0JGLFdBbkJnQmxoQyxHQVFNcXZFLG1CQUFJbHBDLEtBUHhCaXBDO1FBQUgvVCxPQWpGVi9wQyxLQXdGeUMwb0MsT0FBT0Q7T0FQdEM3K0MsT0FBQW1nRDtPQUFHK1QsT0FBQWx1Qzs7O09BZUY7UUFmRW91QyxTQWVGLFdBaEJnQnR2RSxHQVF2QmtxRSxtQkFBSTlqQyxLQVBLZ3BDO1FBQU45VCxPQWpGUGhxQyxLQXdGWXdvQyxPQUFPRDtPQVBaNStDLE9BQUFxZ0Q7T0FBTThULE9BQUFFOzs7WUFBSHAwRDtlQVJWZjtnQkFRYWkxRDt5QkFJYXovQyxLQUFLaTdDLE1BQUtyeUQ7aUJBQU8sT0FBQSxXQUxoQnZZLEdBS0QydkIsb0JBQUtpN0MsT0FBS3J5RDtnQkFBcUM7Z0JBSi9EMkM7ZUFBR2swRDs7SUFNZixPQWRFajFEO2FBUWFpMUQ7c0JBTWF6L0MsS0FBS2k3QyxNQUFLcnlEO2NBQU8sT0FBQSxXQVBoQnZZLEdBT0QydkIsb0JBQUtpN0MsT0FBS3J5RDthQUFvQzthQU5qRTBDO0dBcUJFO1lBa0lmMCtDLGVBL0hpQng0RCxJQUFHQyxJQUFJeW9FLGFBQWEwRjthQUNqQzF1QyxLQUFLNzZCO0tBQ1AsSUFNRXFoQyxPQVBLcmhDO1VBT0xxaEM7a0JBUEtyaEM7a0JBRU87O09BQ2dCeXpEO09BQU5DO09BQU51VDtPQUFMcjlDO01BQ1g7a0JBRFdBLHNCQUFLcTlDO3FCQTdHZDM3QyxLQTZHb0Jvb0MsTUFBTUQ7OztNQUlXbnlCLFFBUGxDdGhDO01BS2tCNnpELFFBRXZCeHlCO01BRmlCeXlCLFFBRWpCenlCO01BRld1akMsT0FFWHZqQztNQUZNMVgsTUFFTjBYO1VBQXVDQztNQUR2QyxlQURNM1gsb0JBQUtpN0MsWUEvR1R0NUMsS0ErR2V3b0MsT0FBTUQ7S0FHRjtNQUR3Q0UsUUFBdEJ6eUI7TUFBZTB5QixRQUFmMXlCO01BQVduQixLQUFYbUI7TUFBTytuQyxLQUFQL25DO01BQ25DMnlCLGlCQUFpQixXQVRENFAsYUFNZGw2QyxLQUV3QzAvQztLQUU5QyxTQURJcFY7a0JBQUFBOztvQkFEMENvVixtQkFBSWxwQztvQkFBbERrQixNQWpIRS9WLEtBaUhvRDBvQyxPQUFPRDs7b0JBRnZEcHFDLG9CQUFLaTdDO29CQS9HVHQ1QyxLQStHZXdvQyxPQUFNRCxRQUVnQnZ5QjtLQUtoQyxHQUFBLDZCQVBVd3lCLE9BRXFDRTtVQUloREUsaUJBTmlCTCxPQUVzQ0U7O01BT2xDO09BQUEsT0F4SHpCem9DLEtBaUhvRDBvQyxPQUFPRDtPQUl2REcsaUJBckhKNW9DLEtBK0dld29DLE9BQU1EO0tBV2xCLE9BQUEsV0FqQjRCMFYsWUFNdEIzRSxNQUV1Q3prQzttQkFJNUMrekI7dUJBTkF2cUMseUJBQUtpN0MsTUFFdUN6a0MsT0FJNUMrekI7SUFVOEQ7SUFFaEMsSUFBQSxPQW5IdENzSSxRQTJGa0JwaEUsS0F3Qk8sV0FuSHpCb2hFLFFBMkZlcmhFO0lBd0JqQixPQUFBLG9DQXZCSTAvQjtHQXVCdUQ7WUEwRDNEMEs7SUFDRXA3QixZQUNFdkssS0FDRDRwRSwwQkFDQUMsdUJBQ0RycEU7SUFFSixHQUxNUixTQUFRQyxNQUFSRCxRQUFBbWIsUUFBUWxiLGNBQVJrYjthQUtGczVDLGdCQUFnQkMsTUFBS3Y2RCxHQUFFa2M7S0FDekI7TUFBSTR0RCxjQVBGMTVEO01BUWdCLFFBNXJCZCttQyxNQTByQm1CbjNDLEdBQUVrYyxPQUNyQjR0RDtNQUNVcmlFO01BQVAreUQ7TUFBSHgzRDtNQUNBa0QsTUFBSSxXQUhVcTBELFVBRWR2M0QsR0FBVXlFO0tBRWQsS0FGTyt5RCxPQUdHLE9BRk50MEQ7bUJBREdzMEQsVUFJTXFRLG1CQUFMajdDO0tBQWMsT0EzeUJ0QnlzQyxNQXd5QkluMkQsS0FHSTBwQixLQUFLaTdDLE1BTFRmO0lBSzhDO0lBRXBELGdCQWJNOW9EO0tBa0JJO01BQVI7TUFsQzRDMjRDO1FBa0NwQzs7VUFqQkw4VjtVQUVEcHBFOytCLE9BRUFpMEQ7TUFwQkFuNUI7aUJBQUt1NEI7U0FDUCxLQURPQSxRQUVPO2FBQ1E3MEQsSUFIZjYwRCxXQUdZMTVELElBSFowNUQsV0FHU25yRCxJQUhUbXJELFdBR01scUMsSUFITmtxQztTQUdxQixlQUFmbHFDLEdBQUdqaEIsSUExS1ZpckQsV0EwS2F4NUQsR0FBRzZFO1FBQXVEO0tBRS9FLEdBWUs2cUU7TUFUVztPQTFKYTcvQyxRQW1LeEI2L0M7T0FuSzRCcjRFLFlBZ0s3QitZO09BL0pXakssTUFnSitCd3pEO09BaEo3Qko7TUFDYjtpQkFEV3B6RCxzQkFzSlh1MEQsU0F0SmFuQjtnQkFBRnB6RDtRQUdXLElBQVhpb0UsTUFIQWpvRSxRQUdIdzBELE1BSEd4MEQsUUFBQUMsYUFHSHUwRCxLQUFHeVQ7UUFIQWpvRSxNQUFBQzs7O1lBS0hxbUIsTUFMR3RtQixRQUlBeTBELE1BSkF6MEQ7UUFJaUIsT0FBQSxXQUxDOU8sV0FLbEJ1akUsS0FMYy9xQztTQUNkMXBCLE1BS0hzbUI7O1NBQXlCO1VBTHRCaWQsTUFBQXZqQztVQUtHd3BFLE1BTEh4cEU7VUFLQTAwRCxNQUxBMTBEO1VBQUUyMEQsVUFLRkQsS0FBRzhVLEtBQU5sakQsS0FMSzhzQztTQUFGcHpELE1BQUF1akM7U0FBRTZ2QixNQUFBdUI7Ozs7OztVQXNKYkosU0E1S0lsQixXQXNLc0NHO0tBVzlDLE9BQUEsOEJBTEllLFFBTEF2NUI7O0lBOEJNO0tBQVI7S0E3QzRDNzZCO09BNkNwQzs7U0FiTG9wRTtTQUNEcnBFOzhCLE9BRUFpMEQ7YUFsQ0FoN0IsS0FBS282QjtLQUNQLEtBRE9BLFFBRU87U0FDUTcwRCxJQUhmNjBELFdBR1kxNUQsSUFIWjA1RCxXQUdTbnJELElBSFRtckQsV0FHTWxxQyxJQUhOa3FDO0tBR3FCLGVBQWZscUMsR0FBR2poQixJQW5LVmdqQixLQW1LYXZ4QixHQUFHNkU7SUFBaUQ7SUFFekUsR0F5Qks0cUU7S0F0Qlc7TUF2SmE3L0MsTUE2S3hCNi9DO01BN0s0QnA1RSxVQTJLN0IrWjtNQTFLV3BRLElBNkkrQnNHO01BN0k3QnpCO0tBQ2I7Z0JBRFc3RSxvQkFtSlhOLE9BbkphbUY7ZUFBRjdFO09BR1csSUFBWDhyQyxJQUhBOXJDLE1BR0h1TyxJQUhHdk8sTUFBQWtHLGFBR0hxSSxHQUFHdTlCO09BSEE5ckMsSUFBQWtHOzs7V0FBQWxELElBQUFoRCxNQUFBeUgsSUFBQXpILE1BSUEwZ0MsTUFKQTFnQztPQUlpQixRQUFBLFdBTEMzSixTQUtsQnFxQyxLQUxjOVE7UUFNUSxJQUFoQjZaLE1BTE56cEMsTUFLRytxRSxNQUxIL3FFLE1BS0F5NkQsTUFMQXo2RCxNQUFFMGYsVUFLRis2QyxLQUFHc1EsS0FBR3RoQyxLQUxKNWtDO1FBQUY3RSxJQUFBZ0Q7UUFBRTZCLElBQUE2YTs7O1FBQUYxZixJQUFBeUg7Ozs7O1NBbUpYL0gsT0F2SkEraUUsUUFpSjBDbjhEO0lBVzlDLE9BQUEsOEJBTEk1RyxNQUxBNC9CO0dBZ0RpRTtZQUduRXJuQyxVQUFRNnhFLGFBQVk4RixjQUFhNzlDLE1BQUdEO0lBQ3RDLElBNUtrQndwQyxPQTFCZG1ILFFBcU1rQzN3QyxPQTNLdkJ5cEMsT0ExQlhrSCxRQXFNK0Ixd0MsT0EzS3BCM3dCLEtBQUFtNkQsTUFBR2w2RCxLQUFBaTZEO0lBQ2Q7VUFEV2w2RCxXQUFHQztVQUFBQSxJQUlGO0tBRUY7TUFEaUM4MkIsS0FMN0I5MkI7TUFLeUJ1YyxLQUx6QnZjO01BS3FCd3VFLEtBTHJCeHVFO01BS2lCK2tDLEtBTGpCL2tDO01BS002MkIsS0FMVDkyQjtNQUtLdWMsS0FMTHZjO01BS0MwdUUsS0FMRDF1RTtNQUtIaWxDLEtBTEdqbEM7TUFNTG9PLElBQUksV0FxS0pzNkQsYUF0S0V6akMsSUFBdUJEO0tBRTdCLFNBREk1MkIsR0FFQyxPQUZEQTtLQUlNLElBQUpnVCxNQUFJLFdBaUtNb3RELGNBdEtORSxJQUF1QkQ7S0FNL0IsU0FESXJ0RCxLQUVDLE9BRkRBO0tBR0ksR0FBQSw2QkFSSTdFLElBQXVCQyxLQUw1QnhjLEtBS1M4MkIsSUFMTjcyQixLQUs2QjgyQjtVQVVoQixJQWZiaGQsT0F4Q1ZvVyxLQTZDbUMzVCxJQUFJdWEsS0FMaENqZCxPQXhDUHFXLEtBNkNZNVQsSUFBSXVhLEtBTFQ5MkIsS0FBQThaLE1BQUc3WixLQUFBOFo7O0dBNEt1RDtZQUd2RWpqQixRQUFNNHhFLGFBQVk4RixjQUFhNzlDLE1BQUdEO0lBQ3BDLElBM0prQndwQyxPQS9DZG1ILFFBeU1nQzN3QyxPQTFKckJ5cEMsT0EvQ1hrSCxRQXlNNkIxd0MsT0ExSmxCM3dCLEtBQUFtNkQsTUFBR2w2RCxLQUFBaTZEO0lBQ2Q7UUFEV2w2RDtTQUFHQzs7UUFJNkI4MkIsS0FKN0I5MkI7UUFJeUJ1YyxLQUp6QnZjO1FBSXFCd3VFLEtBSnJCeHVFO1FBSWlCK2tDLEtBSmpCL2tDO1FBSU02MkIsS0FKVDkyQjtRQUlLdWMsS0FKTHZjO1FBSUMwdUUsS0FKRDF1RTtRQUlIaWxDLEtBSkdqbEM7cUJBS1QsV0FxSkUwb0UsYUF0Skl6akMsSUFBdUJEOztRQUUxQixXQUFBLFdBb0pXd3BDLGNBdEpKRSxJQUF1QkQ7UUFFOUI7U0FDRyxHQUFBLDZCQUhRbHlELElBQXVCQyxLQUo1QnhjLEtBSVM4MkIsSUFKTjcyQixLQUk2QjgyQjtTQUdxQixJQVBsRGhkLE9BN0RWb1csS0FpRW1DM1QsSUFBSXVhLEtBSmhDamQsT0E3RFBxVyxLQWlFWTVULElBQUl1YTtTQUpUOTJCLEtBQUE4WjtTQUFHN1osS0FBQThaOzs7Ozs7O09BTVQ7OztlQU5TOVosSUFFQTtLQUNPOztHQXdKOEM7WUFHckUwaEIsTUFBTTNoQixJQUFHQyxJQUFJcEIsR0FBRzZwRTtJQUloQixXQWpORXJILFFBNk1PcGhFO0lBTU4sT0FqSkQ4aEI7YUEySWMybUQ7YUE3TWRySCxRQTZNSXJoRTs7O3NCQU1Hd3VCLEtBQUtpN0MsYUFBVyxPQUFBLFdBTlo1cUUsR0FNSjJ2QixLQUFLaTdDLE1BQXVCO0dBQUM7WUFHdENrRixRQUFNM3VFLElBQUdDLElBQUkzQixNQUFNTyxHQUFHNnBFO0lBQ2lCLFdBdk5yQ3JILFFBc05PcGhFO0lBQ1gsT0FySkk4aEIsTUFvSm9CMm1ELGFBdE5wQnJILFFBc05JcmhFLFdBQU8xQixNQUFNTztHQUM4QztZQUtqRSt2RSxvQkFBb0I1dUUsSUFBR0MsSUFBSXlvRSxhQUFhMEYsWUFBWTl2RSxNQUFNTztJQU01RCxTQUFJa3dCLElBQUkzWCxLQUFJZ1gsR0FBRWpoQjtLQUFJLE9BQU0sV0FOb0N0TyxHQU1wRHVZLFNBQUlnWCxrQkFBRWpoQjtJQUF1QjtJQUNyQyxTQUFJMmhCLE9BQU8xWCxLQUFJZ1gsR0FBRWpoQjtLQUFJLE9BQU0sV0FQaUN0TyxHQU9qRHVZLFNBQUlnWCxrQkFBRWpoQjtJQUFzQjthQUNuQzBoRSxNQUFNejNELEtBQUlnWCxHQUFFa1IsS0FBRW55QjtLQUFLLE9BQUcsV0FSZ0JpaEUsWUFRMUI5dUMsS0FBRW55QjtlQUFSaUs7ZUFBb0QsV0FSRnZZLEdBUWxEdVksU0FBSWdYLHVCQUFFa1IsS0FBRW55QjtJQUFpRTthQUczRUgsS0FBS2xJLEtBQUVsRyxHQUFHa3dFO0tBQ2hCLElBRFc5dUUsS0FBQThFLEtBQUU3RSxLQUFBckIsR0FBR04sT0FBQXd3RTtLQUNoQjtNQUFHLEdBQUEsNkJBRFE5dUUsSUFBRUMsS0FFUixPQUZXM0I7Z0JBQUwwQjtPQU1vQixPQTlWM0JyQjtnQkF3VlNzQjtnQkFBRzNCO3lCQU1xQmt3QixLQUFLaTdDLE1BQUtyeUQsS0FBTyxPQVhwRDJYLElBVzZDM1gsS0FBVm9YLEtBQUtpN0MsTUFBNEI7OztnQkFOM0R6cEU7WUFTRW1OLElBVEZuTixPQVNEb3VCLElBVENwdUI7a0JBQUVDO2lCQUFBQTtTQVVGLElBRGdCcS9CLE1BVGRyL0IsT0FTVWs2QyxNQVRWbDZDLE9BWU4vUixJQUZJLFdBckJnQnc2RSxhQW9CakJ0NkMsR0FBYStyQjtTQUVULFNBQ1Bqc0QsR0FEZ0IsT0FkckIyZ0YsTUFHY3Z3RSxNQVNOOHZCLEdBQUdqaEIsR0FBY215QjtTQUdiLFFBQVBweEM7VUFJVSxJQUFONmdGLFFBckJUaGdELElBS2N6d0IsTUFTTzY3QyxLQUFJN2E7VUFRcEIsT0FyQkx4USxPQW9CU2lnRCxPQVBEM2dELEdBQUdqaEI7O1NBSUksSUFBTjZoRSxRQWpCVGxnRCxPQUljeHdCLE1BU044dkIsR0FBR2poQjtTQUtOLE9BbkJMNGhCLElBa0JTaWdELE9BSlk3MEIsS0FBSTdhOzs7O1lBVGhCajVCLElBQUFyRyxPQWtCS3E1RCxNQWxCTHI1RCxPQWtCRWsxRCxNQWxCRmwxRCxPQWtCRDRCLElBbEJDNUI7a0JBQUVDO2lCQUFBQTthQWtCbUJvckIsTUFsQm5CcHJCLE9BQUFvb0MsTUFBQXBvQyxPQWtCMkJzNUQsTUFsQjNCdDVELE9Ba0J1Qm0xRCxNQWxCdkJuMUQ7U0FrQjJDLFNBQUEsV0E3QjdCeW9FLGFBNkJkeFQsS0FBdUJFO1VBQ3RCLElBQU42WixRQW5CRmppRSxLQWtCSXBMLEdBQXNCeXBCLEtBbEJoQi9zQixPQUFBNHdFLFFBSGRMLE1Bc0JNSSxPQURLL1osS0FBR21FLEtBQXdCRTtVQWxCN0J2NUQsS0FBQXFHO1VBQUVwRyxLQUFBb29DO1VBQUcvcEMsT0FBQTR3RTs7Ozs7T0EvR2hCO1FBRElwUzttQkFBSTFsRCxLQUFJZ1gsR0FBRWpoQjtXQUFJLE9BQU0sV0FxR2tDdE8sR0FyR2xEdVksU0FBSWdYLGtCQUFFamhCO1VBQXVCO1FBQ2pDNHZEO21CQUFPM2xELEtBQUlnWCxHQUFFamhCO1dBQUksT0FBTSxXQW9HK0J0TyxHQXBHL0N1WSxTQUFJZ1gsa0JBQUVqaEI7VUFBc0I7UUFDckJnaUUsVUF6SGhCOU4sUUF1T1dwaEU7UUE5R0FtdkUsU0F6SFgvTixRQXVPU3JoRTs7O1lBOUdFa21DLE9BQUFrcEMsUUFBS2pwQyxRQUFBZ3BDLFNBQU0vM0QsTUE4R1I5WTtRQTdHZDtjQURXNG5DO2NBQUtDO1NBS087VUFEd0N5eUIsUUFKL0N6eUI7VUFJd0MweUIsUUFKeEMxeUI7VUFJb0NuQixLQUpwQ21CO1VBSWdDK25DLEtBSmhDL25DO1VBSVF1eUIsUUFKYnh5QjtVQUlNeXlCLFFBSk56eUI7VUFJRWpCLEtBSkZpQjtVQUlGNmlDLEtBSkU3aUM7VUFLTDR5QixpQkFBaUIsV0E4RkU0UCxhQS9GaEJLLElBQXVDbUY7U0FFOUMsU0FESXBWO1VBR1c7V0FSS2h3QzthQVFMLFdBMkZxQnNsRCxZQS9GekJucEMsSUFBdUNEO2dCQUo5QjV0QjtnQkFRMEIsV0EyRlF2WSxHQW5HbEN1WSxTQUliMnhELHdCQUFJOWpDLElBQXVDRDtVQUs3QyxHQUFBLDZCQUxVMnpCLE9BQXVDRSxRQUo3QzN5QixPQUlhd3lCLE9BSlJ2eUIsUUFJK0N5eUIsT0FKekN4aEQsTUFBQTBSOztXQVdXLElBWGpCMi9DLFVBdkladDRDLEtBMklvRDBvQyxPQUFPRCxRQUpwRG54QixTQXZJUHRYLEtBMklhd29DLE9BQU9EO1dBSmJ4eUIsT0FBQXVCO1dBQUt0QixRQUFBc2lDO1dBQU1yeEQsTUFBQTBSOzs7c0JBS2hCZ3dDO1VBWVEsSUFqQlEvdkMsUUFGcEIrekMsTUFFb0IxbEQsS0FJMEI4MkQsSUFBSWxwQyxLQUpwQ3FxQyxVQXZJWmwvQyxLQTJJb0Qwb0MsT0FBT0Q7VUFKL0N6eUIsUUFBQWtwQztVQUFNajRELE1BQUEyUjs7O1VBY1IsSUFkUXFqQyxRQURwQjJRLFNBQ29CM2xELEtBSWIyeEQsSUFBSTlqQyxLQUpGdUQsU0F2SVByWSxLQTJJYXdvQyxPQUFPRDtVQUpieHlCLE9BQUFzQztVQUFXcHhCLE1BQUFnMUM7OztRQUVQLE9BaEVYcHpDO2lCQThEa0I1QjswQkFFc0JvWCxLQUFLaTdDLE1BQUtyeUQsS0FBTyxPQUozRDBsRCxNQUlvRDFsRCxLQUFWb1gsS0FBS2k3QyxNQUE0QjtpQkFGN0R0akM7O09BR0QsT0FqRVhudEI7Z0JBOERrQjVCO3lCQUdzQm9YLEtBQUtpN0MsTUFBS3J5RCxLQUFPLE9BSjNEMmxELFNBSW9EM2xELEtBQVZvWCxLQUFLaTdDLE1BQStCO2dCQUhyRXZqQzs7TUFzSGtCLE9BaFczQnZuQztlQXdWT3FCO2VBQUsxQjt3QkFRcUJrd0IsS0FBS2k3QyxNQUFLcnlELEtBQU8sT0FacEQwWCxPQVk2QzFYLEtBQVZvWCxLQUFLaTdDLE1BQStCOztJQWlCRztJQUU5RSxPQTNCUXo4RCxLQVhjaE4sSUFBR0MsSUFBNkIzQjtHQXNDdkM7WUFHVG9DO0lBQVMsOEJBQ0o7dUJBQ0M7SUFDeUI7S0FBcEIyRjtLQUFUekU7S0FBNkIsT0FIL0JsQixPQUdXMkY7S0FBUyxPQUhwQjNGLE9BR0VrQjtLQUFrQixPQUFBO0lBQUEsT0FBQTtHQUF1QjtZQVUvQzB0RSxLQUFLMXdFO0lBQUksT0ExV0xFO2FBMFdDRixlQUF3QjR2QixZQUFZdHJCLE1BQVEsV0FBcEJzckIsS0FBWXRyQixNQUFtQjtHQUFZO1lBQ3hFdW1FLEtBQUs3cUU7SUFBSSxPQTNXTEU7YUEyV0NGLHNCQUErQjZxRSxNQUFLdm1FLE1BQVEsV0FBYnVtRSxNQUFLdm1FLE1BQW9CO0dBQVk7O2FBV3ZFcXNFLGlCQUFpQkMsVUFBVWx4RSxNQUFNTyxHQUFHNnBFO0tBQ3RDLE9BQW9DOztjQURqQjhHO2tCQTZ2Qm5Calk7O2VBNXZCb0M7Z0JBQTJCa1M7Z0JBQUxqN0M7Z0JBQVQ5dEI7Z0JBQVBzZjtnQkFFaEMsUUF6dUJOcEksS0F1dUJzQ29JLE9BQWdCd08sS0FEcEJrNkM7O29CQUszQjU4QyxpQkFITDJqRCxZQUdLM2pEOztvQkFITDJqRCxZQUZ1Qm54RTtlQU9oQixJQUFQd3RFLFNBQU8sV0FQc0JqdEUsR0FFN0I0d0UsV0FEeURoRztlQU83RCxPQWw2QkYxakMsSUEyNUIwQy9sQixPQUFPdGYsUUFBUzh0QixLQU1wRHM5QyxRQVBnQ3BEO2NBUU07SUFBQTthQUcxQ2dILG1CQUFtQkYsVUFBVTN3RSxHQUFHNnBFO0tBQ2xDLE9BQW9DOztjQURmOEc7a0JBa3ZCckJqWTs7ZUFqdkJvQztnQkFBMkJrUztnQkFBTGo3QztnQkFBVDl0QjtnQkFBUHNmO2dCQUVoQyxRQXB2Qk5wSSxLQWt2QnNDb0ksT0FBZ0J3TyxLQUR4Qms2Qzs7b0JBS3ZCNThDLGlCQUhMNmpELFdBR2EsV0FMWTl3RSxHQUtwQml0QixNQUpvRDI5Qzs7b0JBQ3pEa0csV0FEeURsRztlQU03RCxPQTU2QkYxakMsSUFzNkIwQy9sQixPQUFPdGYsUUFBUzh0QixLQUNwRG1oRCxVQUY0QmpIO2NBT21CO0lBQUE7YUFHbkRrSCxZQUFZSixVQUFVOUc7S0FDeEIsT0FBWTtjQWpxQ2Q3OEQ7dUJBaXFDbUJ4RjtlQUViO2dCQURFcEg7a0JBQ0Y7O29CQUhVdXdFO3dCQXd1QmRqWTs7cUJBcnVCd0M7c0JBQXVCa1M7c0JBQUxqN0M7c0JBQVQ5dEI7c0JBQUg5QjtzQkFDcEN3WSxNQW43QlYydUIsSUFrN0I4Q25uQyxHQUFHOEIsUUFBUzh0QixLQUFLaTdDLE1BSHZDZjtzQkFJVDF3RCxXQUFMWjs0QkFEdUMxVyxXQUNsQ3NYOytCQUN5QixXQUp2QjNSLG9CQUV5Q21vQjsrQkFDaERwWDtvQkFDNEQ7ZUFFcEUsa0JBTEluWTtjQUtHO0lBQUM7YUFHUjR3RSxxQkFBcUJMLFVBQVV4Z0U7S0FDM0IsWUFYSjRnRSxZQVVxQkosVUFBVXhnRTsrQkFFM0I5Z0IsY0FBSyxXQUFMQTtLQUVKO01BRGVzZ0M7TUFDZixPQUorQnhmO01BS2hCLE9BQUE7TUFBYixPQUFBO0tBREYsT0FBQSwwQ0FEZXdmO0lBSU87YUFHdEJzaEQsZ0JBQWdCTixVQUFVeGdFO0tBQ3RCLFlBckJKNGdFLFlBb0JnQkosVUFBVXhnRTsrQkFFdEI5Z0IsY0FBSyxPQUFMQTtLQUVzQjtNQURYc2dDO2FBSFd4ZjtNQUlBLE9BQUE7TUFBYixPQUFBO01BQWIsT0FBQSx1Q0FEZXdmO0tBQ2YsT0FBQTtJQUNjO0lBL0NnQjtZQUM5QitnRDtZQVdBRztZQVVBRTtZQVVBQztZQVVBQzs7O0lBY0V0UTsrQkFKQTl1RCxNQUlBOHVEO0lBR0p1UTtJQUNBQztJQUNBQztJQUNBQztJQUNBQztZQUtBQyxrQkFBa0JaLFVBQVU3d0UsTUFBTStwRTtJQUN4QjtLQUFScDZDLFFBQVEsV0FEa0IzdkIsTUFBVjZ3RSxzQkFDdUI1dEUsR0FBRTFULEdBQUssV0FBTEEsR0FBRjBULEdBQWE7SUFDeEQsT0FYRW11RTthQVVFemhELG1CQUNpQzFzQixHQUFFMVQsR0FBSyxXQUFMQSxHQUFGMFQsR0FBYSxHQUZkOG1FO0dBRTRCO1lBRzlEMkgsZUFBZS9oRCxPQUFPbzZDO0lBQ3hCLE9BTkUwSCxrQkFLZTloRCxzQkFBT282QztHQUM0Qjs7SUFROUM0SDtrQ0FKQXJJLFFBSUFxSTtJQUdKQztJQUNBQztJQUNBNXFDO0lBQ0E2cUM7SUFDQUM7Ozs7Ozs7Ozs7WUFFQUMsa0JBQWtCOXFDLFVBQVU2aUM7SUFDOUIsT0F4QkUwSCxrQkF1QmtCdnFDLDRCQUFVNmlDO0dBQzZCO1lBR3pEdm5FLFFBQVF2QyxHQUFHQztJQUNiLE9BQVk7YUExdUNaZ047c0JBMHVDaUJ4RjtjQXhpQlh0SDtnQkF1aUJJSDt5QkFFTzZxRTtpQkFBZSxlQUFBLFdBRm5CNXFFLEdBRUk0cUU7K0JBQTZCLFdBRDdCcGpFO2dCQUMyQztjQUExRDthQUNJO0dBQUM7WUFHTDhjLFNBQVN2a0IsR0FBR0M7SUFDZCxPQUFZO2FBaHZDWmdOO3NCQWd2Q2lCeEY7Y0FwaUJYckg7Z0JBbWlCS0o7eUJBRVE0dkIsS0FBS2k3QztpQkFBZSxlQUFBLFdBRnpCNXFFLEdBRUsydkIsS0FBS2k3QzsrQkFBbUMsV0FEMUNwakU7Z0JBQ3dEO2NBQXZFO2FBQ0k7R0FBQztZQUdMdkYsT0FBT2xDLEdBQUdDO0lBQ1osT0FBWTthQXR2Q1pnTjtzQkFzdkNpQnhGO2NBcGpCWHRIO2dCQW1qQkdIO3lCQUVRNnFFO2lCQUFXLFdBQUEsV0FGaEI1cUUsR0FFSzRxRTtpQkFBVyxjQUFZLFdBRHZCcGpFO2dCQUNvQztjQUFuRDthQUNLO0dBQUM7WUFHTitjLFFBQVF4a0IsR0FBR0M7SUFDYixPQUFZO2FBNXZDWmdOO3NCQTR2Q2lCeEY7Y0FoakJYckg7Z0JBK2lCSUo7eUJBRVM0dkIsS0FBS2k3QztpQkFBVyxXQUFBLFdBRnRCNXFFLEdBRU0ydkIsS0FBS2k3QztpQkFBVyxjQUFrQixXQURwQ3BqRTtnQkFDaUQ7Y0FBaEU7YUFDSztHQUFDO1lBR04yUSxNQUFNcFksR0FBR0M7SUFDWCxPQXRnQk1GO2FBcWdCRUM7OzZCQUN1QjZxRSxNQUFLcnlEO2NBQU8sT0FBRyxXQURuQ3ZZLEdBQ29CNHFFO3dCQUEyQiw0QkFBdEJyeUQ7d0JBQUFBO2FBQXNDO0dBQUM7WUFHekUrVSxPQUFPdnRCLEdBQUdDO0lBQ1osT0ExZ0JNRjthQXlnQkdDOztzQkFDZTR2QixLQUFLaTdDLE1BQUtyeUQ7Y0FBTyxPQUFHLFdBRGhDdlksR0FDWTJ2QixLQUFLaTdDO3dCQUFpQyw0QkFBNUJyeUQ7d0JBQUFBO2FBQTRDO0dBQUM7WUFHN0V3NUQsU0FBV25zRSxLQUF5QjdGO0lBQ3RDLEdBRGE2RixTQUFZQyxNQUFaRCxRQUFBb3NFLFlBQVluc0UsY0FBWm1zRTtJQUNiLG9CQURhQTtjQXBmUC94RTtlQW9mZ0NGLGVBRVU0dkIsS0FBS2k3QyxNQUFLdjdFLEdBQUssZUFBZnNnQyxLQUFLaTdDLE9BQUt2N0UsR0FBcUI7Y0EvZ0J6RXlRO2VBNmdCZ0NDLGVBR0k0dkIsS0FBS2k3QyxNQUFLdjdFLEdBQUssZUFBZnNnQyxLQUFLaTdDLE9BQUt2N0UsR0FBcUI7R0FBQztZQUd4RXk3QixNQUFNM3BCLElBQUdDLElBQUlwQixHQUFHNnBFO0lBQ2xCO0tBQXVFLE9BOUpqRWhvRSxPQTZKS1Q7S0FDZ0QsT0E5SnJEUyxPQTZKRVY7S0FDa0QsT0FBQTtLQUF0RG1xRCxPQUFPO0tBQ1B0eUQ7SUF2TkY4cEI7TUFxTk0zaEI7TUFBR0M7ZUFHdUJ1dUIsS0FBVTg1QztPQUNwQyxZQUFBLFdBSk96cEUsR0FHbUIydkIsS0FBVTg1QzttQkFLaEM7V0FISDE1QztPQUNMLG1DQUxBdTdCLE1BQ0F0eUQsVUFDOEIyMkIsS0FFekJJO09BSEQsT0FBQSw2QkFBSi8yQjtNQU1VO01BUkk2d0U7UUFTZDNxRSxNQVBBbEc7SUFRSixTQUFJOFksSUFBSTlZLEdBQUksT0FBQSxtQ0FUUnN5RCxNQVNJdHlELEdBQTRCO0lBQ3pCLElBQVAwZ0UsT0F6dENGdkQsK0JBdXRDRWozRCxLQUNBNFM7SUFFSixXQURJNG5ELE1BRkF4NkQ7R0FHSztZQUlMK3lFO0lBQWtCQyxjQUFhQyxTQUFRQyxTQUFTNTFDLE1BQU05a0IsU0FBU215RDtJQUNqRSxPQXBpQkkvcEU7YUFtaUJxQ3N5RTtpQkFBUkQsU0FBYkQ7c0JBQ2dDdmlELEtBQVVpN0M7Y0FBaEIsSUFBMEIvb0UsbUJBQUg5QjtjQUNuRSxPQW5wQkZ1dUU7dUJBa3BCcUV2dUU7dUJBQWpCNHZCOzt3QkFDYixtQkFEdUJpN0M7NEJBR25EcUM7d0JBQVEsT0FBQSxXQUorQnp3QyxNQUFNOWtCLFNBQ0ppWSxLQUd6Q3M5QyxRQUhtRHJDO3VCQUdkO3VCQUh3Qi9vRTt1QkFEUGdvRTthQUloQjtHQUFBO0dBRW5ELFNBQUlydEMsS0FBS3g4QixHQUFHMnZCLEtBQUl0Z0MsR0FBRUMsR0FBSSxPQUFBLFdBQWIwUSxHQUFHMnZCLEtBQUl0Z0MsR0FBRUMsR0FBYztHQUNoQyxTQUFJaVIsS0FBS1AsR0FBRzJ2QixLQUFJdGdDLEdBQUVDLEdBQUksT0FBQSxXQUFiMFEsR0FBRzJ2QixLQUFNcmdDLEdBQUZELEdBQWdCO1lBUjlCZ2pGLGFBU0VseEUsSUFBR0MsSUFBSWt4RSxTQUFTQyxTQUFTNzZELFNBQVNteUQ7SUFDcEMsT0FEa0IwSSxXQUFURDtjQVJQTCxrQkFRT0ssU0FBUG54RSxJQUFHQyxJQUZIbzdCLE1BRXlCOWtCLFNBQVNteUQ7Y0FSbENvSSxrQkFRZ0JNLFNBQWJueEUsSUFBSEQsSUFEQVosTUFDeUJtWCxTQUFTbXlEO0dBR2lDO1lBWW5FMkksVUFFR0MsUUFDQWxqRCxHQUNBamhCLEdBR0wsT0FMS21rRSxpQkFDQWxqRCxHQUNBamhCLFFBS2lCO1lBdUR0Qm9rRSxZQUhjenNFLEtBQUVpb0MsS0FBSW9OLEtBQUd1dUI7SUFBYyxJQXJDakM5cEUsSUFxQ1VrRyxLQXJDVzBzRSxrQkFBYUMsZUFBVUM7SUFDOUM7ZUFERTl5RTtNQUVTLE9BMUJYeXlFLFVBd0J1QkcsY0FBYUMsV0FBVUM7Y0FBNUM5eUU7S0FhUTtNQWJSeUgsSUFBQXpIO01BQTRDK3lFLGdCQUE1Qy95RTtNQUFrQ2d6RSxjQUFsQ2h6RTtNQUFBZ0QsSUFBQWhEO01BYUl3aUIsTUFBSSxXQXdCV3NuRCxhQXJDZWtKLGFBcUNsQnozQjtLQXZCaEIsU0FESS80Qjs0QkF3QlEyckI7Z0JBOXNDaEJwNkI7a0JBeXFDSS9RO2tCQXhCRnl2RSxVQXdCdUJHLGNBQWFDLFdBQVVDO2tCQTUxQjVDaDZELFFBNDFCQTlWOzttQkFxQ1ltckM7MEJBckNzQjZrQyxhQUFVRDtrQkF6cUNoRGgvRDtvQkF5cUNJdE07b0JBeEJGZ3JFLFVBd0J1QkcsY0FBYUMsV0FBVUM7b0JBbjRCNUNsNkQsUUFtNEJBblI7dUJBcUNZMG1DLG1CQUFBQTthQXhCUjNyQjtPQWJKeGlCLElBQUFnRDtPQUFxQjR2RTtPQUFhQyxZQUFBRztPQUFVRixjQUFBQzs7O01BQTVDL3lFLElBQUF5SDs7O2FBYUkrYTtNQWJKeGlCLElBQUFnRDs7TUFBQWhELElBQUF5SDtNQUFxQm1yRTtNQUFhQyxZQUFBRztNQUFVRixjQUFBQzs7O0lBSXBDO0tBREV4a0UsSUFIVnZPO0tBR013dkIsSUFITnh2QjtLQUlJd1AsSUFBSSxXQWlDV3M2RCxhQWxDYnQ2QyxHQWtDVStyQjtLQWhDaEI7b0JBZ0NZcE47dUJBQUFBLE1BakNSMytCLHNCQUFBQTt3QkFpQ1EyK0IsTUFqQ1IzK0Isb0JBQUFBOztzQkFERWdnQixHQUFJamhCO2NBM0Jaa2tFLFVBd0J1QkcsY0FBYUMsV0FBVUM7R0FxQzRCO1lBS3hFRyxLQUFLanpFLEdBQUV3dkIsR0FBR3M2QztJQUNoQixJQURXNWpFLE1BQUFsRztJQUNYO2VBRFdrRyxrQkFFQTtjQUZBQTtVQUdIcTFDLE1BSEdyMUM7TUFHVSxhQUFBLFdBSEw0akUsYUFHUnZ1QixLQUhLL3JCOztLQUtIO01BRFEvbkIsSUFKUHZCO01BSUFvd0QsTUFKQXB3RDtNQUlIbEQsSUFKR2tEO01BS0xzSixJQUFJLFdBTE1zNkQsYUFJTHhULEtBSkU5bUM7S0FNWCxTQURJaGdCLEdBRUMsV0E3UUQxTixPQTBRRWtCO2FBQ0Z3TTtNQUtZLFdBVlp5akUsS0FJWXhyRSxHQUpMK25CLEdBQUdzNkM7TUFVNkIsT0FBQTs7O3dCQUFLbUo7Z0JBQVE7aUJBQVcsT0FoUi9EbnhFLE9BMFFFa0I7aUJBTWtELE9BQUEsNEJBQVJpd0U7Z0JBQW1CLE9BQUE7ZUFBUTs7S0FWbEUvc0UsTUFJSGxEOztHQU1zRTtZQUt4RTRlLElBQUtzeEQ7OztxQ0FDQTs7VUFDQTNrRSxnQkFBSGloQjttQkFGRzBqRDt3QkFFSDFqRCxHQUFHamhCO2lCQUlQLDZCQU5PMmtFOztLQVNGO01BRFF6ckU7TUFBSGk1QjtNQUFINmE7TUFBSHY0QztNQUVIKzVCLE9BVkNuYixJQUFLc3hELGVBUUhsd0U7UUFFSCs1QixNQUFrQixPQUFsQkE7Y0FWTW0yQyxrQkFhRCxlQUxDMzNCLEtBQUc3YTtLQU9QLDZCQWZJd3lDO2VBUU16ckU7OztZQVdmeTNELE1BQUlsL0QsR0FBRXdTLEdBQUksT0FuQk5vUCxRQW1CRXBQLElBQUZ4UyxHQUFvQjtZQUdwQjQ2QixzQkFBc0I1NkIsR0FBR0M7SUFDL0IsSUFENEJpRyxNQUFBbEc7SUFDNUI7ZUFENEJrRyxrQkFFakI7Y0FGaUJBO1VBR2pCcUksSUFIaUJySSxRQUdwQnNwQixJQUhvQnRwQjtNQUdSLE9BQUEsV0FIV2pHLEdBR3ZCdXZCLEdBQUdqaEIsYUFBSGloQixHQUFHamhCOztTQUhpQjlHLElBQUF2QixRQUlkdzZCLE1BSmN4NkIsUUFJakJxMUMsTUFKaUJyMUMsUUFJcEJsRCxJQUpvQmtEO0tBS3ZCLEdBQUEsV0FMMEJqRyxHQUlwQnM3QyxLQUFHN2E7TUFHSixJQUVKcHhDLElBVEFzckMsc0JBSUU1M0IsR0FKdUIvQzthQVN6QjNRLElBQUFBLFlBTEtpc0QsS0FBRzdhOztLQUpjeDZCLE1BQUF1Qjs7R0FVSztZQUczQjJ6QixxQkFBcUJwN0IsR0FBR0M7SUFDOUIsSUFEMkJpRyxNQUFBbEc7SUFDM0I7ZUFEMkJrRyxrQkFFaEI7Y0FGZ0JBO1VBR2hCcUksSUFIZ0JySSxRQUduQnNwQixJQUhtQnRwQjtNQUdQLE9BQUEsV0FIVWpHLEdBR3RCdXZCLEdBQUdqaEIsYUFBSGloQixHQUFHamhCOztTQUNNOUcsSUFKVXZCLFFBSWJ3NkIsTUFKYXg2QixRQUloQnExQyxNQUpnQnIxQyxRQUFBbEQsSUFBQWtEO0tBS3RCLEdBQUEsV0FMeUJqRyxHQUluQnM3QyxLQUFHN2E7TUFHSixJQUVKcHhDLElBVEE4ckMscUJBSVczekIsR0FKYXhIO2FBU3hCM1EsSUFBQUEsWUFMS2lzRCxLQUFHN2E7O0tBSmF4NkIsTUFBQWxEOztHQVVLO1lBRzlCcTRCLGNBQWNyN0IsR0FBRzNKLFNBQVFpbEMsS0FBSS9zQjtJQUMvQixpQkFEMkIrc0I7eUJBQUFBOztrQkFBQUE7aUJBMUJyQlY7a0JBMEJVNTZCOzJCQWVtQjR2QixLQUFLaTdDO21CQUFRLFlBQUEsV0FmN0J4MEUsU0FlZ0J1NUIsS0FBS2k3QyxNQWZUdDhEO2tCQWUwQztpQkE1Qm5FNnNCO2tCQWFVcDdCOzJCQUdrQjR2QixLQUFLaTdDO21CQUFRLE9BQUEsV0FINUJ4MEUsU0FHZXU1QixLQUFLaTdDLE1BSFJ0OEQ7a0JBR3dDOztrQkFINUMrc0I7aUJBYnJCRjtrQkFhVXA3QjsyQkFLa0I0dkIsS0FBS2k3QzttQkFBUSxPQUFBLFdBTDVCeDBFLFNBS2V1NUIsS0FBS2k3QyxNQUxSdDhEO2tCQUt5QztpQkEvQmxFcXNCO2tCQTBCVTU2QjsyQkFpQm1CNHZCLEtBQUtpN0M7bUJBQVEsV0FBQSxXQWpCN0J4MEUsU0FpQmdCdTVCLEtBQUtpN0MsTUFqQlR0OEQ7a0JBaUJ5QztzQkFqQjdDK3NCO0tBV2xCO01BQ0o2M0M7UUF6QkMvM0M7VUFhVXA3QjttQkFXeUI0dkIsS0FBS2k3QztXQUFRLE9BQUEsV0FYbkN4MEUsU0FXc0J1NUIsS0FBS2k3QyxNQVhmdDhEO1VBV2dEO1FBQzFFNGtFO2tCQUFBQSxTQUFXdEksaUJBQUxqN0M7TUFBd0IsU0FBQSxXQVpoQnY1QixTQVlSdTVCLEtBQUtpN0MsTUFaZXQ4RCxJQVlnQyxPQUExRDRrRTs7S0FDaUI7O0lBTmI7S0FDSkM7T0FsQ0N4NEM7U0EwQlU1NkI7a0JBTzBCNHZCLEtBQUtpN0M7VUFBUSxZQUFBLFdBUHBDeDBFLFNBT3VCdTVCLEtBQUtpN0MsTUFQaEJ0OEQ7U0FPaUQ7T0FDM0U2a0U7bUJBQUFBLFdBQVdsRyxxQkFBTHI5QztLQUF3QixTQUFBLFdBUmhCeDVCLFNBUVJ3NUIsT0FBS3E5QyxRQVJlMytELElBUWdDLE9BQTFENmtFOztJQUNpQjtHQVFtRDtZQUd2RTczQyx3QkFBd0J2N0IsR0FBR3c3QixZQUFXRjthQUNwQ0csUUFBUzdMLEtBQUtpN0M7S0FDaEIsb0JBQU0sV0FGcUJydkMsWUFDaEI1TCxLQUFLaTdDO0lBR0M7SUFFbkIsU0FBSW52QyxTQUFVOUwsS0FBS2k3QyxNQUFPLFdBTHRCcHZDLFFBS1U3TCxLQUFLaTdDLE1BQStCO0lBQ2xELG9CQVB3Q3Z2QztjQWpDbENGLHFCQWlDb0JwN0IsR0FDdEJ5N0I7Y0EvQ0ViLHNCQThDb0I1NkIsR0FNdEIwN0I7R0FHb0Q7WUFLdEQyM0M7SUFBOEJyekUsR0FBRXN6RSxhQUFhajlFLFNBQVNrOUUsY0FBY0M7YUFDbEVDLFdBQVd6ekUsR0FBRXM3QixLQUFJcGYsT0FBTzdsQjtLQUNwQixZQXBDTmdsQyxjQW1DYXI3QixHQUFhM0osU0FBWGlsQyxLQUFJcGY7aUJBR1Q7U0FERnczRDtLQUFhLGVBQWJBO0lBQ007SUFFaEIsVUFOa0NKLDBCQVNuQjtJQUhmLFNBTmtDQTtTQVEzQnAzRCxRQVIyQm8zRDtLQVFsQixPQVBaRyxXQUQ0Qnp6RSxHQUFzQ3d6RSxjQVEvRHQzRCxPQVJ3QzdsQjs7UUFPeENxOUUsVUFQMkJKO0lBT2xCLE9BTlpHLFdBRDRCenpFLEdBQXdCdXpFLGNBT2pERyxTQVB3Q3I5RTtHQVNsQjtZQU0zQnM5RTtJQUErQjN6RSxHQUFHM0osU0FDYjBtQixhQURtQ0M7SUFFeEQ7O09BakJBcTJEO1NBZStCcnpFLEdBQ1YrYyxhQURhMW1CO2dCQWtCMUI7SUFSUjtLQVNLdTlFO0tBVEw7T0F6QkFQO1NBZStCcnpFLEdBQXlCZ2QsYUFBdEIzbUI7a0JBcUJ2QjtRQUNIdzlFO0lBQWUsZUFIbEJELGVBR0dDO0dBQStDO1lBUXZEQyxTQUFVMXpFLE9BQU8wcEU7SUFDVCxJQUFOdHhELGlCQWlZRm1nRDtJQWhZRjtNQUZZdjREO2VBRUd3dkIsS0FBS2k3QztPQUNsQjtnQkFGRXJ5RDtRQUVPMVc7UUFBTHpCO1FBQ0E4eUUsT0F6eENKaHNDLElBd3hDSTltQyxLQUFLeUIsUUFESTh0QixLQUFLaTdDLE1BRkRmO1FBSVIxd0QsV0FBTCs1RDtPQUNtQixHQUZkcnhFLFdBQ0FzWCxZQUNjLDRCQUpyQlosU0FBQUEsYUFDV29YO09BRFhwWCxTQUdFMjZEOztNQUd1QjtnQkFOekIzNkQ7Z0JBUU0sa0JBUk5BO1FBU0dvWDtJQUFPLHdCQUFQQTtHQUF5QjtZQUc5Qm1rRCxhQUFjM3pFLE9BQVFnUTtJQUNsQixZQWRKMGpFLFNBYWMxekUsT0FBUWdROzhCQUVsQjdCLGNBQUssT0FBTEE7SUFFSjtLQURlcWhCO0tBQ2Y7T0FBQTs7Ozs7U0FEZUE7U0FIT3hmO0lBSXRCLE9BQUE7R0FDYztZQUdkMnNELGlCQUFpQmlYLGFBQVlDLGVBQWNqcEUsTUFBT29GO0lBQ3BEO0tBQXlCLE9BQUEsNkJBRE40akUsYUFBWUM7S0FDM0J2a0QsUUFBUSxtQ0FEaUMxa0I7S0FFekM4K0QsY0FGZ0QxNUQ7S0FHOUMsUUF2VkppaEUsU0FxVkUzaEQsT0FDQW82Qzs4QkFFRXY3RCxjQUFLLE9BQUxBO0lBSTJCO0tBSGhCaWhCO0tBR2dCO09BQUE7O3dCO3dCO0tBQTNCMGtELGNBQWMsbUNBUnlCbHBFO0tBU3ZDbXBFO0lBQ0o7O01BVEV6a0Q7TUFPRXdrRDs7T0FFK0I7UUFBY0U7UUFBUjlFO3FCQUNwQyxXQVRIeEYsYUFHYXQ2QyxHQUswQjgvQzs7V0FEckM2RTtTQUtLLE9BQUE7b0VBSndDQztRQUQ3Q0Q7Ozs7OztNQU0yQjtJQUMvQixNQUFBO0dBQVk7WUFHWnBsRCxZQUFVNDdDLGFBQVkwSixlQUFjcjBFO2FBQ2xDQyxFQUFHMnZCLEtBQUtpN0MsTUFBS3J5RDtLQUFNLGVBQTZCLFdBRDVCNjdELGVBQ1p4SjtLQUFXLG1CQUFZLFdBRHZCRixhQUNMLzZDLGNBQVVwWDtJQUE4RDtJQUMvRSxXQTN4Qk10WSxXQXl4QmdDRixNQUNsQ0M7R0FDZ0M7WUFHbENnWSxlQUFlalksR0FBRzhwRSxhQUFhYTtJQUNqQztLQUEyQixPQTN1QnpCMzJELGNBMHVCZWhVLG9CQUFHOHBFO0tBQ1Z3SztLQUFOQztJQUNELEdBaDVDRHhnRSxTQSs0Q1F1Z0UsYUFFTCxXQUZEQztJQUdrQixXQVRwQnhsRCxZQUsrQjQ3Qyw0QkFDdkIySjtJQUdZLE9BQUE7R0FBa0Q7WUFHdEVFLFNBQ0VwekUsSUFDQ25CO1FBQ2lEMHFFLHdCQUF6QmI7SUFFakIsT0FBQTthQS9qRFo3OEQ7c0JBK2pEbUJLO2NBQVA7O3NCQW4wQk52Tjt3QkErekJGcUI7NEJBNlVGdTNEO2lDQXZVcUMvb0MsS0FBS2k3Qzt5QkFBWDswQkFBcUIvb0U7MEJBQUpUOzBCQUN2Q3d1QixRQUFNLFdBTlo1dkIsR0FLa0MydkI7eUJBRWhDOzBCQUFJOzs2QkE3MUNUcTdDOytCQTIxQ2dENXBFLElBQUlTLFFBQzNDK3RCLE9BRGlDZzdDLE1BSmZmLGFBQXlCYTswQkFNM0M7Ozs7OzJCQUNrQixPQUFBLFdBTFZyOUQsd0JBR1J1aUI7Ozt3QkFFdUM7YUFBRTs7WUFHbEQ0a0QsYUFBYXowRSxHQUFHQyxHQUFHbVE7SUFDZixZQWRKb2tFLFNBYWF4MEUsR0FBR0MsR0FBR21ROzhCQUVmeU4sbUJBQVUsT0FBVkE7SUFFSjtLQURlK1I7S0FDWCs2QyxjQUpldjZEO0tBTStCLDBCQUFTLFdBRnZEdTZELGFBRFcvNkM7S0FHYixPQUFBO0lBQUEsT0FBQTtHQUE4RTtZQWdCbEZrNkMsWUFBWTlwRSxHQUFJLE9BQUpBLFFBQW1DO1lBRy9DdzlEO1FBQWlEMTdELGtCQUFONjNELGdCQUFkdnBEO0lBQy9CLFdBRCtCQSxZQUFjdXBELE1BQU03M0Q7O1lBSWpENHlFLE1BQU1wbEY7SUFBcUIsSUFBZjg1QixjQUFINzVCLGNBQWtCLE9BSjNCaXVFLEtBSU1sdUUsR0FBTTg1QjtJQUFLLFdBSmpCbzBDLEtBSU1sdUUsR0FBR0M7O1lBRVRvbEYsaUJBQWlCQzs7S0FBOEQ5eUU7S0FBTjYzRDtLQUE5Q2tiLFdBQVZEO0tBQWdDeGtFLGFBQWhDd2tFO0lBRWhCLE9BQUEsNkJBRjBCQyxVQUE4Q2xiO2NBQXhEaWI7a0JBQWdDeGtFLFlBQXdCdXBELE1BQU03M0Q7O1lBSy9FZ3pFLHdCQUFrRG5iO1FBQVQ3M0QsbUJBQVpzTztJQUE0QixXQUE1QkEsWUFBcUJ1cEQsTUFBVDczRDs7WUFDekNraEUsVUFBUzV5RCxZQUFXdXBEO0lBQU8sV0FBbEJ2cEQsWUFBV3VwRCxNQTFmZDczRCxPQTBmYzYzRDtHQUF1RDtZQU96RXZwRCxXQUFXcFEsR0FBSSxPQUFKQSxLQUFnQjtZQUMzQm81RCxRQUFRcDVELEdBQUksT0FBSkEsS0FBVTtZQUVsQnk5RCxhQUFXejlEO0lBQ2IsSUFBcUMsT0ExQnJDOHBFLFlBeUJhOXBFLElBQ2IsT0E3bERFKzFELFdBNGxEVy8xRDtJQUNiO2dCQURhQSxhQXBnQlA4QixPQW9nQk85Qjs7O0lBQzJDO0dBQThCO1lBR3BGc1osV0FBU3RaLEdBQUksT0FyOUNiK1QsU0FxOUNTL1QsTUFBeUI7WUFDbENvWixTQUFPcFosR0FBSSxPQUFKQSxLQUFZO1lBRW5CKzBFLE1BQUkvMEUsR0FBRzR2QixLQUFLaTdDO0lBQ29ELFdBakNsRWYsWUFnQ005cEU7SUFDQyxPQTlCUHc5RCxLQTZCTXg5RCxHQTU0Q0ptbkMsSUE0NENJbm5DLE1BQUFBLE1BQUc0dkIsS0FBS2k3QztHQUNvRTtZQUdoRm1LLFVBQVFoMUUsR0FBRzR2QixLQUFLaTdDO0lBQ2xCLFdBRFU3cUUsU0FRUSxPQTVDbEI4cEUsWUFvQ1U5cEU7SUFHUixPQXBDRnc5RCxLQWlDVXg5RCxHQS81Q1JnckUsUUErNUNRaHJFLE1BQUFBLE1BQUc0dkIsS0FBS2k3QztHQVN1QjtZQWV2QzE2QyxJQUFJbndCLEdBQUc0dkIsS0FBS2k3QztJQUNkO0tBTGtCO2FBSVo3cUU7TUFKWSxPQXhEbEI4cEUsWUE0RE05cEU7TUFFSjZkLFNBM0RGMi9DLEtBeURNeDlELEdBbjdDSmlyRSxpQkFtN0NJanJFLE1BQUFBLE1BQUc0dkIsS0FBS2k3Qzs7Ozs0QkFHVzs7O0lBRGIsa0JBQVZodEQ7R0FDaUM7WUFHakNvM0QsWUFBVWoxRSxHQUFHNHZCLEtBQUtpN0M7SUFHK0MsV0FyRW5FZixZQWtFWTlwRTtJQUdWLE9BbEVGdzlELEtBK0RZeDlELEdBanZDVml0RSxVQWl2Q1VqdEUsTUFBQUEsTUFBRzR2QixLQUFLaTdDO0dBRytEO1lBR2pGcUssZUFBYWwxRSxHQUFFNHZCO0lBQ21ELFdBekVwRWs2QyxZQXdFZTlwRTtJQUNSLE9BdEVQdzlELEtBcUVleDlELEdBbi9CYnl1RSxhQW0vQmF6dUUsTUFBRTR2QixLQUFGNXZCO0dBQ3FFO1lBR2xGbTFFLGFBQVduMUUsR0FBRTR2QjtJQUErQyxXQTVFOURrNkMsWUE0RWE5cEU7SUFBaUQsT0F0dkM1RG10RSxXQXN2Q1dudEUsTUFBRTR2QjtHQUE4RDtZQUUzRXdsRCxTQUFPcDFFLEdBQUU0dkIsS0FBSzN2QjtJQUNpRCxXQS9FakU2cEUsWUE4RVM5cEU7SUFDRixPQTVFUHc5RCxLQTJFU3g5RCxHQXJrQ1BrdUUsT0Fxa0NPbHVFLE1BQUU0dkIsS0FBSzN2QixHQUFQRDtHQUN3RTtZQUcvRXExRSxTQUFPcjFFLEdBQUU0dkIsS0FBSzN2QjtJQUNpRCxXQW5GakU2cEUsWUFrRlM5cEU7SUFDRixPQWhGUHc5RCxLQStFU3g5RCxHQWppQ1B1dUUsT0FpaUNPdnVFLE1BQUU0dkIsS0FBSzN2QixHQUFQRDtHQUN3RTtZQUcvRSt2QixXQUFTL3ZCLEdBQUU0dkI7SUFDYixXQURXNXZCLFNBSUksT0ExRmY4cEUsWUFzRlc5cEU7V0ExdkNUZ2tCLFNBMHZDU2hrQixNQUFFNHZCO0dBS3dCO1lBR25DL1YsT0FBSzdaLEdBQUU0dkI7SUFBeUMsV0E5RmxEazZDLFlBOEZPOXBFO0lBQTJDLE9BdHhDNUNnWixLQXN4Q0NoWixNQUFFNHZCO0dBQXdEO1lBRS9EdXVDLFNBQU9uK0QsR0FBRTR2QjtJQUc4QyxXQW5HekRrNkMsWUFnR1M5cEU7SUFHUCxPQTFGRjIwRSxpQkF1RlMzMEUsR0FsbkNQa3dCLE9Ba25DT2x3QixNQUFFNHZCLEtBQUY1dkI7R0FHZ0U7WUFHdkVpd0IsTUFBSWp3QixHQUFFNHZCO0lBQXdDLFdBdEdoRGs2QyxZQXNHTTlwRTtJQUEwQyxPQTF2QzlDcWEsSUEwdkNJcmEsTUFBRTR2QjtHQUF1RDtZQUM3RDBsRCxZQUFVdDFFLEdBQUdDLEdBQUksT0E1Z0NiMHVFLFVBNGdDTTN1RSxNQUFHQyxHQUE2QjtZQUMxQ2laLE9BQUtsWixHQUFHQyxHQUFJLE9BbmdDUkUsS0FtZ0NDSCxNQUFHQyxHQUF3QjtZQUNoQ3crQixRQUFNeitCLEdBQUdDLEdBQUksT0ExL0JURyxNQTAvQkVKLE1BQUdDLEdBQXlCO1lBQ2xDczFFLGNBQVl2MUUsR0FBR0MsR0FBSSxPQWovQm5CNHVFLFlBaS9CWTd1RSxNQUFHQyxHQUErQjtZQUM5Qys5RCxRQUFNNThELElBQUdDLElBQUlwQjtJQUFnRCxXQTNHL0Q2cEUsWUEyR1Exb0U7SUFBdUQsT0E5b0I3RDJoQixNQThvQk0zaEIsT0FBR0MsT0FBSXBCO0dBQWdFO1lBQzdFeU8sTUFBSTFPLEdBQUdDLEdBQUksT0E5RmI2MEUsaUJBOEZNOTBFLEdBbitCQUssSUFtK0JBTCxNQUFHQyxJQUE0QztZQUNuRG8vQyxPQUFLci9DLEdBQUdDLEdBQUksT0EvRmQ2MEUsaUJBK0ZPOTBFLEdBejlCRE0sS0F5OUJDTixNQUFHQyxJQUE2QztZQUNyRHUxRSxPQUFLeDFFLEdBQUdOLE1BQU1PLEdBQUksT0EvOEJkRixLQSs4QkNDLE1BQUdOLE1BQU1PLEdBQThCO1lBQzVDa2EsYUFBV25hLEdBQUdOLE1BQU1PO0lBQUksV0FBYkQ7SUFBYSxzQixPQXo4QnhCMFksaUJBeThCY2haLE1BQU1PO0dBQW9DO1lBQ3hEODlELGFBQVcvOUQsR0FBR04sTUFBTU8sR0FBSSxPQXg3QnBCQyxXQXc3Qk9GLE1BQUdOLE1BQU1PLEdBQW9DO1lBRXhEdzFFLFFBQU1yMEUsSUFBR0MsSUFBSTNCLE1BQU1PO0lBQzZCLFdBbkhsRDZwRSxZQWtIUTFvRTtJQUMwQyxPQTdvQmhEMnVFLFFBNG9CTTN1RSxPQUFHQyxPQUFJM0IsTUFBTU87R0FDNkM7WUFHaEV5MUUsY0FBWTExRSxHQUFHQztJQUFxRCxXQXRIdEU2cEUsWUFzSGM5cEU7SUFBYyxPQW5INUJ3OUQsS0FtSGN4OUQsR0F0N0JaaXZFLFlBczdCWWp2RSxNQUFHQztHQUFxRTtZQUNwRmcrRCxTQUFPaitELEdBQUdDO0lBQWdELFdBdkg1RDZwRSxZQXVIUzlwRTtJQUFjLE9BcEh2Qnc5RCxLQW9IU3g5RCxHQWo3QlA0akIsT0FpN0JPNWpCLE1BQUdDO0dBQWdFO1lBQzFFMDFFLFVBQVEzMUUsR0FBR0M7SUFBaUQsV0F4SDlENnBFLFlBd0hVOXBFO0lBQWMsT0FySHhCdzlELEtBcUhVeDlELEdBNzZCUjJwQixRQTY2QlEzcEIsTUFBR0M7R0FBaUU7WUFDNUUrZ0UsYUFBV2hoRSxHQUFHQztJQUFvRCxXQXpIcEU2cEUsWUF5SGE5cEU7SUFBYyxPQXRIM0J3OUQsS0FzSGF4OUQsR0F6NkJYMHRCLFdBeTZCVzF0QixNQUFHQztHQUFvRTtZQUNsRjIxRSxjQUFZNTFFLEdBQUdDO0lBQXFELFdBMUh0RTZwRSxZQTBIYzlwRTtJQUFjLE9Bdkg1Qnc5RCxLQXVIY3g5RCxHQW42Qlo2dEIsWUFtNkJZN3RCLE1BQUdDO0dBQXFFO1lBRXBGNDFFLGlCQUFlNzFFLEdBQUdDO0lBQ2lDLFdBN0hyRDZwRSxZQTRIaUI5cEU7SUFDVCxPQXRIUjAwRSxNQXFIaUIxMEUsR0E5NUJma3ZFLGVBODVCZWx2RSxNQUFHQztHQUNpRDtZQUduRTYxRSxnQkFBYzkxRSxHQUFHQztJQUNpQyxXQWpJcEQ2cEUsWUFnSWdCOXBFO0lBQ1IsT0ExSFIwMEUsTUF5SGdCMTBFLEdBcDVCZGdVLGNBbzVCY2hVLE1BQUdDO0dBQ2lEO1lBR2xFODFFLGdCQUFjLzFFLEdBQUdDO0lBQ2lDLFdBcklwRDZwRSxZQW9JZ0I5cEU7SUFDUixPQTlIUjAwRSxNQTZIZ0IxMEUsR0FwNUJkb3JDLGNBbzVCY3ByQyxNQUFHQztHQUNpRDtZQUdsRTYrRCxlQUFhOStELEdBQUdDO0lBQ2lDLFdBekluRDZwRSxZQXdJZTlwRTtJQUNQLE9BbElSMDBFLE1BaUllMTBFLEdBbjVCYm11QixhQW01QmFudUIsTUFBR0M7R0FDaUQ7WUFHakUrMUUsaUJBQWVoMkU7SUFDakI7WUFEaUJBO0tBS0MsT0FqSmxCOHBFLFlBNElpQjlwRTtLQUdmLE9BekxBaVksZUFzTGVqWTtJQUVaLE9BQUE7cUQsT0EzSUx3OUQsS0F5SWlCeDlEO0dBTXdCO1lBR3ZDdytELGVBQWVvUixjQUFheHVFLElBQUdDO0lBQ2pDLFdBRGlDQSxjQUFIRDtXQWhzQjVCbkosVUEyaUJGNnhFLFlBcUo4QjFvRSxLQUFid3VFO0dBQzBDO1lBR3pEOTJFLFFBQU04MkUsY0FBYXh1RSxJQUFHQztJQUFLLFdBQUxBLGNBQUhEO1dBaHNCbkJsSixRQXVpQkY0eEUsWUF5SnFCMW9FLEtBQWJ3dUU7R0FBOEU7WUFDcEZxRyxPQUFLajJFLEdBQUksT0F4bkJUMHdFLEtBd25CSzF3RSxNQUFxQjtZQUMxQmt0RSxPQUFLbHRFLEdBQUksT0F4bkJUNnFFLEtBd25CSzdxRSxNQUFxQjtZQUMxQmsyRSxXQUFVakUsV0FBVWp5RSxHQUFJLE9BaGZ4Qmd5RSxTQWdmVUMsV0FBVWp5RSxNQUFvQztZQUV4RHUrRCxpQkFBZW45RCxJQUFHQyxJQUFJbXVFO0lBQzBCLFdBL0psRDFGLFlBOEppQjFvRTtJQUNqQixPQXJyQkV3NEQsZUFvckJleDRELE9BQUdDLGFBQUltdUU7R0FDc0Q7WUFHNUUyRyxzQkFBb0IvMEUsSUFBR0MsSUFBSW11RSxZQUFZOXZFLE1BQU1PO0lBSWhDLFdBdEtmNnBFLFlBa0tzQjFvRTtJQUN0QixPQXZyQkU0dUUsb0JBc3JCb0I1dUUsT0FBR0MsYUFBSW11RSxZQUFZOXZFLE1BQU1PO0dBTzNDO1lBR0ZtMkUsUUFBTWgxRSxJQUFHQyxJQUFJcEI7SUFDc0MsV0E3S3JENnBFLFlBNEtRMW9FO0lBQ0EsT0ExS1JvOEQsS0F5S1FwOEQsSUExZk4ycEIsTUEwZk0zcEIsT0FBR0MsT0FBSXBCO0dBQ3VEO1lBR3BFbzJFLGVBQWFqMUUsSUFBR0MsSUFBSXNXO0lBRXRCO0tBUWtCLE9BMUxsQm15RCxZQWdMZTFvRTtLQUliLE9BbmZBa3hFLGFBK2VhbHhFLE9BQUdDLE9BQUhELE9BQUdDLE9BQUlzVztLQUFQdUQsT0FBRzdaLFNBQUhELFFBQUFBLEtBQUdDO0lBSWhCLE9BM0tGc3pFLGlCQXVLZXo1RDtHQVVvQjtZQUdqQ2xCLFVBQVFoYSxHQUFJLE9BLzBDUjRZLFFBKzBDSTVZLE1BQXdCO1lBQ2hDMjlELGNBQVkzOUQsR0FBSSxPQS95Q2hCbzRELFlBK3lDWXA0RCxNQUE0QjtZQUN4Q2lhLFVBQVFqYSxHQUFJLE9BMXlDUjhZLFFBMHlDSTlZLE1BQXdCO1lBQ2hDNDlELGNBQVk1OUQsR0FBSSxPQXB5Q2hCdTRELFlBb3lDWXY0RCxNQUE0QjtZQUN4QzJaLFVBQVEzWixHQUFHQyxHQUFJLE9BcmpCZnNDLFFBcWpCUXZDLE1BQUdDLEdBQTJCO1lBQ3RDOCtCLFdBQVMvK0IsR0FBR0MsR0FBSSxPQWhqQmhCc2tCLFNBZ2pCU3ZrQixNQUFHQyxHQUE0QjtZQUN4Q3laLFNBQU8xWixHQUFHQyxHQUFJLE9BM2lCZGlDLE9BMmlCT2xDLE1BQUdDLEdBQTBCO1lBQ3BDNitCLFVBQVE5K0IsR0FBR0MsR0FBSSxPQXRpQmZ1a0IsUUFzaUJReGtCLE1BQUdDLEdBQTJCO1lBQ3RDd1osUUFBTXpaLEdBQUdDLEdBQUksT0FqaUJibVksTUFpaUJNcFksTUFBR0MsR0FBeUI7WUFDbEM0K0IsU0FBTzcrQixHQUFHQyxHQUFJLE9BOWhCZHN0QixPQThoQk92dEIsTUFBR0MsR0FBMEI7WUFFcENrK0MsUUFsTFduK0MsR0FrTEh3dkI7SUFDVjtLQUFvRCxPQXpNcERzNkMsWUFzQmE5cEU7S0FtTEssUUEvN0NabTNDLE1BNHdDT24zQyxNQWtMSHd2QjtLQXJMeUJtcUM7S0FzTDVCYTtLQXRMNEI4YjtLQUFuQmxtRSxhQUdIcFE7S0F1TFR1MkU7T0FBYyw0QkFKWC9iO1VBSXFDLDRCQXZML0J4NkQ7VUFBQUE7S0F3TE8sT0F2eERsQjAxRCxPQTRsRGlDaUU7T0E1bERqQ2pFLE9BNGxEaUM0Z0I7S0E2THpCO01BbExEdHpFLElBZlRnZ0UsVUFJZ0I1eUQsWUFBbUJrbUU7TUFBUHgwRSxTQThMcUIsNEJBSjdDeTBFLFVBL0tLdnpFO0tBbUxQLFdBbkxPQSxHQTJLRnczRCxXQXRMU3BxRCxZQUFtQnVwRCxNQUFQNzNEOztJQWdNbEI7S0FyTEQyRixJQWZUdTdELFVBSWdCNXlELFlBQW1CdXBEO0tBQVB2Z0QsV0FpTVcsNEJBUG5DbTlELFVBL0tLOXVFO0lBc0xQLGVBak1jMkksWUFBbUJrbUUsUUFBUGw5RCxXQXNMckJvaEQsT0EzS0UveUQ7R0FzTDhEO1lBR3JFK3VFLFNBak1XeDJFLEdBaU1DK2MsYUFBYUM7SUFDM0I7S0FDa0UsT0F6TmxFOHNELFlBc0JhOXBFO0tBbU1YLFFBNzZDQXlzRSxZQTB1Q1d6c0UsTUFpTUMrYyxhQUFhQztLQUNadXFCO0tBck1vQm95QjtLQXFNL0JyeUI7S0FNRW12QyxNQXZ5REovZ0IsT0FpeURFcHVCO0tBT0VvdkMsTUF4eURKaGhCLE9BaXlEYW51QjtLQUtYb3ZDO09BQ0VGLFFBQ0FDO1VBQ2MsNEJBRmREO1VBRTJCLDRCQUYzQkEsS0FDQUM7T0FGRkMsdUJBdHlERmpoQixPQTRsRGlDaUUsT0FtTjlCLE9Bdk5McUosVUFPYWhqRSxNQUhzQjI1RDtJQWlOZ0I7S0FBQSxPQS9zQjdDNzNELE9BbXNCU3lsQztLQVlnQixPQS9zQnpCemxDLE9BbXNCRndsQztLQVkwQixPQUFBO0tBak5Gc3ZDLGFBaU5ULDRCQTlNTjUyRTtLQUhHb1EsYUFHSHBRO0lBSDZCLFdBQTFCb1EsWUFBbUJ1cEQsTUFBUGlkO0dBbU5lO1lBR3pDQyxTQW5OV3pKLFlBbU5TQztJQUN0QjtLQUVpQixPQTVPakJ2RCxZQXNCYXNEO0tBcU5YLFFBajBDQS90RSxPQTRtQ1crdEUsZUFtTlNDO2tDQWFPO0lBRGQ7S0FsT29CMVQ7S0FBUDczRCxTQWtPYiw0QkEvTkZzckUsZUFtTlNDO0tBdE5OajlELGFBR0hnOUQ7SUEyTlgsc0JBOU5jaDlELFlBQW1CdXBELE1BQVA3M0Q7R0FtT3dCO1lBR2xEZzFFLHVCQUFxQjkyRSxHQUFHdlEsS0FBS0QsS0FBS2tRLE1BQU1PO0lBQ3dCLFdBMVBsRTZwRSxZQXlQdUI5cEU7SUFDMkMsT0F0MENoRTh0RSxxQkFxMENxQjl0RSxNQUFHdlEsS0FBS0QsS0FBS2tRLE1BQU1PO0dBQ3VDO1lBRy9FODJFLGlCQUFlLzJFLEdBQUd2USxLQUFLRDtJQUMwQixXQTlQbkRzNkUsWUE2UGlCOXBFO0lBQ2tDLE9BdHlDakQrdEUsZUFxeUNlL3RFLE1BQUd2USxLQUFLRDtHQUN5QztZQUdoRXduRixjQUFZaDNFLEdBQUVtdUMsS0FBSXZlO0lBQzBCLFdBbFE5Q2s2QyxZQWlRYzlwRTtJQUNnQyxPQXplNUMyeUUsWUF3ZVkzeUUsTUFBRW11QyxLQUFJdmU7R0FDeUM7WUFHM0QyeUMsTUFBSXZpRSxHQUFFd1MsR0FBSSxPQXhjVjBzRCxNQXdjSWwvRCxNQUFFd1MsR0FBc0I7WUFDNUJxUCxRQUFRN2hCLEdBQUV3UztJQUFxQixXQUQvQit2RCxNQUNRdmlFLEdBQUV3UztJQUFxQixPQUFBO0dBQVM7WUFDeEN5a0UsT0FBS2ozRSxHQUFFNHZCO0lBQXlDLFdBdlFsRGs2QyxZQXVRTzlwRTtJQUEyQyxPQTVlNUNpekUsS0E0ZUNqekUsTUFBRTR2QjtHQUF3RDtZQUMvRDJsQixZQUFVMmhDLFdBQVVDLGtCQUFZbjNFLEdBQUksT0F2VHBDK3VCLFlBdVRVbW9ELFdBQVVDLFdBQVluM0U7R0FBOEM7WUFFOUVvL0Q7SUFBYXArQyxPQUFPeXVELDBCQUEwQkMsdUJBQXNCMXZFO0lBQ3RFLE9BOTBCRXdyQzthQTYwQm9FeHJDO2FBQXZEZ2hCO2FBQU95dUQ7YUFBMEJDO2FBQXNCMXZFO0dBTTlEO1lBR05xL0QsZ0JBQWNyL0QsR0FBRzNKLFNBQVFpbEMsS0FBSS9zQjtJQUFJLE9BemJqQzhzQixjQXliY3I3QixNQUFHM0osU0FBUWlsQyxLQUFJL3NCO0dBQTZDO1lBRTFFK3dELDBCQUF3QnQvRCxHQUFHdzdCLFlBQVdGO0lBQ3hDLE9BeGFFQyx3QkF1YXdCdjdCLE1BQUd3N0IsWUFBV0Y7R0FDWTtZQUdsRGtrQyxpQkFBaUI0WCxlQUFjQyxnQkFBZXB4RSxPQUFNakc7SUFDdEQsSUEvdkJvRWtHLE1BOHZCZGxHLE1BM3ZCekIsT0FUdkI4QixPQU04RG9FO0lBSS9ELE9BaFlDbkc7YUE0WDhEbUc7YUFHNUQsNkJBMnZCd0NEO3NCQTF2QnJDMnBCLEtBQUtpN0MsTUFBSzVrRTtjQUFTLE9BQUE7dUJBMHZCR294RTt1QkExdkJZLFdBMHZCMUJELGVBMXZCRW54RSxPQUFWMnBCO3VCQUFLaTdDO2FBQTJEO0dBMnZCRztZQUc1RXlNLHVCQUF1QnQzRSxHQUFHM0osU0FBUzBtQixhQUFhQztJQUVoRDs7T0FwWkEyMkQsK0JBa1p1QjN6RSxNQUFHM0osU0FBUzBtQixhQUFhQztnQkFLeEMsT0F6UlYyM0QsaUJBb1J5QjMwRTs7O0tBSUo2ekU7S0FBYkQ7SUFBNkIsT0ExRW5DNEMsU0FzRXVCeDJFLEdBSWpCNHpFLGVBQWFDO0dBQ2tCO1lBVXJDM1EsZUFBc0IsT0FEdEJ2SywrQkFDcUQ7WUFDckRtTixpQkFBc0JuTSxNQUFPLE9BQVBBLEtBQVc7WUFDakNoMEIsaUJBOTBEVS9WLEtBQUlpN0MsTUE4MERnQixXQTkwRHBCajdDLEtBQUlpN0MsTUE4MERtQztZQUVqRDdJLDRCQUEyQjV4RCxZQUFXeEw7SUFDcEMsV0FsekRGZ3lELDBCQWl6RHNDaHlELE9BQVh3TDtJQUN6QixPQUFBO0dBQWtGO1lBR3BGOHhELGtCQUFpQjl4RCxZQUFXeEw7SUFDOUIsV0F4eURFa3lELGdCQXV5RDRCbHlELE9BQVh3TDtJQUNuQixPQUFBO0dBQ3NCO1lBR3BCbW5FLFdBQVVubkUsWUFBV3NmO0lBQ2pCLElBQ0pvYyxJQWp0QkF1bEMsU0Erc0JxQjNoRCxPQUFYdGY7ZUFFVjA3QixNQUF5QixPQUF6QkE7UUFDSzZ0QixPQURMN3RCO0lBQ3FCLGtCQUFoQjZ0QjtHQUF3QjtZQUc3QjZkLG9CQUFtQnBuRSxZQUFXc2Y7SUFDaEMsV0FydEJFNGhELGtCQW90QjhCNWhELE9BQVh0ZjtJQUNyQixPQUFBO0dBQWdFO1lBRzlEcW5FLGVBQWNybkUsWUFBV3NmO0lBQVksV0F2dEJyQzZoRCxhQXV0QnlCN2hELE9BQVh0ZjtJQUF1QixPQUFBO0dBQXNDO1lBRTNFc25FLGlCQUFnQnRuRSxZQUFXc2Y7SUFDekIsV0FodEJGK2hELGVBK3NCMkIvaEQsT0FBWHRmO0lBQ2QsT0FBQTtHQUF1RTtZQUd6RXVuRSxnQkFBZXZuRSxZQUFXc2YsT0FBT2h3QixNQUFNTztJQUNyQyxXQWx1QkZreEUsY0FpdUIwQnpoRCxPQUFPaHdCLE1BQU1PLEdBQXhCbVE7SUFDYixPQUFBO0dBQStFO1lBR2pGd25FLGtCQUFpQnhuRSxZQUFXc2YsT0FBT3p2QjtJQUNqQyxXQXJ1QkZteEUsZ0JBb3VCNEIxaEQsT0FBT3p2QixHQUFsQm1RO0lBQ2YsT0FBQTtHQUEyRTtZQUc3RXluRSxXQUFVem5FLFlBQVloUTtJQUNsQixJQUVKMHJDLElBM2FBZ29DLFNBd2FzQjF6RSxPQUFaZ1E7ZUFHVjA3QixNQUF5QixPQUF6QkE7UUFESzZ0QixPQUNMN3RCO0lBRHFCLGtCQUFoQjZ0QjtHQUNxQjtZQUcxQm1lLGVBQWMxbkUsWUFBWWhRO0lBQVksV0FqYXRDMnpFLGFBaWEwQjN6RSxPQUFaZ1E7SUFBd0IsT0FBQTtHQUF1QztZQUU3RTZ4RCxpQ0FBNkM4VixrQkFBbUI1NEUsS0FBS2MsR0FDdkUsT0F0M0RFbTJELCtCQXEzRGdFajNELEtBQUtjO0dBQ3pCO1lBRzVDKzNFLHlCQUF3QjVuRSxZQUFXeTJCO0lBQ3JDO0tBQUE7S0FFRSxPQTNuREE0a0MsdUJBd25EbUM1a0MsS0FBWHoyQjtJQUMxQixPQUFBO0dBRStFO1lBRzdFMHhELGNBQWExeEQsWUFBV3kyQjtJQUNwQixJQUNKaUYsSUFqdUJBOUUsWUErdEJ3QkgsS0FBWHoyQjtlQUViMDdCLE1BQXlCLE9BQXpCQTtRQUNLNnRCLE9BREw3dEI7SUFDcUIsa0JBQWhCNnRCO0dBQXdCO1lBRzdCc2UsdUJBQXNCN25FLFlBQVd5MkI7SUFDbkMsV0FydUJFZ3JDLHFCQW91QmlDaHJDLEtBQVh6MkI7SUFDeEIsT0FBQTtHQUFpRTtZQUcvRDhuRSxrQkFBaUI5bkUsWUFBV3kyQjtJQUFVLFdBdnVCdENpckMsZ0JBdXVCNEJqckMsS0FBWHoyQjtJQUFxQixPQUFBO0dBQXVDO1lBRTdFK25FLG9CQUFtQi9uRSxZQUFXeTJCO0lBQzVCLFdBeHVCRmtyQyxrQkF1dUI4QmxyQyxLQUFYejJCO0lBQ2pCLE9BQUE7R0FBd0U7WUFHMUVnb0UsbUJBQWtCaG9FLFlBQVd5MkIsS0FBS25uQyxNQUFNTztJQUN0QyxXQWx2QkYweEUsaUJBaXZCNkI5cUMsS0FBS25uQyxNQUFNTyxHQUF0Qm1RO0lBQ2hCLE9BQUE7R0FBZ0Y7WUFHbEZpb0UscUJBQW9Cam9FLFlBQVd5MkIsS0FBSzVtQztJQUNsQyxXQXJ2QkYyeEUsbUJBb3ZCK0IvcUMsS0FBSzVtQyxHQUFoQm1RO0lBQ2xCLE9BQUE7R0FBNEU7WUFHOUUyeUQsVUFBUS9pRSxHQUFJLE9BQUpBLEVBQUs7WUFFYjAvRCxhQUFZdHZELFlBQVdwUSxHQUN6QixPQWo4REUrMUQsV0FnOER1Qi8xRCxHQUFYb1EsZUFDK0M7WUFHM0R1dkQsV0FBUzMvRCxHQUFJLE9BenpEYitULFNBeXpEUy9ULEdBQW9CO1lBQzdCcVosU0FBT3JaLEdBQUksT0E3MkJQOEIsT0E2MkJHOUIsR0FBa0I7WUFFekJzNEUsTUFBS2xvRSxZQUFXcFEsR0FBRzR2QixLQUFLaTdDO0lBQ3RCLFdBanZERjFqQyxJQWd2RGdCbm5DLE1BQUc0dkIsS0FBS2k3QyxNQUFuQno2RDtJQUNILE9BQUE7R0FBNkU7WUFHL0Vtb0UsVUFBU25vRSxZQUFXcFEsR0FBRzR2QixLQUFLaTdDO0lBRTVCLFdBcndEQUcsUUFtd0RvQmhyRSxNQUFHNHZCLEtBQUtpN0MsTUFBbkJ6NkQsZUFBQUE7SUFFVCxPQUFBO0dBTXFDO1lBR3JDOHRELE1BQUs5dEQsWUFBV3BRLEdBQUc0dkIsS0FBS2k3QztJQUMxQjtLQUFJLHNCQVpGME4sVUFXS25vRSxZQUFXcFEsR0FBRzR2QixLQUFLaTdDO0tBQ3RCOztnQkFDRztHQUFVO1lBR2YyTixZQUFXcG9FLFlBQVdwUSxHQUFHNHZCLEtBQUtpN0M7SUFDaEMsV0F4a0RFb0MsVUF1a0RzQmp0RSxNQUFHNHZCLEtBQUtpN0MsTUFBbkJ6NkQ7SUFDYixPQUFBO0dBQ007WUFHSnFvRSxlQUFjcm9FLFlBQVdwUSxHQUFFNHZCO0lBQzdCLFVBejBDRTYrQyxhQXcwQ3lCenVFLEdBQUU0dkIsUUFBYnhmO0lBQ2hCLE9BQUE7R0FBb0Y7WUFHbEZzb0UsYUFBWXRvRSxZQUFXcFEsR0FBRTR2QjtJQUMzQixPQTVrREV1OUMsV0Eya0R1Qm50RSxHQUFFNHZCLEtBQWJ4ZjtHQUNtRDtZQUcvRHVvRSxTQUFRdm9FLFlBQVdwUSxHQUFFNHZCLEtBQUszdkI7SUFDeEIsVUE3NUNGaXVFLE9BNDVDbUJsdUUsR0FBRTR2QixLQUFLM3ZCLE1BQWxCbVE7SUFDTixPQUFBO0dBQTRFO1lBRzlFd29FLFNBQVF4b0UsWUFBV3BRLEdBQUU0dkIsS0FBSzN2QjtJQUM1QixPQUxFMDRFO2FBSVF2b0U7YUFBV3BRO2FBQUU0dkI7c0JBQ1VpN0MsTUFBUSxXQUFLLFdBRGxCNXFFLEdBQ0s0cUUsT0FBcUI7R0FBQztZQUdyRG5LLFdBQVV0d0QsWUFBV3BRLEdBQUU0dkI7SUFDekIsT0FsbERFNUwsU0FpbERxQmhrQixHQUFFNHZCLEtBQWJ4ZixlQUFBQTtHQUtrQztZQUc1Q3F3RCxPQUFNcndELFlBQVdwUSxHQUFFNHZCLEtBQU0sT0E3bURyQjVXLEtBNm1EYWhaLEdBQUU0dkIsS0FBYnhmLGVBQThFO1lBRXBGaXhELFNBQVFqeEQsWUFBV3BRLEdBQUU0dkI7SUFDbkIsVUExOENGTSxPQXk4Q21CbHdCLEdBQUU0dkIsUUFBYnhmO0lBQ04sT0FBQTtHQUF5RTtZQUczRSt3RCxNQUFLL3dELFlBQVdwUSxHQUFFNHZCLEtBQU0sT0Eva0R4QnZWLElBK2tEZ0JyYSxHQUFFNHZCLEtBQWJ4ZixlQUE2RTtZQUNsRnlvRSxZQUFVNzRFLEdBQUdDLEdBQUksT0FqMkNiMHVFLFVBaTJDTTN1RSxHQUFHQyxHQUF3QjtZQUNyQ2taLE9BQUtuWixHQUFHQyxHQUFJLE9BeDFDUkUsS0F3MUNDSCxHQUFHQyxHQUFtQjtZQUMzQnkrQixRQUFNMStCLEdBQUdDLEdBQUksT0EvMENURyxNQSswQ0VKLEdBQUdDLEdBQW9CO1lBQzdCNjRFLGNBQVk5NEUsR0FBR0MsR0FBSSxPQXQwQ25CNHVFLFlBczBDWTd1RSxHQUFHQyxHQUEwQjtZQUV6Q2loRSxRQUFPOXdELFlBQVdoUCxJQUFHQyxJQUFJcEI7SUFDM0IsT0FyK0JFOGlCLE1BbytCa0IzaEIsSUFBR0MsSUFBSXBCLEdBQWxCbVE7R0FDc0Q7WUFHN0QwRyxNQUFJOVcsR0FBR0MsR0FBSSxPQTV6Q1BJLElBNHpDQUwsR0FBR0MsR0FBa0I7WUFDekI4NEUsT0FBSy80RSxHQUFHQyxHQUFJLE9BbHpDUkssS0FrekNDTixHQUFHQyxHQUFtQjtZQUMzQis0RSxPQUFLaDVFLEdBQUdOLE1BQU1PLEdBQUksT0F4eUNkRixLQXd5Q0NDLEdBQUdOLE1BQU1PLEdBQXlCO1lBQ3ZDNGdFLGFBQVc3Z0UsR0FBR04sTUFBTU8sR0FBRzBZLFFBQVMsT0FseUNoQ0QsV0FreUNXMVksR0FBR04sTUFBTU8sR0FBRzBZO0dBQTRDO1lBQ25FbW9ELGFBQVc5Z0UsR0FBR04sTUFBTU8sR0FBSSxPQWp4Q3BCQyxXQWl4Q09GLEdBQUdOLE1BQU1PLEdBQStCO1lBRW5EZzVFLFFBQU83b0UsWUFBV2hQLElBQUdDLElBQUkzQixNQUFNTztJQUNqQyxPQXQrQkU4dkUsUUFxK0JrQjN1RSxJQUFHQyxJQUFJM0IsTUFBTU8sR0FBeEJtUTtHQUM0RDtZQUduRThvRSxjQUFhOW9FLFlBQVdwUSxHQUFHQztJQUN6QixVQWh4Q0ZndkUsWUErd0N3Qmp2RSxHQUFHQyxHQUFkbVE7SUFDWCxPQUFBO0dBQW1FO1lBR3JFMndELFNBQVEzd0QsWUFBV3BRLEdBQUdDO0lBQ3BCLFVBOXdDRjJqQixPQTZ3Q21CNWpCLEdBQUdDLEdBQWRtUTtJQUNOLE9BQUE7R0FBOEQ7WUFHaEUrb0UsVUFBUy9vRSxZQUFXcFEsR0FBR0M7SUFDckIsVUE3d0NGMHBCLFFBNHdDb0IzcEIsR0FBR0MsR0FBZG1RO0lBQ1AsT0FBQTtHQUErRDtZQUdqRXd6RCxhQUFZeHpELFlBQVdwUSxHQUFHQztJQUN4QixVQTV3Q0Z5dEIsV0Eyd0N1QjF0QixHQUFHQyxHQUFkbVE7SUFDVixPQUFBO0dBQWtFO1lBR3BFZ3BFLGNBQWFocEUsWUFBV3BRLEdBQUdDO0lBQ3pCLFVBendDRjR0QixZQXd3Q3dCN3RCLEdBQUdDLEdBQWRtUTtJQUNYLE9BQUE7R0FBbUU7WUFHckVpcEUsaUJBQWdCanBFLFlBQVdwUSxHQUFHQztJQUNoQztLQUNFLE1BdndDQWl2RSxlQXF3QzJCbHZFLEdBQUdDLEdBQWRtUTtLQUNML007S0FBUkQ7SUFHTCxXQUhLQSxHQUFRQztHQUdUO1lBR0ZpMkUsZ0JBQWVscEUsWUFBV3BRLEdBQUdDO0lBQy9CO0tBQ0UsTUFod0NBK1QsY0E4dkMwQmhVLEdBQUdDLEdBQWRtUTtLQUNKL007S0FBUkQ7SUFHTCxXQUhLQSxHQUFRQztHQUdUO1lBR0ZrMkUsZ0JBQWVucEUsWUFBV3BRLEdBQUdDO0lBQy9CO0tBQ0UsTUFud0NBbXJDLGNBaXdDMEJwckMsR0FBR0MsR0FBZG1RO0tBQ0ovTTtLQUFSRDtJQUdMLFdBSEtBLEdBQVFDO0dBR1Q7WUFHRjQ5RCxlQUFjN3dELFlBQVdwUSxHQUFHQztJQUM5QixJQUNFLE1BcndDQWt1QixhQW13Q3lCbnVCLEdBQUdDLEdBQWRtUSxnQkFDSC9NLGVBQVJEO0lBR0wsV0FIS0EsR0FBUUM7R0FHVDtZQUdGbTJFLGlCQUFnQnBwRSxZQUFXcFE7SUFDN0I7S0FBQTtLQUVFLE1BNWlCQWlZLGVBeWlCMkJqWSxHQUFYb1EsZUFBQUE7SUFDbEIsT0FBQTtHQUtrRDtZQUdoRHN4RCxpQkFBZ0J0eEQsWUFBV3cvRCxjQUFheHVFLElBQUdDLElBQzdDLE9BcGpDRXBKLFVBbWpDZ0JtWSxlQUFXdy9ELGNBQWF4dUUsSUFBR0M7R0FDaUI7WUFHNUQxSCxRQUFPeVcsWUFBV3cvRCxjQUFheHVFLElBQUdDO0lBQ3BDLE9BcGpDRW5KLFFBbWpDT2tZLGVBQVd3L0QsY0FBYXh1RSxJQUFHQztHQUN3QjtZQUcxRG80RSxPQUFLejVFLEdBQUksT0E5K0JUMHdFLEtBOCtCSzF3RSxHQUFnQjtZQUNyQjA1RSxPQUFLMTVFLEdBQUksT0E5K0JUNnFFLEtBOCtCSzdxRSxHQUFnQjtZQUNyQjI1RSxXQUFVMUgsV0FBVWp5RSxHQUFJLE9BdDJCeEJneUUsU0FzMkJVQyxXQUFVanlFLEdBQStCO1lBRW5EeWhFLGlCQUFnQnJ4RCxZQUFXaFAsSUFBR0MsSUFBSW11RTtJQUNwQyxPQTNpQ0U1VixlQTBpQzJCeDRELElBQUdDLElBQWQrTyxlQUFrQm8vRDtHQUM2QztZQUcvRW9LLHNCQUFxQnhwRSxZQUFXaFAsSUFBR0MsSUFBSW11RSxZQUFZOXZFLE1BQU1PO0lBQzNELE9BN2lDRSt2RSxvQkE0aUNnQzV1RSxJQUFHQyxJQUFkK08sZUFBa0JvL0QsWUFBWTl2RSxNQUFNTztHQU92RDtZQUdGNDVFLFFBQU96cEUsWUFBV2hQLElBQUdDLElBQUlwQjtJQUN2QixVQWozQkY4cUIsTUFnM0JrQjNwQixJQUFHQyxJQUFJcEIsR0FBbEJtUTtJQUNMLE9BQUE7R0FBaUU7WUFHbkUwcEUsZUFBYzFwRSxZQXBLUGhQLElBQUFDLElBb0t5QnNXO0lBR2xDO1dBSGdCdkg7S0FwS0gsTUE3MkJQdE8sT0E2MkJHVDtLQXdLUCxNQXoyQkFpeEUsYUFpc0JPbHhFLElBQUFDLElBNzJCSFMsT0E2MkJHVixVQW9LeUJ1VztJQUloQyxPQUFBO0dBTThDO1lBRzlDa29ELFVBQVE3L0QsR0FBSSxPQXJzRFI0WSxRQXFzREk1WSxHQUFtQjtZQUMzQjgvRCxjQUFZOS9ELEdBQUksT0FycURoQm80RCxZQXFxRFlwNEQsR0FBdUI7WUFDbkMrL0QsVUFBUS8vRCxHQUFJLE9BaHFEUjhZLFFBZ3FESTlZLEdBQW1CO1lBQzNCZ2dFLGNBQVloZ0UsR0FBSSxPQTFwRGhCdTRELFlBMHBEWXY0RCxHQUF1QjtZQUNuQ3NnRSxVQUFRdGdFLEdBQUdDLEdBQUksT0EzNkJmc0MsUUEyNkJRdkMsR0FBR0MsR0FBc0I7WUFDakM4NUUsV0FBUy81RSxHQUFHQyxHQUFJLE9BdDZCaEJza0IsU0FzNkJTdmtCLEdBQUdDLEdBQXVCO1lBQ25Db2dFLFNBQU9yZ0UsR0FBR0MsR0FBSSxPQWo2QmRpQyxPQWk2Qk9sQyxHQUFHQyxHQUFxQjtZQUMvQis1RSxVQUFRaDZFLEdBQUdDLEdBQUksT0E1NUJmdWtCLFFBNDVCUXhrQixHQUFHQyxHQUFzQjtZQUNqQ3NnRSxRQUFNdmdFLEdBQUdDLEdBQUksT0F2NUJibVksTUF1NUJNcFksR0FBR0MsR0FBb0I7WUFDN0JnNkUsU0FBT2o2RSxHQUFHQyxHQUFJLE9BcDVCZHN0QixPQW81Qk92dEIsR0FBR0MsR0FBcUI7WUFDL0JxaUUsUUFBT2x5RCxZQUFXcFEsR0FBRXd2QixHQUFJLE9BbnpEcEIybkIsTUFtekRjbjNDLEdBQUV3dkIsR0FBYnBmLGVBQTJFO1lBRWxGOHBFLFNBQVE5cEUsWUFBWWc5RCxZQUFZQztJQUNsQyxPQXRwREVodUUsT0FxcERvQit0RSxZQUFZQyxZQUF4Qmo5RDtHQUNxRTtZQUc3RStwRSxXQUFVL3BFLFlBQVdwUSxHQUFHK2MsYUFBYUM7SUFDdkMsSUFBT3hWLE1BeHhETGlsRSxZQXV4RHFCenNFLEdBQUcrYyxhQUFhQyxhQUEzQjVNO0lBUVosT0FQTzVJO0dBT0o7WUFHRDR5RSx1QkFBc0JocUUsWUFBV3BRLEdBQUd2USxLQUFLRCxLQUFLa1EsTUFBTU87SUFDdEQsT0EzcERFNnRFLHFCQTBwRGlDOXRFLEdBQUd2USxLQUFLRCxLQUFLa1EsTUFBTU8sR0FBOUJtUTtHQU9vQjtZQUcxQ2lxRSxpQkFBZ0JqcUUsWUFBV3BRLEdBQUd2USxLQUFLRDtJQUNyQyxPQWpvREV1K0UsZUFnb0QyQi90RSxHQUFHdlEsS0FBS0QsS0FBbkI0Z0I7R0FDeUQ7WUFHekVrcUUsY0FBYWxxRSxZQUFXcFEsR0FBRW11QyxLQUFJdmU7SUFDaEMsT0FwMEJFK2lELFlBbTBCd0IzeUUsR0FBRW11QyxLQUFJdmUsS0FBakJ4ZjtHQUN1RDtZQUdwRW1xRSxNQUFJdjZFLEdBQUV3UyxHQUFJLE9BbnlCVjBzRCxNQW15QklsL0QsR0FBRXdTLEdBQWlCO1lBQ3ZCZ29FLFVBREl4NkUsR0FBRXdTO0lBQUksVUFueUJWMHNELE1BbXlCSWwvRCxHQUFFd1M7SUFDeUIsT0FBQTtHQUFTO1lBQ3hDaW9FLE9BQU1ycUUsWUFBV3BRLEdBQUU0dkIsS0FBTSxPQXYwQnJCcWpELEtBdTBCYWp6RSxHQUFFNHZCLEtBQWJ4ZixlQUE4RTtZQUNwRnFsRCxZQUFVeWhCLFdBQVVDLGtCQUFZbjNFLEdBQUksT0FscEJwQyt1QixZQWtwQlVtb0QsV0FBVUMsV0FBWW4zRTtHQUF5QztZQUV6RXkvRCxtQkFBa0JydkQsWUFBV3NxRSxXQUFVQyxXQUFVM3ZFO0lBQy9DLFVBeHFCRit4RCxpQkF1cUI2QjJkLFdBQVVDLFdBQVUzdkUsTUFBL0JvRjtJQUNoQixPQUFBO0dBQTZEO1lBRy9Ec3lEO0lBQWF0eUQsWUFBWTRRLE9BQU95dUQsMEJBQTBCQyx1QkFBc0IxdkU7SUFDbEYsT0E3cUNFd3JDO2FBNHFDYXA3QjthQUFZNFE7YUFBT3l1RDthQUEwQkM7YUFBc0IxdkU7R0FDSTtZQUdwRjJpRSx1QkFBNEIzaUUsR0FBRzNKLFNBQVFpbEMsS0FBSS9zQixHQUFJLE9BbnhCL0M4c0IsY0FteEI0QnI3QixHQUFHM0osU0FBUWlsQyxLQUFJL3NCO0dBQXdDO1lBRW5GcTBELGlDQUFzQzVpRSxHQUFHdzdCLFlBQVdGLEtBQ3RELE9BbHdCRUMsd0JBaXdCc0N2N0IsR0FBR3c3QixZQUFXRjtHQUNQO1lBRzdDcy9DO0lBQXdCeHFFLFlBQVdwUSxHQUFHM0osU0FBUzBtQixhQUFhQztJQUN4RDs7T0F6dUJKMjJELCtCQXd1Qm1DM3pFLEdBQUczSixTQUFTMG1CLGFBQWFDO2dCQUdwRDs7O0tBRFc2MkQ7S0FBYkQ7SUFBNkIsT0FsRG5DdUcsV0FnRHdCL3BFLFlBQVdwUSxHQUU3QjR6RSxlQUFhQztHQUNOO1lBR2JnSCxXQUFVenFFLFlBQVdwUSxHQUFHQztJQUNwQixJQUVKNjZFLE1BL3BCQXRHLFNBNHBCcUJ4MEUsR0FBR0MsR0FBZG1RO2VBR1YwcUUsUUFBMkIsT0FBM0JBO1FBREs1MEUsTUFDTDQwRTtJQURjLGtCQUFUNTBFO0dBQ3lCO1lBRzlCNjBFLGVBQWMzcUUsWUFBV3BRLEdBQUdDO0lBQVEsVUFycEJwQ3cwRSxhQXFwQnlCejBFLEdBQUdDLEdBQWRtUTtJQUFzQixPQUFBO0dBQXFDO1lBT3ZFNHFFLFVBQVFoN0UsR0FBR29RLFlBQVl3ZixLQUFLaTdDO0lBQ3hCLFlBeDZESlcsUUF1NkRReHJFOztTQUVIMnJFO0tBQWMsUUFBQSxXQUZSdjdELGVBRU51N0QsVUFGa0IvN0M7TUFHdkIsT0FBQTs7SUFDSyxPQWw4REx5N0MsY0E4N0RRcnJFLEdBQWU0dkIsS0FBS2k3QztHQUkwQjtZQUd0RDlFLFVBQVEvbEUsR0FBSSxPQTM3RFp1ckUsa0JBMjdEUXZyRSxHQUE4QztHQVpsQyxJQUFBLHVCQUdwQmtoQyxPQUVBODVDLFdBT0FqVjtZQVNGakMsUUFBTzF6RDtJQUFhLFdBQWJBLFlBM1dQdW9EO0dBMldrRTtZQUNsRXdLLFlBQVcveUQsWUFBV3dmLEtBQUVpN0MsTUFBSSxXQUFqQno2RCxnQkFBV3dmLEtBQUVpN0M7R0FBMEQ7WUFDbEZvUSxTQUFVN3FFO1FBQWtCdE8sbUJBQU42M0Q7SUFBZ0IsV0FBNUJ2cEQsWUFBWXVwRCxNQUFNNzNEOztZQUM1Qm81RSxVQUFTOXFFLFlBQVd1cEQ7SUFBTyxPQUQzQnNoQixTQUNTN3FFLGdCQUFXdXBELE1BcG9DaEI3M0QsT0Fvb0NnQjYzRDtHQUFxRDtZQUd6RTBKLDRCQUEyQmp6RCxZQUFXeEw7SUFDeEMsT0FMRXEyRTthQUkyQjdxRSxZQTdwRTNCd21ELDBCQTZwRXNDaHlELE9BQVh3TDtHQUd1RDtZQUdsRm16RCxrQkFBaUJuekQsWUFBV3hMO0lBRTVCLFVBdnBFQWt5RCxnQkFxcEU0Qmx5RCxPQUFYd0w7SUFHZCxPQUFBOzs7c0JBQUt1cEQsTUFBUSxPQWJoQnNoQixTQVVpQjdxRSxZQUdUdXBELE1BQWlDO0dBQUM7WUFHMUN3aEIsV0FBVS9xRSxZQUFXc2Y7SUFDakIsSUFFSnRHLElBamtDQWlvRCxTQThqQ3FCM2hELE9BQVh0ZjtlQUdWZ1osTUFBeUIsT0FBekJBO2dCQUFBQSxNQURXdG5CLG1CQUFONjNEO0lBQWlCLHNCQUZadnBELFlBRUx1cEQsTUFBTTczRDtHQUNlO1lBRzFCczVFLG9CQUFtQmhyRSxZQUFXc2Y7SUFDckIsVUFwa0NUNGhELGtCQW1rQzhCNWhELE9BQVh0ZjtJQUNxQyxPQUFBOzs7c0JBQUt1cEQsTUFDN0QsT0F4QkFzaEIsU0FzQm1CN3FFLFlBQzBDdXBELE1BQ3BDO0dBQUM7WUFHMUIwaEIsZUFBY2pyRSxZQUFXc2Y7SUFDM0IsT0E1QkV1ckQsU0EyQmM3cUUsWUF2a0NkbWhFLGFBdWtDeUI3aEQsT0FBWHRmO0dBQzJDO1lBR3pEa3JFLGlCQUFnQmxyRSxZQUFXc2Y7SUFDN0IsT0FoQ0V1ckQsU0ErQmdCN3FFLFlBamtDaEJxaEUsZUFpa0MyQi9oRCxPQUFYdGY7R0FHdUQ7WUFHdkVtckUsZ0JBQWVuckUsWUFBV3NmLE9BQU9od0IsTUFBTU87SUFDekMsT0F0Q0VnN0UsU0FxQ2U3cUUsWUFybENmK2dFLGNBcWxDMEJ6aEQsT0FBT2h3QixNQUFNTyxHQUF4Qm1RO0dBR2dFO1lBRy9Fb3JFLGtCQUFpQnByRSxZQUFXc2YsT0FBT3p2QjtJQUNyQyxPQTVDRWc3RSxTQTJDaUI3cUUsWUExbENqQmdoRSxnQkEwbEM0QjFoRCxPQUFPenZCLEdBQWxCbVE7R0FHMEQ7WUFHM0VxckUsV0FBVXJyRSxZQUFZaFE7SUFDbEIsSUFFSmdwQixJQW55QkEwcUQsU0FneUJzQjF6RSxPQUFaZ1E7ZUFHVmdaLE1BQXlCLE9BQXpCQTtRQURJc3lELGNBQ0p0eUQ7SUFEbUIsa0JBbkRuQjZ4RCxTQWlEVTdxRSxZQUVOc3JFO0dBQ3NCO1lBRzFCQyxlQUFjdnJFLFlBQVloUTtJQUM1QixPQXhERTY2RSxTQXVEYzdxRSxZQXp4QmQyakUsYUF5eEIwQjN6RSxPQUFaZ1E7R0FDNEM7WUFHMURrekQsaUNBQWtDbHpELFlBQVlqUixLQUFLYztJQUNyRCxPQTVERWc3RTthQTJEa0M3cUUsZ0JBL3VFbENnbUQsK0JBK3VFOENqM0QsS0FBS2MsSUFBTGQ7R0FDMEI7WUFHeEV5OEUseUJBQXdCeHJFLFlBQVd5MkI7SUFHbkMsVUFyL0RBNGtDLHVCQWsvRG1DNWtDLEtBQVh6MkI7SUFFckIsT0FBQTs7OzJCLE9BakVINnFFLFNBK0R3QjdxRTtHQUdxRDtZQUc3RXF6RCxjQUFhcnpELFlBQVd5MkI7SUFDcEIsSUFFSnpkLElBNWxDQTRkLFlBeWxDd0JILEtBQVh6MkI7ZUFHYmdaLE1BQXlCLE9BQXpCQTtnQkFBQUEsTUFEV3RuQixtQkFBTjYzRDtJQUFpQixzQkFGVHZwRCxZQUVSdXBELE1BQU03M0Q7R0FDZTtZQUcxQis1RSx1QkFBc0J6ckUsWUFBV3kyQjtJQUN4QixVQS9sQ1RnckMscUJBOGxDaUNockMsS0FBWHoyQjtJQUNtQyxPQUFBOzs7c0JBQUt1cEQsTUFDOUQsT0E3RUFzaEIsU0EyRXNCN3FFLFlBQ3dDdXBELE1BQ3JDO0dBQUM7WUFHMUJtaUIsa0JBQWlCMXJFLFlBQVd5MkI7SUFDOUIsT0FqRkVvMEMsU0FnRmlCN3FFLFlBbG1DakIwaEUsZ0JBa21DNEJqckMsS0FBWHoyQjtHQUN5QztZQUcxRDJyRSxvQkFBbUIzckUsWUFBV3kyQjtJQUNoQyxPQXJGRW8wQyxTQW9GbUI3cUUsWUFwbUNuQjJoRSxrQkFvbUM4QmxyQyxLQUFYejJCO0dBR3FEO1lBR3hFNHJFLG1CQUFrQjVyRSxZQUFXeTJCLEtBQUtubkMsTUFBTU87SUFDMUMsT0EzRkVnN0UsU0EwRmtCN3FFLFlBaG5DbEJ1aEUsaUJBZ25DNkI5cUMsS0FBS25uQyxNQUFNTyxHQUF0Qm1RO0dBRzhEO1lBR2hGNnJFLHFCQUFvQjdyRSxZQUFXeTJCLEtBQUs1bUM7SUFDdEMsT0FqR0VnN0UsU0FnR29CN3FFLFlBcm5DcEJ3aEUsbUJBcW5DK0IvcUMsS0FBSzVtQyxHQUFoQm1RO0dBR3dEO1lBRzVFNnlELG1CQUFrQjd5RCxZQUFXc3FFLFdBQVVDLFdBQVUzdkU7SUFDbkQsT0F2R0Vpd0U7YUFzR2tCN3FFO2FBaDBCbEIyc0QsaUJBZzBCNkIyZCxXQUFVQyxXQUFVM3ZFLE1BQS9Cb0Y7R0FDOEQ7WUFHaEY4ckUsV0FBVTlyRSxZQUFXcFEsR0FBR0M7SUFDcEIsSUFFSjY2RSxNQXh5QkF0RyxTQXF5QnFCeDBFLE1BQUdDLEdBQWRtUTtlQUdWMHFFLFFBQTJCLE9BQTNCQTtRQURJM0gsT0FDSjJIO0lBRFksa0JBNUdaRyxTQTBHVTdxRSxZQUVOK2lFO0dBQzBCO1lBRzlCZ0osZUFBYy9yRSxZQUFXcFEsR0FBR0M7SUFDOUIsT0FqSEVnN0UsU0FnSGM3cUUsWUE5eEJkcWtFLGFBOHhCeUJ6MEUsTUFBR0MsR0FBZG1RO0dBQytDOztJQUluRCxJQUFSOHdCLGtCQWxlRnkzQjtJQWlleUQsV0FDdkR6M0I7O1lBV0oyaUMsYUFBMEI3akUsR0FDNUIsSUFJTW9RLGFBTHNCcFEsTUFDcEIsV0FJRm9RLFlBQ0Y7WUFLRmdzRSxVQUFzQjlqRTtJLGdCQUFrQ3FoRCxNQUMxRCxPQXJ4QkVxSixVQW94QnNCMXFELE1BQWtDcWhELE1BQ3JCOztZQUduQ3VMLFFBTjRCMXJELEdBTWxCLE9BakpSc3FELFFBMkkwQnRxRCxNQU1rQztZQUM5RHVxRCxZQVA0QnZxRCxHQU9oQnBXO0lBQUksVUFQWW9XO0lBT1oscUIsT0FqSmQycEQsaUJBaUpVLy9EO0dBQThEO1lBQzFFaTVFLFdBUjRCN2lFLEdBUWpCcFcsR0FBSSxPQWpJYiszRSxXQXlIMEIzaEUsTUFRakJwVyxHQUE2RDtZQUV4RWs1RSxvQkFWNEI5aUUsR0FVUnBXLEdBQ3RCLE9BOUhJZzRFLG9CQW1IMEI1aEUsTUFVUnBXLEdBQzRDO1lBR2hFbTVFLGVBZDRCL2lFLEdBY2JwVyxHQUFJLE9BNUhqQmk0RSxlQThHMEI3aEUsTUFjYnBXLEdBQWlFO1lBQ2hGbzVFLGlCQWY0QmhqRSxHQWVYcFcsR0FBSSxPQXpIbkJrNEUsaUJBMEcwQjloRSxNQWVYcFcsR0FBbUU7WUFFcEZxNUUsZ0JBakI0QmpqRSxHQWlCWnBXLEdBQUcxRCxNQUFNTztJQUMzQixPQXRISXM3RSxnQkFvRzBCL2hFLE1BaUJacFcsR0FBRzFELE1BQU1PO0dBQzRDO1lBR3JFeThFLGtCQXJCNEJsakUsR0FxQlZwVyxHQUFHbkQsR0FDdkIsT0FwSEl1N0Usa0JBOEYwQmhpRSxNQXFCVnBXLEdBQUduRCxHQUM0QztZQUdqRWdrRSw0QkF6QjRCenFELEdBeUJBcFc7SUFDOUIsT0EvSklpZ0UsNEJBcUkwQjdwRCxNQXlCQXBXO0dBQzRDO1lBR3hFK2dFLGtCQTdCNEIzcUQsR0E2QlZwVyxHQUFJLE9BNUpwQm1nRSxrQkErSDBCL3BELE1BNkJWcFcsR0FBb0U7WUFDdEZ1NUUsV0E5QjRCbmpFLEdBOEJoQnBaLE9BQVEsT0F0SGxCcTdFLFdBd0YwQmppRSxNQThCaEJwWixPQUFzRTtZQUVsRnc4RSxlQWhDNEJwakUsR0FnQ1pwWixPQUNsQixPQW5ISXU3RSxlQWtGMEJuaUUsTUFnQ1pwWixPQUNnRDtZQUdoRThqRSxpQ0FwQzRCMXFELEdBb0NRcmEsS0FBS2M7SUFDM0MsT0FuSElxakUsaUNBOEUwQjlwRCxNQW9DUXJhLEtBQUtjO0dBQzRDO1lBR3JGNDhFLHlCQXhDNEJyakUsR0F3Q0hxdEI7SUFDM0IsT0FuSEkrMEMseUJBMEUwQnBpRSxNQXdDSHF0QjtHQUM4QztZQUd2RXc5QixjQTVDNEI3cUQsR0E0Q2Q5YixHQUFJLE9BaEhoQitsRSxjQW9FMEJqcUQsTUE0Q2Q5YixHQUFnRTtZQUU5RW8vRSx1QkE5QzRCdGpFLEdBOENMOWI7SUFDekIsT0E3R0ltK0UsdUJBOEQwQnJpRSxNQThDTDliO0dBQzRDO1lBR25FcS9FLGtCQWxENEJ2akUsR0FrRFY5YixHQUFJLE9BM0dwQm8rRSxrQkF5RDBCdGlFLE1Ba0RWOWIsR0FBb0U7WUFFdEZzL0Usb0JBcEQ0QnhqRSxHQW9EUjliLEdBQ3RCLE9BMUdJcStFLG9CQXFEMEJ2aUUsTUFvRFI5YixHQUM0QztZQUdoRXUvRSxtQkF4RDRCempFLEdBd0RUOWIsR0FBR2dDLE1BQU1PO0lBQzlCLE9BeEdJKzdFLG1CQStDMEJ4aUUsTUF3RFQ5YixHQUFHZ0MsTUFBTU87R0FDNEM7WUFHeEVpOUUscUJBNUQ0QjFqRSxHQTREUDliLEdBQUd1QztJQUMxQixPQXRHSWc4RSxxQkF5QzBCemlFLE1BNERQOWIsR0FBR3VDO0dBQzRDO1lBR3BFazlFLFdBaEU0QjNqRSxHQWdFakJ4WixHQUFHQyxHQUFJLE9BL0ZoQmk4RSxXQStCMEIxaUUsTUFnRWpCeFosR0FBR0MsR0FBZ0U7WUFDOUVtOUUsZUFBYTVqRSxHQUFFeFosR0FBR0MsR0FBSSxPQTFGcEJrOEUsZUEwRlczaUUsTUFBRXhaLEdBQUdDLEdBQW9FO2lCQU0xRixXQUVHO1lBZ0NDd2tFLFlBQThCNFk7SSxnQkFBK0JsRyxXQUFVbjNFO0tBQ3pFLE9Bbm9CSXUxQyxZQWtvQjRCOG5DLE1BQStCbEcsMkJBQ3JCLFdBQWEsR0FEa0JuM0UsR0FDZjs7WUFHeEQya0UsWUFFVTBZO0ksZ0JBQ1IxQyxXQUNBM3ZFO0tBRUosT0F0SklpNEQsbUJBa0pRb2EsTUFBQUEsTUFDUjFDLFdBQ0EzdkUsTUFFaUY7O1lBR25GNDVELGlCQUVVeVk7SSxnQkFDUEM7S0FHTCx1QkFKWUQsVUFDUEMsa0JBTUo7O1lBR0N6WSxtQkFBb0MwWSxXQUFVbjhFLElBQUdDLElBQUssT0E5d0JwRG05RCxlQTh3QmtDK2UsV0FBVW44RSxJQUFHQztHQUFtQztZQUNwRnlqRSxpQkFBZ0MwWSxTQUFRcDhFLElBQUdDLElBQUssT0Ezd0I5Q3ZJLFFBMndCOEIwa0YsU0FBUXA4RSxJQUFHQztHQUF3QjtZQUVuRTBqRSxjQUFnQ3NZO0ksZ0JBQWlDSSxhQUFZeDNFO0tBQy9FLFVBRGtDbzNFO0tBQ2xDO00sT0E5b0JJN2Qsc0JBNm9CK0RpZSxhQUFZeDNFLGNBQy9COztPQVU1Q2cvRDtZQUNBeVksVUFBUS9qQixNQUFPLFdBRGZzTCxjQUNRdEwsTUE3NUNKNzNELE9BNjVDSTYzRCxPQUF1RDs7O0lBcks3RGdrQjtZQXlLRnhZLFlBQVUvaEU7SUFBSSxxQixPQS9SZCsvRCxZQTBSQThCLGNBS1U3aEU7R0FBNEM7WUFDdER3NkUsV0FBU3g2RSxHQUFJLE9BL1FiKzNFLFdBeVFBbFcsY0FNUzdoRSxHQUEyQztZQUNwRHk2RSxvQkFBa0J6NkU7SUFBSSxPQTFRdEJnNEUsb0JBbVFBblcsY0FPa0I3aEU7R0FBb0Q7WUFDdEUwNkUsZUFBYTE2RSxHQUFJLE9BdFFqQmk0RSxlQThQQXBXLGNBUWE3aEUsR0FBK0M7WUFDNUQyNkUsaUJBQWUzNkUsR0FBSSxPQW5RbkJrNEUsaUJBMFBBclcsY0FTZTdoRSxHQUFpRDtZQUNoRTQ2RSxnQkFBYzU2RSxHQUFHMUQsTUFBTU87SUFBSSxPQTlQM0JzN0UsZ0JBb1BBdFcsY0FVYzdoRSxHQUFHMUQsTUFBTU87R0FBeUQ7WUFDaEZnK0Usa0JBQWdCNzZFLEdBQUduRDtJQUFJLE9BelB2QnU3RSxrQkE4T0F2VyxjQVdnQjdoRSxHQUFHbkQ7R0FBcUQ7WUFFeEVvbEUsNEJBQTBCamlFO0lBQzVCLE9BblNFaWdFLDRCQXFSQTRCLGNBYTBCN2hFO0dBQzRCO1lBR3REbWlFLGtCQUFnQm5pRSxHQUFJLE9BaFNwQm1nRSxrQkErUUEwQixjQWlCZ0I3aEUsR0FBa0Q7WUFDbEU4NkUsV0FBVTk5RSxPQUFRLE9BMVBsQnE3RSxXQXdPQXhXLGNBa0JVN2tFLE9BQW9EO1lBQzlEKzlFLGVBQWMvOUUsT0FBUSxPQXJQdEJ1N0UsZUFrT0ExVyxjQW1CYzdrRSxPQUF3RDtZQUV0RWtsRSxpQ0FBa0NubUUsS0FBS2M7SUFDekMsT0FwUEVxakUsaUNBOE5BMkIsY0FxQmtDOWxFLEtBQUtjO0dBQzRCO1lBR25FbStFLHlCQUF1QnYzQztJQUFNLE9BblA3QiswQyx5QkEwTkEzVyxjQXlCdUJwK0I7R0FBNkQ7WUFDcEY0K0IsY0FBWS9uRSxHQUFJLE9BOU9oQitsRSxjQW9OQXdCLGNBMEJZdm5FLEdBQThDO1lBQzFEMmdGLHVCQUFxQjNnRjtJQUFJLE9Bek96Qm0rRSx1QkE4TUE1VyxjQTJCcUJ2bkU7R0FBdUQ7WUFDNUU0Z0Ysa0JBQWdCNWdGLEdBQUksT0FyT3BCbytFLGtCQXlNQTdXLGNBNEJnQnZuRSxHQUFrRDtZQUNsRTZnRixvQkFBa0I3Z0Y7SUFBSSxPQWxPdEJxK0Usb0JBcU1BOVcsY0E2QmtCdm5FO0dBQW9EO1lBRXRFOGdGLG1CQUFpQjlnRixHQUFHZ0MsTUFBTU87SUFDNUIsT0EvTkUrN0UsbUJBK0xBL1csY0ErQmlCdm5FLEdBQUdnQyxNQUFNTztHQUM0QjtZQUd0RHcrRSxxQkFBbUIvZ0YsR0FBR3VDO0lBQUksT0E1TjFCZzhFLHFCQXlMQWhYLGNBbUNtQnZuRSxHQUFHdUM7R0FBd0Q7WUFDOUV5K0UsV0FBUzErRSxHQUFHQyxHQUFJLE9Bbk5oQmk4RSxXQStLQWpYLGNBb0NTamxFLEdBQUdDLEdBQThDO1lBQzFEMCtFLGVBQWEzK0UsR0FBR0MsR0FBSSxPQTlNcEJrOEUsZUF5S0FsWCxjQXFDYWpsRSxHQUFHQyxHQUFrRDs7Ozs7O09BNzdCbEV3OUQ7T0ErdkJGb0c7T0Fsd0JFenpEO09BaXhCRjgwRDtPQUNBbkI7T0FDQXNZO09BRUFDO09BSUFDO09BQ0FDO09BRUFDO09BSUFDO09BU0FDO09BRUFDO09BSEF6WTtPQUpBRjtPQVdBQztPQUlBMlk7T0FJQXhZO09BRUF5WTtPQUlBQztPQUVBQztPQUlBQztPQUlBQztPQWgwQkU1akU7T0FDQUY7T0FFQTI3RDtPQTRCQTVrRDtPQXhCQTZrRDtPQThCQUM7T0FNQUM7T0FJQUM7T0FFQUM7T0FJQUM7T0FZQXg3RDtPQVJBa1c7T0FVQW91QztPQU1BbHVDO09BQ0FxbEQ7T0FDQXA4RDtPQUNBdWxCO09BQ0E4MkM7T0FDQXZYO09BQ0F0dkQ7T0FDQTJ3QztPQW92QkY4OUI7T0FDQUM7T0FwdkJFNUg7T0FDQXI3RDtPQUNBNGpEO09BRUEwWDtPQUlBQztPQUNBelg7T0FDQTBYO09BQ0EzVTtPQUNBNFU7T0FFQUM7T0FJQUM7T0FJQUM7T0FJQWpYO09BSUFrWDtPQVNBeFg7T0FvSUFnQjtPQWhJQTFtRTtPQUNBbTlFO09BQ0EvSTtPQUNBZ0o7T0FnQkFFO09BSUFDOztPQWxCQTlYO09BSUE0WDtPQTJCQW44RDtPQUNBMmpEO09BQ0ExakQ7T0FDQTJqRDtPQUNBamtEO09BQ0FvbEI7T0FDQXJsQjtPQUNBb2xCO09BQ0FybEI7T0FDQW9sQjtPQUVBc2Y7T0FpQ0EwNEI7T0FsQkFMO09Ba0NBTTtPQUlBQztPQUlBQztPQUlBelU7T0FDQTFnRDtPQUNBbzFEO09BR0E3WDtPQVNBQztPQUVBQztPQVFBZ1k7O09BNm1CRjdTO09BSUFFO09BU0FDO09BWUFDO09BQ0FDO09BRUFDOztRQTlwQkV4dkI7UUFzZkEwdEI7O1NBM0pBeE47U0FFQWdLO1NBelRBeUQ7U0FFQXY5QjtTQTJVQWsxQztTQU1BRTtTQXRVQXhEO1NBTUFDO1NBSUFDO1NBRUFDO1NBSUFDO1NBSUFDO1NBekJBMVY7U0FKQUY7U0F5Q0FDO1NBSUErVjtTQU1BbFc7U0FNQW1XO1NBSUFDO1NBRUFDO1NBSUFDO1NBSUFDO1NBdENBUjtTQU1BQztTQTFDQWhTO1NBZ0ZBcEc7U0FJQUM7U0FDQXRtRDtTQWlCQTZrRDtTQVhBcWE7U0FKQUQ7U0FvQkFFO1NBS0FDO1NBSUFDO1NBSUFDO1NBSUFDO1NBWUFuWTtTQVJBQztTQVVBVztTQUlBRjtTQUNBMFg7U0FDQTEvRDtTQUNBdWxCO1NBQ0FvNkM7U0FFQTVYO1NBSUFwcUQ7U0FDQWlpRTtTQUNBQztTQUNBblk7U0FDQUM7U0FFQW1ZO1NBSUFDO1NBSUFuWTtTQUlBb1k7U0FJQXZWO1NBSUF3VjtTQUlBQztTQU9BQztTQU9BQztTQU9BdFk7U0FPQXVZO1NBU0E5WDtTQUlBL25FO1NBSUE4L0U7U0FDQUM7U0FDQUM7U0FnQkFFO1NBSUFDO1NBbEJBclk7U0FJQW1ZO1NBMkJBL1o7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQU07U0FDQXlaO1NBQ0ExWjtTQUNBMlo7U0FDQXpaO1NBQ0EwWjtTQUNBM1g7U0FFQTRYO1NBSUFDO1NBV0FDO1NBVUFDO1NBSUFDO1NBSUFDO1NBQ0FDO1NBQ0FDO1NBdk9BMVg7U0E4T0FMO1NBSUFDO1NBRUFDO1NBSUFnWTtTQXhVQWppQjs7UUFsUkE4RTtRQUlBbmtEO1FBQ0FGO1FBOEJBK1c7UUF4QkE2a0Q7UUFKQUQ7UUFrQ0FFO1FBTUFDO1FBSUFDO1FBRUFDO1FBSUFDO1FBWUF4N0Q7UUFSQWtXO1FBVUFvdUM7UUFNQWx1QztRQUNBcWxEO1FBQ0FwOEQ7UUFDQXVsQjtRQUNBODJDO1FBQ0F2WDtRQUNBdHZEO1FBQ0Eyd0M7UUFDQW0yQjtRQUNBcjdEO1FBQ0E0akQ7UUFFQTBYO1FBSUFDO1FBQ0F6WDtRQUNBMFg7UUFDQTNVO1FBQ0E0VTtRQUVBQztRQUlBQztRQUlBQztRQUlBalg7UUFJQWtYO1FBU0F4WDtRQUlBMWxFO1FBQ0FtOUU7UUFDQS9JO1FBQ0FnSjtRQWdCQUU7UUFJQUM7UUFsQkE5WDtRQUlBNFg7UUEyQkFuOEQ7UUFDQTJqRDtRQUNBMWpEO1FBQ0EyakQ7UUFDQWprRDtRQUNBb2xCO1FBQ0FybEI7UUFDQW9sQjtRQUNBcmxCO1FBQ0FvbEI7UUFFQXNmO1FBaUNBMDRCO1FBbEJBTDtRQWtDQU07UUFJQUM7UUFJQUM7UUFJQXpVO1FBQ0ExZ0Q7UUFDQW8xRDtRQWhQQTdkO1FBbVBBZ0c7UUFTQUM7UUFFQUM7UUFRQWdZO1FBeVhBeFQ7UUFDQVg7UUEyR0ErWTtRQU1BQztRQWhHQWhCO1FBTUFDO1FBS0FDO1FBSUFDO1FBTUFDO1FBTUFDO1FBakNBalk7UUFOQUY7UUF1REFDO1FBSUFzWTtRQU1Bblk7UUFNQW9ZO1FBS0FDO1FBSUFDO1FBTUFDO1FBTUFDO1FBL0NBUjtRQU1BRTtRQXREQVQ7UUFub0JBOXFFO1FBbVFBb3ZEOzs7UUFvZkVtZTtRQXlLRnhZO1FBK0JBdVo7UUFDQUM7UUEvQkFmO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBTUExWTtRQUpBRjtRQVFBQztRQUlBOFk7UUFDQTNZO1FBQ0E0WTtRQUNBQztRQUNBQztRQUVBQztRQUlBQztRQWpCQVA7UUFDQUM7UUFsQkFUO1FBejVCQWpnQjtRQUlBbmtEO1FBQ0FGO1FBOEJBK1c7UUF4QkE2a0Q7UUFKQUQ7UUFrQ0FFO1FBTUFDO1FBSUFDO1FBRUFDO1FBSUFDO1FBWUF4N0Q7UUFSQWtXO1FBVUFvdUM7UUFNQWx1QztRQUNBcWxEO1FBQ0FwOEQ7UUFDQXVsQjtRQUNBODJDO1FBQ0F2WDtRQUNBdHZEO1FBQ0Eyd0M7UUFDQW0yQjtRQUNBcjdEO1FBQ0E0akQ7UUFFQTBYO1FBSUFDO1FBQ0F6WDtRQUNBMFg7UUFDQTNVO1FBQ0E0VTtRQUVBQztRQUlBQztRQUlBQztRQUlBalg7UUFJQWtYO1FBU0F4WDtRQUlBMWxFO1FBQ0FtOUU7UUFDQS9JO1FBQ0FnSjtRQWdCQUU7UUFJQUM7UUFsQkE5WDtRQUlBNFg7UUEyQkFuOEQ7UUFDQTJqRDtRQUNBMWpEO1FBQ0EyakQ7UUFDQWprRDtRQUNBb2xCO1FBQ0FybEI7UUFDQW9sQjtRQUNBcmxCO1FBQ0FvbEI7UUFFQXNmO1FBaUNBMDRCO1FBbEJBTDtRQWtDQU07UUFJQUM7UUFJQUM7UUFJQXpVO1FBQ0ExZ0Q7UUFDQW8xRDtRQWhQQTdkO1FBbVBBZ0c7UUFTQUM7UUFFQUM7UUFRQWdZO09Bc2dCRjhFO09BNXdCRWhqQjs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7OztJQzNxREZsNkQ7SUFDQWdzRDtJQUNBMXJEO0lBQ0F1VTtJQUNBalM7SUFDQXFtRTtJQUNBN2I7SUFDQUg7SUFDQXl5QjtZQUNBeitFLEtBQUtILEdBQUdDLEdBQUksT0FBQSw2QkFBSkEsR0FBSEQsR0FBMEI7WUFDL0JELEtBQUtDLEdBQUdOLE1BQU1PLEdBQUksT0FBQSw2QkFBSkEsR0FBTlAsTUFBSE0sR0FBcUM7Ozs7T0FWMUNkO09BQ0Fnc0Q7T0FDQTFyRDtPQUNBdVU7T0FDQWpTO09BQ0FxbUU7T0FDQTdiO09BQ0FIO09BQ0F5eUI7T0FDQXorRTtPQUNBSjs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQ1hBOG5FLFFBQVE3bkUsR0FBRTFRLEdBQUksT0FBQSxrQ0FBSkEsR0FBRjBRLEdBQTRCO1lBQ3BDZ29FLFFBQVFob0U7SUFBSSxPQUFHLHFCQUFQQTs7a0JBQXNDLGtDQUF0Q0E7R0FBMkQ7T0FDbkUrbkU7WUFDQUksS0FBS25vRTtJQUFJLE9BQUcscUJBQVBBOztrQkFBc0Msa0NBQXRDQTtHQUE0RDtHQU90RDtJQU5Yb29FO0lBTUlsdkQ7SUFDQUU7Ozs7a0JBREFGLFFBQ0FFO0lBS0poQjtJQUNBbFc7SUFDQThXO0lBQ0FEO0lBQ0FSO0lBQ0FHO0lBQ0FuVztJQUNBdVc7SUFDQXVCO0lBQ0F6QjtJQUNBUDtJQUNBdlk7SUFDQXl0QjtJQUNBL0k7SUFDQUo7SUFDQUg7SUFDQXlGO0lBQ0FuRjtJQUNBbmtCO1lBQ0F3K0UsU0FBVWhqRCxLQUFLRTtJQUFNLE9BQUEsa0NBQVhGLEtBQUtFO0dBQW9DO1lBRW5EbFIsV0FBVzVxQixHQUFHQztJQUNOLElBQU5pRCxNQUFNO0lBQ1Y7O01BRmFsRDtlQUVFb0Q7T0FBZSxVQUFBLFdBRmRuRCxHQUVEbUQ7T0FBd0IsT0FBQTs0Q0FBS0MsR0FBSyxPQXZDL0N3a0UsUUFzQ0Uza0UsS0FDd0NHLEdBQWtCO01BQUM7SUFBL0QsT0FESUg7R0FFRDtZQUdEMm5CLFlBQVk3cUIsR0FBR0M7SUFDUCxJQUFOaUQsTUFBTTtJQUNWO01BWEU5QztNQVNZSjtlQUVFL0csR0FBRW1LO09BQWUsVUFBQSxXQUZoQm5ELEdBRURoSCxHQUFFbUs7T0FBMEIsT0FBQTs0Q0FBS0MsR0FBSyxPQTdDcER3a0UsUUE0Q0Uza0UsS0FDNkNHLEdBQWtCO01BQUM7SUFBcEUsT0FESUg7R0FFRDtZQUdEd3FCLFdBQVcxdEIsR0FBR0M7SUFDTixJQUFOaUQsTUFBTTtJQUNWOztNQUZhbEQ7ZUFFRW9EO09BQ1AsWUFBQSxXQUhRbkQsR0FFRG1EO21CQUVIO1dBQ0hDO09BQUssT0F0RFp3a0UsUUFrREUza0UsS0FJS0c7TUFBa0I7SUFIM0IsT0FESUg7R0FLRDtZQUdEMnFCLFlBQVk3dEIsR0FBR0M7SUFDUCxJQUFOaUQsTUFBTTtJQUNWO01BMUJFOUM7TUF3QllKO2VBRUUvRyxHQUFFbUs7T0FDVixZQUFBLFdBSFNuRCxHQUVEaEgsR0FBRW1LO21CQUVOO1dBQ0hDO09BQUssT0EvRFp3a0UsUUEyREUza0UsS0FJS0c7TUFBa0I7SUFIM0IsT0FESUg7R0FLRDtZQUdEMGdCLE9BQU81akIsR0FBR0M7SUFDRixJQUFOaUQsTUFBTTtJQUNWOztNQUZTbEQ7ZUFFTW9EO09BQVEsVUFBQSxXQUZYbkQsR0FFR21EO09BQVEsYUFyRXJCeWtFLFFBb0VFM2tFLEtBQ1dFO01BQThCO0lBQTdDLE9BRElGO0dBRUQ7WUFHRHltQixRQUFRM3BCLEdBQUdDO0lBQ0gsSUFBTmlELE1BQU07SUFDVjtNQXpDRTlDO01BdUNRSjtlQUVNL0csR0FBRW1LO09BQVEsVUFBQSxXQUZibkQsR0FFR2hILEdBQUVtSztPQUFRLGFBM0V4QnlrRSxRQTBFRTNrRSxLQUNjRTtNQUFnQztJQUFsRCxPQURJRjtHQUVEO1lBR0Q3QyxJQUFJTCxHQUFHQztJQUNDLElBQU5pRCxNQUFNO0lBQ1YsaUJBRk1sRCxZQUVTb0QsR0FBSyxPQWpGbEJ5a0UsUUFnRkUza0UsS0FDNEIsV0FGdkJqRCxHQUVNbUQsSUFBc0I7SUFBckMsT0FESUY7R0FFRDtZQUdENUMsS0FBS04sR0FBR0M7SUFDQSxJQUFOaUQsTUFBTTtJQUNWO01BckRFOUMsT0FtREtKLFlBRVMvRyxHQUFFbUssR0FBSyxPQXZGckJ5a0UsUUFzRkUza0UsS0FDK0IsV0FGekJqRCxHQUVNaEgsR0FBRW1LLElBQXdCO0lBQTFDLE9BRElGO0dBRUQ7WUFHRDBsRSxlQUFlaVcsR0FBRzUrRTtJQUNYLElBQUw2K0UsTUF6QkZsN0QsT0F3QmVpN0QsR0FBRzUrRTtJQUVwQixrQkFGaUI0K0U7SUFFakIsT0ExREVELFNBeURFRSxLQURhRDtHQUdNO1lBR3JCaFcsZ0JBQWdCZ1csR0FBRzUrRTtJQUNaLElBQUw2K0UsTUF6QkZuMUQsUUF3QmdCazFELEdBQUc1K0U7SUFFckIsa0JBRmtCNCtFO0lBRWxCLE9BaEVFRCxTQStERUUsS0FEY0Q7R0FHSztZQUdyQm5XLFlBQVkxb0UsR0FBRXNFO0lBQU8sT0FBa0IseUJBQXpCQSxlQUE4QmhWLEdBQUssT0F2R2pEdTRFLFFBdUdZN25FLEdBQWdDMVEsR0FBZ0I7R0FBQztZQUU3RHNRLFFBQVEwRTtJQUNGLElBQUp0RSxJQUFJO0lBQ1IseUJBRlVzRSxlQUVhaFYsR0FBSyxPQTNHMUJ1NEUsUUEwR0U3bkUsR0FDbUIxUSxHQUFnQjtJQUF2QyxPQURJMFE7R0FFSDtZQUdDa3RDLFNBQVN0b0M7SUFDSCxJQUFKNUUsSUFBSTtJQUNSLDBCQUZXNEUsZ0JBRWN0VixHQUFLLE9Bakg1QnU0RSxRQWdIRTduRSxHQUNxQjFRLEdBQWdCO0lBQXpDLE9BREkwUTtHQUVIO1lBR0NOLEtBQUtQLEtBQUtjO0lBQ1o7S0FBSUQsSUFBSTtLQUNLLE1BQUEsNEJBRk5iO0tBQ0M7O1NBQ1JsRzs7TUF2SEU0dUUsUUFzSEU3bkUsR0FFUSxXQUhBQyxHQUVaaEg7TUFDRSxVQURGQTtpQkFBQUE7TUFBQUE7OztJQUdBLE9BSkkrRztHQUlIO1lBR0NpWixTQUFTalo7SUFDTCxJQUVKYixNQUZJLG1CQURLYTthQUdUYixLQURLO0lBRXVCO0tBQUEsTUFBQSxXQTdINUJpcEUsVUF5SFNwb0U7S0FJTDB4QixNQUFNLDJCQURWdnlCO0tBRUlsRztJQUNKOztNQU5TK0c7ZUFNTXVPO09BQ2IsVUFGRXRWO09BRUYseUJBSEV5NEIscUJBRVduakI7T0FBZixPQUFBLDZCQURJdFY7TUFHSTtJQUZSLE9BRkl5NEI7R0FLRDtZQUdIaGhCLFVBQVV5c0IsV0FBVW55QjtJQUFPLE9BaEMzQnBMLFFBZ0NtQyw2QkFBekJ1OUIsV0FBVW55QjtHQUE0QztZQUNoRWxCLFVBQVUwUSxXQUFVeGE7SUFBMkIsVUFBQSxXQS9HL0NGLFNBK0dvQkU7SUFBMkIsT0FBQSw2QkFBckN3YTtHQUFnRDtZQUUxRDVRLGVBQXlCdWpDO0lBR0UsVUFBQSx5QkFIRkE7SUFHRSxPQUFBO0dBQTZCO1lBR3hEeEgsVUFBVXZpQztJQUNKLElBQUpwRCxJQUFJO0lBbkpONm5FLFFBbUpFN25FLEdBRFFvRDtJQUVaLE9BRElwRDtHQUVIOzs7O09BWkMwUTtPQUNBNUc7T0FFQUY7T0FwSEF5UTs7Ozs7T0FKQTlCO09BQ0FHO09BSkF4VztPQUtBSztPQU5BNlY7T0FVQUM7T0FSQVc7T0FDQUQ7T0FRQWpaO09Ba0dBbVo7T0FwR0FMO09BRkFFO09BU0E0UTtPQUVBdHBCO09BTEFva0I7T0FJQUQ7T0FMQWdKO09BR0F0SjtPQURBRztPQW9IQXVoQjtPQXpDQS9sQztPQU1Bc3RDO09BTUF4dEM7T0FySEFtb0U7T0F1R0FhO09BdEdBVjtPQUNBRDtPQUNBSTtPQUNBQzs7O09BMkVBL25FO09BTUFDO09BaERBc3FCO09BTUFDO09BTUE2QztPQVNBRztPQVNBaks7T0FNQStGO09Ba0JBaS9DO09BTUFDOztPQTlEQStWOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7SUN5TUl2MEU7SUFPQTA3Qzs7Ozs7Ozs7Ozs7Ozs7OztJQWhQRHJnRDtJQUlDbUg7R0FDSixTQUZHeEQsS0FFQy9aLEdBQUssT0FBQSxXQURMdWQsTUFDQXZkLEdBQVc7R0FTYTtJQU4xQm9oQjtJQUNBNUc7SUFDQ0Y7SUFJRDh3QixlQVhDcnhCLHdCQU1EUztZQU9BelQsa0I7R0FBVTtJQWtRTmlMO0lBREFDO2lEQWpRSmxMLFNBUEF5VDs7SUFlRkM7SUFDQWs4QyxvQkFBb0IsNEJBRHBCbDhDO0lBRUFtOEMsb0JBQW9CLDRCQUZwQm44QztJQUdBZzFFO0lBQ0FDO0lBQ0E1M0I7SUFDQWxpQjtJQUNBbWlCO0lBMFBFQztJQXhQRkc7SUFDQUY7SUFDQUM7SUFDQTdsRDtJQUNBRDtJQXlORXdsRDtJQXZORnJzQjtJQUNBajVCO0lBQ0E4bEQ7SUFDQVA7SUFDQWI7SUFDQTBpQjtJQUNBamtCO0lBcU5FcUI7SUFuTkY1a0Q7SUFDQTJrRDs7Ozs7OztZQUVBMWtELFNBQVN4QjtJQUNYO01BQUcsZ0NBRFFBLEdBekJUZ21EO1NBMkJDLGdDQUZRaG1ELEdBeEJUaW1EO0tBMkJHLE9BQUEsb0JBSE1qbUQ7SUFPUCxVQUFBLDRCQVBPQTtJQUtULE9BQUE7R0FHSTtZQWdNRmxRLE9BN0xLc1QsR0FBRXdCLEdBQUksT0FBQSxXQXBCYjZpRCxLQW9CT3JrRCxHQUFFd0IsR0FBVztZQUlKbzZFLFFBQVEzdkY7SUFBSSxPQUFBLCtCQUErQixpQkFBbkNBO0dBQWlEO1lBRXpENHZGLFFBQVE1dkY7SUFLMUIsT0FBQSwrQkFBK0IsaUJBTExBO0dBS21CO1lBRzNCNnZGLFFBQVE3dkY7SUFBSSxPQUFBLCtCQUErQixpQkFBbkNBO0dBQWlEOztvREEzRHZFK0csU0FQQXlULFdBeVBBczhDOzs7Ozs7Ozs7O1lBMUtGdjhDLGlCQUFvQixTQUFFO1lBQ3RCb3ZCLFFBQVFqNUIsR0FBR2s1QixLQUFLQztJQUFPO0tBQUEsTUFBQSxlQUFaRCxLQUFIbDVCO0tBQWUsWUFBWSxlQUEzQkEsR0FBUW01QjtJQUFtQjtHQUFTO1lBQzVDQyxnQkFBZ0JwNUIsR0FBR3ZRLEtBQUtEO0lBQU0sT0FBRyxjQUFqQndRLEdBQUd2USxPQUFBQSxNQUF1QyxlQUExQ3VRLEdBQVF4USxPQUFSd1EsSUFBUXhRO0dBQTBEO1lBRWxGNnBDLFVBQVVyNUIsR0FBR3ZRLEtBQUtEO0lBQ3BCLEdBQU8sZUFEUUMsS0FBS0QsTUFFcEIsT0FKRTRwQyxnQkFFVXA1QixHQUFHdlEsS0FBS0Q7SUFDcEIsTUFBQTtHQUMyQjtZQUd6QjhwQyxNQUFNdDVCLEdBQUd2USxLQUFLRDtJQUNoQixLQUFHLGlCQURRQyxLQUFLRCxNQU9YLFdBZEg0cEMsZ0JBT01wNUIsR0FBR3ZRLEtBQUtEO0lBTVQ7NEJBQWlDLFdBOUZwQ3NhLFdBd0ZZdGE7S0FNVCx1QkFBUyxXQTlGWnNhLFdBd0ZPcmE7S0FJUCxNQUFBO0lBQUEsT0FBQTtHQUdpQztZQUduQzROLEtBQUtvSyxHQUFBQSxPQUFTLGVBQVRBLE1BOURMczlDLGVBOER3QjtZQUN4QjNuRCxLQUFLcUssR0FBQUEsT0FBUyxlQUFUQSxNQS9ETHM5QyxlQStEd0I7WUFJeEI4QixrQjtZQUNBQyxTQUFTOW1ELEdBQUksT0FBSkEsRUFBSztHQVdEO0lBVmJxb0Q7SUFpSkVsbkQ7SUF0SUZMO0lBQ0Ftc0Q7SUFDQXhHO0lBQ0FDO0lBQ0FDO0lBQ0FJO0lBRUFFO0lBQ0FtNEI7SUFNRTduRDs7Ozs7OztZQUVBb3dCO0lBQ0YsT0FBQTtHQUEyRDtZQVF6REMsVUFBVXQ0RDtJQUNaLEdBQUcsZUFEU0EscUJBVFZxNEQ7SUFXTTtLQUFKdHhDLE1BQUksNEJBRkkvbUI7S0FHUjA0RCxvQkFEQTN4QyxvQ0FBQUE7S0FFQTB4QyxvQkFEQUMsb0NBQUFBO0tBRUFGLG9CQURBQyxvQ0FBQUE7S0FFQUYsb0JBREFDLG9DQUFBQTtLQUVBbEMsb0JBREFpQyxvQ0FBQUE7S0FFQTluQyxvQkFEQTZsQyxvQ0FBQUE7SUFFSixPQUFBLDRCQURJN2xDO0dBQ2E7WUFJZmtvQyxXQUFXNXhDO0lBQ2IsR0FBRyxlQURVQSx1QkF0QlhzeEM7O0tBd0JFcjRELGtCQUZTK21CLG9DQUFBQTtLQUdUMHhDLG9CQURBejRELGtDQUFBQTtLQUVBdzRELG9CQURBQyxvQ0FBQUE7S0FFQUYsb0JBREFDLG9DQUFBQTtLQUVBbEMsb0JBREFpQyxvQ0FBQUE7S0FFQTluQyxvQkFEQTZsQyxvQ0FBQUE7SUFFSixPQUFBLGVBREk3bEMsb0NBQUFBO0dBQ3NCO1lBR3hCbW9DLFFBQVE1NEQ7SUFDVixHQUFHLGVBRE9BLHFCQWpDUnE0RDtJQWtDMkI7SUFDN0IsT0FBQSwwQkFGVXI0RCxHQUVILDRCQUZHQTtHQUVnQztZQWlCeEM2NEQsV0FBV2x2RDtJQUNiLEdBQUcsZUFEVUE7S0FJNEMsdUJBQU0sNkJBSmxEQTtLQUdYO09BekRBcytCLFNBMERFOztJQUNXO0tBQUEsTUFBQSxnQ0FMRnQrQjtLQUtiLE1BQUEsNEJBOUtBOFE7SUE4S2UsT0FBQTtHQUFLO1lBSWxCcStDLFVBQVVudkQ7SUFDWixHQUFHLGVBRFNBO0tBR2tELHlCQUFNLDZCQUh4REE7S0FHVjtPQWxFQXMrQixTQWtFUTs7SUFDUCxHQUFBLDZCQUpTdCtCLHFCQUk4QjtJQUFrQixVQUFBLGdDQUFJLDRCQUpwREE7SUFJZ0QsT0FBQSw0QkF0TDVEOFE7R0FzTG1GOzt5REFvRTdFekk7OztJQTFERmpLO0lBRUNtYztJQUlDNnlDO0dBQ0osU0FGRzV5QyxPQUVDbmtCLEdBQUssT0FBQSxXQURMKzJELFFBQ0EvMkQsR0FBVzs7SUFPYjZmOzs7WUFDQXMwQyxZQUFVeHFELEdBQUksT0FBQSxnQ0FBSkEsR0FBMEI7WUFDcEMrc0QsWUFBVXRvRDtJQUFJLE9BQTBCLDRCQUE5QkEsc0JBQUk7R0FBK0I7Ozs7OztTQWhCN0NyRztTQUVDbWM7U0FHQUM7U0FVRGd3QztTQUNBdUM7U0EwQkZJO1NBNUJFajNDO1NBM0xKbTNDO1NBOExJajhDOztnREFPQTA3QyxlQWtDRXprRDs7Ozs7U0FoT05HO1NBSEFEO1NBa09NRDtTQUNBRDs7Ozs7Ozs7Ozs7O1NBcEJKNGxEOztTQUlBZDtTQUNBamxEO1NBek5GZ21EOzs7Ozs7Ozs7O0l6RnNKRTd4RDtJQUNBakc7SUFDQUc7SUFDQUM7OztPeUZ6TENtYTtPQXdDSG5JO09BSEFEO09Bb05FTDtPQXJJRjhyRDtPQTlIR3ZuRDtPQUdBMkQ7T0FLRHFIOztPQXlRSW5QO09BQ0FEOzswQjtPekYvRUo3UjtPQURBRDtPQUZBOEY7T0FDQWpHO095RnhHRjRwQztPQUdBSTtPQUtBQzs7O09BbkZFb0I7Ozs7OztPQTBFRjd3Qjs7O09BM0NBazdDO09BREFpa0I7T0FGQTdoQjs7Ozs7O09BRkF2bEQ7T0FEQWk1QjtPQUVBNnNCO09BTkFGO09BREFEO09BREFFO09Bd1BFSDtPQXZLRmU7T0FuRkFoQjtPQURBbmlCO09BOEVBOW5DO09BREFDO09Bb0JBb3BEO09BRUFFO09BakJBRTtPQUNBQztPQWlCQUM7T0FHQXE0QjtPQXJGQWo1QjtPQXhCQXA4QztPQWFBckk7T0FEQUM7T0FQQXlsRDtPQXlIRVE7T0FhQUs7T0F1Q0FHO09BVEFEO09BbkJBRDtxQjtxQjtXQTRFQW40RCxRQStCQXUzRCxTQTNCQUosS0FJQWQ7T0FSQXIyRDtPQStCQXUzRDtPQTNCQUo7T0FJQWQ7Ozs7T0FySUZ0bEQ7T0FHQTRsRDtPQUVBSztPQUVBRTtPQXhHQSszQjtPQURBRDtPQXNDZ0JFO09BRUFDO09BUUFDOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7O0lDOEJkejVCO0lBaVJFcjdDO0lBT0EwN0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMVhBMXZEO0lBK1ZDcVA7SUFwVkRvRTtJQW9KREY7aURBL0pDdlQsU0FXQXlUO0lBMEpGc0c7OztZQXZGQWl2RSxTQUFTL3ZGO0lBRVgscUNBRldBO0lBR1gsT0FBQSxlQUhXQTtHQUdRO1lBUWpCZ3dGLE9BQU9od0YsR0FBSSxPQUFBLHVCQUFKQSxNQUE4QjtZQThFckN1YSxVQXBFRTdKO0lBQ1ksR0FBTyxXQURmLGVBQUpBLEdBREYwbEQsT0FDRTFsRDtJQUNZLE1BQUE7R0FBZ0I7O0lBMFI5QmpRO0lBQ0FvZjtJQVNBRTtZQURBNjNDLElBL1JJNTNELEdBQUksT0FBQSw0QkFBSkEsR0FBb0I7R0FDbEIsSUFIQXkxRCxNQXhCTnM2QjtZQW9MRno5RSxLQTdKTXdCLEdBS0ssT0FMQyxlQUFOQSxHQUNFMmhELEtBSVk7WUF1SnBCbHFCLEtBM0pNejNCLEdBS0ssT0FMQyxlQUFOQSxHQUFFMmhELEtBS1k7R0FSWjtJQUFKejFEO0lBb0tKcVMsWUFwS1EsZUFBSnJTLEdBREZvMkQ7SUFDRXJ2QztJQW1LSjNVLFlBbktRLGVBQUoyVSxLQURGcXZDO1lBNlRBNEIsUUFqVFFoNEQ7SUFBTSxJQVhaK21CLE1BV1ksNkJBQU4vbUI7SUFYRixPQUFBLGVBQUorbUIsS0FERnF2QztHQVltQzs7SUE4U25DOEI7SUFFQUM7SUFEQUY7SUFHQUY7WUFDQW5pQixZQTlTWTUxQyxHQUFFMko7SUFBTSxJQWhCbEJvZCxNQWdCa0IsdUJBQVIvbUIsR0FBRTJKO0lBaEJSLE9BQUEsZUFBSm9kLEtBREZxdkM7R0FpQmdEO1lBK1NoRDBCLG9CQTlTb0I5M0QsR0FBRTJKO0lBQU0sSUFqQjFCb2QsTUFpQjBCLCtCQUFSL21CLEdBQUUySjtJQWpCaEIsT0FBQSxlQUFKb2QsS0FERnF2QztHQWtCZ0U7O0lBdEI3RHpsRDs7R0F1QkcsU0E4SVJ5bkQsSUFyS090a0QsR0FBRUM7SUFDVCxPQUFBO2FBQWU7ZUFEVnBELEdBQ2EsdUJBRFhtRCxPQUN3Qyx1QkFEdENDOzs7WUFrU1B6TyxTQTFRSXdPLEdBQUVDO0lBQUksT0FBQSxlQUFORCxHQUF1Qix1QkFBckJDO0dBQWlEO1lBMlF2RHhPLFNBMVFJdU8sR0FBRUM7SUFBZ0IsSUEvQlYvVCxJQStCVSx1QkFBbEI4VCxHQUFFQztJQS9CVSxPQUFBLGVBQUovVDtHQStCOEI7O0lBNkk1QzYzRDs7WUFMQWtCLFNBdElXLzRELEdBQUksT0FBQSw2QkFBSkEsR0FBNkI7WUEwS3hDdzNELFNBMU1TOW1ELEdBaUNNLE9BakNGLHVCQUFKQSxNQWlDYztZQXNLdkI0bUQsU0FyS1c1bUQ7SUFBSSxPQXRDWixxQ0FzQ1FBO2tCQXRDeUMsZUFzQ3pDQTs7R0FBVTtZQXNLckI2bUQsYUFyS2U3bUQsR0FBSSxPQTlDakJxL0UsU0E4Q2FyL0UsR0FBYztZQXNLN0JvcEUsZUExTWNwcEUsR0FxQ08sT0FyQ0gsZUFBSkEsUUFxQ29CO1lBZ0NoQzBRLFVBL0JVcGhCLEdBQUksT0FoRGQrdkYsU0FnRHVCLDZCQUFiL3ZGLElBQThCO1lBZ0N4Q3NjLFlBckVPdGM7SUFzQ08sT0FBYyw2QkF0Q2pCLHVCQUFKQTtHQXNDK0I7WUE4TnBDK0gsVUE3Tk8vSCxHQUFPQyxHQUFJLE9BQUEsV0FoSWxCOEcsU0FnSU8vRyxHQUFPQyxHQUFlO1lBMklqQzI0RCxRQWxMUzU0RDtJQXdDSyxPQUFjLDJCQXhDZix1QkFBSkE7R0F3QzZCO1lBK0l0Q2l3RixJQTdJTWp3RixHQUdOLE9BQUEsMkJBSE1BLEdBR0s7WUEySVhrd0YsSUF4TFNsd0Y7SUFnREMsT0FBVSwyQkFoRFAsdUJBQUpBO0dBZ0RxQjtZQW1JOUIyNEQsV0FuTFMzNEQ7SUFpRFEsT0E1RGYrdkYsU0E0RGUsMkJBakRKLHVCQUFKL3ZGO0dBaUQrQztZQW1JeERzNEQsVUFwTFN0NEQ7SUFrRE8sT0E3RGQrdkYsU0E2RGMsMkJBbERILHVCQUFKL3ZGO0dBa0Q4QztZQW1JdkQ2NEQsV0FyTFM3NEQ7SUFtRFEsT0FBaUIsMkJBbkRyQix1QkFBSkE7R0FtRG1DO1lBbUk1Qzg0RCxVQXRMUzk0RDtJQW9ETyxPQUFnQiwyQkFwRG5CLHVCQUFKQTtHQW9EaUM7WUFzTnBDK1osS0F4TEUvWixHQUFTLE9BQUEscUNBQVRBLEdBQTRCO0dBQ1I7SUFBMUJvckMsZUF1TElyeEIsTUFORmhTLFdBL0xGdVU7Ozs7OztZQWVBNnpFLFlBQVlud0YsR0FBSSxPQUFBLGdDQUFKQSxNQUE2RDtZQTRPckVnUyxVQWhVR2hTO0lBNkhPLE9BQXFCLDZCQTdIeEIsdUJBQUpBO0dBNkhzQztZQWtNekNpUyxVQWhNTThKO0lBQ1o7U0F6QklsTSw0QkF3QlFrTTs7WUF4QlJsTTtNQUtNLGVBQUEsZ0JBbUJFa007Ozs7Y0FFTjJ1QixnQkF4QkZ0Zjs7c0JBd0JFc2YsZ0JBeEJGdGY7O1VBd0JFc2YsZ0JBeEJGdGY7OztVQXdCRXNmLGdCQXhCRnRmO1FBU0QsNEJBVENBLFVBRkF2YjtNQWFPO09BQUx1d0MsS0FBSyxnQkFXQ3JrQyxLQXRCUnFQO09BWUVpMUIsS0FBSyxnQkFVQ3RrQyxLQVZFLDRCQVpWcVA7T0FhRixlQUZJZzFCLFNBQ0FDOzs7U0FZTSt2QztLQUNWLEdBRFVBO01BRVEsSUFoR0wxL0UsSUFnR0sscUJBSlJxTCxZQTFJVmcwRSxTQThDYXIvRTs7b0JBOEZUZzZCO1dBSUUybEQsVUFOSXQwRTs7T0FRK0I7UUFBQSxNQUFBLGtEQVIvQkE7UUFNSnMwRSxVQUVRLDJCQVJKdDBFO01BV0ksSUEzSUZ1USxRQTJJRSxxQkFMUitqRTtNQU9ELEdBQUEsY0E3SU8vakUsYUFxRlo2akUsWUEyQ1VwMEU7TUFoSU07T0FlWnUwRSxVQWZZLGVBQUpoa0U7T0E4SU5pa0UsbUJBWkY3bEQsT0FuSEE0bEQsVUFBSSxlQUFKQTthQStIRUM7O0tBVkQ7O2VBZUEsT0E5RExKLFlBMkNVcDBFO0dBbUJVO1lBR3BCNHpFLFFBckpPai9FO0lBcUppQixJQXRKWjFRLElBc0pZLDJCQXJKYix1QkFBSjBRO0lBRFMsT0FBQSxlQUFKMVE7R0FzSnNDO1lBQ2xENHZGLFFBdEpPbC9FO0lBc0ppQixJQXZKWjFRLElBdUpZLDJCQXRKYix1QkFBSjBRO0lBRFMsT0FBQSxlQUFKMVE7R0F1SnNDO1lBQ2xENnZGLFFBdkpPbi9FO0lBdUppQixJQXhKWjFRLElBd0pZLDJCQXZKYix1QkFBSjBRO0lBRFMsT0FBQSxlQUFKMVE7R0F3SnNDO0dBTWhDO0lBRHBCeWE7SUFDQWs4QyxvQkFBb0IsNEJBRHBCbDhDO0lBRUFtOEMsb0JBQW9CLDRCQUZwQm44QztJQW1CQWkvRCxZQTFMRXFXO0lBd0JNUyxRQXhCTlQ7SUEyVEFqNUIsT0EzVEFpNUI7Ozs7Ozs7WUFvTUY3OUUsU0F6TFNsUztJQXlMSSxPQUFBLDRCQXpMQSx1QkFBSkE7R0F5TGtDO1lBQzNDNjJELG1CQUFtQjcyRDtJQUFnQixJQTNMckIrbUIsTUEyTHFCLG9CQUFoQi9tQjtJQTNMRCxPQUFBLGVBQUorbUI7R0EyTDRDO1lBRTFENVUsU0FBU3pCO0lBQ1g7TUFDRyxnQ0FGUUEsR0EvQlRpbUQ7U0FpQzJCLGdDQUZsQmptRCxHQTlCVGttRDtLQWlDZSxJQWhNRDUyRCxJQWdNQyxvQkFITjBRO0tBN0xTLE9BQUEsZUFBSjFROztJQW9NWixVQUFBLDRCQVBPMFE7SUFLVCxPQUFBO0dBR0k7OzhDQWdFQTNJLFdBL0xGdVUsYUEyT0F3NkM7Ozs7Ozs7Ozs7WUE5RkZudEIsUUFBUWo1QixHQUFHazVCLEtBQUtDO0lBQU87S0FBQSxNQUFBLGVBQVpELEtBQUhsNUI7S0FBZSxZQUFZLGVBQTNCQSxHQUFRbTVCO0lBQW1CO0dBQVM7WUFDNUNDLGdCQUFnQnA1QixHQUFHdlEsS0FBS0Q7SUFBTSxPQUFHLGNBQWpCd1EsR0FBR3ZRLE9BQUFBLE1BQXVDLGVBQTFDdVEsR0FBUXhRLE9BQVJ3USxJQUFReFE7R0FBMEQ7WUFFbEY2cEMsVUFBVXI1QixHQUFHdlEsS0FBS0Q7SUFDcEIsR0FBTyxlQURRQyxLQUFLRCxNQUVwQixPQUpFNHBDLGdCQUVVcDVCLEdBQUd2USxLQUFLRDtJQUNwQixNQUFBO0dBQzJCO1lBR3pCOHBDLE1BQU10NUIsR0FBR3ZRLEtBQUtEO0lBQ2hCLEtBQUcsaUJBRFFDLEtBQUtELE1BT1gsV0FkSDRwQyxnQkFPTXA1QixHQUFHdlEsS0FBS0Q7SUFNVDs0QkEzSkhvYyxZQXFKWXBjO0tBTVQsdUJBM0pIb2MsWUFxSk9uYztLQUlQLE1BQUE7SUFBQSxPQUFBO0dBR2lDO1lBeUVqQ3FGLFNBakVLdU8sR0FBRXdCLEdBQUksT0EvRGI2aUQsSUErRE9ya0QsR0FBRXdCLEdBQVc7WUFDcEJ4SCxLQUFLb0ssR0FBSSxJQTlOSG5ZLElBOE5EbVksTUFBQUEsT0E5Tk8sZUFBTm5ZLEdBQ0V3d0YsaUJBNk5jO1lBQ3RCMWlGLEtBQUtxSyxHQUFJLElBOU5IblksSUE4TkRtWSxNQUFBQSxPQTlOTyxlQUFOblksR0FBRXd3RixpQkE4TmM7WUFHdEI1K0UsT0FBTzVSO0lBQUksT0F6UFQrdkYsU0F5UGtCLG9DQUFiL3ZGO0dBQWtDO1lBbUV2QzZSLFdBbEVTN1IsR0FBSSxPQURmNFIsT0FDVzVSLEdBQVk7WUFDdkJ3UixPQWhQU3hSO0lBZ1BFLE9BQWtCLHFDQWhQaEIsdUJBQUpBO0dBZ1A4QjtZQUN2QzI5RCxXQWpQUzM5RDtJQWlQTSxPQUFzQixxQ0FqUHhCLHVCQUFKQTtHQWlQc0M7WUFDL0M0NUUsYUFsUFM1NUU7SUFrUFEsT0FBd0IscUNBbFA1Qix1QkFBSkE7R0FrUDBDO1lBQ25EazNELFNBQVNsM0Q7SUFBSSxPQTlQWCt2RixTQThQb0Isb0NBQWIvdkY7R0FBb0M7WUFDN0NtM0QsYUFBYW4zRCxHQUFJLE9BRGpCazNELFNBQ2FsM0QsR0FBYztZQUMzQm8zRCxTQXJQU3AzRDtJQXFQSSxPQUFvQixxQ0FyUHBCLHVCQUFKQTtHQXFQa0M7WUFDM0NxM0QsYUF0UFNyM0Q7SUFzUFEsT0FBd0IscUNBdFA1Qix1QkFBSkE7R0FzUDBDO1lBQ25ENjVFLGVBdlBTNzVFO0lBdVBVLE9BQTBCLHFDQXZQaEMsdUJBQUpBO0dBdVA4QztZQUN2RHkzRCxhQUFhejNEO0lBQUksT0FqRGpCczNELFNBaUQwQixxQ0FBYnQzRDtHQUF3QztZQUNyRDAzRCxpQkFBaUIxM0Q7SUFBSSxPQXBRbkIrdkYsU0FvUTRCLHFDQUFiL3ZGO0dBQXdDO1lBQ3pEeXdGLG1CQUFtQnp3RjtJQUFtQixJQTNQeEIwUSxJQTJQd0IscUNBQW5CMVE7SUEzUEQsT0FBQSxlQUFKMFE7R0EyUG1EO1lBQ2pFaW5ELGFBM1BTMzNEO0lBMlBRLE9BQXdCLHFDQTNQNUIsdUJBQUpBO0dBMlAwQztZQUNuRDh2RixpQkE1UFM5dkY7SUE0UFksT0FBNEIscUNBNVBwQyx1QkFBSkE7R0E0UGtEO1lBQzNEMHdGLG1CQTdQUzF3RjtJQTZQYyxPQUE4QixxQ0E3UHhDLHVCQUFKQTtHQTZQc0Q7O3lEQW1FekRnUzs7O0dBckRKLFNBRkdtUyxPQUVDbmtCLEdBQUssT0FETCtaLEtBQ0EvWixHQUFXOztJQU9ieUY7OztZQUVBMHVELFlBblJjeHFEO0lBcVJoQixPQUFxQjtrQ0FyUkQsK0JBQUpBO0dBcVJ3QjtZQUd0QytzRCxZQUFVdG9EO0lBQUksT0FzQ1o2RCxVQXRDc0IscUNBQWQ3RDtHQUF3Qjs7Ozs7O1NBckJsQ3JHO1NBRUNxTztTQUdBK047U0FXRGd3QztTQUtBdUM7U0F1QkZJO1NBOUJFcnhEO1NBNkJGc2E7U0FyQkVoRjs7WUFNQTQxRSxZQUFVM3dGLEdBQUksT0FnQ1pnUyxVQWhDUWhTLEdBQWU7R0FnRG5COzs2Q0EvQ055MkQsZUFEQWs2QjtJQVl1Q2pyRjtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQzs7Ozs7U0FoSDNDb007U0FIQUQ7U0FzSU1EO1NBQ0FEO1NBM0JKdlI7U0FDQW9mO1NBQ0F2YTtTQUNBQztTQU9Bd2E7U0FIeUNoYTtTQUFBRDtTQUFBRDtTQUFBRDtTQUFBRDtTQUFBRDtTQUV6Q2t5RDtTQUNBNzNDO1NBQ0ErMkM7U0FDQWpsRDtTQXRJRmdtRDs7Ozs7Ozs7O0lBcUtVOztJMUZoUFI3eEQ7SUFDQWpHO0lBQ0FHO0lBQ0FDOzs7TzBGN0JDbWE7T0FzSEhuSTtPQUhBRDtPQXdIRUw7T0FoRUY4ckQ7T0FxQkt2bkQ7T0FJQzJEO09BdE1KcUg7O09BMlBJblA7T0FDQUQ7Ozs7Ozs7OzBCO08xRjdOSjdSO09BREFEO09BRkE4RjtPQUNBakc7TzBGaUhGNHBDO09BR0FJO09BS0FDO09BOUlFbHBCOztPQU9Bc3FCOzs7Ozs7T0FMQTd3Qjs7O09Ba09BdThDO09BblNNMDVCO09Ba0tSOVc7T0FzSEVqNUU7T0FDQW9mO09BQ0F2YTtPQUdBRTtPQUtBdWE7T0FBQUE7OztPQVBBeGE7T0E3SEZzeUQ7O09Bd0pFSztPQUNBRDtPQUNBRTtPQUNBSDtPQUNBRDtPQUNBbmlCOzs7Ozs7T0ExQkFnaUI7T0FySUZ0bEQ7T0FEQWk1QjtPQUVBNnNCO09BeUpFRjtPQUNBRDtPQUNBRTtPQUNBSDtPQWhLRmU7T0FpS0VoQjtPQUNBbmlCO09BN0ZGOW5DO09BREFDO09BVUFvcEQ7T0FFQUU7T0E5Q0FFO09BRUFDO09BK0NBRTtPQUdBbzRCO09BbEVBajVCO09BOUJBcDhDO09BaUJBckk7T0FDQUM7T0EySkV5bEQ7T0FBQUE7T0FySkZRO09BREFLO09BR0FHO09BREFEO09BSEFEO09BS0FxM0I7T0FDQUM7O1FBNkdFenZGO1FBQ0FvZjtRQUNBdmE7UUFDQUM7UUFPQXdhO1FBTEF2YTtRQUV5Q087UUFBQUQ7UUFBQUQ7UUFBQUQ7UUFBQUQ7UUFBQUQ7UUFFekNreUQ7UUFDQTczQztRQUNBKzJDOzs7O1FBbUJBb0I7UUFDQUQ7UUFDQUU7UUFDQUg7UUFDQUQ7UUFDQW5pQjtRQUNBa2lCO09BM0ZGbG1EO09BRUFKO09BRUFvb0U7T0FDQTFpQjtPQUVBRTtPQUVBeWlCO09BaERBdmlCO09BRUF3aUI7T0ErQ0FyaUI7T0FHQUU7T0FEQTg0QjtPQUdBQztPQXhHRWY7T0FDQUM7T0FDQUM7V0FsS0FFLFVBV0FDOzs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7OztJQzlGQXIxRTtJQWtDRUk7Ozs7Ozs7O0lBeENKMU07SUFLRXRIO0lBR0NxUDtJQUlDbUg7R0FDSixTQUZHeEQsS0FFQy9aLEdBQUssT0FBQSxXQURMdWQsTUFDQXZkLEdBQVc7R0FTYTtJQU4xQm9oQjtJQUNBNUc7SUFDQ0Y7SUFJRDh3QixlQVhDcnhCLE1BTkRoVCxTQVlBeVQ7Ozs7O1lBT0F2SSxVQUdBN0Q7SUFIWSxPQUdaQTtjQUFBQSxlQUFLLFdBM0JQQyxtQkEyQkVEOztHQUEwRTs7SUFHMUU0RDtpREF6QkFqTCxTQVlBeVQ7Ozs2Q0F1QkVPLGFBVkYvSTs7Ozs7O1lBa0JGdUksaUJBQW9CLFNBQUU7WUFDdEJvdkIsUUFBUWo1QixHQUFHazVCLEtBQUtDO0lBQU8sVUFBQSxnQ0FBWkQsS0FBSGw1QjtJQUFlLDZDQUFmQSxHQUFRbTVCO0dBQTRCO1lBQzVDQyxnQkFBZ0JwNUIsR0FBR3ZRLEtBQUtEO0lBQU0sT0FBRyxnQ0FBakJ3USxHQUFHdlE7Y0FBQUE7Y0FBdUMsZ0NBQTFDdVEsR0FBUXhRLE9BQVJ3USxJQUFReFE7R0FBMEQ7WUFFbEY2cEMsVUFBVXI1QixHQUFHdlEsS0FBS0Q7SUFDcEIsR0FBTyxnQ0FEUUMsS0FBS0Q7S0FFcEIsT0FKRTRwQyxnQkFFVXA1QixHQUFHdlEsS0FBS0Q7SUFDcEIsTUFBQTtHQUMyQjtZQUd6QjhwQyxNQUFNdDVCLEdBQUd2USxLQUFLRDtJQUNoQixLQUFHLGdDQURRQyxLQUFLRDtLQU9YLFdBZEg0cEMsZ0JBT01wNUIsR0FBR3ZRLEtBQUtEO0lBTVQ7NEJBQWlDLFdBOUNwQ3NhLFdBd0NZdGE7S0FNVCx1QkFBUyxXQTlDWnNhLFdBd0NPcmE7S0FJUCxNQUFBO0lBQUEsT0FBQTtHQUdpQztZQUduQ3FSLE9BQU94UixHQUFJLE9BQUEsNEJBQUpBLEdBQWlCO1lBTXRCUyxPQUFPcVQsR0FBRUM7SUFBSTtLQUE0QixNQU4zQ3ZDLE9BTVd1QztLQUFtQixNQU45QnZDLE9BTVNzQztLQURROVQsSUFDWTtJQURNLE9BQWxCQTtHQUNtQztZQUNsRDZmLFNBQU8vTCxHQUFFQztJQUFJO0tBQTZCLE1BUDVDdkMsT0FPV3VDO0tBQW1CLE1BUDlCdkMsT0FPU3NDO0tBRlE5VCxJQUVZO0lBRk0sT0FBbEJBO0dBRW9DOztHQU1DLFNBYnREd1IsbUJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztRQTdERW1KO1FBWUNMO1FBVkFsRTtRQUdBMkQ7UUFLRHFIO1FBQ0E1RztRQU9Bdkk7UUFNQUQ7Ozs7Ozs7Ozs7Ozs7UUFtQkYyM0I7UUFHQUk7UUFLQUM7OztRQW5DRW9CO1FBMEJGN3dCO1FBbUJBL0k7WUFPRXFPLFVBREFwZjs7OztHQU9HLE1BQUE7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7SUNzS0RzYTtJQU9BMDdDOzs7Ozs7Ozs7Ozs7Ozs7O0lBelBEcmdEO0lBSUNtSDtHQUNKLFNBRkd4RCxLQUVDL1osR0FBSyxPQUFBLFdBREx1ZCxNQUNBdmQsR0FBVztHQVNhO0lBTjFCb2hCO0lBQ0E1RztJQUNDRjtJQUlEOHdCLGVBWENyeEIsd0JBTURTO1lBd0VBeFUsVUFsRVNoRyxHQUFPQyxHQUFJLE9BQUEsNkJBQVhELEdBQU9DLEdBQWU7R0FTYjtJQWdRZCtSO0lBREFDO2lEQXRNSmpNLFdBeEVBd1U7O0lBY0ZDO0lBQ0FrOEMsb0JBQW9CLDRCQURwQmw4QztJQUVBbThDLG9CQUFvQiw0QkFGcEJuOEM7SUFHQWcxRTtJQUNBQztZQXNRRTUzQiw4QjtZQURBbGlCLHNCO1lBREFtaUIscUI7R0FqUVcsSUFnUVhDO1lBREFHLGtCO1lBREFGLGlCO1lBREFDLGtCO0dBelBRO0lBQ1Y3bEQ7SUFDQUQ7SUFrT0V3bEQ7SUFoT0Zyc0I7SUFDQWo1QjtJQUNBdWxEO1lBK05FcDNELFk7R0E5Tkk7SUFDTmk1RTtJQUNBamtCO0lBNk5FcUI7Ozs7Ozs7WUExTkY1a0QsYztZQUNBMmtELHdCO1lBRUExa0QsU0FBU3hCO0lBQ1g7TUFBRyxnQ0FEUUEsR0F6QlRnbUQ7U0EyQkMsZ0NBRlFobUQsR0F4QlRpbUQ7S0EyQkcsT0FITWptRDtJQU9QLFVBQUEsNEJBUE9BO0lBS1QsT0FBQTtHQUdJOzs7MENBd0JGM0ssV0F4RUF3VSxXQStQQXM4Qzs7Ozs7O0lBSmVqM0M7SUFBQUU7SUFBQXphO0lBQUFDO0lBQUFDO0lBQUFDOzs7OztZQWxMZjFGLFdBQVdDLEdBQUVDLEdBQUksT0FEakIrRixVQUNhL0YsR0FBRkQsR0FBaUI7WUFDNUJHLElBVk9ILEdBQU9DLEdBVUUsT0FWRSxjQUFYRCxHQUFPQyxLQUFQRCxJQUFPQyxFQVV3QjtZQUN0Q0MsSUFaT0YsR0FBT0MsR0FZRSxPQVpFLGlCQUFYRCxHQUFPQyxLQUFQRCxJQUFPQyxFQVl3QjtZQUN0QytHLE1BZE9oSCxHQUFPQyxHQWNJLE9BZEEsV0FBWEQsR0FBT0MsR0FjUztZQUN2QjBwQyxRQWhCZWo1QixHQUFQazVCLEtBQU9DO0lBQUksVUFBQSxlQUFYRCxLQUFPbDVCO0lBZ0JRLGFBaEJKLGVBQUpBLEdBQUFtNUI7R0FnQjZCO1lBQzVDQyxnQkFkT3A1QixHQUFPdlEsS0FIQ0Q7SUFpQmUsT0FkWixjQUFYd1EsR0FBT3ZRLE9BQUFBLE1BSEssZUFHWnVRLEdBSFF4USxPQUdSd1EsSUFIUXhRO0dBaUJtRTtZQUVsRjZwQyxVQUFVcjVCLEdBbkJGdlEsS0FBT0Q7SUFvQmpCLEdBcEJxQixlQUFYQyxLQUFPRCxNQXFCakIsT0FKRTRwQyxnQkFFVXA1QixHQW5CRnZRLEtBQU9EO0lBb0JqQixNQUFBO0dBQzJCO1lBR3pCOHBDLE1BQU10NUIsR0F0QkN2USxLQUFPRDtJQXVCaEIsS0F2Qm9CLGlCQUFYQyxLQUFPRCxNQTZCWCxXQWRINHBDLGdCQU9NcDVCLEdBdEJDdlEsS0FBT0Q7SUE0QlQ7NEJBQWlDLFdBM0Z0Q3NhLFdBK0RjdGE7S0E0QlQsdUJBQVMsV0EzRmRzYSxXQStET3JhO0tBMEJMLE1BQUE7SUFBQSxPQUFBO0dBR2lDO1lBTXJDb2EsaUJBQW9CLFNBQUU7T0FxSnBCN1UsNkJBREFDO1lBREFDLG1CO1lBREFDLG1CO1lBNUlGa0ksS0FBS29LLEdBQUFBLE9BQUFBLE9BdEVMczlDLGtCQXNFc0I7WUFDdEIzbkQsS0FBS3FLLEdBQUFBLE9BQUFBLE9BdkVMczlDLGtCQXVFc0I7WUFDdEJ5QixTQUFTeG1ELEdBQUksT0FBSkEsRUFBSztZQUVkMG1ELFNBQVMxbUQsR0FBSSxPQUFKQSxFQUFLOztJQUVkcW9EO0lBSUFubkQ7SUE4SUVDO0lBNUlGKytFO0lBQ0FwL0U7SUFDQW1zRDtJQUNBaWM7SUFDQXRpQjtJQUNBQztJQUNBdWlCO0lBQ0F0aUI7SUFDQUM7SUFDQUM7SUFDQSs0QjtJQUNBOTRCO1lBRUFTLElBQUlya0QsR0FBRXdCO0lBQUksSUFBb0QsTUFBQSxXQVg5RG9vRCxZQVdNcG9ELElBQXlDLE1BQUEsV0FYL0Nvb0QsWUFXSTVwRDtJQUFpQixPQUFBLFdBK0huQmxDLFlBL0htQjtHQUF3RDtZQXdIM0UvTCxVQXZIS2lPLEdBQUV3QixHQUFJLE9BRGI2aUQsSUFDT3JrRCxHQUFFd0IsR0FBVztZQUlwQm82RSxRQUFRM3ZGLEdBQUksT0FBK0IsaUJBQW5DQSxjQUFpRDs7SUFNdkRpb0M7Ozs7Ozs7WUFFQW93QjtJQUNGLE9BQUE7R0FBMkQ7WUFRekRDLFVBQVV0NEQ7SUFDWixHQUFHLGdDQURTQTtLQVRWcTREO0lBV007S0FBSnR4QyxNQUFJLDRCQUZJL21CO0tBR1J5NEQsTUFEQTF4QyxNQUFBQTtLQUVBeXhDLE1BREFDLE1BQUFBO0tBRUFGLE1BREFDLE1BQUFBO0tBRUFsQyxNQURBaUMsTUFBQUE7S0FFQTluQyxNQURBNmxDLE1BQUFBO0lBRUosT0FBQSw0QkFESTdsQztHQUNhO1lBSWZrb0MsV0FBVzV4QztJQUNiLEdBQUcsZ0NBRFVBO0tBckJYc3hDOztLQXVCRXI0RCxJQUZTK21CLE1BQUFBO0tBR1R5eEMsTUFEQXg0RCxJQUFBQTtLQUVBdTRELE1BREFDLE1BQUFBO0tBRUFsQyxNQURBaUMsTUFBQUE7S0FFQTluQyxNQURBNmxDLE1BQUFBO0lBRUosT0FESTdsQyxPQUFBQTtHQUNzQjtZQUd4Qm1vQyxRQUFRNTREO0lBQ1YsR0FBRyxnQ0FET0E7S0EvQlJxNEQ7SUFnQzJCLElBQUEsNkJBRG5CcjRELElBRUgsNEJBRkdBO0lBQ21CLE9BQUE7R0FDYTtZQWlCeEM2NEQsV0FBV2x2RDtJQUNiLEdBQUcsZ0NBRFVBO0tBSTRDLHVCQUFNLDZCQUpsREE7S0FHWDtPQXZEQXMrQixTQXdERTs7SUFDVztLQUFBLE1BQUEsZ0NBTEZ0K0I7S0FLYixNQUFBLDRCQXZMQThRO0lBdUxlLE9BQUE7R0FBSztZQUlsQnErQyxVQUFVbnZEO0lBQ1osR0FBRyxnQ0FEU0E7S0FHa0QseUJBQU0sNkJBSHhEQTtLQUdWO09BaEVBcytCLFNBZ0VROztJQUVQLEdBQUEsNkJBTFN0K0IscUJBSzhCO0lBQWtCLFVBQUEsZ0NBQUksNEJBTHBEQTtJQUtnRCxPQUFBLDRCQWhNNUQ4UTtHQWdNbUY7O3lEQWlFN0V6STs7O0lBdkRGakw7SUFFQ21kO0lBSUM2eUM7OztHQUNKLFNBRkc1eUMsT0FFQ25rQixHQUFLLE9BQUEsV0FETCsyRCxRQUNBLzJELEdBQVc7WUFRYm0wRCxZQUFVeHFELEdBQUksT0FBQSxnQ0FBSkEsR0FBMEI7WUFDcEMrc0QsWUFBVXRvRDtJQUFJLE9BQTBCLDRCQUE5QkEsc0JBQUk7R0FBK0I7Ozs7OztTQWhCN0NySDtTQUVDbWQ7U0FHQUM7U0FVRGd3QztTQUNBdUM7U0F1QkZJO1NBSmV0eEQ7U0FHZi9FO1NBckJFc2E7O2dEQU9BMDdDLGVBK0JFemtEOzs7OztTQXZPTkc7U0FIQUQ7U0F5T01EO1NBQ0FEO1NBM0JKbk07U0FDQUQ7U0FDQUQ7U0FDQUQ7U0FPQWpGO1NBSGVvZjtTQUFBRTtTQUFBemE7U0FBQUM7U0FBQUM7U0FBQUM7U0FFZm15RDtTQUNBbjNEO1NBQ0FxMkQ7U0FDQWpsRDtTQWpPRmdtRDs7Ozs7Ozs7Ozs7T0E5Qkd2OUM7T0F1Q0huSTtPQUhBRDtPQTJORUw7T0ExSUY4ckQ7T0EvSEd2bkQ7T0FHQTJEO09BS0RxSDs7T0ErUUluUDtPQUNBRDtPQXBCVzZOO09BQUFFO09BQUF6YTtPQUFBQztPQUFBQztPQUFBQztPQS9LZnVCO09BSkFoQjtPQUVBN0Y7T0FDQUQ7T0FIQThGO09BQ0FqRztPQUlBNHBDO09BR0FJO09BS0FDOzs7T0FoRkFvQjs7Ozs7O09BNkZGN3dCOzs7T0E2SkV1OEM7T0E3TkZyQjtPQURBaWtCO09BbU5FN3pFO09BQ0FEO09BQ0FEO09BR0FHO09BS0FyRjtPQUFBQTs7O09BUEFpRjtPQXhORm15RDs7T0FtUEVLO09BQ0FEO09BQ0FFO09BQ0FIO09BQ0FEO09BQ0FuaUI7Ozs7OztPQTFCQWdpQjtPQS9ORnRsRDtPQURBaTVCO09Bb0dBNnNCO09BaUpFRjtPQUNBRDtPQUNBRTtPQUNBSDtPQXZLRmU7T0F3S0VoQjtPQUNBbmlCO09BOUtGOW5DO09BREFDO09BRUFtcEQ7T0FFQUU7T0FhQUc7T0FFQUM7T0FFQUU7T0FFQUM7T0F6RkFkO09BeEJBcDhDO09BYUFySTtPQURBQztPQThQRXlsRDtPQUFBQTtPQWpJQVE7T0FZQUs7T0FzQ0FHO09BVEFEO09BbkJBRDtxQjtxQjs7UUF1RUEveUQ7UUFDQUQ7UUFDQUQ7UUFDQUQ7UUFPQWpGO1FBTEFxRjtRQUVlK1o7UUFBQUU7UUFBQXphO1FBQUFDO1FBQUFDO1FBQUFDO1FBRWZteUQ7UUFDQW4zRDtRQUNBcTJEOzs7O1FBbUJBb0I7UUFDQUQ7UUFDQUU7UUFDQUg7UUFDQUQ7UUFDQW5pQjtRQUNBa2lCO09BdEtGbG1EO09BR0FKO09BWEEwbEQ7T0FFQUU7T0FnQkFLO09BR0FFO09BUEFMO09BSkFzNUI7T0FHQWhYO09BT0E2VztPQUpBM1c7T0F4R0E0VjtPQURBRDtPQXFIQUU7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNuSkExbkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXdDSTRvRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQXVDQXIvRSxPQUFPeFIsR0FBSSxXQUFKQSxHQUFVO1lBQ2pCNDVFLGFBQWE1NUUsR0FBSSxPQUFKQSxFQUFLO1lBSWxCMHdGLG1CQUFtQjF3RixHQUFJLE9BQUEsZ0JBQUpBLEdBQWtCO1lBQ3JDMjNELGFBQWEzM0QsR0FBSSxXQUFLLGdCQUFUQSxJQUF5QjtZQUV0QzR2RixRQUFRbC9FO0lBQUksT0FBbUI7YUFBQSwyQkFBZSxvQkFBdENBO0dBQXVEO1lBQy9EbS9FLFFBQVFuL0U7SUFBSSxPQUFtQjthQUFBLDJCQUFlLG9CQUF0Q0E7R0FBdUQ7O0lBRi9Eb2dGO0lBS0ZDO01BbkRFRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OEI7OEI7OEI7OEI7OEI7OEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4Qjs4Qjs7O3dCO3dCOzs7Ozs7OEI7OEI7OEI7OzhCOzhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCOzs7Ozs7Ozs7OytCOzhCOzs7d0I7OzZCOzZCOzZCOzZCOzZCOzZCOzt3Qjs7Ozs7NkI7NkI7NkI7OzZCOzZCOzZCOztTQXVDQXIvRTtTQUNBb29FOzs7dUI7Ozs7U0FLQWppQjt1QjtTQURBKzRCOztTQUVBSTs7U0FDQWxCO1NBQ0FDO0lBckNVN3ZELG1CQXdDWit3RDtJQXhDWUMsYUF3Q1pEO0lBeENZRSxhQXdDWkY7SUF4Q1lHLGVBd0NaSDtJQXhDWUksZUF3Q1pKO0lBeENZN3NFLGdCQXdDWjZzRTtJQXhDWTVzRSxTQXdDWjRzRTtJQXhDWS94RCxjQXdDWit4RDtJQXhDWXowRSxjQXdDWnkwRTtJQXhDWXI2QixjQXdDWnE2QjtJQXhDWTU4QixjQXdDWjQ4QjtJQXhDWXhyRixXQXdDWndyRjtJQXhDWXZyRixXQXdDWnVyRjtJQXhDWXRyRixXQXdDWnNyRjtJQXhDWXJyRixXQXdDWnFyRjtJQXhDWXByRixXQXdDWm9yRjtJQXhDWW5yRixXQXdDWm1yRjtJQXhDWS9vRixVQXdDWitvRjtJQXhDWWhwRixZQXdDWmdwRjtJQXhDWTdxRixRQXdDWjZxRjtJQXhDWTlxRixRQXdDWjhxRjtJQXhDWTVxRixjQXdDWjRxRjtJQXhDWTNxRixlQXdDWjJxRjtJQXhDWXRoQyxZQXdDWnNoQztJQXhDWXJoQyxjQXdDWnFoQztJQXhDWXBoQyxVQXdDWm9oQztJQXhDWXBiLGVBd0Nab2I7SUF4Q1lLLE9Bd0NaTDtJQXhDWU0sYUF3Q1pOO0lBeENZTyxnQkF3Q1pQO0lBeENZUSxvQkF3Q1pSO0lBeENZUyxnQkF3Q1pUO0lBeENZVSxvQkF3Q1pWO0lBeENZVyxTQXdDWlg7SUF4Q1lZLGNBd0NaWjtZQUFBQTtJQXhDWWEsa0JBd0NaYjtJQXhDWXRYLFNBd0Nac1g7SUF4Q1lQLFFBd0NaTztJQXhDWWMsY0F3Q1pkO0lBeENZbHJGLFdBd0Naa3JGO0lBeENZanJGLFlBd0NaaXJGO0lBeENZaHJGLFlBd0NaZ3JGO0lBeENZeHFGLFlBd0Nad3FGO0lBeENZLzVCLE1Bd0NaKzVCO0lBeENZdnFGLFlBd0NadXFGO0lBeENZdHFGLFlBd0Nac3FGO0lBeENZcnFGLFlBd0NacXFGO0lBeENZcHFGLFlBd0Nab3FGO0lBeENZZSxRQXdDWmY7SUF4Q1lucUYsWUF3Q1ptcUY7SUF4Q1k5akYsT0F3Q1o4akY7SUF4Q1k1akYsTUF3Q1o0akY7SUF4Q1l6akYsT0F3Q1p5akY7SUF4Q1k3akYsU0F3Q1o2akY7SUF4Q1kzakYsTUF3Q1oyakY7SUF4Q1kvakYsTUF3Q1orakY7SUF4Q1lnQixVQXdDWmhCO0lBeENZaUIsdUJBd0NaakI7SUF4Q1lrQixlQXdDWmxCO0lBeENZbUIsYUF3Q1puQjtJQXhDWW9CLGtCQXdDWnBCO0lBeENZdmpGLFFBd0NadWpGO0lBeENZcUIsU0F3Q1pyQjtJQXhDWXNCLFNBd0NadEI7SUF4Q1l1QixRQXdDWnZCO0lBeENZd0IsWUF3Q1p4QjtJQXhDWXlCLFdBd0NaekI7SUF4Q1kwQixZQXdDWjFCO0lBeENZMkIsWUF3Q1ozQjtJQXhDWTRCLGFBd0NaNUI7SUF4Q1k2QixlQXdDWjdCO0lBeENZOEIsZ0JBd0NaOUI7SUF4Q1krQixTQXdDWi9CO0lBeENZZ0MsU0F3Q1poQztJQXhDWWlDLGlCQXdDWmpDO0lBeENZa0MsaUJBd0NabEM7SUF4Q1ltQyxpQkF3Q1puQztJQXhDWW9DLGFBd0NacEM7SUF4Q1lxQyxxQkF3Q1pyQztJQXhDWXNDLHFCQXdDWnRDO0lBeENZdUMsYUF3Q1p2QztJQXhDWXdDLGNBd0NaeEM7SUF4Q1l5QyxjQXdDWnpDO0lBeENZMWpGLE1Bd0NaMGpGO0lBeENZMEMsd0JBd0NaMUM7SUF4Q1kyQyxjQXdDWjNDO0lBeENZNEMsZUF3Q1o1QztJQXhDWTZDLGNBd0NaN0M7SUF4Q1k4QyxZQXdDWjlDO0lBeENZK0MsUUF3Q1ovQztJQXhDWWdELFFBd0NaaEQ7VUFBQUE7SUF4Q1lpRCxXQXdDWmpEO0lBeENZa0QsV0F3Q1psRDtJQXhDWW1ELGlCQXdDWm5EO0lBeENZNzVCLFdBd0NaNjVCO0lBeENZb0QsYUF3Q1pwRDtJQXhDWWxYLGlCQXdDWmtYO0lBeENZcUQsYUF3Q1pyRDtJQXhDWWpYLGlCQXdDWmlYO0lBeENZc0QsaUJBd0NadEQ7SUF4Q1l1RCxpQkF3Q1p2RDtJQXhDWU4scUJBd0NaTTtJQXhDWXdELHVCQXdDWnhEO0lBeENZeUQsdUJBd0NaekQ7SUF4Q1kwRCxTQXdDWjFEO0lBeENZcEIsVUF3Q1pvQjtJQXhDWTJELFlBd0NaM0Q7SUF4Q1k0RCxZQXdDWjVEO1lBVUF4cEYsVUFBTW1KLEdBQUVvUDtJQUNWO0tBQUlpSixNQUFNLFdBbkRJbGpCLFVBa0RONkssR0FBRW9QO0tBRWMsTUFBQSxXQXBEVjJ5RSxXQWtETi9oRixHQUUyQixXQXBEckJnaUYsV0FtRFYzcEU7SUFDRDtNQUFBO1FBcERXcGpCO1FBb0RYLFdBcERXNnNGLFVBb0RKLFdBcERJQyxXQWtETi9oRixHQUFFb1A7UUFsREkyNUQ7S0FxRFQsT0FGRDF3RDtJQU9HOzRCQUE2QyxXQTFEdEN6TSxhQW1EVnlNOzBCQU80QixXQTFEbEJ6TSxhQWtESndEO0tBUUgscUJBQU8sV0ExREF4RCxhQWtETjVMO0lBTUosT0FBQSxXQTNHSnUzQixTQTJHSTtHQUVnRTtZQUdsRXpnQyxVQUFNa0osR0FBRW9QO0lBQ1Y7S0FBSWlPLE9BQU8sV0E5REdqb0IsV0E2RE40SyxHQUFFb1A7S0FFTjgwRSxXQUFXLFdBL0REbHZGLFVBNkROZ0wsR0FBRW9QO0lBR1AsR0FBQSxXQWhFV2xhLFVBNkROOEssR0FBRW9QO0tBR3dCLFVBQUEsV0FoRXBCd3hFLGVBOERWdmpFO0tBRVMsR0FBQSwwQkFEVDZtRTtNQU1HOytCQUE4QyxXQXJFdkN0NEUsYUE4RFZ5Ujs4QkFPNEIsV0FyRWxCelIsYUE2REp3RDtPQVFILHVCQUFPLFdBckVBeEQsYUE2RE41TDtNQU1KLE9BQUE7ZUF0SEp1M0IsU0FzSEk7OztJQUdDLE9BUkRsYTtHQVFLO0dBR1EsSUFBZjhtRSxlQUFlLFdBekVIYjtZQTBFWmMsbUJBQW1CcGtGLEdBQUVvUDtJQUFJLFVBQUEsV0ExRWJyYSxVQTBFT2lMLEdBMUVQOGlGO0lBMEVhLGFBRFYsV0F6RUgvdEYsVUEwRVNxYSxHQURyQiswRTtHQUMwRDtZQUUxRHB0RixVQUFNaUosR0FBRW9QO0lBQ0ksSUFBVmkxRSxVQUFVLFdBN0VBaHZGLFdBNEVOMkssR0FBRW9QOztPQUVQLFdBOUVXbGEsVUE0RUprYSxHQTVFSTI1RDtLQThFbUM7O09BSi9DcWIsbUJBR0VDLFNBRE1qMUU7WUFFdUMsV0E5RW5DbGEsVUE4RW1DLFdBOUVuQ2UsV0E2RVZvdUYsU0FETWoxRSxJQUFGcFA7O0tBT0Q7aUNBQWlELFdBbkYxQzRMLGFBNkVWeTRFOzZCQU00QixXQW5GbEJ6NEUsYUE0RUp3RDtNQU9ILHVCQUFPLFdBbkZBeEQsYUE0RU41TDtLQUtKLE9BQUEsV0FwSUp1M0IsU0FvSUk7O0lBR0MsT0FQRDhzRDtHQU9RO1lBR1ZydEYsVUFBTWdKLEdBQUVvUDtJQUNWLEtBZEVnMUUsbUJBYU1wa0YsR0FBRW9QLElBT0wsT0FBQSxXQTlGU25aLFdBdUZOK0osR0FBRW9QO0lBTUg7Ozs7O1NBQWlELFdBN0YxQ3hELGFBNkZvRCxXQTdGcEQzVixXQXVGTitKLEdBQUVvUDs7NEJBTXNCLFdBN0ZsQnhELGFBdUZKd0Q7S0FNSCx1QkFBTyxXQTdGQXhELGFBdUZONUw7SUFJSixPQUFBLFdBOUlKdTNCLFNBOElJO0dBR007WUFHUitzRCxNQUFJdGtGO0lBQUksT0FBRyxXQWpHQ2pMLFVBaUdSaUwsR0FqR1E4aUY7Y0FpR2tCO2NBQTZCLFdBakcvQ2htRixPQWlHUmtEO0dBQTREO1lBQ2hFdWtGLE1BQUl2a0Y7SUFBSSxPQUFHLFdBbEdDakwsVUFrR1JpTCxHQWxHUThpRjtjQWtHa0I7Y0FBNkIsV0FsRy9DeDhCLEtBa0dSdG1EO0dBQTREO2FBbEdwRDRpRjtJQXFHVCxNQUFBO1lBRUw0QixjQUFnQjMrRSxLQUE4QnFXO0lBQ2hELEdBRGtCclc7U0FBUUMsTUFBUkQsUUFBQUksUUFBUUg7O1NBQVJHO0lBQ2EsVUFBQSxXQXhHZnc2RSxjQXVHZ0N2a0U7SUFDekMsT0FBQSxXQXhHU29uRSxVQXdHVCwrQkFEV3I5RTtHQUNnQztZQUdoRHcrRSxnQkFBa0I1K0UsS0FBOEJxVztJQUNsRCxHQURvQnJXO1NBQVFDLE1BQVJELFFBQUFJLFFBQVFIOztTQUFSRztJQUNtQixVQUFBLFdBNUd2Qnc4RSxZQTJHa0N2bUU7SUFDckMsT0FBQTthQTVHR3NtRSxnQkE0R0gsK0JBRE92OEU7R0FDb0M7T0FHdER5K0Usc0NBUkFGLGdCQUlBQztZQVVBRSxtQkFBcUI5K0UsS0FBOEJzWCxJQUFHQztJQUN4RCxHQUR1QnZYO1NBQVFDLE1BQVJELFFBQUFJLFFBQVFIOztTQUFSRztJQUM2QjtLQUFBLE1BQUEsV0F0SHBDdzZFLGNBcUh3Q3JqRTtLQUNwQixNQUFBLFdBdEhwQnFqRSxjQXFIcUN0akU7SUFDOUMsT0FBQTthQXRIU21tRSxVQXNIVCxnQ0FEZ0JyOUU7R0FDNkM7WUFHbEUyK0UscUJBQXVCLytFLEtBQThCc1gsSUFBR0M7SUFDMUQsR0FEeUJ2WDtTQUFRQyxNQUFSRCxRQUFBSSxRQUFRSDs7U0FBUkc7SUFDaUMsSUFBQSxNQUFBLFdBMUgxQ3c4RSxZQXlIMENybEUsS0FDZCxNQUFBLFdBMUg1QnFsRSxZQXlIdUN0bEU7SUFDMUMsT0FBQTthQTFIR3FsRSxnQkEwSEgsZ0NBRFl2OEU7R0FDK0M7O0lBR3RFNCtFOzBCQVJBRixxQkFJQUM7WUFVQXo4QixXQUFXbm9EO0lBQ2I7S0FDUyxVQUFBLFdBcklPeWdGLGNBbUlIemdGO0tBRUosT0FBQTs7SUFFSixHQUFBLFdBdklXbEwsVUFtSUhrTCxHQW5JRytvRTtLQXdJa0QsdUJBQU0sV0F4SXhEbjlELGFBbUlINUw7S0FLTjtPQTNMTHUzQixTQTJMYTs7SUFDSSxJQUFiNHdCLGlCQXpJVXk2Qjs7S0EwSVI7O09BQUE7U0ExSVF0ckY7U0FBQXl4RTtTQTBJRztXQTFJSDhZLFdBbUlIN2hGLEdBT2lCLFdBMUlka2lGLGNBQUFwQyxPQXlJVjMzQjthQUFBQTtLQUFBQSxnQkFBQUE7O0dBSU87Ozs7T0E3SUc3NEI7T0FBQWd4RDtPQUFBQztPQUFBQztPQUFBQztPQUFBanRFO09BQUFDO09BQUE2YTtPQUFBMWlCO09BQUFvNkM7T0FBQXZDO09BQUE1dUQ7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQW9DO09BQUFEO09BQUE3QjtPQUFBRDtPQUFBRTtPQUFBQztPQUFBcXBEO09BQUFDO09BQUFDO09BQUFnbUI7T0FBQXliO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDOztPQUFBQztPQUFBblk7T0FBQStXO09BQUFxQjtPQUFBaHNGO09BQUFDO09BQUFDO09BQUFRO09BQUF5d0Q7T0FBQXh3RDtPQUFBQztPQUFBQztPQUFBQztPQUFBbXJGO09BQUFsckY7T0FBQXFHO09BQUFFO09BQUFHO09BQUFKO09BQUFFO09BQUFKO09BQUEra0Y7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQUM7T0FBQTNrRjtPQUFBNGtGO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFtQjtPQUFBbEI7T0FBQUM7T0FBQUM7T0FBQW5tRjtPQUFBb21GO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDO09BQUFDOztXQWtEWnhzRixXQVdBQyxXQWVBQyxXQVdBQyxXQVVBc3RGLE9BQ0FDO09BbEdZakI7T0FBQUM7T0FBQS84QjtPQUFBaTlCO09BQUFDO09BQUFDO09BQUFDO09BQUFKO09BQUFyYTtPQUFBQztPQUFBMlc7T0FBQThEO09BQUE1RTtPQUFBK0U7T0FBQUM7T0ErR2RTO09BY0FHO09BTUExOEI7aUNBbkljNDdCOzs7RTs7Ozs7O0dDbERMOztJQUFBO0lBbUJjOzs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7SUNqQnZCeHNEO1lBS0UvbkMsSUFBS0YsR0FBT0MsR0FBSSxPQUFKQSxJQUFQRCxJQUFBQSxJQUFPQyxFQUEwQjs7Ozs7Ozs7Ozs7Ozs7OztZQXVCeEN3a0IsZ0JBQVcseUNBRWE7WUFHeEIyaEQ7SUFBUyw4QkFDQTt1QkFDQztRQUMyQkE7SUFBdUIsT0FBdkJBO0dBQTZCO1lBOEJsRTdyRCxVQUFVN0osR0FBRzNKO2FBZFB5dUY7S0FBTTtNQUdnQjtPQURuQng5QztPQVJTMVg7T0FRMEIzRztPQUFHc2U7T0FDckNzdUIsS0F0QlZILE9BcUIrQ251QjtPQUN6Q3F1QixLQXRCTkYsT0FxQlNwdUI7TUFGSHc5QyxJQUVHeDlDO01BRkh3OUMsSUFFeUN2OUM7Z0JBQXRDRDtXQVpNeTlDLGlCQVlOejlDLFVBQUFBLFVBQUFBO09BVkMsUUFBQSxXQXNCR2p4QyxTQXhCRTB1RixVQUlHbjFEO1FBRmhCLE1BQUE7O2dCQVU2QzJYO1dBTmhDeTlDLGtCQU1nQ3o5QyxXQUFBQSxXQUFBQTtPQUpyQyxRQUFBLFdBZ0JHbHhDLFNBbEJFMnVGLFdBRkdwMUQ7UUFJaEIsTUFBQTs7TUFVWSxVQXZEWnBnQyxJQWtESW9tRSxJQUFJQztTQURrQzVzQyxNQU05QjtPQUFaLE1BQUE7TUFDWSxVQUFBLDRCQU5SMnNDLElBQUlDO01BTUEsT0FBQTtPQUFSLE1BQUE7OztLQVJrQjtJQVFTO0lBS04sT0FkakJpdkIsSUFjSTlrRjtHQUFnQztZQVcxQ2lsRixjQUNLMzFGO0lBRFcsVUFDWEEsd0JBQUFBO0tBQ2tDO01BRC9CZzRDLE9BQUhoNEM7TUFBc0M0MUYsYUFBdEM1MUY7TUFBa0RpNEMsUUFBbERqNEM7TUFDa0MsTUE5Q3ZDb21FLE9BNkN1RG51QjtNQUN0QyxNQTFFZi8zQyxJQTRCRmttRSxPQTZDUXB1QjtNQUNKNjlDLGFBQWE7UUFBYkEsZUFEdUNELFlBQXRDNTFGLE9BQ0Q2MUY7OztJQUVjLE1BQUE7R0FBWTtZQU05QkMsUUFBUUM7SUFDVixVQURVQSxnQ0FBQUE7S0FJQztNQUREQyxZQUhBRDtNQUdzQ0UsYUFIdENGO01BSUp6dkIsS0ExREpGLE9BeURRNHZCO01BRUp6dkIsS0EzREpILE9BeUQ4QzZ2QjtRQVN0Qyw0QkFQSjF2QixTQURBRDtnQkFESTB2QixnQ0FBQUE7T0FzQndCO1FBTmhCRSxpQkFoQlJGO1FBb0JTRyxrQkFwQlRIO1FBc0J3QixNQS9FaEM1dkIsT0E2RWlCK3ZCO2lCQTdFakIvdkIsT0F5RWdCOHZCO1FBbkJSSCxlQXVCU0k7UUFwQlRILGVBSEFEO1FBVlJKLGNBVVFJO1FBVlJKLGNBYVFLO1FBMkJGLE9BM0JFQTs7aUJBb0JTRyxzQ0FBQUE7WUFlR0MsVUFmSEQsb0JBZW9ERSxXQWZwREY7UUFwQlRILGVBbUNZSTtRQXRDWkwsZUFzQzZETTtRQWZwREYscUJBdkJUSjtRQXVCU0kscUJBcEJUSDtRQWJSTCxjQWFRSztRQWJSTCxjQVVRSTtRQVZSSixjQWlDaUJRO1FBdUJULE9BdkJTQTs7T0FhUyxNQUFBOztNQW5CSixNQUFBOztRQStCVCw0QkE1Q1Q3dkIsVUFDQUMsSUFmSm92QixjQVVRSSxZQW1GTixPQW5GTUE7O2VBR3NDRSxpQ0FBQUE7TUF5RFo7T0FObEJLLGtCQW5EOEJMO09BdUQ3Qk0sbUJBdkQ2Qk47T0F5RFosTUFsSGxDN3ZCLE9BNEdnQmt3QjtnQkE1R2hCbHdCLE9BZ0hpQm13QjtPQTFEVFIsZUFzRFFPO09BbkQ4QkwsZ0JBSHRDRjtPQVZSSixjQVVRSTtPQVZSSixjQWE4Q007T0E4RHhDLE9BOUR3Q0E7O2dCQW1EOUJLLHNDQUFBQTtXQWtCSUUsVUFsQkpGLG9CQWtCcURHLFdBbEJyREg7T0FuRDhCTCxnQkFxRXVCUTtPQXhFN0RWLGVBd0VZUztPQWxCSkYscUJBdERSUDtPQXNEUU8scUJBbkQ4Qkw7T0FiOUNOLGNBYThDTTtPQWI5Q04sY0FVUUk7T0FWUkosY0FnRWdCVztPQTBCUixPQTFCUUE7O01BZ0JVLE1BQUE7O0tBbEJKLE1BQUE7O0lBbERKLE9BRlZQO0dBb0ZEO1lBVVBXLFNBQVNDLE1BQUt0c0I7SUFDTCxJQUFQMmMsU0EvRkY4TyxRQThGY3pyQjtJQUVoQixVQUZXc3NCLDJCQUFBQTtTQUdEMytDLE9BSEMyK0M7S0FJTixLQUFBLDZCQURLMytDLE1BRk5ndkMsU0FETzJQLFVBQ1AzUDtLQUlGLE9BN0dBMk8sY0F3R1NnQjs7SUFNSixNQUFBO0dBQVk7WUFNakJDLFVBQVVELE1BQUt0c0I7SUFDTixJQUFQMmMsU0EzR0Y4TyxRQTBHZXpyQjtJQUVqQixVQUZZc3NCLDJCQUFBQTtTQUd3QzErQyxRQUh4QzArQztLQUlQLEtBQUEsNkJBRCtDMStDLE9BRmhEK3VDLFNBRFEyUCxVQUNSM1A7S0FJRixPQXpIQTJPLGNBb0hVZ0I7O0lBTUwsTUFBQTtHQUFZO1lBT1g5MUQsSUFBSW53QixHQUFFZ21FLFNBQVFtZ0IsT0FBTTl2RixTQUFRbTVCLEdBQUVqaEI7SUFDcEMsVUFEVXZPLGdCQUFVbW1GLGNBSWIsV0FKMkIzMkQsR0FBRWpoQjthQUExQnZPO0tBTUEsSUFETXMyRCxNQUxOdDJELE1BTUp3aUIsTUFBSSxXQU5nQm5zQixTQUtWaWdFLEtBTGtCOW1DO0tBVWhDLFNBSkloTjtNQU5jMmpFO2tCQU1kM2pFLGFBTjRCZ04sR0FBRWpoQixNQUExQnZPLFNBQUFBLEdBQXdCd3ZCLEdBQUVqaEI7O0tBQWhCNDNFO1FBQVJuZ0IsU0FBRmhtRSxPQUEwQnVPO0tBY2hDLE9BZE12Tzs7SUFxQkE7S0FEQXNuQyxPQXBCQXRuQztLQW9CWXU3QyxNQXBCWnY3QztLQW9CdUN1bkMsUUFwQnZDdm5DO0tBcUJKd1AsSUFBSSxXQXJCZ0JuWixTQUFRbTVCLEdBb0JaK3JCO0lBRXBCLFNBREkvckM7S0FyQmMyMkU7UUFBUm5nQixTQUFGaG1FLE9BQTBCdU87O2lCQXFCOUJpQjtLQWxDTjAyRSxVQWFVbG1GLEdBQUptd0IsSUFvQjJDb1gsT0FwQnJDeStCLFNBQVFtZ0IsT0FBTTl2RixTQUFRbTVCLEdBQUVqaEI7O0tBekJwQ3kzRSxTQXlCVWhtRixHQUFKbXdCLElBb0JJbVgsTUFwQkUwK0IsU0FBUW1nQixPQUFNOXZGLFNBQVFtNUIsR0FBRWpoQjtJQTRCN0IsT0E1Qkd2TztHQTZCUDtZQTlCSGsrRCxNQWdDRWwrRCxHQUFHZ21FLFNBQVMzdkUsU0FBUzh2RixPQUFPdjJELEtBQUtpN0M7SUFDM0IsSUFBSjNrRSxNQWhDRWlxQixJQStCSm53QixHQUFHZ21FLFNBQWtCbWdCLE9BQVQ5dkYsU0FBZ0J1NUIsS0FBS2k3QztXQUFac2IsV0F0SnZCZixRQXVKSWwvRSxPQUFBQTtHQUMyQjtZQUczQnczQixNQUFNMTlCO0lBQ1osSUFEWWtHLE1BQUFsRztJQUNaO2VBRFlrRyxrQkFFRDtjQUZDQTtVQUFBbEQsSUFBQWtEO2dCQUFBbEQsZ0JBQUFrRCxNQUFBbEQ7VUFHY3VMLElBSGRySSxRQUdHc3BCLElBSEh0cEI7OztVQUdHcTFDLE1BSEhyMUMsUUFHY3c2QixNQUhkeDZCLFFBR2NxSSxJQUFBbXlCLEtBQVhsUixJQUFBK3JCO0tBQ3VELGVBRHZEL3JCLEdBQVdqaEI7O0dBRStDO1lBR25FOGMsS0FBS3JyQjtJQUNYLElBRFdrRyxNQUFBbEc7SUFDWDtlQURXa0csa0JBRUE7Y0FGQUE7Z0JBQUFBLGNBQUFBO2dCQUFBQSx5QkFBQXVCLElBQUF2QixRQUFBQSxNQUFBdUI7VUFHZThHLFNBQVhpaEI7OztVQUFBK3JCLE1BSEpyMUMsUUFHZXc2QixNQUhmeDZCLFFBR2VxSSxJQUFBbXlCLEtBQVhsUixJQUFBK3JCO0tBQ3VELGVBRHZEL3JCLEdBQVdqaEI7O0dBRThDO1lBSWxENjNFO0lBQ0VwbUY7SUFDQzNKO0lBQ0RtNUI7SUFDQTYyRDtJQUNBQztJQUNDQztJQUNBQztJQUNBMzdDO0lBQ0FDO0lBRXpCLElBVndCNWtDLE1BQUFsRztJQVV4QjtlQVZ3QmtHO01BV2IsT0FBQSxXQUxjc2dGLG1CQUVBMTdDLGNBTkR0YixHQUNBNjJELE1BQ0FDO2NBSkFwZ0Y7VUFZVG93RCxNQVpTcHdELFFBWUd3NkIsTUFaSHg2QjtNQWFuQixhQUFBLFdBWm9CN1AsU0FDRG01QixHQVVUOG1DO2dCQUVSLFdBVGtCaXdCLGVBRUExN0MsVUFLVnlyQixLQUFZNTFCLEtBVEgybEQsTUFDQUM7Z0JBV2pCLFdBVGtCRSxtQkFFQTE3QyxjQU5EdGIsR0FDQTYyRCxNQUNBQzs7S0FhZDtNQUREaC9DLE9BaEJlcGhDO01BZ0JIcTFDLE1BaEJHcjFDO01BZ0JTcUksSUFoQlRySTtNQWdCd0JxaEMsUUFoQnhCcmhDO01BaUJsQnNKLElBQUksV0FoQmVuWixTQUNEbTVCLEdBY0grckI7S0FFbkIsU0FESS9yQztNQUVDLE9BQUEsV0Fka0IrMkUsZUFFQTE3QyxVQVNKMFEsS0FBWWh0QyxHQWJUODNFLE1BQ0FDO1NBSkF6YyxlQWlCbEJyNkQsSUFEMEMrM0IsUUFBdkNEO0tBaEJlcGhDLE1BQUEyakU7O0dBOEJMO1lBSWYwYyxjQUFlMTdDLGlCQUFpQmdnQyxnQkFBYSxPQUFBLFdBQTlCaGdDLFVBQWlCZ2dDO0dBQTBCO0dBQzlELFNBQUkyYixrQkFBbUIxN0MsY0FBYWxiLGlCQUFZLE9BQUEsV0FBekJrYixjQUFhbGI7R0FBNEI7WUFGOUQ2MkQsY0FHRXptRixHQUFHM0osU0FBUW01QixHQUFHcWIsVUFBVUM7SUFDMUIsT0F0Q29CczdDO2FBcUNsQnBtRjthQUFHM0o7YUFBUW01Qjs7O2FBRlgrMkQ7YUFDQUM7YUFDYzM3QzthQUFVQztHQVVYO1lBSWI0N0MsZ0JBQWU3N0MsVUFBVWpiLEtBQUtpN0Msa0JBQWEsT0FBQSxXQUE1QmhnQyxVQUFVamIsS0FBS2k3QztHQUFnQztHQUNsRSxTQUFJOGIsb0JBQW1CNzdDLGNBQWFsYixpQkFBWSxPQUFBLFdBQXpCa2IsY0FBYWxiO0dBQTRCO1lBRjlEZzNELGVBR0U1bUYsR0FBRzNKLFNBQVFtNUIsR0FBR3FiLFVBQVVDO0lBQzFCLE9BdERvQnM3QzthQXFEbEJwbUY7YUFBRzNKO2FBQVFtNUI7OzthQUZYazNEO2FBQ0FDO2FBQ2M5N0M7YUFBVUM7R0FVWDtZQUliKzdDLGdCQUFlaDhDLGlCQUFpQmdnQyxNQUFLdGhFLFVBQVMsT0FBQSxXQUEvQnNoQyxVQUFpQmdnQyxNQUFLdGhFO0dBQTBCO0dBQ25FLFNBQUl1OUUsb0JBQW1CaDhDLGNBQWFsYixLQUFJcm1CLFlBQVMsT0FBQSxXQUExQnVoQyxjQUFhbGIsS0FBSXJtQjtHQUE2QjtZQUZuRXc5RSxlQUdFL21GLEdBQUczSixTQUFRbTVCLEdBQUdwc0IsR0FBR3luQyxVQUFVQztJQUM3QixPQXRFb0JzN0M7YUFxRWxCcG1GO2FBQUczSjthQUFRbTVCO2FBQUdwc0I7O2FBRmR5akY7YUFDQUM7YUFDaUJqOEM7YUFBVUM7R0FVZDtZQUliazhDLGdCQUFlbjhDLFVBQVVqYixLQUFLaTdDLE1BQUt0aEUsWUFBUyxPQUFBLFdBQTdCc2hDLFVBQVVqYixLQUFLaTdDLE1BQUt0aEU7R0FBZ0M7R0FDdkUsU0FBSTA5RSxvQkFBbUJuOEMsY0FBYWxiLEtBQUlybUIsWUFBUyxPQUFBLFdBQTFCdWhDLGNBQWFsYixLQUFJcm1CO0dBQTZCO1lBRm5FMjlFLGdCQUdFbG5GLEdBQUczSixTQUFRbTVCLEdBQUdwc0IsR0FBR3luQyxVQUFVQztJQUM3QixPQXRGb0JzN0M7YUFxRmxCcG1GO2FBQUczSjthQUFRbTVCO2FBQUdwc0I7O2FBRmQ0akY7YUFDQUM7YUFDaUJwOEM7YUFBVUM7R0FVZDtZQUlicThDLGdCQUFldDhDLGlCQUFpQmdnQyxNQUFLd2IsTUFBS0MsTUFBTyxPQUFBLFdBQWxDejdDLFVBQWlCZ2dDLE1BQUt3YixNQUFLQztHQUE4QjtHQUM1RSxTQUFJYyxvQkFBbUJ0OEMsY0FBYWxiLEtBQUl5MkQsTUFBS0MsTUFBTyxPQUFBLFdBQTdCeDdDLGNBQWFsYixLQUFJeTJELE1BQUtDO0dBQWlDO1lBRjVFZSxlQUdFcm5GLEdBQUczSixTQUFRbTVCLEdBQUdwc0IsR0FBR0MsR0FBR3duQyxVQUFVQztJQUNoQyxPQXRHb0JzN0M7YUFxR2xCcG1GO2FBQUczSjthQUFRbTVCO2FBQUdwc0I7YUFBR0M7YUFGakI4akY7YUFDQUM7YUFDb0J2OEM7YUFBVUM7R0FVakI7WUFJYnc4QyxnQkFBZXo4QyxVQUFVamIsS0FBS2k3QyxNQUFLd2IsTUFBS0MsTUFBTyxPQUFBLFdBQWhDejdDLFVBQVVqYixLQUFLaTdDLE1BQUt3YixNQUFLQztHQUFvQztHQUNoRixTQUFJaUIsb0JBQW1CejhDLGNBQWFsYixLQUFJeTJELE1BQUtDLE1BQU8sT0FBQSxXQUE3Qng3QyxjQUFhbGIsS0FBSXkyRCxNQUFLQztHQUFpQztZQUY1RWtCLGdCQUdFeG5GLEdBQUczSixTQUFRbTVCLEdBQUdwc0IsR0FBR0MsR0FBR3duQyxVQUFVQztJQUNoQyxPQXRIb0JzN0M7YUFxSGxCcG1GO2FBQUczSjthQUFRbTVCO2FBQUdwc0I7YUFBR0M7YUFGakJpa0Y7YUFDQUM7YUFDb0IxOEM7YUFBVUM7R0FVakI7WUFJYkQsU0FBU3Q4QixHQUFJLFdBQUpBLEdBQVU7R0FDdkIsU0FBSXU4QixvQkFBaUIsU0FBSTtZQUZ2Qjl4QixLQUdFaFosR0FBRzNKLFNBQVFtNUI7SUFBSyxPQW5HbEJpM0QsY0FtR0V6bUYsR0FBRzNKLFNBQVFtNUIsR0FGWHFiLFVBQ0FDO0dBQ2tFO1lBSWxFMjhDLGtCQUFhLFNBQUk7R0FDckIsU0FBSUMsc0JBQWlCLFNBQUs7WUFGeEJydEUsSUFHRXJhLEdBQUczSixTQUFRbTVCO0lBQUssT0F6R2xCaTNELGNBeUdFem1GLEdBQUczSixTQUFRbTVCLEdBRlhpNEQsWUFDQUM7R0FDa0U7WUFXOURsdkIsZUFBZW1CO0lBQ3JCLFVBRHFCQTtLQUVWLE1BQUE7YUFGVUEsU0FHVDtRQU9IcnlCLE9BVllxeUI7Y0FVWnJ5Qix1QkFOOENDLFFBSmxDb3lCLFNBSTZDLE9BQVhweUI7YUFNOUNELFNBOU9UMCtDLFNBb09xQnJzQixNQUFmbkIsZUFVR2x4QixRQUNQLE9BWG1CcXlCO1FBS1NucUMsSUFMVG1xQyxTQUtvQnByRCxJQUxwQm9yRDtrQkFBQUEsMkJBS1NucUMsR0FBV2poQixNQXpPekN5M0UsU0FvT3FCcnNCLFVBQUFBO0dBWWY7WUF3QkF6cEMsT0FBT2x3QixHQUFFMm5GLFNBQVF0eEYsU0FBUWtsRDtJQUMvQixVQURhdjdDLGdCQUFFMm5GLGdCQUliO2FBSlczbkY7U0FLRXcyRCxNQUxGeDJEO0tBTVIsYUFBQSxXQU5rQjNKLFNBQVFrbEQsS0FLaEJpYjtnQkFMQW14QjtnQkFBQUEsZ0JBQUYzbkY7O0lBY0g7S0FERDZvQyxTQWJJN29DO0tBYVFzMkQsTUFiUnQyRDtLQWFtQ3VuQyxRQWJuQ3ZuQztLQWNQd1AsSUFBSSxXQWRhblosU0FBUWtsRCxLQWFWK2E7SUFFbkIsU0FESTltRDtpQkFBQUE7Z0JBMVFOMDJFLFVBNFBhbG1GLEdBQVBrd0IsT0FhMENxWCxPQWJqQ29nRCxTQUFRdHhGLFNBQVFrbEQsT0FBbEJ2N0M7Z0JBeFFiZ21GLFNBd1FhaG1GLEdBQVBrd0IsT0FhRzJZLFFBYk04K0MsU0FBUXR4RixTQUFRa2xELE9BQWxCdjdDO0lBQUUybkY7Y0FhTjkrQyxxQkFqQ0ssT0FpQ2tDdEI7Y0FBQUEsb0JBaENsQyxPQWdDTHNCO1FBeERLOHdCLE9Bd0RrQ3B5QjtJQXZEaEQ7ZUFEY295QjtVQTBCUjJjO21CQTFCUTNjO1VBQUFyeUIsT0FBQXF5QjtnQkFBQXJ5QixtQkFBQXF5QixPQUFBcnlCO1VBMEJSZ3ZDLFNBMUJRM2M7OztVQTBCUjJjLFNBMUJRM2M7S0EyQlosVUFESTJjO01BRVEsTUFBQTtLQURaLFNBRElBO01BM09ONFAsVUEyT001UCxRQW5CQTlkLGVBaUQwQ2p4QjtNQXJSaER5K0MsU0F1UE0xUCxRQThCR3p0QztNQWhCSixPQWRDeXRDOztLQUlRO01BREk5bUQsSUFIWjhtRDtNQUd1Qi9uRSxJQUh2QituRTtNQUlHajFFLEtBelZUK2pGLFFBa1VNNXNCLGVBaUQwQ2p4QjtNQXJCVixNQXBadENtdUIsT0ErWVNyMEQ7TUFLUyxNQWhiaEI3UixJQTRCRmttRSxPQXlhUzdzQjtLQXhCRixXQXdCRUEsUUEzQlNyWixHQUFXamhCLEdBTVgscUNBTFRsTjs7R0FzQ0g7WUFyRU44OEQsU0F1RUVuK0QsR0FBRzJuRixTQUFTdHhGLFNBQVFtNUI7SUFBSyxPQWpZM0I0MUQsUUFzV01sMUQsT0EyQkpsd0IsR0FBRzJuRixTQUFTdHhGLFNBQVFtNUI7R0FBeUM7WUFHM0R6dkIsS0FBS0MsR0FBR04sTUFBTU87SUFDcEIsSUFEV2lHLE1BQUFsRyxHQUFHMDZELFNBQUFoN0Q7SUFDZDtlQURXd0csa0JBRUEsT0FGR3cwRDtjQUFIeDBEO1VBR0YwaEYsUUFIRTFoRixRQUdXMmhGLFNBSFgzaEY7TUFHcUIsT0FBQSxXQUhaakcsR0FHWDJuRixPQUFhQyxRQUhSbnRCOztTQTBCUnB6QixPQTFCS3BoQztlQTBCTG9oQztVQU5BMVgsTUFwQksxcEIsUUFxQkcya0UsT0FyQkgza0UsZ0JBQUFBOztXQXVCZ0I0aEYsaUJBQWNDO09BQ1IsT0FBQSxXQXhCYjluRixHQXVCTzZuRixNQUFjQyxPQUNSLFdBeEJiOW5GLEdBb0JkMnZCLEtBQ1FpN0MsTUFyQkFuUTs7OztlQTBCUnB6QjtXQUFNMGdELFFBMUJEOWhGLFFBMEJjd3pFLFNBMUJkeHpFLGtCQUFBQTs7WUEwQnFEK2hGLHFCQUFjQztRQUNqRCxPQUFBO2lCQTNCVGpvRjtpQkEwQjRDZ29GO2lCQUFjQztpQkFDakQsV0EzQlRqb0YsR0EwQlIrbkYsT0FBYXRPLFFBMUJuQjM1RSxLQTBCQXVuQyxNQTFCUW96QixRQUFNejZEOzs7OztRQUtNa29GLFNBcUJwQjdnRDtRQXJCa0M4Z0QsVUFxQmxDOWdEO1FBcEJBK2dELFFBTktuaUY7UUFPR29pRixTQVBIcGlGO2tCQUFBQTs7UUFpQlcsT0FBQTtpQkFqQkZqRyxHQU1kb29GLE9BQ1FDLFFBVVEsV0FqQkZyb0YsR0FLTWtvRixRQUFjQyxTQUwxQjF0Qjs7WUFTYTZ0QixxQkFBY0M7UUFDUixPQUFBO2lCQVZidm9GO2lCQVNPc29GO2lCQUFjQztpQkFDUjttQkFWYnZvRixHQU1kb29GLE9BQ1FDLFFBR2lDLFdBVjNCcm9GLEdBS01rb0YsUUFBY0MsU0FMMUIxdEI7OztnQkEwQlJwekIsMkJBQUFBO09BSWdCO1FBREltaEQsT0FIcEJuaEQ7UUFHa0NvaEQsUUFIbENwaEQ7UUFHMkNxaEQsUUE3QnRDemlGO1FBNkJtRDBpRixTQTdCbkQxaUY7UUFBQTJqRSxVQUFBM2pFO1FBQUcybkU7VUE4QlEsV0E5QkY1dEUsR0E2QjZCMG9GLE9BQWFDLFFBQzFCLFdBOUJoQjNvRixHQTZCTXdvRixNQUFjQyxPQTdCMUJodUI7T0FBSHgwRCxNQUFBMmpFO09BQUduUCxTQUFBbVQ7Ozs7S0FnQ0s7TUFESmgrQyxRQS9CSjNwQjtNQStCaUJnbkUsU0EvQmpCaG5FO01BQUFxaEMsUUFBQXJoQztNQUFHeW5FLFNBZ0NLLFdBaENDMXRFLEdBK0JMNHZCLE9BQWFxOUMsUUEvQnRCbnRFLEtBMEJBdW5DLE1BMUJRb3pCLFFBQU16NkQ7S0FBVGlHLE1BQUFxaEM7S0FBR216QixTQUFBaVQ7O0dBZ0MyQztZQUduRHh0RSxLQUFLSCxHQUFHQztJQUNkLElBRFdpRyxNQUFBbEc7SUFDWDtlQURXa0csa0JBRUE7Y0FGQUE7VUFHRjJwQixRQUhFM3BCLFFBR1dnbkUsU0FIWGhuRTtNQUdxQixPQUFBLFdBSGxCakcsR0FHTDR2QixPQUFhcTlDOztTQUNiNWxDLE9BSkVwaEMsUUFJSTBwQixNQUpKMXBCLFFBSWlCMmtFLE9BSmpCM2tFLFFBQUFxaEMsUUFBQXJoQztLQUFML0YsS0FJR21uQyxNQUpLcm5DO0tBTVosV0FOWUEsR0FJQzJ2QixLQUFhaTdDO0tBSmpCM2tFLE1BQUFxaEM7O0dBT0k7WUFHVHNoRCxhQUFhN29GLEdBQUdDO0lBQ3RCLElBRG1CaUcsTUFBQWxHO0lBQ25CO2VBRG1Ca0csa0JBRVI7Y0FGUUE7VUFHVDJwQixRQUhTM3BCLFFBR0pveUQsVUFISXB5RDtNQUFBQSxTQUd3QixXQUhyQmpHLEdBR1o0dkIsT0FBS3lvQzs7O1NBQ0xoeEIsT0FKU3BoQyxRQUlIMHBCLE1BSkcxcEIsUUFJRThwQixRQUpGOXBCLFFBQUFxaEMsUUFBQXJoQztLQUFiMmlGLGFBSUl2aEQsTUFKWXJuQztLQUFIaUcsU0FNTixXQU5TakcsR0FJTjJ2QixLQUFLSTtLQUpGOXBCLE1BQUFxaEM7O0dBT0k7WUFHckIwMEI7SUFBYTtLQUNJLE9BQUE7Y0FuaEJqQjFrQztjQW1oQmlCOztTQUNMdkgsa0JBQUxKOztTQUFBQyxrQkFBS3lvQyxvQkFBQXRvQyxRQUFBc29DLFNBQUwxb0MsTUFBQUM7SUFBNEMsV0FBNUNELEtBQUtJO0dBQWlEOzs7OztPQXhmN0RqYztPQXNDQWxLO09BMklBcTBEO09BcUNJeGdDO09BUUFyUztPQTJJSnJTO09BaEdBeXRFO09BZ0NBTTtPQWdDQU07T0FoREFUO09BZ0NBTTtPQWdDQU07T0FzQkFudEU7T0FNQThqRDtPQTBFSXArRDtPQW1DQUk7T0FVQTBvRjtPQVVKNXNCOzs7RTs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNsaEJBaHZEO0lBQ0FndEI7SUFDQTV3QjtJQUNBa3VCOzs7WUErdkJFb3pDLFlBaHZCVTNxRSxHQUFJLE9BQUpBLFFBQWlDO1lBQzdDOHBFLFlBQVk5cEUsR0FBSSxPQUFKQSxRQUErQjtZQUUzQzhvRix3QkFBd0I5b0Y7SUFDMUIsZUFEMEJBOztjQUNLOztHQUF5RDtZQUd0RitvRixpQkFBaUIvb0YsR0FBRUM7SUFDckIsS0FEbUJELE1BV2QsT0FBQSxXQVhnQkM7SUFBRkQ7SUFJakIsSUFBTSxJQUNKMVEsSUFESSxXQUphMlE7VUFRUHFMO1NBQUFGLDBCQUFBRTtLQVJLdEw7S0FVZixNQUFBLDRCQUZVb0w7O0lBUktwTDtJQU9mLE9BRkExUTtHQU1LO0dBS1k7SUFBbkIwNUYsbUJBQW1COzs7Ozs7Ozs7Ozs7WUFXbkI5cEYsT0FBUzJHLFdBQW9DNjBCO0lBQy9DLEdBRFc3MEI7U0FBaUJDLE1BQWpCRCxRQUFBb2pGLGlCQUFpQm5qRjs7U0FBakJtakY7SUFDWCxhQUQyQzlwRSxpQkFBUDRzQyxPQUFPNXNDLGdCQUFQNHNDO0lBQ2pCO0tBQUEsT0FBQSw0QkFEaUJBO0tBQ2hDbTlCLFNBQU8sK0JBWlRGO0tBYUVHLFNBQU8seUJBRFBEO0lBRUo7WUFBVSwyQkFETkM7OztZQUZPRjtZQUFvQ3Z1RDs7R0FTOUM7WUFZQzB1RCxLQUFLcHBGLEdBQUU0dkI7SUFDVDtLQUFJdm1CLE9BQU8sV0FESnJKLFNBQUU0dkI7S0FHQyxPQUFBLDRCQUhINXZCO0lBR0csT0FBQSw2QkFGTnFKO0dBRWdDO1lBR2xDZ2dGLFdBQVdycEYsR0FBR2dtRSxTQUFTcDJDLEtBQUtpN0M7SUFDOUI7S0FBSTV4RSxJQVBGbXdGLEtBTVdwcEYsR0FBWTR2QjtLQUVyQitYLHdCQUZTM25DLE1BQ1QvRyxPQUFBQTtLQUVBa3RGLFFBSFNubUY7SUFHVG1tRjtJQVFpQztLQUFBLE9BdkVuQ3JjLFlBNERXOXBFO0tBS1RzcEY7T0FNRiw0QkFURTNoRCxNQUZZcStCLGVBR1ptZ0IsT0FIcUJ2MkQsS0FBS2k3QztPQUcxQnNiLFVBSFNubUYsT0FhYyw0QkFiZEE7SUFnQk47S0FBQSxXQUFBLDZCQVhIc3BGLFVBSEEzaEQ7cUNBRlMzbkMsTUFDVC9HLE9BQUFBLEtBSUFxd0Y7SUFXbUM7R0FBdUI7WUFHNURDLG1CQUFtQnZwRjtJQUNyQjtLQUFJYixNQURpQmE7S0FFakJ3cEYsY0FEQXJxRixNQURpQmE7S0FHckIsT0FESXdwRixjQUZpQnhwRixPQUVqQndwRjs7S0FHNkI7TUFBQSxPQUFBLDRCQUo3QnJxRjtNQUlFc3FGLG1CQUFtQiwrQkE5RHZCVDthQTBERTdwRixNQUlFc3FGOztNQUdjO09BQVpDO1NBQVksMkJBSGREO09BSUVFLFlBVGEzcEY7TUFBQUEsT0FRYjBwRjtNQVJhMXBGO01BYUo7T0FEVEMsYUFBRzJ2QixLQUFLaTdDLE1BQU8sT0EvQnJCd2UsV0FtQm1CcnBGLE1BWVY0dkIsS0FBS2k3QyxNQUE0QztPQUMzQyxPQUFBLDRCQUpUOGU7OztXQUlKMXdGOztRQUNlLDRCQUxYMHdGLFdBSUoxd0YsT0FBQUE7UUFDRSxtQ0FGRWdIO1FBRUYsV0FERmhIO29CQUFBQTtRQUFBQTs7Ozs7Ozs7Ozs7O0dBRU07WUFxbEJOa3VDLElBbGxCRW5uQyxHQUFHNHZCLEtBQUtpN0M7SUEvRlppZSx3QkErRkk5b0Y7SUFyQ0pxcEYsV0FxQ0lycEYsTUFBRzR2QixLQUFLaTdDO0lBRWQsT0FwQkUwZSxtQkFrQkl2cEY7R0FHYztZQWdsQmhCbXdCLElBN2tCRW53QixHQUFHNHZCLEtBQUtpN0M7SUFyR1ppZSx3QkFxR0k5b0Y7SUEzQ0pxcEYsV0EyQ0lycEYsTUFBRzR2QixLQUFLaTdDO1dBQVI3cUUsV0F4Qkp1cEYsbUJBd0JJdnBGO0dBT1M7WUF1a0JYZ3JFLFFBcGtCTWhyRSxHQUFHNHZCLEtBQUtpN0M7SUFDbEIsWUFra0JJMTZDLElBbmtCTW53QixHQUFHNHZCLEtBQUtpN0MsT0FFVDtJQUVXO0tBQWQrZSxnQkEwbkJGamYsWUE5bkJNM3FFO0tBS0p5VztPQUFROzs7OztTQUxEbVo7U0FJUGc2RDtJQUVKLE9BQUEsMkJBREluekU7R0FDYTtZQXlqQmZ5MEMsTUF0akJJbHJEO0lBeEhOOG9GLHdCQXdITTlvRjtJQUVLLElBQUEsT0FBQSw0QkFGTEEscUJBQ1I7O1NBQ0EvRzs7TUFDRTtNQUFBLGlCQUhNK0csTUFFUi9HLE9BQUFBO01BQ0UsV0FERkE7a0JBQUFBO01BQUFBOzs7SUFGUStHOztHQUtLO1lBeWxCVHltRixjQXRsQll6bUYsR0FBRTR2QixLQUFLaWIsVUFBVUM7SUFJakMsSUFBZSxPQWhGYnMrQyxLQTRFY3BwRixHQUFFNHZCLE1BUWhCK3BDLHdCQVJjMzVEO2NBUWQyNUQsbUJBSGlCLE9BQUEsV0FMYzd1QixjQUFmbGI7YUFRaEIrcEM7S0FDb0MsV0EzSXBDbVEsWUFrSWM5cEU7S0FTZCxPQUFBOytCQURBMjVELFlBUmdCL3BDLEtBQUtpYixVQUFVQzs7UUFNVnRiLElBRXJCbXFDLFNBRmdDcHJELElBRWhDb3JEO0lBREcsYUFBQSxXQXpJSG1RLFlBa0ljOXBFLElBTU93dkIsR0FOTEk7Y0FPZ0IsV0FQWGliLFVBTVd0OEI7Y0FDZ0IsV0FQakJ1OEIsY0FBZmxiO0dBUytEO1lBOGtCN0VtM0QsZUEza0JhL21GLEdBQUU0dkIsS0FBS3hzQixHQUFHeW5DLFVBQVVDO0lBQ3JDLElBQWUsT0F6RmJzK0MsS0F3RmVwcEYsR0FBRTR2QixNQUtqQitwQyx3QkFMZTM1RDtjQUtmMjVELG1CQUhpQixPQUFBLFdBRmtCN3VCLGNBQWxCbGIsS0FBS3hzQjthQUt0QnUyRDtLQUNxQyxXQXBKckNtUSxZQThJZTlwRTtLQU1mLE9BQUE7K0JBREEyNUQsWUFMaUIvcEMsS0FBS3hzQixHQUFHeW5DLFVBQVVDOztRQUdkdGIsSUFFckJtcUMsU0FGZ0NwckQsSUFFaENvckQ7SUFERyxhQUFBLFdBbEpIbVEsWUE4SWU5cEUsSUFHTXd2QixHQUhKSTtjQUllLFdBSlBpYixVQUdPdDhCLEdBSFZuTDtjQUk0QixXQUpmMG5DLGNBQWxCbGIsS0FBS3hzQjtHQU02RDtZQXNrQmpGaWtGLGVBbmtCYXJuRixHQUFFNHZCLEtBQUt4c0IsR0FBR0MsR0FBR3duQyxVQUFVQztJQUN4QyxJQUFlLE9BbEdicytDLEtBaUdlcHBGLEdBQUU0dkIsTUFLakIrcEMsd0JBTGUzNUQ7Y0FLZjI1RCxtQkFIaUIsT0FBQSxXQUZxQjd1QixjQUFyQmxiLEtBQUt4c0IsR0FBR0M7YUFLekJzMkQ7S0FDcUMsV0E3SnJDbVEsWUF1SmU5cEU7S0FNZixPQUFBO2dDQURBMjVELFlBTGlCL3BDLEtBQUt4c0IsR0FBR0MsR0FBR3duQyxVQUFVQzs7UUFHakJ0YixJQUVyQm1xQyxTQUZnQ3ByRCxJQUVoQ29yRDtJQURHLGFBQUEsV0EzSkhtUSxZQXVKZTlwRSxJQUdNd3ZCLEdBSEpJO2NBSWUsV0FKSmliLFVBR0l0OEIsR0FIVm5MLEdBQUdDO2NBSTJCLFdBSmR5bkMsY0FBckJsYixLQUFLeHNCLEdBQUdDO0dBTTZEO1lBOGpCcEZ1akYsZUEzakJhNW1GLEdBQUU0dkIsS0FBS2liLFVBQVVDO0lBSWxDLElBQWUsT0E5R2JzK0MsS0EwR2VwcEYsR0FBRTR2QixNQVFqQitwQyx3QkFSZTM1RDtjQVFmMjVELG1CQUhpQixPQUFBLFdBTGU3dUIsY0FBZmxiO2FBUWpCK3BDO0tBQ3FDLFdBektyQ21RLFlBZ0tlOXBFO0tBU2YsT0FBQTtnQ0FEQTI1RCxZQVJpQi9wQyxLQUFLaWIsVUFBVUM7O1FBTVh0YixJQUVyQm1xQyxTQUZnQ3ByRCxJQUVoQ29yRDtJQURHLGFBQUEsV0F2S0htUSxZQWdLZTlwRSxJQU1Nd3ZCLEdBTkpJO2NBT2UsV0FQVmliLFVBTURyYixHQUFXamhCO2NBQzZCLFdBUDdCdThCLGNBQWZsYjtHQVMrRDtZQW1qQjlFczNELGdCQWhqQmNsbkYsR0FBRTR2QixLQUFLeHNCLEdBQUd5bkMsVUFBVUM7SUFDdEMsSUFBZSxNQXZIYnMrQyxLQXNIZ0JwcEYsR0FBRTR2QixNQUtsQitwQyx3QkFMZ0IzNUQ7Y0FLaEIyNUQsbUJBSGlCLE9BQUEsV0FGbUI3dUIsY0FBbEJsYixLQUFLeHNCO2FBS3ZCdTJEO0tBQ3NDLFdBbEx0Q21RLFlBNEtnQjlwRTtLQU1oQixPQUFBO2dDQURBMjVELFlBTGtCL3BDLEtBQUt4c0IsR0FBR3luQyxVQUFVQzs7UUFHZnRiLElBRXJCbXFDLFNBRmdDcHJELElBRWhDb3JEO0lBREcsYUFBQSxXQWhMSG1RLFlBNEtnQjlwRSxJQUdLd3ZCLEdBSEhJO2NBSWMsV0FKTmliLFVBR0xyYixHQUFXamhCLEdBSFRuTDtjQUl3QyxXQUozQjBuQyxjQUFsQmxiLEtBQUt4c0I7R0FNNkQ7WUEyaUJsRm9rRixnQkF4aUJjeG5GLEdBQUU0dkIsS0FBS3hzQixHQUFHQyxHQUFHd25DLFVBQVVDO0lBQ3pDLElBQWUsTUFoSWJzK0MsS0ErSGdCcHBGLEdBQUU0dkIsTUFLbEIrcEMsd0JBTGdCMzVEO2NBS2hCMjVELG1CQUhpQixPQUFBLFdBRnNCN3VCLGNBQXJCbGIsS0FBS3hzQixHQUFHQzthQUsxQnMyRDtLQUdXLFVBN0xYbVEsWUFxTGdCOXBFO0tBTWhCLE9BQUE7Z0NBREEyNUQsV0FMa0IvcEMsS0FBS3hzQixHQUFHQyxHQUFHd25DLFVBQVVDOztRQUdsQnRiLElBRXJCbXFDLFNBRmdDcHJELElBRWhDb3JEO0lBREcsYUFBQSxXQXpMSG1RLFlBcUxnQjlwRSxJQUdLd3ZCLEdBSEhJO2NBSWMsV0FKSGliLFVBR1JyYixHQUFXamhCLEdBSFRuTCxHQUFHQztjQUl1QyxXQUoxQnluQyxjQUFyQmxiLEtBQUt4c0IsR0FBR0M7R0FhWDtZQUlid25DLFNBQVN0OEIsR0FBSSxXQUFKQSxHQUFVO0dBQ3ZCLFNBQUl1OEIsb0JBQWlCLFNBQUk7WUErZ0JyQjl4QixLQTlnQkFoWixHQUFFNHZCO0lBQU8sT0FnaEJUNjJELGNBaGhCQXptRixHQUFFNHZCLEtBRkZpYixVQUNBQztHQUNvRDtZQW9mcER6d0IsSUFqZkVyYSxHQUFFNHZCO0lBQ1IsSUFBZSxNQXRKYnc1RCxLQXFKSXBwRixHQUFFNHZCLE1BSU4rcEMsd0JBSkkzNUQ7Y0FJSjI1RCxtQkFGaUI7YUFFakJBO0tBQWtDLFVBL01sQ21RLFlBMk1JOXBFO0tBSUksT0FBQSw2QkFBUjI1RCxXQUpNL3BDOztRQUdlSixJQUNyQm1xQztpQkFEdUMsV0E5TXZDbVEsWUEyTUk5cEUsSUFHaUJ3dkIsR0FIZkk7R0FJK0M7WUFtZW5ETSxPQWhlS2x3QixHQUFFNHZCO0lBaE5UazVELHdCQWdOTzlvRjtJQUVEO0tBQUovRyxJQTlKRm13RixLQTRKT3BwRixHQUFFNHZCO0tBR1ArWCx3QkFISzNuQyxNQUVML0csT0FBQUE7S0FFQTR3RixtQkFKSzdwRjtJQUlMNnBGO0lBR3FEO0tBQUEsTUF6TnZEL2YsWUFrTk85cEU7S0FNTHNwRixXQUNGLDZCQUpFM2hELE1BQ0FraUQsdUJBSk9qNkQ7V0FTSiw2QkFOSCtYLE1BR0EyaEQ7S0FHbUMsaUJBVDlCdHBGLE1BRUwvRyxPQUFBQSxLQUlBcXdGOztXQUZBTztrQkFKSzdwRixPQVU2Qiw0QkFWN0JBOztHQVV5QztZQTJlOUM4QixPQXhlSzlCLEdBQUksT0FBSkEsS0FBWTtZQXllakIrVCxTQXplSy9ULEdBQ00sYUFETkEsYUFDa0I7WUFzZXZCRCxLQXZlS0MsR0FHQ04sTUFBTU87SUFDaEIsU0FKU0QsTUFLSixPQUZLTjtJQUtFLElBRE44UyxJQVBHeFMsaUJBUUh3WSxVQUxJOVksT0FNSjhaLElBVEd4WjtJQVVQO0tBVk9BO0tBWVEsSUFBQSxNQUFBLDRCQUxYd1MsT0FLRjs7VUFBQXZaOztXQUlJNndGLFNBaEJDOXBGLFNBWUwvRztpQkFJSTZ3RjtpQkFBQUE7U0FSRnR4RSxTQVFtQiw2QkFBakJzeEUsUUFSRnR4RSxRQUxVdlk7O2FBWU8ydkIsTUFDZms2RCxXQUQ0QmpmLE9BQzVCaWY7U0FSRnR4RSxTQU8rQyxXQVpyQ3ZZLEdBWU8ydkIsS0FBYWk3QyxNQVA5QnJ5RDs7T0FJRixVQUFBdmY7a0JBQUFBO09BQUFBOzs7O1VBVVVxUztTQUFBRiwwQkFBQUU7S0F0Qkx0TCxPQVNId1o7S0FlRixNQUFBLDRCQUZVcE87O0lBdEJMcEwsT0FTSHdaO1dBREFoQjtHQWdCUTtZQXdjVnBZLE1BcmNJSixHQUFHQztJQUNYLFNBRFFELE1BRUg7SUFHSCxJQURJd1MsSUFKRXhTLGlCQUtGd1osSUFMRXhaO0lBTU47S0FOTUE7S0FRUyxJQUFBLE1BQUEsNEJBSlh3UyxPQUlGOztVQUFBdlo7O1dBSUk2d0YsU0FaQTlwRixTQVFKL0c7aUJBSUk2d0Y7aUJBQUFBO1NBQVUsNkJBQVZBLFFBWkc3cEY7aUJBV1kydkIsTUFDZms2RCxXQUQ0QmpmLE9BQzVCaWYsV0FEc0MsV0FYbkM3cEYsR0FXWTJ2QixLQUFhaTdDO09BSGhDLFVBQUE1eEU7a0JBQUFBO09BQUFBOzs7O1VBUVVxUztTQUFBRiwwQkFBQUU7S0FoQk50TCxPQUtGd1o7S0FhRixNQUFBLDRCQUZVcE87O0lBaEJOcEwsT0FLRndaOztHQWFRO1lBa2JWclosS0EvYUdILEdBQUdDO0lBQUksT0FnYlZHLE1BaGJHSixtQkFBK0I2cUUsTUFBUSxPQUFBLFdBQXBDNXFFLEdBQTRCNHFFLE1BQWM7R0FBQztZQThhakQ4RCxVQTdhUTN1RSxHQUFHQztJQUFJLE9BK2FmRyxNQS9hUUosWUFBd0I0dkIsWUFBZSxPQUFBLFdBQXBDM3ZCLEdBQXFCMnZCLEtBQW9CO0dBQUM7WUFFbkRtNkQsZ0JBQWdCQyxPQUFNL3dGO0lBQzVCLElBRDRCNkwsTUFBQTdMO0lBQzVCO0tBQWMsSUFBVmd4RiwyQkFEa0JELE9BQU1sbEYsU0FBQUE7S0FFekIsS0FBQSw0QkFEQ21sRjtNQUdDLE9BQUEsNkJBSERBO0tBRXVCLElBSENyOEQsTUFHRCw0QkFIQzlvQjtLQUFBQSxNQUFBOG9COztHQUlHO1lBeVozQnF1QyxXQXRaU2o4RDtJQUNiLFNBRGFBO0tBQ1E7T0ExU25CdTNCLFNBMFMyQjtJQUFSLE9BUmZ3eUQsZ0JBT08vcEY7R0FFWTtZQW1ackJnOEQsT0FoWktoOEQsR0FBSSxPQTBhVCtULFNBMWFLL1QsYUFaSCtwRixnQkFZRy9wRixVQUFpRTtZQStZdEU2SixVQTdZUXFnRixlQUFjQyxnQkFBZW5xRjtJQUN6QyxJQUFhLE1BQUEsNEJBRDRCQSxxQkFDekM7O1NBQUEvRzs7TUFDeUMsSUFBQSxNQWxTdkM2d0UsWUFnU3VDOXBFLElBRXJCLHVCQUZxQkEsTUFDekMvRyxPQUFBQTtNQUNFO01BQUEsVUFERkE7aUJBQUFBO01BQUFBOzs7SUFJRTtLQURFbXhGO09Ba2FBcnFGO1NBdGFxQ0M7O2tCQUtmNHZCLEtBQUtpN0MsTUFBSzV4RTtVQUNoQyxXQU5RaXhGLGVBS2N0NkQ7VUFFdEIsV0FQc0J1NkQsZ0JBS0t0ZjtVQUUzQixPQUFBLDRCQUZnQzV4RTtTQUczQjtPQUpMbXhGLGFBSnFDcHFGO0lBVXpDLE1BQUE7R0FBNEI7WUFJeEJ5bkYsV0FBU2w1RSxVQUFNLE9BQU5BLEVBQU87R0FDcEIsU0FBSW01RSxlQUFhbDRELEdBQUV4dkI7SUFFRiwyQkFBNEMsV0FGMUNBLFNBQUZ3dkI7SUFDZixNQUFBO0dBQ3FGO1lBc2FuRnhMLFNBcGFTaGtCLEdBQUU0dkI7SUFBTSxPQXNhakJtM0QsZUF0YVMvbUYsR0FBRTR2QixLQUFGNXZCLEdBTFR5bkYsWUFDQUM7R0FJa0U7WUE4WWxFbGpFLFFBellNeGtCLEdBQUdDO0lBQ2IsT0FBWTthQTVVVmdOO3NCQTRVZXhGO2NBc1lickg7Z0JBdllNSjt5QkFFUzR2QixLQUFLaTdDO2lCQUFXLFVBQUEsV0FGdEI1cUUsR0FFTTJ2QixLQUFLaTdDO2lCQUFXLGFBQWtCLFdBRHBDcGpFO2dCQUNpRDtjQUFoRTthQUNLO0dBQUM7WUFxWUp2RixPQWxZS2xDLEdBQUdDO0lBQUksT0FtWVp1a0IsUUFuWUt4a0IsbUJBQWlDNnFFLE1BQVEsT0FBQSxXQUF0QzVxRSxHQUE4QjRxRSxNQUFjO0dBQUM7WUFxWXJEdG1ELFNBcFlPdmtCLEdBQUdDO0lBQUk7O1lBa1lkdWtCO2NBbFlPeGtCLFlBQStCNHZCLEtBQUtpN0MsTUFBUSxXQUFJLFdBQTdDNXFFLEdBQTRCMnZCLEtBQUtpN0MsTUFBMEI7R0FBRTtZQW1ZdkV0b0UsUUFsWU12QyxHQUFHQztJQUFJOztZQWlZYnVrQixRQWpZTXhrQixtQkFBc0M2cUUsTUFBUSxXQUFJLFdBQS9DNXFFLEdBQW1DNHFFLE1BQW9CO0dBQUU7WUFxWWxFdDlDLE9BbllLdnRCLEdBQUdDO0lBQ1osT0FtWUlGO2FBcFlLQzs7c0JBQ2U0dkIsS0FBS2k3QyxNQUFLcnlEO2NBQU8sT0FBRyxXQURoQ3ZZLEdBQ1kydkIsS0FBS2k3Qzt3QkFBaUMsNEJBQTVCcnlEO3dCQUFBQTthQUE0QztHQUFDO1lBaVkzRUosTUE5WElwWSxHQUFHQztJQUNYLE9BK1hJRjthQWhZSUM7OzZCQUN1QjZxRSxNQUFLcnlEO2NBQU8sT0FBRyxXQURuQ3ZZLEdBQ29CNHFFO3dCQUEyQiw0QkFBdEJyeUQ7d0JBQUFBO2FBQXNDO0dBQUM7WUFtWXZFbFksS0FoWUdOLEdBQUdDO0lBRVIsSUFERW9xRixRQTFTRm5yRixXQXlTS2MsV0FBQUEsT0FBQUE7SUFxWEhJO01BclhHSjtlQUlVNHZCLEtBQUtpN0MsTUFBUSxPQXFXMUIxakMsSUF4V0FrakQsT0FHYXo2RCxLQUFrQyxXQUp6QzN2QixHQUlPMnZCLEtBQUtpN0MsT0FBMkM7SUFBakUsT0FISXdmO0dBSUM7WUEwWERocUYsSUF2WEVMLEdBQUdDO0lBQUksT0F3WFRLLEtBeFhFTixtQkFBOEI2cUUsTUFBUSxPQUFBLFdBQW5DNXFFLEdBQTJCNHFFLE1BQWM7R0FBQztZQStWL0NyckUsS0E5VkdRLEdBQUksT0FzWFBLLElBdFhHTCxpQkFBSSxjQUFjO1lBeVhyQjZ0QixZQXZYVTd0QixHQUFHQztJQUVmLElBREVvcUYsUUFyVEZuckYsV0FvVFljLFdBQUFBLE9BQUFBO0lBMFdWSTtNQTFXVUo7ZUFJRzR2QixLQUFLaTdDO09BQ2QsWUFBQSxXQUxTNXFFLEdBSUEydkIsS0FBS2k3QzttQkFHVjtXQURIa0c7T0FBWSxPQXdWakI1cEMsSUE3VkFrakQsT0FHYXo2RCxLQUVSbWhEO01BQ0s7SUFIZCxPQUhJc1o7R0FPQztZQThXRDM4RCxXQTNXUzF0QixHQUFHQztJQUFJLE9BNFdoQjR0QixZQTVXUzd0QixtQkFBcUM2cUUsTUFBUSxPQUFBLFdBQTFDNXFFLEdBQWtDNHFFLE1BQWM7R0FBQztZQStXN0RsaEQsUUE3V00zcEIsR0FBR0M7SUFDYixPQXlXSTR0QjthQTFXTTd0QjtzQkFDYTR2QixLQUFLaTdDO2NBQVEsT0FBRyxXQUQxQjVxRSxHQUNVMnZCLEtBQUtpN0MsWUFBQUE7YUFBZ0Q7R0FBQztZQTJXekVqbkQsT0F4V0s1akIsR0FBR0M7SUFBSSxPQXlXWjBwQixRQXpXSzNwQixtQkFBaUM2cUUsTUFBUSxPQUFBLFdBQXRDNXFFLEdBQThCNHFFLE1BQWM7R0FBQztZQXVXckRvRSxZQXRXVWp2RSxHQUFHQztJQUFJLE9Bd1dqQjBwQixRQXhXVTNwQixZQUEwQjR2QixZQUFlLE9BQUEsV0FBdEMzdkIsR0FBdUIydkIsS0FBb0I7R0FBQztZQTBXekRzL0MsZUF4V2FsdkUsR0FBR0M7SUFDcEI7S0FBSXFxRixLQXpVRnByRixXQXdVZWMsV0FBQUEsT0FBQUE7S0FJYm9CLEtBNVVGbEMsV0F3VWVjLFdBQUFBLE9BQUFBO0lBc1ZiSTtNQXRWYUo7ZUFPQTR2QixLQUFLaTdDO09BQ2IsWUFBQSxXQVJXNXFFLEdBT0gydkIsS0FBS2k3Qzs7WUFFWmtHO1FBQVksT0FpVWxCNXBDLElBelVBbWpELElBTWExNkQsS0FFUG1oRDs7V0FDQ3daO09BQVksT0FnVW5CcGpELElBdFVBL2xDLElBR2F3dUIsS0FHTjI2RDtNQUFzQztJQUNqRCxXQVZJRCxJQUdBbHBGO0dBT0U7WUE0VkY0UyxjQXpWWWhVLEdBQUdDO0lBQUksT0EwVm5CaXZFO2FBMVZZbHZFLG1CQUF3QzZxRSxNQUFRLE9BQUEsV0FBN0M1cUUsR0FBcUM0cUUsTUFBYztHQUFDO1lBNFZuRXovQixjQTFWWXByQyxHQUFHQztJQUNuQixPQXVWSWl2RTthQXhWWWx2RTtzQkFDVTR2QixLQUFLaTdDO2NBQVEsT0FBRyxXQUR2QjVxRSxHQUNPMnZCLEtBQUtpN0MsWUFBQUEsWUFBQUE7YUFBd0Q7R0FBQztZQXdWcEYxOEMsYUFyVldudUIsR0FBR0M7SUFBSSxPQXNWbEJtckM7YUF0VldwckMsbUJBQXVDNnFFLE1BQVEsT0FBQSxXQUE1QzVxRSxHQUFvQzRxRSxNQUFjO0dBQUM7WUF1VmpFMmYsWUFyVlV4cUYsR0FBRXlxRixJQUFJcHZFO0lBQ3BCLE9BMFZJZ3NFO2FBM1ZVcm5GO2FBQUV5cUY7YUFBRnpxRjthQUFNcWI7c0JBTUh3dkQsa0JBQVksT0FBWkEsS0FBZ0I7c0JBQ1pqN0MsS0FBSTV2QixHQUFFcWI7Y0FDVCxJQUFWMEMsWUFBVSxXQURTMUM7Y0E2U3ZCOHJCLElBN1NxQm5uQyxHQUFKNHZCLEtBQ2I3UjtjQUNKLE9BRElBO2FBRUc7R0FBQztZQTRVUjJzRSxhQXpVVzFxRixHQUFFeXFGLElBQUlwdkU7SUFDckIsT0E2VUlnc0U7YUE5VVdybkY7YUFBRXlxRjthQUFGenFGO2FBQU1xYjtzQkFNSnd2RCxrQkFBWSxPQUFaQSxLQUFnQjtzQkFDWmo3QyxLQUFJNXZCLEdBQUVxYjtjQUNULElBQVYwQyxZQUFVLFdBRFMxQyxXQUFOdVU7Y0FnU2pCdVgsSUFoU3FCbm5DLEdBQUo0dkIsS0FDYjdSO2NBQ0osT0FESUE7YUFFRztHQUFDO1lBd1VSNHNFLGdCQXRoQkEzcUYsR0FBRTR2QjtJQUFOLElBb05JL1IsU0E0VEE0b0UsY0FoaEJBem1GLEdBQUU0dkIsS0FGRmliLFVBQ0FDO0lBc05ELEdBQUEsNEJBRENqdEIsU0FzUkFxUyxPQTFlQWx3QixHQUFFNHZCO0lBcU53QixPQUQxQi9SO0dBRUU7WUF3UkZxd0QsT0E5ZUFsdUUsR0FBRTR2QixLQTBOUzN2QjtJQUNULFlBQUEsV0FEU0EsR0FzVFh3bUYsY0FoaEJBem1GLEdBQUU0dkIsS0FGRmliLFVBQ0FDO2dCQTZOTSxPQThRTjVhLE9BMWVBbHdCLEdBQUU0dkI7UUE2TkNpN0M7SUFBUSxPQThRWDFqQyxJQTNlQW5uQyxHQUFFNHZCLEtBNk5DaTdDO0dBQTJCO1lBbVI5QitmLGtCQWhmQTVxRixHQUFFNHZCLEtBZ09vQjN2QjtJQUNmLElBQVA0cUUsT0FBTyxXQURlNXFFLEdBZ1R0QndtRixjQWhoQkF6bUYsR0FBRTR2QixLQUZGaWIsVUFDQUM7SUE0ZUEzRCxJQTNlQW5uQyxHQUFFNHZCLEtBaU9GaTdDO0lBQ0osT0FESUE7R0FFQTtZQTRRQTBELE9BelFLdnVFLEdBQUV5cUYsSUFBSXhxRixHQTBRWDJxRixrQkExUUs1cUYsR0FBRXlxRixJQUFJeHFGLElBQVksU0FBOEI7WUFFdkQ0cUYsUUFBU0MsZ0JBQWU5cUYsR0FBRTR2QixLQUFJbTdEO0lBQ2hDLE9BRFdEO2NBc1FQNWM7ZUF0UXNCbHVFO2VBQUU0dkI7d0JBR0wvcEI7Z0JBQ25CO2lCQUFXLE1BQUEsNEJBRFFBO2lCQUdqQjJNLElBRkksNEJBSnNCdTRFOzZCQU0xQnY0RSxZQUFBQTtlQUFXO2NBaVFiKzdEO2VBdlFzQnZ1RTtlQUFFNHZCOztnQkFRVixZQUFoQixPQVI4Qm03RDtvQkFVckI5eEY7Z0JBQUssT0FBQSw0QkFWZ0I4eEYsSUFVckI5eEY7ZUFBWTtHQUFBO1lBbVRuQm9FLEtBaFRLd0ksVUFBa0M3RixHQUFFNHZCO0lBQU0sR0FBMUMvcEIsU0FBS0MsTUFBTEQsUUFBQWtsRixLQUFLamxGLGNBQUxpbEY7SUFBMEM7U0FBZjVyRSxnQkFBakIyckUsaUJBQWlCM3JFOztTQUFqQjJyRTtJQUFnQyxPQWJqREQsUUFhaUJDLGdCQUF3QjlxRixHQUFFNHZCLEtBQXBDbTdEO0dBQTBFO1lBaVQvRTN0RixLQWhUS3lJLFVBQWtDN0YsR0FBRTR2QjtJQUFNLEdBQTFDL3BCLFNBQUtDLE1BQUxELFFBQUFrbEYsS0FBS2psRixjQUFMaWxGO0lBQTBDO1NBQWY1ckUsZ0JBQWpCMnJFLGlCQUFpQjNyRTs7U0FBakIyckU7SUFBOEQsT0FkL0VELFFBY2lCQyxnQkFBd0I5cUYsR0FBRTR2QixLQUFvQyw2QkFBeEVtN0Q7R0FBNkU7WUEyUGxGOWQsVUF6UFFqdEUsR0FBRzR2QixLQUFLaTdDO0lBQ3BCLE9Bc1BJMEQ7YUF2UFF2dUU7YUFBRzR2Qjs7Y0FDQyxZQUNKLFdBRlFpN0M7a0JBR1g3bkU7Y0FBSyxXQUhNNm5FLE1BR1g3bkU7YUFBZTtHQUFBO1lBdVBwQnlyRSxhQWxmQXp1RSxHQUFFNHZCO0lBQU4sWUFnaEJJNjJELGNBaGhCQXptRixHQUFFNHZCLEtBRkZpYixVQUNBQztnQkFpUU07OzBCQUVHbnBCLGFBQU8sT0F5T2hCd2xCLElBM2VBbm5DLEdBQUU0dkIsS0FrUU9qTztJQURhLE9BeU90QnVPLE9BMWVBbHdCLEdBQUU0dkI7R0FrUWlDO1lBaVBuQ3U5QyxXQW5mQW50RSxHQUFFNHZCO0lBQU4sWUFnaEJJNjJELGNBaGhCQXptRixHQUFFNHZCLEtBRkZpYixVQUNBQztnQkF3UU07UUFDSDluQztJQUFLLE9BQUxBO0dBQU07WUFHWGdvRjtJQUFlL0IsZ0JBQWdCbDlCLE1BQU1yeEIsVUFBVXV3RCxTQUFTQyxVQUFTaDVEO0lBQ25FLEdBRGlDNjVCO1NBR3hCcnVELElBSHdCcXVELFNBQzdCbTlCLFNBRUt4ckY7O1NBRkx3ckYsU0FHUSx5QkFKdURoM0Q7SUFNekQ7S0FBTmh2QixNQXhiRmhFLE9Ba2JlK3BGLG9CQUNiQyxTQURtQ3h1RDtLQU9uQ3l3RDtJQUNKOztNQVJtRWo1RDtlQVE1Q3pxQjtPQUNyQixJQUFJbW9CLE1BQU0sV0FUcUNxN0QsU0FRMUJ4akYsSUFFakJvakUsT0FBTyxXQVY2Q3FnQixVQVFuQ3pqRjtPQUdsQixPQThORDRTLElBbk9BblgsS0FHRTBzQjtrQkFGRnU3RCxlQUVFdjdELEtBRkZ1N0Q7aUJBeU5BaGtELElBMU5BamtDLEtBR0Uwc0IsS0FDQWk3QztNQUM4RDtRQUdsRTZGLE9BUEV5YTtXQU9GemE7NkJBQXdCLDJCQUF4QkEsTUFkcUNoMkM7eUJBTW5DeDNCO0dBUW1GO1lBaUJyRm11RSxTQUFVNFgsZ0JBQWdCbDlCLE1BQU1yeEIsVUFBUzdOO0lBQ3JDOztPQWhDSm0rRDtTQStCVS9CO1NBQWdCbDlCO1NBQU1yeEI7OztTQUFTN047O1NBR3pCMkM7S0FBSyx3QkFBZSwwQkFBcEJBOztRQURaeHZCO0lBQUssa0JBQUxBO0dBQytDO1lBR25Eb3JGLHlCQUEwQm5DLGdCQUFnQmw5QixNQUFNcnhCLFVBQVM3TjtJQUMzRCxPQXRDRW0rRDthQXFDMEIvQjthQUFnQmw5QjthQUFNcnhCOzs7YUFBUzdOO0dBQ2lCO1lBRzFFeWtELGtCQUFtQjJYLGdCQUFnQmw5QixNQUFNcnhCLFVBQVM3TjtJQUM5QyxZQVhKd2tELFNBVW1CNFgsZ0JBQWdCbDlCLE1BQU1yeEIsVUFBUzdOOzhCQUU5Q3RlLGNBQUssV0FBTEE7SUFFSixJQURlcWhCLGdCQUNYKzZDLGNBSnFDandDO0lBS3pDLE9BQUE7Ozs7O2FBRmU5SzthQUNYKzZDO0dBQ2dFO1lBR3BFNEcsYUFBYzBYLGdCQUFnQmw5QixNQUFNcnhCLFVBQVM3TjtJQUN6QyxZQVRKeWtELGtCQVFjMlgsZ0JBQWdCbDlCLE1BQU1yeEIsVUFBUzdOOzJCQUVuQ3RlLGNBQUssT0FBTEE7UUFDRzFKO0lBQUssT0FBQSwyQkFBTEE7R0FBa0I7WUFHL0I0c0UsZUFBZ0J3WCxnQkFBZ0JDLFFBQU14dUQsVUFBU3hJO0lBQ2pELElBdkNnRWc1RCw2QkFBVEQ7T0FzQ3JCL0I7U0FuQ3pCeHJGLElBbUN5QndyRixXQXJDOUJuOUIsT0FFS3J1RDs7U0FGTHF1RCxPQUdRLHlCQWtDcUM3NUI7SUFoQ3ZDLElBQU5odkIsTUF6Y0ZoRSxPQXllZ0IrcEYsb0JBckNkbDlCLE9BcUNvQ3J4QjtJQS9CeEM7O01BK0JpRHhJO2VBL0IxQnpxQjtPQUNyQixJQUFJbW9CLE1BQU0sV0FSMkNxN0QsU0FPaEN4akYsSUFFakJvakUsT0FBTyxXQVRtRHFnQixVQU96Q3pqRjtPQUdyQixPQTJNRXdsRSxVQS9NQS9wRSxLQUVFMHNCLEtBQ0FpN0M7TUFDb0I7SUFIMUIsT0FESTNuRTtHQWlDOEU7WUFvTjlFOHVFLFNBak5PaHlFO0lBQUksT0F3TFhEO2FBeExPQzs7c0JBQWtCNHZCLEtBQUtpN0MsTUFBS3ZtRSxNQUFRLGVBQWxCc3JCLEtBQUtpN0MsT0FBS3ZtRSxNQUEyQjtHQUFZO1lBRTVFd0YsVUFBVTZnRSxhQUFZMGdCLGNBQWFyckY7SUFDckM7S0FBQSxNQThNSWd5RSxTQS9NaUNoeUU7S0FHZjtPQUFBOzs7O1VBQUEsSUFBY3N2RSxhQUFSbkY7VUFBa0IsT0FBQSxXQUhUbnFFLFNBR1RtcUUsSUFBUW1GO1NBQW1DO0tBQ3ZELE1BQUEsNkJBSkozRSxhQUFZMGdCO0lBQ3hCLE9BQUEsV0FHRztHQUFvRDtZQUdyRDM2RSxVQUFXZ3FCLFVBQVNnZ0QsV0FBVTRRLFdBQVV0Z0Y7SUFDMUM7S0FBeUIsTUFBQSw2QkFESDB2RSxXQUFVNFE7S0FDNUI1N0QsUUFBUSxrQ0FEOEIxa0I7S0FFcEM7T0F2Q0pxbUUsZ0JBdUNtQyx5QkFEakMzaEQsU0FEU2dMLFVBQ1RoTDs4QkFFRW5oQixjQUFLLE9BQUxBO0lBSTJCO0tBSGhCaWhCO0tBR2dCO09BQUE7O3VCO3VCO0tBQTNCMGtELGNBQWMsa0NBUHNCbHBFO0tBUXBDbXBFO0lBQ0o7O01BUkV6a0Q7TUFNRXdrRDs7T0FFZ0M7UUFBY0U7UUFBUjlFO29CQUNyQyxXQVZNNTBDLGFBSUlsTCxHQUsyQjgvQzs7V0FEdEM2RTtTQUtLLE9BQUE7b0VBSnlDQztRQUQ5Q0Q7Ozs7OztNQU0yQjtJQUMvQixNQUFBO0dBQVk7WUFHWnZxRSxlQUVHMmhGLFdBQ0FqTztJQUd3QixVQUFBLDhCQUp4QmlPLFdBQ0FqTztJQUd3QixPQUFBO0dBQStDO1lBbUx4RTVNLEtBaExHMXdFO0lBQUksT0FvSlBELEtBcEpHQyxlQUE2QjR2QixZQUFZcFgsS0FBTyxXQUFuQm9YLEtBQVlwWCxLQUFpQjtHQUFDO1lBaUw5RHF5RCxLQWhMRzdxRTtJQUFJLE9BbUpQRCxLQW5KR0Msc0JBQXlCNnFFLE1BQUt2bUUsTUFBUSxXQUFidW1FLE1BQUt2bUUsTUFBb0I7R0FBWTtZQWNuRW9tQjtJQUFPdStELGdCQUFnQmw5QixNQUFNcnhCLFVBQVV1d0QsU0FBU0MsVUFBVXZ6RSxTQUFRdWE7SUFDMUQsSUExWE4xSCxTQXZLRnRyQixPQWdpQk8rcEYsZ0JBQWdCbDlCLE1BQU1yeEI7SUFYYjs7TUFXa0R4STtlQVg3Q3M1RDtPQUNyQjtRQS9XSTU3RCxNQStXTSxXQVU2QnE3RCxTQVhsQk87UUFFakIzZ0IsT0FBTyxXQVNxQ3FnQixVQVgzQk07UUE5V3ZCLFFBZ2hCSS9FLGNBaGhCQWo4RCxRQUFFb0YsS0FGRmliLFVBQ0FDOztZQXFYTzJnRCxnQkFITHZlLFNBR1ksV0FLMEN2MUQsU0FMakQ4ekUsS0FKTDVnQjs7WUFDQXFDLFNBREFyQztPQU1KLE9BcUhFMWpDLElBM2VBM2MsUUFBRW9GLEtBaVhBczlDO01BS2lCO0lBS3ZCLE9BM1hJMWlEO0dBNFhEO1lBR0RraEUsZ0JBQWlCekMsZ0JBQWdCbDlCLE1BQU1yeEIsVUFBVXV3RCxTQUFRLzREO0lBQzNELE9BckhFODREO2FBb0hpQi9CO2FBQWdCbDlCO2FBQU1yeEI7YUFBVXV3RDsyQjthQUFRLzREO0dBQ2dCO1lBR3pFeTVEO0lBQTBCMUMsZ0JBQWdCbDlCLE1BQU1yeEIsVUFBVXV3RCxTQUFRLzREO0lBQzlEO2FBTEp3NUQsZ0JBSTBCekMsZ0JBQWdCbDlCLE1BQU1yeEIsVUFBVXV3RCxTQUFRLzREOztLQUlsRTtNQURnQncrQztNQUNaL0YsY0FKNENqd0M7TUFRM0M7MEJBQVUsNkJBSlhpd0MsYUFEWStGO01BR2QsTUFBQTtLQUFBLE9BQUE7O1FBSkUxd0U7SUFBSyxXQUFMQTtHQU0yQztZQUcvQzRyRixvQkFBcUIzQyxnQkFBZ0JsOUIsTUFBTXJ4QixVQUFVdXdELFNBQVEvNEQ7SUFDL0M7O09BWmR5NUQseUJBV3FCMUMsZ0JBQWdCbDlCLE1BQU1yeEIsVUFBVXV3RCxTQUFRLzREO0lBQy9DLE9BQUE7R0FBd0U7WUFJcEYyNUQsVUFBVTdyRixHQUFHNHZCLEtBQUszdkIsR0FBRTZyQztJQUNoQixZQUFBLFdBRGM3ckMsR0FBTDJ2QixLQUFPa2M7Z0JBRVo7UUFDSHY5QjtJQUFLLE9BcUZWNDRCLElBeEZVbm5DLEdBQUc0dkIsS0FHUnJoQjtHQUF1QjtZQWtJNUJ3YyxNQXhoQkErZ0UsUUFBQUMsU0F3WmdCOXJGO0lBQ2xCLE9BQU8sNkJBelpMNnJGLFdBQUFDO0tBMFpHO0lBRUgsSUFERTFCLFFBbGtCSm5yRixXQXVLRTRzRixnQkFBQUEsWUFBQUE7SUFsTUYvQztNQWtNRStDOztPQW1hQSxPQXJtQkYvQztnQkFrTUVnRDs7aUJBdWZBM3JGO21CQXZmQTByRjs0QkFBRWw4RCxLQW9hZ0MwWDtvQkFwYXRDOzZCQWdoQkltL0MsY0FoaEJBc0YsU0FBRW44RCxLQUZGaWIsVUFDQUM7O3FCQXVhc0MsT0FuQnRDK2dELFVBUUV4QixPQTNaQXo2RCxLQXdaYzN2QixrQkFZa0JxbkM7d0JBR3ZCQztvQkFBaUMsT0FwQjVDc2tEOzZCQVFFeEIsT0EzWkF6NkQsS0F3WmMzdkIsc0JBWWtCcW5DLE1BR3ZCQzttQkFBc0Q7aUJBQzlDLE9BK0VuQm5uQzswQkF2ZkEyckY7bUNBQUVuOEQsS0F3YWlDMlg7MkJBQy9CLE9BdUdKay9DLGNBaGhCQXFGLFFBQUVsOEQsS0FGRmliLFVBQ0FDOztxQ0FvWkErZ0QsVUFRRXhCLE9BM1pBejZELEtBd1pjM3ZCLGtCQWdCbUJzbkM7MEJBR2pCO2dCQUNXO01BQUM7SUFWaEMsT0FQSThpRDtHQWtCQztZQTRHSDJCLFdBekdVcHdELEtBaGJWRSxLQWdib0I3N0I7SUFDeEIsT0FzRUlHO2FBdkVVdzdCO3NCQWhiUmhNLEtBaWJrQmk3QztjQUN0QjtlQUFJb2hCLGFBOEZGeEYsY0FoaEJBM3FELEtBQUVsTSxLQUZGaWIsVUFDQUM7ZUFvYkVvaEQ7aUJBcm5CSm5EO21CQWtNRWp0RDs7b0JBbWIyQyxPQUE3QyxXQUhzQjc3QixHQWhibEIydkIsS0FpYmtCaTdDLE1BQ2xCb2hCO21CQUM2RDtjQUNqRSxLQURJQyxRQUVRLE9BcURWaDhELE9BMWVBNEwsS0FBRWxNO2tCQXNiS3M5QyxTQUhMZ2Y7Y0FJRixLQUxFRCxZQU1TLE9BbURYOWtELElBM2VBckwsS0FBRWxNLEtBc2JLczlDO2NBR29CO2VBQW5CaWYsV0FQTkY7ZUFPeUIsVUFBQSw2QkFBbkJFLFVBSERqZjsyQkFxRFAvbEMsSUEzZUFyTCxLQUFFbE0sS0FzYktzOUM7YUFHdUU7R0FBQztZQXFHL0VyRSxnQkFsR2M3b0UsR0FBR0M7SUFFbkI7S0FERW1zRjtPQWlFQXJzRjtTQWxFY0M7O2tCQUVTNHZCLEtBQUtpN0MsTUFBS3RpRDtVQUFNLE9BQUcsV0FGekJ0b0IsR0FFTTJ2QixLQUFLaTdDLFFBQUt0aUQsU0FBVnFILEtBQVVySDtTQUE0QztJQUUxRCxPQUFBOzJCQUhuQjZqRSxvQkFHd0J4OEQsS0FBTyxPQTBDL0JNLE9BOUNjbHdCLEdBSVU0dkIsS0FBbUI7R0FBQztZQTZGNUNnNUMsZUExRmE1b0UsR0FBR0M7SUFBSSxPQTJGcEI0b0U7YUEzRmE3b0UsbUJBQXlDNnFFLE1BQVEsT0FBQSxXQUE5QzVxRSxHQUFzQzRxRSxNQUFjO0dBQUM7WUF5RnJFd2hCLG9CQXhGa0Jyc0YsR0FBR0M7SUFBSSxPQTBGekI0b0U7YUExRmtCN29FLFlBQWtDNHZCLFlBQWUsT0FBQSxXQUE5QzN2QixHQUErQjJ2QixLQUFvQjtHQUFDO1lBOEZ6RTA4RCxvQkE1RmtCdHNGLEdBQUdDO0lBQ1A7S0FBZHNzRjtPQXVEQXhzRjtTQXhEa0JDOztrQkFDcUI0dkIsS0FBS2k3QyxNQUFLdGlEO1VBQU0sZUFBaEJxSCxLQUFzQixXQUR4QzN2QixHQUNrQjJ2QixLQUFLaTdDLFFBQUt0aUQ7U0FBK0I7SUFDM0QsT0FBQTs7YUFEckJna0U7O2NBQ3FCLElBQVcxdUUsbUJBQUwrUjtjQUM3QixLQURrQy9SLFFBRXhCLE9BZ0NScVMsT0FwQ2tCbHdCLEdBRVM0dkI7a0JBR3RCaTdDLE9BSDJCaHREO2NBR25CLE9BZ0Nic3BCLElBckNrQm5uQyxHQUVTNHZCLEtBR3RCaTdDO2FBQXlCO0dBQUE7WUFzRjlCMmhCLG1CQW5GaUJ4c0YsR0FBR0M7SUFBSSxPQW9GeEJxc0Y7YUFwRmlCdHNGLG1CQUE2QzZxRSxNQUFRLE9BQUEsV0FBbEQ1cUUsR0FBMEM0cUUsTUFBYztHQUFDO1lBa0Y3RWdlLGFBaEZXN29GLEdBQUdDO0lBdHBCaEI2b0Ysd0JBc3BCYTlvRjtJQUVJLE9BcHBCakIrb0Y7YUFrcEJhL29GOztjQUVlO2NBQXNCLE9BQUE7O3VCQUZyQ0E7cUNBQ2YsT0FBQSxxQkFEa0JDO2FBRTJEO0dBQUM7WUE2RTFFMHFDLFlBMUVVM3FDLEdBQUdDO0lBQUksT0EyRWpCNG9GLGFBM0VVN29GLG1CQUFzQzZxRSxNQUFRLE9BQUEsV0FBM0M1cUUsR0FBbUM0cUUsTUFBYztHQUFDO1lBK0UvRDRoQixRQTdFSW4yRixPQWhjQzRQLEtBQUFsRztJQWljVCxVQWpjU2tHLFdBQUFsRzs7Y0FrY007ZUFwckJiaU47d0JBb3JCa0J4RjtnQkEzcEJsQnNoRjtrQkF5Tk8vb0Y7O21CQW9jTCxPQTRCQUk7NEJBaGVLOEY7cUNBdkJIMHBCLEtBMmRvQmk3Qzs2QkEzZDFCLFlBZ2hCSTRiLGNBemZLem1GLEdBdkJINHZCLEtBRkZpYixVQUNBQzt5Q0E4ZFksT0FBQSxXQUpJcmpDOzZCQUtTOzhCQUFoQnlsRTs4QkFBZ0IsVUFBQSxXQVByQjUyRSxPQUlrQnUwRSxNQUdicUM7MENBQXdDLFdBTGpDemxFOzRCQUsrQztrQkFBQztnQkFKbEU7ZUFLSTs7R0FBQzs7UUEyRkhpekI7YUFJQXdrQixTQUFRK3BDLGdCQUFnQmw5QjtLQUFVLE9BcnVCcEM3c0QsT0FxdUJVK3BGLGdCQUFnQmw5QixNQUp4QnJ4QjtJQUkyRTthQUMzRTY4QyxXQUFVMFIsZ0JBQWdCbDlCLE1BQUsvb0Q7S0FBSSxPQXJSckNxdUUsU0FxUlk0WCxnQkFBZ0JsOUIsTUFMMUJyeEIsVUFLK0IxM0I7SUFBOEM7YUFFN0UwcEYsMkJBQTBCekQsZ0JBQWdCbDlCLE1BQUsvb0Q7S0FDakQsT0FsUkFvb0YseUJBaVI0Qm5DLGdCQUFnQmw5QixNQVAxQ3J4QixVQU8rQzEzQjtJQUNTO2FBR3hEdzBFLG9CQUFtQnlSLGdCQUFnQmw5QixNQUFLL29EO0tBQzFDLE9BbFJBc3VFLGtCQWlScUIyWCxnQkFBZ0JsOUIsTUFYbkNyeEIsVUFXd0MxM0I7SUFDUzthQUdqRHkwRSxlQUFjd1IsZ0JBQWdCbDlCLE1BQUsvb0Q7S0FDckMsT0E5UUF1dUUsYUE2UWdCMFgsZ0JBQWdCbDlCLE1BZjlCcnhCLFVBZW1DMTNCO0lBQ1M7YUFHNUNzckIsWUFBVW9zRCxXQUFVNFEsV0FBVXRnRjtLQUFPLE9BOVB2QzBGLFVBMk9FZ3FCLFVBbUJVZ2dELFdBQVU0USxXQUFVdGdGO0lBQW1EO2FBRWpGMHNFLGlCQUFnQnVSLGdCQUFnQmw5QixNQUFLL29EO0tBQ3ZDLE9BOVFBeXVFLGVBNlFrQndYLGdCQUFnQmw5QixNQXJCaENyeEIsVUFxQnFDMTNCO0lBQ1M7YUFHOUMycEYsZ0JBQWUxRCxnQkFBZ0JsOUIsTUFBTWsvQixTQUFTQyxVQUFTbG9GO0tBQ3pELE9BelVBZ29GO2NBd1VpQi9CLGdCQUFnQmw5QixNQXpCL0JyeEIsVUF5QnFDdXdELFNBQVNDLFVBQVNsb0Y7SUFDUzthQUdoRTRwRixrQkFBaUIzRCxnQkFBZ0JsOUIsTUFBTWsvQixTQUFRam9GO0tBQ2pELE9Bek5BMG9GLGdCQXdObUJ6QyxnQkFBZ0JsOUIsTUE3QmpDcnhCLFVBNkJ1Q3V3RCxTQUFRam9GO0lBQ1M7YUFHeEQ2cEYsMkJBQTBCNUQsZ0JBQWdCbDlCLE1BQU1rL0IsU0FBUWpvRjtLQUMxRCxPQXpOQTJvRjtjQXdONEIxQyxnQkFBZ0JsOUIsTUFqQzFDcnhCLFVBaUNnRHV3RCxTQUFRam9GO0lBQ1M7YUFHakU4cEYsc0JBQXFCN0QsZ0JBQWdCbDlCLE1BQU1rL0IsU0FBUWpvRjtLQUNyRCxPQWxOQTRvRixvQkFpTnVCM0MsZ0JBQWdCbDlCLE1BckNyQ3J4QixVQXFDMkN1d0QsU0FBUWpvRjtJQUNTO2FBRzVEeXNCLFFBQU93NUQsZ0JBQWdCbDlCLE1BQU1rL0IsU0FBU0MsVUFBVXZ6RSxTQUFRM1U7S0FDMUQsT0EzT0EwbkI7Y0EwT1N1K0QsZ0JBQWdCbDlCLE1BekN2QnJ4QixVQXlDNkJ1d0QsU0FBU0MsVUFBVXZ6RSxTQUFRM1U7SUFDUztJQTNDakU7WUFvQkFzckI7WUFmQTR3QjtZQUNBcTRCO1lBRUFtVjtZQUlBbFY7WUFJQUM7WUFNQUM7WUFJQWlWO1lBSUFDO1lBSUFDO1lBSUFDO1lBSUFyOUQ7O0dBekRVO0lBa0VWaUw7dUJBQUFBO0lBM0RKcE07SUFHRTR3QjtJQUFBcTRCO0lBQUFtVjtJQUFBbFY7SUFBQUM7SUFBQUM7SUFBQWlWO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFyOUQ7WUE2RUVreEQsV0FBUzNnRixHQUFJLE9BQUpBLEtBQWM7R0FQWixrQkFPWDJnRjtZQUdGeGhDLFNBQVE4cEMsZ0JBQWdCbDlCLE1BQUt2eUM7SUFDL0IsT0E1eUJFdGEsT0EyeUJRK3BGLGdCQUFnQmw5QixNQUNULDZCQURjdnlDO0dBQzhCO1lBRzNEMmhFLFdBQVU4TixnQkFBZ0JsOUIsTUFBS3Z5QyxHQUFFeFc7SUFDbkMsT0EvVkVxdUUsU0E4VlU0WCxnQkFBZ0JsOUIsTUFDVCw2QkFEY3Z5QyxJQUFFeFc7R0FDMkI7WUFHNUQrcEYsMkJBQTBCOUQsZ0JBQWdCbDlCLE1BQUt2eUMsR0FBRXhXO0lBQ25ELE9BN1ZFb29GO2FBNFYwQm5DLGdCQUFnQmw5QixNQUNULDZCQURjdnlDLElBQUV4VztHQUMyQjtZQUc1RW80RSxvQkFBbUI2TixnQkFBZ0JsOUIsTUFBS3Z5QyxHQUFFeFc7SUFDNUMsT0E3VkVzdUU7YUE0Vm1CMlgsZ0JBQWdCbDlCLE1BQ1QsNkJBRGN2eUMsSUFBRXhXO0dBQzJCO1lBR3JFcTRFLGVBQWM0TixnQkFBZ0JsOUIsTUFBS3Z5QyxHQUFFeFc7SUFDdkMsT0F6VkV1dUU7YUF3VmMwWCxnQkFBZ0JsOUIsTUFDVCw2QkFEY3Z5QyxJQUFFeFc7R0FDMkI7WUFHaEVzNEUsaUJBQWdCMk4sZ0JBQWdCbDlCLE1BQUt2eUMsR0FBRXhXO0lBQ3pDLE9BdlZFeXVFO2FBc1ZnQndYLGdCQUFnQmw5QixNQUNULDZCQURjdnlDLElBQUV4VztHQUMyQjtZQUdsRWdxRixnQkFBZS9ELGdCQUFnQmw5QixNQUFLdnlDLEdBQUd5eEUsU0FBU0MsVUFBU2xvRjtJQUMzRCxPQWxaRWdvRjthQWlaZS9CO2FBQWdCbDlCO2FBQ1QsNkJBRGN2eUM7YUFBR3l4RTthQUFTQzthQUFTbG9GO0dBQzJCO1lBR3BGaXFGLGtCQUFpQmhFLGdCQUFnQmw5QixNQUFLdnlDLEdBQUd5eEUsU0FBUWpvRjtJQUNuRCxPQWxTRTBvRjthQWlTaUJ6QzthQUFnQmw5QjthQUNULDZCQURjdnlDO2FBQUd5eEU7YUFBUWpvRjtHQUMyQjtZQUc1RWtxRiwyQkFBMEJqRSxnQkFBZ0JsOUIsTUFBS3Z5QyxHQUFHeXhFLFNBQVFqb0Y7SUFDNUQsT0FsU0Uyb0Y7YUFpUzBCMUM7YUFBZ0JsOUI7YUFDVCw2QkFEY3Z5QzthQUFHeXhFO2FBQVFqb0Y7R0FDMkI7WUFHckZtcUYsc0JBQXFCbEUsZ0JBQWdCbDlCLE1BQUt2eUMsR0FBR3l4RSxTQUFRam9GO0lBQ3ZELE9BM1JFNG9GO2FBMFJxQjNDO2FBQWdCbDlCO2FBQ1QsNkJBRGN2eUM7YUFBR3l4RTthQUFRam9GO0dBQzJCO1lBR2hGb3FGLFFBQU9uRSxnQkFBZ0JsOUIsTUFBS3Z5QyxHQUFHeXhFLFNBQVNDLFVBQVV2ekUsU0FBUTNVO0lBQzVELE9BcFRFMG5CO2FBbVRPdStEO2FBQWdCbDlCO2FBQ1QsNkJBRGN2eUM7YUFBR3l4RTthQUFTQzthQUFVdnpFO2FBQVEzVTtHQUMyQjtZQUdyRnFxRixXQUFXcnRGLEdBQUksb0NBQUpBLE1BQThCO2lCQUV4QixXQUVsQjtZQThCQ3lrRSxZQUE4QjRZO0ksZ0JBQStCbEcsV0FBVW4zRSxHQUN6RSxPQTNZRThKLFVBMFk4QnV6RSxNQUErQmxHLFdBQVVuM0UsR0FDeEM7O1lBRy9CMmtFLFlBQThCMFk7SSxnQkFBK0IxQyxXQUFVM3ZFO0tBQ3pFLFVBRGdDcXlFO0tBQ2hDLE9BeFlFM3NFO2NBd1lrQixpQ0FEWTJzRSxNQUFBQSxNQUFBQTs7Y0FBK0IxQztjQUFVM3ZFLE1BQ0U7O1lBR3pFNDVELGlCQUFtQ3lZO0ksZ0JBQW9DQyxXQUN6RSxPQTFYRTF6RSxlQXlYbUN5ekUsTUFBb0NDLFdBQ2hDOztZQUd2Q3hZLGlCQUFnQzBZLFNBQVFwOEUsSUFBR0MsSUFBSyxPQTFMOUNvckYsUUEwTDhCalAsU0FBUXA4RSxJQUFHQztHQUF3Qjs7OztPQXY3Qm5FZ0k7T0FEQTR3QjtPQWtpQkFud0I7T0E0VEFxMUM7T0FJQWc4QjtPQUlBNFI7T0FJQTNSO09BSUFDO09BSUFDO09BSUEwUjtPQUlBQztPQUlBQztPQUlBQztPQUlBQztPQXJJRXppQjtPQS9EQXpmO09BQ0ExckQ7T0FxQkFPO09BVEE0dUU7T0FDQXh1RTtPQUNBQztPQUVBb2tCO09BREF0aUI7T0FHQXFpQjtPQURBaGlCO09BR0FnckI7T0FEQW5WO09BR0F0VztPQUNBaVM7T0FaQXNHO09BVkE2VjtPQUpBOHJDO09BQ0FDO09BSUE5MEI7T0FDQWhYO09BQ0E2NkM7T0FDQWtEO09BQ0FLO09BQ0FxYztPQWlCQXZxRjtPQUNBQztPQUNBb3RCO09BQ0FHO09BQ0FvaEQ7T0FDQXJyRDtPQUNBK0Y7T0FDQTNWO09BQ0FrN0Q7T0FDQS9nRDtPQUNBaWQ7T0FDQW8vQztPQUNBRTtPQUNBMXhFO09BQ0FnTDtPQUNBeWlFO09BQ0FNO09BQ0FNO09BQ0FUO09BQ0FNO09BQ0FNO09BQ0FtRDtPQUVBNS9EO09BQ0FpaEU7T0FDQXRiO09BQ0E3RjtPQUNBd2hCO09BQ0F6akI7T0FDQUM7T0FDQWwrQjtPQUNBaytDO09BQ0EyRDtPQUNBRjtPQUVBRztPQUFBQTtPQWJBemE7T0FjQTMwRTtPQUNBRDtPQXJEQTZ2RTtPQUNBd0I7T0FDQXRCO09BNkxGa2dCO09BM01FeGpGOzs7UUE0RUp5a0I7UUF6T0V4a0I7UUF5QkFGO1FBMlFFOHdCO1FBdklBN3dCO1FBK0VGcTFDO1FBQUFxNEI7UUFBQW1WO1FBQUFsVjtRQUFBQztRQUFBQztRQUFBaVY7UUFBQUM7UUFBQUM7UUFBQUM7UUFBQXI5RDtRQWJFazdDO1FBL0RBemY7UUFDQTFyRDtRQXFCQU87UUFUQTR1RTtRQUNBeHVFO1FBQ0FDO1FBRUFva0I7UUFEQXRpQjtRQUdBcWlCO1FBREFoaUI7UUFHQWdyQjtRQURBblY7UUFHQXRXO1FBQ0FpUztRQVpBc0c7UUFWQTZWO1FBSkE4ckM7UUFDQUM7UUFJQTkwQjtRQUNBaFg7UUFDQTY2QztRQUNBa0Q7UUFDQUs7UUFDQXFjO1FBaUJBdnFGO1FBQ0FDO1FBQ0FvdEI7UUFDQUc7UUFDQW9oRDtRQUNBcnJEO1FBQ0ErRjtRQUNBM1Y7UUFDQWs3RDtRQUNBL2dEO1FBQ0FpZDtRQUNBby9DO1FBQ0FFO1FBQ0ExeEU7UUFDQWdMO1FBQ0F5aUU7UUFDQU07UUFDQU07UUFDQVQ7UUFDQU07UUFDQU07UUFDQW1EO1FBRUE1L0Q7UUFDQWloRTtRQUNBdGI7UUFDQTdGO1FBQ0F3aEI7UUFDQXpqQjtRQUNBQztRQUNBbCtCO1FBQ0FrK0M7UUFDQTJEO1FBQ0FGO1FBRUFHO1FBQUFBO1FBYkF6YTtRQWNBMzBFO1FBQ0FEO1FBckRBNnZFO1FBQ0F3QjtRQUNBdEI7O09BK05GMUk7T0FJQUU7T0FJQUM7T0FJQUU7Ozs7RTs7Ozs7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7O0lDMzdCQXVvQjtJQVVFM3lEO0lBUkY0eUQ7SUFDQXJnRjtJQVFFaStDO0lBQ0FwcEQ7SUFDQXVZOzs7WUFDQXRHLFNBQVMvVCxHQUFJLE9BQUEsNkJBQUpBLEdBQXNCO1lBRS9CK1ksU0FBUy9ZLEdBQUdDO0lBQ2QsT0FBWTthQWRaZ047c0JBY2lCeEY7Y0FDZjs7Z0JBRlN6SDt5QkFFbUI2WTtpQkFDcEIsSUFFSjJqQixJQUZJLFdBSEl2OEIsR0FFZ0I0WTt3QkFHeEIyakIsSUFBZSxXQUpKLzBCLEdBSVgrMEI7Z0JBQXlCO2NBSDdCO2FBSUk7R0FBQztZQUdMeGpCLEtBQUtoWixHQUFHQztJQUFJLE9BVFo4WSxTQVNLL1ksWUFBMEJvRCxHQUFLLE9BQUcsV0FBL0JuRCxHQUF1Qm1ELFNBQUFBLE9BQWlDO0dBQUM7WUFDakUrc0IsSUFBSW53QixHQUFFd3ZCLEdBQUksT0FBQSw2QkFBTnh2QixHQUFFd3ZCLE1BQWlDO1lBRXZDKzlELFdBQVd2dEYsR0FBRXd2QjtJQUNmLE9BQUcsV0FoQkRuVixLQWVXcmEsR0FBRXd2QjtjQUVWO2VBRUgsNkJBSld4dkIsR0FBRXd2QjtHQUtBO1lBR2JnK0QsZUFBZXh0RixHQUFFd3ZCO0lBQW9CLFVBUnJDKzlELFdBUWV2dEYsR0FBRXd2QjtJQUFvQixPQUFBO0dBQWdCOztJQUNyRFU7OztZQUVBdTlELGNBQWN6dEYsR0FBRXd2QjtJQUNsQixHQUFHLFdBM0JEblYsS0EwQmNyYSxHQUFFd3ZCLElBR2hCLFdBTEFVLFFBRWNsd0IsR0FBRXd2QixJQUdoQjtJQUV5QyxVQUFBLDZCQUwzQnh2QjtJQUsyQixPQUFBLDREQUx6Qnd2QjtHQUtnRDtZQUdoRWsrRCxrQkFBa0IxdEYsR0FBRXd2QjtJQUFvQixVQVJ4Q2krRCxjQVFrQnp0RixHQUFFd3ZCO0lBQW9CLE9BQUE7R0FBbUI7WUFDM0R6dkIsS0FBS0MsR0FBR04sTUFBTU87SUFBSSxPQUF3Qjs7YUFBckNEO2FBQUdOO3NCQUF3Q2t3QixZQUFhcFgsS0FBTyxPQUFBLFdBQXREdlksR0FBK0N1WSxLQUFib1gsS0FBNkI7R0FBQztZQUM5RXp2QixLQUFLSCxHQUFHQyxHQUFJLE9BQUEsNkJBQVBELEdBQUdDLEdBQTBCO1lBQ2xDbVksTUFBTXBZLEdBQUdDLEdBQUksT0FBQSw4QkFGYkYsTUFFTUMsR0FBR0MsR0FBOEI7WUFDdkNvWSxJQUFJbUIsR0FBRXhaLEdBQUdDLEdBQUksT0FBQSw4QkFIYkYsTUFHSXlaLEdBQUV4WixHQUFHQyxHQUE4QjtZQUN2QzJZLFFBQVE1WSxHQUFHM0o7SUFBVSxPQUFBLDhCQUpyQjBKLE1BSVFDLEdBQUczSjtHQUE0QztZQUN2RHlpQixRQUFROVksR0FBRzNKO0lBQVUsT0FBQSw4QkFMckIwSixNQUtRQyxHQUFHM0o7R0FBNEM7WUFDdkRraUIsWUFBWXZZLEdBQUdOLE1BQU1PO0lBQUksT0FBQSw4QkFOekJGLE1BTWVMLE1BQU1PLEdBQVREO0dBQW1EO1lBQy9EMFksV0FBVzFZLEdBQUdOLE1BQU1PO0lBQUksd0NBUHhCRixNQU9jTCxNQUFNTztJQUFJLHFCLDRCQUFiRDtHQUFrRDs7SUFDN0RGOzs7OztZQTJHQWdLLFVBekdVNmpGLFdBQVUzdEY7SUFDdEI7S0FBd0IsTUFBQSxXQUh0QkYsU0FFb0JFO0tBQ0U7S0FBZ0MsTUFBQSxzQkFBQSxXQWpEdEQwNkIsVUFnRG9CMTZCO0lBQ0MsT0FBQSw2QkFEWDJ0RjtHQUNpRTtZQUczRTEwRSxTQUFTalo7SUFDWDtLQUFJYixNQUFNLFdBbkRSMkMsUUFrRFM5QjtLQUVQcXdDLFlBQVksNEJBRFpseEM7SUFFaUIsT0FqQm5CWTthQWNTQzs7c0JBR2V3WSxLQUFJb1g7Y0FDNUIsU0FEd0JwWDtlQUVuQixPQUFBLDJCQUpIclosS0FFMEJ5d0I7Y0FEMUJ5Z0IsV0FLUyw0QkFMVEE7d0JBQUFBO2NBTUEseUJBTHNCNzNCLHFCQUFJb1g7Y0FLMUIsT0FMc0JwWDthQU1sQjtHQUFDO1lBR1B0VyxPQUFPbEMsR0FBR0M7SUFBSSxPQUFxQjs7YUFBNUJEO3NCQUFrQzR2QixZQUFnQixPQUFBLFdBQS9DM3ZCLEdBQStCMnZCLEtBQXFCO0dBQUM7WUFDL0RydEIsUUFBUXZDLEdBQUdDO0lBQUk7O1lBQUk7O2NBQVhEO3VCQUF1QzR2QixZQUFnQixXQUFJLFdBQXhEM3ZCLEdBQW9DMnZCLEtBQTJCO0dBQUU7WUFDNUV0NUIsTUFBTThLLElBQUdDO0lBQUssT0FBQTtvREFBNEIsU0FBSSxHQUF4Q0QsSUFBR0M7R0FBNEM7WUFDckQ3QixLQUFLUSxHQUFJLE9BQUEsNkJBQUpBLEdBQWtCO1lBQ3ZCNGpCLE9BQU81akIsR0FBR0M7SUFBSSxPQUFxQjs7YUFBNUJEO3NCQUFrQzR2QixZQUFnQixPQUFBLFdBQS9DM3ZCLEdBQStCMnZCLEtBQXFCO0dBQUM7WUFDL0RrcEMsTUFBTTEzRCxJQUFHQztJQUFLLE9BQXVCOytCQUEvQkQsSUFBR0MseUJBQTZDLFdBQU87R0FBQztZQUM5RGdjLEtBQUtqYyxJQUFHQztJQUFLLE9BRmJ1aUI7YUFFS3hpQjtzQkFBMEJ3dUIsS0FBTyxXQUFJLDZCQUFsQ3Z1QixJQUF1QnV1QixLQUErQjtHQUFDO1lBRS9EeXBDLE1BQU1qNEQsSUFBR0M7SUFDMEIsVUFBQSxXQXZFbkNTLFFBc0VTVDthQUNjLFdBdkV2QlMsUUFzRU1WO1NBQ0t3c0YsU0FETHhzRixJQUNKeXNGLFVBRE94c0Y7O1NBQ0V1c0YsU0FERnZzRixJQUNQd3NGLFVBREl6c0Y7SUFFbUIsT0FBQTs7YUFEdkJ5c0Y7c0JBQzZCaitEO2NBQWdCLE9BQUEsNkJBRHBDZytELFFBQ29CaCtEO2FBQXNDO0dBQUM7WUFHdEVnNUMsZUFBZTVvRSxHQUFHQztJQUNKO0tBQVptc0Y7T0F4Q0Zyc0YsS0F1Q2VDLGVBQ3VCdW9CLElBQUdqNUIsR0FBSyxPQUFHLFdBRC9CMlEsR0FDdUIzUSxLQUFIaTVCLFNBQUdqNUIsR0FBSGk1QixJQUFtQztJQUNwRCxPQUFBOzthQURuQjZqRTtzQkFDd0I5OEYsR0FBSyxPQUFBLFdBcEQvQjRnQyxRQWtEZWx3QixHQUVXMVEsR0FBZTtHQUFDO1lBRzFDdytGLGdCQUFnQkM7SUFBVSxPQUF1Qiw2QkFBakNBLHVCO0dBQXVDO1lBQ3ZEQyxXQUFXaHVGLEdBQUdDO0lBQUksT0FBa0I7O2FBQXpCRDtzQkFBK0I0dkIsWUFBZ0IsT0FBQSxXQUE1QzN2QixHQUE0QjJ2QixLQUFxQjtHQUFDO1lBS2xFMXdCLE9BQVErcEYsZ0JBQWdCbDlCLE1BQUt2eUM7SUFBSSxPQUFBLDRCQUF6Qnl2RSxnQkFBZ0JsOUIsTUFBS3Z5QztHQUEwQztZQUV2RTVaLFFBQVNxcEYsZ0JBQWdCbDlCLE1BQUt2eUMsR0FBRXhXO0lBQ2xDLEdBRDJCK29EO1NBR2xCejhELElBSGtCeThELFNBQ3ZCbTlCLFNBRUs1NUY7O1NBRkw0NUYsU0FHUSx5QkFKc0JsbUY7SUFNMUIsSUFBSmhELElBQUksNEJBTkdpcEYsb0JBQ1BDLFNBRDRCMXZFO0lBT2hDLHlCQVBrQ3hXLFlBT2R3c0IsR0FBSyxPQWpGckJXLElBZ0ZBbndCLEdBQ2dCd3ZCLEdBQVk7SUFBaEMsT0FESXh2QjtHQUVIO1lBR0MwUSxVQUFVOEksR0FBRXkwRSxXQUFVampGO0lBQ3hCLFNBRHdCQTtLQUVQLE9BQUEsNkRBRk9BO0lBSWQsSUFERTFHLE9BSFkwRyxTQUlsQmhMLElBakJKZCxjQWlCdUIseUJBRGJvRixRQUhBa1Y7SUFLVjs7TUFGVWxWO2VBRWEwRztPQUNiLElBQUpuRyxJQUFJLFdBTkVvcEYsV0FLV2pqRjtvQkF4RnJCdWlGLFdBdUZFdnRGLEdBRUU2RTs7aUJBR1M7b0VBSlFtRztNQUl1RDtJQUo5RSxPQURJaEw7R0FNSDs7YUFpQkNrL0MsU0FBUStwQyxnQkFBZ0JsOUI7S0FDMUIsT0F6Q0E3c0QsT0F3Q1UrcEYsZ0JBQWdCbDlCLE1BQ0c7SUFBOEI7YUFHekQ4VixVQUFTb25CLGdCQUFnQmw5QixNQUFLL29EO0tBQ2hDLE9BM0NBcEQ7Y0EwQ1dxcEYsZ0JBQWdCbDlCLE1BQ0csc0NBREUvb0Q7SUFDOEI7YUFHNURzckIsWUFBVTIvRCxXQUFVampGO0tBQU8sT0FuQzdCMEYsVUFtQ3VDLHNDQUEzQnU5RSxXQUFVampGO0lBQThEO0lBVGxGLFdBU0FzakIsYUFSQTR3QixVQUlBMmlCOzs7dUJBNUlGeXJCO0lBK0hGaC9EO0lBR0U0d0I7SUFBQTJpQjtZQWdDRWo0RCxlQUFldWpDO0lBQXVDLFVBQUEseUJBQXZDQTtJQUF1QyxPQUFBO0dBQTZCO21CQUdsRSxXQUVwQjtZQUVDczNCLFlBQWdDQztJLGdCQUFtQzFrRSxHQUNyRSxPQVRJOEosVUFROEI0NkQsUUFBbUMxa0UsR0FDNUM7O1lBR3ZCMmtFLFlBQWdDRDtJLGdCQUFtQzE1RDtLQUNyRSxPQWpFRTBGLGNBZ0VnQ2cwRCxRQUFBQSxRQUFBQSxTQUFBQSxRQUFtQzE1RCxNQUM1Qjs7WUFHdkM0NUQsaUJBQXFDRjtJQUNWLFVBQUEsNkJBRFVBO0lBQ1YsT0FBQTs7WUFHM0JJLGlCQUFnQzFqRSxJQUFHQyxJQUFLLE9BM0d0Qy9LLE1BMkc4QjhLLElBQUdDLElBQWdCO0dBRXRDO0lBQ1hzL0U7SUFEVyxjQUNYQTs7O09BdkJBNzJFO09BakVGNUs7T0FFQVU7T0F4RkVrQztPQUVBaVM7T0FtQ0E1VDtPQURBSjtPQU1Bd1k7T0FDQUc7T0FtQkF4VztPQUNBSztPQXpCQTZWO09BQ0FDO09BMUJBVztPQVRBRDtPQXdDQWpaO09BTUFtWjtPQVZBTDtPQUNBRTtPQXhDQXVCO09BZ0VBN2E7T0FuREEyd0I7T0FFQW85RDtPQVFBQztPQUNBdDlEO09BRUF1OUQ7T0FRQUM7T0FwQ0F4aUM7T0FpRUE1MEQ7T0FFQXN0QjtPQVNBZ2xEO09BTEF2UDtPQUhBUDtPQUNBejdDO09BWUF5d0U7T0FDQUU7T0E3RkZYOztRQWlJRi8rRDtRQWtDSXhrQjtRQUNBRjtRQWhDRnMxQztRQUFBMmlCO1FBeEhFLy9EO1FBRUFpUztRQW1DQTVUO1FBREFKO1FBTUF3WTtRQUNBRztRQW1CQXhXO1FBQ0FLO1FBekJBNlY7UUFDQUM7UUExQkFXO1FBVEFEO1FBd0NBalo7UUFNQW1aO1FBVkFMO1FBQ0FFO1FBeENBdUI7UUFnRUE3YTtRQW5EQTJ3QjtRQUVBbzlEO1FBUUFDO1FBQ0F0OUQ7UUFFQXU5RDtRQVFBQztRQXBDQXhpQztRQWlFQTUwRDtRQUVBc3RCO1FBU0FnbEQ7UUFMQXZQO1FBSEFQO1FBQ0F6N0M7UUFZQXl3RTtRQUNBRTs7O09BOEVGdnBCO09BSUFFO09BSUFDO09BSUFFOzs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7O0lDOFZFNzZEO0lBR0dpakQ7SUFvQ0Y1OUI7Ozs7Ozs7Ozs7O0lBMFlDamxCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUExeEJKM0k7SUFDQW5OOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTNLQWdqQztJQUtHN3hCO0lBSUNtSDtHQUNKLFNBRkd4RCxLQUVDL1osR0FBSyxPQUFBLFdBREx1ZCxNQUNBdmQsR0FBVztHQVNhO0lBTjFCb2hCO0lBQ0E1RztJQUNDRjtJQUlEOHdCLGVBWENyeEIsZUFNRFM7SUFNQXpTO2lEQUFBQSxXQU5BeVM7OztZQWlCRkQsaUJBQW9CLFNBQUU7WUFDdEJySSxTQUFTbFMsR0FBSSxPQUFKQSxFQUFLO1lBQ2RtUyxTQUFTblMsR0FBSSxPQUFKQSxFQUFLO1lBRWRpUyxVQUFVN0Q7SUFDWixJQUFJLFdBQUEsNEJBRFFBLElBQ1I7Z0JBQ0csT0FBQSxnQ0FGS0E7R0FFaUM7WUErSDNDNEQsVUFBVWhTO0lBQ1o7S0FDT0MsSUFBSSwyQkFGQ0Q7S0FHTixPQUFBLDRCQURDQztLQXhIYTJrQjtPQXlIZCxzQ0FITTVrQjtVQUVMQztVQUNpQywyQkFINUJEO0tBckhSMFQsa0NBRGdCa1I7S0FFUGpiO0lBQ1g7UUFGRStKLEtBQ1MvSixHQUVOLE9BQUEsNkJBSmFpYjtLQU1WLFlBQUEsd0JBTlVBLEtBRVBqYjs7OztNQUFiLE9BRm9CaWI7O0tBT1csSUFMbEJwUCxNQUtrQiw0QkFMbEI3TDtLQUFBQSxJQUFBNkw7O0dBdUhrRDtHQUs5QjtJQUEvQm9wRiwrQkFBK0I7SUFDL0JDLDRCQUE0QjtJQUM1Qi9uQztJQU9BbGxEO0lBQ0FKO1lBQ0FzdEYsU0FBU24xRixHQUFJLE9BQUEsMEJBQUpBLEdBQW9CO0dBR2I7SUFGaEIydEQ7SUFDQUU7SUFDQXVuQyxnQkFBZ0I7SUFDaEJDLGdCQUFnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQWVoQkMsVUFBVXZ1RjtJQUNaLEtBQUcsZ0NBRFNBO0tBS0osT0FBQSxnQ0FMSUEsR0FoQlZxdUY7bUJBc0JRLHlCQU5FcnVGOztJQUdELElBQUxrRyxNQUFLLHFCQUhDbEc7SUFJUCxPQUFBLGdDQURDa0csS0FsQkpvb0Y7a0JBbUJpQyx5QkFEN0Jwb0Y7O0dBSUc7WUFHZXNvRixjQUFjeHVGO0lBQ3RDLEdBQUcsZ0NBRG1DQTtLQUczQixJQUFMa0csTUFBSyxxQkFIMkJsRztLQUlqQyxHQUFBLGdDQURDa0csS0E1Qkpvb0Y7TUE4QkssT0FBQSx5QkFGRHBvRjtLQUdnRSxXQUFBLGdCQU5oQ2xHO0tBTS9CLE9BQUE7O0lBQ0MsR0FBQSxnQ0FQOEJBLEdBMUJwQ3F1RjtLQWtDRyxPQUFBLHlCQVJpQ3J1RjtJQVNxQyxXQUFBLGdCQVRyQ0E7SUFTakMsT0FBQTtHQUFnRjtZQUduRnl1RixZQUFZenVGO0lBQ2QsR0FBRyxnQ0FEV0E7S0FFTixPQUFBLGdDQUZNQSxHQXJDWnN1RjttQkF1Q21DLHlCQUZ2QnR1Rjs7SUFJSCxJQUFMa0csTUFBSyx1QkFKR2xHO0lBS1QsT0FBQSxnQ0FEQ2tHLEtBMUNKbW9GO2tCQTJDaUMseUJBRDdCbm9GOztHQUNtRTtZQUdqRHdvRixnQkFBZ0IxdUY7SUFDeEMsR0FBRyxnQ0FEcUNBO0tBR25DLEdBQUEsZ0NBSG1DQSxHQTdDdENzdUY7TUFpREssT0FBQSx5QkFKaUN0dUY7S0FLZ0MsV0FBQSxnQkFMaENBO0tBS2pDLE9BQUE7O0lBRUksSUFBTGtHLE1BQUssdUJBUDZCbEc7SUFRbkMsR0FBQSxnQ0FEQ2tHLEtBckRKbW9GO0tBdURLLE9BQUEseUJBRkRub0Y7SUFJc0UsV0FBQSxnQkFYcENsRztJQVdwQyxPQUFBO0dBQW1GO1lBR3JGMnVGLG9CQUFvQjN1RjtJQUN0QjtNQUFHLGdDQURtQkEsR0E1RHBCcXVGO1NBNkR1QixnQ0FESHJ1RixHQTNEcEJzdUY7S0E2REcsV0FBSyx5QkFGWXR1RjtJQUdqQjtHQUFJO1lBR2U0dUYsd0JBQXdCNXVGO0lBQ2hEO01BQUcsZ0NBRDZDQSxHQWxFOUNxdUY7U0FtRXVCLGdDQUR1QnJ1RixHQWpFOUNzdUY7S0FtRUcsT0FBQSx5QkFGMkN0dUY7SUFNNUMsV0FBQSxnQkFONENBO0lBSTlDLE9BQUE7R0FHSTtHQWtCaUI7SUFBQSxNQUFBO0lBQXJCNnVGLG1CQUFtQjtJQUNuQkMsbUJBQW1CO0lBS25CQyx5QkFBeUI7WUFFSEMsMkJBQTJCaHZGO0lBR2hEOztPQUFBLGdDQUhnREEsR0FGakQrdUY7VUFBQUE7O0lBQXlCLE9BQUEsNEJBRXdCL3VGO0dBSzNDO1lBR05pdkYsa0JBQWtCanZGO0lBQ3BCLEdBQUcsZ0NBRGlCQTtLQUdULElBQUxrRyxNQVhrQjhvRiwyQkFRSmh2RjtLQUlmLE9BQUEsZ0NBRENrRyxLQTdHSm9vRjttQkE4R2lDLHlCQUQ3QnBvRjs7O0lBR0ssSUFBTEMsTUFBSyx1QkFBTSw0QkFOR25HO0lBT2YsT0FBQSxnQ0FEQ21HLEtBakhKa29GO2tCQWtIaUMseUJBRDdCbG9GOztHQUNtRTtZQUd2RStvRixrQkFBa0JsdkY7SUFDcEIsR0FBRyxnQ0FEaUJBO0tBR2YsS0FBQSxnQ0FIZUEsR0F6QmxCOHVGO01BOEJRLE9BQUEsZ0NBTFU5dUYsR0FwSGxCc3VGO29CQTBIVSx5QkFOUXR1Rjs7S0FJZ0IsV0F0QlpndkYsMkJBa0JKaHZGO0tBSWIsV0FBSzs7SUFJSixLQUFBLGdDQVJZQSxHQTFCbEI2dUY7S0FvQ00sT0FBQSxnQ0FWWTd1RixHQXJIbEJxdUY7bUJBZ0lRLHlCQVhVcnVGOztJQVNjLFdBQUEsdUJBQU8sNEJBVHJCQTtJQVNmLFdBQUs7R0FHRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTVJUCtrRDtJQUNBaWtCO0lBQ0FtbUI7SUFDQUM7SUFDQUM7SUFDQUM7SUEwSUFDOzBCQWZBTCxvQkFWQUQ7WUErQkFPLHNCQUFzQnh2RjtJQUN4QixHQUFHLGdDQURxQkE7S0FHYixJQUFMa0csTUExQ2tCOG9GLDJCQXVDQWh2RjtLQUluQixHQUFBLGdDQURDa0csS0E1SUpvb0Y7TUE4SUssT0FBQSx5QkFGRHBvRjtLQUdxRSxXQUFBLGdCQU5uRGxHO0tBTWpCLE9BQUE7O0lBRUksSUFBTG1HLE1BQUssdUJBQU0sNEJBUk9uRztJQVNuQixHQUFBLGdDQURDbUcsS0FsSkprb0Y7S0FvSkssT0FBQSx5QkFGRGxvRjtJQUdxRSxXQUFBLGdCQVhuRG5HO0lBV2pCLE9BQUE7R0FBK0U7WUFHOUR5dkYsc0JBQXNCenZGO0lBQzlDLEdBQUcsZ0NBRDJDQTtLQUd6QyxHQUFBLGdDQUh5Q0EsR0E1RDVDOHVGO01BZ0U0QixXQXpETkUsMkJBcURzQmh2RjtNQUloQixPQUFBOztLQUNwQixHQUFBLGdDQUxvQ0EsR0F2SjVDc3VGO01BNkpLLE9BQUEseUJBTnVDdHVGO0tBTzZCLFdBQUEsZ0JBUDdCQTtLQU92QyxPQUFBOztJQUNDLEdBQUEsZ0NBUnNDQSxHQTdENUM2dUY7S0FzRTBCLFdBQUEsdUJBQU8sNEJBVFc3dUY7S0FTbEIsT0FBQTs7SUFDcEIsR0FBQSxnQ0FWc0NBLEdBeEo1Q3F1RjtLQW1LRyxPQUFBLHlCQVh5Q3J1RjtJQWErQixXQUFBLGdCQWIvQkE7SUFhNUMsT0FBQTtHQUFxRjs7SUFHckYwdkY7MEJBaEJzQkQsd0JBZHRCRDtZQXVDU0csV0FBYTlwRixLQUFnQjdGO0lBQ3hDLEdBRHdCNkYsU0FBTUMsTUFBTkQsUUFBQXNvQyxNQUFNcm9DLGNBQU5xb0M7SUFDeEIsb0JBRHdCQTs7aUJBQUFBO2dCQS9HQXlnRCx3QkErR2dCNXVGO2dCQVR0QzB2RixtQkFTc0MxdkY7MkJBQWhCbXVDLE1BbklBdWdELGdCQW1JZ0IxdUYsS0F2SmhCd3VGLGNBdUpnQnh1RjtHQUtaO1lBRzFCNHZGLE9BQVMvcEYsS0FBZ0I3RjtJQUMzQixHQURXNkYsU0FBTUMsTUFBTkQsUUFBQXNvQyxNQUFNcm9DLGNBQU5xb0M7SUFDWCxJQUFJLGVBVE93aEQsZUFRQXhoRCxNQUFnQm51QyxLQUN2QjtnQkFDRztHQUFJO1lBR1Q2dkYsT0FBTzd2RjtJQUFJLFdBQUEsZ0NBQUpBO0lBQUksT0FBQTtHQUFZO1lBQ3ZCOHZGLFVBQVU5dkY7SUFBSSxXQUFBLDRCQUFKQSxHQUFBQTtJQUFJLE9BQUE7R0FBVztZQUV6Qit2RixTQUFVemdHLEdBQU9DO0lBQ25CLE9BQUcsbUJBRGdCQTtjQUFQRDtjQUNlO3dCQURmQTtnQkFBT0M7Z0JBQ2dDLGdDQUR2Q0QsR0FBT0MsS0FBUEQsSUFBT0M7R0FDbUQ7WUFHcEV5Z0csU0FBVTFnRyxHQUFPQztJQUNuQixPQUFHLG1CQURnQkE7Y0FBUEQ7Y0FDZTt3QkFEZkE7Z0JBQU9DO2dCQUNnQyxnQ0FEdkNELEdBQU9DLEtBQVBELElBQU9DO0dBQ21EOztJQUdwRTRnQztJQUNBdHdCO0lBQ0F5bUQ7SUFFQTVvQztZQUNBdXlFLE9BQU8zZ0csR0FBSSxPQUFBLDRCQUFKQSxHQUFBQSxHQUFVO1lBV2Y0Z0csV0FBV2x3RixHQUFJLE9BQUEsNkJBQUpBLEdBQVM7WUFDcEJtd0YsU0FBU253RixHQUFJLE9BQUEsNkJBQUpBLEdBQVM7WUFPcEJvbEQsbUJBQW1CcGxEO0lBQUksT0FBRyxnQ0FBUEE7Y0FBb0IsdUJBQXBCQTtjQUFzQyxxQkFBdENBO0dBQWdEO1lBR3BEb3dGLHFCQUFxQnB3RjtJQUN0QztNQUFHLGdDQURtQ0EsR0F6SXBDNnVGO1NBMEl5QixnQ0FEVzd1RixHQXhJcEM4dUY7S0EwSVMsT0FBQSx1QkFuSWFFLDJCQWlJY2h2RjtJQUdqQyxPQUFBLDRCQUhpQ0E7R0FHMUI7WUFHVnNsRCxjQUFjdGxELEdBQUksT0FOSG93RixxQkFNRHB3RixHQUFvRDtZQUVsRXF3RiwyQkFBMkJyd0Y7SUFDN0I7O01BQUcsZ0NBRDBCQSxHQWpKM0I2dUY7V0FrSjBCLGdDQURDN3VGLEdBaEozQjh1RjtLQW9KWTtNQUFSemhELFFBQVEsdUJBSmVydEM7TUFNdkJzd0YsZUFBZSw0QkFGZmpqRDtNQUdBa2pELGFBQWEsNEJBUFV2d0YsR0FJdkJxdEM7TUFJQW1qRCxZQUFZLDRCQUZaRixjQU51QnR3RjtLQVN4QixHQUFBLGdDQUZDdXdGLFlBQ0FDLFlBRUMsT0FORG5qRDtLQU9JLEdBQUEsZ0NBSkprakQsWUFDQUM7TUFJQyxPQU5ERjtLQVFGLFdBQUEsc0JBVkVqakQ7S0FVRixPQUFBLDRDQVZFQSxRQUVBaWpEOztJQUpELE9BQUEsNEJBRndCdHdGO0dBZ0JUO0dBR0c7SUFBckJ5d0YscUJBQXFCO0lBQ3JCQyxxQkFBcUI7WUFFckJDLG1CQUFtQjN3RjtJQUNyQixHQUFHLGdDQURrQkE7S0FHVixJQUFMa0csTUFBSyxxQkFIVWxHO0tBSWhCLEdBQUEsZ0NBRENrRyxLQUxKd3FGO01BT0ssT0FBQSwyQkFGRHhxRjtLQU1BLFdBQUEsNEJBVGVsRztLQU9qQixPQUFBOztJQUlJLEdBQUEsZ0NBWGFBLEdBSG5CeXdGO0tBZUcsT0FBQSwyQkFaZ0J6d0Y7SUFnQmpCLFdBQUEsNEJBaEJpQkE7SUFjbkIsT0FBQTtHQUdJO1lBR0o0d0YscUJBQXFCNXdGO0lBQ3ZCLEdBQUcsZ0NBRG9CQTtLQUdsQixHQUFBLGdDQUhrQkEsR0F0QnJCMHdGO01BMEJLLE9BQUEsMkJBSmdCMXdGO0tBUWpCLFdBQUEsNEJBUmlCQTtLQU1uQixPQUFBOztJQUtPLElBQUxrRyxNQUFLLHVCQVhZbEc7SUFZbEIsR0FBQSxnQ0FEQ2tHLEtBbENKdXFGO0tBb0NLLE9BQUEsMkJBRkR2cUY7SUFNQSxXQUFBLDRCQWpCaUJsRztJQWVuQixPQUFBO0dBR0s7WUFHUDZ3RiwrQkFBdUN2RztJQUNqQyxJQUFKdHFGLElBeEVhb3dGLHFCQXVFd0I5RjtJQUV0QyxHQUFBLGdDQURDdHFGO0tBR0MsR0FBQSxnQ0FIREEsR0E1Q0Ywd0Y7TUFnREssT0FBQSwyQkFKSDF3RjtLQVFFLFdBQUEsZ0JBVG1Dc3FGO0tBT3JDLE9BQUE7O0lBSUksR0FBQSxnQ0FWSnRxRixHQTdDRnl3RjtLQXdERyxPQUFBLDJCQVhEendGO0lBZUEsV0FBQSxnQkFoQnFDc3FGO0lBY3ZDLE9BQUE7R0FHSTtZQUdKd0csK0JBQXVDN3dGO0lBQWlCLFdBdkp4RHl2RixtQkF1SnVDenZGO0lBQWlCLE9BQUE7R0FBc0I7O0lBRTlFOHdGOztTQUZBRDtTQXBCQUQ7WUE0QkFyckMsTUFBUTMvQyxLQTdGTTdGO0lBOEZoQixHQURVNkYsU0FBTUMsTUFBTkQsUUFBQXNvQyxNQUFNcm9DLGNBQU5xb0M7SUFDVixvQkFEVUE7O2lCQUFBQTtnQkF0R1JpWCxtQkFTY3BsRDtnQkFOQ293RixxQkFNRHB3Rjs7aUJBNkZObXVDO2dCQUdDLHVCQWhHS251QztnQkFpR1AscUJBakdPQTtHQWtHZTtPQVkzQi9IO0dBS0QsU0FGQ3EyQixZQW9CQy9aO0lBbEJGOztjQWtCRUE7aUJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1VBakJnRDs7U0FDVjs7UUFDTTs7T0FDTTs7TUFDVjs7Z0JBYXhDQTs7TUFDQSxPQUFBOzRDQXBCRTI0QyxrQkFtQkYzNEM7OztNQURBLE9BQUE7NENBbEJFMjRDLGtCQW1CRjM0Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0FYYyxPQUFBOytDQVJaMjRDLGtCQW1CRjM0Qzs7UUFUQSxPQUFBOzhDQVZFMjRDLGtCQW1CRjM0Qzs7T0FQQSxPQUFBOzZDQVpFMjRDLGtCQW1CRjM0Qzs7TUFMYyxPQUFBOzRDQWRaMjRDLGtCQW1CRjM0Qzs7S0FIQSxPQUFBOzJDQWhCRTI0QyxrQkFtQkYzNEM7O0lBR0EsT0FBQSx3Q0F0QkUyNEMsa0JBbUJGMzRDO0dBR3NFO1lBSXZFM0k7SUFDRDs7T0FDZTs7T0FDTDs7T0FDRzs7T0FDRztlQUNMOztHQUF5QjtZQXFCbkM2M0MsWUFBVXpqRDtJQUFtQixXQTNCN0I0TCxZQTJCVTVMO0lBQW1CLE9BQUE7R0FBYTtZQUMxQ2dtRCxZQUFVdG9EO0lBQUksT0F2RGQ0d0IsWUF1RHdCLDZCQUFkNXdCO0dBQWdDO1lBRzVDc3pGLFNBQVNoeEY7SUFDWCxPQUNNLDJCQUZLQTs7T0FHSTs7T0FDRzs7T0FDTDs7T0FDSTtlQUNMOztHQUFLO1lBR2ZxakQsbUJBQXFCeDlDLFdBQXVDa3ZCO0lBQzlELEdBRHVCbHZCLFNBQVlDLE1BQVpELFFBQUE0OEMsWUFBWTM4QyxjQUFaMjhDO0lBQ3ZCLGFBRHVEdGpDLGlCQUFiOHhFLGFBQWE5eEUsZ0JBQWI4eEU7SUFDcEMsWUFBQSw0QkFEd0RsOEQ7O0tBRXBELE9BQUEscUNBRm9EQSxRQUF2QzB0QjtJQUlWOztLQURDbGI7S0FBTkQ7S0FDRnVCLFNBQU8scUNBREx2QixNQUhlbWI7S0FLakJvbkI7T0FMb0NvbkI7VUFNbkI7O3dCQUErQnpoRixHQUFLLE9BQUEsMEJBQUxBLE9BQXFCO1dBSDdEKzNCO1VBQUFBO09BRVJzaUMsbUJBSUssT0FMTGhoQztJQU1XLFdBQUEsb0NBTFhnaEM7SUFLVyxPQUFBLDZCQU5YaGhDO0dBTXVCO1lBRzNCMVMsY0FBZXNzQixXQUFZNThDLEtBQWVvckYsa0JBQW9DaHhGO0lBQ2hGLEdBRDZCNEYsU0FBV0MsTUFBWEQsUUFBQXFyRixXQUFXcHJGLGNBQVhvckY7SUFDN0I7U0FEeUUveEUsaUJBQWhCZ3lFLGdCQUFnQmh5RTs7U0FBaEJneUU7T0FBNUJELGNBRXhCLGdDQUZ3QkE7SUFHdkIsWUExQkpGLFNBdUI4RS93RjtvQkFLakU7O0tBRFEsT0FBQSxnQ0FKeURBOztLQU8xRXZDO09BUG1EeXpGO1VBUS9CLGdDQVJHRCxVQUFtRGp4RjtVQVF0QixnQ0FSN0JpeEYsVUFBbURqeEY7SUFVOUUsT0F2QkFvakQsbUJBYWVaLFdBQTJCd3VDLFlBT3RDdnpGO0dBR3VDO1lBRzNDcXhCLFlBQVUvdUI7SUFDRCxJQUFQZ0wsT0FBTyxXQXRtQlBsQixXQXFtQlE5Sjt1Q0FHUyxPQUZqQmdMO2FBQUFBO1NBVU0rcEIsU0FWTi9wQjtLQVdJLE9BQUEsa0NBREUrcEI7ZUFWTi9wQjttQkEzQkZxNEMseUJBcUNRdHVCOztJQURBLDZCQUFVLHlCQVRoQi9wQjtJQU9HLE9BQUE7YUEzbkJMdXNCO2FBMm5CSztHQUk0RTtZQUdqRjY1RDtJQUFnQ3B4RixHQUFJNkYsS0FBY3dyRixNQUFNQyxNQUFNQyxNQUFNQyxNQUFNQztJQUs1RSxHQUxzQzVyRixTQUFTQyxNQUFURCxRQUFBMGxCLFNBQVN6bEIsY0FBVHlsQjtJQThCaEMsWUFqRkp5bEUsU0FtRGdDaHhGO29CQWdDbkI7O0tBRFEsT0FBQSxnQ0EvQldBO2FBa0M1Qm9yRSxHQUFHcHJFO2NBY0RxcEQsS0FBS3FvQyxLQUFJQyxXQUFFQztNQUNiOztPQUN5QjtTQUF0QixnQ0FGVUE7WUFFWSxnQ0FGZEQ7O09BR0wsR0FBQSxnQ0FIT0M7UUFHdUM7U0FqUjFDMXJGLE1BaVIwQyw0QkFIdkMwckY7U0E5UUMsT0FOSHhCLHFCQU1EbHFGO1FBaVJ1QixHQUFBLGdDQUh0QnlyRjs7T0FDWCxNQUFBOztNQUcwQjtPQWxSaEIzeEYsSUFrUmdCLDRCQUpiNHhGO09BOVFDLE9BTkh4QixxQkFNRHB3RjtNQWtSSCxLQUFBLGdDQUpJMnhGO09BSVgsTUFBQTtNQTlDSTtPQUFKbmlFO1NBQUk7dUJBQU0sNEJBMENDbWlFLFdBQUVDO09BbkNiaGpDLFFBQVEsNEJBbUNLZ2pDLGFBMUNicGlFO09BUXdCLE9BQUEsNEJBUnhCQTtPQVFBcWlFLFNBQVMsNEJBa0NJRDtPQTlCYkUsYUFBYSw0QkFKYkQsUUFrQ1dGO09BN0JYSSxZQUFZLDRCQTZCREosV0FuQ1gvaUM7T0FPQXJULE1BcFRKbTBDLG1CQXNTSWxnRTtPQWdETThtQztTQWpDUCxnQ0FIQ3c3QixZQUNBQztZQUdDLDRCQUZEeDJDO1lBR0k7bUNBTEp1MkMsWUFDQUM7Y0FDQXgyQzs7a0JBTW9DLDZCQU5wQ0E7Z0JBQUFBO2dCQVFDLDRCQVJEQTtPQWlDT3pQLElBR0csNkJBRkp3cUI7T0FERnI5RCxJQUdGLDRCQUZJcTlEO2NBREZyOUQsWUFBQUE7ZUFBRzZ5QyxVQUFBQTtxQkFBQUE7a0JBU0YsZ0NBOUQyQnZnQixRQXFENUJ0eUIsR0FMR3k0RjtrQkFlRixnQ0EvRDJCbm1FLFFBcUQ1QnR5QixHQUxHeTRGLEtBS0E1bEQ7T0FPUCxNQUFBOztNQURBLE1BQUE7S0FJc0M7S0FhckMsS0FBQSxnQ0ExQ0U5ckM7TUE0Q0csR0FBQSxnQ0E1Q0hBO09BNkNBLE9BL0JEcXBELEtBaEQ0Q2dvQyxNQWtDM0NyeEY7TUE4Q0csR0FBQSxnQ0E5Q0hBO09BK0NBLE9BakNEcXBELEtBaERrRGlvQyxNQWtDakR0eEY7TUFnREcsR0FBQSxnQ0FoREhBO09BaURBLE9BbkNEcXBELEtBaER3RGtvQyxNQWtDdkR2eEY7TUFrREcsR0FBQSxnQ0FsREhBO09BbURBLE9BckNEcXBELEtBaEQ4RG1vQyxNQWtDN0R4eEY7V0FsQ21FeXhGLE1Bd0Y1RCxPQUFBLGdDQXhGc0JsbUUsUUFrQzdCdnJCO1VBdURJZ3lGLFNBekYrRFA7TUEwRmpFLE9BQUEsZ0NBeERGenhGO2dCQWNEcXBELEtBeUNLMm9DLFFBdkRKaHlGO2dCQTBESSxnQ0E1RnlCdXJCLFFBa0M3QnZyQjs7S0FFZ0I7T0FBWCxvQ0FGTEE7VUFFZ0IsZ0NBRmhCQTtNQUdLO09BQUoxUSxJQUFJLDZCQXJDd0JpOEIsUUFxQ2YsMEJBSGR2ckI7TUFLQSxLQUFBLDRCQUZDMVEsV0FTQyxPQVREQTtNQUlNO09BQUorbUIsTUFBSSw0QkFKTi9tQjtPQUtFa2pCLElBQUosNkJBREk2RDtNQUVKLGVBRklBLEtBRVEsNEJBRFI3RDtNQUVKLGVBSEk2RCxLQUdRLDRCQUZSN0Q7TUFFSixPQUFBLDRCQUhJNkQ7O0tBTE4sTUFBQTtJQXdEaUM7SUFFbEMsR0FBQSxnQ0E5RjZCclcsUUE4RmhCLE9BNURab3JFLEdBbEM0QnByRTtJQThGQSxXQTVENUJvckUsR0E0RCtCLDZCQTlGSHByRTtJQThGQSxPQUFBO0dBQU87WUFHdkNpeUYseUJBQXlCanlGO0lBQzNCLE9BbEdFb3hGO2FBaUd5QnB4RjtHQUMyRDtZQVVwRnlrRCxRQUFRbjFELEdBQUVrakI7SUFDWixTQURZQSxHQUdQO0lBUUs7S0FBSjZELFVBQVEsNEJBWEovbUI7S0FZSm1qQixVQVpNRDtLQWFONE87T0FEQTNPO0tBREE0RCxTQU1HLGdDQU5IQTtLQUNBNUQsU0FNRyw2QkFOSEE7UUFBQUEsWUFDQTJPLFdBRkEvSyxRQWVBLDZCQWRBNUQ7OzthQUFBQSwyQ0FEQTRELFFBRUErSztjQWlCQyw2QkFsQkQzTztNQUNBMk8sV0FpQjhCLDRCQW5COUIvSyxRQUVBK0s7S0FGQS9LLFNBb0JHLDRCQXBCSEEsUUFBQUE7S0FDQTVELFNBb0JHLDZCQXBCSEE7O0dBd0JTO1lBR2J5L0UsVUFBVTVpRyxHQUFHZ3NDO0lBQ2YsR0FBRyxnQ0FEU2hzQyxRQUVQO0lBQ08sS0EvWlZ3Z0csVUE0WlV4Z0csSUFJUCxPQUpPQTtvQkFBR2dzQztLQVVLO01BRE02MkQsS0FUWDcyRDtNQVVLO1FBQUE7VUF6bUJsQng2QjtVQXltQnlCLHFCQUFVLGlCQUFPLHNCQVZoQ3hSO01BVUY4aUcsS0FBSyw0QkFEV0Q7TUFGaEJFLE9BR0FEO01BSEpFLE9BRW9CSDs7S0FJTjtNQU5WSSxPQVBLajNEO01BYUs7UUFBQTtVQTVtQmxCeDZCO1VBNG1CeUIscUJBQVUsaUJBQU8sc0JBYmhDeFI7TUFPTmtqRyxPQU1TLDRCQU5MRDtNQUFBRixPQUFBRTtNQUFKRCxPQUFBRTtXQUFBRixNQVdDO2FBWERBLE1BYUMsT0FwQktoakc7SUF3QkssSUFBVG1qRyxTQUFTLHlCQWpCUEo7YUFpQkZJLGVBakJGSDtLQW9DWSxJQUFSdHhFLFFBbEZSeWpDLGFBK0RNZ3VDO0tBb0JGLFFBckNJSjtNQXNDQzs7U0E1WlRoQywyQkE0Wm9DLDRCQTdDMUIvZ0csR0EyQ0YweEI7TUFFQyxPQUFBLGtDQUZEQTs7S0FHQzthQTdaVHF2RSwyQkE2Wm9DLDRCQTlDMUIvZ0csR0EyQ0YweEI7S0FHQyxPQUFBLGtDQUhEQTs7SUFGUyxPQTN4QmpCemYsVUEyeEJpQixnQ0FsQ2Ird0YsTUFQTWhqRztHQThDa0Q7WUFHNURvakcsa0JBQWtCcGpHLEdBQUdxakc7SUFDdkIsV0FEdUJBO2NBakRyQlQsVUFpRGtCNWlHLGtCQUFHcWpHO2NBR3JCLGdDQUhxQkE7R0FPdUM7WUFHNURDLGNBQWN0akcsR0FBR3VqRztJQUFpQixPQTNEbENYLFVBMkRjNWlHLG1CQUFHdWpHO0dBQWtFO1lBQ25GNTVELFFBQVFqNUIsR0FBR2s1QixLQUFLQztJQUFPLFdBQUEsZ0NBQVpELEtBQUhsNUI7SUFBZSw4Q0FBZkEsR0FBUW01QjtHQUE0QjtZQUU1Q0UsVUFBVXI1QixHQUFHdlEsS0FBS0Q7SUFFcEIsR0FBTyxnQ0FGUUMsS0FBS0Q7S0FJcEIsT0FBQSw0QkFKWXdRLEdBQUd2USxLQUFLRDtJQUVwQixNQUFBO0dBRTJCO1lBR3pCOHBDLE1BQU10NUIsR0FBR3ZRLEtBQUtEO0lBRWhCLEdBQUcsZ0NBRlFDLEtBQUtEO0tBR1gsV0FBRyw0QkFIQXdRLEdBQUd2USxLQUFLRDtJQVFUOzRCQUFpQyxXQXAxQnBDc2EsV0E0MEJZdGE7S0FRVCx1QkFBUyxXQXAxQlpzYSxXQTQwQk9yYTtLQU1QLE1BQUE7SUFBQSxPQUFBO0dBRXNEOztJQUd4RDRmO0lBQ0F6YTtJQUNBQztJQUVBQztJQUVBQztZQUVBKzlGLFNBQVM5eUY7SUFDWCxHQUFHLGdDQURRQSxRQUVOO0lBQ0csR0FBQSxnQ0FIR0EsUUFJTjtJQUNHLEdBQUEsZ0NBTEdBLFFBTU47SUFDb0Q7S0FBQSxxQkFqUXZEK3VCLFlBMFBTL3VCO0tBT1EsTUFBQTtJQUFBLE9BQUE7R0FBMEQ7WUFHM0UreUYsWUFBWS95RjtJQUNkLE9BQUcsZ0NBRFdBOztjQUNhO3FDQURiQTs7Z0JBQ3FDLGdDQURyQ0E7R0FDOEQ7WUFHMUVnekYsY0FBY2h6RjtJQUNMLElBQVB5YixPQUFPLHlCQURLemI7SUFFVixPQUFBLHNCQURGeWI7R0FDeUI7R0FLRjtJQUR6QnczRTs7SUFDQUM7TUFBeUI7UUFBQTtJQUN6QkMsZ0JBQWdCLDBCQURoQkQ7SUFDZ0I7SUFDTyxNQUFBLDJDQUh2QkQ7SUFHQUcsZ0JBQXVCO0lBQ3ZCQyxrQkFBa0IsMkJBRGxCRDtZQUdBRSxjQUFjdHpGO0lBQ2hCO0tBQUl5YixPQUFPLHlCQURLemI7S0FFRCxNQUFBLDJCQURYeWIsTUFQRnczRTtJQVFLLE9BQUE7YUFBQSxnQ0FQTEM7R0FRa0I7WUFHbEJLLGNBQWN2ekY7SUFDTCxJQUFQeWIsT0FBTyx5QkFES3piO0lBRWUsT0FBQTs2QkFBQSx1QkFEM0J5YixNQVRGNDNFO0dBVXlEO1lBR3pERyxnQkFBaUJDLFVBQVU5dUMsVUFBVSt1QztJQUN2QyxHQUFRLHlCQURxQi91QyxVQWYzQnd1QyxtQkFlMkJ4dUM7S0FFeEIsT0FBQSxnQ0FGd0JBLFVBZjNCd3VDO0lBa0JhLFVBQUEsMkJBSHdCTyxVQWRyQ047SUFpQmEsR0FBQSxnQ0FId0JNO0tBUW5DO01BQUEsTUFBQSwyQkF0QkZOO01BcUJFLE1BQUEsMkJBUG1DTTtLQUtyQyxPQUFBOztJQU9nQjtLQURaQyxZQVhhRjtLQVliRztPQUFZO1NBQXNCLDRCQVpYanZDO0tBYXZCa3ZDLFlBQVksMkJBYnFCSDtLQWNqQ2o0RSxPQUFtQixjQUhuQms0RSxXQUdtQyxjQUZuQ0MsV0FDQUM7SUFFSixPQUFBLGlDQURJcDRFO0dBQzBCO1lBRzlCcTRFLFlBQWFMLFVBQVU5dUMsVUFBVSt1QztJQUNuQyxPQUFrQjs7OztjQUFXLE9BbkIzQkYsZ0JBa0JhQyxVQUFVOXVDLFVBQVUrdUM7YUFDdUM7R0FBQztZQU92RXpULFlBQVUzd0YsR0FBSSxPQUFBLGdDQUFKQSxHQUEyQjtZQUNyQ2ltRCxZQUFVam1ELEdBQUksV0FEZDJ3RixZQUNVM3dGLElBQTJCO1lBQ3JDaTNELFlBQVVqM0QsR0FBSSxPQTM0QmhCaVMsVUEyNEJZalMsR0FBZTs7OzBDQTE1QnpCK0gsV0FOQXlTLFdBZ0tGczhDOztZQTh3QkF4c0IsWUFBWTU1QixHQUFJLE9BQUEsZ0NBQUpBLE9BQVU7WUFDdEI2NUIsZ0JBQWdCNzVCLEdBQUksT0FBQSxnQ0FBSkEsT0FBVztZQUMzQjg1QixZQUFZOTVCLEdBQUksT0FBQSxnQ0FBSkEsT0FBVTtZQUN0Qis1QixnQkFBZ0IvNUIsR0FBSSxPQUFBLGdDQUFKQSxPQUFXOzs7NkNBS3ZCcUssYUFoeUJKL0k7OztJQTZ5QjJDdE07SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7WUFNekNpckYsV0FBU2h4RixHQUFJLE9BQUpBLEVBQUs7R0FhSDtJQUtYeWtHO0lBTFc7Ozs7OztPQUtYQTtPQTlzQkZoRjtPQTBNQThCO09Bb0JBQztPQXZLc0JyQjs7Ozs7Ozs7Ozs7O1lBaXNCdEJoZ0csSUFBS0gsR0FBT0M7SUFBSSxLQUFHLHNCQUFkRCxHQUFPQyxRQUFnQixtQkFBdkJELElBQTRDLE9BQXJDQztJQUE4QixPQUFyQ0Q7R0FBNkM7WUFDbERFLElBQUtGLEdBQU9DO0lBQUksS0FBRyxzQkFBZEQsR0FBT0MsUUFBZ0IsbUJBQXZCRCxJQUE0QyxPQUFyQ0M7SUFBOEIsT0FBckNEO0dBQTZDOzs7O09BcmdDL0NzYTtPQWtCSG5JO09BREFEO09BM0JHa0U7T0FHQTJEO09BS0RxSDtPQXNtQkZxZTtPQWhsQkF4dEI7Ozs7Ozs7OztPQWcvQkE5UjtPQUNBRDs7O09Bbk1BeXBDO09BRUFJO09BT0FDOzs7T0F2MEJFb0I7T0F5NkJGZDtPQUNBQztPQUNBQztPQUNBQztPQWg2QkFsd0I7O09BMklBbkk7T0FDQW5OO09BREFtTjtPQUNBbk47T0FHQTZ4RDtPQUNBckI7T0FDQWlrQjtPQUNBbW1CO09BQ0FDO09BQ0FDO09BQ0FDOzs7T0FSQXBCO09BQ0FDOzs7OztPQVFBanRGO09BQ0FKO09BQ0FzdEY7T0FDQXhuQztPQUNBRTtPQXdVQXRCO09BOUlBb3FDO09BUlNEO09BZ0RUdnFDOzs7T0FTQUU7T0FFQStxQztPQWhMQTFCO09BdEJBRjtPQXRCQUY7T0FvSEFnQjtPQWxFc0JYO09BcEJBRjtPQXBCQUY7T0E4SXRCa0I7T0E4R0FrQjtPQXBCQUQ7T0ErREFJO09BalVBMUM7T0FDQUM7T0E4UEFtQztPQUNBQztPQTRZQWdDO09BVUFFOztPQXhkQS9DO09BQ0FDOztPQUVBQztPQUlBQztPQXNlQTNnRjtPQUNBemE7T0FHQUU7O09BRkFEOztPQUlBRTtXQXhkRW03RixZQUNBQzs7O09BakJGaGdFO09BQ0F0d0I7T0FDQXltRDtPQUVBNW9DOzs7UUE4ZEFyTztRQUNBemE7UUFDQUM7UUFFQUM7OztRQUVBQztRQXNHMkNNO1FBQUFEO1FBQUFEO1FBQUFEO1FBQUFEO1FBQUFEOztRQTVrQjNDc3hEO1FBdk5BRjtRQU9BbGxEO1FBa3lCRW8vRTtXQWxIRmp4RSxVQUNBemEsVUFDQUMsVUFFQUMsNEJBRUFDO09BdnNCQXVNO09Ba2NBNjBCO09BNkhBODdEO09BakdBYjtPQTRHQTNzQztPQXRXQXdyQzs7OztRQTBJRWg0RjtRQUNBZ1M7UUFFQXFrQjtRQTJCQTFpQjtRQVVDMGpCO1FBa0JEMDJCO1FBREF2QztPQUlGdXRDOztPQThSQThCO09BVUFDO09BNkNBZTtPQWxCQU47T0F2QkFSO09BWUFNO09BTUFDO1dBaDRCRTdpRixXQWc2QkE2a0MsYUE5NUJDM3JDLGdCQSs1QkQyOEMsYUFGQTA1Qjs7OztFOzs7Ozs7Ozs7RTs7Ozs7Ozs7O0U7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUM1NkJGK1QsY0FBY2gwRixHQUFFdEMsR0FBR2dkLEtBQUt2YjtJQUFNLE9BQUEsZ0JBQWhCYSxHQUFFdEMsR0FBR2dkLEtBQUt2YjtHQUErQjtZQUN2RDgwRixhQUFhajBGLEdBQUV0QyxHQUFHZ2QsS0FBS3ZiO0lBQU0sT0FBQSxnQkFBaEJhLEdBQUV0QyxHQUFHZ2QsS0FBS3ZiO0dBQThCO1lBQ3JEMkssVUFBVTlKO0lBQW1CLFVBQUEscUJBQW5CQTtJQUFtQixPQUFBO0dBQVk7WUFZbkNrL0MsU0FBUS8vQyxLQUFNLE9BQUEsMkJBQU5BLEtBQXNCO09BQzlCaWE7WUFFQW5KLFlBQWEyckIsS0FBS0MsU0FBU0MsS0FBS0MsU0FBUzU4QjtJQUMzQyxPQUFBLDZCQURleThCLEtBQUtDLFNBQVNDLEtBQUtDLFNBQVM1OEI7R0FDQzs7Ozs7WUFIMUNpYSxVQURBOGxDLFVBR0FqdkM7Ozs7Ozs7OztPQWZObkc7Ozs7Ozs7Ozs7Ozs7Ozs7T0FGQWtxRjs7T0FDQUM7Ozs7RTs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0dDRFE7O0lBQ1JDOzs7Ozs7O0lBREFDO1lBR0FwaUYsSUFBTWxNO0lBQ1IsR0FEUUE7U0FBcUJDLE1BQXJCRCxRQUFBdXVGLHFCQUFxQnR1Rjs7U0FBckJzdUY7SUFDUixPQUFBLG1DQURRQTtHQUNzQztZQUc1Qzl5RixVQUFVdEI7SUFDWixPQVJFbTBGLFdBQ0FELGlCQU9pQyxnQ0FEdkJsMEY7R0FDOEQ7WUFHeEVxMEYsZUFBZXIwRjtJQUF1QixVQUp0Q3NCLFVBSWV0QjtJQUF1QixPQUFBO0dBQWE7WUFDbkQ4SixVQUFVOUo7SUFBd0IsVUFEbENxMEYsZUFDVXIwRjtJQUFJLFdBQVUsd0NBQXFDMVEsR0FBSyxXQUFMQSxHQUFnQjtHQUFFOztJQUc3RWdsRztJQUNBQzs7O1lBQ0FDLG1CQUFpQixPQUFBLG1DQUFrQztZQUVuREMsb0JBQW9CcnBGO0lBQ3RCLE9BQUcseUJBRG1CQSxXQUZwQm9wRjtHQUd1RTtZQWV2RUUsZUFBZXJ4RixHQUFHcEQ7SUFDUixJQUFSMDBGLFFBQVEsV0FwQlZKO0lBcUJGLFdBdEJFRCxlQW9CZWp4RjtJQUdPLE9BQUE7O2FBSEpwRDs2QkFHZSxPQURuQyxXQXRCRXEwRixlQXFCRUssT0FFa0Q7R0FBQztZQUl2RDVuRjtJQWhCUSxZQUFBOztLQUVrQjtNQUFqQnpkOztNQUFpQixNQUFBLDRCQUFqQkE7TUFITHNsRztRQUdVOzs7d0JBQUEsT0FBQTs7U0FIVkE7SUFLSixjQUxJQTtpQkFLMEMsV0FmNUNOO0dBMkIrQzs7OztPQTlCakR4cUY7T0FUQWlJO09BSUF6UTtPQUlBK3lGO09BWEFGOztRQWdCRUk7UUFEQUQ7UUFvQkFJO1FBbEJBRjtRQUVBQztPQXVCRjFuRjs7O0U7Ozs7Ozs7OztHOzs7OztHQ3FIVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFwSVZyZDtJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBb0lVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWFSNkk7SUFQOEIsaUNBTzlCQTtJQVNBNko7SUFDQXNCO0lBRUFtc0Y7SUFJQUM7WUFJQ0MsbUJBR0M1L0U7SUFBb0IsT0FBQSwwQkFBcEJBO0dBQXlEO0dBQTdEO0lBT0V4TztJQUNBc0I7SUFFQ25FO0lBTUMrSTtHQUNKLFNBRkd6SCxVQUVDOVYsR0FBSyxPQUFBLFdBREx1ZCxNQUNBdmQsR0FBVzs7SUFHYjBsRztJQUNBQztJQUNDQztJQU1EdHVGO0lBQ0FzQjtJQUVDckU7SUFNQ3dpRDtHQUNKLFNBRkduaEQsVUFFQzVWLEdBQUssT0FBQSxXQURMKzJELFFBQ0EvMkQsR0FBVzs7SUFHYjZsRztJQUNBQztJQUNDQztJQU1EQztJQU1BenVGO0lBQ0E0QjtJQUVDaEY7SUFNQzh4RjtHQUNKLFNBRkdqd0YsV0FFQ2hXLEdBQUssT0FBQSxXQURMaW1HLFFBQ0FqbUcsR0FBVzs7SUFHYmttRztJQUNBQztJQUNDQztJQU1ENXVGO0lBQ0FxQjtJQUVDNUU7SUFJQ295RjtHQUNKLFNBRkd4d0YsU0FFQzdWLEdBQUssT0FBQSxXQURMcW1HLFFBQ0FybUcsR0FBVzs7SUFHYnNtRztJQUNBQztJQUNDQztJQU1EL3VGO0lBQ0FxQjtJQUVDeEU7SUFNQ215RjtHQUNKLFNBRkc5d0YsV0FFQzNWLEdBQUssT0FBQSxXQURMeW1HLFFBQ0F6bUcsR0FBVzs7SUFHYjBtRztJQUNBQztJQUNDQztJQU1EbHZGO0lBQ0FxQjtJQUVDN0U7SUFNQzJ5RjtHQUNKLFNBRkdueEYsV0FFQzFWLEdBQUssT0FBQSxXQURMNm1HLFFBQ0E3bUcsR0FBVzs7SUFHYjhtRztJQUNBQztJQUNDQztJQU1ENXVGO0lBQ0FrQjtJQUVBMUU7SUFVQXF5RjtJQUlBQztZQUlDQyxrQkFDQ3RoRjtJQUFvQixPQUFBLHlCQUFwQkE7R0FBd0Q7R0FBNUQ7SUFRRWxPO0lBQ0FxQjtJQUVDdkU7SUFNQzJ5RjtHQUNKLFNBRkczeEYsZUFFQ3pWLEdBQUssT0FBQSxXQURMb25HLFFBQ0FwbkcsR0FBVzs7SUFHYnFuRztJQUNBQztJQUVDQztJQVNEOXVGO0lBSUFjO0lBSUE3RTtJQVVBOHlGO0lBSUFDO1lBSUNDLG9CQUdDN2hGO0lBQW9CLE9BQUEsMkJBQXBCQTtHQUEwRDtHQUE5RDtJQU9Fbk47SUFDQWM7SUFFQW11RjtJQUlBQztZQUlDQyxpQkFDQ2hpRjtJQUFvQixPQUFBLHdCQUFwQkE7R0FBdUQ7R0FBM0Q7SUFPRWpPO0lBQ0FxQjtJQUVDN0U7R0FPSCxTQUZHMkIsWUFFQy9WLEdBQUssZ0NBQUxBLEdBQVc7O0lBR2I4bkc7SUFDQUM7SUFDQ0M7SUFNREM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQ0M7SUFNRHh3RjtJQUNBcUI7SUFFQ2xGO0lBTUNzMEY7R0FDSixTQUZHcnlGLFVBRUNqVyxHQUFLLE9BQUEsV0FETHNvRyxRQUNBdG9HLEdBQVc7R0FsVEg7SUFxVFZ1b0c7SUFDQUM7SUFDQ0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMENEM2xGO0lBWUFwVjtJQUNBRTtJQU9BODZGO0lBQ0FDO0lBQ0ExZ0U7SUFJQXA2QjtJQTNYVTs7T0FJVmlLO09BQ0FzQjtPQUVBbXNGO09BSUFDO09BSUNDO09BVURwdUY7T0FDQXNCO09BRUNuRTtPQUtBc0I7T0FLRDR2RjtPQUNBQztPQUNDQztPQU1EdHVGO09BQ0FzQjtPQUVDckU7T0FLQXFCO09BS0Rpd0Y7T0FDQUM7T0FDQ0M7T0FNREM7T0FNQXp1RjtPQUNBNEI7T0FFQ2hGO09BS0E2QjtPQUtEa3dGO09BQ0FDO09BQ0NDO09BTUQ1dUY7T0FDQXFCO09BRUM1RTtPQUdBNEI7T0FLRHl3RjtPQUNBQztPQUNDQztPQU1EL3VGO09BQ0FxQjtPQUVDeEU7T0FLQXFCO09BS0Qrd0Y7T0FDQUM7T0FDQ0M7T0FNRGx2RjtPQUNBcUI7T0FFQzdFO09BS0F3QjtPQUtEb3hGO09BQ0FDO09BQ0NDO09BTUQ1dUY7T0FDQWtCO09BRUExRTtPQVVBcXlGO09BSUFDO09BSUNDO09BU0R4dkY7T0FDQXFCO09BRUN2RTtPQUtBZ0I7T0FLRDR4RjtPQUNBQztPQUVDQztPQVNEOXVGO09BSUFjO09BSUE3RTtPQVVBOHlGO09BSUFDO09BSUNDO09BVURodkY7T0FDQWM7T0FFQW11RjtPQUlBQztPQUlDQztPQVFEandGO09BQ0FxQjtPQUVDN0U7T0FLQTJCO09BS0QreEY7T0FDQUM7T0FDQ0M7T0FNREM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQ0M7T0FNRHh3RjtPQUNBcUI7T0FFQ2xGO09BS0FpQztPQUtEc3lGO09BQ0FDO09BQ0NDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTBDRDNsRjtPQVlBcFY7T0FDQUU7T0FPQTg2RjtPQUNBQztPQUNBMWdFO09BSUFwNkI7SUF2WEErNkY7SUFDQUM7SUFFQUM7SUFJQUM7SUFJQ0M7SUFVREM7SUFDQUM7SUFFQ0M7SUFLQUM7SUFLREM7SUFDQUM7SUFDQ0M7SUFNREM7SUFDQUM7SUFFQ0M7SUFLQUM7SUFLREM7SUFDQUM7SUFDQ0M7SUFNREM7SUFNQUM7SUFDQUM7SUFFQ0M7SUFLQUM7SUFLREM7SUFDQUM7SUFDQ0M7SUFNREM7SUFDQUM7SUFFQ0M7SUFHQUM7SUFLREM7SUFDQUM7SUFDQ0M7SUFNREM7SUFDQUM7SUFFQ0M7SUFLQUM7SUFLREM7SUFDQUM7SUFDQ0M7SUFNREM7SUFDQUM7SUFFQ0M7SUFLQUM7SUFLREM7SUFDQUM7SUFDQ0M7SUFNREM7SUFDQUM7SUFFQUM7SUFVQUM7SUFJQUM7SUFJQ0M7SUFTREM7SUFDQUM7SUFFQ0M7SUFLQUM7SUFLREM7SUFDQUM7SUFFQ0M7SUFTREM7SUFJQUM7SUFJQUM7SUFVQUM7SUFJQUM7SUFJQ0M7SUFVREM7SUFDQUM7SUFFQUM7SUFJQUM7SUFJQ0M7SUFRREM7SUFDQUM7SUFFQ0M7SUFLQUM7SUFLREM7SUFDQUM7SUFDQ0M7SUFNREM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQ0M7SUFNREM7SUFDQUM7SUFFQ0M7SUFLQUM7SUFLREM7SUFDQUM7SUFDQ0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMENEemhHO0lBWUE4WDtJQUNBRTtJQU9BcFg7SUFDQUU7SUFDQTRnRztJQUlBQzs7OztHQWdCRzs7Ozs7O09BamlCTHBwRztPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDtPQUFBRDs7OztPQTBKRXdvRztPQUNBQztPQUVBQztPQUlBQztPQUlDQztPQVVEQztPQUNBQztPQUVDQztPQUtBQztPQUtEQztPQUNBQztPQUNDQztPQU1EQztPQUNBQztPQUVDQztPQUtBQztPQUtEQztPQUNBQztPQUNDQztPQU1EQztPQU1BQztPQUNBQztPQUVDQztPQUtBQztPQUtEQztPQUNBQztPQUNDQztPQU1EQztPQUNBQztPQUVDQztPQUdBQztPQUtEQztPQUNBQztPQUNDQztPQU1EQztPQUNBQztPQUVDQztPQUtBQztPQUtEQztPQUNBQztPQUNDQztPQU1EQztPQUNBQztPQUVDQztPQUtBQztPQUtEQztPQUNBQztPQUNDQztPQU1EQztPQUNBQztPQUVBQztPQVVBQztPQUlBQztPQUlDQztPQVNEQztPQUNBQztPQUVDQztPQUtBQztPQUtEQztPQUNBQztPQUVDQztPQVNEQztPQUlBQztPQUlBQztPQVVBQztPQUlBQztPQUlDQztPQVVEQztPQUNBQztPQUVBQztPQUlBQztPQUlDQztPQVFEQztPQUNBQztPQUVDQztPQUtBQztPQUtEQztPQUNBQztPQUNDQztPQU1EQztPQUNBQztPQUNBQztPQUNBQztPQUNDQztPQU1EQztPQUNBQztPQUVDQztPQUtBQztPQUtEQztPQUNBQztPQUNDQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0EwQ0R6aEc7T0FZQThYO09BQ0FFO09BT0FwWDtPQUNBRTtPQUNBNGdHO09BSUFDOzs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCoqIFByaW1pdGl2ZXMgZm9yIHBvbHltb3JwaGljIGNvbXBhcmUuICopXG5cbigqXyBQb2x5bW9ycGhpYyBjb21waWxlciBwcmltaXRpdmVzIGNhbid0IGJlIGFsaWFzZXMgYXMgdGhpcyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gIGlubGluaW5nLiAoSWYgYWxpYXNlZCB3aXRob3V0IGEgdHlwZSBhbm5vdGF0aW9uLCB0aGUgY29tcGlsZXIgd291bGQgaW1wbGVtZW50IHRoZW1cbiAgdXNpbmcgdGhlIGdlbmVyaWMgY29kZSBkb2luZyBhIEMgY2FsbCwgYW5kIGl0J3MgdGhpcyBjb2RlIHRoYXQgd291bGQgYmUgaW5saW5lZC4pIEFzIGFcbiAgcmVzdWx0IHdlIGhhdmUgdG8gY29weSB0aGUgW2V4dGVybmFsIC4uLl0gZGVjbGFyYXRpb24gaGVyZS4gKilcbmV4dGVybmFsICggPCApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbmV4dGVybmFsICggPD0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuZXh0ZXJuYWwgKCA8PiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbmV4dGVybmFsICggPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbmV4dGVybmFsICggPiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbmV4dGVybmFsICggPj0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZXh0ZXJuYWwgYXNjZW5kaW5nIDogJ2EgLT4gJ2EgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5leHRlcm5hbCBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5leHRlcm5hbCBlcXVhbCA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5cbmxldCBkZXNjZW5kaW5nIHggeSA9IGNvbXBhcmUgeSB4XG5sZXQgbWF4ID0gQ2FtbC5tYXhcbmxldCBtaW4gPSBDYW1sLm1pblxuIiwiKCogVGhpcyBtb2R1bGUgaXMgaW5jbHVkZWQgaW4gW0ltcG9ydF0uICBJdCBpcyBhaW1lZCBhdCBtb2R1bGVzIHRoYXQgZGVmaW5lIHRoZSBzdGFuZGFyZFxuICAgY29tYmluYXRvcnMgZm9yIFtzZXhwX29mXSwgW29mX3NleHBdLCBbY29tcGFyZV0gYW5kIFtoYXNoXSBhbmQgYXJlIGluY2x1ZGVkIGluXG4gICBbSW1wb3J0XS4gKilcblxuaW5jbHVkZSAoXG4gIFNoYWRvd19zdGRsaWIgOlxuICAgIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgIGluY2x1ZGUgU2hhZG93X3N0ZGxpYlxuICBlbmRcbiAgd2l0aCB0eXBlICdhIHJlZiA6PSAnYSByZWZcbiAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgOj0gKCdhLCAnYiwgJ2MpIGZvcm1hdFxuICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0IDo9ICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NFxuICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgOj0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcbiAgKCogVGhlc2UgbW9kdWxlcyBhcmUgcmVkZWZpbmVkIGluIEJhc2UgKilcbiAgd2l0aCBtb2R1bGUgQXJyYXkgOj0gU2hhZG93X3N0ZGxpYi5BcnJheVxuICB3aXRoIG1vZHVsZSBBdG9taWMgOj0gU2hhZG93X3N0ZGxpYi5BdG9taWNcbiAgd2l0aCBtb2R1bGUgQm9vbCA6PSBTaGFkb3dfc3RkbGliLkJvb2xcbiAgd2l0aCBtb2R1bGUgQnVmZmVyIDo9IFNoYWRvd19zdGRsaWIuQnVmZmVyXG4gIHdpdGggbW9kdWxlIEJ5dGVzIDo9IFNoYWRvd19zdGRsaWIuQnl0ZXNcbiAgd2l0aCBtb2R1bGUgQ2hhciA6PSBTaGFkb3dfc3RkbGliLkNoYXJcbiAgd2l0aCBtb2R1bGUgRWl0aGVyIDo9IFNoYWRvd19zdGRsaWIuRWl0aGVyXG4gIHdpdGggbW9kdWxlIEZsb2F0IDo9IFNoYWRvd19zdGRsaWIuRmxvYXRcbiAgd2l0aCBtb2R1bGUgSGFzaHRibCA6PSBTaGFkb3dfc3RkbGliLkhhc2h0YmxcbiAgd2l0aCBtb2R1bGUgSW50IDo9IFNoYWRvd19zdGRsaWIuSW50XG4gIHdpdGggbW9kdWxlIEludDMyIDo9IFNoYWRvd19zdGRsaWIuSW50MzJcbiAgd2l0aCBtb2R1bGUgSW50NjQgOj0gU2hhZG93X3N0ZGxpYi5JbnQ2NFxuICB3aXRoIG1vZHVsZSBMYXp5IDo9IFNoYWRvd19zdGRsaWIuTGF6eVxuICB3aXRoIG1vZHVsZSBMaXN0IDo9IFNoYWRvd19zdGRsaWIuTGlzdFxuICB3aXRoIG1vZHVsZSBNYXAgOj0gU2hhZG93X3N0ZGxpYi5NYXBcbiAgd2l0aCBtb2R1bGUgTmF0aXZlaW50IDo9IFNoYWRvd19zdGRsaWIuTmF0aXZlaW50XG4gIHdpdGggbW9kdWxlIE9wdGlvbiA6PSBTaGFkb3dfc3RkbGliLk9wdGlvblxuICB3aXRoIG1vZHVsZSBQcmludGYgOj0gU2hhZG93X3N0ZGxpYi5QcmludGZcbiAgd2l0aCBtb2R1bGUgUXVldWUgOj0gU2hhZG93X3N0ZGxpYi5RdWV1ZVxuICB3aXRoIG1vZHVsZSBSYW5kb20gOj0gU2hhZG93X3N0ZGxpYi5SYW5kb21cbiAgd2l0aCBtb2R1bGUgUmVzdWx0IDo9IFNoYWRvd19zdGRsaWIuUmVzdWx0XG4gIHdpdGggbW9kdWxlIFNldCA6PSBTaGFkb3dfc3RkbGliLlNldFxuICB3aXRoIG1vZHVsZSBTdGFjayA6PSBTaGFkb3dfc3RkbGliLlN0YWNrXG4gIHdpdGggbW9kdWxlIFN0cmluZyA6PSBTaGFkb3dfc3RkbGliLlN0cmluZ1xuICB3aXRoIG1vZHVsZSBTeXMgOj0gU2hhZG93X3N0ZGxpYi5TeXNcbiAgd2l0aCBtb2R1bGUgVWNoYXIgOj0gU2hhZG93X3N0ZGxpYi5VY2hhclxuICB3aXRoIG1vZHVsZSBVbml0IDo9IFNoYWRvd19zdGRsaWIuVW5pdCkgW0BvY2FtbC53YXJuaW5nIFwiLTNcIl1cblxudHlwZSAnYSByZWYgPSAnYSBDYW1sLnJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cblxuKCogUmVzaHVmZmxlIFtDYW1sXSBzbyB0aGF0IHdlIGNob29zZSB0aGUgbW9kdWxlcyB1c2luZyBsYWJlbHMgd2hlbiBhdmFpbGFibGUuICopXG5tb2R1bGUgQ2FtbCA9IHN0cnVjdFxuXG4gIGluY2x1ZGUgQ2FtbFxuXG4gIG1vZHVsZSBBcmcgPSBDYW1sLkFyZyAoKiogQGNhbm9uaWNhbCBDYW1sLkFyZyAqKVxuXG4gIG1vZHVsZSBBcnJheSA9IENhbWwuU3RkTGFiZWxzLkFycmF5ICgqKiBAY2Fub25pY2FsIENhbWwuU3RkTGFiZWxzLkFycmF5ICopXG5cbiAgbW9kdWxlIEJvb2wgPSBDYW1sLkJvb2wgKCoqIEBjYW5vbmljYWwgQ2FtbC5Cb29sICopXG5cbiAgbW9kdWxlIEJ1ZmZlciA9IENhbWwuQnVmZmVyICgqKiBAY2Fub25pY2FsIENhbWwuQnVmZmVyICopXG5cbiAgbW9kdWxlIEJ5dGVzID0gQ2FtbC5TdGRMYWJlbHMuQnl0ZXMgKCoqIEBjYW5vbmljYWwgQ2FtbC5TdGRMYWJlbHMuQnl0ZXMgKilcblxuICBtb2R1bGUgQ2hhciA9IENhbWwuQ2hhciAoKiogQGNhbm9uaWNhbCBDYW1sLkNoYXIgKilcblxuICBtb2R1bGUgRXBoZW1lcm9uID0gQ2FtbC5FcGhlbWVyb24gKCoqIEBjYW5vbmljYWwgQ2FtbC5FcGhlbWVyb24gKilcblxuICBtb2R1bGUgRmxvYXQgPSBDYW1sLkZsb2F0ICgqKiBAY2Fub25pY2FsIENhbWwuRmxvYXQgKilcblxuICBtb2R1bGUgRm9ybWF0ID0gQ2FtbC5Gb3JtYXQgKCoqIEBjYW5vbmljYWwgQ2FtbC5Gb3JtYXQgKilcblxuICBtb2R1bGUgRnVuID0gQ2FtbC5GdW4gKCoqIEBjYW5vbmljYWwgQ2FtbC5GdW4gKilcblxuICBtb2R1bGUgR2MgPSBDYW1sLkdjICgqKiBAY2Fub25pY2FsIENhbWwuR2MgKilcblxuICBtb2R1bGUgSGFzaHRibCA9IENhbWwuTW9yZUxhYmVscy5IYXNodGJsICgqKiBAY2Fub25pY2FsIENhbWwuTW9yZUxhYmVscy5IYXNodGJsICopXG5cbiAgbW9kdWxlIEludDMyID0gQ2FtbC5JbnQzMiAoKiogQGNhbm9uaWNhbCBDYW1sLkludDMyICopXG5cbiAgbW9kdWxlIEludCA9IENhbWwuSW50ICgqKiBAY2Fub25pY2FsIENhbWwuSW50ICopXG5cbiAgbW9kdWxlIEludDY0ID0gQ2FtbC5JbnQ2NCAoKiogQGNhbm9uaWNhbCBDYW1sLkludDY0ICopXG5cbiAgbW9kdWxlIExhenkgPSBDYW1sLkxhenkgKCoqIEBjYW5vbmljYWwgQ2FtbC5MYXp5ICopXG5cbiAgbW9kdWxlIExleGluZyA9IENhbWwuTGV4aW5nICgqKiBAY2Fub25pY2FsIENhbWwuTGV4aW5nICopXG5cbiAgbW9kdWxlIExpc3QgPSBDYW1sLlN0ZExhYmVscy5MaXN0ICgqKiBAY2Fub25pY2FsIENhbWwuU3RkTGFiZWxzLkxpc3QgKilcblxuICBtb2R1bGUgTWFwID0gQ2FtbC5Nb3JlTGFiZWxzLk1hcCAoKiogQGNhbm9uaWNhbCBDYW1sLk1vcmVMYWJlbHMuTWFwICopXG5cbiAgbW9kdWxlIE5hdGl2ZWludCA9IENhbWwuTmF0aXZlaW50ICgqKiBAY2Fub25pY2FsIENhbWwuTmF0aXZlaW50ICopXG5cbiAgbW9kdWxlIE9iaiA9IENhbWwuT2JqICgqKiBAY2Fub25pY2FsIENhbWwuT2JqICopXG5cbiAgbW9kdWxlIE9wdGlvbiA9IENhbWwuT3B0aW9uICgqKiBAY2Fub25pY2FsIENhbWwuT3B0aW9uICopXG5cbiAgbW9kdWxlIFBhcnNpbmcgPSBDYW1sLlBhcnNpbmcgKCoqIEBjYW5vbmljYWwgQ2FtbC5QYXJzaW5nICopXG5cbiAgbW9kdWxlIFByaW50ZXhjID0gQ2FtbC5QcmludGV4YyAoKiogQGNhbm9uaWNhbCBDYW1sLlByaW50ZXhjICopXG5cbiAgbW9kdWxlIFByaW50ZiA9IENhbWwuUHJpbnRmICgqKiBAY2Fub25pY2FsIENhbWwuUHJpbnRmICopXG5cbiAgbW9kdWxlIFF1ZXVlID0gQ2FtbC5RdWV1ZSAoKiogQGNhbm9uaWNhbCBDYW1sLlF1ZXVlICopXG5cbiAgbW9kdWxlIFJhbmRvbSA9IENhbWwuUmFuZG9tICgqKiBAY2Fub25pY2FsIENhbWwuUmFuZG9tICopXG5cbiAgbW9kdWxlIFJlc3VsdCA9IENhbWwuUmVzdWx0ICgqKiBAY2Fub25pY2FsIENhbWwuUmVzdWx0ICopXG5cbiAgbW9kdWxlIFNjYW5mID0gQ2FtbC5TY2FuZiAoKiogQGNhbm9uaWNhbCBDYW1sLlNjYW5mICopXG5cbiAgbW9kdWxlIFNlcSA9IENhbWwuU2VxICgqKiBAY2Fub25pY2FsIENhbWwuU2VxICopXG5cbiAgbW9kdWxlIFNldCA9IENhbWwuTW9yZUxhYmVscy5TZXQgKCoqIEBjYW5vbmljYWwgQ2FtbC5Nb3JlTGFiZWxzLlNldCAqKVxuXG4gIG1vZHVsZSBTdGFjayA9IENhbWwuU3RhY2sgKCoqIEBjYW5vbmljYWwgQ2FtbC5TdGFjayAqKVxuXG4gIG1vZHVsZSBTdHJpbmcgPSBDYW1sLlN0ZExhYmVscy5TdHJpbmcgKCoqIEBjYW5vbmljYWwgQ2FtbC5TdGRMYWJlbHMuU3RyaW5nICopXG5cbiAgbW9kdWxlIFN5cyA9IENhbWwuU3lzICgqKiBAY2Fub25pY2FsIENhbWwuU3lzICopXG5cbiAgbW9kdWxlIFVjaGFyID0gQ2FtbC5VY2hhciAoKiogQGNhbm9uaWNhbCBDYW1sLlVjaGFyICopXG5cbiAgbW9kdWxlIFVuaXQgPSBDYW1sLlVuaXQgKCoqIEBjYW5vbmljYWwgQ2FtbC5Vbml0ICopXG5cbiAgZXhjZXB0aW9uIE5vdF9mb3VuZCA9IENhbWwuTm90X2ZvdW5kXG5lbmRcblxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcblxuKCogVGhlc2UgbmVlZCB0byBiZSBkZWNsYXJlZCBhcyBhbiBleHRlcm5hbCB0byBnZXQgdGhlIGxhenkgYmVoYXZpb3IgKilcbmV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5leHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcblxuKCogV2UgdXNlIFtPYmoubWFnaWNdIGhlcmUgYXMgb3RoZXIgaW1wbGVtZW50YXRpb25zIGdlbmVyYXRlIGEgY29uZGl0aW9uYWwganVtcCBhbmQgdGhlXG4gICBwZXJmb3JtYW5jZSBkaWZmZXJlbmNlIGlzIG5vdGljZWFibGUuICopXG5sZXQgYm9vbF90b19pbnQgKHggOiBib29sKSA6IGludCA9IENhbWwuT2JqLm1hZ2ljIHhcblxuKCogVGhpcyBuZWVkIHRvIGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIGZvciB0aGUgd2FybmluZ3MgdG8gd29yayBwcm9wZXJseSAqKVxuZXh0ZXJuYWwgaWdub3JlIDogXyAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxubGV0ICggIT0gKSA9IENhbWwuKCAhPSApXG5sZXQgKCAqICkgPSBDYW1sLiggKiApXG5sZXQgKCAqKiApID0gQ2FtbC4oICoqIClcbmxldCAoICouICkgPSBDYW1sLiggKi4gKVxubGV0ICggKyApID0gQ2FtbC4oICsgKVxubGV0ICggKy4gKSA9IENhbWwuKCArLiApXG5sZXQgKCAtICkgPSBDYW1sLiggLSApXG5sZXQgKCAtLiApID0gQ2FtbC4oIC0uIClcbmxldCAoIC8gKSA9IENhbWwuKCAvIClcbmxldCAoIC8uICkgPSBDYW1sLiggLy4gKVxuXG5tb2R1bGUgUG9seSA9IFBvbHkwICgqKiBAY2Fub25pY2FsIEJhc2UuUG9seSAqKVxuXG5tb2R1bGUgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICAoKiBEZWNsYXJlZCBhcyBleHRlcm5hbHMgc28gdGhhdCB0aGUgY29tcGlsZXIgc2tpcHMgdGhlIGNhbWxfYXBwbHlfWCB3cmFwcGluZyBldmVuIHdoZW5cbiAgICAgY29tcGlsaW5nIHdpdGhvdXQgY3Jvc3MgbGlicmFyeSBpbmxpbmluZy4gKilcbiAgZXh0ZXJuYWwgKCA9ICkgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVlcXVhbFwiXG4gIGV4dGVybmFsICggPD4gKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA8ICkgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG4gIGV4dGVybmFsICggPiApIDogaW50IC0+IGludCAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuICBleHRlcm5hbCAoIDw9ICkgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuICBleHRlcm5hbCAoID49ICkgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuICBleHRlcm5hbCBjb21wYXJlIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbiAgZXh0ZXJuYWwgZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5cbiAgbGV0IGFzY2VuZGluZyAoeCA6IGludCkgeSA9IGNvbXBhcmUgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogaW50KSB5ID0gY29tcGFyZSB5IHhcbiAgbGV0IG1heCAoeCA6IGludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBpbnQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbmluY2x1ZGUgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5tb2R1bGUgSW50MzJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IENhbWwuSW50MzIudCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICAoKiBEZWNsYXJlZCBhcyBleHRlcm5hbHMgc28gdGhhdCB0aGUgY29tcGlsZXIgc2tpcHMgdGhlIGNhbWxfYXBwbHlfWCB3cmFwcGluZyBldmVuIHdoZW5cbiAgICAgY29tcGlsaW5nIHdpdGhvdXQgY3Jvc3MgbGlicmFyeSBpbmxpbmluZy4gKilcbiAgZXh0ZXJuYWwgKCA9ICkgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGJvb2wgPSBcIiVlcXVhbFwiXG4gIGV4dGVybmFsICggPD4gKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA8ICkgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG4gIGV4dGVybmFsICggPiApIDogQ2FtbC5JbnQ2NC50IC0+IENhbWwuSW50NjQudCAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuICBleHRlcm5hbCAoIDw9ICkgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuICBleHRlcm5hbCAoID49ICkgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuICBleHRlcm5hbCBjb21wYXJlIDogQ2FtbC5JbnQ2NC50IC0+IENhbWwuSW50NjQudCAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbiAgZXh0ZXJuYWwgZXF1YWwgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5cbiAgbGV0IGFzY2VuZGluZyAoeCA6IENhbWwuSW50NjQudCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IENhbWwuSW50NjQudCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IG1heCAoeCA6IENhbWwuSW50NjQudCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBDYW1sLkludDY0LnQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbm1vZHVsZSBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIEJvb2xfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogYm9vbCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogYm9vbCkgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiBib29sKSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogYm9vbCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBib29sKSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiBib29sKSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogYm9vbCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBib29sKSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBib29sKSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IGJvb2wpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogYm9vbCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIENoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogY2hhcikgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogY2hhcikgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogY2hhcikgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiBjaGFyKSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogY2hhcikgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBjaGFyKSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBjaGFyKSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IGNoYXIpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogY2hhcikgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIFVjaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgaSB4ID0gQ2FtbC5VY2hhci50b19pbnQgeFxuICBsZXQgKCA8ICkgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPCApIChpIHgpIChpIHkpXG4gIGxldCAoIDw9ICkgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSAoaSB4KSAoaSB5KVxuICBsZXQgKCA8PiApICh4IDogQ2FtbC5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw+ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPSApICh4IDogQ2FtbC5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID0gKSAoaSB4KSAoaSB5KVxuICBsZXQgKCA+ICkgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPiApIChpIHgpIChpIHkpXG4gIGxldCAoID49ICkgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSAoaSB4KSAoaSB5KVxuXG4gIGxldCBhc2NlbmRpbmcgKHggOiBDYW1sLlVjaGFyLnQpIHkgPVxuICAgIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuYXNjZW5kaW5nIChpIHgpIChpIHkpXG4gIDs7XG5cbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBDYW1sLlVjaGFyLnQpIHkgPVxuICAgIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZGVzY2VuZGluZyAoaSB4KSAoaSB5KVxuICA7O1xuXG4gIGxldCBjb21wYXJlICh4IDogQ2FtbC5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlIChpIHgpIChpIHkpXG4gIGxldCBlcXVhbCAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWwgKGkgeCkgKGkgeSlcbiAgbGV0IG1heCAoeCA6IENhbWwuVWNoYXIudCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbm1vZHVsZSBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IGZsb2F0KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGZsb2F0KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGZsb2F0KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogZmxvYXQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogZmxvYXQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGZsb2F0KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IGZsb2F0KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IGZsb2F0KSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgU3RyaW5nX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogc3RyaW5nKSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogc3RyaW5nKSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IHN0cmluZykgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogc3RyaW5nKSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IHN0cmluZykgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBzdHJpbmcpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbm1vZHVsZSBCeXRlc19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IGJ5dGVzKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGJ5dGVzKSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGJ5dGVzKSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogYnl0ZXMpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogYnl0ZXMpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGJ5dGVzKSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IGJ5dGVzKSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IGJ5dGVzKSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG4oKiBUaGlzIG5lZWRzIHRvIGJlIGRlZmluZWQgYXMgYW4gZXh0ZXJuYWwgc28gdGhhdCB0aGUgY29tcGlsZXIgY2FuIHNwZWNpYWxpemUgaXQgYXMgYVxuICAgZGlyZWN0IHNldCBvciBjYW1sX21vZGlmeSAqKVxuZXh0ZXJuYWwgKCA6PSApIDogJ2EgcmVmIC0+ICdhIC0+IHVuaXQgPSBcIiVzZXRmaWVsZDBcIlxuXG4oKiBUaGVzZSBuZWVkIHRvIGJlIGRlZmluZWQgYXMgYW4gZXh0ZXJuYWwgb3RoZXJ3aXNlIHRoZSBjb21waWxlciB3b24ndCB1bmJveFxuICAgcmVmZXJlbmNlcyAqKVxuZXh0ZXJuYWwgKCAhICkgOiAnYSByZWYgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgcmVmIDogJ2EgLT4gJ2EgcmVmID0gXCIlbWFrZW11dGFibGVcIlxuXG5sZXQgKCBAICkgPSBDYW1sLiggQCApXG5sZXQgKCBeICkgPSBDYW1sLiggXiApXG5sZXQgKCB+LSApID0gQ2FtbC4oIH4tIClcbmxldCAoIH4tLiApID0gQ2FtbC4oIH4tLiApXG5sZXQgKCBhc3IgKSA9IENhbWwuKCBhc3IgKVxubGV0ICggbGFuZCApID0gQ2FtbC4oIGxhbmQgKVxubGV0IGxub3QgPSBDYW1sLmxub3RcbmxldCAoIGxvciApID0gQ2FtbC4oIGxvciApXG5sZXQgKCBsc2wgKSA9IENhbWwuKCBsc2wgKVxubGV0ICggbHNyICkgPSBDYW1sLiggbHNyIClcbmxldCAoIGx4b3IgKSA9IENhbWwuKCBseG9yIClcbmxldCAoIG1vZCApID0gQ2FtbC4oIG1vZCApXG5sZXQgYWJzID0gQ2FtbC5hYnNcbmxldCBmYWlsd2l0aCA9IENhbWwuZmFpbHdpdGhcbmxldCBmc3QgPSBDYW1sLmZzdFxubGV0IGludmFsaWRfYXJnID0gQ2FtbC5pbnZhbGlkX2FyZ1xubGV0IHNuZCA9IENhbWwuc25kXG5cbigqIFtyYWlzZV0gbmVlZHMgdG8gYmUgZGVmaW5lZCBhcyBhbiBleHRlcm5hbCBhcyB0aGUgY29tcGlsZXIgYXV0b21hdGljYWxseSByZXBsYWNlc1xuICAgJyVyYWlzZScgYnkgJyVyZXJhaXNlJyB3aGVuIGFwcHJvcHJpYXRlLiAqKVxuZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gXyA9IFwiJXJhaXNlXCJcblxubGV0IHBoeXNfZXF1YWwgPSBDYW1sLiggPT0gKVxubGV0IGRlY3IgPSBDYW1sLmRlY3JcbmxldCBpbmNyID0gQ2FtbC5pbmNyXG5cbigqIHVzZWQgYnkgc2V4cF9jb252LCB3aGljaCBmbG9hdDAgZGVwZW5kcyBvbiB0aHJvdWdoIG9wdGlvbiAqKVxubGV0IGZsb2F0X29mX3N0cmluZyA9IENhbWwuZmxvYXRfb2Zfc3RyaW5nXG5cbigqIFthbV90ZXN0aW5nXSBpcyB1c2VkIGluIGEgZmV3IHBsYWNlcyB0byBiZWhhdmUgZGlmZmVyZW50bHkgd2hlbiBpbiB0ZXN0aW5nIG1vZGUsIHN1Y2hcbiAgIGFzIGluIFtyYW5kb20ubWxdLiAgW2FtX3Rlc3RpbmddIGlzIGltcGxlbWVudGVkIHVzaW5nIFtCYXNlX2FtX3Rlc3RpbmddLCBhIHdlYWsgQy9qc1xuICAgcHJpbWl0aXZlIHRoYXQgcmV0dXJucyBbZmFsc2VdLCBidXQgd2hlbiBsaW5raW5nIGFuIGlubGluZS10ZXN0LXJ1bm5lciBleGVjdXRhYmxlLCBpc1xuICAgb3ZlcnJpZGRlbiBieSBhbm90aGVyIHByaW1pdGl2ZSB0aGF0IHJldHVybnMgW3RydWVdLiAqKVxuZXh0ZXJuYWwgYW1fdGVzdGluZyA6IHVuaXQgLT4gYm9vbCA9IFwiQmFzZV9hbV90ZXN0aW5nXCJcblxubGV0IGFtX3Rlc3RpbmcgPSBhbV90ZXN0aW5nICgpXG4iLCJvcGVuISBJbXBvcnQwXG5pbmNsdWRlIENhbWwuUHJpbnRmXG5cbigqKiBmYWlsd2l0aCwgaW52YWxpZF9hcmcsIGFuZCBleGl0IGFjY2VwdGluZyBwcmludGYncyBmb3JtYXQuICopXG5cbmxldCBmYWlsd2l0aGYgZm10ID0ga3NwcmludGYgKGZ1biBzICgpIC0+IGZhaWx3aXRoIHMpIGZtdFxubGV0IGludmFsaWRfYXJnZiBmbXQgPSBrc3ByaW50ZiAoZnVuIHMgKCkgLT4gaW52YWxpZF9hcmcgcykgZm10XG4iLCIoKiBbU3lzMF0gZGVmaW5lcyBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5IGRlZmluZWQgaW5cbiAgIHRlcm1zIG9mIFtDYW1sLlN5c10uICBbU3lzMF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZSBwYXJ0IG9mXG4gICBbQ2FtbC5TeXNdIHRoYXQgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyIHRoYW4gc3lzLm1sXG4gICBzaG91bGQgdXNlIFtDYW1sLlN5c10uIFtTeXMwXSBoYXMgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZVxuICAgZWFybHkgaW4gQmFzZSdzIGJ1aWxkIG9yZGVyLiAgQWxsIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSB0aGVzZVxuICAgZnVuY3Rpb25zIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5TeXNdIGluIGJ1aWxkIG9yZGVyIHNob3VsZCBkb1xuICAgW21vZHVsZSBTeXMgPSBTeXMwXS4gIERlZmluaW5nIFttb2R1bGUgU3lzID0gU3lzMF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZVxuICAgaXQgcHJldmVudHMgb2NhbWxkZXAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5TeXNdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5cbnR5cGUgYmFja2VuZF90eXBlID0gQ2FtbC5TeXMuYmFja2VuZF90eXBlID1cbiAgfCBOYXRpdmVcbiAgfCBCeXRlY29kZVxuICB8IE90aGVyIG9mIHN0cmluZ1xuXG5sZXQgYmFja2VuZF90eXBlID0gQ2FtbC5TeXMuYmFja2VuZF90eXBlXG5sZXQgaW50ZXJhY3RpdmUgPSBDYW1sLlN5cy5pbnRlcmFjdGl2ZVxubGV0IG9zX3R5cGUgPSBDYW1sLlN5cy5vc190eXBlXG5sZXQgdW5peCA9IENhbWwuU3lzLnVuaXhcbmxldCB3aW4zMiA9IENhbWwuU3lzLndpbjMyXG5sZXQgY3lnd2luID0gQ2FtbC5TeXMuY3lnd2luXG5sZXQgd29yZF9zaXplX2luX2JpdHMgPSBDYW1sLlN5cy53b3JkX3NpemVcbmxldCBpbnRfc2l6ZV9pbl9iaXRzID0gQ2FtbC5TeXMuaW50X3NpemVcbmxldCBiaWdfZW5kaWFuID0gQ2FtbC5TeXMuYmlnX2VuZGlhblxubGV0IG1heF9zdHJpbmdfbGVuZ3RoID0gQ2FtbC5TeXMubWF4X3N0cmluZ19sZW5ndGhcbmxldCBtYXhfYXJyYXlfbGVuZ3RoID0gQ2FtbC5TeXMubWF4X2FycmF5X2xlbmd0aFxubGV0IHJ1bnRpbWVfdmFyaWFudCA9IENhbWwuU3lzLnJ1bnRpbWVfdmFyaWFudFxubGV0IHJ1bnRpbWVfcGFyYW1ldGVycyA9IENhbWwuU3lzLnJ1bnRpbWVfcGFyYW1ldGVyc1xubGV0IGFyZ3YgPSBDYW1sLlN5cy5hcmd2XG5sZXQgZ2V0X2FyZ3YgKCkgPSBDYW1sLlN5cy5hcmd2XG5sZXQgb2NhbWxfdmVyc2lvbiA9IENhbWwuU3lzLm9jYW1sX3ZlcnNpb25cbmxldCBlbmFibGVfcnVudGltZV93YXJuaW5ncyA9IENhbWwuU3lzLmVuYWJsZV9ydW50aW1lX3dhcm5pbmdzXG5sZXQgcnVudGltZV93YXJuaW5nc19lbmFibGVkID0gQ2FtbC5TeXMucnVudGltZV93YXJuaW5nc19lbmFibGVkXG5cbmxldCBnZXRlbnZfZXhuIHZhciA9XG4gIHRyeSBDYW1sLlN5cy5nZXRlbnYgdmFyIHdpdGhcbiAgfCBDYW1sLk5vdF9mb3VuZCAtPlxuICAgIFByaW50Zi5mYWlsd2l0aGYgXCJTeXMuZ2V0ZW52X2V4bjogZW52aXJvbm1lbnQgdmFyaWFibGUgJXMgaXMgbm90IHNldFwiIHZhciAoKVxuOztcblxubGV0IGdldGVudiB2YXIgPVxuICBtYXRjaCBDYW1sLlN5cy5nZXRlbnYgdmFyIHdpdGhcbiAgfCB4IC0+IFNvbWUgeFxuICB8IGV4Y2VwdGlvbiBDYW1sLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5leHRlcm5hbCBvcGFxdWVfaWRlbnRpdHkgOiAnYSAtPiAnYSA9IFwiJW9wYXF1ZVwiXG5cbmV4Y2VwdGlvbiBCcmVhayA9IENhbWwuU3lzLkJyZWFrXG4iLCIoKiBbQXJyYXkwXSBkZWZpbmVzIGFycmF5IGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHkgZGVmaW5lZCBpbiB0ZXJtc1xuICAgb2YgW0NhbWwuQXJyYXldLiAgW0FycmF5MF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZSBwYXJ0IG9mIFtDYW1sLkFycmF5XVxuICAgdGhhdCBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXIgdGhhbiBhcnJheTAubWwgc2hvdWxkIHVzZSBbQ2FtbC5BcnJheV0uXG4gICBbQXJyYXkwXSBoYXMgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuICBBbGxcbiAgIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBhcnJheXMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLkFycmF5XSBpbiBidWlsZCBvcmRlciBzaG91bGRcbiAgIGRvIFttb2R1bGUgQXJyYXkgPSBBcnJheTBdLiAgVGhpcyBpbmNsdWRlcyB1c2VzIG9mIHN1YnNjcmlwdCBzeW50YXggKFt4LihpKV0sIFt4LihpKSA8LVxuICAgZV0pLCB3aGljaCB0aGUgT0NhbWwgcGFyc2VyIGRlc3VnYXJzIGludG8gY2FsbHMgdG8gW0FycmF5LmdldF0gYW5kIFtBcnJheS5zZXRdLlxuICAgRGVmaW5pbmcgW21vZHVsZSBBcnJheSA9IEFycmF5MF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdCBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tXG4gICBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5BcnJheV0uICopXG5cbm9wZW4hIEltcG9ydDBcbm1vZHVsZSBTeXMgPSBTeXMwXG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5cbm1vZHVsZSBBcnJheSA9IHN0cnVjdFxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gJ2EgLT4gJ2EgYXJyYXkgPSBcImNhbWxfbWFrZV92ZWN0XCJcbiAgZXh0ZXJuYWwgY3JlYXRlX2Zsb2F0X3VuaW5pdGlhbGl6ZWQgOiBpbnQgLT4gZmxvYXQgYXJyYXkgPSBcImNhbWxfbWFrZV9mbG9hdF92ZWN0XCJcbiAgZXh0ZXJuYWwgZ2V0IDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBsZW5ndGggOiAnYSBhcnJheSAtPiBpbnQgPSBcIiVhcnJheV9sZW5ndGhcIlxuICBleHRlcm5hbCBzZXQgOiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldCA6ICdhIGFycmF5IC0+IGludCAtPiAnYSA9IFwiJWFycmF5X3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVhcnJheV91bnNhZmVfc2V0XCJcblxuICBleHRlcm5hbCB1bnNhZmVfYmxpdFxuICAgIDogIHNyYzonYSBhcnJheVxuICAgIC0+IHNyY19wb3M6aW50XG4gICAgLT4gZHN0OidhIGFycmF5XG4gICAgLT4gZHN0X3BvczppbnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gdW5pdFxuICAgID0gXCJjYW1sX2FycmF5X2JsaXRcIlxuZW5kXG5cbmluY2x1ZGUgQXJyYXlcblxubGV0IG1heF9sZW5ndGggPSBTeXMubWF4X2FycmF5X2xlbmd0aFxuXG5sZXQgY3JlYXRlIH5sZW4geCA9XG4gIHRyeSBjcmVhdGUgbGVuIHggd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPiBpbnZhbGlkX2FyZ2YgXCJBcnJheS5jcmVhdGUgfmxlbjolZDogaW52YWxpZCBsZW5ndGhcIiBsZW4gKClcbjs7XG5cbmxldCBjcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCB+bGVuID1cbiAgdHJ5IGNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIGxlbiB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+XG4gICAgaW52YWxpZF9hcmdmIFwiQXJyYXkuY3JlYXRlX2Zsb2F0X3VuaW5pdGlhbGl6ZWQgfmxlbjolZDogaW52YWxpZCBsZW5ndGhcIiBsZW4gKClcbjs7XG5cbmxldCBhcHBlbmQgPSBDYW1sLkFycmF5LmFwcGVuZFxubGV0IGJsaXQgPSBDYW1sLkFycmF5LmJsaXRcbmxldCBjb25jYXQgPSBDYW1sLkFycmF5LmNvbmNhdFxubGV0IGNvcHkgPSBDYW1sLkFycmF5LmNvcHlcbmxldCBmaWxsID0gQ2FtbC5BcnJheS5maWxsXG5sZXQgaW5pdCA9IENhbWwuQXJyYXkuaW5pdFxubGV0IG1ha2VfbWF0cml4ID0gQ2FtbC5BcnJheS5tYWtlX21hdHJpeFxubGV0IG9mX2xpc3QgPSBDYW1sLkFycmF5Lm9mX2xpc3RcbmxldCBzdWIgPSBDYW1sLkFycmF5LnN1YlxubGV0IHRvX2xpc3QgPSBDYW1sLkFycmF5LnRvX2xpc3RcblxuKCogVGhlc2UgYXJlIGV0YSBleHBhbmRlZCBpbiBvcmRlciB0byBwZXJtdXRlIHBhcmFtZXRlciBvcmRlciB0byBmb2xsb3cgQmFzZVxuICAgY29udmVudGlvbnMuICopXG5sZXQgZm9sZCB0IH5pbml0IH5mID0gQ2FtbC5BcnJheS5mb2xkX2xlZnQgdCB+aW5pdCB+ZlxubGV0IGZvbGRfcmlnaHQgdCB+ZiB+aW5pdCA9IENhbWwuQXJyYXkuZm9sZF9yaWdodCB0IH5mIH5pbml0XG5sZXQgaXRlciB0IH5mID0gQ2FtbC5BcnJheS5pdGVyIHQgfmZcbmxldCBpdGVyaSB0IH5mID0gQ2FtbC5BcnJheS5pdGVyaSB0IH5mXG5sZXQgbWFwIHQgfmYgPSBDYW1sLkFycmF5Lm1hcCB0IH5mXG5sZXQgbWFwaSB0IH5mID0gQ2FtbC5BcnJheS5tYXBpIHQgfmZcbmxldCBzdGFibGVfc29ydCB0IH5jb21wYXJlID0gQ2FtbC5BcnJheS5zdGFibGVfc29ydCB0IH5jbXA6Y29tcGFyZVxuXG5sZXQgc3dhcCB0IGkgaiA9XG4gIGxldCBlbHRfaSA9IHQuKGkpIGluXG4gIGxldCBlbHRfaiA9IHQuKGopIGluXG4gIHVuc2FmZV9zZXQgdCBpIGVsdF9qO1xuICB1bnNhZmVfc2V0IHQgaiBlbHRfaVxuOztcbiIsIigqIFtDaGFyMF0gZGVmaW5lcyBjaGFyIGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHkgZGVmaW5lZCBpbiB0ZXJtcyBvZlxuICAgW0NhbWwuQ2hhcl0uICBbQ2hhcjBdIGlzIGludGVuZGVkIHRvIGNvbXBsZXRlbHkgZXhwcmVzcyB0aGUgcGFydCBvZiBbQ2FtbC5DaGFyXSB0aGF0XG4gICBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXIgdGhhbiBjaGFyMC5tbCBzaG91bGQgdXNlIFtDYW1sLkNoYXJdLlxuICAgW0NoYXIwXSBoYXMgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuICBBbGxcbiAgIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBjaGFycyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuQ2hhcl0gaW4gYnVpbGQgb3JkZXIgc2hvdWxkIGRvXG4gICBbbW9kdWxlIENoYXIgPSBDaGFyMF0uICBEZWZpbmluZyBbbW9kdWxlIENoYXIgPSBDaGFyMF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdFxuICAgcHJldmVudHMgb2NhbWxkZXAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5DaGFyXS4gKilcblxub3BlbiEgSW1wb3J0MFxuXG5sZXQgZmFpbHdpdGhmID0gUHJpbnRmLmZhaWx3aXRoZlxubGV0IGVzY2FwZWQgPSBDYW1sLkNoYXIuZXNjYXBlZFxubGV0IGxvd2VyY2FzZSA9IENhbWwuQ2hhci5sb3dlcmNhc2VfYXNjaWlcbmxldCB0b19pbnQgPSBDYW1sLkNoYXIuY29kZVxubGV0IHVuc2FmZV9vZl9pbnQgPSBDYW1sLkNoYXIudW5zYWZlX2NoclxubGV0IHVwcGVyY2FzZSA9IENhbWwuQ2hhci51cHBlcmNhc2VfYXNjaWlcblxuKCogV2UgdXNlIG91ciBvd24gcmFuZ2UgdGVzdCB3aGVuIGNvbnZlcnRpbmcgaW50ZWdlcnMgdG8gY2hhcnMgcmF0aGVyIHRoYW5cbiAgIGNhbGxpbmcgW0NhbWwuQ2hhci5jaHJdIGJlY2F1c2UgaXQncyBzaW1wbGUgYW5kIGl0IHNhdmVzIHVzIGEgZnVuY3Rpb24gY2FsbFxuICAgYW5kIHRoZSB0cnktd2l0aCAoZXhjZXB0aW9ucyBjb3N0LCBlc3BlY2lhbGx5IGluIHRoZSB3b3JsZCB3aXRoIGJhY2t0cmFjZXMpLiAqKVxubGV0IGludF9pc19vayBpID0gMCA8PSBpICYmIGkgPD0gMjU1XG5sZXQgbWluX3ZhbHVlID0gdW5zYWZlX29mX2ludCAwXG5sZXQgbWF4X3ZhbHVlID0gdW5zYWZlX29mX2ludCAyNTVcbmxldCBvZl9pbnQgaSA9IGlmIGludF9pc19vayBpIHRoZW4gU29tZSAodW5zYWZlX29mX2ludCBpKSBlbHNlIE5vbmVcblxubGV0IG9mX2ludF9leG4gaSA9XG4gIGlmIGludF9pc19vayBpXG4gIHRoZW4gdW5zYWZlX29mX2ludCBpXG4gIGVsc2UgZmFpbHdpdGhmIFwiQ2hhci5vZl9pbnRfZXhuIGdvdCBpbnRlZ2VyIG91dCBvZiByYW5nZTogJWRcIiBpICgpXG47O1xuXG5sZXQgZXF1YWwgKHQxIDogY2hhcikgdDIgPSBQb2x5LmVxdWFsIHQxIHQyXG4iLCIoKiBbSW50MF0gZGVmaW5lcyBpbnRlZ2VyIGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHlcbiAgIGRlZmluZWQgaW4gdGVybXMgb2YgW0NhbWxdLiBbSW50MF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZVxuICAgcGFydCBvZiBbQ2FtbF0gdGhhdCBbQmFzZV0gdXNlcyBmb3IgaW50ZWdlcnMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyXG4gICB0aGFuIGludDAubWwgc2hvdWxkIHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdGhyb3VnaCBbQ2FtbF0uIFtJbnQwXSBoYXNcbiAgIGZldyBkZXBlbmRlbmNpZXMsIGFuZCBzbyBpcyBhdmFpbGFibGUgZWFybHkgaW4gQmFzZSdzIGJ1aWxkIG9yZGVyLlxuXG4gICBBbGwgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIGludHMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLkludF0gaW4gYnVpbGRcbiAgIG9yZGVyIHNob3VsZCBkbzpcblxuICAge1tcbiAgICAgbW9kdWxlIEludCAgPSBJbnQwXG4gICBdfVxuXG4gICBEZWZpbmluZyBbbW9kdWxlIEludCA9IEludDBdIGlzIGFsc28gbmVjZXNzYXJ5IGJlY2F1c2UgaXQgcHJldmVudHMgb2NhbWxkZXBcbiAgIGZyb20gbWlzdGFrZW5seSBjYXVzaW5nIGEgZmlsZSB0byBkZXBlbmQgb24gW0Jhc2UuSW50XS4gKilcblxubGV0IHRvX3N0cmluZyA9IENhbWwuc3RyaW5nX29mX2ludFxubGV0IG9mX3N0cmluZyA9IENhbWwuaW50X29mX3N0cmluZ1xubGV0IHRvX2Zsb2F0ID0gQ2FtbC5mbG9hdF9vZl9pbnRcbmxldCBvZl9mbG9hdCA9IENhbWwuaW50X29mX2Zsb2F0XG5sZXQgbWF4X3ZhbHVlID0gQ2FtbC5tYXhfaW50XG5sZXQgbWluX3ZhbHVlID0gQ2FtbC5taW5faW50XG5sZXQgc3VjYyA9IENhbWwuc3VjY1xuIiwiKCogW0xpc3QwXSBkZWZpbmVzIGxpc3QgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluIHRlcm1zIG9mXG4gICBbQ2FtbC5MaXN0XS4gIFtMaXN0MF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZSBwYXJ0IG9mIFtDYW1sLkxpc3RdIHRoYXRcbiAgIFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIGxpc3QwLm1sIHNob3VsZCB1c2UgW0NhbWwuTGlzdF0uXG4gICBbTGlzdDBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci4gIEFsbFxuICAgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIGxpc3RzIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5MaXN0XSBpbiBidWlsZCBvcmRlciBzaG91bGQgZG9cbiAgIFttb2R1bGUgTGlzdCA9IExpc3QwXS4gIERlZmluaW5nIFttb2R1bGUgTGlzdCA9IExpc3QwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0XG4gICBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLkxpc3RdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5cbmxldCBoZF9leG4gPSBDYW1sLkxpc3QuaGRcbmxldCBsZW5ndGggPSBDYW1sLkxpc3QubGVuZ3RoXG5sZXQgcmV2X2FwcGVuZCA9IENhbWwuTGlzdC5yZXZfYXBwZW5kXG5sZXQgdGxfZXhuID0gQ2FtbC5MaXN0LnRsXG5sZXQgdW56aXAgPSBDYW1sLkxpc3Quc3BsaXRcblxuKCogVGhlc2UgYXJlIGV0YSBleHBhbmRlZCBpbiBvcmRlciB0byBwZXJtdXRlIHBhcmFtZXRlciBvcmRlciB0byBmb2xsb3cgQmFzZVxuICAgY29udmVudGlvbnMuICopXG5sZXQgZXhpc3RzIHQgfmYgPSBDYW1sLkxpc3QuZXhpc3RzIHQgfmZcbmxldCBleGlzdHMyX29rIGwxIGwyIH5mID0gQ2FtbC5MaXN0LmV4aXN0czIgbDEgbDIgfmZcbmxldCBmb2xkIHQgfmluaXQgfmYgPSBDYW1sLkxpc3QuZm9sZF9sZWZ0IHQgfmYgfmluaXRcbmxldCBmb2xkMl9vayBsMSBsMiB+aW5pdCB+ZiA9IENhbWwuTGlzdC5mb2xkX2xlZnQyIGwxIGwyIH5pbml0IH5mXG5sZXQgZm9yX2FsbCB0IH5mID0gQ2FtbC5MaXN0LmZvcl9hbGwgdCB+ZlxubGV0IGZvcl9hbGwyX29rIGwxIGwyIH5mID0gQ2FtbC5MaXN0LmZvcl9hbGwyIGwxIGwyIH5mXG5sZXQgaXRlciB0IH5mID0gQ2FtbC5MaXN0Lml0ZXIgdCB+ZlxubGV0IGl0ZXIyX29rIGwxIGwyIH5mID0gQ2FtbC5MaXN0Lml0ZXIyIGwxIGwyIH5mXG5sZXQgbm9udGFpbF9tYXAgdCB+ZiA9IENhbWwuTGlzdC5tYXAgdCB+ZlxubGV0IG5vbnRhaWxfbWFwaSB0IH5mID0gQ2FtbC5MaXN0Lm1hcGkgdCB+ZlxubGV0IHBhcnRpdGlvbiB0IH5mID0gQ2FtbC5MaXN0LnBhcnRpdGlvbiB0IH5mXG5sZXQgcmV2X21hcCB0IH5mID0gQ2FtbC5MaXN0LnJldl9tYXAgdCB+ZlxubGV0IHJldl9tYXAyX29rIGwxIGwyIH5mID0gQ2FtbC5MaXN0LnJldl9tYXAyIGwxIGwyIH5mXG5sZXQgc29ydCBsIH5jb21wYXJlID0gQ2FtbC5MaXN0LnNvcnQgbCB+Y21wOmNvbXBhcmVcbmxldCBzdGFibGVfc29ydCBsIH5jb21wYXJlID0gQ2FtbC5MaXN0LnN0YWJsZV9zb3J0IGwgfmNtcDpjb21wYXJlXG5cbmxldCByZXYgPSBmdW5jdGlvblxuICB8IChbXSB8IFsgXyBdKSBhcyByZXMgLT4gcmVzXG4gIHwgeCA6OiB5IDo6IHJlc3QgLT4gcmV2X2FwcGVuZCByZXN0IFsgeTsgeCBdXG47O1xuXG5sZXQgZm9sZF9yaWdodCBsIH5mIH5pbml0ID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gaW5pdCAoKiBhdm9pZCB0aGUgYWxsb2NhdGlvbiBvZiBbfmZdIGJlbG93ICopXG4gIHwgXyAtPiBmb2xkIH5mOihmdW4gYSBiIC0+IGYgYiBhKSB+aW5pdCAocmV2IGwpXG47O1xuIiwiKCpcbiAgIFRoaXMgaXMgdGhlIGludGVyZmFjZSB0byB0aGUgcnVudGltZSBzdXBwb3J0IGZvciBbcHB4X2hhc2hdLlxuXG4gICBUaGUgW3BweF9oYXNoXSBzeW50YXggZXh0ZW5zaW9uIHN1cHBvcnRzOiBbQEBkZXJpdmluZyBoYXNoXSBhbmQgWyVoYXNoX2ZvbGQ6IFRZUEVdIGFuZFxuICAgWyVoYXNoOiBUWVBFXVxuXG4gICBGb3IgdHlwZSBbdF0gYSBmdW5jdGlvbiBbaGFzaF9mb2xkX3RdIG9mIHR5cGUgW0hhc2guc3RhdGUgLT4gdCAtPiBIYXNoLnN0YXRlXSBpc1xuICAgZ2VuZXJhdGVkLlxuXG4gICBUaGUgZ2VuZXJhdGVkIFtoYXNoX2ZvbGRfPFQ+XSBmdW5jdGlvbiBpcyBjb21wb3NpdGlvbmFsLCBmb2xsb3dpbmcgdGhlIHN0cnVjdHVyZSBvZiB0aGVcbiAgIHR5cGU7IGFsbG93aW5nIHVzZXIgb3ZlcnJpZGVzIGF0IGV2ZXJ5IGxldmVsLiBUaGlzIGlzIGluIGNvbnRyYXN0IHRvIG9jYW1sJ3MgYnVpbHRpblxuICAgcG9seW1vcnBoaWMgaGFzaGluZyBbSGFzaHRibC5oYXNoXSB3aGljaCBpZ25vcmVzIHVzZXIgb3ZlcnJpZGVzLlxuXG4gICBUaGUgZ2VuZXJhdG9yIGFsc28gcHJvdmlkZXMgYSBkaXJlY3QgaGFzaC1mdW5jdGlvbiBbaGFzaF0gKG5hbWVkIFtoYXNoXzxUPl0gd2hlbiA8VD4gIT1cbiAgIFwidFwiKSBvZiB0eXBlOiBbdCAtPiBIYXNoLmhhc2hfdmFsdWVdLlxuXG4gICBUaGUgZm9sZGluZyBoYXNoIGZ1bmN0aW9uIGNhbiBiZSBhY2Nlc3NlZCBhcyBbJWhhc2hfZm9sZDogVFlQRV1cbiAgIFRoZSBkaXJlY3QgaGFzaCBmdW5jdGlvbiBjYW4gYmUgYWNjZXNzZWQgYXMgWyVoYXNoOiBUWVBFXVxuKilcblxub3BlbiEgSW1wb3J0MFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5tb2R1bGUgQ2hhciA9IENoYXIwXG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBIYXNoX2ludGZcblxuKCoqIEJ1aWx0aW4gZm9sZGluZy1zdHlsZSBoYXNoIGZ1bmN0aW9ucywgYWJzdHJhY3RlZCBvdmVyIFtIYXNoX2ludGYuU10gKilcbm1vZHVsZSBGb2xkaW5nIChIYXNoIDogSGFzaF9pbnRmLlMpIDpcbiAgSGFzaF9pbnRmLkJ1aWx0aW5faW50ZlxuICB3aXRoIHR5cGUgc3RhdGUgPSBIYXNoLnN0YXRlXG4gICBhbmQgdHlwZSBoYXNoX3ZhbHVlID0gSGFzaC5oYXNoX3ZhbHVlID0gc3RydWN0XG4gIHR5cGUgc3RhdGUgPSBIYXNoLnN0YXRlXG4gIHR5cGUgaGFzaF92YWx1ZSA9IEhhc2guaGFzaF92YWx1ZVxuICB0eXBlICdhIGZvbGRlciA9IHN0YXRlIC0+ICdhIC0+IHN0YXRlXG5cbiAgbGV0IGhhc2hfZm9sZF91bml0IHMgKCkgPSBzXG4gIGxldCBoYXNoX2ZvbGRfaW50ID0gSGFzaC5mb2xkX2ludFxuICBsZXQgaGFzaF9mb2xkX2ludDY0ID0gSGFzaC5mb2xkX2ludDY0XG4gIGxldCBoYXNoX2ZvbGRfZmxvYXQgPSBIYXNoLmZvbGRfZmxvYXRcbiAgbGV0IGhhc2hfZm9sZF9zdHJpbmcgPSBIYXNoLmZvbGRfc3RyaW5nXG4gIGxldCBhc19pbnQgZiBzIHggPSBoYXNoX2ZvbGRfaW50IHMgKGYgeClcblxuICAoKiBUaGlzIGlnbm9yZXMgdGhlIHNpZ24gYml0IG9uIDMyLWJpdCBhcmNoaXRlY3R1cmVzLCBidXQgaXQncyB1bmxpa2VseSB0byBsZWFkIHRvXG4gICAgIGZyZXF1ZW50IGNvbGxpc2lvbnMgKG1pbl92YWx1ZSBjb2xsaWRpbmcgd2l0aCAwIGlzIHRoZSBtb3N0IGxpa2VseSBvbmUpLiAgKilcbiAgbGV0IGhhc2hfZm9sZF9pbnQzMiA9IGFzX2ludCBDYW1sLkludDMyLnRvX2ludFxuICBsZXQgaGFzaF9mb2xkX2NoYXIgPSBhc19pbnQgQ2hhci50b19pbnRcblxuICBsZXQgaGFzaF9mb2xkX2Jvb2wgPVxuICAgIGFzX2ludCAoZnVuY3Rpb25cbiAgICAgIHwgdHJ1ZSAtPiAxXG4gICAgICB8IGZhbHNlIC0+IDApXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9uYXRpdmVpbnQgcyB4ID0gaGFzaF9mb2xkX2ludDY0IHMgKENhbWwuSW50NjQub2ZfbmF0aXZlaW50IHgpXG5cbiAgbGV0IGhhc2hfZm9sZF9vcHRpb24gaGFzaF9mb2xkX2VsZW0gcyA9IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IGhhc2hfZm9sZF9pbnQgcyAwXG4gICAgfCBTb21lIHggLT4gaGFzaF9mb2xkX2VsZW0gKGhhc2hfZm9sZF9pbnQgcyAxKSB4XG4gIDs7XG5cbiAgbGV0IHJlYyBoYXNoX2ZvbGRfbGlzdF9ib2R5IGhhc2hfZm9sZF9lbGVtIHMgbGlzdCA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBzXG4gICAgfCB4IDo6IHhzIC0+IGhhc2hfZm9sZF9saXN0X2JvZHkgaGFzaF9mb2xkX2VsZW0gKGhhc2hfZm9sZF9lbGVtIHMgeCkgeHNcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX2xpc3QgaGFzaF9mb2xkX2VsZW0gcyBsaXN0ID1cbiAgICAoKiBUaGUgW2xlbmd0aF0gb2YgdGhlIGxpc3QgbXVzdCBiZSBpbmNvcnBvcmF0ZWQgaW50byB0aGUgaGFzaC1zdGF0ZSBzbyB2YWx1ZXMgb2ZcbiAgICAgICB0eXBlcyBzdWNoIGFzIFt1bml0IGxpc3RdIC0gKFtdLCBbKCldLCBbKCk7KCldLC4uKSBhcmUgaGFzaGVkIGRpZmZlcmVudGx5LiAqKVxuICAgICgqIFRoZSBbbGVuZ3RoXSBtdXN0IGNvbWUgYmVmb3JlIHRoZSBlbGVtZW50cyB0byBhdm9pZCBhIHZpb2xhdGlvbiBvZiB0aGUgcnVsZVxuICAgICAgIGVuZm9yY2VkIGJ5IFBlcmZlY3RfaGFzaC4gKilcbiAgICBsZXQgcyA9IGhhc2hfZm9sZF9pbnQgcyAoTGlzdC5sZW5ndGggbGlzdCkgaW5cbiAgICBsZXQgcyA9IGhhc2hfZm9sZF9saXN0X2JvZHkgaGFzaF9mb2xkX2VsZW0gcyBsaXN0IGluXG4gICAgc1xuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfbGF6eV90IGhhc2hfZm9sZF9lbGVtIHMgeCA9IGhhc2hfZm9sZF9lbGVtIHMgKENhbWwuTGF6eS5mb3JjZSB4KVxuICBsZXQgaGFzaF9mb2xkX3JlZl9mcm96ZW4gaGFzaF9mb2xkX2VsZW0gcyB4ID0gaGFzaF9mb2xkX2VsZW0gcyAheFxuXG4gIGxldCByZWMgaGFzaF9mb2xkX2FycmF5X2Zyb3plbl9pIGhhc2hfZm9sZF9lbGVtIHMgYXJyYXkgaSA9XG4gICAgaWYgaSA9IEFycmF5Lmxlbmd0aCBhcnJheVxuICAgIHRoZW4gc1xuICAgIGVsc2UgKFxuICAgICAgbGV0IGUgPSBBcnJheS51bnNhZmVfZ2V0IGFycmF5IGkgaW5cbiAgICAgIGhhc2hfZm9sZF9hcnJheV9mcm96ZW5faSBoYXNoX2ZvbGRfZWxlbSAoaGFzaF9mb2xkX2VsZW0gcyBlKSBhcnJheSAoaSArIDEpKVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfYXJyYXlfZnJvemVuIGhhc2hfZm9sZF9lbGVtIHMgYXJyYXkgPVxuICAgIGhhc2hfZm9sZF9hcnJheV9mcm96ZW5faVxuICAgICAgKCogW2xlbmd0aF0gbXVzdCBiZSBpbmNvcnBvcmF0ZWQgZm9yIGFycmF5cywgYXMgaXQgaXMgZm9yIGxpc3RzLiBTZWUgY29tbWVudCBhYm92ZSAqKVxuICAgICAgaGFzaF9mb2xkX2VsZW1cbiAgICAgIChoYXNoX2ZvbGRfaW50IHMgKEFycmF5Lmxlbmd0aCBhcnJheSkpXG4gICAgICBhcnJheVxuICAgICAgMFxuICA7O1xuXG4gICgqIHRoZSBkdXBsaWNhdGlvbiBoZXJlIGlzIGJlY2F1c2Ugd2UgdGhpbmtcbiAgICAgb2NhbWwgY2FuJ3QgZWxpbWluYXRlIGluZGlyZWN0IGZ1bmN0aW9uIGNhbGxzIG90aGVyd2lzZS4gKilcbiAgbGV0IGhhc2hfbmF0aXZlaW50IHggPVxuICAgIEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9uYXRpdmVpbnQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICA7O1xuXG4gIGxldCBoYXNoX2ludDY0IHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfaW50NjQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF9pbnQzMiB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2ludDMyIChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbiAgbGV0IGhhc2hfY2hhciB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2NoYXIgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF9pbnQgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9pbnQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF9ib29sIHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfYm9vbCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG5cbiAgbGV0IGhhc2hfc3RyaW5nIHggPVxuICAgIEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9zdHJpbmcgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICA7O1xuXG4gIGxldCBoYXNoX2Zsb2F0IHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfZmxvYXQgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF91bml0IHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfdW5pdCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG5lbmRcblxubW9kdWxlIEYgKEhhc2ggOiBIYXNoX2ludGYuUykgOlxuICBIYXNoX2ludGYuRnVsbFxuICB3aXRoIHR5cGUgaGFzaF92YWx1ZSA9IEhhc2guaGFzaF92YWx1ZVxuICAgYW5kIHR5cGUgc3RhdGUgPSBIYXNoLnN0YXRlXG4gICBhbmQgdHlwZSBzZWVkID0gSGFzaC5zZWVkID0gc3RydWN0XG4gIGluY2x1ZGUgSGFzaFxuXG4gIHR5cGUgJ2EgZm9sZGVyID0gc3RhdGUgLT4gJ2EgLT4gc3RhdGVcblxuICBsZXQgY3JlYXRlID9zZWVkICgpID0gcmVzZXQgP3NlZWQgKGFsbG9jICgpKVxuICBsZXQgb2ZfZm9sZCBoYXNoX2ZvbGRfdCB0ID0gZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF90IChjcmVhdGUgKCkpIHQpXG5cbiAgbW9kdWxlIEJ1aWx0aW4gPSBGb2xkaW5nIChIYXNoKVxuXG4gIGxldCBydW4gP3NlZWQgZm9sZGVyIHggPVxuICAgIEhhc2guZ2V0X2hhc2hfdmFsdWUgKGZvbGRlciAoSGFzaC5yZXNldCA/c2VlZCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIDs7XG5lbmRcblxubW9kdWxlIEludGVybmFsaGFzaCA6IHNpZ1xuICBpbmNsdWRlXG4gICAgSGFzaF9pbnRmLlNcbiAgICB3aXRoIHR5cGUgc3RhdGUgPSBCYXNlX2ludGVybmFsaGFzaF90eXBlcy5zdGF0ZVxuICAgICAoKiBXZSBnaXZlIGEgY29uY3JldGUgdHlwZSBmb3IgW3N0YXRlXSwgYWxiZWl0IG9ubHkgcGFydGlhbGx5IGV4cG9zZWQgKHNlZVxuICAgICAgICBCYXNlX2ludGVybmFsaGFzaF90eXBlcyksIHNvIHRoYXQgaXQgdW5pZmllcyB3aXRoIHRoZSBzYW1lIHR5cGUgaW4gW0Jhc2VfYm9vdF0sXG4gICAgICAgIGFuZCB0byBhbGxvdyBvcHRpbWl6YXRpb25zIGZvciB0aGUgaW1tZWRpYXRlIHR5cGUuICopXG4gICAgIGFuZCB0eXBlIHNlZWQgPSBCYXNlX2ludGVybmFsaGFzaF90eXBlcy5zZWVkXG4gICAgIGFuZCB0eXBlIGhhc2hfdmFsdWUgPSBCYXNlX2ludGVybmFsaGFzaF90eXBlcy5oYXNoX3ZhbHVlXG5cbiAgZXh0ZXJuYWwgZm9sZF9pbnQ2NCA6IHN0YXRlIC0+IGludDY0IC0+IHN0YXRlID0gXCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludDY0XCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBmb2xkX2ludCA6IHN0YXRlIC0+IGludCAtPiBzdGF0ZSA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9pbnRcIiBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGZvbGRfZmxvYXQgOiBzdGF0ZSAtPiBmbG9hdCAtPiBzdGF0ZSA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9mbG9hdFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgZm9sZF9zdHJpbmcgOiBzdGF0ZSAtPiBzdHJpbmcgLT4gc3RhdGUgPSBcIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfc3RyaW5nXCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBnZXRfaGFzaF92YWx1ZSA6IHN0YXRlIC0+IGhhc2hfdmFsdWUgPSBcIkJhc2VfaW50ZXJuYWxoYXNoX2dldF9oYXNoX3ZhbHVlXCJcbiAgW0BAbm9hbGxvY11cbmVuZCA9IHN0cnVjdFxuICBsZXQgZGVzY3JpcHRpb24gPSBcImludGVybmFsaGFzaFwiXG5cbiAgaW5jbHVkZSBCYXNlX2ludGVybmFsaGFzaF90eXBlc1xuXG4gIGxldCBhbGxvYyAoKSA9IGNyZWF0ZV9zZWVkZWQgMFxuICBsZXQgcmVzZXQgPyhzZWVkID0gMCkgX3QgPSBjcmVhdGVfc2VlZGVkIHNlZWRcblxuICBtb2R1bGUgRm9yX3Rlc3RzID0gc3RydWN0XG4gICAgbGV0IGNvbXBhcmVfc3RhdGUgKGEgOiBzdGF0ZSkgKGIgOiBzdGF0ZSkgPSBjb21wYXJlIChhIDo+IGludCkgKGIgOj4gaW50KVxuICAgIGxldCBzdGF0ZV90b19zdHJpbmcgKHN0YXRlIDogc3RhdGUpID0gSW50LnRvX3N0cmluZyAoc3RhdGUgOj4gaW50KVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICBpbmNsdWRlIEludGVybmFsaGFzaFxuXG4gIHR5cGUgJ2EgZm9sZGVyID0gc3RhdGUgLT4gJ2EgLT4gc3RhdGVcblxuICBsZXQgY3JlYXRlID9zZWVkICgpID0gcmVzZXQgP3NlZWQgKGFsbG9jICgpKVxuICBsZXQgcnVuID9zZWVkIGZvbGRlciB4ID0gZ2V0X2hhc2hfdmFsdWUgKGZvbGRlciAocmVzZXQgP3NlZWQgKGFsbG9jICgpKSkgeClcbiAgbGV0IG9mX2ZvbGQgaGFzaF9mb2xkX3QgdCA9IGdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfdCAoY3JlYXRlICgpKSB0KVxuXG4gIG1vZHVsZSBCdWlsdGluID0gc3RydWN0XG4gICAgbW9kdWxlIEZvbGRpbmcgPSBGb2xkaW5nIChJbnRlcm5hbGhhc2gpXG4gICAgaW5jbHVkZSBGb2xkaW5nXG5cbiAgICAoKiBbRm9sZGluZ10gcHJvdmlkZXMgc29tZSBkZWZhdWx0IGltcGxlbWVudGF0aW9ucyBmb3IgdGhlIFtoYXNoXypdIGZ1bmN0aW9ucyBiZWxvdyxcbiAgICAgICBidXQgdGhleSBhcmUgaW5lZmZpY2llbnQgZm9yIHNvbWUgdXNlLWNhc2VzIGJlY2F1c2Ugb2YgdGhlIHVzZSBvZiB0aGUgW2hhc2hfZm9sZF1cbiAgICAgICBmdW5jdGlvbnMuIEF0IHRoaXMgcG9pbnQsIHRoZSBbaGFzaF92YWx1ZV0gdHlwZSBoYXMgYmVlbiBmaXhlZCB0byBbaW50XSwgc28gdGhpc1xuICAgICAgIG1vZHVsZSBjYW4gcHJvdmlkZSBzcGVjaWFsaXplZCBpbXBsZW1lbnRhdGlvbnMuICopXG5cbiAgICBsZXQgaGFzaF9jaGFyID0gQ2hhcjAudG9faW50XG5cbiAgICAoKiBUaGlzIGhhc2ggd2FzIGNob3NlbiBmcm9tIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2JhZGJveS82MjY3NzQzXG5cbiAgICAgICBJdCBhdHRlbXB0cyB0byBmdWxmaWxsIHRoZSBwcmltYXJ5IGdvYWxzIG9mIGEgbm9uLWNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbjpcblxuICAgICAgIC0gYSBiaXQgY2hhbmdlIGluIHRoZSBpbnB1dCBzaG91bGQgY2hhbmdlIH4xLzIgb2YgdGhlIG91dHB1dCBiaXRzXG4gICAgICAgLSB0aGUgb3V0cHV0IHNob3VsZCBiZSB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQgYWNyb3NzIHRoZSBvdXRwdXQgcmFuZ2VcbiAgICAgICAtIGlucHV0cyB0aGF0IGFyZSBjbG9zZSB0byBlYWNoIG90aGVyIHNob3VsZG4ndCBsZWFkIHRvIG91dHB1dHMgdGhhdCBhcmUgY2xvc2UgdG9cbiAgICAgICAgIGVhY2ggb3RoZXIuXG4gICAgICAgLSBhbGwgYml0cyBvZiB0aGUgaW5wdXQgYXJlIHVzZWQgaW4gZ2VuZXJhdGluZyB0aGUgb3V0cHV0XG5cbiAgICAgICBJbiBvdXIgY2FzZSB3ZSBhbHNvIHdhbnQgaXQgdG8gYmUgZmFzdCwgbm9uLWFsbG9jYXRpbmcsIGFuZCBpbmxpbmFibGUuICAqKVxuICAgIGxldFtAaW5saW5lIGFsd2F5c10gaGFzaF9pbnQgKHQgOiBpbnQpID1cbiAgICAgIGxldCB0ID0gbG5vdCB0ICsgKHQgbHNsIDIxKSBpblxuICAgICAgbGV0IHQgPSB0IGx4b3IgKHQgbHNyIDI0KSBpblxuICAgICAgbGV0IHQgPSB0ICsgKHQgbHNsIDMpICsgKHQgbHNsIDgpIGluXG4gICAgICBsZXQgdCA9IHQgbHhvciAodCBsc3IgMTQpIGluXG4gICAgICBsZXQgdCA9IHQgKyAodCBsc2wgMikgKyAodCBsc2wgNCkgaW5cbiAgICAgIGxldCB0ID0gdCBseG9yICh0IGxzciAyOCkgaW5cbiAgICAgIHQgKyAodCBsc2wgMzEpXG4gICAgOztcblxuICAgIGxldCBoYXNoX2Jvb2wgeCA9IGlmIHggdGhlbiAxIGVsc2UgMFxuXG4gICAgZXh0ZXJuYWwgaGFzaF9mbG9hdCA6IGZsb2F0IC0+IGludCA9IFwiQmFzZV9oYXNoX2RvdWJsZVwiIFtAQG5vYWxsb2NdXG5cbiAgICBsZXQgaGFzaF91bml0ICgpID0gMFxuICBlbmRcbmVuZFxuXG5pbmNsdWRlIFRcbiIsIm9wZW4gSW1wb3J0MFxuXG5sZXQgcGh5c19lcXVhbCA9IHBoeXNfZXF1YWxcblxuZXh0ZXJuYWwgcG9seW1vcnBoaWNfY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludCA9IFwiJWNvbXBhcmVcIlxuZXh0ZXJuYWwgcG9seW1vcnBoaWNfZXF1YWwgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcblxubGV0IGNvbXBhcmVfYWJzdHJhY3QgfnR5cGVfbmFtZSBfIF8gPVxuICBQcmludGYua3NwcmludGZcbiAgICBmYWlsd2l0aFxuICAgIFwiQ29tcGFyZSBjYWxsZWQgb24gdGhlIHR5cGUgJXMsIHdoaWNoIGlzIGFic3RyYWN0IGluIGFuIGltcGxlbWVudGF0aW9uLlwiXG4gICAgdHlwZV9uYW1lXG47O1xuXG5sZXQgZXF1YWxfYWJzdHJhY3QgfnR5cGVfbmFtZSBfIF8gPVxuICBQcmludGYua3NwcmludGZcbiAgICBmYWlsd2l0aFxuICAgIFwiRXF1YWwgY2FsbGVkIG9uIHRoZSB0eXBlICVzLCB3aGljaCBpcyBhYnN0cmFjdCBpbiBhbiBpbXBsZW1lbnRhdGlvbi5cIlxuICAgIHR5cGVfbmFtZVxuOztcblxudHlwZSAnYSBjb21wYXJlID0gJ2EgLT4gJ2EgLT4gaW50XG50eXBlICdhIGVxdWFsID0gJ2EgLT4gJ2EgLT4gYm9vbFxuXG5tb2R1bGUgQ29tcGFyYWJsZSA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgY29tcGFyZSA6IHQgY29tcGFyZVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiAnYSBjb21wYXJlIC0+ICdhIHQgY29tcGFyZVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiAnYSBjb21wYXJlIC0+ICdiIGNvbXBhcmUgLT4gKCdhLCAnYikgdCBjb21wYXJlXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiAnYSBjb21wYXJlIC0+ICdiIGNvbXBhcmUgLT4gJ2MgY29tcGFyZSAtPiAoJ2EsICdiLCAnYykgdCBjb21wYXJlXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBFcXVhbCA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgZXF1YWwgOiB0IGVxdWFsXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgZXF1YWwgOiAnYSBlcXVhbCAtPiAnYSB0IGVxdWFsXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgZXF1YWwgOiAnYSBlcXVhbCAtPiAnYiBlcXVhbCAtPiAoJ2EsICdiKSB0IGVxdWFsXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGVxdWFsIDogJ2EgZXF1YWwgLT4gJ2IgZXF1YWwgLT4gJ2MgZXF1YWwgLT4gKCdhLCAnYiwgJ2MpIHQgZXF1YWxcbiAgZW5kXG5lbmRcblxubW9kdWxlIEJ1aWx0aW4gPSBzdHJ1Y3RcbiAgbGV0IGNvbXBhcmVfYm9vbCA6IGJvb2wgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9jaGFyIDogY2hhciBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2Zsb2F0IDogZmxvYXQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9pbnQgOiBpbnQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9pbnQzMiA6IGludDMyIGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfaW50NjQgOiBpbnQ2NCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX25hdGl2ZWludCA6IG5hdGl2ZWludCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX3N0cmluZyA6IHN0cmluZyBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX3VuaXQgOiB1bml0IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcblxuICBsZXQgY29tcGFyZV9hcnJheSBjb21wYXJlX2VsdCBhIGIgPVxuICAgIGlmIHBoeXNfZXF1YWwgYSBiXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBsZXQgbGVuX2EgPSBBcnJheTAubGVuZ3RoIGEgaW5cbiAgICAgIGxldCBsZW5fYiA9IEFycmF5MC5sZW5ndGggYiBpblxuICAgICAgbGV0IHJldCA9IGNvbXBhcmUgbGVuX2EgbGVuX2IgaW5cbiAgICAgIGlmIHJldCA8PiAwXG4gICAgICB0aGVuIHJldFxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgICAgICBpZiBpID0gbGVuX2FcbiAgICAgICAgICB0aGVuIDBcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCBsID0gQXJyYXkwLnVuc2FmZV9nZXQgYSBpXG4gICAgICAgICAgICBhbmQgciA9IEFycmF5MC51bnNhZmVfZ2V0IGIgaSBpblxuICAgICAgICAgICAgbGV0IHJlcyA9IGNvbXBhcmVfZWx0IGwgciBpblxuICAgICAgICAgICAgaWYgcmVzIDw+IDAgdGhlbiByZXMgZWxzZSBsb29wIChpICsgMSkpXG4gICAgICAgIGluXG4gICAgICAgIGxvb3AgMCkpXG4gIDs7XG5cbiAgbGV0IHJlYyBjb21wYXJlX2xpc3QgY29tcGFyZV9lbHQgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IFtdLCBbXSAtPiAwXG4gICAgfCBbXSwgXyAtPiAtMVxuICAgIHwgXywgW10gLT4gMVxuICAgIHwgeCA6OiB4cywgeSA6OiB5cyAtPlxuICAgICAgbGV0IHJlcyA9IGNvbXBhcmVfZWx0IHggeSBpblxuICAgICAgaWYgcmVzIDw+IDAgdGhlbiByZXMgZWxzZSBjb21wYXJlX2xpc3QgY29tcGFyZV9lbHQgeHMgeXNcbiAgOztcblxuICBsZXQgY29tcGFyZV9vcHRpb24gY29tcGFyZV9lbHQgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IE5vbmUsIE5vbmUgLT4gMFxuICAgIHwgTm9uZSwgU29tZSBfIC0+IC0xXG4gICAgfCBTb21lIF8sIE5vbmUgLT4gMVxuICAgIHwgU29tZSBhLCBTb21lIGIgLT4gY29tcGFyZV9lbHQgYSBiXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfcmVmIGNvbXBhcmVfZWx0IGEgYiA9IGNvbXBhcmVfZWx0ICFhICFiXG4gIGxldCBlcXVhbF9ib29sIDogYm9vbCBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2NoYXIgOiBjaGFyIGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfaW50IDogaW50IGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfaW50MzIgOiBpbnQzMiBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX2ludDY0IDogaW50NjQgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9zdHJpbmcgOiBzdHJpbmcgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF91bml0IDogdW5pdCBlcXVhbCA9IFBvbHkuZXF1YWxcblxuICAoKiBbUG9seS5lcXVhbF0gaXMgSUVFRSBjb21wbGlhbnQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQgaGVyZS4gKilcbiAgbGV0IGVxdWFsX2Zsb2F0IHggeSA9IGVxdWFsX2ludCAoY29tcGFyZV9mbG9hdCB4IHkpIDBcblxuICBsZXQgZXF1YWxfYXJyYXkgZXF1YWxfZWx0IGEgYiA9XG4gICAgcGh5c19lcXVhbCBhIGJcbiAgICB8fFxuICAgIGxldCBsZW5fYSA9IEFycmF5MC5sZW5ndGggYSBpblxuICAgIGxldCBsZW5fYiA9IEFycmF5MC5sZW5ndGggYiBpblxuICAgIGVxdWFsIGxlbl9hIGxlbl9iXG4gICAgJiZcbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpID0gbGVuX2FcbiAgICAgIHx8XG4gICAgICBsZXQgbCA9IEFycmF5MC51bnNhZmVfZ2V0IGEgaVxuICAgICAgYW5kIHIgPSBBcnJheTAudW5zYWZlX2dldCBiIGkgaW5cbiAgICAgIGVxdWFsX2VsdCBsIHIgJiYgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcbiAgOztcblxuICBsZXQgcmVjIGVxdWFsX2xpc3QgZXF1YWxfZWx0IGEgYiA9XG4gICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgfCBbXSwgW10gLT4gdHJ1ZVxuICAgIHwgW10sIF8gfCBfLCBbXSAtPiBmYWxzZVxuICAgIHwgeCA6OiB4cywgeSA6OiB5cyAtPiBlcXVhbF9lbHQgeCB5ICYmIGVxdWFsX2xpc3QgZXF1YWxfZWx0IHhzIHlzXG4gIDs7XG5cbiAgbGV0IGVxdWFsX29wdGlvbiBlcXVhbF9lbHQgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IE5vbmUsIE5vbmUgLT4gdHJ1ZVxuICAgIHwgTm9uZSwgU29tZSBfIHwgU29tZSBfLCBOb25lIC0+IGZhbHNlXG4gICAgfCBTb21lIGEsIFNvbWUgYiAtPiBlcXVhbF9lbHQgYSBiXG4gIDs7XG5cbiAgbGV0IGVxdWFsX3JlZiBlcXVhbF9lbHQgYSBiID0gZXF1YWxfZWx0ICFhICFiXG5lbmRcbiIsIigqKiBUaGlzIG1vZHVsZSBpcyBmb3IgdXNlIGJ5IHBweF9oYXNoLCBhbmQgaXMgdGh1cyBub3QgaW4gdGhlIGludGVyZmFjZSBvZiBCYXNlLiAqKVxubW9kdWxlIFN0ZCA9IHN0cnVjdFxuICBtb2R1bGUgSGFzaCA9IEhhc2ggKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNoICopXG5lbmRcblxudHlwZSAnYSBoYXNoX2ZvbGQgPSBTdGQuSGFzaC5zdGF0ZSAtPiAnYSAtPiBTdGQuSGFzaC5zdGF0ZVxuXG5tb2R1bGUgSGFzaGFibGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIGhhc2hfZm9sZF90IDogdCBoYXNoX2ZvbGRcbiAgICB2YWwgaGFzaCA6IHQgLT4gU3RkLkhhc2guaGFzaF92YWx1ZVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGhhc2hfZm9sZF90IDogJ2EgaGFzaF9mb2xkIC0+ICdhIHQgaGFzaF9mb2xkXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgaGFzaF9mb2xkX3QgOiAnYSBoYXNoX2ZvbGQgLT4gJ2IgaGFzaF9mb2xkIC0+ICgnYSwgJ2IpIHQgaGFzaF9mb2xkXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGhhc2hfZm9sZF90XG4gICAgICA6ICAnYSBoYXNoX2ZvbGRcbiAgICAgIC0+ICdiIGhhc2hfZm9sZFxuICAgICAgLT4gJ2MgaGFzaF9mb2xkXG4gICAgICAtPiAoJ2EsICdiLCAnYykgdCBoYXNoX2ZvbGRcbiAgZW5kXG5lbmRcbiIsIm9wZW4gSGFzaC5CdWlsdGluXG5vcGVuIFBweF9jb21wYXJlX2xpYi5CdWlsdGluXG5pbmNsdWRlIFNleHBsaWIwLlNleHBcblxuKCoqIFR5cGUgb2YgUy1leHByZXNzaW9ucyAqKVxudHlwZSB0ID0gU2V4cGxpYjAuU2V4cC50ID1cbiAgfCBBdG9tIG9mIHN0cmluZ1xuICB8IExpc3Qgb2YgdCBsaXN0XG5bQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxubGV0IHJlYyBjb21wYXJlID1cbiAgKGZ1biBhX18wMDFfIGJfXzAwMl8gLT5cbiAgICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDAxXyBiX18wMDJfXG4gICAgIHRoZW4gMFxuICAgICBlbHNlIChcbiAgICAgICBtYXRjaCBhX18wMDFfLCBiX18wMDJfIHdpdGhcbiAgICAgICB8IEF0b20gX2FfXzAwM18sIEF0b20gX2JfXzAwNF8gLT4gY29tcGFyZV9zdHJpbmcgX2FfXzAwM18gX2JfXzAwNF9cbiAgICAgICB8IEF0b20gXywgXyAtPiAtMVxuICAgICAgIHwgXywgQXRvbSBfIC0+IDFcbiAgICAgICB8IExpc3QgX2FfXzAwNV8sIExpc3QgX2JfXzAwNl8gLT4gY29tcGFyZV9saXN0IGNvbXBhcmUgX2FfXzAwNV8gX2JfXzAwNl8pXG4gICAgICAgOiB0IC0+IHQgLT4gaW50KVxuOztcblxubGV0IHJlYyAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgKGZ1biBoc3YgYXJnIC0+XG4gICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgIHwgQXRvbSBfYTAgLT5cbiAgICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwIGluXG4gICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgIGhhc2hfZm9sZF9zdHJpbmcgaHN2IF9hMFxuICAgICB8IExpc3QgX2EwIC0+XG4gICAgICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMSBpblxuICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICBoYXNoX2ZvbGRfbGlzdCBoYXNoX2ZvbGRfdCBoc3YgX2EwXG4gICAgICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG5cbmFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgbGV0IGZ1bmMgYXJnID1cbiAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gIGluXG4gIGZ1biB4IC0+IGZ1bmMgeFxuOztcblxuW0BAQGVuZF1cblxubGV0IHRfc2V4cF9ncmFtbWFyID0gU2V4cGxpYjAuU2V4cF9jb252LnNleHBfdF9zZXhwX2dyYW1tYXJcbmxldCBvZl9zdHJpbmcgPSAoKVxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIFN5cyA9IFN5czBcblxudHlwZSB0ID1cbiAgfCBXMzJcbiAgfCBXNjRcbltAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG5sZXQgc2V4cF9vZl90ID1cbiAgKGZ1bmN0aW9uXG4gICAgfCBXMzIgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiVzMyXCJcbiAgICB8IFc2NCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJXNjRcIlxuICAgICAgICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgbnVtX2JpdHMgPSBmdW5jdGlvblxuICB8IFczMiAtPiAzMlxuICB8IFc2NCAtPiA2NFxuOztcblxubGV0IHdvcmRfc2l6ZSA9XG4gIG1hdGNoIFN5cy53b3JkX3NpemVfaW5fYml0cyB3aXRoXG4gIHwgMzIgLT4gVzMyXG4gIHwgNjQgLT4gVzY0XG4gIHwgXyAtPiBmYWlsd2l0aCBcInVua25vd24gd29yZCBzaXplXCJcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxubGV0IHIgPSByZWYgWyBcIkJhc2UuU2V4cC5wcF9odW1cIiBdXG5sZXQgYWxsICgpID0gIXJcbmxldCByZWdpc3RlciBwID0gciA6PSBwIDo6ICFyXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHBwIDogRm9ybWF0dGVyLnQgLT4gdCAtPiB1bml0XG5lbmRcblxubW9kdWxlIFJlZ2lzdGVyX3BwIChNIDogc2lnXG4gICAgaW5jbHVkZSBTXG5cbiAgICB2YWwgbW9kdWxlX25hbWUgOiBzdHJpbmdcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBNXG5cbiAgbGV0ICgpID0gcmVnaXN0ZXIgKE0ubW9kdWxlX25hbWUgXiBcIi5wcFwiKVxuZW5kXG5cbm1vZHVsZSBSZWdpc3RlciAoTSA6IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIG1vZHVsZV9uYW1lIDogc3RyaW5nXG4gICAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG4gIGVuZCkgPVxuICBSZWdpc3Rlcl9wcCAoc3RydWN0XG4gICAgaW5jbHVkZSBNXG5cbiAgICBsZXQgcHAgZm9ybWF0dGVyIHQgPSBDYW1sLkZvcm1hdC5wcF9wcmludF9zdHJpbmcgZm9ybWF0dGVyIChNLnRvX3N0cmluZyB0KVxuICBlbmQpXG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSB0ID0gZXhuIFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG5sZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfZXhuIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG5cbltAQEBlbmRdXG5cbmxldCBleGl0ID0gQ2FtbC5leGl0XG5cbmV4Y2VwdGlvbiBGaW5hbGx5IG9mIHQgKiB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG5sZXQgKCkgPVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgRmluYWxseV0gKGZ1bmN0aW9uXG4gICAgfCBGaW5hbGx5IChhcmcwX18wMDFfLCBhcmcxX18wMDJfKSAtPlxuICAgICAgbGV0IHJlczBfXzAwM18gPSBzZXhwX29mX3QgYXJnMF9fMDAxX1xuICAgICAgYW5kIHJlczFfXzAwNF8gPSBzZXhwX29mX3QgYXJnMV9fMDAyXyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiZXhuLm1sLkZpbmFsbHlcIjsgcmVzMF9fMDAzXzsgcmVzMV9fMDA0XyBdXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbjs7XG5cbltAQEBlbmRdXG5cbmV4Y2VwdGlvbiBSZXJhaXNlZCBvZiBzdHJpbmcgKiB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG5sZXQgKCkgPVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgUmVyYWlzZWRdIChmdW5jdGlvblxuICAgIHwgUmVyYWlzZWQgKGFyZzBfXzAwNV8sIGFyZzFfXzAwNl8pIC0+XG4gICAgICBsZXQgcmVzMF9fMDA3XyA9IHNleHBfb2Zfc3RyaW5nIGFyZzBfXzAwNV9cbiAgICAgIGFuZCByZXMxX18wMDhfID0gc2V4cF9vZl90IGFyZzFfXzAwNl8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcImV4bi5tbC5SZXJhaXNlZFwiOyByZXMwX18wMDdfOyByZXMxX18wMDhfIF1cbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuOztcblxuW0BAQGVuZF1cblxuZXhjZXB0aW9uIFNleHAgb2YgU2V4cC50XG5cbigqIFdlIGluc3RhbGwgYSBjdXN0b20gZXhuLWNvbnZlcnRlciByYXRoZXIgdGhhbiB1c2U6XG5cbiAgIHtbXG4gICAgIGV4Y2VwdGlvbiBTZXhwIG9mIFNleHAudCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cbiAgICAgKCogLi4uICopXG4gICAgIFtAQEBlbmRdXG4gICBdfVxuXG4gICB0byBlbGltaW5hdGUgdGhlIGV4dHJhIHdyYXBwaW5nIG9mIFsoU2V4cCAuLi4pXS4gKilcbmxldCAoKSA9XG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTZXhwXSAoZnVuY3Rpb25cbiAgICB8IFNleHAgdCAtPiB0XG4gICAgfCBfIC0+XG4gICAgICAoKiBSZWFjaGluZyB0aGlzIGJyYW5jaCBpbmRpY2F0ZXMgYSBidWcgaW4gc2V4cGxpYi4gKilcbiAgICAgIGFzc2VydCBmYWxzZSlcbjs7XG5cbmxldCBjcmVhdGVfcyBzZXhwID0gU2V4cCBzZXhwXG5cbmxldCByYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSB0IGJhY2t0cmFjZSA9XG4gIENhbWwuUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2UgdCBiYWNrdHJhY2Vcbjs7XG5cbmV4dGVybmFsIGlzX3BoeXNfZXF1YWxfbW9zdF9yZWNlbnQgOiB0IC0+IGJvb2wgPSBcIkJhc2VfY2FtbF9leG5faXNfbW9zdF9yZWNlbnRfZXhuXCJcblxubGV0IHJlcmFpc2UgZXhuIHN0ciA9XG4gIGxldCBleG4nID0gUmVyYWlzZWQgKHN0ciwgZXhuKSBpblxuICBpZiBpc19waHlzX2VxdWFsX21vc3RfcmVjZW50IGV4blxuICB0aGVuIChcbiAgICBsZXQgYnQgPSBDYW1sLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgZXhuJyBidClcbiAgZWxzZSByYWlzZSBleG4nXG47O1xuXG5sZXQgcmVyYWlzZWYgZXhjIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiAoZnVuIHN0ciAoKSAtPiByZXJhaXNlIGV4YyBzdHIpIGZvcm1hdFxubGV0IHRvX3N0cmluZyBleGMgPSBTZXhwLnRvX3N0cmluZ19odW0gfmluZGVudDoyIChzZXhwX29mX2V4biBleGMpXG5sZXQgdG9fc3RyaW5nX21hY2ggZXhjID0gU2V4cC50b19zdHJpbmdfbWFjaCAoc2V4cF9vZl9leG4gZXhjKVxubGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfZXhuXG5cbmxldCBwcm90ZWN0eCB+ZiB4IH4oZmluYWxseSA6IF8gLT4gdW5pdCkgPVxuICBtYXRjaCBmIHggd2l0aFxuICB8IHJlcyAtPlxuICAgIGZpbmFsbHkgeDtcbiAgICByZXNcbiAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgbGV0IGJ0ID0gQ2FtbC5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgIChtYXRjaCBmaW5hbGx5IHggd2l0aFxuICAgICB8ICgpIC0+IHJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIGV4biBidFxuICAgICB8IGV4Y2VwdGlvbiBmaW5hbF9leG4gLT5cbiAgICAgICAoKiBVbmZvcnR1bmF0ZWx5LCB0aGUgYmFja3RyYWNlIG9mIHRoZSBbZmluYWxfZXhuXSBpcyBkaXNjYXJkZWQgaGVyZS4gKilcbiAgICAgICByYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSAoRmluYWxseSAoZXhuLCBmaW5hbF9leG4pKSBidClcbjs7XG5cbmxldCBwcm90ZWN0IH5mIH5maW5hbGx5ID0gcHJvdGVjdHggfmYgKCkgfmZpbmFsbHlcblxubGV0IGRvZXNfcmFpc2UgKHR5cGUgYSkgKGYgOiB1bml0IC0+IGEpID1cbiAgdHJ5XG4gICAgaWdub3JlIChmICgpIDogYSk7XG4gICAgZmFsc2VcbiAgd2l0aFxuICB8IF8gLT4gdHJ1ZVxuOztcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3Rlcl9wcCAoc3RydWN0XG4gICAgdHlwZSB0ID0gZXhuXG5cbiAgICBsZXQgcHAgcHBmIHQgPVxuICAgICAgbWF0Y2ggc2V4cF9vZl9leG5fb3B0IHQgd2l0aFxuICAgICAgfCBTb21lIHNleHAgLT4gU2V4cC5wcF9odW0gcHBmIHNleHBcbiAgICAgIHwgTm9uZSAtPiBDYW1sLkZvcm1hdC5wcF9wcmludF9zdHJpbmcgcHBmIChDYW1sLlByaW50ZXhjLnRvX3N0cmluZyB0KVxuICAgIDs7XG5cbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuRXhuXCJcbiAgZW5kKVxuXG5sZXQgcHJpbnRfd2l0aF9iYWNrdHJhY2UgZXhjIHJhd19iYWNrdHJhY2UgPVxuICBDYW1sLkZvcm1hdC5lcHJpbnRmIFwiQFs8Mj5VbmNhdWdodCBleGNlcHRpb246QFxcbkBcXG5AWyVhQF1AXUBcXG5ALlwiIHBwIGV4YztcbiAgaWYgQ2FtbC5QcmludGV4Yy5iYWNrdHJhY2Vfc3RhdHVzICgpXG4gIHRoZW4gQ2FtbC5QcmludGV4Yy5wcmludF9yYXdfYmFja3RyYWNlIENhbWwuc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gIENhbWwuZmx1c2ggQ2FtbC5zdGRlcnJcbjs7XG5cbmxldCBzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgKCkgPVxuICBDYW1sLlByaW50ZXhjLnNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBwcmludF93aXRoX2JhY2t0cmFjZVxuOztcblxubGV0IGhhbmRsZV91bmNhdWdodF9hdXggfmRvX2F0X2V4aXQgfmV4aXQgZiA9XG4gIHRyeSBmICgpIHdpdGhcbiAgfCBleGMgLT5cbiAgICBsZXQgcmF3X2JhY2t0cmFjZSA9IENhbWwuUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAoKiBPbmUgcmVhc29uIHRvIHJ1biBbZG9fYXRfZXhpdF0gaGFuZGxlcnMgYmVmb3JlIHByaW50aW5nIG91dCB0aGUgZXJyb3IgbWVzc2FnZSBpc1xuICAgICAgIHRoYXQgaXQgaGVscHMgY3Vyc2VzIGFwcGxpY2F0aW9ucyBicmluZyB0aGUgdGVybWluYWwgaW4gYSBnb29kIHN0YXRlLCBvdGhlcndpc2UgdGhlXG4gICAgICAgZXJyb3IgbWVzc2FnZSBtaWdodCBnZXQgY29ycnVwdGVkLiAgQWxzbywgdGhlIE9DYW1sIHRvcC1sZXZlbCB1bmNhdWdodCBleGNlcHRpb25cbiAgICAgICBoYW5kbGVyIGRvZXMgdGhlIHNhbWUuICopXG4gICAgaWYgZG9fYXRfZXhpdFxuICAgIHRoZW4gKFxuICAgICAgdHJ5IENhbWwuZG9fYXRfZXhpdCAoKSB3aXRoXG4gICAgICB8IF8gLT4gKCkpO1xuICAgICh0cnkgcHJpbnRfd2l0aF9iYWNrdHJhY2UgZXhjIHJhd19iYWNrdHJhY2Ugd2l0aFxuICAgICB8IF8gLT5cbiAgICAgICAodHJ5XG4gICAgICAgICAgQ2FtbC5QcmludGYuZXByaW50ZiBcIkV4bi5oYW5kbGVfdW5jYXVnaHQgY291bGQgbm90IHByaW50OyBleGl0aW5nIGFueXdheVxcbiUhXCJcbiAgICAgICAgd2l0aFxuICAgICAgICB8IF8gLT4gKCkpKTtcbiAgICBleGl0IDFcbjs7XG5cbmxldCBoYW5kbGVfdW5jYXVnaHRfYW5kX2V4aXQgZiA9IGhhbmRsZV91bmNhdWdodF9hdXggZiB+ZXhpdCB+ZG9fYXRfZXhpdDp0cnVlXG5cbmxldCBoYW5kbGVfdW5jYXVnaHQgfmV4aXQ6bXVzdF9leGl0IGYgPVxuICBoYW5kbGVfdW5jYXVnaHRfYXV4IGYgfmV4aXQ6KGlmIG11c3RfZXhpdCB0aGVuIGV4aXQgZWxzZSBpZ25vcmUpIH5kb19hdF9leGl0Om11c3RfZXhpdFxuOztcblxubGV0IHJlcmFpc2VfdW5jYXVnaHQgc3RyIGZ1bmMgPVxuICB0cnkgZnVuYyAoKSB3aXRoXG4gIHwgZXhuIC0+XG4gICAgbGV0IGJ0ID0gQ2FtbC5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgIHJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIChSZXJhaXNlZCAoc3RyLCBleG4pKSBidFxuOztcblxuZXh0ZXJuYWwgY2xlYXJfYmFja3RyYWNlIDogdW5pdCAtPiB1bml0ID0gXCJCYXNlX2NsZWFyX2NhbWxfYmFja3RyYWNlX3Bvc1wiIFtAQG5vYWxsb2NdXG5cbmxldCByYWlzZV93aXRob3V0X2JhY2t0cmFjZSBlID1cbiAgKCogV2UgY2xlYXIgdGhlIGJhY2t0cmFjZSB0byByZWR1Y2UgY29uZnVzaW9uLCBzbyB0aGF0IHBlb3BsZSBkb24ndCB0aGluayB3aGF0ZXZlclxuICAgICBpcyBzdG9yZWQgY29ycmVzcG9uZHMgdG8gdGhpcyByYWlzZS4gKilcbiAgY2xlYXJfYmFja3RyYWNlICgpO1xuICBDYW1sLnJhaXNlX25vdHJhY2UgZVxuOztcblxubGV0IGluaXRpYWxpemVfbW9kdWxlICgpID0gc2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyICgpXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBjbGVhcl9iYWNrdHJhY2UgPSBjbGVhcl9iYWNrdHJhY2VcbmVuZFxuIiwiKCogYmVsb25ncyBpbiBDb21tb24sIGJ1dCBtb3ZlZCBoZXJlIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyAqKVxuXG5vcGVuISBJbXBvcnRcblxudHlwZSAnYSByZXR1cm4gPSB7IHJldHVybiA6ICdiLiAnYSAtPiAnYiB9IFtAQHVuYm94ZWRdXG5cbmxldCB3aXRoX3JldHVybiAodHlwZSBhKSBmID1cbiAgbGV0IG1vZHVsZSBNID0gc3RydWN0XG4gICAgKCogUmFpc2VkIHRvIGluZGljYXRlIH5yZXR1cm4gd2FzIGNhbGxlZC4gIExvY2FsIHNvIHRoYXQgdGhlIGV4Y2VwdGlvbiBpcyB0aWVkIHRvIGFcbiAgICAgICBwYXJ0aWN1bGFyIGNhbGwgb2YgW3dpdGhfcmV0dXJuXS4gKilcbiAgICBleGNlcHRpb24gUmV0dXJuIG9mIGFcbiAgZW5kXG4gIGluXG4gIGxldCBpc19hbGl2ZSA9IHJlZiB0cnVlIGluXG4gIGxldCByZXR1cm4gYSA9XG4gICAgaWYgbm90ICFpc19hbGl2ZVxuICAgIHRoZW4gZmFpbHdpdGggXCJ1c2Ugb2YgW3JldHVybl0gZnJvbSBhIFt3aXRoX3JldHVybl0gdGhhdCBhbHJlYWR5IHJldHVybmVkXCI7XG4gICAgRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIChNLlJldHVybiBhKVxuICBpblxuICB0cnlcbiAgICBsZXQgYSA9IGYgeyByZXR1cm4gfSBpblxuICAgIGlzX2FsaXZlIDo9IGZhbHNlO1xuICAgIGFcbiAgd2l0aFxuICB8IGV4biAtPlxuICAgIGlzX2FsaXZlIDo9IGZhbHNlO1xuICAgIChtYXRjaCBleG4gd2l0aFxuICAgICB8IE0uUmV0dXJuIGEgLT4gYVxuICAgICB8IF8gLT4gcmFpc2UgZXhuKVxuOztcblxubGV0IHdpdGhfcmV0dXJuX29wdGlvbiBmID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByZXR1cm4gLT5cbiAgICBmIHsgcmV0dXJuID0gKGZ1biBhIC0+IHJldHVybi5yZXR1cm4gKFNvbWUgYSkpIH07XG4gICAgTm9uZSlcbjs7XG5cbmxldCBwcmVwZW5kIHsgcmV0dXJuIH0gfmYgPSB7IHJldHVybiA9IChmdW4geCAtPiByZXR1cm4gKGYgeCkpIH1cbiIsIm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgdHlwZSBCYXNpYyA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgYmluZCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2IgdCkgLT4gJ2IgdFxuICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuXG4gICgqKiBUaGUgZm9sbG93aW5nIGlkZW50aXRpZXMgb3VnaHQgdG8gaG9sZCAoZm9yIHNvbWUgdmFsdWUgb2YgPSk6XG5cbiAgICAgIC0gW3JldHVybiB4ID4+PSBmID0gZiB4XVxuICAgICAgLSBbdCA+Pj0gZnVuIHggLT4gcmV0dXJuIHggPSB0XVxuICAgICAgLSBbKHQgPj49IGYpID4+PSBnID0gdCA+Pj0gZnVuIHggLT4gKGYgeCA+Pj0gZyldXG5cbiAgICAgIE5vdGU6IFs+Pj1dIGlzIHRoZSBpbmZpeCBub3RhdGlvbiBmb3IgW2JpbmRdKSAqKVxuXG4gICgqKiBUaGUgW21hcF0gYXJndW1lbnQgdG8gW01vbmFkLk1ha2VdIHNheXMgaG93IHRvIGltcGxlbWVudCB0aGUgbW9uYWQncyBbbWFwXSBmdW5jdGlvbi5cbiAgICAgIFtgRGVmaW5lX3VzaW5nX2JpbmRdIG1lYW5zIHRvIGRlZmluZSBbbWFwIHQgfmYgPSBiaW5kIHQgfmY6KGZ1biBhIC0+IHJldHVybiAoZiBhKSldLlxuICAgICAgW2BDdXN0b21dIG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiwgcHJlc3VtYWJseSB3aXRoIHNvbWV0aGluZyBtb3JlXG4gICAgICBlZmZpY2llbnQuXG5cbiAgICAgIFNvbWUgb3RoZXIgZnVuY3Rpb25zIHJldHVybmVkIGJ5IFtNb25hZC5NYWtlXSBhcmUgZGVmaW5lZCBpbiB0ZXJtcyBvZiBbbWFwXSwgc29cbiAgICAgIHBhc3NpbmcgaW4gYSBtb3JlIGVmZmljaWVudCBbbWFwXSB3aWxsIGltcHJvdmUgdGhlaXIgZWZmaWNpZW5jeSBhcyB3ZWxsLiAqKVxuICB2YWwgbWFwIDogWyBgRGVmaW5lX3VzaW5nX2JpbmQgfCBgQ3VzdG9tIG9mICdhIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICdiIHQgXVxuZW5kXG5cbm1vZHVsZSB0eXBlIEluZml4ID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gICgqKiBbdCA+Pj0gZl0gcmV0dXJucyBhIGNvbXB1dGF0aW9uIHRoYXQgc2VxdWVuY2VzIHRoZSBjb21wdXRhdGlvbnMgcmVwcmVzZW50ZWQgYnkgdHdvXG4gICAgICBtb25hZCBlbGVtZW50cy4gIFRoZSByZXN1bHRpbmcgY29tcHV0YXRpb24gZmlyc3QgZG9lcyBbdF0gdG8geWllbGQgYSB2YWx1ZSBbdl0sIGFuZFxuICAgICAgdGhlbiBydW5zIHRoZSBjb21wdXRhdGlvbiByZXR1cm5lZCBieSBbZiB2XS4gKilcbiAgdmFsICggPj49ICkgOiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XG5cbiAgKCoqIFt0ID4+fCBmXSBpcyBbdCA+Pj0gKGZ1biBhIC0+IHJldHVybiAoZiBhKSldLiAqKVxuICB2YWwgKCA+PnwgKSA6ICdhIHQgLT4gKCdhIC0+ICdiKSAtPiAnYiB0XG5lbmRcblxubW9kdWxlIHR5cGUgU3ludGF4ID0gc2lnXG4gICgqKiBPcGVuaW5nIGEgbW9kdWxlIG9mIHRoaXMgdHlwZSBhbGxvd3Mgb25lIHRvIHVzZSB0aGUgWyViaW5kXSBhbmQgWyVtYXBdIHN5bnRheFxuICAgICAgZXh0ZW5zaW9ucyBkZWZpbmVkIGJ5IHBweF9sZXQsIGFuZCBicmluZ3MgW3JldHVybl0gaW50byBzY29wZS4gKilcblxuICB0eXBlICdhIHRcblxuICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgICgqKiBUaGVzZSBhcmUgY29udmVuaWVudCB0byBoYXZlIGluIHNjb3BlIHdoZW4gcHJvZ3JhbW1pbmcgd2l0aCBhIG1vbmFkOiAqKVxuXG4gICAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcblxuICAgIGluY2x1ZGUgSW5maXggd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICAgIHZhbCByZXR1cm4gOiAnYSAtPiAnYSB0XG4gICAgICB2YWwgYmluZCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2IgdCkgLT4gJ2IgdFxuICAgICAgdmFsIG1hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICdiIHRcbiAgICAgIHZhbCBib3RoIDogJ2EgdCAtPiAnYiB0IC0+ICgnYSAqICdiKSB0XG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA6IHNpZyBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIHR5cGUgU193aXRob3V0X3N5bnRheCA9IHNpZ1xuICB0eXBlICdhIHRcblxuICBpbmNsdWRlIEluZml4IHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgbW9kdWxlIE1vbmFkX2luZml4IDogSW5maXggd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gICgqKiBbYmluZCB0IH5mXSA9IFt0ID4+PSBmXSAqKVxuICB2YWwgYmluZCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2IgdCkgLT4gJ2IgdFxuXG4gICgqKiBbcmV0dXJuIHZdIHJldHVybnMgdGhlICh0cml2aWFsKSBjb21wdXRhdGlvbiB0aGF0IHJldHVybnMgdi4gKilcbiAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcblxuICAoKiogW21hcCB0IH5mXSBpcyB0ID4+fCBmLiAqKVxuICB2YWwgbWFwIDogJ2EgdCAtPiBmOignYSAtPiAnYikgLT4gJ2IgdFxuXG4gICgqKiBbam9pbiB0XSBpcyBbdCA+Pj0gKGZ1biB0JyAtPiB0JyldLiAqKVxuICB2YWwgam9pbiA6ICdhIHQgdCAtPiAnYSB0XG5cbiAgKCoqIFtpZ25vcmVfbSB0XSBpcyBbbWFwIHQgfmY6KGZ1biBfIC0+ICgpKV0uICBbaWdub3JlX21dIHVzZWQgdG8gYmUgY2FsbGVkIFtpZ25vcmVdLFxuICAgICAgYnV0IHdlIGRlY2lkZWQgdGhhdCB3YXMgYSBiYWQgbmFtZSwgYmVjYXVzZSBpdCBzaGFkb3dlZCB0aGUgd2lkZWx5IHVzZWRcbiAgICAgIFtDYW1sLmlnbm9yZV0uICBTb21lIG1vbmFkcyBzdGlsbCBkbyBbbGV0IGlnbm9yZSA9IGlnbm9yZV9tXSBmb3IgaGlzdG9yaWNhbFxuICAgICAgcmVhc29ucy4gKilcbiAgdmFsIGlnbm9yZV9tIDogJ2EgdCAtPiB1bml0IHRcblxuICB2YWwgYWxsIDogJ2EgdCBsaXN0IC0+ICdhIGxpc3QgdFxuXG4gICgqKiBMaWtlIFthbGxdLCBidXQgZW5zdXJlcyB0aGF0IGV2ZXJ5IG1vbmFkaWMgdmFsdWUgaW4gdGhlIGxpc3QgcHJvZHVjZXMgYSB1bml0IHZhbHVlLFxuICAgICAgYWxsIG9mIHdoaWNoIGFyZSBkaXNjYXJkZWQgcmF0aGVyIHRoYW4gYmVpbmcgY29sbGVjdGVkIGludG8gYSBsaXN0LiAqKVxuICB2YWwgYWxsX3VuaXQgOiB1bml0IHQgbGlzdCAtPiB1bml0IHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIGluY2x1ZGUgU193aXRob3V0X3N5bnRheCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gIGluY2x1ZGUgU3ludGF4IHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBCYXNpYzIgPSBzaWdcbiAgKCoqIE11bHRpIHBhcmFtZXRlciBtb25hZC4gVGhlIHNlY29uZCBwYXJhbWV0ZXIgZ2V0cyB1bmlmaWVkIGFjcm9zcyBhbGwgdGhlIGNvbXB1dGF0aW9uLlxuICAgICAgVGhpcyBpcyB1c2VkIHRvIGVuY29kZSBtb25hZHMgd29ya2luZyBvbiBhIG11bHRpIHBhcmFtZXRlciBkYXRhIHN0cnVjdHVyZSBsaWtlXG4gICAgICAoWygnYSwnYikgcmVzdWx0XSkuICopXG5cbiAgdHlwZSAoJ2EsICdlKSB0XG5cbiAgdmFsIGJpbmQgOiAoJ2EsICdlKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2UpIHQpIC0+ICgnYiwgJ2UpIHRcbiAgdmFsIG1hcCA6IFsgYERlZmluZV91c2luZ19iaW5kIHwgYEN1c3RvbSBvZiAoJ2EsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdlKSB0IF1cbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXykgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEluZml4MiA9IHNpZ1xuICAoKiogU2FtZSBhcyB7IUluZml4fSwgZXhjZXB0IHRoZSBtb25hZCB0eXBlIGhhcyB0d28gYXJndW1lbnRzLiBUaGUgc2Vjb25kIGlzIGFsd2F5cyBqdXN0XG4gICAgICBwYXNzZWQgdGhyb3VnaC4gKilcblxuICB0eXBlICgnYSwgJ2UpIHRcblxuICB2YWwgKCA+Pj0gKSA6ICgnYSwgJ2UpIHQgLT4gKCdhIC0+ICgnYiwgJ2UpIHQpIC0+ICgnYiwgJ2UpIHRcbiAgdmFsICggPj58ICkgOiAoJ2EsICdlKSB0IC0+ICgnYSAtPiAnYikgLT4gKCdiLCAnZSkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFN5bnRheDIgPSBzaWdcbiAgdHlwZSAoJ2EsICdlKSB0XG5cbiAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfKSB0XG5cbiAgICBpbmNsdWRlIEluZml4MiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSB0XG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXykgdFxuICAgICAgdmFsIGJpbmQgOiAoJ2EsICdlKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2UpIHQpIC0+ICgnYiwgJ2UpIHRcbiAgICAgIHZhbCBtYXAgOiAoJ2EsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdlKSB0XG4gICAgICB2YWwgYm90aCA6ICgnYSwgJ2UpIHQgLT4gKCdiLCAnZSkgdCAtPiAoJ2EgKiAnYiwgJ2UpIHRcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzIDogc2lnIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAoKiogVGhlIHNhbWUgYXMgeyFTfSBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHR3byBhcmd1bWVudHMuIFRoZSBzZWNvbmQgaXMgYWx3YXlzIGp1c3RcbiAgICAgIHBhc3NlZCB0aHJvdWdoLiAqKVxuXG4gIHR5cGUgKCdhLCAnZSkgdFxuXG4gIGluY2x1ZGUgSW5maXgyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIHRcbiAgaW5jbHVkZSBTeW50YXgyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIHRcbiAgbW9kdWxlIE1vbmFkX2luZml4IDogSW5maXgyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIHRcblxuICB2YWwgYmluZCA6ICgnYSwgJ2UpIHQgLT4gZjooJ2EgLT4gKCdiLCAnZSkgdCkgLT4gKCdiLCAnZSkgdFxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfKSB0XG4gIHZhbCBtYXAgOiAoJ2EsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdlKSB0XG4gIHZhbCBqb2luIDogKCgnYSwgJ2UpIHQsICdlKSB0IC0+ICgnYSwgJ2UpIHRcbiAgdmFsIGlnbm9yZV9tIDogKF8sICdlKSB0IC0+ICh1bml0LCAnZSkgdFxuICB2YWwgYWxsIDogKCdhLCAnZSkgdCBsaXN0IC0+ICgnYSBsaXN0LCAnZSkgdFxuICB2YWwgYWxsX3VuaXQgOiAodW5pdCwgJ2UpIHQgbGlzdCAtPiAodW5pdCwgJ2UpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBCYXNpYzMgPSBzaWdcbiAgKCoqIE11bHRpIHBhcmFtZXRlciBtb25hZC4gVGhlIHNlY29uZCBhbmQgdGhpcmQgcGFyYW1ldGVycyBnZXQgdW5pZmllZCBhY3Jvc3MgYWxsIHRoZVxuICAgICAgY29tcHV0YXRpb24uICopXG5cbiAgdHlwZSAoJ2EsICdkLCAnZSkgdFxuXG4gIHZhbCBiaW5kIDogKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gKCdiLCAnZCwgJ2UpIHQpIC0+ICgnYiwgJ2QsICdlKSB0XG5cbiAgdmFsIG1hcFxuICAgIDogWyBgRGVmaW5lX3VzaW5nX2JpbmQgfCBgQ3VzdG9tIG9mICgnYSwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdkLCAnZSkgdCBdXG5cbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXywgXykgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEluZml4MyA9IHNpZ1xuICAoKiogU2FtZSBhcyBJbmZpeCwgZXhjZXB0IHRoZSBtb25hZCB0eXBlIGhhcyB0aHJlZSBhcmd1bWVudHMuIFRoZSBzZWNvbmQgYW5kIHRoaXJkIGFyZVxuICAgICAgYWx3YXlzIGp1c3QgcGFzc2VkIHRocm91Z2guICopXG5cbiAgdHlwZSAoJ2EsICdkLCAnZSkgdFxuXG4gIHZhbCAoID4+PSApIDogKCdhLCAnZCwgJ2UpIHQgLT4gKCdhIC0+ICgnYiwgJ2QsICdlKSB0KSAtPiAoJ2IsICdkLCAnZSkgdFxuICB2YWwgKCA+PnwgKSA6ICgnYSwgJ2QsICdlKSB0IC0+ICgnYSAtPiAnYikgLT4gKCdiLCAnZCwgJ2UpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTeW50YXgzID0gc2lnXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHRcblxuICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8sIF8pIHRcblxuICAgIGluY2x1ZGUgSW5maXgzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgdFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8sIF8pIHRcbiAgICAgIHZhbCBiaW5kIDogKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gKCdiLCAnZCwgJ2UpIHQpIC0+ICgnYiwgJ2QsICdlKSB0XG4gICAgICB2YWwgbWFwIDogKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2QsICdlKSB0XG4gICAgICB2YWwgYm90aCA6ICgnYSwgJ2QsICdlKSB0IC0+ICgnYiwgJ2QsICdlKSB0IC0+ICgnYSAqICdiLCAnZCwgJ2UpIHRcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzIDogc2lnIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTMyA9IHNpZ1xuICAoKiogVGhlIHNhbWUgYXMgeyFTfSBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHRocmVlIGFyZ3VtZW50cy4gVGhlIHNlY29uZFxuICAgICAgYW5kIHRoaXJkIGFyZSBhbHdheXMganVzdCBwYXNzZWQgdGhyb3VnaC4gKilcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0XG5cbiAgaW5jbHVkZSBJbmZpeDMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSB0XG4gIGluY2x1ZGUgU3ludGF4MyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIHRcbiAgbW9kdWxlIE1vbmFkX2luZml4IDogSW5maXgzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgdFxuXG4gIHZhbCBiaW5kIDogKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gKCdiLCAnZCwgJ2UpIHQpIC0+ICgnYiwgJ2QsICdlKSB0XG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8sIF8pIHRcbiAgdmFsIG1hcCA6ICgnYSwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdkLCAnZSkgdFxuICB2YWwgam9pbiA6ICgoJ2EsICdkLCAnZSkgdCwgJ2QsICdlKSB0IC0+ICgnYSwgJ2QsICdlKSB0XG4gIHZhbCBpZ25vcmVfbSA6IChfLCAnZCwgJ2UpIHQgLT4gKHVuaXQsICdkLCAnZSkgdFxuICB2YWwgYWxsIDogKCdhLCAnZCwgJ2UpIHQgbGlzdCAtPiAoJ2EgbGlzdCwgJ2QsICdlKSB0XG4gIHZhbCBhbGxfdW5pdCA6ICh1bml0LCAnZCwgJ2UpIHQgbGlzdCAtPiAodW5pdCwgJ2QsICdlKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQmFzaWNfaW5kZXhlZCA9IHNpZ1xuICAoKiogSW5kZXhlZCBtb25hZCwgaW4gdGhlIHN0eWxlIG9mIEF0a2V5LiBUaGUgc2Vjb25kIGFuZCB0aGlyZCBwYXJhbWV0ZXJzIGFyZSBjb21wb3NlZFxuICAgICAgYWNyb3NzIGFsbCBjb21wdXRhdGlvbi4gVG8gc2VlIHRoaXMgbW9yZSBjbGVhcmx5LCB5b3UgY2FuIGxvb2sgYXQgdGhlIHR5cGUgb2YgYmluZDpcblxuICAgICAge1tcbiAgICAgICAgdmFsIGJpbmQgOiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAoJ2IsICdqLCAnaykgdCkgLT4gKCdiLCAnaSwgJ2spIHRcbiAgICAgIF19XG5cbiAgICAgIGFuZCBpc29sYXRlIHNvbWUgb2YgdGhlIHR5cGUgdmFyaWFibGVzIHRvIHNlZSB0aGVpciBpbmRpdmlkdWFsIGJlaGF2aW9yczpcblxuICAgICAge1tcbiAgICAgICAgdmFsIGJpbmQgOiAnYSAgICAgICAgICAgICAtPiBmOignYSAtPiAgJ2IgICAgICAgICAgICkgLT4gICdiXG4gICAgICAgIHZhbCBiaW5kIDogICAgICAnaSwgJ2ogICAgLT4gICAgICAgICAgICAgICAnaiwgJ2sgICAgIC0+ICAgICAnaSwgJ2tcbiAgICAgIF19XG5cbiAgICAgIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIEF0a2V5LXN0eWxlIGluZGV4ZWQgbW9uYWRzLCBzZWU6XG5cbiAgICAgIHt2XG4gICAgICAgIFBhcmFtZXRlcmlzZWQgTm90aW9ucyBvZiBDb21wdXRhdGlvblxuICAgICAgICBSb2JlcnQgQXRrZXlcbiAgICAgICAgaHR0cDovL2JlbnRuaWIub3JnL3BhcmFtbm90aW9ucy1qZnAucGRmXG4gICAgICB2fSAqKVxuXG4gIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICB2YWwgYmluZCA6ICgnYSwgJ2ksICdqKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2osICdrKSB0KSAtPiAoJ2IsICdpLCAnaykgdFxuXG4gIHZhbCBtYXBcbiAgICA6IFsgYERlZmluZV91c2luZ19iaW5kIHwgYEN1c3RvbSBvZiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2opIHQgXVxuXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEluZml4X2luZGV4ZWQgPSBzaWdcbiAgKCoqIFNhbWUgYXMgeyFJbmZpeH0sIGV4Y2VwdCB0aGUgbW9uYWQgdHlwZSBoYXMgdGhyZWUgYXJndW1lbnRzLiBUaGUgc2Vjb25kIGFuZFxuICAgICAgdGhpcmQgYXJlIGNvbXBvc2VkIGFjcm9zcyBhbGwgY29tcHV0YXRpb24uICopXG5cbiAgdHlwZSAoJ2EsICdpLCAnaikgdFxuXG4gIHZhbCAoID4+PSApIDogKCdhLCAnaSwgJ2opIHQgLT4gKCdhIC0+ICgnYiwgJ2osICdrKSB0KSAtPiAoJ2IsICdpLCAnaykgdFxuICB2YWwgKCA+PnwgKSA6ICgnYSwgJ2ksICdqKSB0IC0+ICgnYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2opIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTeW50YXhfaW5kZXhlZCA9IHNpZ1xuICB0eXBlICgnYSwgJ2ksICdqKSB0XG5cbiAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCAnaSwgJ2kpIHRcblxuICAgIGluY2x1ZGUgSW5maXhfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgOj0gKCdhLCAnaSwgJ2opIHRcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCAnaSwgJ2kpIHRcbiAgICAgIHZhbCBiaW5kIDogKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2spIHQpIC0+ICgnYiwgJ2ksICdrKSB0XG4gICAgICB2YWwgbWFwIDogKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2ksICdqKSB0XG4gICAgICB2YWwgYm90aCA6ICgnYSwgJ2ksICdqKSB0IC0+ICgnYiwgJ2osICdrKSB0IC0+ICgnYSAqICdiLCAnaSwgJ2spIHRcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzIDogc2lnIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX2luZGV4ZWQgPSBzaWdcbiAgKCoqIFRoZSBzYW1lIGFzIHshU30gZXhjZXB0IHRoZSBtb25hZCB0eXBlIGhhcyB0aHJlZSBhcmd1bWVudHMuIFRoZSBzZWNvbmQgYW5kXG4gICAgICB0aGlyZCBhcmUgY29tcG9zZWQgYWNyb3NzIGFsbCBjb21wdXRhdGlvbi4gKilcblxuICB0eXBlICgnYSwgJ2ksICdqKSB0XG5cbiAgaW5jbHVkZSBJbmZpeF9pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgdFxuICBpbmNsdWRlIFN5bnRheF9pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgdFxuICBtb2R1bGUgTW9uYWRfaW5maXggOiBJbmZpeF9pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgdFxuXG4gIHZhbCBiaW5kIDogKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2spIHQpIC0+ICgnYiwgJ2ksICdrKSB0XG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSkgdFxuICB2YWwgbWFwIDogKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2ksICdqKSB0XG4gIHZhbCBqb2luIDogKCgnYSwgJ2osICdrKSB0LCAnaSwgJ2opIHQgLT4gKCdhLCAnaSwgJ2spIHRcbiAgdmFsIGlnbm9yZV9tIDogKF8sICdpLCAnaikgdCAtPiAodW5pdCwgJ2ksICdqKSB0XG4gIHZhbCBhbGwgOiAoJ2EsICdpLCAnaSkgdCBsaXN0IC0+ICgnYSBsaXN0LCAnaSwgJ2kpIHRcbiAgdmFsIGFsbF91bml0IDogKHVuaXQsICdpLCAnaSkgdCBsaXN0IC0+ICh1bml0LCAnaSwgJ2kpIHRcbmVuZFxuXG5tb2R1bGUgU190b19TMiAoWCA6IFMpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50XG5lbmRcblxubW9kdWxlIFMyX3RvX1MzIChYIDogUzIpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnRcbmVuZFxuXG5tb2R1bGUgU190b19TX2luZGV4ZWQgKFggOiBTKSA6IFNfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgPSAnYSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdpLCAnaikgdCA9ICdhIFgudFxuZW5kXG5cbm1vZHVsZSBTMl90b19TIChYIDogUzIpIDogUyB3aXRoIHR5cGUgJ2EgdCA9ICgnYSwgdW5pdCkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgJ2EgdCA9ICgnYSwgdW5pdCkgWC50XG5lbmRcblxubW9kdWxlIFMzX3RvX1MyIChYIDogUzMpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlLCB1bml0KSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSwgdW5pdCkgWC50XG5lbmRcblxubW9kdWxlIFNfaW5kZXhlZF90b19TMiAoWCA6IFNfaW5kZXhlZCkgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UsICdlKSBYLnQgPVxuc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UsICdlKSBYLnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNb25hZCA9IHNpZ1xuICAoKiogQSBtb25hZCBpcyBhbiBhYnN0cmFjdGlvbiBvZiB0aGUgY29uY2VwdCBvZiBzZXF1ZW5jaW5nIG9mIGNvbXB1dGF0aW9ucy4gIEEgdmFsdWUgb2ZcbiAgICAgIHR5cGUgWydhIG1vbmFkXSByZXByZXNlbnRzIGEgY29tcHV0YXRpb24gdGhhdCByZXR1cm5zIGEgdmFsdWUgb2YgdHlwZSBbJ2FdLiAqKVxuXG4gIG1vZHVsZSB0eXBlIEJhc2ljID0gQmFzaWNcbiAgbW9kdWxlIHR5cGUgQmFzaWMyID0gQmFzaWMyXG4gIG1vZHVsZSB0eXBlIEJhc2ljMyA9IEJhc2ljM1xuICBtb2R1bGUgdHlwZSBCYXNpY19pbmRleGVkID0gQmFzaWNfaW5kZXhlZFxuICBtb2R1bGUgdHlwZSBJbmZpeCA9IEluZml4XG4gIG1vZHVsZSB0eXBlIEluZml4MiA9IEluZml4MlxuICBtb2R1bGUgdHlwZSBJbmZpeDMgPSBJbmZpeDNcbiAgbW9kdWxlIHR5cGUgSW5maXhfaW5kZXhlZCA9IEluZml4X2luZGV4ZWRcbiAgbW9kdWxlIHR5cGUgU3ludGF4ID0gU3ludGF4XG4gIG1vZHVsZSB0eXBlIFN5bnRheDIgPSBTeW50YXgyXG4gIG1vZHVsZSB0eXBlIFN5bnRheDMgPSBTeW50YXgzXG4gIG1vZHVsZSB0eXBlIFN5bnRheF9pbmRleGVkID0gU3ludGF4X2luZGV4ZWRcbiAgbW9kdWxlIHR5cGUgU193aXRob3V0X3N5bnRheCA9IFNfd2l0aG91dF9zeW50YXhcbiAgbW9kdWxlIHR5cGUgUyA9IFNcbiAgbW9kdWxlIHR5cGUgUzIgPSBTMlxuICBtb2R1bGUgdHlwZSBTMyA9IFMzXG4gIG1vZHVsZSB0eXBlIFNfaW5kZXhlZCA9IFNfaW5kZXhlZFxuXG4gIG1vZHVsZSBNYWtlIChYIDogQmFzaWMpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBYLnRcbiAgbW9kdWxlIE1ha2UyIChYIDogQmFzaWMyKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIFgudFxuICBtb2R1bGUgTWFrZTMgKFggOiBCYXNpYzMpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSBYLnRcblxuICBtb2R1bGUgTWFrZV9pbmRleGVkIChYIDogQmFzaWNfaW5kZXhlZCkgOlxuICAgIFNfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIFgudFxuXG4gICgqKiBEZWZpbmUgYSBtb25hZCB0aHJvdWdoIGFuIGlzb21vcnBoaXNtIHdpdGggYW4gZXhpc3RpbmcgbW9uYWQuIEZvciBleGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlICdhIHQgPSB7IHZhbHVlIDogJ2EgfVxuXG4gICAgICAgIGluY2x1ZGUgTW9uYWQuT2ZfbW9uYWQgKE1vbmFkLklkZW50KSAoc3RydWN0XG4gICAgICAgICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgICAgICAgICBsZXQgdG9fbW9uYWQgeyB2YWx1ZSB9ID0gdmFsdWVcbiAgICAgICAgICAgIGxldCBvZl9tb25hZCB2YWx1ZSA9IHsgdmFsdWUgfVxuICAgICAgICAgIGVuZClcbiAgICAgIF19ICopXG4gIG1vZHVsZSBPZl9tb25hZFxuICAgICAgKE1vbmFkIDogUykgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgIHR5cGUgJ2EgdFxuXG4gICAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAnYSB0IC0+ICdhIE1vbmFkLnRcbiAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICdhIE1vbmFkLnQgLT4gJ2EgdFxuICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTIHdpdGggdHlwZSAnYSB0IDo9ICdhIE0udFxuXG4gIG1vZHVsZSBPZl9tb25hZDJcbiAgICAgIChNb25hZCA6IFMyKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX21vbmFkIDogKCdhLCAnYikgdCAtPiAoJ2EsICdiKSBNb25hZC50XG4gICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX21vbmFkIDogKCdhLCAnYikgTW9uYWQudCAtPiAoJ2EsICdiKSB0XG4gICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSBNLnRcblxuICBtb2R1bGUgT2ZfbW9uYWQzXG4gICAgICAoTW9uYWQgOiBTMykgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2IsICdjKSBNb25hZC50IC0+ICgnYSwgJ2IsICdjKSB0XG4gICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTMyB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIE0udFxuXG4gIG1vZHVsZSBPZl9tb25hZF9pbmRleGVkXG4gICAgICAoTW9uYWQgOiBTX2luZGV4ZWQpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdpLCAnaikgdCAtPiAoJ2EsICdpLCAnaikgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdpLCAnaikgTW9uYWQudCAtPiAoJ2EsICdpLCAnaikgdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kKSA6IFNfaW5kZXhlZCB3aXRoIHR5cGUgKCdhLCAnaSwgJ2opIHQgOj0gKCdhLCAnaSwgJ2opIE0udFxuXG4gIG1vZHVsZSBJZGVudCA6IFMgd2l0aCB0eXBlICdhIHQgPSAnYVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBMaXN0ID0gTGlzdDBcbmluY2x1ZGUgTW9uYWRfaW50ZlxuXG5tb2R1bGUgdHlwZSBCYXNpY19nZW5lcmFsID0gc2lnXG4gIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuXG4gIHZhbCBiaW5kXG4gICAgOiAgKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuICAgIC0+IGY6KCdhIC0+ICgnYiwgJ2osICdrLCAnZCwgJ2UpIHQpXG4gICAgLT4gKCdiLCAnaSwgJ2ssICdkLCAnZSkgdFxuXG4gIHZhbCBtYXBcbiAgICA6IFsgYERlZmluZV91c2luZ19iaW5kXG4gICAgICB8IGBDdXN0b20gb2YgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2osICdkLCAnZSkgdFxuICAgICAgXVxuXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSwgJ2QsICdlKSB0XG5lbmRcblxubW9kdWxlIE1ha2VfZ2VuZXJhbCAoTSA6IEJhc2ljX2dlbmVyYWwpID0gc3RydWN0XG4gIGxldCBiaW5kID0gTS5iaW5kXG4gIGxldCByZXR1cm4gPSBNLnJldHVyblxuICBsZXQgbWFwX3ZpYV9iaW5kIG1hIH5mID0gTS5iaW5kIG1hIH5mOihmdW4gYSAtPiBNLnJldHVybiAoZiBhKSlcblxuICBsZXQgbWFwID1cbiAgICBtYXRjaCBNLm1hcCB3aXRoXG4gICAgfCBgRGVmaW5lX3VzaW5nX2JpbmQgLT4gbWFwX3ZpYV9iaW5kXG4gICAgfCBgQ3VzdG9tIHggLT4geFxuICA7O1xuXG4gIG1vZHVsZSBNb25hZF9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoID4+PSApIHQgZiA9IGJpbmQgdCB+ZlxuICAgIGxldCAoID4+fCApIHQgZiA9IG1hcCB0IH5mXG4gIGVuZFxuXG4gIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cblxuICAgIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICBsZXQgYmluZCA9IGJpbmRcbiAgICAgIGxldCBtYXAgPSBtYXBcbiAgICAgIGxldCBib3RoIGEgYiA9IGEgPj49IGZ1biBhIC0+IGIgPj58IGZ1biBiIC0+IGEsIGJcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzID0gc3RydWN0IGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBsZXQgam9pbiB0ID0gdCA+Pj0gZnVuIHQnIC0+IHQnXG4gIGxldCBpZ25vcmVfbSB0ID0gbWFwIHQgfmY6KGZ1biBfIC0+ICgpKVxuXG4gIGxldCBhbGwgPVxuICAgIGxldCByZWMgbG9vcCB2cyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJldHVybiAoTGlzdC5yZXYgdnMpXG4gICAgICB8IHQgOjogdHMgLT4gdCA+Pj0gZnVuIHYgLT4gbG9vcCAodiA6OiB2cykgdHNcbiAgICBpblxuICAgIGZ1biB0cyAtPiBsb29wIFtdIHRzXG4gIDs7XG5cbiAgbGV0IHJlYyBhbGxfdW5pdCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXR1cm4gKClcbiAgICB8IHQgOjogdHMgLT4gdCA+Pj0gZnVuICgpIC0+IGFsbF91bml0IHRzXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2VfaW5kZXhlZCAoTSA6IEJhc2ljX2luZGV4ZWQpIDpcbiAgU19pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgTS50ID0gTWFrZV9nZW5lcmFsIChzdHJ1Y3RcbiAgICBpbmNsdWRlIE1cblxuICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2ksICdqKSBNLnRcbiAgZW5kKVxuXG5tb2R1bGUgTWFrZTMgKE0gOiBCYXNpYzMpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSBNLnQgPVxuICBNYWtlX2dlbmVyYWwgKHN0cnVjdFxuICAgIGluY2x1ZGUgTVxuXG4gICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCwgJ2UpIE0udFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlMiAoTSA6IEJhc2ljMikgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZCkgdCA6PSAoJ2EsICdkKSBNLnQgPSBNYWtlX2dlbmVyYWwgKHN0cnVjdFxuICAgIGluY2x1ZGUgTVxuXG4gICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgTS50XG4gIGVuZClcblxubW9kdWxlIE1ha2UgKE0gOiBCYXNpYykgOiBTIHdpdGggdHlwZSAnYSB0IDo9ICdhIE0udCA9IE1ha2VfZ2VuZXJhbCAoc3RydWN0XG4gICAgaW5jbHVkZSBNXG5cbiAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAnYSBNLnRcbiAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWRfZ2VuZXJhbCAoTW9uYWQgOiBzaWdcbiAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcblxuICAgIHZhbCBiaW5kXG4gICAgICA6ICAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG4gICAgICAtPiBmOignYSAtPiAoJ2IsICdqLCAnaywgJ2QsICdlKSB0KVxuICAgICAgLT4gKCdiLCAnaSwgJ2ssICdkLCAnZSkgdFxuXG4gICAgdmFsIG1hcCA6ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2ksICdqLCAnZCwgJ2UpIHRcbiAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCAnaSwgJ2ksICdkLCAnZSkgdFxuICBlbmQpIChNIDogc2lnXG4gICAgICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG5cbiAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0IC0+ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIE1vbmFkLnRcbiAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdpLCAnaiwgJ2QsICdlKSBNb25hZC50IC0+ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcbiAgICAgICAgZW5kKSA9XG4gIE1ha2VfZ2VuZXJhbCAoc3RydWN0XG4gICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnaSwgJ2osICdkLCAnZSkgTS50XG5cbiAgICBsZXQgcmV0dXJuIGEgPSBNLm9mX21vbmFkIChNb25hZC5yZXR1cm4gYSlcbiAgICBsZXQgYmluZCB0IH5mID0gTS5vZl9tb25hZCAoTW9uYWQuYmluZCAoTS50b19tb25hZCB0KSB+ZjooZnVuIGEgLT4gTS50b19tb25hZCAoZiBhKSkpXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gKGZ1biB0IH5mIC0+IE0ub2ZfbW9uYWQgKE1vbmFkLm1hcCAoTS50b19tb25hZCB0KSB+ZikpXG4gIGVuZClcblxubW9kdWxlIE9mX21vbmFkX2luZGV4ZWRcbiAgICAoTW9uYWQgOiBTX2luZGV4ZWQpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlICgnYSwgJ2ksICdqKSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2ksICdqKSB0IC0+ICgnYSwgJ2ksICdqKSBNb25hZC50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdpLCAnaikgTW9uYWQudCAtPiAoJ2EsICdpLCAnaikgdFxuICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCkgPVxuICBPZl9tb25hZF9nZW5lcmFsXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNb25hZFxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdpLCAnaikgTW9uYWQudFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1cblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnaSwgJ2opIE0udFxuICAgIGVuZClcblxubW9kdWxlIE9mX21vbmFkM1xuICAgIChNb25hZCA6IFMzKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsIHRvX21vbmFkIDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIE1vbmFkLnRcbiAgICAgICAgICAgICAgICAgICAgdmFsIG9mX21vbmFkIDogKCdhLCAnYiwgJ2MpIE1vbmFkLnQgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICAgICAgICAgICAgICAgIGVuZCkgPVxuICBPZl9tb25hZF9nZW5lcmFsXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNb25hZFxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkLCAnZSkgTW9uYWQudFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1cblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCwgJ2UpIE0udFxuICAgIGVuZClcblxubW9kdWxlIE9mX21vbmFkMlxuICAgIChNb25hZCA6IFMyKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIE1vbmFkLnRcbiAgICAgICAgICAgICAgICAgICAgdmFsIG9mX21vbmFkIDogKCdhLCAnYikgTW9uYWQudCAtPiAoJ2EsICdiKSB0XG4gICAgICAgICAgICAgICAgICBlbmQpID1cbiAgT2ZfbW9uYWRfZ2VuZXJhbFxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTW9uYWRcblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgTW9uYWQudFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1cblxuICAgICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgTS50XG4gICAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWRcbiAgICAoTW9uYWQgOiBTKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgIHR5cGUgJ2EgdFxuXG4gICAgICAgICAgICAgICAgICAgdmFsIHRvX21vbmFkIDogJ2EgdCAtPiAnYSBNb25hZC50XG4gICAgICAgICAgICAgICAgICAgdmFsIG9mX21vbmFkIDogJ2EgTW9uYWQudCAtPiAnYSB0XG4gICAgICAgICAgICAgICAgIGVuZCkgPVxuICBPZl9tb25hZF9nZW5lcmFsXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNb25hZFxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAnYSBNb25hZC50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTVxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAnYSBNLnRcbiAgICBlbmQpXG5cbm1vZHVsZSBJZGVudCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYVxuXG4gIGluY2x1ZGUgTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgICBsZXQgYmluZCBhIH5mID0gZiBhXG4gICAgICBsZXQgcmV0dXJuIGEgPSBhXG4gICAgICBsZXQgbWFwID0gYEN1c3RvbSAoZnVuIGEgfmYgLT4gZiBhKVxuICAgIGVuZClcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEFwcGxpY2F0aXZlX2ludGZcbm1vZHVsZSBMaXN0ID0gTGlzdDBcblxuKCoqIFRoaXMgbW9kdWxlIHNlcnZlcyBtb3N0bHkgYXMgYSBwYXJ0aWFsIGNoZWNrIHRoYXQgW1MyXSBhbmQgW1NdIGFyZSBpbiBzeW5jLCBidXRcbiAgICBhY3R1YWxseSBjYWxsaW5nIGl0IGlzIG9jY2FzaW9uYWxseSB1c2VmdWwuICopXG5tb2R1bGUgU190b19TMiAoWCA6IFMpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50XG5lbmRcblxubW9kdWxlIFMyX3RvX1MgKFggOiBTMikgOiBTIHdpdGggdHlwZSAnYSB0ID0gKCdhLCB1bml0KSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAnYSB0ID0gKCdhLCB1bml0KSBYLnRcbmVuZFxuXG5tb2R1bGUgUzJfdG9fUzMgKFggOiBTMikgOiBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudFxuZW5kXG5cbm1vZHVsZSBTM190b19TMiAoWCA6IFMzKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdkKSB0ID0gKCdhLCAnZCwgdW5pdCkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIHR5cGUgKCdhLCAnZCkgdCA9ICgnYSwgJ2QsIHVuaXQpIFgudFxuZW5kXG5cbm1vZHVsZSBNYWtlMyAoWCA6IEJhc2ljMykgOiBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICBsZXQgKCA8Kj4gKSA9IGFwcGx5XG4gIGxldCBkZXJpdmVkX21hcCB0IH5mID0gcmV0dXJuIGYgPCo+IHRcblxuICBsZXQgbWFwID1cbiAgICBtYXRjaCBYLm1hcCB3aXRoXG4gICAgfCBgRGVmaW5lX3VzaW5nX2FwcGx5IC0+IGRlcml2ZWRfbWFwXG4gICAgfCBgQ3VzdG9tIHggLT4geFxuICA7O1xuXG4gIGxldCAoID4+fCApIHQgZiA9IG1hcCB0IH5mXG4gIGxldCBtYXAyIHRhIHRiIH5mID0gbWFwIH5mIHRhIDwqPiB0YlxuICBsZXQgbWFwMyB0YSB0YiB0YyB+ZiA9IG1hcCB+ZiB0YSA8Kj4gdGIgPCo+IHRjXG4gIGxldCBhbGwgdHMgPSBMaXN0LmZvbGRfcmlnaHQgdHMgfmluaXQ6KHJldHVybiBbXSkgfmY6KG1hcDIgfmY6KGZ1biB4IHhzIC0+IHggOjogeHMpKVxuICBsZXQgYm90aCB0YSB0YiA9IG1hcDIgdGEgdGIgfmY6KGZ1biBhIGIgLT4gYSwgYilcbiAgbGV0ICggKj4gKSB1IHYgPSByZXR1cm4gKGZ1biAoKSB5IC0+IHkpIDwqPiB1IDwqPiB2XG4gIGxldCAoIDwqICkgdSB2ID0gcmV0dXJuIChmdW4geCAoKSAtPiB4KSA8Kj4gdSA8Kj4gdlxuICBsZXQgYWxsX3VuaXQgdHMgPSBMaXN0LmZvbGQgdHMgfmluaXQ6KHJldHVybiAoKSkgfmY6KCAqPiApXG5cbiAgbW9kdWxlIEFwcGxpY2F0aXZlX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPCo+ICkgPSAoIDwqPiApXG4gICAgbGV0ICggKj4gKSA9ICggKj4gKVxuICAgIGxldCAoIDwqICkgPSAoIDwqIClcbiAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgZW5kXG5lbmRcblxubW9kdWxlIE1ha2UyIChYIDogQmFzaWMyKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIFgudCA9IE1ha2UzIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFhcblxuICAgIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnRcbiAgZW5kKVxuXG5tb2R1bGUgTWFrZSAoWCA6IEJhc2ljKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgWC50ID0gTWFrZTIgKHN0cnVjdFxuICAgIGluY2x1ZGUgWFxuXG4gICAgdHlwZSAoJ2EsICdlKSB0ID0gJ2EgWC50XG4gIGVuZClcblxubW9kdWxlIE1ha2VfbGV0X3N5bnRheDNcbiAgICAoWCA6IEZvcl9sZXRfc3ludGF4MykgKEludGYgOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlIHR5cGUgU1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kKVxuICAgIChJbXBsIDogSW50Zi5TKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFhcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgICBpbmNsdWRlIFhcbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IEltcGxcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIE1ha2VfbGV0X3N5bnRheDJcbiAgICAoWCA6IEZvcl9sZXRfc3ludGF4MikgKEludGYgOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlIHR5cGUgU1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kKVxuICAgIChJbXBsIDogSW50Zi5TKSA9XG4gIE1ha2VfbGV0X3N5bnRheDNcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIFhcblxuICAgICAgdHlwZSAoJ2EsICdkLCBfKSB0ID0gKCdhLCAnZCkgWC50XG4gICAgZW5kKVxuICAgIChJbnRmKVxuICAgIChJbXBsKVxuXG5tb2R1bGUgTWFrZV9sZXRfc3ludGF4XG4gICAgKFggOiBGb3JfbGV0X3N5bnRheCkgKEludGYgOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUgdHlwZSBTXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZClcbiAgICAoSW1wbCA6IEludGYuUykgPVxuICBNYWtlX2xldF9zeW50YXgyXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBYXG5cbiAgICAgIHR5cGUgKCdhLCBfKSB0ID0gJ2EgWC50XG4gICAgZW5kKVxuICAgIChJbnRmKVxuICAgIChJbXBsKVxuXG4oKiogVGhpcyBmdW5jdG9yIGNsb3NlbHkgcmVzZW1ibGVzIFtNYWtlM10sIGFuZCBpbmRlZWQgaXQgY291bGQgYmUgaW1wbGVtZW50ZWRcbiAgICBtdWNoIHNob3J0ZXIgaW4gdGVybXMgb2YgW01ha2UzXS4gSG93ZXZlciwgd2UgaW1wbGVtZW50IGl0IGJ5IGhhbmQgc28gdGhhdFxuICAgIHRoZSByZXN1bHRpbmcgZnVuY3Rpb25zIGFyZSBtb3JlIGVmZmljaWVudCwgZS5nLiB1c2luZyBbbWFwMl0gZGlyZWN0bHkgaW5zdGVhZCBvZlxuICAgIGRlZmluaW5nIFthcHBseV0gaW4gdGVybXMgb2YgaXQgYW5kIHRoZW4gW21hcDJdIGluIHRlcm1zIG9mIHRoYXQuIEZvciBtb3N0XG4gICAgYXBwbGljYXRpdmVzIHRoaXMgZG9lcyBub3QgbWF0dGVyLCBidXQgZm9yIHNvbWUgKHN1Y2ggYXMgQm9uc2FpLlZhbHVlLnQpLCBpdCBoYXMgYVxuICAgIGxhcmdlciBpbXBhY3QuICopXG5tb2R1bGUgTWFrZTNfdXNpbmdfbWFwMiAoWCA6IEJhc2ljM191c2luZ19tYXAyKSA6XG4gIFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIGxldCBhcHBseSB0ZiB0YSA9IG1hcDIgdGYgdGEgfmY6KGZ1biBmIGEgLT4gZiBhKVxuICBsZXQgKCA8Kj4gKSA9IGFwcGx5XG4gIGxldCBkZXJpdmVkX21hcCB0IH5mID0gcmV0dXJuIGYgPCo+IHRcblxuICBsZXQgbWFwID1cbiAgICBtYXRjaCBYLm1hcCB3aXRoXG4gICAgfCBgRGVmaW5lX3VzaW5nX21hcDIgLT4gZGVyaXZlZF9tYXBcbiAgICB8IGBDdXN0b20geCAtPiB4XG4gIDs7XG5cbiAgbGV0ICggPj58ICkgdCBmID0gbWFwIHQgfmZcbiAgbGV0IGJvdGggdGEgdGIgPSBtYXAyIHRhIHRiIH5mOihmdW4gYSBiIC0+IGEsIGIpXG4gIGxldCBtYXAzIHRhIHRiIHRjIH5mID0gbWFwMiAobWFwMiB0YSB0YiB+ZikgdGMgfmY6KGZ1biBmYWIgYyAtPiBmYWIgYylcbiAgbGV0IGFsbCB0cyA9IExpc3QuZm9sZF9yaWdodCB0cyB+aW5pdDoocmV0dXJuIFtdKSB+ZjoobWFwMiB+ZjooZnVuIHggeHMgLT4geCA6OiB4cykpXG4gIGxldCAoICo+ICkgdSB2ID0gbWFwMiB1IHYgfmY6KGZ1biAoKSB5IC0+IHkpXG4gIGxldCAoIDwqICkgdSB2ID0gbWFwMiB1IHYgfmY6KGZ1biB4ICgpIC0+IHgpXG4gIGxldCBhbGxfdW5pdCB0cyA9IExpc3QuZm9sZCB0cyB+aW5pdDoocmV0dXJuICgpKSB+ZjooICo+IClcblxuICBtb2R1bGUgQXBwbGljYXRpdmVfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA8Kj4gKSA9ICggPCo+IClcbiAgICBsZXQgKCAqPiApID0gKCAqPiApXG4gICAgbGV0ICggPCogKSA9ICggPCogKVxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTWFrZTJfdXNpbmdfbWFwMiAoWCA6IEJhc2ljMl91c2luZ19tYXAyKSA6XG4gIFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIFgudCA9IE1ha2UzX3VzaW5nX21hcDIgKHN0cnVjdFxuICAgIGluY2x1ZGUgWFxuXG4gICAgdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlX3VzaW5nX21hcDIgKFggOiBCYXNpY191c2luZ19tYXAyKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgWC50ID1cbiAgTWFrZTJfdXNpbmdfbWFwMiAoc3RydWN0XG4gICAgaW5jbHVkZSBYXG5cbiAgICB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnRcbiAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWQyIChNIDogTW9uYWQuUzIpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgTS50ID0gTWFrZTIgKHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UpIE0udFxuXG4gICAgbGV0IHJldHVybiA9IE0ucmV0dXJuXG4gICAgbGV0IGFwcGx5IG1mIG14ID0gTS5iaW5kIG1mIH5mOihmdW4gZiAtPiBNLm1hcCBteCB+ZilcbiAgICBsZXQgbWFwID0gYEN1c3RvbSBNLm1hcFxuICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZCAoTSA6IE1vbmFkLlMpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBNLnQgPSBPZl9tb25hZDIgKHN0cnVjdFxuICAgIGluY2x1ZGUgTVxuXG4gICAgdHlwZSAoJ2EsIF8pIHQgPSAnYSBNLnRcbiAgZW5kKVxuXG5tb2R1bGUgQ29tcG9zZSAoRiA6IFMpIChHIDogUykgOiBTIHdpdGggdHlwZSAnYSB0ID0gJ2EgRi50IEcudCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBGLnQgRy50XG5cbiAgaW5jbHVkZSBNYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICAgIGxldCByZXR1cm4gYSA9IEcucmV0dXJuIChGLnJldHVybiBhKVxuICAgICAgbGV0IGFwcGx5IHRmIHR4ID0gRy5hcHBseSAoRy5tYXAgfmY6Ri5hcHBseSB0ZikgdHhcbiAgICAgIGxldCBjdXN0b21fbWFwIHQgfmYgPSBHLm1hcCB+ZjooRi5tYXAgfmYpIHRcbiAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIGN1c3RvbV9tYXBcbiAgICBlbmQpXG5lbmRcblxubW9kdWxlIFBhaXIgKEYgOiBTKSAoRyA6IFMpIDogUyB3aXRoIHR5cGUgJ2EgdCA9ICdhIEYudCAqICdhIEcudCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBGLnQgKiAnYSBHLnRcblxuICBpbmNsdWRlIE1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgICAgbGV0IHJldHVybiBhID0gRi5yZXR1cm4gYSwgRy5yZXR1cm4gYVxuICAgICAgbGV0IGFwcGx5IHRmIHR4ID0gRi5hcHBseSAoZnN0IHRmKSAoZnN0IHR4KSwgRy5hcHBseSAoc25kIHRmKSAoc25kIHR4KVxuICAgICAgbGV0IGN1c3RvbV9tYXAgdCB+ZiA9IEYubWFwIH5mIChmc3QgdCksIEcubWFwIH5mIChzbmQgdClcbiAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIGN1c3RvbV9tYXBcbiAgICBlbmQpXG5lbmRcbiIsIigqIFtCeXRlczBdIGRlZmluZXMgc3RyaW5nIGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHlcbiAgIGRlZmluZWQgaW4gdGVybXMgb2YgW0NhbWwuQnl0ZXNdLiBbQnl0ZXMwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3NcbiAgIHRoZSBwYXJ0IG9mIFtDYW1sLkJ5dGVzXSB0aGF0IFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlclxuICAgdGhhbiBieXRlczAubWwgc2hvdWxkIHVzZSBbQ2FtbC5CeXRlc10uIFtCeXRlczBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmRcbiAgIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuXG5cbiAgIEFsbCBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2Ugc3RyaW5ncyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuQnl0ZXNdIGluXG4gICBidWlsZCBvcmRlciBzaG91bGQgZG86XG5cbiAgIHtbXG4gICAgIG1vZHVsZSBCeXRlcyAgPSBCeXRlczBcbiAgIF19XG5cbiAgIERlZmluaW5nIFttb2R1bGUgQnl0ZXMgPSBCeXRlczBdIGlzIGFsc28gbmVjZXNzYXJ5IGJlY2F1c2UgaXQgcHJldmVudHNcbiAgIG9jYW1sZGVwIGZyb20gbWlzdGFrZW5seSBjYXVzaW5nIGEgZmlsZSB0byBkZXBlbmQgb24gW0Jhc2UuQnl0ZXNdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5tb2R1bGUgU3lzID0gU3lzMFxuXG5tb2R1bGUgUHJpbWl0aXZlcyA9IHN0cnVjdFxuICBleHRlcm5hbCBnZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciA9IFwiJWJ5dGVzX3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgbGVuZ3RoIDogYnl0ZXMgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCAgICAgICAgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuXG4gICgqIFt1bnNhZmVfYmxpdF9zdHJpbmddIGlzIG5vdCBleHBvcnRlZCBpbiB0aGUgW3N0ZGxpYl0gc28gd2UgZXhwb3J0IGl0IGhlcmUgKilcbiAgZXh0ZXJuYWwgdW5zYWZlX2JsaXRfc3RyaW5nXG4gICAgOiAgc3JjOnN0cmluZ1xuICAgIC0+IHNyY19wb3M6aW50XG4gICAgLT4gZHN0OmJ5dGVzXG4gICAgLT4gZHN0X3BvczppbnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gdW5pdFxuICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCB1bnNhZmVfZ2V0X2ludDY0IDogYnl0ZXMgLT4gaW50IC0+IGludDY0ID0gXCIlY2FtbF9ieXRlc19nZXQ2NHVcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0X2ludDY0IDogYnl0ZXMgLT4gaW50IC0+IGludDY0IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDY0dVwiXG5lbmRcblxuaW5jbHVkZSBQcmltaXRpdmVzXG5cbmxldCBtYXhfbGVuZ3RoID0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG5sZXQgYmxpdCA9IENhbWwuQnl0ZXMuYmxpdFxubGV0IGJsaXRfc3RyaW5nID0gQ2FtbC5CeXRlcy5ibGl0X3N0cmluZ1xubGV0IGNvbXBhcmUgPSBDYW1sLkJ5dGVzLmNvbXBhcmVcbmxldCBjb3B5ID0gQ2FtbC5CeXRlcy5jb3B5XG5sZXQgY3JlYXRlID0gQ2FtbC5CeXRlcy5jcmVhdGVcbmxldCBmaWxsID0gQ2FtbC5CeXRlcy5maWxsXG5sZXQgbWFrZSA9IENhbWwuQnl0ZXMubWFrZVxubGV0IG1hcCA9IENhbWwuQnl0ZXMubWFwXG5sZXQgbWFwaSA9IENhbWwuQnl0ZXMubWFwaVxubGV0IHN1YiA9IENhbWwuQnl0ZXMuc3ViXG5sZXQgdW5zYWZlX2JsaXQgPSBDYW1sLkJ5dGVzLnVuc2FmZV9ibGl0XG5sZXQgdG9fc3RyaW5nID0gQ2FtbC5CeXRlcy50b19zdHJpbmdcbmxldCBvZl9zdHJpbmcgPSBDYW1sLkJ5dGVzLm9mX3N0cmluZ1xubGV0IHVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6cyA9IENhbWwuQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzXG5sZXQgdW5zYWZlX29mX3N0cmluZ19wcm9taXNlX25vX211dGF0aW9uID0gQ2FtbC5CeXRlcy51bnNhZmVfb2Zfc3RyaW5nXG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSAoJ2EsICd3aXRuZXNzKSB0ID1cbiAgeyBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50XG4gIDsgc2V4cF9vZl90IDogJ2EgLT4gU2V4cC50XG4gIH1cblxudHlwZSAoJ2EsICdiKSBjb21wYXJhdG9yID0gKCdhLCAnYikgdFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgdFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yIDogKHQsIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSB0eXBlIFMxID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yIDogKCdhIHQsIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfZmMgPSBzaWdcbiAgdHlwZSBjb21wYXJhYmxlX3RcblxuICBpbmNsdWRlIFMgd2l0aCB0eXBlIHQgOj0gY29tcGFyYWJsZV90XG5lbmRcblxubW9kdWxlIE1vZHVsZSA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPSAobW9kdWxlIFMgd2l0aCB0eXBlIHQgPSAnYSBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSAnYilcbmVuZFxuXG5sZXQgbWFrZSAodHlwZSB0KSB+Y29tcGFyZSB+c2V4cF9vZl90ID1cbiAgKG1vZHVsZSBzdHJ1Y3RcbiAgICB0eXBlIGNvbXBhcmFibGVfdCA9IHRcbiAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gICAgbGV0IGNvbXBhcmF0b3IgPSB7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGVuZCA6IFNfZmNcbiAgICB3aXRoIHR5cGUgY29tcGFyYWJsZV90ID0gdClcbjs7XG5cbm1vZHVsZSBTX3RvX1MxIChTIDogUykgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gUy50XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gUy5jb21wYXJhdG9yX3dpdG5lc3NcblxuICBvcGVuIFNcblxuICBsZXQgY29tcGFyYXRvciA9IGNvbXBhcmF0b3JcbmVuZFxuXG5tb2R1bGUgTWFrZSAoTSA6IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgPVxuc3RydWN0XG4gIGluY2x1ZGUgTVxuXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBNLnsgY29tcGFyZTsgc2V4cF9vZl90IH1cbmVuZFxuXG5tb2R1bGUgTWFrZTEgKE0gOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBjb21wYXJlIDogJ2EgdCAtPiAnYSB0IC0+IGludFxuICAgIHZhbCBzZXhwX29mX3QgOiAnYSB0IC0+IFNleHAudFxuICBlbmQpID1cbnN0cnVjdFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yID0gTS57IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5lbmRcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2FcblxuICBpbmNsdWRlIE1ha2UxIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG5cbiAgICAgIGxldCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gICAgICBsZXQgc2V4cF9vZl90IF8gPSBTZXhwLkF0b20gXCJfXCJcbiAgICBlbmQpXG5lbmRcblxubW9kdWxlIHR5cGUgRGVyaXZlZCA9IHNpZ1xuICB0eXBlICdhIHRcbiAgdHlwZSAnY21wIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yIDogKCdhLCAnY21wKSBjb21wYXJhdG9yIC0+ICgnYSB0LCAnY21wIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSBEZXJpdmVkIChNIDogc2lnXG4gICAgdHlwZSAnYSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICB2YWwgc2V4cF9vZl90IDogKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgJ2NtcCBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciBhID1cbiAgICB7IGNvbXBhcmUgPSBNLmNvbXBhcmUgYS5jb21wYXJlOyBzZXhwX29mX3QgPSBNLnNleHBfb2ZfdCBhLnNleHBfb2ZfdCB9XG4gIDs7XG5lbmRcblxubW9kdWxlIHR5cGUgRGVyaXZlZDIgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG4gIHR5cGUgKCdjbXBfYSwgJ2NtcF9iKSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgY29tcGFyYXRvclxuICAgIDogICgnYSwgJ2NtcF9hKSBjb21wYXJhdG9yXG4gICAgLT4gKCdiLCAnY21wX2IpIGNvbXBhcmF0b3JcbiAgICAtPiAoKCdhLCAnYikgdCwgKCdjbXBfYSwgJ2NtcF9iKSBjb21wYXJhdG9yX3dpdG5lc3MpIGNvbXBhcmF0b3JcbmVuZFxuXG5tb2R1bGUgRGVyaXZlZDIgKE0gOiBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICAgIHZhbCBzZXhwX29mX3RcbiAgICAgIDogICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2IgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdhLCAnYikgdFxuICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpID1cbnN0cnVjdFxuICB0eXBlICgnY21wX2EsICdjbXBfYikgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgYSBiID1cbiAgICB7IGNvbXBhcmUgPSBNLmNvbXBhcmUgYS5jb21wYXJlIGIuY29tcGFyZVxuICAgIDsgc2V4cF9vZl90ID0gTS5zZXhwX29mX3QgYS5zZXhwX29mX3QgYi5zZXhwX29mX3RcbiAgICB9XG4gIDs7XG5lbmRcblxubW9kdWxlIHR5cGUgRGVyaXZlZF9waGFudG9tID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICdjbXAgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3JcbiAgICA6ICAoJ2EsICdjbXApIGNvbXBhcmF0b3JcbiAgICAtPiAoKCdhLCBfKSB0LCAnY21wIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSBEZXJpdmVkX3BoYW50b20gKE0gOiBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBjb21wYXJlIDogKCdhIC0+ICdhIC0+IGludCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGludFxuICAgIHZhbCBzZXhwX29mX3QgOiAoJ2EgLT4gU2V4cC50KSAtPiAoJ2EsIF8pIHQgLT4gU2V4cC50XG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgJ2NtcF9hIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yIGEgPVxuICAgIHsgY29tcGFyZSA9IE0uY29tcGFyZSBhLmNvbXBhcmU7IHNleHBfb2ZfdCA9IE0uc2V4cF9vZl90IGEuc2V4cF9vZl90IH1cbiAgOztcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgKCdmLCAncykgdCA9XG4gIHwgRmlyc3Qgb2YgJ2ZcbiAgfCBTZWNvbmQgb2YgJ3NcbltAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCBjb21wYXJlIDpcbiAgJ2YgJ3MuICgnZiAtPiAnZiAtPiBpbnQpIC0+ICgncyAtPiAncyAtPiBpbnQpIC0+ICgnZiwgJ3MpIHQgLT4gKCdmLCAncykgdCAtPiBpbnRcbiAgPVxuICBmdW4gX2NtcF9fZiBfY21wX19zIGFfXzAwMV8gYl9fMDAyXyAtPlxuICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMDFfIGJfXzAwMl9cbiAgdGhlbiAwXG4gIGVsc2UgKFxuICAgIG1hdGNoIGFfXzAwMV8sIGJfXzAwMl8gd2l0aFxuICAgIHwgRmlyc3QgX2FfXzAwM18sIEZpcnN0IF9iX18wMDRfIC0+IF9jbXBfX2YgX2FfXzAwM18gX2JfXzAwNF9cbiAgICB8IEZpcnN0IF8sIF8gLT4gLTFcbiAgICB8IF8sIEZpcnN0IF8gLT4gMVxuICAgIHwgU2Vjb25kIF9hX18wMDVfLCBTZWNvbmQgX2JfXzAwNl8gLT4gX2NtcF9fcyBfYV9fMDA1XyBfYl9fMDA2Xylcbjs7XG5cbmxldCBoYXNoX2ZvbGRfdFxuICA6IHR5cGUgZiBzLlxuICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gZiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgLT4gKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBzIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAtPiAoZiwgcykgdFxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICA9XG4gIGZ1biBfaGFzaF9mb2xkX2YgX2hhc2hfZm9sZF9zIGhzdiBhcmcgLT5cbiAgbWF0Y2ggYXJnIHdpdGhcbiAgfCBGaXJzdCBfYTAgLT5cbiAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwIGluXG4gICAgbGV0IGhzdiA9IGhzdiBpblxuICAgIF9oYXNoX2ZvbGRfZiBoc3YgX2EwXG4gIHwgU2Vjb25kIF9hMCAtPlxuICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDEgaW5cbiAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgX2hhc2hfZm9sZF9zIGhzdiBfYTBcbjs7XG5cbmxldCB0X29mX3NleHAgOlxuICAnZiAncy5cbiAgKFNleHBsaWIwLlNleHAudCAtPiAnZikgLT4gKFNleHBsaWIwLlNleHAudCAtPiAncykgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICgnZiwgJ3MpIHRcbiAgPVxuICBmdW4gKHR5cGUgZl9fMDIzXyBzX18wMjRfKVxuICAgICAgOiAgKChTZXhwbGliMC5TZXhwLnQgLT4gZl9fMDIzXykgLT4gKFNleHBsaWIwLlNleHAudCAtPiBzX18wMjRfKSAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAgICAgICAtPiAoZl9fMDIzXywgc19fMDI0XykgdCkgLT5cbiAgICBsZXQgZXJyb3Jfc291cmNlX18wMTFfID0gXCJlaXRoZXIwLm1sLnRcIiBpblxuICAgIGZ1biBfb2ZfZl9fMDA3XyBfb2Zfc19fMDA4XyAtPiBmdW5jdGlvblxuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJmaXJzdFwiIHwgXCJGaXJzdFwiKSBhcyBfdGFnX18wMTRfKSA6OiBzZXhwX2FyZ3NfXzAxNV8pIGFzXG4gICAgICAgIF9zZXhwX18wMTNfIC0+XG4gICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAxNV8gd2l0aFxuICAgICAgICAgfCBbIGFyZzBfXzAxNl8gXSAtPlxuICAgICAgICAgICBsZXQgcmVzMF9fMDE3XyA9IF9vZl9mX18wMDdfIGFyZzBfXzAxNl8gaW5cbiAgICAgICAgICAgRmlyc3QgcmVzMF9fMDE3X1xuICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAxMV9cbiAgICAgICAgICAgICBfdGFnX18wMTRfXG4gICAgICAgICAgICAgX3NleHBfXzAxM18pXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcInNlY29uZFwiIHwgXCJTZWNvbmRcIikgYXMgX3RhZ19fMDE5XykgOjogc2V4cF9hcmdzX18wMjBfKSBhc1xuICAgICAgICBfc2V4cF9fMDE4XyAtPlxuICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMjBfIHdpdGhcbiAgICAgICAgIHwgWyBhcmcwX18wMjFfIF0gLT5cbiAgICAgICAgICAgbGV0IHJlczBfXzAyMl8gPSBfb2Zfc19fMDA4XyBhcmcwX18wMjFfIGluXG4gICAgICAgICAgIFNlY29uZCByZXMwX18wMjJfXG4gICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDExX1xuICAgICAgICAgICAgIF90YWdfXzAxOV9cbiAgICAgICAgICAgICBfc2V4cF9fMDE4XylcbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImZpcnN0XCIgfCBcIkZpcnN0XCIpIGFzIHNleHBfXzAxMl8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAxMV8gc2V4cF9fMDEyX1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwic2Vjb25kXCIgfCBcIlNlY29uZFwiKSBhcyBzZXhwX18wMTJfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMTFfIHNleHBfXzAxMl9cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMTBfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAxMV8gc2V4cF9fMDEwX1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDEwXyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAxMV8gc2V4cF9fMDEwX1xuICAgICAgfCBzZXhwX18wMTBfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMTFfIHNleHBfXzAxMF9cbjs7XG5cbmxldCBzZXhwX29mX3QgOlxuICAnZiAncy5cbiAgKCdmIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdzIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdmLCAncykgdCAtPiBTZXhwbGliMC5TZXhwLnRcbiAgPVxuICBmdW4gKHR5cGUgZl9fMDMxXyBzX18wMzJfKVxuICAgICAgOiAgKChmX18wMzFfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKHNfXzAzMl8gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAgIC0+IChmX18wMzFfLCBzX18wMzJfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICBmdW4gX29mX2ZfXzAyNV8gX29mX3NfXzAyNl8gLT4gZnVuY3Rpb25cbiAgICAgIHwgRmlyc3QgYXJnMF9fMDI3XyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDI4XyA9IF9vZl9mX18wMjVfIGFyZzBfXzAyN18gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiRmlyc3RcIjsgcmVzMF9fMDI4XyBdXG4gICAgICB8IFNlY29uZCBhcmcwX18wMjlfIC0+XG4gICAgICAgIGxldCByZXMwX18wMzBfID0gX29mX3NfXzAyNl8gYXJnMF9fMDI5XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJTZWNvbmRcIjsgcmVzMF9fMDMwXyBdXG47O1xuXG5sZXQgKHRfc2V4cF9ncmFtbWFyIDpcbiAgICAgICAnZiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAtPiAncyBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAtPiAoJ2YsICdzKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA9XG4gIGZ1biBfJ2Zfc2V4cF9ncmFtbWFyIF8nc19zZXhwX2dyYW1tYXIgLT5cbiAgeyB1bnR5cGVkID1cbiAgICAgIFZhcmlhbnRcbiAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgWyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkZpcnN0XCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydmX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJTZWNvbmRcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ3Nfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbltAQEBlbmRdXG4iLCIoKiBUaGUgdHlwZSBbdF0gc2hvdWxkIGJlIGFic3RyYWN0IHRvIG1ha2UgdGhlIGZzZXQgYW5kIHNldCBmdW5jdGlvbnMgdW5hdmFpbGFibGVcbiAgIGZvciBwcml2YXRlIHR5cGVzIGF0IHRoZSBsZXZlbCBvZiB0eXBlcyAoYW5kIG5vdCBieSBwdXR0aW5nIE5vbmUgaW4gdGhlIGZpZWxkKS5cbiAgIFVuZm9ydHVuYXRlbHksIG1ha2luZyB0aGUgdHlwZSBhYnN0cmFjdCBtZWFucyB0aGF0IHdoZW4gY3JlYXRpbmcgZmllbGRzICh0aHJvdWdoXG4gICBhIFtjcmVhdGVdIGZ1bmN0aW9uKSB2YWx1ZSByZXN0cmljdGlvbiBraWNrcyBpbi4gVGhpcyBpcyB3b3JrZWQgYXJvdW5kIGJ5IGluc3RlYWRcbiAgIG5vdCBtYWtpbmcgdGhlIHR5cGUgYWJzdHJhY3QsIGJ1dCBmb3JjaW5nIGFueW9uZSBicmVha2luZyB0aGUgYWJzdHJhY3Rpb24gdG8gdXNlXG4gICB0aGUgW0Zvcl9nZW5lcmF0ZWRfY29kZV0gbW9kdWxlLCBtYWtpbmcgaXQgb2J2aW91cyB0byBhbnkgcmVhZGVyIHRoYXQgc29tZXRoaW5nIHVnbHlcbiAgIGlzIGdvaW5nIG9uLlxuICAgdF93aXRoX3Blcm0gKGFuZCBkZXJpdmF0aXZlcykgaXMgdGhlIHR5cGUgdGhhdCB1c2VycyByZWFsbHkgdXNlLiBJdCBpcyBhIGNvbnN0cnVjdG9yXG4gICBiZWNhdXNlOlxuICAgMS4gaXQgbWFrZXMgdHlwZSBlcnJvcnMgbW9yZSByZWFkYWJsZSAobGVzcyBhbGlhc2luZylcbiAgIDIuIHRoZSB0eXBlciBpbiBvY2FtbCA0LjAxIGFsbG93cyB0aGlzOlxuXG4gICB7W1xuICAgICBtb2R1bGUgQSA9IHN0cnVjdFxuICAgICAgIHR5cGUgdCA9IHthIDogaW50fVxuICAgICBlbmRcbiAgICAgdHlwZSB0ID0gQS50XG4gICAgIGxldCBmICh4IDogdCkgPSB4LmFcbiAgIF19XG5cbiAgIChhbHRob3VnaCB3aXRoIFdhcm5pbmcgNDA6IGEgaXMgdXNlZCBvdXQgb2Ygc2NvcGUpXG4gICB3aGljaCBtZWFucyB0aGF0IGlmIFt0X3dpdGhfcGVybV0gd2FzIHJlYWxseSBhbiBhbGlhcyBvbiBbRm9yX2dlbmVyYXRlZF9jb2RlLnRdLFxuICAgcGVvcGxlIGNvdWxkIHNheSBbdC5zZXR0ZXJdIGFuZCBicmVhayB0aGUgYWJzdHJhY3Rpb24gd2l0aCBubyBpbmRpY2F0aW9uIHRoYXRcbiAgIHNvbWV0aGluZyB1Z2x5IGlzIGdvaW5nIG9uIGluIHRoZSBzb3VyY2UgY29kZS5cbiAgIFRoZSB3YXJuaW5nIGlzIChJIHRoaW5rKSBmb3IgcGVvcGxlIHdobyB3YW50IHRvIG1ha2UgdGhlaXIgY29kZSBjb21wYXRpYmxlIHdpdGhcbiAgIHByZXZpb3VzIHZlcnNpb25zIG9mIG9jYW1sLCBzbyB3ZSBtYXkgdmVyeSB3ZWxsIHR1cm4gaXQgb2ZmLlxuXG4gICBUaGUgdHlwZSB0X3dpdGhfcGVybSBjb3VsZCBhbHNvIGhhdmUgYmVlbiBhIFt1bml0IC0+IEZvcl9nZW5lcmF0ZWRfY29kZS50XSB0byB3b3JrXG4gICBhcm91bmQgdmFsdWUgcmVzdHJpY3Rpb24gYW5kIHRoZW4gW0Zvcl9nZW5lcmF0ZWRfY29kZS50XSB3b3VsZCBoYXZlIGJlZW4gYSBwcm9wZXJcbiAgIGFic3RyYWN0IHR5cGUsIGJ1dCBpdCBsb29rcyBsaWtlIGl0IGNvdWxkIGltcGFjdCBwZXJmb3JtYW5jZSAoZm9yIGV4YW1wbGUsIGEgZm9sZCBvbiBhXG4gICByZWNvcmQgdHlwZSB3aXRoIDQwIGZpZWxkcyB3b3VsZCBhY3R1YWxseSBhbGxvY2F0ZSB0aGUgNDAgW0Zvcl9nZW5lcmF0ZWRfY29kZS50XSdzIGF0XG4gICBldmVyeSBzaW5nbGUgZm9sZC4pICopXG5cbm1vZHVsZSBGb3JfZ2VuZXJhdGVkX2NvZGUgPSBzdHJ1Y3RcbiAgdHlwZSAoJ3Blcm0sICdyZWNvcmQsICdmaWVsZCkgdCA9XG4gICAgeyBmb3JjZV92YXJpYW5jZSA6ICdwZXJtIC0+IHVuaXRcbiAgICA7ICgqIGZvcmNlIFt0XSB0byBiZSBjb250cmF2YXJpYW50IGluIFsncGVybV0sIGJlY2F1c2UgcGhhbnRvbSB0eXBlIHZhcmlhYmxlcyBvblxuICAgICAgICAgY29uY3JldGUgdHlwZXMgZG9uJ3Qgd29yayB0aGF0IHdlbGwgb3RoZXJ3aXNlICh1c2luZyA6PiBjYW4gcmVtb3ZlIHRoZW0gZWFzaWx5KSAqKVxuICAgICAgbmFtZSA6IHN0cmluZ1xuICAgIDsgc2V0dGVyIDogKCdyZWNvcmQgLT4gJ2ZpZWxkIC0+IHVuaXQpIG9wdGlvblxuICAgIDsgZ2V0dGVyIDogJ3JlY29yZCAtPiAnZmllbGRcbiAgICA7IGZzZXQgOiAncmVjb3JkIC0+ICdmaWVsZCAtPiAncmVjb3JkXG4gICAgfVxuXG4gIGxldCBvcGFxdWVfaWRlbnRpdHkgPSBTeXMwLm9wYXF1ZV9pZGVudGl0eVxuZW5kXG5cbnR5cGUgKCdwZXJtLCAncmVjb3JkLCAnZmllbGQpIHRfd2l0aF9wZXJtID1cbiAgfCBGaWVsZCBvZiAoJ3Blcm0sICdyZWNvcmQsICdmaWVsZCkgRm9yX2dlbmVyYXRlZF9jb2RlLnRcbltAQHVuYm94ZWRdXG5cbnR5cGUgKCdyZWNvcmQsICdmaWVsZCkgdCA9IChbIGBSZWFkIHwgYFNldF9hbmRfY3JlYXRlIF0sICdyZWNvcmQsICdmaWVsZCkgdF93aXRoX3Blcm1cbnR5cGUgKCdyZWNvcmQsICdmaWVsZCkgcmVhZG9ubHlfdCA9IChbIGBSZWFkIF0sICdyZWNvcmQsICdmaWVsZCkgdF93aXRoX3Blcm1cblxubGV0IG5hbWUgKEZpZWxkIGZpZWxkKSA9IGZpZWxkLm5hbWVcbmxldCBnZXQgKEZpZWxkIGZpZWxkKSByID0gZmllbGQuZ2V0dGVyIHJcbmxldCBmc2V0IChGaWVsZCBmaWVsZCkgciB2ID0gZmllbGQuZnNldCByIHZcbmxldCBzZXR0ZXIgKEZpZWxkIGZpZWxkKSA9IGZpZWxkLnNldHRlclxuXG50eXBlICgncGVybSwgJ3JlY29yZCwgJ3Jlc3VsdCkgdXNlciA9XG4gIHsgZiA6ICdmaWVsZC4gKCdwZXJtLCAncmVjb3JkLCAnZmllbGQpIHRfd2l0aF9wZXJtIC0+ICdyZXN1bHQgfVxuXG5sZXQgbWFwIChGaWVsZCBmaWVsZCkgciB+ZiA9IGZpZWxkLmZzZXQgciAoZiAoZmllbGQuZ2V0dGVyIHIpKVxuXG5sZXQgdXBkYXRlciAoRmllbGQgZmllbGQpID1cbiAgbWF0Y2ggZmllbGQuc2V0dGVyIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHNldHRlciAtPiBTb21lIChmdW4gciB+ZiAtPiBzZXR0ZXIgciAoZiAoZmllbGQuZ2V0dGVyIHIpKSlcbjs7XG4iLCIoKiBbU3RyaW5nMF0gZGVmaW5lcyBzdHJpbmcgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluXG4gICB0ZXJtcyBvZiBbQ2FtbC5TdHJpbmddLiBbU3RyaW5nMF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZSBwYXJ0IG9mXG4gICBbQ2FtbC5TdHJpbmddIHRoYXQgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyIHRoYW4gc3RyaW5nMC5tbCBzaG91bGRcbiAgIHVzZSBbQ2FtbC5TdHJpbmddLiAgW1N0cmluZzBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2Unc1xuICAgYnVpbGQgb3JkZXIuXG5cbiAgIEFsbCBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2Ugc3RyaW5ncywgaW5jbHVkaW5nIHRoZSBzdWJzY3JpcHQgc3ludGF4XG4gICBbeC4oaSldIG9yIFt4LihpKSA8LSBlXSB3aGljaCB0aGUgT0NhbWwgcGFyc2VyIGRlc3VnYXJzIGludG8gY2FsbHMgdG9cbiAgIFtTdHJpbmddLCBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuU3RyaW5nXSBpbiBidWlsZCBvcmRlciBzaG91bGQgZG9cblxuICAge1tcbiAgICAgbW9kdWxlIFN0cmluZyA9IFN0cmluZzBcbiAgIF19XG5cbiAgIERlZmluaW5nIFttb2R1bGUgU3RyaW5nID0gU3RyaW5nMF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdCBwcmV2ZW50c1xuICAgb2NhbWxkZXAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5TdHJpbmddLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5tb2R1bGUgQnl0ZXMgPSBCeXRlczBcbm1vZHVsZSBTeXMgPSBTeXMwXG5cbm1vZHVsZSBTdHJpbmcgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCBzZXQgICAgICAgIDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmVuZFxuXG5pbmNsdWRlIFN0cmluZ1xuXG5sZXQgbWF4X2xlbmd0aCA9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxubGV0ICggXiApID0gKCBeIClcbmxldCBjYXBpdGFsaXplID0gQ2FtbC5TdHJpbmcuY2FwaXRhbGl6ZV9hc2NpaVxubGV0IGNvbXBhcmUgPSBDYW1sLlN0cmluZy5jb21wYXJlXG5cbmxldCBjb3B5IHggPVxuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nXG4gICAgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6XG4gICAgICAoQnl0ZXMub2Zfc3RyaW5nIHgpXG47O1xuXG5sZXQgZXNjYXBlZCA9IENhbWwuU3RyaW5nLmVzY2FwZWRcbmxldCBsb3dlcmNhc2UgPSBDYW1sLlN0cmluZy5sb3dlcmNhc2VfYXNjaWlcbmxldCBtYWtlID0gQ2FtbC5TdHJpbmcubWFrZVxubGV0IHN1YiA9IENhbWwuU3RyaW5nLnN1YlxubGV0IHVuY2FwaXRhbGl6ZSA9IENhbWwuU3RyaW5nLnVuY2FwaXRhbGl6ZV9hc2NpaVxubGV0IHVuc2FmZV9ibGl0ID0gQ2FtbC5TdHJpbmcudW5zYWZlX2JsaXRcbmxldCB1cHBlcmNhc2UgPSBDYW1sLlN0cmluZy51cHBlcmNhc2VfYXNjaWlcblxubGV0IGNvbmNhdCA/KHNlcCA9IFwiXCIpIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBcIlwiXG4gICgqIFRoZSBzdGRsaWIgZG9lcyBub3Qgc3BlY2lhbGl6ZSB0aGlzIGNhc2UgYmVjYXVzZSBpdCBjb3VsZCBicmVhayBleGlzdGluZyBwcm9qZWN0cy4gKilcbiAgfCBbIHggXSAtPiB4XG4gIHwgbCAtPiBDYW1sLlN0cmluZy5jb25jYXQgfnNlcCBsXG47O1xuXG4oKiBUaGVzZSBhcmUgZXRhIGV4cGFuZGVkIGluIG9yZGVyIHRvIHBlcm11dGUgcGFyYW1ldGVyIG9yZGVyIHRvIGZvbGxvdyBCYXNlXG4gICBjb252ZW50aW9ucy4gKilcbmxldCBpdGVyIHQgfmYgPSBDYW1sLlN0cmluZy5pdGVyIHQgfmZcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEludCA9IEludDBcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IENhbWwuTGV4aW5nLnBvc2l0aW9uID1cbiAgICB7IHBvc19mbmFtZSA6IHN0cmluZ1xuICAgIDsgcG9zX2xudW0gOiBpbnRcbiAgICA7IHBvc19ib2wgOiBpbnRcbiAgICA7IHBvc19jbnVtIDogaW50XG4gICAgfVxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA9XG4gICAgKGZ1biBhX18wMDFfIGJfXzAwMl8gLT5cbiAgICAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMDFfIGJfXzAwMl9cbiAgICAgICB0aGVuIDBcbiAgICAgICBlbHNlIChcbiAgICAgICAgIG1hdGNoIGNvbXBhcmVfc3RyaW5nIGFfXzAwMV8ucG9zX2ZuYW1lIGJfXzAwMl8ucG9zX2ZuYW1lIHdpdGhcbiAgICAgICAgIHwgMCAtPlxuICAgICAgICAgICAobWF0Y2ggY29tcGFyZV9pbnQgYV9fMDAxXy5wb3NfbG51bSBiX18wMDJfLnBvc19sbnVtIHdpdGhcbiAgICAgICAgICAgIHwgMCAtPlxuICAgICAgICAgICAgICAobWF0Y2ggY29tcGFyZV9pbnQgYV9fMDAxXy5wb3NfYm9sIGJfXzAwMl8ucG9zX2JvbCB3aXRoXG4gICAgICAgICAgICAgICB8IDAgLT4gY29tcGFyZV9pbnQgYV9fMDAxXy5wb3NfY251bSBiX18wMDJfLnBvc19jbnVtXG4gICAgICAgICAgICAgICB8IG4gLT4gbilcbiAgICAgICAgICAgIHwgbiAtPiBuKVxuICAgICAgICAgfCBuIC0+IG4pXG4gICAgICAgICA6IHQgLT4gdCAtPiBpbnQpXG4gIDs7XG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGZ1biBoc3YgYXJnIC0+XG4gICAgICBsZXQgaHN2ID1cbiAgICAgICAgbGV0IGhzdiA9XG4gICAgICAgICAgbGV0IGhzdiA9XG4gICAgICAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgICAgICBoYXNoX2ZvbGRfc3RyaW5nIGhzdiBhcmcucG9zX2ZuYW1lXG4gICAgICAgICAgaW5cbiAgICAgICAgICBoYXNoX2ZvbGRfaW50IGhzdiBhcmcucG9zX2xudW1cbiAgICAgICAgaW5cbiAgICAgICAgaGFzaF9mb2xkX2ludCBoc3YgYXJnLnBvc19ib2xcbiAgICAgIGluXG4gICAgICBoYXNoX2ZvbGRfaW50IGhzdiBhcmcucG9zX2NudW1cbiAgOztcblxuICBsZXQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgYXJnID1cbiAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gICAgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuIHsgcG9zX2ZuYW1lID0gcG9zX2ZuYW1lX18wMDRfXG4gICAgICAgICA7IHBvc19sbnVtID0gcG9zX2xudW1fXzAwNl9cbiAgICAgICAgIDsgcG9zX2JvbCA9IHBvc19ib2xfXzAwOF9cbiAgICAgICAgIDsgcG9zX2NudW0gPSBwb3NfY251bV9fMDEwX1xuICAgICAgICAgfSAtPlxuICAgICAgbGV0IGJuZHNfXzAwM18gPSBbXSBpblxuICAgICAgbGV0IGJuZHNfXzAwM18gPVxuICAgICAgICBsZXQgYXJnX18wMTFfID0gc2V4cF9vZl9pbnQgcG9zX2NudW1fXzAxMF8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwicG9zX2NudW1cIjsgYXJnX18wMTFfIF0gOjogYm5kc19fMDAzX1xuICAgICAgaW5cbiAgICAgIGxldCBibmRzX18wMDNfID1cbiAgICAgICAgbGV0IGFyZ19fMDA5XyA9IHNleHBfb2ZfaW50IHBvc19ib2xfXzAwOF8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwicG9zX2JvbFwiOyBhcmdfXzAwOV8gXSA6OiBibmRzX18wMDNfXG4gICAgICBpblxuICAgICAgbGV0IGJuZHNfXzAwM18gPVxuICAgICAgICBsZXQgYXJnX18wMDdfID0gc2V4cF9vZl9pbnQgcG9zX2xudW1fXzAwNl8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwicG9zX2xudW1cIjsgYXJnX18wMDdfIF0gOjogYm5kc19fMDAzX1xuICAgICAgaW5cbiAgICAgIGxldCBibmRzX18wMDNfID1cbiAgICAgICAgbGV0IGFyZ19fMDA1XyA9IHNleHBfb2Zfc3RyaW5nIHBvc19mbmFtZV9fMDA0XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwb3NfZm5hbWVcIjsgYXJnX18wMDVfIF0gOjogYm5kc19fMDAzX1xuICAgICAgaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBibmRzX18wMDNfXG4gICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxuKCogVGhpcyBpcyB0aGUgc2FtZSBmdW5jdGlvbiBhcyBQcHhfaGVyZS5saWZ0X3Bvc2l0aW9uX2FzX3N0cmluZy4gKilcbmxldCBtYWtlX2xvY2F0aW9uX3N0cmluZyB+cG9zX2ZuYW1lIH5wb3NfbG51bSB+cG9zX2NudW0gfnBvc19ib2wgPVxuICBTdHJpbmcuY29uY2F0XG4gICAgWyBwb3NfZm5hbWU7IFwiOlwiOyBJbnQudG9fc3RyaW5nIHBvc19sbnVtOyBcIjpcIjsgSW50LnRvX3N0cmluZyAocG9zX2NudW0gLSBwb3NfYm9sKSBdXG47O1xuXG5sZXQgdG9fc3RyaW5nIHsgQ2FtbC5MZXhpbmcucG9zX2ZuYW1lOyBwb3NfbG51bTsgcG9zX2NudW07IHBvc19ib2wgfSA9XG4gIG1ha2VfbG9jYXRpb25fc3RyaW5nIH5wb3NfZm5hbWUgfnBvc19sbnVtIH5wb3NfY251bSB+cG9zX2JvbFxuOztcblxubGV0IHNleHBfb2ZfdCB0ID0gU2V4cC5BdG9tICh0b19zdHJpbmcgdClcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBMaXN0MFxuXG5sZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICB8IFtdIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgcGFydGl0aW9uX21hcCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHQgZnN0IHNuZCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiByZXYgZnN0LCByZXYgc25kXG4gICAgfCB4IDo6IHQgLT5cbiAgICAgIChtYXRjaCAoZiB4IDogXyBFaXRoZXIwLnQpIHdpdGhcbiAgICAgICB8IEZpcnN0IHkgLT4gbG9vcCB0ICh5IDo6IGZzdCkgc25kXG4gICAgICAgfCBTZWNvbmQgeSAtPiBsb29wIHQgZnN0ICh5IDo6IHNuZCkpXG4gIGluXG4gIGxvb3AgdCBbXSBbXVxuOztcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEVpdGhlciA9IEVpdGhlcjBcblxudHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgQ2FtbC5yZXN1bHQgPVxuICB8IE9rIG9mICdhXG4gIHwgRXJyb3Igb2YgJ2JcbltAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXIsIGNvbXBhcmUsIGVxdWFsLCBoYXNoXVxuXG5sZXQgdF9vZl9zZXhwIDpcbiAgJ2EgJ2IuXG4gIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ2IpIC0+IFNleHBsaWIwLlNleHAudCAtPiAoJ2EsICdiKSB0XG4gID1cbiAgZnVuICh0eXBlIGFfXzAxN18gYl9fMDE4XylcbiAgICAgIDogICgoU2V4cGxpYjAuU2V4cC50IC0+IGFfXzAxN18pIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gYl9fMDE4XykgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgICAgICAgLT4gKGFfXzAxN18sIGJfXzAxOF8pIHQpIC0+XG4gICAgbGV0IGVycm9yX3NvdXJjZV9fMDA1XyA9IFwicmVzdWx0Lm1sLnRcIiBpblxuICAgIGZ1biBfb2ZfYV9fMDAxXyBfb2ZfYl9fMDAyXyAtPiBmdW5jdGlvblxuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJva1wiIHwgXCJPa1wiKSBhcyBfdGFnX18wMDhfKSA6OiBzZXhwX2FyZ3NfXzAwOV8pIGFzXG4gICAgICAgIF9zZXhwX18wMDdfIC0+XG4gICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAwOV8gd2l0aFxuICAgICAgICAgfCBbIGFyZzBfXzAxMF8gXSAtPlxuICAgICAgICAgICBsZXQgcmVzMF9fMDExXyA9IF9vZl9hX18wMDFfIGFyZzBfXzAxMF8gaW5cbiAgICAgICAgICAgT2sgcmVzMF9fMDExX1xuICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAwNV9cbiAgICAgICAgICAgICBfdGFnX18wMDhfXG4gICAgICAgICAgICAgX3NleHBfXzAwN18pXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImVycm9yXCIgfCBcIkVycm9yXCIpIGFzIF90YWdfXzAxM18pIDo6IHNleHBfYXJnc19fMDE0XykgYXNcbiAgICAgICAgX3NleHBfXzAxMl8gLT5cbiAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDE0XyB3aXRoXG4gICAgICAgICB8IFsgYXJnMF9fMDE1XyBdIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wMTZfID0gX29mX2JfXzAwMl8gYXJnMF9fMDE1XyBpblxuICAgICAgICAgICBFcnJvciByZXMwX18wMTZfXG4gICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDA1X1xuICAgICAgICAgICAgIF90YWdfXzAxM19cbiAgICAgICAgICAgICBfc2V4cF9fMDEyXylcbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm9rXCIgfCBcIk9rXCIpIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA2X1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZXJyb3JcIiB8IFwiRXJyb3JcIikgYXMgc2V4cF9fMDA2XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDZfXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbiAgICAgIHwgc2V4cF9fMDA0XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG47O1xuXG5sZXQgc2V4cF9vZl90IDpcbiAgJ2EgJ2IuXG4gICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICgnYSwgJ2IpIHQgLT4gU2V4cGxpYjAuU2V4cC50XG4gID1cbiAgZnVuICh0eXBlIGFfXzAyNV8gYl9fMDI2XylcbiAgICAgIDogICgoYV9fMDI1XyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IChiX18wMjZfIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgICAtPiAoYV9fMDI1XywgYl9fMDI2XykgdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gICAgZnVuIF9vZl9hX18wMTlfIF9vZl9iX18wMjBfIC0+IGZ1bmN0aW9uXG4gICAgICB8IE9rIGFyZzBfXzAyMV8gLT5cbiAgICAgICAgbGV0IHJlczBfXzAyMl8gPSBfb2ZfYV9fMDE5XyBhcmcwX18wMjFfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIk9rXCI7IHJlczBfXzAyMl8gXVxuICAgICAgfCBFcnJvciBhcmcwX18wMjNfIC0+XG4gICAgICAgIGxldCByZXMwX18wMjRfID0gX29mX2JfXzAyMF8gYXJnMF9fMDIzXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJFcnJvclwiOyByZXMwX18wMjRfIF1cbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOlxuICAgICAgICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgIC0+ICdiIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgIC0+ICgnYSwgJ2IpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgXydiX3NleHBfZ3JhbW1hciAtPlxuICB7IHVudHlwZWQgPVxuICAgICAgVmFyaWFudFxuICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICBbIE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiT2tcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkVycm9yXCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydiX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICB9XG47O1xuXG5sZXQgY29tcGFyZSA6XG4gICdhICdiLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAoJ2IgLT4gJ2IgLT4gaW50KSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gaW50XG4gID1cbiAgZnVuIF9jbXBfX2EgX2NtcF9fYiBhX18wMjdfIGJfXzAyOF8gLT5cbiAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDI3XyBiX18wMjhfXG4gIHRoZW4gMFxuICBlbHNlIChcbiAgICBtYXRjaCBhX18wMjdfLCBiX18wMjhfIHdpdGhcbiAgICB8IE9rIF9hX18wMjlfLCBPayBfYl9fMDMwXyAtPiBfY21wX19hIF9hX18wMjlfIF9iX18wMzBfXG4gICAgfCBPayBfLCBfIC0+IC0xXG4gICAgfCBfLCBPayBfIC0+IDFcbiAgICB8IEVycm9yIF9hX18wMzFfLCBFcnJvciBfYl9fMDMyXyAtPiBfY21wX19iIF9hX18wMzFfIF9iX18wMzJfKVxuOztcblxubGV0IGVxdWFsIDpcbiAgJ2EgJ2IuICgnYSAtPiAnYSAtPiBib29sKSAtPiAoJ2IgLT4gJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGJvb2xcbiAgPVxuICBmdW4gX2NtcF9fYSBfY21wX19iIGFfXzAzM18gYl9fMDM0XyAtPlxuICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMzNfIGJfXzAzNF9cbiAgdGhlbiB0cnVlXG4gIGVsc2UgKFxuICAgIG1hdGNoIGFfXzAzM18sIGJfXzAzNF8gd2l0aFxuICAgIHwgT2sgX2FfXzAzNV8sIE9rIF9iX18wMzZfIC0+IF9jbXBfX2EgX2FfXzAzNV8gX2JfXzAzNl9cbiAgICB8IE9rIF8sIF8gLT4gZmFsc2VcbiAgICB8IF8sIE9rIF8gLT4gZmFsc2VcbiAgICB8IEVycm9yIF9hX18wMzdfLCBFcnJvciBfYl9fMDM4XyAtPiBfY21wX19iIF9hX18wMzdfIF9iX18wMzhfKVxuOztcblxubGV0IGhhc2hfZm9sZF90XG4gIDogdHlwZSBhIGIuXG4gICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgIC0+IChhLCBiKSB0XG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gID1cbiAgZnVuIF9oYXNoX2ZvbGRfYSBfaGFzaF9mb2xkX2IgaHN2IGFyZyAtPlxuICBtYXRjaCBhcmcgd2l0aFxuICB8IE9rIF9hMCAtPlxuICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgX2hhc2hfZm9sZF9hIGhzdiBfYTBcbiAgfCBFcnJvciBfYTAgLT5cbiAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxIGluXG4gICAgbGV0IGhzdiA9IGhzdiBpblxuICAgIF9oYXNoX2ZvbGRfYiBoc3YgX2EwXG47O1xuXG5bQEBAZW5kXVxuXG5pbmNsdWRlIE1vbmFkLk1ha2UyIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuXG4gICAgbGV0IGJpbmQgeCB+ZiA9XG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgRXJyb3IgXyBhcyB4IC0+IHhcbiAgICAgIHwgT2sgeCAtPiBmIHhcbiAgICA7O1xuXG4gICAgbGV0IG1hcCB4IH5mID1cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBFcnJvciBfIGFzIHggLT4geFxuICAgICAgfCBPayB4IC0+IE9rIChmIHgpXG4gICAgOztcblxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgIGxldCByZXR1cm4geCA9IE9rIHhcbiAgZW5kKVxuXG5sZXQgaW52YXJpYW50IGNoZWNrX29rIGNoZWNrX2Vycm9yIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBPayBvayAtPiBjaGVja19vayBva1xuICB8IEVycm9yIGVycm9yIC0+IGNoZWNrX2Vycm9yIGVycm9yXG47O1xuXG5sZXQgZmFpbCB4ID0gRXJyb3IgeFxubGV0IGZhaWxmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBmYWlsIGZvcm1hdFxuXG5sZXQgbWFwX2Vycm9yIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBPayBfIGFzIHggLT4geFxuICB8IEVycm9yIHggLT4gRXJyb3IgKGYgeClcbjs7XG5cbm1vZHVsZSBFcnJvciA9IE1vbmFkLk1ha2UyIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdiLCAnYSkgdFxuXG4gICAgbGV0IGJpbmQgeCB+ZiA9XG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgT2sgXyBhcyBvayAtPiBva1xuICAgICAgfCBFcnJvciBlIC0+IGYgZVxuICAgIDs7XG5cbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBfZXJyb3JcbiAgICBsZXQgcmV0dXJuIGUgPSBFcnJvciBlXG4gIGVuZClcblxubGV0IGlzX29rID0gZnVuY3Rpb25cbiAgfCBPayBfIC0+IHRydWVcbiAgfCBFcnJvciBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfZXJyb3IgPSBmdW5jdGlvblxuICB8IE9rIF8gLT4gZmFsc2VcbiAgfCBFcnJvciBfIC0+IHRydWVcbjs7XG5cbmxldCBvayA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiBTb21lIHhcbiAgfCBFcnJvciBfIC0+IE5vbmVcbjs7XG5cbmxldCBlcnJvciA9IGZ1bmN0aW9uXG4gIHwgT2sgXyAtPiBOb25lXG4gIHwgRXJyb3IgeCAtPiBTb21lIHhcbjs7XG5cbmxldCBvZl9vcHRpb24gb3B0IH5lcnJvciA9XG4gIG1hdGNoIG9wdCB3aXRoXG4gIHwgU29tZSB4IC0+IE9rIHhcbiAgfCBOb25lIC0+IEVycm9yIGVycm9yXG47O1xuXG5sZXQgaXRlciB2IH5mID1cbiAgbWF0Y2ggdiB3aXRoXG4gIHwgT2sgeCAtPiBmIHhcbiAgfCBFcnJvciBfIC0+ICgpXG47O1xuXG5sZXQgaXRlcl9lcnJvciB2IH5mID1cbiAgbWF0Y2ggdiB3aXRoXG4gIHwgT2sgXyAtPiAoKVxuICB8IEVycm9yIHggLT4gZiB4XG47O1xuXG5sZXQgdG9fZWl0aGVyIDogXyB0IC0+IF8gRWl0aGVyLnQgPSBmdW5jdGlvblxuICB8IE9rIHggLT4gRmlyc3QgeFxuICB8IEVycm9yIHggLT4gU2Vjb25kIHhcbjs7XG5cbmxldCBvZl9laXRoZXIgOiBfIEVpdGhlci50IC0+IF8gdCA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgeCAtPiBPayB4XG4gIHwgU2Vjb25kIHggLT4gRXJyb3IgeFxuOztcblxubGV0IG9rX2lmX3RydWUgYm9vbCB+ZXJyb3IgPSBpZiBib29sIHRoZW4gT2sgKCkgZWxzZSBFcnJvciBlcnJvclxuXG5sZXQgdHJ5X3dpdGggZiA9XG4gIHRyeSBPayAoZiAoKSkgd2l0aFxuICB8IGV4biAtPiBFcnJvciBleG5cbjs7XG5cbmxldCBva19leG4gPSBmdW5jdGlvblxuICB8IE9rIHggLT4geFxuICB8IEVycm9yIGV4biAtPiByYWlzZSBleG5cbjs7XG5cbmxldCBva19vcl9mYWlsd2l0aCA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiB4XG4gIHwgRXJyb3Igc3RyIC0+IGZhaWx3aXRoIHN0clxuOztcblxubW9kdWxlIEV4cG9ydCA9IHN0cnVjdFxuICB0eXBlICgnb2ssICdlcnIpIF9yZXN1bHQgPSAoJ29rLCAnZXJyKSB0ID1cbiAgICB8IE9rIG9mICdva1xuICAgIHwgRXJyb3Igb2YgJ2VyclxuXG4gIGxldCBpc19lcnJvciA9IGlzX2Vycm9yXG4gIGxldCBpc19vayA9IGlzX29rXG5lbmRcblxubGV0IGNvbWJpbmUgdDEgdDIgfm9rIH5lcnIgPVxuICBtYXRjaCB0MSwgdDIgd2l0aFxuICB8IE9rIF8sIEVycm9yIGUgfCBFcnJvciBlLCBPayBfIC0+IEVycm9yIGVcbiAgfCBPayBvazEsIE9rIG9rMiAtPiBPayAob2sgb2sxIG9rMilcbiAgfCBFcnJvciBlcnIxLCBFcnJvciBlcnIyIC0+IEVycm9yIChlcnIgZXJyMSBlcnIyKVxuOztcblxubGV0IGNvbWJpbmVfZXJyb3JzIGwgPVxuICBsZXQgb2ssIGVycnMgPSBMaXN0MS5wYXJ0aXRpb25fbWFwIGwgfmY6dG9fZWl0aGVyIGluXG4gIG1hdGNoIGVycnMgd2l0aFxuICB8IFtdIC0+IE9rIG9rXG4gIHwgXyA6OiBfIC0+IEVycm9yIGVycnNcbjs7XG5cbmxldCBjb21iaW5lX2Vycm9yc191bml0IGwgPSBtYXAgKGNvbWJpbmVfZXJyb3JzIGwpIH5mOihmdW4gKF8gOiB1bml0IGxpc3QpIC0+ICgpKVxuXG4oKiBkZXByZWNhdGVkIGJpbmRpbmcgZm9yIGV4cG9ydCBvbmx5ICopXG5sZXQgb2tfZnN0ID0gdG9fZWl0aGVyXG4iLCIoKiogUHJvdmlkZXMgZ2VuZXJpYyBzaWduYXR1cmVzIGZvciBjb250YWluZXIgZGF0YSBzdHJ1Y3R1cmVzLlxuXG4gICAgVGhlc2Ugc2lnbmF0dXJlcyBpbmNsdWRlIGZ1bmN0aW9ucyAoW2l0ZXJdLCBbZm9sZF0sIFtleGlzdHNdLCBbZm9yX2FsbF0sIC4uLikgdGhhdFxuICAgIHlvdSB3b3VsZCBleHBlY3QgdG8gZmluZCBpbiBhbnkgY29udGFpbmVyLiBVc2VkIGJ5IGluY2x1ZGluZyBbQ29udGFpbmVyLlMwXSBvclxuICAgIFtDb250YWluZXIuUzFdIGluIHRoZSBzaWduYXR1cmUgZm9yIGV2ZXJ5IGNvbnRhaW5lci1saWtlIGRhdGEgc3RydWN0dXJlIChbQXJyYXldLFxuICAgIFtMaXN0XSwgW1N0cmluZ10sIC4uLikgdG8gZW5zdXJlIGEgY29uc2lzdGVudCBpbnRlcmZhY2UuICopXG5cbm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gICgqKiBbQ29udGludWVfb3Jfc3RvcC50XSBpcyB1c2VkIGJ5IHRoZSBbZl0gYXJndW1lbnQgdG8gW2ZvbGRfdW50aWxdIGluIG9yZGVyIHRvXG4gICAgICBpbmRpY2F0ZSB3aGV0aGVyIGZvbGRpbmcgc2hvdWxkIGNvbnRpbnVlLCBvciBzdG9wIGVhcmx5LlxuXG4gICAgICBAY2Fub25pY2FsIEJhc2UuQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3BcbiAgKilcbiAgbW9kdWxlIENvbnRpbnVlX29yX3N0b3AgPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2IpIHQgPVxuICAgICAgfCBDb250aW51ZSBvZiAnYVxuICAgICAgfCBTdG9wIG9mICdiXG4gIGVuZFxuZW5kXG5cbmluY2x1ZGUgRXhwb3J0XG5cbigqKiBAY2Fub25pY2FsIEJhc2UuQ29udGFpbmVyLlN1bW1hYmxlICopXG5tb2R1bGUgdHlwZSBTdW1tYWJsZSA9IHNpZ1xuICB0eXBlIHRcblxuICAoKiogVGhlIHJlc3VsdCBvZiBzdW1taW5nIG5vIHZhbHVlcy4gKilcbiAgdmFsIHplcm8gOiB0XG5cbiAgKCoqIEFuIG9wZXJhdGlvbiB0aGF0IGNvbWJpbmVzIHR3byBbdF0ncyBhbmQgaGFuZGxlcyBbemVybyArIHhdIGJ5IGp1c3QgcmV0dXJuaW5nIFt4XSxcbiAgICAgIGFzIHdlbGwgYXMgaW4gdGhlIHN5bW1ldHJpYyBjYXNlLiAqKVxuICB2YWwgKCArICkgOiB0IC0+IHQgLT4gdFxuZW5kXG5cbigqKiBTaWduYXR1cmUgZm9yIG1vbm9tb3JwaGljIGNvbnRhaW5lciAtIGEgY29udGFpbmVyIGZvciBhIHNwZWNpZmljIGVsZW1lbnQgdHlwZSwgZS5nLixcbiAgICBzdHJpbmcsIHdoaWNoIGlzIGEgY29udGFpbmVyIG9mIGNoYXJhY3RlcnMgKFt0eXBlIGVsdCA9IGNoYXJdKSBhbmQgbmV2ZXIgb2YgYW55dGhpbmdcbiAgICBlbHNlLiAqKVxubW9kdWxlIHR5cGUgUzAgPSBzaWdcbiAgdHlwZSB0XG4gIHR5cGUgZWx0XG5cbiAgKCoqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBlbGVtZW50IGlzIHRoZXJlLCB1c2luZyBlcXVhbGl0eSBvbiBbZWx0XXMuICopXG4gIHZhbCBtZW0gOiB0IC0+IGVsdCAtPiBib29sXG5cbiAgdmFsIGxlbmd0aCA6IHQgLT4gaW50XG4gIHZhbCBpc19lbXB0eSA6IHQgLT4gYm9vbFxuXG4gICgqKiBbaXRlcl0gbXVzdCBhbGxvdyBleGNlcHRpb25zIHJhaXNlZCBpbiBbZl0gdG8gZXNjYXBlLCB0ZXJtaW5hdGluZyB0aGUgaXRlcmF0aW9uXG4gICAgICBjbGVhbmx5LiAgVGhlIHNhbWUgaG9sZHMgZm9yIGFsbCBmdW5jdGlvbnMgYmVsb3cgdGFraW5nIGFuIFtmXS4gKilcbiAgdmFsIGl0ZXIgOiB0IC0+IGY6KGVsdCAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIFtmb2xkIHQgfmluaXQgfmZdIHJldHVybnMgW2YgKC4uLiBmIChmIChmIGluaXQgZTEpIGUyKSBlMyAuLi4pIGVuXSwgd2hlcmUgW2UxLi5lbl1cbiAgICAgIGFyZSB0aGUgZWxlbWVudHMgb2YgW3RdLiAqKVxuICB2YWwgZm9sZCA6IHQgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2FjY3VtIC0+IGVsdCAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gICgqKiBbZm9sZF9yZXN1bHQgdCB+aW5pdCB+Zl0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdIHRoYXQgcnVucyBpbiB0aGVcbiAgICAgIFtSZXN1bHRdIG1vbmFkLiAgSWYgW2ZdIHJldHVybnMgYW4gW0Vycm9yIF9dLCB0aGF0IHZhbHVlIGlzIHJldHVybmVkIHdpdGhvdXQgYW55XG4gICAgICBhZGRpdGlvbmFsIGludm9jYXRpb25zIG9mIFtmXS4gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+IGVsdCAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50XG5cbiAgKCoqIFtmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaF0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdLiBJZiBbZl1cbiAgICAgIHJldHVybnMgW1N0b3AgX10gdGhlIGNvbXB1dGF0aW9uIGNlYXNlcyBhbmQgcmVzdWx0cyBpbiB0aGF0IHZhbHVlLiBJZiBbZl0gcmV0dXJuc1xuICAgICAgW0NvbnRpbnVlIF9dLCB0aGUgZm9sZCB3aWxsIHByb2NlZWQuIElmIFtmXSBuZXZlciByZXR1cm5zIFtTdG9wIF9dLCB0aGUgZmluYWwgcmVzdWx0XG4gICAgICBpcyBjb21wdXRlZCBieSBbZmluaXNoXS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBtYXliZV9uZWdhdGl2ZSA9XG4gICAgICAgICAgfCBGb3VuZF9uZWdhdGl2ZSBvZiBpbnRcbiAgICAgICAgICB8IEFsbF9ub25uZWdhdGl2ZSBvZiB7IHN1bSA6IGludCB9XG5cbiAgICAgICAgKCoqIFtmaXJzdF9uZWdfb3Jfc3VtIGxpc3RdIHJldHVybnMgdGhlIGZpcnN0IG5lZ2F0aXZlIG51bWJlciBpbiBbbGlzdF0sIGlmIGFueSxcbiAgICAgICAgICAgIG90aGVyd2lzZSByZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGxpc3QuICopXG4gICAgICAgIGxldCBmaXJzdF9uZWdfb3Jfc3VtID1cbiAgICAgICAgICBMaXN0LmZvbGRfdW50aWwgfmluaXQ6MFxuICAgICAgICAgICAgfmY6KGZ1biBzdW0geCAtPlxuICAgICAgICAgICAgICBpZiB4IDwgMFxuICAgICAgICAgICAgICB0aGVuIFN0b3AgKEZvdW5kX25lZ2F0aXZlIHgpXG4gICAgICAgICAgICAgIGVsc2UgQ29udGludWUgKHN1bSArIHgpKVxuICAgICAgICAgICAgfmZpbmlzaDooZnVuIHN1bSAtPiBBbGxfbm9ubmVnYXRpdmUgeyBzdW0gfSlcbiAgICAgICAgOztcblxuICAgICAgICBsZXQgeCA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IDM7IDQ7IDVdXG4gICAgICAgIHZhbCB4IDogbWF5YmVfbmVnYXRpdmUgPSBBbGxfbm9ubmVnYXRpdmUge3N1bSA9IDE1fVxuXG4gICAgICAgIGxldCB5ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgLTM7IDQ7IDVdXG4gICAgICAgIHZhbCB5IDogbWF5YmVfbmVnYXRpdmUgPSBGb3VuZF9uZWdhdGl2ZSAtM1xuICAgICAgXX0gKilcbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gZWx0IC0+ICgnYWNjdW0sICdmaW5hbCkgQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjY3VtIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlcmUgZXhpc3RzIGFuIGVsZW1lbnQgZm9yIHdoaWNoIHRoZSBwcm92aWRlZFxuICAgICAgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIFt0cnVlXS4gVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZXhpc3RzIDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIFt0cnVlXSBmb3IgYWxsXG4gICAgICBlbGVtZW50cy4gVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZm9yX2FsbCA6IHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGZvciB3aGljaCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIHRydWUuICopXG4gIHZhbCBjb3VudCA6IHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGludFxuXG4gICgqKiBSZXR1cm5zIHRoZSBzdW0gb2YgW2YgaV0gZm9yIGFsbCBbaV0gaW4gdGhlIGNvbnRhaW5lci4gKilcbiAgdmFsIHN1bSA6IChtb2R1bGUgU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKSAtPiB0IC0+IGY6KGVsdCAtPiAnc3VtKSAtPiAnc3VtXG5cbiAgKCoqIFJldHVybnMgYXMgYW4gW29wdGlvbl0gdGhlIGZpcnN0IGVsZW1lbnQgZm9yIHdoaWNoIFtmXSBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGZpbmQgOiB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBlbHQgb3B0aW9uXG5cbiAgKCoqIFJldHVybnMgdGhlIGZpcnN0IGV2YWx1YXRpb24gb2YgW2ZdIHRoYXQgcmV0dXJucyBbU29tZV0sIGFuZCByZXR1cm5zIFtOb25lXSBpZiB0aGVyZVxuICAgICAgaXMgbm8gc3VjaCBlbGVtZW50LiAgKilcbiAgdmFsIGZpbmRfbWFwIDogdCAtPiBmOihlbHQgLT4gJ2Egb3B0aW9uKSAtPiAnYSBvcHRpb25cblxuICB2YWwgdG9fbGlzdCA6IHQgLT4gZWx0IGxpc3RcbiAgdmFsIHRvX2FycmF5IDogdCAtPiBlbHQgYXJyYXlcblxuICAoKiogUmV0dXJucyBhIG1pbiAocmVzcC4gbWF4KSBlbGVtZW50IGZyb20gdGhlIGNvbGxlY3Rpb24gdXNpbmcgdGhlIHByb3ZpZGVkIFtjb21wYXJlXVxuICAgICAgZnVuY3Rpb24uIEluIGNhc2Ugb2YgYSB0aWUsIHRoZSBmaXJzdCBlbGVtZW50IGVuY291bnRlcmVkIHdoaWxlIHRyYXZlcnNpbmcgdGhlXG4gICAgICBjb2xsZWN0aW9uIGlzIHJldHVybmVkLiBUaGUgaW1wbGVtZW50YXRpb24gdXNlcyBbZm9sZF0gc28gaXQgaGFzIHRoZSBzYW1lXG4gICAgICBjb21wbGV4aXR5IGFzIFtmb2xkXS4gUmV0dXJucyBbTm9uZV0gaWZmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5LiAqKVxuICB2YWwgbWluX2VsdCA6IHQgLT4gY29tcGFyZTooZWx0IC0+IGVsdCAtPiBpbnQpIC0+IGVsdCBvcHRpb25cblxuICB2YWwgbWF4X2VsdCA6IHQgLT4gY29tcGFyZTooZWx0IC0+IGVsdCAtPiBpbnQpIC0+IGVsdCBvcHRpb25cbmVuZFxuXG5tb2R1bGUgdHlwZSBTMF9waGFudG9tID0gc2lnXG4gIHR5cGUgZWx0XG4gIHR5cGUgJ2EgdFxuXG4gICgqKiBDaGVja3Mgd2hldGhlciB0aGUgcHJvdmlkZWQgZWxlbWVudCBpcyB0aGVyZSwgdXNpbmcgZXF1YWxpdHkgb24gW2VsdF1zLiAqKVxuICB2YWwgbWVtIDogXyB0IC0+IGVsdCAtPiBib29sXG5cbiAgdmFsIGxlbmd0aCA6IF8gdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogXyB0IC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiBfIHQgLT4gZjooZWx0IC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogW2ZvbGQgdCB+aW5pdCB+Zl0gcmV0dXJucyBbZiAoLi4uIGYgKGYgKGYgaW5pdCBlMSkgZTIpIGUzIC4uLikgZW5dLCB3aGVyZSBbZTEuLmVuXVxuICAgICAgYXJlIHRoZSBlbGVtZW50cyBvZiBbdF0uICopXG4gIHZhbCBmb2xkIDogXyB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiBlbHQgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICAoKiogW2ZvbGRfcmVzdWx0IHQgfmluaXQgfmZdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXSB0aGF0IHJ1bnMgaW4gdGhlXG4gICAgICBbUmVzdWx0XSBtb25hZC4gIElmIFtmXSByZXR1cm5zIGFuIFtFcnJvciBfXSwgdGhhdCB2YWx1ZSBpcyByZXR1cm5lZCB3aXRob3V0IGFueVxuICAgICAgYWRkaXRpb25hbCBpbnZvY2F0aW9ucyBvZiBbZl0uICopXG4gIHZhbCBmb2xkX3Jlc3VsdFxuICAgIDogIF8gdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+IGVsdCAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50XG5cbiAgKCoqIFtmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaF0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdLiBJZiBbZl1cbiAgICAgIHJldHVybnMgW1N0b3AgX10gdGhlIGNvbXB1dGF0aW9uIGNlYXNlcyBhbmQgcmVzdWx0cyBpbiB0aGF0IHZhbHVlLiBJZiBbZl0gcmV0dXJuc1xuICAgICAgW0NvbnRpbnVlIF9dLCB0aGUgZm9sZCB3aWxsIHByb2NlZWQuIElmIFtmXSBuZXZlciByZXR1cm5zIFtTdG9wIF9dLCB0aGUgZmluYWwgcmVzdWx0XG4gICAgICBpcyBjb21wdXRlZCBieSBbZmluaXNoXS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBtYXliZV9uZWdhdGl2ZSA9XG4gICAgICAgICAgfCBGb3VuZF9uZWdhdGl2ZSBvZiBpbnRcbiAgICAgICAgICB8IEFsbF9ub25uZWdhdGl2ZSBvZiB7IHN1bSA6IGludCB9XG5cbiAgICAgICAgKCoqIFtmaXJzdF9uZWdfb3Jfc3VtIGxpc3RdIHJldHVybnMgdGhlIGZpcnN0IG5lZ2F0aXZlIG51bWJlciBpbiBbbGlzdF0sIGlmIGFueSxcbiAgICAgICAgICAgIG90aGVyd2lzZSByZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGxpc3QuICopXG4gICAgICAgIGxldCBmaXJzdF9uZWdfb3Jfc3VtID1cbiAgICAgICAgICBMaXN0LmZvbGRfdW50aWwgfmluaXQ6MFxuICAgICAgICAgICAgfmY6KGZ1biBzdW0geCAtPlxuICAgICAgICAgICAgICBpZiB4IDwgMFxuICAgICAgICAgICAgICB0aGVuIFN0b3AgKEZvdW5kX25lZ2F0aXZlIHgpXG4gICAgICAgICAgICAgIGVsc2UgQ29udGludWUgKHN1bSArIHgpKVxuICAgICAgICAgICAgfmZpbmlzaDooZnVuIHN1bSAtPiBBbGxfbm9ubmVnYXRpdmUgeyBzdW0gfSlcbiAgICAgICAgOztcblxuICAgICAgICBsZXQgeCA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IDM7IDQ7IDVdXG4gICAgICAgIHZhbCB4IDogbWF5YmVfbmVnYXRpdmUgPSBBbGxfbm9ubmVnYXRpdmUge3N1bSA9IDE1fVxuXG4gICAgICAgIGxldCB5ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgLTM7IDQ7IDVdXG4gICAgICAgIHZhbCB5IDogbWF5YmVfbmVnYXRpdmUgPSBGb3VuZF9uZWdhdGl2ZSAtM1xuICAgICAgXX0gKilcbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICBfIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiBlbHQgLT4gKCdhY2N1bSwgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGVyZSBleGlzdHMgYW4gZWxlbWVudCBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkXG4gICAgICBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdLiAgVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZXhpc3RzIDogXyB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdIGZvciBhbGxcbiAgICAgIGVsZW1lbnRzLiAgVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZm9yX2FsbCA6IF8gdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZm9yIHdoaWNoIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGNvdW50IDogXyB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBpbnRcblxuICAoKiogUmV0dXJucyB0aGUgc3VtIG9mIFtmIGldIGZvciBhbGwgW2ldIGluIHRoZSBjb250YWluZXIuIFRoZSBvcmRlciBpbiB3aGljaCB0aGVcbiAgICAgIGVsZW1lbnRzIHdpbGwgYmUgc3VtbWVkIGlzIHVuc3BlY2lmaWVkLiAqKVxuICB2YWwgc3VtIDogKG1vZHVsZSBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pIC0+IF8gdCAtPiBmOihlbHQgLT4gJ3N1bSkgLT4gJ3N1bVxuXG4gICgqKiBSZXR1cm5zIGFzIGFuIFtvcHRpb25dIHRoZSBmaXJzdCBlbGVtZW50IGZvciB3aGljaCBbZl0gZXZhbHVhdGVzIHRvIHRydWUuICopXG4gIHZhbCBmaW5kIDogXyB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBlbHQgb3B0aW9uXG5cbiAgKCoqIFJldHVybnMgdGhlIGZpcnN0IGV2YWx1YXRpb24gb2YgW2ZdIHRoYXQgcmV0dXJucyBbU29tZV0sIGFuZCByZXR1cm5zIFtOb25lXSBpZiB0aGVyZVxuICAgICAgaXMgbm8gc3VjaCBlbGVtZW50LiAgKilcbiAgdmFsIGZpbmRfbWFwIDogXyB0IC0+IGY6KGVsdCAtPiAnYSBvcHRpb24pIC0+ICdhIG9wdGlvblxuXG4gIHZhbCB0b19saXN0IDogXyB0IC0+IGVsdCBsaXN0XG4gIHZhbCB0b19hcnJheSA6IF8gdCAtPiBlbHQgYXJyYXlcblxuICAoKiogUmV0dXJucyBhIG1pbiAocmVzcCBtYXgpIGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgW2NvbXBhcmVdXG4gICAgICBmdW5jdGlvbiwgb3IgW05vbmVdIGlmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5LiAgSW4gY2FzZSBvZiBhIHRpZSwgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgIGVuY291bnRlcmVkIHdoaWxlIHRyYXZlcnNpbmcgdGhlIGNvbGxlY3Rpb24gaXMgcmV0dXJuZWQuICopXG4gIHZhbCBtaW5fZWx0IDogXyB0IC0+IGNvbXBhcmU6KGVsdCAtPiBlbHQgLT4gaW50KSAtPiBlbHQgb3B0aW9uXG5cbiAgdmFsIG1heF9lbHQgOiBfIHQgLT4gY29tcGFyZTooZWx0IC0+IGVsdCAtPiBpbnQpIC0+IGVsdCBvcHRpb25cbmVuZFxuXG4oKiogU2lnbmF0dXJlIGZvciBwb2x5bW9ycGhpYyBjb250YWluZXIsIGUuZy4sIFsnYSBsaXN0XSBvciBbJ2EgYXJyYXldLiAqKVxubW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgKCoqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBlbGVtZW50IGlzIHRoZXJlLCB1c2luZyBbZXF1YWxdLiAqKVxuICB2YWwgbWVtIDogJ2EgdCAtPiAnYSAtPiBlcXVhbDooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiAnYSB0IC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAnYSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogW2ZvbGQgdCB+aW5pdCB+Zl0gcmV0dXJucyBbZiAoLi4uIGYgKGYgKGYgaW5pdCBlMSkgZTIpIGUzIC4uLikgZW5dLCB3aGVyZSBbZTEuLmVuXVxuICAgICAgYXJlIHRoZSBlbGVtZW50cyBvZiBbdF0gICopXG4gIHZhbCBmb2xkIDogJ2EgdCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gJ2EgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICAoKiogW2ZvbGRfcmVzdWx0IHQgfmluaXQgfmZdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXSB0aGF0IHJ1bnMgaW4gdGhlXG4gICAgICBbUmVzdWx0XSBtb25hZC4gIElmIFtmXSByZXR1cm5zIGFuIFtFcnJvciBfXSwgdGhhdCB2YWx1ZSBpcyByZXR1cm5lZCB3aXRob3V0IGFueVxuICAgICAgYWRkaXRpb25hbCBpbnZvY2F0aW9ucyBvZiBbZl0uICopXG4gIHZhbCBmb2xkX3Jlc3VsdFxuICAgIDogICdhIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50XG5cbiAgKCoqIFtmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaF0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdLiBJZiBbZl1cbiAgICAgIHJldHVybnMgW1N0b3AgX10gdGhlIGNvbXB1dGF0aW9uIGNlYXNlcyBhbmQgcmVzdWx0cyBpbiB0aGF0IHZhbHVlLiBJZiBbZl0gcmV0dXJuc1xuICAgICAgW0NvbnRpbnVlIF9dLCB0aGUgZm9sZCB3aWxsIHByb2NlZWQuIElmIFtmXSBuZXZlciByZXR1cm5zIFtTdG9wIF9dLCB0aGUgZmluYWwgcmVzdWx0XG4gICAgICBpcyBjb21wdXRlZCBieSBbZmluaXNoXS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBtYXliZV9uZWdhdGl2ZSA9XG4gICAgICAgICAgfCBGb3VuZF9uZWdhdGl2ZSBvZiBpbnRcbiAgICAgICAgICB8IEFsbF9ub25uZWdhdGl2ZSBvZiB7IHN1bSA6IGludCB9XG5cbiAgICAgICAgKCoqIFtmaXJzdF9uZWdfb3Jfc3VtIGxpc3RdIHJldHVybnMgdGhlIGZpcnN0IG5lZ2F0aXZlIG51bWJlciBpbiBbbGlzdF0sIGlmIGFueSxcbiAgICAgICAgICAgIG90aGVyd2lzZSByZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGxpc3QuICopXG4gICAgICAgIGxldCBmaXJzdF9uZWdfb3Jfc3VtID1cbiAgICAgICAgICBMaXN0LmZvbGRfdW50aWwgfmluaXQ6MFxuICAgICAgICAgICAgfmY6KGZ1biBzdW0geCAtPlxuICAgICAgICAgICAgICBpZiB4IDwgMFxuICAgICAgICAgICAgICB0aGVuIFN0b3AgKEZvdW5kX25lZ2F0aXZlIHgpXG4gICAgICAgICAgICAgIGVsc2UgQ29udGludWUgKHN1bSArIHgpKVxuICAgICAgICAgICAgfmZpbmlzaDooZnVuIHN1bSAtPiBBbGxfbm9ubmVnYXRpdmUgeyBzdW0gfSlcbiAgICAgICAgOztcblxuICAgICAgICBsZXQgeCA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IDM7IDQ7IDVdXG4gICAgICAgIHZhbCB4IDogbWF5YmVfbmVnYXRpdmUgPSBBbGxfbm9ubmVnYXRpdmUge3N1bSA9IDE1fVxuXG4gICAgICAgIGxldCB5ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgLTM7IDQ7IDVdXG4gICAgICAgIHZhbCB5IDogbWF5YmVfbmVnYXRpdmUgPSBGb3VuZF9uZWdhdGl2ZSAtM1xuICAgICAgXX0gKilcbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAnYSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgLT4gKCdhY2N1bSwgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGVyZSBleGlzdHMgYW4gZWxlbWVudCBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkXG4gICAgICBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdLiAgVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZXhpc3RzIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdIGZvciBhbGxcbiAgICAgIGVsZW1lbnRzLiAgVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZm9yX2FsbCA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZm9yIHdoaWNoIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGNvdW50IDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiBpbnRcblxuICAoKiogUmV0dXJucyB0aGUgc3VtIG9mIFtmIGldIGZvciBhbGwgW2ldIGluIHRoZSBjb250YWluZXIuICopXG4gIHZhbCBzdW0gOiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSkgLT4gJ2EgdCAtPiBmOignYSAtPiAnc3VtKSAtPiAnc3VtXG5cbiAgKCoqIFJldHVybnMgYXMgYW4gW29wdGlvbl0gdGhlIGZpcnN0IGVsZW1lbnQgZm9yIHdoaWNoIFtmXSBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGZpbmQgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvblxuXG4gICgqKiBSZXR1cm5zIHRoZSBmaXJzdCBldmFsdWF0aW9uIG9mIFtmXSB0aGF0IHJldHVybnMgW1NvbWVdLCBhbmQgcmV0dXJucyBbTm9uZV0gaWYgdGhlcmVcbiAgICAgIGlzIG5vIHN1Y2ggZWxlbWVudC4gICopXG4gIHZhbCBmaW5kX21hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cblxuICB2YWwgdG9fbGlzdCA6ICdhIHQgLT4gJ2EgbGlzdFxuICB2YWwgdG9fYXJyYXkgOiAnYSB0IC0+ICdhIGFycmF5XG5cbiAgKCoqIFJldHVybnMgYSBtaW5pbXVtIChyZXNwIG1heGltdW0pIGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbiB1c2luZyB0aGUgcHJvdmlkZWRcbiAgICAgIFtjb21wYXJlXSBmdW5jdGlvbiwgb3IgW05vbmVdIGlmIHRoZSBjb2xsZWN0aW9uIGlzIGVtcHR5LiBJbiBjYXNlIG9mIGEgdGllLCB0aGUgZmlyc3RcbiAgICAgIGVsZW1lbnQgZW5jb3VudGVyZWQgd2hpbGUgdHJhdmVyc2luZyB0aGUgY29sbGVjdGlvbiBpcyByZXR1cm5lZC4gVGhlIGltcGxlbWVudGF0aW9uXG4gICAgICB1c2VzIFtmb2xkXSBzbyBpdCBoYXMgdGhlIHNhbWUgY29tcGxleGl0eSBhcyBbZm9sZF0uICopXG4gIHZhbCBtaW5fZWx0IDogJ2EgdCAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBtYXhfZWx0IDogJ2EgdCAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpIC0+ICdhIG9wdGlvblxuZW5kXG5cbm1vZHVsZSB0eXBlIFMxX3BoYW50b21faW52YXJpYW50ID0gc2lnXG4gIHR5cGUgKCdhLCAncGhhbnRvbSkgdFxuXG4gICgqKiBDaGVja3Mgd2hldGhlciB0aGUgcHJvdmlkZWQgZWxlbWVudCBpcyB0aGVyZSwgdXNpbmcgW2VxdWFsXS4gKilcbiAgdmFsIG1lbSA6ICgnYSwgXykgdCAtPiAnYSAtPiBlcXVhbDooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gIHZhbCBsZW5ndGggOiAoXywgXykgdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgaXRlciA6ICgnYSwgXykgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIFtmb2xkIHQgfmluaXQgfmZdIHJldHVybnMgW2YgKC4uLiBmIChmIChmIGluaXQgZTEpIGUyKSBlMyAuLi4pIGVuXSwgd2hlcmUgW2UxLi5lbl1cbiAgICAgIGFyZSB0aGUgZWxlbWVudHMgb2YgW3RdLiAqKVxuICB2YWwgZm9sZCA6ICgnYSwgXykgdCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gJ2EgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICAoKiogW2ZvbGRfcmVzdWx0IHQgfmluaXQgfmZdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXSB0aGF0IHJ1bnMgaW4gdGhlXG4gICAgICBbUmVzdWx0XSBtb25hZC4gIElmIFtmXSByZXR1cm5zIGFuIFtFcnJvciBfXSwgdGhhdCB2YWx1ZSBpcyByZXR1cm5lZCB3aXRob3V0IGFueVxuICAgICAgYWRkaXRpb25hbCBpbnZvY2F0aW9ucyBvZiBbZl0uICopXG4gIHZhbCBmb2xkX3Jlc3VsdFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnRcblxuICAoKiogW2ZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0uIElmIFtmXVxuICAgICAgcmV0dXJucyBbU3RvcCBfXSB0aGUgY29tcHV0YXRpb24gY2Vhc2VzIGFuZCByZXN1bHRzIGluIHRoYXQgdmFsdWUuIElmIFtmXSByZXR1cm5zXG4gICAgICBbQ29udGludWUgX10sIHRoZSBmb2xkIHdpbGwgcHJvY2VlZC4gSWYgW2ZdIG5ldmVyIHJldHVybnMgW1N0b3AgX10sIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgIGlzIGNvbXB1dGVkIGJ5IFtmaW5pc2hdLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIG1heWJlX25lZ2F0aXZlID1cbiAgICAgICAgICB8IEZvdW5kX25lZ2F0aXZlIG9mIGludFxuICAgICAgICAgIHwgQWxsX25vbm5lZ2F0aXZlIG9mIHsgc3VtIDogaW50IH1cblxuICAgICAgICAoKiogW2ZpcnN0X25lZ19vcl9zdW0gbGlzdF0gcmV0dXJucyB0aGUgZmlyc3QgbmVnYXRpdmUgbnVtYmVyIGluIFtsaXN0XSwgaWYgYW55LFxuICAgICAgICAgICAgb3RoZXJ3aXNlIHJldHVybnMgdGhlIHN1bSBvZiB0aGUgbGlzdC4gKilcbiAgICAgICAgbGV0IGZpcnN0X25lZ19vcl9zdW0gPVxuICAgICAgICAgIExpc3QuZm9sZF91bnRpbCB+aW5pdDowXG4gICAgICAgICAgICB+ZjooZnVuIHN1bSB4IC0+XG4gICAgICAgICAgICAgIGlmIHggPCAwXG4gICAgICAgICAgICAgIHRoZW4gU3RvcCAoRm91bmRfbmVnYXRpdmUgeClcbiAgICAgICAgICAgICAgZWxzZSBDb250aW51ZSAoc3VtICsgeCkpXG4gICAgICAgICAgICB+ZmluaXNoOihmdW4gc3VtIC0+IEFsbF9ub25uZWdhdGl2ZSB7IHN1bSB9KVxuICAgICAgICA7O1xuXG4gICAgICAgIGxldCB4ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgMzsgNDsgNV1cbiAgICAgICAgdmFsIHggOiBtYXliZV9uZWdhdGl2ZSA9IEFsbF9ub25uZWdhdGl2ZSB7c3VtID0gMTV9XG5cbiAgICAgICAgbGV0IHkgPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAtMzsgNDsgNV1cbiAgICAgICAgdmFsIHkgOiBtYXliZV9uZWdhdGl2ZSA9IEZvdW5kX25lZ2F0aXZlIC0zXG4gICAgICBdfSAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICgnYWNjdW0sICdmaW5hbCkgQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjY3VtIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlcmUgZXhpc3RzIGFuIGVsZW1lbnQgZm9yIHdoaWNoIHRoZSBwcm92aWRlZFxuICAgICAgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIFt0cnVlXS4gIFRoaXMgaXMgYSBzaG9ydC1jaXJjdWl0aW5nIG9wZXJhdGlvbi4gKilcbiAgdmFsIGV4aXN0cyA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdIGZvciBhbGxcbiAgICAgIGVsZW1lbnRzLiAgVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZm9yX2FsbCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgY291bnQgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gaW50XG5cbiAgKCoqIFJldHVybnMgdGhlIHN1bSBvZiBbZiBpXSBmb3IgYWxsIFtpXSBpbiB0aGUgY29udGFpbmVyLiAqKVxuICB2YWwgc3VtIDogKG1vZHVsZSBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pIC0+ICgnYSwgXykgdCAtPiBmOignYSAtPiAnc3VtKSAtPiAnc3VtXG5cbiAgKCoqIFJldHVybnMgYXMgYW4gW29wdGlvbl0gdGhlIGZpcnN0IGVsZW1lbnQgZm9yIHdoaWNoIFtmXSBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGZpbmQgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIFJldHVybnMgdGhlIGZpcnN0IGV2YWx1YXRpb24gb2YgW2ZdIHRoYXQgcmV0dXJucyBbU29tZV0sIGFuZCByZXR1cm5zIFtOb25lXSBpZiB0aGVyZVxuICAgICAgaXMgbm8gc3VjaCBlbGVtZW50LiAgKilcbiAgdmFsIGZpbmRfbWFwIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbikgLT4gJ2Igb3B0aW9uXG5cbiAgdmFsIHRvX2xpc3QgOiAoJ2EsIF8pIHQgLT4gJ2EgbGlzdFxuICB2YWwgdG9fYXJyYXkgOiAoJ2EsIF8pIHQgLT4gJ2EgYXJyYXlcblxuICAoKiogUmV0dXJucyBhIG1pbiAocmVzcCBtYXgpIGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgW2NvbXBhcmVdXG4gICAgICBmdW5jdGlvbi4gSW4gY2FzZSBvZiBhIHRpZSwgdGhlIGZpcnN0IGVsZW1lbnQgZW5jb3VudGVyZWQgd2hpbGUgdHJhdmVyc2luZyB0aGVcbiAgICAgIGNvbGxlY3Rpb24gaXMgcmV0dXJuZWQuIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIFtmb2xkXSBzbyBpdCBoYXMgdGhlIHNhbWUgY29tcGxleGl0eVxuICAgICAgYXMgW2ZvbGRdLiBSZXR1cm5zIFtOb25lXSBpZmYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuICopXG4gIHZhbCBtaW5fZWx0IDogKCdhLCBfKSB0IC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludCkgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIG1heF9lbHQgOiAoJ2EsIF8pIHQgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBvcHRpb25cbmVuZFxuXG5tb2R1bGUgdHlwZSBTMV9waGFudG9tID0gc2lnXG4gIHR5cGUgKCdhLCArJ3BoYW50b20pIHRcblxuICBpbmNsdWRlIFMxX3BoYW50b21faW52YXJpYW50IHdpdGggdHlwZSAoJ2EsICdwaGFudG9tKSB0IDo9ICgnYSwgJ3BoYW50b20pIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBHZW5lcmljID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlICdhIGVsdFxuXG4gIHZhbCBsZW5ndGggOiBfIHQgLT4gaW50XG4gIHZhbCBpc19lbXB0eSA6IF8gdCAtPiBib29sXG4gIHZhbCBpdGVyIDogJ2EgdCAtPiBmOignYSBlbHQgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgZm9sZCA6ICdhIHQgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2FjY3VtIC0+ICdhIGVsdCAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gIHZhbCBmb2xkX3Jlc3VsdFxuICAgIDogICdhIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSBlbHQgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudFxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgJ2EgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIGVsdCAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2N1bSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGV4aXN0cyA6ICdhIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGwgOiAnYSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICdhIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+IGludFxuICB2YWwgc3VtIDogKG1vZHVsZSBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pIC0+ICdhIHQgLT4gZjooJ2EgZWx0IC0+ICdzdW0pIC0+ICdzdW1cbiAgdmFsIGZpbmQgOiAnYSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCBmaW5kX21hcCA6ICdhIHQgLT4gZjooJ2EgZWx0IC0+ICdiIG9wdGlvbikgLT4gJ2Igb3B0aW9uXG4gIHZhbCB0b19saXN0IDogJ2EgdCAtPiAnYSBlbHQgbGlzdFxuICB2YWwgdG9fYXJyYXkgOiAnYSB0IC0+ICdhIGVsdCBhcnJheVxuICB2YWwgbWluX2VsdCA6ICdhIHQgLT4gY29tcGFyZTooJ2EgZWx0IC0+ICdhIGVsdCAtPiBpbnQpIC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIG1heF9lbHQgOiAnYSB0IC0+IGNvbXBhcmU6KCdhIGVsdCAtPiAnYSBlbHQgLT4gaW50KSAtPiAnYSBlbHQgb3B0aW9uXG5lbmRcblxubW9kdWxlIHR5cGUgR2VuZXJpY19waGFudG9tID0gc2lnXG4gIHR5cGUgKCdhLCAncGhhbnRvbSkgdFxuICB0eXBlICdhIGVsdFxuXG4gIHZhbCBsZW5ndGggOiAoXywgXykgdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgaXRlciA6ICgnYSwgXykgdCAtPiBmOignYSBlbHQgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgZm9sZCA6ICgnYSwgXykgdCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gJ2EgZWx0IC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgZWx0IC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnRcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIGVsdCAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2N1bSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGV4aXN0cyA6ICgnYSwgXykgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbCA6ICgnYSwgXykgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+IGludFxuXG4gIHZhbCBzdW1cbiAgICA6ICAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSlcbiAgICAtPiAoJ2EsIF8pIHRcbiAgICAtPiBmOignYSBlbHQgLT4gJ3N1bSlcbiAgICAtPiAnc3VtXG5cbiAgdmFsIGZpbmQgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIGZpbmRfbWFwIDogKCdhLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiAnYiBvcHRpb24pIC0+ICdiIG9wdGlvblxuICB2YWwgdG9fbGlzdCA6ICgnYSwgXykgdCAtPiAnYSBlbHQgbGlzdFxuICB2YWwgdG9fYXJyYXkgOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0IGFycmF5XG4gIHZhbCBtaW5fZWx0IDogKCdhLCBfKSB0IC0+IGNvbXBhcmU6KCdhIGVsdCAtPiAnYSBlbHQgLT4gaW50KSAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCBtYXhfZWx0IDogKCdhLCBfKSB0IC0+IGNvbXBhcmU6KCdhIGVsdCAtPiAnYSBlbHQgLT4gaW50KSAtPiAnYSBlbHQgb3B0aW9uXG5lbmRcblxubW9kdWxlIHR5cGUgTWFrZV9nZW5fYXJnID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlICdhIGVsdFxuXG4gIHZhbCBmb2xkIDogJ2EgdCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gJ2EgZWx0IC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgKCoqIFRoZSBbaXRlcl0gYXJndW1lbnQgdG8gW0NvbnRhaW5lci5NYWtlXSBzcGVjaWZpZXMgaG93IHRvIGltcGxlbWVudCB0aGVcbiAgICAgIGNvbnRhaW5lcidzIFtpdGVyXSBmdW5jdGlvbi4gIFtgRGVmaW5lX3VzaW5nX2ZvbGRdIG1lYW5zIHRvIGRlZmluZSBbaXRlcl1cbiAgICAgIHZpYTpcblxuICAgICAge1tcbiAgICAgICAgaXRlciB0IH5mID0gQ29udGFpbmVyLml0ZXIgfmZvbGQgdCB+ZlxuICAgICAgXX1cblxuICAgICAgW2BDdXN0b21dIG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiwgcHJlc3VtYWJseSB3aXRoIHNvbWV0aGluZyBtb3JlXG4gICAgICBlZmZpY2llbnQuICBTZXZlcmFsIG90aGVyIGZ1bmN0aW9ucyByZXR1cm5lZCBieSBbQ29udGFpbmVyLk1ha2VdIGFyZSBkZWZpbmVkIGluXG4gICAgICB0ZXJtcyBvZiBbaXRlcl0sIHNvIHBhc3NpbmcgaW4gYSBtb3JlIGVmZmljaWVudCBbaXRlcl0gd2lsbCBpbXByb3ZlIHRoZWlyIGVmZmljaWVuY3lcbiAgICAgIGFzIHdlbGwuICopXG4gIHZhbCBpdGVyIDogWyBgRGVmaW5lX3VzaW5nX2ZvbGQgfCBgQ3VzdG9tIG9mICdhIHQgLT4gZjooJ2EgZWx0IC0+IHVuaXQpIC0+IHVuaXQgXVxuXG4gICgqKiBUaGUgW2xlbmd0aF0gYXJndW1lbnQgdG8gW0NvbnRhaW5lci5NYWtlXSBzcGVjaWZpZXMgaG93IHRvIGltcGxlbWVudCB0aGVcbiAgICAgIGNvbnRhaW5lcidzIFtsZW5ndGhdIGZ1bmN0aW9uLiAgW2BEZWZpbmVfdXNpbmdfZm9sZF0gbWVhbnMgdG8gZGVmaW5lXG4gICAgICBbbGVuZ3RoXSB2aWE6XG5cbiAgICAgIHtbXG4gICAgICAgIGxlbmd0aCB0IH5mID0gQ29udGFpbmVyLmxlbmd0aCB+Zm9sZCB0IH5mXG4gICAgICBdfVxuXG4gICAgICBbYEN1c3RvbV0gb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCBwcmVzdW1hYmx5IHdpdGggc29tZXRoaW5nIG1vcmVcbiAgICAgIGVmZmljaWVudC4gIFNldmVyYWwgb3RoZXIgZnVuY3Rpb25zIHJldHVybmVkIGJ5IFtDb250YWluZXIuTWFrZV0gYXJlIGRlZmluZWQgaW5cbiAgICAgIHRlcm1zIG9mIFtsZW5ndGhdLCBzbyBwYXNzaW5nIGluIGEgbW9yZSBlZmZpY2llbnQgW2xlbmd0aF0gd2lsbCBpbXByb3ZlIHRoZWlyXG4gICAgICBlZmZpY2llbmN5IGFzIHdlbGwuICopXG4gIHZhbCBsZW5ndGggOiBbIGBEZWZpbmVfdXNpbmdfZm9sZCB8IGBDdXN0b20gb2YgJ2EgdCAtPiBpbnQgXVxuZW5kXG5cbm1vZHVsZSB0eXBlIE1ha2VfYXJnID0gTWFrZV9nZW5fYXJnIHdpdGggdHlwZSAnYSBlbHQgOj0gJ2EgTW9uYWQuSWRlbnQudFxuXG5tb2R1bGUgdHlwZSBNYWtlMF9hcmcgPSBzaWdcbiAgbW9kdWxlIEVsdCA6IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2xcbiAgZW5kXG5cbiAgdHlwZSB0XG5cbiAgaW5jbHVkZSBNYWtlX2dlbl9hcmcgd2l0aCB0eXBlICdhIHQgOj0gdCBhbmQgdHlwZSAnYSBlbHQgOj0gRWx0LnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBDb250YWluZXIgPSBzaWdcbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBzdHJ1Y3RcbiAgICBpbmNsdWRlIEV4cG9ydFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMCA9IFMwXG4gIG1vZHVsZSB0eXBlIFMwX3BoYW50b20gPSBTMF9waGFudG9tXG4gIG1vZHVsZSB0eXBlIFMxID0gUzFcbiAgbW9kdWxlIHR5cGUgUzFfcGhhbnRvbV9pbnZhcmlhbnQgPSBTMV9waGFudG9tX2ludmFyaWFudFxuICBtb2R1bGUgdHlwZSBTMV9waGFudG9tID0gUzFfcGhhbnRvbVxuICBtb2R1bGUgdHlwZSBHZW5lcmljID0gR2VuZXJpY1xuICBtb2R1bGUgdHlwZSBHZW5lcmljX3BoYW50b20gPSBHZW5lcmljX3BoYW50b21cbiAgbW9kdWxlIHR5cGUgU3VtbWFibGUgPSBTdW1tYWJsZVxuXG4gICgqKiBHZW5lcmljIGRlZmluaXRpb25zIG9mIGNvbnRhaW5lciBvcGVyYXRpb25zIGluIHRlcm1zIG9mIFtmb2xkXS5cblxuICAgICAgRS5nLjogW2l0ZXIgfmZvbGQgdCB+ZiA9IGZvbGQgdCB+aW5pdDooKSB+ZjooZnVuICgpIGEgLT4gZiBhKV0uICopXG5cbiAgdHlwZSAoJ3QsICdhLCAnYWNjdW0pIGZvbGQgPSAndCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gJ2EgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cbiAgdHlwZSAoJ3QsICdhKSBpdGVyID0gJ3QgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICB0eXBlICd0IGxlbmd0aCA9ICd0IC0+IGludFxuXG4gIHZhbCBpdGVyIDogZm9sZDooJ3QsICdhLCB1bml0KSBmb2xkIC0+ICgndCwgJ2EpIGl0ZXJcbiAgdmFsIGNvdW50IDogZm9sZDooJ3QsICdhLCBpbnQpIGZvbGQgLT4gJ3QgLT4gZjooJ2EgLT4gYm9vbCkgLT4gaW50XG5cbiAgdmFsIG1pbl9lbHRcbiAgICA6ICBmb2xkOigndCwgJ2EsICdhIG9wdGlvbikgZm9sZFxuICAgIC0+ICd0XG4gICAgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KVxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBtYXhfZWx0XG4gICAgOiAgZm9sZDooJ3QsICdhLCAnYSBvcHRpb24pIGZvbGRcbiAgICAtPiAndFxuICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludClcbiAgICAtPiAnYSBvcHRpb25cblxuICB2YWwgbGVuZ3RoIDogZm9sZDooJ3QsIF8sIGludCkgZm9sZCAtPiAndCAtPiBpbnRcbiAgdmFsIHRvX2xpc3QgOiBmb2xkOigndCwgJ2EsICdhIGxpc3QpIGZvbGQgLT4gJ3QgLT4gJ2EgbGlzdFxuXG4gIHZhbCBzdW1cbiAgICA6ICBmb2xkOigndCwgJ2EsICdzdW0pIGZvbGRcbiAgICAtPiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSlcbiAgICAtPiAndFxuICAgIC0+IGY6KCdhIC0+ICdzdW0pXG4gICAgLT4gJ3N1bVxuXG4gIHZhbCBmb2xkX3Jlc3VsdFxuICAgIDogIGZvbGQ6KCd0LCAnYSwgJ2IpIGZvbGRcbiAgICAtPiBpbml0OidiXG4gICAgLT4gZjooJ2IgLT4gJ2EgLT4gKCdiLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gJ3RcbiAgICAtPiAoJ2IsICdlKSBSZXN1bHQudFxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgZm9sZDooJ3QsICdhLCAnYikgZm9sZFxuICAgIC0+IGluaXQ6J2JcbiAgICAtPiBmOignYiAtPiAnYSAtPiAoJ2IsICdmaW5hbCkgQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2IgLT4gJ2ZpbmFsKVxuICAgIC0+ICd0XG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIEdlbmVyaWMgZGVmaW5pdGlvbnMgb2YgY29udGFpbmVyIG9wZXJhdGlvbnMgaW4gdGVybXMgb2YgW2l0ZXJdIGFuZCBbbGVuZ3RoXS4gKilcbiAgdmFsIGlzX2VtcHR5IDogaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+IGJvb2xcblxuICB2YWwgZXhpc3RzIDogaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGwgOiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZmluZCA6IGl0ZXI6KCd0LCAnYSkgaXRlciAtPiAndCAtPiBmOignYSAtPiBib29sKSAtPiAnYSBvcHRpb25cbiAgdmFsIGZpbmRfbWFwIDogaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbikgLT4gJ2Igb3B0aW9uXG4gIHZhbCB0b19hcnJheSA6IGxlbmd0aDondCBsZW5ndGggLT4gaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+ICdhIGFycmF5XG5cbiAgKCoqIFRoZSBpZGlvbSBmb3IgdXNpbmcgW0NvbnRhaW5lci5NYWtlXSBpcyB0byBiaW5kIHRoZSByZXN1bHRpbmcgbW9kdWxlIGFuZCB0b1xuICAgICAgZXhwbGljaXRseSBpbXBvcnQgZWFjaCBvZiB0aGUgZnVuY3Rpb25zIHRoYXQgb25lIHdhbnRzOlxuXG4gICAgICB7W1xuICAgICAgICBtb2R1bGUgQyA9IENvbnRhaW5lci5NYWtlIChzdHJ1Y3QgLi4uIGVuZClcbiAgICAgICAgbGV0IGNvdW50ICAgID0gQy5jb3VudFxuICAgICAgICBsZXQgZXhpc3RzICAgPSBDLmV4aXN0c1xuICAgICAgICBsZXQgZmluZCAgICAgPSBDLmZpbmRcbiAgICAgICAgKCogLi4uICopXG4gICAgICBdfVxuXG4gICAgICBUaGlzIGlzIHByZWZlcmFibGUgdG86XG5cbiAgICAgIHtbXG4gICAgICAgIGluY2x1ZGUgQ29udGFpbmVyLk1ha2UgKHN0cnVjdCAuLi4gZW5kKVxuICAgICAgXX1cblxuICAgICAgYmVjYXVzZSB0aGUgW2luY2x1ZGVdIG1ha2VzIGl0IHRvbyBlYXN5IHRvIHNoYWRvdyBzcGVjaWFsaXplZCBpbXBsZW1lbnRhdGlvbnMgb2ZcbiAgICAgIGNvbnRhaW5lciBmdW5jdGlvbnMgKFtsZW5ndGhdIGJlaW5nIGEgY29tbW9uIG9uZSkuXG5cbiAgICAgIFtDb250YWluZXIuTWFrZTBdIGlzIGxpa2UgW0NvbnRhaW5lci5NYWtlXSwgYnV0IGZvciBtb25vbW9ycGhpYyBjb250YWluZXJzIGxpa2VcbiAgICAgIFtzdHJpbmddLiAqKVxuICBtb2R1bGUgTWFrZSAoVCA6IE1ha2VfYXJnKSA6IFMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIFQudFxuXG4gIG1vZHVsZSBNYWtlMCAoVCA6IE1ha2UwX2FyZykgOiBTMCB3aXRoIHR5cGUgdCA6PSBULnQgYW5kIHR5cGUgZWx0IDo9IFQuRWx0LnRcblxuICBtb2R1bGUgTWFrZV9nZW4gKFQgOiBNYWtlX2dlbl9hcmcpIDpcbiAgICBHZW5lcmljIHdpdGggdHlwZSAnYSB0IDo9ICdhIFQudCBhbmQgdHlwZSAnYSBlbHQgOj0gJ2EgVC5lbHRcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBMaXN0ID0gTGlzdDBcbmluY2x1ZGUgQ29udGFpbmVyX2ludGZcblxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxudHlwZSAoJ3QsICdhLCAnYWNjdW0pIGZvbGQgPSAndCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gJ2EgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cbnR5cGUgKCd0LCAnYSkgaXRlciA9ICd0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcbnR5cGUgJ3QgbGVuZ3RoID0gJ3QgLT4gaW50XG5cbmxldCBpdGVyIH5mb2xkIHQgfmYgPSBmb2xkIHQgfmluaXQ6KCkgfmY6KGZ1biAoKSBhIC0+IGYgYSlcbmxldCBjb3VudCB+Zm9sZCB0IH5mID0gZm9sZCB0IH5pbml0OjAgfmY6KGZ1biBuIGEgLT4gaWYgZiBhIHRoZW4gbiArIDEgZWxzZSBuKVxuXG5sZXQgc3VtICh0eXBlIGEpIH5mb2xkIChtb2R1bGUgTSA6IFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gYSkgdCB+ZiA9XG4gIGZvbGQgdCB+aW5pdDpNLnplcm8gfmY6KGZ1biBuIGEgLT4gTS4oICsgKSBuIChmIGEpKVxuOztcblxubGV0IGZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHQgPVxuICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICBSZXN1bHQuT2tcbiAgICAgIChmb2xkIHQgfmluaXQgfmY6KGZ1biBhY2MgaXRlbSAtPlxuICAgICAgICAgbWF0Y2ggZiBhY2MgaXRlbSB3aXRoXG4gICAgICAgICB8IFJlc3VsdC5PayB4IC0+IHhcbiAgICAgICAgIHwgRXJyb3IgXyBhcyBlIC0+IHJldHVybiBlKSkpXG47O1xuXG5sZXQgZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB+ZmluaXNoIHQgPVxuICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICBmaW5pc2hcbiAgICAgIChmb2xkIHQgfmluaXQgfmY6KGZ1biBhY2MgaXRlbSAtPlxuICAgICAgICAgbWF0Y2ggZiBhY2MgaXRlbSB3aXRoXG4gICAgICAgICB8IENvbnRpbnVlX29yX3N0b3AuQ29udGludWUgeCAtPiB4XG4gICAgICAgICB8IFN0b3AgeCAtPiByZXR1cm4geCkpKVxuOztcblxubGV0IG1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZSA9XG4gIGZvbGQgdCB+aW5pdDpOb25lIH5mOihmdW4gYWNjIGVsdCAtPlxuICAgIG1hdGNoIGFjYyB3aXRoXG4gICAgfCBOb25lIC0+IFNvbWUgZWx0XG4gICAgfCBTb21lIG1pbiAtPiBpZiBjb21wYXJlIG1pbiBlbHQgPiAwIHRoZW4gU29tZSBlbHQgZWxzZSBhY2MpXG47O1xuXG5sZXQgbWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlID1cbiAgZm9sZCB0IH5pbml0Ok5vbmUgfmY6KGZ1biBhY2MgZWx0IC0+XG4gICAgbWF0Y2ggYWNjIHdpdGhcbiAgICB8IE5vbmUgLT4gU29tZSBlbHRcbiAgICB8IFNvbWUgbWF4IC0+IGlmIGNvbXBhcmUgbWF4IGVsdCA8IDAgdGhlbiBTb21lIGVsdCBlbHNlIGFjYylcbjs7XG5cbmxldCBsZW5ndGggfmZvbGQgYyA9IGZvbGQgYyB+aW5pdDowIH5mOihmdW4gYWNjIF8gLT4gYWNjICsgMSlcblxubGV0IGlzX2VtcHR5IH5pdGVyIGMgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIGMgfmY6KGZ1biBfIC0+IHIucmV0dXJuIGZhbHNlKTtcbiAgICB0cnVlKVxuOztcblxubGV0IGV4aXN0cyB+aXRlciBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciBjIH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICBmYWxzZSlcbjs7XG5cbmxldCBmb3JfYWxsIH5pdGVyIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIGMgfmY6KGZ1biB4IC0+IGlmIG5vdCAoZiB4KSB0aGVuIHIucmV0dXJuIGZhbHNlKTtcbiAgICB0cnVlKVxuOztcblxubGV0IGZpbmRfbWFwIH5pdGVyIHQgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIHQgfmY6KGZ1biB4IC0+XG4gICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgfCBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgXyBhcyByZXMgLT4gci5yZXR1cm4gcmVzKTtcbiAgICBOb25lKVxuOztcblxubGV0IGZpbmQgfml0ZXIgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgYyB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gci5yZXR1cm4gKFNvbWUgeCkpO1xuICAgIE5vbmUpXG47O1xuXG5sZXQgdG9fbGlzdCB+Zm9sZCBjID0gTGlzdC5yZXYgKGZvbGQgYyB+aW5pdDpbXSB+ZjooZnVuIGFjYyB4IC0+IHggOjogYWNjKSlcblxubGV0IHRvX2FycmF5IH5sZW5ndGggfml0ZXIgYyA9XG4gIGxldCBhcnJheSA9IHJlZiBbfHxdIGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgaXRlciBjIH5mOihmdW4geCAtPlxuICAgIGlmICFpID0gMCB0aGVuIGFycmF5IDo9IEFycmF5LmNyZWF0ZSB+bGVuOihsZW5ndGggYykgeDtcbiAgICAhYXJyYXkuKCFpKSA8LSB4O1xuICAgIGluY3IgaSk7XG4gICFhcnJheVxuOztcblxubW9kdWxlIE1ha2VfZ2VuIChUIDogTWFrZV9nZW5fYXJnKSA6IHNpZ1xuICBpbmNsdWRlIEdlbmVyaWMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVC50IHdpdGggdHlwZSAnYSBlbHQgOj0gJ2EgVC5lbHRcbmVuZCA9IHN0cnVjdFxuICBsZXQgZm9sZCA9IFQuZm9sZFxuXG4gIGxldCBpdGVyID1cbiAgICBtYXRjaCBULml0ZXIgd2l0aFxuICAgIHwgYEN1c3RvbSBpdGVyIC0+IGl0ZXJcbiAgICB8IGBEZWZpbmVfdXNpbmdfZm9sZCAtPiBmdW4gdCB+ZiAtPiBpdGVyIH5mb2xkIHQgfmZcbiAgOztcblxuICBsZXQgbGVuZ3RoID1cbiAgICBtYXRjaCBULmxlbmd0aCB3aXRoXG4gICAgfCBgQ3VzdG9tIGxlbmd0aCAtPiBsZW5ndGhcbiAgICB8IGBEZWZpbmVfdXNpbmdfZm9sZCAtPiBmdW4gdCAtPiBsZW5ndGggfmZvbGQgdFxuICA7O1xuXG4gIGxldCBpc19lbXB0eSB0ID0gaXNfZW1wdHkgfml0ZXIgdFxuICBsZXQgc3VtIG0gdCA9IHN1bSB+Zm9sZCBtIHRcbiAgbGV0IGNvdW50IHQgfmYgPSBjb3VudCB+Zm9sZCB0IH5mXG4gIGxldCBleGlzdHMgdCB+ZiA9IGV4aXN0cyB+aXRlciB0IH5mXG4gIGxldCBmb3JfYWxsIHQgfmYgPSBmb3JfYWxsIH5pdGVyIHQgfmZcbiAgbGV0IGZpbmRfbWFwIHQgfmYgPSBmaW5kX21hcCB+aXRlciB0IH5mXG4gIGxldCBmaW5kIHQgfmYgPSBmaW5kIH5pdGVyIHQgfmZcbiAgbGV0IHRvX2xpc3QgdCA9IHRvX2xpc3QgfmZvbGQgdFxuICBsZXQgdG9fYXJyYXkgdCA9IHRvX2FycmF5IH5sZW5ndGggfml0ZXIgdFxuICBsZXQgbWluX2VsdCB0IH5jb21wYXJlID0gbWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG4gIGxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBtYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcbiAgbGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBmb2xkX3Jlc3VsdCB0IH5mb2xkIH5pbml0IH5mXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9IGZvbGRfdW50aWwgdCB+Zm9sZCB+aW5pdCB+ZiB+ZmluaXNoXG5lbmRcblxubW9kdWxlIE1ha2UgKFQgOiBNYWtlX2FyZykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYWtlX2dlbiAoc3RydWN0XG4gICAgICBpbmNsdWRlIFRcblxuICAgICAgdHlwZSAnYSBlbHQgPSAnYVxuICAgIGVuZClcblxuICBsZXQgbWVtIHQgYSB+ZXF1YWwgPSBleGlzdHMgdCB+ZjooZXF1YWwgYSlcbmVuZFxuXG5tb2R1bGUgTWFrZTAgKFQgOiBNYWtlMF9hcmcpID0gc3RydWN0XG4gIGluY2x1ZGUgTWFrZV9nZW4gKHN0cnVjdFxuICAgICAgaW5jbHVkZSBUXG5cbiAgICAgIHR5cGUgJ2EgdCA9IFQudFxuICAgICAgdHlwZSAnYSBlbHQgPSBULkVsdC50XG4gICAgZW5kKVxuXG4gIGxldCBtZW0gdCBlbHQgPSBleGlzdHMgdCB+ZjooVC5FbHQuZXF1YWwgZWx0KVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQ2FtbC5MYXp5XG5cbnR5cGUgJ2EgdCA9ICdhIGxhenlfdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID0gbGF6eV90X29mX3NleHBcbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPSBzZXhwX29mX2xhenlfdFxuXG5sZXQgKHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBsYXp5X3Rfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbjs7XG5cbltAQEBlbmRdXG5cbmxldCBtYXAgdCB+ZiA9IGxhenkgKGYgKGZvcmNlIHQpKVxuXG5sZXQgY29tcGFyZSBjb21wYXJlX2EgdDEgdDIgPVxuICBpZiBwaHlzX2VxdWFsIHQxIHQyIHRoZW4gMCBlbHNlIGNvbXBhcmVfYSAoZm9yY2UgdDEpIChmb3JjZSB0Milcbjs7XG5cbmxldCBlcXVhbCBlcXVhbF9hIHQxIHQyID0gaWYgcGh5c19lcXVhbCB0MSB0MiB0aGVuIHRydWUgZWxzZSBlcXVhbF9hIChmb3JjZSB0MSkgKGZvcmNlIHQyKVxubGV0IGhhc2hfZm9sZF90ID0gSGFzaC5CdWlsdGluLmhhc2hfZm9sZF9sYXp5X3RcblxuaW5jbHVkZSBNb25hZC5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IHJldHVybiB4ID0gZnJvbV92YWwgeFxuICAgIGxldCBiaW5kIHQgfmYgPSBsYXp5IChmb3JjZSAoZiAoZm9yY2UgdCkpKVxuICAgIGxldCBtYXAgPSBtYXBcbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgZW5kKVxuXG5tb2R1bGUgVF91bmZvcmNpbmcgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID1cbiAgICBpZiBpc192YWwgdCB0aGVuIHNleHBfb2ZfYSAoZm9yY2UgdCkgZWxzZSBzZXhwX29mX3N0cmluZyBcIjx1bmZvcmNlZCBsYXp5PlwiXG4gIDs7XG5lbmRcbiIsIigqIFNwbGl0IG9mZiB0byBhdm9pZCBhIGN5Y2xpYyBkZXBlbmRlbmN5IHdpdGggW09yX2Vycm9yXS4gKilcblxub3BlbiEgSW1wb3J0XG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5cbmxldCBzbG93X2NoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoID1cbiAgaWYgcG9zIDwgMCB0aGVuIGludmFsaWRfYXJnZiBcIk5lZ2F0aXZlIHBvc2l0aW9uOiAlZFwiIHBvcyAoKTtcbiAgaWYgbGVuIDwgMCB0aGVuIGludmFsaWRfYXJnZiBcIk5lZ2F0aXZlIGxlbmd0aDogJWRcIiBsZW4gKCk7XG4gICgqIFdlIHVzZSBbcG9zID4gdG90YWxfbGVuZ3RoIC0gbGVuXSByYXRoZXIgdGhhbiBbcG9zICsgbGVuID4gdG90YWxfbGVuZ3RoXSB0byBhdm9pZCB0aGVcbiAgICAgcG9zc2liaWxpdHkgb2Ygb3ZlcmZsb3cuICopXG4gIGlmIHBvcyA+IHRvdGFsX2xlbmd0aCAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnZiBcInBvcyArIGxlbiBwYXN0IGVuZDogJWQgKyAlZCA+ICVkXCIgcG9zIGxlbiB0b3RhbF9sZW5ndGggKClcbltAQGNvbGRdIFtAQGlubGluZSBuZXZlcl0gW0BAbG9jYWwgbmV2ZXJdIFtAQHNwZWNpYWxpc2UgbmV2ZXJdXG47O1xuXG5sZXQgY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGggPVxuICAoKiBUaGlzIGlzIGJldHRlciB0aGFuIFtzbG93X2NoZWNrX3Bvc19sZW5fZXhuXSBmb3IgdHdvIHJlYXNvbnM6XG5cbiAgICAgLSBtdWNoIGxlc3MgaW5saW5lZCBjb2RlXG4gICAgIC0gb25seSBvbmUgY29uZGl0aW9uYWwganVtcFxuXG4gICAgIFRoZSByZWFzb24gaXQgd29ya3MgaXMgdGhhdCBjaGVja2luZyBbPCAwXSBpcyB0ZXN0aW5nIHRoZSBoaWdoZXN0IG9yZGVyIGJpdCwgc29cbiAgICAgW2EgPCAwIHx8IGIgPCAwXSBpcyB0aGUgc2FtZSBhcyBbYSBsb3IgYiA8IDBdLlxuXG4gICAgIFtwb3MgKyBsZW5dIGNhbiBvdmVyZmxvdywgc28gW3BvcyA+IHRvdGFsX2xlbmd0aCAtIGxlbl0gaXMgbm90IGVxdWl2YWxlbnQgdG9cbiAgICAgW3RvdGFsX2xlbmd0aCAtIGxlbiAtIHBvcyA8IDBdLCB3ZSBuZWVkIHRvIHRlc3QgZm9yIFtwb3MgKyBsZW5dIG92ZXJmbG93IGFzXG4gICAgIHdlbGwuICopXG4gIGxldCBzdG9wID0gcG9zICsgbGVuIGluXG4gIGlmIHBvcyBsb3IgbGVuIGxvciBzdG9wIGxvciAodG90YWxfbGVuZ3RoIC0gc3RvcCkgPCAwXG4gIHRoZW4gc2xvd19jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aFxuOztcblxubGV0IGdldF9wb3NfbGVuX2V4biA/KHBvcyA9IDApID9sZW4gKCkgfnRvdGFsX2xlbmd0aCA9XG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBTb21lIGkgLT4gaVxuICAgIHwgTm9uZSAtPiB0b3RhbF9sZW5ndGggLSBwb3NcbiAgaW5cbiAgY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg7XG4gIHBvcywgbGVuXG47O1xuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgc2xvd19jaGVja19wb3NfbGVuX2V4biA9IHNsb3dfY2hlY2tfcG9zX2xlbl9leG5cbmVuZFxuIiwiXG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcblxubW9kdWxlIFJlcHIgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHN0IDogaW50IGFycmF5XG4gICAgOyBtdXRhYmxlIGlkeCA6IGludFxuICAgIH1cblxuICBsZXQgb2Zfc3RhdGUgOiBDYW1sLlJhbmRvbS5TdGF0ZS50IC0+IHQgPSBDYW1sLk9iai5tYWdpY1xuZW5kXG5cbmxldCBhc3NpZ24gdDEgdDIgPVxuICBsZXQgdDEgPSBSZXByLm9mX3N0YXRlIChMYXp5LmZvcmNlIHQxKSBpblxuICBsZXQgdDIgPSBSZXByLm9mX3N0YXRlIChMYXp5LmZvcmNlIHQyKSBpblxuICBBcnJheS5ibGl0IH5zcmM6dDIuc3QgfnNyY19wb3M6MCB+ZHN0OnQxLnN0IH5kc3RfcG9zOjAgfmxlbjooQXJyYXkubGVuZ3RoIHQxLnN0KTtcbiAgdDEuaWR4IDwtIHQyLmlkeFxuXG5sZXQgbWFrZV9kZWZhdWx0IGRlZmF1bHQgPSBkZWZhdWx0XG5cbmxldFtAaW5saW5lIGFsd2F5c10gZ2V0X3N0YXRlIHN0YXRlID0gc3RhdGVcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEludCA9IEludDBcbm1vZHVsZSBDaGFyID0gQ2hhcjBcblxuKCogVW5mb3J0dW5hdGVseSwgYmVjYXVzZSB0aGUgc3RhbmRhcmQgbGlicmFyeSBkb2VzIG5vdCBleHBvc2VcbiAgIFtDYW1sLlJhbmRvbS5TdGF0ZS5kZWZhdWx0XSwgd2UgaGF2ZSB0byBjb25zdHJ1Y3Qgb3VyIG93bi4gIFdlIHRoZW4gYnVpbGQgdGhlXG4gICBbQ2FtbC5SYW5kb20uaW50XSwgW0NhbWwuUmFuZG9tLmJvb2xdIGZ1bmN0aW9ucyBhbmQgZnJpZW5kcyB1c2luZyB0aGF0IGRlZmF1bHQgc3RhdGUgaW5cbiAgIGV4YWN0bHkgdGhlIHNhbWUgd2F5IGFzIHRoZSBzdGFuZGFyZCBsaWJyYXJ5LlxuXG4gICBPbmUgb3RoZXIgdHJpY2tpbmVzcyBpcyB0aGF0IHdlIG5lZWQgYWNjZXNzIHRvIHRoZSB1bmV4cG9zZWQgW0NhbWwuUmFuZG9tLlN0YXRlLmFzc2lnbl1cbiAgIGZ1bmN0aW9uLCB3aGljaCBhY2Nlc3NlcyB0aGUgdW5leHBvc2VkIHN0YXRlIHJlcHJlc2VudGF0aW9uLiAgU28sIHdlIGNvcHkgdGhlXG4gICBbU3RhdGUucmVwcl0gdHlwZSBkZWZpbml0aW9uIGFuZCBbYXNzaWduXSBmdW5jdGlvbiB0byBoZXJlIGZyb20gdGhlIHN0YW5kYXJkIGxpYnJhcnksXG4gICBhbmQgdXNlIFtPYmoubWFnaWNdIHRvIGdldCBhY2Nlc3MgdG8gdGhlIHVuZGVybHlpbmcgaW1wbGVtZW50YXRpb24uICopXG5cbigqIFJlZ3Jlc3Npb24gdGVzdHMgb3VnaHQgdG8gYmUgZGV0ZXJtaW5pc3RpYyBiZWNhdXNlIHRoYXQgd2F5IGFueW9uZSB3aG8gYnJlYWtzIHRoZSB0ZXN0XG4gICBrbm93cyB0aGF0IGl0J3MgdGhlaXIgY29kZSB0aGF0IGJyb2tlIHRoZSB0ZXN0LiAgSWYgdGVzdHMgYXJlIG5vbmRldGVybWluaXN0aWMsIGEgdGVzdFxuICAgZmFpbHVyZSBtYXkgaW5zdGVhZCBoYXBwZW4gYmVjYXVzZSB0aGUgdGVzdCBydW5uZXIgZ290IHVubHVja3kgYW5kIHVuY292ZXJlZCBhblxuICAgZXhpc3RpbmcgYnVnIGluIHRoZSBjb2RlIHN1cHBvc2VkbHkgYmVpbmcgXCJwcm90ZWN0ZWRcIiBieSB0aGUgdGVzdCBpbiBxdWVzdGlvbi4gKilcbmxldCBmb3JiaWRfbm9uZGV0ZXJtaW5pc21faW5fdGVzdHMgfmFsbG93X2luX3Rlc3RzID1cbiAgaWYgYW1fdGVzdGluZ1xuICB0aGVuIChcbiAgICBtYXRjaCBhbGxvd19pbl90ZXN0cyB3aXRoXG4gICAgfCBTb21lIHRydWUgLT4gKClcbiAgICB8IE5vbmUgfCBTb21lIGZhbHNlIC0+XG4gICAgICBmYWlsd2l0aFxuICAgICAgICBcImluaXRpYWxpemluZyBSYW5kb20gd2l0aCBhIG5vbmRldGVybWluaXN0aWMgc2VlZCBpcyBmb3JiaWRkZW4gaW4gaW5saW5lIHRlc3RzXCIpXG47O1xuXG5leHRlcm5hbCByYW5kb21fc2VlZCA6IHVuaXQgLT4gaW50IGFycmF5ID0gXCJjYW1sX3N5c19yYW5kb21fc2VlZFwiXG5cbmxldCByYW5kb21fc2VlZCA/YWxsb3dfaW5fdGVzdHMgKCkgPVxuICBmb3JiaWRfbm9uZGV0ZXJtaW5pc21faW5fdGVzdHMgfmFsbG93X2luX3Rlc3RzO1xuICByYW5kb21fc2VlZCAoKVxuOztcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG4gICgqIFdlIGFsbG93IGxhemluZXNzIG9ubHkgZm9yIHRoZSBkZWZpbml0aW9uIG9mIFtkZWZhdWx0XSwgYmVsb3csIHdoaWNoIG1heSBsYXppbHkgY2FsbFxuICAgICBbbWFrZV9zZWxmX2luaXRdLiBGb3IgYWxsIG90aGVyIHB1cnBvc2VzLCB3ZSBjcmVhdGUgYW5kIHVzZSBbdF0gZWFnZXJseS4gKilcbiAgdHlwZSB0ID0gQ2FtbC5SYW5kb20uU3RhdGUudCBMYXp5LnRcblxuICBsZXQgYml0cyB0ID0gQ2FtbC5SYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSB0KVxuICBsZXQgYm9vbCB0ID0gQ2FtbC5SYW5kb20uU3RhdGUuYm9vbCAoTGF6eS5mb3JjZSB0KVxuICBsZXQgaW50IHQgeCA9IENhbWwuUmFuZG9tLlN0YXRlLmludCAoTGF6eS5mb3JjZSB0KSB4XG4gIGxldCBpbnQzMiB0IHggPSBDYW1sLlJhbmRvbS5TdGF0ZS5pbnQzMiAoTGF6eS5mb3JjZSB0KSB4XG4gIGxldCBpbnQ2NCB0IHggPSBDYW1sLlJhbmRvbS5TdGF0ZS5pbnQ2NCAoTGF6eS5mb3JjZSB0KSB4XG4gIGxldCBuYXRpdmVpbnQgdCB4ID0gQ2FtbC5SYW5kb20uU3RhdGUubmF0aXZlaW50IChMYXp5LmZvcmNlIHQpIHhcbiAgbGV0IG1ha2Ugc2VlZCA9IExhenkuZnJvbV92YWwgKENhbWwuUmFuZG9tLlN0YXRlLm1ha2Ugc2VlZClcbiAgbGV0IGNvcHkgdCA9IExhenkuZnJvbV92YWwgKENhbWwuUmFuZG9tLlN0YXRlLmNvcHkgKExhenkuZm9yY2UgdCkpXG4gIGxldCBjaGFyIHQgPSBpbnQgdCAyNTYgfD4gQ2hhci51bnNhZmVfb2ZfaW50XG4gIGxldCBhc2NpaSB0ID0gaW50IHQgMTI4IHw+IENoYXIudW5zYWZlX29mX2ludFxuXG4gIGxldCBtYWtlX3NlbGZfaW5pdCA/YWxsb3dfaW5fdGVzdHMgKCkgPVxuICAgIGZvcmJpZF9ub25kZXRlcm1pbmlzbV9pbl90ZXN0cyB+YWxsb3dfaW5fdGVzdHM7XG4gICAgTGF6eS5mcm9tX3ZhbCAoQ2FtbC5SYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQgKCkpXG4gIDs7XG5cbiAgbGV0IGFzc2lnbiA9IFJhbmRvbV9yZXByLmFzc2lnblxuXG4gIGxldCBmdWxsX2luaXQgdCBzZWVkID0gYXNzaWduIHQgKG1ha2Ugc2VlZClcblxuICBsZXQgZGVmYXVsdCA9XG4gICAgaWYgYW1fdGVzdGluZ1xuICAgIHRoZW4gKFxuICAgICAgKCogV2UgZGVmaW5lIEJhc2UncyBkZWZhdWx0IHJhbmRvbSBzdGF0ZSBhcyBhIGNvcHkgb2YgT0NhbWwncyBkZWZhdWx0IHJhbmRvbSBzdGF0ZS5cbiAgICAgICAgIFRoaXMgbWVhbnMgdGhhdCBwcm9ncmFtcyB0aGF0IHVzZSBCYXNlLlJhbmRvbSB3aWxsIHNlZSB0aGUgc2FtZSBzZXF1ZW5jZSBvZlxuICAgICAgICAgcmFuZG9tIGJpdHMgYXMgaWYgdGhleSBoYWQgdXNlZCBDYW1sLlJhbmRvbS4gSG93ZXZlciwgYmVjYXVzZSBbZ2V0X3N0YXRlXSByZXR1cm5zXG4gICAgICAgICBhIGNvcHksIEJhc2UuUmFuZG9tIGFuZCBPQ2FtbC5SYW5kb20gYXJlIG5vdCB1c2luZyB0aGUgc2FtZSBzdGF0ZS4gSWYgYSBwcm9ncmFtXG4gICAgICAgICB1c2VkIGJvdGgsIGVhY2ggb2YgdGhlbSB3b3VsZCBnbyB0aHJvdWdoIHRoZSBzYW1lIHNlcXVlbmNlIG9mIHJhbmRvbSBiaXRzLiBUb1xuICAgICAgICAgYXZvaWQgdGhhdCwgd2UgcmVzZXQgT0NhbWwncyByYW5kb20gc3RhdGUgdG8gYSBkaWZmZXJlbnQgc2VlZCwgZ2l2aW5nIGl0IGFcbiAgICAgICAgIGRpZmZlcmVudCBzZXF1ZW5jZS4gKilcbiAgICAgIGxldCB0ID0gQ2FtbC5SYW5kb20uZ2V0X3N0YXRlICgpIGluXG4gICAgICBDYW1sLlJhbmRvbS5pbml0IDEzNztcbiAgICAgIExhenkuZnJvbV92YWwgdClcbiAgICBlbHNlXG4gICAgICBsYXp5XG4gICAgICAgICgqIE91dHNpZGUgb2YgdGVzdHMsIHdlIGluaXRpYWxpemUgcmFuZG9tIHN0YXRlIG5vbmRldGVybWluaXN0aWNhbGx5IGFuZCBsYXppbHkuXG4gICAgICAgICAgIFdlIGZvcmNlIHRoZSByYW5kb20gaW5pdGlhbGl6YXRpb24gdG8gYmUgbGF6eSBzbyB0aGF0IHdlIGRvIG5vdCBwYXkgYW55IGNvc3RcbiAgICAgICAgICAgZm9yIGl0IGluIHByb2dyYW1zIHRoYXQgZG8gbm90IHVzZSByYW5kb21uZXNzLiAqKVxuICAgICAgICAoTGF6eS5mb3JjZSAobWFrZV9zZWxmX2luaXQgKCkpKVxuICA7O1xuXG4gIGxldCBpbnRfb25fNjRiaXRzIHQgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDB4M0ZGRkZGRkYgKCogKDEgbHNsIDMwKSAtIDEgKilcbiAgICB0aGVuIGludCB0IGJvdW5kXG4gICAgZWxzZSBDYW1sLkludDY0LnRvX2ludCAoaW50NjQgdCAoQ2FtbC5JbnQ2NC5vZl9pbnQgYm91bmQpKVxuICA7O1xuXG4gIGxldCBpbnRfb25fMzJiaXRzIHQgYm91bmQgPVxuICAgICgqIE5vdCBhbHdheXMgdHJ1ZSB3aXRoIHRoZSBKYXZhU2NyaXB0IGJhY2tlbmQuICopXG4gICAgaWYgYm91bmQgPD0gMHgzRkZGRkZGRiAoKiAoMSBsc2wgMzApIC0gMSAqKVxuICAgIHRoZW4gaW50IHQgYm91bmRcbiAgICBlbHNlIENhbWwuSW50MzIudG9faW50IChpbnQzMiB0IChDYW1sLkludDMyLm9mX2ludCBib3VuZCkpXG4gIDs7XG5cbiAgbGV0IGludCA9XG4gICAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gICAgfCBXNjQgLT4gaW50X29uXzY0Yml0c1xuICAgIHwgVzMyIC0+IGludF9vbl8zMmJpdHNcbiAgOztcblxuICBsZXQgZnVsbF9yYW5nZV9pbnQ2NCA9XG4gICAgbGV0IG9wZW4gQ2FtbC5JbnQ2NCBpblxuICAgIGxldCBiaXRzIHN0YXRlID0gb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGZ1biBzdGF0ZSAtPlxuICAgICAgbG9neG9yXG4gICAgICAgIChiaXRzIHN0YXRlKVxuICAgICAgICAobG9neG9yIChzaGlmdF9sZWZ0IChiaXRzIHN0YXRlKSAzMCkgKHNoaWZ0X2xlZnQgKGJpdHMgc3RhdGUpIDYwKSlcbiAgOztcblxuICBsZXQgZnVsbF9yYW5nZV9pbnQzMiA9XG4gICAgbGV0IG9wZW4gQ2FtbC5JbnQzMiBpblxuICAgIGxldCBiaXRzIHN0YXRlID0gb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGZ1biBzdGF0ZSAtPiBsb2d4b3IgKGJpdHMgc3RhdGUpIChzaGlmdF9sZWZ0IChiaXRzIHN0YXRlKSAzMClcbiAgOztcblxuICBsZXQgZnVsbF9yYW5nZV9pbnRfb25fNjRiaXRzIHN0YXRlID0gQ2FtbC5JbnQ2NC50b19pbnQgKGZ1bGxfcmFuZ2VfaW50NjQgc3RhdGUpXG4gIGxldCBmdWxsX3JhbmdlX2ludF9vbl8zMmJpdHMgc3RhdGUgPSBDYW1sLkludDMyLnRvX2ludCAoZnVsbF9yYW5nZV9pbnQzMiBzdGF0ZSlcblxuICBsZXQgZnVsbF9yYW5nZV9pbnQgPVxuICAgIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICAgIHwgVzY0IC0+IGZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0c1xuICAgIHwgVzMyIC0+IGZ1bGxfcmFuZ2VfaW50X29uXzMyYml0c1xuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX25hdGl2ZWludF9vbl82NGJpdHMgc3RhdGUgPVxuICAgIENhbWwuSW50NjQudG9fbmF0aXZlaW50IChmdWxsX3JhbmdlX2ludDY0IHN0YXRlKVxuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX25hdGl2ZWludF9vbl8zMmJpdHMgc3RhdGUgPVxuICAgIENhbWwuTmF0aXZlaW50Lm9mX2ludDMyIChmdWxsX3JhbmdlX2ludDMyIHN0YXRlKVxuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX25hdGl2ZWludCA9XG4gICAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gICAgfCBXNjQgLT4gZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fNjRiaXRzXG4gICAgfCBXMzIgLT4gZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fMzJiaXRzXG4gIDs7XG5cbiAgbGV0IHJhaXNlX2Nyb3NzZWRfYm91bmRzIG5hbWUgbG93ZXJfYm91bmQgdXBwZXJfYm91bmQgc3RyaW5nX29mX2JvdW5kID1cbiAgICBQcmludGYuZmFpbHdpdGhmXG4gICAgICBcIlJhbmRvbS4lczogY3Jvc3NlZCBib3VuZHMgWyVzID4gJXNdXCJcbiAgICAgIG5hbWVcbiAgICAgIChzdHJpbmdfb2ZfYm91bmQgbG93ZXJfYm91bmQpXG4gICAgICAoc3RyaW5nX29mX2JvdW5kIHVwcGVyX2JvdW5kKVxuICAgICAgKClcbiAgW0BAY29sZF0gW0BAaW5saW5lIG5ldmVyXSBbQEBsb2NhbCBuZXZlcl0gW0BAc3BlY2lhbGlzZSBuZXZlcl1cbiAgOztcblxuICBsZXQgaW50X2luY2wgPVxuICAgIGxldCByZWMgaW5fcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgICAgbGV0IGludCA9IGZ1bGxfcmFuZ2VfaW50IHN0YXRlIGluXG4gICAgICBpZiBpbnQgPj0gbG8gJiYgaW50IDw9IGhpIHRoZW4gaW50IGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgICBpblxuICAgIGZ1biBzdGF0ZSBsbyBoaSAtPlxuICAgICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwiaW50XCIgbG8gaGkgSW50LnRvX3N0cmluZztcbiAgICAgIGxldCBkaWZmID0gaGkgLSBsbyBpblxuICAgICAgaWYgZGlmZiA9IEludC5tYXhfdmFsdWVcbiAgICAgIHRoZW4gbG8gKyAoZnVsbF9yYW5nZV9pbnQgc3RhdGUgbGFuZCBJbnQubWF4X3ZhbHVlKVxuICAgICAgZWxzZSBpZiBkaWZmID49IDBcbiAgICAgIHRoZW4gbG8gKyBpbnQgc3RhdGUgKEludC5zdWNjIGRpZmYpXG4gICAgICBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gIDs7XG5cbiAgbGV0IGludDMyX2luY2wgPVxuICAgIGxldCBvcGVuIEludDMyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCByZWMgaW5fcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgICAgbGV0IGludCA9IGZ1bGxfcmFuZ2VfaW50MzIgc3RhdGUgaW5cbiAgICAgIGlmIGludCA+PSBsbyAmJiBpbnQgPD0gaGkgdGhlbiBpbnQgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICAgIGluXG4gICAgbGV0IG9wZW4gQ2FtbC5JbnQzMiBpblxuICAgIGZ1biBzdGF0ZSBsbyBoaSAtPlxuICAgICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwiaW50MzJcIiBsbyBoaSB0b19zdHJpbmc7XG4gICAgICBsZXQgZGlmZiA9IHN1YiBoaSBsbyBpblxuICAgICAgaWYgZGlmZiA9IG1heF9pbnRcbiAgICAgIHRoZW4gYWRkIGxvIChsb2dhbmQgKGZ1bGxfcmFuZ2VfaW50MzIgc3RhdGUpIG1heF9pbnQpXG4gICAgICBlbHNlIGlmIGRpZmYgPj0gMGxcbiAgICAgIHRoZW4gYWRkIGxvIChpbnQzMiBzdGF0ZSAoc3VjYyBkaWZmKSlcbiAgICAgIGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgOztcblxuICBsZXQgbmF0aXZlaW50X2luY2wgPVxuICAgIGxldCBvcGVuIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgcmVjIGluX3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICAgIGxldCBpbnQgPSBmdWxsX3JhbmdlX25hdGl2ZWludCBzdGF0ZSBpblxuICAgICAgaWYgaW50ID49IGxvICYmIGludCA8PSBoaSB0aGVuIGludCBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gICAgaW5cbiAgICBsZXQgb3BlbiBDYW1sLk5hdGl2ZWludCBpblxuICAgIGZ1biBzdGF0ZSBsbyBoaSAtPlxuICAgICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwibmF0aXZlaW50XCIgbG8gaGkgdG9fc3RyaW5nO1xuICAgICAgbGV0IGRpZmYgPSBzdWIgaGkgbG8gaW5cbiAgICAgIGlmIGRpZmYgPSBtYXhfaW50XG4gICAgICB0aGVuIGFkZCBsbyAobG9nYW5kIChmdWxsX3JhbmdlX25hdGl2ZWludCBzdGF0ZSkgbWF4X2ludClcbiAgICAgIGVsc2UgaWYgZGlmZiA+PSAwblxuICAgICAgdGhlbiBhZGQgbG8gKG5hdGl2ZWludCBzdGF0ZSAoc3VjYyBkaWZmKSlcbiAgICAgIGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgOztcblxuICBsZXQgaW50NjRfaW5jbCA9XG4gICAgbGV0IG9wZW4gSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgbGV0IHJlYyBpbl9yYW5nZSBzdGF0ZSBsbyBoaSA9XG4gICAgICBsZXQgaW50ID0gZnVsbF9yYW5nZV9pbnQ2NCBzdGF0ZSBpblxuICAgICAgaWYgaW50ID49IGxvICYmIGludCA8PSBoaSB0aGVuIGludCBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gICAgaW5cbiAgICBsZXQgb3BlbiBDYW1sLkludDY0IGluXG4gICAgZnVuIHN0YXRlIGxvIGhpIC0+XG4gICAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJpbnQ2NFwiIGxvIGhpIHRvX3N0cmluZztcbiAgICAgIGxldCBkaWZmID0gc3ViIGhpIGxvIGluXG4gICAgICBpZiBkaWZmID0gbWF4X2ludFxuICAgICAgdGhlbiBhZGQgbG8gKGxvZ2FuZCAoZnVsbF9yYW5nZV9pbnQ2NCBzdGF0ZSkgbWF4X2ludClcbiAgICAgIGVsc2UgaWYgZGlmZiA+PSAwTFxuICAgICAgdGhlbiBhZGQgbG8gKGludDY0IHN0YXRlIChzdWNjIGRpZmYpKVxuICAgICAgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICA7O1xuXG4gICgqIFJldHVybiBhIHVuaWZvcm1seSByYW5kb20gZmxvYXQgaW4gWzAsIDEpLiAqKVxuICBsZXQgcmVjIHJhd2Zsb2F0IHN0YXRlID1cbiAgICBsZXQgb3BlbiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgc2NhbGUgPSAweDFwLTMwIGluXG4gICAgKCogMl4tMzAgKilcbiAgICBsZXQgcjEgPSBDYW1sLmZsb2F0X29mX2ludCAoYml0cyBzdGF0ZSkgaW5cbiAgICBsZXQgcjIgPSBDYW1sLmZsb2F0X29mX2ludCAoYml0cyBzdGF0ZSkgaW5cbiAgICBsZXQgcmVzdWx0ID0gKChyMSAqLiBzY2FsZSkgKy4gcjIpICouIHNjYWxlIGluXG4gICAgKCogV2l0aCB2ZXJ5IHNtYWxsIHByb2JhYmlsaXR5LCByZXN1bHQgY2FuIHJvdW5kIHVwIHRvIDEuMCwgc28gaW4gdGhhdCBjYXNlLCB3ZSBqdXN0XG4gICAgICAgdHJ5IGFnYWluLiAqKVxuICAgIGlmIHJlc3VsdCA8IDEuMCB0aGVuIHJlc3VsdCBlbHNlIHJhd2Zsb2F0IHN0YXRlXG4gIDs7XG5cbiAgbGV0IGZsb2F0IHN0YXRlIGhpID0gcmF3ZmxvYXQgc3RhdGUgKi4gaGlcblxuICBsZXQgZmxvYXRfcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgIGxldCBvcGVuIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGlmIGxvID4gaGkgdGhlbiByYWlzZV9jcm9zc2VkX2JvdW5kcyBcImZsb2F0XCIgbG8gaGkgQ2FtbC5zdHJpbmdfb2ZfZmxvYXQ7XG4gICAgbG8gKy4gZmxvYXQgc3RhdGUgKGhpIC0uIGxvKVxuICA7O1xuZW5kXG5cbmxldCBkZWZhdWx0ID0gUmFuZG9tX3JlcHIubWFrZV9kZWZhdWx0IFN0YXRlLmRlZmF1bHRcblxubGV0IGJpdHMgKCkgPSBTdGF0ZS5iaXRzIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdClcbmxldCBpbnQgeCA9IFN0YXRlLmludCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHhcbmxldCBpbnQzMiB4ID0gU3RhdGUuaW50MzIgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4XG5sZXQgbmF0aXZlaW50IHggPSBTdGF0ZS5uYXRpdmVpbnQgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4XG5sZXQgaW50NjQgeCA9IFN0YXRlLmludDY0IChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeFxubGV0IGZsb2F0IHggPSBTdGF0ZS5mbG9hdCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHhcbmxldCBpbnRfaW5jbCB4IHkgPSBTdGF0ZS5pbnRfaW5jbCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHggeVxubGV0IGludDMyX2luY2wgeCB5ID0gU3RhdGUuaW50MzJfaW5jbCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHggeVxubGV0IG5hdGl2ZWludF9pbmNsIHggeSA9IFN0YXRlLm5hdGl2ZWludF9pbmNsIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeCB5XG5sZXQgaW50NjRfaW5jbCB4IHkgPSBTdGF0ZS5pbnQ2NF9pbmNsIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeCB5XG5sZXQgZmxvYXRfcmFuZ2UgeCB5ID0gU3RhdGUuZmxvYXRfcmFuZ2UgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4IHlcbmxldCBib29sICgpID0gU3RhdGUuYm9vbCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpXG5sZXQgY2hhciAoKSA9IFN0YXRlLmNoYXIgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KVxubGV0IGFzY2lpICgpID0gU3RhdGUuYXNjaWkgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KVxubGV0IGZ1bGxfaW5pdCBzZWVkID0gU3RhdGUuZnVsbF9pbml0IChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgc2VlZFxubGV0IGluaXQgc2VlZCA9IGZ1bGxfaW5pdCBbfCBzZWVkIHxdXG5sZXQgc2VsZl9pbml0ID9hbGxvd19pbl90ZXN0cyAoKSA9IGZ1bGxfaW5pdCAocmFuZG9tX3NlZWQgP2FsbG93X2luX3Rlc3RzICgpKVxubGV0IHNldF9zdGF0ZSBzID0gU3RhdGUuYXNzaWduIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgc1xuIiwiKCoqIEFuIGludGVybmFsLW9ubHkgbW9kdWxlIGZhY3RvcmVkIG91dCBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gY29yZV9hcnJheVxuICAgIGFuZCBjb3JlX2xpc3QuICBDb250YWlucyBjb2RlIGZvciBwZXJtdXRpbmcgYW4gYXJyYXkuICopXG5cbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBBcnJheTBcblxubGV0IHBlcm11dGUgPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgPyhwb3MgPSAwKSA/bGVuIHQgPVxuICAoKiBDb3BpZWQgZnJvbSBbT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbjBdIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSB0dXBsZSB3aGVuIGNvbXBpbGluZ1xuICAgICB3aXRob3V0IGZsYW1iZGEuICopXG4gIGxldCB0b3RhbF9sZW5ndGggPSBsZW5ndGggdCBpblxuICBsZXQgbGVuID1cbiAgICBtYXRjaCBsZW4gd2l0aFxuICAgIHwgU29tZSBsIC0+IGxcbiAgICB8IE5vbmUgLT4gdG90YWxfbGVuZ3RoIC0gcG9zXG4gIGluXG4gIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24wLmNoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoO1xuICBsZXQgbnVtX3N3YXBzID0gbGVuIC0gMSBpblxuICBmb3IgaSA9IG51bV9zd2FwcyBkb3dudG8gMSBkb1xuICAgIGxldCB0aGlzX2kgPSBwb3MgKyBpIGluXG4gICAgKCogW3JhbmRvbV9pXSBpcyBkcmF3biBmcm9tIFtwb3MsdGhpc19pXSAqKVxuICAgIGxldCByYW5kb21faSA9IHBvcyArIFJhbmRvbS5TdGF0ZS5pbnQgcmFuZG9tX3N0YXRlIChpICsgMSkgaW5cbiAgICBzd2FwIHQgdGhpc19pIHJhbmRvbV9pXG4gIGRvbmVcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxubGV0IGNvbnN0IGMgXyA9IGNcblxuZXh0ZXJuYWwgaWdub3JlIDogXyAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxuKCogdGhpcyBoYXMgdGhlIHNhbWUgYmVoYXZpb3IgYXMgW0NhbWwuaWdub3JlXSAqKVxuXG5sZXQgbm9uIGYgeCA9IG5vdCAoZiB4KVxuXG5sZXQgZm9yZXZlciBmID1cbiAgbGV0IHJlYyBmb3JldmVyICgpID1cbiAgICBmICgpO1xuICAgIGZvcmV2ZXIgKClcbiAgaW5cbiAgdHJ5IGZvcmV2ZXIgKCkgd2l0aFxuICB8IGUgLT4gZVxuOztcblxuZXh0ZXJuYWwgaWQgOiAnYSAtPiAnYSA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsICggfD4gKSA6ICdhIC0+ICgnYSAtPiAnYikgLT4gJ2IgPSBcIiVyZXZhcHBseVwiXG5cbigqIFRoZSB0eXBpY2FsIHVzZSBjYXNlIGZvciB0aGVzZSBmdW5jdGlvbnMgaXMgdG8gcGFzcyBpbiBmdW5jdGlvbmFsIGFyZ3VtZW50cyBhbmQgZ2V0XG4gICBmdW5jdGlvbnMgYXMgYSByZXN1bHQuICopXG5sZXQgY29tcG9zZSBmIGcgeCA9IGYgKGcgeClcbmxldCBmbGlwIGYgeCB5ID0gZiB5IHhcbmxldCByZWMgYXBwbHlfbl90aW1lcyB+biBmIHggPSBpZiBuIDw9IDAgdGhlbiB4IGVsc2UgYXBwbHlfbl90aW1lcyB+bjoobiAtIDEpIGYgKGYgeClcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPVxuICB8IExlc3NcbiAgfCBFcXVhbFxuICB8IEdyZWF0ZXJcbltAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBlbnVtZXJhdGUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IGNvbXBhcmUgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuXG5sZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gIChmdW4gaHN2IGFyZyAtPlxuICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICB8IExlc3MgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwXG4gICAgIHwgRXF1YWwgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxXG4gICAgIHwgR3JlYXRlciAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDJcbiAgICAgICAgICAgICAgICAgIDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuOztcblxubGV0IChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICBsZXQgZnVuYyBhcmcgPVxuICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgaW5cbiAgZnVuIHggLT4gZnVuYyB4XG47O1xuXG5sZXQgYWxsID0gKFsgTGVzczsgRXF1YWw7IEdyZWF0ZXIgXSA6IHQgbGlzdClcblxubGV0IHRfb2Zfc2V4cCA9XG4gIChsZXQgZXJyb3Jfc291cmNlX18wMDVfID0gXCJvcmRlcmluZy5tbC50XCIgaW5cbiAgIGZ1bmN0aW9uXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJsZXNzXCIgfCBcIkxlc3NcIikgLT4gTGVzc1xuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZXF1YWxcIiB8IFwiRXF1YWxcIikgLT4gRXF1YWxcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImdyZWF0ZXJcIiB8IFwiR3JlYXRlclwiKSAtPiBHcmVhdGVyXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImxlc3NcIiB8IFwiTGVzc1wiKSA6OiBfKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNl9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiZXF1YWxcIiB8IFwiRXF1YWxcIikgOjogXykgYXMgc2V4cF9fMDA2XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDZfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImdyZWF0ZXJcIiB8IFwiR3JlYXRlclwiKSA6OiBfKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNl9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgfCBzZXhwX18wMDRfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbiAgICAgICAgICAgICAgICAgICA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuOztcblxubGV0IHNleHBfb2ZfdCA9XG4gIChmdW5jdGlvblxuICAgIHwgTGVzcyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJMZXNzXCJcbiAgICB8IEVxdWFsIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkVxdWFsXCJcbiAgICB8IEdyZWF0ZXIgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiR3JlYXRlclwiXG4gICAgICAgICAgICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG47O1xuXG5sZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICB7IHVudHlwZWQgPVxuICAgICAgVmFyaWFudFxuICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICBbIE5vX3RhZyB7IG5hbWUgPSBcIkxlc3NcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIkVxdWFsXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJHcmVhdGVyXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbltAQEBlbmRdXG5cbmxldCBlcXVhbCBhIGIgPSBjb21wYXJlIGEgYiA9IDBcblxubW9kdWxlIEV4cG9ydCA9IHN0cnVjdFxuICB0eXBlIF9vcmRlcmluZyA9IHQgPVxuICAgIHwgTGVzc1xuICAgIHwgRXF1YWxcbiAgICB8IEdyZWF0ZXJcbmVuZFxuXG5sZXQgb2ZfaW50IG4gPSBpZiBuIDwgMCB0aGVuIExlc3MgZWxzZSBpZiBuID0gMCB0aGVuIEVxdWFsIGVsc2UgR3JlYXRlclxuXG5sZXQgdG9faW50ID0gZnVuY3Rpb25cbiAgfCBMZXNzIC0+IC0xXG4gIHwgRXF1YWwgLT4gMFxuICB8IEdyZWF0ZXIgLT4gMVxuOztcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5tb2R1bGUgRWl0aGVyID0gRWl0aGVyMFxuXG5cbmluY2x1ZGUgTGlzdDFcblxuKCogVGhpcyBpdHNlbGYgaW5jbHVkZXMgW0xpc3QwXS4gKilcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2EgbGlzdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPSBsaXN0X29mX3NleHBcbiAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9IHNleHBfb2ZfbGlzdFxuXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gbGlzdF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIE9yX3VuZXF1YWxfbGVuZ3RocyA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHwgT2sgb2YgJ2FcbiAgICB8IFVuZXF1YWxfbGVuZ3Roc1xuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID1cbiAgICBmdW4gX2NtcF9fYSBhX18wMDZfIGJfXzAwN18gLT5cbiAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMDZfIGJfXzAwN19cbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFfXzAwNl8sIGJfXzAwN18gd2l0aFxuICAgICAgfCBPayBfYV9fMDA4XywgT2sgX2JfXzAwOV8gLT4gX2NtcF9fYSBfYV9fMDA4XyBfYl9fMDA5X1xuICAgICAgfCBPayBfLCBfIC0+IC0xXG4gICAgICB8IF8sIE9rIF8gLT4gMVxuICAgICAgfCBVbmVxdWFsX2xlbmd0aHMsIFVuZXF1YWxfbGVuZ3RocyAtPiAwKVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIGZ1biAodHlwZSBhX18wMTNfKSA6ICgoYV9fMDEzXyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IGFfXzAxM18gdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gICAgZnVuIF9vZl9hX18wMTBfIC0+IGZ1bmN0aW9uXG4gICAgICB8IE9rIGFyZzBfXzAxMV8gLT5cbiAgICAgICAgbGV0IHJlczBfXzAxMl8gPSBfb2ZfYV9fMDEwXyBhcmcwX18wMTFfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIk9rXCI7IHJlczBfXzAxMl8gXVxuICAgICAgfCBVbmVxdWFsX2xlbmd0aHMgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiVW5lcXVhbF9sZW5ndGhzXCJcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbmluY2x1ZGUgVFxuXG5sZXQgaW52YXJpYW50IGYgdCA9IGl0ZXIgdCB+ZlxubGV0IG9mX2xpc3QgdCA9IHRcblxubGV0IHJhbmdlJyB+Y29tcGFyZSB+c3RyaWRlID8oc3RhcnQgPSBgaW5jbHVzaXZlKSA/KHN0b3AgPSBgZXhjbHVzaXZlKSBzdGFydF9pIHN0b3BfaSA9XG4gIGxldCBuZXh0X2kgPSBzdHJpZGUgc3RhcnRfaSBpblxuICBsZXQgb3JkZXIgeCB5ID0gT3JkZXJpbmcub2ZfaW50IChjb21wYXJlIHggeSkgaW5cbiAgbGV0IHJhaXNlX3N0cmlkZV9jYW5ub3RfcmV0dXJuX3NhbWVfdmFsdWUgKCkgPVxuICAgIGludmFsaWRfYXJnIFwiTGlzdC5yYW5nZSc6IHN0cmlkZSBmdW5jdGlvbiBjYW5ub3QgcmV0dXJuIHRoZSBzYW1lIHZhbHVlXCJcbiAgaW5cbiAgbGV0IGluaXRpYWxfc3RyaWRlX29yZGVyID1cbiAgICBtYXRjaCBvcmRlciBzdGFydF9pIG5leHRfaSB3aXRoXG4gICAgfCBFcXVhbCAtPiByYWlzZV9zdHJpZGVfY2Fubm90X3JldHVybl9zYW1lX3ZhbHVlICgpXG4gICAgfCBMZXNzIC0+IGBMZXNzXG4gICAgfCBHcmVhdGVyIC0+IGBHcmVhdGVyXG4gIGluXG4gIGxldCByZWMgbG9vcCBpIGFjY3VtID1cbiAgICBsZXQgaV90b19zdG9wX29yZGVyID0gb3JkZXIgaSBzdG9wX2kgaW5cbiAgICBtYXRjaCBpX3RvX3N0b3Bfb3JkZXIsIGluaXRpYWxfc3RyaWRlX29yZGVyIHdpdGhcbiAgICB8IExlc3MsIGBMZXNzIHwgR3JlYXRlciwgYEdyZWF0ZXIgLT5cbiAgICAgICgqIGhhdmVuJ3QgeWV0IHJlYWNoZWQgW3N0b3BfaV0uIENvbnRpbnVlLiAqKVxuICAgICAgbGV0IG5leHRfaSA9IHN0cmlkZSBpIGluXG4gICAgICAobWF0Y2ggb3JkZXIgaSBuZXh0X2ksIGluaXRpYWxfc3RyaWRlX29yZGVyIHdpdGhcbiAgICAgICB8IEVxdWFsLCBfIC0+IHJhaXNlX3N0cmlkZV9jYW5ub3RfcmV0dXJuX3NhbWVfdmFsdWUgKClcbiAgICAgICB8IExlc3MsIGBHcmVhdGVyIHwgR3JlYXRlciwgYExlc3MgLT5cbiAgICAgICAgIGludmFsaWRfYXJnIFwiTGlzdC5yYW5nZSc6IHN0cmlkZSBmdW5jdGlvbiBjYW5ub3QgY2hhbmdlIGRpcmVjdGlvblwiXG4gICAgICAgfCBMZXNzLCBgTGVzcyB8IEdyZWF0ZXIsIGBHcmVhdGVyIC0+IGxvb3AgbmV4dF9pIChpIDo6IGFjY3VtKSlcbiAgICB8IExlc3MsIGBHcmVhdGVyIHwgR3JlYXRlciwgYExlc3MgLT5cbiAgICAgICgqIHN0ZXBwZWQgcGFzdCBbc3RvcF9pXS4gIEZpbmlzaGVkLiAqKVxuICAgICAgYWNjdW1cbiAgICB8IEVxdWFsLCBfIC0+XG4gICAgICAoKiByZWFjaGVkIFtzdG9wX2ldLiAgRmluaXNoZWQuICopXG4gICAgICAobWF0Y2ggc3RvcCB3aXRoXG4gICAgICAgfCBgaW5jbHVzaXZlIC0+IGkgOjogYWNjdW1cbiAgICAgICB8IGBleGNsdXNpdmUgLT4gYWNjdW0pXG4gIGluXG4gIGxldCBzdGFydF9pID1cbiAgICBtYXRjaCBzdGFydCB3aXRoXG4gICAgfCBgaW5jbHVzaXZlIC0+IHN0YXJ0X2lcbiAgICB8IGBleGNsdXNpdmUgLT4gbmV4dF9pXG4gIGluXG4gIHJldiAobG9vcCBzdGFydF9pIFtdKVxuOztcblxubGV0IHJhbmdlID8oc3RyaWRlID0gMSkgPyhzdGFydCA9IGBpbmNsdXNpdmUpID8oc3RvcCA9IGBleGNsdXNpdmUpIHN0YXJ0X2kgc3RvcF9pID1cbiAgaWYgc3RyaWRlID0gMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5yYW5nZTogc3RyaWRlIG11c3QgYmUgbm9uLXplcm9cIjtcbiAgcmFuZ2UnIH5jb21wYXJlIH5zdHJpZGU6KGZ1biB4IC0+IHggKyBzdHJpZGUpIH5zdGFydCB+c3RvcCBzdGFydF9pIHN0b3BfaVxuOztcblxubGV0IGhkIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBfIC0+IFNvbWUgeFxuOztcblxubGV0IHRsIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgXyA6OiB0JyAtPiBTb21lIHQnXG47O1xuXG5sZXQgbnRoIHQgbiA9XG4gIGlmIG4gPCAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgcmVjIG50aF9hdXggdCBuID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBbXSAtPiBOb25lXG4gICAgICB8IGEgOjogdCAtPiBpZiBuID0gMCB0aGVuIFNvbWUgYSBlbHNlIG50aF9hdXggdCAobiAtIDEpXG4gICAgaW5cbiAgICBudGhfYXV4IHQgbilcbjs7XG5cbmxldCBudGhfZXhuIHQgbiA9XG4gIG1hdGNoIG50aCB0IG4gd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmdmIFwiTGlzdC5udGhfZXhuICVkIGNhbGxlZCBvbiBsaXN0IG9mIGxlbmd0aCAlZFwiIG4gKGxlbmd0aCB0KSAoKVxuICB8IFNvbWUgYSAtPiBhXG47O1xuXG5sZXQgdW5vcmRlcmVkX2FwcGVuZCBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIGwgfCBsLCBbXSAtPiBsXG4gIHwgXyAtPiByZXZfYXBwZW5kIGwxIGwyXG47O1xuXG5tb2R1bGUgQ2hlY2tfbGVuZ3RoMiA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPVxuICAgIHwgU2FtZV9sZW5ndGggb2YgaW50XG4gICAgfCBVbmVxdWFsX2xlbmd0aHMgb2ZcbiAgICAgICAgeyBzaGFyZWRfbGVuZ3RoIDogaW50XG4gICAgICAgIDsgdGFpbF9vZl9hIDogJ2EgbGlzdFxuICAgICAgICA7IHRhaWxfb2ZfYiA6ICdiIGxpc3RcbiAgICAgICAgfVxuXG4gICgqIEluIHRoZSBbVW5lcXVhbF9sZW5ndGhzXSBjYXNlLCBhdCBsZWFzdCBvbmUgb2YgdGhlIHRhaWxzIHdpbGwgYmUgbm9uLWVtcHR5LiAqKVxuICBsZXQgb2ZfbGlzdHMgbDEgbDIgPVxuICAgIGxldCByZWMgbG9vcCBhIGIgc2hhcmVkX2xlbmd0aCA9XG4gICAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICAgIHwgW10sIFtdIC0+IFNhbWVfbGVuZ3RoIHNoYXJlZF9sZW5ndGhcbiAgICAgIHwgXyA6OiBhLCBfIDo6IGIgLT4gbG9vcCBhIGIgKHNoYXJlZF9sZW5ndGggKyAxKVxuICAgICAgfCBbXSwgXyB8IF8sIFtdIC0+IFVuZXF1YWxfbGVuZ3RocyB7IHNoYXJlZF9sZW5ndGg7IHRhaWxfb2ZfYSA9IGE7IHRhaWxfb2ZfYiA9IGIgfVxuICAgIGluXG4gICAgbG9vcCBsMSBsMiAwXG4gIDs7XG5lbmRcblxubGV0IGNoZWNrX2xlbmd0aDJfZXhuIG5hbWUgbDEgbDIgPVxuICBtYXRjaCBDaGVja19sZW5ndGgyLm9mX2xpc3RzIGwxIGwyIHdpdGhcbiAgfCBTYW1lX2xlbmd0aCBfIC0+ICgpXG4gIHwgVW5lcXVhbF9sZW5ndGhzIHsgc2hhcmVkX2xlbmd0aDsgdGFpbF9vZl9hOyB0YWlsX29mX2IgfSAtPlxuICAgIGludmFsaWRfYXJnZlxuICAgICAgXCJsZW5ndGggbWlzbWF0Y2ggaW4gJXM6ICVkIDw+ICVkXCJcbiAgICAgIG5hbWVcbiAgICAgIChzaGFyZWRfbGVuZ3RoICsgbGVuZ3RoIHRhaWxfb2ZfYSlcbiAgICAgIChzaGFyZWRfbGVuZ3RoICsgbGVuZ3RoIHRhaWxfb2ZfYilcbiAgICAgICgpXG47O1xuXG5sZXQgY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZiA9XG4gIG1hdGNoIENoZWNrX2xlbmd0aDIub2ZfbGlzdHMgbDEgbDIgd2l0aFxuICB8IFNhbWVfbGVuZ3RoIF8gLT4gT3JfdW5lcXVhbF9sZW5ndGhzLk9rIChmIGwxIGwyKVxuICB8IFVuZXF1YWxfbGVuZ3RocyBfIC0+IFVuZXF1YWxfbGVuZ3Roc1xuOztcblxubW9kdWxlIENoZWNrX2xlbmd0aDMgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiLCAnYykgdCA9XG4gICAgfCBTYW1lX2xlbmd0aCBvZiBpbnRcbiAgICB8IFVuZXF1YWxfbGVuZ3RocyBvZlxuICAgICAgICB7IHNoYXJlZF9sZW5ndGggOiBpbnRcbiAgICAgICAgOyB0YWlsX29mX2EgOiAnYSBsaXN0XG4gICAgICAgIDsgdGFpbF9vZl9iIDogJ2IgbGlzdFxuICAgICAgICA7IHRhaWxfb2ZfYyA6ICdjIGxpc3RcbiAgICAgICAgfVxuXG4gICgqIEluIHRoZSBbVW5lcXVhbF9sZW5ndGhzXSBjYXNlLCBhdCBsZWFzdCBvbmUgb2YgdGhlIHRhaWxzIHdpbGwgYmUgbm9uLWVtcHR5LiAqKVxuICBsZXQgb2ZfbGlzdHMgbDEgbDIgbDMgPVxuICAgIGxldCByZWMgbG9vcCBhIGIgYyBzaGFyZWRfbGVuZ3RoID1cbiAgICAgIG1hdGNoIGEsIGIsIGMgd2l0aFxuICAgICAgfCBbXSwgW10sIFtdIC0+IFNhbWVfbGVuZ3RoIHNoYXJlZF9sZW5ndGhcbiAgICAgIHwgXyA6OiBhLCBfIDo6IGIsIF8gOjogYyAtPiBsb29wIGEgYiBjIChzaGFyZWRfbGVuZ3RoICsgMSlcbiAgICAgIHwgW10sIF8sIF8gfCBfLCBbXSwgXyB8IF8sIF8sIFtdIC0+XG4gICAgICAgIFVuZXF1YWxfbGVuZ3RocyB7IHNoYXJlZF9sZW5ndGg7IHRhaWxfb2ZfYSA9IGE7IHRhaWxfb2ZfYiA9IGI7IHRhaWxfb2ZfYyA9IGMgfVxuICAgIGluXG4gICAgbG9vcCBsMSBsMiBsMyAwXG4gIDs7XG5lbmRcblxubGV0IGNoZWNrX2xlbmd0aDNfZXhuIG5hbWUgbDEgbDIgbDMgPVxuICBtYXRjaCBDaGVja19sZW5ndGgzLm9mX2xpc3RzIGwxIGwyIGwzIHdpdGhcbiAgfCBTYW1lX2xlbmd0aCBfIC0+ICgpXG4gIHwgVW5lcXVhbF9sZW5ndGhzIHsgc2hhcmVkX2xlbmd0aDsgdGFpbF9vZl9hOyB0YWlsX29mX2I7IHRhaWxfb2ZfYyB9IC0+XG4gICAgbGV0IG4xID0gc2hhcmVkX2xlbmd0aCArIGxlbmd0aCB0YWlsX29mX2EgaW5cbiAgICBsZXQgbjIgPSBzaGFyZWRfbGVuZ3RoICsgbGVuZ3RoIHRhaWxfb2ZfYiBpblxuICAgIGxldCBuMyA9IHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9jIGluXG4gICAgaW52YWxpZF9hcmdmIFwibGVuZ3RoIG1pc21hdGNoIGluICVzOiAlZCA8PiAlZCB8fCAlZCA8PiAlZFwiIG5hbWUgbjEgbjIgbjIgbjMgKClcbjs7XG5cbmxldCBjaGVja19sZW5ndGgzIGwxIGwyIGwzIH5mID1cbiAgbWF0Y2ggQ2hlY2tfbGVuZ3RoMy5vZl9saXN0cyBsMSBsMiBsMyB3aXRoXG4gIHwgU2FtZV9sZW5ndGggXyAtPiBPcl91bmVxdWFsX2xlbmd0aHMuT2sgKGYgbDEgbDIgbDMpXG4gIHwgVW5lcXVhbF9sZW5ndGhzIF8gLT4gVW5lcXVhbF9sZW5ndGhzXG47O1xuXG5sZXQgaXRlcjIgbDEgbDIgfmYgPSBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihpdGVyMl9vayB+ZilcblxubGV0IGl0ZXIyX2V4biBsMSBsMiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiaXRlcjJfZXhuXCIgbDEgbDI7XG4gIGl0ZXIyX29rIGwxIGwyIH5mXG47O1xuXG5sZXQgcmV2X21hcDIgbDEgbDIgfmYgPSBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihyZXZfbWFwMl9vayB+ZilcblxubGV0IHJldl9tYXAyX2V4biBsMSBsMiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwicmV2X21hcDJfZXhuXCIgbDEgbDI7XG4gIHJldl9tYXAyX29rIGwxIGwyIH5mXG47O1xuXG5sZXQgZm9sZDIgbDEgbDIgfmluaXQgfmYgPSBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihmb2xkMl9vayB+aW5pdCB+ZilcblxubGV0IGZvbGQyX2V4biBsMSBsMiB+aW5pdCB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiZm9sZDJfZXhuXCIgbDEgbDI7XG4gIGZvbGQyX29rIGwxIGwyIH5pbml0IH5mXG47O1xuXG5sZXQgZm9yX2FsbDIgbDEgbDIgfmYgPSBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihmb3JfYWxsMl9vayB+ZilcblxubGV0IGZvcl9hbGwyX2V4biBsMSBsMiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiZm9yX2FsbDJfZXhuXCIgbDEgbDI7XG4gIGZvcl9hbGwyX29rIGwxIGwyIH5mXG47O1xuXG5sZXQgZXhpc3RzMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KGV4aXN0czJfb2sgfmYpXG5cbmxldCBleGlzdHMyX2V4biBsMSBsMiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiZXhpc3RzMl9leG5cIiBsMSBsMjtcbiAgZXhpc3RzMl9vayBsMSBsMiB+ZlxuOztcblxubGV0IG1lbSB0IGEgfmVxdWFsID1cbiAgbGV0IHJlYyBsb29wIGVxdWFsIGEgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gZmFsc2VcbiAgICB8IGIgOjogYnMgLT4gZXF1YWwgYSBiIHx8IGxvb3AgZXF1YWwgYSBic1xuICBpblxuICBsb29wIGVxdWFsIGEgdFxuOztcblxuKCogVGhpcyBpcyBhIGNvcHkgb2YgdGhlIGNvZGUgZnJvbSB0aGUgc3RhbmRhcmQgbGlicmFyeSwgd2l0aCBhbiBleHRyYSBldGEtZXhwYW5zaW9uIHRvXG4gICBhdm9pZCBjcmVhdGluZyBwYXJ0aWFsIGNsb3N1cmVzIChzaG93ZWQgdXAgZm9yIFtmaWx0ZXJdKSBpbiBwcm9maWxpbmcpLiAqKVxubGV0IHJldl9maWx0ZXIgdCB+ZiA9XG4gIGxldCByZWMgZmluZCB+ZiBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3VcbiAgICB8IHggOjogbCAtPiBpZiBmIHggdGhlbiBmaW5kIH5mICh4IDo6IGFjY3UpIGwgZWxzZSBmaW5kIH5mIGFjY3UgbFxuICBpblxuICBmaW5kIH5mIFtdIHRcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9IHJldiAocmV2X2ZpbHRlciB0IH5mKVxuXG5sZXQgZmluZF9tYXAgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCB4IDo6IGwgLT5cbiAgICAgIChtYXRjaCBmIHggd2l0aFxuICAgICAgIHwgTm9uZSAtPiBsb29wIGxcbiAgICAgICB8IFNvbWUgXyBhcyByIC0+IHIpXG4gIGluXG4gIGxvb3AgdFxuOztcblxubGV0IGZpbmRfbWFwX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkxpc3QuZmluZF9tYXBfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGZpbmRfbWFwX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kX21hcCB0IH5mIHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCBTb21lIHggLT4geFxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfbWFwX2V4blxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCB4IDo6IGwgLT4gaWYgZiB4IHRoZW4gU29tZSB4IGVsc2UgbG9vcCBsXG4gIGluXG4gIGxvb3AgdFxuOztcblxubGV0IGZpbmRfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiTGlzdC5maW5kX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCByZWMgZmluZF9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IHggOjogdCAtPiBpZiBmIHggdGhlbiB4IGVsc2UgZmluZF9leG4gdCB+ZlxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfZXhuXG47O1xuXG5sZXQgZmluZGkgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgeCA6OiBsIC0+IGlmIGYgaSB4IHRoZW4gU29tZSAoaSwgeCkgZWxzZSBsb29wIChpICsgMSkgbFxuICBpblxuICBsb29wIDAgdFxuOztcblxubGV0IGZpbmRpX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkxpc3QuZmluZGlfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGZpbmRpX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kaSB0IH5mIHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCBTb21lIHggLT4geFxuICBpblxuICBmaW5kaV9leG5cbjs7XG5cbmxldCBmaW5kX21hcGkgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICAobWF0Y2ggZiBpIHggd2l0aFxuICAgICAgIHwgU29tZSBfIGFzIHJlc3VsdCAtPiByZXN1bHRcbiAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpIGwpXG4gIGluXG4gIGxvb3AgMCB0XG47O1xuXG5sZXQgZmluZF9tYXBpX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkxpc3QuZmluZF9tYXBpX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBmaW5kX21hcGlfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmRfbWFwaSB0IH5mIHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCBTb21lIHggLT4geFxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfbWFwaV9leG5cbjs7XG5cbmxldCBmb3JfYWxsaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIGkgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiB0cnVlXG4gICAgfCBoZCA6OiB0bCAtPiBmIGkgaGQgJiYgbG9vcCAoaSArIDEpIHRsXG4gIGluXG4gIGxvb3AgMCB0XG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIGkgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiBmYWxzZVxuICAgIHwgaGQgOjogdGwgLT4gZiBpIGhkIHx8IGxvb3AgKGkgKyAxKSB0bFxuICBpblxuICBsb29wIDAgdFxuOztcblxuKCoqIEZvciB0aGUgY29udGFpbmVyIGludGVyZmFjZS4gKilcbmxldCBmb2xkX2xlZnQgPSBmb2xkXG5cbmxldCB0b19hcnJheSA9IEFycmF5Lm9mX2xpc3RcbmxldCB0b19saXN0IHQgPSB0XG5cbmxldCBtYXhfbm9uX3RhaWxjYWxsID1cbiAgbWF0Y2ggU3lzLmJhY2tlbmRfdHlwZSB3aXRoXG4gIHwgU3lzLk5hdGl2ZSB8IFN5cy5CeXRlY29kZSAtPiAxXzAwMFxuICAoKiBXZSBkb24ndCBrbm93IHRoZSBzaXplIG9mIHRoZSBzdGFjaywgYmV0dGVyIGJlIHNhZmUgYW5kIGFzc3VtZSBpdCdzIHNtYWxsLiBUaGlzXG4gICAgIG51bWJlciB3YXMgdGFrZW4gZnJvbSBvY2FtbCNzdGRsaWIvbGlzdC5tbCB3aGljaCBpcyBhbHNvIGVxdWFsIHRvIHRoZSBkZWZhdWx0IGxpbWl0XG4gICAgIG9mIHJlY3Vyc2l2ZSBjYWxsIGluIHRoZSBqc19vZl9vY2FtbCBjb21waWxlciBiZWZvcmUgc3dpdGNoaW5nIHRvIHRyYW1wb2xpbmUuICopXG4gIHwgU3lzLk90aGVyIF8gLT4gNTBcbjs7XG5cbigqKiBUYWlsIHJlY3Vyc2l2ZSB2ZXJzaW9ucyBvZiBzdGFuZGFyZCBbTGlzdF0gbW9kdWxlICopXG5cbmxldCB0YWlsX2FwcGVuZCBsMSBsMiA9IHJldl9hcHBlbmQgKHJldiBsMSkgbDJcblxuKCogVGhlcmUgYXJlIGEgZmV3IG9wdGltaXplZCBsaXN0IG9wZXJhdGlvbnMgaGVyZSwgaW5jbHVkaW5nIGFwcGVuZCBhbmQgbWFwLiAgVGhlcmUgYXJlXG4gICBiYXNpY2FsbHkgdHdvIG9wdGltaXphdGlvbnMgaW4gcGxheTogbG9vcCB1bnJvbGxpbmcsIGFuZCBkeW5hbWljIHN3aXRjaGluZyBiZXR3ZWVuXG4gICBzdGFjayBhbmQgaGVhcCBhbGxvY2F0aW9uLlxuXG4gICBUaGUgbG9vcC11bnJvbGxpbmcgaXMgc3RyYWlnaHRmb3J3YXJkLCB3ZSBqdXN0IHVucm9sbCA1IGxldmVscyBvZiB0aGUgbG9vcC4gIFRoaXMgbWFrZXNcbiAgIGVhY2ggaXRlcmF0aW9uIGZhc3RlciwgYW5kIGFsc28gcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHN0YWNrIGZyYW1lcyBjb25zdW1lZCBwZXIgbGlzdFxuICAgZWxlbWVudC5cblxuICAgVGhlIGR5bmFtaWMgc3dpdGNoaW5nIGlzIGRvbmUgYnkgY291bnRpbmcgdGhlIG51bWJlciBvZiBzdGFjayBmcmFtZXMsIGFuZCB0aGVuXG4gICBzd2l0Y2hpbmcgdG8gdGhlIFwic2xvd1wiIGltcGxlbWVudGF0aW9uIHdoZW4gd2UgZXhjZWVkIGEgZ2l2ZW4gbGltaXQuICBUaGlzIG1lYW5zIHRoYXRcbiAgIHNob3J0IGxpc3RzIHVzZSB0aGUgZmFzdCBzdGFjay1hbGxvY2F0aW9uIG1ldGhvZCwgYW5kIGxvbmcgbGlzdHMgdXNlIGEgc2xvd2VyIG9uZSB0aGF0XG4gICBkb2Vzbid0IHJlcXVpcmUgc3RhY2sgc3BhY2UuICopXG5sZXQgcmVjIGNvdW50X2FwcGVuZCBsMSBsMiBjb3VudCA9XG4gIG1hdGNoIGwyIHdpdGhcbiAgfCBbXSAtPiBsMVxuICB8IF8gLT5cbiAgICAobWF0Y2ggbDEgd2l0aFxuICAgICB8IFtdIC0+IGwyXG4gICAgIHwgWyB4MSBdIC0+IHgxIDo6IGwyXG4gICAgIHwgWyB4MTsgeDIgXSAtPiB4MSA6OiB4MiA6OiBsMlxuICAgICB8IFsgeDE7IHgyOyB4MyBdIC0+IHgxIDo6IHgyIDo6IHgzIDo6IGwyXG4gICAgIHwgWyB4MTsgeDI7IHgzOyB4NCBdIC0+IHgxIDo6IHgyIDo6IHgzIDo6IHg0IDo6IGwyXG4gICAgIHwgeDEgOjogeDIgOjogeDMgOjogeDQgOjogeDUgOjogdGwgLT5cbiAgICAgICB4MVxuICAgICAgIDo6IHgyXG4gICAgICAgOjogeDNcbiAgICAgICA6OiB4NFxuICAgICAgIDo6IHg1XG4gICAgICAgOjpcbiAgICAgICAoaWYgY291bnQgPiBtYXhfbm9uX3RhaWxjYWxsXG4gICAgICAgIHRoZW4gdGFpbF9hcHBlbmQgdGwgbDJcbiAgICAgICAgZWxzZSBjb3VudF9hcHBlbmQgdGwgbDIgKGNvdW50ICsgMSkpKVxuOztcblxubGV0IGFwcGVuZCBsMSBsMiA9IGNvdW50X2FwcGVuZCBsMSBsMiAwXG5cbigqIEFuIG9yZGluYXJ5IHRhaWwgcmVjdXJzaXZlIG1hcCBidWlsZHMgdXAgYW4gaW50ZXJtZWRpYXRlIChyZXZlcnNlZCkgcmVwcmVzZW50YXRpb24sXG4gICB3aXRoIG9uZSBoZWFwIGFsbG9jYXRlZCBvYmplY3QgcGVyIGVsZW1lbnQuIFRoZSBmb2xsb3dpbmcgaW1wbGVtZW50YXRpb24gaW5zdGVhZCBjaHVua3NcbiAgIDkgb2JqZWN0cyBpbnRvIG9uZSBoZWFwIGFsbG9jYXRlZCBvYmplY3QsIHJlZHVjaW5nIGFsbG9jYXRpb24gYW5kIHBlcmZvcm1hbmNlIGNvc3RzXG4gICBhY2NvcmRpbmdseS4gTm90ZSB0aGF0IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgbGlzdCBpcyBkb25lIGJ5IHRoZSBzdGRsaWIncyBtYXBcbiAgIGZ1bmN0aW9uLiAqKVxubGV0IHRhaWxfbWFwIHhzIH5mID1cbiAgbGV0IHJlYyByaXNlIHlzID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHlzXG4gICAgfCAoeTAsIHkxLCB5MiwgeTMsIHk0LCB5NSwgeTYsIHk3LCB5OCkgOjogYnMgLT5cbiAgICAgIHJpc2UgKHkwIDo6IHkxIDo6IHkyIDo6IHkzIDo6IHk0IDo6IHk1IDo6IHk2IDo6IHk3IDo6IHk4IDo6IHlzKSBic1xuICBpblxuICBsZXQgcmVjIGRpdmUgYnMgPSBmdW5jdGlvblxuICAgIHwgeDAgOjogeDEgOjogeDIgOjogeDMgOjogeDQgOjogeDUgOjogeDYgOjogeDcgOjogeDggOjogeHMgLT5cbiAgICAgIGxldCB5MCA9IGYgeDAgaW5cbiAgICAgIGxldCB5MSA9IGYgeDEgaW5cbiAgICAgIGxldCB5MiA9IGYgeDIgaW5cbiAgICAgIGxldCB5MyA9IGYgeDMgaW5cbiAgICAgIGxldCB5NCA9IGYgeDQgaW5cbiAgICAgIGxldCB5NSA9IGYgeDUgaW5cbiAgICAgIGxldCB5NiA9IGYgeDYgaW5cbiAgICAgIGxldCB5NyA9IGYgeDcgaW5cbiAgICAgIGxldCB5OCA9IGYgeDggaW5cbiAgICAgIGRpdmUgKCh5MCwgeTEsIHkyLCB5MywgeTQsIHk1LCB5NiwgeTcsIHk4KSA6OiBicykgeHNcbiAgICB8IHhzIC0+IHJpc2UgKG5vbnRhaWxfbWFwIH5mIHhzKSBic1xuICBpblxuICBkaXZlIFtdIHhzXG47O1xuXG5sZXQgcmVjIGNvdW50X21hcCB+ZiBsIGN0ciA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgWyB4MSBdIC0+XG4gICAgbGV0IGYxID0gZiB4MSBpblxuICAgIFsgZjEgXVxuICB8IFsgeDE7IHgyIF0gLT5cbiAgICBsZXQgZjEgPSBmIHgxIGluXG4gICAgbGV0IGYyID0gZiB4MiBpblxuICAgIFsgZjE7IGYyIF1cbiAgfCBbIHgxOyB4MjsgeDMgXSAtPlxuICAgIGxldCBmMSA9IGYgeDEgaW5cbiAgICBsZXQgZjIgPSBmIHgyIGluXG4gICAgbGV0IGYzID0gZiB4MyBpblxuICAgIFsgZjE7IGYyOyBmMyBdXG4gIHwgWyB4MTsgeDI7IHgzOyB4NCBdIC0+XG4gICAgbGV0IGYxID0gZiB4MSBpblxuICAgIGxldCBmMiA9IGYgeDIgaW5cbiAgICBsZXQgZjMgPSBmIHgzIGluXG4gICAgbGV0IGY0ID0gZiB4NCBpblxuICAgIFsgZjE7IGYyOyBmMzsgZjQgXVxuICB8IHgxIDo6IHgyIDo6IHgzIDo6IHg0IDo6IHg1IDo6IHRsIC0+XG4gICAgbGV0IGYxID0gZiB4MSBpblxuICAgIGxldCBmMiA9IGYgeDIgaW5cbiAgICBsZXQgZjMgPSBmIHgzIGluXG4gICAgbGV0IGY0ID0gZiB4NCBpblxuICAgIGxldCBmNSA9IGYgeDUgaW5cbiAgICBmMVxuICAgIDo6IGYyXG4gICAgOjogZjNcbiAgICA6OiBmNFxuICAgIDo6IGY1XG4gICAgOjogKGlmIGN0ciA+IG1heF9ub25fdGFpbGNhbGwgdGhlbiB0YWlsX21hcCB+ZiB0bCBlbHNlIGNvdW50X21hcCB+ZiB0bCAoY3RyICsgMSkpXG47O1xuXG5sZXQgbWFwIGwgfmYgPSBjb3VudF9tYXAgfmYgbCAwXG5cbmxldCBmb2xkaW5nX21hcCB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIG1hcCB0IH5mOihmdW4geCAtPlxuICAgIGxldCBuZXdfYWNjLCB5ID0gZiAhYWNjIHggaW5cbiAgICBhY2MgOj0gbmV3X2FjYztcbiAgICB5KVxuOztcblxubGV0IGZvbGRfbWFwIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbGV0IHJlc3VsdCA9XG4gICAgbWFwIHQgfmY6KGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYywgeSA9IGYgIWFjYyB4IGluXG4gICAgICBhY2MgOj0gbmV3X2FjYztcbiAgICAgIHkpXG4gIGluXG4gICFhY2MsIHJlc3VsdFxuOztcblxubGV0ICggPj58ICkgbCBmID0gbWFwIGwgfmZcbmxldCBtYXAyX29rIGwxIGwyIH5mID0gcmV2IChyZXZfbWFwMl9vayBsMSBsMiB+ZilcbmxldCBtYXAyIGwxIGwyIH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjoobWFwMl9vayB+ZilcblxubGV0IG1hcDJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJtYXAyX2V4blwiIGwxIGwyO1xuICBtYXAyX29rIGwxIGwyIH5mXG47O1xuXG5sZXQgcmV2X21hcDNfb2sgbDEgbDIgbDMgfmYgPVxuICBsZXQgcmVjIGxvb3AgbDEgbDIgbDMgYWMgPVxuICAgIG1hdGNoIGwxLCBsMiwgbDMgd2l0aFxuICAgIHwgW10sIFtdLCBbXSAtPiBhY1xuICAgIHwgeDEgOjogbDEsIHgyIDo6IGwyLCB4MyA6OiBsMyAtPiBsb29wIGwxIGwyIGwzIChmIHgxIHgyIHgzIDo6IGFjKVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgaW5cbiAgbG9vcCBsMSBsMiBsMyBbXVxuOztcblxubGV0IHJldl9tYXAzIGwxIGwyIGwzIH5mID0gY2hlY2tfbGVuZ3RoMyBsMSBsMiBsMyB+ZjoocmV2X21hcDNfb2sgfmYpXG5cbmxldCByZXZfbWFwM19leG4gbDEgbDIgbDMgfmYgPVxuICBjaGVja19sZW5ndGgzX2V4biBcInJldl9tYXAzX2V4blwiIGwxIGwyIGwzO1xuICByZXZfbWFwM19vayBsMSBsMiBsMyB+ZlxuOztcblxubGV0IG1hcDNfb2sgbDEgbDIgbDMgfmYgPSByZXYgKHJldl9tYXAzX29rIGwxIGwyIGwzIH5mKVxubGV0IG1hcDMgbDEgbDIgbDMgfmYgPSBjaGVja19sZW5ndGgzIGwxIGwyIGwzIH5mOihtYXAzX29rIH5mKVxuXG5sZXQgbWFwM19leG4gbDEgbDIgbDMgfmYgPVxuICBjaGVja19sZW5ndGgzX2V4biBcIm1hcDNfZXhuXCIgbDEgbDIgbDM7XG4gIG1hcDNfb2sgbDEgbDIgbDMgfmZcbjs7XG5cbmxldCByZWMgcmV2X21hcF9hcHBlbmQgbDEgbDIgfmYgPVxuICBtYXRjaCBsMSB3aXRoXG4gIHwgW10gLT4gbDJcbiAgfCBoIDo6IHQgLT4gcmV2X21hcF9hcHBlbmQgfmYgdCAoZiBoIDo6IGwyKVxuOztcblxubGV0IHVuemlwIGxpc3QgPVxuICBsZXQgcmVjIGxvb3AgbGlzdCBsMSBsMiA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBsMSwgbDJcbiAgICB8ICh4LCB5KSA6OiB0bCAtPiBsb29wIHRsICh4IDo6IGwxKSAoeSA6OiBsMilcbiAgaW5cbiAgbG9vcCAocmV2IGxpc3QpIFtdIFtdXG47O1xuXG5sZXQgdW56aXAzIGxpc3QgPVxuICBsZXQgcmVjIGxvb3AgbGlzdCBsMSBsMiBsMyA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBsMSwgbDIsIGwzXG4gICAgfCAoeCwgeSwgeikgOjogdGwgLT4gbG9vcCB0bCAoeCA6OiBsMSkgKHkgOjogbDIpICh6IDo6IGwzKVxuICBpblxuICBsb29wIChyZXYgbGlzdCkgW10gW10gW11cbjs7XG5cbmxldCB6aXBfZXhuIGwxIGwyID1cbiAgdHJ5IG1hcDJfb2sgfmY6KGZ1biBhIGIgLT4gYSwgYikgbDEgbDIgd2l0aFxuICB8IF8gLT4gaW52YWxpZF9hcmdmIFwibGVuZ3RoIG1pc21hdGNoIGluIHppcF9leG46ICVkIDw+ICVkXCIgKGxlbmd0aCBsMSkgKGxlbmd0aCBsMikgKClcbjs7XG5cbmxldCB6aXAgbDEgbDIgPSBtYXAyIH5mOihmdW4gYSBiIC0+IGEsIGIpIGwxIGwyXG5cbigqKiBBZGRpdGlvbmFsIGxpc3Qgb3BlcmF0aW9ucyAqKVxuXG5sZXQgcmV2X21hcGkgbCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IGggOjogdCAtPiBsb29wIChpICsgMSkgKGYgaSBoIDo6IGFjYykgdFxuICBpblxuICBsb29wIDAgW10gbFxuOztcblxubGV0IG1hcGkgbCB+ZiA9IHJldiAocmV2X21hcGkgbCB+ZilcblxubGV0IGZvbGRpbmdfbWFwaSB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIG1hcGkgdCB+ZjooZnVuIGkgeCAtPlxuICAgIGxldCBuZXdfYWNjLCB5ID0gZiBpICFhY2MgeCBpblxuICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgIHkpXG47O1xuXG5sZXQgZm9sZF9tYXBpIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbGV0IHJlc3VsdCA9XG4gICAgbWFwaSB0IH5mOihmdW4gaSB4IC0+XG4gICAgICBsZXQgbmV3X2FjYywgeSA9IGYgaSAhYWNjIHggaW5cbiAgICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgICAgeSlcbiAgaW5cbiAgIWFjYywgcmVzdWx0XG47O1xuXG5sZXQgaXRlcmkgbCB+ZiA9XG4gIGlnbm9yZVxuICAgIChmb2xkIGwgfmluaXQ6MCB+ZjooZnVuIGkgeCAtPlxuICAgICAgIGYgaSB4O1xuICAgICAgIGkgKyAxKVxuICAgICA6IGludClcbjs7XG5cbmxldCBmb2xkaSB0IH5pbml0IH5mID1cbiAgc25kIChmb2xkIHQgfmluaXQ6KDAsIGluaXQpIH5mOihmdW4gKGksIGFjYykgdiAtPiBpICsgMSwgZiBpIGFjYyB2KSlcbjs7XG5cbmxldCBmaWx0ZXJpIGwgfmYgPVxuICByZXYgKGZvbGRpIGwgfmY6KGZ1biBwb3MgYWNjIHggLT4gaWYgZiBwb3MgeCB0aGVuIHggOjogYWNjIGVsc2UgYWNjKSB+aW5pdDpbXSlcbjs7XG5cbmxldCByZWR1Y2UgbCB+ZiA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCBoZCA6OiB0bCAtPiBTb21lIChmb2xkIH5pbml0OmhkIH5mIHRsKVxuOztcblxubGV0IHJlZHVjZV9leG4gbCB+ZiA9XG4gIG1hdGNoIHJlZHVjZSBsIH5mIHdpdGhcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnIFwiTGlzdC5yZWR1Y2VfZXhuXCJcbiAgfCBTb21lIHYgLT4gdlxuOztcblxubGV0IHJlZHVjZV9iYWxhbmNlZCBsIH5mID1cbiAgKCogQ2FsbCB0aGUgXCJzaXplXCIgb2YgYSB2YWx1ZSB0aGUgbnVtYmVyIG9mIGxpc3QgZWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gY29tYmluZWQgaW50b1xuICAgICBpdCB2aWEgY2FsbHMgdG8gW2ZdLiAgV2UgcHJvY2VlZCBieSB1c2luZyBbZl0gdG8gY29tYmluZSBlbGVtZW50cyBpbiB0aGUgYWNjdW11bGF0b3JcbiAgICAgb2YgdGhlIHNhbWUgc2l6ZSB1bnRpbCB3ZSBjYW4ndCBjb21iaW5lIGFueSBtb3JlLCB0aGVuIGdldHRpbmcgYSBuZXcgZWxlbWVudCBmcm9tIHRoZVxuICAgICBpbnB1dCBsaXN0IGFuZCByZXBlYXRpbmcuXG5cbiAgICAgV2l0aCB0aGlzIHN0cmF0ZWd5LCBpbiB0aGUgYWNjdW11bGF0b3I6XG4gICAgIC0gd2Ugb25seSBldmVyIGhhdmUgZWxlbWVudHMgb2Ygc2l6ZXMgYSBwb3dlciBvZiB0d29cbiAgICAgLSB3ZSBuZXZlciBoYXZlIG1vcmUgdGhhbiBvbmUgZWxlbWVudCBvZiBlYWNoIHNpemVcbiAgICAgLSB0aGUgc3VtIG9mIGFsbCB0aGUgZWxlbWVudCBzaXplcyBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGNvbnN1bWVkXG5cbiAgICAgVGhlc2UgY29uZGl0aW9ucyBlbmZvcmNlIHRoYXQgbGlzdCBvZiBlbGVtZW50cyBvZiBlYWNoIHNpemUgaXMgcHJlY2lzZWx5IHRoZSBiaW5hcnlcbiAgICAgZXhwYW5zaW9uIG9mIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29uc3VtZWQ6IGlmIHlvdSd2ZSBjb25zdW1lZCAxMyA9IDBiMTEwMVxuICAgICBlbGVtZW50cywgeW91IGhhdmUgb25lIGVsZW1lbnQgb2Ygc2l6ZSA4LCBvbmUgb2Ygc2l6ZSA0LCBhbmQgb25lIG9mIHNpemUgMS4gIEhlbmNlXG4gICAgIHdoZW4gYSBuZXcgZWxlbWVudCBjb21lcyBhbG9uZywgdGhlIG51bWJlciBvZiBjb21iaW5pbmdzIHlvdSBuZWVkIHRvIGRvIGlzIHRoZSBudW1iZXJcbiAgICAgb2YgdHJhaWxpbmcgMXMgaW4gdGhlIGJpbmFyeSBleHBhbnNpb24gb2YgW251bV0sIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdGhhdCBoYXZlXG4gICAgIGFscmVhZHkgZ29uZSBpbnRvIHRoZSBhY2N1bXVsYXRvci4gIFRoZSBhY2N1bXVsYXRvciBpcyBpbiBhc2NlbmRpbmcgb3JkZXIgb2Ygc2l6ZSwgc29cbiAgICAgdGhlIG5leHQgZWxlbWVudCB0byBjb21iaW5lIHdpdGggaXMgYWx3YXlzIHRoZSBoZWFkIG9mIHRoZSBsaXN0LiAqKVxuICBsZXQgcmVjIHN0ZXBfYWNjdW0gbnVtIGFjYyB4ID1cbiAgICBpZiBudW0gbGFuZCAxID0gMFxuICAgIHRoZW4geCA6OiBhY2NcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFjYyB3aXRoXG4gICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgKCogTmV3IGVsZW1lbnRzIGZyb20gbGF0ZXIgaW4gdGhlIGlucHV0IGxpc3QgZ28gb24gdGhlIGZyb250IG9mIHRoZSBhY2N1bXVsYXRvciwgc29cbiAgICAgICAgIHRoZSBhY2N1bXVsYXRvciBpcyBpbiByZXZlcnNlIG9yZGVyIHdydCB0aGUgb3JpZ2luYWwgbGlzdCBvcmRlciwgaGVuY2UgW2YgeSB4XVxuICAgICAgICAgaW5zdGVhZCBvZiBbZiB4IHldLiAqKVxuICAgICAgfCB5IDo6IHlzIC0+IHN0ZXBfYWNjdW0gKG51bSBhc3IgMSkgeXMgKGYgeSB4KSlcbiAgaW5cbiAgKCogRXhwZXJpbWVudGFsbHksIGlubGluaW5nIFtmb2xkaV0gYW5kIHVucm9sbGluZyB0aGlzIGxvb3AgYSBmZXcgdGltZXMgY2FuIHJlZHVjZVxuICAgICBydW50aW1lIGRvd24gdG8gYSB0aGlyZCBhbmQgYWxsb2NhdGlvbiB0byAxLzE2dGggb3Igc28gaW4gdGhlIG1pY3JvYmVuY2htYXJrcyBiZWxvdy5cbiAgICAgSG93ZXZlciwgaW4gbW9zdCB1c2UgY2FzZXMgW2ZdIGlzIGxpa2VseSB0byBiZSBleHBlbnNpdmUgKG90aGVyd2lzZSB3aHkgZG8geW91IGNhcmVcbiAgICAgYWJvdXQgdGhlIG9yZGVyIG9mIHJlZHVjdGlvbj8pIHNvIHRoZSBvdmVyaGVhZCBvZiB0aGlzIGZ1bmN0aW9uIGl0c2VsZiBkb2Vzbid0IHJlYWxseVxuICAgICBtYXR0ZXIuIElmIHlvdSBjb21lIHVwIHdpdGggYSB1c2UtY2FzZSB3aGVyZSBpdCBkb2VzLCB0aGVuIHRoYXQncyBzb21ldGhpbmcgeW91IG1pZ2h0XG4gICAgIHdhbnQgdG8gdHJ5OiBzZWUgaGcgbG9nIC1wciA0OWVmMDY1ZjQyOWQuICopXG4gIG1hdGNoIGZvbGRpIGwgfmluaXQ6W10gfmY6c3RlcF9hY2N1bSB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogeHMgLT4gU29tZSAoZm9sZCB4cyB+aW5pdDp4IH5mOihmdW4geCB5IC0+IGYgeSB4KSlcbjs7XG5cbmxldCByZWR1Y2VfYmFsYW5jZWRfZXhuIGwgfmYgPVxuICBtYXRjaCByZWR1Y2VfYmFsYW5jZWQgbCB+ZiB3aXRoXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QucmVkdWNlX2JhbGFuY2VkX2V4blwiXG4gIHwgU29tZSB2IC0+IHZcbjs7XG5cbmxldCBncm91cGkgbCB+YnJlYWsgPVxuICBsZXQgZ3JvdXBzID1cbiAgICBmb2xkaSBsIH5pbml0OltdIH5mOihmdW4gaSBhY2MgeCAtPlxuICAgICAgbWF0Y2ggYWNjIHdpdGhcbiAgICAgIHwgW10gLT4gWyBbIHggXSBdXG4gICAgICB8IGN1cnJlbnRfZ3JvdXAgOjogdGwgLT5cbiAgICAgICAgaWYgYnJlYWsgaSAoaGRfZXhuIGN1cnJlbnRfZ3JvdXApIHhcbiAgICAgICAgdGhlbiBbIHggXSA6OiBjdXJyZW50X2dyb3VwIDo6IHRsICgqIHN0YXJ0IG5ldyBncm91cCAqKVxuICAgICAgICBlbHNlICh4IDo6IGN1cnJlbnRfZ3JvdXApIDo6IHRsKVxuICAgICgqIGV4dGVuZCBjdXJyZW50IGdyb3VwICopXG4gIGluXG4gIG1hdGNoIGdyb3VwcyB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCBsIC0+IHJldl9tYXAgbCB+ZjpyZXZcbjs7XG5cbmxldCBncm91cCBsIH5icmVhayA9IGdyb3VwaSBsIH5icmVhazooZnVuIF8geCB5IC0+IGJyZWFrIHggeSlcblxubGV0IHNvcnRfYW5kX2dyb3VwIGwgfmNvbXBhcmUgPVxuICBsIHw+IHN0YWJsZV9zb3J0IH5jb21wYXJlIHw+IGdyb3VwIH5icmVhazooZnVuIHggeSAtPiBjb21wYXJlIHggeSA8PiAwKVxuOztcblxubGV0IGNvbmNhdF9tYXAgbCB+ZiA9XG4gIGxldCByZWMgYXV4IGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXYgYWNjXG4gICAgfCBoZCA6OiB0bCAtPiBhdXggKHJldl9hcHBlbmQgKGYgaGQpIGFjYykgdGxcbiAgaW5cbiAgYXV4IFtdIGxcbjs7XG5cbmxldCBjb25jYXRfbWFwaSBsIH5mID1cbiAgbGV0IHJlYyBhdXggY29udCBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV2IGFjY1xuICAgIHwgaGQgOjogdGwgLT4gYXV4IChjb250ICsgMSkgKHJldl9hcHBlbmQgKGYgY29udCBoZCkgYWNjKSB0bFxuICBpblxuICBhdXggMCBbXSBsXG47O1xuXG5sZXQgbWVyZ2UgbDEgbDIgfmNvbXBhcmUgPVxuICBsZXQgcmVjIGxvb3AgYWNjIGwxIGwyID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgYWNjIGwyXG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBhY2MgbDFcbiAgICB8IGgxIDo6IHQxLCBoMiA6OiB0MiAtPlxuICAgICAgaWYgY29tcGFyZSBoMSBoMiA8PSAwIHRoZW4gbG9vcCAoaDEgOjogYWNjKSB0MSBsMiBlbHNlIGxvb3AgKGgyIDo6IGFjYykgbDEgdDJcbiAgaW5cbiAgbG9vcCBbXSBsMSBsMlxuOztcblxubW9kdWxlIENhcnRlc2lhbl9wcm9kdWN0ID0gc3RydWN0XG4gICgqIFdlIGFyZSBleHBsaWNpdCBhYm91dCB3aGF0IHdlIGV4cG9ydCBmcm9tIGZ1bmN0b3JzIHNvIHRoYXQgd2UgZG9uJ3QgYWNjaWRlbnRhbGx5XG4gICAgIHJlYmluZCBtb3JlIGVmZmljaWVudCBsaXN0LXNwZWNpZmljIGZ1bmN0aW9ucy4gKilcblxuICBsZXQgYmluZCA9IGNvbmNhdF9tYXBcbiAgbGV0IG1hcCA9IG1hcFxuICBsZXQgbWFwMiBhIGIgfmYgPSBjb25jYXRfbWFwIGEgfmY6KGZ1biB4IC0+IG1hcCBiIH5mOihmdW4geSAtPiBmIHggeSkpXG4gIGxldCByZXR1cm4geCA9IFsgeCBdXG4gIGxldCAoID4+fCApID0gKCA+PnwgKVxuICBsZXQgKCA+Pj0gKSB0IGYgPSBiaW5kIHQgfmZcblxuICBvcGVuIHN0cnVjdFxuICAgIG1vZHVsZSBBcHBsaWNhdGl2ZSA9IEFwcGxpY2F0aXZlLk1ha2VfdXNpbmdfbWFwMiAoc3RydWN0XG4gICAgICAgIHR5cGUgJ2EgdCA9ICdhIGxpc3RcblxuICAgICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgICAgICBsZXQgbWFwMiA9IG1hcDJcbiAgICAgIGVuZClcblxuICAgIG1vZHVsZSBNb25hZCA9IE1vbmFkLk1ha2UgKHN0cnVjdFxuICAgICAgICB0eXBlICdhIHQgPSAnYSBsaXN0XG5cbiAgICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICAgICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgICBlbmQpXG4gIGVuZFxuXG4gIGxldCBhbGwgPSBNb25hZC5hbGxcbiAgbGV0IGFsbF91bml0ID0gTW9uYWQuYWxsX3VuaXRcbiAgbGV0IGlnbm9yZV9tID0gTW9uYWQuaWdub3JlX21cbiAgbGV0IGpvaW4gPSBNb25hZC5qb2luXG5cbiAgbW9kdWxlIE1vbmFkX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gICAgbGV0ICggPj49ICkgPSAoID4+PSApXG4gIGVuZFxuXG4gIGxldCBhcHBseSA9IEFwcGxpY2F0aXZlLmFwcGx5XG4gIGxldCBib3RoID0gQXBwbGljYXRpdmUuYm90aFxuICBsZXQgbWFwMyA9IEFwcGxpY2F0aXZlLm1hcDNcbiAgbGV0ICggPCo+ICkgPSBBcHBsaWNhdGl2ZS4oIDwqPiApXG4gIGxldCAoICo+ICkgPSBBcHBsaWNhdGl2ZS4oICo+IClcbiAgbGV0ICggPCogKSA9IEFwcGxpY2F0aXZlLiggPCogKVxuXG4gIG1vZHVsZSBBcHBsaWNhdGl2ZV9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICAgIGxldCAoIDwqPiApID0gQXBwbGljYXRpdmUuKCA8Kj4gKVxuICAgIGxldCAoICo+ICkgPSBBcHBsaWNhdGl2ZS4oICo+IClcbiAgICBsZXQgKCA8KiApID0gQXBwbGljYXRpdmUuKCA8KiApXG4gIGVuZFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICAgIGxldCAoID4+PSApID0gKCA+Pj0gKVxuXG4gICAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgIGxldCBiaW5kID0gYmluZFxuICAgICAgbGV0IG1hcCA9IG1hcFxuICAgICAgbGV0IGJvdGggPSBib3RoXG5cbiAgICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IHN0cnVjdCBlbmRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuaW5jbHVkZSAoQ2FydGVzaWFuX3Byb2R1Y3QgOiBNb25hZC5TIHdpdGggdHlwZSAnYSB0IDo9ICdhIHQpXG5cbigqKiByZXR1cm5zIGZpbmFsIGVsZW1lbnQgb2YgbGlzdCAqKVxubGV0IHJlYyBsYXN0X2V4biBsaXN0ID1cbiAgbWF0Y2ggbGlzdCB3aXRoXG4gIHwgWyB4IF0gLT4geFxuICB8IF8gOjogdGwgLT4gbGFzdF9leG4gdGxcbiAgfCBbXSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QubGFzdFwiXG47O1xuXG4oKiogb3B0aW9uYWxseSByZXR1cm5zIGZpbmFsIGVsZW1lbnQgb2YgbGlzdCAqKVxubGV0IHJlYyBsYXN0IGxpc3QgPVxuICBtYXRjaCBsaXN0IHdpdGhcbiAgfCBbIHggXSAtPiBTb21lIHhcbiAgfCBfIDo6IHRsIC0+IGxhc3QgdGxcbiAgfCBbXSAtPiBOb25lXG47O1xuXG5sZXQgcmVjIGlzX3ByZWZpeCBsaXN0IH5wcmVmaXggfmVxdWFsID1cbiAgbWF0Y2ggcHJlZml4IHdpdGhcbiAgfCBbXSAtPiB0cnVlXG4gIHwgaGQgOjogdGwgLT5cbiAgICAobWF0Y2ggbGlzdCB3aXRoXG4gICAgIHwgW10gLT4gZmFsc2VcbiAgICAgfCBoZCcgOjogdGwnIC0+IGVxdWFsIGhkIGhkJyAmJiBpc19wcmVmaXggdGwnIH5wcmVmaXg6dGwgfmVxdWFsKVxuOztcblxubGV0IGZpbmRfY29uc2VjdXRpdmVfZHVwbGljYXRlIHQgfmVxdWFsID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IGExIDo6IHQgLT5cbiAgICBsZXQgcmVjIGxvb3AgYTEgdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgW10gLT4gTm9uZVxuICAgICAgfCBhMiA6OiB0IC0+IGlmIGVxdWFsIGExIGEyIHRoZW4gU29tZSAoYTEsIGEyKSBlbHNlIGxvb3AgYTIgdFxuICAgIGluXG4gICAgbG9vcCBhMSB0XG47O1xuXG4oKiByZXR1cm5zIGxpc3Qgd2l0aG91dCBhZGphY2VudCBkdXBsaWNhdGVzICopXG5sZXQgcmVtb3ZlX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZXMgPyh3aGljaF90b19rZWVwID0gYExhc3QpIGxpc3QgfmVxdWFsID1cbiAgbGV0IHJlYyBsb29wIHRvX2tlZXAgYWNjdW0gPSBmdW5jdGlvblxuICAgIHwgW10gLT4gdG9fa2VlcCA6OiBhY2N1bVxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgIGlmIGVxdWFsIGhkIHRvX2tlZXBcbiAgICAgIHRoZW4gKFxuICAgICAgICBsZXQgdG9fa2VlcCA9XG4gICAgICAgICAgbWF0Y2ggd2hpY2hfdG9fa2VlcCB3aXRoXG4gICAgICAgICAgfCBgRmlyc3QgLT4gdG9fa2VlcFxuICAgICAgICAgIHwgYExhc3QgLT4gaGRcbiAgICAgICAgaW5cbiAgICAgICAgbG9vcCB0b19rZWVwIGFjY3VtIHRsKVxuICAgICAgZWxzZSBsb29wIGhkICh0b19rZWVwIDo6IGFjY3VtKSB0bFxuICBpblxuICBtYXRjaCBsaXN0IHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IGhkIDo6IHRsIC0+IHJldiAobG9vcCBoZCBbXSB0bClcbjs7XG5cbigqKiByZXR1cm5zIHNvcnRlZCB2ZXJzaW9uIG9mIGxpc3Qgd2l0aCBkdXBsaWNhdGVzIHJlbW92ZWQgKilcbmxldCBkZWR1cF9hbmRfc29ydCBsaXN0IH5jb21wYXJlID1cbiAgbWF0Y2ggbGlzdCB3aXRoXG4gIHwgW10gfCBbIF8gXSAtPiBsaXN0ICgqIHBlcmZvcm1hbmNlIGhhY2sgKilcbiAgfCBfIC0+XG4gICAgbGV0IGVxdWFsIHggeCcgPSBjb21wYXJlIHggeCcgPSAwIGluXG4gICAgbGV0IHNvcnRlZCA9IHNvcnQgfmNvbXBhcmUgbGlzdCBpblxuICAgIHJlbW92ZV9jb25zZWN1dGl2ZV9kdXBsaWNhdGVzIH5lcXVhbCBzb3J0ZWRcbjs7XG5cbmxldCBmaW5kX2FfZHVwIGwgfmNvbXBhcmUgPVxuICBsZXQgc29ydGVkID0gc29ydCBsIH5jb21wYXJlIGluXG4gIGxldCByZWMgbG9vcCBsID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIHwgWyBfIF0gLT4gTm9uZVxuICAgIHwgaGQxIDo6IChoZDIgOjogXyBhcyB0bCkgLT4gaWYgY29tcGFyZSBoZDEgaGQyID0gMCB0aGVuIFNvbWUgaGQxIGVsc2UgbG9vcCB0bFxuICBpblxuICBsb29wIHNvcnRlZFxuOztcblxubGV0IGNvbnRhaW5zX2R1cCBsc3QgfmNvbXBhcmUgPVxuICBtYXRjaCBmaW5kX2FfZHVwIGxzdCB+Y29tcGFyZSB3aXRoXG4gIHwgU29tZSBfIC0+IHRydWVcbiAgfCBOb25lIC0+IGZhbHNlXG47O1xuXG5sZXQgZmluZF9hbGxfZHVwcyBsIH5jb21wYXJlID1cbiAgKCogV2UgYWRkIHRoaXMgcmV2ZXJzYWwsIHNvIHdlIGNhbiBza2lwIGEgW3Jldl0gYXQgdGhlIGVuZC4gV2UgY291bGQgc2tpcFxuICAgICBbcmV2XSBhbnl3YXkgc2luY2Ugd2UgZG9uIG5vdCBnaXZlIGFueSBvcmRlcmluZyBndWFyYW50ZWVzLCBidXQgaXQgaXNcbiAgICAgbmljZSB0byBnZXQgcmVzdWx0cyBpbiBuYXR1cmFsIG9yZGVyLiAqKVxuICBsZXQgY29tcGFyZSBhIGIgPSAtMSAqIGNvbXBhcmUgYSBiIGluXG4gIGxldCBzb3J0ZWQgPSBzb3J0IH5jb21wYXJlIGwgaW5cbiAgKCogV2FsayB0aGUgbGlzdCBhbmQgcmVjb3JkIHRoZSBmaXJzdCBvZiBlYWNoIGNvbnNlY3V0aXZlIHJ1biBvZiBpZGVudGljYWwgZWxlbWVudHMgKilcbiAgbGV0IHJlYyBsb29wIHNvcnRlZCBwcmV2IH5hbHJlYWR5X3JlY29yZGVkIGFjYyA9XG4gICAgbWF0Y2ggc29ydGVkIHdpdGhcbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgIGlmIGNvbXBhcmUgcHJldiBoZCA8PiAwXG4gICAgICB0aGVuIGxvb3AgdGwgaGQgfmFscmVhZHlfcmVjb3JkZWQ6ZmFsc2UgYWNjXG4gICAgICBlbHNlIGlmIGFscmVhZHlfcmVjb3JkZWRcbiAgICAgIHRoZW4gbG9vcCB0bCBoZCB+YWxyZWFkeV9yZWNvcmRlZDp0cnVlIGFjY1xuICAgICAgZWxzZSBsb29wIHRsIGhkIH5hbHJlYWR5X3JlY29yZGVkOnRydWUgKGhkIDo6IGFjYylcbiAgaW5cbiAgbWF0Y2ggc29ydGVkIHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IGhkIDo6IHRsIC0+IGxvb3AgdGwgaGQgfmFscmVhZHlfcmVjb3JkZWQ6ZmFsc2UgW11cbjs7XG5cbmxldCByZWMgYWxsX2VxdWFsX3RvIHQgdiB+ZXF1YWwgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiB0cnVlXG4gIHwgeCA6OiB4cyAtPiBlcXVhbCB4IHYgJiYgYWxsX2VxdWFsX3RvIHhzIHYgfmVxdWFsXG47O1xuXG5sZXQgYWxsX2VxdWFsIHQgfmVxdWFsID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogeHMgLT4gaWYgYWxsX2VxdWFsX3RvIHhzIHggfmVxdWFsIHRoZW4gU29tZSB4IGVsc2UgTm9uZVxuOztcblxubGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxubGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbmxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5cbmxldCBjb3VudGkgdCB+ZiA9XG4gIGZvbGRpIHQgfmluaXQ6MCB+ZjooZnVuIGlkeCBjb3VudCBhIC0+IGlmIGYgaWR4IGEgdGhlbiBjb3VudCArIDEgZWxzZSBjb3VudClcbjs7XG5cbmxldCBpbml0IG4gfmYgPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnZiBcIkxpc3QuaW5pdCAlZFwiIG4gKCk7XG4gIGxldCByZWMgbG9vcCBpIGFjY3VtID1cbiAgICBhc3NlcnQgKGkgPj0gMCk7XG4gICAgaWYgaSA9IDAgdGhlbiBhY2N1bSBlbHNlIGxvb3AgKGkgLSAxKSAoZiAoaSAtIDEpIDo6IGFjY3VtKVxuICBpblxuICBsb29wIG4gW11cbjs7XG5cbmxldCByZXZfZmlsdGVyX21hcCBsIH5mID1cbiAgbGV0IHJlYyBsb29wIGwgYWNjdW0gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gYWNjdW1cbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAobWF0Y2ggZiBoZCB3aXRoXG4gICAgICAgfCBTb21lIHggLT4gbG9vcCB0bCAoeCA6OiBhY2N1bSlcbiAgICAgICB8IE5vbmUgLT4gbG9vcCB0bCBhY2N1bSlcbiAgaW5cbiAgbG9vcCBsIFtdXG47O1xuXG5sZXQgZmlsdGVyX21hcCBsIH5mID0gcmV2IChyZXZfZmlsdGVyX21hcCBsIH5mKVxuXG5sZXQgcmV2X2ZpbHRlcl9tYXBpIGwgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSBsIGFjY3VtID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGFjY3VtXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgKG1hdGNoIGYgaSBoZCB3aXRoXG4gICAgICAgfCBTb21lIHggLT4gbG9vcCAoaSArIDEpIHRsICh4IDo6IGFjY3VtKVxuICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSkgdGwgYWNjdW0pXG4gIGluXG4gIGxvb3AgMCBsIFtdXG47O1xuXG5sZXQgZmlsdGVyX21hcGkgbCB+ZiA9IHJldiAocmV2X2ZpbHRlcl9tYXBpIGwgfmYpXG5sZXQgZmlsdGVyX29wdCBsID0gZmlsdGVyX21hcCBsIH5mOkZuLmlkXG5cbmxldCBwYXJ0aXRpb24zX21hcCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHQgZnN0IHNuZCB0cmQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gcmV2IGZzdCwgcmV2IHNuZCwgcmV2IHRyZFxuICAgIHwgeCA6OiB0IC0+XG4gICAgICAobWF0Y2ggZiB4IHdpdGhcbiAgICAgICB8IGBGc3QgeSAtPiBsb29wIHQgKHkgOjogZnN0KSBzbmQgdHJkXG4gICAgICAgfCBgU25kIHkgLT4gbG9vcCB0IGZzdCAoeSA6OiBzbmQpIHRyZFxuICAgICAgIHwgYFRyZCB5IC0+IGxvb3AgdCBmc3Qgc25kICh5IDo6IHRyZCkpXG4gIGluXG4gIGxvb3AgdCBbXSBbXSBbXVxuOztcblxubGV0IHBhcnRpdGlvbl90ZiB0IH5mID1cbiAgbGV0IGYgeCA6IF8gRWl0aGVyLnQgPSBpZiBmIHggdGhlbiBGaXJzdCB4IGVsc2UgU2Vjb25kIHggaW5cbiAgcGFydGl0aW9uX21hcCB0IH5mXG47O1xuXG5sZXQgcGFydGl0aW9uX3Jlc3VsdCB0ID0gcGFydGl0aW9uX21hcCB0IH5mOlJlc3VsdC50b19laXRoZXJcblxubW9kdWxlIEFzc29jID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdCA9ICgnYSAqICdiKSBsaXN0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IHRfb2Zfc2V4cCA6XG4gICAgJ2EgJ2IuXG4gICAgKFNleHBsaWIwLlNleHAudCAtPiAnYSlcbiAgICAtPiAoU2V4cGxpYjAuU2V4cC50IC0+ICdiKVxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgIC0+ICgnYSwgJ2IpIHRcbiAgICA9XG4gICAgbGV0IGVycm9yX3NvdXJjZV9fMDIyXyA9IFwibGlzdC5tbC5Bc3NvYy50XCIgaW5cbiAgICBmdW4gX29mX2FfXzAxNF8gX29mX2JfXzAxNV8geF9fMDIzXyAtPlxuICAgICAgbGlzdF9vZl9zZXhwXG4gICAgICAgIChmdW5jdGlvblxuICAgICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFsgYXJnMF9fMDE3XzsgYXJnMV9fMDE4XyBdIC0+XG4gICAgICAgICAgICBsZXQgcmVzMF9fMDE5XyA9IF9vZl9hX18wMTRfIGFyZzBfXzAxN19cbiAgICAgICAgICAgIGFuZCByZXMxX18wMjBfID0gX29mX2JfXzAxNV8gYXJnMV9fMDE4XyBpblxuICAgICAgICAgICAgcmVzMF9fMDE5XywgcmVzMV9fMDIwX1xuICAgICAgICAgIHwgc2V4cF9fMDIxXyAtPlxuICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnR1cGxlX29mX3NpemVfbl9leHBlY3RlZFxuICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAyMl9cbiAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICBzZXhwX18wMjFfKVxuICAgICAgICB4X18wMjNfXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6XG4gICAgJ2EgJ2IuXG4gICAgKCdhIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2IgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICA9XG4gICAgZnVuIF9vZl9hX18wMjRfIF9vZl9iX18wMjVfIHhfXzAzMF8gLT5cbiAgICAgIHNleHBfb2ZfbGlzdFxuICAgICAgICAoZnVuIChhcmcwX18wMjZfLCBhcmcxX18wMjdfKSAtPlxuICAgICAgICAgICBsZXQgcmVzMF9fMDI4XyA9IF9vZl9hX18wMjRfIGFyZzBfXzAyNl9cbiAgICAgICAgICAgYW5kIHJlczFfXzAyOV8gPSBfb2ZfYl9fMDI1XyBhcmcxX18wMjdfIGluXG4gICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIHJlczBfXzAyOF87IHJlczFfXzAyOV8gXSlcbiAgICAgICAgeF9fMDMwX1xuICA7O1xuXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOlxuICAgICAgICAgJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgICAtPiAnYiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgIC0+ICgnYSwgJ2IpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gICAgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIF8nYl9zZXhwX2dyYW1tYXIgLT5cbiAgICAgIGxpc3Rfc2V4cF9ncmFtbWFyXG4gICAgICAgIHsgdW50eXBlZCA9XG4gICAgICAgICAgICBMaXN0IChDb25zIChfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWQsIENvbnMgKF8nYl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpKSlcbiAgICAgICAgfVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHBhaXJfb2ZfZ3JvdXAgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCAoaywgXykgOjogXyBhcyBsaXN0IC0+IGssIG1hcCBsaXN0IH5mOnNuZFxuICA7O1xuXG4gIGxldCBncm91cCBhbGlzdCB+ZXF1YWwgPVxuICAgIGdyb3VwIGFsaXN0IH5icmVhazooZnVuICh4LCBfKSAoeSwgXykgLT4gbm90IChlcXVhbCB4IHkpKSB8PiBtYXAgfmY6cGFpcl9vZl9ncm91cFxuICA7O1xuXG4gIGxldCBzb3J0X2FuZF9ncm91cCBhbGlzdCB+Y29tcGFyZSA9XG4gICAgc29ydF9hbmRfZ3JvdXAgYWxpc3QgfmNvbXBhcmU6KGZ1biAoeCwgXykgKHksIF8pIC0+IGNvbXBhcmUgeCB5KVxuICAgIHw+IG1hcCB+ZjpwYWlyX29mX2dyb3VwXG4gIDs7XG5cbiAgbGV0IGZpbmQgdCB+ZXF1YWwga2V5ID1cbiAgICBtYXRjaCBmaW5kIHQgfmY6KGZ1biAoa2V5JywgXykgLT4gZXF1YWwga2V5IGtleScpIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSB4IC0+IFNvbWUgKHNuZCB4KVxuICA7O1xuXG4gIGxldCBmaW5kX2V4biA9XG4gICAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiTGlzdC5Bc3NvYy5maW5kX2V4bjogbm90IGZvdW5kXCIpIGluXG4gICAgbGV0IGZpbmRfZXhuIHQgfmVxdWFsIGtleSA9XG4gICAgICBtYXRjaCBmaW5kIHQga2V5IH5lcXVhbCB3aXRoXG4gICAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgICB8IFNvbWUgdmFsdWUgLT4gdmFsdWVcbiAgICBpblxuICAgICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgICBmaW5kX2V4blxuICA7O1xuXG4gIGxldCBtZW0gdCB+ZXF1YWwga2V5ID1cbiAgICBtYXRjaCBmaW5kIHQgfmVxdWFsIGtleSB3aXRoXG4gICAgfCBOb25lIC0+IGZhbHNlXG4gICAgfCBTb21lIF8gLT4gdHJ1ZVxuICA7O1xuXG4gIGxldCByZW1vdmUgdCB+ZXF1YWwga2V5ID0gZmlsdGVyIHQgfmY6KGZ1biAoa2V5JywgXykgLT4gbm90IChlcXVhbCBrZXkga2V5JykpXG5cbiAgbGV0IGFkZCB0IH5lcXVhbCBrZXkgdmFsdWUgPVxuICAgICgqIHRoZSByZW1vdmUgZG9lc24ndCBjaGFuZ2UgdGhlIG1hcCBzZW1hbnRpY3MsIGJ1dCBrZWVwcyB0aGUgbGlzdCBzbWFsbCAqKVxuICAgIChrZXksIHZhbHVlKSA6OiByZW1vdmUgdCB+ZXF1YWwga2V5XG4gIDs7XG5cbiAgbGV0IGludmVyc2UgdCA9IG1hcCB0IH5mOihmdW4gKHgsIHkpIC0+IHksIHgpXG4gIGxldCBtYXAgdCB+ZiA9IG1hcCB0IH5mOihmdW4gKGtleSwgdmFsdWUpIC0+IGtleSwgZiB2YWx1ZSlcbmVuZFxuXG5sZXQgc3ViIGwgfnBvcyB+bGVuID1cbiAgKCogV2UgdXNlIFtwb3MgPiBsZW5ndGggbCAtIGxlbl0gcmF0aGVyIHRoYW4gW3BvcyArIGxlbiA+IGxlbmd0aCBsXSB0byBhdm9pZCB0aGVcbiAgICAgcG9zc2liaWxpdHkgb2Ygb3ZlcmZsb3cuICopXG4gIGlmIHBvcyA8IDAgfHwgbGVuIDwgMCB8fCBwb3MgPiBsZW5ndGggbCAtIGxlbiB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5zdWJcIjtcbiAgcmV2XG4gICAgKGZvbGRpIGwgfmluaXQ6W10gfmY6KGZ1biBpIGFjYyBlbCAtPlxuICAgICAgIGlmIGkgPj0gcG9zICYmIGkgPCBwb3MgKyBsZW4gdGhlbiBlbCA6OiBhY2MgZWxzZSBhY2MpKVxuOztcblxubGV0IHNwbGl0X24gdF9vcmlnIG4gPVxuICBpZiBuIDw9IDBcbiAgdGhlbiBbXSwgdF9vcmlnXG4gIGVsc2UgKFxuICAgIGxldCByZWMgbG9vcCBuIHQgYWNjdW0gPVxuICAgICAgaWYgbiA9IDBcbiAgICAgIHRoZW4gcmV2IGFjY3VtLCB0XG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgW10gLT4gdF9vcmlnLCBbXSAoKiBpbiB0aGlzIGNhc2UsIHRfb3JpZyA9IHJldiBhY2N1bSAqKVxuICAgICAgICB8IGhkIDo6IHRsIC0+IGxvb3AgKG4gLSAxKSB0bCAoaGQgOjogYWNjdW0pKVxuICAgIGluXG4gICAgbG9vcCBuIHRfb3JpZyBbXSlcbjs7XG5cbigqIGNvcGllZCBmcm9tIFtzcGxpdF9uXSB0byBhdm9pZCBhbGxvY2F0aW5nIGEgdHVwbGUgKilcbmxldCB0YWtlIHRfb3JpZyBuID1cbiAgaWYgbiA8PSAwXG4gIHRoZW4gW11cbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBsb29wIG4gdCBhY2N1bSA9XG4gICAgICBpZiBuID0gMFxuICAgICAgdGhlbiByZXYgYWNjdW1cbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBbXSAtPiB0X29yaWdcbiAgICAgICAgfCBoZCA6OiB0bCAtPiBsb29wIChuIC0gMSkgdGwgKGhkIDo6IGFjY3VtKSlcbiAgICBpblxuICAgIGxvb3AgbiB0X29yaWcgW10pXG47O1xuXG5sZXQgcmVjIGRyb3AgdCBuID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgXyA6OiB0bCB3aGVuIG4gPiAwIC0+IGRyb3AgdGwgKG4gLSAxKVxuICB8IHQgLT4gdFxuOztcblxubGV0IGNodW5rc19vZiBsIH5sZW5ndGggPVxuICBpZiBsZW5ndGggPD0gMCB0aGVuIGludmFsaWRfYXJnZiBcIkxpc3QuY2h1bmtzX29mOiBFeHBlY3RlZCBsZW5ndGggPiAwLCBnb3QgJWRcIiBsZW5ndGggKCk7XG4gIGxldCByZWMgYXV4IG9mX2xlbmd0aCBhY2MgbCA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiByZXYgYWNjXG4gICAgfCBfIDo6IF8gLT5cbiAgICAgIGxldCBzdWJsaXN0LCBsID0gc3BsaXRfbiBsIGxlbmd0aCBpblxuICAgICAgYXV4IG9mX2xlbmd0aCAoc3VibGlzdCA6OiBhY2MpIGxcbiAgaW5cbiAgYXV4IGxlbmd0aCBbXSBsXG47O1xuXG5sZXQgc3BsaXRfd2hpbGUgeHMgfmYgPVxuICBsZXQgcmVjIGxvb3AgYWNjID0gZnVuY3Rpb25cbiAgICB8IGhkIDo6IHRsIHdoZW4gZiBoZCAtPiBsb29wIChoZCA6OiBhY2MpIHRsXG4gICAgfCB0IC0+IHJldiBhY2MsIHRcbiAgaW5cbiAgbG9vcCBbXSB4c1xuOztcblxuKCogY29waWVkIGZyb20gW3NwbGl0X3doaWxlXSB0byBhdm9pZCBhbGxvY2F0aW5nIGEgdHVwbGUgKilcbmxldCB0YWtlX3doaWxlIHhzIH5mID1cbiAgbGV0IHJlYyBsb29wIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBoZCA6OiB0bCB3aGVuIGYgaGQgLT4gbG9vcCAoaGQgOjogYWNjKSB0bFxuICAgIHwgXyAtPiByZXYgYWNjXG4gIGluXG4gIGxvb3AgW10geHNcbjs7XG5cbmxldCByZWMgZHJvcF93aGlsZSB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgaGQgOjogdGwgd2hlbiBmIGhkIC0+IGRyb3Bfd2hpbGUgdGwgfmZcbiAgfCB0IC0+IHRcbjs7XG5cbmxldCBkcm9wX2xhc3QgdCA9XG4gIG1hdGNoIHJldiB0IHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgXyA6OiBsc3QgLT4gU29tZSAocmV2IGxzdClcbjs7XG5cbmxldCBkcm9wX2xhc3RfZXhuIHQgPVxuICBtYXRjaCBkcm9wX2xhc3QgdCB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcIkxpc3QuZHJvcF9sYXN0X2V4bjogZW1wdHkgbGlzdFwiXG4gIHwgU29tZSBsc3QgLT4gbHN0XG47O1xuXG5sZXQgY2FydGVzaWFuX3Byb2R1Y3QgbGlzdDEgbGlzdDIgPVxuICBpZiBpc19lbXB0eSBsaXN0MlxuICB0aGVuIFtdXG4gIGVsc2UgKFxuICAgIGxldCByZWMgbG9vcCBsMSBsMiBhY2N1bSA9XG4gICAgICBtYXRjaCBsMSB3aXRoXG4gICAgICB8IFtdIC0+IGFjY3VtXG4gICAgICB8IGhkIDo6IHRsIC0+IGxvb3AgdGwgbDIgKHJldl9hcHBlbmQgKG1hcCB+ZjooZnVuIHggLT4gaGQsIHgpIGwyKSBhY2N1bSlcbiAgICBpblxuICAgIHJldiAobG9vcCBsaXN0MSBsaXN0MiBbXSkpXG47O1xuXG5sZXQgY29uY2F0IGwgPSBmb2xkX3JpZ2h0IGwgfmluaXQ6W10gfmY6YXBwZW5kXG5sZXQgY29uY2F0X25vX29yZGVyIGwgPSBmb2xkIGwgfmluaXQ6W10gfmY6KGZ1biBhY2MgbCAtPiByZXZfYXBwZW5kIGwgYWNjKVxubGV0IGNvbnMgeCBsID0geCA6OiBsXG5cbmxldCBpc19zb3J0ZWQgbCB+Y29tcGFyZSA9XG4gIGxldCByZWMgbG9vcCBsID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIHwgWyBfIF0gLT4gdHJ1ZVxuICAgIHwgeDEgOjogKHgyIDo6IF8gYXMgcmVzdCkgLT4gY29tcGFyZSB4MSB4MiA8PSAwICYmIGxvb3AgcmVzdFxuICBpblxuICBsb29wIGxcbjs7XG5cbmxldCBpc19zb3J0ZWRfc3RyaWN0bHkgbCB+Y29tcGFyZSA9XG4gIGxldCByZWMgbG9vcCBsID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIHwgWyBfIF0gLT4gdHJ1ZVxuICAgIHwgeDEgOjogKHgyIDo6IF8gYXMgcmVzdCkgLT4gY29tcGFyZSB4MSB4MiA8IDAgJiYgbG9vcCByZXN0XG4gIGluXG4gIGxvb3AgbFxuOztcblxubW9kdWxlIEluZml4ID0gc3RydWN0XG4gIGxldCAoIEAgKSA9IGFwcGVuZFxuZW5kXG5cbmxldCBwZXJtdXRlID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGxpc3QgPVxuICBtYXRjaCBsaXN0IHdpdGhcbiAgKCogc3BlY2lhbCBjYXNlcyB0byBzcGVlZCB0aGluZ3MgdXAgaW4gdHJpdmlhbCBjYXNlcyAqKVxuICB8IFtdIHwgWyBfIF0gLT4gbGlzdFxuICB8IFsgeDsgeSBdIC0+IGlmIFJhbmRvbS5TdGF0ZS5ib29sIHJhbmRvbV9zdGF0ZSB0aGVuIFsgeTsgeCBdIGVsc2UgbGlzdFxuICB8IF8gLT5cbiAgICBsZXQgYXJyID0gQXJyYXkub2ZfbGlzdCBsaXN0IGluXG4gICAgQXJyYXlfcGVybXV0ZS5wZXJtdXRlIGFyciB+cmFuZG9tX3N0YXRlO1xuICAgIEFycmF5LnRvX2xpc3QgYXJyXG47O1xuXG5sZXQgcmFuZG9tX2VsZW1lbnRfZXhuID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGxpc3QgPVxuICBpZiBpc19lbXB0eSBsaXN0XG4gIHRoZW4gZmFpbHdpdGggXCJMaXN0LnJhbmRvbV9lbGVtZW50X2V4bjogZW1wdHkgbGlzdFwiXG4gIGVsc2UgbnRoX2V4biBsaXN0IChSYW5kb20uU3RhdGUuaW50IHJhbmRvbV9zdGF0ZSAobGVuZ3RoIGxpc3QpKVxuOztcblxubGV0IHJhbmRvbV9lbGVtZW50ID8ocmFuZG9tX3N0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGxpc3QgPVxuICB0cnkgU29tZSAocmFuZG9tX2VsZW1lbnRfZXhuIH5yYW5kb21fc3RhdGUgbGlzdCkgd2l0aFxuICB8IF8gLT4gTm9uZVxuOztcblxubGV0IHJlYyBjb21wYXJlIGNtcCBhIGIgPVxuICBtYXRjaCBhLCBiIHdpdGhcbiAgfCBbXSwgW10gLT4gMFxuICB8IFtdLCBfIC0+IC0xXG4gIHwgXywgW10gLT4gMVxuICB8IHggOjogeHMsIHkgOjogeXMgLT5cbiAgICBsZXQgbiA9IGNtcCB4IHkgaW5cbiAgICBpZiBuID0gMCB0aGVuIGNvbXBhcmUgY21wIHhzIHlzIGVsc2UgblxuOztcblxubGV0IGhhc2hfZm9sZF90ID0gaGFzaF9mb2xkX2xpc3RcblxubGV0IGVxdWFsIGVxdWFsIHQxIHQyID1cbiAgbGV0IHJlYyBsb29wIH5lcXVhbCB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IFtdLCBbXSAtPiB0cnVlXG4gICAgfCB4MSA6OiB0MSwgeDIgOjogdDIgLT4gZXF1YWwgeDEgeDIgJiYgbG9vcCB+ZXF1YWwgdDEgdDJcbiAgICB8IF8gLT4gZmFsc2VcbiAgaW5cbiAgbG9vcCB+ZXF1YWwgdDEgdDJcbjs7XG5cbmxldCB0cmFuc3Bvc2UgPVxuICBsZXQgcmVjIHNwbGl0X29mZl9maXJzdF9jb2x1bW4gdCBjb2x1bW5fYWNjIHRyaW1tZWQgZm91bmRfZW1wdHkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gY29sdW1uX2FjYywgdHJpbW1lZCwgZm91bmRfZW1wdHlcbiAgICB8IFtdIDo6IHRsIC0+IHNwbGl0X29mZl9maXJzdF9jb2x1bW4gdGwgY29sdW1uX2FjYyB0cmltbWVkIHRydWVcbiAgICB8ICh4IDo6IHhzKSA6OiB0bCAtPlxuICAgICAgc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiB0bCAoeCA6OiBjb2x1bW5fYWNjKSAoeHMgOjogdHJpbW1lZCkgZm91bmRfZW1wdHlcbiAgaW5cbiAgbGV0IHNwbGl0X29mZl9maXJzdF9jb2x1bW4gcm93cyA9IHNwbGl0X29mZl9maXJzdF9jb2x1bW4gcm93cyBbXSBbXSBmYWxzZSBpblxuICBsZXQgcmVjIGxvb3Agcm93cyBjb2x1bW5zIGRvX3JldiA9XG4gICAgbWF0Y2ggc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiByb3dzIHdpdGhcbiAgICB8IFtdLCBbXSwgXyAtPiBTb21lIChyZXYgY29sdW1ucylcbiAgICB8IGNvbHVtbiwgdHJpbW1lZF9yb3dzLCBmb3VuZF9lbXB0eSAtPlxuICAgICAgaWYgZm91bmRfZW1wdHlcbiAgICAgIHRoZW4gTm9uZVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBjb2x1bW4gPSBpZiBkb19yZXYgdGhlbiByZXYgY29sdW1uIGVsc2UgY29sdW1uIGluXG4gICAgICAgIGxvb3AgdHJpbW1lZF9yb3dzIChjb2x1bW4gOjogY29sdW1ucykgKG5vdCBkb19yZXYpKVxuICBpblxuICBmdW4gdCAtPiBsb29wIHQgW10gdHJ1ZVxuOztcblxuZXhjZXB0aW9uIFRyYW5zcG9zZV9nb3RfbGlzdHNfb2ZfZGlmZmVyZW50X2xlbmd0aHMgb2YgaW50IGxpc3QgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbmxldCAoKSA9XG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZFxuICAgIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFRyYW5zcG9zZV9nb3RfbGlzdHNfb2ZfZGlmZmVyZW50X2xlbmd0aHNdXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IFRyYW5zcG9zZV9nb3RfbGlzdHNfb2ZfZGlmZmVyZW50X2xlbmd0aHMgYXJnMF9fMDMxXyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDMyXyA9IHNleHBfb2ZfbGlzdCBzZXhwX29mX2ludCBhcmcwX18wMzFfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwibGlzdC5tbC5UcmFuc3Bvc2VfZ290X2xpc3RzX29mX2RpZmZlcmVudF9sZW5ndGhzXCJcbiAgICAgICAgICA7IHJlczBfXzAzMl9cbiAgICAgICAgICBdXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuOztcblxuW0BAQGVuZF1cblxubGV0IHRyYW5zcG9zZV9leG4gbCA9XG4gIG1hdGNoIHRyYW5zcG9zZSBsIHdpdGhcbiAgfCBTb21lIGwgLT4gbFxuICB8IE5vbmUgLT4gcmFpc2UgKFRyYW5zcG9zZV9nb3RfbGlzdHNfb2ZfZGlmZmVyZW50X2xlbmd0aHMgKG1hcCBsIH5mOmxlbmd0aCkpXG47O1xuXG5sZXQgaW50ZXJzcGVyc2UgdCB+c2VwID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCB4IDo6IHhzIC0+IHggOjogZm9sZF9yaWdodCB4cyB+aW5pdDpbXSB+ZjooZnVuIHkgYWNjIC0+IHNlcCA6OiB5IDo6IGFjYylcbjs7XG5cbmxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbmxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB0XG5cbmxldCBpc19zdWZmaXggbGlzdCB+c3VmZml4IH5lcXVhbDplcXVhbF9lbHQgPVxuICBsZXQgbGlzdF9sZW4gPSBsZW5ndGggbGlzdCBpblxuICBsZXQgc3VmZml4X2xlbiA9IGxlbmd0aCBzdWZmaXggaW5cbiAgbGlzdF9sZW4gPj0gc3VmZml4X2xlbiAmJiBlcXVhbCBlcXVhbF9lbHQgKGRyb3AgbGlzdCAobGlzdF9sZW4gLSBzdWZmaXhfbGVuKSkgc3VmZml4XG47O1xuIiwiKCogVGhpcyBtb2R1bGUgaXMgdHJ5aW5nIHRvIG1pbmltaXplIGRlcGVuZGVuY2llcyBvbiBtb2R1bGVzIGluIENvcmUsIHNvIGFzIHRvIGFsbG93XG4gICBbSW5mb10sIFtFcnJvcl0sIGFuZCBbT3JfZXJyb3JdIHRvIGJlIHVzZWQgaW4gYXMgbWFueSBwbGFjZXMgYXMgcG9zc2libGUuIFBsZWFzZSBhdm9pZFxuICAgYWRkaW5nIG5ldyBkZXBlbmRlbmNpZXMuICopXG5cbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbmZvX2ludGZcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5cbm1vZHVsZSBNZXNzYWdlID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBDb3VsZF9ub3RfY29uc3RydWN0IG9mIFNleHAudFxuICAgIHwgU3RyaW5nIG9mIHN0cmluZ1xuICAgIHwgRXhuIG9mIGV4blxuICAgIHwgU2V4cCBvZiBTZXhwLnRcbiAgICB8IFRhZ19zZXhwIG9mIHN0cmluZyAqIFNleHAudCAqIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC50IG9wdGlvblxuICAgIHwgVGFnX3Qgb2Ygc3RyaW5nICogdFxuICAgIHwgVGFnX2FyZyBvZiBzdHJpbmcgKiBTZXhwLnQgKiB0XG4gICAgfCBPZl9saXN0IG9mIGludCBvcHRpb24gKiB0IGxpc3RcbiAgICB8IFdpdGhfYmFja3RyYWNlIG9mIHQgKiBzdHJpbmcgKCogYmFja3RyYWNlICopXG4gIFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIGxldCByZWMgc2V4cF9vZl90ID1cbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgQ291bGRfbm90X2NvbnN0cnVjdCBhcmcwX18wMDFfIC0+XG4gICAgICAgIGxldCByZXMwX18wMDJfID0gU2V4cC5zZXhwX29mX3QgYXJnMF9fMDAxXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJDb3VsZF9ub3RfY29uc3RydWN0XCI7IHJlczBfXzAwMl8gXVxuICAgICAgfCBTdHJpbmcgYXJnMF9fMDAzXyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDA0XyA9IHNleHBfb2Zfc3RyaW5nIGFyZzBfXzAwM18gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiU3RyaW5nXCI7IHJlczBfXzAwNF8gXVxuICAgICAgfCBFeG4gYXJnMF9fMDA1XyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDA2XyA9IHNleHBfb2ZfZXhuIGFyZzBfXzAwNV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiRXhuXCI7IHJlczBfXzAwNl8gXVxuICAgICAgfCBTZXhwIGFyZzBfXzAwN18gLT5cbiAgICAgICAgbGV0IHJlczBfXzAwOF8gPSBTZXhwLnNleHBfb2ZfdCBhcmcwX18wMDdfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlNleHBcIjsgcmVzMF9fMDA4XyBdXG4gICAgICB8IFRhZ19zZXhwIChhcmcwX18wMDlfLCBhcmcxX18wMTBfLCBhcmcyX18wMTFfKSAtPlxuICAgICAgICBsZXQgcmVzMF9fMDEyXyA9IHNleHBfb2Zfc3RyaW5nIGFyZzBfXzAwOV9cbiAgICAgICAgYW5kIHJlczFfXzAxM18gPSBTZXhwLnNleHBfb2ZfdCBhcmcxX18wMTBfXG4gICAgICAgIGFuZCByZXMyX18wMTRfID0gc2V4cF9vZl9vcHRpb24gU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdCBhcmcyX18wMTFfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiVGFnX3NleHBcIjsgcmVzMF9fMDEyXzsgcmVzMV9fMDEzXzsgcmVzMl9fMDE0XyBdXG4gICAgICB8IFRhZ190IChhcmcwX18wMTVfLCBhcmcxX18wMTZfKSAtPlxuICAgICAgICBsZXQgcmVzMF9fMDE3XyA9IHNleHBfb2Zfc3RyaW5nIGFyZzBfXzAxNV9cbiAgICAgICAgYW5kIHJlczFfXzAxOF8gPSBzZXhwX29mX3QgYXJnMV9fMDE2XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJUYWdfdFwiOyByZXMwX18wMTdfOyByZXMxX18wMThfIF1cbiAgICAgIHwgVGFnX2FyZyAoYXJnMF9fMDE5XywgYXJnMV9fMDIwXywgYXJnMl9fMDIxXykgLT5cbiAgICAgICAgbGV0IHJlczBfXzAyMl8gPSBzZXhwX29mX3N0cmluZyBhcmcwX18wMTlfXG4gICAgICAgIGFuZCByZXMxX18wMjNfID0gU2V4cC5zZXhwX29mX3QgYXJnMV9fMDIwX1xuICAgICAgICBhbmQgcmVzMl9fMDI0XyA9IHNleHBfb2ZfdCBhcmcyX18wMjFfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiVGFnX2FyZ1wiOyByZXMwX18wMjJfOyByZXMxX18wMjNfOyByZXMyX18wMjRfIF1cbiAgICAgIHwgT2ZfbGlzdCAoYXJnMF9fMDI1XywgYXJnMV9fMDI2XykgLT5cbiAgICAgICAgbGV0IHJlczBfXzAyN18gPSBzZXhwX29mX29wdGlvbiBzZXhwX29mX2ludCBhcmcwX18wMjVfXG4gICAgICAgIGFuZCByZXMxX18wMjhfID0gc2V4cF9vZl9saXN0IHNleHBfb2ZfdCBhcmcxX18wMjZfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIk9mX2xpc3RcIjsgcmVzMF9fMDI3XzsgcmVzMV9fMDI4XyBdXG4gICAgICB8IFdpdGhfYmFja3RyYWNlIChhcmcwX18wMjlfLCBhcmcxX18wMzBfKSAtPlxuICAgICAgICBsZXQgcmVzMF9fMDMxXyA9IHNleHBfb2ZfdCBhcmcwX18wMjlfXG4gICAgICAgIGFuZCByZXMxX18wMzJfID0gc2V4cF9vZl9zdHJpbmcgYXJnMV9fMDMwXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJXaXRoX2JhY2t0cmFjZVwiOyByZXMwX18wMzFfOyByZXMxX18wMzJfIF1cbiAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCByZWMgdG9fc3RyaW5nc19odW0gdCBhYyA9XG4gICAgKCogV2UgdXNlIFtTZXhwLnRvX3N0cmluZ19tYWNoXSwgZGVzcGl0ZSB0aGUgZmFjdCB0aGF0IHdlIGFyZSBpbXBsZW1lbnRpbmdcbiAgICAgICBbdG9fc3RyaW5nc19odW1dLCBiZWNhdXNlIHdlIHdhbnQgdGhlIGluZm8gdG8gZml0IG9uIGEgc2luZ2xlIGxpbmUsIGFuZCBvbmNlIHdlJ3ZlXG4gICAgICAgaGFkIHRvIHJlc29ydCB0byBzZXhwcywgdGhlIG1lc3NhZ2UgaXMgZ29pbmcgdG8gc3RhcnQgbm90IGxvb2tpbmcgc28gcHJldHR5XG4gICAgICAgYW55d2F5LiAqKVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgQ291bGRfbm90X2NvbnN0cnVjdCBzZXhwIC0+XG4gICAgICBcImNvdWxkIG5vdCBjb25zdHJ1Y3QgaW5mbzogXCIgOjogU2V4cC50b19zdHJpbmdfbWFjaCBzZXhwIDo6IGFjXG4gICAgfCBTdHJpbmcgc3RyaW5nIC0+IHN0cmluZyA6OiBhY1xuICAgIHwgRXhuIGV4biAtPiBTZXhwLnRvX3N0cmluZ19tYWNoIChFeG4uc2V4cF9vZl90IGV4bikgOjogYWNcbiAgICB8IFNleHAgc2V4cCAtPiBTZXhwLnRvX3N0cmluZ19tYWNoIHNleHAgOjogYWNcbiAgICB8IFRhZ19zZXhwICh0YWcsIHNleHAsIF8pIC0+IHRhZyA6OiBcIjogXCIgOjogU2V4cC50b19zdHJpbmdfbWFjaCBzZXhwIDo6IGFjXG4gICAgfCBUYWdfdCAodGFnLCB0KSAtPiB0YWcgOjogXCI6IFwiIDo6IHRvX3N0cmluZ3NfaHVtIHQgYWNcbiAgICB8IFRhZ19hcmcgKHRhZywgc2V4cCwgdCkgLT5cbiAgICAgIGxldCBib2R5ID0gU2V4cC50b19zdHJpbmdfbWFjaCBzZXhwIDo6IFwiOiBcIiA6OiB0b19zdHJpbmdzX2h1bSB0IGFjIGluXG4gICAgICBpZiBTdHJpbmcubGVuZ3RoIHRhZyA9IDAgdGhlbiBib2R5IGVsc2UgdGFnIDo6IFwiOiBcIiA6OiBib2R5XG4gICAgfCBXaXRoX2JhY2t0cmFjZSAodCwgYmFja3RyYWNlKSAtPlxuICAgICAgdG9fc3RyaW5nc19odW0gdCAoXCJcXG5CYWNrdHJhY2U6XFxuXCIgOjogYmFja3RyYWNlIDo6IGFjKVxuICAgIHwgT2ZfbGlzdCAodHJ1bmNfYWZ0ZXIsIHRzKSAtPlxuICAgICAgbGV0IHRzID1cbiAgICAgICAgbWF0Y2ggdHJ1bmNfYWZ0ZXIgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gdHNcbiAgICAgICAgfCBTb21lIG1heCAtPlxuICAgICAgICAgIGxldCBuID0gTGlzdC5sZW5ndGggdHMgaW5cbiAgICAgICAgICBpZiBuIDw9IG1heFxuICAgICAgICAgIHRoZW4gdHNcbiAgICAgICAgICBlbHNlIExpc3QudGFrZSB0cyBtYXggQCBbIFN0cmluZyAoUHJpbnRmLnNwcmludGYgXCJhbmQgJWQgbW9yZSBpbmZvXCIgKG4gLSBtYXgpKSBdXG4gICAgICBpblxuICAgICAgTGlzdC5mb2xkIChMaXN0LnJldiB0cykgfmluaXQ6YWMgfmY6KGZ1biBhYyB0IC0+XG4gICAgICAgIHRvX3N0cmluZ3NfaHVtIHQgKGlmIExpc3QuaXNfZW1wdHkgYWMgdGhlbiBhYyBlbHNlIFwiOyBcIiA6OiBhYykpXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZ19odW1fZGVwcmVjYXRlZCB0ID0gU3RyaW5nLmNvbmNhdCAodG9fc3RyaW5nc19odW0gdCBbXSlcblxuICBsZXQgcmVjIHRvX3NleHBzX2h1bSB0IGFjID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IENvdWxkX25vdF9jb25zdHJ1Y3QgXyBhcyB0IC0+IHNleHBfb2ZfdCB0IDo6IGFjXG4gICAgfCBTdHJpbmcgc3RyaW5nIC0+IEF0b20gc3RyaW5nIDo6IGFjXG4gICAgfCBFeG4gZXhuIC0+IEV4bi5zZXhwX29mX3QgZXhuIDo6IGFjXG4gICAgfCBTZXhwIHNleHAgLT4gc2V4cCA6OiBhY1xuICAgIHwgVGFnX3NleHAgKHRhZywgc2V4cCwgaGVyZSkgLT5cbiAgICAgIExpc3RcbiAgICAgICAgKEF0b20gdGFnXG4gICAgICAgICA6OiBzZXhwXG4gICAgICAgICA6OlxuICAgICAgICAgKG1hdGNoIGhlcmUgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBbXVxuICAgICAgICAgIHwgU29tZSBoZXJlIC0+IFsgU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdCBoZXJlIF0pKVxuICAgICAgOjogYWNcbiAgICB8IFRhZ190ICh0YWcsIHQpIC0+IExpc3QgKEF0b20gdGFnIDo6IHRvX3NleHBzX2h1bSB0IFtdKSA6OiBhY1xuICAgIHwgVGFnX2FyZyAodGFnLCBzZXhwLCB0KSAtPlxuICAgICAgbGV0IGJvZHkgPSBzZXhwIDo6IHRvX3NleHBzX2h1bSB0IFtdIGluXG4gICAgICBpZiBTdHJpbmcubGVuZ3RoIHRhZyA9IDAgdGhlbiBMaXN0IGJvZHkgOjogYWMgZWxzZSBMaXN0IChBdG9tIHRhZyA6OiBib2R5KSA6OiBhY1xuICAgIHwgV2l0aF9iYWNrdHJhY2UgKHQsIGJhY2t0cmFjZSkgLT5cbiAgICAgIFNleHAuTGlzdCBbIHRvX3NleHBfaHVtIHQ7IFNleHAuQXRvbSBiYWNrdHJhY2UgXSA6OiBhY1xuICAgIHwgT2ZfbGlzdCAoXywgdHMpIC0+XG4gICAgICBMaXN0LmZvbGQgKExpc3QucmV2IHRzKSB+aW5pdDphYyB+ZjooZnVuIGFjIHQgLT4gdG9fc2V4cHNfaHVtIHQgYWMpXG5cbiAgYW5kIHRvX3NleHBfaHVtIHQgPVxuICAgIG1hdGNoIHRvX3NleHBzX2h1bSB0IFtdIHdpdGhcbiAgICB8IFsgc2V4cCBdIC0+IHNleHBcbiAgICB8IHNleHBzIC0+IFNleHAuTGlzdCBzZXhwc1xuICA7O1xuXG4gICgqIFdlIHVzZSBbcHJvdGVjdF0gdG8gZ3VhcmQgYWdhaW5zdCBleGNlcHRpb25zIHJhaXNlZCBieSB1c2VyLXN1cHBsaWVkIGZ1bmN0aW9ucywgc29cbiAgICAgdGhhdCBmYWlsdXJlIHRvIHByb2R1Y2Ugb25lIHBhcnQgb2YgYW4gaW5mbyBkb2Vzbid0IGludGVyZmVyZSB3aXRoIG90aGVyIHBhcnRzLiAqKVxuICBsZXQgcHJvdGVjdCBmID1cbiAgICB0cnkgZiAoKSB3aXRoXG4gICAgfCBleG4gLT4gQ291bGRfbm90X2NvbnN0cnVjdCAoRXhuLnNleHBfb2ZfdCBleG4pXG4gIDs7XG5cbiAgbGV0IG9mX2luZm8gaW5mbyA9IHByb3RlY3QgKGZ1biAoKSAtPiBMYXp5LmZvcmNlIGluZm8pXG4gIGxldCB0b19pbmZvIHQgPSBsYXp5IHRcbmVuZFxuXG5vcGVuIE1lc3NhZ2VcblxudHlwZSB0ID0gTWVzc2FnZS50IExhenkudFxuXG5sZXQgaW52YXJpYW50IF8gPSAoKVxubGV0IHRvX21lc3NhZ2UgPSBNZXNzYWdlLm9mX2luZm9cbmxldCBvZl9tZXNzYWdlID0gTWVzc2FnZS50b19pbmZvXG5cbigqIEl0IGlzIE9LIHRvIHVzZSBbTWVzc2FnZS50b19zZXhwX2h1bV0sIHdoaWNoIGlzIG5vdCBzdGFibGUsIGJlY2F1c2UgW3Rfb2Zfc2V4cF0gYmVsb3dcbiAgIGNhbiBoYW5kbGUgYW55IHNleHAuICopXG5sZXQgc2V4cF9vZl90IHQgPSBNZXNzYWdlLnRvX3NleHBfaHVtICh0b19tZXNzYWdlIHQpXG5sZXQgdF9vZl9zZXhwIHNleHAgPSBsYXp5IChNZXNzYWdlLlNleHAgc2V4cClcbmxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHsgdW50eXBlZCA9IEFueSBcIkluZm8udFwiIH1cbmxldCBjb21wYXJlIHQxIHQyID0gU2V4cC5jb21wYXJlIChzZXhwX29mX3QgdDEpIChzZXhwX29mX3QgdDIpXG5sZXQgZXF1YWwgdDEgdDIgPSBTZXhwLmVxdWFsIChzZXhwX29mX3QgdDEpIChzZXhwX29mX3QgdDIpXG5sZXQgaGFzaF9mb2xkX3Qgc3RhdGUgdCA9IFNleHAuaGFzaF9mb2xkX3Qgc3RhdGUgKHNleHBfb2ZfdCB0KVxubGV0IGhhc2ggdCA9IEhhc2gucnVuIGhhc2hfZm9sZF90IHRcblxubGV0IHRvX3N0cmluZ19odW0gdCA9XG4gIG1hdGNoIHRvX21lc3NhZ2UgdCB3aXRoXG4gIHwgU3RyaW5nIHMgLT4gc1xuICB8IG1lc3NhZ2UgLT4gU2V4cC50b19zdHJpbmdfaHVtIChNZXNzYWdlLnRvX3NleHBfaHVtIG1lc3NhZ2UpXG47O1xuXG5sZXQgdG9fc3RyaW5nX2h1bV9kZXByZWNhdGVkIHQgPSBNZXNzYWdlLnRvX3N0cmluZ19odW1fZGVwcmVjYXRlZCAodG9fbWVzc2FnZSB0KVxubGV0IHRvX3N0cmluZ19tYWNoIHQgPSBTZXhwLnRvX3N0cmluZ19tYWNoIChzZXhwX29mX3QgdClcbmxldCBvZl9sYXp5IGwgPSBsYXp5IChwcm90ZWN0IChmdW4gKCkgLT4gU3RyaW5nIChMYXp5LmZvcmNlIGwpKSlcbmxldCBvZl9sYXp5X3NleHAgbCA9IGxhenkgKHByb3RlY3QgKGZ1biAoKSAtPiBTZXhwIChMYXp5LmZvcmNlIGwpKSlcbmxldCBvZl9sYXp5X3QgbGF6eV90ID0gTGF6eS5qb2luIGxhenlfdFxubGV0IG9mX3N0cmluZyBtZXNzYWdlID0gTGF6eS5mcm9tX3ZhbCAoU3RyaW5nIG1lc3NhZ2UpXG5sZXQgY3JlYXRlZiBmb3JtYXQgPSBQcmludGYua3NwcmludGYgb2Zfc3RyaW5nIGZvcm1hdFxubGV0IG9mX3RodW5rIGYgPSBsYXp5IChwcm90ZWN0IChmdW4gKCkgLT4gU3RyaW5nIChmICgpKSkpXG5cbmxldCBjcmVhdGUgP2hlcmUgP3N0cmljdCB0YWcgeCBzZXhwX29mX3ggPVxuICBtYXRjaCBzdHJpY3Qgd2l0aFxuICB8IE5vbmUgLT4gbGF6eSAocHJvdGVjdCAoZnVuICgpIC0+IFRhZ19zZXhwICh0YWcsIHNleHBfb2ZfeCB4LCBoZXJlKSkpXG4gIHwgU29tZSAoKSAtPiBvZl9tZXNzYWdlIChUYWdfc2V4cCAodGFnLCBzZXhwX29mX3ggeCwgaGVyZSkpXG47O1xuXG5sZXQgY3JlYXRlX3Mgc2V4cCA9IExhenkuZnJvbV92YWwgKFNleHAgc2V4cClcbmxldCB0YWcgdCB+dGFnID0gbGF6eSAoVGFnX3QgKHRhZywgdG9fbWVzc2FnZSB0KSlcblxubGV0IHRhZ19zX2xhenkgdCB+dGFnID1cbiAgbGF6eSAocHJvdGVjdCAoZnVuICgpIC0+IFRhZ19hcmcgKFwiXCIsIExhenkuZm9yY2UgdGFnLCB0b19tZXNzYWdlIHQpKSlcbjs7XG5cbmxldCB0YWdfcyB0IH50YWcgPSB0YWdfc19sYXp5IHQgfnRhZzooTGF6eS5mcm9tX3ZhbCB0YWcpXG5cbmxldCB0YWdfYXJnIHQgdGFnIHggc2V4cF9vZl94ID1cbiAgbGF6eSAocHJvdGVjdCAoZnVuICgpIC0+IFRhZ19hcmcgKHRhZywgc2V4cF9vZl94IHgsIHRvX21lc3NhZ2UgdCkpKVxuOztcblxubGV0IG9mX2xpc3QgP3RydW5jX2FmdGVyIHRzID0gbGF6eSAoT2ZfbGlzdCAodHJ1bmNfYWZ0ZXIsIExpc3QubWFwIHRzIH5mOnRvX21lc3NhZ2UpKVxuXG5leGNlcHRpb24gRXhuIG9mIHRcblxubGV0ICgpID1cbiAgKCogV2UgaW5zdGFsbCBhIGN1c3RvbSBleG4tY29udmVydGVyIHJhdGhlciB0aGFuIHVzZVxuICAgICBbZXhjZXB0aW9uIEV4biBvZiB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXSAuLi4gW0BAQGVuZF1dIHRvIGVsaW1pbmF0ZSB0aGUgZXh0cmFcbiAgICAgd3JhcHBpbmcgb2YgXCIoRXhuIC4uLilcIi4gKilcbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEV4bl0gKGZ1bmN0aW9uXG4gICAgfCBFeG4gdCAtPiBzZXhwX29mX3QgdFxuICAgIHwgXyAtPlxuICAgICAgKCogUmVhY2hpbmcgdGhpcyBicmFuY2ggaW5kaWNhdGVzIGEgYnVnIGluIHNleHBsaWIuICopXG4gICAgICBhc3NlcnQgZmFsc2UpXG47O1xuXG5sZXQgdG9fZXhuIHQgPVxuICBpZiBub3QgKExhenkuaXNfdmFsIHQpXG4gIHRoZW4gRXhuIHRcbiAgZWxzZSAoXG4gICAgbWF0Y2ggTGF6eS5mb3JjZSB0IHdpdGhcbiAgICB8IE1lc3NhZ2UuRXhuIGV4biAtPiBleG5cbiAgICB8IF8gLT4gRXhuIHQpXG47O1xuXG5sZXQgb2ZfZXhuID9iYWNrdHJhY2UgZXhuID1cbiAgbGV0IGJhY2t0cmFjZSA9XG4gICAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBgR2V0IC0+IFNvbWUgKENhbWwuUHJpbnRleGMuZ2V0X2JhY2t0cmFjZSAoKSlcbiAgICB8IFNvbWUgKGBUaGlzIHMpIC0+IFNvbWUgc1xuICBpblxuICBtYXRjaCBleG4sIGJhY2t0cmFjZSB3aXRoXG4gIHwgRXhuIHQsIE5vbmUgLT4gdFxuICB8IEV4biB0LCBTb21lIGJhY2t0cmFjZSAtPiBsYXp5IChXaXRoX2JhY2t0cmFjZSAodG9fbWVzc2FnZSB0LCBiYWNrdHJhY2UpKVxuICB8IF8sIE5vbmUgLT4gTGF6eS5mcm9tX3ZhbCAoTWVzc2FnZS5FeG4gZXhuKVxuICB8IF8sIFNvbWUgYmFja3RyYWNlIC0+IGxhenkgKFdpdGhfYmFja3RyYWNlIChTZXhwIChFeG4uc2V4cF9vZl90IGV4biksIGJhY2t0cmFjZSkpXG47O1xuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyX3BwIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkluZm9cIlxuICAgIGxldCBwcCBwcGYgdCA9IENhbWwuRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgKHRvX3N0cmluZ19odW0gdClcbiAgZW5kKVxuXG5tb2R1bGUgSW50ZXJuYWxfcmVwciA9IE1lc3NhZ2VcblxuIiwiKCogVGhpcyBtb2R1bGUgaXMgdHJ5aW5nIHRvIG1pbmltaXplIGRlcGVuZGVuY2llcyBvbiBtb2R1bGVzIGluIENvcmUsIHNvIGFzIHRvIGFsbG93XG4gICBbRXJyb3JdIGFuZCBbT3JfZXJyb3JdIHRvIGJlIHVzZWQgaW4gdmFyaW91cyBwbGFjZXMuICBQbGVhc2UgYXZvaWQgYWRkaW5nIG5ld1xuICAgZGVwZW5kZW5jaWVzLiAqKVxuXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgSW5mb1xuXG5sZXQgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gQW55IFwiRXJyb3IudFwiIH1cbmxldCByYWlzZSB0ID0gcmFpc2UgKHRvX2V4biB0KVxubGV0IHJhaXNlX3Mgc2V4cCA9IHJhaXNlIChjcmVhdGVfcyBzZXhwKVxubGV0IHRvX2luZm8gdCA9IHRcbmxldCBvZl9pbmZvIHQgPSB0XG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXJfcHAgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuRXJyb3JcIlxuICAgIGxldCBwcCA9IHBwXG4gIGVuZClcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbnZhcmlhbnRfaW50ZlxuXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxubGV0IGludmFyaWFudCBoZXJlIHQgc2V4cF9vZl90IGYgOiB1bml0ID1cbiAgdHJ5IGYgKCkgd2l0aFxuICB8IGV4biAtPlxuICAgIHJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiaW52YXJpYW50IGZhaWxlZFwiXG4gICAgICAgICBbIFwiXCIsIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3QgaGVyZVxuICAgICAgICAgOyBcImV4blwiLCBzZXhwX29mX2V4biBleG5cbiAgICAgICAgIDsgXCJcIiwgc2V4cF9vZl90IHRcbiAgICAgICAgIF0pXG47O1xuXG5sZXQgY2hlY2tfZmllbGQgdCBmIGZpZWxkID1cbiAgdHJ5IGYgKEZpZWxkLmdldCBmaWVsZCB0KSB3aXRoXG4gIHwgZXhuIC0+XG4gICAgcmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJwcm9ibGVtIHdpdGggZmllbGRcIlxuICAgICAgICAgWyBcImZpZWxkXCIsIHNleHBfb2Zfc3RyaW5nIChGaWVsZC5uYW1lIGZpZWxkKTsgXCJleG5cIiwgc2V4cF9vZl9leG4gZXhuIF0pXG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbmluY2x1ZGUgKFxuICBSZXN1bHQgOlxuICAgIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgIGluY2x1ZGUgUmVzdWx0XG4gIGVuZFxuICB3aXRoIG1vZHVsZSBFcnJvciA6PSBSZXN1bHQuRXJyb3IpXG5cbnR5cGUgJ2EgdCA9ICgnYSwgRXJyb3IudCkgUmVzdWx0LnRcbltAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID1cbiAgZnVuIF9jbXBfX2EgYV9fMDAxXyBiX18wMDJfIC0+IFJlc3VsdC5jb21wYXJlIF9jbXBfX2EgRXJyb3IuY29tcGFyZSBhX18wMDFfIGJfXzAwMl9cbjs7XG5cbmxldCBlcXVhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2wgPVxuICBmdW4gX2NtcF9fYSBhX18wMDdfIGJfXzAwOF8gLT4gUmVzdWx0LmVxdWFsIF9jbXBfX2EgRXJyb3IuZXF1YWwgYV9fMDA3XyBiX18wMDhfXG47O1xuXG5sZXQgaGFzaF9mb2xkX3QgOlxuICAnYS5cbiAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiAnYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAtPiAnYSB0XG4gIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICA9XG4gIGZ1biBfaGFzaF9mb2xkX2EgaHN2IGFyZyAtPiBSZXN1bHQuaGFzaF9mb2xkX3QgX2hhc2hfZm9sZF9hIEVycm9yLmhhc2hfZm9sZF90IGhzdiBhcmdcbjs7XG5cbmxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPVxuICBmdW4gX29mX2FfXzAxM18geF9fMDE1XyAtPiBSZXN1bHQudF9vZl9zZXhwIF9vZl9hX18wMTNfIEVycm9yLnRfb2Zfc2V4cCB4X18wMTVfXG47O1xuXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgZnVuIF9vZl9hX18wMTZfIHhfXzAxN18gLT4gUmVzdWx0LnNleHBfb2ZfdCBfb2ZfYV9fMDE2XyBFcnJvci5zZXhwX29mX3QgeF9fMDE3X1xuOztcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gUmVzdWx0LnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXIgRXJyb3IudF9zZXhwX2dyYW1tYXJcbjs7XG5cbltAQEBlbmRdXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE9rIGEgLT4gaW52YXJpYW50X2EgYVxuICB8IEVycm9yIGVycm9yIC0+IEVycm9yLmludmFyaWFudCBlcnJvclxuOztcblxuaW5jbHVkZSBBcHBsaWNhdGl2ZS5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuXG4gICAgbGV0IGFwcGx5IGYgeCA9XG4gICAgICBSZXN1bHQuY29tYmluZSBmIHggfm9rOihmdW4gZiB4IC0+IGYgeCkgfmVycjooZnVuIGUxIGUyIC0+IEVycm9yLm9mX2xpc3QgWyBlMTsgZTIgXSlcbiAgICA7O1xuXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZClcblxubW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgbGV0IHJldHVybiA9IHJldHVyblxuXG4gIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgbWFwID0gbWFwXG4gICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgbGV0IGJvdGggPSBib3RoXG5cbiAgICAoKiBmcm9tIEFwcGxpY2F0aXZlLk1ha2UgKilcbiAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBzdHJ1Y3QgZW5kXG4gIGVuZFxuZW5kXG5cbmxldCBvayA9IFJlc3VsdC5va1xubGV0IGlzX29rID0gUmVzdWx0LmlzX29rXG5sZXQgaXNfZXJyb3IgPSBSZXN1bHQuaXNfZXJyb3JcblxubGV0IHRyeV93aXRoID8oYmFja3RyYWNlID0gZmFsc2UpIGYgPVxuICB0cnkgT2sgKGYgKCkpIHdpdGhcbiAgfCBleG4gLT4gRXJyb3IgKEVycm9yLm9mX2V4biBleG4gP2JhY2t0cmFjZTooaWYgYmFja3RyYWNlIHRoZW4gU29tZSBgR2V0IGVsc2UgTm9uZSkpXG47O1xuXG5sZXQgdHJ5X3dpdGhfam9pbiA/YmFja3RyYWNlIGYgPSBqb2luICh0cnlfd2l0aCA/YmFja3RyYWNlIGYpXG5cbmxldCBva19leG4gPSBmdW5jdGlvblxuICB8IE9rIHggLT4geFxuICB8IEVycm9yIGVyciAtPiBFcnJvci5yYWlzZSBlcnJcbjs7XG5cbmxldCBvZl9leG4gP2JhY2t0cmFjZSBleG4gPSBFcnJvciAoRXJyb3Iub2ZfZXhuID9iYWNrdHJhY2UgZXhuKVxuXG5sZXQgb2ZfZXhuX3Jlc3VsdCA/YmFja3RyYWNlID0gZnVuY3Rpb25cbiAgfCBPayBfIGFzIHogLT4gelxuICB8IEVycm9yIGV4biAtPiBvZl9leG4gP2JhY2t0cmFjZSBleG5cbjs7XG5cbmxldCBlcnJvciA/aGVyZSA/c3RyaWN0IG1lc3NhZ2UgYSBzZXhwX29mX2EgPVxuICBFcnJvciAoRXJyb3IuY3JlYXRlID9oZXJlID9zdHJpY3QgbWVzc2FnZSBhIHNleHBfb2ZfYSlcbjs7XG5cbmxldCBlcnJvcl9zIHNleHAgPSBFcnJvciAoRXJyb3IuY3JlYXRlX3Mgc2V4cClcbmxldCBlcnJvcl9zdHJpbmcgbWVzc2FnZSA9IEVycm9yIChFcnJvci5vZl9zdHJpbmcgbWVzc2FnZSlcbmxldCBlcnJvcmYgZm9ybWF0ID0gUHJpbnRmLmtzcHJpbnRmIGVycm9yX3N0cmluZyBmb3JtYXRcbmxldCB0YWcgdCB+dGFnID0gUmVzdWx0Lm1hcF9lcnJvciB0IH5mOihFcnJvci50YWcgfnRhZylcbmxldCB0YWdfcyB0IH50YWcgPSBSZXN1bHQubWFwX2Vycm9yIHQgfmY6KEVycm9yLnRhZ19zIH50YWcpXG5sZXQgdGFnX3NfbGF6eSB0IH50YWcgPSBSZXN1bHQubWFwX2Vycm9yIHQgfmY6KEVycm9yLnRhZ19zX2xhenkgfnRhZylcblxubGV0IHRhZ19hcmcgdCBtZXNzYWdlIGEgc2V4cF9vZl9hID1cbiAgUmVzdWx0Lm1hcF9lcnJvciB0IH5mOihmdW4gZSAtPiBFcnJvci50YWdfYXJnIGUgbWVzc2FnZSBhIHNleHBfb2ZfYSlcbjs7XG5cbmxldCB1bmltcGxlbWVudGVkIHMgPSBlcnJvciBcInVuaW1wbGVtZW50ZWRcIiBzIHNleHBfb2Zfc3RyaW5nXG5sZXQgY29tYmluZV9lcnJvcnMgbCA9IFJlc3VsdC5tYXBfZXJyb3IgKFJlc3VsdC5jb21iaW5lX2Vycm9ycyBsKSB+ZjpFcnJvci5vZl9saXN0XG5sZXQgY29tYmluZV9lcnJvcnNfdW5pdCBsID0gUmVzdWx0Lm1hcCAoY29tYmluZV9lcnJvcnMgbCkgfmY6KGZ1biAoXyA6IHVuaXQgbGlzdCkgLT4gKCkpXG5cbmxldCBmaWx0ZXJfb2tfYXRfbGVhc3Rfb25lIGwgPVxuICBsZXQgb2ssIGVycnMgPSBMaXN0LnBhcnRpdGlvbl9tYXAgbCB+ZjpSZXN1bHQudG9fZWl0aGVyIGluXG4gIG1hdGNoIG9rIHdpdGhcbiAgfCBbXSAtPiBFcnJvciAoRXJyb3Iub2ZfbGlzdCBlcnJzKVxuICB8IF8gLT4gT2sgb2tcbjs7XG5cbmxldCBmaW5kX29rIGwgPVxuICBtYXRjaCBMaXN0LmZpbmRfbWFwIGwgfmY6UmVzdWx0Lm9rIHdpdGhcbiAgfCBTb21lIHggLT4gT2sgeFxuICB8IE5vbmUgLT5cbiAgICBFcnJvclxuICAgICAgKEVycm9yLm9mX2xpc3RcbiAgICAgICAgIChMaXN0Lm1hcCBsIH5mOihmdW5jdGlvblxuICAgICAgICAgICAgfCBPayBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgfCBFcnJvciBlcnIgLT4gZXJyKSkpXG47O1xuXG5sZXQgZmluZF9tYXBfb2sgbCB+ZiA9XG4gIFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgIEVycm9yXG4gICAgICAoRXJyb3Iub2ZfbGlzdFxuICAgICAgICAgKExpc3QubWFwIGwgfmY6KGZ1biBlbHQgLT5cbiAgICAgICAgICAgIG1hdGNoIGYgZWx0IHdpdGhcbiAgICAgICAgICAgIHwgT2sgXyBhcyB4IC0+IHJldHVybiB4XG4gICAgICAgICAgICB8IEVycm9yIGVyciAtPiBlcnIpKSkpXG47O1xuXG5sZXQgbWFwID0gUmVzdWx0Lm1hcFxubGV0IGl0ZXIgPSBSZXN1bHQuaXRlclxubGV0IGl0ZXJfZXJyb3IgPSBSZXN1bHQuaXRlcl9lcnJvclxuIiwiKCogVGhpcyBpcyBicm9rZW4gb2ZmIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBTaWduIGFuZCBDb21wYXJhYmxlLiAqKVxuXG5vcGVuISBJbXBvcnRcblxudHlwZSB0ID1cbiAgfCBOZWdcbiAgfCBaZXJvXG4gIHwgUG9zXG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyLCBjb21wYXJlLCBoYXNoLCBlbnVtZXJhdGVdXG5cbmxldCB0X29mX3NleHAgPVxuICAobGV0IGVycm9yX3NvdXJjZV9fMDAzXyA9IFwic2lnbjAubWwudFwiIGluXG4gICBmdW5jdGlvblxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwibmVnXCIgfCBcIk5lZ1wiKSAtPiBOZWdcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSAtPiBaZXJvXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJwb3NcIiB8IFwiUG9zXCIpIC0+IFBvc1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJuZWdcIiB8IFwiTmVnXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDAyXyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwMl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgIHwgc2V4cF9fMDAyXyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICAgICAgICAgICAgICAgICAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbjs7XG5cbmxldCBzZXhwX29mX3QgPVxuICAoZnVuY3Rpb25cbiAgICB8IE5lZyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJOZWdcIlxuICAgIHwgWmVybyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJaZXJvXCJcbiAgICB8IFBvcyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJQb3NcIlxuICAgICAgICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG47O1xuXG5sZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICB7IHVudHlwZWQgPVxuICAgICAgVmFyaWFudFxuICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICBbIE5vX3RhZyB7IG5hbWUgPSBcIk5lZ1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiWmVyb1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiUG9zXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbmxldCBjb21wYXJlID0gKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIDogdCAtPiB0IC0+IGludClcblxubGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgbWF0Y2ggYXJnIHdpdGhcbiAgICAgfCBOZWcgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwXG4gICAgIHwgWmVybyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDFcbiAgICAgfCBQb3MgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAyXG4gICAgICAgICAgICAgIDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuOztcblxubGV0IChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICBsZXQgZnVuYyBhcmcgPVxuICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgaW5cbiAgZnVuIHggLT4gZnVuYyB4XG47O1xuXG5sZXQgYWxsID0gKFsgTmVnOyBaZXJvOyBQb3MgXSA6IHQgbGlzdClcblxuW0BAQGVuZF1cblxubW9kdWxlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiB0KSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IHQpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IHQpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogdCkgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IHQpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogdCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogdCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IHQpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogdCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogdCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiB0KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IHQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbmxldCBvZl9zdHJpbmcgcyA9IHRfb2Zfc2V4cCAoc2V4cF9vZl9zdHJpbmcgcylcbmxldCB0b19zdHJpbmcgdCA9IHN0cmluZ19vZl9zZXhwIChzZXhwX29mX3QgdClcblxubGV0IHRvX2ludCA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IC0xXG4gIHwgWmVybyAtPiAwXG4gIHwgUG9zIC0+IDFcbjs7XG5cbmxldCBfID0gaGFzaFxuXG4oKiBJZ25vcmUgdGhlIGhhc2ggZnVuY3Rpb24gcHJvZHVjZWQgYnkgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2hdICopXG5sZXQgaGFzaCA9IHRvX2ludFxubGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlNpZ25cIlxubGV0IG9mX2ludCBuID0gaWYgbiA8IDAgdGhlbiBOZWcgZWxzZSBpZiBuID0gMCB0aGVuIFplcm8gZWxzZSBQb3NcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBDb21wYXJhYmxlX2ludGZcblxubW9kdWxlIFdpdGhfemVybyAoVCA6IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZV1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIHplcm8gOiB0XG4gIGVuZCkgPVxuc3RydWN0XG4gIG9wZW4gVFxuXG4gIGxldCBpc19wb3NpdGl2ZSB0ID0gY29tcGFyZSB0IHplcm8gPiAwXG4gIGxldCBpc19ub25fbmVnYXRpdmUgdCA9IGNvbXBhcmUgdCB6ZXJvID49IDBcbiAgbGV0IGlzX25lZ2F0aXZlIHQgPSBjb21wYXJlIHQgemVybyA8IDBcbiAgbGV0IGlzX25vbl9wb3NpdGl2ZSB0ID0gY29tcGFyZSB0IHplcm8gPD0gMFxuICBsZXQgc2lnbiB0ID0gU2lnbjAub2ZfaW50IChjb21wYXJlIHQgemVybylcbmVuZFxuXG5tb2R1bGUgUG9seSAoVCA6IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IFQudCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIGxldCBzZXhwX29mX3QgPSAoVC5zZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudClcblxuICAgIFtAQEBlbmRdXG5cbiAgICBpbmNsdWRlIFBvbHlcbiAgZW5kXG5cbiAgaW5jbHVkZSBQb2x5XG5cbiAgbGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG4gIGxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbiAgbGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gICAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbiAgOztcblxuICBsZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICAgIGlmIG1pbiA+IG1heFxuICAgIHRoZW5cbiAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG4gIDs7XG5cbiAgbW9kdWxlIEMgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcbiAgICBpbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlKVxuICBlbmRcblxuICBpbmNsdWRlIENcbmVuZFxuXG5sZXQgZ3QgY21wIGEgYiA9IGNtcCBhIGIgPiAwXG5sZXQgbHQgY21wIGEgYiA9IGNtcCBhIGIgPCAwXG5sZXQgZ2VxIGNtcCBhIGIgPSBjbXAgYSBiID49IDBcbmxldCBsZXEgY21wIGEgYiA9IGNtcCBhIGIgPD0gMFxubGV0IGVxdWFsIGNtcCBhIGIgPSBjbXAgYSBiID0gMFxubGV0IG5vdF9lcXVhbCBjbXAgYSBiID0gY21wIGEgYiA8PiAwXG5sZXQgbWluIGNtcCB0IHQnID0gaWYgbGVxIGNtcCB0IHQnIHRoZW4gdCBlbHNlIHQnXG5sZXQgbWF4IGNtcCB0IHQnID0gaWYgZ2VxIGNtcCB0IHQnIHRoZW4gdCBlbHNlIHQnXG5cbm1vZHVsZSBJbmZpeCAoVCA6IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZV1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpIDogSW5maXggd2l0aCB0eXBlIHQgOj0gVC50ID0gc3RydWN0XG4gIGxldCAoID4gKSBhIGIgPSBndCBULmNvbXBhcmUgYSBiXG4gIGxldCAoIDwgKSBhIGIgPSBsdCBULmNvbXBhcmUgYSBiXG4gIGxldCAoID49ICkgYSBiID0gZ2VxIFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPD0gKSBhIGIgPSBsZXEgVC5jb21wYXJlIGEgYlxuICBsZXQgKCA9ICkgYSBiID0gZXF1YWwgVC5jb21wYXJlIGEgYlxuICBsZXQgKCA8PiApIGEgYiA9IG5vdF9lcXVhbCBULmNvbXBhcmUgYSBiXG5lbmRcblxubW9kdWxlIFBvbHltb3JwaGljX2NvbXBhcmUgKFQgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSA6IFBvbHltb3JwaGljX2NvbXBhcmUgd2l0aCB0eXBlIHQgOj0gVC50ID0gc3RydWN0XG4gIGluY2x1ZGUgSW5maXggKFQpXG5cbiAgbGV0IGNvbXBhcmUgPSBULmNvbXBhcmVcbiAgbGV0IGVxdWFsID0gKCA9IClcbiAgbGV0IG1pbiB0IHQnID0gbWluIGNvbXBhcmUgdCB0J1xuICBsZXQgbWF4IHQgdCcgPSBtYXggY29tcGFyZSB0IHQnXG5lbmRcblxubW9kdWxlIE1ha2VfdXNpbmdfY29tcGFyYXRvciAoVCA6IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbiAgZW5kKSA6IFMgd2l0aCB0eXBlIHQgOj0gVC50IGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IFQuY29tcGFyYXRvcl93aXRuZXNzID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgY29tcGFyZSA9IGNvbXBhcmF0b3IuY29tcGFyZVxuICBlbmRcblxuICBpbmNsdWRlIFRcbiAgbW9kdWxlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IFBvbHltb3JwaGljX2NvbXBhcmUgKFQpXG4gIGluY2x1ZGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IGFzY2VuZGluZyA9IGNvbXBhcmVcbiAgbGV0IGRlc2NlbmRpbmcgdCB0JyA9IGNvbXBhcmUgdCcgdFxuICBsZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbiAgbGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxuICBsZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICAgIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuICA7O1xuXG4gIGxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gICAgaWYgbWluID4gbWF4XG4gICAgdGhlblxuICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICAgIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZSAoVCA6IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgPVxuICBNYWtlX3VzaW5nX2NvbXBhcmF0b3IgKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuICAgIGluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuICBlbmQpXG5cbm1vZHVsZSBJbmhlcml0IChDIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgKFQgOiBzaWdcbiAgICAgICAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICAgICAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgICAgICAgIFtAQEBlbmRdXG5cbiAgICAgICAgICB2YWwgY29tcG9uZW50IDogdCAtPiBDLnRcbiAgICAgICAgZW5kKSA9XG4gIE1ha2UgKHN0cnVjdFxuICAgIHR5cGUgdCA9IFQudCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIGxldCBzZXhwX29mX3QgPSAoVC5zZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudClcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgY29tcGFyZSB0IHQnID0gQy5jb21wYXJlIChULmNvbXBvbmVudCB0KSAoVC5jb21wb25lbnQgdCcpXG4gIGVuZClcblxuKCogY29tcGFyZSBbeF0gYW5kIFt5XSBsZXhpY29ncmFwaGljYWxseSB1c2luZyBmdW5jdGlvbnMgaW4gdGhlIGxpc3QgW2NtcHNdICopXG5sZXQgbGV4aWNvZ3JhcGhpYyBjbXBzIHggeSA9XG4gIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgfCBjbXAgOjogY21wcyAtPlxuICAgICAgbGV0IHJlcyA9IGNtcCB4IHkgaW5cbiAgICAgIGlmIHJlcyA9IDAgdGhlbiBsb29wIGNtcHMgZWxzZSByZXNcbiAgICB8IFtdIC0+IDBcbiAgaW5cbiAgbG9vcCBjbXBzXG47O1xuXG5sZXQgbGlmdCBjbXAgfmYgeCB5ID0gY21wIChmIHgpIChmIHkpXG5sZXQgcmV2ZXJzZSBjbXAgeCB5ID0gY21wIHkgeFxuIiwib3BlbiEgSW1wb3J0XG5cbigqKiBAY2Fub25pY2FsIEJhc2UuSGFzaGFibGUuS2V5ICopXG5tb2R1bGUgdHlwZSBLZXkgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cblxuICAoKiogVmFsdWVzIHJldHVybmVkIGJ5IFtoYXNoXSBtdXN0IGJlIG5vbi1uZWdhdGl2ZS4gIEFuIGV4Y2VwdGlvbiB3aWxsIGJlIHJhaXNlZCBpbiB0aGVcbiAgICAgIGNhc2UgdGhhdCBbaGFzaF0gcmV0dXJucyBhIG5lZ2F0aXZlIHZhbHVlLiAqKVxuICB2YWwgaGFzaCA6IHQgLT4gaW50XG5lbmRcblxubW9kdWxlIEhhc2hhYmxlID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBoYXNoIDogJ2EgLT4gaW50XG4gICAgOyBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50XG4gICAgOyBzZXhwX29mX3QgOiAnYSAtPiBTZXhwLnRcbiAgICB9XG5cbiAgKCoqIFRoaXMgZnVuY3Rpb24gaXMgc291bmQgYnV0IG5vdCBjb21wbGV0ZSwgbWVhbmluZyB0aGF0IGlmIGl0IHJldHVybnMgW3RydWVdIHRoZW4gaXQnc1xuICAgICAgc2FmZSB0byB1c2UgdGhlIHR3byBpbnRlcmNoYW5nZWFibHkuICBJZiBpdCdzIFtmYWxzZV0sIHlvdSBoYXZlIG5vIGd1YXJhbnRlZXMuICBGb3JcbiAgICAgIGV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgID4gdXRvcFxuICAgICAgICBvcGVuIENvcmU7O1xuICAgICAgICBsZXQgZXF1YWwgKGEgOiAnYSBIYXNodGJsX2ludGYuSGFzaGFibGUudCkgYiA9XG4gICAgICAgICAgcGh5c19lcXVhbCBhIGJcbiAgICAgICAgICB8fCAocGh5c19lcXVhbCBhLmhhc2ggYi5oYXNoXG4gICAgICAgICAgICAgICYmIHBoeXNfZXF1YWwgYS5jb21wYXJlIGIuY29tcGFyZVxuICAgICAgICAgICAgICAmJiBwaHlzX2VxdWFsIGEuc2V4cF9vZl90IGIuc2V4cF9vZl90KVxuICAgICAgICA7O1xuICAgICAgICBsZXQgYSA9IEhhc2h0YmxfaW50Zi5IYXNoYWJsZS57IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCA9IEludC5zZXhwX29mX3QgfTs7XG4gICAgICAgIGxldCBiID0gSGFzaHRibF9pbnRmLkhhc2hhYmxlLnsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90ID0gSW50LnNleHBfb2ZfdCB9OztcbiAgICAgICAgZXF1YWwgYSBiOzsgICgqIGZhbHNlPyEgKilcbiAgICAgIF19XG4gICopXG4gIGxldCBlcXVhbCBhIGIgPVxuICAgIHBoeXNfZXF1YWwgYSBiXG4gICAgfHwgKHBoeXNfZXF1YWwgYS5oYXNoIGIuaGFzaFxuICAgICAgICAmJiBwaHlzX2VxdWFsIGEuY29tcGFyZSBiLmNvbXBhcmVcbiAgICAgICAgJiYgcGh5c19lcXVhbCBhLnNleHBfb2ZfdCBiLnNleHBfb2ZfdClcbiAgOztcblxuICBsZXQgaGFzaF9wYXJhbSA9IENhbWwuSGFzaHRibC5oYXNoX3BhcmFtXG4gIGxldCBoYXNoID0gQ2FtbC5IYXNodGJsLmhhc2hcbiAgbGV0IHBvbHkgPSB7IGhhc2g7IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmU7IHNleHBfb2ZfdCA9IChmdW4gXyAtPiBTZXhwLkF0b20gXCJfXCIpIH1cblxuICBsZXQgb2Zfa2V5ICh0eXBlIGEpIChtb2R1bGUgS2V5IDogS2V5IHdpdGggdHlwZSB0ID0gYSkgPVxuICAgIHsgaGFzaCA9IEtleS5oYXNoOyBjb21wYXJlID0gS2V5LmNvbXBhcmU7IHNleHBfb2ZfdCA9IEtleS5zZXhwX29mX3QgfVxuICA7O1xuXG4gIGxldCB0b19rZXkgKHR5cGUgYSkgeyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfSA9XG4gICAgKG1vZHVsZSBzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IGFcblxuICAgICAgbGV0IGhhc2ggPSBoYXNoXG4gICAgICBsZXQgY29tcGFyZSA9IGNvbXBhcmVcbiAgICAgIGxldCBzZXhwX29mX3QgPSBzZXhwX29mX3RcbiAgICBlbmQgOiBLZXlcbiAgICAgIHdpdGggdHlwZSB0ID0gYSlcbiAgOztcbmVuZFxuXG5pbmNsdWRlIEhhc2hhYmxlXG5cbm1vZHVsZSB0eXBlIEhhc2hhYmxlID0gc2lnXG4gIHR5cGUgJ2EgdCA9ICdhIEhhc2hhYmxlLnQgPVxuICAgIHsgaGFzaCA6ICdhIC0+IGludFxuICAgIDsgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludFxuICAgIDsgc2V4cF9vZl90IDogJ2EgLT4gU2V4cC50XG4gICAgfVxuXG4gIHZhbCBlcXVhbCA6ICdhIHQgLT4gJ2EgdCAtPiBib29sXG4gIHZhbCBwb2x5IDogJ2EgdFxuICB2YWwgb2Zfa2V5IDogKG1vZHVsZSBLZXkgd2l0aCB0eXBlIHQgPSAnYSkgLT4gJ2EgdFxuICB2YWwgdG9fa2V5IDogJ2EgdCAtPiAobW9kdWxlIEtleSB3aXRoIHR5cGUgdCA9ICdhKVxuICB2YWwgaGFzaF9wYXJhbSA6IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50XG4gIHZhbCBoYXNoIDogJ2EgLT4gaW50XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJZGVudGlmaWFibGVfaW50ZlxuXG5tb2R1bGUgTWFrZSAoVCA6IEFyZykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlIChUKVxuICBpbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChUKVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbmVuZFxuXG5tb2R1bGUgTWFrZV91c2luZ19jb21wYXJhdG9yIChUIDogQXJnX3dpdGhfY29tcGFyYXRvcikgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlX3VzaW5nX2NvbXBhcmF0b3IgKFQpXG4gIGluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKFQpXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gdW5pdCBbQEBkZXJpdmluZ19pbmxpbmUgZW51bWVyYXRlLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGFsbCA9IChbICgpIF0gOiB0IGxpc3QpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF91bml0XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF91bml0IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9ICh1bml0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX3VuaXQgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gdW5pdF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBjb21wYXJlIF8gXyA9IDBcblxuICBsZXQgb2Zfc3RyaW5nID0gZnVuY3Rpb25cbiAgICB8IFwiKClcIiAtPiAoKVxuICAgIHwgXyAtPiBmYWlsd2l0aCBcIkJhc2UuVW5pdC5vZl9zdHJpbmc6ICgpIGV4cGVjdGVkXCJcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nICgpID0gXCIoKVwiXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5Vbml0XCJcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgSWRlbnRpZmlhYmxlLk1ha2UgKFQpXG5cbmxldCBpbnZhcmlhbnQgKCkgPSAoKVxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24wXG5cbmxldCBnZXRfcG9zX2xlbiA/cG9zID9sZW4gKCkgfnRvdGFsX2xlbmd0aCA9XG4gIHRyeSBSZXN1bHQuT2sgKGdldF9wb3NfbGVuX2V4biAoKSA/cG9zID9sZW4gfnRvdGFsX2xlbmd0aCkgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgcyAtPiBPcl9lcnJvci5lcnJvcl9zdHJpbmcgc1xuOztcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IGEgc2VhcmNoIGZvciB0aGUgZmlyc3QgKHJlc3AuIGxhc3QpIGVsZW1lbnRcbiAgIHNhdGlzZnlpbmcgYSBwcmVkaWNhdGUsIGFzc3VtaW5nIHRoYXQgdGhlIHByZWRpY2F0ZSBpcyBpbmNyZWFzaW5nIG9uXG4gICB0aGUgY29udGFpbmVyLCBtZWFuaW5nIHRoYXQsIGlmIHRoZSBjb250YWluZXIgaXMgW3UxLi4udW5dLCB0aGVyZSBleGlzdHMgYVxuICAgayBzdWNoIHRoYXQgcCh1MSk9Li4uLj1wKHVrKSA9IGZhbHNlIGFuZCBwKHVrKzEpPS4uLi49cCh1bik9IHRydWUuXG4gICBJZiB0aGlzIGsgPSAxIChyZXNwIG4pLCBmaW5kX2xhc3Rfbm90X3NhdGlzZnlpbmcgKHJlc3AgZmluZF9maXJzdF9zYXRpc2Z5aW5nKVxuICAgd2lsbCByZXR1cm4gTm9uZS4gKilcblxubGV0IHJlYyBsaW5lYXJfc2VhcmNoX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbyB+aGkgfnByZWQgPVxuICBpZiBsbyA+IGhpXG4gIHRoZW4gTm9uZVxuICBlbHNlIGlmIHByZWQgKGdldCB0IGxvKVxuICB0aGVuIFNvbWUgbG9cbiAgZWxzZSBsaW5lYXJfc2VhcmNoX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbzoobG8gKyAxKSB+aGkgfnByZWRcbjs7XG5cbigqIFRha2VzIGEgY29udGFpbmVyIFt0XSwgYSBwcmVkaWNhdGUgW3ByZWRdIGFuZCB0d28gaW5kaWNlcyBbbG8gPCBoaV0sIHN1Y2ggdGhhdFxuICAgW3ByZWRdIGlzIGluY3JlYXNpbmcgb24gW3RdIGJldHdlZW4gW2xvXSBhbmQgW2hpXS5cblxuICAgcmV0dXJuIGEgcmFuZ2UgKGxvLCBoaSkgd2hlcmU6XG4gICAtIGxvIGFuZCBoaSBhcmUgY2xvc2UgZW5vdWdoIHRvZ2V0aGVyIGZvciBhIGxpbmVhciBzZWFyY2hcbiAgIC0gSWYgW3ByZWRdIGlzIG5vdCBjb25zdGFudGx5IFtmYWxzZV0gb24gW3RdIGJldHdlZW4gW2xvXSBhbmQgW2hpXSwgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgb24gd2hpY2ggW3ByZWRdIGlzIFt0cnVlXSBpcyBiZXR3ZWVuIFtsb10gYW5kIFtoaV0uICopXG4oKiBJbnZhcmlhbnQ6IHRoZSBmaXJzdCBlbGVtZW50IHNhdGlzZnlpbmcgW3ByZWRdLCBpZiBpdCBleGlzdHMgaXMgYmV0d2VlbiBbbG9dIGFuZCBbaGldICopXG5sZXQgcmVjIGZpbmRfcmFuZ2VfbmVhcl9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG8gfmhpIH5wcmVkID1cbiAgKCogV2FybmluZzogdGhpcyBmdW5jdGlvbiB3aWxsIG5vdCB0ZXJtaW5hdGUgaWYgdGhlIGNvbnN0YW50IChjdXJyZW50bHkgOCkgaXNcbiAgICAgc2V0IDw9IDEgKilcbiAgaWYgaGkgLSBsbyA8PSA4XG4gIHRoZW4gbG8sIGhpXG4gIGVsc2UgKFxuICAgIGxldCBtaWQgPSBsbyArICgoaGkgLSBsbykgLyAyKSBpblxuICAgIGlmIHByZWQgKGdldCB0IG1pZClcbiAgICAoKiBJTlZBUklBTlQgY2hlY2s6IGl0IG1lYW5zIHRoZSBmaXJzdCBzYXRpc2Z5aW5nIGVsZW1lbnQgaXMgYmV0d2VlbiBbbG9dIGFuZCBbbWlkXSAqKVxuICAgIHRoZW5cbiAgICAgIGZpbmRfcmFuZ2VfbmVhcl9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG8gfmhpOm1pZCB+cHJlZFxuICAgICAgKCogSU5WQVJJQU5UIGNoZWNrOiBpdCBtZWFucyB0aGUgZmlyc3Qgc2F0aXNmeWluZyBlbGVtZW50LCBpZiBpdCBleGlzdHMsXG4gICAgICAgICBpcyBiZXR3ZWVuIFttaWQrMV0gYW5kIFtoaV0gKilcbiAgICBlbHNlIGZpbmRfcmFuZ2VfbmVhcl9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG86KG1pZCArIDEpIH5oaSB+cHJlZClcbjs7XG5cbmxldCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkID1cbiAgbGV0IHBvcywgbGVuID1cbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmdldF9wb3NfbGVuX2V4biAoKSA/cG9zID9sZW4gfnRvdGFsX2xlbmd0aDoobGVuZ3RoIHQpXG4gIGluXG4gIGxldCBsbyA9IHBvcyBpblxuICBsZXQgaGkgPSBwb3MgKyBsZW4gLSAxIGluXG4gIGxldCBsbywgaGkgPSBmaW5kX3JhbmdlX25lYXJfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvIH5oaSB+cHJlZCBpblxuICBsaW5lYXJfc2VhcmNoX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbyB+aGkgfnByZWRcbjs7XG5cbigqIFRha2VzIGFuIGFycmF5IHdpdGggc2hhcGUgW3RydWUsLi4udHJ1ZSxmYWxzZSwuLi5mYWxzZV0gKGkuZS4sIHRoZSBfcmV2ZXJzZV8gb2Ygd2hhdFxuICAgaXMgZGVzY3JpYmVkIGFib3ZlKSBhbmQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdHJ1ZSBvciBOb25lIGlmIHRoZXJlIGFyZSBub1xuICAgdHJ1ZSopXG5sZXQgZmluZF9sYXN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfnByZWQgfmdldCB+bGVuZ3RoID1cbiAgbGV0IHBvcywgbGVuID1cbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmdldF9wb3NfbGVuX2V4biAoKSA/cG9zID9sZW4gfnRvdGFsX2xlbmd0aDoobGVuZ3RoIHQpXG4gIGluXG4gIGlmIGxlbiA9IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgICgqIFRoZSBsYXN0IHNhdGlzZnlpbmcgaXMgdGhlIG9uZSBqdXN0IGJlZm9yZSB0aGUgZmlyc3Qgbm90IHNhdGlzZnlpbmcgKilcbiAgICBtYXRjaCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgfnBvcyB+bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihGbi5ub24gcHJlZCkgd2l0aFxuICAgIHwgTm9uZSAtPiBTb21lIChwb3MgKyBsZW4gLSAxKVxuICAgICgqIFRoaXMgbWVhbnMgdGhhdCBhbGwgZWxlbWVudHMgc2F0aXNmeSBwcmVkLlxuICAgICAgIFRoZXJlIGlzIGF0IGxlYXN0IGFuIGVsZW1lbnQgYXMgKGxlbiA+IDApICopXG4gICAgfCBTb21lIGkgd2hlbiBpID0gcG9zIC0+IE5vbmUgKCogbm8gZWxlbWVudCBzYXRpc2ZpZXMgcHJlZCAqKVxuICAgIHwgU29tZSBpIC0+IFNvbWUgKGkgLSAxKSlcbjs7XG5cbmxldCBiaW5hcnlfc2VhcmNoID9wb3MgP2xlbiB0IH5sZW5ndGggfmdldCB+Y29tcGFyZSBob3cgdiA9XG4gIG1hdGNoIGhvdyB3aXRoXG4gIHwgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuIC0+XG4gICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA8IDApXG4gIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5wcmVkOihmdW4geCAtPiBjb21wYXJlIHggdiA8PSAwKVxuICB8IGBGaXJzdF9lcXVhbF90byAtPlxuICAgIChtYXRjaFxuICAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID49IDApXG4gICAgIHdpdGhcbiAgICAgfCBTb21lIHggd2hlbiBjb21wYXJlIChnZXQgdCB4KSB2ID0gMCAtPiBTb21lIHhcbiAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gIHwgYExhc3RfZXF1YWxfdG8gLT5cbiAgICAobWF0Y2hcbiAgICAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDw9IDApXG4gICAgIHdpdGhcbiAgICAgfCBTb21lIHggd2hlbiBjb21wYXJlIChnZXQgdCB4KSB2ID0gMCAtPiBTb21lIHhcbiAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAtPlxuICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID49IDApXG4gIHwgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhbiAtPlxuICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID4gMClcbjs7XG5cbmxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA/cG9zID9sZW4gdCB+bGVuZ3RoIH5nZXQgfnNlZ21lbnRfb2YgaG93ID1cbiAgbGV0IGlzX2xlZnQgeCA9XG4gICAgbWF0Y2ggc2VnbWVudF9vZiB4IHdpdGhcbiAgICB8IGBMZWZ0IC0+IHRydWVcbiAgICB8IGBSaWdodCAtPiBmYWxzZVxuICBpblxuICBsZXQgaXNfcmlnaHQgeCA9IG5vdCAoaXNfbGVmdCB4KSBpblxuICBtYXRjaCBob3cgd2l0aFxuICB8IGBMYXN0X29uX2xlZnQgLT4gZmluZF9sYXN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmxlbmd0aCB+Z2V0IH5wcmVkOmlzX2xlZnRcbiAgfCBgRmlyc3Rfb25fcmlnaHQgLT4gZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5sZW5ndGggfmdldCB+cHJlZDppc19yaWdodFxuOztcbiIsIigqKiBNb2R1bGUgdHlwZXMgZm9yIGEgW2JpbmFyeV9zZWFyY2hdIGZ1bmN0aW9uIGZvciBhIHNlcXVlbmNlLCBhbmQgZnVuY3RvcnMgZm9yIGJ1aWxkaW5nXG4gICAgW2JpbmFyeV9zZWFyY2hdIGZ1bmN0aW9ucy4gKilcblxub3BlbiEgSW1wb3J0XG5cbigqKiBBbiBbSW5kZXhhYmxlXSB0eXBlIGlzIGEgZmluaXRlIHNlcXVlbmNlIG9mIGVsZW1lbnRzIGluZGV4ZWQgYnkgY29uc2VjdXRpdmUgaW50ZWdlcnNcbiAgICBbMF0gLi4uIFtsZW5ndGggdCAtIDFdLiAgW2dldF0gYW5kIFtsZW5ndGhdIG11c3QgYmUgTygxKSBmb3IgdGhlIHJlc3VsdGluZ1xuICAgIFtiaW5hcnlfc2VhcmNoXSB0byBiZSBsZyhuKS4gKilcbm1vZHVsZSB0eXBlIEluZGV4YWJsZSA9IHNpZ1xuICB0eXBlIGVsdFxuICB0eXBlIHRcblxuICB2YWwgZ2V0IDogdCAtPiBpbnQgLT4gZWx0XG4gIHZhbCBsZW5ndGggOiB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSB0eXBlIEluZGV4YWJsZTEgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhXG4gIHZhbCBsZW5ndGggOiBfIHQgLT4gaW50XG5lbmRcblxubW9kdWxlIFdoaWNoX3RhcmdldF9ieV9rZXkgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICBbIGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAoKiogICAgICAgIHt2IHwgPCBlbHQgWCB8ICAgICAgICAgICAgICAgICAgICAgICB2fSAqKVxuICAgIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvICgqKiAgICAge3YgfCAgICAgIDw9IGVsdCAgICAgICBYIHwgICAgICAgICAgIHZ9ICopXG4gICAgfCBgTGFzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgICB7diAgICAgICAgICAgfCAgID0gZWx0IFggfCAgICAgICAgICAgdn0gKilcbiAgICB8IGBGaXJzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8IFggPSBlbHQgICB8ICAgICAgICAgICB2fSAqKVxuICAgIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAoKioge3YgICAgICAgICAgIHwgWCAgICAgICA+PSBlbHQgICAgICB8IHZ9ICopXG4gICAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuICgqKiAgICB7diAgICAgICAgICAgICAgICAgICAgICAgfCBYID4gZWx0IHwgdn0gKilcbiAgICBdXG4gIFtAQGRlcml2aW5nX2lubGluZSBlbnVtZXJhdGVdXG5cbiAgbGV0IGFsbCA9XG4gICAgKFsgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuXG4gICAgIDsgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvXG4gICAgIDsgYExhc3RfZXF1YWxfdG9cbiAgICAgOyBgRmlyc3RfZXF1YWxfdG9cbiAgICAgOyBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvXG4gICAgIDsgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhblxuICAgICBdXG4gICAgIDogdCBsaXN0KVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIFdoaWNoX3RhcmdldF9ieV9zZWdtZW50ID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgWyBgTGFzdF9vbl9sZWZ0XG4gICAgfCBgRmlyc3Rfb25fcmlnaHRcbiAgICBdXG4gIFtAQGRlcml2aW5nX2lubGluZSBlbnVtZXJhdGVdXG5cbiAgbGV0IGFsbCA9IChbIGBMYXN0X29uX2xlZnQ7IGBGaXJzdF9vbl9yaWdodCBdIDogdCBsaXN0KVxuXG4gIFtAQEBlbmRdXG5lbmRcblxudHlwZSAoJ3QsICdlbHQsICdrZXkpIGJpbmFyeV9zZWFyY2ggPVxuICA/cG9zOmludFxuICAtPiA/bGVuOmludFxuICAtPiAndFxuICAtPiBjb21wYXJlOignZWx0IC0+ICdrZXkgLT4gaW50KVxuICAtPiBXaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgLT4gJ2tleVxuICAtPiBpbnQgb3B0aW9uXG5cbnR5cGUgKCd0LCAnZWx0KSBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA9XG4gID9wb3M6aW50XG4gIC0+ID9sZW46aW50XG4gIC0+ICd0XG4gIC0+IHNlZ21lbnRfb2Y6KCdlbHQgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAtPiBXaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gIC0+IGludCBvcHRpb25cblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIGVsdFxuICB0eXBlIHRcblxuICAoKiogU2VlIFtCaW5hcnlfc2VhcmNoLmJpbmFyeV9zZWFyY2hdIGluIGJpbmFyeV9zZWFyY2gubWwgKilcbiAgdmFsIGJpbmFyeV9zZWFyY2ggOiAodCwgZWx0LCAna2V5KSBiaW5hcnlfc2VhcmNoXG5cbiAgKCoqIFNlZSBbQmluYXJ5X3NlYXJjaC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZF0gaW4gYmluYXJ5X3NlYXJjaC5tbCAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgOiAodCwgZWx0KSBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMxID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoIDogKCdhIHQsICdhLCAna2V5KSBiaW5hcnlfc2VhcmNoXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA6ICgnYSB0LCAnYSkgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbmVuZFxuXG5tb2R1bGUgdHlwZSBCaW5hcnlfc2VhcmNoYWJsZSA9IHNpZ1xuICBtb2R1bGUgdHlwZSBTID0gU1xuICBtb2R1bGUgdHlwZSBTMSA9IFMxXG4gIG1vZHVsZSB0eXBlIEluZGV4YWJsZSA9IEluZGV4YWJsZVxuICBtb2R1bGUgdHlwZSBJbmRleGFibGUxID0gSW5kZXhhYmxlMVxuXG4gIG1vZHVsZSBXaGljaF90YXJnZXRfYnlfa2V5ID0gV2hpY2hfdGFyZ2V0X2J5X2tleVxuICBtb2R1bGUgV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQgPSBXaGljaF90YXJnZXRfYnlfc2VnbWVudFxuXG4gIHR5cGUgbm9ucmVjICgndCwgJ2VsdCwgJ2tleSkgYmluYXJ5X3NlYXJjaCA9ICgndCwgJ2VsdCwgJ2tleSkgYmluYXJ5X3NlYXJjaFxuICB0eXBlIG5vbnJlYyAoJ3QsICdlbHQpIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkID0gKCd0LCAnZWx0KSBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuXG4gIG1vZHVsZSBNYWtlIChUIDogSW5kZXhhYmxlKSA6IFMgd2l0aCB0eXBlIHQgOj0gVC50IHdpdGggdHlwZSBlbHQgOj0gVC5lbHRcbiAgbW9kdWxlIE1ha2UxIChUIDogSW5kZXhhYmxlMSkgOiBTMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBULnRcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEJpbmFyeV9zZWFyY2hhYmxlX2ludGZcblxubW9kdWxlIHR5cGUgQXJnID0gc2lnXG4gIHR5cGUgJ2EgZWx0XG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBnZXQgOiAnYSB0IC0+IGludCAtPiAnYSBlbHRcbiAgdmFsIGxlbmd0aCA6IF8gdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgTWFrZV9nZW4gKFQgOiBBcmcpID0gc3RydWN0XG4gIGxldCBnZXQgPSBULmdldFxuICBsZXQgbGVuZ3RoID0gVC5sZW5ndGhcblxuICBsZXQgYmluYXJ5X3NlYXJjaCA/cG9zID9sZW4gdCB+Y29tcGFyZSBob3cgdiA9XG4gICAgQmluYXJ5X3NlYXJjaC5iaW5hcnlfc2VhcmNoID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+Y29tcGFyZSBob3cgdlxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA/cG9zID9sZW4gdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIEJpbmFyeV9zZWFyY2guYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5zZWdtZW50X29mIGhvd1xuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlIChUIDogSW5kZXhhYmxlKSA9IE1ha2VfZ2VuIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIHR5cGUgJ2EgZWx0ID0gVC5lbHRcbiAgICB0eXBlICdhIHQgPSBULnRcbiAgZW5kKVxuXG5tb2R1bGUgTWFrZTEgKFQgOiBJbmRleGFibGUxKSA9IE1ha2VfZ2VuIChzdHJ1Y3RcbiAgICB0eXBlICdhIGVsdCA9ICdhXG4gICAgdHlwZSAnYSB0ID0gJ2EgVC50XG5cbiAgICBsZXQgZ2V0ID0gVC5nZXRcbiAgICBsZXQgbGVuZ3RoID0gVC5sZW5ndGhcbiAgZW5kKVxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEJsaXRfaW50ZlxuXG5tb2R1bGUgdHlwZSBTZXF1ZW5jZV9nZW4gPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGxlbmd0aCA6IF8gdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgTWFrZV9nZW5cbiAgICAoU3JjIDogU2VxdWVuY2VfZ2VuKSAoRHN0IDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZSBTZXF1ZW5jZV9nZW5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCBjcmVhdGVfbGlrZSA6IGxlbjppbnQgLT4gJ2EgU3JjLnQgLT4gJ2EgdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCB1bnNhZmVfYmxpdCA6ICgnYSBTcmMudCwgJ2EgdCkgYmxpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQpID1cbnN0cnVjdFxuICBsZXQgdW5zYWZlX2JsaXQgPSBEc3QudW5zYWZlX2JsaXRcblxuICBsZXQgYmxpdCB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4blxuICAgICAgfnBvczpzcmNfcG9zXG4gICAgICB+bGVuXG4gICAgICB+dG90YWxfbGVuZ3RoOihTcmMubGVuZ3RoIHNyYyk7XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4blxuICAgICAgfnBvczpkc3RfcG9zXG4gICAgICB+bGVuXG4gICAgICB+dG90YWxfbGVuZ3RoOihEc3QubGVuZ3RoIGRzdCk7XG4gICAgaWYgbGVuID4gMCB0aGVuIHVuc2FmZV9ibGl0IH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuXG4gIDs7XG5cbiAgbGV0IGJsaXRvXG4gICAgICAgIH5zcmNcbiAgICAgICAgPyhzcmNfcG9zID0gMClcbiAgICAgICAgPyhzcmNfbGVuID0gU3JjLmxlbmd0aCBzcmMgLSBzcmNfcG9zKVxuICAgICAgICB+ZHN0XG4gICAgICAgID8oZHN0X3BvcyA9IDApXG4gICAgICAgICgpXG4gICAgPVxuICAgIGJsaXQgfnNyYyB+c3JjX3BvcyB+bGVuOnNyY19sZW4gfmRzdCB+ZHN0X3Bvc1xuICA7O1xuXG4gICgqIFtzdWJdIGFuZCBbc3Vib10gZW5zdXJlIHRoYXQgZXZlcnkgcG9zaXRpb24gb2YgdGhlIGNyZWF0ZWQgc2VxdWVuY2UgaXMgcG9wdWxhdGVkIGJ5XG4gICAgIGFuIGVsZW1lbnQgb2YgdGhlIHNvdXJjZSBhcnJheS4gIFRodXMgZXZlcnkgZWxlbWVudCBvZiBbZHN0XSBiZWxvdyBpcyB3ZWxsXG4gICAgIGRlZmluZWQuICopXG4gIGxldCBzdWIgc3JjIH5wb3MgfmxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDooU3JjLmxlbmd0aCBzcmMpO1xuICAgIGxldCBkc3QgPSBEc3QuY3JlYXRlX2xpa2UgfmxlbiBzcmMgaW5cbiAgICBpZiBsZW4gPiAwIHRoZW4gdW5zYWZlX2JsaXQgfnNyYyB+c3JjX3Bvczpwb3MgfmRzdCB+ZHN0X3BvczowIH5sZW47XG4gICAgZHN0XG4gIDs7XG5cbiAgbGV0IHN1Ym8gPyhwb3MgPSAwKSA/bGVuIHNyYyA9XG4gICAgc3ViXG4gICAgICBzcmNcbiAgICAgIH5wb3NcbiAgICAgIH5sZW46XG4gICAgICAgIChtYXRjaCBsZW4gd2l0aFxuICAgICAgICAgfCBTb21lIGkgLT4gaVxuICAgICAgICAgfCBOb25lIC0+IFNyYy5sZW5ndGggc3JjIC0gcG9zKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlMSAoU2VxdWVuY2UgOiBzaWdcbiAgICBpbmNsdWRlIFNlcXVlbmNlX2dlblxuXG4gICAgdmFsIGNyZWF0ZV9saWtlIDogbGVuOmludCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgdW5zYWZlX2JsaXQgOiAoJ2EgdCwgJ2EgdCkgYmxpdFxuICBlbmQpID1cbiAgTWFrZV9nZW4gKFNlcXVlbmNlKSAoU2VxdWVuY2UpXG5cbm1vZHVsZSBNYWtlMV9nZW5lcmljIChTZXF1ZW5jZSA6IFNlcXVlbmNlMSkgPSBNYWtlX2dlbiAoU2VxdWVuY2UpIChTZXF1ZW5jZSlcblxubW9kdWxlIE1ha2UgKFNlcXVlbmNlIDogc2lnXG4gICAgaW5jbHVkZSBTZXF1ZW5jZVxuXG4gICAgdmFsIGNyZWF0ZSA6IGxlbjppbnQgLT4gdFxuICAgIHZhbCB1bnNhZmVfYmxpdCA6ICh0LCB0KSBibGl0XG4gIGVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBTZXF1ZW5jZSA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9IFNlcXVlbmNlLnRcblxuICAgIG9wZW4gU2VxdWVuY2VcblxuICAgIGxldCBjcmVhdGVfbGlrZSB+bGVuIF8gPSBjcmVhdGUgfmxlblxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuICBlbmRcblxuICBpbmNsdWRlIE1ha2VfZ2VuIChTZXF1ZW5jZSkgKFNlcXVlbmNlKVxuZW5kXG5cbm1vZHVsZSBNYWtlX2Rpc3RpbmN0XG4gICAgKFNyYyA6IFNlcXVlbmNlKSAoRHN0IDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlIFNlcXVlbmNlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCBjcmVhdGUgOiBsZW46aW50IC0+IHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCB1bnNhZmVfYmxpdCA6IChTcmMudCwgdCkgYmxpdFxuICAgICAgICAgICAgICAgICAgICAgIGVuZCkgPVxuICBNYWtlX2dlblxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IFNyYy50XG5cbiAgICAgIG9wZW4gU3JjXG5cbiAgICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gRHN0LnRcblxuICAgICAgb3BlbiBEc3RcblxuICAgICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgICAgbGV0IGNyZWF0ZV9saWtlIH5sZW4gXyA9IGNyZWF0ZSB+bGVuXG4gICAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuICAgIGVuZClcblxubW9kdWxlIE1ha2VfdG9fc3RyaW5nIChUIDogc2lnXG4gICAgdHlwZSB0XG4gIGVuZClcbiAgICAoVG9fYnl0ZXMgOiBTX2Rpc3RpbmN0IHdpdGggdHlwZSBzcmMgOj0gVC50IHdpdGggdHlwZSBkc3QgOj0gYnl0ZXMpID1cbnN0cnVjdFxuICBvcGVuIFRvX2J5dGVzXG5cbiAgbGV0IHN1YiBzcmMgfnBvcyB+bGVuID1cbiAgICBCeXRlczAudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTooc3ViIHNyYyB+cG9zIH5sZW4pXG4gIDs7XG5cbiAgbGV0IHN1Ym8gP3BvcyA/bGVuIHNyYyA9XG4gICAgQnl0ZXMwLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6KHN1Ym8gP3BvcyA/bGVuIHNyYylcbiAgOztcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbmluY2x1ZGUgKFxuc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIG9wdGlvbiBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPSBjb21wYXJlX29wdGlvblxuXG4gIGxldCBoYXNoX2ZvbGRfdCA6XG4gICAgJ2EuXG4gICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiAnYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgLT4gJ2EgdFxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgID1cbiAgICBoYXNoX2ZvbGRfb3B0aW9uXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9XG4gICAgb3B0aW9uX29mX3NleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBzZXhwX29mX29wdGlvblxuICA7O1xuXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gb3B0aW9uX3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZCA6XG5zaWdcbiAgdHlwZSAnYSB0ID0gJ2Egb3B0aW9uIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gIGluY2x1ZGUgUHB4X2hhc2hfbGliLkhhc2hhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgdmFsIHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIFtAQEBlbmRdXG5lbmQpXG5cbnR5cGUgJ2EgdCA9ICdhIG9wdGlvbiA9XG4gIHwgTm9uZVxuICB8IFNvbWUgb2YgJ2FcblxubGV0IGlzX25vbmUgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19zb21lID0gZnVuY3Rpb25cbiAgfCBTb21lIF8gLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCB2YWx1ZV9tYXAgbyB+ZGVmYXVsdCB+ZiA9XG4gIG1hdGNoIG8gd2l0aFxuICB8IFNvbWUgeCAtPiBmIHhcbiAgfCBOb25lIC0+IGRlZmF1bHRcbjs7XG5cbmxldCBpdGVyIG8gfmYgPVxuICBtYXRjaCBvIHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBhIC0+IGYgYVxuOztcblxubGV0IGludmFyaWFudCBmIHQgPSBpdGVyIHQgfmZcblxubGV0IGNhbGwgeCB+ZiA9XG4gIG1hdGNoIGYgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGYgLT4gZiB4XG47O1xuXG5sZXQgdmFsdWUgdCB+ZGVmYXVsdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gZGVmYXVsdFxuICB8IFNvbWUgeCAtPiB4XG47O1xuXG5sZXQgdmFsdWVfZXhuID9oZXJlID9lcnJvciA/bWVzc2FnZSB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU29tZSB4IC0+IHhcbiAgfCBOb25lIC0+XG4gICAgbGV0IGVycm9yID1cbiAgICAgIG1hdGNoIGhlcmUsIGVycm9yLCBtZXNzYWdlIHdpdGhcbiAgICAgIHwgTm9uZSwgTm9uZSwgTm9uZSAtPiBFcnJvci5vZl9zdHJpbmcgXCJPcHRpb24udmFsdWVfZXhuIE5vbmVcIlxuICAgICAgfCBOb25lLCBOb25lLCBTb21lIG0gLT4gRXJyb3Iub2Zfc3RyaW5nIG1cbiAgICAgIHwgTm9uZSwgU29tZSBlLCBOb25lIC0+IGVcbiAgICAgIHwgTm9uZSwgU29tZSBlLCBTb21lIG0gLT4gRXJyb3IudGFnIGUgfnRhZzptXG4gICAgICB8IFNvbWUgcCwgTm9uZSwgTm9uZSAtPlxuICAgICAgICBFcnJvci5jcmVhdGUgXCJPcHRpb24udmFsdWVfZXhuXCIgcCBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90XG4gICAgICB8IFNvbWUgcCwgTm9uZSwgU29tZSBtIC0+IEVycm9yLmNyZWF0ZSBtIHAgU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdFxuICAgICAgfCBTb21lIHAsIFNvbWUgZSwgXyAtPlxuICAgICAgICBFcnJvci5jcmVhdGVcbiAgICAgICAgICAodmFsdWUgbWVzc2FnZSB+ZGVmYXVsdDpcIlwiKVxuICAgICAgICAgIChlLCBwKVxuICAgICAgICAgIChzZXhwX29mX3BhaXIgRXJyb3Iuc2V4cF9vZl90IFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3QpXG4gICAgaW5cbiAgICBFcnJvci5yYWlzZSBlcnJvclxuOztcblxubGV0IHZhbHVlX29yX3RodW5rIG8gfmRlZmF1bHQgPVxuICBtYXRjaCBvIHdpdGhcbiAgfCBTb21lIHggLT4geFxuICB8IE5vbmUgLT4gZGVmYXVsdCAoKVxuOztcblxubGV0IHRvX2FycmF5IHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IFt8fF1cbiAgfCBTb21lIHggLT4gW3wgeCB8XVxuOztcblxubGV0IHRvX2xpc3QgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gW11cbiAgfCBTb21lIHggLT4gWyB4IF1cbjs7XG5cbmxldCBtaW5fZWx0IHQgfmNvbXBhcmU6XyA9IHRcbmxldCBtYXhfZWx0IHQgfmNvbXBhcmU6XyA9IHRcblxubGV0IHN1bSAodHlwZSBhKSAobW9kdWxlIE0gOiBDb250YWluZXIuU3VtbWFibGUgd2l0aCB0eXBlIHQgPSBhKSB0IH5mID1cbiAgdmFsdWVfbWFwIHQgfmRlZmF1bHQ6TS56ZXJvIH5mXG47O1xuXG5sZXQgZm9yX2FsbCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiB0cnVlXG4gIHwgU29tZSB4IC0+IGYgeFxuOztcblxubGV0IGV4aXN0cyB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBmYWxzZVxuICB8IFNvbWUgeCAtPiBmIHhcbjs7XG5cbmxldCBtZW0gdCBhIH5lcXVhbCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gZmFsc2VcbiAgfCBTb21lIGEnIC0+IGVxdWFsIGEgYSdcbjs7XG5cbmxldCBsZW5ndGggdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gMFxuICB8IFNvbWUgXyAtPiAxXG47O1xuXG5sZXQgaXNfZW1wdHkgPSBpc19ub25lXG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IGluaXRcbiAgfCBTb21lIHggLT4gZiBpbml0IHhcbjs7XG5cbmxldCBjb3VudCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiAwXG4gIHwgU29tZSBhIC0+IGlmIGYgYSB0aGVuIDEgZWxzZSAwXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSB4IC0+IGlmIGYgeCB0aGVuIHQgZWxzZSBOb25lXG47O1xuXG5sZXQgZmluZF9tYXAgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgYSAtPiBmIGFcbjs7XG5cbmxldCBlcXVhbCBmIHQgdCcgPVxuICBtYXRjaCB0LCB0JyB3aXRoXG4gIHwgTm9uZSwgTm9uZSAtPiB0cnVlXG4gIHwgU29tZSB4LCBTb21lIHgnIC0+IGYgeCB4J1xuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBzb21lIHggPSBTb21lIHhcblxubGV0IGZpcnN0X3NvbWUgeCB5ID1cbiAgbWF0Y2ggeCB3aXRoXG4gIHwgU29tZSBfIC0+IHhcbiAgfCBOb25lIC0+IHlcbjs7XG5cbmxldCBzb21lX2lmIGNvbmQgeCA9IGlmIGNvbmQgdGhlbiBTb21lIHggZWxzZSBOb25lXG5cbmxldCBtZXJnZSBhIGIgfmYgPVxuICBtYXRjaCBhLCBiIHdpdGhcbiAgfCBOb25lLCB4IHwgeCwgTm9uZSAtPiB4XG4gIHwgU29tZSBhLCBTb21lIGIgLT4gU29tZSAoZiBhIGIpXG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTb21lIHYgYXMgbyB3aGVuIGYgdiAtPiBvXG4gIHwgXyAtPiBOb25lXG47O1xuXG5sZXQgdHJ5X3dpdGggZiA9XG4gIG1hdGNoIGYgKCkgd2l0aFxuICB8IHggLT4gU29tZSB4XG4gIHwgZXhjZXB0aW9uIF8gLT4gTm9uZVxuOztcblxubGV0IHRyeV93aXRoX2pvaW4gZiA9XG4gIG1hdGNoIGYgKCkgd2l0aFxuICB8IHggLT4geFxuICB8IGV4Y2VwdGlvbiBfIC0+IE5vbmVcbjs7XG5cbmxldCBtYXAgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgYSAtPiBTb21lIChmIGEpXG47O1xuXG5sZXQgYXBwbHkgZiB4ID1cbiAgbWF0Y2ggZiB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBmIC0+IG1hcCB+ZiB4XG47O1xuXG5tb2R1bGUgTW9uYWRfYXJnID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIG9wdGlvblxuXG4gIGxldCByZXR1cm4geCA9IFNvbWUgeFxuICBsZXQgYXBwbHkgPSBhcHBseVxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcblxuICBsZXQgYmluZCBvIH5mID1cbiAgICBtYXRjaCBvIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSB4IC0+IGYgeFxuICA7O1xuZW5kXG5cbmluY2x1ZGUgTW9uYWQuTWFrZSAoTW9uYWRfYXJnKVxuaW5jbHVkZSBBcHBsaWNhdGl2ZS5NYWtlIChNb25hZF9hcmcpXG5cbmxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbmxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB0XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgU2V4cGxpYjAuU2V4cGFibGVcblxubW9kdWxlIE9mX3NleHBhYmxlXG4gICAgKFNleHBhYmxlIDogUykgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlIHRcblxuICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19zZXhwYWJsZSA6IHQgLT4gU2V4cGFibGUudFxuICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9zZXhwYWJsZSA6IFNleHBhYmxlLnQgLT4gdFxuICAgICAgICAgICAgICAgICAgICBlbmQpIDogUyB3aXRoIHR5cGUgdCA6PSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBzZXhwID1cbiAgICBsZXQgcyA9IFNleHBhYmxlLnRfb2Zfc2V4cCBzZXhwIGluXG4gICAgdHJ5IE0ub2Zfc2V4cGFibGUgcyB3aXRoXG4gICAgfCBleG4gLT4gb2Zfc2V4cF9lcnJvcl9leG4gZXhuIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHQgPSBTZXhwYWJsZS5zZXhwX29mX3QgKE0udG9fc2V4cGFibGUgdClcbmVuZFxuXG5tb2R1bGUgT2Zfc2V4cGFibGUxXG4gICAgKFNleHBhYmxlIDogUzEpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGUgJ2EgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19zZXhwYWJsZSA6ICdhIHQgLT4gJ2EgU2V4cGFibGUudFxuICAgICAgICAgICAgICAgICAgICAgICB2YWwgb2Zfc2V4cGFibGUgOiAnYSBTZXhwYWJsZS50IC0+ICdhIHRcbiAgICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCA9XG4gICAgbGV0IHMgPSBTZXhwYWJsZS50X29mX3NleHAgYV9vZl9zZXhwIHNleHAgaW5cbiAgICB0cnkgTS5vZl9zZXhwYWJsZSBzIHdpdGhcbiAgICB8IGV4biAtPiBvZl9zZXhwX2Vycm9yX2V4biBleG4gc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSBTZXhwYWJsZS5zZXhwX29mX3Qgc2V4cF9vZl9hIChNLnRvX3NleHBhYmxlIHQpXG5lbmRcblxubW9kdWxlIE9mX3NleHBhYmxlMlxuICAgIChTZXhwYWJsZSA6IFMyKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgICAgICAgICAgICAgICAgICAgICB2YWwgdG9fc2V4cGFibGUgOiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIFNleHBhYmxlLnRcbiAgICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX3NleHBhYmxlIDogKCdhLCAnYikgU2V4cGFibGUudCAtPiAoJ2EsICdiKSB0XG4gICAgICAgICAgICAgICAgICAgICBlbmQpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgTS50ID0gc3RydWN0XG4gIGxldCB0X29mX3NleHAgYV9vZl9zZXhwIGJfb2Zfc2V4cCBzZXhwID1cbiAgICBsZXQgcyA9IFNleHBhYmxlLnRfb2Zfc2V4cCBhX29mX3NleHAgYl9vZl9zZXhwIHNleHAgaW5cbiAgICB0cnkgTS5vZl9zZXhwYWJsZSBzIHdpdGhcbiAgICB8IGV4biAtPiBvZl9zZXhwX2Vycm9yX2V4biBleG4gc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHNleHBfb2ZfYiB0ID1cbiAgICBTZXhwYWJsZS5zZXhwX29mX3Qgc2V4cF9vZl9hIHNleHBfb2ZfYiAoTS50b19zZXhwYWJsZSB0KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBPZl9zZXhwYWJsZTNcbiAgICAoU2V4cGFibGUgOiBTMykgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19zZXhwYWJsZSA6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSBTZXhwYWJsZS50XG4gICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9zZXhwYWJsZSA6ICgnYSwgJ2IsICdjKSBTZXhwYWJsZS50IC0+ICgnYSwgJ2IsICdjKSB0XG4gICAgICAgICAgICAgICAgICAgICBlbmQpIDogUzMgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgYl9vZl9zZXhwIGNfb2Zfc2V4cCBzZXhwID1cbiAgICBsZXQgcyA9IFNleHBhYmxlLnRfb2Zfc2V4cCBhX29mX3NleHAgYl9vZl9zZXhwIGNfb2Zfc2V4cCBzZXhwIGluXG4gICAgdHJ5IE0ub2Zfc2V4cGFibGUgcyB3aXRoXG4gICAgfCBleG4gLT4gb2Zfc2V4cF9lcnJvcl9leG4gZXhuIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSBzZXhwX29mX2Igc2V4cF9vZl9jIHQgPVxuICAgIFNleHBhYmxlLnNleHBfb2ZfdCBzZXhwX29mX2Egc2V4cF9vZl9iIHNleHBfb2ZfYyAoTS50b19zZXhwYWJsZSB0KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBPZl9zdHJpbmdhYmxlIChNIDogU3RyaW5nYWJsZS5TKSA6IFMgd2l0aCB0eXBlIHQgOj0gTS50ID0gc3RydWN0XG4gIGxldCB0X29mX3NleHAgc2V4cCA9XG4gICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgfCBTZXhwLkF0b20gcyAtPlxuICAgICAgKHRyeSBNLm9mX3N0cmluZyBzIHdpdGhcbiAgICAgICB8IGV4biAtPiBvZl9zZXhwX2Vycm9yX2V4biBleG4gc2V4cClcbiAgICB8IFNleHAuTGlzdCBfIC0+XG4gICAgICBvZl9zZXhwX2Vycm9yXG4gICAgICAgIFwiU2V4cGFibGUuT2Zfc3RyaW5nYWJsZS50X29mX3NleHAgZXhwZWN0ZWQgYW4gYXRvbSwgYnV0IGdvdCBhIGxpc3RcIlxuICAgICAgICBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCB0ID0gU2V4cC5BdG9tIChNLnRvX3N0cmluZyB0KVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgRWl0aGVyX2ludGZcbm1vZHVsZSBMaXN0ID0gTGlzdDBcbmluY2x1ZGUgRWl0aGVyMFxuXG5sZXQgc3dhcCA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgeCAtPiBTZWNvbmQgeFxuICB8IFNlY29uZCB4IC0+IEZpcnN0IHhcbjs7XG5cbmxldCBpc19maXJzdCA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgXyAtPiB0cnVlXG4gIHwgU2Vjb25kIF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19zZWNvbmQgPSBmdW5jdGlvblxuICB8IEZpcnN0IF8gLT4gZmFsc2VcbiAgfCBTZWNvbmQgXyAtPiB0cnVlXG47O1xuXG5sZXQgdmFsdWUgKEZpcnN0IHggfCBTZWNvbmQgeCkgPSB4XG5cbmxldCB2YWx1ZV9tYXAgdCB+Zmlyc3QgfnNlY29uZCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEZpcnN0IHggLT4gZmlyc3QgeFxuICB8IFNlY29uZCB4IC0+IHNlY29uZCB4XG47O1xuXG5sZXQgaXRlciA9IHZhbHVlX21hcFxuXG5sZXQgbWFwIHQgfmZpcnN0IH5zZWNvbmQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBGaXJzdCB4IC0+IEZpcnN0IChmaXJzdCB4KVxuICB8IFNlY29uZCB4IC0+IFNlY29uZCAoc2Vjb25kIHgpXG47O1xuXG5sZXQgZmlyc3QgeCA9IEZpcnN0IHhcbmxldCBzZWNvbmQgeCA9IFNlY29uZCB4XG5cbmxldCBlcXVhbCBlcTEgZXEyIHQxIHQyID1cbiAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgfCBGaXJzdCB4LCBGaXJzdCB5IC0+IGVxMSB4IHlcbiAgfCBTZWNvbmQgeCwgU2Vjb25kIHkgLT4gZXEyIHggeVxuICB8IEZpcnN0IF8sIFNlY29uZCBfIHwgU2Vjb25kIF8sIEZpcnN0IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpbnZhcmlhbnQgZiBzID0gZnVuY3Rpb25cbiAgfCBGaXJzdCB4IC0+IGYgeFxuICB8IFNlY29uZCB5IC0+IHMgeVxuOztcblxubW9kdWxlIE1ha2VfZm9jdXNlZCAoTSA6IHNpZ1xuICAgIHR5cGUgKCsnYSwgKydiKSB0XG5cbiAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfKSB0XG4gICAgdmFsIG90aGVyIDogJ2IgLT4gKF8sICdiKSB0XG4gICAgdmFsIGVpdGhlciA6ICgnYSwgJ2IpIHQgLT4gcmV0dXJuOignYSAtPiAnYykgLT4gb3RoZXI6KCdiIC0+ICdjKSAtPiAnY1xuXG4gICAgdmFsIGNvbWJpbmVcbiAgICAgIDogICgnYSwgJ2QpIHRcbiAgICAgIC0+ICgnYiwgJ2QpIHRcbiAgICAgIC0+IGY6KCdhIC0+ICdiIC0+ICdjKVxuICAgICAgLT4gb3RoZXI6KCdkIC0+ICdkIC0+ICdkKVxuICAgICAgLT4gKCdjLCAnZCkgdFxuXG4gICAgdmFsIGJpbmQgOiAoJ2EsICdiKSB0IC0+IGY6KCdhIC0+ICgnYywgJ2IpIHQpIC0+ICgnYywgJ2IpIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBNXG4gIG9wZW4gV2l0aF9yZXR1cm5cblxuICBsZXQgbWFwIHQgfmYgPSBiaW5kIHQgfmY6KGZ1biB4IC0+IHJldHVybiAoZiB4KSlcblxuICBpbmNsdWRlIE1vbmFkLk1ha2UyIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG5cbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgIGxldCBiaW5kID0gYmluZFxuICAgICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gICAgZW5kKVxuXG4gIG1vZHVsZSBBcHAgPSBBcHBsaWNhdGl2ZS5NYWtlMiAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuXG4gICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICBsZXQgYXBwbHkgdDEgdDIgPSBiaW5kIHQxIH5mOihmdW4gZiAtPiBiaW5kIHQyIH5mOihmdW4geCAtPiByZXR1cm4gKGYgeCkpKVxuICAgICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gICAgZW5kKVxuXG4gIGluY2x1ZGUgQXBwXG5cbiAgbGV0IGNvbWJpbmVfYWxsID1cbiAgICBsZXQgcmVjIG90aGVyX2xvb3AgZiBhY2MgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBvdGhlciBhY2NcbiAgICAgIHwgdCA6OiB0cyAtPlxuICAgICAgICBlaXRoZXJcbiAgICAgICAgICB0XG4gICAgICAgICAgfnJldHVybjooZnVuIF8gLT4gb3RoZXJfbG9vcCBmIGFjYyB0cylcbiAgICAgICAgICB+b3RoZXI6KGZ1biBvIC0+IG90aGVyX2xvb3AgZiAoZiBhY2MgbykgdHMpXG4gICAgaW5cbiAgICBsZXQgcmVjIHJldHVybl9sb29wIGYgYWNjID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuIChMaXN0LnJldiBhY2MpXG4gICAgICB8IHQgOjogdHMgLT5cbiAgICAgICAgZWl0aGVyXG4gICAgICAgICAgdFxuICAgICAgICAgIH5yZXR1cm46KGZ1biB4IC0+IHJldHVybl9sb29wIGYgKHggOjogYWNjKSB0cylcbiAgICAgICAgICB+b3RoZXI6KGZ1biBvIC0+IG90aGVyX2xvb3AgZiBvIHRzKVxuICAgIGluXG4gICAgZnVuIHRzIH5mIC0+IHJldHVybl9sb29wIGYgW10gdHNcbiAgOztcblxuICBsZXQgY29tYmluZV9hbGxfdW5pdCA9XG4gICAgbGV0IHJlYyBvdGhlcl9sb29wIGYgYWNjID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gb3RoZXIgYWNjXG4gICAgICB8IHQgOjogdHMgLT5cbiAgICAgICAgZWl0aGVyXG4gICAgICAgICAgdFxuICAgICAgICAgIH5yZXR1cm46KGZ1biAoKSAtPiBvdGhlcl9sb29wIGYgYWNjIHRzKVxuICAgICAgICAgIH5vdGhlcjooZnVuIG8gLT4gb3RoZXJfbG9vcCBmIChmIGFjYyBvKSB0cylcbiAgICBpblxuICAgIGxldCByZWMgcmV0dXJuX2xvb3AgZiA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IHJldHVybiAoKVxuICAgICAgfCB0IDo6IHRzIC0+XG4gICAgICAgIGVpdGhlciB0IH5yZXR1cm46KGZ1biAoKSAtPiByZXR1cm5fbG9vcCBmIHRzKSB+b3RoZXI6KGZ1biBvIC0+IG90aGVyX2xvb3AgZiBvIHRzKVxuICAgIGluXG4gICAgZnVuIHRzIH5mIC0+IHJldHVybl9sb29wIGYgdHNcbiAgOztcblxuICBsZXQgdG9fb3B0aW9uIHQgPSBlaXRoZXIgdCB+cmV0dXJuOk9wdGlvbi5zb21lIH5vdGhlcjooZnVuIF8gLT4gTm9uZSlcbiAgbGV0IHZhbHVlIHQgfmRlZmF1bHQgPSBlaXRoZXIgdCB+cmV0dXJuOkZuLmlkIH5vdGhlcjooZnVuIF8gLT4gZGVmYXVsdClcblxuICBsZXQgd2l0aF9yZXR1cm4gZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByZXQgLT4gb3RoZXIgKGYgKFdpdGhfcmV0dXJuLnByZXBlbmQgcmV0IH5mOnJldHVybikpKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBGaXJzdCA9IE1ha2VfZm9jdXNlZCAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcblxuICAgIGxldCByZXR1cm4gPSBmaXJzdFxuICAgIGxldCBvdGhlciA9IHNlY29uZFxuXG4gICAgbGV0IGVpdGhlciB0IH5yZXR1cm4gfm90aGVyID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBGaXJzdCB4IC0+IHJldHVybiB4XG4gICAgICB8IFNlY29uZCB5IC0+IG90aGVyIHlcbiAgICA7O1xuXG4gICAgbGV0IGNvbWJpbmUgdDEgdDIgfmYgfm90aGVyID1cbiAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICB8IEZpcnN0IHgsIEZpcnN0IHkgLT4gRmlyc3QgKGYgeCB5KVxuICAgICAgfCBTZWNvbmQgeCwgU2Vjb25kIHkgLT4gU2Vjb25kIChvdGhlciB4IHkpXG4gICAgICB8IFNlY29uZCB4LCBfIHwgXywgU2Vjb25kIHggLT4gU2Vjb25kIHhcbiAgICA7O1xuXG4gICAgbGV0IGJpbmQgdCB+ZiA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRmlyc3QgeCAtPiBmIHhcbiAgICAgICgqIFJldXNlIHRoZSB2YWx1ZSBpbiBvcmRlciB0byBhdm9pZCBhbGxvY2F0aW9uLiAqKVxuICAgICAgfCBTZWNvbmQgXyBhcyB5IC0+IHlcbiAgICA7O1xuICBlbmQpXG5cbm1vZHVsZSBTZWNvbmQgPSBNYWtlX2ZvY3VzZWQgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2IsICdhKSB0XG5cbiAgICBsZXQgcmV0dXJuID0gc2Vjb25kXG4gICAgbGV0IG90aGVyID0gZmlyc3RcblxuICAgIGxldCBlaXRoZXIgdCB+cmV0dXJuIH5vdGhlciA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgU2Vjb25kIHkgLT4gcmV0dXJuIHlcbiAgICAgIHwgRmlyc3QgeCAtPiBvdGhlciB4XG4gICAgOztcblxuICAgIGxldCBjb21iaW5lIHQxIHQyIH5mIH5vdGhlciA9XG4gICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgfCBTZWNvbmQgeCwgU2Vjb25kIHkgLT4gU2Vjb25kIChmIHggeSlcbiAgICAgIHwgRmlyc3QgeCwgRmlyc3QgeSAtPiBGaXJzdCAob3RoZXIgeCB5KVxuICAgICAgfCBGaXJzdCB4LCBfIHwgXywgRmlyc3QgeCAtPiBGaXJzdCB4XG4gICAgOztcblxuICAgIGxldCBiaW5kIHQgfmYgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFNlY29uZCB4IC0+IGYgeFxuICAgICAgKCogUmV1c2UgdGhlIHZhbHVlIGluIG9yZGVyIHRvIGF2b2lkIGFsbG9jYXRpb24sIGxpa2UgW0ZpcnN0LmJpbmRdIGFib3ZlLiAqKVxuICAgICAgfCBGaXJzdCBfIGFzIHkgLT4geVxuICAgIDs7XG4gIGVuZClcblxubW9kdWxlIEV4cG9ydCA9IHN0cnVjdFxuICB0eXBlICgnZiwgJ3MpIF9laXRoZXIgPSAoJ2YsICdzKSB0ID1cbiAgICB8IEZpcnN0IG9mICdmXG4gICAgfCBTZWNvbmQgb2YgJ3NcbmVuZFxuIiwiaW5jbHVkZSBJbmRleGVkX2NvbnRhaW5lcl9pbnRmXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5cbmxldCBpdGVyaSB+Zm9sZCB0IH5mID1cbiAgaWdub3JlXG4gICAgKGZvbGQgdCB+aW5pdDowIH5mOihmdW4gaSB4IC0+XG4gICAgICAgZiBpIHg7XG4gICAgICAgaSArIDEpXG4gICAgIDogaW50KVxuOztcblxubGV0IGZvbGRpIH5mb2xkIHQgfmluaXQgfmYgPVxuICBsZXQgaSA9IHJlZiAwIGluXG4gIGZvbGQgdCB+aW5pdCB+ZjooZnVuIGFjYyB2IC0+XG4gICAgbGV0IGFjYyA9IGYgIWkgYWNjIHYgaW5cbiAgICBpIDo9ICFpICsgMTtcbiAgICBhY2MpXG47O1xuXG5sZXQgY291bnRpIH5mb2xkaSB0IH5mID0gZm9sZGkgdCB+aW5pdDowIH5mOihmdW4gaSBuIGEgLT4gaWYgZiBpIGEgdGhlbiBuICsgMSBlbHNlIG4pXG5cbmxldCBleGlzdHNpIH5pdGVyaSBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgYyB+ZjooZnVuIGkgeCAtPiBpZiBmIGkgeCB0aGVuIHIucmV0dXJuIHRydWUpO1xuICAgIGZhbHNlKVxuOztcblxubGV0IGZvcl9hbGxpIH5pdGVyaSBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgYyB+ZjooZnVuIGkgeCAtPiBpZiBub3QgKGYgaSB4KSB0aGVuIHIucmV0dXJuIGZhbHNlKTtcbiAgICB0cnVlKVxuOztcblxubGV0IGZpbmRfbWFwaSB+aXRlcmkgdCB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXJpIHQgfmY6KGZ1biBpIHggLT5cbiAgICAgIG1hdGNoIGYgaSB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgfCBTb21lIF8gYXMgcmVzIC0+IHIucmV0dXJuIHJlcyk7XG4gICAgTm9uZSlcbjs7XG5cbmxldCBmaW5kaSB+aXRlcmkgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXJpIGMgfmY6KGZ1biBpIHggLT4gaWYgZiBpIHggdGhlbiByLnJldHVybiAoU29tZSAoaSwgeCkpKTtcbiAgICBOb25lKVxuOztcblxubW9kdWxlIE1ha2VfZ2VuIChUIDogc2lnXG4gICAgaW5jbHVkZSBDb250YWluZXJfaW50Zi5NYWtlX2dlbl9hcmdcblxuICAgIHZhbCBpdGVyaSA6IFsgYERlZmluZV91c2luZ19mb2xkIHwgYEN1c3RvbSBvZiAoJ2EgdCwgJ2EgZWx0KSBpdGVyaSBdXG4gICAgdmFsIGZvbGRpIDogWyBgRGVmaW5lX3VzaW5nX2ZvbGQgfCBgQ3VzdG9tIG9mICgnYSB0LCAnYSBlbHQsIF8pIGZvbGRpIF1cbiAgZW5kKSA6IEdlbmVyaWMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVC50IHdpdGggdHlwZSAnYSBlbHQgOj0gJ2EgVC5lbHQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBDb250YWluZXIuTWFrZV9nZW4gKFQpXG5cbiAgbGV0IGl0ZXJpID1cbiAgICBtYXRjaCBULml0ZXJpIHdpdGhcbiAgICB8IGBDdXN0b20gaXRlcmkgLT4gaXRlcmlcbiAgICB8IGBEZWZpbmVfdXNpbmdfZm9sZCAtPiBmdW4gdCB+ZiAtPiBpdGVyaSB+Zm9sZCB0IH5mXG4gIDs7XG5cbiAgbGV0IGZvbGRpID1cbiAgICBtYXRjaCBULmZvbGRpIHdpdGhcbiAgICB8IGBDdXN0b20gZm9sZGkgLT4gZm9sZGlcbiAgICB8IGBEZWZpbmVfdXNpbmdfZm9sZCAtPiBmdW4gdCB+aW5pdCB+ZiAtPiBmb2xkaSB+Zm9sZCB0IH5pbml0IH5mXG4gIDs7XG5cbiAgbGV0IGNvdW50aSB0IH5mID0gY291bnRpIH5mb2xkaSB0IH5mXG4gIGxldCBleGlzdHNpIHQgfmYgPSBleGlzdHNpIH5pdGVyaSB0IH5mXG4gIGxldCBmb3JfYWxsaSB0IH5mID0gZm9yX2FsbGkgfml0ZXJpIHQgfmZcbiAgbGV0IGZpbmRfbWFwaSB0IH5mID0gZmluZF9tYXBpIH5pdGVyaSB0IH5mXG4gIGxldCBmaW5kaSB0IH5mID0gZmluZGkgfml0ZXJpIHQgfmZcbmVuZFxuXG5tb2R1bGUgTWFrZSAoVCA6IE1ha2VfYXJnKSA9IHN0cnVjdFxuICBtb2R1bGUgQyA9IENvbnRhaW5lci5NYWtlIChUKVxuXG4gICgqIE5vdCBwYXJ0IG9mIFtDb250YWluZXIuR2VuZXJpY10uICopXG4gIGxldCBtZW0gPSBDLm1lbVxuXG4gIGluY2x1ZGUgTWFrZV9nZW4gKHN0cnVjdFxuICAgICAgaW5jbHVkZSBUXG5cbiAgICAgIHR5cGUgJ2EgdCA9ICdhIFQudFxuICAgICAgdHlwZSAnYSBlbHQgPSAnYVxuICAgIGVuZClcbmVuZFxuXG5tb2R1bGUgTWFrZTAgKFQgOiBNYWtlMF9hcmcpID0gc3RydWN0XG4gIG1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2UwIChUKVxuXG4gICgqIE5vdCBwYXJ0IG9mIFtDb250YWluZXIuR2VuZXJpY10uICopXG4gIGxldCBtZW0gPSBDLm1lbVxuXG4gIGluY2x1ZGUgTWFrZV9nZW4gKHN0cnVjdFxuICAgICAgaW5jbHVkZSBUXG5cbiAgICAgIHR5cGUgJ2EgdCA9IFQudFxuICAgICAgdHlwZSAnYSBlbHQgPSBULkVsdC50XG4gICAgZW5kKVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbm9wZW4gQ29udGFpbmVyX2ludGYuRXhwb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBMaXN0ID0gTGlzdDFcblxubW9kdWxlIFN0ZXAgPSBzdHJ1Y3RcbiAgKCogJ2EgaXMgYW4gaXRlbSBpbiB0aGUgc2VxdWVuY2UsICdzIGlzIHRoZSBzdGF0ZSB0aGF0IHdpbGwgcHJvZHVjZSB0aGUgcmVtYWluZGVyIG9mXG4gICAgIHRoZSBzZXF1ZW5jZSAqKVxuICB0eXBlICgnYSwgJ3MpIHQgPVxuICAgIHwgRG9uZVxuICAgIHwgU2tpcCBvZiAnc1xuICAgIHwgWWllbGQgb2YgJ2EgKiAnc1xuICBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAnYSAncy5cbiAgICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgncyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdhLCAncykgdFxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgID1cbiAgICBmdW4gKHR5cGUgYV9fMDA5XyBzX18wMTBfKVxuICAgICAgICA6ICAoKGFfXzAwOV8gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoc19fMDEwXyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgICAgICAtPiAoYV9fMDA5Xywgc19fMDEwXykgdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gICAgICBmdW4gX29mX2FfXzAwMV8gX29mX3NfXzAwMl8gLT4gZnVuY3Rpb25cbiAgICAgICAgfCBEb25lIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkRvbmVcIlxuICAgICAgICB8IFNraXAgYXJnMF9fMDAzXyAtPlxuICAgICAgICAgIGxldCByZXMwX18wMDRfID0gX29mX3NfXzAwMl8gYXJnMF9fMDAzXyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlNraXBcIjsgcmVzMF9fMDA0XyBdXG4gICAgICAgIHwgWWllbGQgKGFyZzBfXzAwNV8sIGFyZzFfXzAwNl8pIC0+XG4gICAgICAgICAgbGV0IHJlczBfXzAwN18gPSBfb2ZfYV9fMDAxXyBhcmcwX18wMDVfXG4gICAgICAgICAgYW5kIHJlczFfXzAwOF8gPSBfb2Zfc19fMDAyXyBhcmcxX18wMDZfIGluXG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiWWllbGRcIjsgcmVzMF9fMDA3XzsgcmVzMV9fMDA4XyBdXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5vcGVuIFN0ZXBcblxuKCogJ2EgaXMgYW4gaXRlbSBpbiB0aGUgc2VxdWVuY2UsICdzIGlzIHRoZSBzdGF0ZSB0aGF0IHdpbGwgcHJvZHVjZSB0aGUgcmVtYWluZGVyIG9mIHRoZVxuICAgc2VxdWVuY2UgKilcbnR5cGUgK18gdCA9IFNlcXVlbmNlIDogJ3MgKiAoJ3MgLT4gKCdhLCAncykgU3RlcC50KSAtPiAnYSB0XG50eXBlICdhIHNlcXVlbmNlID0gJ2EgdFxuXG5tb2R1bGUgRXhwZXJ0ID0gc3RydWN0XG4gIGxldCBuZXh0X3N0ZXAgKFNlcXVlbmNlIChzLCBmKSkgPVxuICAgIG1hdGNoIGYgcyB3aXRoXG4gICAgfCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgcyAtPiBTa2lwIChTZXF1ZW5jZSAocywgZikpXG4gICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGEsIFNlcXVlbmNlIChzLCBmKSlcbiAgOztcblxuICBsZXQgZGVsYXllZF9mb2xkX3N0ZXAgcyB+aW5pdCB+ZiB+ZmluaXNoID1cbiAgICBsZXQgcmVjIGxvb3AgcyBuZXh0IGZpbmlzaCBmIGFjYyA9XG4gICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgfCBEb25lIC0+IGZpbmlzaCBhY2NcbiAgICAgIHwgU2tpcCBzIC0+IGYgYWNjIE5vbmUgfms6KGxvb3AgcyBuZXh0IGZpbmlzaCBmKVxuICAgICAgfCBZaWVsZCAoYSwgcykgLT4gZiBhY2MgKFNvbWUgYSkgfms6KGxvb3AgcyBuZXh0IGZpbmlzaCBmKVxuICAgIGluXG4gICAgbWF0Y2ggcyB3aXRoXG4gICAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT4gbG9vcCBzIG5leHQgZmluaXNoIGYgaW5pdFxuICA7O1xuZW5kXG5cbmxldCB1bmZvbGRfc3RlcCB+aW5pdCB+ZiA9IFNlcXVlbmNlIChpbml0LCBmKVxuXG5sZXQgdW5mb2xkIH5pbml0IH5mID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQgfmY6KGZ1biBzIC0+XG4gICAgbWF0Y2ggZiBzIHdpdGhcbiAgICB8IE5vbmUgLT4gU3RlcC5Eb25lXG4gICAgfCBTb21lIChhLCBzKSAtPiBTdGVwLllpZWxkIChhLCBzKSlcbjs7XG5cbmxldCB1bmZvbGRfd2l0aCBzIH5pbml0IH5mID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggKGluaXQsIHMpXG4gICAgICAsIGZ1biAoc2VlZCwgcykgLT5cbiAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoc2VlZCwgcylcbiAgICAgICAgfCBZaWVsZCAoYSwgcykgLT5cbiAgICAgICAgICAobWF0Y2ggZiBzZWVkIGEgd2l0aFxuICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICB8IFNraXAgc2VlZCAtPiBTa2lwIChzZWVkLCBzKVxuICAgICAgICAgICB8IFlpZWxkIChhLCBzZWVkKSAtPiBZaWVsZCAoYSwgKHNlZWQsIHMpKSkgKVxuOztcblxubGV0IHVuZm9sZF93aXRoX2FuZF9maW5pc2ggcyB+aW5pdCB+cnVubmluZ19zdGVwIH5pbm5lcl9maW5pc2hlZCB+ZmluaXNoaW5nX3N0ZXAgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCBgSW5uZXJfcnVubmluZyAoaW5pdCwgcylcbiAgICAgICwgZnVuIHN0YXRlIC0+XG4gICAgICAgIG1hdGNoIHN0YXRlIHdpdGhcbiAgICAgICAgfCBgSW5uZXJfcnVubmluZyAoc3RhdGUsIGlubmVyX3N0YXRlKSAtPlxuICAgICAgICAgIChtYXRjaCBuZXh0IGlubmVyX3N0YXRlIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IFNraXAgKGBJbm5lcl9maW5pc2hlZCAoaW5uZXJfZmluaXNoZWQgc3RhdGUpKVxuICAgICAgICAgICB8IFNraXAgaW5uZXJfc3RhdGUgLT4gU2tpcCAoYElubmVyX3J1bm5pbmcgKHN0YXRlLCBpbm5lcl9zdGF0ZSkpXG4gICAgICAgICAgIHwgWWllbGQgKHgsIGlubmVyX3N0YXRlKSAtPlxuICAgICAgICAgICAgIChtYXRjaCBydW5uaW5nX3N0ZXAgc3RhdGUgeCB3aXRoXG4gICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgIHwgU2tpcCBzdGF0ZSAtPiBTa2lwIChgSW5uZXJfcnVubmluZyAoc3RhdGUsIGlubmVyX3N0YXRlKSlcbiAgICAgICAgICAgICAgfCBZaWVsZCAoeSwgc3RhdGUpIC0+IFlpZWxkICh5LCBgSW5uZXJfcnVubmluZyAoc3RhdGUsIGlubmVyX3N0YXRlKSkpKVxuICAgICAgICB8IGBJbm5lcl9maW5pc2hlZCBzdGF0ZSAtPlxuICAgICAgICAgIChtYXRjaCBmaW5pc2hpbmdfc3RlcCBzdGF0ZSB3aXRoXG4gICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgIHwgU2tpcCBzdGF0ZSAtPiBTa2lwIChgSW5uZXJfZmluaXNoZWQgc3RhdGUpXG4gICAgICAgICAgIHwgWWllbGQgKHksIHN0YXRlKSAtPiBZaWVsZCAoeSwgYElubmVyX2ZpbmlzaGVkIHN0YXRlKSkgKVxuOztcblxubGV0IG9mX2xpc3QgbCA9XG4gIHVuZm9sZF9zdGVwIH5pbml0OmwgfmY6KGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBEb25lXG4gICAgfCB4IDo6IGwgLT4gWWllbGQgKHgsIGwpKVxuOztcblxuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IHJlYyBsb29wIHNlZWQgdiBuZXh0IGYgPVxuICAgIG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgfCBEb25lIC0+IHZcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgdiBuZXh0IGZcbiAgICB8IFlpZWxkIChhLCBzKSAtPiBsb29wIHMgKGYgdiBhKSBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBpbml0IG5leHQgZlxuOztcblxubGV0IHRvX2xpc3RfcmV2IHQgPSBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biBsIHggLT4geCA6OiBsKVxuXG5cbmxldCB0b19saXN0IChTZXF1ZW5jZSAocywgbmV4dCkpID1cbiAgbGV0IHNhZmVfdG9fbGlzdCB0ID0gTGlzdC5yZXYgKHRvX2xpc3RfcmV2IHQpIGluXG4gIGxldCByZWMgdG9fbGlzdCBzIG5leHQgaSA9XG4gICAgaWYgaSA9IDBcbiAgICB0aGVuIHNhZmVfdG9fbGlzdCAoU2VxdWVuY2UgKHMsIG5leHQpKVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBbXVxuICAgICAgfCBTa2lwIHMgLT4gdG9fbGlzdCBzIG5leHQgaVxuICAgICAgfCBZaWVsZCAoYSwgcykgLT4gYSA6OiB0b19saXN0IHMgbmV4dCAoaSAtIDEpKVxuICBpblxuICB0b19saXN0IHMgbmV4dCA1MDBcbjs7XG5cbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSBzZXhwX29mX2xpc3Qgc2V4cF9vZl9hICh0b19saXN0IHQpXG5cbmxldCByYW5nZSA/KHN0cmlkZSA9IDEpID8oc3RhcnQgPSBgaW5jbHVzaXZlKSA/KHN0b3AgPSBgZXhjbHVzaXZlKSBzdGFydF92IHN0b3BfdiA9XG4gIGxldCBzdGVwID1cbiAgICBtYXRjaCBzdG9wIHdpdGhcbiAgICB8IGBpbmNsdXNpdmUgd2hlbiBzdHJpZGUgPj0gMCAtPlxuICAgICAgZnVuIGkgLT4gaWYgaSA+IHN0b3BfdiB0aGVuIERvbmUgZWxzZSBZaWVsZCAoaSwgaSArIHN0cmlkZSlcbiAgICB8IGBpbmNsdXNpdmUgLT4gZnVuIGkgLT4gaWYgaSA8IHN0b3BfdiB0aGVuIERvbmUgZWxzZSBZaWVsZCAoaSwgaSArIHN0cmlkZSlcbiAgICB8IGBleGNsdXNpdmUgd2hlbiBzdHJpZGUgPj0gMCAtPlxuICAgICAgZnVuIGkgLT4gaWYgaSA+PSBzdG9wX3YgdGhlbiBEb25lIGVsc2UgWWllbGQgKGksIGkgKyBzdHJpZGUpXG4gICAgfCBgZXhjbHVzaXZlIC0+IGZ1biBpIC0+IGlmIGkgPD0gc3RvcF92IHRoZW4gRG9uZSBlbHNlIFlpZWxkIChpLCBpICsgc3RyaWRlKVxuICBpblxuICBsZXQgaW5pdCA9XG4gICAgbWF0Y2ggc3RhcnQgd2l0aFxuICAgIHwgYGluY2x1c2l2ZSAtPiBzdGFydF92XG4gICAgfCBgZXhjbHVzaXZlIC0+IHN0YXJ0X3YgKyBzdHJpZGVcbiAgaW5cbiAgdW5mb2xkX3N0ZXAgfmluaXQgfmY6c3RlcFxuOztcblxubGV0IG9mX2xhenkgdF9sYXp5ID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6dF9sYXp5IH5mOihmdW4gdF9sYXp5IC0+XG4gICAgbGV0IChTZXF1ZW5jZSAocywgbmV4dCkpID0gTGF6eS5mb3JjZSB0X2xhenkgaW5cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBEb25lXG4gICAgfCBTa2lwIHMgLT5cbiAgICAgIFNraXBcbiAgICAgICAgKGxldCB2ID0gU2VxdWVuY2UgKHMsIG5leHQpIGluXG4gICAgICAgICBsYXp5IHYpXG4gICAgfCBZaWVsZCAoeCwgcykgLT5cbiAgICAgIFlpZWxkXG4gICAgICAgICggeFxuICAgICAgICAsIGxldCB2ID0gU2VxdWVuY2UgKHMsIG5leHQpIGluXG4gICAgICAgICAgbGF6eSB2ICkpXG47O1xuXG5sZXQgbWFwIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCBzZWVkXG4gICAgICAsIGZ1biBzZWVkIC0+XG4gICAgICAgIG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgIHwgU2tpcCBzIC0+IFNraXAgc1xuICAgICAgICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoZiBhLCBzKSApXG47O1xuXG5sZXQgbWFwaSB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggKDAsIHMpXG4gICAgICAsIGZ1biAoaSwgcykgLT5cbiAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoaSwgcylcbiAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGYgaSBhLCAoaSArIDEsIHMpKSApXG47O1xuXG5sZXQgZm9sZGluZ19tYXAgdCB+aW5pdCB+ZiA9XG4gIHVuZm9sZF93aXRoIHQgfmluaXQgfmY6KGZ1biBhY2MgeCAtPlxuICAgIGxldCBhY2MsIHggPSBmIGFjYyB4IGluXG4gICAgWWllbGQgKHgsIGFjYykpXG47O1xuXG5sZXQgZm9sZGluZ19tYXBpIHQgfmluaXQgfmYgPVxuICB1bmZvbGRfd2l0aCB0IH5pbml0OigwLCBpbml0KSB+ZjooZnVuIChpLCBhY2MpIHggLT5cbiAgICBsZXQgYWNjLCB4ID0gZiBpIGFjYyB4IGluXG4gICAgWWllbGQgKHgsIChpICsgMSwgYWNjKSkpXG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCBzZWVkXG4gICAgICAsIGZ1biBzZWVkIC0+XG4gICAgICAgIG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgIHwgU2tpcCBzIC0+IFNraXAgc1xuICAgICAgICB8IFlpZWxkIChhLCBzKSB3aGVuIGYgYSAtPiBZaWVsZCAoYSwgcylcbiAgICAgICAgfCBZaWVsZCAoXywgcykgLT4gU2tpcCBzIClcbjs7XG5cbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBtYXAgfmY6c25kIChmaWx0ZXIgKG1hcGkgdCB+ZjooZnVuIGkgcyAtPiBpLCBzKSkgfmY6KGZ1biAoaSwgcykgLT4gZiBpIHMpKVxuOztcblxubGV0IGxlbmd0aCB0ID1cbiAgbGV0IHJlYyBsb29wIGkgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBpXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBpIHMgbmV4dFxuICAgIHwgWWllbGQgKF8sIHMpIC0+IGxvb3AgKGkgKyAxKSBzIG5leHRcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3AgMCBzZWVkIG5leHRcbjs7XG5cbmxldCB0b19saXN0X3Jldl93aXRoX2xlbmd0aCB0ID0gZm9sZCB0IH5pbml0OihbXSwgMCkgfmY6KGZ1biAobCwgaSkgeCAtPiB4IDo6IGwsIGkgKyAxKVxuXG5sZXQgdG9fYXJyYXkgdCA9XG4gIGxldCBsLCBsZW4gPSB0b19saXN0X3Jldl93aXRoX2xlbmd0aCB0IGluXG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFt8fF1cbiAgfCB4IDo6IGwgLT5cbiAgICBsZXQgYSA9IEFycmF5LmNyZWF0ZSB+bGVuIHggaW5cbiAgICBsZXQgcmVjIGxvb3AgaSBsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgKGkgPSAtMSlcbiAgICAgIHwgeCA6OiBsIC0+XG4gICAgICAgIGEuKGkpIDwtIHg7XG4gICAgICAgIGxvb3AgKGkgLSAxKSBsXG4gICAgaW5cbiAgICBsb29wIChsZW4gLSAyKSBsO1xuICAgIGFcbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFlpZWxkIChhLCBfKSB3aGVuIGYgYSAtPiBTb21lIGFcbiAgICB8IFlpZWxkIChfLCBzKSB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dCBmXG47O1xuXG5sZXQgZmluZF9tYXAgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgWWllbGQgKGEsIHMpIC0+XG4gICAgICAobWF0Y2ggZiBhIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gbG9vcCBzIG5leHQgZlxuICAgICAgIHwgc29tZV9iIC0+IHNvbWVfYilcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dCBmXG47O1xuXG5cbmxldCBmaW5kX21hcGkgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiBpID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBZaWVsZCAoYSwgcykgLT5cbiAgICAgIChtYXRjaCBmIGkgYSB3aXRoXG4gICAgICAgfCBOb25lIC0+IGxvb3AgcyBuZXh0IGYgKGkgKyAxKVxuICAgICAgIHwgc29tZV9iIC0+IHNvbWVfYilcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBmIGlcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGYgMFxuOztcblxubGV0IGZvcl9hbGwgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gdHJ1ZVxuICAgIHwgWWllbGQgKGEsIF8pIHdoZW4gbm90IChmIGEpIC0+IGZhbHNlXG4gICAgfCBZaWVsZCAoXywgcykgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgZlxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgaSA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gdHJ1ZVxuICAgIHwgWWllbGQgKGEsIF8pIHdoZW4gbm90IChmIGkgYSkgLT4gZmFsc2VcbiAgICB8IFlpZWxkIChfLCBzKSAtPiBsb29wIHMgbmV4dCBmIChpICsgMSlcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBmIGlcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGYgMFxuOztcblxubGV0IGV4aXN0cyB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBmYWxzZVxuICAgIHwgWWllbGQgKGEsIF8pIHdoZW4gZiBhIC0+IHRydWVcbiAgICB8IFlpZWxkIChfLCBzKSB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dCBmXG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmIGkgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IGZhbHNlXG4gICAgfCBZaWVsZCAoYSwgXykgd2hlbiBmIGkgYSAtPiB0cnVlXG4gICAgfCBZaWVsZCAoXywgcykgLT4gbG9vcCBzIG5leHQgZiAoaSArIDEpXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgZiBpXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dCBmIDBcbjs7XG5cbmxldCBpdGVyIHQgfmYgPVxuICBsZXQgcmVjIGxvb3Agc2VlZCBuZXh0IGYgPVxuICAgIG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgfCBEb25lIC0+ICgpXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgZlxuICAgIHwgWWllbGQgKGEsIHMpIC0+XG4gICAgICBmIGE7XG4gICAgICBsb29wIHMgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dCBmXG47O1xuXG5sZXQgaXNfZW1wdHkgdCA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IHRydWVcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgbmV4dFxuICAgIHwgWWllbGQgXyAtPiBmYWxzZVxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHRcbjs7XG5cbmxldCBtZW0gdCBhIH5lcXVhbCA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgYSA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gZmFsc2VcbiAgICB8IFlpZWxkIChiLCBfKSB3aGVuIGVxdWFsIGEgYiAtPiB0cnVlXG4gICAgfCBZaWVsZCAoXywgcykgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHQgYVxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgYVxuOztcblxubGV0IGVtcHR5ID0gU2VxdWVuY2UgKCgpLCBmdW4gKCkgLT4gRG9uZSlcblxubGV0IGJpbmQgdCB+ZiA9XG4gIHVuZm9sZF9zdGVwXG4gICAgfmY6KGZ1bmN0aW9uXG4gICAgICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSwgcmVzdCAtPlxuICAgICAgICAobWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICAgICAgIHwgRG9uZSAtPlxuICAgICAgICAgICAobWF0Y2ggcmVzdCB3aXRoXG4gICAgICAgICAgICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPlxuICAgICAgICAgICAgICAobWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICAgICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChlbXB0eSwgU2VxdWVuY2UgKHMsIG5leHQpKVxuICAgICAgICAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gU2tpcCAoZiBhLCBTZXF1ZW5jZSAocywgbmV4dCkpKSlcbiAgICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKFNlcXVlbmNlIChzLCBuZXh0KSwgcmVzdClcbiAgICAgICAgIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChhLCAoU2VxdWVuY2UgKHMsIG5leHQpLCByZXN0KSkpKVxuICAgIH5pbml0OihlbXB0eSwgdClcbjs7XG5cbmxldCByZXR1cm4geCA9XG4gIHVuZm9sZF9zdGVwIH5pbml0OihTb21lIHgpIH5mOihmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBEb25lXG4gICAgfCBTb21lIHggLT4gWWllbGQgKHgsIE5vbmUpKVxuOztcblxuaW5jbHVkZSBNb25hZC5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICBlbmQpXG5cbmxldCBudGggcyBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCByZWMgbG9vcCBpIHMgbmV4dCA9XG4gICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgfCBEb25lIC0+IE5vbmVcbiAgICAgIHwgU2tpcCBzIC0+IGxvb3AgaSBzIG5leHRcbiAgICAgIHwgWWllbGQgKGEsIHMpIC0+IGlmIHBoeXNfZXF1YWwgaSAwIHRoZW4gU29tZSBhIGVsc2UgbG9vcCAoaSAtIDEpIHMgbmV4dFxuICAgIGluXG4gICAgbWF0Y2ggcyB3aXRoXG4gICAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT4gbG9vcCBuIHMgbmV4dClcbjs7XG5cbmxldCBudGhfZXhuIHMgbiA9XG4gIGlmIG4gPCAwXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTZXF1ZW5jZS5udGhcIlxuICBlbHNlIChcbiAgICBtYXRjaCBudGggcyBuIHdpdGhcbiAgICB8IE5vbmUgLT4gZmFpbHdpdGggXCJTZXF1ZW5jZS5udGhcIlxuICAgIHwgU29tZSB4IC0+IHgpXG47O1xuXG5tb2R1bGUgTWVyZ2Vfd2l0aF9kdXBsaWNhdGVzX2VsZW1lbnQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB0ID1cbiAgICB8IExlZnQgb2YgJ2FcbiAgICB8IFJpZ2h0IG9mICdiXG4gICAgfCBCb3RoIG9mICdhICogJ2JcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZSA6XG4gICAgJ2EgJ2IuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICgnYiAtPiAnYiAtPiBpbnQpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBpbnRcbiAgICA9XG4gICAgZnVuIF9jbXBfX2EgX2NtcF9fYiBhX18wMTFfIGJfXzAxMl8gLT5cbiAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMTFfIGJfXzAxMl9cbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFfXzAxMV8sIGJfXzAxMl8gd2l0aFxuICAgICAgfCBMZWZ0IF9hX18wMTNfLCBMZWZ0IF9iX18wMTRfIC0+IF9jbXBfX2EgX2FfXzAxM18gX2JfXzAxNF9cbiAgICAgIHwgTGVmdCBfLCBfIC0+IC0xXG4gICAgICB8IF8sIExlZnQgXyAtPiAxXG4gICAgICB8IFJpZ2h0IF9hX18wMTVfLCBSaWdodCBfYl9fMDE2XyAtPiBfY21wX19iIF9hX18wMTVfIF9iX18wMTZfXG4gICAgICB8IFJpZ2h0IF8sIF8gLT4gLTFcbiAgICAgIHwgXywgUmlnaHQgXyAtPiAxXG4gICAgICB8IEJvdGggKF9hX18wMTdfLCBfYV9fMDE5XyksIEJvdGggKF9iX18wMThfLCBfYl9fMDIwXykgLT5cbiAgICAgICAgKG1hdGNoIF9jbXBfX2EgX2FfXzAxN18gX2JfXzAxOF8gd2l0aFxuICAgICAgICAgfCAwIC0+IF9jbXBfX2IgX2FfXzAxOV8gX2JfXzAyMF9cbiAgICAgICAgIHwgbiAtPiBuKSlcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX3RcbiAgICA6IHR5cGUgYSBiLlxuICAgICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAgIC0+IChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gYiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAgIC0+IChhLCBiKSB0XG4gICAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICA9XG4gICAgZnVuIF9oYXNoX2ZvbGRfYSBfaGFzaF9mb2xkX2IgaHN2IGFyZyAtPlxuICAgICAgbWF0Y2ggYXJnIHdpdGhcbiAgICAgIHwgTGVmdCBfYTAgLT5cbiAgICAgICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMCBpblxuICAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgIF9oYXNoX2ZvbGRfYSBoc3YgX2EwXG4gICAgICB8IFJpZ2h0IF9hMCAtPlxuICAgICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxIGluXG4gICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICAgX2hhc2hfZm9sZF9iIGhzdiBfYTBcbiAgICAgIHwgQm90aCAoX2EwLCBfYTEpIC0+XG4gICAgICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDIgaW5cbiAgICAgICAgbGV0IGhzdiA9XG4gICAgICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgICAgIF9oYXNoX2ZvbGRfYSBoc3YgX2EwXG4gICAgICAgIGluXG4gICAgICAgIF9oYXNoX2ZvbGRfYiBoc3YgX2ExXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA6XG4gICAgJ2EgJ2IuXG4gICAgKFNleHBsaWIwLlNleHAudCAtPiAnYSlcbiAgICAtPiAoU2V4cGxpYjAuU2V4cC50IC0+ICdiKVxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgIC0+ICgnYSwgJ2IpIHRcbiAgICA9XG4gICAgZnVuICh0eXBlIGFfXzA0NF8gYl9fMDQ1XylcbiAgICAgICAgOiAgKChTZXhwbGliMC5TZXhwLnQgLT4gYV9fMDQ0XykgLT4gKFNleHBsaWIwLlNleHAudCAtPiBiX18wNDVfKVxuICAgICAgICAgICAgLT4gU2V4cGxpYjAuU2V4cC50IC0+IChhX18wNDRfLCBiX18wNDVfKSB0KSAtPlxuICAgICAgbGV0IGVycm9yX3NvdXJjZV9fMDI1XyA9IFwic2VxdWVuY2UubWwuTWVyZ2Vfd2l0aF9kdXBsaWNhdGVzX2VsZW1lbnQudFwiIGluXG4gICAgICBmdW4gX29mX2FfXzAyMV8gX29mX2JfXzAyMl8gLT4gZnVuY3Rpb25cbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImxlZnRcIiB8IFwiTGVmdFwiKSBhcyBfdGFnX18wMjhfKSA6OiBzZXhwX2FyZ3NfXzAyOV8pIGFzXG4gICAgICAgICAgX3NleHBfXzAyN18gLT5cbiAgICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMjlfIHdpdGhcbiAgICAgICAgICAgfCBbIGFyZzBfXzAzMF8gXSAtPlxuICAgICAgICAgICAgIGxldCByZXMwX18wMzFfID0gX29mX2FfXzAyMV8gYXJnMF9fMDMwXyBpblxuICAgICAgICAgICAgIExlZnQgcmVzMF9fMDMxX1xuICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAyNV9cbiAgICAgICAgICAgICAgIF90YWdfXzAyOF9cbiAgICAgICAgICAgICAgIF9zZXhwX18wMjdfKVxuICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwicmlnaHRcIiB8IFwiUmlnaHRcIikgYXMgX3RhZ19fMDMzXykgOjogc2V4cF9hcmdzX18wMzRfKSBhc1xuICAgICAgICAgIF9zZXhwX18wMzJfIC0+XG4gICAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDM0XyB3aXRoXG4gICAgICAgICAgIHwgWyBhcmcwX18wMzVfIF0gLT5cbiAgICAgICAgICAgICBsZXQgcmVzMF9fMDM2XyA9IF9vZl9iX18wMjJfIGFyZzBfXzAzNV8gaW5cbiAgICAgICAgICAgICBSaWdodCByZXMwX18wMzZfXG4gICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDI1X1xuICAgICAgICAgICAgICAgX3RhZ19fMDMzX1xuICAgICAgICAgICAgICAgX3NleHBfXzAzMl8pXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJib3RoXCIgfCBcIkJvdGhcIikgYXMgX3RhZ19fMDM4XykgOjogc2V4cF9hcmdzX18wMzlfKSBhc1xuICAgICAgICAgIF9zZXhwX18wMzdfIC0+XG4gICAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDM5XyB3aXRoXG4gICAgICAgICAgIHwgWyBhcmcwX18wNDBfOyBhcmcxX18wNDFfIF0gLT5cbiAgICAgICAgICAgICBsZXQgcmVzMF9fMDQyXyA9IF9vZl9hX18wMjFfIGFyZzBfXzA0MF9cbiAgICAgICAgICAgICBhbmQgcmVzMV9fMDQzXyA9IF9vZl9iX18wMjJfIGFyZzFfXzA0MV8gaW5cbiAgICAgICAgICAgICBCb3RoIChyZXMwX18wNDJfLCByZXMxX18wNDNfKVxuICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAyNV9cbiAgICAgICAgICAgICAgIF90YWdfXzAzOF9cbiAgICAgICAgICAgICAgIF9zZXhwX18wMzdfKVxuICAgICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJsZWZ0XCIgfCBcIkxlZnRcIikgYXMgc2V4cF9fMDI2XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMjVfIHNleHBfXzAyNl9cbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwicmlnaHRcIiB8IFwiUmlnaHRcIikgYXMgc2V4cF9fMDI2XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMjVfIHNleHBfXzAyNl9cbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiYm90aFwiIHwgXCJCb3RoXCIpIGFzIHNleHBfXzAyNl8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDI1XyBzZXhwX18wMjZfXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMjRfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDI1XyBzZXhwX18wMjRfXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAyNF8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAyNV8gc2V4cF9fMDI0X1xuICAgICAgICB8IHNleHBfXzAyNF8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDI1XyBzZXhwX18wMjRfXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6XG4gICAgJ2EgJ2IuXG4gICAgKCdhIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2IgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICA9XG4gICAgZnVuICh0eXBlIGFfXzA1Nl8gYl9fMDU3XylcbiAgICAgICAgOiAgKChhX18wNTZfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKGJfXzA1N18gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAgICAgLT4gKGFfXzA1Nl8sIGJfXzA1N18pIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICAgICAgZnVuIF9vZl9hX18wNDZfIF9vZl9iX18wNDdfIC0+IGZ1bmN0aW9uXG4gICAgICAgIHwgTGVmdCBhcmcwX18wNDhfIC0+XG4gICAgICAgICAgbGV0IHJlczBfXzA0OV8gPSBfb2ZfYV9fMDQ2XyBhcmcwX18wNDhfIGluXG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiTGVmdFwiOyByZXMwX18wNDlfIF1cbiAgICAgICAgfCBSaWdodCBhcmcwX18wNTBfIC0+XG4gICAgICAgICAgbGV0IHJlczBfXzA1MV8gPSBfb2ZfYl9fMDQ3XyBhcmcwX18wNTBfIGluXG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiUmlnaHRcIjsgcmVzMF9fMDUxXyBdXG4gICAgICAgIHwgQm90aCAoYXJnMF9fMDUyXywgYXJnMV9fMDUzXykgLT5cbiAgICAgICAgICBsZXQgcmVzMF9fMDU0XyA9IF9vZl9hX18wNDZfIGFyZzBfXzA1Ml9cbiAgICAgICAgICBhbmQgcmVzMV9fMDU1XyA9IF9vZl9iX18wNDdfIGFyZzFfXzA1M18gaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJCb3RoXCI7IHJlczBfXzA1NF87IHJlczFfXzA1NV8gXVxuICA7O1xuXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOlxuICAgICAgICAgJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgICAtPiAnYiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgIC0+ICgnYSwgJ2IpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gICAgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIF8nYl9zZXhwX2dyYW1tYXIgLT5cbiAgICAgIHsgdW50eXBlZCA9XG4gICAgICAgICAgVmFyaWFudFxuICAgICAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgICBbIE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkxlZnRcIlxuICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiUmlnaHRcIlxuICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiQm90aFwiXG4gICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmdzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBDb25zIChfJ2Jfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgIH1cbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbmxldCBtZXJnZV93aXRoX2R1cGxpY2F0ZXMgKFNlcXVlbmNlIChzMSwgbmV4dDEpKSAoU2VxdWVuY2UgKHMyLCBuZXh0MikpIH5jb21wYXJlID1cbiAgbGV0IHVuc2hhZG93ZWRfY29tcGFyZSA9IGNvbXBhcmUgaW5cbiAgbGV0IG9wZW4gTWVyZ2Vfd2l0aF9kdXBsaWNhdGVzX2VsZW1lbnQgaW5cbiAgbGV0IG5leHQgPSBmdW5jdGlvblxuICAgIHwgU2tpcCBzMSwgczIgLT4gU2tpcCAobmV4dDEgczEsIHMyKVxuICAgIHwgczEsIFNraXAgczIgLT4gU2tpcCAoczEsIG5leHQyIHMyKVxuICAgIHwgKFlpZWxkIChhLCBzMScpIGFzIHMxKSwgKFlpZWxkIChiLCBzMicpIGFzIHMyKSAtPlxuICAgICAgbGV0IGNvbXBhcmlzb24gPSB1bnNoYWRvd2VkX2NvbXBhcmUgYSBiIGluXG4gICAgICBpZiBjb21wYXJpc29uIDwgMFxuICAgICAgdGhlbiBZaWVsZCAoTGVmdCBhLCAoU2tpcCBzMScsIHMyKSlcbiAgICAgIGVsc2UgaWYgY29tcGFyaXNvbiA9IDBcbiAgICAgIHRoZW4gWWllbGQgKEJvdGggKGEsIGIpLCAoU2tpcCBzMScsIFNraXAgczInKSlcbiAgICAgIGVsc2UgWWllbGQgKFJpZ2h0IGIsIChzMSwgU2tpcCBzMicpKVxuICAgIHwgRG9uZSwgRG9uZSAtPiBEb25lXG4gICAgfCBZaWVsZCAoYSwgczEpLCBEb25lIC0+IFlpZWxkIChMZWZ0IGEsIChTa2lwIHMxLCBEb25lKSlcbiAgICB8IERvbmUsIFlpZWxkIChiLCBzMikgLT4gWWllbGQgKFJpZ2h0IGIsIChEb25lLCBTa2lwIHMyKSlcbiAgaW5cbiAgU2VxdWVuY2UgKChTa2lwIHMxLCBTa2lwIHMyKSwgbmV4dClcbjs7XG5cbmxldCBtZXJnZV9kZWR1cGVkX2FuZF9zb3J0ZWQgczEgczIgfmNvbXBhcmUgPVxuICBtYXAgKG1lcmdlX3dpdGhfZHVwbGljYXRlcyBzMSBzMiB+Y29tcGFyZSkgfmY6KGZ1bmN0aW9uXG4gICAgfCBMZWZ0IHggfCBSaWdodCB4IHwgQm90aCAoeCwgXykgLT4geClcbjs7XG5cbmxldCAobWVyZ2UgW0BkZXByZWNhdGVkXG4gICAgICAgXCJbc2luY2UgMjAyMS0wN10gRm9yIGlkZW50aWNhbCBiZWhhdmlvciwgdXNlIFxcXG4gICAgICAgIFtTZXF1ZW5jZS5tZXJnZV9kZWR1cGVkX2FuZF9zb3J0ZWRdLCBidXQgY29uc2lkZXIgdXNpbmcgXFxcbiAgICAgICAgW1NlcXVlbmNlLm1lcmdlX3NvcnRlZF0gaW5zdGVhZC5cIl0pXG4gID1cbiAgbWVyZ2VfZGVkdXBlZF9hbmRfc29ydGVkXG47O1xuXG5sZXQgbWVyZ2Vfc29ydGVkIChTZXF1ZW5jZSAoczEsIG5leHQxKSkgKFNlcXVlbmNlIChzMiwgbmV4dDIpKSB+Y29tcGFyZSA9XG4gIGxldCBuZXh0ID0gZnVuY3Rpb25cbiAgICB8IFNraXAgczEsIHMyIC0+IFNraXAgKG5leHQxIHMxLCBzMilcbiAgICB8IHMxLCBTa2lwIHMyIC0+IFNraXAgKHMxLCBuZXh0MiBzMilcbiAgICB8IChZaWVsZCAoYSwgczEnKSBhcyBzMSksIChZaWVsZCAoYiwgczInKSBhcyBzMikgLT5cbiAgICAgIGxldCBjb21wYXJpc29uID0gY29tcGFyZSBhIGIgaW5cbiAgICAgIGlmIGNvbXBhcmlzb24gPD0gMCB0aGVuIFlpZWxkIChhLCAoU2tpcCBzMScsIHMyKSkgZWxzZSBZaWVsZCAoYiwgKHMxLCBTa2lwIHMyJykpXG4gICAgfCBEb25lLCBEb25lIC0+IERvbmVcbiAgICB8IFlpZWxkIChhLCBzMSksIERvbmUgLT4gWWllbGQgKGEsIChTa2lwIHMxLCBEb25lKSlcbiAgICB8IERvbmUsIFlpZWxkIChiLCBzMikgLT4gWWllbGQgKGIsIChEb25lLCBTa2lwIHMyKSlcbiAgaW5cbiAgU2VxdWVuY2UgKChTa2lwIHMxLCBTa2lwIHMyKSwgbmV4dClcbjs7XG5cbmxldCBoZCBzID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0XG4gICAgfCBZaWVsZCAoYSwgXykgLT4gU29tZSBhXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPiBsb29wIHMgbmV4dFxuOztcblxubGV0IGhkX2V4biBzID1cbiAgbWF0Y2ggaGQgcyB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcImhkX2V4blwiXG4gIHwgU29tZSBhIC0+IGFcbjs7XG5cbmxldCB0bCBzID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0XG4gICAgfCBZaWVsZCAoXywgYSkgLT4gU29tZSBhXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIChtYXRjaCBsb29wIHMgbmV4dCB3aXRoXG4gICAgIHwgTm9uZSAtPiBOb25lXG4gICAgIHwgU29tZSBzIC0+IFNvbWUgKFNlcXVlbmNlIChzLCBuZXh0KSkpXG47O1xuXG5sZXQgdGxfZWFnZXJseV9leG4gcyA9XG4gIG1hdGNoIHRsIHMgd2l0aFxuICB8IE5vbmUgLT4gZmFpbHdpdGggXCJTZXF1ZW5jZS50bF9leG5cIlxuICB8IFNvbWUgcyAtPiBzXG47O1xuXG5sZXQgbGlmdF9pZGVudGl0eSBuZXh0IHMgPVxuICBtYXRjaCBuZXh0IHMgd2l0aFxuICB8IERvbmUgLT4gRG9uZVxuICB8IFNraXAgcyAtPiBTa2lwIChgSWRlbnRpdHkgcylcbiAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGEsIGBJZGVudGl0eSBzKVxuOztcblxubGV0IG5leHQgcyA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgbmV4dFxuICAgIHwgWWllbGQgKGEsIHMpIC0+IFNvbWUgKGEsIFNlcXVlbmNlIChzLCBuZXh0KSlcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+IGxvb3AgcyBuZXh0XG47O1xuXG5sZXQgZmlsdGVyX29wdCBzID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggc1xuICAgICAgLCBmdW4gcyAtPlxuICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICB8IFNraXAgcyAtPiBTa2lwIHNcbiAgICAgICAgfCBZaWVsZCAoTm9uZSwgcykgLT4gU2tpcCBzXG4gICAgICAgIHwgWWllbGQgKFNvbWUgYSwgcykgLT4gWWllbGQgKGEsIHMpIClcbjs7XG5cbmxldCBmaWx0ZXJfbWFwIHMgfmYgPSBmaWx0ZXJfb3B0IChtYXAgcyB+ZilcbmxldCBmaWx0ZXJfbWFwaSBzIH5mID0gZmlsdGVyX21hcCAobWFwaSBzIH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIChpLCBzKSAtPiBmIGkgcylcblxubGV0IHNwbGl0X24gcyBuID1cbiAgbGV0IHJlYyBsb29wIHMgaSBhY2N1bSBuZXh0ID1cbiAgICBpZiBpIDw9IDBcbiAgICB0aGVuIExpc3QucmV2IGFjY3VtLCBTZXF1ZW5jZSAocywgbmV4dClcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICB8IERvbmUgLT4gTGlzdC5yZXYgYWNjdW0sIGVtcHR5XG4gICAgICB8IFNraXAgcyAtPiBsb29wIHMgaSBhY2N1bSBuZXh0XG4gICAgICB8IFlpZWxkIChhLCBzKSAtPiBsb29wIHMgKGkgLSAxKSAoYSA6OiBhY2N1bSkgbmV4dClcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+IGxvb3AgcyBuIFtdIG5leHRcbjs7XG5cbmxldCBjaHVua3NfZXhuIHQgbiA9XG4gIGlmIG4gPD0gMFxuICB0aGVuIGludmFsaWRfYXJnIFwiU2VxdWVuY2UuY2h1bmtzX2V4blwiXG4gIGVsc2VcbiAgICB1bmZvbGRfc3RlcCB+aW5pdDp0IH5mOihmdW4gdCAtPlxuICAgICAgbWF0Y2ggc3BsaXRfbiB0IG4gd2l0aFxuICAgICAgfCBbXSwgX2VtcHR5IC0+IERvbmVcbiAgICAgIHwgKF8gOjogXyBhcyB4cyksIHQgLT4gWWllbGQgKHhzLCB0KSlcbjs7XG5cbmxldCBmaW5kaSBzIH5mID0gZmluZCAobWFwaSBzIH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIChpLCBzKSAtPiBmIGkgcylcblxubGV0IGZpbmRfZXhuIHMgfmYgPVxuICBtYXRjaCBmaW5kIHMgfmYgd2l0aFxuICB8IE5vbmUgLT4gZmFpbHdpdGggXCJTZXF1ZW5jZS5maW5kX2V4blwiXG4gIHwgU29tZSB4IC0+IHhcbjs7XG5cbmxldCBhcHBlbmQgczEgczIgPVxuICBtYXRjaCBzMSwgczIgd2l0aFxuICB8IFNlcXVlbmNlIChzMSwgbmV4dDEpLCBTZXF1ZW5jZSAoczIsIG5leHQyKSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIGBGaXJzdF9saXN0IHMxXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgYEZpcnN0X2xpc3QgczEgLT5cbiAgICAgICAgICAobWF0Y2ggbmV4dDEgczEgd2l0aFxuICAgICAgICAgICB8IERvbmUgLT4gU2tpcCAoYFNlY29uZF9saXN0IHMyKVxuICAgICAgICAgICB8IFNraXAgczEgLT4gU2tpcCAoYEZpcnN0X2xpc3QgczEpXG4gICAgICAgICAgIHwgWWllbGQgKGEsIHMxKSAtPiBZaWVsZCAoYSwgYEZpcnN0X2xpc3QgczEpKVxuICAgICAgICB8IGBTZWNvbmRfbGlzdCBzMiAtPlxuICAgICAgICAgIChtYXRjaCBuZXh0MiBzMiB3aXRoXG4gICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgIHwgU2tpcCBzMiAtPiBTa2lwIChgU2Vjb25kX2xpc3QgczIpXG4gICAgICAgICAgIHwgWWllbGQgKGEsIHMyKSAtPiBZaWVsZCAoYSwgYFNlY29uZF9saXN0IHMyKSkgKVxuOztcblxubGV0IGNvbmNhdF9tYXAgcyB+ZiA9IGJpbmQgcyB+ZlxubGV0IGNvbmNhdCBzID0gY29uY2F0X21hcCBzIH5mOkZuLmlkXG5sZXQgY29uY2F0X21hcGkgcyB+ZiA9IGNvbmNhdF9tYXAgKG1hcGkgcyB+ZjooZnVuIGkgcyAtPiBpLCBzKSkgfmY6KGZ1biAoaSwgcykgLT4gZiBpIHMpXG5cbmxldCB6aXAgKFNlcXVlbmNlIChzMSwgbmV4dDEpKSAoU2VxdWVuY2UgKHMyLCBuZXh0MikpID1cbiAgbGV0IG5leHQgPSBmdW5jdGlvblxuICAgIHwgWWllbGQgKGEsIHMxKSwgWWllbGQgKGIsIHMyKSAtPiBZaWVsZCAoKGEsIGIpLCAoU2tpcCBzMSwgU2tpcCBzMikpXG4gICAgfCBEb25lLCBfIHwgXywgRG9uZSAtPiBEb25lXG4gICAgfCBTa2lwIHMxLCBzMiAtPiBTa2lwIChuZXh0MSBzMSwgczIpXG4gICAgfCBzMSwgU2tpcCBzMiAtPiBTa2lwIChzMSwgbmV4dDIgczIpXG4gIGluXG4gIFNlcXVlbmNlICgoU2tpcCBzMSwgU2tpcCBzMiksIG5leHQpXG47O1xuXG5sZXQgemlwX2Z1bGwgKFNlcXVlbmNlIChzMSwgbmV4dDEpKSAoU2VxdWVuY2UgKHMyLCBuZXh0MikpID1cbiAgbGV0IG5leHQgPSBmdW5jdGlvblxuICAgIHwgWWllbGQgKGEsIHMxKSwgWWllbGQgKGIsIHMyKSAtPiBZaWVsZCAoYEJvdGggKGEsIGIpLCAoU2tpcCBzMSwgU2tpcCBzMikpXG4gICAgfCBEb25lLCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgczEsIHMyIC0+IFNraXAgKG5leHQxIHMxLCBzMilcbiAgICB8IHMxLCBTa2lwIHMyIC0+IFNraXAgKHMxLCBuZXh0MiBzMilcbiAgICB8IERvbmUsIFlpZWxkIChiLCBzMikgLT4gWWllbGQgKGBSaWdodCBiLCAoRG9uZSwgbmV4dDIgczIpKVxuICAgIHwgWWllbGQgKGEsIHMxKSwgRG9uZSAtPiBZaWVsZCAoYExlZnQgYSwgKG5leHQxIHMxLCBEb25lKSlcbiAgaW5cbiAgU2VxdWVuY2UgKChTa2lwIHMxLCBTa2lwIHMyKSwgbmV4dClcbjs7XG5cbmxldCBib3VuZGVkX2xlbmd0aCAoU2VxdWVuY2UgKHNlZWQsIG5leHQpKSB+YXRfbW9zdCA9XG4gIGxldCByZWMgbG9vcCBpIHNlZWQgbmV4dCA9XG4gICAgaWYgaSA+IGF0X21vc3RcbiAgICB0aGVuIGBHcmVhdGVyXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgfCBEb25lIC0+IGBJcyBpXG4gICAgICB8IFNraXAgc2VlZCAtPiBsb29wIGkgc2VlZCBuZXh0XG4gICAgICB8IFlpZWxkIChfLCBzZWVkKSAtPiBsb29wIChpICsgMSkgc2VlZCBuZXh0KVxuICBpblxuICBsb29wIDAgc2VlZCBuZXh0XG47O1xuXG5sZXQgbGVuZ3RoX2lzX2JvdW5kZWRfYnkgPyhtaW4gPSAtMSkgP21heCB0ID1cbiAgbGV0IGxlbmd0aF9pc19hdF9sZWFzdCAoU2VxdWVuY2UgKHMsIG5leHQpKSA9XG4gICAgbGV0IHJlYyBsb29wIHMgYWNjID1cbiAgICAgIGlmIGFjYyA+PSBtaW5cbiAgICAgIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgIHwgRG9uZSAtPiBmYWxzZVxuICAgICAgICB8IFNraXAgcyAtPiBsb29wIHMgYWNjXG4gICAgICAgIHwgWWllbGQgKF8sIHMpIC0+IGxvb3AgcyAoYWNjICsgMSkpXG4gICAgaW5cbiAgICBsb29wIHMgMFxuICBpblxuICBtYXRjaCBtYXggd2l0aFxuICB8IE5vbmUgLT4gbGVuZ3RoX2lzX2F0X2xlYXN0IHRcbiAgfCBTb21lIG1heCAtPlxuICAgIChtYXRjaCBib3VuZGVkX2xlbmd0aCB0IH5hdF9tb3N0Om1heCB3aXRoXG4gICAgIHwgYElzIGxlbiB3aGVuIGxlbiA+PSBtaW4gLT4gdHJ1ZVxuICAgICB8IF8gLT4gZmFsc2UpXG47O1xuXG5sZXQgaXRlcmkgcyB+ZiA9IGl0ZXIgKG1hcGkgcyB+ZjooZnVuIGkgcyAtPiBpLCBzKSkgfmY6KGZ1biAoaSwgcykgLT4gZiBpIHMpXG5cbmxldCBmb2xkaSBzIH5pbml0IH5mID1cbiAgZm9sZCB+aW5pdCAobWFwaSBzIH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIGFjYyAoaSwgcykgLT4gZiBpIGFjYyBzKVxuOztcblxubGV0IHJlZHVjZSBzIH5mID1cbiAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIChhLCBzKSAtPiBTb21lIChmb2xkIHMgfmluaXQ6YSB+Zilcbjs7XG5cbmxldCByZWR1Y2VfZXhuIHMgfmYgPVxuICBtYXRjaCByZWR1Y2UgcyB+ZiB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNlcXVlbmNlLnJlZHVjZV9leG5cIlxuICB8IFNvbWUgcmVzIC0+IHJlc1xuOztcblxubGV0IGdyb3VwIChTZXF1ZW5jZSAocywgbmV4dCkpIH5icmVhayA9XG4gIHVuZm9sZF9zdGVwXG4gICAgfmluaXQ6KFNvbWUgKFtdLCBzKSlcbiAgICB+ZjooZnVuY3Rpb25cbiAgICAgIHwgTm9uZSAtPiBEb25lXG4gICAgICB8IFNvbWUgKGFjYywgcykgLT5cbiAgICAgICAgKG1hdGNoIGFjYywgbmV4dCBzIHdpdGhcbiAgICAgICAgIHwgXywgU2tpcCBzIC0+IFNraXAgKFNvbWUgKGFjYywgcykpXG4gICAgICAgICB8IFtdLCBEb25lIC0+IERvbmVcbiAgICAgICAgIHwgYWNjLCBEb25lIC0+IFlpZWxkIChMaXN0LnJldiBhY2MsIE5vbmUpXG4gICAgICAgICB8IFtdLCBZaWVsZCAoY3VyLCBzKSAtPiBTa2lwIChTb21lIChbIGN1ciBdLCBzKSlcbiAgICAgICAgIHwgKHByZXYgOjogXyBhcyBhY2MpLCBZaWVsZCAoY3VyLCBzKSAtPlxuICAgICAgICAgICBpZiBicmVhayBwcmV2IGN1clxuICAgICAgICAgICB0aGVuIFlpZWxkIChMaXN0LnJldiBhY2MsIFNvbWUgKFsgY3VyIF0sIHMpKVxuICAgICAgICAgICBlbHNlIFNraXAgKFNvbWUgKGN1ciA6OiBhY2MsIHMpKSkpXG47O1xuXG5sZXQgZmluZF9jb25zZWN1dGl2ZV9kdXBsaWNhdGUgKFNlcXVlbmNlIChzLCBuZXh0KSkgfmVxdWFsID1cbiAgbGV0IHJlYyBsb29wIGxhc3RfZWx0IHMgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFNraXAgcyAtPiBsb29wIGxhc3RfZWx0IHNcbiAgICB8IFlpZWxkIChhLCBzKSAtPlxuICAgICAgKG1hdGNoIGxhc3RfZWx0IHdpdGhcbiAgICAgICB8IFNvbWUgYiB3aGVuIGVxdWFsIGEgYiAtPiBTb21lIChiLCBhKVxuICAgICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBsb29wIChTb21lIGEpIHMpXG4gIGluXG4gIGxvb3AgTm9uZSBzXG47O1xuXG5sZXQgcmVtb3ZlX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZXMgcyB+ZXF1YWwgPVxuICB1bmZvbGRfd2l0aCBzIH5pbml0Ok5vbmUgfmY6KGZ1biBwcmV2IGEgLT5cbiAgICBtYXRjaCBwcmV2IHdpdGhcbiAgICB8IFNvbWUgYiB3aGVuIGVxdWFsIGEgYiAtPiBTa2lwIChTb21lIGEpXG4gICAgfCBOb25lIHwgU29tZSBfIC0+IFlpZWxkIChhLCBTb21lIGEpKVxuOztcblxubGV0IGNvdW50IHMgfmYgPSBsZW5ndGggKGZpbHRlciBzIH5mKVxubGV0IGNvdW50aSB0IH5mID0gbGVuZ3RoIChmaWx0ZXJpIHQgfmYpXG5sZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG5sZXQgbWluX2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZVxubGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcblxubGV0IGluaXQgbiB+ZiA9XG4gIHVuZm9sZF9zdGVwIH5pbml0OjAgfmY6KGZ1biBpIC0+IGlmIGkgPj0gbiB0aGVuIERvbmUgZWxzZSBZaWVsZCAoZiBpLCBpICsgMSkpXG47O1xuXG5sZXQgc3ViIHMgfnBvcyB+bGVuID1cbiAgaWYgcG9zIDwgMCB8fCBsZW4gPCAwIHRoZW4gZmFpbHdpdGggXCJTZXF1ZW5jZS5zdWJcIjtcbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggKDAsIHMpXG4gICAgICAsIGZ1biAoaSwgcykgLT5cbiAgICAgICAgaWYgaSAtIHBvcyA+PSBsZW5cbiAgICAgICAgdGhlbiBEb25lXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChpLCBzKVxuICAgICAgICAgIHwgWWllbGQgKGEsIHMpIHdoZW4gaSA+PSBwb3MgLT4gWWllbGQgKGEsIChpICsgMSwgcykpXG4gICAgICAgICAgfCBZaWVsZCAoXywgcykgLT4gU2tpcCAoaSArIDEsIHMpKSApXG47O1xuXG5sZXQgdGFrZSBzIGxlbiA9XG4gIGlmIGxlbiA8IDAgdGhlbiBmYWlsd2l0aCBcIlNlcXVlbmNlLnRha2VcIjtcbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggKDAsIHMpXG4gICAgICAsIGZ1biAoaSwgcykgLT5cbiAgICAgICAgaWYgaSA+PSBsZW5cbiAgICAgICAgdGhlbiBEb25lXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChpLCBzKVxuICAgICAgICAgIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChhLCAoaSArIDEsIHMpKSkgKVxuOztcblxubGV0IGRyb3AgcyBsZW4gPVxuICBpZiBsZW4gPCAwIHRoZW4gZmFpbHdpdGggXCJTZXF1ZW5jZS5kcm9wXCI7XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoICgwLCBzKVxuICAgICAgLCBmdW4gKGksIHMpIC0+XG4gICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKGksIHMpXG4gICAgICAgIHwgWWllbGQgKGEsIHMpIHdoZW4gaSA+PSBsZW4gLT4gWWllbGQgKGEsIChpICsgMSwgcykpXG4gICAgICAgIHwgWWllbGQgKF8sIHMpIC0+IFNraXAgKGkgKyAxLCBzKSApXG47O1xuXG5sZXQgdGFrZV93aGlsZSBzIH5mID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggc1xuICAgICAgLCBmdW4gcyAtPlxuICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICB8IFNraXAgcyAtPiBTa2lwIHNcbiAgICAgICAgfCBZaWVsZCAoYSwgcykgd2hlbiBmIGEgLT4gWWllbGQgKGEsIHMpXG4gICAgICAgIHwgWWllbGQgKF8sIF8pIC0+IERvbmUgKVxuOztcblxubGV0IGRyb3Bfd2hpbGUgcyB+ZiA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIGBEcm9wcGluZyBzXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgYERyb3BwaW5nIHMgLT5cbiAgICAgICAgICAobWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoYERyb3BwaW5nIHMpXG4gICAgICAgICAgIHwgWWllbGQgKGEsIHMpIHdoZW4gZiBhIC0+IFNraXAgKGBEcm9wcGluZyBzKVxuICAgICAgICAgICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoYSwgYElkZW50aXR5IHMpKVxuICAgICAgICB8IGBJZGVudGl0eSBzIC0+IGxpZnRfaWRlbnRpdHkgbmV4dCBzIClcbjs7XG5cbmxldCBzaGlmdF9yaWdodCBzIHggPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCBgQ29uc2luZyAoc2VlZCwgeClcbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBgQ29uc2luZyAoc2VlZCwgeCkgLT4gWWllbGQgKHgsIGBJZGVudGl0eSBzZWVkKVxuICAgICAgICB8IGBJZGVudGl0eSBzIC0+IGxpZnRfaWRlbnRpdHkgbmV4dCBzIClcbjs7XG5cbmxldCBzaGlmdF9yaWdodF93aXRoX2xpc3QgcyBsID0gYXBwZW5kIChvZl9saXN0IGwpIHNcbmxldCBzaGlmdF9sZWZ0ID0gZHJvcFxuXG5tb2R1bGUgSW5maXggPSBzdHJ1Y3RcbiAgbGV0ICggQCApID0gYXBwZW5kXG5lbmRcblxubGV0IGludGVyc3BlcnNlIHMgfnNlcCA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIGBJbml0IHNcbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBgSW5pdCBzIC0+XG4gICAgICAgICAgKG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKGBJbml0IHMpXG4gICAgICAgICAgIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChhLCBgUnVubmluZyBzKSlcbiAgICAgICAgfCBgUnVubmluZyBzIC0+XG4gICAgICAgICAgKG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKGBSdW5uaW5nIHMpXG4gICAgICAgICAgIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChzZXAsIGBQdXR0aW5nIChhLCBzKSkpXG4gICAgICAgIHwgYFB1dHRpbmcgKGEsIHMpIC0+IFlpZWxkIChhLCBgUnVubmluZyBzKSApXG47O1xuXG5sZXQgcmVwZWF0IHggPSB1bmZvbGRfc3RlcCB+aW5pdDp4IH5mOihmdW4geCAtPiBZaWVsZCAoeCwgeCkpXG5cbmxldCBjeWNsZV9saXN0X2V4biB4cyA9XG4gIGlmIExpc3QuaXNfZW1wdHkgeHMgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcXVlbmNlLmN5Y2xlX2xpc3RfZXhuXCI7XG4gIGxldCBzID0gb2ZfbGlzdCB4cyBpblxuICBjb25jYXRfbWFwIH5mOihmdW4gKCkgLT4gcykgKHJlcGVhdCAoKSlcbjs7XG5cbmxldCBjYXJ0ZXNpYW5fcHJvZHVjdCBzYSBzYiA9IGNvbmNhdF9tYXAgc2EgfmY6KGZ1biBhIC0+IHppcCAocmVwZWF0IGEpIHNiKVxubGV0IHNpbmdsZXRvbiB4ID0gcmV0dXJuIHhcblxubGV0IGRlbGF5ZWRfZm9sZCBzIH5pbml0IH5mIH5maW5pc2ggPVxuICBFeHBlcnQuZGVsYXllZF9mb2xkX3N0ZXAgcyB+aW5pdCB+ZmluaXNoIH5mOihmdW4gYWNjIG9wdGlvbiB+ayAtPlxuICAgIG1hdGNoIG9wdGlvbiB3aXRoXG4gICAgfCBOb25lIC0+IGsgYWNjXG4gICAgfCBTb21lIGEgLT4gZiBhY2MgYSB+aylcbjs7XG5cbmxldCBmb2xkX20gfmJpbmQgfnJldHVybiB0IH5pbml0IH5mID1cbiAgRXhwZXJ0LmRlbGF5ZWRfZm9sZF9zdGVwXG4gICAgdFxuICAgIH5pbml0XG4gICAgfmY6KGZ1biBhY2Mgb3B0aW9uIH5rIC0+XG4gICAgICBtYXRjaCBvcHRpb24gd2l0aFxuICAgICAgfCBOb25lIC0+IGJpbmQgKHJldHVybiBhY2MpIH5mOmtcbiAgICAgIHwgU29tZSBhIC0+IGJpbmQgKGYgYWNjIGEpIH5mOmspXG4gICAgfmZpbmlzaDpyZXR1cm5cbjs7XG5cbmxldCBpdGVyX20gfmJpbmQgfnJldHVybiB0IH5mID1cbiAgRXhwZXJ0LmRlbGF5ZWRfZm9sZF9zdGVwXG4gICAgdFxuICAgIH5pbml0OigpXG4gICAgfmY6KGZ1biAoKSBvcHRpb24gfmsgLT5cbiAgICAgIG1hdGNoIG9wdGlvbiB3aXRoXG4gICAgICB8IE5vbmUgLT4gYmluZCAocmV0dXJuICgpKSB+ZjprXG4gICAgICB8IFNvbWUgYSAtPiBiaW5kIChmIGEpIH5mOmspXG4gICAgfmZpbmlzaDpyZXR1cm5cbjs7XG5cbmxldCBmb2xkX3VudGlsIHMgfmluaXQgfmYgfmZpbmlzaCA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiBhY2MgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IGZpbmlzaCBhY2NcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBmIGFjY1xuICAgIHwgWWllbGQgKGEsIHMpIC0+XG4gICAgICAobWF0Y2ggKGYgYWNjIGEgOiAoJ2EsICdiKSBDb250aW51ZV9vcl9zdG9wLnQpIHdpdGhcbiAgICAgICB8IFN0b3AgeCAtPiB4XG4gICAgICAgfCBDb250aW51ZSBhY2MgLT4gbG9vcCBzIG5leHQgZiBhY2MpXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPiBsb29wIHMgbmV4dCBmIGluaXRcbjs7XG5cbmxldCBmb2xkX3Jlc3VsdCBzIH5pbml0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmIGFjYyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gUmVzdWx0LnJldHVybiBhY2NcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBmIGFjY1xuICAgIHwgWWllbGQgKGEsIHMpIC0+XG4gICAgICAobWF0Y2ggKGYgYWNjIGEgOiAoXywgXykgUmVzdWx0LnQpIHdpdGhcbiAgICAgICB8IEVycm9yIF8gYXMgZSAtPiBlXG4gICAgICAgfCBPayBhY2MgLT4gbG9vcCBzIG5leHQgZiBhY2MpXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPiBsb29wIHMgbmV4dCBmIGluaXRcbjs7XG5cbmxldCBmb3JjZV9lYWdlcmx5IHQgPSBvZl9saXN0ICh0b19saXN0IHQpXG5cbmxldCBtZW1vaXplICh0eXBlIGEpIChTZXF1ZW5jZSAocywgbmV4dCkpID1cbiAgbGV0IG1vZHVsZSBNID0gc3RydWN0XG4gICAgdHlwZSB0ID0gVCBvZiAoYSwgdCkgU3RlcC50IExhenkudFxuICBlbmRcbiAgaW5cbiAgbGV0IHJlYyBtZW1vaXplIHMgPSBNLlQgKGxhenkgKGZpbmRfc3RlcCBzKSlcbiAgYW5kIGZpbmRfc3RlcCBzID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBEb25lXG4gICAgfCBTa2lwIHMgLT4gZmluZF9zdGVwIHNcbiAgICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoYSwgbWVtb2l6ZSBzKVxuICBpblxuICBTZXF1ZW5jZSAobWVtb2l6ZSBzLCBmdW4gKE0uVCBsKSAtPiBMYXp5LmZvcmNlIGwpXG47O1xuXG5sZXQgZHJvcF9lYWdlcmx5IHMgbGVuID1cbiAgbGV0IHJlYyBsb29wIGkgfmxlbiBzIG5leHQgPVxuICAgIGlmIGkgPj0gbGVuXG4gICAgdGhlbiBTZXF1ZW5jZSAocywgbmV4dClcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICB8IERvbmUgLT4gZW1wdHlcbiAgICAgIHwgU2tpcCBzIC0+IGxvb3AgaSB+bGVuIHMgbmV4dFxuICAgICAgfCBZaWVsZCAoXywgcykgLT4gbG9vcCAoaSArIDEpIH5sZW4gcyBuZXh0KVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT4gbG9vcCAwIH5sZW4gcyBuZXh0XG47O1xuXG5sZXQgZHJvcF93aGlsZV9vcHRpb24gKFNlcXVlbmNlIChzLCBuZXh0KSkgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgU2tpcCBzIC0+IGxvb3Agc1xuICAgIHwgWWllbGQgKHgsIHMpIC0+IGlmIGYgeCB0aGVuIGxvb3AgcyBlbHNlIFNvbWUgKHgsIFNlcXVlbmNlIChzLCBuZXh0KSlcbiAgaW5cbiAgbG9vcCBzXG47O1xuXG5sZXQgY29tcGFyZSBjb21wYXJlX2EgdDEgdDIgPVxuICBXaXRoX3JldHVybi53aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyICh6aXBfZnVsbCB0MSB0MikgfmY6KGZ1bmN0aW9uXG4gICAgICB8IGBMZWZ0IF8gLT4gci5yZXR1cm4gMVxuICAgICAgfCBgUmlnaHQgXyAtPiByLnJldHVybiAoLTEpXG4gICAgICB8IGBCb3RoICh2MSwgdjIpIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9hIHYxIHYyIGluXG4gICAgICAgIGlmIGMgPD4gMCB0aGVuIHIucmV0dXJuIGMpO1xuICAgIDApXG47O1xuXG5sZXQgZXF1YWwgZXF1YWxfYSB0MSB0MiA9XG4gIGZvcl9hbGwgKHppcF9mdWxsIHQxIHQyKSB+ZjooZnVuY3Rpb25cbiAgICB8IGBCb3RoIChhMSwgYTIpIC0+IGVxdWFsX2EgYTEgYTJcbiAgICB8IGBMZWZ0IF8gfCBgUmlnaHQgXyAtPiBmYWxzZSlcbjs7XG5cbmxldCByb3VuZF9yb2JpbiBsaXN0ID1cbiAgbGV0IG5leHQgKHRvZG9fc3RhY2ssIGRvbmVfc3RhY2spID1cbiAgICBtYXRjaCB0b2RvX3N0YWNrIHdpdGhcbiAgICB8IFNlcXVlbmNlIChzLCBmKSA6OiB0b2RvX3N0YWNrIC0+XG4gICAgICAobWF0Y2ggZiBzIHdpdGhcbiAgICAgICB8IFlpZWxkICh4LCBzKSAtPiBZaWVsZCAoeCwgKHRvZG9fc3RhY2ssIFNlcXVlbmNlIChzLCBmKSA6OiBkb25lX3N0YWNrKSlcbiAgICAgICB8IFNraXAgcyAtPiBTa2lwIChTZXF1ZW5jZSAocywgZikgOjogdG9kb19zdGFjaywgZG9uZV9zdGFjaylcbiAgICAgICB8IERvbmUgLT4gU2tpcCAodG9kb19zdGFjaywgZG9uZV9zdGFjaykpXG4gICAgfCBbXSAtPiBpZiBMaXN0LmlzX2VtcHR5IGRvbmVfc3RhY2sgdGhlbiBEb25lIGVsc2UgU2tpcCAoTGlzdC5yZXYgZG9uZV9zdGFjaywgW10pXG4gIGluXG4gIGxldCBzdGF0ZSA9IGxpc3QsIFtdIGluXG4gIFNlcXVlbmNlIChzdGF0ZSwgbmV4dClcbjs7XG5cbmxldCBpbnRlcmxlYXZlIChTZXF1ZW5jZSAoczEsIGYxKSkgPVxuICBsZXQgbmV4dCAodG9kb19zdGFjaywgZG9uZV9zdGFjaywgczEpID1cbiAgICBtYXRjaCB0b2RvX3N0YWNrIHdpdGhcbiAgICB8IFNlcXVlbmNlIChzMiwgZjIpIDo6IHRvZG9fc3RhY2sgLT5cbiAgICAgIChtYXRjaCBmMiBzMiB3aXRoXG4gICAgICAgfCBZaWVsZCAoeCwgczIpIC0+IFlpZWxkICh4LCAodG9kb19zdGFjaywgU2VxdWVuY2UgKHMyLCBmMikgOjogZG9uZV9zdGFjaywgczEpKVxuICAgICAgIHwgU2tpcCBzMiAtPiBTa2lwICh0b2RvX3N0YWNrLCBTZXF1ZW5jZSAoczIsIGYyKSA6OiBkb25lX3N0YWNrLCBzMSlcbiAgICAgICB8IERvbmUgLT4gU2tpcCAodG9kb19zdGFjaywgZG9uZV9zdGFjaywgczEpKVxuICAgIHwgW10gLT5cbiAgICAgIChtYXRjaCBmMSBzMSwgZG9uZV9zdGFjayB3aXRoXG4gICAgICAgfCBZaWVsZCAodCwgczEpLCBfIC0+IFNraXAgKExpc3QucmV2ICh0IDo6IGRvbmVfc3RhY2spLCBbXSwgczEpXG4gICAgICAgfCBTa2lwIHMxLCBfIC0+IFNraXAgKExpc3QucmV2IGRvbmVfc3RhY2ssIFtdLCBzMSlcbiAgICAgICB8IERvbmUsIF8gOjogXyAtPiBTa2lwIChMaXN0LnJldiBkb25lX3N0YWNrLCBbXSwgczEpXG4gICAgICAgfCBEb25lLCBbXSAtPiBEb25lKVxuICBpblxuICBsZXQgc3RhdGUgPSBbXSwgW10sIHMxIGluXG4gIFNlcXVlbmNlIChzdGF0ZSwgbmV4dClcbjs7XG5cbmxldCBpbnRlcmxlYXZlZF9jYXJ0ZXNpYW5fcHJvZHVjdCBzMSBzMiA9XG4gIG1hcCBzMSB+ZjooZnVuIHgxIC0+IG1hcCBzMiB+ZjooZnVuIHgyIC0+IHgxLCB4MikpIHw+IGludGVybGVhdmVcbjs7XG5cbmxldCBvZl9zZXEgKHNlcSA6IF8gQ2FtbC5TZXEudCkgPVxuICB1bmZvbGRfc3RlcCB+aW5pdDpzZXEgfmY6KGZ1biBzZXEgLT5cbiAgICBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgTmlsIC0+IERvbmVcbiAgICB8IENvbnMgKGhkLCB0bCkgLT4gWWllbGQgKGhkLCB0bCkpXG47O1xuXG5sZXQgdG9fc2VxIChTZXF1ZW5jZSAoc3RhdGUsIG5leHQpKSA9XG4gIGxldCByZWMgbG9vcCBzdGF0ZSA9XG4gICAgbWF0Y2ggbmV4dCBzdGF0ZSB3aXRoXG4gICAgfCBEb25lIC0+IENhbWwuU2VxLk5pbFxuICAgIHwgU2tpcCBzdGF0ZSAtPiBsb29wIHN0YXRlXG4gICAgfCBZaWVsZCAoaGQsIHN0YXRlKSAtPiBDYW1sLlNlcS5Db25zIChoZCwgZnVuICgpIC0+IGxvb3Agc3RhdGUpXG4gIGluXG4gIGZ1biAoKSAtPiBsb29wIHN0YXRlXG47O1xuXG5tb2R1bGUgR2VuZXJhdG9yID0gc3RydWN0XG4gIHR5cGUgJ2VsdCBzdGVwcyA9IFdyYXAgb2YgKCdlbHQsIHVuaXQgLT4gJ2VsdCBzdGVwcykgU3RlcC50XG5cbiAgbGV0IHVud3JhcCAoV3JhcCBzdGVwKSA9IHN0ZXBcblxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnZWx0KSB0ID0gKCdhIC0+ICdlbHQgc3RlcHMpIC0+ICdlbHQgc3RlcHNcblxuICAgIGxldCByZXR1cm4geCBrID0gayB4XG5cbiAgICBsZXQgYmluZCBtIH5mIGsgPVxuICAgICAgbSAoZnVuIGEgLT5cbiAgICAgICAgbGV0IG0nID0gZiBhIGluXG4gICAgICAgIG0nIGspXG4gICAgOztcblxuICAgIGxldCBtYXAgbSB+ZiBrID0gbSAoZnVuIGEgLT4gayAoZiBhKSlcbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgTW9uYWQuTWFrZTIgKFQpXG5cbiAgbGV0IHlpZWxkIGUgayA9IFdyYXAgKFlpZWxkIChlLCBrKSlcbiAgbGV0IHRvX3N0ZXBzIHQgPSB0IChmdW4gKCkgLT4gV3JhcCBEb25lKVxuXG4gIGxldCBvZl9zZXF1ZW5jZSBzZXF1ZW5jZSA9XG4gICAgZGVsYXllZF9mb2xkXG4gICAgICBzZXF1ZW5jZVxuICAgICAgfmluaXQ6KClcbiAgICAgIH5mOihmdW4gKCkgeCB+ayBmIC0+IFdyYXAgKFlpZWxkICh4LCBmdW4gKCkgLT4gayAoKSBmKSkpXG4gICAgICB+ZmluaXNoOnJldHVyblxuICA7O1xuXG4gIGxldCBydW4gdCA9XG4gICAgbGV0IGluaXQgKCkgPSB0b19zdGVwcyB0IGluXG4gICAgbGV0IGYgdGh1bmsgPSB1bndyYXAgKHRodW5rICgpKSBpblxuICAgIHVuZm9sZF9zdGVwIH5pbml0IH5mXG4gIDs7XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBBcnJheTBcblxudHlwZSAnYSB0ID0gJ2EgYXJyYXkgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9IGNvbXBhcmVfYXJyYXlcbmxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPSBhcnJheV9vZl9zZXhwXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID0gc2V4cF9vZl9hcnJheVxuXG5sZXQgKHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBhcnJheV9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuOztcblxuW0BAQGVuZF1cblxuKCogVGhpcyBtb2R1bGUgaW1wbGVtZW50cyBhIG5ldyBpbi1wbGFjZSwgY29uc3RhbnQgaGVhcCBzb3J0aW5nIGFsZ29yaXRobSB0byByZXBsYWNlIHRoZVxuICAgb25lIHVzZWQgYnkgdGhlIHN0YW5kYXJkIGxpYnJhcmllcy4gIEl0cyBvbmx5IHB1cnBvc2UgaXMgdG8gYmUgZmFzdGVyIChob3BlZnVsbHlcbiAgIHN0cmljdGx5IGZhc3RlcikgdGhhbiB0aGUgYmFzZSBzb3J0IGFuZCBzdGFibGVfc29ydC5cblxuICAgQXQgYSBoaWdoIGxldmVsIHRoZSBhbGdvcml0aG0gaXM6XG4gICAtIHBpY2sgdHdvIHBpdm90IHBvaW50cyBieTpcbiAgIC0gcGljayA1IGFyYml0cmFyeSBlbGVtZW50cyBmcm9tIHRoZSBhcnJheVxuICAgLSBzb3J0IHRoZW0gd2l0aGluIHRoZSBhcnJheVxuICAgLSB0YWtlIHRoZSBlbGVtZW50cyBvbiBlaXRoZXIgc2lkZSBvZiB0aGUgbWlkZGxlIGVsZW1lbnQgb2YgdGhlIHNvcnQgYXMgdGhlIHBpdm90c1xuICAgLSBzb3J0IHRoZSBhcnJheSB3aXRoOlxuICAgLSBhbGwgZWxlbWVudHMgbGVzcyB0aGFuIHBpdm90MSB0byB0aGUgbGVmdCAocmFuZ2UgMSlcbiAgIC0gYWxsIGVsZW1lbnRzID49IHBpdm90MSBhbmQgPD0gcGl2b3QyIGluIHRoZSBtaWRkbGUgKHJhbmdlIDIpXG4gICAtIGFsbCBlbGVtZW50cyA+IHBpdm90MiB0byB0aGUgcmlnaHQgKHJhbmdlIDMpXG4gICAtIGlmIHBpdm90MSBhbmQgcGl2b3QyIGFyZSBlcXVhbCwgdGhlbiB0aGUgbWlkZGxlIHJhbmdlIGlzIHNvcnRlZCwgc28gaWdub3JlIGl0XG4gICAtIHJlY3Vyc2UgaW50byByYW5nZSAxLCAyIChpZiBwaXZvdDEgYW5kIHBpdm90MiBhcmUgdW5lcXVhbCksIGFuZCAzXG4gICAtIGR1cmluZyByZWN1cnNpb24gdGhlcmUgYXJlIHR3byBpbmZsZWN0aW9uIHBvaW50czpcbiAgIC0gaWYgdGhlIHNpemUgb2YgdGhlIGN1cnJlbnQgcmFuZ2UgaXMgc21hbGwsIHVzZSBpbnNlcnRpb24gc29ydCB0byBzb3J0IGl0XG4gICAtIGlmIHRoZSBzdGFjayBkZXB0aCBpcyBsYXJnZSwgc29ydCB0aGUgcmFuZ2Ugd2l0aCBoZWFwLXNvcnQgdG8gYXZvaWQgbl4yIHdvcnN0LWNhc2VcbiAgICAgYmVoYXZpb3JcblxuICAgU2VlIHRoZSBmb2xsb3dpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb246XG4gICAtIFwiRHVhbC1QaXZvdCBRdWlja3NvcnRcIiBieSBWbGFkaW1pciBZYXJvc2xhdnNraXkuXG4gICAgIEF2YWlsYWJsZSBhdFxuICAgICBodHRwOi8vd3d3LmtyaWNoZS5jb20uYXIvcm9vdC9wcm9ncmFtbWluZy9zcGFjZVRpbWVDb21wbGV4aXR5L0R1YWxQaXZvdFF1aWNrc29ydC5wZGZcbiAgIC0gXCJRdWlja3NvcnQgaXMgT3B0aW1hbFwiIGJ5IFNlZGdld2ljayBhbmQgQmVudGxleS5cbiAgICAgU2xpZGVzIGF0IGh0dHA6Ly93d3cuY3MucHJpbmNldG9uLmVkdS9+cnMvdGFsa3MvUXVpY2tzb3J0SXNPcHRpbWFsLnBkZlxuICAgLSBodHRwOi8vd3d3LnNvcnRpbmctYWxnb3JpdGhtcy5jb20vcXVpY2stc29ydC0zLXdheSAqKVxuXG5tb2R1bGUgU29ydCA9IHN0cnVjdFxuICAoKiBGb3IgdGhlIHNha2Ugb2Ygc3BlZWQgd2UgY291bGQgdXNlIHVuc2FmZSBnZXQvc2V0IHRocm91Z2hvdXQsIGJ1dCBzcGVlZCB0ZXN0cyBkb24ndFxuICAgICBzaG93IGEgc2lnbmlmaWNhbnQgaW1wcm92ZW1lbnQuICopXG4gIGxldCBnZXQgPSBnZXRcbiAgbGV0IHNldCA9IHNldFxuXG4gIGxldCBzd2FwIGFyciBpIGogPVxuICAgIGxldCB0bXAgPSBnZXQgYXJyIGkgaW5cbiAgICBzZXQgYXJyIGkgKGdldCBhcnIgaik7XG4gICAgc2V0IGFyciBqIHRtcFxuICA7O1xuXG4gIG1vZHVsZSB0eXBlIFNvcnQgPSBzaWdcbiAgICB2YWwgc29ydFxuICAgICAgOiAgJ2EgdFxuICAgICAgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KVxuICAgICAgLT4gbGVmdDppbnQgKCogbGVmdG1vc3QgaW5kZXggb2Ygc3ViLWFycmF5IHRvIHNvcnQgKilcbiAgICAgIC0+IHJpZ2h0OmludCAoKiByaWdodG1vc3QgaW5kZXggb2Ygc3ViLWFycmF5IHRvIHNvcnQgKilcbiAgICAgIC0+IHVuaXRcbiAgZW5kXG5cbiAgKCogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnNlcnRpb25fc29ydCAqKVxuICBtb2R1bGUgSW5zZXJ0aW9uX3NvcnQgOiBTb3J0ID0gc3RydWN0XG4gICAgbGV0IHNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICAoKiBsb29wIGludmFyaWFudDpcbiAgICAgICAgIFthcnJdIGlzIHNvcnRlZCBmcm9tIFtsZWZ0XSB0byBbcG9zIC0gMV0sIGluY2x1c2l2ZSAqKVxuICAgICAgZm9yIHBvcyA9IGxlZnQgKyAxIHRvIHJpZ2h0IGRvXG4gICAgICAgICgqIGxvb3AgaW52YXJpYW50czpcbiAgICAgICAgICAgMS4gIHRoZSBzdWJhcnJheSBhcnJbbGVmdCAuLiBpLTFdIGlzIHNvcnRlZFxuICAgICAgICAgICAyLiAgdGhlIHN1YmFycmF5IGFycltpKzEgLi4gcG9zXSBpcyBzb3J0ZWQgYW5kIGNvbnRhaW5zIG9ubHkgZWxlbWVudHMgPiB2XG4gICAgICAgICAgIDMuICBhcnJbaV0gbWF5IGJlIHRob3VnaHQgb2YgYXMgY29udGFpbmluZyB2XG5cbiAgICAgICAgICAgTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgYWxsb2NhdGUgYSBjbG9zdXJlLCBidXQgaXMgbGVmdCBpbiB0aGUgZm9yXG4gICAgICAgICAgIGxvb3AgZm9yIHRoZSByZWFkYWJpbGl0eSBvZiB0aGUgZG9jdW1lbnRhdGlvbi4gKilcbiAgICAgICAgbGV0IHJlYyBsb29wIGFyciB+bGVmdCB+Y29tcGFyZSBpIHYgPVxuICAgICAgICAgIGxldCBpX25leHQgPSBpIC0gMSBpblxuICAgICAgICAgIGlmIGlfbmV4dCA+PSBsZWZ0ICYmIGNvbXBhcmUgKGdldCBhcnIgaV9uZXh0KSB2ID4gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgc2V0IGFyciBpIChnZXQgYXJyIGlfbmV4dCk7XG4gICAgICAgICAgICBsb29wIGFyciB+bGVmdCB+Y29tcGFyZSBpX25leHQgdilcbiAgICAgICAgICBlbHNlIGlcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHYgPSBnZXQgYXJyIHBvcyBpblxuICAgICAgICBsZXQgZmluYWxfcG9zID0gbG9vcCBhcnIgfmxlZnQgfmNvbXBhcmUgcG9zIHYgaW5cbiAgICAgICAgc2V0IGFyciBmaW5hbF9wb3MgdlxuICAgICAgZG9uZVxuICAgIDs7XG4gIGVuZFxuXG4gICgqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVhcHNvcnQgKilcbiAgbW9kdWxlIEhlYXBfc29ydCA6IFNvcnQgPSBzdHJ1Y3RcbiAgICAoKiBsb29wIGludmFyaWFudDpcbiAgICAgICByb290J3MgY2hpbGRyZW4gYXJlIGJvdGggZWl0aGVyIHJvb3RzIG9mIG1heC1oZWFwcyBvciA+IHJpZ2h0ICopXG4gICAgbGV0IHJlYyBoZWFwaWZ5IGFyciB+Y29tcGFyZSByb290IH5sZWZ0IH5yaWdodCA9XG4gICAgICBsZXQgcmVsYXRpdmVfcm9vdCA9IHJvb3QgLSBsZWZ0IGluXG4gICAgICBsZXQgbGVmdF9jaGlsZCA9ICgyICogcmVsYXRpdmVfcm9vdCkgKyBsZWZ0ICsgMSBpblxuICAgICAgbGV0IHJpZ2h0X2NoaWxkID0gKDIgKiByZWxhdGl2ZV9yb290KSArIGxlZnQgKyAyIGluXG4gICAgICBsZXQgbGFyZ2VzdCA9XG4gICAgICAgIGlmIGxlZnRfY2hpbGQgPD0gcmlnaHQgJiYgY29tcGFyZSAoZ2V0IGFyciBsZWZ0X2NoaWxkKSAoZ2V0IGFyciByb290KSA+IDBcbiAgICAgICAgdGhlbiBsZWZ0X2NoaWxkXG4gICAgICAgIGVsc2Ugcm9vdFxuICAgICAgaW5cbiAgICAgIGxldCBsYXJnZXN0ID1cbiAgICAgICAgaWYgcmlnaHRfY2hpbGQgPD0gcmlnaHQgJiYgY29tcGFyZSAoZ2V0IGFyciByaWdodF9jaGlsZCkgKGdldCBhcnIgbGFyZ2VzdCkgPiAwXG4gICAgICAgIHRoZW4gcmlnaHRfY2hpbGRcbiAgICAgICAgZWxzZSBsYXJnZXN0XG4gICAgICBpblxuICAgICAgaWYgbGFyZ2VzdCA8PiByb290XG4gICAgICB0aGVuIChcbiAgICAgICAgc3dhcCBhcnIgcm9vdCBsYXJnZXN0O1xuICAgICAgICBoZWFwaWZ5IGFyciB+Y29tcGFyZSBsYXJnZXN0IH5sZWZ0IH5yaWdodClcbiAgICA7O1xuXG4gICAgbGV0IGJ1aWxkX2hlYXAgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICAoKiBFbGVtZW50cyBpbiB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIGFycmF5IGFyZSBhbHJlYWR5IGhlYXBzIG9mIHNpemUgMS4gIFdlIG1vdmVcbiAgICAgICAgIHRocm91Z2ggdGhlIGZpcnN0IGhhbGYgb2YgdGhlIGFycmF5IGZyb20gYmFjayB0byBmcm9udCBleGFtaW5pbmcgdGhlIGVsZW1lbnQgYXRcbiAgICAgICAgIGhhbmQsIGFuZCB0aGUgbGVmdCBhbmQgcmlnaHQgY2hpbGRyZW4sIGZpeGluZyB0aGUgaGVhcCBwcm9wZXJ0eSBhcyB3ZSBnby4gKilcbiAgICAgIGZvciBpID0gKGxlZnQgKyByaWdodCkgLyAyIGRvd250byBsZWZ0IGRvXG4gICAgICAgIGhlYXBpZnkgYXJyIH5jb21wYXJlIGkgfmxlZnQgfnJpZ2h0XG4gICAgICBkb25lXG4gICAgOztcblxuICAgIGxldCBzb3J0IGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgPVxuICAgICAgYnVpbGRfaGVhcCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0O1xuICAgICAgKCogbG9vcCBpbnZhcmlhbnRzOlxuICAgICAgICAgMS4gIHRoZSBzdWJhcnJheSBhcnJbbGVmdCAuLi4gaV0gaXMgYSBtYXgtaGVhcCBIXG4gICAgICAgICAyLiAgdGhlIHN1YmFycmF5IGFycltpKzEgLi4uIHJpZ2h0XSBpcyBzb3J0ZWQgKGNhbGwgaXQgUylcbiAgICAgICAgIDMuICBldmVyeSBlbGVtZW50IG9mIEggaXMgbGVzcyB0aGFuIGV2ZXJ5IGVsZW1lbnQgb2YgUyAqKVxuICAgICAgZm9yIGkgPSByaWdodCBkb3dudG8gbGVmdCArIDEgZG9cbiAgICAgICAgc3dhcCBhcnIgbGVmdCBpO1xuICAgICAgICBoZWFwaWZ5IGFyciB+Y29tcGFyZSBsZWZ0IH5sZWZ0IH5yaWdodDooaSAtIDEpXG4gICAgICBkb25lXG4gICAgOztcbiAgZW5kXG5cbiAgKCogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRyb3NvcnQgKilcbiAgbW9kdWxlIEludHJvX3NvcnQgOiBzaWdcbiAgICBpbmNsdWRlIFNvcnRcblxuICAgIHZhbCBmaXZlX2VsZW1lbnRfc29ydFxuICAgICAgOiAgJ2EgdFxuICAgICAgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KVxuICAgICAgLT4gaW50XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IHVuaXRcbiAgZW5kID0gc3RydWN0XG4gICAgbGV0IGZpdmVfZWxlbWVudF9zb3J0IGFyciB+Y29tcGFyZSBtMSBtMiBtMyBtNCBtNSA9XG4gICAgICBsZXQgY29tcGFyZV9hbmRfc3dhcCBpIGogPVxuICAgICAgICBpZiBjb21wYXJlIChnZXQgYXJyIGkpIChnZXQgYXJyIGopID4gMCB0aGVuIHN3YXAgYXJyIGkgalxuICAgICAgaW5cbiAgICAgICgqIE9wdGltYWwgNS1lbGVtZW50IHNvcnRpbmcgbmV0d29yazpcblxuICAgICAgICAge3ZcbiAgICAgICAgICAgIDEtLW8tLS0tLW8tLS0tLW8tLS0tLS0tLS0tLS0tLTFcbiAgICAgICAgICAgICAgIHwgICAgIHwgICAgIHxcbiAgICAgICAgICAgIDItLW8tLS0tLXwtLW8tLXwtLS0tLW8tLW8tLS0tLTJcbiAgICAgICAgICAgICAgICAgICAgIHwgIHwgIHwgICAgIHwgIHxcbiAgICAgICAgICAgIDMtLS0tLS0tLW8tLW8tLXwtLW8tLXwtLW8tLS0tLTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHwgIHxcbiAgICAgICAgICAgIDQtLS0tLW8tLS0tLS0tLW8tLW8tLXwtLS0tLW8tLTRcbiAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHwgICAgIHxcbiAgICAgICAgICAgIDUtLS0tLW8tLS0tLS0tLS0tLS0tLW8tLS0tLW8tLTVcbiAgICAgICAgICB2fSAqKVxuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMSBtMjtcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTQgbTU7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0xIG0zO1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMiBtMztcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTEgbTQ7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0zIG00O1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMiBtNTtcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTIgbTM7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG00IG01XG4gICAgOztcblxuICAgICgqIGNob29zZSBwaXZvdHMgZm9yIHRoZSBhcnJheSBieSBzb3J0aW5nIDUgZWxlbWVudHMgYW5kIGV4YW1pbmluZyB0aGUgY2VudGVyIHRocmVlXG4gICAgICAgZWxlbWVudHMuICBUaGUgZ29hbCBpcyB0byBjaG9vc2UgdHdvIHBpdm90cyB0aGF0IHdpbGwgZWl0aGVyOlxuICAgICAgIC0gYnJlYWsgdGhlIHJhbmdlIHVwIGludG8gMyBldmVuIHBhcnRpdGlvbnNcbiAgICAgICAgIG9yXG4gICAgICAgLSBlbGltaW5hdGUgYSBjb21tb25seSBhcHBlYXJpbmcgZWxlbWVudCBieSBzb3J0aW5nIGl0IGludG8gdGhlIGNlbnRlciBwYXJ0aXRpb25cbiAgICAgICAgIGJ5IGl0c2VsZlxuICAgICAgICAgVG8gdGhpcyBlbmQgd2UgbG9vayBhdCB0aGUgY2VudGVyIDMgZWxlbWVudHMgb2YgdGhlIDUgYW5kIHJldHVybiBwYWlycyBvZiBlcXVhbFxuICAgICAgICAgZWxlbWVudHMgb3IgdGhlIHdpZGVzdCByYW5nZSAqKVxuICAgIGxldCBjaG9vc2VfcGl2b3RzIGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgPVxuICAgICAgbGV0IHNpeHRoID0gKHJpZ2h0IC0gbGVmdCkgLyA2IGluXG4gICAgICBsZXQgbTEgPSBsZWZ0ICsgc2l4dGggaW5cbiAgICAgIGxldCBtMiA9IG0xICsgc2l4dGggaW5cbiAgICAgIGxldCBtMyA9IG0yICsgc2l4dGggaW5cbiAgICAgIGxldCBtNCA9IG0zICsgc2l4dGggaW5cbiAgICAgIGxldCBtNSA9IG00ICsgc2l4dGggaW5cbiAgICAgIGZpdmVfZWxlbWVudF9zb3J0IGFyciB+Y29tcGFyZSBtMSBtMiBtMyBtNCBtNTtcbiAgICAgIGxldCBtMl92YWwgPSBnZXQgYXJyIG0yIGluXG4gICAgICBsZXQgbTNfdmFsID0gZ2V0IGFyciBtMyBpblxuICAgICAgbGV0IG00X3ZhbCA9IGdldCBhcnIgbTQgaW5cbiAgICAgIGlmIGNvbXBhcmUgbTJfdmFsIG0zX3ZhbCA9IDBcbiAgICAgIHRoZW4gbTJfdmFsLCBtM192YWwsIHRydWVcbiAgICAgIGVsc2UgaWYgY29tcGFyZSBtM192YWwgbTRfdmFsID0gMFxuICAgICAgdGhlbiBtM192YWwsIG00X3ZhbCwgdHJ1ZVxuICAgICAgZWxzZSBtMl92YWwsIG00X3ZhbCwgZmFsc2VcbiAgICA7O1xuXG4gICAgbGV0IGR1YWxfcGl2b3RfcGFydGl0aW9uIGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgPVxuICAgICAgbGV0IHBpdm90MSwgcGl2b3QyLCBwaXZvdHNfZXF1YWwgPSBjaG9vc2VfcGl2b3RzIGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQgaW5cbiAgICAgICgqIGxvb3AgaW52YXJpYW50czpcbiAgICAgICAgIDEuICBsZWZ0IDw9IGwgPCByIDw9IHJpZ2h0XG4gICAgICAgICAyLiAgbCA8PSBwIDw9IHJcbiAgICAgICAgIDMuICBsIDw9IHggPCBwICAgICBpbXBsaWVzIGFyclt4XSA+PSBwaXZvdDFcbiAgICAgICAgIGFuZCBhcnJbeF0gPD0gcGl2b3QyXG4gICAgICAgICA0LiAgbGVmdCA8PSB4IDwgbCAgaW1wbGllcyBhcnJbeF0gPCBwaXZvdDFcbiAgICAgICAgIDUuICByIDwgeCA8PSByaWdodCBpbXBsaWVzIGFyclt4XSA+IHBpdm90MiAqKVxuICAgICAgbGV0IHJlYyBsb29wIGwgcCByID1cbiAgICAgICAgbGV0IHB2ID0gZ2V0IGFyciBwIGluXG4gICAgICAgIGlmIGNvbXBhcmUgcHYgcGl2b3QxIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBzd2FwIGFyciBwIGw7XG4gICAgICAgICAgY29udCAobCArIDEpIChwICsgMSkgcilcbiAgICAgICAgZWxzZSBpZiBjb21wYXJlIHB2IHBpdm90MiA+IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgKCogbG9vcCBpbnZhcmlhbnRzOiAgc2FtZSBhcyB0aG9zZSBvZiB0aGUgb3V0ZXIgbG9vcCAqKVxuICAgICAgICAgIGxldCByZWMgc2Nhbl9iYWNrd2FyZHMgciA9XG4gICAgICAgICAgICBpZiByID4gcCAmJiBjb21wYXJlIChnZXQgYXJyIHIpIHBpdm90MiA+IDAgdGhlbiBzY2FuX2JhY2t3YXJkcyAociAtIDEpIGVsc2UgclxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IHIgPSBzY2FuX2JhY2t3YXJkcyByIGluXG4gICAgICAgICAgc3dhcCBhcnIgciBwO1xuICAgICAgICAgIGNvbnQgbCBwIChyIC0gMSkpXG4gICAgICAgIGVsc2UgY29udCBsIChwICsgMSkgclxuICAgICAgYW5kIGNvbnQgbCBwIHIgPSBpZiBwID4gciB0aGVuIGwsIHIgZWxzZSBsb29wIGwgcCByIGluXG4gICAgICBsZXQgbCwgciA9IGNvbnQgbGVmdCBsZWZ0IHJpZ2h0IGluXG4gICAgICBsLCByLCBwaXZvdHNfZXF1YWxcbiAgICA7O1xuXG4gICAgbGV0IHJlYyBpbnRyb19zb3J0IGFyciB+bWF4X2RlcHRoIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICBsZXQgbGVuID0gcmlnaHQgLSBsZWZ0ICsgMSBpblxuICAgICAgKCogVGhpcyB0YWtlcyBjYXJlIG9mIHNvbWUgZWRnZSBjYXNlcywgc3VjaCBhcyBsZWZ0ID4gcmlnaHQgb3IgdmVyeSBzaG9ydCBhcnJheXMsXG4gICAgICAgICBzaW5jZSBJbnNlcnRpb25fc29ydC5zb3J0IGhhbmRsZXMgdGhlc2UgY2FzZXMgcHJvcGVybHkuICBUaHVzIHdlIGRvbid0IG5lZWQgdG9cbiAgICAgICAgIG1ha2Ugc3VyZSB0aGF0IGxlZnQgYW5kIHJpZ2h0IGFyZSB2YWxpZCBpbiByZWN1cnNpdmUgY2FsbHMuICopXG4gICAgICBpZiBsZW4gPD0gMzJcbiAgICAgIHRoZW4gSW5zZXJ0aW9uX3NvcnQuc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0XG4gICAgICBlbHNlIGlmIG1heF9kZXB0aCA8IDBcbiAgICAgIHRoZW4gSGVhcF9zb3J0LnNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodFxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBtYXhfZGVwdGggPSBtYXhfZGVwdGggLSAxIGluXG4gICAgICAgIGxldCBsLCByLCBtaWRkbGVfc29ydGVkID0gZHVhbF9waXZvdF9wYXJ0aXRpb24gYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCBpblxuICAgICAgICBpbnRyb19zb3J0IGFyciB+bWF4X2RlcHRoIH5jb21wYXJlIH5sZWZ0IH5yaWdodDoobCAtIDEpO1xuICAgICAgICBpZiBub3QgbWlkZGxlX3NvcnRlZCB0aGVuIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGggfmNvbXBhcmUgfmxlZnQ6bCB+cmlnaHQ6cjtcbiAgICAgICAgaW50cm9fc29ydCBhcnIgfm1heF9kZXB0aCB+Y29tcGFyZSB+bGVmdDoociArIDEpIH5yaWdodClcbiAgICA7O1xuXG4gICAgbGV0IHNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICBsZXQgaGVhcF9zb3J0X3N3aXRjaF9kZXB0aCA9XG4gICAgICAgICgqIFdlIGJhaWwgb3V0IHRvIGhlYXAgc29ydCBhdCBhIHJlY3Vyc2lvbiBkZXB0aCBvZiAzMi4gR05VIGludHJvc29ydCB1c2VzIDJsZyhuKS5cbiAgICAgICAgICAgVGhlIGV4cGVjdGVkIHJlY3Vyc2lvbiBkZXB0aCBmb3IgcGVyZmVjdCAzLXdheSBzcGxpdHMgaXMgbG9nXzMobikuXG5cbiAgICAgICAgICAgVXNpbmcgMzIgbWVhbnMgYSBiYWxhbmNlZCAzLXdheSBzcGxpdCB3b3VsZCB3b3JrIHVwIHRvIDNeMzIgZWxlbWVudHMgKHJvdWdobHlcbiAgICAgICAgICAgMl41MCBvciAxMF4xNSkuIEdOVSByZWFjaGVzIGEgZGVwdGggb2YgMzIgYXQgNjU1MzYgZWxlbWVudHMuXG5cbiAgICAgICAgICAgRm9yIHNtYWxsIGFycmF5cywgdGhpcyBtYWtlcyB1cyBsZXNzIGxpa2VseSB0byBiYWlsIG91dCB0byBoZWFwIHNvcnQsIGJ1dCB0aGVcbiAgICAgICAgICAgMzIqTiBjb3N0IGJlZm9yZSB3ZSBkbyBpcyBub3QgdGhhdCBtdWNoLlxuXG4gICAgICAgICAgIEZvciBsYXJnZSBhcnJheXMsIHRoaXMgbWVhbnMgd2UgYXJlIG1vcmUgbGlrZWx5IHRvIGJhaWwgb3V0IHRvIGhlYXAgc29ydCBhdFxuICAgICAgICAgICBzb21lIHBvaW50IGlmIHdlIGdldCBzb21lIGJhZCBzcGxpdHMgb3IgaWYgdGhlIGFycmF5IGlzIGh1Z2UuIEJ1dCB0aGF0J3Mgb25seSBhXG4gICAgICAgICAgIGNvbnN0YW50IGZhY3RvciBjb3N0IGluIHRoZSBmaW5hbCBzdGFnZXMgb2YgcmVjdXJzaW9uLlxuXG4gICAgICAgICAgIEFsbCBpbiBhbGwsIHRoaXMgc2VlbXMgdG8gYmUgYSBzbWFsbCB0cmFkZW9mZiBhbmQgYXZvaWRzIHBheWluZyBhIGNvc3QgdG9cbiAgICAgICAgICAgY29tcHV0ZSBhIGxvZ2FyaXRobSBhdCB0aGUgc3RhcnQuICopXG4gICAgICAgIDMyXG4gICAgICBpblxuICAgICAgaW50cm9fc29ydCBhcnIgfm1heF9kZXB0aDpoZWFwX3NvcnRfc3dpdGNoX2RlcHRoIH5jb21wYXJlIH5sZWZ0IH5yaWdodFxuICAgIDs7XG4gIGVuZFxuZW5kXG5cbmxldCBzb3J0ID9wb3MgP2xlbiBhcnIgfmNvbXBhcmUgPVxuICBsZXQgcG9zLCBsZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uZ2V0X3Bvc19sZW5fZXhuICgpID9wb3MgP2xlbiB+dG90YWxfbGVuZ3RoOihsZW5ndGggYXJyKVxuICBpblxuICBTb3J0LkludHJvX3NvcnQuc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQ6cG9zIH5yaWdodDoocG9zICsgbGVuIC0gMSlcbjs7XG5cbmxldCB0b19hcnJheSB0ID0gdFxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxubGV0IGlzX3NvcnRlZCB0IH5jb21wYXJlID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID4gMCAmJiAhcmVzdWx0IGRvXG4gICAgbGV0IGVsdF9pID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgbGV0IGVsdF9pX21pbnVzXzEgPSB1bnNhZmVfZ2V0IHQgKCFpIC0gMSkgaW5cbiAgICBpZiBjb21wYXJlIGVsdF9pX21pbnVzXzEgZWx0X2kgPiAwIHRoZW4gcmVzdWx0IDo9IGZhbHNlO1xuICAgIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgaXNfc29ydGVkX3N0cmljdGx5IHQgfmNvbXBhcmUgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWkgPiAwICYmICFyZXN1bHQgZG9cbiAgICBsZXQgZWx0X2kgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICBsZXQgZWx0X2lfbWludXNfMSA9IHVuc2FmZV9nZXQgdCAoIWkgLSAxKSBpblxuICAgIGlmIGNvbXBhcmUgZWx0X2lfbWludXNfMSBlbHRfaSA+PSAwIHRoZW4gcmVzdWx0IDo9IGZhbHNlO1xuICAgIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgbWVyZ2UgYTEgYTIgfmNvbXBhcmUgPVxuICBsZXQgbDEgPSBBcnJheS5sZW5ndGggYTEgaW5cbiAgbGV0IGwyID0gQXJyYXkubGVuZ3RoIGEyIGluXG4gIGlmIGwxID0gMFxuICB0aGVuIGNvcHkgYTJcbiAgZWxzZSBpZiBsMiA9IDBcbiAgdGhlbiBjb3B5IGExXG4gIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhMiAwKSAodW5zYWZlX2dldCBhMSAobDEgLSAxKSkgPj0gMFxuICB0aGVuIGFwcGVuZCBhMSBhMlxuICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYTEgMCkgKHVuc2FmZV9nZXQgYTIgKGwyIC0gMSkpID4gMFxuICB0aGVuIGFwcGVuZCBhMiBhMVxuICBlbHNlIChcbiAgICBsZXQgbGVuID0gbDEgKyBsMiBpblxuICAgIGxldCBtZXJnZWQgPSBjcmVhdGUgfmxlbiAodW5zYWZlX2dldCBhMSAwKSBpblxuICAgIGxldCBhMV9pbmRleCA9IHJlZiAwIGluXG4gICAgbGV0IGEyX2luZGV4ID0gcmVmIDAgaW5cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IHVzZV9hMSA9XG4gICAgICAgIGlmIGwxID0gIWExX2luZGV4XG4gICAgICAgIHRoZW4gZmFsc2VcbiAgICAgICAgZWxzZSBpZiBsMiA9ICFhMl9pbmRleFxuICAgICAgICB0aGVuIHRydWVcbiAgICAgICAgZWxzZSBjb21wYXJlICh1bnNhZmVfZ2V0IGExICFhMV9pbmRleCkgKHVuc2FmZV9nZXQgYTIgIWEyX2luZGV4KSA8PSAwXG4gICAgICBpblxuICAgICAgaWYgdXNlX2ExXG4gICAgICB0aGVuIChcbiAgICAgICAgdW5zYWZlX3NldCBtZXJnZWQgaSAodW5zYWZlX2dldCBhMSAhYTFfaW5kZXgpO1xuICAgICAgICBhMV9pbmRleCA6PSAhYTFfaW5kZXggKyAxKVxuICAgICAgZWxzZSAoXG4gICAgICAgIHVuc2FmZV9zZXQgbWVyZ2VkIGkgKHVuc2FmZV9nZXQgYTIgIWEyX2luZGV4KTtcbiAgICAgICAgYTJfaW5kZXggOj0gIWEyX2luZGV4ICsgMSlcbiAgICBkb25lO1xuICAgIG1lcmdlZClcbjs7XG5cbmxldCBjb3B5X21hdHJpeCA9IG1hcCB+Zjpjb3B5XG5cbmxldCBmb2xkaW5nX21hcCB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIG1hcCB0IH5mOihmdW4geCAtPlxuICAgIGxldCBuZXdfYWNjLCB5ID0gZiAhYWNjIHggaW5cbiAgICBhY2MgOj0gbmV3X2FjYztcbiAgICB5KVxuOztcblxubGV0IGZvbGRfbWFwIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbGV0IHJlc3VsdCA9XG4gICAgbWFwIHQgfmY6KGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYywgeSA9IGYgIWFjYyB4IGluXG4gICAgICBhY2MgOj0gbmV3X2FjYztcbiAgICAgIHkpXG4gIGluXG4gICFhY2MsIHJlc3VsdFxuOztcblxubGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxubGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIHRcbmxldCBjb3VudCB0IH5mID0gQ29udGFpbmVyLmNvdW50IH5mb2xkIHQgfmZcbmxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcbmxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5sZXQgbWF4X2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuXG5sZXQgZm9sZGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgYWNjIDo9IGYgaSAhYWNjICh1bnNhZmVfZ2V0IHQgaSlcbiAgZG9uZTtcbiAgIWFjY1xuOztcblxubGV0IGZvbGRpbmdfbWFwaSB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIG1hcGkgdCB+ZjooZnVuIGkgeCAtPlxuICAgIGxldCBuZXdfYWNjLCB5ID0gZiBpICFhY2MgeCBpblxuICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgIHkpXG47O1xuXG5sZXQgZm9sZF9tYXBpIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbGV0IHJlc3VsdCA9XG4gICAgbWFwaSB0IH5mOihmdW4gaSB4IC0+XG4gICAgICBsZXQgbmV3X2FjYywgeSA9IGYgaSAhYWNjIHggaW5cbiAgICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgICAgeSlcbiAgaW5cbiAgIWFjYywgcmVzdWx0XG47O1xuXG5sZXQgY291bnRpIHQgfmYgPVxuICBmb2xkaSB0IH5pbml0OjAgfmY6KGZ1biBpZHggY291bnQgYSAtPiBpZiBmIGlkeCBhIHRoZW4gY291bnQgKyAxIGVsc2UgY291bnQpXG47O1xuXG5sZXQgY29uY2F0X21hcCB0IH5mID0gY29uY2F0ICh0b19saXN0IChtYXAgfmYgdCkpXG5sZXQgY29uY2F0X21hcGkgdCB+ZiA9IGNvbmNhdCAodG9fbGlzdCAobWFwaSB+ZiB0KSlcblxubGV0IHJldl9pbnBsYWNlIHQgPVxuICBsZXQgaSA9IHJlZiAwIGluXG4gIGxldCBqID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIHdoaWxlICFpIDwgIWogZG9cbiAgICBzd2FwIHQgIWkgIWo7XG4gICAgaW5jciBpO1xuICAgIGRlY3IgalxuICBkb25lXG47O1xuXG5sZXQgcmV2IHQgPVxuICBsZXQgdCA9IGNvcHkgdCBpblxuICByZXZfaW5wbGFjZSB0O1xuICB0XG47O1xuXG5sZXQgb2ZfbGlzdF9yZXYgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFt8fF1cbiAgfCBhIDo6IGwgLT5cbiAgICBsZXQgbGVuID0gMSArIExpc3QubGVuZ3RoIGwgaW5cbiAgICBsZXQgdCA9IGNyZWF0ZSB+bGVuIGEgaW5cbiAgICBsZXQgciA9IHJlZiBsIGluXG4gICAgKCogV2Ugc3RhcnQgYXQgW2xlbiAtIDJdIGJlY2F1c2Ugd2UgYWxyZWFkeSBwdXQgW2FdIGF0IFt0LihsZW4gLSAxKV0uICopXG4gICAgZm9yIGkgPSBsZW4gLSAyIGRvd250byAwIGRvXG4gICAgICBtYXRjaCAhciB3aXRoXG4gICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBhIDo6IGwgLT5cbiAgICAgICAgdC4oaSkgPC0gYTtcbiAgICAgICAgciA6PSBsXG4gICAgZG9uZTtcbiAgICB0XG47O1xuXG4oKiBbb2ZfbGlzdF9tYXBdIGFuZCBbb2ZfbGlzdF9yZXZfbWFwXSBhcmUgYmFzZWQgb24gZnVuY3Rpb25zIGZyb20gdGhlIE9DYW1sXG4gICBkaXN0cmlidXRpb24uICopXG5cbmxldCBvZl9saXN0X21hcCB4cyB+ZiA9XG4gIG1hdGNoIHhzIHdpdGhcbiAgfCBbXSAtPiBbfHxdXG4gIHwgaGQgOjogdGwgLT5cbiAgICBsZXQgYSA9IGNyZWF0ZSB+bGVuOigxICsgTGlzdC5sZW5ndGggdGwpIChmIGhkKSBpblxuICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gYVxuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICB1bnNhZmVfc2V0IGEgaSAoZiBoZCk7XG4gICAgICAgIGZpbGwgKGkgKyAxKSB0bFxuICAgIGluXG4gICAgZmlsbCAxIHRsXG47O1xuXG5sZXQgb2ZfbGlzdF9tYXBpIHhzIH5mID1cbiAgbWF0Y2ggeHMgd2l0aFxuICB8IFtdIC0+IFt8fF1cbiAgfCBoZCA6OiB0bCAtPlxuICAgIGxldCBhID0gY3JlYXRlIH5sZW46KDEgKyBMaXN0Lmxlbmd0aCB0bCkgKGYgMCBoZCkgaW5cbiAgICBsZXQgcmVjIGZpbGwgYSBpID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gYVxuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICB1bnNhZmVfc2V0IGEgaSAoZiBpIGhkKTtcbiAgICAgICAgZmlsbCBhIChpICsgMSkgdGxcbiAgICBpblxuICAgIGZpbGwgYSAxIHRsXG47O1xuXG5sZXQgb2ZfbGlzdF9yZXZfbWFwIHhzIH5mID1cbiAgbGV0IHQgPSBvZl9saXN0X21hcCB4cyB+ZiBpblxuICByZXZfaW5wbGFjZSB0O1xuICB0XG47O1xuXG5sZXQgb2ZfbGlzdF9yZXZfbWFwaSB4cyB+ZiA9XG4gIGxldCB0ID0gb2ZfbGlzdF9tYXBpIHhzIH5mIGluXG4gIHJldl9pbnBsYWNlIHQ7XG4gIHRcbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgbGV0IHIgPSByZWYgW3x8XSBpblxuICBsZXQgayA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICBtYXRjaCBmIGkgKHVuc2FmZV9nZXQgdCBpKSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGEgLT5cbiAgICAgIGlmICFrID0gMCB0aGVuIHIgOj0gY3JlYXRlIH5sZW46KGxlbmd0aCB0KSBhO1xuICAgICAgdW5zYWZlX3NldCAhciAhayBhO1xuICAgICAgaW5jciBrXG4gIGRvbmU7XG4gIGlmICFrID0gbGVuZ3RoIHQgdGhlbiAhciBlbHNlIGlmICFrID4gMCB0aGVuIHN1YiB+cG9zOjAgfmxlbjohayAhciBlbHNlIFt8fF1cbjs7XG5cbmxldCBmaWx0ZXJfbWFwIHQgfmYgPSBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gX2kgYSAtPiBmIGEpXG5sZXQgZmlsdGVyX29wdCB0ID0gZmlsdGVyX21hcCB0IH5mOkZuLmlkXG5cbmxldCByYWlzZV9sZW5ndGhfbWlzbWF0Y2ggbmFtZSBuMSBuMiA9XG4gIGludmFsaWRfYXJnZiBcImxlbmd0aCBtaXNtYXRjaCBpbiAlczogJWQgPD4gJWRcIiBuYW1lIG4xIG4yICgpXG5bQEBjb2xkXSBbQEBpbmxpbmUgbmV2ZXJdIFtAQGxvY2FsIG5ldmVyXSBbQEBzcGVjaWFsaXNlIG5ldmVyXVxuOztcblxubGV0IGNoZWNrX2xlbmd0aDJfZXhuIG5hbWUgdDEgdDIgPVxuICBsZXQgbjEgPSBsZW5ndGggdDEgaW5cbiAgbGV0IG4yID0gbGVuZ3RoIHQyIGluXG4gIGlmIG4xIDw+IG4yIHRoZW4gcmFpc2VfbGVuZ3RoX21pc21hdGNoIG5hbWUgbjEgbjJcbjs7XG5cbmxldCBpdGVyMl9leG4gdDEgdDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIkFycmF5Lml0ZXIyX2V4blwiIHQxIHQyO1xuICBpdGVyaSB0MSB+ZjooZnVuIGkgeDEgLT4gZiB4MSAodW5zYWZlX2dldCB0MiBpKSlcbjs7XG5cbmxldCBtYXAyX2V4biB0MSB0MiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkubWFwMl9leG5cIiB0MSB0MjtcbiAgaW5pdCAobGVuZ3RoIHQxKSB+ZjooZnVuIGkgLT4gZiAodW5zYWZlX2dldCB0MSBpKSAodW5zYWZlX2dldCB0MiBpKSlcbjs7XG5cbmxldCBmb2xkMl9leG4gdDEgdDIgfmluaXQgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIkFycmF5LmZvbGQyX2V4blwiIHQxIHQyO1xuICBmb2xkaSB0MSB+aW5pdCB+ZjooZnVuIGkgYWMgeCAtPiBmIGFjIHggKHVuc2FmZV9nZXQgdDIgaSkpXG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPSBmaWx0ZXJfbWFwIHQgfmY6KGZ1biB4IC0+IGlmIGYgeCB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpXG5sZXQgZmlsdGVyaSB0IH5mID0gZmlsdGVyX21hcGkgdCB+ZjooZnVuIGkgeCAtPiBpZiBmIGkgeCB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpXG5cblxubGV0IGV4aXN0cyB0IH5mID1cbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiBmYWxzZSBpblxuICB3aGlsZSAhaSA+PSAwICYmIG5vdCAhcmVzdWx0IGRvXG4gICAgaWYgZiAodW5zYWZlX2dldCB0ICFpKSB0aGVuIHJlc3VsdCA6PSB0cnVlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIGZhbHNlIGluXG4gIHdoaWxlICFpID49IDAgJiYgbm90ICFyZXN1bHQgZG9cbiAgICBpZiBmICFpICh1bnNhZmVfZ2V0IHQgIWkpIHRoZW4gcmVzdWx0IDo9IHRydWUgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IG1lbSB0IGEgfmVxdWFsID0gZXhpc3RzIHQgfmY6KGVxdWFsIGEpXG5cbmxldCBmb3JfYWxsIHQgfmYgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiAhcmVzdWx0IGRvXG4gICAgaWYgbm90IChmICh1bnNhZmVfZ2V0IHQgIWkpKSB0aGVuIHJlc3VsdCA6PSBmYWxzZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZm9yX2FsbGkgdCB+ZiA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFpID49IDAgJiYgIXJlc3VsdCBkb1xuICAgIGlmIG5vdCAoZiAhaSAodW5zYWZlX2dldCB0ICFpKSkgdGhlbiByZXN1bHQgOj0gZmFsc2UgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGV4aXN0czJfZXhuIHQxIHQyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJBcnJheS5leGlzdHMyX2V4blwiIHQxIHQyO1xuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQxIC0gMSkgaW5cbiAgbGV0IHJlc3VsdCA9IHJlZiBmYWxzZSBpblxuICB3aGlsZSAhaSA+PSAwICYmIG5vdCAhcmVzdWx0IGRvXG4gICAgaWYgZiAodW5zYWZlX2dldCB0MSAhaSkgKHVuc2FmZV9nZXQgdDIgIWkpIHRoZW4gcmVzdWx0IDo9IHRydWUgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGZvcl9hbGwyX2V4biB0MSB0MiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkuZm9yX2FsbDJfZXhuXCIgdDEgdDI7XG4gIGxldCBpID0gcmVmIChsZW5ndGggdDEgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiAhcmVzdWx0IGRvXG4gICAgaWYgbm90IChmICh1bnNhZmVfZ2V0IHQxICFpKSAodW5zYWZlX2dldCB0MiAhaSkpIHRoZW4gcmVzdWx0IDo9IGZhbHNlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBlcXVhbCBlcXVhbCB0MSB0MiA9IGxlbmd0aCB0MSA9IGxlbmd0aCB0MiAmJiBmb3JfYWxsMl9leG4gdDEgdDIgfmY6ZXF1YWxcblxuXG5sZXQgbWFwX2lucGxhY2UgdCB+ZiA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICB1bnNhZmVfc2V0IHQgaSAoZiAodW5zYWZlX2dldCB0IGkpKVxuICBkb25lXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIGZpbmRpX2ludGVybmFsIHQgfmYgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoIHQgaW5cbiAgaWYgbGVuZ3RoID0gMFxuICB0aGVuIGlmX25vdF9mb3VuZCAoKVxuICBlbHNlIChcbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGZvdW5kID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IHZhbHVlX2ZvdW5kID0gcmVmICh1bnNhZmVfZ2V0IHQgMCkgaW5cbiAgICB3aGlsZSAobm90ICFmb3VuZCkgJiYgIWkgPCBsZW5ndGggZG9cbiAgICAgIGxldCB2YWx1ZSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgICAgaWYgZiAhaSB2YWx1ZVxuICAgICAgdGhlbiAoXG4gICAgICAgIHZhbHVlX2ZvdW5kIDo9IHZhbHVlO1xuICAgICAgICBmb3VuZCA6PSB0cnVlKVxuICAgICAgZWxzZSBpbmNyIGlcbiAgICBkb25lO1xuICAgIGlmICFmb3VuZCB0aGVuIGlmX2ZvdW5kIH5pOiFpIH52YWx1ZTohdmFsdWVfZm91bmQgZWxzZSBpZl9ub3RfZm91bmQgKCkpXG47O1xuXG5sZXQgZmluZGkgdCB+ZiA9XG4gIGZpbmRpX2ludGVybmFsXG4gICAgdFxuICAgIH5mXG4gICAgfmlmX2ZvdW5kOihmdW4gfmkgfnZhbHVlIC0+IFNvbWUgKGksIHZhbHVlKSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4gKCkgLT4gTm9uZSlcbjs7XG5cbmxldCBmaW5kaV9leG4gdCB+ZiA9XG4gIGZpbmRpX2ludGVybmFsXG4gICAgdFxuICAgIH5mXG4gICAgfmlmX2ZvdW5kOihmdW4gfmkgfnZhbHVlIC0+IGksIHZhbHVlKVxuICAgIH5pZl9ub3RfZm91bmQ6KGZ1biAoKSAtPiByYWlzZSAoTm90X2ZvdW5kX3MgKEF0b20gXCJBcnJheS5maW5kaV9leG46IG5vdCBmb3VuZFwiKSkpXG47O1xuXG5sZXQgZmluZF9leG4gdCB+ZiA9XG4gIGZpbmRpX2ludGVybmFsXG4gICAgdFxuICAgIH5mOihmdW4gX2kgeCAtPiBmIHgpXG4gICAgfmlmX2ZvdW5kOihmdW4gfmk6XyB+dmFsdWUgLT4gdmFsdWUpXG4gICAgfmlmX25vdF9mb3VuZDooZnVuICgpIC0+IHJhaXNlIChOb3RfZm91bmRfcyAoQXRvbSBcIkFycmF5LmZpbmRfZXhuOiBub3QgZm91bmRcIikpKVxuOztcblxubGV0IGZpbmQgdCB+ZiA9IE9wdGlvbi5tYXAgKGZpbmRpIHQgfmY6KGZ1biBfaSB4IC0+IGYgeCkpIH5mOihmdW4gKF9pLCB4KSAtPiB4KVxuXG5sZXQgZmluZF9tYXAgdCB+ZiA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IHZhbHVlX2ZvdW5kID0gcmVmIE5vbmUgaW5cbiAgICB3aGlsZSBPcHRpb24uaXNfbm9uZSAhdmFsdWVfZm91bmQgJiYgIWkgPCBsZW5ndGggZG9cbiAgICAgIGxldCB2YWx1ZSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgICAgdmFsdWVfZm91bmQgOj0gZiB2YWx1ZTtcbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgIXZhbHVlX2ZvdW5kKVxuOztcblxubGV0IGZpbmRfbWFwX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkFycmF5LmZpbmRfbWFwX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBmaW5kX21hcF9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZF9tYXAgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX21hcF9leG5cbjs7XG5cbmxldCBmaW5kX21hcGkgdCB+ZiA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IHZhbHVlX2ZvdW5kID0gcmVmIE5vbmUgaW5cbiAgICB3aGlsZSBPcHRpb24uaXNfbm9uZSAhdmFsdWVfZm91bmQgJiYgIWkgPCBsZW5ndGggZG9cbiAgICAgIGxldCB2YWx1ZSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgICAgdmFsdWVfZm91bmQgOj0gZiAhaSB2YWx1ZTtcbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgIXZhbHVlX2ZvdW5kKVxuOztcblxubGV0IGZpbmRfbWFwaV9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJBcnJheS5maW5kX21hcGlfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGZpbmRfbWFwaV9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZF9tYXBpIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9tYXBpX2V4blxuOztcblxubGV0IGZpbmRfY29uc2VjdXRpdmVfZHVwbGljYXRlIHQgfmVxdWFsID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBpZiBuIDw9IDFcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCByZXN1bHQgPSByZWYgTm9uZSBpblxuICAgIGxldCBpID0gcmVmIDEgaW5cbiAgICBsZXQgcHJldiA9IHJlZiAodW5zYWZlX2dldCB0IDApIGluXG4gICAgd2hpbGUgIWkgPCBuIGRvXG4gICAgICBsZXQgY3VyID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICBpZiBlcXVhbCBjdXIgIXByZXZcbiAgICAgIHRoZW4gKFxuICAgICAgICByZXN1bHQgOj0gU29tZSAoIXByZXYsIGN1cik7XG4gICAgICAgIGkgOj0gbilcbiAgICAgIGVsc2UgKFxuICAgICAgICBwcmV2IDo9IGN1cjtcbiAgICAgICAgaW5jciBpKVxuICAgIGRvbmU7XG4gICAgIXJlc3VsdClcbjs7XG5cbmxldCByZWR1Y2UgdCB+ZiA9XG4gIGlmIGxlbmd0aCB0ID0gMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHIgPSByZWYgKHVuc2FmZV9nZXQgdCAwKSBpblxuICAgIGZvciBpID0gMSB0byBsZW5ndGggdCAtIDEgZG9cbiAgICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCB0IGkpXG4gICAgZG9uZTtcbiAgICBTb21lICFyKVxuOztcblxubGV0IHJlZHVjZV9leG4gdCB+ZiA9XG4gIG1hdGNoIHJlZHVjZSB0IH5mIHdpdGhcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnIFwiQXJyYXkucmVkdWNlX2V4blwiXG4gIHwgU29tZSB2IC0+IHZcbjs7XG5cbmxldCBwZXJtdXRlID0gQXJyYXlfcGVybXV0ZS5wZXJtdXRlXG5cbmxldCByYW5kb21fZWxlbWVudF9leG4gPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgdCA9XG4gIGlmIGlzX2VtcHR5IHRcbiAgdGhlbiBmYWlsd2l0aCBcIkFycmF5LnJhbmRvbV9lbGVtZW50X2V4bjogZW1wdHkgYXJyYXlcIlxuICBlbHNlIHQuKFJhbmRvbS5TdGF0ZS5pbnQgcmFuZG9tX3N0YXRlIChsZW5ndGggdCkpXG47O1xuXG5sZXQgcmFuZG9tX2VsZW1lbnQgPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgdCA9XG4gIHRyeSBTb21lIChyYW5kb21fZWxlbWVudF9leG4gfnJhbmRvbV9zdGF0ZSB0KSB3aXRoXG4gIHwgXyAtPiBOb25lXG47O1xuXG5sZXQgemlwIHQxIHQyID1cbiAgaWYgbGVuZ3RoIHQxIDw+IGxlbmd0aCB0MiB0aGVuIE5vbmUgZWxzZSBTb21lIChtYXAyX2V4biB0MSB0MiB+ZjooZnVuIHgxIHgyIC0+IHgxLCB4MikpXG47O1xuXG5sZXQgemlwX2V4biB0MSB0MiA9XG4gIGlmIGxlbmd0aCB0MSA8PiBsZW5ndGggdDJcbiAgdGhlbiBmYWlsd2l0aCBcIkFycmF5LnppcF9leG5cIlxuICBlbHNlIG1hcDJfZXhuIHQxIHQyIH5mOihmdW4geDEgeDIgLT4geDEsIHgyKVxuOztcblxubGV0IHVuemlwIHQgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGlmIG4gPSAwXG4gIHRoZW4gW3x8XSwgW3x8XVxuICBlbHNlIChcbiAgICBsZXQgeCwgeSA9IHQuKDApIGluXG4gICAgbGV0IHJlczEgPSBjcmVhdGUgfmxlbjpuIHggaW5cbiAgICBsZXQgcmVzMiA9IGNyZWF0ZSB+bGVuOm4geSBpblxuICAgIGZvciBpID0gMSB0byBuIC0gMSBkb1xuICAgICAgbGV0IHgsIHkgPSB0LihpKSBpblxuICAgICAgcmVzMS4oaSkgPC0geDtcbiAgICAgIHJlczIuKGkpIDwtIHlcbiAgICBkb25lO1xuICAgIHJlczEsIHJlczIpXG47O1xuXG5sZXQgc29ydGVkX2NvcHkgdCB+Y29tcGFyZSA9XG4gIGxldCB0MSA9IGNvcHkgdCBpblxuICBzb3J0IHQxIH5jb21wYXJlO1xuICB0MVxuOztcblxubGV0IHBhcnRpdGlvbmlfdGYgdCB+ZiA9XG4gIGxldCBib3RoID0gbWFwaSB0IH5mOihmdW4gaSB4IC0+IGlmIGYgaSB4IHRoZW4gRWl0aGVyLkZpcnN0IHggZWxzZSBFaXRoZXIuU2Vjb25kIHgpIGluXG4gIGxldCB0cnVlcyA9XG4gICAgZmlsdGVyX21hcCBib3RoIH5mOihmdW5jdGlvblxuICAgICAgfCBGaXJzdCB4IC0+IFNvbWUgeFxuICAgICAgfCBTZWNvbmQgXyAtPiBOb25lKVxuICBpblxuICBsZXQgZmFsc2VzID1cbiAgICBmaWx0ZXJfbWFwIGJvdGggfmY6KGZ1bmN0aW9uXG4gICAgICB8IEZpcnN0IF8gLT4gTm9uZVxuICAgICAgfCBTZWNvbmQgeCAtPiBTb21lIHgpXG4gIGluXG4gIHRydWVzLCBmYWxzZXNcbjs7XG5cbmxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9IHBhcnRpdGlvbmlfdGYgdCB+ZjooZnVuIF9pIHggLT4gZiB4KVxubGV0IGxhc3QgdCA9IHQuKGxlbmd0aCB0IC0gMSlcblxuKCogQ29udmVydCB0byBhIHNlcXVlbmNlIGJ1dCBkb2VzIG5vdCBhdHRlbXB0IHRvIHByb3RlY3QgYWdhaW5zdCBtb2RpZmljYXRpb25cbiAgIGluIHRoZSBhcnJheS4gKilcbmxldCB0b19zZXF1ZW5jZV9tdXRhYmxlIHQgPVxuICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdDowIH5mOihmdW4gaSAtPlxuICAgIGlmIGkgPj0gbGVuZ3RoIHQgdGhlbiBTZXF1ZW5jZS5TdGVwLkRvbmUgZWxzZSBTZXF1ZW5jZS5TdGVwLllpZWxkICh0LihpKSwgaSArIDEpKVxuOztcblxubGV0IHRvX3NlcXVlbmNlIHQgPSB0b19zZXF1ZW5jZV9tdXRhYmxlIChjb3B5IHQpXG5cbmxldCBjYXJ0ZXNpYW5fcHJvZHVjdCB0MSB0MiA9XG4gIGlmIGlzX2VtcHR5IHQxIHx8IGlzX2VtcHR5IHQyXG4gIHRoZW4gW3x8XVxuICBlbHNlIChcbiAgICBsZXQgbjEgPSBsZW5ndGggdDEgaW5cbiAgICBsZXQgbjIgPSBsZW5ndGggdDIgaW5cbiAgICBsZXQgdCA9IGNyZWF0ZSB+bGVuOihuMSAqIG4yKSAodDEuKDApLCB0Mi4oMCkpIGluXG4gICAgbGV0IHIgPSByZWYgMCBpblxuICAgIGZvciBpMSA9IDAgdG8gbjEgLSAxIGRvXG4gICAgICBmb3IgaTIgPSAwIHRvIG4yIC0gMSBkb1xuICAgICAgICB0LighcikgPC0gdDEuKGkxKSwgdDIuKGkyKTtcbiAgICAgICAgaW5jciByXG4gICAgICBkb25lXG4gICAgZG9uZTtcbiAgICB0KVxuOztcblxubGV0IHRyYW5zcG9zZSB0dCA9XG4gIGlmIGxlbmd0aCB0dCA9IDBcbiAgdGhlbiBTb21lIFt8fF1cbiAgZWxzZSAoXG4gICAgbGV0IHdpZHRoID0gbGVuZ3RoIHR0IGluXG4gICAgbGV0IGRlcHRoID0gbGVuZ3RoIHR0LigwKSBpblxuICAgIGlmIGV4aXN0cyB0dCB+ZjooZnVuIHQgLT4gbGVuZ3RoIHQgPD4gZGVwdGgpXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZSBTb21lIChpbml0IGRlcHRoIH5mOihmdW4gZCAtPiBpbml0IHdpZHRoIH5mOihmdW4gdyAtPiB0dC4odykuKGQpKSkpKVxuOztcblxubGV0IHRyYW5zcG9zZV9leG4gdHQgPVxuICBtYXRjaCB0cmFuc3Bvc2UgdHQgd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJBcnJheS50cmFuc3Bvc2VfZXhuXCJcbiAgfCBTb21lIHR0JyAtPiB0dCdcbjs7XG5cbmluY2x1ZGUgQmluYXJ5X3NlYXJjaGFibGUuTWFrZTEgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgZ2V0ID0gZ2V0XG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICBlbmQpXG5cbmluY2x1ZGUgQmxpdC5NYWtlMSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcblxuICAgIGxldCBjcmVhdGVfbGlrZSB+bGVuIHQgPVxuICAgICAgaWYgbGVuID0gMFxuICAgICAgdGhlbiBbfHxdXG4gICAgICBlbHNlIChcbiAgICAgICAgYXNzZXJ0IChsZW5ndGggdCA+IDApO1xuICAgICAgICBjcmVhdGUgfmxlbiB0LigwKSlcbiAgICA7O1xuXG4gICAgbGV0IHVuc2FmZV9ibGl0ID0gdW5zYWZlX2JsaXRcbiAgZW5kKVxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPSBpdGVyIHQgfmY6aW52YXJpYW50X2FcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIFNvcnQgPSBTb3J0XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEludCA9IEludDBcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcblxuKCogV2UgbWFpbnRhaW4gdGhlIHByb3BlcnR5IHRoYXQgYWxsIHZhbHVlcyBvZiB0eXBlIFt0XSBkbyBub3QgaGF2ZSB0aGUgdGFnXG4gICBbZG91YmxlX2FycmF5X3RhZ10uICBTb21lIGZ1bmN0aW9ucyBiZWxvdyBhc3N1bWUgdGhpcyBpbiBvcmRlciB0byBhdm9pZCB0ZXN0aW5nIHRoZVxuICAgdGFnLCBhbmQgd2lsbCBzZWdmYXVsdCBpZiB0aGlzIHByb3BlcnR5IGRvZXNuJ3QgaG9sZC4gKilcbnR5cGUgdCA9IENhbWwuT2JqLnQgYXJyYXlcblxubGV0IGludmFyaWFudCB0ID0gYXNzZXJ0IChDYW1sLk9iai50YWcgKENhbWwuT2JqLnJlcHIgdCkgPD4gQ2FtbC5PYmouZG91YmxlX2FycmF5X3RhZylcbmxldCBsZW5ndGggPSBBcnJheS5sZW5ndGggKCogd291bGQgY2hlY2sgZm9yIGZsb2F0IGFycmF5cyBpbiAzMiBiaXQsIGJ1dCB3aGF0ZXZlciAqKVxuXG5sZXQgc2V4cF9vZl90IHQgPVxuICBTZXhwLkF0b21cbiAgICAoU3RyaW5nLmNvbmNhdCB+c2VwOlwiXCIgWyBcIjxPYmpfYXJyYXkudCBvZiBsZW5ndGggXCI7IEludC50b19zdHJpbmcgKGxlbmd0aCB0KTsgXCI+XCIgXSlcbjs7XG5cbmxldCB6ZXJvX29iaiA9IENhbWwuT2JqLnJlcHIgKDAgOiBpbnQpXG5cbigqIFdlIGNhbGwgW0FycmF5LmNyZWF0ZV0gd2l0aCBhIHZhbHVlIHRoYXQgaXMgbm90IGEgZmxvYXQgc28gdGhhdCB0aGUgYXJyYXkgZG9lc24ndCBnZXRcbiAgIHRhZ2dlZCB3aXRoIFtEb3VibGVfYXJyYXlfdGFnXS4gKilcbmxldCBjcmVhdGVfemVybyB+bGVuID0gQXJyYXkuY3JlYXRlIH5sZW4gemVyb19vYmpcbmxldCBlbXB0eSA9IFt8fF1cblxudHlwZSBub3RfYV9mbG9hdCA9XG4gIHwgTm90X2FfZmxvYXRfMFxuICB8IE5vdF9hX2Zsb2F0XzEgb2YgaW50XG5cbmxldCBfbm90X2FfZmxvYXRfMCA9IE5vdF9hX2Zsb2F0XzBcbmxldCBfbm90X2FfZmxvYXRfMSA9IE5vdF9hX2Zsb2F0XzEgNDJcblxubGV0IGdldCB0IGkgPVxuICAoKiBNYWtlIHRoZSBjb21waWxlciBiZWxpZXZlIFt0XSBpcyBhbiBhcnJheSBub3QgY29udGFpbmluZyBmbG9hdHMgc28gaXQgZG9lcyBub3QgY2hlY2tcbiAgICAgaWYgW3RdIGlzIHRhZ2dlZCB3aXRoIFtEb3VibGVfYXJyYXlfdGFnXS4gIEl0IGlzIE5PVCBvayB0byB1c2UgW2ludCBhcnJheV0gc2luY2UgKGlmXG4gICAgIHRoaXMgZnVuY3Rpb24gaXMgaW5saW5lZCBhbmQgdGhlIGFycmF5IGNvbnRhaW5zIGluLWhlYXAgYm94ZWQgdmFsdWVzKSB3cm9uZyByZWdpc3RlclxuICAgICB0eXBpbmcgbWF5IHJlc3VsdCwgbGVhZGluZyB0byBhIGZhaWx1cmUgdG8gcmVnaXN0ZXIgbmVjZXNzYXJ5IEdDIHJvb3RzLiAqKVxuICBDYW1sLk9iai5yZXByICgoQ2FtbC5PYmoubWFnaWMgKHQgOiB0KSA6IG5vdF9hX2Zsb2F0IGFycmF5KS4oaSkgOiBub3RfYV9mbG9hdClcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX2dldCB0IGkgPVxuICAoKiBNYWtlIHRoZSBjb21waWxlciBiZWxpZXZlIFt0XSBpcyBhbiBhcnJheSBub3QgY29udGFpbmluZyBmbG9hdHMgc28gaXQgZG9lcyBub3QgY2hlY2tcbiAgICAgaWYgW3RdIGlzIHRhZ2dlZCB3aXRoIFtEb3VibGVfYXJyYXlfdGFnXS4gKilcbiAgQ2FtbC5PYmoucmVwclxuICAgIChBcnJheS51bnNhZmVfZ2V0IChDYW1sLk9iai5tYWdpYyAodCA6IHQpIDogbm90X2FfZmxvYXQgYXJyYXkpIGkgOiBub3RfYV9mbG9hdClcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmogPVxuICAoKiBTYW1lIGNvbW1lbnQgYXMgW3Vuc2FmZV9nZXRdLiBTeXMub3BhcXVlX2lkZW50aXR5IHByZXZlbnRzIHRoZSBjb21waWxlciBmcm9tXG4gICAgIHBvdGVudGlhbGx5IHdyb25nbHkgZ3Vlc3NpbmcgdGhlIHR5cGUgb2YgdGhlIGFycmF5IGJhc2VkIG9uIHRoZSB0eXBlIG9mIGVsZW1lbnQsIHRoYXRcbiAgICAgaXMgcHJldmVudCB0aGUgaW1wbGljYXRpb246IChPYmoudGFnIG9iaiA9IE9iai5kb3VibGVfdGFnKSA9PiAoT2JqLnRhZyB0ID1cbiAgICAgT2JqLmRvdWJsZV9hcnJheV90YWcpIHdoaWNoIGZsYW1iZGEgaGFzIHRyaWVkIGluIHRoZSBwYXN0IChhdCBsZWFzdCB0aGF0J3MgYXNzdW1pbmdcbiAgICAgdGhlIGNvbXBpbGVyIHJlc3BlY3RzIFN5cy5vcGFxdWVfaWRlbnRpdHksIHdoaWNoIGlzIG5vdCBhbHdheXMgdGhlIGNhc2UpLiAqKVxuICBBcnJheS51bnNhZmVfc2V0XG4gICAgKENhbWwuT2JqLm1hZ2ljICh0IDogdCkgOiBub3RfYV9mbG9hdCBhcnJheSlcbiAgICBpXG4gICAgKENhbWwuT2JqLm9iaiAoU3lzLm9wYXF1ZV9pZGVudGl0eSBvYmopIDogbm90X2FfZmxvYXQpXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHNldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmogPVxuICAoKiBzYW1lIGFzIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSBidXQgc2FmZSAqKVxuICAoQ2FtbC5PYmoubWFnaWMgKHQgOiB0KSA6IG5vdF9hX2Zsb2F0IGFycmF5KS4oaSlcbiAgPC0gKENhbWwuT2JqLm9iaiAoU3lzLm9wYXF1ZV9pZGVudGl0eSBvYmopIDogbm90X2FfZmxvYXQpXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIGludCA9XG4gICgqIFRoaXMgc2tpcHMgW2NhbWxfbW9kaWZ5XSwgd2hpY2ggaXMgT0sgaWYgYm90aCB0aGUgb2xkIGFuZCBuZXcgdmFsdWVzIGFyZSBpbnRlZ2Vycy4gKilcbiAgQXJyYXkudW5zYWZlX3NldCAoQ2FtbC5PYmoubWFnaWMgKHQgOiB0KSA6IGludCBhcnJheSkgaSAoU3lzLm9wYXF1ZV9pZGVudGl0eSBpbnQpXG47O1xuXG4oKiBGb3IgW3NldF0gYW5kIFt1bnNhZmVfc2V0XSwgaWYgYSBwb2ludGVyIGlzIGludm9sdmVkLCB3ZSBmaXJzdCBkbyBhIHBoeXNpY2FsLWVxdWFsaXR5XG4gICB0ZXN0IHRvIHNlZSBpZiB0aGUgcG9pbnRlciBpcyBjaGFuZ2luZy4gIElmIG5vdCwgd2UgZG9uJ3QgbmVlZCB0byBkbyB0aGUgW3NldF0sIHdoaWNoXG4gICBzYXZlcyBhIGNhbGwgdG8gW2NhbWxfbW9kaWZ5XS4gIFdlIHRoaW5rIHRoaXMgcGh5c2ljYWwtZXF1YWxpdHkgdGVzdCBpcyB3b3J0aCBpdFxuICAgYmVjYXVzZSBpdCBpcyB2ZXJ5IGNoZWFwIChib3RoIHZhbHVlcyBhcmUgYWxyZWFkeSBhdmFpbGFibGUgZnJvbSB0aGUgW2lzX2ludF0gdGVzdClcbiAgIGFuZCBiZWNhdXNlIFtjYW1sX21vZGlmeV0gaXMgZXhwZW5zaXZlLiAqKVxuXG5sZXQgc2V0IHQgaSBvYmogPVxuICAoKiBXZSB1c2UgW2dldF0gZmlyc3QgYnV0IHRoZW4gd2UgdXNlIFtBcnJheS51bnNhZmVfc2V0XSBzaW5jZSB3ZSBrbm93IHRoYXQgW2ldIGlzXG4gICAgIHZhbGlkLiAqKVxuICBsZXQgb2xkX29iaiA9IGdldCB0IGkgaW5cbiAgaWYgQ2FtbC5PYmouaXNfaW50IG9sZF9vYmogJiYgQ2FtbC5PYmouaXNfaW50IG9ialxuICB0aGVuIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIChDYW1sLk9iai5vYmogb2JqIDogaW50KVxuICBlbHNlIGlmIG5vdCAocGh5c19lcXVhbCBvbGRfb2JqIG9iailcbiAgdGhlbiB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9ialxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfc2V0IHQgaSBvYmogPVxuICBsZXQgb2xkX29iaiA9IHVuc2FmZV9nZXQgdCBpIGluXG4gIGlmIENhbWwuT2JqLmlzX2ludCBvbGRfb2JqICYmIENhbWwuT2JqLmlzX2ludCBvYmpcbiAgdGhlbiB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSAoQ2FtbC5PYmoub2JqIG9iaiA6IGludClcbiAgZWxzZSBpZiBub3QgKHBoeXNfZXF1YWwgb2xkX29iaiBvYmopXG4gIHRoZW4gdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmpcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX3NldF9vbWl0X3BoeXNfZXF1YWxfY2hlY2sgdCBpIG9iaiA9XG4gIGxldCBvbGRfb2JqID0gdW5zYWZlX2dldCB0IGkgaW5cbiAgaWYgQ2FtbC5PYmouaXNfaW50IG9sZF9vYmogJiYgQ2FtbC5PYmouaXNfaW50IG9ialxuICB0aGVuIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIChDYW1sLk9iai5vYmogb2JqIDogaW50KVxuICBlbHNlIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgb2JqXG47O1xuXG5sZXQgc3dhcCB0IGkgaiA9XG4gIGxldCBhID0gZ2V0IHQgaSBpblxuICBsZXQgYiA9IGdldCB0IGogaW5cbiAgdW5zYWZlX3NldCB0IGkgYjtcbiAgdW5zYWZlX3NldCB0IGogYVxuOztcblxubGV0IGNyZWF0ZSB+bGVuIHggPVxuICAoKiBJZiB3ZSBjYW4sIHVzZSBbQXJyYXkuY3JlYXRlXSBkaXJlY3RseS4gKilcbiAgaWYgQ2FtbC5PYmoudGFnIHggPD4gQ2FtbC5PYmouZG91YmxlX3RhZ1xuICB0aGVuIEFycmF5LmNyZWF0ZSB+bGVuIHhcbiAgZWxzZSAoXG4gICAgKCogT3RoZXJ3aXNlIHVzZSBbY3JlYXRlX3plcm9dIGFuZCBzZXQgdGhlIGNvbnRlbnRzICopXG4gICAgbGV0IHQgPSBjcmVhdGVfemVybyB+bGVuIGluXG4gICAgbGV0IHggPSBTeXMub3BhcXVlX2lkZW50aXR5IHggaW5cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSB4XG4gICAgZG9uZTtcbiAgICB0KVxuOztcblxubGV0IHNpbmdsZXRvbiBvYmogPSBjcmVhdGUgfmxlbjoxIG9ialxuXG4oKiBQcmUtY29uZGl0aW9uOiB0LihpKSBpcyBhbiBpbnRlZ2VyLiAqKVxubGV0IHVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgb2JqID1cbiAgaWYgQ2FtbC5PYmouaXNfaW50IG9ialxuICB0aGVuIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIChDYW1sLk9iai5vYmogb2JqIDogaW50KVxuICBlbHNlXG4gICAgKCogW3QuKGkpXSBpcyBhbiBpbnRlZ2VyIGFuZCBbb2JqXSBpcyBub3QsIHNvIHdlIGRvIG5vdCBuZWVkIHRvIGNoZWNrIGlmIHRoZXkgYXJlXG4gICAgICAgZXF1YWwuICopXG4gICAgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmpcbjs7XG5cbmxldCB1bnNhZmVfc2V0X2ludCB0IGkgaW50ID1cbiAgbGV0IG9sZF9vYmogPSB1bnNhZmVfZ2V0IHQgaSBpblxuICBpZiBDYW1sLk9iai5pc19pbnQgb2xkX29ialxuICB0aGVuIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIGludFxuICBlbHNlIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgKENhbWwuT2JqLnJlcHIgaW50KVxuOztcblxubGV0IHVuc2FmZV9jbGVhcl9pZl9wb2ludGVyIHQgaSA9XG4gIGxldCBvbGRfb2JqID0gdW5zYWZlX2dldCB0IGkgaW5cbiAgaWYgbm90IChDYW1sLk9iai5pc19pbnQgb2xkX29iaikgdGhlbiB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIChDYW1sLk9iai5yZXByIDApXG47O1xuXG4oKiogW3Vuc2FmZV9ibGl0XSBpcyBsaWtlIFtBcnJheS5ibGl0XSwgZXhjZXB0IGl0IHVzZXMgb3VyIG93biBmb3ItbG9vcCB0byBhdm9pZFxuICAgIGNhbWxfbW9kaWZ5IHdoZW4gcG9zc2libGUuICBJdHMgcGVyZm9ybWFuY2UgaXMgc3RpbGwgbm90IGNvbXBhcmFibGUgdG8gYSBtZW1jcHkuICopXG5sZXQgdW5zYWZlX2JsaXQgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4gPVxuICAoKiBXaGVuIFtwaHlzX2VxdWFsIHNyYyBkc3RdLCB3ZSBuZWVkIHRvIGNoZWNrIHdoZXRoZXIgW2RzdF9wb3MgPCBzcmNfcG9zXSBhbmQgaGF2ZSB0aGVcbiAgICAgZm9yIGxvb3AgZ28gaW4gdGhlIHJpZ2h0IGRpcmVjdGlvbiBzbyB0aGF0IHdlIGRvbid0IG92ZXJ3cml0ZSBkYXRhIHRoYXQgd2Ugc3RpbGwgbmVlZFxuICAgICB0byByZWFkLiAgV2hlbiBbbm90IChwaHlzX2VxdWFsIHNyYyBkc3QpXSwgZG9pbmcgdGhpcyBpcyBoYXJtbGVzcy4gIEZyb20gYVxuICAgICBtZW1vcnktcGVyZm9ybWFuY2UgcGVyc3BlY3RpdmUsIGl0IGRvZXNuJ3QgbWF0dGVyIHdoZXRoZXIgb25lIGxvb3BzIHVwIG9yIGRvd24uXG4gICAgIENvbnN0YW50LXN0cmlkZSBhY2Nlc3MsIGZvcndhcmQgb3IgYmFja3dhcmQsIHNob3VsZCBiZSBpbmRpc3Rpbmd1aXNoYWJsZSAoYXQgbGVhc3Qgb25cbiAgICAgYW4gaW50ZWwgaTcpLiAgU28sIHdlIGRvbid0IGRvIGEgY2hlY2sgZm9yIFtwaHlzX2VxdWFsIHNyYyBkc3RdIGFuZCBhbHdheXMgbG9vcCB1cCBpblxuICAgICB0aGF0IGNhc2UuICopXG4gIGlmIGRzdF9wb3MgPCBzcmNfcG9zXG4gIHRoZW5cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCBkc3QgKGRzdF9wb3MgKyBpKSAodW5zYWZlX2dldCBzcmMgKHNyY19wb3MgKyBpKSlcbiAgICBkb25lXG4gIGVsc2VcbiAgICBmb3IgaSA9IGxlbiAtIDEgZG93bnRvIDAgZG9cbiAgICAgIHVuc2FmZV9zZXQgZHN0IChkc3RfcG9zICsgaSkgKHVuc2FmZV9nZXQgc3JjIChzcmNfcG9zICsgaSkpXG4gICAgZG9uZVxuOztcblxuaW5jbHVkZSBCbGl0Lk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgY3JlYXRlID0gY3JlYXRlX3plcm9cbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgbGV0IHVuc2FmZV9ibGl0ID0gdW5zYWZlX2JsaXRcbiAgZW5kKVxuXG5sZXQgY29weSBzcmMgPVxuICBsZXQgZHN0ID0gY3JlYXRlX3plcm8gfmxlbjoobGVuZ3RoIHNyYykgaW5cbiAgYmxpdG8gfnNyYyB+ZHN0ICgpO1xuICBkc3Rcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxuKCogV0FSTklORzpcbiAgIFdlIHVzZSBub24tbWVtb3J5LXNhZmUgdGhpbmdzIHRocm91Z2hvdXQgdGhlIFtUcnVzdGVkXSBtb2R1bGUuXG4gICBNb3N0IG9mIGl0IGlzIG9ubHkgc2FmZSBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSB0eXBlIHNpZ25hdHVyZSAoZS5nLiBleHBvc2luZ1xuICAgW3ZhbCBjb3B5IDogJ2EgdCAtPiAnYiB0XSB3b3VsZCBiZSBhIGJpZyBtaXN0YWtlKS4gKilcbm1vZHVsZSBUcnVzdGVkIDogc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBlbXB0eSA6ICdhIHRcbiAgdmFsIHVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCA6IGxlbjppbnQgLT4gJ2EgdFxuICB2YWwgY3JlYXRlX29ial9hcnJheSA6IGxlbjppbnQgLT4gJ2EgdFxuICB2YWwgY3JlYXRlIDogbGVuOmludCAtPiAnYSAtPiAnYSB0XG4gIHZhbCBzaW5nbGV0b24gOiAnYSAtPiAnYSB0XG4gIHZhbCBnZXQgOiAnYSB0IC0+IGludCAtPiAnYVxuICB2YWwgc2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgc3dhcCA6IF8gdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9nZXQgOiAnYSB0IC0+IGludCAtPiAnYVxuICB2YWwgdW5zYWZlX3NldCA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9zZXRfb21pdF9waHlzX2VxdWFsX2NoZWNrIDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgdW5zYWZlX3NldF9pbnQgOiAnYSB0IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICB2YWwgdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCA6ICdhIHQgLT4gaW50IC0+IGludCAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCBzZXRfd2l0aF9jYW1sX21vZGlmeSA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gIHZhbCB1bnNhZmVfYmxpdCA6ICgnYSB0LCAnYSB0KSBCbGl0LmJsaXRcbiAgdmFsIGNvcHkgOiAnYSB0IC0+ICdhIHRcbiAgdmFsIHVuc2FmZV9jbGVhcl9pZl9wb2ludGVyIDogXyB0IC0+IGludCAtPiB1bml0XG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gT2JqX2FycmF5LnRcblxuICBsZXQgZW1wdHkgPSBPYmpfYXJyYXkuZW1wdHlcbiAgbGV0IHVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCB+bGVuID0gT2JqX2FycmF5LmNyZWF0ZV96ZXJvIH5sZW5cbiAgbGV0IGNyZWF0ZV9vYmpfYXJyYXkgfmxlbiA9IE9ial9hcnJheS5jcmVhdGVfemVybyB+bGVuXG4gIGxldCBjcmVhdGUgfmxlbiB4ID0gT2JqX2FycmF5LmNyZWF0ZSB+bGVuIChDYW1sLk9iai5yZXByIHgpXG4gIGxldCBzaW5nbGV0b24geCA9IE9ial9hcnJheS5zaW5nbGV0b24gKENhbWwuT2JqLnJlcHIgeClcbiAgbGV0IHN3YXAgdCBpIGogPSBPYmpfYXJyYXkuc3dhcCB0IGkgalxuICBsZXQgZ2V0IGFyciBpID0gQ2FtbC5PYmoub2JqIChPYmpfYXJyYXkuZ2V0IGFyciBpKVxuICBsZXQgc2V0IGFyciBpIHggPSBPYmpfYXJyYXkuc2V0IGFyciBpIChDYW1sLk9iai5yZXByIHgpXG4gIGxldCB1bnNhZmVfZ2V0IGFyciBpID0gQ2FtbC5PYmoub2JqIChPYmpfYXJyYXkudW5zYWZlX2dldCBhcnIgaSlcbiAgbGV0IHVuc2FmZV9zZXQgYXJyIGkgeCA9IE9ial9hcnJheS51bnNhZmVfc2V0IGFyciBpIChDYW1sLk9iai5yZXByIHgpXG4gIGxldCB1bnNhZmVfc2V0X2ludCBhcnIgaSB4ID0gT2JqX2FycmF5LnVuc2FmZV9zZXRfaW50IGFyciBpIHhcblxuICBsZXQgdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCBhcnIgaSB4ID1cbiAgICBPYmpfYXJyYXkudW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCBhcnIgaSB4XG4gIDs7XG5cbiAgbGV0IHVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5X2ludCBhcnIgaSB4ID1cbiAgICBPYmpfYXJyYXkudW5zYWZlX3NldF9hc3N1bWluZ19jdXJyZW50bHlfaW50IGFyciBpIChDYW1sLk9iai5yZXByIHgpXG4gIDs7XG5cbiAgbGV0IGxlbmd0aCA9IE9ial9hcnJheS5sZW5ndGhcbiAgbGV0IHVuc2FmZV9ibGl0ID0gT2JqX2FycmF5LnVuc2FmZV9ibGl0XG4gIGxldCBjb3B5ID0gT2JqX2FycmF5LmNvcHlcblxuICBsZXQgdW5zYWZlX3NldF9vbWl0X3BoeXNfZXF1YWxfY2hlY2sgdCBpIHggPVxuICAgIE9ial9hcnJheS51bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGVjayB0IGkgKENhbWwuT2JqLnJlcHIgeClcbiAgOztcblxuICBsZXQgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSB4ID1cbiAgICBPYmpfYXJyYXkudW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSAoQ2FtbC5PYmoucmVwciB4KVxuICA7O1xuXG4gIGxldCBzZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgeCA9IE9ial9hcnJheS5zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgKENhbWwuT2JqLnJlcHIgeClcbiAgbGV0IHVuc2FmZV9jbGVhcl9pZl9wb2ludGVyID0gT2JqX2FycmF5LnVuc2FmZV9jbGVhcl9pZl9wb2ludGVyXG5lbmRcblxuaW5jbHVkZSBUcnVzdGVkXG5cbmxldCBpbnZhcmlhbnQgdCA9IGFzc2VydCAoQ2FtbC5PYmoudGFnIChDYW1sLk9iai5yZXByIHQpIDw+IENhbWwuT2JqLmRvdWJsZV9hcnJheV90YWcpXG5cbmxldCBpbml0IGwgfmYgPVxuICBpZiBsIDwgMFxuICB0aGVuIGludmFsaWRfYXJnIFwiVW5pZm9ybV9hcnJheS5pbml0XCJcbiAgZWxzZSAoXG4gICAgbGV0IHJlcyA9IHVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCB+bGVuOmwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgICBkb25lO1xuICAgIHJlcylcbjs7XG5cbmxldCBvZl9hcnJheSBhcnIgPSBpbml0IH5mOihBcnJheS51bnNhZmVfZ2V0IGFycikgKEFycmF5Lmxlbmd0aCBhcnIpXG5sZXQgbWFwIGEgfmYgPSBpbml0IH5mOihmdW4gaSAtPiBmICh1bnNhZmVfZ2V0IGEgaSkpIChsZW5ndGggYSlcbmxldCBtYXBpIGEgfmYgPSBpbml0IH5mOihmdW4gaSAtPiBmIGkgKHVuc2FmZV9nZXQgYSBpKSkgKGxlbmd0aCBhKVxuXG5sZXQgaXRlciBhIH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIGYgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lXG47O1xuXG5sZXQgaXRlcmkgYSB+ZiA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICBmIGkgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lXG47O1xuXG5sZXQgZm9sZGkgYSB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgYWNjIDo9IGYgaSAhYWNjICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZTtcbiAgIWFjY1xuOztcblxubGV0IHRvX2xpc3QgdCA9IExpc3QuaW5pdCB+ZjooZ2V0IHQpIChsZW5ndGggdClcblxubGV0IG9mX2xpc3QgbCA9XG4gIGxldCBsZW4gPSBMaXN0Lmxlbmd0aCBsIGluXG4gIGxldCByZXMgPSB1bnNhZmVfY3JlYXRlX3VuaW5pdGlhbGl6ZWQgfmxlbiBpblxuICBMaXN0Lml0ZXJpIGwgfmY6KGZ1biBpIHggLT4gc2V0IHJlcyBpIHgpO1xuICByZXNcbjs7XG5cbigqIEl0IGlzIG5vdCBzYWZlIGZvciBbdG9fYXJyYXldIHRvIGJlIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBiZWNhdXNlIHdlIGhhdmUgY29kZSB0aGF0XG4gICByZWxpZXMgb24gW2Zsb2F0IGFycmF5XXMgYmVpbmcgdW5ib3hlZCwgZm9yIGV4YW1wbGUgaW4gW2Jpbl93cml0ZV9hcnJheV0uICopXG5sZXQgdG9fYXJyYXkgdCA9IEFycmF5LmluaXQgKGxlbmd0aCB0KSB+ZjooZnVuIGkgLT4gdW5zYWZlX2dldCB0IGkpXG5cbmxldCBleGlzdHMgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCB0IH5mIGkgPVxuICAgIGlmIGkgPCAwIHRoZW4gZmFsc2UgZWxzZSBmICh1bnNhZmVfZ2V0IHQgaSkgfHwgbG9vcCB0IH5mIChpIC0gMSlcbiAgaW5cbiAgbG9vcCB0IH5mIChsZW5ndGggdCAtIDEpXG47O1xuXG5sZXQgZm9yX2FsbCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHQgfmYgaSA9IGlmIGkgPCAwIHRoZW4gdHJ1ZSBlbHNlIGYgKHVuc2FmZV9nZXQgdCBpKSAmJiBsb29wIHQgfmYgKGkgLSAxKSBpblxuICBsb29wIHQgfmYgKGxlbmd0aCB0IC0gMSlcbjs7XG5cbmxldCBtYXAyX2V4biB0MSB0MiB+ZiA9XG4gIGxldCBsZW4gPSBsZW5ndGggdDEgaW5cbiAgaWYgbGVuZ3RoIHQyIDw+IGxlbiB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkubWFwMl9leG5cIjtcbiAgaW5pdCBsZW4gfmY6KGZ1biBpIC0+IGYgKHVuc2FmZV9nZXQgdDEgaSkgKHVuc2FmZV9nZXQgdDIgaSkpXG47O1xuXG5sZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgZWx0KSAoZ3JhbW1hciA6IGVsdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiBlbHQgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKEFycmF5LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG47O1xuXG5pbmNsdWRlXG4gIFNleHBhYmxlLk9mX3NleHBhYmxlMVxuICAgIChBcnJheSlcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgICBsZXQgdG9fc2V4cGFibGUgPSB0b19hcnJheVxuICAgICAgbGV0IG9mX3NleHBhYmxlID0gb2ZfYXJyYXlcbiAgICBlbmQpXG5cbmluY2x1ZGUgQmxpdC5NYWtlMSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcblxuICAgIGxldCBjcmVhdGVfbGlrZSB+bGVuIHQgPVxuICAgICAgaWYgbGVuID0gMFxuICAgICAgdGhlbiBlbXB0eVxuICAgICAgZWxzZSAoXG4gICAgICAgIGFzc2VydCAobGVuZ3RoIHQgPiAwKTtcbiAgICAgICAgY3JlYXRlIH5sZW4gKGdldCB0IDApKVxuICAgIDs7XG5cbiAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuICBlbmQpXG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBsZXQgciA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lO1xuICAhclxuOztcblxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbmxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5cbigqIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIHBweF9jb21wYXJlIFtjb21wYXJlX2FycmF5XSBidXQgdXNlcyBvdXIgW3Vuc2FmZV9nZXRdIGFuZCBbbGVuZ3RoXS4gKilcbmxldCBjb21wYXJlIGNvbXBhcmVfZWx0IGEgYiA9XG4gIGlmIHBoeXNfZXF1YWwgYSBiXG4gIHRoZW4gMFxuICBlbHNlIChcbiAgICBsZXQgbGVuX2EgPSBsZW5ndGggYSBpblxuICAgIGxldCBsZW5fYiA9IGxlbmd0aCBiIGluXG4gICAgbGV0IHJldCA9IGNvbXBhcmUgbGVuX2EgbGVuX2IgaW5cbiAgICBpZiByZXQgPD4gMFxuICAgIHRoZW4gcmV0XG4gICAgZWxzZSAoXG4gICAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICAgIGlmIGkgPSBsZW5fYVxuICAgICAgICB0aGVuIDBcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IGwgPSB1bnNhZmVfZ2V0IGEgaVxuICAgICAgICAgIGFuZCByID0gdW5zYWZlX2dldCBiIGkgaW5cbiAgICAgICAgICBsZXQgcmVzID0gY29tcGFyZV9lbHQgbCByIGluXG4gICAgICAgICAgaWYgcmVzIDw+IDAgdGhlbiByZXMgZWxzZSBsb29wIChpICsgMSkpXG4gICAgICBpblxuICAgICAgbG9vcCAwKSlcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBjZWlsID0gQ2FtbC5jZWlsXG5sZXQgZmxvb3IgPSBDYW1sLmZsb29yXG5sZXQgbW9kX2Zsb2F0ID0gQ2FtbC5tb2RfZmxvYXRcbmxldCBtb2RmID0gQ2FtbC5tb2RmXG5sZXQgZmxvYXRfb2Zfc3RyaW5nID0gQ2FtbC5mbG9hdF9vZl9zdHJpbmdcbmxldCBuYW4gPSBDYW1sLm5hblxubGV0IGluZmluaXR5ID0gQ2FtbC5pbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IENhbWwubmVnX2luZmluaXR5XG5sZXQgbWF4X2Zpbml0ZV92YWx1ZSA9IENhbWwubWF4X2Zsb2F0XG5sZXQgZXBzaWxvbl9mbG9hdCA9IENhbWwuZXBzaWxvbl9mbG9hdFxubGV0IGNsYXNzaWZ5X2Zsb2F0ID0gQ2FtbC5jbGFzc2lmeV9mbG9hdFxubGV0IGFic19mbG9hdCA9IENhbWwuYWJzX2Zsb2F0XG5sZXQgaXNfaW50ZWdlciA9IENhbWwuRmxvYXQuaXNfaW50ZWdlclxubGV0ICggKiogKSA9IENhbWwuKCAqKiApXG5cbmxldCAoICUuICkgYSBiID1cbiAgKCogUmFpc2UgaW4gY2FzZSBvZiBhIG5lZ2F0aXZlIG1vZHVsdXMsIGFzIGRvZXMgSW50LiggJSApLiAqKVxuICBpZiBiIDwgMC5cbiAgdGhlbiBQcmludGYuaW52YWxpZF9hcmdmIFwiJWYgJSUgJWYgaW4gZmxvYXQwLm1sOiBtb2R1bHVzIHNob3VsZCBiZSBwb3NpdGl2ZVwiIGEgYiAoKTtcbiAgbGV0IG0gPSBDYW1sLm1vZF9mbG9hdCBhIGIgaW5cbiAgKCogUHJvZHVjZSBhIG5vbi1uZWdhdGl2ZSByZXN1bHQgaW4gYW5hbG9neSB3aXRoIEludC4oICUgKS4gKilcbiAgaWYgbSA8IDAuIHRoZW4gbSArLiBiIGVsc2UgbVxuOztcblxuKCogVGhlIGJpdHMgb2YgSU5SSUEncyBbUGVydmFzaXZlc10gdGhhdCB3ZSBqdXN0IHdhbnQgdG8gZXhwb3NlIGluIFtGbG9hdF0uIE1vc3QgYXJlXG4gICBhbHJlYWR5IGRlcHJlY2F0ZWQgaW4gW1BlcnZhc2l2ZXNdLCBhbmQgZXZlbnR1YWxseSBhbGwgb2YgdGhlbSBzaG91bGQgYmUuICopXG5pbmNsdWRlIChcbiAgQ2FtbCA6XG4gIHNpZ1xuICAgIGV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuXG4gICAgZXh0ZXJuYWwgbGRleHBcbiAgICAgIDogIChmbG9hdFtAdW5ib3hlZF0pXG4gICAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgICAtPiAoZmxvYXRbQHVuYm94ZWRdKVxuICAgICAgPSBcImNhbWxfbGRleHBfZmxvYXRcIiBcImNhbWxfbGRleHBfZmxvYXRfdW5ib3hlZFwiXG4gICAgW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGxvZzEwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMTBfZmxvYXRcIiBcImxvZzEwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGV4cG0xIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwbTFfZmxvYXRcIiBcImNhbWxfZXhwbTFcIlxuICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgY29weXNpZ24gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3B5c2lnbl9mbG9hdFwiIFwiY2FtbF9jb3B5c2lnblwiXG4gICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5fZmxvYXRcIiBcInNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBhc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbl9mbG9hdFwiIFwiYXNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBoeXBvdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCJcbiAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCB0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuaF9mbG9hdFwiIFwidGFuaFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gIGVuZClcblxuKCogV2UgbmVlZCB0aGlzIGluZGlyZWN0aW9uIGJlY2F1c2UgdGhlc2UgYXJlIGV4cG9zZWQgYXMgXCJ2YWxcIiBpbnN0ZWFkIG9mIFwiZXh0ZXJuYWxcIiAqKVxubGV0IGZyZXhwID0gZnJleHBcbmxldCBsZGV4cCA9IGxkZXhwXG5sZXQgaXNfbmFuIHggPSAoeCA6IGZsb2F0KSA8PiB4XG5cbigqIEFuIG9yZGVyLXByZXNlcnZpbmcgYmlqZWN0aW9uIGJldHdlZW4gYWxsIGZsb2F0cyBleGNlcHQgZm9yIE5hTnMsIGFuZCA5OS45NSUgb2ZcbiAgIGludDY0cy5cblxuICAgTm90ZSB3ZSBkb24ndCBkaXN0aW5ndWlzaCAwLiBhbmQgLTAuIGFzIHNlcGFyYXRlIHZhbHVlcyBoZXJlLCB0aGV5IGJvdGggbWFwIHRvIDBMLCB3aGljaFxuICAgbWFwcyBiYWNrIHRvIDAuXG5cbiAgIFRoaXMgc2hvdWxkIHdvcmsgYm90aCBvbiBsaXR0bGUtZW5kaWFuIGFuZCBoaWdoLWVuZGlhbiBDUFVzLiAgV2lraXBlZGlhIHNheXM6IFwib25cbiAgIG1vZGVybiBzdGFuZGFyZCBjb21wdXRlcnMgKGkuZS4sIGltcGxlbWVudGluZyBJRUVFIDc1NCksIG9uZSBtYXkgaW4gcHJhY3RpY2Ugc2FmZWx5XG4gICBhc3N1bWUgdGhhdCB0aGUgZW5kaWFubmVzcyBpcyB0aGUgc2FtZSBmb3IgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyBhcyBmb3IgaW50ZWdlcnNcIlxuICAgKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRW5kaWFubmVzcyNGbG9hdGluZy1wb2ludF9hbmRfZW5kaWFubmVzcykuXG4qKVxubGV0IHRvX2ludDY0X3ByZXNlcnZlX29yZGVyIHQgPVxuICBpZiBpc19uYW4gdFxuICB0aGVuIE5vbmVcbiAgZWxzZSBpZiB0ID0gMC5cbiAgdGhlbiAoKiBhbHNvIGluY2x1ZGVzIC0wLiAqKVxuICAgIFNvbWUgMExcbiAgZWxzZSBpZiB0ID4gMC5cbiAgdGhlbiBTb21lIChDYW1sLkludDY0LmJpdHNfb2ZfZmxvYXQgdClcbiAgZWxzZSBTb21lIChDYW1sLkludDY0Lm5lZyAoQ2FtbC5JbnQ2NC5iaXRzX29mX2Zsb2F0ICgtLnQpKSlcbjs7XG5cbmxldCB0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlcl9leG4geCA9IE9wdGlvbi52YWx1ZV9leG4gKHRvX2ludDY0X3ByZXNlcnZlX29yZGVyIHgpXG5cbmxldCBvZl9pbnQ2NF9wcmVzZXJ2ZV9vcmRlciB4ID1cbiAgaWYgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSB4IDBMXG4gIHRoZW4gQ2FtbC5JbnQ2NC5mbG9hdF9vZl9iaXRzIHhcbiAgZWxzZSB+LS4oQ2FtbC5JbnQ2NC5mbG9hdF9vZl9iaXRzIChDYW1sLkludDY0Lm5lZyB4KSlcbjs7XG5cbmxldCBvbmVfdWxwIGRpciB0ID1cbiAgbWF0Y2ggdG9faW50NjRfcHJlc2VydmVfb3JkZXIgdCB3aXRoXG4gIHwgTm9uZSAtPiBDYW1sLm5hblxuICB8IFNvbWUgeCAtPlxuICAgIG9mX2ludDY0X3ByZXNlcnZlX29yZGVyXG4gICAgICAoQ2FtbC5JbnQ2NC5hZGRcbiAgICAgICAgIHhcbiAgICAgICAgIChtYXRjaCBkaXIgd2l0aFxuICAgICAgICAgIHwgYFVwIC0+IDFMXG4gICAgICAgICAgfCBgRG93biAtPiAtMUwpKVxuOztcblxuKCogW3VwcGVyX2JvdW5kX2Zvcl9pbnRdIGFuZCBbbG93ZXJfYm91bmRfZm9yX2ludF0gYXJlIGZvciBjYWxjdWxhdGluZyB0aGUgbWF4L21pbiBmbG9hdFxuICAgdGhhdCBmaXRzIGluIGEgZ2l2ZW4tc2l6ZSBpbnRlZ2VyIHdoZW4gcm91bmRlZCB0b3dhcmRzIDAgKHVzaW5nIFtpbnRfb2ZfZmxvYXRdKS5cblxuICAgbWF4X2ludC9taW5faW50IGRlcGVuZCBvbiBbbnVtX2JpdHNdLCBlLmcuICsvLSAyXjMwLCArLy0gMl42MiBpZiAzMS1iaXQsIDYzLWJpdFxuICAgKHJlc3BlY3RpdmVseSkgd2hpbGUgZmxvYXQgaXMgSUVFRSBzdGFuZGFyZCBmb3IgZG91YmxlICg1MiBzaWduaWZpY2FudCBiaXRzKS5cblxuICAgSW4gYWxsIGNhc2VzLCB3ZSB3YW50IHRvIGd1YXJhbnRlZSB0aGF0XG4gICBbbG93ZXJfYm91bmRfZm9yX2ludCA8PSB4IDw9IHVwcGVyX2JvdW5kX2Zvcl9pbnRdXG4gICBpZmYgW2ludF9vZl9mbG9hdCB4XSBmaXRzIGluIGFuIGludCB3aXRoIFtudW1fYml0c10gYml0cy5cblxuICAgWzIgKiogKG51bV9iaXRzIC0gMSldIGlzIHRoZSBmaXJzdCBmbG9hdCBncmVhdGVyIHRoYXQgbWF4X2ludCwgd2UgdXNlIHRoZSBwcmVjZWRpbmdcbiAgIGZsb2F0IGFzIHVwcGVyIGJvdW5kLlxuXG4gICBbLSAoMiAqKiAobnVtX2JpdHMgLSAxKSldIGlzIGVxdWFsIHRvIG1pbl9pbnQuXG4gICBGb3IgbG93ZXIgYm91bmQgd2UgbG9vayBmb3IgdGhlIHNtYWxsZXN0IGZsb2F0IFtmXSBzYXRpc2Z5aW5nIFtmID4gbWluX2ludCAtIDFdIHNvIHRoYXRcbiAgIFtmXSByb3VuZHMgdG93YXJkIHplcm8gdG8gW21pbl9pbnRdXG5cbiAgIFNvIGluIHBhcnRpY3VsYXIgd2Ugd2lsbCBoYXZlOlxuICAgW2xvd2VyX2JvdW5kX2Zvcl9pbnQgeCA8PSAtICgyICoqICgxLXgpKV1cbiAgIFt1cHBlcl9ib3VuZF9mb3JfaW50IHggIDwgICAgMiAqKiAoMS14KSBdXG4qKVxubGV0IHVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHMgPVxuICBsZXQgZXhwID0gQ2FtbC5mbG9hdF9vZl9pbnQgKG51bV9iaXRzIC0gMSkgaW5cbiAgb25lX3VscCBgRG93biAoMi4gKiogZXhwKVxuOztcblxubGV0IGlzX3hfbWludXNfb25lX2V4YWN0IHggPVxuICAoKiBbeCA9IHggLS4gMS5dIGRvZXMgbm90IHdvcmsgd2l0aCB4ODcgZmxvYXRpbmcgcG9pbnQgYXJpdGhtZXRpYyBiYWNrZW5kICh3aGljaCBpcyB1c2VkXG4gICAgIG9uIDMyLWJpdCBvY2FtbCkgYmVjYXVzZSBvZiA4MC1iaXQgcmVnaXN0ZXIgcHJlY2lzaW9uIG9mIGludGVybWVkaWF0ZSBjb21wdXRhdGlvbnMuXG5cbiAgICAgQW4gYWx0ZXJuYXRpdmUgd2F5IG9mIGNvbXB1dGluZyB0aGlzOiBbeCAtLiBvbmVfdWxwIGBEb3duIHggPD0gMS5dIGlzIGFsc28gcHJvbmUgdG9cbiAgICAgdGhlIHNhbWUgcHJlY2lzaW9uIGlzc3VlczogeW91IG5lZWQgdG8gbWFrZSBzdXJlIFt4XSBpcyA2NC1iaXQuXG4gICopXG4gIGxldCBvcGVuIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICBub3QgKENhbWwuSW50NjQuYml0c19vZl9mbG9hdCB4ID0gQ2FtbC5JbnQ2NC5iaXRzX29mX2Zsb2F0ICh4IC0uIDEuKSlcbjs7XG5cbmxldCBsb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzID1cbiAgbGV0IGV4cCA9IENhbWwuZmxvYXRfb2ZfaW50IChudW1fYml0cyAtIDEpIGluXG4gIGxldCBtaW5faW50X2FzX2Zsb2F0ID0gfi0uKDIuICoqIGV4cCkgaW5cbiAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICBpZiBudW1fYml0cyAtIDEgPCA1MyAoKiA1MyA9ICNiaXRzIGluIHRoZSBmbG9hdCdzIG1hbnRpc3NhIHdpdGggc2lnbiBpbmNsdWRlZCAqKVxuICB0aGVuIChcbiAgICAoKiBUaGUgc21hbGxlc3QgZmxvYXQgdGhhdCByb3VuZHMgdG93YXJkcyB6ZXJvIHRvIFttaW5faW50XSBpc1xuICAgICAgIFttaW5faW50IC0gMSArIGVwc2lsb25dICopXG4gICAgYXNzZXJ0IChpc194X21pbnVzX29uZV9leGFjdCBtaW5faW50X2FzX2Zsb2F0KTtcbiAgICBvbmVfdWxwIGBVcCAobWluX2ludF9hc19mbG9hdCAtLiAxLikpXG4gIGVsc2UgKFxuICAgICgqIFttaW5faW50X2FzX2Zsb2F0XSBpcyBhbHJlYWR5IHRoZSBzbWFsbGVzdCBmbG9hdCBbZl0gc2F0aXNmeWluZyBbZiA+IG1pbl9pbnQgLSAxXS4gKilcbiAgICBhc3NlcnQgKG5vdCAoaXNfeF9taW51c19vbmVfZXhhY3QgbWluX2ludF9hc19mbG9hdCkpO1xuICAgIG1pbl9pbnRfYXNfZmxvYXQpXG47O1xuXG4oKiBGbG9hdCBjbGFtcGluZyBpcyBzdHJ1Y3R1cmVkIHNsaWdodGx5IGRpZmZlcmVudGx5IHRoYW4gY2xhbXBpbmcgZm9yIG90aGVyIHR5cGVzLCBzb1xuICAgdGhhdCB3ZSBnZXQgdGhlIGJlaGF2aW9yIG9mIFtjbGFtcF91bmNoZWNrZWQgbmFuIH5taW4gfm1heCA9IG5hbl0gKGZvciBhbnkgW21pbl0gYW5kXG4gICBbbWF4XSkgZm9yIGZyZWUuXG4qKVxubGV0IGNsYW1wX3VuY2hlY2tlZCAodCA6IGZsb2F0KSB+bWluIH5tYXggPVxuICBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgbWF4IDwgdCB0aGVuIG1heCBlbHNlIHRcbjs7XG5cbmxldCBib3ggPVxuICAoKiBQcmV2ZW50IHBvdGVudGlhbCBjb25zdGFudCBmb2xkaW5nIG9mIFsrLiAwLl0gaW4gdGhlIG5lYXIgb2NhbWxvcHQgZnV0dXJlLiAqKVxuICBsZXQgeCA9IFN5czAub3BhcXVlX2lkZW50aXR5IDAuIGluXG4gIGZ1biBmIC0+IGYgKy4geFxuOztcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5pbmNsdWRlIENoYXIwXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGNoYXIgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZSA9IChjb21wYXJlX2NoYXIgOiB0IC0+IHQgLT4gaW50KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfY2hhclxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfY2hhciBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoY2hhcl9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9jaGFyIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGNoYXJfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgdG9fc3RyaW5nIHQgPSBTdHJpbmcubWFrZSAxIHRcblxuICBsZXQgb2Zfc3RyaW5nIHMgPVxuICAgIG1hdGNoIFN0cmluZy5sZW5ndGggcyB3aXRoXG4gICAgfCAxIC0+IHMuWzBdXG4gICAgfCBfIC0+IGZhaWx3aXRoZiBcIkNoYXIub2Zfc3RyaW5nOiAlU1wiIHMgKClcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFRcblxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuQ2hhclwiXG4gIGVuZClcblxubGV0IHBwIGZtdCBjID0gQ2FtbC5Gb3JtYXQuZnByaW50ZiBmbXQgXCIlQ1wiIGNcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgQ2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBhbGwgPSBBcnJheS5pbml0IDI1NiB+Zjp1bnNhZmVfb2ZfaW50IHw+IEFycmF5LnRvX2xpc3RcblxubGV0IGlzX2xvd2VyY2FzZSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3VwcGVyY2FzZSA9IGZ1bmN0aW9uXG4gIHwgJ0EnIC4uICdaJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3ByaW50ID0gZnVuY3Rpb25cbiAgfCAnICcgLi4gJ34nIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfd2hpdGVzcGFjZSA9IGZ1bmN0aW9uXG4gIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXDAxMScgKCogdmVydGljYWwgdGFiICopIHwgJ1xcMDEyJyAoKiBmb3JtIGZlZWQgKikgfCAnXFxyJyB8ICcgJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfYWxwaGEgPSBmdW5jdGlvblxuICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG4oKiBXcml0aW5nIHRoZXNlIG91dCwgaW5zdGVhZCBvZiBjYWxsaW5nIFtpc19hbHBoYV0gYW5kIFtpc19kaWdpdF0sIHJlZHVjZXNcbiAgIHJ1bnRpbWUgYnkgYXBwcm94LiAzMCUgKilcbmxldCBpc19hbHBoYW51bSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgfCAnMCcgLi4gJzknIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgZ2V0X2RpZ2l0X3Vuc2FmZSB0ID0gdG9faW50IHQgLSB0b19pbnQgJzAnXG5cbmxldCBnZXRfZGlnaXRfZXhuIHQgPVxuICBpZiBpc19kaWdpdCB0XG4gIHRoZW4gZ2V0X2RpZ2l0X3Vuc2FmZSB0XG4gIGVsc2UgZmFpbHdpdGhmIFwiQ2hhci5nZXRfZGlnaXRfZXhuICVDOiBub3QgYSBkaWdpdFwiIHQgKClcbjs7XG5cbmxldCBnZXRfZGlnaXQgdCA9IGlmIGlzX2RpZ2l0IHQgdGhlbiBTb21lIChnZXRfZGlnaXRfdW5zYWZlIHQpIGVsc2UgTm9uZVxuXG5sZXQgaXNfaGV4X2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19oZXhfZGlnaXRfbG93ZXIgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfaGV4X2RpZ2l0X3VwcGVyID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIHwgJ0EnIC4uICdGJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGdldF9oZXhfZGlnaXRfZXhuID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIGFzIHQgLT4gdG9faW50IHQgLSB0b19pbnQgJzAnXG4gIHwgJ2EnIC4uICdmJyBhcyB0IC0+IHRvX2ludCB0IC0gdG9faW50ICdhJyArIDEwXG4gIHwgJ0EnIC4uICdGJyBhcyB0IC0+IHRvX2ludCB0IC0gdG9faW50ICdBJyArIDEwXG4gIHwgdCAtPlxuICAgIEVycm9yLnJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiQ2hhci5nZXRfaGV4X2RpZ2l0X2V4bjogbm90IGEgaGV4YWRlY2ltYWwgZGlnaXRcIlxuICAgICAgICAgWyBcImNoYXJcIiwgc2V4cF9vZl90IHQgXSlcbjs7XG5cbmxldCBnZXRfaGV4X2RpZ2l0IHQgPSBpZiBpc19oZXhfZGlnaXQgdCB0aGVuIFNvbWUgKGdldF9oZXhfZGlnaXRfZXhuIHQpIGVsc2UgTm9uZVxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBsZXQgKCA+PSApID0gKCA+PSApXG4gIGxldCAoIDw9ICkgPSAoIDw9IClcbiAgbGV0ICggPSApID0gKCA9IClcbiAgbGV0ICggPiApID0gKCA+IClcbiAgbGV0ICggPCApID0gKCA8IClcbiAgbGV0ICggPD4gKSA9ICggPD4gKVxuZW5kXG5cbm1vZHVsZSBDYXNlbGVzcyA9IHN0cnVjdFxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IGNoYXIgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICAgIGxldCB0X29mX3NleHAgPSAoY2hhcl9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gICAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2NoYXIgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBjaGFyX3NleHBfZ3JhbW1hclxuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBjb21wYXJlIGMxIGMyID0gY29tcGFyZSAobG93ZXJjYXNlIGMxKSAobG93ZXJjYXNlIGMyKVxuICAgIGxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID0gaGFzaF9mb2xkX2NoYXIgc3RhdGUgKGxvd2VyY2FzZSB0KVxuICAgIGxldCBoYXNoIHQgPSBIYXNoLnJ1biBoYXNoX2ZvbGRfdCB0XG4gIGVuZFxuXG4gIGluY2x1ZGUgVFxuICBpbmNsdWRlIENvbXBhcmFibGUuTWFrZSAoVClcbmVuZFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgQ2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm1vZHVsZSBMaXN0ID0gTGlzdFxuXG5tb2R1bGUgRW51bWVyYWJsZSA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgYWxsIDogdCBsaXN0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgYWxsIDogJ2EgbGlzdCAtPiAnYSB0IGxpc3RcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBhbGwgOiAnYSBsaXN0IC0+ICdiIGxpc3QgLT4gKCdhLCAnYikgdCBsaXN0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGFsbCA6ICdhIGxpc3QgLT4gJ2IgbGlzdCAtPiAnYyBsaXN0IC0+ICgnYSwgJ2IsICdjKSB0IGxpc3RcbiAgZW5kXG5lbmRcbiIsIm9wZW4hIEltcG9ydDAuSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxubW9kdWxlIEJ5dGVzID0gQnl0ZXMwXG5tb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuXG4oKiBDb25zdHJ1Y3QgYSBieXRlIHN0cmluZyBvZiBsZW5ndGggMjU2LCBtYXBwaW5nIGV2ZXJ5IGlucHV0IGNoYXJhY3RlciBjb2RlIHRvXG4gICBpdHMgY29ycmVzcG9uZGluZyBvdXRwdXQgY2hhcmFjdGVyLlxuXG4gICBCZW5jaG1hcmtzIGluZGljYXRlIHRoYXQgdGhpcyBpcyBmYXN0ZXIgdGhhbiB0aGUgbGFtYmRhIChpbmNsdWRpbmcgY29zdCBvZlxuICAgdGhpcyBmdW5jdGlvbiksIGV2ZW4gaWYgdGFyZ2V0L3JlcGxhY2VtZW50IGFyZSBqdXN0IDIgY2hhcmFjdGVycyBlYWNoLlxuXG4gICBSZXR1cm4gTm9uZSBpZiB0aGUgdHJhbnNsYXRpb24gbWFwIGlzIGVxdWl2YWxlbnQgdG8ganVzdCB0aGUgaWRlbnRpdHkuICopXG5sZXQgdHJfY3JlYXRlX21hcCB+dGFyZ2V0IH5yZXBsYWNlbWVudCA9XG4gIGxldCB0cl9tYXAgPSBCeXRlcy5jcmVhdGUgMjU2IGluXG4gIGZvciBpID0gMCB0byAyNTUgZG9cbiAgICBCeXRlcy51bnNhZmVfc2V0IHRyX21hcCBpIChDaGFyLm9mX2ludF9leG4gaSlcbiAgZG9uZTtcbiAgZm9yIGkgPSAwIHRvIG1pbiAoU3RyaW5nLmxlbmd0aCB0YXJnZXQpIChTdHJpbmcubGVuZ3RoIHJlcGxhY2VtZW50KSAtIDEgZG9cbiAgICBsZXQgaW5kZXggPSBDaGFyLnRvX2ludCAoU3RyaW5nLnVuc2FmZV9nZXQgdGFyZ2V0IGkpIGluXG4gICAgQnl0ZXMudW5zYWZlX3NldCB0cl9tYXAgaW5kZXggKFN0cmluZy51bnNhZmVfZ2V0IHJlcGxhY2VtZW50IGkpXG4gIGRvbmU7XG4gIGxldCBsYXN0X3JlcGxhY2VtZW50ID0gU3RyaW5nLnVuc2FmZV9nZXQgcmVwbGFjZW1lbnQgKFN0cmluZy5sZW5ndGggcmVwbGFjZW1lbnQgLSAxKSBpblxuICBmb3JcbiAgICBpID0gbWluIChTdHJpbmcubGVuZ3RoIHRhcmdldCkgKFN0cmluZy5sZW5ndGggcmVwbGFjZW1lbnQpIHRvIFN0cmluZy5sZW5ndGggdGFyZ2V0IC0gMVxuICBkb1xuICAgIGxldCBpbmRleCA9IENoYXIudG9faW50IChTdHJpbmcudW5zYWZlX2dldCB0YXJnZXQgaSkgaW5cbiAgICBCeXRlcy51bnNhZmVfc2V0IHRyX21hcCBpbmRleCBsYXN0X3JlcGxhY2VtZW50XG4gIGRvbmU7XG4gIGxldCByZWMgaGF2ZV9hbnlfZGlmZmVyZW50IHRyX21hcCBpID1cbiAgICBpZiBpID0gMjU2XG4gICAgdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgQ2hhci4oIDw+ICkgKEJ5dGVzMC51bnNhZmVfZ2V0IHRyX21hcCBpKSAoQ2hhci5vZl9pbnRfZXhuIGkpXG4gICAgdGhlbiB0cnVlXG4gICAgZWxzZSBoYXZlX2FueV9kaWZmZXJlbnQgdHJfbWFwIChpICsgMSlcbiAgaW5cbiAgKCogcXVpY2sgY2hlY2sgb24gdGhlIGZpcnN0IHRhcmdldCBjaGFyYWN0ZXIgd2hpY2ggd2lsbCA5OSUgYmUgdHJ1ZSAqKVxuICBsZXQgZmlyc3RfdGFyZ2V0ID0gdGFyZ2V0LlswXSBpblxuICBpZiBDaGFyLiggPD4gKSAoQnl0ZXMwLnVuc2FmZV9nZXQgdHJfbWFwIChDaGFyLnRvX2ludCBmaXJzdF90YXJnZXQpKSBmaXJzdF90YXJnZXRcbiAgfHwgaGF2ZV9hbnlfZGlmZmVyZW50IHRyX21hcCAwXG4gIHRoZW4gU29tZSAoQnl0ZXMwLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6dHJfbWFwKVxuICBlbHNlIE5vbmVcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSAnYSB0ID0gJ2FcblxubGV0IHN0YWdlID0gRm4uaWRcbmxldCB1bnN0YWdlID0gRm4uaWRcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5pbmNsdWRlIFN0cmluZzBcbm1vZHVsZSBCeXRlcyA9IEJ5dGVzMFxuKCogVGhpcyBhbGlhcyBpcyBuZWNlc3NhcnkgZGVzcGl0ZSBbU3RyaW5nMF0gZGVmaW5pbmcgW0J5dGVzID0gQnl0ZXMwXSwgaW4gb3JkZXIgdG9cbiAgIGNvbnZpbmNlIG9jYW1sZGVwIHRoYXQgdGhpcyBmaWxlIGRvZXNuJ3QgZGVwZW5kIG9uIGJ5dGVzLm1sLiAqKVxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5sZXQgc3RhZ2UgPSBTdGFnZWQuc3RhZ2VcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gc3RyaW5nIFtAQGRlcml2aW5nX2lubGluZSBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9zdHJpbmdcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX3N0cmluZyBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoc3RyaW5nX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX3N0cmluZyA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBzdHJpbmdfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBjb21wYXJlID0gY29tcGFyZVxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbnR5cGUgZWx0ID0gY2hhclxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxuXG4oKiBUaGlzIGlzIGNvcGllZC9hZGFwdGVkIGZyb20gJ2JsaXQubWwnLlxuICAgW3N1Yl0sIFtzdWJvXSBjb3VsZCBiZSBpbXBsZW1lbnRlZCB1c2luZyBbQmxpdC5NYWtlKEJ5dGVzKV0gcGx1cyB1bnNhZmUgY2FzdHMgdG8vZnJvbVxuICAgc3RyaW5nIGJ1dCB3ZXJlIGlubGluZWQgaGVyZSB0byBhdm9pZCB1c2luZyBbQnl0ZXMudW5zYWZlX29mX3N0cmluZ10gYXMgbXVjaCBhcyBwb3NzaWJsZS5cbiopXG5sZXQgc3ViIHNyYyB+cG9zIH5sZW4gPVxuICBpZiBwb3MgPSAwICYmIGxlbiA9IFN0cmluZy5sZW5ndGggc3JjXG4gIHRoZW4gc3JjXG4gIGVsc2UgKFxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCBzcmMpO1xuICAgIGlmIGxlbiA9IDBcbiAgICB0aGVuIFwiXCJcbiAgICBlbHNlIChcbiAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgICBCeXRlcy51bnNhZmVfYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3Bvczpwb3MgfmRzdCB+ZHN0X3BvczowIH5sZW47XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdCkpXG47O1xuXG5sZXQgc3VibyA/KHBvcyA9IDApID9sZW4gc3JjID1cbiAgc3ViXG4gICAgc3JjXG4gICAgfnBvc1xuICAgIH5sZW46XG4gICAgICAobWF0Y2ggbGVuIHdpdGhcbiAgICAgICB8IFNvbWUgaSAtPiBpXG4gICAgICAgfCBOb25lIC0+IGxlbmd0aCBzcmMgLSBwb3MpXG47O1xuXG5sZXQgcmVjIGNvbnRhaW5zX3Vuc2FmZSB0IH5wb3MgfmVuZF8gY2hhciA9XG4gIHBvcyA8IGVuZF9cbiAgJiYgKENoYXIuZXF1YWwgKHVuc2FmZV9nZXQgdCBwb3MpIGNoYXIgfHwgY29udGFpbnNfdW5zYWZlIHQgfnBvczoocG9zICsgMSkgfmVuZF8gY2hhcilcbjs7XG5cbmxldCBjb250YWlucyA/KHBvcyA9IDApID9sZW4gdCBjaGFyID1cbiAgbGV0IHRvdGFsX2xlbmd0aCA9IFN0cmluZy5sZW5ndGggdCBpblxuICBsZXQgbGVuID0gT3B0aW9uLnZhbHVlIGxlbiB+ZGVmYXVsdDoodG90YWxfbGVuZ3RoIC0gcG9zKSBpblxuICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmNoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoO1xuICBjb250YWluc191bnNhZmUgdCB+cG9zIH5lbmRfOihwb3MgKyBsZW4pIGNoYXJcbjs7XG5cbmxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG5cbmxldCByZWMgaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgc3RyaW5nIH5wb3MgfmxlbiB+bm90X2ZvdW5kIGNoYXIgPVxuICBpZiBwb3MgPj0gbGVuXG4gIHRoZW4gcmFpc2Ugbm90X2ZvdW5kXG4gIGVsc2UgaWYgQ2hhci5lcXVhbCAodW5zYWZlX2dldCBzdHJpbmcgcG9zKSBjaGFyXG4gIHRoZW4gcG9zXG4gIGVsc2UgaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgc3RyaW5nIH5wb3M6KHBvcyArIDEpIH5sZW4gfm5vdF9mb3VuZCBjaGFyXG47O1xuXG5sZXQgaW5kZXhfZXhuX2ludGVybmFsIHQgfm5vdF9mb3VuZCBjaGFyID1cbiAgaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgdCB+cG9zOjAgfmxlbjoobGVuZ3RoIHQpIH5ub3RfZm91bmQgY2hhclxuOztcblxubGV0IGluZGV4X2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIlN0cmluZy5pbmRleF9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgaW5kZXhfZXhuIHQgY2hhciA9IGluZGV4X2V4bl9pbnRlcm5hbCB0IH5ub3RfZm91bmQgY2hhciBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGluZGV4X2V4blxuOztcblxubGV0IGluZGV4X2Zyb21fZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLmluZGV4X2Zyb21fZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGluZGV4X2Zyb21fZXhuIHQgcG9zIGNoYXIgPVxuICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgIGlmIHBvcyA8IDAgfHwgcG9zID4gbGVuXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX2V4blwiXG4gICAgZWxzZSBpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCB0IH5wb3MgfmxlbiB+bm90X2ZvdW5kIGNoYXJcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBpbmRleF9mcm9tX2V4blxuOztcblxubGV0IHJlYyByaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgc3RyaW5nIH5wb3MgfmxlbiB+bm90X2ZvdW5kIGNoYXIgPVxuICBpZiBwb3MgPCAwXG4gIHRoZW4gcmFpc2Ugbm90X2ZvdW5kXG4gIGVsc2UgaWYgQ2hhci5lcXVhbCAodW5zYWZlX2dldCBzdHJpbmcgcG9zKSBjaGFyXG4gIHRoZW4gcG9zXG4gIGVsc2UgcmluZGV4X2Zyb21fZXhuX2ludGVybmFsIHN0cmluZyB+cG9zOihwb3MgLSAxKSB+bGVuIH5ub3RfZm91bmQgY2hhclxuOztcblxubGV0IHJpbmRleF9leG5faW50ZXJuYWwgdCB+bm90X2ZvdW5kIGNoYXIgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgcmluZGV4X2Zyb21fZXhuX2ludGVybmFsIHQgfnBvczoobGVuIC0gMSkgfmxlbiB+bm90X2ZvdW5kIGNoYXJcbjs7XG5cbmxldCByaW5kZXhfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLnJpbmRleF9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgcmluZGV4X2V4biB0IGNoYXIgPSByaW5kZXhfZXhuX2ludGVybmFsIHQgfm5vdF9mb3VuZCBjaGFyIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgcmluZGV4X2V4blxuOztcblxubGV0IHJpbmRleF9mcm9tX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIlN0cmluZy5yaW5kZXhfZnJvbV9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgcmluZGV4X2Zyb21fZXhuIHQgcG9zIGNoYXIgPVxuICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgIGlmIHBvcyA8IC0xIHx8IHBvcyA+PSBsZW5cbiAgICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX2V4blwiXG4gICAgZWxzZSByaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgdCB+cG9zIH5sZW4gfm5vdF9mb3VuZCBjaGFyXG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgcmluZGV4X2Zyb21fZXhuXG47O1xuXG5sZXQgaW5kZXggdCBjaGFyID1cbiAgdHJ5IFNvbWUgKGluZGV4X2V4biB0IGNoYXIpIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgQ2FtbC5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubGV0IHJpbmRleCB0IGNoYXIgPVxuICB0cnkgU29tZSAocmluZGV4X2V4biB0IGNoYXIpIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgQ2FtbC5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubGV0IGluZGV4X2Zyb20gdCBwb3MgY2hhciA9XG4gIHRyeSBTb21lIChpbmRleF9mcm9tX2V4biB0IHBvcyBjaGFyKSB3aXRoXG4gIHwgTm90X2ZvdW5kX3MgXyB8IENhbWwuTm90X2ZvdW5kIC0+IE5vbmVcbjs7XG5cbmxldCByaW5kZXhfZnJvbSB0IHBvcyBjaGFyID1cbiAgdHJ5IFNvbWUgKHJpbmRleF9mcm9tX2V4biB0IHBvcyBjaGFyKSB3aXRoXG4gIHwgTm90X2ZvdW5kX3MgXyB8IENhbWwuTm90X2ZvdW5kIC0+IE5vbmVcbjs7XG5cbm1vZHVsZSBTZWFyY2hfcGF0dGVybjAgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IHBhdHRlcm4gOiBzdHJpbmdcbiAgICA7IGNhc2Vfc2Vuc2l0aXZlIDogYm9vbFxuICAgIDsga21wX2FycmF5IDogaW50IGFycmF5XG4gICAgfVxuXG4gIGxldCBzZXhwX29mX3QgeyBwYXR0ZXJuOyBjYXNlX3NlbnNpdGl2ZTsga21wX2FycmF5ID0gXyB9IDogU2V4cC50ID1cbiAgICBMaXN0XG4gICAgICBbIExpc3QgWyBBdG9tIFwicGF0dGVyblwiOyBzZXhwX29mX3N0cmluZyBwYXR0ZXJuIF1cbiAgICAgIDsgTGlzdCBbIEF0b20gXCJjYXNlX3NlbnNpdGl2ZVwiOyBzZXhwX29mX2Jvb2wgY2FzZV9zZW5zaXRpdmUgXVxuICAgICAgXVxuICA7O1xuXG4gIGxldCBwYXR0ZXJuIHQgPSB0LnBhdHRlcm5cbiAgbGV0IGNhc2Vfc2Vuc2l0aXZlIHQgPSB0LmNhc2Vfc2Vuc2l0aXZlXG5cbiAgKCogRmluZCBtYXggbnVtYmVyIG9mIG1hdGNoZWQgY2hhcmFjdGVycyBhdCBbbmV4dF90ZXh0X2NoYXJdLCBnaXZlbiB0aGUgY3VycmVudFxuICAgICBbbWF0Y2hlZF9jaGFyc10uIFRyeSB0byBleHRlbmQgdGhlIGN1cnJlbnQgbWF0Y2gsIGlmIGNoYXJzIGRvbid0IG1hdGNoLCB0cnkgdG8gbWF0Y2hcbiAgICAgZmV3ZXIgY2hhcnMuIElmIGNoYXJzIG1hdGNoIHRoZW4gZXh0ZW5kIHRoZSBtYXRjaC4gKilcbiAgbGV0IGttcF9pbnRlcm5hbF9sb29wIH5tYXRjaGVkX2NoYXJzIH5uZXh0X3RleHRfY2hhciB+cGF0dGVybiB+a21wX2FycmF5IH5jaGFyX2VxdWFsID1cbiAgICBsZXQgbWF0Y2hlZF9jaGFycyA9IHJlZiBtYXRjaGVkX2NoYXJzIGluXG4gICAgd2hpbGVcbiAgICAgICFtYXRjaGVkX2NoYXJzID4gMFxuICAgICAgJiYgbm90IChjaGFyX2VxdWFsIG5leHRfdGV4dF9jaGFyICh1bnNhZmVfZ2V0IHBhdHRlcm4gIW1hdGNoZWRfY2hhcnMpKVxuICAgIGRvXG4gICAgICBtYXRjaGVkX2NoYXJzIDo9IEFycmF5LnVuc2FmZV9nZXQga21wX2FycmF5ICghbWF0Y2hlZF9jaGFycyAtIDEpXG4gICAgZG9uZTtcbiAgICBpZiBjaGFyX2VxdWFsIG5leHRfdGV4dF9jaGFyICh1bnNhZmVfZ2V0IHBhdHRlcm4gIW1hdGNoZWRfY2hhcnMpXG4gICAgdGhlbiBtYXRjaGVkX2NoYXJzIDo9ICFtYXRjaGVkX2NoYXJzICsgMTtcbiAgICAhbWF0Y2hlZF9jaGFyc1xuICA7O1xuXG4gIGxldCBnZXRfY2hhcl9lcXVhbCB+Y2FzZV9zZW5zaXRpdmUgPVxuICAgIG1hdGNoIGNhc2Vfc2Vuc2l0aXZlIHdpdGhcbiAgICB8IHRydWUgLT4gQ2hhci5lcXVhbFxuICAgIHwgZmFsc2UgLT4gQ2hhci5DYXNlbGVzcy5lcXVhbFxuICA7O1xuXG4gICgqIENsYXNzaWMgS01QIHByZS1wcm9jZXNzaW5nIG9mIHRoZSBwYXR0ZXJuOiBidWlsZCB0aGUgaW50IGFycmF5LCB3aGljaCwgZm9yIGVhY2ggaSxcbiAgICAgY29udGFpbnMgdGhlIGxlbmd0aCBvZiB0aGUgbG9uZ2VzdCBub24tdHJpdmlhbCBwcmVmaXggb2YgcyB3aGljaCBpcyBlcXVhbCB0byBhIHN1ZmZpeFxuICAgICBlbmRpbmcgYXQgcy5baV0gKilcbiAgbGV0IGNyZWF0ZSBwYXR0ZXJuIH5jYXNlX3NlbnNpdGl2ZSA9XG4gICAgbGV0IG4gPSBsZW5ndGggcGF0dGVybiBpblxuICAgIGxldCBrbXBfYXJyYXkgPSBBcnJheS5jcmVhdGUgfmxlbjpuICgtMSkgaW5cbiAgICBpZiBuID4gMFxuICAgIHRoZW4gKFxuICAgICAgbGV0IGNoYXJfZXF1YWwgPSBnZXRfY2hhcl9lcXVhbCB+Y2FzZV9zZW5zaXRpdmUgaW5cbiAgICAgIEFycmF5LnVuc2FmZV9zZXQga21wX2FycmF5IDAgMDtcbiAgICAgIGxldCBtYXRjaGVkX2NoYXJzID0gcmVmIDAgaW5cbiAgICAgIGZvciBpID0gMSB0byBuIC0gMSBkb1xuICAgICAgICBtYXRjaGVkX2NoYXJzXG4gICAgICAgIDo9IGttcF9pbnRlcm5hbF9sb29wXG4gICAgICAgICAgICAgfm1hdGNoZWRfY2hhcnM6IW1hdGNoZWRfY2hhcnNcbiAgICAgICAgICAgICB+bmV4dF90ZXh0X2NoYXI6KHVuc2FmZV9nZXQgcGF0dGVybiBpKVxuICAgICAgICAgICAgIH5wYXR0ZXJuXG4gICAgICAgICAgICAgfmttcF9hcnJheVxuICAgICAgICAgICAgIH5jaGFyX2VxdWFsO1xuICAgICAgICBBcnJheS51bnNhZmVfc2V0IGttcF9hcnJheSBpICFtYXRjaGVkX2NoYXJzXG4gICAgICBkb25lKTtcbiAgICB7IHBhdHRlcm47IGNhc2Vfc2Vuc2l0aXZlOyBrbXBfYXJyYXkgfVxuICA7O1xuXG4gICgqIENsYXNzaWMgS01QOiB1c2UgdGhlIHByZS1wcm9jZXNzZWQgcGF0dGVybiB0byBvcHRpbWl6ZSBsb29rLWJlaGluZHMgb24gbm9uLW1hdGNoZXMuXG4gICAgIFdlIHJldHVybiBpbnQgdG8gYXZvaWQgYWxsb2NhdGlvbiBpbiBbaW5kZXhfZXhuXS4gLTEgbWVhbnMgbm8gbWF0Y2guICopXG4gIGxldCBpbmRleF9pbnRlcm5hbCA/KHBvcyA9IDApIHsgcGF0dGVybjsgY2FzZV9zZW5zaXRpdmU7IGttcF9hcnJheSB9IH5pbl86dGV4dCA9XG4gICAgaWYgcG9zIDwgMCB8fCBwb3MgPiBsZW5ndGggdGV4dCAtIGxlbmd0aCBwYXR0ZXJuXG4gICAgdGhlbiAtMVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGNoYXJfZXF1YWwgPSBnZXRfY2hhcl9lcXVhbCB+Y2FzZV9zZW5zaXRpdmUgaW5cbiAgICAgIGxldCBqID0gcmVmIHBvcyBpblxuICAgICAgbGV0IG1hdGNoZWRfY2hhcnMgPSByZWYgMCBpblxuICAgICAgbGV0IGsgPSBsZW5ndGggcGF0dGVybiBpblxuICAgICAgbGV0IG4gPSBsZW5ndGggdGV4dCBpblxuICAgICAgd2hpbGUgIWogPCBuICYmICFtYXRjaGVkX2NoYXJzIDwgayBkb1xuICAgICAgICBsZXQgbmV4dF90ZXh0X2NoYXIgPSB1bnNhZmVfZ2V0IHRleHQgIWogaW5cbiAgICAgICAgbWF0Y2hlZF9jaGFyc1xuICAgICAgICA6PSBrbXBfaW50ZXJuYWxfbG9vcFxuICAgICAgICAgICAgIH5tYXRjaGVkX2NoYXJzOiFtYXRjaGVkX2NoYXJzXG4gICAgICAgICAgICAgfm5leHRfdGV4dF9jaGFyXG4gICAgICAgICAgICAgfnBhdHRlcm5cbiAgICAgICAgICAgICB+a21wX2FycmF5XG4gICAgICAgICAgICAgfmNoYXJfZXF1YWw7XG4gICAgICAgIGogOj0gIWogKyAxXG4gICAgICBkb25lO1xuICAgICAgaWYgIW1hdGNoZWRfY2hhcnMgPSBrIHRoZW4gIWogLSBrIGVsc2UgLTEpXG4gIDs7XG5cbiAgbGV0IG1hdGNoZXMgdCBzdHIgPSBpbmRleF9pbnRlcm5hbCB0IH5pbl86c3RyID49IDBcblxuICBsZXQgaW5kZXggP3BvcyB0IH5pbl8gPVxuICAgIGxldCBwID0gaW5kZXhfaW50ZXJuYWwgP3BvcyB0IH5pbl8gaW5cbiAgICBpZiBwIDwgMCB0aGVuIE5vbmUgZWxzZSBTb21lIHBcbiAgOztcblxuICBsZXQgaW5kZXhfZXhuID9wb3MgdCB+aW5fID1cbiAgICBsZXQgcCA9IGluZGV4X2ludGVybmFsID9wb3MgdCB+aW5fIGluXG4gICAgaWYgcCA+PSAwXG4gICAgdGhlbiBwXG4gICAgZWxzZVxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlIFwiU3Vic3RyaW5nIG5vdCBmb3VuZFwiIFsgXCJzdWJzdHJpbmdcIiwgc2V4cF9vZl9zdHJpbmcgdC5wYXR0ZXJuIF0pXG4gIDs7XG5cbiAgbGV0IGluZGV4X2FsbCB7IHBhdHRlcm47IGNhc2Vfc2Vuc2l0aXZlOyBrbXBfYXJyYXkgfSB+bWF5X292ZXJsYXAgfmluXzp0ZXh0ID1cbiAgICBpZiBsZW5ndGggcGF0dGVybiA9IDBcbiAgICB0aGVuIExpc3QuaW5pdCAoMSArIGxlbmd0aCB0ZXh0KSB+ZjpGbi5pZFxuICAgIGVsc2UgKFxuICAgICAgbGV0IGNoYXJfZXF1YWwgPSBnZXRfY2hhcl9lcXVhbCB+Y2FzZV9zZW5zaXRpdmUgaW5cbiAgICAgIGxldCBtYXRjaGVkX2NoYXJzID0gcmVmIDAgaW5cbiAgICAgIGxldCBrID0gbGVuZ3RoIHBhdHRlcm4gaW5cbiAgICAgIGxldCBuID0gbGVuZ3RoIHRleHQgaW5cbiAgICAgIGxldCBmb3VuZCA9IHJlZiBbXSBpblxuICAgICAgZm9yIGogPSAwIHRvIG4gZG9cbiAgICAgICAgaWYgIW1hdGNoZWRfY2hhcnMgPSBrXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGZvdW5kIDo9IChqIC0gaykgOjogIWZvdW5kO1xuICAgICAgICAgICgqIHdlIGp1c3QgZm91bmQgYSBtYXRjaCBpbiB0aGUgcHJldmlvdXMgaXRlcmF0aW9uICopXG4gICAgICAgICAgbWF0Y2ggbWF5X292ZXJsYXAgd2l0aFxuICAgICAgICAgIHwgdHJ1ZSAtPiBtYXRjaGVkX2NoYXJzIDo9IEFycmF5LnVuc2FmZV9nZXQga21wX2FycmF5IChrIC0gMSlcbiAgICAgICAgICB8IGZhbHNlIC0+IG1hdGNoZWRfY2hhcnMgOj0gMCk7XG4gICAgICAgIGlmIGogPCBuXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBuZXh0X3RleHRfY2hhciA9IHVuc2FmZV9nZXQgdGV4dCBqIGluXG4gICAgICAgICAgbWF0Y2hlZF9jaGFyc1xuICAgICAgICAgIDo9IGttcF9pbnRlcm5hbF9sb29wXG4gICAgICAgICAgICAgICB+bWF0Y2hlZF9jaGFyczohbWF0Y2hlZF9jaGFyc1xuICAgICAgICAgICAgICAgfm5leHRfdGV4dF9jaGFyXG4gICAgICAgICAgICAgICB+cGF0dGVyblxuICAgICAgICAgICAgICAgfmttcF9hcnJheVxuICAgICAgICAgICAgICAgfmNoYXJfZXF1YWwpXG4gICAgICBkb25lO1xuICAgICAgTGlzdC5yZXYgIWZvdW5kKVxuICA7O1xuXG4gIGxldCByZXBsYWNlX2ZpcnN0ID9wb3MgdCB+aW5fOnMgfndpdGhfID1cbiAgICBtYXRjaCBpbmRleCA/cG9zIHQgfmluXzpzIHdpdGhcbiAgICB8IE5vbmUgLT4gc1xuICAgIHwgU29tZSBpIC0+XG4gICAgICBsZXQgbGVuX3MgPSBsZW5ndGggcyBpblxuICAgICAgbGV0IGxlbl90ID0gbGVuZ3RoIHQucGF0dGVybiBpblxuICAgICAgbGV0IGxlbl93aXRoID0gbGVuZ3RoIHdpdGhfIGluXG4gICAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIChsZW5fcyArIGxlbl93aXRoIC0gbGVuX3QpIGluXG4gICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOnMgfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOjAgfmxlbjppO1xuICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzp3aXRoXyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6aSB+bGVuOmxlbl93aXRoO1xuICAgICAgQnl0ZXMuYmxpdF9zdHJpbmdcbiAgICAgICAgfnNyYzpzXG4gICAgICAgIH5zcmNfcG9zOihpICsgbGVuX3QpXG4gICAgICAgIH5kc3RcbiAgICAgICAgfmRzdF9wb3M6KGkgKyBsZW5fd2l0aClcbiAgICAgICAgfmxlbjoobGVuX3MgLSBpIC0gbGVuX3QpO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpkc3RcbiAgOztcblxuXG4gIGxldCByZXBsYWNlX2FsbCB0IH5pbl86cyB+d2l0aF8gPVxuICAgIGxldCBtYXRjaGVzID0gaW5kZXhfYWxsIHQgfm1heV9vdmVybGFwOmZhbHNlIH5pbl86cyBpblxuICAgIG1hdGNoIG1hdGNoZXMgd2l0aFxuICAgIHwgW10gLT4gc1xuICAgIHwgXyA6OiBfIC0+XG4gICAgICBsZXQgbGVuX3MgPSBsZW5ndGggcyBpblxuICAgICAgbGV0IGxlbl90ID0gbGVuZ3RoIHQucGF0dGVybiBpblxuICAgICAgbGV0IGxlbl93aXRoID0gbGVuZ3RoIHdpdGhfIGluXG4gICAgICBsZXQgbnVtX21hdGNoZXMgPSBMaXN0Lmxlbmd0aCBtYXRjaGVzIGluXG4gICAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIChsZW5fcyArICgobGVuX3dpdGggLSBsZW5fdCkgKiBudW1fbWF0Y2hlcykpIGluXG4gICAgICBsZXQgbmV4dF9kc3RfcG9zID0gcmVmIDAgaW5cbiAgICAgIGxldCBuZXh0X3NyY19wb3MgPSByZWYgMCBpblxuICAgICAgTGlzdC5pdGVyIG1hdGNoZXMgfmY6KGZ1biBpIC0+XG4gICAgICAgIGxldCBsZW4gPSBpIC0gIW5leHRfc3JjX3BvcyBpblxuICAgICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOnMgfnNyY19wb3M6IW5leHRfc3JjX3BvcyB+ZHN0IH5kc3RfcG9zOiFuZXh0X2RzdF9wb3MgfmxlbjtcbiAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmdcbiAgICAgICAgICB+c3JjOndpdGhfXG4gICAgICAgICAgfnNyY19wb3M6MFxuICAgICAgICAgIH5kc3RcbiAgICAgICAgICB+ZHN0X3BvczooIW5leHRfZHN0X3BvcyArIGxlbilcbiAgICAgICAgICB+bGVuOmxlbl93aXRoO1xuICAgICAgICBuZXh0X2RzdF9wb3MgOj0gIW5leHRfZHN0X3BvcyArIGxlbiArIGxlbl93aXRoO1xuICAgICAgICBuZXh0X3NyY19wb3MgOj0gIW5leHRfc3JjX3BvcyArIGxlbiArIGxlbl90KTtcbiAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nXG4gICAgICAgIH5zcmM6c1xuICAgICAgICB+c3JjX3BvczohbmV4dF9zcmNfcG9zXG4gICAgICAgIH5kc3RcbiAgICAgICAgfmRzdF9wb3M6IW5leHRfZHN0X3Bvc1xuICAgICAgICB+bGVuOihsZW5fcyAtICFuZXh0X3NyY19wb3MpO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpkc3RcbiAgOztcblxuICBsZXQgc3BsaXRfb24gdCBzID1cbiAgICBsZXQgcGF0dGVybl9sZW4gPSBTdHJpbmcubGVuZ3RoIHQucGF0dGVybiBpblxuICAgIGxldCBtYXRjaGVzID0gaW5kZXhfYWxsIHQgfm1heV9vdmVybGFwOmZhbHNlIH5pbl86cyBpblxuICAgIExpc3QubWFwMl9leG5cbiAgICAgICgtcGF0dGVybl9sZW4gOjogbWF0Y2hlcylcbiAgICAgIChtYXRjaGVzIEAgWyBTdHJpbmcubGVuZ3RoIHMgXSlcbiAgICAgIH5mOihmdW4gaSBqIC0+IHN1YiBzIH5wb3M6KGkgKyBwYXR0ZXJuX2xlbikgfmxlbjooaiAtIGkgLSBwYXR0ZXJuX2xlbikpXG4gIDs7XG5cbiAgbW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgICB0eXBlIHB1YmxpYyA9IHRcblxuICAgIHR5cGUgbm9ucmVjIHQgPSB0ID1cbiAgICAgIHsgcGF0dGVybiA6IHN0cmluZ1xuICAgICAgOyBjYXNlX3NlbnNpdGl2ZSA6IGJvb2xcbiAgICAgIDsga21wX2FycmF5IDogaW50IGFycmF5XG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGVxdWFsLCBzZXhwX29mXVxuXG4gICAgbGV0IGVxdWFsID1cbiAgICAgIChmdW4gYV9fMDAyXyBiX18wMDNfIC0+XG4gICAgICAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMDJfIGJfXzAwM19cbiAgICAgICAgIHRoZW4gdHJ1ZVxuICAgICAgICAgZWxzZVxuICAgICAgICAgICBQcHhfY29tcGFyZV9saWIuKCAmJiApXG4gICAgICAgICAgICAgKGVxdWFsX3N0cmluZyBhX18wMDJfLnBhdHRlcm4gYl9fMDAzXy5wYXR0ZXJuKVxuICAgICAgICAgICAgIChQcHhfY29tcGFyZV9saWIuKCAmJiApXG4gICAgICAgICAgICAgICAgKGVxdWFsX2Jvb2wgYV9fMDAyXy5jYXNlX3NlbnNpdGl2ZSBiX18wMDNfLmNhc2Vfc2Vuc2l0aXZlKVxuICAgICAgICAgICAgICAgIChlcXVhbF9hcnJheSBlcXVhbF9pbnQgYV9fMDAyXy5rbXBfYXJyYXkgYl9fMDAzXy5rbXBfYXJyYXkpKVxuICAgICAgICAgICA6IHQgLT4gdCAtPiBib29sKVxuICAgIDs7XG5cbiAgICBsZXQgc2V4cF9vZl90ID1cbiAgICAgIChmdW4geyBwYXR0ZXJuID0gcGF0dGVybl9fMDA3X1xuICAgICAgICAgICA7IGNhc2Vfc2Vuc2l0aXZlID0gY2FzZV9zZW5zaXRpdmVfXzAwOV9cbiAgICAgICAgICAgOyBrbXBfYXJyYXkgPSBrbXBfYXJyYXlfXzAxMV9cbiAgICAgICAgICAgfSAtPlxuICAgICAgICBsZXQgYm5kc19fMDA2XyA9IFtdIGluXG4gICAgICAgIGxldCBibmRzX18wMDZfID1cbiAgICAgICAgICBsZXQgYXJnX18wMTJfID0gc2V4cF9vZl9hcnJheSBzZXhwX29mX2ludCBrbXBfYXJyYXlfXzAxMV8gaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJrbXBfYXJyYXlcIjsgYXJnX18wMTJfIF0gOjogYm5kc19fMDA2X1xuICAgICAgICBpblxuICAgICAgICBsZXQgYm5kc19fMDA2XyA9XG4gICAgICAgICAgbGV0IGFyZ19fMDEwXyA9IHNleHBfb2ZfYm9vbCBjYXNlX3NlbnNpdGl2ZV9fMDA5XyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImNhc2Vfc2Vuc2l0aXZlXCI7IGFyZ19fMDEwXyBdXG4gICAgICAgICAgOjogYm5kc19fMDA2X1xuICAgICAgICBpblxuICAgICAgICBsZXQgYm5kc19fMDA2XyA9XG4gICAgICAgICAgbGV0IGFyZ19fMDA4XyA9IHNleHBfb2Zfc3RyaW5nIHBhdHRlcm5fXzAwN18gaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwYXR0ZXJuXCI7IGFyZ19fMDA4XyBdIDo6IGJuZHNfXzAwNl9cbiAgICAgICAgaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IGJuZHNfXzAwNl9cbiAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCByZXByZXNlbnRhdGlvbiA9IEZuLmlkXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBTZWFyY2hfcGF0dGVybl9oZWxwZXIgPSBzdHJ1Y3RcbiAgbW9kdWxlIFNlYXJjaF9wYXR0ZXJuID0gU2VhcmNoX3BhdHRlcm4wXG5lbmRcblxub3BlbiBTZWFyY2hfcGF0dGVybl9oZWxwZXJcblxubGV0IHN1YnN0cl9pbmRleF9nZW4gfmNhc2Vfc2Vuc2l0aXZlID9wb3MgdCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLmluZGV4ID9wb3MgKFNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSB+Y2FzZV9zZW5zaXRpdmUgcGF0dGVybikgfmluXzp0XG47O1xuXG5sZXQgc3Vic3RyX2luZGV4X2V4bl9nZW4gfmNhc2Vfc2Vuc2l0aXZlID9wb3MgdCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLmluZGV4X2V4biA/cG9zIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pIH5pbl86dFxuOztcblxubGV0IHN1YnN0cl9pbmRleF9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZSB0IH5tYXlfb3ZlcmxhcCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLmluZGV4X2FsbFxuICAgIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pXG4gICAgfm1heV9vdmVybGFwXG4gICAgfmluXzp0XG47O1xuXG5sZXQgc3Vic3RyX3JlcGxhY2VfZmlyc3RfZ2VuIH5jYXNlX3NlbnNpdGl2ZSA/cG9zIHQgfnBhdHRlcm4gPVxuICBTZWFyY2hfcGF0dGVybi5yZXBsYWNlX2ZpcnN0ID9wb3MgKFNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSB+Y2FzZV9zZW5zaXRpdmUgcGF0dGVybikgfmluXzp0XG47O1xuXG5sZXQgc3Vic3RyX3JlcGxhY2VfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmUgdCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLnJlcGxhY2VfYWxsIChTZWFyY2hfcGF0dGVybi5jcmVhdGUgfmNhc2Vfc2Vuc2l0aXZlIHBhdHRlcm4pIH5pbl86dFxuOztcblxubGV0IGlzX3N1YnN0cmluZ19nZW4gfmNhc2Vfc2Vuc2l0aXZlIHQgfnN1YnN0cmluZyA9XG4gIE9wdGlvbi5pc19zb21lIChzdWJzdHJfaW5kZXhfZ2VuIHQgfnBhdHRlcm46c3Vic3RyaW5nIH5jYXNlX3NlbnNpdGl2ZSlcbjs7XG5cbmxldCBzdWJzdHJfaW5kZXggPSBzdWJzdHJfaW5kZXhfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgc3Vic3RyX2luZGV4X2V4biA9IHN1YnN0cl9pbmRleF9leG5fZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgc3Vic3RyX2luZGV4X2FsbCA9IHN1YnN0cl9pbmRleF9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgc3Vic3RyX3JlcGxhY2VfZmlyc3QgPSBzdWJzdHJfcmVwbGFjZV9maXJzdF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcbmxldCBzdWJzdHJfcmVwbGFjZV9hbGwgPSBzdWJzdHJfcmVwbGFjZV9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5sZXQgaXNfc3Vic3RyaW5nID0gaXNfc3Vic3RyaW5nX2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxuXG5sZXQgaXNfc3Vic3RyaW5nX2F0X2dlbiA9XG4gIGxldCByZWMgbG9vcCB+c3RyIH5zdHJfcG9zIH5zdWIgfnN1Yl9wb3MgfnN1Yl9sZW4gfmNoYXJfZXF1YWwgPVxuICAgIGlmIHN1Yl9wb3MgPSBzdWJfbGVuXG4gICAgdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBjaGFyX2VxdWFsICh1bnNhZmVfZ2V0IHN0ciBzdHJfcG9zKSAodW5zYWZlX2dldCBzdWIgc3ViX3BvcylcbiAgICB0aGVuIGxvb3AgfnN0ciB+c3RyX3Bvczooc3RyX3BvcyArIDEpIH5zdWIgfnN1Yl9wb3M6KHN1Yl9wb3MgKyAxKSB+c3ViX2xlbiB+Y2hhcl9lcXVhbFxuICAgIGVsc2UgZmFsc2VcbiAgaW5cbiAgZnVuIHN0ciB+cG9zOnN0cl9wb3MgfnN1YnN0cmluZzpzdWIgfmNoYXJfZXF1YWwgLT5cbiAgICBsZXQgc3RyX2xlbiA9IGxlbmd0aCBzdHIgaW5cbiAgICBsZXQgc3ViX2xlbiA9IGxlbmd0aCBzdWIgaW5cbiAgICBpZiBzdHJfcG9zIDwgMCB8fCBzdHJfcG9zID4gc3RyX2xlblxuICAgIHRoZW5cbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIlN0cmluZy5pc19zdWJzdHJpbmdfYXQ6IGludmFsaWQgaW5kZXggJWQgZm9yIHN0cmluZyBvZiBsZW5ndGggJWRcIlxuICAgICAgICBzdHJfcG9zXG4gICAgICAgIHN0cl9sZW5cbiAgICAgICAgKCk7XG4gICAgc3RyX3BvcyArIHN1Yl9sZW4gPD0gc3RyX2xlblxuICAgICYmIGxvb3AgfnN0ciB+c3RyX3BvcyB+c3ViIH5zdWJfcG9zOjAgfnN1Yl9sZW4gfmNoYXJfZXF1YWxcbjs7XG5cbmxldCBpc19zdWZmaXhfZ2VuIHN0cmluZyB+c3VmZml4IH5jaGFyX2VxdWFsID1cbiAgbGV0IHN0cmluZ19sZW4gPSBsZW5ndGggc3RyaW5nIGluXG4gIGxldCBzdWZmaXhfbGVuID0gbGVuZ3RoIHN1ZmZpeCBpblxuICBzdHJpbmdfbGVuID49IHN1ZmZpeF9sZW5cbiAgJiYgaXNfc3Vic3RyaW5nX2F0X2dlblxuICAgICAgIHN0cmluZ1xuICAgICAgIH5wb3M6KHN0cmluZ19sZW4gLSBzdWZmaXhfbGVuKVxuICAgICAgIH5zdWJzdHJpbmc6c3VmZml4XG4gICAgICAgfmNoYXJfZXF1YWxcbjs7XG5cbmxldCBpc19wcmVmaXhfZ2VuIHN0cmluZyB+cHJlZml4IH5jaGFyX2VxdWFsID1cbiAgbGV0IHN0cmluZ19sZW4gPSBsZW5ndGggc3RyaW5nIGluXG4gIGxldCBwcmVmaXhfbGVuID0gbGVuZ3RoIHByZWZpeCBpblxuICBzdHJpbmdfbGVuID49IHByZWZpeF9sZW5cbiAgJiYgaXNfc3Vic3RyaW5nX2F0X2dlbiBzdHJpbmcgfnBvczowIH5zdWJzdHJpbmc6cHJlZml4IH5jaGFyX2VxdWFsXG47O1xuXG5tb2R1bGUgQ2FzZWxlc3MgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBzdHJpbmcgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICAgIGxldCB0X29mX3NleHAgPSAoc3RyaW5nX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2Zfc3RyaW5nIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gc3RyaW5nX3NleHBfZ3JhbW1hclxuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBjaGFyX2NvbXBhcmVfY2FzZWxlc3MgYzEgYzIgPSBDaGFyLmNvbXBhcmUgKENoYXIubG93ZXJjYXNlIGMxKSAoQ2hhci5sb3dlcmNhc2UgYzIpXG5cbiAgICBsZXQgcmVjIGNvbXBhcmVfbG9vcCB+cG9zIH5zdHJpbmcxIH5sZW4xIH5zdHJpbmcyIH5sZW4yID1cbiAgICAgIGlmIHBvcyA9IGxlbjFcbiAgICAgIHRoZW4gaWYgcG9zID0gbGVuMiB0aGVuIDAgZWxzZSAtMVxuICAgICAgZWxzZSBpZiBwb3MgPSBsZW4yXG4gICAgICB0aGVuIDFcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgYyA9IGNoYXJfY29tcGFyZV9jYXNlbGVzcyAodW5zYWZlX2dldCBzdHJpbmcxIHBvcykgKHVuc2FmZV9nZXQgc3RyaW5nMiBwb3MpIGluXG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8IDAgLT4gY29tcGFyZV9sb29wIH5wb3M6KHBvcyArIDEpIH5zdHJpbmcxIH5sZW4xIH5zdHJpbmcyIH5sZW4yXG4gICAgICAgIHwgXyAtPiBjKVxuICAgIDs7XG5cbiAgICBsZXQgY29tcGFyZSBzdHJpbmcxIHN0cmluZzIgPVxuICAgICAgaWYgcGh5c19lcXVhbCBzdHJpbmcxIHN0cmluZzJcbiAgICAgIHRoZW4gMFxuICAgICAgZWxzZVxuICAgICAgICBjb21wYXJlX2xvb3BcbiAgICAgICAgICB+cG9zOjBcbiAgICAgICAgICB+c3RyaW5nMVxuICAgICAgICAgIH5sZW4xOihTdHJpbmcubGVuZ3RoIHN0cmluZzEpXG4gICAgICAgICAgfnN0cmluZzJcbiAgICAgICAgICB+bGVuMjooU3RyaW5nLmxlbmd0aCBzdHJpbmcyKVxuICAgIDs7XG5cbiAgICBsZXQgaGFzaF9mb2xkX3Qgc3RhdGUgdCA9XG4gICAgICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgICAgIGxldCBzdGF0ZSA9IHJlZiAoaGFzaF9mb2xkX2ludCBzdGF0ZSBsZW4pIGluXG4gICAgICBmb3IgcG9zID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIHN0YXRlIDo9IGhhc2hfZm9sZF9jaGFyICFzdGF0ZSAoQ2hhci5sb3dlcmNhc2UgKHVuc2FmZV9nZXQgdCBwb3MpKVxuICAgICAgZG9uZTtcbiAgICAgICFzdGF0ZVxuICAgIDs7XG5cbiAgICBsZXQgaGFzaCB0ID0gSGFzaC5ydW4gaGFzaF9mb2xkX3QgdFxuICAgIGxldCBpc19zdWZmaXggcyB+c3VmZml4ID0gaXNfc3VmZml4X2dlbiBzIH5zdWZmaXggfmNoYXJfZXF1YWw6Q2hhci5DYXNlbGVzcy5lcXVhbFxuICAgIGxldCBpc19wcmVmaXggcyB+cHJlZml4ID0gaXNfcHJlZml4X2dlbiBzIH5wcmVmaXggfmNoYXJfZXF1YWw6Q2hhci5DYXNlbGVzcy5lcXVhbFxuICAgIGxldCBzdWJzdHJfaW5kZXggPSBzdWJzdHJfaW5kZXhfZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBzdWJzdHJfaW5kZXhfZXhuID0gc3Vic3RyX2luZGV4X2V4bl9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IHN1YnN0cl9pbmRleF9hbGwgPSBzdWJzdHJfaW5kZXhfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgc3Vic3RyX3JlcGxhY2VfZmlyc3QgPSBzdWJzdHJfcmVwbGFjZV9maXJzdF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IHN1YnN0cl9yZXBsYWNlX2FsbCA9IHN1YnN0cl9yZXBsYWNlX2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IGlzX3N1YnN0cmluZyA9IGlzX3N1YnN0cmluZ19nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IGlzX3N1YnN0cmluZ19hdCA9IGlzX3N1YnN0cmluZ19hdF9nZW4gfmNoYXJfZXF1YWw6Q2hhci5DYXNlbGVzcy5lcXVhbFxuICBlbmRcblxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhYmxlLk1ha2UgKFQpXG5lbmRcblxubGV0IG9mX3N0cmluZyA9IEZuLmlkXG5sZXQgdG9fc3RyaW5nID0gRm4uaWRcblxubGV0IGluaXQgbiB+ZiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiU3RyaW5nLmluaXQgJWRcIiBuICgpO1xuICBsZXQgdCA9IEJ5dGVzLmNyZWF0ZSBuIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIEJ5dGVzLnNldCB0IGkgKGYgaSlcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp0XG47O1xuXG5sZXQgdG9fbGlzdCBzID1cbiAgbGV0IHJlYyBsb29wIGFjYyBpID0gaWYgaSA8IDAgdGhlbiBhY2MgZWxzZSBsb29wIChzLltpXSA6OiBhY2MpIChpIC0gMSkgaW5cbiAgbG9vcCBbXSAobGVuZ3RoIHMgLSAxKVxuOztcblxubGV0IHRvX2xpc3RfcmV2IHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGFjYyBpID0gaWYgaSA9IGxlbiB0aGVuIGFjYyBlbHNlIGxvb3AgKHMuW2ldIDo6IGFjYykgKGkgKyAxKSBpblxuICBsb29wIFtdIDBcbjs7XG5cbmxldCByZXYgdCA9XG4gIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICBsZXQgcmVzID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgcmVzIGkgKHVuc2FmZV9nZXQgdCAobGVuIC0gMSAtIGkpKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnJlc1xuOztcblxuKCoqIEVmZmljaWVudCBzdHJpbmcgc3BsaXR0aW5nICopXG5cbmxldCBsc3BsaXQyX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIlN0cmluZy5sc3BsaXQyX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBsc3BsaXQyX2V4biBsaW5lIH5vbjpkZWxpbSA9XG4gICAgbGV0IHBvcyA9IGluZGV4X2V4bl9pbnRlcm5hbCBsaW5lIH5ub3RfZm91bmQgZGVsaW0gaW5cbiAgICBzdWIgbGluZSB+cG9zOjAgfmxlbjpwb3MsIHN1YiBsaW5lIH5wb3M6KHBvcyArIDEpIH5sZW46KGxlbmd0aCBsaW5lIC0gcG9zIC0gMSlcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBsc3BsaXQyX2V4blxuOztcblxubGV0IHJzcGxpdDJfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLnJzcGxpdDJfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IHJzcGxpdDJfZXhuIGxpbmUgfm9uOmRlbGltID1cbiAgICBsZXQgcG9zID0gcmluZGV4X2V4bl9pbnRlcm5hbCBsaW5lIH5ub3RfZm91bmQgZGVsaW0gaW5cbiAgICBzdWIgbGluZSB+cG9zOjAgfmxlbjpwb3MsIHN1YiBsaW5lIH5wb3M6KHBvcyArIDEpIH5sZW46KGxlbmd0aCBsaW5lIC0gcG9zIC0gMSlcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICByc3BsaXQyX2V4blxuOztcblxubGV0IGxzcGxpdDIgbGluZSB+b24gPVxuICB0cnkgU29tZSAobHNwbGl0Ml9leG4gbGluZSB+b24pIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgQ2FtbC5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubGV0IHJzcGxpdDIgbGluZSB+b24gPVxuICB0cnkgU29tZSAocnNwbGl0Ml9leG4gbGluZSB+b24pIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgQ2FtbC5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubGV0IHJlYyBjaGFyX2xpc3RfbWVtIGwgKGMgOiBjaGFyKSA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IGZhbHNlXG4gIHwgaGQgOjogdGwgLT4gQ2hhci5lcXVhbCBoZCBjIHx8IGNoYXJfbGlzdF9tZW0gdGwgY1xuOztcblxubGV0IHNwbGl0X2dlbiBzdHIgfm9uID1cbiAgbGV0IGlzX2RlbGltID1cbiAgICBtYXRjaCBvbiB3aXRoXG4gICAgfCBgY2hhciBjJyAtPiBmdW4gYyAtPiBDaGFyLmVxdWFsIGMgYydcbiAgICB8IGBjaGFyX2xpc3QgbCAtPiBmdW4gYyAtPiBjaGFyX2xpc3RfbWVtIGwgY1xuICBpblxuICBsZXQgbGVuID0gbGVuZ3RoIHN0ciBpblxuICBsZXQgcmVjIGxvb3AgYWNjIGxhc3RfcG9zIHBvcyA9XG4gICAgaWYgcG9zID0gLTFcbiAgICB0aGVuIHN1YiBzdHIgfnBvczowIH5sZW46bGFzdF9wb3MgOjogYWNjXG4gICAgZWxzZSBpZiBpc19kZWxpbSBzdHIuW3Bvc11cbiAgICB0aGVuIChcbiAgICAgIGxldCBwb3MxID0gcG9zICsgMSBpblxuICAgICAgbGV0IHN1Yl9zdHIgPSBzdWIgc3RyIH5wb3M6cG9zMSB+bGVuOihsYXN0X3BvcyAtIHBvczEpIGluXG4gICAgICBsb29wIChzdWJfc3RyIDo6IGFjYykgcG9zIChwb3MgLSAxKSlcbiAgICBlbHNlIGxvb3AgYWNjIGxhc3RfcG9zIChwb3MgLSAxKVxuICBpblxuICBsb29wIFtdIGxlbiAobGVuIC0gMSlcbjs7XG5cbmxldCBzcGxpdCBzdHIgfm9uID0gc3BsaXRfZ2VuIHN0ciB+b246KGBjaGFyIG9uKVxubGV0IHNwbGl0X29uX2NoYXJzIHN0ciB+b246Y2hhcnMgPSBzcGxpdF9nZW4gc3RyIH5vbjooYGNoYXJfbGlzdCBjaGFycylcblxubGV0IHNwbGl0X2xpbmVzID1cbiAgbGV0IGJhY2tfdXBfYXRfbmV3bGluZSB+dCB+cG9zIH5lb2wgPVxuICAgIHBvcyA6PSAhcG9zIC0gaWYgIXBvcyA+IDAgJiYgQ2hhci5lcXVhbCB0LlshcG9zIC0gMV0gJ1xccicgdGhlbiAyIGVsc2UgMTtcbiAgICBlb2wgOj0gIXBvcyArIDFcbiAgaW5cbiAgZnVuIHQgLT5cbiAgICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gICAgaWYgbiA9IDBcbiAgICB0aGVuIFtdXG4gICAgZWxzZSAoXG4gICAgICAoKiBJbnZhcmlhbnQ6IFstMSA8PSBwb3MgPCBlb2xdLiAqKVxuICAgICAgbGV0IHBvcyA9IHJlZiAobiAtIDEpIGluXG4gICAgICBsZXQgZW9sID0gcmVmIG4gaW5cbiAgICAgIGxldCBhYyA9IHJlZiBbXSBpblxuICAgICAgKCogV2UgdHJlYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nIHNwZWNpYWxseSwgYmVjYXVzZSBpZiB0aGUgc3RyaW5nIGVuZHMgd2l0aCBhXG4gICAgICAgICBuZXdsaW5lLCB3ZSBkb24ndCB3YW50IGFuIGV4dHJhIGVtcHR5IHN0cmluZyBhdCB0aGUgZW5kIG9mIHRoZSBvdXRwdXQuICopXG4gICAgICBpZiBDaGFyLmVxdWFsIHQuWyFwb3NdICdcXG4nIHRoZW4gYmFja191cF9hdF9uZXdsaW5lIH50IH5wb3MgfmVvbDtcbiAgICAgIHdoaWxlICFwb3MgPj0gMCBkb1xuICAgICAgICBpZiBDaGFyLiggPD4gKSB0LlshcG9zXSAnXFxuJ1xuICAgICAgICB0aGVuIGRlY3IgcG9zXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIEJlY2F1c2UgW3BvcyA8IGVvbF0sIHdlIGtub3cgdGhhdCBbc3RhcnQgPD0gZW9sXS4gKilcbiAgICAgICAgICBsZXQgc3RhcnQgPSAhcG9zICsgMSBpblxuICAgICAgICAgIGFjIDo9IHN1YiB0IH5wb3M6c3RhcnQgfmxlbjooIWVvbCAtIHN0YXJ0KSA6OiAhYWM7XG4gICAgICAgICAgYmFja191cF9hdF9uZXdsaW5lIH50IH5wb3MgfmVvbClcbiAgICAgIGRvbmU7XG4gICAgICBzdWIgdCB+cG9zOjAgfmxlbjohZW9sIDo6ICFhYylcbjs7XG5cbmxldCBpc19zdWZmaXggcyB+c3VmZml4ID0gaXNfc3VmZml4X2dlbiBzIH5zdWZmaXggfmNoYXJfZXF1YWw6Q2hhci5lcXVhbFxubGV0IGlzX3ByZWZpeCBzIH5wcmVmaXggPSBpc19wcmVmaXhfZ2VuIHMgfnByZWZpeCB+Y2hhcl9lcXVhbDpDaGFyLmVxdWFsXG5cbmxldCBpc19zdWJzdHJpbmdfYXQgcyB+cG9zIH5zdWJzdHJpbmcgPVxuICBpc19zdWJzdHJpbmdfYXRfZ2VuIHMgfnBvcyB+c3Vic3RyaW5nIH5jaGFyX2VxdWFsOkNoYXIuZXF1YWxcbjs7XG5cbmxldCB3cmFwX3N1Yl9uIHQgbiB+bmFtZSB+cG9zIH5sZW4gfm9uX2Vycm9yID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyAobmFtZSBeIFwiIGV4cGVjdGluZyBub25uZWdhdGl2ZSBhcmd1bWVudFwiKVxuICBlbHNlIChcbiAgICB0cnkgc3ViIHQgfnBvcyB+bGVuIHdpdGhcbiAgICB8IF8gLT4gb25fZXJyb3IpXG47O1xuXG5sZXQgZHJvcF9wcmVmaXggdCBuID1cbiAgd3JhcF9zdWJfbiB+bmFtZTpcImRyb3BfcHJlZml4XCIgdCBuIH5wb3M6biB+bGVuOihsZW5ndGggdCAtIG4pIH5vbl9lcnJvcjpcIlwiXG47O1xuXG5sZXQgZHJvcF9zdWZmaXggdCBuID1cbiAgd3JhcF9zdWJfbiB+bmFtZTpcImRyb3Bfc3VmZml4XCIgdCBuIH5wb3M6MCB+bGVuOihsZW5ndGggdCAtIG4pIH5vbl9lcnJvcjpcIlwiXG47O1xuXG5sZXQgcHJlZml4IHQgbiA9IHdyYXBfc3ViX24gfm5hbWU6XCJwcmVmaXhcIiB0IG4gfnBvczowIH5sZW46biB+b25fZXJyb3I6dFxubGV0IHN1ZmZpeCB0IG4gPSB3cmFwX3N1Yl9uIH5uYW1lOlwic3VmZml4XCIgdCBuIH5wb3M6KGxlbmd0aCB0IC0gbikgfmxlbjpuIH5vbl9lcnJvcjp0XG5cbmxldCBsZmluZGkgPyhwb3MgPSAwKSB0IH5mID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBsZXQgcmVjIGxvb3AgaSA9IGlmIGkgPSBuIHRoZW4gTm9uZSBlbHNlIGlmIGYgaSB0LltpXSB0aGVuIFNvbWUgaSBlbHNlIGxvb3AgKGkgKyAxKSBpblxuICBsb29wIHBvc1xuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIG1hdGNoIGxmaW5kaSB0IH5mOihmdW4gXyBjIC0+IGYgYykgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgaSAtPiBTb21lIHQuW2ldXG47O1xuXG5sZXQgZmluZF9tYXAgdCB+ZiA9XG4gIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBmIHQuW2ldIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSlcbiAgICAgIHwgU29tZSBfIGFzIHJlcyAtPiByZXMpXG4gIGluXG4gIGxvb3AgMFxuOztcblxubGV0IHJmaW5kaSA/cG9zIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSA9IGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlIGlmIGYgaSB0LltpXSB0aGVuIFNvbWUgaSBlbHNlIGxvb3AgKGkgLSAxKSBpblxuICBsZXQgcG9zID1cbiAgICBtYXRjaCBwb3Mgd2l0aFxuICAgIHwgU29tZSBwb3MgLT4gcG9zXG4gICAgfCBOb25lIC0+IGxlbmd0aCB0IC0gMVxuICBpblxuICBsb29wIHBvc1xuOztcblxubGV0IGxhc3Rfbm9uX2Ryb3AgfmRyb3AgdCA9IHJmaW5kaSB0IH5mOihmdW4gXyBjIC0+IG5vdCAoZHJvcCBjKSlcblxubGV0IHJzdHJpcCA/KGRyb3AgPSBDaGFyLmlzX3doaXRlc3BhY2UpIHQgPVxuICBtYXRjaCBsYXN0X25vbl9kcm9wIHQgfmRyb3Agd2l0aFxuICB8IE5vbmUgLT4gXCJcIlxuICB8IFNvbWUgaSAtPiBpZiBpID0gbGVuZ3RoIHQgLSAxIHRoZW4gdCBlbHNlIHByZWZpeCB0IChpICsgMSlcbjs7XG5cbmxldCBmaXJzdF9ub25fZHJvcCB+ZHJvcCB0ID0gbGZpbmRpIHQgfmY6KGZ1biBfIGMgLT4gbm90IChkcm9wIGMpKVxuXG5sZXQgbHN0cmlwID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCA9XG4gIG1hdGNoIGZpcnN0X25vbl9kcm9wIHQgfmRyb3Agd2l0aFxuICB8IE5vbmUgLT4gXCJcIlxuICB8IFNvbWUgMCAtPiB0XG4gIHwgU29tZSBuIC0+IGRyb3BfcHJlZml4IHQgblxuOztcblxuKCogW3N0cmlwIHRdIGNvdWxkIGJlIGltcGxlbWVudGVkIGFzIFtsc3RyaXAgKHJzdHJpcCB0KV0uICBUaGUgaW1wbGVtZW50YXRpb25cbiAgIGJlbG93IHNhdmVzIChhdCBsZWFzdCkgYSBmYWN0b3Igb2YgdHdvIGFsbG9jYXRpb24sIGJ5IG9ubHkgYWxsb2NhdGluZyB0aGVcbiAgIGZpbmFsIHJlc3VsdC4gIFRoaXMgYWxzbyBzYXZlcyBzb21lIGFtb3VudCBvZiB0aW1lLiAqKVxubGV0IHN0cmlwID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwIHx8IG5vdCAoZHJvcCB0LlswXSB8fCBkcm9wIHQuW2xlbmd0aCAtIDFdKVxuICB0aGVuIHRcbiAgZWxzZSAoXG4gICAgbWF0Y2ggZmlyc3Rfbm9uX2Ryb3AgdCB+ZHJvcCB3aXRoXG4gICAgfCBOb25lIC0+IFwiXCJcbiAgICB8IFNvbWUgZmlyc3QgLT5cbiAgICAgIChtYXRjaCBsYXN0X25vbl9kcm9wIHQgfmRyb3Agd2l0aFxuICAgICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICB8IFNvbWUgbGFzdCAtPiBzdWIgdCB+cG9zOmZpcnN0IH5sZW46KGxhc3QgLSBmaXJzdCArIDEpKSlcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBsZXQgbCA9IGxlbmd0aCB0IGluXG4gIGxldCB0JyA9IEJ5dGVzLmNyZWF0ZSBsIGluXG4gIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdCcgaSAoZiBpIHQuW2ldKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnQnXG47O1xuXG4oKiByZXBlYXRlZCBjb2RlIHRvIGF2b2lkIHJlcXVpcmluZyBhbiBleHRyYSBhbGxvY2F0aW9uIGZvciBhIGNsb3N1cmUgb24gZWFjaCBjYWxsLiAqKVxubGV0IG1hcCB0IH5mID1cbiAgbGV0IGwgPSBsZW5ndGggdCBpblxuICBsZXQgdCcgPSBCeXRlcy5jcmVhdGUgbCBpblxuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBCeXRlcy51bnNhZmVfc2V0IHQnIGkgKGYgdC5baV0pXG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6dCdcbjs7XG5cbmxldCB0b19hcnJheSBzID0gQXJyYXkuaW5pdCAobGVuZ3RoIHMpIH5mOihmdW4gaSAtPiBzLltpXSlcblxubGV0IGV4aXN0cyA9XG4gIGxldCByZWMgbG9vcCBzIGkgfmxlbiB+ZiA9IGkgPCBsZW4gJiYgKGYgcy5baV0gfHwgbG9vcCBzIChpICsgMSkgfmxlbiB+ZikgaW5cbiAgZnVuIHMgfmYgLT4gbG9vcCBzIDAgfmxlbjoobGVuZ3RoIHMpIH5mXG47O1xuXG5sZXQgZm9yX2FsbCA9XG4gIGxldCByZWMgbG9vcCBzIGkgfmxlbiB+ZiA9IGkgPSBsZW4gfHwgKGYgcy5baV0gJiYgbG9vcCBzIChpICsgMSkgfmxlbiB+ZikgaW5cbiAgZnVuIHMgfmYgLT4gbG9vcCBzIDAgfmxlbjoobGVuZ3RoIHMpIH5mXG47O1xuXG5sZXQgZm9sZCA9XG4gIGxldCByZWMgbG9vcCB0IGkgYWMgfmYgfmxlbiA9XG4gICAgaWYgaSA9IGxlbiB0aGVuIGFjIGVsc2UgbG9vcCB0IChpICsgMSkgKGYgYWMgdC5baV0pIH5mIH5sZW5cbiAgaW5cbiAgZnVuIHQgfmluaXQgfmYgLT4gbG9vcCB0IDAgaW5pdCB+ZiB+bGVuOihsZW5ndGggdClcbjs7XG5cbmxldCBmb2xkaSA9XG4gIGxldCByZWMgbG9vcCB0IGkgYWMgfmYgfmxlbiA9XG4gICAgaWYgaSA9IGxlbiB0aGVuIGFjIGVsc2UgbG9vcCB0IChpICsgMSkgKGYgaSBhYyB0LltpXSkgfmYgfmxlblxuICBpblxuICBmdW4gdCB+aW5pdCB+ZiAtPiBsb29wIHQgMCBpbml0IH5mIH5sZW46KGxlbmd0aCB0KVxuOztcblxubGV0IGl0ZXJpIHQgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHQgLSAxIGRvXG4gICAgZiBpICh1bnNhZmVfZ2V0IHQgaSlcbiAgZG9uZVxuOztcblxubGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxubGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxubGV0IG1pbl9lbHQgdCA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHRcbmxldCBtYXhfZWx0IHQgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0XG5sZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgdFxubGV0IGZpbmRfbWFwaSB0IH5mID0gSW5kZXhlZF9jb250YWluZXIuZmluZF9tYXBpIH5pdGVyaSB0IH5mXG5sZXQgZmluZGkgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmZpbmRpIH5pdGVyaSB0IH5mXG5sZXQgY291bnRpIHQgfmYgPSBJbmRleGVkX2NvbnRhaW5lci5jb3VudGkgfmZvbGRpIHQgfmZcbmxldCBmb3JfYWxsaSB0IH5mID0gSW5kZXhlZF9jb250YWluZXIuZm9yX2FsbGkgfml0ZXJpIHQgfmZcbmxldCBleGlzdHNpIHQgfmYgPSBJbmRleGVkX2NvbnRhaW5lci5leGlzdHNpIH5pdGVyaSB0IH5mXG5cbmxldCBtZW0gPVxuICBsZXQgcmVjIGxvb3AgdCBjIH5wb3M6aSB+bGVuID1cbiAgICBpIDwgbGVuICYmIChDaGFyLmVxdWFsIGMgKHVuc2FmZV9nZXQgdCBpKSB8fCBsb29wIHQgYyB+cG9zOihpICsgMSkgfmxlbilcbiAgaW5cbiAgZnVuIHQgYyAtPiBsb29wIHQgYyB+cG9zOjAgfmxlbjoobGVuZ3RoIHQpXG47O1xuXG5sZXQgdHIgfnRhcmdldCB+cmVwbGFjZW1lbnQgcyA9XG4gIGlmIENoYXIuZXF1YWwgdGFyZ2V0IHJlcGxhY2VtZW50XG4gIHRoZW4gc1xuICBlbHNlIGlmIG1lbSBzIHRhcmdldFxuICB0aGVuIG1hcCBzIH5mOihmdW4gYyAtPiBpZiBDaGFyLmVxdWFsIGMgdGFyZ2V0IHRoZW4gcmVwbGFjZW1lbnQgZWxzZSBjKVxuICBlbHNlIHNcbjs7XG5cbmxldCB0cl9tdWx0aSB+dGFyZ2V0IH5yZXBsYWNlbWVudCA9XG4gIGlmIGlzX2VtcHR5IHRhcmdldFxuICB0aGVuIHN0YWdlIEZuLmlkXG4gIGVsc2UgaWYgaXNfZW1wdHkgcmVwbGFjZW1lbnRcbiAgdGhlbiBpbnZhbGlkX2FyZyBcInRyX211bHRpIHJlcGxhY2VtZW50IGlzIGVtcHR5IHN0cmluZ1wiXG4gIGVsc2UgKFxuICAgIG1hdGNoIEJ5dGVzX3RyLnRyX2NyZWF0ZV9tYXAgfnRhcmdldCB+cmVwbGFjZW1lbnQgd2l0aFxuICAgIHwgTm9uZSAtPiBzdGFnZSBGbi5pZFxuICAgIHwgU29tZSB0cl9tYXAgLT5cbiAgICAgIHN0YWdlIChmdW4gcyAtPlxuICAgICAgICBpZiBleGlzdHMgcyB+ZjooZnVuIGMgLT4gQ2hhci4oIDw+ICkgYyAodW5zYWZlX2dldCB0cl9tYXAgKENoYXIudG9faW50IGMpKSlcbiAgICAgICAgdGhlbiBtYXAgcyB+ZjooZnVuIGMgLT4gdW5zYWZlX2dldCB0cl9tYXAgKENoYXIudG9faW50IGMpKVxuICAgICAgICBlbHNlIHMpKVxuOztcblxuKCogZmFzdCB2ZXJzaW9uLCBpZiB3ZSBldmVyIG5lZWQgaXQ6XG4gICB7W1xuICAgICBsZXQgY29uY2F0X2FycmF5IH5zZXAgYXIgPVxuICAgICAgIGxldCBhcl9sZW4gPSBBcnJheS5sZW5ndGggYXIgaW5cbiAgICAgICBpZiBhcl9sZW4gPSAwIHRoZW4gXCJcIlxuICAgICAgIGVsc2VcbiAgICAgICAgIGxldCBzZXBfbGVuID0gbGVuZ3RoIHNlcCBpblxuICAgICAgICAgbGV0IHJlc19sZW5fcmVmID0gcmVmIChzZXBfbGVuICogKGFyX2xlbiAtIDEpKSBpblxuICAgICAgICAgZm9yIGkgPSAwIHRvIGFyX2xlbiAtIDEgZG9cbiAgICAgICAgICAgcmVzX2xlbl9yZWYgOj0gIXJlc19sZW5fcmVmICsgbGVuZ3RoIGFyLihpKVxuICAgICAgICAgZG9uZTtcbiAgICAgICAgIGxldCByZXMgPSBjcmVhdGUgIXJlc19sZW5fcmVmIGluXG4gICAgICAgICBsZXQgc3RyXzAgPSBhci4oMCkgaW5cbiAgICAgICAgIGxldCBsZW5fMCA9IGxlbmd0aCBzdHJfMCBpblxuICAgICAgICAgYmxpdCB+c3JjOnN0cl8wIH5zcmNfcG9zOjAgfmRzdDpyZXMgfmRzdF9wb3M6MCB+bGVuOmxlbl8wO1xuICAgICAgICAgbGV0IHBvc19yZWYgPSByZWYgbGVuXzAgaW5cbiAgICAgICAgIGZvciBpID0gMSB0byBhcl9sZW4gLSAxIGRvXG4gICAgICAgICAgIGxldCBwb3MgPSAhcG9zX3JlZiBpblxuICAgICAgICAgICBibGl0IH5zcmM6c2VwIH5zcmNfcG9zOjAgfmRzdDpyZXMgfmRzdF9wb3M6cG9zIH5sZW46c2VwX2xlbjtcbiAgICAgICAgICAgbGV0IG5ld19wb3MgPSBwb3MgKyBzZXBfbGVuIGluXG4gICAgICAgICAgIGxldCBzdHJfaSA9IGFyLihpKSBpblxuICAgICAgICAgICBsZXQgbGVuX2kgPSBsZW5ndGggc3RyX2kgaW5cbiAgICAgICAgICAgYmxpdCB+c3JjOnN0cl9pIH5zcmNfcG9zOjAgfmRzdDpyZXMgfmRzdF9wb3M6bmV3X3BvcyB+bGVuOmxlbl9pO1xuICAgICAgICAgICBwb3NfcmVmIDo9IG5ld19wb3MgKyBsZW5faVxuICAgICAgICAgZG9uZTtcbiAgICAgICAgIHJlc1xuICAgXX0gKilcblxubGV0IGNvbmNhdF9hcnJheSA/c2VwIGFyID0gY29uY2F0ID9zZXAgKEFycmF5LnRvX2xpc3QgYXIpXG5sZXQgY29uY2F0X21hcCA/c2VwIHMgfmYgPSBjb25jYXRfYXJyYXkgP3NlcCAoQXJyYXkubWFwICh0b19hcnJheSBzKSB+ZilcblxuKCogW2ZpbHRlciB0IGZdIGlzIGltcGxlbWVudGVkIGJ5IHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtLlxuXG4gICBMZXQgW24gPSBsZW5ndGggdF0uXG5cbiAgIDEuIEZpbmQgdGhlIGxvd2VzdCBbaV0gc3VjaCB0aGF0IFtub3QgKGYgdC5baV0pXS5cblxuICAgMi4gSWYgdGhlcmUgaXMgbm8gc3VjaCBbaV0sIHRoZW4gcmV0dXJuIFt0XS5cblxuICAgMy4gSWYgdGhlcmUgaXMgc3VjaCBhbiBbaV0sIGFsbG9jYXRlIGEgc3RyaW5nLCBbb3V0XSwgdG8gaG9sZCB0aGUgcmVzdWx0LiAgW291dF0gaGFzXG4gICBsZW5ndGggW24gLSAxXSwgd2hpY2ggaXMgdGhlIG1heGltdW0gcG9zc2libGUgb3V0cHV0IHNpemUgZ2l2ZW4gdGhhdCB0aGVyZSBpcyBhdCBsZWFzdFxuICAgb25lIGNoYXJhY3RlciBub3Qgc2F0aXNmeWluZyBbZl0uXG5cbiAgIDQuIENvcHkgY2hhcmFjdGVycyBhdCBpbmRpY2VzIDAgLi4uIFtpIC0gMV0gZnJvbSBbdF0gdG8gW291dF0uXG5cbiAgIDUuIFdhbGsgdGhyb3VnaCBjaGFyYWN0ZXJzIGF0IGluZGljZXMgW2krMV0gLi4uIFtuLTFdIG9mIFt0XSwgY29weWluZyB0aG9zZSB0aGF0XG4gICBzYXRpc2Z5IFtmXSBmcm9tIFt0XSB0byBbb3V0XS5cblxuICAgNi4gSWYgd2UgY29tcGxldGVseSBmaWxsZWQgW291dF0sIHRoZW4gcmV0dXJuIGl0LiAgSWYgbm90LCByZXR1cm4gdGhlIHByZWZpeCBvZiBbb3V0XVxuICAgdGhhdCB3ZSBkaWQgZmlsbCBpbi5cblxuICAgVGhpcyBhbGdvcml0aG0gaGFzIHRoZSBwcm9wZXJ0eSB0aGF0IGl0IGRvZXNuJ3QgYWxsb2NhdGUgYSBuZXcgc3RyaW5nIGlmIHRoZXJlJ3NcbiAgIG5vdGhpbmcgdG8gZmlsdGVyLCB3aGljaCBpcyBhIGNvbW1vbiBjYXNlLiAqKVxubGV0IGZpbHRlciB0IH5mID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbiAmJiBmIHQuWyFpXSBkb1xuICAgIGluY3IgaVxuICBkb25lO1xuICBpZiAhaSA9IG5cbiAgdGhlbiB0XG4gIGVsc2UgKFxuICAgIGxldCBvdXQgPSBCeXRlcy5jcmVhdGUgKG4gLSAxKSBpblxuICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6dCB+c3JjX3BvczowIH5kc3Q6b3V0IH5kc3RfcG9zOjAgfmxlbjohaTtcbiAgICBsZXQgb3V0X3BvcyA9IHJlZiAhaSBpblxuICAgIGluY3IgaTtcbiAgICB3aGlsZSAhaSA8IG4gZG9cbiAgICAgIGxldCBjID0gdC5bIWldIGluXG4gICAgICBpZiBmIGNcbiAgICAgIHRoZW4gKFxuICAgICAgICBCeXRlcy5zZXQgb3V0ICFvdXRfcG9zIGM7XG4gICAgICAgIGluY3Igb3V0X3Bvcyk7XG4gICAgICBpbmNyIGlcbiAgICBkb25lO1xuICAgIGxldCBvdXQgPSBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOm91dCBpblxuICAgIGlmICFvdXRfcG9zID0gbiAtIDEgdGhlbiBvdXQgZWxzZSBzdWIgb3V0IH5wb3M6MCB+bGVuOiFvdXRfcG9zKVxuOztcblxuKCogcmVwZWF0ZWQgY29kZSB0byBhdm9pZCByZXF1aXJpbmcgYW4gZXh0cmEgYWxsb2NhdGlvbiBmb3IgYSBjbG9zdXJlIG9uIGVhY2ggY2FsbC4gKilcbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBuICYmIGYgIWkgdC5bIWldIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gIGlmICFpID0gblxuICB0aGVuIHRcbiAgZWxzZSAoXG4gICAgbGV0IG91dCA9IEJ5dGVzLmNyZWF0ZSAobiAtIDEpIGluXG4gICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzp0IH5zcmNfcG9zOjAgfmRzdDpvdXQgfmRzdF9wb3M6MCB+bGVuOiFpO1xuICAgIGxldCBvdXRfcG9zID0gcmVmICFpIGluXG4gICAgaW5jciBpO1xuICAgIHdoaWxlICFpIDwgbiBkb1xuICAgICAgbGV0IGMgPSB0LlshaV0gaW5cbiAgICAgIGlmIGYgIWkgY1xuICAgICAgdGhlbiAoXG4gICAgICAgIEJ5dGVzLnNldCBvdXQgIW91dF9wb3MgYztcbiAgICAgICAgaW5jciBvdXRfcG9zKTtcbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgbGV0IG91dCA9IEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6b3V0IGluXG4gICAgaWYgIW91dF9wb3MgPSBuIC0gMSB0aGVuIG91dCBlbHNlIHN1YiBvdXQgfnBvczowIH5sZW46IW91dF9wb3MpXG47O1xuXG5sZXQgY2hvcF9wcmVmaXggcyB+cHJlZml4ID1cbiAgaWYgaXNfcHJlZml4IHMgfnByZWZpeCB0aGVuIFNvbWUgKGRyb3BfcHJlZml4IHMgKGxlbmd0aCBwcmVmaXgpKSBlbHNlIE5vbmVcbjs7XG5cbmxldCBjaG9wX3ByZWZpeF9pZl9leGlzdHMgcyB+cHJlZml4ID1cbiAgaWYgaXNfcHJlZml4IHMgfnByZWZpeCB0aGVuIGRyb3BfcHJlZml4IHMgKGxlbmd0aCBwcmVmaXgpIGVsc2Ugc1xuOztcblxubGV0IGNob3BfcHJlZml4X2V4biBzIH5wcmVmaXggPVxuICBtYXRjaCBjaG9wX3ByZWZpeCBzIH5wcmVmaXggd2l0aFxuICB8IFNvbWUgc3RyIC0+IHN0clxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmdmIFwiU3RyaW5nLmNob3BfcHJlZml4X2V4biAlUyAlU1wiIHMgcHJlZml4ICgpXG47O1xuXG5sZXQgY2hvcF9zdWZmaXggcyB+c3VmZml4ID1cbiAgaWYgaXNfc3VmZml4IHMgfnN1ZmZpeCB0aGVuIFNvbWUgKGRyb3Bfc3VmZml4IHMgKGxlbmd0aCBzdWZmaXgpKSBlbHNlIE5vbmVcbjs7XG5cbmxldCBjaG9wX3N1ZmZpeF9pZl9leGlzdHMgcyB+c3VmZml4ID1cbiAgaWYgaXNfc3VmZml4IHMgfnN1ZmZpeCB0aGVuIGRyb3Bfc3VmZml4IHMgKGxlbmd0aCBzdWZmaXgpIGVsc2Ugc1xuOztcblxubGV0IGNob3Bfc3VmZml4X2V4biBzIH5zdWZmaXggPVxuICBtYXRjaCBjaG9wX3N1ZmZpeCBzIH5zdWZmaXggd2l0aFxuICB8IFNvbWUgc3RyIC0+IHN0clxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmdmIFwiU3RyaW5nLmNob3Bfc3VmZml4X2V4biAlUyAlU1wiIHMgc3VmZml4ICgpXG47O1xuXG5tb2R1bGUgRm9yX2NvbW1vbl9wcmVmaXhfYW5kX3N1ZmZpeCA9IHN0cnVjdFxuICAoKiBXaGVuIHRha2luZyBhIHN0cmluZyBwcmVmaXggb3Igc3VmZml4LCB3ZSBleHRyYWN0IGZyb20gdGhlIHNob3J0ZXN0IGlucHV0IGF2YWlsYWJsZVxuICAgICBpbiBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiBvbmUgb2Ygb3VyIGlucHV0cyB3aXRob3V0IGFsbG9jYXRpbmcgYSBuZXcgc3RyaW5nLiAqKVxuXG4gIGxldCBzaG9ydGVyIGEgYiA9IGlmIGxlbmd0aCBhIDw9IGxlbmd0aCBiIHRoZW4gYSBlbHNlIGJcblxuICBsZXQgc2hvcnRlc3QgbGlzdCA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBcIlwiXG4gICAgfCBmaXJzdCA6OiByZXN0IC0+IExpc3QuZm9sZCByZXN0IH5pbml0OmZpcnN0IH5mOnNob3J0ZXJcbiAgOztcblxuICAoKiBPdXIgZ2VuZXJpYyBhY2Nlc3NvcnMgZm9yIGNvbW1vbiBwcmVmaXgvc3VmZml4IGFic3RyYWN0IG92ZXIgW2dldF9wb3NdLCB3aGljaCBpc1xuICAgICBlaXRoZXIgW3Bvc19mcm9tX2xlZnRdIG9yIFtwb3NfZnJvbV9yaWdodF0uICopXG5cbiAgbGV0IHBvc19mcm9tX2xlZnQgKF8gOiB0KSAoaSA6IGludCkgPSBpXG4gIGxldCBwb3NfZnJvbV9yaWdodCB0IGkgPSBsZW5ndGggdCAtIGkgLSAxXG5cbiAgbGV0IHJlYyBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AgYSBiIH5nZXRfcG9zIH5tYXhfbGVuIH5sZW5fc29fZmFyID1cbiAgICBpZiBsZW5fc29fZmFyID49IG1heF9sZW5cbiAgICB0aGVuIG1heF9sZW5cbiAgICBlbHNlIGlmIENoYXIuZXF1YWxcbiAgICAgICAgICAgICAgKHVuc2FmZV9nZXQgYSAoZ2V0X3BvcyBhIGxlbl9zb19mYXIpKVxuICAgICAgICAgICAgICAodW5zYWZlX2dldCBiIChnZXRfcG9zIGIgbGVuX3NvX2ZhcikpXG4gICAgdGhlbiBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AgYSBiIH5nZXRfcG9zIH5tYXhfbGVuIH5sZW5fc29fZmFyOihsZW5fc29fZmFyICsgMSlcbiAgICBlbHNlIGxlbl9zb19mYXJcbiAgOztcblxuICBsZXQgY29tbW9uX2dlbmVyaWMyX2xlbmd0aCBhIGIgfmdldF9wb3MgPVxuICAgIGxldCBtYXhfbGVuID0gbWluIChsZW5ndGggYSkgKGxlbmd0aCBiKSBpblxuICAgIGNvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcCBhIGIgfmdldF9wb3Mgfm1heF9sZW4gfmxlbl9zb19mYXI6MFxuICA7O1xuXG4gIGxldCByZWMgY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AgZmlyc3QgbGlzdCB+Z2V0X3BvcyB+bWF4X2xlbiA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiBtYXhfbGVuXG4gICAgfCBzZWNvbmQgOjogcmVzdCAtPlxuICAgICAgbGV0IG1heF9sZW4gPVxuICAgICAgICAoKiBXZSBjYWxsIFtjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3BdIHJhdGhlciB0aGFuIFtjb21tb25fZ2VuZXJpYzJfbGVuZ3RoXSBzb1xuICAgICAgICAgICB0aGF0IFttYXhfbGVuXSBsaW1pdHMgb3VyIHRyYXZlcnNhbCBvZiBbZmlyc3RdIGFuZCBbc2Vjb25kXS4gKilcbiAgICAgICAgY29tbW9uX2dlbmVyaWMyX2xlbmd0aF9sb29wIGZpcnN0IHNlY29uZCB+Z2V0X3BvcyB+bWF4X2xlbiB+bGVuX3NvX2ZhcjowXG4gICAgICBpblxuICAgICAgY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3Agc2Vjb25kIHJlc3QgfmdldF9wb3Mgfm1heF9sZW5cbiAgOztcblxuICBsZXQgY29tbW9uX2dlbmVyaWNfbGVuZ3RoIGxpc3QgfmdldF9wb3MgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gMFxuICAgIHwgZmlyc3QgOjogcmVzdCAtPlxuICAgICAgKCogUHJlY29tcHV0aW5nIFttYXhfbGVuXSBiYXNlZCBvbiBbc2hvcnRlc3QgbGlzdF0gc2F2ZXMgdXMgd29yayBpbiBsb25nZXIgc3RyaW5ncyxcbiAgICAgICAgIGF0IHRoZSBjb3N0IG9mIGFuIGV4dHJhIHBhc3Mgb3ZlciB0aGUgc3BpbmUgb2YgW2xpc3RdLlxuXG4gICAgICAgICBGb3IgZXhhbXBsZSwgaWYgeW91J3JlIGxvb2tpbmcgZm9yIHRoZSBsb25nZXN0IHByZWZpeCBvZiB0aGUgc3RyaW5nczpcblxuICAgICAgICAge3ZcbiAgICAgICAgICAgIGxldCBsb25nX2EgPSBMaXN0LmluaXQgMTAwMCB+ZjooRm4uY29uc3QgJ2EnKVxuICAgICAgICAgICAgWyBsb25nX2E7IGxvbmdfYTsgJ2FhJyBdXG4gICAgICAgICB2fVxuXG4gICAgICAgICB0aGUgYXBwcm9hY2ggYmVsb3cgd2lsbCBqdXN0IGNoZWNrIHRoZSBmaXJzdCB0d28gY2hhcmFjdGVycyBvZiBhbGwgdGhlIHN0cmluZ3MuXG4gICAgICAqKVxuICAgICAgbGV0IG1heF9sZW4gPSBsZW5ndGggKHNob3J0ZXN0IGxpc3QpIGluXG4gICAgICBjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcCBmaXJzdCByZXN0IH5nZXRfcG9zIH5tYXhfbGVuXG4gIDs7XG5cbiAgKCogT3VyIGdlbmVyaWMgYWNjZXNzb3JzIHRoYXQgcHJvZHVjZSBhIHN0cmluZyBhYnN0cmFjdCBvdmVyIFt0YWtlXSwgd2hpY2ggaXMgZWl0aGVyXG4gICAgIFtwcmVmaXhdIG9yIFtzdWZmaXhdLiAqKVxuXG4gIGxldCBjb21tb25fZ2VuZXJpYzIgYSBiIH5nZXRfcG9zIH50YWtlID1cbiAgICBsZXQgbGVuID0gY29tbW9uX2dlbmVyaWMyX2xlbmd0aCBhIGIgfmdldF9wb3MgaW5cbiAgICAoKiBVc2UgdGhlIHNob3J0ZXIgb2YgdGhlIHR3byBzdHJpbmdzLCBzbyB0aGF0IGlmIHRoZSBzaG9ydGVyIG9uZSBpcyB0aGUgc2hhcmVkXG4gICAgICAgcHJlZml4LCBbdGFrZV0gd29uJ3QgYWxsb2NhdGUgYW5vdGhlciBzdHJpbmcuICopXG4gICAgdGFrZSAoc2hvcnRlciBhIGIpIGxlblxuICA7O1xuXG4gIGxldCBjb21tb25fZ2VuZXJpYyBsaXN0IH5nZXRfcG9zIH50YWtlID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IFwiXCJcbiAgICB8IGZpcnN0IDo6IHJlc3QgLT5cbiAgICAgICgqIEFzIHdpdGggW2NvbW1vbl9nZW5lcmljX2xlbmd0aF0sIHdlIGJhc2UgW21heF9sZW5dIG9uIFtzaG9ydGVzdCBsaXN0XS4gV2UgYWxzb1xuICAgICAgICAgdXNlIHRoaXMgcmVzdWx0IGZvciBbdGFrZV0sIGJlbG93LCB0byBwb3RlbnRpYWxseSBhdm9pZCBhbGxvY2F0aW5nIGEgc3RyaW5nLiAqKVxuICAgICAgbGV0IHMgPSBzaG9ydGVzdCBsaXN0IGluXG4gICAgICBsZXQgbWF4X2xlbiA9IGxlbmd0aCBzIGluXG4gICAgICBpZiBtYXhfbGVuID0gMFxuICAgICAgdGhlbiBcIlwiXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGxlbiA9XG4gICAgICAgICAgKCogV2UgY2FsbCBkaXJlY3RseSBpbnRvIFtjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcF0gcmF0aGVyIHRoYW5cbiAgICAgICAgICAgICBbY29tbW9uX2dlbmVyaWNfbGVuZ3RoXSB0byBhdm9pZCByZWNvbXB1dGluZyBbc2hvcnRlc3QgbGlzdF0uICopXG4gICAgICAgICAgY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AgZmlyc3QgcmVzdCB+Z2V0X3BvcyB+bWF4X2xlblxuICAgICAgICBpblxuICAgICAgICB0YWtlIHMgbGVuKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgc3RydWN0XG4gIG9wZW4gRm9yX2NvbW1vbl9wcmVmaXhfYW5kX3N1ZmZpeFxuXG4gIGxldCBjb21tb25fcHJlZml4IGxpc3QgPSBjb21tb25fZ2VuZXJpYyBsaXN0IH50YWtlOnByZWZpeCB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4IGxpc3QgPSBjb21tb25fZ2VuZXJpYyBsaXN0IH50YWtlOnN1ZmZpeCB+Z2V0X3Bvczpwb3NfZnJvbV9yaWdodFxuICBsZXQgY29tbW9uX3ByZWZpeDIgYSBiID0gY29tbW9uX2dlbmVyaWMyIGEgYiB+dGFrZTpwcmVmaXggfmdldF9wb3M6cG9zX2Zyb21fbGVmdFxuICBsZXQgY29tbW9uX3N1ZmZpeDIgYSBiID0gY29tbW9uX2dlbmVyaWMyIGEgYiB+dGFrZTpzdWZmaXggfmdldF9wb3M6cG9zX2Zyb21fcmlnaHRcbiAgbGV0IGNvbW1vbl9wcmVmaXhfbGVuZ3RoIGxpc3QgPSBjb21tb25fZ2VuZXJpY19sZW5ndGggbGlzdCB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4X2xlbmd0aCBsaXN0ID0gY29tbW9uX2dlbmVyaWNfbGVuZ3RoIGxpc3QgfmdldF9wb3M6cG9zX2Zyb21fcmlnaHRcbiAgbGV0IGNvbW1vbl9wcmVmaXgyX2xlbmd0aCBhIGIgPSBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIGEgYiB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4Ml9sZW5ndGggYSBiID0gY29tbW9uX2dlbmVyaWMyX2xlbmd0aCBhIGIgfmdldF9wb3M6cG9zX2Zyb21fcmlnaHRcbmVuZFxuXG4oKiBUaGVyZSB1c2VkIHRvIGJlIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uIHRoYXQgd2FzIGZhc3RlciBmb3IgdmVyeSBzaG9ydCBzdHJpbmdzXG4gICAocGVha2luZyBhdCA0MCUgZmFzdGVyIGZvciA0LTYgY2hhciBsb25nIHN0cmluZ3MpLlxuICAgVGhpcyBuZXcgZnVuY3Rpb24gaXMgYXJvdW5kIDIwJSBmYXN0ZXIgdGhhbiB0aGUgZGVmYXVsdCBoYXNoIGZ1bmN0aW9uLCBidXQgc2xvd2VyXG4gICB0aGFuIHRoZSBwcmV2aW91cyBjdXN0b20gaW1wbGVtZW50YXRpb24uIEhvd2V2ZXIsIHRoZSBuZXcgT0NhbWwgZnVuY3Rpb24gaXMgd2VsbFxuICAgYmVoYXZlZCwgYW5kIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbGVzcyBsaWtlbHkgdG8gZGl2ZXJnZSBmcm9tIHRoZSBkZWZhdWx0IE9DYW1sXG4gICBpbXBsZW1lbnRhdGlvbiBkb2VzLCB3aGljaCBpcyBhIGRlc2lyYWJsZSBwcm9wZXJ0eS4gKFRoZSBvbmx5IHdheSB0byBhdm9pZCB0aGVcbiAgIGRpdmVyZ2VuY2UgaXMgdG8gZXhwb3NlIHRoZSBtYWNybyByZWRlZmluZWQgaW4gaGFzaF9zdHVicy5jIGluIHRoZSBoYXNoLmggaGVhZGVyIG9mXG4gICB0aGUgT0NhbWwgY29tcGlsZXIuKSAqKVxubW9kdWxlIEhhc2ggPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgaGFzaCA6IHN0cmluZyAtPiBpbnQgPSBcIkJhc2VfaGFzaF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZW5kXG5cbigqIFtpbmNsdWRlIEhhc2hdIHRvIG1ha2UgdGhlIFtleHRlcm5hbF0gdmVyc2lvbiBvdmVycmlkZSB0aGUgW2hhc2hdIGZyb21cbiAgIFtIYXNoYWJsZS5NYWtlX2JpbmFibGVdLCBzbyB0aGF0IHdlIGdldCBhIGxpdHRsZSBiaXQgb2YgYSBzcGVlZHVwIGJ5IGV4cG9zaW5nIGl0IGFzXG4gICBleHRlcm5hbCBpbiB0aGUgbWxpLiAqKVxubGV0IF8gPSBoYXNoXG5cbmluY2x1ZGUgSGFzaFxuXG4oKiBmb3IgaW50ZXJhY3RpdmUgdG9wLWxldmVscyAtLSBtb2R1bGVzIGRlcml2aW5nIGZyb20gU3RyaW5nIHNob3VsZCBoYXZlIFN0cmluZydzIHByZXR0eVxuICAgcHJpbnRlci4gKilcbmxldCBwcCBwcGYgc3RyaW5nID0gQ2FtbC5Gb3JtYXQuZnByaW50ZiBwcGYgXCIlU1wiIHN0cmluZ1xubGV0IG9mX2NoYXIgYyA9IG1ha2UgMSBjXG5cbmxldCBvZl9jaGFyX2xpc3QgbCA9XG4gIGxldCB0ID0gQnl0ZXMuY3JlYXRlIChMaXN0Lmxlbmd0aCBsKSBpblxuICBMaXN0Lml0ZXJpIGwgfmY6KGZ1biBpIGMgLT4gQnl0ZXMuc2V0IHQgaSBjKTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp0XG47O1xuXG5tb2R1bGUgRXNjYXBpbmcgPSBzdHJ1Y3RcbiAgKCogSWYgdGhpcyBpcyBjaGFuZ2VkLCBtYWtlIHN1cmUgdG8gdXBkYXRlIFtlc2NhcGVdLCB3aGljaCBhdHRlbXB0cyB0byBlbnN1cmUgYWxsIHRoZVxuICAgICBpbnZhcmlhbnRzIGNoZWNrZWQgaGVyZS4gICopXG4gIGxldCBidWlsZF9hbmRfdmFsaWRhdGVfZXNjYXBld29ydGh5X21hcCBlc2NhcGV3b3J0aHlfbWFwIGVzY2FwZV9jaGFyIGZ1bmMgPVxuICAgIGxldCBlc2NhcGV3b3J0aHlfbWFwID1cbiAgICAgIGlmIExpc3QuQXNzb2MubWVtIGVzY2FwZXdvcnRoeV9tYXAgfmVxdWFsOkNoYXIuZXF1YWwgZXNjYXBlX2NoYXJcbiAgICAgIHRoZW4gZXNjYXBld29ydGh5X21hcFxuICAgICAgZWxzZSAoZXNjYXBlX2NoYXIsIGVzY2FwZV9jaGFyKSA6OiBlc2NhcGV3b3J0aHlfbWFwXG4gICAgaW5cbiAgICBsZXQgYXJyID0gQXJyYXkuY3JlYXRlIH5sZW46MjU2ICgtMSkgaW5cbiAgICBsZXQgdmFscyA9IEFycmF5LmNyZWF0ZSB+bGVuOjI1NiBmYWxzZSBpblxuICAgIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IE9rIGFyclxuICAgICAgfCAoY19mcm9tLCBjX3RvKSA6OiBsIC0+XG4gICAgICAgIGxldCBrLCB2ID1cbiAgICAgICAgICBtYXRjaCBmdW5jIHdpdGhcbiAgICAgICAgICB8IGBFc2NhcGUgLT4gQ2hhci50b19pbnQgY19mcm9tLCBjX3RvXG4gICAgICAgICAgfCBgVW5lc2NhcGUgLT4gQ2hhci50b19pbnQgY190bywgY19mcm9tXG4gICAgICAgIGluXG4gICAgICAgIGlmIGFyci4oaykgPD4gLTEgfHwgdmFscy4oQ2hhci50b19pbnQgdilcbiAgICAgICAgdGhlblxuICAgICAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgICAgIFwiZXNjYXBld29ydGh5X21hcCBub3Qgb25lLXRvLW9uZVwiXG4gICAgICAgICAgICAgICBbIFwiY19mcm9tXCIsIHNleHBfb2ZfY2hhciBjX2Zyb21cbiAgICAgICAgICAgICAgIDsgXCJjX3RvXCIsIHNleHBfb2ZfY2hhciBjX3RvXG4gICAgICAgICAgICAgICA7ICggXCJlc2NhcGV3b3J0aHlfbWFwXCJcbiAgICAgICAgICAgICAgICAgLCBzZXhwX29mX2xpc3QgKHNleHBfb2ZfcGFpciBzZXhwX29mX2NoYXIgc2V4cF9vZl9jaGFyKSBlc2NhcGV3b3J0aHlfbWFwXG4gICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgIF0pXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGFyci4oaykgPC0gQ2hhci50b19pbnQgdjtcbiAgICAgICAgICB2YWxzLihDaGFyLnRvX2ludCB2KSA8LSB0cnVlO1xuICAgICAgICAgIGxvb3AgbClcbiAgICBpblxuICAgIGxvb3AgZXNjYXBld29ydGh5X21hcFxuICA7O1xuXG4gIGxldCBlc2NhcGVfZ2VuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhciA9XG4gICAgbWF0Y2ggYnVpbGRfYW5kX3ZhbGlkYXRlX2VzY2FwZXdvcnRoeV9tYXAgZXNjYXBld29ydGh5X21hcCBlc2NhcGVfY2hhciBgRXNjYXBlIHdpdGhcbiAgICB8IEVycm9yIF8gYXMgeCAtPiB4XG4gICAgfCBPayBlc2NhcGV3b3J0aHkgLT5cbiAgICAgIE9rXG4gICAgICAgIChmdW4gc3JjIC0+XG4gICAgICAgICAgICgqIGNhbGN1bGF0ZSBhIGxpc3Qgb2YgKGluZGV4IG9mIGNoYXIgdG8gZXNjYXBlICogZXNjYXBlZCBjaGFyKSBmaXJzdCwgdGhlIG9yZGVyXG4gICAgICAgICAgICAgIGlzIGZyb20gdGFpbCB0byBoZWFkICopXG4gICAgICAgICAgIGxldCB0b19lc2NhcGVfbGVuID0gcmVmIDAgaW5cbiAgICAgICAgICAgbGV0IHRvX2VzY2FwZSA9XG4gICAgICAgICAgICAgZm9sZGkgc3JjIH5pbml0OltdIH5mOihmdW4gaSBhY2MgYyAtPlxuICAgICAgICAgICAgICAgbWF0Y2ggZXNjYXBld29ydGh5LihDaGFyLnRvX2ludCBjKSB3aXRoXG4gICAgICAgICAgICAgICB8IC0xIC0+IGFjY1xuICAgICAgICAgICAgICAgfCBuIC0+XG4gICAgICAgICAgICAgICAgICgqIChpbmRleCBvZiBjaGFyIHRvIGVzY2FwZSAqIGVzY2FwZWQgY2hhcikgKilcbiAgICAgICAgICAgICAgICAgaW5jciB0b19lc2NhcGVfbGVuO1xuICAgICAgICAgICAgICAgICAoaSwgQ2hhci51bnNhZmVfb2ZfaW50IG4pIDo6IGFjYylcbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgbWF0Y2ggdG9fZXNjYXBlIHdpdGhcbiAgICAgICAgICAgfCBbXSAtPiBzcmNcbiAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgKCogW3RvX2VzY2FwZV0gZGl2aWRlIFtzcmNdIHRvIFtMaXN0Lmxlbmd0aCB0b19lc2NhcGUgKyAxXSBwaWVjZXMgc2VwYXJhdGVkIGJ5XG4gICAgICAgICAgICAgICAgdGhlIGNoYXJzIHRvIGVzY2FwZS5cblxuICAgICAgICAgICAgICAgIExldHMgdGFrZVxuICAgICAgICAgICAgICAgIHtbXG4gICAgICAgICAgICAgICAgICBlc2NhcGVfZ2VuX2V4blxuICAgICAgICAgICAgICAgICAgICB+ZXNjYXBld29ydGh5X21hcDpbKCdhJywgJ0EnKTsgKCdiJywgJ0InKTsgKCdjJywgJ0MnKV1cbiAgICAgICAgICAgICAgICAgICAgfmVzY2FwZV9jaGFyOidfJ1xuICAgICAgICAgICAgICAgIF19XG4gICAgICAgICAgICAgICAgZm9yIGV4YW1wbGUsIGFuZCBhc3N1bWUgdGhlIHN0cmluZyB0byBlc2NhcGUgaXNcblxuICAgICAgICAgICAgICAgIFwiMDAwYTExMWIyMjJjMzMzXCJcblxuICAgICAgICAgICAgICAgIHRoZW4gW3RvX2VzY2FwZV0gaXMgWygxMSwgJ0MnKTsgKDcsICdCJyk7ICgzLCAnQScpXS5cblxuICAgICAgICAgICAgICAgIFRoZW4gd2UgY3JlYXRlIGEgW2RzdF0gb2YgbGVuZ3RoIFtsZW5ndGggc3JjICsgM10gdG8gc3RvcmUgdGhlXG4gICAgICAgICAgICAgICAgcmVzdWx0LCBjb3B5IHBpZWNlIFwiMzMzXCIgdG8gW2RzdF0gZGlyZWN0bHksIHRoZW4gY29weSAnXycgYW5kICdDJyB0byBbZHN0XTtcbiAgICAgICAgICAgICAgICB0aGVuIG1vdmUgb24gdG8gbmV4dDsgYWZ0ZXIgMyBpdGVyYXRpb25zLCBjb3B5IHBpZWNlIFwiMDAwXCIgYW5kIHdlIGFyZSBkb25lLlxuXG4gICAgICAgICAgICAgICAgRmluYWxseSB0aGUgcmVzdWx0IHdpbGwgYmVcblxuICAgICAgICAgICAgICAgIFwiMDAwX0ExMTFfQjIyMl9DMzMzXCIgKilcbiAgICAgICAgICAgICBsZXQgc3JjX2xlbiA9IGxlbmd0aCBzcmMgaW5cbiAgICAgICAgICAgICBsZXQgZHN0X2xlbiA9IHNyY19sZW4gKyAhdG9fZXNjYXBlX2xlbiBpblxuICAgICAgICAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgZHN0X2xlbiBpblxuICAgICAgICAgICAgIGxldCByZWMgbG9vcCBsYXN0X2lkeCBsYXN0X2RzdF9wb3MgPSBmdW5jdGlvblxuICAgICAgICAgICAgICAgfCBbXSAtPlxuICAgICAgICAgICAgICAgICAoKiBjb3B5IFwiMDAwXCIgYXQgbGFzdCAqKVxuICAgICAgICAgICAgICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zOjAgfmRzdCB+ZHN0X3BvczowIH5sZW46bGFzdF9pZHhcbiAgICAgICAgICAgICAgIHwgKGlkeCwgZXNjYXBlZF9jaGFyKSA6OiB0b19lc2NhcGUgLT5cbiAgICAgICAgICAgICAgICAgKCpbaWR4XSA9IHRoZSBjaGFyIHRvIGVzY2FwZSopXG4gICAgICAgICAgICAgICAgICgqIHRha2UgZmlyc3QgaXRlcmF0aW9uIGZvciBleGFtcGxlICopXG4gICAgICAgICAgICAgICAgICgqIGNhbGN1bGF0ZSBsZW5ndGggb2YgXCIzMzNcIiwgbWludXMgMSBiZWNhdXNlIHdlIGRvbid0IGNvcHkgJ2MnICopXG4gICAgICAgICAgICAgICAgIGxldCBsZW4gPSBsYXN0X2lkeCAtIGlkeCAtIDEgaW5cbiAgICAgICAgICAgICAgICAgKCogc2V0IHRoZSBkc3RfcG9zIHRvIGNvcHkgdG8gKilcbiAgICAgICAgICAgICAgICAgbGV0IGRzdF9wb3MgPSBsYXN0X2RzdF9wb3MgLSBsZW4gaW5cbiAgICAgICAgICAgICAgICAgKCogY29weSBcIjMzM1wiLCBzZXQgW3NyY19wb3NdIHRvIFtpZHggKyAxXSB0byBza2lwICdjJyAqKVxuICAgICAgICAgICAgICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zOihpZHggKyAxKSB+ZHN0IH5kc3RfcG9zIH5sZW47XG4gICAgICAgICAgICAgICAgICgqIGJhY2tvZmYgW2RzdF9wb3NdIGJ5IDIgdG8gY29weSAnXycgYW5kICdDJyAqKVxuICAgICAgICAgICAgICAgICBsZXQgZHN0X3BvcyA9IGRzdF9wb3MgLSAyIGluXG4gICAgICAgICAgICAgICAgIEJ5dGVzLnNldCBkc3QgZHN0X3BvcyBlc2NhcGVfY2hhcjtcbiAgICAgICAgICAgICAgICAgQnl0ZXMuc2V0IGRzdCAoZHN0X3BvcyArIDEpIGVzY2FwZWRfY2hhcjtcbiAgICAgICAgICAgICAgICAgbG9vcCBpZHggZHN0X3BvcyB0b19lc2NhcGVcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICgqIHNldCBbbGFzdF9kc3RfcG9zXSBhbmQgW2xhc3RfaWR4XSB0byBsZW5ndGggb2YgW2RzdF0gYW5kIFtzcmNdIGZpcnN0ICopXG4gICAgICAgICAgICAgbG9vcCBzcmNfbGVuIGRzdF9sZW4gdG9fZXNjYXBlO1xuICAgICAgICAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6ZHN0KVxuICA7O1xuXG4gIGxldCBlc2NhcGVfZ2VuX2V4biB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXIgPVxuICAgIE9yX2Vycm9yLm9rX2V4biAoZXNjYXBlX2dlbiB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXIpIHw+IHN0YWdlXG4gIDs7XG5cbiAgbGV0IGVzY2FwZSB+ZXNjYXBld29ydGh5IH5lc2NhcGVfY2hhciA9XG4gICAgKCogRm9yIFtlc2NhcGVfZ2VuX2V4bl0sIHdlIGRvbid0IGtub3cgaG93IHRvIGZpeCBpbnZhbGlkIGVzY2FwZXdvcnRoeV9tYXAgc28gd2UgaGF2ZVxuICAgICAgIHRvIHJhaXNlIGV4Y2VwdGlvbjsgYnV0IGluIHRoaXMgY2FzZSwgd2Uga25vdyBob3cgdG8gZml4IGR1cGxpY2F0ZWQgZWxlbWVudHMgaW5cbiAgICAgICBlc2NhcGV3b3J0aHkgbGlzdCwgc28gd2UganVzdCBmaXggaXQgaW5zdGVhZCBvZiByYWlzaW5nIGV4Y2VwdGlvbiB0byBtYWtlIHRoaXNcbiAgICAgICBmdW5jdGlvbiBlYXNpZXIgdG8gdXNlLiAgKilcbiAgICBsZXQgZXNjYXBld29ydGh5X21hcCA9XG4gICAgICBlc2NhcGV3b3J0aHlcbiAgICAgIHw+IExpc3QuZGVkdXBfYW5kX3NvcnQgfmNvbXBhcmU6Q2hhci5jb21wYXJlXG4gICAgICB8PiBMaXN0Lm1hcCB+ZjooZnVuIGMgLT4gYywgYylcbiAgICBpblxuICAgIGVzY2FwZV9nZW5fZXhuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhclxuICA7O1xuXG4gICgqIEluIGFuIGVzY2FwZWQgc3RyaW5nLCBhbnkgY2hhciBpcyBlaXRoZXIgYEVzY2FwaW5nLCBgRXNjYXBlZCBvciBgTGl0ZXJhbC4gRm9yXG4gICAgIGV4YW1wbGUsIHRoZSBlc2NhcGUgc3RhdHVzZXMgb2YgY2hhcnMgaW4gc3RyaW5nIFwiYV9hX19cIiB3aXRoIGVzY2FwZV9jaGFyID0gJ18nIGFyZVxuXG4gICAgIGEgOiBgTGl0ZXJhbFxuICAgICBfIDogYEVzY2FwaW5nXG4gICAgIGEgOiBgRXNjYXBlZFxuICAgICBfIDogYEVzY2FwaW5nXG4gICAgIF8gOiBgRXNjYXBlZFxuXG4gICAgIFt1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIGkgcHJldmlvdXNfc3RhdHVzXSBnZXRzIGVzY2FwZSBzdGF0dXMgb2ZcbiAgICAgc3RyLltpXSBiYXNpbmcgb24gZXNjYXBlIHN0YXR1cyBvZiBzdHIuW2kgLSAxXSAqKVxuICBsZXQgdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBpID0gZnVuY3Rpb25cbiAgICB8IGBFc2NhcGluZyAtPiBgRXNjYXBlZFxuICAgIHwgYExpdGVyYWwgfCBgRXNjYXBlZCAtPlxuICAgICAgaWYgQ2hhci5lcXVhbCBzdHIuW2ldIGVzY2FwZV9jaGFyIHRoZW4gYEVzY2FwaW5nIGVsc2UgYExpdGVyYWxcbiAgOztcblxuICBsZXQgdW5lc2NhcGVfZ2VuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhciA9XG4gICAgbWF0Y2ggYnVpbGRfYW5kX3ZhbGlkYXRlX2VzY2FwZXdvcnRoeV9tYXAgZXNjYXBld29ydGh5X21hcCBlc2NhcGVfY2hhciBgVW5lc2NhcGUgd2l0aFxuICAgIHwgRXJyb3IgXyBhcyB4IC0+IHhcbiAgICB8IE9rIGVzY2FwZXdvcnRoeSAtPlxuICAgICAgT2tcbiAgICAgICAgKGZ1biBzcmMgLT5cbiAgICAgICAgICAgKCogQ29udGludWUgdGhlIGV4YW1wbGUgaW4gW2VzY2FwZV9nZW5fZXhuXSwgbm93IHdlIHVuZXNjYXBlXG5cbiAgICAgICAgICAgICAgXCIwMDBfQTExMV9CMjIyX0MzMzNcIlxuXG4gICAgICAgICAgICAgIGJhY2sgdG9cblxuICAgICAgICAgICAgICBcIjAwMGExMTFiMjIyYzMzM1wiXG5cbiAgICAgICAgICAgICAgVGhlbiBbdG9fdW5lc2NhcGVdIGlzIFsxNDsgOTsgNF0sIHdoaWNoIGlzIGluZGV4ZXMgb2YgJ18ncy5cblxuICAgICAgICAgICAgICBUaGVuIHdlIGNyZWF0ZSBhIHN0cmluZyBbZHN0XSB0byBzdG9yZSB0aGUgcmVzdWx0LCBjb3B5IFwiMzMzXCIgdG8gaXQsIHRoZW4gY29weVxuICAgICAgICAgICAgICAnYycsIHRoZW4gbW92ZSBvbiB0byBuZXh0IGl0ZXJhdGlvbi4gQWZ0ZXIgMyBpdGVyYXRpb25zIGNvcHkgXCIwMDBcIiBhbmQgd2UgYXJlXG4gICAgICAgICAgICAgIGRvbmUuICAqKVxuICAgICAgICAgICAoKiBpbmRleGVzIG9mIGVzY2FwZSBjaGFycyAqKVxuICAgICAgICAgICBsZXQgdG9fdW5lc2NhcGUgPVxuICAgICAgICAgICAgIGxldCByZWMgbG9vcCBpIHN0YXR1cyBhY2MgPVxuICAgICAgICAgICAgICAgaWYgaSA+PSBsZW5ndGggc3JjXG4gICAgICAgICAgICAgICB0aGVuIGFjY1xuICAgICAgICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICAgICAgIGxldCBzdGF0dXMgPSB1cGRhdGVfZXNjYXBlX3N0YXR1cyBzcmMgfmVzY2FwZV9jaGFyIGkgc3RhdHVzIGluXG4gICAgICAgICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgICAgICAgICAoaSArIDEpXG4gICAgICAgICAgICAgICAgICAgc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgKG1hdGNoIHN0YXR1cyB3aXRoXG4gICAgICAgICAgICAgICAgICAgIHwgYEVzY2FwaW5nIC0+IGkgOjogYWNjXG4gICAgICAgICAgICAgICAgICAgIHwgYEVzY2FwZWQgfCBgTGl0ZXJhbCAtPiBhY2MpKVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgbG9vcCAwIGBMaXRlcmFsIFtdXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIG1hdGNoIHRvX3VuZXNjYXBlIHdpdGhcbiAgICAgICAgICAgfCBbXSAtPiBzcmNcbiAgICAgICAgICAgfCBpZHggOjogdG9fdW5lc2NhcGUnIC0+XG4gICAgICAgICAgICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSAobGVuZ3RoIHNyYyAtIExpc3QubGVuZ3RoIHRvX3VuZXNjYXBlKSBpblxuICAgICAgICAgICAgIGxldCByZWMgbG9vcCBsYXN0X2lkeCBsYXN0X2RzdF9wb3MgPSBmdW5jdGlvblxuICAgICAgICAgICAgICAgfCBbXSAtPlxuICAgICAgICAgICAgICAgICAoKiBjb3B5IFwiMDAwXCIgYXQgbGFzdCAqKVxuICAgICAgICAgICAgICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zOjAgfmRzdCB+ZHN0X3BvczowIH5sZW46bGFzdF9pZHhcbiAgICAgICAgICAgICAgIHwgaWR4IDo6IHRvX3VuZXNjYXBlIC0+XG4gICAgICAgICAgICAgICAgICgqIFtpZHhdID0gaW5kZXggb2YgZXNjYXBpbmcgY2hhciAqKVxuICAgICAgICAgICAgICAgICAoKiB0YWtlIDFzdCBpdGVyYXRpb24gYXMgZXhhbXBsZSwgY2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgXCIzMzNcIiwgbWludXMgMiB0b1xuICAgICAgICAgICAgICAgICAgICBza2lwICdfQycgKilcbiAgICAgICAgICAgICAgICAgbGV0IGxlbiA9IGxhc3RfaWR4IC0gaWR4IC0gMiBpblxuICAgICAgICAgICAgICAgICAoKiBwb2ludCBbZHN0X3Bvc10gdG8gdGhlIHBvc2l0aW9uIHRvIGNvcHkgXCIzMzNcIiB0byAqKVxuICAgICAgICAgICAgICAgICBsZXQgZHN0X3BvcyA9IGxhc3RfZHN0X3BvcyAtIGxlbiBpblxuICAgICAgICAgICAgICAgICAoKiBjb3B5IFwiMzMzXCIgKilcbiAgICAgICAgICAgICAgICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYyB+c3JjX3BvczooaWR4ICsgMikgfmRzdCB+ZHN0X3BvcyB+bGVuO1xuICAgICAgICAgICAgICAgICAoKiBiYWNrb2ZmIFtkc3RfcG9zXSBieSAxIHRvIGNvcHkgJ2MnICopXG4gICAgICAgICAgICAgICAgIGxldCBkc3RfcG9zID0gZHN0X3BvcyAtIDEgaW5cbiAgICAgICAgICAgICAgICAgQnl0ZXMuc2V0XG4gICAgICAgICAgICAgICAgICAgZHN0XG4gICAgICAgICAgICAgICAgICAgZHN0X3Bvc1xuICAgICAgICAgICAgICAgICAgIChtYXRjaCBlc2NhcGV3b3J0aHkuKENoYXIudG9faW50IHNyYy5baWR4ICsgMV0pIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgfCAtMSAtPiBzcmMuW2lkeCArIDFdXG4gICAgICAgICAgICAgICAgICAgIHwgbiAtPiBDaGFyLnVuc2FmZV9vZl9pbnQgbik7XG4gICAgICAgICAgICAgICAgICgqIHVwZGF0ZSBbbGFzdF9kc3RfcG9zXSBhbmQgW2xhc3RfaWR4XSAqKVxuICAgICAgICAgICAgICAgICBsb29wIGlkeCBkc3RfcG9zIHRvX3VuZXNjYXBlXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICBpZiBpZHggPCBsZW5ndGggc3JjIC0gMVxuICAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgICgqIHNldCBbbGFzdF9kc3RfcG9zXSBhbmQgW2xhc3RfaWR4XSB0byBsZW5ndGggb2YgW2RzdF0gYW5kIFtzcmNdICopXG4gICAgICAgICAgICAgICBsb29wIChsZW5ndGggc3JjKSAoQnl0ZXMubGVuZ3RoIGRzdCkgdG9fdW5lc2NhcGVcbiAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAoKiBmb3IgZXNjYXBlZCBzdHJpbmcgZW5kaW5nIHdpdGggYW4gZXNjYXBpbmcgY2hhciBsaWtlIFwiMDAwX1wiLCBqdXN0IGlnbm9yZVxuICAgICAgICAgICAgICAgICAgdGhlIGxhc3QgZXNjYXBpbmcgY2hhciAqKVxuICAgICAgICAgICAgICAgbG9vcCAobGVuZ3RoIHNyYyAtIDEpIChCeXRlcy5sZW5ndGggZHN0KSB0b191bmVzY2FwZSc7XG4gICAgICAgICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpkc3QpXG4gIDs7XG5cbiAgbGV0IHVuZXNjYXBlX2dlbl9leG4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyID1cbiAgICBPcl9lcnJvci5va19leG4gKHVuZXNjYXBlX2dlbiB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXIpIHw+IHN0YWdlXG4gIDs7XG5cbiAgbGV0IHVuZXNjYXBlIH5lc2NhcGVfY2hhciA9IHVuZXNjYXBlX2dlbl9leG4gfmVzY2FwZXdvcnRoeV9tYXA6W10gfmVzY2FwZV9jaGFyXG5cbiAgbGV0IHByZWNlZGluZ19lc2NhcGVfY2hhcnMgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGxldCByZWMgbG9vcCBwIGNudCA9XG4gICAgICBpZiBwIDwgMCB8fCBDaGFyLiggPD4gKSBzdHIuW3BdIGVzY2FwZV9jaGFyIHRoZW4gY250IGVsc2UgbG9vcCAocCAtIDEpIChjbnQgKyAxKVxuICAgIGluXG4gICAgbG9vcCAocG9zIC0gMSkgMFxuICA7O1xuXG4gICgqIEluIGFuIGVzY2FwZWQgc3RyaW5nLCBhbnkgY2hhciBpcyBlaXRoZXIgYEVzY2FwaW5nLCBgRXNjYXBlZCBvciBgTGl0ZXJhbC4gRm9yXG4gICAgIGV4YW1wbGUsIHRoZSBlc2NhcGUgc3RhdHVzZXMgb2YgY2hhcnMgaW4gc3RyaW5nIFwiYV9hX19cIiB3aXRoIGVzY2FwZV9jaGFyID0gJ18nIGFyZVxuXG4gICAgIGEgOiBgTGl0ZXJhbFxuICAgICBfIDogYEVzY2FwaW5nXG4gICAgIGEgOiBgRXNjYXBlZFxuICAgICBfIDogYEVzY2FwaW5nXG4gICAgIF8gOiBgRXNjYXBlZFxuXG4gICAgIFt1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIGkgcHJldmlvdXNfc3RhdHVzXSBnZXRzIGVzY2FwZSBzdGF0dXMgb2ZcbiAgICAgc3RyLltpXSBiYXNpbmcgb24gZXNjYXBlIHN0YXR1cyBvZiBzdHIuW2kgLSAxXSAqKVxuICBsZXQgdXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBpID0gZnVuY3Rpb25cbiAgICB8IGBFc2NhcGluZyAtPiBgRXNjYXBlZFxuICAgIHwgYExpdGVyYWwgfCBgRXNjYXBlZCAtPlxuICAgICAgaWYgQ2hhci5lcXVhbCBzdHIuW2ldIGVzY2FwZV9jaGFyIHRoZW4gYEVzY2FwaW5nIGVsc2UgYExpdGVyYWxcbiAgOztcblxuICBsZXQgZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyA9XG4gICAgbGV0IG9kZCA9IHByZWNlZGluZ19lc2NhcGVfY2hhcnMgc3RyIH5lc2NhcGVfY2hhciBwb3MgbW9kIDIgPSAxIGluXG4gICAgbWF0Y2ggb2RkLCBDaGFyLmVxdWFsIHN0ci5bcG9zXSBlc2NhcGVfY2hhciB3aXRoXG4gICAgfCB0cnVlLCAodHJ1ZSB8IGZhbHNlKSAtPiBgRXNjYXBlZFxuICAgIHwgZmFsc2UsIHRydWUgLT4gYEVzY2FwaW5nXG4gICAgfCBmYWxzZSwgZmFsc2UgLT4gYExpdGVyYWxcbiAgOztcblxuICBsZXQgY2hlY2tfYm91bmQgc3RyIHBvcyBmdW5jdGlvbl9uYW1lID1cbiAgICBpZiBwb3MgPj0gbGVuZ3RoIHN0ciB8fCBwb3MgPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiJXM6IG91dCBvZiBib3VuZHNcIiBmdW5jdGlvbl9uYW1lICgpXG4gIDs7XG5cbiAgbGV0IGlzX2NoYXJfZXNjYXBpbmcgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGNoZWNrX2JvdW5kIHN0ciBwb3MgXCJpc19jaGFyX2VzY2FwaW5nXCI7XG4gICAgbWF0Y2ggZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyB3aXRoXG4gICAgfCBgRXNjYXBpbmcgLT4gdHJ1ZVxuICAgIHwgYEVzY2FwZWQgfCBgTGl0ZXJhbCAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCBpc19jaGFyX2VzY2FwZWQgc3RyIH5lc2NhcGVfY2hhciBwb3MgPVxuICAgIGNoZWNrX2JvdW5kIHN0ciBwb3MgXCJpc19jaGFyX2VzY2FwZWRcIjtcbiAgICBtYXRjaCBlc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIHdpdGhcbiAgICB8IGBFc2NhcGVkIC0+IHRydWVcbiAgICB8IGBFc2NhcGluZyB8IGBMaXRlcmFsIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IGlzX2NoYXJfbGl0ZXJhbCBzdHIgfmVzY2FwZV9jaGFyIHBvcyA9XG4gICAgY2hlY2tfYm91bmQgc3RyIHBvcyBcImlzX2NoYXJfbGl0ZXJhbFwiO1xuICAgIG1hdGNoIGVzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3Mgd2l0aFxuICAgIHwgYExpdGVyYWwgLT4gdHJ1ZVxuICAgIHwgYEVzY2FwZWQgfCBgRXNjYXBpbmcgLT4gZmFsc2VcbiAgOztcblxuICBsZXQgaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyID1cbiAgICBjaGVja19ib3VuZCBzdHIgcG9zIFwiaW5kZXhfZnJvbVwiO1xuICAgIGxldCByZWMgbG9vcCBpIHN0YXR1cyA9XG4gICAgICBpZiBpID49IHBvc1xuICAgICAgJiYgKG1hdGNoIHN0YXR1cyB3aXRoXG4gICAgICAgICAgfCBgTGl0ZXJhbCAtPiB0cnVlXG4gICAgICAgICAgfCBgRXNjYXBlZCB8IGBFc2NhcGluZyAtPiBmYWxzZSlcbiAgICAgICYmIENoYXIuZXF1YWwgc3RyLltpXSBjaGFyXG4gICAgICB0aGVuIFNvbWUgaVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBpID0gaSArIDEgaW5cbiAgICAgICAgaWYgaSA+PSBsZW5ndGggc3RyXG4gICAgICAgIHRoZW4gTm9uZVxuICAgICAgICBlbHNlIGxvb3AgaSAodXBkYXRlX2VzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBpIHN0YXR1cykpXG4gICAgaW5cbiAgICBsb29wIHBvcyAoZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcylcbiAgOztcblxuICBsZXQgaW5kZXhfZnJvbV9leG4gc3RyIH5lc2NhcGVfY2hhciBwb3MgY2hhciA9XG4gICAgbWF0Y2ggaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyIHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcImluZGV4X2Zyb21fZXhuOiBub3QgZm91bmRcIlxuICAgICAgICAgICBbIFwic3RyXCIsIHNleHBfb2ZfdCBzdHJcbiAgICAgICAgICAgOyBcImVzY2FwZV9jaGFyXCIsIHNleHBfb2ZfY2hhciBlc2NhcGVfY2hhclxuICAgICAgICAgICA7IFwicG9zXCIsIHNleHBfb2ZfaW50IHBvc1xuICAgICAgICAgICA7IFwiY2hhclwiLCBzZXhwX29mX2NoYXIgY2hhclxuICAgICAgICAgICBdKVxuICAgIHwgU29tZSBwb3MgLT4gcG9zXG4gIDs7XG5cbiAgbGV0IGluZGV4IHN0ciB+ZXNjYXBlX2NoYXIgY2hhciA9IGluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciAwIGNoYXJcbiAgbGV0IGluZGV4X2V4biBzdHIgfmVzY2FwZV9jaGFyIGNoYXIgPSBpbmRleF9mcm9tX2V4biBzdHIgfmVzY2FwZV9jaGFyIDAgY2hhclxuXG4gIGxldCByaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyID1cbiAgICBjaGVja19ib3VuZCBzdHIgcG9zIFwicmluZGV4X2Zyb21cIjtcbiAgICAoKiBpZiB0aGUgdGFyZ2V0IGNoYXIgaXMgdGhlIHNhbWUgYXMgW2VzY2FwZV9jaGFyXSwgd2UgaGF2ZSBubyB3YXkgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gICAgICAgZXNjYXBlX2NoYXIgaXMgbGl0ZXJhbCwgc28ganVzdCByZXR1cm4gTm9uZSAqKVxuICAgIGlmIENoYXIuZXF1YWwgY2hhciBlc2NhcGVfY2hhclxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHJlYyBsb29wIHBvcyA9XG4gICAgICAgIGlmIHBvcyA8IDBcbiAgICAgICAgdGhlbiBOb25lXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCBlc2NhcGVfY2hhcnMgPSBwcmVjZWRpbmdfZXNjYXBlX2NoYXJzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGluXG4gICAgICAgICAgaWYgZXNjYXBlX2NoYXJzIG1vZCAyID0gMCAmJiBDaGFyLmVxdWFsIHN0ci5bcG9zXSBjaGFyXG4gICAgICAgICAgdGhlbiBTb21lIHBvc1xuICAgICAgICAgIGVsc2UgbG9vcCAocG9zIC0gZXNjYXBlX2NoYXJzIC0gMSkpXG4gICAgICBpblxuICAgICAgbG9vcCBwb3MpXG4gIDs7XG5cbiAgbGV0IHJpbmRleF9mcm9tX2V4biBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyID1cbiAgICBtYXRjaCByaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyIHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcInJpbmRleF9mcm9tX2V4bjogbm90IGZvdW5kXCJcbiAgICAgICAgICAgWyBcInN0clwiLCBzZXhwX29mX3Qgc3RyXG4gICAgICAgICAgIDsgXCJlc2NhcGVfY2hhclwiLCBzZXhwX29mX2NoYXIgZXNjYXBlX2NoYXJcbiAgICAgICAgICAgOyBcInBvc1wiLCBzZXhwX29mX2ludCBwb3NcbiAgICAgICAgICAgOyBcImNoYXJcIiwgc2V4cF9vZl9jaGFyIGNoYXJcbiAgICAgICAgICAgXSlcbiAgICB8IFNvbWUgcG9zIC0+IHBvc1xuICA7O1xuXG4gIGxldCByaW5kZXggc3RyIH5lc2NhcGVfY2hhciBjaGFyID1cbiAgICBpZiBpc19lbXB0eSBzdHIgdGhlbiBOb25lIGVsc2UgcmluZGV4X2Zyb20gc3RyIH5lc2NhcGVfY2hhciAobGVuZ3RoIHN0ciAtIDEpIGNoYXJcbiAgOztcblxuICBsZXQgcmluZGV4X2V4biBzdHIgfmVzY2FwZV9jaGFyIGNoYXIgPVxuICAgIHJpbmRleF9mcm9tX2V4biBzdHIgfmVzY2FwZV9jaGFyIChsZW5ndGggc3RyIC0gMSkgY2hhclxuICA7O1xuXG4gICgqIFtzcGxpdF9nZW4gc3RyIH5lc2NhcGVfY2hhciB+b25dIHdvcmtzIHNpbWlsYXJseSB0byBbU3RyaW5nLnNwbGl0X2dlbl0sIHdpdGggYW5cbiAgICAgYWRkaXRpb25hbCByZXF1aXJlbWVudDogb25seSBzcGxpdCBvbiBsaXRlcmFsIGNoYXJzLCBub3QgZXNjYXBpbmcgb3IgZXNjYXBlZCAqKVxuICBsZXQgc3BsaXRfZ2VuIHN0ciB+ZXNjYXBlX2NoYXIgfm9uID1cbiAgICBsZXQgaXNfZGVsaW0gPVxuICAgICAgbWF0Y2ggb24gd2l0aFxuICAgICAgfCBgY2hhciBjJyAtPiBmdW4gYyAtPiBDaGFyLmVxdWFsIGMgYydcbiAgICAgIHwgYGNoYXJfbGlzdCBsIC0+IGZ1biBjIC0+IGNoYXJfbGlzdF9tZW0gbCBjXG4gICAgaW5cbiAgICBsZXQgbGVuID0gbGVuZ3RoIHN0ciBpblxuICAgIGxldCByZWMgbG9vcCBhY2Mgc3RhdHVzIGxhc3RfcG9zIHBvcyA9XG4gICAgICBpZiBwb3MgPSBsZW5cbiAgICAgIHRoZW4gTGlzdC5yZXYgKHN1YiBzdHIgfnBvczpsYXN0X3BvcyB+bGVuOihsZW4gLSBsYXN0X3BvcykgOjogYWNjKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBzdGF0dXMgPSB1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyBzdGF0dXMgaW5cbiAgICAgICAgaWYgKG1hdGNoIHN0YXR1cyB3aXRoXG4gICAgICAgICAgfCBgTGl0ZXJhbCAtPiB0cnVlXG4gICAgICAgICAgfCBgRXNjYXBlZCB8IGBFc2NhcGluZyAtPiBmYWxzZSlcbiAgICAgICAgJiYgaXNfZGVsaW0gc3RyLltwb3NdXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBzdWJfc3RyID0gc3ViIHN0ciB+cG9zOmxhc3RfcG9zIH5sZW46KHBvcyAtIGxhc3RfcG9zKSBpblxuICAgICAgICAgIGxvb3AgKHN1Yl9zdHIgOjogYWNjKSBzdGF0dXMgKHBvcyArIDEpIChwb3MgKyAxKSlcbiAgICAgICAgZWxzZSBsb29wIGFjYyBzdGF0dXMgbGFzdF9wb3MgKHBvcyArIDEpKVxuICAgIGluXG4gICAgbG9vcCBbXSBgTGl0ZXJhbCAwIDBcbiAgOztcblxuICBsZXQgc3BsaXQgc3RyIH5vbiA9IHNwbGl0X2dlbiBzdHIgfm9uOihgY2hhciBvbilcbiAgbGV0IHNwbGl0X29uX2NoYXJzIHN0ciB+b246Y2hhcnMgPSBzcGxpdF9nZW4gc3RyIH5vbjooYGNoYXJfbGlzdCBjaGFycylcblxuICBsZXQgc3BsaXRfYXQgc3RyIHBvcyA9XG4gICAgc3ViIHN0ciB+cG9zOjAgfmxlbjpwb3MsIHN1YiBzdHIgfnBvczoocG9zICsgMSkgfmxlbjoobGVuZ3RoIHN0ciAtIHBvcyAtIDEpXG4gIDs7XG5cbiAgbGV0IGxzcGxpdDIgc3RyIH5vbiB+ZXNjYXBlX2NoYXIgPVxuICAgIE9wdGlvbi5tYXAgKGluZGV4IHN0ciB+ZXNjYXBlX2NoYXIgb24pIH5mOihmdW4geCAtPiBzcGxpdF9hdCBzdHIgeClcbiAgOztcblxuICBsZXQgcnNwbGl0MiBzdHIgfm9uIH5lc2NhcGVfY2hhciA9XG4gICAgT3B0aW9uLm1hcCAocmluZGV4IHN0ciB+ZXNjYXBlX2NoYXIgb24pIH5mOihmdW4geCAtPiBzcGxpdF9hdCBzdHIgeClcbiAgOztcblxuICBsZXQgbHNwbGl0Ml9leG4gc3RyIH5vbiB+ZXNjYXBlX2NoYXIgPSBzcGxpdF9hdCBzdHIgKGluZGV4X2V4biBzdHIgfmVzY2FwZV9jaGFyIG9uKVxuICBsZXQgcnNwbGl0Ml9leG4gc3RyIH5vbiB+ZXNjYXBlX2NoYXIgPSBzcGxpdF9hdCBzdHIgKHJpbmRleF9leG4gc3RyIH5lc2NhcGVfY2hhciBvbilcblxuICAoKiBbbGFzdF9ub25fZHJvcF9saXRlcmFsXSBhbmQgW2ZpcnN0X25vbl9kcm9wX2xpdGVyYWxdIGFyZSBlaXRoZXIgYm90aCBbTm9uZV0gb3IgYm90aFxuICAgICBbU29tZV0uIElmIFtTb21lXSwgdGhlbiB0aGUgZm9ybWVyIGlzID49IHRoZSBsYXR0ZXIuICopXG4gIGxldCBsYXN0X25vbl9kcm9wX2xpdGVyYWwgfmRyb3AgfmVzY2FwZV9jaGFyIHQgPVxuICAgIHJmaW5kaSB0IH5mOihmdW4gaSBjIC0+XG4gICAgICAobm90IChkcm9wIGMpKVxuICAgICAgfHwgaXNfY2hhcl9lc2NhcGluZyB0IH5lc2NhcGVfY2hhciBpXG4gICAgICB8fCBpc19jaGFyX2VzY2FwZWQgdCB+ZXNjYXBlX2NoYXIgaSlcbiAgOztcblxuICBsZXQgZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB+ZHJvcCB+ZXNjYXBlX2NoYXIgdCA9XG4gICAgbGZpbmRpIHQgfmY6KGZ1biBpIGMgLT5cbiAgICAgIChub3QgKGRyb3AgYykpXG4gICAgICB8fCBpc19jaGFyX2VzY2FwaW5nIHQgfmVzY2FwZV9jaGFyIGlcbiAgICAgIHx8IGlzX2NoYXJfZXNjYXBlZCB0IH5lc2NhcGVfY2hhciBpKVxuICA7O1xuXG4gIGxldCByc3RyaXBfbGl0ZXJhbCA/KGRyb3AgPSBDaGFyLmlzX3doaXRlc3BhY2UpIHQgfmVzY2FwZV9jaGFyID1cbiAgICBtYXRjaCBsYXN0X25vbl9kcm9wX2xpdGVyYWwgdCB+ZHJvcCB+ZXNjYXBlX2NoYXIgd2l0aFxuICAgIHwgTm9uZSAtPiBcIlwiXG4gICAgfCBTb21lIGkgLT4gaWYgaSA9IGxlbmd0aCB0IC0gMSB0aGVuIHQgZWxzZSBwcmVmaXggdCAoaSArIDEpXG4gIDs7XG5cbiAgbGV0IGxzdHJpcF9saXRlcmFsID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCB+ZXNjYXBlX2NoYXIgPVxuICAgIG1hdGNoIGZpcnN0X25vbl9kcm9wX2xpdGVyYWwgdCB+ZHJvcCB+ZXNjYXBlX2NoYXIgd2l0aFxuICAgIHwgTm9uZSAtPiBcIlwiXG4gICAgfCBTb21lIDAgLT4gdFxuICAgIHwgU29tZSBuIC0+IGRyb3BfcHJlZml4IHQgblxuICA7O1xuXG4gICgqIFtzdHJpcCB0XSBjb3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBbbHN0cmlwIChyc3RyaXAgdCldLiAgVGhlIGltcGxlbWVudGF0aW9uXG4gICAgIGJlbG93IHNhdmVzIChhdCBsZWFzdCkgYSBmYWN0b3Igb2YgdHdvIGFsbG9jYXRpb24sIGJ5IG9ubHkgYWxsb2NhdGluZyB0aGVcbiAgICAgZmluYWwgcmVzdWx0LiAgVGhpcyBhbHNvIHNhdmVzIHNvbWUgYW1vdW50IG9mIHRpbWUuICopXG4gIGxldCBzdHJpcF9saXRlcmFsID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCB+ZXNjYXBlX2NoYXIgPVxuICAgIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICAgICgqIHBlcmZvcm1hbmNlIGhhY2s6IGF2b2lkIGNvcHlpbmcgW3RdIGluIGNvbW1vbiBjYXNlcyAqKVxuICAgIGlmIGxlbmd0aCA9IDAgfHwgbm90IChkcm9wIHQuWzBdIHx8IGRyb3AgdC5bbGVuZ3RoIC0gMV0pXG4gICAgdGhlbiB0XG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBmaXJzdF9ub25fZHJvcF9saXRlcmFsIHQgfmRyb3AgfmVzY2FwZV9jaGFyIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBcIlwiXG4gICAgICB8IFNvbWUgZmlyc3QgLT5cbiAgICAgICAgKG1hdGNoIGxhc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB0IH5kcm9wIH5lc2NhcGVfY2hhciB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICB8IFNvbWUgbGFzdCAtPiBzdWIgdCB+cG9zOmZpcnN0IH5sZW46KGxhc3QgLSBmaXJzdCArIDEpKSlcbiAgOztcbmVuZFxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBTdHJpbmdfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbigqIE92ZXJyaWRlIFtTZWFyY2hfcGF0dGVybl0gd2l0aCBkZWZhdWx0IGNhc2Utc2Vuc2l0aXZpdHkgYXJndW1lbnQgYXQgdGhlIGVuZCBvZiB0aGVcbiAgIGZpbGUsIHNvIHRoYXQgY2FsbCBzaXRlcyBhYm92ZSBhcmUgZm9yY2VkIHRvIHN1cHBseSBjYXNlLXNlbnNpdGl2aXR5IGV4cGxpY2l0bHkuICopXG5tb2R1bGUgU2VhcmNoX3BhdHRlcm4gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTZWFyY2hfcGF0dGVybjBcblxuICBsZXQgY3JlYXRlID8oY2FzZV9zZW5zaXRpdmUgPSB0cnVlKSBwYXR0ZXJuID0gY3JlYXRlIHBhdHRlcm4gfmNhc2Vfc2Vuc2l0aXZlXG5lbmRcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIFN0cmluZ19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEFycmF5ID0gQXJyYXkwXG5cbmxldCBzdGFnZSA9IFN0YWdlZC5zdGFnZVxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBieXRlcyBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCB0X29mX3NleHAgPSAoYnl0ZXNfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfYnl0ZXMgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gYnl0ZXNfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBpbmNsdWRlIEJ5dGVzMFxuXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5CeXRlc1wiXG4gIGxldCBwcCBmbXQgdCA9IENhbWwuRm9ybWF0LmZwcmludGYgZm10IFwiJVNcIiAodG9fc3RyaW5nIHQpXG5lbmRcblxuaW5jbHVkZSBUXG5cbm1vZHVsZSBUb19ieXRlcyA9IEJsaXQuTWFrZSAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgY3JlYXRlIH5sZW4gPSBjcmVhdGUgbGVuXG4gIGVuZClcblxuaW5jbHVkZSBUb19ieXRlc1xuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyX3BwIChUKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBCeXRlc19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbm1vZHVsZSBUb19zdHJpbmcgPSBCbGl0Lk1ha2VfdG9fc3RyaW5nIChUKSAoVG9fYnl0ZXMpXG5cbm1vZHVsZSBGcm9tX3N0cmluZyA9XG4gIEJsaXQuTWFrZV9kaXN0aW5jdFxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IHN0cmluZ1xuXG4gICAgICBsZXQgbGVuZ3RoID0gU3RyaW5nLmxlbmd0aFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBsZXQgY3JlYXRlIH5sZW4gPSBjcmVhdGUgbGVuXG4gICAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdF9zdHJpbmdcbiAgICBlbmQpXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5cbmxldCBpbml0IG4gfmYgPVxuICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPCApIG4gMFxuICB0aGVuIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJCeXRlcy5pbml0ICVkXCIgbiAoKTtcbiAgbGV0IHQgPSBjcmVhdGUgbiBpblxuICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICB1bnNhZmVfc2V0IHQgaSAoZiBpKVxuICBkb25lO1xuICB0XG47O1xuXG5sZXQgb2ZfY2hhcl9saXN0IGwgPVxuICBsZXQgdCA9IGNyZWF0ZSAoTGlzdC5sZW5ndGggbCkgaW5cbiAgTGlzdC5pdGVyaSBsIH5mOihmdW4gaSBjIC0+IHNldCB0IGkgYyk7XG4gIHRcbjs7XG5cbmxldCB0b19saXN0IHQgPVxuICBsZXQgcmVjIGxvb3AgdCBpIGFjYyA9XG4gICAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBpIDBcbiAgICB0aGVuIGFjY1xuICAgIGVsc2UgbG9vcCB0IChpIC0gMSkgKHVuc2FmZV9nZXQgdCBpIDo6IGFjYylcbiAgaW5cbiAgbG9vcCB0IChsZW5ndGggdCAtIDEpIFtdXG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9IEFycmF5LmluaXQgKGxlbmd0aCB0KSB+ZjooZnVuIGkgLT4gdW5zYWZlX2dldCB0IGkpXG5sZXQgbWFwIHQgfmYgPSBtYXAgdCB+ZlxubGV0IG1hcGkgdCB+ZiA9IG1hcGkgdCB+ZlxuXG5sZXQgZm9sZCA9XG4gIGxldCByZWMgbG9vcCB0IH5mIH5sZW4gfnBvcyBhY2MgPVxuICAgIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWwgcG9zIGxlblxuICAgIHRoZW4gYWNjXG4gICAgZWxzZSBsb29wIHQgfmYgfmxlbiB+cG9zOihwb3MgKyAxKSAoZiBhY2MgKHVuc2FmZV9nZXQgdCBwb3MpKVxuICBpblxuICBmdW4gdCB+aW5pdCB+ZiAtPiBsb29wIHQgfmYgfmxlbjoobGVuZ3RoIHQpIH5wb3M6MCBpbml0XG47O1xuXG5sZXQgZm9sZGkgPVxuICBsZXQgcmVjIGxvb3AgdCB+ZiB+bGVuIH5wb3MgYWNjID1cbiAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmVxdWFsIHBvcyBsZW5cbiAgICB0aGVuIGFjY1xuICAgIGVsc2UgbG9vcCB0IH5mIH5sZW4gfnBvczoocG9zICsgMSkgKGYgcG9zIGFjYyAodW5zYWZlX2dldCB0IHBvcykpXG4gIGluXG4gIGZ1biB0IH5pbml0IH5mIC0+IGxvb3AgdCB+ZiB+bGVuOihsZW5ndGggdCkgfnBvczowIGluaXRcbjs7XG5cbmxldCB0ciB+dGFyZ2V0IH5yZXBsYWNlbWVudCBzID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgIGlmIENoYXIuZXF1YWwgKHVuc2FmZV9nZXQgcyBpKSB0YXJnZXQgdGhlbiB1bnNhZmVfc2V0IHMgaSByZXBsYWNlbWVudFxuICBkb25lXG47O1xuXG5sZXQgdHJfbXVsdGkgfnRhcmdldCB+cmVwbGFjZW1lbnQgPVxuICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPSApIChTdHJpbmcubGVuZ3RoIHRhcmdldCkgMFxuICB0aGVuIHN0YWdlIGlnbm9yZVxuICBlbHNlIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA9ICkgKFN0cmluZy5sZW5ndGggcmVwbGFjZW1lbnQpIDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcInRyX211bHRpOiByZXBsYWNlbWVudCBpcyB0aGUgZW1wdHkgc3RyaW5nXCJcbiAgZWxzZSAoXG4gICAgbWF0Y2ggQnl0ZXNfdHIudHJfY3JlYXRlX21hcCB+dGFyZ2V0IH5yZXBsYWNlbWVudCB3aXRoXG4gICAgfCBOb25lIC0+IHN0YWdlIGlnbm9yZVxuICAgIHwgU29tZSB0cl9tYXAgLT5cbiAgICAgIHN0YWdlIChmdW4gcyAtPlxuICAgICAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBzIGkgKFN0cmluZy51bnNhZmVfZ2V0IHRyX21hcCAoQ2hhci50b19pbnQgKHVuc2FmZV9nZXQgcyBpKSkpXG4gICAgICAgIGRvbmUpKVxuOztcblxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxubGV0IGNvbnRhaW5zID9wb3MgP2xlbiB0IGNoYXIgPVxuICBsZXQgcG9zLCBsZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uZ2V0X3Bvc19sZW5fZXhuICgpID9wb3MgP2xlbiB+dG90YWxfbGVuZ3RoOihsZW5ndGggdClcbiAgaW5cbiAgbGV0IGxhc3QgPSBwb3MgKyBsZW4gaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgaSBsYXN0XG4gICAgJiYgKENoYXIuZXF1YWwgKGdldCB0IGkpIGNoYXIgfHwgbG9vcCAoaSArIDEpKVxuICBpblxuICBsb29wIHBvc1xuOztcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEJ5dGVzX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwiIyAxIFwic3JjL2hleF9sZXhlci5tbGxcIlxuIFxudHlwZSByZXN1bHQgPVxufCBOZWcgb2Ygc3RyaW5nXG58IFBvcyBvZiBzdHJpbmdcblxuIyA4IFwic3JjL2hleF9sZXhlci5tbFwiXG5sZXQgX19vY2FtbF9sZXhfdGFibGVzID0ge1xuICBMZXhpbmcubGV4X2Jhc2UgPVxuICAgXCJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAxXFwwMDBcXDAwMVxcMDAwXFwwMDJcXDAwMFxcMDI3XFwwMDBcXDA4MlxcMDAwXFwxMDVcXDAwMFxcXG4gICAgXCI7XG4gIExleGluZy5sZXhfYmFja3RyayA9XG4gICBcIlxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAwMVxcMDAwXFxcbiAgICBcIjtcbiAgTGV4aW5nLmxleF9kZWZhdWx0ID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFwiO1xuICBMZXhpbmcubGV4X3RyYW5zID1cbiAgIFwiXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDFcXDAwMFxcMDAzXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMDA0XFwwMDBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcIjtcbiAgTGV4aW5nLmxleF9jaGVjayA9XG4gICBcIlxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDAwXFwwMDBcXDAwMlxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDFcXDAwMFxcMDAzXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFxcbiAgICBcXDAwNFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDAxXFwwMDBcXDAwM1xcMDAwXFwwMDVcXDAwMFxcMjU1XFwyNTVcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcXG4gICAgXFwwMDZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwN1xcMDAwXFwyNTVcXDI1NVxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XCI7XG4gIExleGluZy5sZXhfYmFzZV9jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfYmFja3Rya19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfZGVmYXVsdF9jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfdHJhbnNfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2NoZWNrX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9jb2RlID1cbiAgIFwiXCI7XG59XG5cbmxldCByZWMgcGFyc2VfaGV4IGxleGJ1ZiA9XG4gICBfX29jYW1sX2xleF9wYXJzZV9oZXhfcmVjIGxleGJ1ZiAwXG5hbmQgX19vY2FtbF9sZXhfcGFyc2VfaGV4X3JlYyBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGUgPVxuICBtYXRjaCBMZXhpbmcuZW5naW5lIF9fb2NhbWxfbGV4X3RhYmxlcyBfX29jYW1sX2xleF9zdGF0ZSBsZXhidWYgd2l0aFxuICAgICAgfCAwIC0+XG5sZXRcbiMgOCBcInNyYy9oZXhfbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlcbiMgMTM1IFwic3JjL2hleF9sZXhlci5tbFwiXG49IExleGluZy5zdWJfbGV4ZW1lIGxleGJ1ZiAobGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcG9zICsgMykgbGV4YnVmLkxleGluZy5sZXhfY3Vycl9wb3MgaW5cbiMgMTQgXCJzcmMvaGV4X2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICggTmVnIGJvZHkgKVxuIyAxMzkgXCJzcmMvaGV4X2xleGVyLm1sXCJcblxuICB8IDEgLT5cbmxldFxuIyA4IFwic3JjL2hleF9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keVxuIyAxNDUgXCJzcmMvaGV4X2xleGVyLm1sXCJcbj0gTGV4aW5nLnN1Yl9sZXhlbWUgbGV4YnVmIChsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wb3MgKyAyKSBsZXhidWYuTGV4aW5nLmxleF9jdXJyX3BvcyBpblxuIyAxNSBcInNyYy9oZXhfbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCBQb3MgYm9keSApXG4jIDE0OSBcInNyYy9oZXhfbGV4ZXIubWxcIlxuXG4gIHwgX19vY2FtbF9sZXhfc3RhdGUgLT4gbGV4YnVmLkxleGluZy5yZWZpbGxfYnVmZiBsZXhidWY7XG4gICAgICBfX29jYW1sX2xleF9wYXJzZV9oZXhfcmVjIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZVxuXG47O1xuXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBJbnQgPSBJbnQwXG5tb2R1bGUgU3lzID0gU3lzMFxuXG5sZXQgY29udmVydF9mYWlsdXJlIHggYSBiIHRvX3N0cmluZyA9XG4gIFByaW50Zi5mYWlsd2l0aGZcbiAgICBcImNvbnZlcnNpb24gZnJvbSAlcyB0byAlcyBmYWlsZWQ6ICVzIGlzIG91dCBvZiByYW5nZVwiXG4gICAgYVxuICAgIGJcbiAgICAodG9fc3RyaW5nIHgpXG4gICAgKClcbltAQGNvbGRdIFtAQGlubGluZSBuZXZlcl0gW0BAbG9jYWwgbmV2ZXJdIFtAQHNwZWNpYWxpc2UgbmV2ZXJdXG47O1xuXG5sZXQgbnVtX2JpdHNfaW50ID0gU3lzLmludF9zaXplX2luX2JpdHNcbmxldCBudW1fYml0c19pbnQzMiA9IDMyXG5sZXQgbnVtX2JpdHNfaW50NjQgPSA2NFxubGV0IG51bV9iaXRzX25hdGl2ZWludCA9IFdvcmRfc2l6ZS5udW1fYml0cyBXb3JkX3NpemUud29yZF9zaXplXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludCA9IDYzIHx8IG51bV9iaXRzX2ludCA9IDMxIHx8IG51bV9iaXRzX2ludCA9IDMyKVxubGV0IG1pbl9pbnQzMiA9IENhbWwuSW50MzIubWluX2ludFxubGV0IG1heF9pbnQzMiA9IENhbWwuSW50MzIubWF4X2ludFxubGV0IG1pbl9pbnQ2NCA9IENhbWwuSW50NjQubWluX2ludFxubGV0IG1heF9pbnQ2NCA9IENhbWwuSW50NjQubWF4X2ludFxubGV0IG1pbl9uYXRpdmVpbnQgPSBDYW1sLk5hdGl2ZWludC5taW5faW50XG5sZXQgbWF4X25hdGl2ZWludCA9IENhbWwuTmF0aXZlaW50Lm1heF9pbnRcbmxldCBpbnRfdG9fc3RyaW5nID0gQ2FtbC5zdHJpbmdfb2ZfaW50XG5sZXQgaW50MzJfdG9fc3RyaW5nID0gQ2FtbC5JbnQzMi50b19zdHJpbmdcbmxldCBpbnQ2NF90b19zdHJpbmcgPSBDYW1sLkludDY0LnRvX3N0cmluZ1xubGV0IG5hdGl2ZWludF90b19zdHJpbmcgPSBDYW1sLk5hdGl2ZWludC50b19zdHJpbmdcblxuKCogaW50IDwtPiBpbnQzMiAqKVxuXG5sZXQgaW50X3RvX2ludDMyX2ZhaWx1cmUgeCA9IGNvbnZlcnRfZmFpbHVyZSB4IFwiaW50XCIgXCJpbnQzMlwiIGludF90b19zdHJpbmdcbmxldCBpbnQzMl90b19pbnRfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQzMlwiIFwiaW50XCIgaW50MzJfdG9fc3RyaW5nXG5sZXQgaW50MzJfdG9faW50X3RydW5jID0gQ2FtbC5JbnQzMi50b19pbnRcbmxldCBpbnRfdG9faW50MzJfdHJ1bmMgPSBDYW1sLkludDMyLm9mX2ludFxuXG5sZXQgaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgPVxuICBpZiBudW1fYml0c19pbnQgPD0gbnVtX2JpdHNfaW50MzJcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBpbnQzMl90b19pbnRfdHJ1bmMgbWluX2ludDMyIGluXG4gICAgbGV0IG1heCA9IGludDMyX3RvX2ludF90cnVuYyBtYXhfaW50MzIgaW5cbiAgICBmdW4geCAtPiBjb21wYXJlX2ludCBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50IHggbWF4IDw9IDApXG47O1xuXG5sZXQgaW50MzJfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgPVxuICBpZiBudW1fYml0c19pbnQzMiA8PSBudW1fYml0c19pbnRcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBpbnRfdG9faW50MzJfdHJ1bmMgSW50Lm1pbl92YWx1ZSBpblxuICAgIGxldCBtYXggPSBpbnRfdG9faW50MzJfdHJ1bmMgSW50Lm1heF92YWx1ZSBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfaW50MzIgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDMyIHggbWF4IDw9IDApXG47O1xuXG5sZXQgaW50X3RvX2ludDMyIHggPVxuICBpZiBpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4IHRoZW4gU29tZSAoaW50X3RvX2ludDMyX3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IGludDMyX3RvX2ludCB4ID1cbiAgaWYgaW50MzJfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeCB0aGVuIFNvbWUgKGludDMyX3RvX2ludF90cnVuYyB4KSBlbHNlIE5vbmVcbjs7XG5cbmxldCBpbnRfdG9faW50MzJfZXhuIHggPVxuICBpZiBpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4IHRoZW4gaW50X3RvX2ludDMyX3RydW5jIHggZWxzZSBpbnRfdG9faW50MzJfZmFpbHVyZSB4XG47O1xuXG5sZXQgaW50MzJfdG9faW50X2V4biB4ID1cbiAgaWYgaW50MzJfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeCB0aGVuIGludDMyX3RvX2ludF90cnVuYyB4IGVsc2UgaW50MzJfdG9faW50X2ZhaWx1cmUgeFxuOztcblxuKCogaW50IDwtPiBpbnQ2NCAqKVxuXG5sZXQgaW50NjRfdG9faW50X2ZhaWx1cmUgeCA9IGNvbnZlcnRfZmFpbHVyZSB4IFwiaW50NjRcIiBcImludFwiIGludDY0X3RvX3N0cmluZ1xubGV0ICgpID0gYXNzZXJ0IChudW1fYml0c19pbnQgPCBudW1fYml0c19pbnQ2NClcbmxldCBpbnRfdG9faW50NjQgPSBDYW1sLkludDY0Lm9mX2ludFxubGV0IGludDY0X3RvX2ludF90cnVuYyA9IENhbWwuSW50NjQudG9faW50XG5cbmxldCBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCA9XG4gIGxldCBtaW4gPSBpbnRfdG9faW50NjQgSW50Lm1pbl92YWx1ZSBpblxuICBsZXQgbWF4ID0gaW50X3RvX2ludDY0IEludC5tYXhfdmFsdWUgaW5cbiAgZnVuIHggLT4gY29tcGFyZV9pbnQ2NCBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50NjQgeCBtYXggPD0gMFxuOztcblxubGV0IGludDY0X3RvX2ludCB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeCB0aGVuIFNvbWUgKGludDY0X3RvX2ludF90cnVuYyB4KSBlbHNlIE5vbmVcbjs7XG5cbmxldCBpbnQ2NF90b19pbnRfZXhuIHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gaW50NjRfdG9faW50X3RydW5jIHggZWxzZSBpbnQ2NF90b19pbnRfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQgPC0+IG5hdGl2ZWludCAqKVxuXG5sZXQgbmF0aXZlaW50X3RvX2ludF9mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcIm5hdGl2ZWludFwiIFwiaW50XCIgbmF0aXZlaW50X3RvX3N0cmluZ1xubGV0ICgpID0gYXNzZXJ0IChudW1fYml0c19pbnQgPD0gbnVtX2JpdHNfbmF0aXZlaW50KVxubGV0IGludF90b19uYXRpdmVpbnQgPSBDYW1sLk5hdGl2ZWludC5vZl9pbnRcbmxldCBuYXRpdmVpbnRfdG9faW50X3RydW5jID0gQ2FtbC5OYXRpdmVpbnQudG9faW50XG5cbmxldCBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgPVxuICBpZiBudW1fYml0c19uYXRpdmVpbnQgPD0gbnVtX2JpdHNfaW50XG4gIHRoZW4gZnVuIF8gLT4gdHJ1ZVxuICBlbHNlIChcbiAgICBsZXQgbWluID0gaW50X3RvX25hdGl2ZWludCBJbnQubWluX3ZhbHVlIGluXG4gICAgbGV0IG1heCA9IGludF90b19uYXRpdmVpbnQgSW50Lm1heF92YWx1ZSBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfbmF0aXZlaW50IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9uYXRpdmVpbnQgeCBtYXggPD0gMClcbjs7XG5cbmxldCBuYXRpdmVpbnRfdG9faW50IHggPVxuICBpZiBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQgeCB0aGVuIFNvbWUgKG5hdGl2ZWludF90b19pbnRfdHJ1bmMgeCkgZWxzZSBOb25lXG47O1xuXG5sZXQgbmF0aXZlaW50X3RvX2ludF9leG4geCA9XG4gIGlmIG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4XG4gIHRoZW4gbmF0aXZlaW50X3RvX2ludF90cnVuYyB4XG4gIGVsc2UgbmF0aXZlaW50X3RvX2ludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludDMyIDwtPiBpbnQ2NCAqKVxuXG5sZXQgaW50NjRfdG9faW50MzJfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwiaW50MzJcIiBpbnQ2NF90b19zdHJpbmdcbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50MzIgPCBudW1fYml0c19pbnQ2NClcbmxldCBpbnQzMl90b19pbnQ2NCA9IENhbWwuSW50NjQub2ZfaW50MzJcbmxldCBpbnQ2NF90b19pbnQzMl90cnVuYyA9IENhbWwuSW50NjQudG9faW50MzJcblxubGV0IGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgPVxuICBsZXQgbWluID0gaW50MzJfdG9faW50NjQgbWluX2ludDMyIGluXG4gIGxldCBtYXggPSBpbnQzMl90b19pbnQ2NCBtYXhfaW50MzIgaW5cbiAgZnVuIHggLT4gY29tcGFyZV9pbnQ2NCBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50NjQgeCBtYXggPD0gMFxuOztcblxubGV0IGludDY0X3RvX2ludDMyIHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHggdGhlbiBTb21lIChpbnQ2NF90b19pbnQzMl90cnVuYyB4KSBlbHNlIE5vbmVcbjs7XG5cbmxldCBpbnQ2NF90b19pbnQzMl9leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeFxuICB0aGVuIGludDY0X3RvX2ludDMyX3RydW5jIHhcbiAgZWxzZSBpbnQ2NF90b19pbnQzMl9mYWlsdXJlIHhcbjs7XG5cbigqIGludDMyIDwtPiBuYXRpdmVpbnQgKilcblxubGV0IG5hdGl2ZWludF90b19pbnQzMl9mYWlsdXJlIHggPVxuICBjb252ZXJ0X2ZhaWx1cmUgeCBcIm5hdGl2ZWludFwiIFwiaW50MzJcIiBuYXRpdmVpbnRfdG9fc3RyaW5nXG47O1xuXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludDMyIDw9IG51bV9iaXRzX25hdGl2ZWludClcbmxldCBpbnQzMl90b19uYXRpdmVpbnQgPSBDYW1sLk5hdGl2ZWludC5vZl9pbnQzMlxubGV0IG5hdGl2ZWludF90b19pbnQzMl90cnVuYyA9IENhbWwuTmF0aXZlaW50LnRvX2ludDMyXG5cbmxldCBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiA9XG4gIGlmIG51bV9iaXRzX25hdGl2ZWludCA8PSBudW1fYml0c19pbnQzMlxuICB0aGVuIGZ1biBfIC0+IHRydWVcbiAgZWxzZSAoXG4gICAgbGV0IG1pbiA9IGludDMyX3RvX25hdGl2ZWludCBtaW5faW50MzIgaW5cbiAgICBsZXQgbWF4ID0gaW50MzJfdG9fbmF0aXZlaW50IG1heF9pbnQzMiBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfbmF0aXZlaW50IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9uYXRpdmVpbnQgeCBtYXggPD0gMClcbjs7XG5cbmxldCBuYXRpdmVpbnRfdG9faW50MzIgeCA9XG4gIGlmIG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHhcbiAgdGhlbiBTb21lIChuYXRpdmVpbnRfdG9faW50MzJfdHJ1bmMgeClcbiAgZWxzZSBOb25lXG47O1xuXG5sZXQgbmF0aXZlaW50X3RvX2ludDMyX2V4biB4ID1cbiAgaWYgbmF0aXZlaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeFxuICB0aGVuIG5hdGl2ZWludF90b19pbnQzMl90cnVuYyB4XG4gIGVsc2UgbmF0aXZlaW50X3RvX2ludDMyX2ZhaWx1cmUgeFxuOztcblxuKCogaW50NjQgPC0+IG5hdGl2ZWludCAqKVxuXG5sZXQgaW50NjRfdG9fbmF0aXZlaW50X2ZhaWx1cmUgeCA9IGNvbnZlcnRfZmFpbHVyZSB4IFwiaW50NjRcIiBcIm5hdGl2ZWludFwiIGludDY0X3RvX3N0cmluZ1xubGV0ICgpID0gYXNzZXJ0IChudW1fYml0c19pbnQ2NCA+PSBudW1fYml0c19uYXRpdmVpbnQpXG5sZXQgaW50NjRfdG9fbmF0aXZlaW50X3RydW5jID0gQ2FtbC5JbnQ2NC50b19uYXRpdmVpbnRcbmxldCBuYXRpdmVpbnRfdG9faW50NjQgPSBDYW1sLkludDY0Lm9mX25hdGl2ZWludFxuXG5sZXQgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19uYXRpdmVpbnQgPVxuICBpZiBudW1fYml0c19pbnQ2NCA8PSBudW1fYml0c19uYXRpdmVpbnRcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBuYXRpdmVpbnRfdG9faW50NjQgbWluX25hdGl2ZWludCBpblxuICAgIGxldCBtYXggPSBuYXRpdmVpbnRfdG9faW50NjQgbWF4X25hdGl2ZWludCBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfaW50NjQgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDY0IHggbWF4IDw9IDApXG47O1xuXG5sZXQgaW50NjRfdG9fbmF0aXZlaW50IHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX25hdGl2ZWludCB4XG4gIHRoZW4gU29tZSAoaW50NjRfdG9fbmF0aXZlaW50X3RydW5jIHgpXG4gIGVsc2UgTm9uZVxuOztcblxubGV0IGludDY0X3RvX25hdGl2ZWludF9leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfbmF0aXZlaW50IHhcbiAgdGhlbiBpbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgeFxuICBlbHNlIGludDY0X3RvX25hdGl2ZWludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludDY0IDwtPiBpbnQ2MyAqKVxuXG5sZXQgaW50NjRfdG9faW50NjNfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwiaW50NjNcIiBpbnQ2NF90b19zdHJpbmdcblxubGV0IGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50NjMgPVxuICBsZXQgbWluID0gQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodCBtaW5faW50NjQgMSBpblxuICBsZXQgbWF4ID0gQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodCBtYXhfaW50NjQgMSBpblxuICBmdW4geCAtPiBjb21wYXJlX2ludDY0IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQ2NCB4IG1heCA8PSAwXG47O1xuXG5sZXQgaW50NjRfZml0X29uX2ludDYzX2V4biB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQ2MyB4IHRoZW4gKCkgZWxzZSBpbnQ2NF90b19pbnQ2M19mYWlsdXJlIHhcbjs7XG5cbigqIHN0cmluZyBjb252ZXJzaW9ucyAqKVxuXG5sZXQgaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSBpbnB1dCB+ZGVsaW1pdGVyIH5jaGFyc19wZXJfZGVsaW1pdGVyID1cbiAgbGV0IGlucHV0X2xlbmd0aCA9IFN0cmluZy5sZW5ndGggaW5wdXQgaW5cbiAgaWYgaW5wdXRfbGVuZ3RoIDw9IGNoYXJzX3Blcl9kZWxpbWl0ZXJcbiAgdGhlbiBpbnB1dFxuICBlbHNlIChcbiAgICBsZXQgaGFzX3NpZ24gPVxuICAgICAgbWF0Y2ggaW5wdXQuWzBdIHdpdGhcbiAgICAgIHwgJysnIHwgJy0nIC0+IHRydWVcbiAgICAgIHwgXyAtPiBmYWxzZVxuICAgIGluXG4gICAgbGV0IG51bV9kaWdpdHMgPSBpZiBoYXNfc2lnbiB0aGVuIGlucHV0X2xlbmd0aCAtIDEgZWxzZSBpbnB1dF9sZW5ndGggaW5cbiAgICBsZXQgbnVtX2RlbGltaXRlcnMgPSAobnVtX2RpZ2l0cyAtIDEpIC8gY2hhcnNfcGVyX2RlbGltaXRlciBpblxuICAgIGxldCBvdXRwdXRfbGVuZ3RoID0gaW5wdXRfbGVuZ3RoICsgbnVtX2RlbGltaXRlcnMgaW5cbiAgICBsZXQgb3V0cHV0ID0gQnl0ZXMuY3JlYXRlIG91dHB1dF9sZW5ndGggaW5cbiAgICBsZXQgaW5wdXRfcG9zID0gcmVmIChpbnB1dF9sZW5ndGggLSAxKSBpblxuICAgIGxldCBvdXRwdXRfcG9zID0gcmVmIChvdXRwdXRfbGVuZ3RoIC0gMSkgaW5cbiAgICBsZXQgbnVtX2NoYXJzX3VudGlsX2RlbGltaXRlciA9IHJlZiBjaGFyc19wZXJfZGVsaW1pdGVyIGluXG4gICAgbGV0IGZpcnN0X2RpZ2l0X3BvcyA9IGlmIGhhc19zaWduIHRoZW4gMSBlbHNlIDAgaW5cbiAgICB3aGlsZSAhaW5wdXRfcG9zID49IGZpcnN0X2RpZ2l0X3BvcyBkb1xuICAgICAgaWYgIW51bV9jaGFyc191bnRpbF9kZWxpbWl0ZXIgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgQnl0ZXMuc2V0IG91dHB1dCAhb3V0cHV0X3BvcyBkZWxpbWl0ZXI7XG4gICAgICAgIGRlY3Igb3V0cHV0X3BvcztcbiAgICAgICAgbnVtX2NoYXJzX3VudGlsX2RlbGltaXRlciA6PSBjaGFyc19wZXJfZGVsaW1pdGVyKTtcbiAgICAgIEJ5dGVzLnNldCBvdXRwdXQgIW91dHB1dF9wb3MgaW5wdXQuWyFpbnB1dF9wb3NdO1xuICAgICAgZGVjciBpbnB1dF9wb3M7XG4gICAgICBkZWNyIG91dHB1dF9wb3M7XG4gICAgICBkZWNyIG51bV9jaGFyc191bnRpbF9kZWxpbWl0ZXJcbiAgICBkb25lO1xuICAgIGlmIGhhc19zaWduIHRoZW4gQnl0ZXMuc2V0IG91dHB1dCAwIGlucHV0LlswXTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOm91dHB1dClcbjs7XG5cbmxldCBpbnNlcnRfZGVsaW1pdGVyIGlucHV0IH5kZWxpbWl0ZXIgPVxuICBpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5IGlucHV0IH5kZWxpbWl0ZXIgfmNoYXJzX3Blcl9kZWxpbWl0ZXI6M1xuOztcblxubGV0IGluc2VydF91bmRlcnNjb3JlcyBpbnB1dCA9IGluc2VydF9kZWxpbWl0ZXIgaW5wdXQgfmRlbGltaXRlcjonXydcbmxldCBzZXhwX29mX2ludF9zdHlsZSA9IFNleHAub2ZfaW50X3N0eWxlXG5cbm1vZHVsZSBNYWtlIChJIDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgb3BlbiBJXG5cbiAgbGV0IGNoYXJzX3Blcl9kZWxpbWl0ZXIgPSAzXG5cbiAgbGV0IHRvX3N0cmluZ19odW0gPyhkZWxpbWl0ZXIgPSAnXycpIHQgPVxuICAgIGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgKHRvX3N0cmluZyB0KSB+ZGVsaW1pdGVyIH5jaGFyc19wZXJfZGVsaW1pdGVyXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCB0ID1cbiAgICBsZXQgcyA9IHRvX3N0cmluZyB0IGluXG4gICAgU2V4cC5BdG9tXG4gICAgICAobWF0Y2ggIXNleHBfb2ZfaW50X3N0eWxlIHdpdGhcbiAgICAgICB8IGBVbmRlcnNjb3JlcyAtPiBpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5IHMgfmNoYXJzX3Blcl9kZWxpbWl0ZXIgfmRlbGltaXRlcjonXydcbiAgICAgICB8IGBOb191bmRlcnNjb3JlcyAtPiBzKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlX2hleCAoSSA6IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG4gICAgaW5jbHVkZSBQcHhfaGFzaF9saWIuSGFzaGFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIHRvX3N0cmluZyA6IHQgLT4gc3RyaW5nXG4gICAgdmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiB0XG4gICAgdmFsIHplcm8gOiB0XG4gICAgdmFsICggPCApIDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgbmVnIDogdCAtPiB0XG4gICAgdmFsIG1vZHVsZV9uYW1lIDogc3RyaW5nXG4gIGVuZCkgPVxuc3RydWN0XG4gIG1vZHVsZSBUX2hleCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IEkudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxuICAgIGxldCBjb21wYXJlID0gKEkuY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBJLmhhc2hfZm9sZF90XG5cbiAgICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgICBsZXQgZnVuYyA9IEkuaGFzaCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgY2hhcnNfcGVyX2RlbGltaXRlciA9IDRcblxuICAgIGxldCB0b19zdHJpbmcnID9kZWxpbWl0ZXIgdCA9XG4gICAgICBsZXQgbWFrZV9zdWZmaXggPVxuICAgICAgICBtYXRjaCBkZWxpbWl0ZXIgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gSS50b19zdHJpbmdcbiAgICAgICAgfCBTb21lIGRlbGltaXRlciAtPlxuICAgICAgICAgIGZ1biB0IC0+IGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgKEkudG9fc3RyaW5nIHQpIH5kZWxpbWl0ZXIgfmNoYXJzX3Blcl9kZWxpbWl0ZXJcbiAgICAgIGluXG4gICAgICBpZiBJLiggPCApIHQgSS56ZXJvIHRoZW4gXCItMHhcIiBeIG1ha2Vfc3VmZml4IChJLm5lZyB0KSBlbHNlIFwiMHhcIiBeIG1ha2Vfc3VmZml4IHRcbiAgICA7O1xuXG4gICAgbGV0IHRvX3N0cmluZyB0ID0gdG9fc3RyaW5nJyB0ID9kZWxpbWl0ZXI6Tm9uZVxuICAgIGxldCB0b19zdHJpbmdfaHVtID8oZGVsaW1pdGVyID0gJ18nKSB0ID0gdG9fc3RyaW5nJyB0IH5kZWxpbWl0ZXJcblxuICAgIGxldCBpbnZhbGlkIHN0ciA9XG4gICAgICBQcmludGYuZmFpbHdpdGhmIFwiJXMub2Zfc3RyaW5nOiBpbnZhbGlkIGlucHV0ICVTXCIgSS5tb2R1bGVfbmFtZSBzdHIgKClcbiAgICA7O1xuXG4gICAgbGV0IG9mX3N0cmluZ193aXRoX2RlbGltaXRlciBzdHIgPVxuICAgICAgSS5vZl9zdHJpbmcgKFN0cmluZy5maWx0ZXIgc3RyIH5mOihmdW4gYyAtPiBDaGFyLiggPD4gKSBjICdfJykpXG4gICAgOztcblxuICAgIGxldCBvZl9zdHJpbmcgc3RyID1cbiAgICAgIGxldCBtb2R1bGUgTCA9IEhleF9sZXhlciBpblxuICAgICAgbGV0IGxleCA9IENhbWwuTGV4aW5nLmZyb21fc3RyaW5nIHN0ciBpblxuICAgICAgbGV0IHJlc3VsdCA9IE9wdGlvbi50cnlfd2l0aCAoZnVuICgpIC0+IEwucGFyc2VfaGV4IGxleCkgaW5cbiAgICAgIGlmIGxleC5sZXhfY3Vycl9wb3MgPSBsZXgubGV4X2J1ZmZlcl9sZW5cbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gaW52YWxpZCBzdHJcbiAgICAgICAgfCBTb21lIChOZWcgYm9keSkgLT4gSS5uZWcgKG9mX3N0cmluZ193aXRoX2RlbGltaXRlciBib2R5KVxuICAgICAgICB8IFNvbWUgKFBvcyBib2R5KSAtPiBvZl9zdHJpbmdfd2l0aF9kZWxpbWl0ZXIgYm9keSlcbiAgICAgIGVsc2UgaW52YWxpZCBzdHJcbiAgICA7O1xuXG4gICAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICAgIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgU3RyaW5nLnRfc2V4cF9ncmFtbWFyXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIEhleCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVF9oZXhcbiAgICBpbmNsdWRlIFNleHBhYmxlLk9mX3N0cmluZ2FibGUgKFRfaGV4KVxuICBlbmRcbmVuZFxuIiwiKCogVGhpcyBmaWxlIHdhcyBhdXRvZ2VuZXJhdGVkIGJ5IC4uL2dlbmVyYXRlL2dlbmVyYXRlX3Bvd19vdmVyZmxvd19ib3VuZHMuZXhlICopXG5cbm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcblxuKCogV2UgaGF2ZSB0byB1c2UgSW50NjQudG9faW50X2V4biBpbnN0ZWFkIG9mIGludCBjb25zdGFudHMgdG8gbWFrZVxuICAgc3VyZSB0aGF0IGZpbGUgY2FuIGJlIHByZXByb2Nlc3NlZCBvbiAzMi1iaXQgbWFjaGluZXMuICopXG5cbmxldCBvdmVyZmxvd19ib3VuZF9tYXhfaW50MzJfdmFsdWUgOiBpbnQzMiA9XG4gIDIxNDc0ODM2NDdsXG5cbmxldCBpbnQzMl9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMgOiBpbnQzMiBhcnJheSA9XG4gIFt8IDIxNDc0ODM2NDdsXG4gIDsgIDIxNDc0ODM2NDdsXG4gIDsgIDQ2MzQwbFxuICA7ICAxMjkwbFxuICA7ICAyMTVsXG4gIDsgIDczbFxuICA7ICAzNWxcbiAgOyAgMjFsXG4gIDsgIDE0bFxuICA7ICAxMGxcbiAgOyAgOGxcbiAgOyAgN2xcbiAgOyAgNWxcbiAgOyAgNWxcbiAgOyAgNGxcbiAgOyAgNGxcbiAgOyAgM2xcbiAgOyAgM2xcbiAgOyAgM2xcbiAgOyAgM2xcbiAgOyAgMmxcbiAgOyAgMmxcbiAgOyAgMmxcbiAgOyAgMmxcbiAgOyAgMmxcbiAgOyAgMmxcbiAgOyAgMmxcbiAgOyAgMmxcbiAgOyAgMmxcbiAgOyAgMmxcbiAgOyAgMmxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgOyAgMWxcbiAgfF1cblxubGV0IG92ZXJmbG93X2JvdW5kX21heF9pbnRfdmFsdWUgOiBpbnQgPVxuICAoLTEpIGxzciAxXG5cbmxldCBpbnRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50IGFycmF5ID1cbiAgbWF0Y2ggSW50X2NvbnZlcnNpb25zLm51bV9iaXRzX2ludCB3aXRoXG4gIHwgMzIgLT4gQXJyYXkubWFwIGludDMyX3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyB+ZjpDYW1sLkludDMyLnRvX2ludFxuICB8IDYzIC0+XG4gICAgW3wgQ2FtbC5JbnQ2NC50b19pbnQgNDYxMTY4NjAxODQyNzM4NzkwM0xcbiAgICA7ICBDYW1sLkludDY0LnRvX2ludCA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuICAgIDsgIENhbWwuSW50NjQudG9faW50IDIxNDc0ODM2NDdMXG4gICAgOyAgMTY2NDUxMFxuICAgIDsgIDQ2MzQwXG4gICAgOyAgNTQwNFxuICAgIDsgIDEyOTBcbiAgICA7ICA0NjNcbiAgICA7ICAyMTVcbiAgICA7ICAxMThcbiAgICA7ICA3M1xuICAgIDsgIDQ5XG4gICAgOyAgMzVcbiAgICA7ICAyN1xuICAgIDsgIDIxXG4gICAgOyAgMTdcbiAgICA7ICAxNFxuICAgIDsgIDEyXG4gICAgOyAgMTBcbiAgICA7ICA5XG4gICAgOyAgOFxuICAgIDsgIDdcbiAgICA7ICA3XG4gICAgOyAgNlxuICAgIDsgIDVcbiAgICA7ICA1XG4gICAgOyAgNVxuICAgIDsgIDRcbiAgICA7ICA0XG4gICAgOyAgNFxuICAgIDsgIDRcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICB8XVxuICB8IDMxIC0+XG4gICAgW3wgMTA3Mzc0MTgyM1xuICAgIDsgIDEwNzM3NDE4MjNcbiAgICA7ICAzMjc2N1xuICAgIDsgIDEwMjNcbiAgICA7ICAxODFcbiAgICA7ICA2M1xuICAgIDsgIDMxXG4gICAgOyAgMTlcbiAgICA7ICAxM1xuICAgIDsgIDEwXG4gICAgOyAgN1xuICAgIDsgIDZcbiAgICA7ICA1XG4gICAgOyAgNFxuICAgIDsgIDRcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgfF1cbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludDYzX29uX2ludDY0X3ZhbHVlIDogaW50NjQgPVxuICA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuXG5sZXQgaW50NjNfb25faW50NjRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50NjQgYXJyYXkgPVxuICBbfCA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuICA7ICA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuICA7ICAyMTQ3NDgzNjQ3TFxuICA7ICAxNjY0NTEwTFxuICA7ICA0NjM0MExcbiAgOyAgNTQwNExcbiAgOyAgMTI5MExcbiAgOyAgNDYzTFxuICA7ICAyMTVMXG4gIDsgIDExOExcbiAgOyAgNzNMXG4gIDsgIDQ5TFxuICA7ICAzNUxcbiAgOyAgMjdMXG4gIDsgIDIxTFxuICA7ICAxN0xcbiAgOyAgMTRMXG4gIDsgIDEyTFxuICA7ICAxMExcbiAgOyAgOUxcbiAgOyAgOExcbiAgOyAgN0xcbiAgOyAgN0xcbiAgOyAgNkxcbiAgOyAgNUxcbiAgOyAgNUxcbiAgOyAgNUxcbiAgOyAgNExcbiAgOyAgNExcbiAgOyAgNExcbiAgOyAgNExcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMUxcbiAgOyAgMUxcbiAgfF1cblxubGV0IG92ZXJmbG93X2JvdW5kX21heF9pbnQ2NF92YWx1ZSA6IGludDY0ID1cbiAgOTIyMzM3MjAzNjg1NDc3NTgwN0xcblxubGV0IGludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludDY0IGFycmF5ID1cbiAgW3wgOTIyMzM3MjAzNjg1NDc3NTgwN0xcbiAgOyAgOTIyMzM3MjAzNjg1NDc3NTgwN0xcbiAgOyAgMzAzNzAwMDQ5OUxcbiAgOyAgMjA5NzE1MUxcbiAgOyAgNTUxMDhMXG4gIDsgIDYyMDhMXG4gIDsgIDE0NDhMXG4gIDsgIDUxMUxcbiAgOyAgMjM0TFxuICA7ICAxMjdMXG4gIDsgIDc4TFxuICA7ICA1MkxcbiAgOyAgMzhMXG4gIDsgIDI4TFxuICA7ICAyMkxcbiAgOyAgMThMXG4gIDsgIDE1TFxuICA7ICAxM0xcbiAgOyAgMTFMXG4gIDsgIDlMXG4gIDsgIDhMXG4gIDsgIDdMXG4gIDsgIDdMXG4gIDsgIDZMXG4gIDsgIDZMXG4gIDsgIDVMXG4gIDsgIDVMXG4gIDsgIDVMXG4gIDsgIDRMXG4gIDsgIDRMXG4gIDsgIDRMXG4gIDsgIDRMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDNMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDJMXG4gIDsgIDFMXG4gIHxdXG5cbmxldCBpbnQ2NF9uZWdhdGl2ZV9vdmVyZmxvd19ib3VuZHMgOiBpbnQ2NCBhcnJheSA9XG4gIFt8IC05MjIzMzcyMDM2ODU0Nzc1ODA3TFxuICA7ICAtOTIyMzM3MjAzNjg1NDc3NTgwN0xcbiAgOyAgLTMwMzcwMDA0OTlMXG4gIDsgIC0yMDk3MTUxTFxuICA7ICAtNTUxMDhMXG4gIDsgIC02MjA4TFxuICA7ICAtMTQ0OExcbiAgOyAgLTUxMUxcbiAgOyAgLTIzNExcbiAgOyAgLTEyN0xcbiAgOyAgLTc4TFxuICA7ICAtNTJMXG4gIDsgIC0zOExcbiAgOyAgLTI4TFxuICA7ICAtMjJMXG4gIDsgIC0xOExcbiAgOyAgLTE1TFxuICA7ICAtMTNMXG4gIDsgIC0xMUxcbiAgOyAgLTlMXG4gIDsgIC04TFxuICA7ICAtN0xcbiAgOyAgLTdMXG4gIDsgIC02TFxuICA7ICAtNkxcbiAgOyAgLTVMXG4gIDsgIC01TFxuICA7ICAtNUxcbiAgOyAgLTRMXG4gIDsgIC00TFxuICA7ICAtNExcbiAgOyAgLTRMXG4gIDsgIC0zTFxuICA7ICAtM0xcbiAgOyAgLTNMXG4gIDsgIC0zTFxuICA7ICAtM0xcbiAgOyAgLTNMXG4gIDsgIC0zTFxuICA7ICAtM0xcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMUxcbiAgfF1cbiIsIm9wZW4hIEltcG9ydFxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxubGV0IG5lZ2F0aXZlX2V4cG9uZW50ICgpID0gUHJpbnRmLmludmFsaWRfYXJnZiBcImV4cG9uZW50IGNhbiBub3QgYmUgbmVnYXRpdmVcIiAoKVxubGV0IG92ZXJmbG93ICgpID0gUHJpbnRmLmludmFsaWRfYXJnZiBcImludGVnZXIgb3ZlcmZsb3cgaW4gcG93XCIgKClcblxuKCogVG8gaW1wbGVtZW50IFtpbnQ2NF9wb3ddLCB3ZSB1c2UgQyBjb2RlIHJhdGhlciB0aGFuIE9DYW1sIHRvIGVsaW1pbmF0ZSBhbGxvY2F0aW9uLiAqKVxuZXh0ZXJuYWwgaW50X21hdGhfaW50X3BvdyA6IGludCAtPiBpbnQgLT4gaW50ID0gXCJCYXNlX2ludF9tYXRoX2ludF9wb3dfc3R1YlwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBpbnRfbWF0aF9pbnQ2NF9wb3cgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9wb3dfc3R1YlwiXG5cbmxldCBpbnRfcG93IGJhc2UgZXhwb25lbnQgPVxuICBpZiBleHBvbmVudCA8IDAgdGhlbiBuZWdhdGl2ZV9leHBvbmVudCAoKTtcbiAgaWYgYWJzIGJhc2UgPiAxXG4gICYmIChleHBvbmVudCA+IDYzXG4gICAgICB8fCBhYnMgYmFzZSA+IFBvd19vdmVyZmxvd19ib3VuZHMuaW50X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcy4oZXhwb25lbnQpKVxuICB0aGVuIG92ZXJmbG93ICgpO1xuICBpbnRfbWF0aF9pbnRfcG93IGJhc2UgZXhwb25lbnRcbjs7XG5cbm1vZHVsZSBJbnQ2NF93aXRoX2NvbXBhcmlzb25zID0gc3RydWN0XG4gIGluY2x1ZGUgQ2FtbC5JbnQ2NFxuXG4gIGV4dGVybmFsICggPCApIDogaW50NjQgLT4gaW50NjQgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+ICkgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuICBleHRlcm5hbCAoID49ICkgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBib29sID0gXCIlZ3JlYXRlcmVxdWFsXCJcbmVuZFxuXG4oKiB3ZSBkb24ndCBkbyBbYWJzXSBpbiBpbnQ2NCBjYXNlIHRvIGF2b2lkIGFsbG9jYXRpb24gKilcbmxldCBpbnQ2NF9wb3cgYmFzZSBleHBvbmVudCA9XG4gIGxldCBvcGVuIEludDY0X3dpdGhfY29tcGFyaXNvbnMgaW5cbiAgaWYgZXhwb25lbnQgPCAwTCB0aGVuIG5lZ2F0aXZlX2V4cG9uZW50ICgpO1xuICBpZiAoYmFzZSA+IDFMIHx8IGJhc2UgPCAtMUwpXG4gICYmIChleHBvbmVudCA+IDYzTFxuICAgICAgfHwgKGJhc2UgPj0gMExcbiAgICAgICAgICAmJiBiYXNlID4gUG93X292ZXJmbG93X2JvdW5kcy5pbnQ2NF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMuKHRvX2ludCBleHBvbmVudClcbiAgICAgICAgIClcbiAgICAgIHx8IChiYXNlIDwgMExcbiAgICAgICAgICAmJiBiYXNlIDwgUG93X292ZXJmbG93X2JvdW5kcy5pbnQ2NF9uZWdhdGl2ZV9vdmVyZmxvd19ib3VuZHMuKHRvX2ludCBleHBvbmVudClcbiAgICAgICAgICkpXG4gIHRoZW4gb3ZlcmZsb3cgKCk7XG4gIGludF9tYXRoX2ludDY0X3BvdyBiYXNlIGV4cG9uZW50XG47O1xuXG5sZXQgaW50NjNfcG93X29uX2ludDY0IGJhc2UgZXhwb25lbnQgPVxuICBsZXQgb3BlbiBJbnQ2NF93aXRoX2NvbXBhcmlzb25zIGluXG4gIGlmIGV4cG9uZW50IDwgMEwgdGhlbiBuZWdhdGl2ZV9leHBvbmVudCAoKTtcbiAgaWYgYWJzIGJhc2UgPiAxTFxuICAmJiAoZXhwb25lbnQgPiA2M0xcbiAgICAgIHx8IGFicyBiYXNlXG4gICAgICAgICA+IFBvd19vdmVyZmxvd19ib3VuZHMuaW50NjNfb25faW50NjRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzLih0b19pbnQgZXhwb25lbnQpXG4gICAgIClcbiAgdGhlbiBvdmVyZmxvdyAoKTtcbiAgaW50X21hdGhfaW50NjRfcG93IGJhc2UgZXhwb25lbnRcbjs7XG5cbm1vZHVsZSB0eXBlIE1ha2VfYXJnID0gc2lnXG4gIHR5cGUgdFxuXG4gIGluY2x1ZGUgRmxvYXRhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuICBpbmNsdWRlIFN0cmluZ2FibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsICggKyApIDogdCAtPiB0IC0+IHRcbiAgdmFsICggLSApIDogdCAtPiB0IC0+IHRcbiAgdmFsICggKiApIDogdCAtPiB0IC0+IHRcbiAgdmFsICggLyApIDogdCAtPiB0IC0+IHRcbiAgdmFsICggfi0gKSA6IHQgLT4gdFxuXG4gIGluY2x1ZGUgQ29tcGFyaXNvbnMuSW5maXggd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCBhYnMgOiB0IC0+IHRcbiAgdmFsIG5lZyA6IHQgLT4gdFxuICB2YWwgemVybyA6IHRcbiAgdmFsIG9mX2ludF9leG4gOiBpbnQgLT4gdFxuICB2YWwgcmVtIDogdCAtPiB0IC0+IHRcbmVuZFxuXG5tb2R1bGUgTWFrZSAoWCA6IE1ha2VfYXJnKSA9IHN0cnVjdFxuICBvcGVuIFhcblxuICBsZXQgKCAlICkgeCB5ID1cbiAgICBpZiB5IDw9IHplcm9cbiAgICB0aGVuXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCIlcyAlJSAlcyBpbiBjb3JlX2ludC5tbDogbW9kdWx1cyBzaG91bGQgYmUgcG9zaXRpdmVcIlxuICAgICAgICAodG9fc3RyaW5nIHgpXG4gICAgICAgICh0b19zdHJpbmcgeSlcbiAgICAgICAgKCk7XG4gICAgbGV0IHJ2YWwgPSBYLnJlbSB4IHkgaW5cbiAgICBpZiBydmFsIDwgemVybyB0aGVuIHJ2YWwgKyB5IGVsc2UgcnZhbFxuICA7O1xuXG4gIGxldCBvbmUgPSBvZl9pbnRfZXhuIDFcblxuICBsZXQgKCAvJSApIHggeSA9XG4gICAgaWYgeSA8PSB6ZXJvXG4gICAgdGhlblxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiJXMgLyUlICVzIGluIGNvcmVfaW50Lm1sOiBkaXZpc29yIHNob3VsZCBiZSBwb3NpdGl2ZVwiXG4gICAgICAgICh0b19zdHJpbmcgeClcbiAgICAgICAgKHRvX3N0cmluZyB5KVxuICAgICAgICAoKTtcbiAgICBpZiB4IDwgemVybyB0aGVuICgoeCArIG9uZSkgLyB5KSAtIG9uZSBlbHNlIHggLyB5XG4gIDs7XG5cbiAgKCoqIGZsb2F0IGRpdmlzaW9uIG9mIGludGVnZXJzICopXG4gIGxldCAoIC8vICkgeCB5ID0gdG9fZmxvYXQgeCAvLiB0b19mbG9hdCB5XG5cbiAgbGV0IHJvdW5kX2Rvd24gaSB+dG9fbXVsdGlwbGVfb2Y6bW9kdWx1cyA9IGkgLSAoaSAlIG1vZHVsdXMpXG5cbiAgbGV0IHJvdW5kX3VwIGkgfnRvX211bHRpcGxlX29mOm1vZHVsdXMgPVxuICAgIGxldCByZW1haW5kZXIgPSBpICUgbW9kdWx1cyBpblxuICAgIGlmIHJlbWFpbmRlciA9IHplcm8gdGhlbiBpIGVsc2UgaSArIG1vZHVsdXMgLSByZW1haW5kZXJcbiAgOztcblxuICBsZXQgcm91bmRfdG93YXJkc196ZXJvIGkgfnRvX211bHRpcGxlX29mID1cbiAgICBpZiBpID0gemVyb1xuICAgIHRoZW4gemVyb1xuICAgIGVsc2UgaWYgaSA+IHplcm9cbiAgICB0aGVuIHJvdW5kX2Rvd24gaSB+dG9fbXVsdGlwbGVfb2ZcbiAgICBlbHNlIHJvdW5kX3VwIGkgfnRvX211bHRpcGxlX29mXG4gIDs7XG5cbiAgbGV0IHJvdW5kX25lYXJlc3QgaSB+dG9fbXVsdGlwbGVfb2Y6bW9kdWx1cyA9XG4gICAgbGV0IHJlbWFpbmRlciA9IGkgJSBtb2R1bHVzIGluXG4gICAgbGV0IG1vZHVsdXNfbWludXNfcmVtYWluZGVyID0gbW9kdWx1cyAtIHJlbWFpbmRlciBpblxuICAgIGlmIG1vZHVsdXNfbWludXNfcmVtYWluZGVyIDw9IHJlbWFpbmRlclxuICAgIHRoZW4gaSArIG1vZHVsdXNfbWludXNfcmVtYWluZGVyXG4gICAgZWxzZSBpIC0gcmVtYWluZGVyXG4gIDs7XG5cbiAgbGV0IHJvdW5kID8oZGlyID0gYE5lYXJlc3QpIGkgfnRvX211bHRpcGxlX29mID1cbiAgICBtYXRjaCBkaXIgd2l0aFxuICAgIHwgYE5lYXJlc3QgLT4gcm91bmRfbmVhcmVzdCBpIH50b19tdWx0aXBsZV9vZlxuICAgIHwgYERvd24gLT4gcm91bmRfZG93biBpIH50b19tdWx0aXBsZV9vZlxuICAgIHwgYFVwIC0+IHJvdW5kX3VwIGkgfnRvX211bHRpcGxlX29mXG4gICAgfCBgWmVybyAtPiByb3VuZF90b3dhcmRzX3plcm8gaSB+dG9fbXVsdGlwbGVfb2ZcbiAgOztcbmVuZFxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgaW50X3BvdyA9IGludF9wb3dcbiAgbGV0IGludDY0X3BvdyA9IGludDY0X3Bvd1xuICBsZXQgaW50NjNfcG93X29uX2ludDY0ID0gaW50NjNfcG93X29uX2ludDY0XG5cbiAgbW9kdWxlIFBvd19vdmVyZmxvd19ib3VuZHMgPSBQb3dfb3ZlcmZsb3dfYm91bmRzXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiBDIHN0dWIgZm9yIGludCBwb3Bjb3VudCB0byB1c2UgdGhlIFBPUENOVCBpbnN0cnVjdGlvbiB3aGVyZSBwb3NzaWJsZSAqKVxuZXh0ZXJuYWwgaW50X3BvcGNvdW50IDogaW50IC0+IGludCA9IFwiQmFzZV9pbnRfbWF0aF9pbnRfcG9wY291bnRcIiBbQEBub2FsbG9jXVxuXG4oKiBUbyBtYWludGFpbiBqYXZhc2NyaXB0IGNvbXBhdGliaWxpdHkgYW5kIGVuYWJsZSB1bmJveGluZywgd2UgaW1wbGVtZW50IHBvcGNvdW50IGluXG4gICBPQ2FtbCByYXRoZXIgdGhhbiB1c2UgQyBzdHVicy4gSW1wbGVtZW50YXRpb24gYWRhcHRlZCBmcm9tOlxuICAgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFtbWluZ193ZWlnaHQjRWZmaWNpZW50X2ltcGxlbWVudGF0aW9uICopXG5sZXQgaW50NjRfcG9wY291bnQgPVxuICBsZXQgb3BlbiBDYW1sLkludDY0IGluXG4gIGxldCAoICsgKSA9IGFkZCBpblxuICBsZXQgKCAtICkgPSBzdWIgaW5cbiAgbGV0ICggKiApID0gbXVsIGluXG4gIGxldCAoIGxzciApID0gc2hpZnRfcmlnaHRfbG9naWNhbCBpblxuICBsZXQgKCBsYW5kICkgPSBsb2dhbmQgaW5cbiAgbGV0IG0xID0gMHg1NTU1NTU1NTU1NTU1NTU1TCBpblxuICAoKiAwYjAxMDEwMTAxLi4uICopXG4gIGxldCBtMiA9IDB4MzMzMzMzMzMzMzMzMzMzM0wgaW5cbiAgKCogMGIwMDExMDAxMS4uLiAqKVxuICBsZXQgbTQgPSAweDBmMGYwZjBmMGYwZjBmMGZMIGluXG4gICgqIDBiMDAwMDExMTEuLi4gKilcbiAgbGV0IGgwMSA9IDB4MDEwMTAxMDEwMTAxMDEwMUwgaW5cbiAgKCogMSBiaXQgc2V0IHBlciBieXRlICopXG4gIGZ1biBbQGlubGluZV0geCAtPlxuICAgICgqIGdhdGhlciB0aGUgYml0IGNvdW50IGZvciBldmVyeSBwYWlyIG9mIGJpdHMgKilcbiAgICBsZXQgeCA9IHggLSAoKHggbHNyIDEpIGxhbmQgbTEpIGluXG4gICAgKCogZ2F0aGVyIHRoZSBiaXQgY291bnQgZm9yIGV2ZXJ5IDQgYml0cyAqKVxuICAgIGxldCB4ID0gKHggbGFuZCBtMikgKyAoKHggbHNyIDIpIGxhbmQgbTIpIGluXG4gICAgKCogZ2F0aGVyIHRoZSBiaXQgY291bnQgZm9yIGV2ZXJ5IGJ5dGUgKilcbiAgICBsZXQgeCA9ICh4ICsgKHggbHNyIDQpKSBsYW5kIG00IGluXG4gICAgKCogc3VtIHRoZSBiaXQgY291bnRzIGluIHRoZSB0b3AgYnl0ZSBhbmQgc2hpZnQgaXQgZG93biAqKVxuICAgIHRvX2ludCAoKHggKiBoMDEpIGxzciA1Nilcbjs7XG5cbmxldCBpbnQzMl9wb3Bjb3VudCA9XG4gICgqIE9uIDY0LWJpdCBzeXN0ZW1zLCB0aGlzIGlzIGZhc3RlciB0aGFuIGltcGxlbWVudGluZyB1c2luZyBbaW50MzJdIGFyaXRobWV0aWMuICopXG4gIGxldCBtYXNrID0gMHhmZmZmX2ZmZmZMIGluXG4gIGZ1biBbQGlubGluZV0geCAtPiBpbnQ2NF9wb3Bjb3VudCAoQ2FtbC5JbnQ2NC5sb2dhbmQgKENhbWwuSW50NjQub2ZfaW50MzIgeCkgbWFzaylcbjs7XG5cbmxldCBuYXRpdmVpbnRfcG9wY291bnQgPVxuICBtYXRjaCBDYW1sLk5hdGl2ZWludC5zaXplIHdpdGhcbiAgfCAzMiAtPiBmdW4gW0BpbmxpbmVdIHggLT4gaW50MzJfcG9wY291bnQgKENhbWwuTmF0aXZlaW50LnRvX2ludDMyIHgpXG4gIHwgNjQgLT4gZnVuIFtAaW5saW5lXSB4IC0+IGludDY0X3BvcGNvdW50IChDYW1sLkludDY0Lm9mX25hdGl2ZWludCB4KVxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG47O1xuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIFNpZ24wXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChTaWduMClcblxuKCogT3BlbiBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbnMgc29cbiAgIHRoZXkgZG8gbm90IHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9uc1xuICAgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCB0b19mbG9hdCA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IC0xLlxuICB8IFplcm8gLT4gMC5cbiAgfCBQb3MgLT4gMS5cbjs7XG5cbmxldCBmbGlwID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gUG9zXG4gIHwgWmVybyAtPiBaZXJvXG4gIHwgUG9zIC0+IE5lZ1xuOztcblxubGV0ICggKiApIHQgdCcgPSBvZl9pbnQgKHRvX2ludCB0ICogdG9faW50IHQnKVxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhdCB0aGUgZW5kLCBhZnRlciBhbnlcbiAgIGZ1bmN0b3IgYXBwbGljYXRpb25zIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvXG4gICB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5IHRoaXNcbiAgIG1vZHVsZS4gKilcbmluY2x1ZGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgSW50X2ludGZcbmluY2x1ZGUgSW50MFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnQgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfaW50IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChpbnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfaW50IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGludF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgeCB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlIHggeVxuXG4gIGxldCBvZl9zdHJpbmcgcyA9XG4gICAgdHJ5IG9mX3N0cmluZyBzIHdpdGhcbiAgICB8IF8gLT4gUHJpbnRmLmZhaWx3aXRoZiBcIkludC5vZl9zdHJpbmc6ICVTXCIgcyAoKVxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbmVuZFxuXG5sZXQgbnVtX2JpdHMgPSBJbnRfY29udmVyc2lvbnMubnVtX2JpdHNfaW50XG5sZXQgZmxvYXRfbG93ZXJfYm91bmQgPSBGbG9hdDAubG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X3VwcGVyX2JvdW5kID0gRmxvYXQwLnVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCB0b19mbG9hdCA9IENhbWwuZmxvYXRfb2ZfaW50XG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkID0gQ2FtbC5pbnRfb2ZfZmxvYXRcblxubGV0IG9mX2Zsb2F0IGYgPVxuICBpZiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIGYgZmxvYXRfbG93ZXJfYm91bmRcbiAgJiYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBmIGZsb2F0X3VwcGVyX2JvdW5kXG4gIHRoZW4gQ2FtbC5pbnRfb2ZfZmxvYXQgZlxuICBlbHNlXG4gICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgXCJJbnQub2ZfZmxvYXQ6IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCBmKVxuICAgICAgKClcbjs7XG5cbmxldCB6ZXJvID0gMFxubGV0IG9uZSA9IDFcbmxldCBtaW51c19vbmUgPSAtMVxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCB6ZXJvID0gemVyb1xuICBlbmQpXG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5pbmNsdWRlIENvbnYuTWFrZSAoVClcblxuaW5jbHVkZSBDb252Lk1ha2VfaGV4IChzdHJ1Y3RcbiAgICBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICAgIHR5cGUgdCA9IGludCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxuICAgIGxldCBjb21wYXJlID0gKGNvbXBhcmVfaW50IDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIGhhc2hfZm9sZF9pbnRcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gaGFzaF9pbnQgaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gICAgbGV0IG5lZyA9ICggfi0gKVxuICAgIGxldCAoIDwgKSA9ICggPCApXG4gICAgbGV0IHRvX3N0cmluZyBpID0gUHJpbnRmLnNwcmludGYgXCIleFwiIGlcbiAgICBsZXQgb2Zfc3RyaW5nIHMgPSBDYW1sLlNjYW5mLnNzY2FuZiBzIFwiJXhcIiBGbi5pZFxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQuSGV4XCJcbiAgZW5kKVxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnRcIlxuICBlbmQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvXG4gICB0aGV5IGRvIG5vdCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnNcbiAgIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmV4dGVybmFsIHRvX2ludDMyX3RydW5jIDogdCAtPiBpbnQzMiA9IFwiJWludDMyX29mX2ludFwiXG5leHRlcm5hbCBvZl9pbnQzMl90cnVuYyA6IGludDMyIC0+IHQgPSBcIiVpbnQzMl90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfaW50NjRfdHJ1bmMgOiBpbnQ2NCAtPiB0ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIG9mX25hdGl2ZWludF90cnVuYyA6IG5hdGl2ZWludCAtPiB0ID0gXCIlbmF0aXZlaW50X3RvX2ludFwiXG5cbmxldCBwcmVkIGkgPSBpIC0gMVxubGV0IHN1Y2MgaSA9IGkgKyAxXG5sZXQgdG9faW50IGkgPSBpXG5sZXQgdG9faW50X2V4biA9IHRvX2ludFxubGV0IG9mX2ludCBpID0gaVxubGV0IG9mX2ludF9leG4gPSBvZl9pbnRcbmxldCBtYXhfdmFsdWUgPSBDYW1sLm1heF9pbnRcbmxldCBtaW5fdmFsdWUgPSBDYW1sLm1pbl9pbnRcbmxldCBtYXhfdmFsdWVfMzBfYml0cyA9IDB4M0ZGRl9GRkZGXG5sZXQgb2ZfaW50MzIgPSBDb252LmludDMyX3RvX2ludFxubGV0IG9mX2ludDMyX2V4biA9IENvbnYuaW50MzJfdG9faW50X2V4blxubGV0IHRvX2ludDMyID0gQ29udi5pbnRfdG9faW50MzJcbmxldCB0b19pbnQzMl9leG4gPSBDb252LmludF90b19pbnQzMl9leG5cbmxldCBvZl9pbnQ2NCA9IENvbnYuaW50NjRfdG9faW50XG5sZXQgb2ZfaW50NjRfZXhuID0gQ29udi5pbnQ2NF90b19pbnRfZXhuXG5sZXQgdG9faW50NjQgPSBDb252LmludF90b19pbnQ2NFxubGV0IG9mX25hdGl2ZWludCA9IENvbnYubmF0aXZlaW50X3RvX2ludFxubGV0IG9mX25hdGl2ZWludF9leG4gPSBDb252Lm5hdGl2ZWludF90b19pbnRfZXhuXG5sZXQgdG9fbmF0aXZlaW50ID0gQ29udi5pbnRfdG9fbmF0aXZlaW50XG5sZXQgdG9fbmF0aXZlaW50X2V4biA9IHRvX25hdGl2ZWludFxubGV0IGFicyB4ID0gYWJzIHhcblxuKCogbm90ZSB0aGF0IHJlbSBpcyBub3Qgc2FtZSBhcyAlICopXG5sZXQgcmVtIGEgYiA9IGEgbW9kIGJcbmxldCBpbmNyID0gQ2FtbC5pbmNyXG5sZXQgZGVjciA9IENhbWwuZGVjclxubGV0IHNoaWZ0X3JpZ2h0IGEgYiA9IGEgYXNyIGJcbmxldCBzaGlmdF9yaWdodF9sb2dpY2FsIGEgYiA9IGEgbHNyIGJcbmxldCBzaGlmdF9sZWZ0IGEgYiA9IGEgbHNsIGJcbmxldCBiaXRfbm90IGEgPSBsbm90IGFcbmxldCBiaXRfb3IgYSBiID0gYSBsb3IgYlxubGV0IGJpdF9hbmQgYSBiID0gYSBsYW5kIGJcbmxldCBiaXRfeG9yIGEgYiA9IGEgbHhvciBiXG5sZXQgcG93ID0gSW50X21hdGguUHJpdmF0ZS5pbnRfcG93XG5sZXQgKCAqKiApIGIgZSA9IHBvdyBiIGVcblxubW9kdWxlIFBvdzIgPSBzdHJ1Y3RcbiAgb3BlbiEgSW1wb3J0XG5cbiAgbGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbiAgbGV0IG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKSA9XG4gICAgUHJpbnRmLmludmFsaWRfYXJnZiBcImFyZ3VtZW50IG11c3QgYmUgc3RyaWN0bHkgcG9zaXRpdmVcIiAoKVxuICA7O1xuXG5cbiAgKCoqIFwiY2VpbGluZyBwb3dlciBvZiAyXCIgLSBMZWFzdCBwb3dlciBvZiAyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgY2VpbF9wb3cyIHggPVxuICAgIGlmIHggPD0gMCB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IHggLSAxIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICAoKiBUaGUgbmV4dCBsaW5lIGlzIHN1cGVyZmx1b3VzIG9uIDMyLWJpdCBhcmNoaXRlY3R1cmVzLCBidXQgaXQncyBmYXN0ZXIgdG8gZG8gaXRcbiAgICAgICBhbnl3YXkgdGhhbiB0byBicmFuY2ggKilcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICB4ICsgMVxuICA7O1xuXG4gICgqKiBcImZsb29yIHBvd2VyIG9mIDJcIiAtIExhcmdlc3QgcG93ZXIgb2YgMiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGZsb29yX3BvdzIgeCA9XG4gICAgaWYgeCA8PSAwIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgKCogVGhlIG5leHQgbGluZSBpcyBzdXBlcmZsdW91cyBvbiAzMi1iaXQgYXJjaGl0ZWN0dXJlcywgYnV0IGl0J3MgZmFzdGVyIHRvIGRvIGl0XG4gICAgICAgYW55d2F5IHRoYW4gdG8gYnJhbmNoICopXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgeCAtICh4IGxzciAxKVxuICA7O1xuXG4gIGxldCBpc19wb3cyIHggPVxuICAgIGlmIHggPD0gMCB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICB4IGxhbmQgKHggLSAxKSA9IDBcbiAgOztcblxuICAoKiBDIHN0dWJzIGZvciBpbnQgY2x6IGFuZCBjdHogdG8gdXNlIHRoZSBDTFovQlNSL0NUWi9CU0YgaW5zdHJ1Y3Rpb24gd2hlcmUgcG9zc2libGUgKilcbiAgZXh0ZXJuYWwgY2x6XG4gICAgOiAgKCogTm90ZSB0aGF0IHdlIHBhc3MgdGhlIHRhZ2dlZCBpbnQgaGVyZS4gU2VlIGludF9tYXRoX3N0dWJzLmMgZm9yIGRldGFpbHMgb24gd2h5XG4gICAgICAgICAgdGhpcyBpcyBjb3JyZWN0LiAqKVxuICAgIGludFxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnRfY2x6XCIgXCJCYXNlX2ludF9tYXRoX2ludF9jbHpfdW50YWdnZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGN0elxuICAgIDogIChpbnRbQHVudGFnZ2VkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50X2N0elwiIFwiQmFzZV9pbnRfbWF0aF9pbnRfY3R6X3VudGFnZ2VkXCJcbiAgW0BAbm9hbGxvY11cblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBmbG9vcl9sb2cyIGkgPVxuICAgIGlmIGkgPD0gMFxuICAgIHRoZW4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0ludC5mbG9vcl9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl9pbnQgaSBdKTtcbiAgICBudW1fYml0cyAtIDEgLSBjbHogaVxuICA7O1xuXG4gIGxldCBjZWlsX2xvZzIgaSA9XG4gICAgaWYgaSA8PSAwXG4gICAgdGhlbiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSW50LmNlaWxfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50IGkgXSk7XG4gICAgaWYgaSA9IDEgdGhlbiAwIGVsc2UgbnVtX2JpdHMgLSBjbHogKGkgLSAxKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgUG93MlxuXG5sZXQgc2lnbiA9IFNpZ24ub2ZfaW50XG5sZXQgcG9wY291bnQgPSBQb3Bjb3VudC5pbnRfcG9wY291bnRcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGV4dGVybmFsICggKyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuICBleHRlcm5hbCAoIC0gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbiAgZXh0ZXJuYWwgKCAqICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW11bGludFwiXG4gIGV4dGVybmFsICggLyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuICBleHRlcm5hbCAoIH4tICkgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcblxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IGFicyA9IGFic1xuXG4gIGV4dGVybmFsIG5lZyA6IHQgLT4gdCA9IFwiJW5lZ2ludFwiXG5cbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfaW50X2V4blxuZW5kXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGluY2x1ZGUgUHJlX09cblxuICBtb2R1bGUgRiA9IEludF9tYXRoLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgaW5jbHVkZSBQcmVfT1xuXG4gICAgICBsZXQgcmVtID0gcmVtXG4gICAgICBsZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxuICAgICAgbGV0IG9mX2Zsb2F0ID0gb2ZfZmxvYXRcbiAgICAgIGxldCBvZl9zdHJpbmcgPSBULm9mX3N0cmluZ1xuICAgICAgbGV0IHRvX3N0cmluZyA9IFQudG9fc3RyaW5nXG4gICAgZW5kKVxuXG4gIGluY2x1ZGUgRlxuXG4gIGV4dGVybmFsIGJzd2FwMTYgOiBpbnQgLT4gaW50ID0gXCIlYnN3YXAxNlwiXG5cbiAgKCogVGhlc2UgaW5saW5lZCB2ZXJzaW9ucyBvZiAoJSksICgvJSksIGFuZCAoLy8pIHBlcmZvcm0gYmV0dGVyIHRoYW4gdGhlaXIgZnVuY3Rvcml6ZWRcbiAgICAgY291bnRlcnBhcnRzIGluIFtGXSAoc2VlIGJlbmNobWFya3MgYmVsb3cpLlxuXG4gICAgIFRoZSByZWFzb24gdGhlc2UgZnVuY3Rpb25zIGFyZSBpbmxpbmVkIGluIFtJbnRdIGJ1dCBub3QgaW4gYW55IG9mIHRoZSBvdGhlciBpbnRlZ2VyXG4gICAgIG1vZHVsZXMgaXMgdGhhdCB0aGV5IGV4aXN0ZWQgaW4gW0ludF0gYW5kIFtJbnRdIGFsb25lIHByaW9yIHRvIHRoZSBpbnRyb2R1Y3Rpb24gb2ZcbiAgICAgdGhlIFtJbnRfbWF0aC5NYWtlXSBmdW5jdG9yLCBhbmQgd2UgZGlkbid0IHdhbnQgdG8gZGVncmFkZSB0aGVpciBwZXJmb3JtYW5jZS5cblxuICAgICBXZSB3b24ndCBwcmUtZW1wdGl2ZWx5IGRvIHRoZSBzYW1lIGZvciBuZXcgZnVuY3Rpb25zLCB1bmxlc3Mgc29tZW9uZSBjYXJlcywgb24gYSBjYXNlXG4gICAgIGJ5IGNhc2UgZmFzaGlvbi4gICopXG5cbiAgbGV0ICggJSApIHggeSA9XG4gICAgaWYgeSA8PSB6ZXJvXG4gICAgdGhlblxuICAgICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgICBcIiVzICUlICVzIGluIGNvcmVfaW50Lm1sOiBtb2R1bHVzIHNob3VsZCBiZSBwb3NpdGl2ZVwiXG4gICAgICAgICh0b19zdHJpbmcgeClcbiAgICAgICAgKHRvX3N0cmluZyB5KVxuICAgICAgICAoKTtcbiAgICBsZXQgcnZhbCA9IHJlbSB4IHkgaW5cbiAgICBpZiBydmFsIDwgemVybyB0aGVuIHJ2YWwgKyB5IGVsc2UgcnZhbFxuICA7O1xuXG4gIGxldCAoIC8lICkgeCB5ID1cbiAgICBpZiB5IDw9IHplcm9cbiAgICB0aGVuXG4gICAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICAgIFwiJXMgLyUlICVzIGluIGNvcmVfaW50Lm1sOiBkaXZpc29yIHNob3VsZCBiZSBwb3NpdGl2ZVwiXG4gICAgICAgICh0b19zdHJpbmcgeClcbiAgICAgICAgKHRvX3N0cmluZyB5KVxuICAgICAgICAoKTtcbiAgICBpZiB4IDwgemVybyB0aGVuICgoeCArIG9uZSkgLyB5KSAtIG9uZSBlbHNlIHggLyB5XG4gIDs7XG5cbiAgbGV0ICggLy8gKSB4IHkgPSB0b19mbG9hdCB4IC8uIHRvX2Zsb2F0IHlcblxuICBleHRlcm5hbCAoIGxhbmQgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbiAgZXh0ZXJuYWwgKCBsb3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlb3JpbnRcIlxuICBleHRlcm5hbCAoIGx4b3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcblxuICBsZXQgbG5vdCA9IGxub3RcblxuICBleHRlcm5hbCAoIGxzbCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuICBleHRlcm5hbCAoIGxzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuICBleHRlcm5hbCAoIGFzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhc3JpbnRcIlxuZW5kXG5cbmluY2x1ZGUgT1xuXG4oKiBbSW50XSBhbmQgW0ludC5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSBPX0YgPSBPLkZcbmVuZFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3JcbiAgIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zXG4gICBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5IHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcblxubGV0IGZhaWx3aXRoZiA9IFByaW50Zi5mYWlsd2l0aGZcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBVY2hhcjBcblxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuVWNoYXJcIlxuICBsZXQgaGFzaF9mb2xkX3Qgc3RhdGUgdCA9IEhhc2guZm9sZF9pbnQgc3RhdGUgKHRvX2ludCB0KVxuICBsZXQgaGFzaCB0ID0gSGFzaC5ydW4gaGFzaF9mb2xkX3QgdFxuICBsZXQgdG9fc3RyaW5nIHQgPSBQcmludGYuc3ByaW50ZiBcIlUrJTA0WFwiICh0b19pbnQgdClcblxuICAoKiBEbyBub3QgYWN0dWFsbHkgZXhwb3J0IHRoaXMuIFNlZSBkaXNjdXNzaW9uIGluIHRoZSAubWxpICopXG5cbiAgbGV0IHNleHBfb2ZfdCB0ID0gU2V4cC5BdG9tICh0b19zdHJpbmcgdClcblxuICBsZXQgdF9vZl9zZXhwIHNleHAgPVxuICAgIG1hdGNoIHNleHAgd2l0aFxuICAgIHwgU2V4cC5MaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcIlVjaGFyLnRfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG4gICAgfCBTZXhwLkF0b20gcyAtPlxuICAgICAgKHRyeSBDYW1sLlNjYW5mLnNzY2FuZiBzIFwiVSslWFwiIChmdW4gaSAtPiBVY2hhcjAub2ZfaW50IGkpIHdpdGhcbiAgICAgICB8IF8gLT4gb2Zfc2V4cF9lcnJvciBcIlVjaGFyLnRfb2Zfc2V4cDogYXRvbSBvZiB0aGUgZm9ybSBVK1hYWFggbmVlZGVkXCIgc2V4cClcbiAgOztcblxuICBsZXQgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50ID1cbiAgICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIFN0cmluZy50X3NleHBfZ3JhbW1hclxuICA7O1xuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoVClcbmluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlIChUKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBVY2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBpbnRfaXNfc2NhbGFyID0gaXNfdmFsaWRcblxubGV0IHN1Y2NfZXhuIGMgPVxuICB0cnkgVWNoYXIwLnN1Y2MgYyB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBtc2cgLT4gZmFpbHdpdGhmIFwiVWNoYXIuc3VjY19leG46ICVzXCIgbXNnICgpXG47O1xuXG5sZXQgc3VjYyBjID1cbiAgdHJ5IFNvbWUgKFVjaGFyMC5zdWNjIGMpIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gTm9uZVxuOztcblxubGV0IHByZWRfZXhuIGMgPVxuICB0cnkgVWNoYXIwLnByZWQgYyB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBtc2cgLT4gZmFpbHdpdGhmIFwiVWNoYXIucHJlZF9leG46ICVzXCIgbXNnICgpXG47O1xuXG5sZXQgcHJlZCBjID1cbiAgdHJ5IFNvbWUgKFVjaGFyMC5wcmVkIGMpIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gTm9uZVxuOztcblxubGV0IG9mX3NjYWxhciBpID0gaWYgaW50X2lzX3NjYWxhciBpIHRoZW4gU29tZSAodW5zYWZlX29mX2ludCBpKSBlbHNlIE5vbmVcblxubGV0IG9mX3NjYWxhcl9leG4gaSA9XG4gIGlmIGludF9pc19zY2FsYXIgaVxuICB0aGVuIHVuc2FmZV9vZl9pbnQgaVxuICBlbHNlIGZhaWx3aXRoZiBcIlVjaGFyLm9mX2ludF9leG4gZ290IGEgaW52YWxpZCBVbmljb2RlIHNjYWxhciB2YWx1ZTogJTA0WFwiIGkgKClcbjs7XG5cbmxldCB0b19zY2FsYXIgdCA9IFVjaGFyMC50b19pbnQgdFxubGV0IHRvX2NoYXIgYyA9IGlmIGlzX2NoYXIgYyB0aGVuIFNvbWUgKHVuc2FmZV90b19jaGFyIGMpIGVsc2UgTm9uZVxuXG5sZXQgdG9fY2hhcl9leG4gYyA9XG4gIGlmIGlzX2NoYXIgY1xuICB0aGVuIHVuc2FmZV90b19jaGFyIGNcbiAgZWxzZSBmYWlsd2l0aGYgXCJVY2hhci50b19jaGFyX2V4biBnb3QgYSBub24gbGF0aW4tMSBjaGFyYWN0ZXI6IFUrJTA0WFwiICh0b19pbnQgYykgKClcbjs7XG5cbmxldCB1dGY4X2J5dGVfbGVuZ3RoIHVjaGFyID1cbiAgbGV0IGNvZGVwb2ludCA9IHRvX3NjYWxhciB1Y2hhciBpblxuICBpZiBJbnQuKCA8ICkgY29kZXBvaW50IDB4ODBcbiAgdGhlbiAxXG4gIGVsc2UgaWYgSW50LiggPCApIGNvZGVwb2ludCAweDgwMFxuICB0aGVuIDJcbiAgZWxzZSBpZiBJbnQuKCA8ICkgY29kZXBvaW50IDB4MTAwMDBcbiAgdGhlbiAzXG4gIGVsc2UgNFxuOztcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIFVjaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgKCdhLCAnYikgdCA9IFQgOiAoJ2EsICdhKSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG5sZXQgc2V4cF9vZl90IDpcbiAgJ2EgJ2IuXG4gICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICgnYSwgJ2IpIHQgLT4gU2V4cGxpYjAuU2V4cC50XG4gID1cbiAgZnVuICh0eXBlIGFfXzAwM18gYl9fMDA0XylcbiAgICAgIDogICgoYV9fMDAzXyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IChiX18wMDRfIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgICAtPiAoYV9fMDAzXywgYl9fMDA0XykgdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gICAgZnVuIF9vZl9hX18wMDFfIF9vZl9iX18wMDJfIFQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiVFwiXG47O1xuXG5bQEBAZW5kXVxuXG50eXBlICgnYSwgJ2IpIGVxdWFsID0gKCdhLCAnYikgdFxuXG5sZXQgcmVmbCA9IFRcbmxldCBzeW0gKHR5cGUgYSBiKSAoVCA6IChhLCBiKSB0KSA6IChiLCBhKSB0ID0gVFxubGV0IHRyYW5zICh0eXBlIGEgYiBjKSAoVCA6IChhLCBiKSB0KSAoVCA6IChiLCBjKSB0KSA6IChhLCBjKSB0ID0gVFxubGV0IGNvbnYgKHR5cGUgYSBiKSAoVCA6IChhLCBiKSB0KSAoYSA6IGEpIDogYiA9IGFcblxubW9kdWxlIExpZnQgKFggOiBzaWdcbiAgICB0eXBlICdhIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbGV0IGxpZnQgKHR5cGUgYSBiKSAoVCA6IChhLCBiKSB0KSA6IChhIFgudCwgYiBYLnQpIHQgPSBUXG5lbmRcblxubW9kdWxlIExpZnQyIChYIDogc2lnXG4gICAgdHlwZSAoJ2ExLCAnYTIpIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbGV0IGxpZnQgKHR5cGUgYTEgYjEgYTIgYjIpIChUIDogKGExLCBiMSkgdCkgKFQgOiAoYTIsIGIyKSB0KVxuICAgIDogKChhMSwgYTIpIFgudCwgKGIxLCBiMikgWC50KSB0XG4gICAgPVxuICAgIFRcbiAgOztcbmVuZFxuXG5tb2R1bGUgTGlmdDMgKFggOiBzaWdcbiAgICB0eXBlICgnYTEsICdhMiwgJ2EzKSB0XG4gIGVuZCkgPVxuc3RydWN0XG4gIGxldCBsaWZ0ICh0eXBlIGExIGIxIGEyIGIyIGEzIGIzKSAoVCA6IChhMSwgYjEpIHQpIChUIDogKGEyLCBiMikgdCkgKFQgOiAoYTMsIGIzKSB0KVxuICAgIDogKChhMSwgYTIsIGEzKSBYLnQsIChiMSwgYjIsIGIzKSBYLnQpIHRcbiAgICA9XG4gICAgVFxuICA7O1xuZW5kXG5cbmxldCBkZXR1cGxlMiAodHlwZSBhMSBhMiBiMSBiMikgKFQgOiAoYTEgKiBhMiwgYjEgKiBiMikgdCkgOiAoYTEsIGIxKSB0ICogKGEyLCBiMikgdCA9XG4gIFQsIFRcbjs7XG5cbmxldCB0dXBsZTIgKHR5cGUgYTEgYTIgYjEgYjIpIChUIDogKGExLCBiMSkgdCkgKFQgOiAoYTIsIGIyKSB0KSA6IChhMSAqIGEyLCBiMSAqIGIyKSB0ID0gVFxuXG5tb2R1bGUgdHlwZSBJbmplY3RpdmUgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIHN0cmlwIDogKCdhIHQsICdiIHQpIGVxdWFsIC0+ICgnYSwgJ2IpIGVxdWFsXG5lbmRcblxubW9kdWxlIHR5cGUgSW5qZWN0aXZlMiA9IHNpZ1xuICB0eXBlICgnYTEsICdhMikgdFxuXG4gIHZhbCBzdHJpcCA6ICgoJ2ExLCAnYTIpIHQsICgnYjEsICdiMikgdCkgZXF1YWwgLT4gKCdhMSwgJ2IxKSBlcXVhbCAqICgnYTIsICdiMikgZXF1YWxcbmVuZFxuXG5tb2R1bGUgQ29tcG9zaXRpb25fcHJlc2VydmVzX2luamVjdGl2aXR5IChNMSA6IEluamVjdGl2ZSkgKE0yIDogSW5qZWN0aXZlKSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBNMS50IE0yLnRcblxuICBsZXQgc3RyaXAgZSA9IE0xLnN0cmlwIChNMi5zdHJpcCBlKVxuZW5kXG5cbm1vZHVsZSBJZCA9IHN0cnVjdFxuICBtb2R1bGUgVWlkID0gSW50XG5cbiAgbW9kdWxlIFdpdG5lc3MgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgS2V5ID0gc3RydWN0XG4gICAgICB0eXBlIF8gdCA9IC4uXG4gICAgICB0eXBlIHR5cGVfd2l0bmVzc19pbnQgPSBbIGB0eXBlX3dpdG5lc3Mgb2YgaW50IF0gW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICAgIGxldCBzZXhwX29mX3R5cGVfd2l0bmVzc19pbnQgPVxuICAgICAgICAoZnVuIChgdHlwZV93aXRuZXNzIHZfXzAwNV8pIC0+XG4gICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInR5cGVfd2l0bmVzc1wiOyBzZXhwX29mX2ludCB2X18wMDVfIF1cbiAgICAgICAgICAgOiB0eXBlX3dpdG5lc3NfaW50IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIDs7XG5cbiAgICAgIFtAQEBlbmRdXG5cbiAgICAgIGxldCBzZXhwX29mX3QgX3NleHBfb2ZfYSB0ID1cbiAgICAgICAgYHR5cGVfd2l0bmVzc1xuICAgICAgICAgIChDYW1sLk9iai5FeHRlbnNpb25fY29uc3RydWN0b3IuaWQgKENhbWwuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5vZl92YWwgdCkpXG4gICAgICAgIHw+IHNleHBfb2ZfdHlwZV93aXRuZXNzX2ludFxuICAgICAgOztcbiAgICBlbmRcblxuICAgIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICAgIHR5cGUgdFxuICAgICAgdHlwZSBfIEtleS50ICs9IEtleSA6IHQgS2V5LnRcbiAgICBlbmRcblxuICAgIHR5cGUgJ2EgdCA9IChtb2R1bGUgUyB3aXRoIHR5cGUgdCA9ICdhKVxuXG4gICAgbGV0IHNleHBfb2ZfdCAodHlwZSBhKSBzZXhwX29mX2EgKG1vZHVsZSBNIDogUyB3aXRoIHR5cGUgdCA9IGEpID1cbiAgICAgIE0uS2V5IHw+IEtleS5zZXhwX29mX3Qgc2V4cF9vZl9hXG4gICAgOztcblxuICAgIGxldCBjcmVhdGUgKHR5cGUgdCkgKCkgPVxuICAgICAgbGV0IG1vZHVsZSBNID0gc3RydWN0XG4gICAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG4gICAgICAgIHR5cGUgXyBLZXkudCArPSBLZXkgOiB0IEtleS50XG4gICAgICBlbmRcbiAgICAgIGluXG4gICAgICAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gdClcbiAgICA7O1xuXG4gICAgbGV0IHVpZCAodHlwZSBhKSAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPVxuICAgICAgQ2FtbC5PYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLmlkIChDYW1sLk9iai5FeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsIE0uS2V5KVxuICAgIDs7XG5cbiAgICAoKiBXZSB3YW50IGEgY29uc3RhbnQgYWxsb2NhdGVkIG9uY2UgdGhhdCBbc2FtZV0gY2FuIHJldHVybiB3aGVuZXZlciBpdCBnZXRzIHRoZSBzYW1lXG4gICAgICAgd2l0bmVzc2VzLiAgSWYgd2Ugd3JpdGUgdGhlIGNvbnN0YW50IGluc2lkZSB0aGUgYm9keSBvZiBbc2FtZV0sIHRoZSBuYXRpdmUtY29kZVxuICAgICAgIGNvbXBpbGVyIHdpbGwgZG8gdGhlIHJpZ2h0IHRoaW5nIGFuZCBsaWZ0IGl0IG91dC4gIEJ1dCBmb3IgY2xhcml0eSBhbmQgcm9idXN0bmVzcyxcbiAgICAgICB3ZSBkbyBpdCBvdXJzZWx2ZXMuICopXG4gICAgbGV0IHNvbWVfdCA9IFNvbWUgVFxuXG4gICAgbGV0IHNhbWUgKHR5cGUgYSBiKSAoYSA6IGEgdCkgKGIgOiBiIHQpIDogKGEsIGIpIGVxdWFsIG9wdGlvbiA9XG4gICAgICBsZXQgbW9kdWxlIEEgPSAodmFsIGEgOiBTIHdpdGggdHlwZSB0ID0gYSkgaW5cbiAgICAgIGxldCBtb2R1bGUgQiA9ICh2YWwgYiA6IFMgd2l0aCB0eXBlIHQgPSBiKSBpblxuICAgICAgbWF0Y2ggQS5LZXkgd2l0aFxuICAgICAgfCBCLktleSAtPiBzb21lX3RcbiAgICAgIHwgXyAtPiBOb25lXG4gICAgOztcbiAgZW5kXG5cblxuICB0eXBlICdhIHQgPVxuICAgIHsgd2l0bmVzcyA6ICdhIFdpdG5lc3MudFxuICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgIDsgdG9fc2V4cCA6ICdhIC0+IFNleHAudFxuICAgIH1cblxuICBsZXQgc2V4cF9vZl90IF8geyB3aXRuZXNzOyBuYW1lOyB0b19zZXhwIH0gOiBTZXhwLnQgPVxuICAgIGlmIGFtX3Rlc3RpbmdcbiAgICB0aGVuIEF0b20gbmFtZVxuICAgIGVsc2VcbiAgICAgIExpc3RcbiAgICAgICAgWyBMaXN0IFsgQXRvbSBcIm5hbWVcIjsgQXRvbSBuYW1lIF1cbiAgICAgICAgOyBMaXN0IFsgQXRvbSBcIndpdG5lc3NcIjsgd2l0bmVzcyB8PiBXaXRuZXNzLnNleHBfb2ZfdCB0b19zZXhwIF1cbiAgICAgICAgXVxuICA7O1xuXG4gIGxldCB0b19zZXhwIHQgPSB0LnRvX3NleHBcbiAgbGV0IG5hbWUgdCA9IHQubmFtZVxuICBsZXQgY3JlYXRlIH5uYW1lIHRvX3NleHAgPSB7IHdpdG5lc3MgPSBXaXRuZXNzLmNyZWF0ZSAoKTsgbmFtZTsgdG9fc2V4cCB9XG4gIGxldCB1aWQgdCA9IFdpdG5lc3MudWlkIHQud2l0bmVzc1xuICBsZXQgaGFzaCB0ID0gdWlkIHRcbiAgbGV0IGhhc2hfZm9sZF90IHMgdCA9IGhhc2hfZm9sZF9pbnQgcyAodWlkIHQpXG4gIGxldCBzYW1lX3dpdG5lc3MgdDEgdDIgPSBXaXRuZXNzLnNhbWUgdDEud2l0bmVzcyB0Mi53aXRuZXNzXG4gIGxldCBzYW1lIHQxIHQyID0gT3B0aW9uLmlzX3NvbWUgKHNhbWVfd2l0bmVzcyB0MSB0MilcblxuICBsZXQgc2FtZV93aXRuZXNzX2V4biB0MSB0MiA9XG4gICAgbWF0Y2ggc2FtZV93aXRuZXNzIHQxIHQyIHdpdGhcbiAgICB8IFNvbWUgdyAtPiB3XG4gICAgfCBOb25lIC0+XG4gICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJUeXBlX2VxdWFsLklkLnNhbWVfd2l0bmVzc19leG4gZ290IGRpZmZlcmVudCBpZHNcIlxuICAgICAgICAgICBbICggXCJcIlxuICAgICAgICAgICAgICwgc2V4cF9vZl9wYWlyIChzZXhwX29mX3Qgc2V4cF9vZl9vcGFxdWUpIChzZXhwX29mX3Qgc2V4cF9vZl9vcGFxdWUpICh0MSwgdDIpXG4gICAgICAgICAgICAgKVxuICAgICAgICAgICBdKVxuICA7O1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxuKCoqIFsnYSBDaGVhcF9vcHRpb24udF0gaXMgbGlrZSBbJ2Egb3B0aW9uXSwgYnV0IGl0IGRvZXNuJ3QgYm94IFtzb21lIF9dIHZhbHVlcy5cblxuICAgIFRoZXJlIGFyZSBzZXZlcmFsIHRoaW5ncyB0aGF0IGFyZSB1bnNhZmUgYWJvdXQgaXQ6XG5cbiAgICAtIFtmbG9hdCB0IGFycmF5XSAob3IgYW55IGFycmF5LWJhY2tlZCBjb250YWluZXIpIGlzIG5vdCBtZW1vcnktc2FmZVxuICAgICAgYmVjYXVzZSBmbG9hdCBhcnJheSBvcHRpbWl6YXRpb24gaXMgaW5jb21wYXRpYmxlIHdpdGggdW5ib3hlZCBvcHRpb25cbiAgICAgIG9wdGltaXphdGlvbi4gWW91IGhhdmUgdG8gdXNlIFtVbmlmb3JtX2FycmF5LnRdIGluc3RlYWQgb2YgW2FycmF5XS5cblxuICAgIC0gTmVzdGVkIG9wdGlvbnMgKFsnYSB0IHRdKSBkb24ndCB3b3JrLiBUaGV5IGFyZSBiZWxpZXZlZCB0byBiZVxuICAgICAgbWVtb3J5LXNhZmUsIGJ1dCBub3QgcGFyYW1ldHJpYy5cblxuICAgIC0gQSByZWNvcmQgd2l0aCBbZmxvYXQgdF1zIGluIGl0IHNob3VsZCBiZSBzYWZlLCBidXQgaXQncyBvbmx5IFt0XSBiZWluZ1xuICAgICAgYWJzdHJhY3QgdGhhdCBnaXZlcyB5b3Ugc2FmZXR5LiBJZiB0aGUgY29tcGlsZXIgd2FzIHNtYXJ0IGVub3VnaCB0byBwZWVrXG4gICAgICB0aHJvdWdoIHRoZSBtb2R1bGUgc2lnbmF0dXJlIHRoZW4gaXQgY291bGQgZGVjaWRlIHRvIGNvbnN0cnVjdCBhIGZsb2F0XG4gICAgICBhcnJheSBpbnN0ZWFkLiAqKVxubW9kdWxlIENoZWFwX29wdGlvbiA9IHN0cnVjdFxuICAoKiBUaGlzIGlzIHRha2VuIGZyb20gY29yZS4gUmF0aGVyIHRoYW4gZXhwb3NlIGl0IGluIHRoZSBwdWJsaWMgaW50ZXJmYWNlIG9mIGJhc2UsIGp1c3RcbiAgICAga2VlcCBhIGNvcHkgYXJvdW5kIGhlcmUuICopXG4gIGxldCBwaHlzX3NhbWUgKHR5cGUgYSBiKSAoYSA6IGEpIChiIDogYikgPSBwaHlzX2VxdWFsIGEgKENhbWwuT2JqLm1hZ2ljIGIgOiBhKVxuXG4gIG1vZHVsZSBUMCA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIG5vbmUgOiBfIHRcbiAgICB2YWwgc29tZSA6ICdhIC0+ICdhIHRcbiAgICB2YWwgaXNfbm9uZSA6IF8gdCAtPiBib29sXG4gICAgdmFsIGlzX3NvbWUgOiBfIHQgLT4gYm9vbFxuICAgIHZhbCB2YWx1ZV9leG4gOiAnYSB0IC0+ICdhXG4gICAgdmFsIHZhbHVlX3Vuc2FmZSA6ICdhIHQgLT4gJ2FcbiAgICB2YWwgaXRlcl9zb21lIDogJ2EgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIGVuZCA9IHN0cnVjdFxuICAgIHR5cGUgKydhIHRcblxuICAgICgqIEJlaW5nIGEgcG9pbnRlciwgbm8gb25lIG91dHNpZGUgdGhpcyBtb2R1bGUgY2FuIGNvbnN0cnVjdCBhIHZhbHVlIHRoYXQgaXNcbiAgICAgICBbcGh5c19zYW1lXSBhcyB0aGlzIG9uZS5cblxuICAgICAgIEl0IHdvdWxkIGJlIHNpbXBsZXIgdG8gdXNlIHRoaXMgdmFsdWUgYXMgW25vbmVdLCBidXQgd2UgdXNlIGFuIGltbWVkaWF0ZSBpbnN0ZWFkXG4gICAgICAgYmVjYXVzZSBpdCBsZXRzIHVzIGF2b2lkIGNhbWxfbW9kaWZ5IHdoZW4gc2V0dGluZyB0byBbbm9uZV0sIG1ha2luZyBjZXJ0YWluXG4gICAgICAgYmVuY2htYXJrcyBzaWduaWZpY2FudGx5IGZhc3RlciAoZS5nLiAuLi9iZW5jaC9hcnJheV9xdWV1ZS5leGUpLlxuXG4gICAgICAgdGhpcyBjb2RlIGlzIGR1cGxpY2F0ZWQgaW4gTW9wdGlvbiwgYW5kIGlmIHdlIGZpbmQgeWV0IGFub3RoZXIgcGxhY2Ugd2hlcmUgd2Ugd2FudFxuICAgICAgIGl0IHdlIHNob3VsZCByZWNvbnNpZGVyIG1ha2luZyBpdCBzaGFyZWQuICopXG4gICAgbGV0IG5vbmVfc3Vic3RpdHV0ZSA6IF8gdCA9IENhbWwuT2JqLm9iaiAoQ2FtbC5PYmoubmV3X2Jsb2NrIENhbWwuT2JqLmFic3RyYWN0X3RhZyAxKVxuXG4gICAgbGV0IG5vbmUgOiBfIHQgPVxuICAgICAgKCogVGhlIG51bWJlciB3YXMgcHJvZHVjZWQgYnlcbiAgICAgICAgIFs8IC9kZXYvdXJhbmRvbSB0ciAtYyAtZCAnMTIzNDU2Nzg5MGFiY2RlZicgfCBoZWFkIC1jIDE2XS5cblxuICAgICAgICAgVGhlIGlkZWEgaXMgdGhhdCBhIHJhbmRvbSBudW1iZXIgd2lsbCBoYXZlIGxvd2VyIHByb2JhYmlsaXR5IHRvIGNvbGxpZGUgd2l0aFxuICAgICAgICAgYW55dGhpbmcgdGhhbiBhbnkgbnVtYmVyIHdlIGNhbiBjaG9vc2Ugb3Vyc2VsdmVzLlxuXG4gICAgICAgICBXZSBhcmUgdXNpbmcgYSBwb2x5bW9ycGhpYyB2YXJpYW50IGluc3RlYWQgb2YgYW4gaW50ZWdlciBjb25zdGFudCBiZWNhdXNlIHRoZXJlXG4gICAgICAgICBpcyBhIGNvbXBpbGVyIGJ1ZyB3aGVyZSBpdCB3cm9uZ2x5IGFzc3VtZXMgdGhhdCB0aGUgcmVzdWx0IG9mIFtpZiBfIHRoZW4gYyBlbHNlXG4gICAgICAgICB5XSBpcyBub3QgYSBwb2ludGVyIGlmIFtjXSBpcyBhbiBpbnRlZ2VyIGNvbXBpbGUtdGltZSBjb25zdGFudC4gIFRoaXMgaXMgYmVpbmdcbiAgICAgICAgIGZpeGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9vY2FtbC9vY2FtbC9wdWxsLzU1NS4gIFRoZSBcIm1lbW9yeSBjb3JydXB0aW9uXCIgdGVzdFxuICAgICAgICAgYmVsb3cgZGVtb25zdHJhdGVzIHRoZSBpc3N1ZS4gICopXG4gICAgICBDYW1sLk9iai5tYWdpYyBgeDZlOGVlMzQ3OGUxZDc0NDlcbiAgICA7O1xuXG4gICAgbGV0IGlzX25vbmUgeCA9IHBoeXNfZXF1YWwgeCBub25lXG4gICAgbGV0IGlzX3NvbWUgeCA9IG5vdCAocGh5c19lcXVhbCB4IG5vbmUpXG5cbiAgICBsZXQgc29tZSAodHlwZSBhKSAoeCA6IGEpIDogYSB0ID1cbiAgICAgIGlmIHBoeXNfc2FtZSB4IG5vbmUgdGhlbiBub25lX3N1YnN0aXR1dGUgZWxzZSBDYW1sLk9iai5tYWdpYyB4XG4gICAgOztcblxuICAgIGxldCB2YWx1ZV91bnNhZmUgKHR5cGUgYSkgKHggOiBhIHQpIDogYSA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHggbm9uZV9zdWJzdGl0dXRlIHRoZW4gQ2FtbC5PYmoubWFnaWMgbm9uZSBlbHNlIENhbWwuT2JqLm1hZ2ljIHhcbiAgICA7O1xuXG4gICAgbGV0IHZhbHVlX2V4biB4ID1cbiAgICAgIGlmIGlzX3NvbWUgeFxuICAgICAgdGhlbiB2YWx1ZV91bnNhZmUgeFxuICAgICAgZWxzZSBmYWlsd2l0aCBcIk9wdGlvbl9hcnJheS5nZXRfc29tZV9leG46IHRoZSBlbGVtZW50IGlzIFtOb25lXVwiXG4gICAgOztcblxuICAgIGxldCBpdGVyX3NvbWUgdCB+ZiA9IGlmIGlzX3NvbWUgdCB0aGVuIGYgKHZhbHVlX3Vuc2FmZSB0KVxuICBlbmRcblxuICBtb2R1bGUgVDEgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFQwXG5cbiAgICBsZXQgb2Zfb3B0aW9uID0gZnVuY3Rpb25cbiAgICAgIHwgTm9uZSAtPiBub25lXG4gICAgICB8IFNvbWUgeCAtPiBzb21lIHhcbiAgICA7O1xuXG4gICAgbGV0W0BpbmxpbmVdIHRvX29wdGlvbiB4ID0gaWYgaXNfc29tZSB4IHRoZW4gU29tZSAodmFsdWVfdW5zYWZlIHgpIGVsc2UgTm9uZVxuICAgIGxldCB0b19zZXhwYWJsZSA9IHRvX29wdGlvblxuICAgIGxldCBvZl9zZXhwYWJsZSA9IG9mX29wdGlvblxuXG4gICAgbGV0IHRfc2V4cF9ncmFtbWFyICh0eXBlIGEpIChncmFtbWFyIDogYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICAgIDogYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICA9XG4gICAgICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChPcHRpb24udF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbiAgICA7O1xuICBlbmRcblxuICBpbmNsdWRlIFQxXG4gIGluY2x1ZGUgU2V4cGFibGUuT2Zfc2V4cGFibGUxIChPcHRpb24pIChUMSlcbmVuZFxuXG50eXBlICdhIHQgPSAnYSBDaGVhcF9vcHRpb24udCBVbmlmb3JtX2FycmF5LnQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9XG4gIGZ1biBfb2ZfYV9fMDAxXyB4X18wMDNfIC0+XG4gIFVuaWZvcm1fYXJyYXkudF9vZl9zZXhwIChDaGVhcF9vcHRpb24udF9vZl9zZXhwIF9vZl9hX18wMDFfKSB4X18wMDNfXG47O1xuXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgZnVuIF9vZl9hX18wMDRfIHhfXzAwNV8gLT5cbiAgVW5pZm9ybV9hcnJheS5zZXhwX29mX3QgKENoZWFwX29wdGlvbi5zZXhwX29mX3QgX29mX2FfXzAwNF8pIHhfXzAwNV9cbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+XG4gIFVuaWZvcm1fYXJyYXkudF9zZXhwX2dyYW1tYXIgKENoZWFwX29wdGlvbi50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyKVxuOztcblxuW0BAQGVuZF1cblxubGV0IGVtcHR5ID0gVW5pZm9ybV9hcnJheS5lbXB0eVxubGV0IGNyZWF0ZSB+bGVuID0gVW5pZm9ybV9hcnJheS5jcmVhdGUgfmxlbiBDaGVhcF9vcHRpb24ubm9uZVxubGV0IGluaXQgbiB+ZiA9IFVuaWZvcm1fYXJyYXkuaW5pdCBuIH5mOihmdW4gaSAtPiBDaGVhcF9vcHRpb24ub2Zfb3B0aW9uIChmIGkpKVxubGV0IGluaXRfc29tZSBuIH5mID0gVW5pZm9ybV9hcnJheS5pbml0IG4gfmY6KGZ1biBpIC0+IENoZWFwX29wdGlvbi5zb21lIChmIGkpKVxubGV0IGxlbmd0aCA9IFVuaWZvcm1fYXJyYXkubGVuZ3RoXG5sZXRbQGlubGluZV0gZ2V0IHQgaSA9IENoZWFwX29wdGlvbi50b19vcHRpb24gKFVuaWZvcm1fYXJyYXkuZ2V0IHQgaSlcbmxldCBnZXRfc29tZV9leG4gdCBpID0gQ2hlYXBfb3B0aW9uLnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS5nZXQgdCBpKVxubGV0IGlzX25vbmUgdCBpID0gQ2hlYXBfb3B0aW9uLmlzX25vbmUgKFVuaWZvcm1fYXJyYXkuZ2V0IHQgaSlcbmxldCBpc19zb21lIHQgaSA9IENoZWFwX29wdGlvbi5pc19zb21lIChVbmlmb3JtX2FycmF5LmdldCB0IGkpXG5sZXQgc2V0IHQgaSB4ID0gVW5pZm9ybV9hcnJheS5zZXQgdCBpIChDaGVhcF9vcHRpb24ub2Zfb3B0aW9uIHgpXG5sZXQgc2V0X3NvbWUgdCBpIHggPSBVbmlmb3JtX2FycmF5LnNldCB0IGkgKENoZWFwX29wdGlvbi5zb21lIHgpXG5sZXQgc2V0X25vbmUgdCBpID0gVW5pZm9ybV9hcnJheS5zZXQgdCBpIENoZWFwX29wdGlvbi5ub25lXG5sZXQgc3dhcCB0IGkgaiA9IFVuaWZvcm1fYXJyYXkuc3dhcCB0IGkgalxubGV0IHVuc2FmZV9nZXQgdCBpID0gQ2hlYXBfb3B0aW9uLnRvX29wdGlvbiAoVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IHQgaSlcbmxldCB1bnNhZmVfZ2V0X3NvbWVfZXhuIHQgaSA9IENoZWFwX29wdGlvbi52YWx1ZV9leG4gKFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCB0IGkpXG5cbmxldCB1bnNhZmVfZ2V0X3NvbWVfYXNzdW1pbmdfc29tZSB0IGkgPVxuICBDaGVhcF9vcHRpb24udmFsdWVfdW5zYWZlIChVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgdCBpKVxuOztcblxubGV0IHVuc2FmZV9pc19zb21lIHQgaSA9IENoZWFwX29wdGlvbi5pc19zb21lIChVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgdCBpKVxubGV0IHVuc2FmZV9zZXQgdCBpIHggPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCBpIChDaGVhcF9vcHRpb24ub2Zfb3B0aW9uIHgpXG5sZXQgdW5zYWZlX3NldF9zb21lIHQgaSB4ID0gVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgaSAoQ2hlYXBfb3B0aW9uLnNvbWUgeClcbmxldCB1bnNhZmVfc2V0X25vbmUgdCBpID0gVW5pZm9ybV9hcnJheS51bnNhZmVfc2V0IHQgaSBDaGVhcF9vcHRpb24ubm9uZVxuXG5sZXQgY2xlYXIgdCA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICB1bnNhZmVfc2V0X25vbmUgdCBpXG4gIGRvbmVcbjs7XG5cbmxldCBpdGVyaSBpbnB1dCB+ZiA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggaW5wdXQgLSAxIGRvXG4gICAgZiBpICh1bnNhZmVfZ2V0IGlucHV0IGkpXG4gIGRvbmVcbjs7XG5cbmxldCBpdGVyIGlucHV0IH5mID0gaXRlcmkgaW5wdXQgfmY6KGZ1biAoXyA6IGludCkgeCAtPiBmIHgpXG5cbmxldCBmb2xkaSBpbnB1dCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBpdGVyaSBpbnB1dCB+ZjooZnVuIGkgZWxlbSAtPiBhY2MgOj0gZiBpICFhY2MgZWxlbSk7XG4gICFhY2Ncbjs7XG5cbmxldCBmb2xkIGlucHV0IH5pbml0IH5mID0gZm9sZGkgaW5wdXQgfmluaXQgfmY6KGZ1biAoXyA6IGludCkgYWNjIHggLT4gZiBhY2MgeClcblxuaW5jbHVkZSBJbmRleGVkX2NvbnRhaW5lci5NYWtlX2dlbiAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcbiAgICB0eXBlICdhIGVsdCA9ICdhIG9wdGlvblxuXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGZvbGRpID0gYEN1c3RvbSBmb2xkaVxuICAgIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gICAgbGV0IGl0ZXJpID0gYEN1c3RvbSBpdGVyaVxuICAgIGxldCBsZW5ndGggPSBgQ3VzdG9tIGxlbmd0aFxuICBlbmQpXG5cbmxldCBtYXBpIGlucHV0IH5mID1cbiAgbGV0IG91dHB1dCA9IGNyZWF0ZSB+bGVuOihsZW5ndGggaW5wdXQpIGluXG4gIGl0ZXJpIGlucHV0IH5mOihmdW4gaSBlbGVtIC0+IHVuc2FmZV9zZXQgb3V0cHV0IGkgKGYgaSBlbGVtKSk7XG4gIG91dHB1dFxuOztcblxubGV0IG1hcCBpbnB1dCB+ZiA9IG1hcGkgaW5wdXQgfmY6KGZ1biAoXyA6IGludCkgZWxlbSAtPiBmIGVsZW0pXG5cbmxldCBtYXBfc29tZSBpbnB1dCB+ZiA9XG4gIGxldCBsZW4gPSBsZW5ndGggaW5wdXQgaW5cbiAgbGV0IG91dHB1dCA9IGNyZWF0ZSB+bGVuIGluXG4gIGxldCAoKSA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIGxldCBvcHQgPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgaW5wdXQgaSBpblxuICAgICAgQ2hlYXBfb3B0aW9uLml0ZXJfc29tZSBvcHQgfmY6KGZ1biB4IC0+IHVuc2FmZV9zZXRfc29tZSBvdXRwdXQgaSAoZiB4KSlcbiAgICBkb25lXG4gIGluXG4gIG91dHB1dFxuOztcblxubGV0IG9mX2FycmF5IGFycmF5ID0gaW5pdCAoQXJyYXkubGVuZ3RoIGFycmF5KSB+ZjooZnVuIGkgLT4gQXJyYXkudW5zYWZlX2dldCBhcnJheSBpKVxuXG5sZXQgb2ZfYXJyYXlfc29tZSBhcnJheSA9XG4gIGluaXRfc29tZSAoQXJyYXkubGVuZ3RoIGFycmF5KSB+ZjooZnVuIGkgLT4gQXJyYXkudW5zYWZlX2dldCBhcnJheSBpKVxuOztcblxubGV0IHRvX2FycmF5IHQgPSBBcnJheS5pbml0IChsZW5ndGggdCkgfmY6KGZ1biBpIC0+IHVuc2FmZV9nZXQgdCBpKVxuXG5pbmNsdWRlIEJsaXQuTWFrZTFfZ2VuZXJpYyAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgY3JlYXRlX2xpa2UgfmxlbiBfID0gY3JlYXRlIH5sZW5cbiAgICBsZXQgdW5zYWZlX2JsaXQgPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9ibGl0XG4gIGVuZClcblxubGV0IGNvcHkgPSBVbmlmb3JtX2FycmF5LmNvcHlcblxubW9kdWxlIEZvcl90ZXN0aW5nID0gc3RydWN0XG4gIG1vZHVsZSBVbnNhZmVfY2hlYXBfb3B0aW9uID0gQ2hlYXBfb3B0aW9uXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBTdGFja19pbnRmXG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4oKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIHNpbWlsYXIgdG8gW0RlcXVlXSBpbiB0aGF0IGl0IHVzZXMgYW4gYXJyYXkgb2YgWydhXSBhbmRcbiAgIGEgbXV0YWJsZSBbaW50XSB0byBpbmRpY2F0ZSB3aGF0IGluIHRoZSBhcnJheSBpcyB1c2VkLiAgV2UgY2hvb3NlIHRvIGltcGxlbWVudCBbU3RhY2tdXG4gICBkaXJlY3RseSByYXRoZXIgdGhhbiBvbiB0b3Agb2YgW0RlcXVlXSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gIEUuZy4gYSBzaW1wbGVcbiAgIG1pY3JvYmVuY2htYXJrIHNob3dzIHRoYXQgcHVzaC9wb3AgaXMgYWJvdXQgMjAlIGZhc3Rlci4gKilcbnR5cGUgJ2EgdCA9XG4gIHsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgOyBtdXRhYmxlIGVsdHMgOiAnYSBPcHRpb25fYXJyYXkudFxuICB9XG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biBfb2ZfYV9fMDAxXyB7IGxlbmd0aCA9IGxlbmd0aF9fMDAzXzsgZWx0cyA9IGVsdHNfXzAwNV8gfSAtPlxuICBsZXQgYm5kc19fMDAyXyA9IFtdIGluXG4gIGxldCBibmRzX18wMDJfID1cbiAgICBsZXQgYXJnX18wMDZfID0gT3B0aW9uX2FycmF5LnNleHBfb2ZfdCBfb2ZfYV9fMDAxXyBlbHRzX18wMDVfIGluXG4gICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiZWx0c1wiOyBhcmdfXzAwNl8gXSA6OiBibmRzX18wMDJfXG4gIGluXG4gIGxldCBibmRzX18wMDJfID1cbiAgICBsZXQgYXJnX18wMDRfID0gc2V4cF9vZl9pbnQgbGVuZ3RoX18wMDNfIGluXG4gICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwibGVuZ3RoXCI7IGFyZ19fMDA0XyBdIDo6IGJuZHNfXzAwMl9cbiAgaW5cbiAgU2V4cGxpYjAuU2V4cC5MaXN0IGJuZHNfXzAwMl9cbjs7XG5cbltAQEBlbmRdXG5cbmxldCBzZXhwX29mX3RfaW50ZXJuYWwgPSBzZXhwX29mX3RcbmxldCBzZXhwX29mX3QgPSBgUmVib3VuZF9sYXRlclxubGV0IF8gPSBzZXhwX29mX3RcbmxldCBjYXBhY2l0eSB0ID0gT3B0aW9uX2FycmF5Lmxlbmd0aCB0LmVsdHNcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSAoeyBsZW5ndGg7IGVsdHMgfSBhcyB0KSA6IHVuaXQgPVxuICB0cnlcbiAgICBhc3NlcnQgKDAgPD0gbGVuZ3RoICYmIGxlbmd0aCA8PSBPcHRpb25fYXJyYXkubGVuZ3RoIGVsdHMpO1xuICAgIGZvciBpID0gMCB0byBsZW5ndGggLSAxIGRvXG4gICAgICBpbnZhcmlhbnRfYSAoT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biBlbHRzIGkpXG4gICAgZG9uZTtcbiAgICAoKiBXZSBtYWludGFpbiB0aGUgaW52YXJpYW50IHRoYXQgdW51c2VkIGVsZW1lbnRzIGFyZSB1bnNldCB0byBhdm9pZCBhIHNwYWNlXG4gICAgICAgbGVhay4gKilcbiAgICBmb3IgaSA9IGxlbmd0aCB0byBPcHRpb25fYXJyYXkubGVuZ3RoIGVsdHMgLSAxIGRvXG4gICAgICBhc3NlcnQgKG5vdCAoT3B0aW9uX2FycmF5LmlzX3NvbWUgZWx0cyBpKSlcbiAgICBkb25lXG4gIHdpdGhcbiAgfCBleG4gLT5cbiAgICByYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcIlN0YWNrLmludmFyaWFudCBmYWlsZWRcIlxuICAgICAgICAgWyBcImV4blwiLCBleG4gfD4gRXhuLnNleHBfb2ZfdDsgXCJzdGFja1wiLCB0IHw+IHNleHBfb2ZfdF9pbnRlcm5hbCBzZXhwX29mX29wYXF1ZSBdKVxuOztcblxubGV0IGNyZWF0ZSAodHlwZSBhKSAoKSA6IGEgdCA9IHsgbGVuZ3RoID0gMDsgZWx0cyA9IE9wdGlvbl9hcnJheS5lbXB0eSB9XG5sZXQgbGVuZ3RoIHQgPSB0Lmxlbmd0aFxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxuKCogVGhlIG9yZGVyIGluIHdoaWNoIGVsZW1lbnRzIGFyZSB2aXNpdGVkIGhhcyBiZWVuIGNob3NlbiBzbyBhcyB0byBiZSBiYWNrd2FyZHNcbiAgIGNvbXBhdGlibGUgd2l0aCBbQ2FtbC5TdGFja10gKilcbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBsZXQgciA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gdC5sZW5ndGggLSAxIGRvd250byAwIGRvXG4gICAgciA6PSBmICFyIChPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIHQuZWx0cyBpKVxuICBkb25lO1xuICAhclxuOztcblxubGV0IGl0ZXIgdCB+ZiA9XG4gIGZvciBpID0gdC5sZW5ndGggLSAxIGRvd250byAwIGRvXG4gICAgZiAoT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmVsdHMgaSlcbiAgZG9uZVxuOztcblxubW9kdWxlIEMgPSBDb250YWluZXIuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gICAgbGV0IGxlbmd0aCA9IGBDdXN0b20gbGVuZ3RoXG4gIGVuZClcblxubGV0IG1lbSA9IEMubWVtXG5sZXQgZXhpc3RzID0gQy5leGlzdHNcbmxldCBmb3JfYWxsID0gQy5mb3JfYWxsXG5sZXQgY291bnQgPSBDLmNvdW50XG5sZXQgc3VtID0gQy5zdW1cbmxldCBmaW5kID0gQy5maW5kXG5sZXQgZmluZF9tYXAgPSBDLmZpbmRfbWFwXG5sZXQgdG9fbGlzdCA9IEMudG9fbGlzdFxubGV0IHRvX2FycmF5ID0gQy50b19hcnJheVxubGV0IG1pbl9lbHQgPSBDLm1pbl9lbHRcbmxldCBtYXhfZWx0ID0gQy5tYXhfZWx0XG5sZXQgZm9sZF9yZXN1bHQgPSBDLmZvbGRfcmVzdWx0XG5sZXQgZm9sZF91bnRpbCA9IEMuZm9sZF91bnRpbFxuXG5sZXQgb2ZfbGlzdCAodHlwZSBhKSAobCA6IGEgbGlzdCkgPVxuICBpZiBMaXN0LmlzX2VtcHR5IGxcbiAgdGhlbiBjcmVhdGUgKClcbiAgZWxzZSAoXG4gICAgbGV0IGxlbmd0aCA9IExpc3QubGVuZ3RoIGwgaW5cbiAgICBsZXQgZWx0cyA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjooMiAqIGxlbmd0aCkgaW5cbiAgICBsZXQgciA9IHJlZiBsIGluXG4gICAgZm9yIGkgPSBsZW5ndGggLSAxIGRvd250byAwIGRvXG4gICAgICBtYXRjaCAhciB3aXRoXG4gICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBhIDo6IGwgLT5cbiAgICAgICAgT3B0aW9uX2FycmF5LnNldF9zb21lIGVsdHMgaSBhO1xuICAgICAgICByIDo9IGxcbiAgICBkb25lO1xuICAgIHsgbGVuZ3RoOyBlbHRzIH0pXG47O1xuXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gTGlzdC5zZXhwX29mX3Qgc2V4cF9vZl9hICh0b19saXN0IHQpXG5sZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwID0gb2ZfbGlzdCAoTGlzdC50X29mX3NleHAgYV9vZl9zZXhwIHNleHApXG5cbmxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBhKSAoZ3JhbW1hciA6IGEgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoTGlzdC50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuOztcblxubGV0IHJlc2l6ZSB0IHNpemUgPVxuICBsZXQgYXJyID0gT3B0aW9uX2FycmF5LmNyZWF0ZSB+bGVuOnNpemUgaW5cbiAgT3B0aW9uX2FycmF5LmJsaXQgfnNyYzp0LmVsdHMgfmRzdDphcnIgfnNyY19wb3M6MCB+ZHN0X3BvczowIH5sZW46dC5sZW5ndGg7XG4gIHQuZWx0cyA8LSBhcnJcbjs7XG5cbmxldCBzZXRfY2FwYWNpdHkgdCBuZXdfY2FwYWNpdHkgPVxuICBsZXQgbmV3X2NhcGFjaXR5ID0gbWF4IG5ld19jYXBhY2l0eSAobGVuZ3RoIHQpIGluXG4gIGlmIG5ld19jYXBhY2l0eSA8PiBjYXBhY2l0eSB0IHRoZW4gcmVzaXplIHQgbmV3X2NhcGFjaXR5XG47O1xuXG5sZXQgcHVzaCB0IGEgPVxuICBpZiB0Lmxlbmd0aCA9IE9wdGlvbl9hcnJheS5sZW5ndGggdC5lbHRzIHRoZW4gcmVzaXplIHQgKDIgKiAodC5sZW5ndGggKyAxKSk7XG4gIE9wdGlvbl9hcnJheS5zZXRfc29tZSB0LmVsdHMgdC5sZW5ndGggYTtcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggKyAxXG47O1xuXG5sZXQgcG9wX25vbmVtcHR5IHQgPVxuICBsZXQgaSA9IHQubGVuZ3RoIC0gMSBpblxuICBsZXQgcmVzdWx0ID0gT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmVsdHMgaSBpblxuICBPcHRpb25fYXJyYXkuc2V0X25vbmUgdC5lbHRzIGk7XG4gIHQubGVuZ3RoIDwtIGk7XG4gIHJlc3VsdFxuOztcblxubGV0IHBvcF9lcnJvciA9IEVycm9yLm9mX3N0cmluZyBcIlN0YWNrLnBvcCBvZiBlbXB0eSBzdGFja1wiXG5sZXQgcG9wIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKHBvcF9ub25lbXB0eSB0KVxubGV0IHBvcF9leG4gdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBFcnJvci5yYWlzZSBwb3BfZXJyb3IgZWxzZSBwb3Bfbm9uZW1wdHkgdFxubGV0IHRvcF9ub25lbXB0eSB0ID0gT3B0aW9uX2FycmF5LmdldF9zb21lX2V4biB0LmVsdHMgKHQubGVuZ3RoIC0gMSlcbmxldCB0b3BfZXJyb3IgPSBFcnJvci5vZl9zdHJpbmcgXCJTdGFjay50b3Agb2YgZW1wdHkgc3RhY2tcIlxubGV0IHRvcCB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lICh0b3Bfbm9uZW1wdHkgdClcbmxldCB0b3BfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gRXJyb3IucmFpc2UgdG9wX2Vycm9yIGVsc2UgdG9wX25vbmVtcHR5IHRcbmxldCBjb3B5IHsgbGVuZ3RoOyBlbHRzIH0gPSB7IGxlbmd0aDsgZWx0cyA9IE9wdGlvbl9hcnJheS5jb3B5IGVsdHMgfVxuXG5sZXQgY2xlYXIgdCA9XG4gIGlmIHQubGVuZ3RoID4gMFxuICB0aGVuIChcbiAgICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICBPcHRpb25fYXJyYXkuc2V0X25vbmUgdC5lbHRzIGlcbiAgICBkb25lO1xuICAgIHQubGVuZ3RoIDwtIDApXG47O1xuXG5sZXQgdW50aWxfZW1wdHkgdCBmID1cbiAgbGV0IHJlYyBsb29wICgpID1cbiAgICBpZiB0Lmxlbmd0aCA+IDBcbiAgICB0aGVuIChcbiAgICAgIGYgKHBvcF9ub25lbXB0eSB0KTtcbiAgICAgIGxvb3AgKCkpXG4gIGluXG4gIGxvb3AgKClcbjs7XG5cbmxldCBzaW5nbGV0b24geCA9XG4gIGxldCB0ID0gY3JlYXRlICgpIGluXG4gIHB1c2ggdCB4O1xuICB0XG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbigqIFRoaXMgaXMgbGlmdGVkIG91dCBvZiBbTV0gYmVjYXVzZSBbU291cmNlX2NvZGVfcG9zaXRpb24wXSBleHBvcnRzIFtTdHJpbmcwXVxuICAgYXMgW1N0cmluZ10sIHdoaWNoIGRvZXMgbm90IGV4cG9ydCBhIGhhc2ggZnVuY3Rpb24uICopXG5sZXQgaGFzaF9vdmVycmlkZSB7IENhbWwuTGV4aW5nLnBvc19mbmFtZTsgcG9zX2xudW07IHBvc19ib2w7IHBvc19jbnVtIH0gPVxuICBTdHJpbmcuaGFzaCBwb3NfZm5hbWVcbiAgbHhvciBJbnQuaGFzaCBwb3NfbG51bVxuICBseG9yIEludC5oYXNoIHBvc19ib2xcbiAgbHhvciBJbnQuaGFzaCBwb3NfY251bVxuOztcblxubW9kdWxlIE0gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTb3VyY2VfY29kZV9wb3NpdGlvbjBcblxuICBsZXQgaGFzaCA9IGhhc2hfb3ZlcnJpZGVcbmVuZFxuXG5pbmNsdWRlIE1cbmluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlX3VzaW5nX2NvbXBhcmF0b3IgKE0pXG5cbmxldCBvZl9wb3MgKHBvc19mbmFtZSwgcG9zX2xudW0sIHBvc19jbnVtLCBfKSA9XG4gIHsgcG9zX2ZuYW1lOyBwb3NfbG51bTsgcG9zX2NudW07IHBvc19ib2wgPSAwIH1cbjs7XG4iLCJvcGVuISBJbXBvcnRcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IE5lZ1xuICAgIHwgWmVyb1xuICAgIHwgUG9zXG4gICAgfCBOYW5cbiAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hciwgY29tcGFyZSwgaGFzaCwgZW51bWVyYXRlXVxuXG4gIGxldCB0X29mX3NleHAgPVxuICAgIChsZXQgZXJyb3Jfc291cmNlX18wMDNfID0gXCJzaWduX29yX25hbi5tbC5ULnRcIiBpblxuICAgICBmdW5jdGlvblxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJuZWdcIiB8IFwiTmVnXCIpIC0+IE5lZ1xuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgLT4gWmVyb1xuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJwb3NcIiB8IFwiUG9zXCIpIC0+IFBvc1xuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJuYW5cIiB8IFwiTmFuXCIpIC0+IE5hblxuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5lZ1wiIHwgXCJOZWdcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJwb3NcIiB8IFwiUG9zXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibmFuXCIgfCBcIk5hblwiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDAyXyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDJfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgICAgfCBzZXhwX18wMDJfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IE5lZyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJOZWdcIlxuICAgICAgfCBaZXJvIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlplcm9cIlxuICAgICAgfCBQb3MgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiUG9zXCJcbiAgICAgIHwgTmFuIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIk5hblwiXG4gICAgICAgICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgeyB1bnR5cGVkID1cbiAgICAgICAgVmFyaWFudFxuICAgICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICBbIE5vX3RhZyB7IG5hbWUgPSBcIk5lZ1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJaZXJvXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlBvc1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJOYW5cIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgfVxuICA7O1xuXG4gIGxldCBjb21wYXJlID0gKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIDogdCAtPiB0IC0+IGludClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgKGZ1biBoc3YgYXJnIC0+XG4gICAgICAgbWF0Y2ggYXJnIHdpdGhcbiAgICAgICB8IE5lZyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDBcbiAgICAgICB8IFplcm8gLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxXG4gICAgICAgfCBQb3MgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAyXG4gICAgICAgfCBOYW4gLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAzXG4gICAgICAgICAgICAgICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gIDs7XG5cbiAgbGV0IChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jIGFyZyA9XG4gICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgICBoYXNoX2ZvbGRfdCBoc3YgYXJnKVxuICAgIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGFsbCA9IChbIE5lZzsgWmVybzsgUG9zOyBOYW4gXSA6IHQgbGlzdClcblxuICBbQEBAZW5kXVxuXG4gIGxldCBvZl9zdHJpbmcgcyA9IHRfb2Zfc2V4cCAoc2V4cF9vZl9zdHJpbmcgcylcbiAgbGV0IHRvX3N0cmluZyB0ID0gc3RyaW5nX29mX3NleHAgKHNleHBfb2ZfdCB0KVxuICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuU2lnbl9vcl9uYW5cIlxuZW5kXG5cbm1vZHVsZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogVC50KSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogVC50KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IFQudCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IFQudCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBULnQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IFQudCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiBULnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogVC50KSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgSWRlbnRpZmlhYmxlLk1ha2UgKFQpXG5cbigqIE9wZW4gW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgb2Zfc2lnbiA9IGZ1bmN0aW9uXG4gIHwgU2lnbi5OZWcgLT4gTmVnXG4gIHwgU2lnbi5aZXJvIC0+IFplcm9cbiAgfCBTaWduLlBvcyAtPiBQb3Ncbjs7XG5cbmxldCB0b19zaWduX2V4biA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IFNpZ24uTmVnXG4gIHwgWmVybyAtPiBTaWduLlplcm9cbiAgfCBQb3MgLT4gU2lnbi5Qb3NcbiAgfCBOYW4gLT4gaW52YWxpZF9hcmcgXCJCYXNlLlNpZ25fb3JfbmFuLnRvX3NpZ25fZXhuOiBOYW5cIlxuOztcblxubGV0IG9mX2ludCBuID0gb2Zfc2lnbiAoU2lnbi5vZl9pbnQgbilcbmxldCB0b19pbnRfZXhuIHQgPSBTaWduLnRvX2ludCAodG9fc2lnbl9leG4gdClcblxubGV0IGZsaXAgPSBmdW5jdGlvblxuICB8IE5lZyAtPiBQb3NcbiAgfCBaZXJvIC0+IFplcm9cbiAgfCBQb3MgLT4gTmVnXG4gIHwgTmFuIC0+IE5hblxuOztcblxubGV0ICggKiApIHQgdCcgPVxuICBtYXRjaCB0LCB0JyB3aXRoXG4gIHwgTmFuLCBfIHwgXywgTmFuIC0+IE5hblxuICB8IF8gLT4gb2Zfc2lnbiAoU2lnbi4oICogKSAodG9fc2lnbl9leG4gdCkgKHRvX3NpZ25fZXhuIHQnKSlcbjs7XG5cbigqIEluY2x1ZGUgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXIgYW55IGZ1bmN0b3IgYXBwbGljYXRpb25zIHRoYXRcbiAgIGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieSB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSAnYSB0ID1cbiAgfCBJbmNsIG9mICdhXG4gIHwgRXhjbCBvZiAnYVxuICB8IFVuYm91bmRlZFxuW0BAZGVyaXZpbmdfaW5saW5lIGVudW1lcmF0ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgYWxsIDogJ2EuICdhIGxpc3QgLT4gJ2EgdCBsaXN0ID1cbiAgZnVuIF9hbGxfb2ZfYSAtPlxuICBQcHhfZW51bWVyYXRlX2xpYi5MaXN0LmFwcGVuZFxuICAgIChsZXQgcmVjIG1hcCBsIGFjYyA9XG4gICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgfCBbXSAtPiBQcHhfZW51bWVyYXRlX2xpYi5MaXN0LnJldiBhY2NcbiAgICAgICB8IGVudW1lcmF0ZV9fMDAxXyA6OiBsIC0+IG1hcCBsIChJbmNsIGVudW1lcmF0ZV9fMDAxXyA6OiBhY2MpXG4gICAgIGluXG4gICAgIG1hcCBfYWxsX29mX2EgW10pXG4gICAgKFBweF9lbnVtZXJhdGVfbGliLkxpc3QuYXBwZW5kXG4gICAgICAgKGxldCByZWMgbWFwIGwgYWNjID1cbiAgICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IFBweF9lbnVtZXJhdGVfbGliLkxpc3QucmV2IGFjY1xuICAgICAgICAgIHwgZW51bWVyYXRlX18wMDJfIDo6IGwgLT4gbWFwIGwgKEV4Y2wgZW51bWVyYXRlX18wMDJfIDo6IGFjYylcbiAgICAgICAgaW5cbiAgICAgICAgbWFwIF9hbGxfb2ZfYSBbXSlcbiAgICAgICBbIFVuYm91bmRlZCBdKVxuOztcblxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9XG4gIGZ1biAodHlwZSBhX18wMThfKSA6ICgoU2V4cGxpYjAuU2V4cC50IC0+IGFfXzAxOF8pIC0+IFNleHBsaWIwLlNleHAudCAtPiBhX18wMThfIHQpIC0+XG4gIGxldCBlcnJvcl9zb3VyY2VfXzAwNl8gPSBcIm1heWJlX2JvdW5kLm1sLnRcIiBpblxuICBmdW4gX29mX2FfXzAwM18gLT4gZnVuY3Rpb25cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJpbmNsXCIgfCBcIkluY2xcIikgYXMgX3RhZ19fMDA5XykgOjogc2V4cF9hcmdzX18wMTBfKSBhc1xuICAgICAgX3NleHBfXzAwOF8gLT5cbiAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAxMF8gd2l0aFxuICAgICAgIHwgWyBhcmcwX18wMTFfIF0gLT5cbiAgICAgICAgIGxldCByZXMwX18wMTJfID0gX29mX2FfXzAwM18gYXJnMF9fMDExXyBpblxuICAgICAgICAgSW5jbCByZXMwX18wMTJfXG4gICAgICAgfCBfIC0+XG4gICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDA2X1xuICAgICAgICAgICBfdGFnX18wMDlfXG4gICAgICAgICAgIF9zZXhwX18wMDhfKVxuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImV4Y2xcIiB8IFwiRXhjbFwiKSBhcyBfdGFnX18wMTRfKSA6OiBzZXhwX2FyZ3NfXzAxNV8pIGFzXG4gICAgICBfc2V4cF9fMDEzXyAtPlxuICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDE1XyB3aXRoXG4gICAgICAgfCBbIGFyZzBfXzAxNl8gXSAtPlxuICAgICAgICAgbGV0IHJlczBfXzAxN18gPSBfb2ZfYV9fMDAzXyBhcmcwX18wMTZfIGluXG4gICAgICAgICBFeGNsIHJlczBfXzAxN19cbiAgICAgICB8IF8gLT5cbiAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMDZfXG4gICAgICAgICAgIF90YWdfXzAxNF9cbiAgICAgICAgICAgX3NleHBfXzAxM18pXG4gICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwidW5ib3VuZGVkXCIgfCBcIlVuYm91bmRlZFwiKSAtPiBVbmJvdW5kZWRcbiAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbmNsXCIgfCBcIkluY2xcIikgYXMgc2V4cF9fMDA3XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImV4Y2xcIiB8IFwiRXhjbFwiKSBhcyBzZXhwX18wMDdfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJ1bmJvdW5kZWRcIiB8IFwiVW5ib3VuZGVkXCIpIDo6IF8pIGFzXG4gICAgICBzZXhwX18wMDdfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDA1XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDVfXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDA1XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwNV9cbiAgICB8IHNleHBfXzAwNV8gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwNV9cbjs7XG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gKHR5cGUgYV9fMDI0XykgOiAoKGFfXzAyNF8gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiBhX18wMjRfIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICBmdW4gX29mX2FfXzAxOV8gLT4gZnVuY3Rpb25cbiAgICB8IEluY2wgYXJnMF9fMDIwXyAtPlxuICAgICAgbGV0IHJlczBfXzAyMV8gPSBfb2ZfYV9fMDE5XyBhcmcwX18wMjBfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJJbmNsXCI7IHJlczBfXzAyMV8gXVxuICAgIHwgRXhjbCBhcmcwX18wMjJfIC0+XG4gICAgICBsZXQgcmVzMF9fMDIzXyA9IF9vZl9hX18wMTlfIGFyZzBfXzAyMl8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkV4Y2xcIjsgcmVzMF9fMDIzXyBdXG4gICAgfCBVbmJvdW5kZWQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiVW5ib3VuZGVkXCJcbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJJbmNsXCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydhX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJFeGNsXCJcbiAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydhX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiVW5ib3VuZGVkXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbltAQEBlbmRdXG5cbnR5cGUgaW50ZXJ2YWxfY29tcGFyaXNvbiA9XG4gIHwgQmVsb3dfbG93ZXJfYm91bmRcbiAgfCBJbl9yYW5nZVxuICB8IEFib3ZlX3VwcGVyX2JvdW5kXG5bQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyLCBjb21wYXJlLCBoYXNoXVxuXG5sZXQgaW50ZXJ2YWxfY29tcGFyaXNvbl9vZl9zZXhwID1cbiAgKGxldCBlcnJvcl9zb3VyY2VfXzAyN18gPSBcIm1heWJlX2JvdW5kLm1sLmludGVydmFsX2NvbXBhcmlzb25cIiBpblxuICAgZnVuY3Rpb25cbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImJlbG93X2xvd2VyX2JvdW5kXCIgfCBcIkJlbG93X2xvd2VyX2JvdW5kXCIpIC0+IEJlbG93X2xvd2VyX2JvdW5kXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbl9yYW5nZVwiIHwgXCJJbl9yYW5nZVwiKSAtPiBJbl9yYW5nZVxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiYWJvdmVfdXBwZXJfYm91bmRcIiB8IFwiQWJvdmVfdXBwZXJfYm91bmRcIikgLT4gQWJvdmVfdXBwZXJfYm91bmRcbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJiZWxvd19sb3dlcl9ib3VuZFwiIHwgXCJCZWxvd19sb3dlcl9ib3VuZFwiKSA6OiBfKSBhcyBzZXhwX18wMjhfXG4gICAgIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMjdfIHNleHBfXzAyOF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiaW5fcmFuZ2VcIiB8IFwiSW5fcmFuZ2VcIikgOjogXykgYXMgc2V4cF9fMDI4X1xuICAgICAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDI3XyBzZXhwX18wMjhfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKFwiYWJvdmVfdXBwZXJfYm91bmRcIiB8IFwiQWJvdmVfdXBwZXJfYm91bmRcIikgOjogXykgYXMgc2V4cF9fMDI4X1xuICAgICAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDI3XyBzZXhwX18wMjhfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDI2XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMjdfIHNleHBfXzAyNl9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAyNl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMjdfIHNleHBfXzAyNl9cbiAgIHwgc2V4cF9fMDI2XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDI3XyBzZXhwX18wMjZfXG4gICAgICAgICAgICAgICAgICAgOiBTZXhwbGliMC5TZXhwLnQgLT4gaW50ZXJ2YWxfY29tcGFyaXNvbilcbjs7XG5cbmxldCBzZXhwX29mX2ludGVydmFsX2NvbXBhcmlzb24gPVxuICAoZnVuY3Rpb25cbiAgICB8IEJlbG93X2xvd2VyX2JvdW5kIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkJlbG93X2xvd2VyX2JvdW5kXCJcbiAgICB8IEluX3JhbmdlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkluX3JhbmdlXCJcbiAgICB8IEFib3ZlX3VwcGVyX2JvdW5kIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkFib3ZlX3VwcGVyX2JvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBTZXhwbGliMC5TZXhwLnQpXG47O1xuXG5sZXQgKGludGVydmFsX2NvbXBhcmlzb25fc2V4cF9ncmFtbWFyIDogaW50ZXJ2YWxfY29tcGFyaXNvbiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICB7IHVudHlwZWQgPVxuICAgICAgVmFyaWFudFxuICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICBbIE5vX3RhZyB7IG5hbWUgPSBcIkJlbG93X2xvd2VyX2JvdW5kXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJJbl9yYW5nZVwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiQWJvdmVfdXBwZXJfYm91bmRcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxubGV0IGNvbXBhcmVfaW50ZXJ2YWxfY29tcGFyaXNvbiA9XG4gIChQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfY29tcGFyZVxuICAgOiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IGludGVydmFsX2NvbXBhcmlzb24gLT4gaW50KVxuOztcblxubGV0IChoYXNoX2ZvbGRfaW50ZXJ2YWxfY29tcGFyaXNvbiA6XG4gICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGludGVydmFsX2NvbXBhcmlzb24gLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICA9XG4gIChmdW4gaHN2IGFyZyAtPlxuICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICB8IEJlbG93X2xvd2VyX2JvdW5kIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMFxuICAgICB8IEluX3JhbmdlIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMVxuICAgICB8IEFib3ZlX3VwcGVyX2JvdW5kIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGludGVydmFsX2NvbXBhcmlzb24gLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuOztcblxubGV0IChoYXNoX2ludGVydmFsX2NvbXBhcmlzb24gOiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gIGxldCBmdW5jIGFyZyA9XG4gICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICBoYXNoX2ZvbGRfaW50ZXJ2YWxfY29tcGFyaXNvbiBoc3YgYXJnKVxuICBpblxuICBmdW4geCAtPiBmdW5jIHhcbjs7XG5cbltAQEBlbmRdXG5cbmxldCBtYXAgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEluY2wgaW5jbCAtPiBJbmNsIChmIGluY2wpXG4gIHwgRXhjbCBleGNsIC0+IEV4Y2wgKGYgZXhjbClcbiAgfCBVbmJvdW5kZWQgLT4gVW5ib3VuZGVkXG47O1xuXG5sZXQgaXNfbG93ZXJfYm91bmQgdCB+b2ZfOmEgfmNvbXBhcmUgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBJbmNsIGluY2wgLT4gY29tcGFyZSBpbmNsIGEgPD0gMFxuICB8IEV4Y2wgZXhjbCAtPiBjb21wYXJlIGV4Y2wgYSA8IDBcbiAgfCBVbmJvdW5kZWQgLT4gdHJ1ZVxuOztcblxubGV0IGlzX3VwcGVyX2JvdW5kIHQgfm9mXzphIH5jb21wYXJlID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgSW5jbCBpbmNsIC0+IGNvbXBhcmUgYSBpbmNsIDw9IDBcbiAgfCBFeGNsIGV4Y2wgLT4gY29tcGFyZSBhIGV4Y2wgPCAwXG4gIHwgVW5ib3VuZGVkIC0+IHRydWVcbjs7XG5cbmxldCBib3VuZHNfY3Jvc3NlZCB+bG93ZXIgfnVwcGVyIH5jb21wYXJlID1cbiAgbWF0Y2ggbG93ZXIgd2l0aFxuICB8IFVuYm91bmRlZCAtPiBmYWxzZVxuICB8IEluY2wgbG93ZXIgfCBFeGNsIGxvd2VyIC0+XG4gICAgKG1hdGNoIHVwcGVyIHdpdGhcbiAgICAgfCBVbmJvdW5kZWQgLT4gZmFsc2VcbiAgICAgfCBJbmNsIHVwcGVyIHwgRXhjbCB1cHBlciAtPiBjb21wYXJlIGxvd2VyIHVwcGVyID4gMClcbjs7XG5cbmxldCBjaGVja19pbnRlcnZhbF9leG4gfmxvd2VyIH51cHBlciB+Y29tcGFyZSA9XG4gIGlmIGJvdW5kc19jcm9zc2VkIH5sb3dlciB+dXBwZXIgfmNvbXBhcmVcbiAgdGhlbiBmYWlsd2l0aCBcIk1heWJlX2JvdW5kLmNvbXBhcmVfdG9faW50ZXJ2YWxfZXhuOiBsb3dlciBib3VuZCA+IHVwcGVyIGJvdW5kXCJcbjs7XG5cbmxldCBjb21wYXJlX3RvX2ludGVydmFsX2V4biB+bG93ZXIgfnVwcGVyIGEgfmNvbXBhcmUgPVxuICBjaGVja19pbnRlcnZhbF9leG4gfmxvd2VyIH51cHBlciB+Y29tcGFyZTtcbiAgaWYgbm90IChpc19sb3dlcl9ib3VuZCBsb3dlciB+b2ZfOmEgfmNvbXBhcmUpXG4gIHRoZW4gQmVsb3dfbG93ZXJfYm91bmRcbiAgZWxzZSBpZiBub3QgKGlzX3VwcGVyX2JvdW5kIHVwcGVyIH5vZl86YSB+Y29tcGFyZSlcbiAgdGhlbiBBYm92ZV91cHBlcl9ib3VuZFxuICBlbHNlIEluX3JhbmdlXG47O1xuXG5sZXQgaW50ZXJ2YWxfY29udGFpbnNfZXhuIH5sb3dlciB+dXBwZXIgYSB+Y29tcGFyZSA9XG4gIG1hdGNoIGNvbXBhcmVfdG9faW50ZXJ2YWxfZXhuIH5sb3dlciB+dXBwZXIgYSB+Y29tcGFyZSB3aXRoXG4gIHwgSW5fcmFuZ2UgLT4gdHJ1ZVxuICB8IEJlbG93X2xvd2VyX2JvdW5kIHwgQWJvdmVfdXBwZXJfYm91bmQgLT4gZmFsc2Vcbjs7XG4iLCJvcGVuISBJbXBvcnRcbm9wZW4hIFRcblxubW9kdWxlIE9yX2R1cGxpY2F0ZSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIFsgYE9rIG9mICdhXG4gICAgfCBgRHVwbGljYXRlXG4gICAgXVxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgbGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9XG4gICAgZnVuIF9jbXBfX2EgYV9fMDAxXyBiX18wMDJfIC0+XG4gICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDAxXyBiX18wMDJfXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wMDFfLCBiX18wMDJfIHdpdGhcbiAgICAgIHwgYE9rIF9sZWZ0X18wMDNfLCBgT2sgX3JpZ2h0X18wMDRfIC0+IF9jbXBfX2EgX2xlZnRfXzAwM18gX3JpZ2h0X18wMDRfXG4gICAgICB8IGBEdXBsaWNhdGUsIGBEdXBsaWNhdGUgLT4gMFxuICAgICAgfCB4LCB5IC0+IFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIHggeSlcbiAgOztcblxuICBsZXQgZXF1YWwgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sID1cbiAgICBmdW4gX2NtcF9fYSBhX18wMDVfIGJfXzAwNl8gLT5cbiAgICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAwNV8gYl9fMDA2X1xuICAgICAgdGhlbiB0cnVlXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggYV9fMDA1XywgYl9fMDA2XyB3aXRoXG4gICAgICAgIHwgYE9rIF9sZWZ0X18wMDdfLCBgT2sgX3JpZ2h0X18wMDhfIC0+IF9jbXBfX2EgX2xlZnRfXzAwN18gX3JpZ2h0X18wMDhfXG4gICAgICAgIHwgYER1cGxpY2F0ZSwgYER1cGxpY2F0ZSAtPiB0cnVlXG4gICAgICAgIHwgeCwgeSAtPiBQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfZXF1YWwgeCB5KVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIGZ1biBfb2ZfYV9fMDA5XyAtPiBmdW5jdGlvblxuICAgICAgfCBgT2sgdl9fMDEwXyAtPiBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJPa1wiOyBfb2ZfYV9fMDA5XyB2X18wMTBfIF1cbiAgICAgIHwgYER1cGxpY2F0ZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJEdXBsaWNhdGVcIlxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIFdpdGhvdXRfY29tcGFyYXRvciA9IHN0cnVjdFxuICB0eXBlICgna2V5LCAnY21wLCAneikgdCA9ICd6XG5lbmRcblxubW9kdWxlIFdpdGhfY29tcGFyYXRvciA9IHN0cnVjdFxuICB0eXBlICgna2V5LCAnY21wLCAneikgdCA9IGNvbXBhcmF0b3I6KCdrZXksICdjbXApIENvbXBhcmF0b3IudCAtPiAnelxuZW5kXG5cbm1vZHVsZSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZSA9IHN0cnVjdFxuICB0eXBlICgna2V5LCAnY21wLCAneikgdCA9ICgna2V5LCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICd6XG5lbmRcblxubW9kdWxlIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssICd2KSB0ID0gJ2sgKiBbIGBMZWZ0IG9mICd2IHwgYFJpZ2h0IG9mICd2IHwgYFVuZXF1YWwgb2YgJ3YgKiAndiBdXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlIDpcbiAgICAnayAndi4gKCdrIC0+ICdrIC0+IGludCkgLT4gKCd2IC0+ICd2IC0+IGludCkgLT4gKCdrLCAndikgdCAtPiAoJ2ssICd2KSB0IC0+IGludFxuICAgID1cbiAgICBmdW4gX2NtcF9fayBfY21wX192IGFfXzAxMV8gYl9fMDEyXyAtPlxuICAgIGxldCB0X18wMTNfLCB0X18wMTRfID0gYV9fMDExXyBpblxuICAgIGxldCB0X18wMTVfLCB0X18wMTZfID0gYl9fMDEyXyBpblxuICAgIG1hdGNoIF9jbXBfX2sgdF9fMDEzXyB0X18wMTVfIHdpdGhcbiAgICB8IDAgLT5cbiAgICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIHRfXzAxNF8gdF9fMDE2X1xuICAgICAgdGhlbiAwXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggdF9fMDE0XywgdF9fMDE2XyB3aXRoXG4gICAgICAgIHwgYExlZnQgX2xlZnRfXzAxN18sIGBMZWZ0IF9yaWdodF9fMDE4XyAtPiBfY21wX192IF9sZWZ0X18wMTdfIF9yaWdodF9fMDE4X1xuICAgICAgICB8IGBSaWdodCBfbGVmdF9fMDE5XywgYFJpZ2h0IF9yaWdodF9fMDIwXyAtPiBfY21wX192IF9sZWZ0X18wMTlfIF9yaWdodF9fMDIwX1xuICAgICAgICB8IGBVbmVxdWFsIF9sZWZ0X18wMjFfLCBgVW5lcXVhbCBfcmlnaHRfXzAyMl8gLT5cbiAgICAgICAgICBsZXQgdF9fMDIzXywgdF9fMDI0XyA9IF9sZWZ0X18wMjFfIGluXG4gICAgICAgICAgbGV0IHRfXzAyNV8sIHRfXzAyNl8gPSBfcmlnaHRfXzAyMl8gaW5cbiAgICAgICAgICAobWF0Y2ggX2NtcF9fdiB0X18wMjNfIHRfXzAyNV8gd2l0aFxuICAgICAgICAgICB8IDAgLT4gX2NtcF9fdiB0X18wMjRfIHRfXzAyNl9cbiAgICAgICAgICAgfCBuIC0+IG4pXG4gICAgICAgIHwgeCwgeSAtPiBQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfY29tcGFyZSB4IHkpXG4gICAgfCBuIC0+IG5cbiAgOztcblxuICBsZXQgZXF1YWwgOlxuICAgICdrICd2LlxuICAgICgnayAtPiAnayAtPiBib29sKSAtPiAoJ3YgLT4gJ3YgLT4gYm9vbCkgLT4gKCdrLCAndikgdCAtPiAoJ2ssICd2KSB0IC0+IGJvb2xcbiAgICA9XG4gICAgZnVuIF9jbXBfX2sgX2NtcF9fdiBhX18wMjdfIGJfXzAyOF8gLT5cbiAgICAgIGxldCB0X18wMjlfLCB0X18wMzBfID0gYV9fMDI3XyBpblxuICAgICAgbGV0IHRfXzAzMV8sIHRfXzAzMl8gPSBiX18wMjhfIGluXG4gICAgICBQcHhfY29tcGFyZV9saWIuKCAmJiApXG4gICAgICAgIChfY21wX19rIHRfXzAyOV8gdF9fMDMxXylcbiAgICAgICAgKGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIHRfXzAzMF8gdF9fMDMyX1xuICAgICAgICAgdGhlbiB0cnVlXG4gICAgICAgICBlbHNlIChcbiAgICAgICAgICAgbWF0Y2ggdF9fMDMwXywgdF9fMDMyXyB3aXRoXG4gICAgICAgICAgIHwgYExlZnQgX2xlZnRfXzAzM18sIGBMZWZ0IF9yaWdodF9fMDM0XyAtPiBfY21wX192IF9sZWZ0X18wMzNfIF9yaWdodF9fMDM0X1xuICAgICAgICAgICB8IGBSaWdodCBfbGVmdF9fMDM1XywgYFJpZ2h0IF9yaWdodF9fMDM2XyAtPiBfY21wX192IF9sZWZ0X18wMzVfIF9yaWdodF9fMDM2X1xuICAgICAgICAgICB8IGBVbmVxdWFsIF9sZWZ0X18wMzdfLCBgVW5lcXVhbCBfcmlnaHRfXzAzOF8gLT5cbiAgICAgICAgICAgICBsZXQgdF9fMDM5XywgdF9fMDQwXyA9IF9sZWZ0X18wMzdfIGluXG4gICAgICAgICAgICAgbGV0IHRfXzA0MV8sIHRfXzA0Ml8gPSBfcmlnaHRfXzAzOF8gaW5cbiAgICAgICAgICAgICBQcHhfY29tcGFyZV9saWIuKCAmJiApIChfY21wX192IHRfXzAzOV8gdF9fMDQxXykgKF9jbXBfX3YgdF9fMDQwXyB0X18wNDJfKVxuICAgICAgICAgICB8IHgsIHkgLT4gUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2VxdWFsIHggeSkpXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA6XG4gICAgJ2sgJ3YuXG4gICAgKFNleHBsaWIwLlNleHAudCAtPiAnaylcbiAgICAtPiAoU2V4cGxpYjAuU2V4cC50IC0+ICd2KVxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgIC0+ICgnaywgJ3YpIHRcbiAgICA9XG4gICAgbGV0IGVycm9yX3NvdXJjZV9fMDU3XyA9IFwibWFwX2ludGYubWwuU3ltbWV0cmljX2RpZmZfZWxlbWVudC50XCIgaW5cbiAgICBmdW4gX29mX2tfXzA0M18gX29mX3ZfXzA0NF8gLT4gZnVuY3Rpb25cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFsgYXJnMF9fMDY3XzsgYXJnMV9fMDY4XyBdIC0+XG4gICAgICAgIGxldCByZXMwX18wNjlfID0gX29mX2tfXzA0M18gYXJnMF9fMDY3X1xuICAgICAgICBhbmQgcmVzMV9fMDcwXyA9XG4gICAgICAgICAgbGV0IHNleHBfXzA2Nl8gPSBhcmcxX18wNjhfIGluXG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBtYXRjaCBzZXhwX18wNjZfIHdpdGhcbiAgICAgICAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIGF0b21fXzA0N18gYXMgX3NleHBfXzA0OV8gLT5cbiAgICAgICAgICAgICAgKG1hdGNoIGF0b21fXzA0N18gd2l0aFxuICAgICAgICAgICAgICAgfCBcIkxlZnRcIiAtPlxuICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDU3XyBfc2V4cF9fMDQ5X1xuICAgICAgICAgICAgICAgfCBcIlJpZ2h0XCIgLT5cbiAgICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnB0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzA1N18gX3NleHBfXzA0OV9cbiAgICAgICAgICAgICAgIHwgXCJVbmVxdWFsXCIgLT5cbiAgICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnB0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzA1N18gX3NleHBfXzA0OV9cbiAgICAgICAgICAgICAgIHwgXyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iubm9fdmFyaWFudF9tYXRjaCAoKSlcbiAgICAgICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gYXRvbV9fMDQ3XyA6OiBzZXhwX2FyZ3NfXzA1MF8pIGFzXG4gICAgICAgICAgICAgIF9zZXhwX18wNDlfIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBhdG9tX18wNDdfIHdpdGhcbiAgICAgICAgICAgICAgIHwgXCJMZWZ0XCIgYXMgX3RhZ19fMDYzXyAtPlxuICAgICAgICAgICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wNTBfIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgWyBhcmcwX18wNjRfIF0gLT5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlczBfXzA2NV8gPSBfb2Zfdl9fMDQ0XyBhcmcwX18wNjRfIGluXG4gICAgICAgICAgICAgICAgICAgIGBMZWZ0IHJlczBfXzA2NV9cbiAgICAgICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgICAgICAgX3RhZ19fMDYzX1xuICAgICAgICAgICAgICAgICAgICAgIF9zZXhwX18wNDlfKVxuICAgICAgICAgICAgICAgfCBcIlJpZ2h0XCIgYXMgX3RhZ19fMDYwXyAtPlxuICAgICAgICAgICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wNTBfIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgWyBhcmcwX18wNjFfIF0gLT5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlczBfXzA2Ml8gPSBfb2Zfdl9fMDQ0XyBhcmcwX18wNjFfIGluXG4gICAgICAgICAgICAgICAgICAgIGBSaWdodCByZXMwX18wNjJfXG4gICAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnB0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgICAgICAgIF90YWdfXzA2MF9cbiAgICAgICAgICAgICAgICAgICAgICBfc2V4cF9fMDQ5XylcbiAgICAgICAgICAgICAgIHwgXCJVbmVxdWFsXCIgYXMgX3RhZ19fMDUxXyAtPlxuICAgICAgICAgICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wNTBfIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgWyBhcmcwX18wNThfIF0gLT5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlczBfXzA1OV8gPVxuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoIGFyZzBfXzA1OF8gd2l0aFxuICAgICAgICAgICAgICAgICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFsgYXJnMF9fMDUyXzsgYXJnMV9fMDUzXyBdIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzMF9fMDU0XyA9IF9vZl92X18wNDRfIGFyZzBfXzA1Ml9cbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZCByZXMxX18wNTVfID0gX29mX3ZfXzA0NF8gYXJnMV9fMDUzXyBpblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzMF9fMDU0XywgcmVzMV9fMDU1X1xuICAgICAgICAgICAgICAgICAgICAgIHwgc2V4cF9fMDU2XyAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnR1cGxlX29mX3NpemVfbl9leHBlY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICBzZXhwX18wNTZfXG4gICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgIGBVbmVxdWFsIHJlczBfXzA1OV9cbiAgICAgICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgICAgICAgX3RhZ19fMDUxX1xuICAgICAgICAgICAgICAgICAgICAgIF9zZXhwX18wNDlfKVxuICAgICAgICAgICAgICAgfCBfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5ub192YXJpYW50X21hdGNoICgpKVxuICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzA0OF8gLT5cbiAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfcG9seV92YXJcbiAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICBzZXhwX18wNDhfXG4gICAgICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wNDhfIC0+XG4gICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfcG9seV92YXJcbiAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICBzZXhwX18wNDhfXG4gICAgICAgICAgd2l0aFxuICAgICAgICAgIHwgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLk5vX3ZhcmlhbnRfbWF0Y2ggLT5cbiAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5ub19tYXRjaGluZ192YXJpYW50X2ZvdW5kXG4gICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICBzZXhwX18wNjZfXG4gICAgICAgIGluXG4gICAgICAgIHJlczBfXzA2OV8sIHJlczFfXzA3MF9cbiAgICAgIHwgc2V4cF9fMDcxXyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkIGVycm9yX3NvdXJjZV9fMDU3XyAyIHNleHBfXzA3MV9cbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAnayAndi5cbiAgICAoJ2sgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgndiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdrLCAndikgdFxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgID1cbiAgICBmdW4gX29mX2tfXzA3Ml8gX29mX3ZfXzA3M18gKGFyZzBfXzA4MV8sIGFyZzFfXzA4Ml8pIC0+XG4gICAgICBsZXQgcmVzMF9fMDgzXyA9IF9vZl9rX18wNzJfIGFyZzBfXzA4MV9cbiAgICAgIGFuZCByZXMxX18wODRfID1cbiAgICAgICAgbWF0Y2ggYXJnMV9fMDgyXyB3aXRoXG4gICAgICAgIHwgYExlZnQgdl9fMDc0XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkxlZnRcIjsgX29mX3ZfXzA3M18gdl9fMDc0XyBdXG4gICAgICAgIHwgYFJpZ2h0IHZfXzA3NV8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJSaWdodFwiOyBfb2Zfdl9fMDczXyB2X18wNzVfIF1cbiAgICAgICAgfCBgVW5lcXVhbCB2X18wNzZfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlVuZXF1YWxcIlxuICAgICAgICAgICAgOyAobGV0IGFyZzBfXzA3N18sIGFyZzFfXzA3OF8gPSB2X18wNzZfIGluXG4gICAgICAgICAgICAgICBsZXQgcmVzMF9fMDc5XyA9IF9vZl92X18wNzNfIGFyZzBfXzA3N19cbiAgICAgICAgICAgICAgIGFuZCByZXMxX18wODBfID0gX29mX3ZfXzA3M18gYXJnMV9fMDc4XyBpblxuICAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgcmVzMF9fMDc5XzsgcmVzMV9fMDgwXyBdKVxuICAgICAgICAgICAgXVxuICAgICAgaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIHJlczBfXzA4M187IHJlczFfXzA4NF8gXVxuICA7O1xuXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOlxuICAgICAgICAgJ2sgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgICAtPiAndiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgIC0+ICgnaywgJ3YpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gICAgPVxuICAgIGZ1biBfJ2tfc2V4cF9ncmFtbWFyIF8ndl9zZXhwX2dyYW1tYXIgLT5cbiAgICAgIHsgdW50eXBlZCA9XG4gICAgICAgICAgTGlzdFxuICAgICAgICAgICAgKENvbnNcbiAgICAgICAgICAgICAgICggXydrX3NleHBfZ3JhbW1hci51bnR5cGVkXG4gICAgICAgICAgICAgICAsIENvbnNcbiAgICAgICAgICAgICAgICAgICAoIFZhcmlhbnRcbiAgICAgICAgICAgICAgICAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJMZWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFyZ3MgPSBDb25zIChfJ3Zfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIlJpZ2h0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZV9raW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFyZ3MgPSBDb25zIChfJ3Zfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIlVuZXF1YWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJncyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIExpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKENvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBfJ3Zfc2V4cF9ncmFtbWFyLnVudHlwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBDb25zIChfJ3Zfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgRW1wdHkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAsIEVtcHR5ICkgKSlcbiAgICAgIH1cbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSBNZXJnZV9lbGVtZW50ID0gc3RydWN0XG4gIHR5cGUgKCdsZWZ0LCAncmlnaHQpIHQgPVxuICAgIFsgYExlZnQgb2YgJ2xlZnRcbiAgICB8IGBSaWdodCBvZiAncmlnaHRcbiAgICB8IGBCb3RoIG9mICdsZWZ0ICogJ3JpZ2h0XG4gICAgXVxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgbGV0IGNvbXBhcmUgOlxuICAgICdsZWZ0ICdyaWdodC5cbiAgICAoJ2xlZnQgLT4gJ2xlZnQgLT4gaW50KVxuICAgIC0+ICgncmlnaHQgLT4gJ3JpZ2h0IC0+IGludClcbiAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgLT4gaW50XG4gICAgPVxuICAgIGZ1biBfY21wX19sZWZ0IF9jbXBfX3JpZ2h0IGFfXzA4NV8gYl9fMDg2XyAtPlxuICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzA4NV8gYl9fMDg2X1xuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDg1XywgYl9fMDg2XyB3aXRoXG4gICAgICB8IGBMZWZ0IF9sZWZ0X18wODdfLCBgTGVmdCBfcmlnaHRfXzA4OF8gLT4gX2NtcF9fbGVmdCBfbGVmdF9fMDg3XyBfcmlnaHRfXzA4OF9cbiAgICAgIHwgYFJpZ2h0IF9sZWZ0X18wODlfLCBgUmlnaHQgX3JpZ2h0X18wOTBfIC0+IF9jbXBfX3JpZ2h0IF9sZWZ0X18wODlfIF9yaWdodF9fMDkwX1xuICAgICAgfCBgQm90aCBfbGVmdF9fMDkxXywgYEJvdGggX3JpZ2h0X18wOTJfIC0+XG4gICAgICAgIGxldCB0X18wOTNfLCB0X18wOTRfID0gX2xlZnRfXzA5MV8gaW5cbiAgICAgICAgbGV0IHRfXzA5NV8sIHRfXzA5Nl8gPSBfcmlnaHRfXzA5Ml8gaW5cbiAgICAgICAgKG1hdGNoIF9jbXBfX2xlZnQgdF9fMDkzXyB0X18wOTVfIHdpdGhcbiAgICAgICAgIHwgMCAtPiBfY21wX19yaWdodCB0X18wOTRfIHRfXzA5Nl9cbiAgICAgICAgIHwgbiAtPiBuKVxuICAgICAgfCB4LCB5IC0+IFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIHggeSlcbiAgOztcblxuICBsZXQgZXF1YWwgOlxuICAgICdsZWZ0ICdyaWdodC5cbiAgICAoJ2xlZnQgLT4gJ2xlZnQgLT4gYm9vbClcbiAgICAtPiAoJ3JpZ2h0IC0+ICdyaWdodCAtPiBib29sKVxuICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAtPiBib29sXG4gICAgPVxuICAgIGZ1biBfY21wX19sZWZ0IF9jbXBfX3JpZ2h0IGFfXzA5N18gYl9fMDk4XyAtPlxuICAgICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDk3XyBiX18wOThfXG4gICAgICB0aGVuIHRydWVcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBhX18wOTdfLCBiX18wOThfIHdpdGhcbiAgICAgICAgfCBgTGVmdCBfbGVmdF9fMDk5XywgYExlZnQgX3JpZ2h0X18xMDBfIC0+IF9jbXBfX2xlZnQgX2xlZnRfXzA5OV8gX3JpZ2h0X18xMDBfXG4gICAgICAgIHwgYFJpZ2h0IF9sZWZ0X18xMDFfLCBgUmlnaHQgX3JpZ2h0X18xMDJfIC0+IF9jbXBfX3JpZ2h0IF9sZWZ0X18xMDFfIF9yaWdodF9fMTAyX1xuICAgICAgICB8IGBCb3RoIF9sZWZ0X18xMDNfLCBgQm90aCBfcmlnaHRfXzEwNF8gLT5cbiAgICAgICAgICBsZXQgdF9fMTA1XywgdF9fMTA2XyA9IF9sZWZ0X18xMDNfIGluXG4gICAgICAgICAgbGV0IHRfXzEwN18sIHRfXzEwOF8gPSBfcmlnaHRfXzEwNF8gaW5cbiAgICAgICAgICBQcHhfY29tcGFyZV9saWIuKCAmJiApIChfY21wX19sZWZ0IHRfXzEwNV8gdF9fMTA3XykgKF9jbXBfX3JpZ2h0IHRfXzEwNl8gdF9fMTA4XylcbiAgICAgICAgfCB4LCB5IC0+IFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19lcXVhbCB4IHkpXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6XG4gICAgJ2xlZnQgJ3JpZ2h0LlxuICAgICgnbGVmdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdyaWdodCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICA9XG4gICAgZnVuIF9vZl9sZWZ0X18xMDlfIF9vZl9yaWdodF9fMTEwXyAtPiBmdW5jdGlvblxuICAgICAgfCBgTGVmdCB2X18xMTFfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkxlZnRcIjsgX29mX2xlZnRfXzEwOV8gdl9fMTExXyBdXG4gICAgICB8IGBSaWdodCB2X18xMTJfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlJpZ2h0XCI7IF9vZl9yaWdodF9fMTEwXyB2X18xMTJfIF1cbiAgICAgIHwgYEJvdGggdl9fMTEzXyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkJvdGhcIlxuICAgICAgICAgIDsgKGxldCBhcmcwX18xMTRfLCBhcmcxX18xMTVfID0gdl9fMTEzXyBpblxuICAgICAgICAgICAgIGxldCByZXMwX18xMTZfID0gX29mX2xlZnRfXzEwOV8gYXJnMF9fMTE0X1xuICAgICAgICAgICAgIGFuZCByZXMxX18xMTdfID0gX29mX3JpZ2h0X18xMTBfIGFyZzFfXzExNV8gaW5cbiAgICAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyByZXMwX18xMTZfOyByZXMxX18xMTdfIF0pXG4gICAgICAgICAgXVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5NYXAuQ29udGludWVfb3Jfc3RvcCAqKVxubW9kdWxlIENvbnRpbnVlX29yX3N0b3AgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IENvbnRpbnVlXG4gICAgfCBTdG9wXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlbnVtZXJhdGUsIGVxdWFsLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlID0gKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGFsbCA9IChbIENvbnRpbnVlOyBTdG9wIF0gOiB0IGxpc3QpXG4gIGxldCBlcXVhbCA9IChQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfZXF1YWwgOiB0IC0+IHQgLT4gYm9vbClcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgQ29udGludWUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiQ29udGludWVcIlxuICAgICAgfCBTdG9wIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlN0b3BcIlxuICAgICAgICAgICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk1hcC5GaW5pc2hlZF9vcl91bmZpbmlzaGVkICopXG5tb2R1bGUgRmluaXNoZWRfb3JfdW5maW5pc2hlZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgRmluaXNoZWRcbiAgICB8IFVuZmluaXNoZWRcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVudW1lcmF0ZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgbGV0IGNvbXBhcmUgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgYWxsID0gKFsgRmluaXNoZWQ7IFVuZmluaXNoZWQgXSA6IHQgbGlzdClcbiAgbGV0IGVxdWFsID0gKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19lcXVhbCA6IHQgLT4gdCAtPiBib29sKVxuXG4gIGxldCBzZXhwX29mX3QgPVxuICAgIChmdW5jdGlvblxuICAgICAgfCBGaW5pc2hlZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJGaW5pc2hlZFwiXG4gICAgICB8IFVuZmluaXNoZWQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiVW5maW5pc2hlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yc19nZW5lcmljID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdFxuICB0eXBlICgnYSwgJ2IsICdjbXApIHRyZWVcbiAgdHlwZSAnYSBrZXlcbiAgdHlwZSAnY21wIGNtcFxuICB0eXBlICgnYSwgJ2NtcCwgJ3opIG9wdGlvbnNcblxuICB2YWwgaW52YXJpYW50cyA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiBib29sKSBvcHRpb25zXG4gIHZhbCBpc19lbXB0eSA6IChfLCBfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIGxlbmd0aCA6IChfLCBfLCBfKSB0IC0+IGludFxuXG4gIHZhbCBhZGRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayBrZXkgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2R1cGxpY2F0ZS50IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBhZGRfZXhuXG4gICAgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgc2V0XG4gICAgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgYWRkX211bHRpXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+IGtleTonayBrZXkgLT4gZGF0YTondiAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIHJlbW92ZV9tdWx0aVxuICAgIDogKCdrLCAnY21wLCAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4gJ2sga2V5IC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBmaW5kX211bHRpIDogKCdrLCAnY21wLCAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4gJ2sga2V5IC0+ICd2IGxpc3QpIG9wdGlvbnNcblxuICB2YWwgY2hhbmdlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gZjooJ3Ygb3B0aW9uIC0+ICd2IG9wdGlvbikgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgdXBkYXRlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gZjooJ3Ygb3B0aW9uIC0+ICd2KSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBmaW5kIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiAndiBvcHRpb24pIG9wdGlvbnNcbiAgdmFsIGZpbmRfZXhuIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiAndikgb3B0aW9uc1xuICB2YWwgcmVtb3ZlIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBtZW0gOiAoJ2ssICdjbXAsICgnaywgXywgJ2NtcCkgdCAtPiAnayBrZXkgLT4gYm9vbCkgb3B0aW9uc1xuICB2YWwgaXRlcl9rZXlzIDogKCdrLCBfLCBfKSB0IC0+IGY6KCdrIGtleSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICd2LCBfKSB0IC0+IGY6KCd2IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdFxuXG4gIHZhbCBpdGVyaV91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gIHZhbCBpdGVyMlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOigndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+IHVuaXQpXG4gICAgICAtPiB1bml0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBtYXAgOiAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOigndjEgLT4gJ3YyKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICB2YWwgbWFwaSA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondjEgLT4gJ3YyKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICB2YWwgZm9sZCA6ICgnaywgJ3YsIF8pIHQgLT4gaW5pdDonYSAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2EgLT4gJ2EpIC0+ICdhXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYVxuICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYSAtPiAoJ2EsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6ICgnaywgJ3YsIF8pIHQgLT4gaW5pdDonYSAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2EgLT4gJ2EpIC0+ICdhXG5cbiAgdmFsIGZvbGQyXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndjEsICdjbXApIHRcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgICAtPiBpbml0OidhXG4gICAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6KCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2EgLT4gJ2EpXG4gICAgICAtPiAnYSApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZmlsdGVyX2tleXNcbiAgICA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiBmOignayBrZXkgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXIgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXJpXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZmlsdGVyX21hcFxuICAgIDogKCdrLCAnY21wLCAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOigndjEgLT4gJ3YyIG9wdGlvbikgLT4gKCdrLCAndjIsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgZmlsdGVyX21hcGlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YxIC0+ICd2MiBvcHRpb24pIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgICApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHQgKiAoJ2ssICd2MywgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgcGFydGl0aW9uX21hcFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAtPiBmOigndjEgLT4gKCd2MiwgJ3YzKSBFaXRoZXIudClcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0ICogKCdrLCAndjMsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIHBhcnRpdGlvbmlfdGZcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbClcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBwYXJ0aXRpb25fdGZcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBjb21iaW5lX2Vycm9yc1xuICAgIDogKCdrLCAnY21wLCAoJ2ssICd2IE9yX2Vycm9yLnQsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50KSBvcHRpb25zXG5cbiAgdmFsIGNvbXBhcmVfZGlyZWN0XG4gICAgOiAoJ2ssICdjbXAsICgndiAtPiAndiAtPiBpbnQpIC0+ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiBpbnQpIG9wdGlvbnNcblxuICB2YWwgZXF1YWxcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ3YgLT4gJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IC0+IGJvb2wgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGtleXMgOiAoJ2ssIF8sIF8pIHQgLT4gJ2sga2V5IGxpc3RcbiAgdmFsIGRhdGEgOiAoXywgJ3YsIF8pIHQgLT4gJ3YgbGlzdFxuXG4gIHZhbCB0b19hbGlzdFxuICAgIDogID9rZXlfb3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiAoJ2ssICd2LCBfKSB0XG4gICAgLT4gKCdrIGtleSAqICd2KSBsaXN0XG5cbiAgdmFsIG1lcmdlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndjEsICdjbXApIHRcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgICAtPiBmOihrZXk6J2sga2V5IC0+ICgndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+ICd2MyBvcHRpb24pXG4gICAgICAtPiAoJ2ssICd2MywgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gY29tYmluZTooa2V5OidrIGtleSAtPiAndiAtPiAndiAtPiAndilcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAgIC0+ICgnayBrZXksICd2KSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgU2VxdWVuY2UudCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IGRhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgICAtPiBpbml0OidhXG4gICAgICAtPiBmOignYSAtPiAoJ2sga2V5LCAndikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IC0+ICdhKVxuICAgICAgLT4gJ2EgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG1pbl9lbHQgOiAoJ2ssICd2LCBfKSB0IC0+ICgnayBrZXkgKiAndikgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sga2V5ICogJ3ZcbiAgdmFsIG1heF9lbHQgOiAoJ2ssICd2LCBfKSB0IC0+ICgnayBrZXkgKiAndikgb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sga2V5ICogJ3ZcbiAgdmFsIGZvcl9hbGwgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGxpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogKCdrLCAndiwgXykgdCAtPiBmOigndiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHNpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGludFxuICB2YWwgY291bnRpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gaW50XG5cbiAgdmFsIHNwbGl0XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gJ2sga2V5XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrIGtleSAqICd2KSBvcHRpb24gKiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBhcHBlbmRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCBsb3dlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IHVwcGVyX3BhcnQ6KCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIF0gKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gbG93ZXJfYm91bmQ6J2sga2V5IE1heWJlX2JvdW5kLnRcbiAgICAgIC0+IHVwcGVyX2JvdW5kOidrIGtleSBNYXliZV9ib3VuZC50XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IG1pbjonayBrZXlcbiAgICAgIC0+IG1heDonayBrZXlcbiAgICAgIC0+IGluaXQ6J2FcbiAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYSAtPiAnYSlcbiAgICAgIC0+ICdhIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCByYW5nZV90b19hbGlzdFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4gbWluOidrIGtleSAtPiBtYXg6J2sga2V5IC0+ICgnayBrZXkgKiAndikgbGlzdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgY2xvc2VzdF9rZXlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBbIGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiBdXG4gICAgICAtPiAnayBrZXlcbiAgICAgIC0+ICgnayBrZXkgKiAndikgb3B0aW9uIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBudGggOiAoJ2ssICd2LCAnY21wKSB0IC0+IGludCAtPiAoJ2sga2V5ICogJ3YpIG9wdGlvblxuICB2YWwgbnRoX2V4biA6ICgnaywgJ3YsICdjbXApIHQgLT4gaW50IC0+ICdrIGtleSAqICd2XG4gIHZhbCByYW5rIDogKCdrLCAnY21wLCAoJ2ssIF8sICdjbXApIHQgLT4gJ2sga2V5IC0+IGludCBvcHRpb24pIG9wdGlvbnNcbiAgdmFsIHRvX3RyZWUgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnayBrZXksICd2LCAnY21wKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgP29yZGVyOlsgYEluY3JlYXNpbmdfa2V5IHwgYERlY3JlYXNpbmdfa2V5IF1cbiAgICAgIC0+ID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG86J2sga2V5XG4gICAgICAtPiA/a2V5c19sZXNzX29yX2VxdWFsX3RvOidrIGtleVxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gY29tcGFyZTooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdrZXkgLT4gaW50KVxuICAgICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgICAtPiAna2V5XG4gICAgICAtPiAoJ2sga2V5ICogJ3YpIG9wdGlvbiApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBzZWdtZW50X29mOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgICAgLT4gKCdrIGtleSAqICd2KSBvcHRpb24gKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc3VicmFuZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBjb21wYXJlOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2JvdW5kIC0+IGludClcbiAgICAgIC0+IGxvd2VyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgICAtPiB1cHBlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMxID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlICdhIHRyZWVcbiAgdHlwZSBrZXlcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgaW52YXJpYW50cyA6IF8gdCAtPiBib29sXG4gIHZhbCBpc19lbXB0eSA6IF8gdCAtPiBib29sXG4gIHZhbCBsZW5ndGggOiBfIHQgLT4gaW50XG4gIHZhbCBhZGQgOiAnYSB0IC0+IGtleTprZXkgLT4gZGF0YTonYSAtPiAnYSB0IE9yX2R1cGxpY2F0ZS50XG4gIHZhbCBhZGRfZXhuIDogJ2EgdCAtPiBrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2EgdFxuICB2YWwgc2V0IDogJ2EgdCAtPiBrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2EgdFxuICB2YWwgYWRkX211bHRpIDogJ2EgbGlzdCB0IC0+IGtleTprZXkgLT4gZGF0YTonYSAtPiAnYSBsaXN0IHRcbiAgdmFsIHJlbW92ZV9tdWx0aSA6ICdhIGxpc3QgdCAtPiBrZXkgLT4gJ2EgbGlzdCB0XG4gIHZhbCBmaW5kX211bHRpIDogJ2EgbGlzdCB0IC0+IGtleSAtPiAnYSBsaXN0XG4gIHZhbCBjaGFuZ2UgOiAnYSB0IC0+IGtleSAtPiBmOignYSBvcHRpb24gLT4gJ2Egb3B0aW9uKSAtPiAnYSB0XG4gIHZhbCB1cGRhdGUgOiAnYSB0IC0+IGtleSAtPiBmOignYSBvcHRpb24gLT4gJ2EpIC0+ICdhIHRcbiAgdmFsIGZpbmQgOiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgdmFsIGZpbmRfZXhuIDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgdmFsIHJlbW92ZSA6ICdhIHQgLT4ga2V5IC0+ICdhIHRcbiAgdmFsIG1lbSA6IF8gdCAtPiBrZXkgLT4gYm9vbFxuICB2YWwgaXRlcl9rZXlzIDogXyB0IC0+IGY6KGtleSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogJ2EgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyaSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IHVuaXQpIC0+IHVuaXRcblxuICB2YWwgaXRlcmlfdW50aWxcbiAgICA6ICAnYSB0XG4gICAgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLnRcblxuICB2YWwgaXRlcjIgOiAnYSB0IC0+ICdiIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOignYSwgJ2IpIE1lcmdlX2VsZW1lbnQudCAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBtYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAnYiB0XG4gIHZhbCBtYXBpIDogJ2EgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2IpIC0+ICdiIHRcbiAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2IgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+ICdiIC0+ICdiKSAtPiAnYlxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgJ2EgdFxuICAgIC0+IGluaXQ6J2FjY1xuICAgIC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiAnYWNjIC0+ICgnYWNjLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6ICdhIHQgLT4gaW5pdDonYiAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2IgLT4gJ2IpIC0+ICdiXG5cbiAgdmFsIGZvbGQyXG4gICAgOiAgJ2EgdFxuICAgIC0+ICdiIHRcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooa2V5OmtleSAtPiBkYXRhOignYSwgJ2IpIE1lcmdlX2VsZW1lbnQudCAtPiAnYyAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBmaWx0ZXJfa2V5cyA6ICdhIHQgLT4gZjooa2V5IC0+IGJvb2wpIC0+ICdhIHRcbiAgdmFsIGZpbHRlciA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2EgdFxuICB2YWwgZmlsdGVyaSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IGJvb2wpIC0+ICdhIHRcbiAgdmFsIGZpbHRlcl9tYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbikgLT4gJ2IgdFxuICB2YWwgZmlsdGVyX21hcGkgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiAnYiBvcHRpb24pIC0+ICdiIHRcbiAgdmFsIHBhcnRpdGlvbl9tYXBpIDogJ2EgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gKCdiLCAnYykgRWl0aGVyLnQpIC0+ICdiIHQgKiAnYyB0XG4gIHZhbCBwYXJ0aXRpb25fbWFwIDogJ2EgdCAtPiBmOignYSAtPiAoJ2IsICdjKSBFaXRoZXIudCkgLT4gJ2IgdCAqICdjIHRcbiAgdmFsIHBhcnRpdGlvbmlfdGYgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiBib29sKSAtPiAnYSB0ICogJ2EgdFxuICB2YWwgcGFydGl0aW9uX3RmIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSB0ICogJ2EgdFxuICB2YWwgY29tYmluZV9lcnJvcnMgOiAnYSBPcl9lcnJvci50IHQgLT4gJ2EgdCBPcl9lcnJvci50XG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sXG4gIHZhbCBrZXlzIDogXyB0IC0+IGtleSBsaXN0XG4gIHZhbCBkYXRhIDogJ2EgdCAtPiAnYSBsaXN0XG4gIHZhbCB0b19hbGlzdCA6ID9rZXlfb3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF0gLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIGxpc3RcbiAgdmFsIG1lcmdlIDogJ2EgdCAtPiAnYiB0IC0+IGY6KGtleTprZXkgLT4gKCdhLCAnYikgTWVyZ2VfZWxlbWVudC50IC0+ICdjIG9wdGlvbikgLT4gJ2MgdFxuICB2YWwgbWVyZ2Vfc2tld2VkIDogJ3YgdCAtPiAndiB0IC0+IGNvbWJpbmU6KGtleTprZXkgLT4gJ3YgLT4gJ3YgLT4gJ3YpIC0+ICd2IHRcblxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICAnYSB0XG4gICAgLT4gJ2EgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCdhIC0+ICdhIC0+IGJvb2wpXG4gICAgLT4gKGtleSwgJ2EpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5cbiAgdmFsIGZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICA6ICAnYSB0XG4gICAgLT4gJ2EgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCdhIC0+ICdhIC0+IGJvb2wpXG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+IChrZXksICdhKSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgbWluX2VsdCA6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogJ2EgdCAtPiBrZXkgKiAnYVxuICB2YWwgbWF4X2VsdCA6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogJ2EgdCAtPiBrZXkgKiAnYVxuICB2YWwgZm9yX2FsbCA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbGkgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0c2kgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiBib29sKSAtPiBpbnRcbiAgdmFsIHNwbGl0IDogJ2EgdCAtPiBrZXkgLT4gJ2EgdCAqIChrZXkgKiAnYSkgb3B0aW9uICogJ2EgdFxuXG4gIHZhbCBhcHBlbmRcbiAgICA6ICBsb3dlcl9wYXJ0OidhIHRcbiAgICAtPiB1cHBlcl9wYXJ0OidhIHRcbiAgICAtPiBbIGBPayBvZiAnYSB0IHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgXVxuXG4gIHZhbCBzdWJyYW5nZVxuICAgIDogICdhIHRcbiAgICAtPiBsb3dlcl9ib3VuZDprZXkgTWF5YmVfYm91bmQudFxuICAgIC0+IHVwcGVyX2JvdW5kOmtleSBNYXliZV9ib3VuZC50XG4gICAgLT4gJ2EgdFxuXG4gIHZhbCBmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgIDogICdhIHRcbiAgICAtPiBtaW46a2V5XG4gICAgLT4gbWF4OmtleVxuICAgIC0+IGluaXQ6J2JcbiAgICAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gJ2JcblxuICB2YWwgcmFuZ2VfdG9fYWxpc3QgOiAnYSB0IC0+IG1pbjprZXkgLT4gbWF4OmtleSAtPiAoa2V5ICogJ2EpIGxpc3RcblxuICB2YWwgY2xvc2VzdF9rZXlcbiAgICA6ICAnYSB0XG4gICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgIC0+IGtleVxuICAgIC0+IChrZXkgKiAnYSkgb3B0aW9uXG5cbiAgdmFsIG50aCA6ICdhIHQgLT4gaW50IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gIHZhbCBudGhfZXhuIDogJ2EgdCAtPiBpbnQgLT4ga2V5ICogJ2FcbiAgdmFsIHJhbmsgOiBfIHQgLT4ga2V5IC0+IGludCBvcHRpb25cbiAgdmFsIHRvX3RyZWUgOiAnYSB0IC0+ICdhIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZ19rZXkgfCBgRGVjcmVhc2luZ19rZXkgXVxuICAgIC0+ID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG86a2V5XG4gICAgLT4gP2tleXNfbGVzc19vcl9lcXVhbF90bzprZXlcbiAgICAtPiAnYSB0XG4gICAgLT4gKGtleSAqICdhKSBTZXF1ZW5jZS50XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICAnYSB0XG4gICAgLT4gY29tcGFyZTooa2V5OmtleSAtPiBkYXRhOidhIC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgIC0+ICdrZXlcbiAgICAtPiAoa2V5ICogJ2EpIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogICdhIHRcbiAgICAtPiBzZWdtZW50X29mOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAtPiAoa2V5ICogJ2EpIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXG4gICAgOiAgJ2EgdFxuICAgIC0+IGNvbXBhcmU6KGtleTprZXkgLT4gZGF0YTonYSAtPiAnYm91bmQgLT4gaW50KVxuICAgIC0+IGxvd2VyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiAnYSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzMiA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAoJ2EsICdiKSB0cmVlXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGludmFyaWFudHMgOiAoXywgXykgdCAtPiBib29sXG4gIHZhbCBpc19lbXB0eSA6IChfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIGxlbmd0aCA6IChfLCBfKSB0IC0+IGludFxuICB2YWwgYWRkIDogKCdhLCAnYikgdCAtPiBrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2EsICdiKSB0IE9yX2R1cGxpY2F0ZS50XG4gIHZhbCBhZGRfZXhuIDogKCdhLCAnYikgdCAtPiBrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2EsICdiKSB0XG4gIHZhbCBzZXQgOiAoJ2EsICdiKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIGFkZF9tdWx0aSA6ICgnYSwgJ2IgbGlzdCkgdCAtPiBrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2EsICdiIGxpc3QpIHRcbiAgdmFsIHJlbW92ZV9tdWx0aSA6ICgnYSwgJ2IgbGlzdCkgdCAtPiAnYSAtPiAoJ2EsICdiIGxpc3QpIHRcbiAgdmFsIGZpbmRfbXVsdGkgOiAoJ2EsICdiIGxpc3QpIHQgLT4gJ2EgLT4gJ2IgbGlzdFxuICB2YWwgY2hhbmdlIDogKCdhLCAnYikgdCAtPiAnYSAtPiBmOignYiBvcHRpb24gLT4gJ2Igb3B0aW9uKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCB1cGRhdGUgOiAoJ2EsICdiKSB0IC0+ICdhIC0+IGY6KCdiIG9wdGlvbiAtPiAnYikgLT4gKCdhLCAnYikgdFxuICB2YWwgZmluZCA6ICgnYSwgJ2IpIHQgLT4gJ2EgLT4gJ2Igb3B0aW9uXG4gIHZhbCBmaW5kX2V4biA6ICgnYSwgJ2IpIHQgLT4gJ2EgLT4gJ2JcbiAgdmFsIHJlbW92ZSA6ICgnYSwgJ2IpIHQgLT4gJ2EgLT4gKCdhLCAnYikgdFxuICB2YWwgbWVtIDogKCdhLCAnYikgdCAtPiAnYSAtPiBib29sXG4gIHZhbCBpdGVyX2tleXMgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlciA6IChfLCAnYikgdCAtPiBmOignYiAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdFxuXG4gIHZhbCBpdGVyaV91bnRpbFxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gRmluaXNoZWRfb3JfdW5maW5pc2hlZC50XG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICgnYSwgJ2MpIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTooJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgdmFsIG1hcCA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gJ2MpIC0+ICgnYSwgJ2MpIHRcbiAgdmFsIG1hcGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjKSAtPiAoJ2EsICdjKSB0XG4gIHZhbCBmb2xkIDogKCdhLCAnYikgdCAtPiBpbml0OidjIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKSAtPiAnY1xuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdrLCAndikgdFxuICAgIC0+IGluaXQ6J2FcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYSAtPiAoJ2EsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6ICgnYSwgJ2IpIHQgLT4gaW5pdDonYyAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyAtPiAnYykgLT4gJ2NcblxuICB2YWwgZm9sZDJcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gKCdhLCAnYykgdFxuICAgIC0+IGluaXQ6J2RcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTooJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2QgLT4gJ2QpXG4gICAgLT4gJ2RcblxuICB2YWwgZmlsdGVyX2tleXMgOiAoJ2EsICdiKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIGZpbHRlciA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdFxuICB2YWwgZmlsdGVyaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdFxuICB2YWwgZmlsdGVyX21hcCA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gJ2Mgb3B0aW9uKSAtPiAoJ2EsICdjKSB0XG4gIHZhbCBmaWx0ZXJfbWFwaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2Mgb3B0aW9uKSAtPiAoJ2EsICdjKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBpXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICgnYywgJ2QpIEVpdGhlci50KVxuICAgIC0+ICgnYSwgJ2MpIHQgKiAoJ2EsICdkKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXAgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+ICgnYywgJ2QpIEVpdGhlci50KSAtPiAoJ2EsICdjKSB0ICogKCdhLCAnZCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25pX3RmXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYikgdCAqICgnYSwgJ2IpIHRcblxuICB2YWwgcGFydGl0aW9uX3RmIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0ICogKCdhLCAnYikgdFxuICB2YWwgY29tYmluZV9lcnJvcnMgOiAoJ2EsICdiIE9yX2Vycm9yLnQpIHQgLT4gKCdhLCAnYikgdCBPcl9lcnJvci50XG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgnYiAtPiAnYiAtPiBpbnQpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogKCdiIC0+ICdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBib29sXG4gIHZhbCBrZXlzIDogKCdhLCBfKSB0IC0+ICdhIGxpc3RcbiAgdmFsIGRhdGEgOiAoXywgJ2IpIHQgLT4gJ2IgbGlzdFxuICB2YWwgdG9fYWxpc3QgOiA/a2V5X29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdIC0+ICgnYSwgJ2IpIHQgLT4gKCdhICogJ2IpIGxpc3RcblxuICB2YWwgbWVyZ2VcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gKCdhLCAnYykgdFxuICAgIC0+IGY6KGtleTonYSAtPiAoJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2Qgb3B0aW9uKVxuICAgIC0+ICgnYSwgJ2QpIHRcblxuICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgOiAgKCdrLCAndikgdFxuICAgIC0+ICgnaywgJ3YpIHRcbiAgICAtPiBjb21iaW5lOihrZXk6J2sgLT4gJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgLT4gKCdrLCAndikgdFxuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ2IgLT4gJ2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiKSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgU2VxdWVuY2UudFxuXG4gIHZhbCBmb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAtPiBkYXRhX2VxdWFsOignYiAtPiAnYiAtPiBib29sKVxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOignYyAtPiAoJ2EsICdiKSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgbWluX2VsdCA6ICgnYSwgJ2IpIHQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2EsICdiKSB0IC0+ICdhICogJ2JcbiAgdmFsIG1heF9lbHQgOiAoJ2EsICdiKSB0IC0+ICgnYSAqICdiKSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdhLCAnYikgdCAtPiAnYSAqICdiXG4gIHZhbCBmb3JfYWxsIDogKF8sICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGxpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGludFxuICB2YWwgc3BsaXQgOiAoJ2EsICdiKSB0IC0+ICdhIC0+ICgnYSwgJ2IpIHQgKiAoJ2EgKiAnYikgb3B0aW9uICogKCdhLCAnYikgdFxuXG4gIHZhbCBhcHBlbmRcbiAgICA6ICBsb3dlcl9wYXJ0OignYSwgJ2IpIHRcbiAgICAtPiB1cHBlcl9wYXJ0OignYSwgJ2IpIHRcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgXVxuXG4gIHZhbCBzdWJyYW5nZVxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiBsb3dlcl9ib3VuZDonYSBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2EgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnYSwgJ2IpIHRcblxuICB2YWwgZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gbWluOidhXG4gICAgLT4gbWF4OidhXG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIHJhbmdlX3RvX2FsaXN0IDogKCdhLCAnYikgdCAtPiBtaW46J2EgLT4gbWF4OidhIC0+ICgnYSAqICdiKSBsaXN0XG5cbiAgdmFsIGNsb3Nlc3Rfa2V5XG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAtPiAnYVxuICAgIC0+ICgnYSAqICdiKSBvcHRpb25cblxuICB2YWwgbnRoIDogKCdhLCAnYikgdCAtPiBpbnQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbnRoX2V4biA6ICgnYSwgJ2IpIHQgLT4gaW50IC0+ICdhICogJ2JcbiAgdmFsIHJhbmsgOiAoJ2EsIF8pIHQgLT4gJ2EgLT4gaW50IG9wdGlvblxuICB2YWwgdG9fdHJlZSA6ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nX2tleSB8IGBEZWNyZWFzaW5nX2tleSBdXG4gICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdiKSB0XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogICgnaywgJ3YpIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAna2V5IC0+IGludClcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAtPiAna2V5XG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogICgnaywgJ3YpIHRcbiAgICAtPiBzZWdtZW50X29mOihrZXk6J2sgLT4gZGF0YTondiAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZVxuICAgIDogICgnaywgJ3YpIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYm91bmQgLT4gaW50KVxuICAgIC0+IGxvd2VyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiAoJ2ssICd2KSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzMyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjbXApIHRcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0cmVlXG5cbiAgdmFsIGludmFyaWFudHMgOiAoXywgXywgXykgdCAtPiBib29sXG4gIHZhbCBpc19lbXB0eSA6IChfLCBfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIGxlbmd0aCA6IChfLCBfLCBfKSB0IC0+IGludFxuICB2YWwgYWRkIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2R1cGxpY2F0ZS50XG4gIHZhbCBhZGRfZXhuIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCBzZXQgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgdmFsIGFkZF9tdWx0aSA6ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdCAtPiBrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcbiAgdmFsIHJlbW92ZV9tdWx0aSA6ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcbiAgdmFsIGZpbmRfbXVsdGkgOiAoJ2EsICdiIGxpc3QsICdjbXApIHQgLT4gJ2EgLT4gJ2IgbGlzdFxuICB2YWwgY2hhbmdlIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiBmOignYiBvcHRpb24gLT4gJ2Igb3B0aW9uKSAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCB1cGRhdGUgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhIC0+IGY6KCdiIG9wdGlvbiAtPiAnYikgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICB2YWwgZmluZCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gJ2Igb3B0aW9uXG4gIHZhbCBmaW5kX2V4biA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gJ2JcbiAgdmFsIHJlbW92ZSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICB2YWwgbWVtIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiBib29sXG4gIHZhbCBpdGVyX2tleXMgOiAoJ2EsIF8sICdjbXApIHQgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlciA6IChfLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyaSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdFxuXG4gIHZhbCBpdGVyaV91bnRpbFxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gRmluaXNoZWRfb3JfdW5maW5pc2hlZC50XG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTooJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgdmFsIG1hcCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooJ2IgLT4gJ2MpIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgdmFsIG1hcGkgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjKSAtPiAoJ2EsICdjLCAnY21wKSB0XG4gIHZhbCBmb2xkIDogKCdhLCAnYiwgXykgdCAtPiBpbml0OidjIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKSAtPiAnY1xuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGluaXQ6J2FcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYSAtPiAoJ2EsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6ICgnYSwgJ2IsIF8pIHQgLT4gaW5pdDonYyAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyAtPiAnYykgLT4gJ2NcblxuICB2YWwgZm9sZDJcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICAgIC0+IGluaXQ6J2RcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTooJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2QgLT4gJ2QpXG4gICAgLT4gJ2RcblxuICB2YWwgZmlsdGVyX2tleXMgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgdmFsIGZpbHRlciA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICB2YWwgZmlsdGVyaSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICB2YWwgZmlsdGVyX21hcCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooJ2IgLT4gJ2Mgb3B0aW9uKSAtPiAoJ2EsICdjLCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlcl9tYXBpXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIG9wdGlvbilcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBpXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICgnYywgJ2QpIEVpdGhlci50KVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHQgKiAoJ2EsICdkLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooJ2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdCAqICgnYSwgJ2QsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uaV90ZlxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgKiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl90ZlxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOignYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgKiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIGNvbWJpbmVfZXJyb3JzIDogKCdhLCAnYiBPcl9lcnJvci50LCAnY21wKSB0IC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuICB2YWwgY29tcGFyZV9kaXJlY3QgOiAoJ2IgLT4gJ2IgLT4gaW50KSAtPiAoJ2EsICdiLCAnY21wKSB0IC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gaW50XG4gIHZhbCBlcXVhbCA6ICgnYiAtPiAnYiAtPiBib29sKSAtPiAoJ2EsICdiLCAnY21wKSB0IC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gYm9vbFxuICB2YWwga2V5cyA6ICgnYSwgXywgXykgdCAtPiAnYSBsaXN0XG4gIHZhbCBkYXRhIDogKF8sICdiLCBfKSB0IC0+ICdiIGxpc3RcblxuICB2YWwgdG9fYWxpc3RcbiAgICA6ICA/a2V5X29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gKCdhLCAnYiwgXykgdFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG5cbiAgdmFsIG1lcmdlXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gKCdiLCAnYykgTWVyZ2VfZWxlbWVudC50IC0+ICdkIG9wdGlvbilcbiAgICAtPiAoJ2EsICdkLCAnY21wKSB0XG5cbiAgdmFsIG1lcmdlX3NrZXdlZFxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tYmluZTooa2V5OidrIC0+ICd2IC0+ICd2IC0+ICd2KVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCdiIC0+ICdiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IFNlcXVlbmNlLnRcblxuICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ2IgLT4gJ2IgLT4gYm9vbClcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gKCdhLCAnYikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIG1pbl9lbHQgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICgnYSAqICdiKSBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAqICdiXG4gIHZhbCBtYXhfZWx0IDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgKiAnYlxuICB2YWwgZm9yX2FsbCA6IChfLCAnYiwgXykgdCAtPiBmOignYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsaSA6ICgnYSwgJ2IsIF8pIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogKF8sICdiLCBfKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0c2kgOiAoJ2EsICdiLCBfKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogKF8sICdiLCBfKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGludFxuICB2YWwgY291bnRpIDogKCdhLCAnYiwgXykgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBpbnRcblxuICB2YWwgc3BsaXRcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gJ2tcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrICogJ3YpIG9wdGlvbiAqICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgYXBwZW5kXG4gICAgOiAgbG93ZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gdXBwZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIF1cblxuICB2YWwgc3VicmFuZ2VcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gbG93ZXJfYm91bmQ6J2sgTWF5YmVfYm91bmQudFxuICAgIC0+IHVwcGVyX2JvdW5kOidrIE1heWJlX2JvdW5kLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgdmFsIGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgOiAgKCdhLCAnYiwgXykgdFxuICAgIC0+IG1pbjonYVxuICAgIC0+IG1heDonYVxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCByYW5nZV90b19hbGlzdCA6ICgnYSwgJ2IsIF8pIHQgLT4gbWluOidhIC0+IG1heDonYSAtPiAoJ2EgKiAnYikgbGlzdFxuXG4gIHZhbCBjbG9zZXN0X2tleVxuICAgIDogICgnYSwgJ2IsIF8pIHRcbiAgICAtPiBbIGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiBdXG4gICAgLT4gJ2FcbiAgICAtPiAoJ2EgKiAnYikgb3B0aW9uXG5cbiAgdmFsIG50aCA6ICgnYSwgJ2IsIF8pIHQgLT4gaW50IC0+ICgnYSAqICdiKSBvcHRpb25cbiAgdmFsIG50aF9leG4gOiAoJ2EsICdiLCBfKSB0IC0+IGludCAtPiAnYSAqICdiXG4gIHZhbCByYW5rIDogKCdhLCBfLCBfKSB0IC0+ICdhIC0+IGludCBvcHRpb25cbiAgdmFsIHRvX3RyZWUgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICgnYSwgJ2IsICdjbXApIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZ19rZXkgfCBgRGVjcmVhc2luZ19rZXkgXVxuICAgIC0+ID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/a2V5c19sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnYiwgXykgdFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gY29tcGFyZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgLT4gJ2tleVxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gc2VnbWVudF9vZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc3VicmFuZ2VcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2JvdW5kIC0+IGludClcbiAgICAtPiBsb3dlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+IHVwcGVyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdFxuICB0eXBlICgnYSwgJ2IsICdjbXApIHRyZWVcblxuICB2YWwgaW52YXJpYW50cyA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiBib29sXG4gIHZhbCBpc19lbXB0eSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gYm9vbFxuICB2YWwgbGVuZ3RoIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBpbnRcblxuICB2YWwgYWRkXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBrZXk6J2FcbiAgICAtPiBkYXRhOidiXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9kdXBsaWNhdGUudFxuXG4gIHZhbCBhZGRfZXhuXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBrZXk6J2FcbiAgICAtPiBkYXRhOidiXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBzZXRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGtleTonYVxuICAgIC0+IGRhdGE6J2JcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIGFkZF9tdWx0aVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcbiAgICAtPiBrZXk6J2FcbiAgICAtPiBkYXRhOidiXG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgdmFsIHJlbW92ZV9tdWx0aVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcbiAgICAtPiAnYVxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuXG4gIHZhbCBmaW5kX211bHRpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuICAgIC0+ICdhXG4gICAgLT4gJ2IgbGlzdFxuXG4gIHZhbCBjaGFuZ2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICdhXG4gICAgLT4gZjooJ2Igb3B0aW9uIC0+ICdiIG9wdGlvbilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIHVwZGF0ZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gJ2FcbiAgICAtPiBmOignYiBvcHRpb24gLT4gJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBmaW5kIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhIC0+ICdiIG9wdGlvblxuICB2YWwgZmluZF9leG4gOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gJ2JcblxuICB2YWwgcmVtb3ZlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAnYVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgbWVtIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhIC0+IGJvb2xcbiAgdmFsIGl0ZXJfa2V5cyA6ICgnYSwgXywgJ2NtcCkgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICdiLCAnY21wKSB0IC0+IGY6KCdiIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGl0ZXJpX3VudGlsXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLnRcblxuICB2YWwgaXRlcjJcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTooJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgdmFsIG1hcCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooJ2IgLT4gJ2MpIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgdmFsIG1hcGkgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjKSAtPiAoJ2EsICdjLCAnY21wKSB0XG4gIHZhbCBmb2xkIDogKCdhLCAnYiwgXykgdCAtPiBpbml0OidjIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKSAtPiAnY1xuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGluaXQ6J2FcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYSAtPiAoJ2EsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6ICgnYSwgJ2IsIF8pIHQgLT4gaW5pdDonYyAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyAtPiAnYykgLT4gJ2NcblxuICB2YWwgZm9sZDJcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgICAtPiBpbml0OidkXG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6KCdiLCAnYykgTWVyZ2VfZWxlbWVudC50IC0+ICdkIC0+ICdkKVxuICAgIC0+ICdkXG5cbiAgdmFsIGZpbHRlcl9rZXlzXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOignYSAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgZmlsdGVyXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOignYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgZmlsdGVyaVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlcl9tYXBcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KCdiIC0+ICdjIG9wdGlvbilcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlcl9tYXBpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyBvcHRpb24pXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25fbWFwaVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdCAqICgnYSwgJ2QsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX21hcFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooJ2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdCAqICgnYSwgJ2QsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uaV90ZlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0ICogKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25fdGZcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KCdiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCAqICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgY29tYmluZV9lcnJvcnNcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiBPcl9lcnJvci50LCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgdmFsIGNvbXBhcmVfZGlyZWN0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYiAtPiAnYiAtPiBpbnQpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBpbnRcblxuICB2YWwgZXF1YWxcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdiIC0+ICdiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBib29sXG5cbiAgdmFsIGtleXMgOiAoJ2EsIF8sIF8pIHQgLT4gJ2EgbGlzdFxuICB2YWwgZGF0YSA6IChfLCAnYiwgXykgdCAtPiAnYiBsaXN0XG5cbiAgdmFsIHRvX2FsaXN0XG4gICAgOiAgP2tleV9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ICgnYSwgJ2IsIF8pIHRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuXG4gIHZhbCBtZXJnZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiAoJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2Qgb3B0aW9uKVxuICAgIC0+ICgnYSwgJ2QsICdjbXApIHRcblxuICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgOiAgY29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tYmluZTooa2V5OidrIC0+ICd2IC0+ICd2IC0+ICd2KVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBkYXRhX2VxdWFsOignYiAtPiAnYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5cbiAgdmFsIGZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBkYXRhX2VxdWFsOignYiAtPiAnYiAtPiBib29sKVxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOignYyAtPiAoJ2EsICdiKSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgbWluX2VsdCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhICogJ2JcbiAgdmFsIG1heF9lbHQgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICgnYSAqICdiKSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAqICdiXG4gIHZhbCBmb3JfYWxsIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsaSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHNpIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGludFxuXG4gIHZhbCBzcGxpdFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gJ2FcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0ICogKCdhICogJ2IpIG9wdGlvbiAqICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgYXBwZW5kXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+IGxvd2VyX3BhcnQ6KCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IHVwcGVyX3BhcnQ6KCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IsICdjbXApIHQgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyBdXG5cbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBsb3dlcl9ib3VuZDonYSBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2EgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IG1pbjonYVxuICAgIC0+IG1heDonYVxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCByYW5nZV90b19hbGlzdFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gbWluOidhXG4gICAgLT4gbWF4OidhXG4gICAgLT4gKCdhICogJ2IpIGxpc3RcblxuICB2YWwgY2xvc2VzdF9rZXlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAtPiAnYVxuICAgIC0+ICgnYSAqICdiKSBvcHRpb25cblxuICB2YWwgbnRoIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBpbnQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbnRoX2V4biA6ICgnYSwgJ2IsICdjbXApIHQgLT4gaW50IC0+ICdhICogJ2JcbiAgdmFsIHJhbmsgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gaW50IG9wdGlvblxuICB2YWwgdG9fdHJlZSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhLCAnYiwgJ2NtcCkgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiA/b3JkZXI6WyBgSW5jcmVhc2luZ19rZXkgfCBgRGVjcmVhc2luZ19rZXkgXVxuICAgIC0+ID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/a2V5c19sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGNvbXBhcmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgIC0+ICdrZXlcbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgY29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBzZWdtZW50X29mOihrZXk6J2sgLT4gZGF0YTondiAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZVxuICAgIDogIGNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2JvdW5kIC0+IGludClcbiAgICAtPiBsb3dlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+IHVwcGVyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuZW5kXG5cbigqKiBDb25zaXN0ZW5jeSBjaGVja3MgKHNhbWUgYXMgaW4gW0NvbnRhaW5lcl0pLiAqKVxubW9kdWxlIENoZWNrX2FjY2Vzc29yc1xuICAgIChUIDogVDMpXG4gICAgKFRyZWUgOiBUMylcbiAgICAoS2V5IDogVDEpXG4gICAgKENtcCA6IFQxKVxuICAgIChPcHRpb25zIDogVDMpXG4gICAgKF8gOiBBY2Nlc3NvcnNfZ2VuZXJpY1xuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIG9wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIE9wdGlvbnMudFxuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIFQudFxuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIFRyZWUudFxuICAgICB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIEtleS50XG4gICAgIHdpdGggdHlwZSAnY21wIGNtcCA6PSAnY21wIENtcC50KSA9XG5zdHJ1Y3QgZW5kXG5cbm1vZHVsZSBDaGVja19hY2Nlc3NvcnMxIChNIDogQWNjZXNzb3JzMSkgPVxuICBDaGVja19hY2Nlc3NvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gJ2IgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAnYiBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5rZXlcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5jb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2FjY2Vzc29yczIgKE0gOiBBY2Nlc3NvcnMyKSA9XG4gIENoZWNrX2FjY2Vzc29yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiKSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzMyAoTSA6IEFjY2Vzc29yczMpID1cbiAgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2FjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yIChNIDogQWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3IpID1cbiAgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKFdpdGhfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IHNpZ1xuICB0eXBlICgnaywgJ3YsICdjbXApIHRcbiAgdHlwZSAoJ2ssICd2LCAnY21wKSB0cmVlXG4gIHR5cGUgJ2sga2V5XG4gIHR5cGUgKCdhLCAnY21wLCAneikgb3B0aW9uc1xuICB0eXBlICdjbXAgY21wXG5cbiAgdmFsIGVtcHR5IDogKCdrLCAnY21wLCAoJ2ssIF8sICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIHNpbmdsZXRvbiA6ICgnaywgJ2NtcCwgJ2sga2V5IC0+ICd2IC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgbWFwX2tleXNcbiAgICA6ICggJ2syXG4gICAgICAsICdjbXAyXG4gICAgICAsICgnazEsICd2LCAnY21wMSkgdFxuICAgICAgLT4gZjooJ2sxIGtleSAtPiAnazIga2V5KVxuICAgICAgLT4gWyBgT2sgb2YgKCdrMiwgJ3YsICdjbXAyKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2syIGtleSBdIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBtYXBfa2V5c19leG5cbiAgICA6ICggJ2syXG4gICAgICAsICdjbXAyXG4gICAgICAsICgnazEsICd2LCAnY21wMSkgdCAtPiBmOignazEga2V5IC0+ICdrMiBrZXkpIC0+ICgnazIsICd2LCAnY21wMikgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgb2Zfc29ydGVkX2FycmF5XG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgYXJyYXkgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50KSBvcHRpb25zXG5cbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWRcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBhcnJheSAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkXG4gICAgOiAoJ2ssICdjbXAsIGxlbjppbnQgLT4gZjooaW50IC0+ICdrIGtleSAqICd2KSAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrIGtleSAqICd2KSBsaXN0IC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnayBrZXkgXSApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3JcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBsaXN0IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9leG4gOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgbGlzdCAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBvZl9hbGlzdF9tdWx0aSA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBsaXN0IC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9mb2xkXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrIGtleSAqICd2MSkgbGlzdCAtPiBpbml0Oid2MiAtPiBmOigndjIgLT4gJ3YxIC0+ICd2MikgLT4gKCdrLCAndjIsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X3JlZHVjZVxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gZjooJ3YgLT4gJ3YgLT4gJ3YpIC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZVxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50KSBvcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnayBrZXkgXVxuICAgICAgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX29yX2Vycm9yXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIG9wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VfZXhuIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9zZXF1ZW5jZV9tdWx0aVxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX2ZvbGRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YxKSBTZXF1ZW5jZS50XG4gICAgICAtPiBpbml0Oid2MlxuICAgICAgLT4gZjooJ3YyIC0+ICd2MSAtPiAndjIpXG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VfcmVkdWNlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IC0+IGY6KCd2IC0+ICd2IC0+ICd2KSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl9pdGVyaVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsIGl0ZXJpOihmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAgIC0+IFsgYE9rIG9mICgnaywgJ3YsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnayBrZXkgXSApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgb2ZfaXRlcmlfZXhuXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgaXRlcmk6KGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0KSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl90cmVlIDogKCdrLCAnY21wLCAoJ2sga2V5LCAndiwgJ2NtcCkgdHJlZSAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMxID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlICdhIHRyZWVcbiAgdHlwZSBrZXlcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgZW1wdHkgOiBfIHRcbiAgdmFsIHNpbmdsZXRvbiA6IGtleSAtPiAnYSAtPiAnYSB0XG4gIHZhbCBtYXBfa2V5cyA6ICd2IHQgLT4gZjooa2V5IC0+IGtleSkgLT4gWyBgT2sgb2YgJ3YgdCB8IGBEdXBsaWNhdGVfa2V5IG9mIGtleSBdXG4gIHZhbCBtYXBfa2V5c19leG4gOiAndiB0IC0+IGY6KGtleSAtPiBrZXkpIC0+ICd2IHRcbiAgdmFsIG9mX2FsaXN0IDogKGtleSAqICdhKSBsaXN0IC0+IFsgYE9rIG9mICdhIHQgfCBgRHVwbGljYXRlX2tleSBvZiBrZXkgXVxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3IgOiAoa2V5ICogJ2EpIGxpc3QgLT4gJ2EgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9hbGlzdF9leG4gOiAoa2V5ICogJ2EpIGxpc3QgLT4gJ2EgdFxuICB2YWwgb2ZfYWxpc3RfbXVsdGkgOiAoa2V5ICogJ2EpIGxpc3QgLT4gJ2EgbGlzdCB0XG4gIHZhbCBvZl9hbGlzdF9mb2xkIDogKGtleSAqICdhKSBsaXN0IC0+IGluaXQ6J2IgLT4gZjooJ2IgLT4gJ2EgLT4gJ2IpIC0+ICdiIHRcbiAgdmFsIG9mX2FsaXN0X3JlZHVjZSA6IChrZXkgKiAnYSkgbGlzdCAtPiBmOignYSAtPiAnYSAtPiAnYSkgLT4gJ2EgdFxuICB2YWwgb2Zfc29ydGVkX2FycmF5IDogKGtleSAqICdhKSBhcnJheSAtPiAnYSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgOiAoa2V5ICogJ2EpIGFycmF5IC0+ICdhIHRcbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIDogbGVuOmludCAtPiBmOihpbnQgLT4ga2V5ICogJ2EpIC0+ICdhIHRcbiAgdmFsIG9mX2luY3JlYXNpbmdfc2VxdWVuY2UgOiAoa2V5ICogJ2EpIFNlcXVlbmNlLnQgLT4gJ2EgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zZXF1ZW5jZSA6IChrZXkgKiAnYSkgU2VxdWVuY2UudCAtPiBbIGBPayBvZiAnYSB0IHwgYER1cGxpY2F0ZV9rZXkgb2Yga2V5IF1cbiAgdmFsIG9mX3NlcXVlbmNlX29yX2Vycm9yIDogKGtleSAqICdhKSBTZXF1ZW5jZS50IC0+ICdhIHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc2VxdWVuY2VfZXhuIDogKGtleSAqICdhKSBTZXF1ZW5jZS50IC0+ICdhIHRcbiAgdmFsIG9mX3NlcXVlbmNlX211bHRpIDogKGtleSAqICdhKSBTZXF1ZW5jZS50IC0+ICdhIGxpc3QgdFxuICB2YWwgb2Zfc2VxdWVuY2VfZm9sZCA6IChrZXkgKiAnYSkgU2VxdWVuY2UudCAtPiBpbml0OidiIC0+IGY6KCdiIC0+ICdhIC0+ICdiKSAtPiAnYiB0XG4gIHZhbCBvZl9zZXF1ZW5jZV9yZWR1Y2UgOiAoa2V5ICogJ2EpIFNlcXVlbmNlLnQgLT4gZjooJ2EgLT4gJ2EgLT4gJ2EpIC0+ICdhIHRcblxuICB2YWwgb2ZfaXRlcmlcbiAgICA6ICBpdGVyaTooZjooa2V5OmtleSAtPiBkYXRhOid2IC0+IHVuaXQpIC0+IHVuaXQpXG4gICAgLT4gWyBgT2sgb2YgJ3YgdCB8IGBEdXBsaWNhdGVfa2V5IG9mIGtleSBdXG5cbiAgdmFsIG9mX2l0ZXJpX2V4biA6IGl0ZXJpOihmOihrZXk6a2V5IC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdCkgLT4gJ3YgdFxuICB2YWwgb2ZfdHJlZSA6ICdhIHRyZWUgLT4gJ2EgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzMiA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAoJ2EsICdiKSB0cmVlXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGVtcHR5IDogKF8sIF8pIHRcbiAgdmFsIHNpbmdsZXRvbiA6ICdhIC0+ICdiIC0+ICgnYSwgJ2IpIHRcblxuICB2YWwgbWFwX2tleXNcbiAgICA6ICAoJ2sxLCAndikgdFxuICAgIC0+IGY6KCdrMSAtPiAnazIpXG4gICAgLT4gWyBgT2sgb2YgKCdrMiwgJ3YpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnazIgXVxuXG4gIHZhbCBtYXBfa2V5c19leG4gOiAoJ2sxLCAndikgdCAtPiBmOignazEgLT4gJ2syKSAtPiAoJ2syLCAndikgdFxuICB2YWwgb2ZfYWxpc3QgOiAoJ2EgKiAnYikgbGlzdCAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3IgOiAoJ2EgKiAnYikgbGlzdCAtPiAoJ2EsICdiKSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX2FsaXN0X2V4biA6ICgnYSAqICdiKSBsaXN0IC0+ICgnYSwgJ2IpIHRcbiAgdmFsIG9mX2FsaXN0X211bHRpIDogKCdhICogJ2IpIGxpc3QgLT4gKCdhLCAnYiBsaXN0KSB0XG4gIHZhbCBvZl9hbGlzdF9mb2xkIDogKCdhICogJ2IpIGxpc3QgLT4gaW5pdDonYyAtPiBmOignYyAtPiAnYiAtPiAnYykgLT4gKCdhLCAnYykgdFxuICB2YWwgb2ZfYWxpc3RfcmVkdWNlIDogKCdhICogJ2IpIGxpc3QgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheSA6ICgnYSAqICdiKSBhcnJheSAtPiAoJ2EsICdiKSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgOiAoJ2EgKiAnYikgYXJyYXkgLT4gKCdhLCAnYikgdFxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgOiBsZW46aW50IC0+IGY6KGludCAtPiAnYSAqICdiKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIDogKCdhICogJ2IpIFNlcXVlbmNlLnQgLT4gKCdhLCAnYikgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zZXF1ZW5jZSA6ICgnYSAqICdiKSBTZXF1ZW5jZS50IC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG4gIHZhbCBvZl9zZXF1ZW5jZV9vcl9lcnJvciA6ICgnYSAqICdiKSBTZXF1ZW5jZS50IC0+ICgnYSwgJ2IpIHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc2VxdWVuY2VfZXhuIDogKCdhICogJ2IpIFNlcXVlbmNlLnQgLT4gKCdhLCAnYikgdFxuICB2YWwgb2Zfc2VxdWVuY2VfbXVsdGkgOiAoJ2EgKiAnYikgU2VxdWVuY2UudCAtPiAoJ2EsICdiIGxpc3QpIHRcblxuICB2YWwgb2Zfc2VxdWVuY2VfZm9sZFxuICAgIDogICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICdiIC0+ICdjKVxuICAgIC0+ICgnYSwgJ2MpIHRcblxuICB2YWwgb2Zfc2VxdWVuY2VfcmVkdWNlIDogKCdhICogJ2IpIFNlcXVlbmNlLnQgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpIC0+ICgnYSwgJ2IpIHRcblxuICB2YWwgb2ZfaXRlcmlcbiAgICA6ICBpdGVyaTooZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gIHZhbCBvZl9pdGVyaV9leG4gOiBpdGVyaTooZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdCkgLT4gKCdhLCAnYikgdFxuICB2YWwgb2ZfdHJlZSA6ICgnYSwgJ2IpIHRyZWUgLT4gKCdhLCAnYikgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzM193aXRoX2NvbXBhcmF0b3IgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdHJlZVxuXG4gIHZhbCBlbXB0eSA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCBfLCAnY21wKSB0XG4gIHZhbCBzaW5nbGV0b24gOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICdhIC0+ICdiIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgbWFwX2tleXNcbiAgICA6ICBjb21wYXJhdG9yOignazIsICdjbXAyKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2sxLCAndiwgJ2NtcDEpIHRcbiAgICAtPiBmOignazEgLT4gJ2syKVxuICAgIC0+IFsgYE9rIG9mICgnazIsICd2LCAnY21wMikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrMiBdXG5cbiAgdmFsIG1hcF9rZXlzX2V4blxuICAgIDogIGNvbXBhcmF0b3I6KCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IudFxuICAgIC0+ICgnazEsICd2LCAnY21wMSkgdFxuICAgIC0+IGY6KCdrMSAtPiAnazIpXG4gICAgLT4gKCdrMiwgJ3YsICdjbXAyKSB0XG5cbiAgdmFsIG9mX2FsaXN0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cblxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3JcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgb2ZfYWxpc3RfZXhuXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9hbGlzdF9tdWx0aVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9hbGlzdF9mb2xkXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICdiIC0+ICdjKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICB2YWwgb2ZfYWxpc3RfcmVkdWNlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGFycmF5XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGFycmF5XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gZjooaW50IC0+ICdhICogJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgdmFsIG9mX3NlcXVlbmNlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cblxuICB2YWwgb2Zfc2VxdWVuY2Vfb3JfZXJyb3JcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgb2Zfc2VxdWVuY2VfZXhuXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9tdWx0aVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9mb2xkXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICdiIC0+ICdjKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICB2YWwgb2Zfc2VxdWVuY2VfcmVkdWNlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9pdGVyaVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiBpdGVyaTooZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiLCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gIHZhbCBvZl9pdGVyaV9leG5cbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gaXRlcmk6KGY6KGtleTonYSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXQpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBvZl90cmVlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRyZWVcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5lbmRcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzXG4gICAgKFQgOiBUMylcbiAgICAoVHJlZSA6IFQzKVxuICAgIChLZXkgOiBUMSlcbiAgICAoQ21wIDogVDEpXG4gICAgKE9wdGlvbnMgOiBUMylcbiAgICAoXyA6IENyZWF0b3JzX2dlbmVyaWNcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBvcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBPcHRpb25zLnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSBULnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSBUcmVlLnRcbiAgICAgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBLZXkudFxuICAgICB3aXRoIHR5cGUgJ2EgY21wIDo9ICdhIENtcC50KSA9XG5zdHJ1Y3QgZW5kXG5cbm1vZHVsZSBDaGVja19jcmVhdG9yczEgKE0gOiBDcmVhdG9yczEpID1cbiAgQ2hlY2tfY3JlYXRvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gJ2IgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAnYiBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5rZXlcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5jb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzMiAoTSA6IENyZWF0b3JzMikgPVxuICBDaGVja19jcmVhdG9yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiKSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvciAoTSA6IENyZWF0b3JzM193aXRoX2NvbXBhcmF0b3IpID1cbiAgQ2hlY2tfY3JlYXRvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoV2l0aF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzX2dlbmVyaWMgPSBzaWdcbiAgaW5jbHVkZSBDcmVhdG9yc19nZW5lcmljXG5cbiAgaW5jbHVkZVxuICAgIEFjY2Vzc29yc19nZW5lcmljXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSB0cmVlXG4gICAgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBrZXlcbiAgICB3aXRoIHR5cGUgJ2EgY21wIDo9ICdhIGNtcFxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgb3B0aW9uc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMxID0gc2lnXG4gIGluY2x1ZGUgQ3JlYXRvcnMxXG5cbiAgaW5jbHVkZVxuICAgIEFjY2Vzc29yczFcbiAgICB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gICAgd2l0aCB0eXBlICdhIHRyZWUgOj0gJ2EgdHJlZVxuICAgIHdpdGggdHlwZSBrZXkgOj0ga2V5XG4gICAgd2l0aCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA6PSBjb21wYXJhdG9yX3dpdG5lc3NcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMiA9IHNpZ1xuICBpbmNsdWRlIENyZWF0b3JzMlxuXG4gIGluY2x1ZGVcbiAgICBBY2Nlc3NvcnMyXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIHRyZWVcbiAgICB3aXRoIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzIDo9IGNvbXBhcmF0b3Jfd2l0bmVzc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvciA9IHNpZ1xuICBpbmNsdWRlIENyZWF0b3JzM193aXRoX2NvbXBhcmF0b3JcblxuICBpbmNsdWRlXG4gICAgQWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3JcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIHRyZWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX3BvbHkgPSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMlxuXG5tb2R1bGUgdHlwZSBGb3JfZGVyaXZpbmcgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gIG1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gICAgdmFsIHRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgaW5jbHVkZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgOj0gdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9ncmFtbWFyXVxuXG4gICAgdmFsIHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgQ29tcGFyZV9tID0gc2lnIGVuZFxuICBtb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxuICBtb2R1bGUgdHlwZSBIYXNoX2ZvbGRfbSA9IEhhc2hlci5TXG5cbiAgdmFsIHNleHBfb2ZfbV9fdFxuICAgIDogIChtb2R1bGUgU2V4cF9vZl9tIHdpdGggdHlwZSB0ID0gJ2spXG4gICAgLT4gKCd2IC0+IFNleHAudClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gU2V4cC50XG5cbiAgdmFsIG1fX3Rfb2Zfc2V4cFxuICAgIDogIChtb2R1bGUgTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gJ2sgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gJ2NtcClcbiAgICAtPiAoU2V4cC50IC0+ICd2KVxuICAgIC0+IFNleHAudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgbV9fdF9zZXhwX2dyYW1tYXJcbiAgICA6ICAobW9kdWxlIE1fc2V4cF9ncmFtbWFyIHdpdGggdHlwZSB0ID0gJ2spXG4gICAgLT4gJ3YgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgdmFsIGNvbXBhcmVfbV9fdFxuICAgIDogIChtb2R1bGUgQ29tcGFyZV9tKVxuICAgIC0+ICgndiAtPiAndiAtPiBpbnQpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBpbnRcblxuICB2YWwgZXF1YWxfbV9fdFxuICAgIDogIChtb2R1bGUgRXF1YWxfbSlcbiAgICAtPiAoJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGJvb2xcblxuICB2YWwgaGFzaF9mb2xkX21fX3RcbiAgICA6ICAobW9kdWxlIEhhc2hfZm9sZF9tIHdpdGggdHlwZSB0ID0gJ2spXG4gICAgLT4gKEhhc2guc3RhdGUgLT4gJ3YgLT4gSGFzaC5zdGF0ZSlcbiAgICAtPiBIYXNoLnN0YXRlXG4gICAgLT4gKCdrLCAndiwgXykgdFxuICAgIC0+IEhhc2guc3RhdGVcbmVuZFxuXG5tb2R1bGUgdHlwZSBNYXAgPSBzaWdcbiAgKCoqIFtNYXBdIGlzIGEgZnVuY3Rpb25hbCBkYXRhIHN0cnVjdHVyZSAoYmFsYW5jZWQgYmluYXJ5IHRyZWUpIGltcGxlbWVudGluZyBmaW5pdGUgbWFwc1xuICAgICAgb3ZlciBhIHRvdGFsbHktb3JkZXJlZCBkb21haW4sIGNhbGxlZCBhIFwia2V5XCIuICopXG5cbiAgdHlwZSAoJ2tleSwgKyd2YWx1ZSwgJ2NtcCkgdFxuXG4gIG1vZHVsZSBPcl9kdXBsaWNhdGUgPSBPcl9kdXBsaWNhdGVcbiAgbW9kdWxlIENvbnRpbnVlX29yX3N0b3AgPSBDb250aW51ZV9vcl9zdG9wXG5cbiAgbW9kdWxlIEZpbmlzaGVkX29yX3VuZmluaXNoZWQgOiBzaWdcbiAgICB0eXBlIHQgPSBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLnQgPVxuICAgICAgfCBGaW5pc2hlZFxuICAgICAgfCBVbmZpbmlzaGVkXG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVudW1lcmF0ZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuICAgIGluY2x1ZGUgUHB4X2VudW1lcmF0ZV9saWIuRW51bWVyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5FcXVhbC5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgICgqKiBNYXBzIFtDb250aW51ZV0gdG8gW0ZpbmlzaGVkXSBhbmQgW1N0b3BdIHRvIFtVbmZpbmlzaGVkXS4gKilcbiAgICB2YWwgb2ZfY29udGludWVfb3Jfc3RvcCA6IENvbnRpbnVlX29yX3N0b3AudCAtPiB0XG5cbiAgICAoKiogTWFwcyBbRmluaXNoZWRdIHRvIFtDb250aW51ZV0gYW5kIFtVbmZpbmlzaGVkXSB0byBbU3RvcF0uICopXG4gICAgdmFsIHRvX2NvbnRpbnVlX29yX3N0b3AgOiB0IC0+IENvbnRpbnVlX29yX3N0b3AudFxuICBlbmRcblxuICBtb2R1bGUgTWVyZ2VfZWxlbWVudCA6IHNpZ1xuICAgIHR5cGUgKCdsZWZ0LCAncmlnaHQpIHQgPVxuICAgICAgWyBgTGVmdCBvZiAnbGVmdFxuICAgICAgfCBgUmlnaHQgb2YgJ3JpZ2h0XG4gICAgICB8IGBCb3RoIG9mICdsZWZ0ICogJ3JpZ2h0XG4gICAgICBdXG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwX29mXVxuXG4gICAgdmFsIGNvbXBhcmVcbiAgICAgIDogICgnbGVmdCAtPiAnbGVmdCAtPiBpbnQpXG4gICAgICAtPiAoJ3JpZ2h0IC0+ICdyaWdodCAtPiBpbnQpXG4gICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+IGludFxuXG4gICAgdmFsIGVxdWFsXG4gICAgICA6ICAoJ2xlZnQgLT4gJ2xlZnQgLT4gYm9vbClcbiAgICAgIC0+ICgncmlnaHQgLT4gJ3JpZ2h0IC0+IGJvb2wpXG4gICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+IGJvb2xcblxuICAgIHZhbCBzZXhwX29mX3RcbiAgICAgIDogICgnbGVmdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ3JpZ2h0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgbGVmdCA6ICgnbGVmdCwgXykgdCAtPiAnbGVmdCBvcHRpb25cbiAgICB2YWwgcmlnaHQgOiAoXywgJ3JpZ2h0KSB0IC0+ICdyaWdodCBvcHRpb25cbiAgICB2YWwgbGVmdF92YWx1ZSA6ICgnbGVmdCwgXykgdCAtPiBkZWZhdWx0OidsZWZ0IC0+ICdsZWZ0XG4gICAgdmFsIHJpZ2h0X3ZhbHVlIDogKF8sICdyaWdodCkgdCAtPiBkZWZhdWx0OidyaWdodCAtPiAncmlnaHRcblxuICAgIHZhbCB2YWx1ZXNcbiAgICAgIDogICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiBsZWZ0X2RlZmF1bHQ6J2xlZnRcbiAgICAgIC0+IHJpZ2h0X2RlZmF1bHQ6J3JpZ2h0XG4gICAgICAtPiAnbGVmdCAqICdyaWdodFxuICBlbmRcblxuICB0eXBlICgnaywgJ2NtcCkgY29tcGFyYXRvciA9ICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMjEtMTJdIHVzZSBbQ29tcGFyYXRvci5Nb2R1bGUudF0gaW5zdGVhZFwiXVxuXG4gICgqKiBUZXN0IGlmIHRoZSBpbnZhcmlhbnRzIG9mIHRoZSBpbnRlcm5hbCBBVkwgc2VhcmNoIHRyZWUgaG9sZC4gKilcbiAgdmFsIGludmFyaWFudHMgOiAoXywgXywgXykgdCAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgYSBmaXJzdC1jbGFzcyBtb2R1bGUgdGhhdCBjYW4gYmUgdXNlZCB0byBidWlsZCBvdGhlciBtYXAvc2V0L2V0Yy5cbiAgICAgIHdpdGggdGhlIHNhbWUgbm90aW9uIG9mIGNvbXBhcmlzb24uICopXG4gIHZhbCBjb21wYXJhdG9yX3MgOiAoJ2EsIF8sICdjbXApIHQgLT4gKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG5cbiAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EsIF8sICdjbXApIHQgLT4gKCdhLCAnY21wKSBDb21wYXJhdG9yLnRcblxuICAoKiogVGhlIGVtcHR5IG1hcC4gKilcbiAgdmFsIGVtcHR5IDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogQSBtYXAgd2l0aCBvbmUgKGtleSwgZGF0YSkgcGFpci4gKilcbiAgdmFsIHNpbmdsZXRvbiA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnYSAtPiAnYiAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBsaXN0IHdpdGggdW5pcXVlIGtleXMuICopXG4gIHZhbCBvZl9hbGlzdFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIGxpc3Qgd2l0aCB1bmlxdWUga2V5cywgcmV0dXJuaW5nIGFuIGVycm9yIGlmXG4gICAgICBkdXBsaWNhdGUgWydhXSBrZXlzIGFyZSBmb3VuZC4gKilcbiAgdmFsIG9mX2FsaXN0X29yX2Vycm9yXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIGxpc3Qgd2l0aCB1bmlxdWUga2V5cywgcmFpc2luZyBhbiBleGNlcHRpb24gaWZcbiAgICAgIGR1cGxpY2F0ZSBbJ2FdIGtleXMgYXJlIGZvdW5kLiAqKVxuICB2YWwgb2ZfYWxpc3RfZXhuIDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICgnYSAqICdiKSBsaXN0IC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIGxpc3Qgd2l0aCBwb3NzaWJseSByZXBlYXRlZCBrZXlzLiBUaGUgdmFsdWVzIGluXG4gICAgICB0aGUgbWFwIGZvciBhIGdpdmVuIGtleSBhcHBlYXIgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhleSBkaWQgaW4gdGhlIGFzc29jaWF0aW9uXG4gICAgICBsaXN0LiAqKVxuICB2YWwgb2ZfYWxpc3RfbXVsdGlcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuXG4gICgqKiBDb21iaW5lcyBhbiBhc3NvY2lhdGlvbiBsaXN0IGludG8gYSBtYXAsIGZvbGRpbmcgdG9nZXRoZXIgYm91bmQgdmFsdWVzIHdpdGggY29tbW9uXG4gICAgICBrZXlzLiBUaGUgYWNjdW11bGF0b3IgaXMgcGVyLWtleS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgIyBsZXQgbWFwID0gU3RyaW5nLk1hcC5vZl9hbGlzdF9mb2xkXG4gICAgICAgICAgICAgICAgICAgICAgWyBcImFcIiwgMTsgXCJhXCIsIDEwOyBcImJcIiwgMjsgXCJiXCIsIDIwOyBcImJcIiwgMjAwIF1cbiAgICAgICAgICAgICAgICAgICAgICB+aW5pdDpJbnQuU2V0LmVtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgfmY6U2V0LmFkZFxuICAgICAgICAgIGluXG4gICAgICAgICAgcHJpbnRfcyBbJXNleHAgKG1hcCA6IEludC5TZXQudCBTdHJpbmcuTWFwLnQpXTs7XG4gICAgICAgICgoYSAoMSAxMCkpIChiICgyIDIwIDIwMCkpKVxuICAgICAgICAtIDogdW5pdCA9ICgpXG4gICAgICBdfVxuICAqKVxuICB2YWwgb2ZfYWxpc3RfZm9sZFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICdiIC0+ICdjKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICAoKiogQ29tYmluZXMgYW4gYXNzb2NpYXRpb24gbGlzdCBpbnRvIGEgbWFwLCByZWR1Y2luZyB0b2dldGhlciBib3VuZCB2YWx1ZXMgd2l0aCBjb21tb25cbiAgICAgIGtleXMuICopXG4gIHZhbCBvZl9hbGlzdF9yZWR1Y2VcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+IGY6KCdiIC0+ICdiIC0+ICdiKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogW29mX2l0ZXJpIH5pdGVyaV0gYmVoYXZlcyBsaWtlIFtvZl9hbGlzdF0sIGV4Y2VwdCB0aGF0IGluc3RlYWQgb2YgdGFraW5nIGEgY29uY3JldGVcbiAgICAgIGRhdGEgc3RydWN0dXJlLCBpdCB0YWtlcyBhbiBpdGVyYXRpb24gZnVuY3Rpb24uICBGb3IgaW5zdGFuY2UsIHRvIGNvbnZlcnQgYSBzdHJpbmcgdGFibGVcbiAgICAgIGludG8gYSBtYXA6IFtvZl9pdGVyaSAobW9kdWxlIFN0cmluZykgfmY6KEhhc2h0YmwuaXRlcmkgdGFibGUpXS4gIEl0IGlzIGZhc3RlciB0aGFuXG4gICAgICBhZGRpbmcgdGhlIGVsZW1lbnRzIG9uZSBieSBvbmUuICopXG4gIHZhbCBvZl9pdGVyaVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGl0ZXJpOihmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0KVxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG5cbiAgKCoqIExpa2UgW29mX2l0ZXJpXSBleGNlcHQgdGhhdCBpdCByYWlzZXMgYW4gZXhjZXB0aW9uIGlmIGR1cGxpY2F0ZSBbJ2FdIGtleXMgYXJlIGZvdW5kLiAqKVxuICB2YWwgb2ZfaXRlcmlfZXhuXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gaXRlcmk6KGY6KGtleTonYSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXQpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYSBzb3J0ZWQgYXJyYXkgb2Yga2V5LWRhdGEgcGFpcnMuIFRoZSBpbnB1dCBhcnJheSBtdXN0IGJlIHNvcnRlZFxuICAgICAgKGVpdGhlciBpbiBhc2NlbmRpbmcgb3IgZGVzY2VuZGluZyBvcmRlciksIGFzIGdpdmVuIGJ5IHRoZSByZWxldmFudCBjb21wYXJhdG9yLCBhbmRcbiAgICAgIG11c3Qgbm90IGNvbnRhaW4gZHVwbGljYXRlIGtleXMuIElmIGVpdGhlciBvZiB0aGVzZSBjb25kaXRpb25zIGRvZXMgbm90IGhvbGQsXG4gICAgICBhbiBlcnJvciBpcyByZXR1cm5lZC4gICopXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgYXJyYXlcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICAoKiogTGlrZSBbb2Zfc29ydGVkX2FycmF5XSBleGNlcHQgdGhhdCBpdCByZXR1cm5zIGEgbWFwIHdpdGggYnJva2VuIGludmFyaWFudHMgd2hlbiBhblxuICAgICAgW0Vycm9yXSB3b3VsZCBoYXZlIGJlZW4gcmV0dXJuZWQuICopXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGFycmF5XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBbb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgYyB+bGVuIH5mXSBiZWhhdmVzIGxpa2UgW29mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgY1xuICAgICAgKEFycmF5LmluaXQgbGVuIH5mKV0sIHdpdGggdGhlIGFkZGl0aW9uYWwgcmVzdHJpY3Rpb24gdGhhdCBhIGRlY3JlYXNpbmcgb3JkZXIgaXMgbm90XG4gICAgICBzdXBwb3J0ZWQuICBUaGUgYWR2YW50YWdlIGlzIG5vdCByZXF1aXJpbmcgeW91IHRvIGFsbG9jYXRlIGFuIGludGVybWVkaWF0ZSBhcnJheS4gIFtmXVxuICAgICAgd2lsbCBiZSBjYWxsZWQgd2l0aCAwLCAxLCAuLi4gW2xlbiAtIDFdLCBpbiBvcmRlci4gKilcbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gbGVuOmludFxuICAgIC0+IGY6KGludCAtPiAnYSAqICdiKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogW29mX2luY3JlYXNpbmdfc2VxdWVuY2UgYyBzZXFdIGJlaGF2ZXMgbGlrZSBbb2Zfc29ydGVkX2FycmF5IGMgKFNlcXVlbmNlLnRvX2FycmF5XG4gICAgICBzZXEpXSwgYnV0IGRvZXMgbm90IGFsbG9jYXRlIHRoZSBpbnRlcm1lZGlhdGUgYXJyYXkuXG5cbiAgICAgIFRoZSBzZXF1ZW5jZSB3aWxsIGJlIGZvbGRlZCBvdmVyIG9uY2UsIGFuZCB0aGUgYWRkaXRpb25hbCB0aW1lIGNvbXBsZXhpdHkgaXMge2UgTyhuKX0uXG4gICopXG4gIHZhbCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlXG4gICAgOiAgKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrICogJ3YpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIHNlcXVlbmNlIHdpdGggdW5pcXVlIGtleXMuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZSBjIHNlcV0gYmVoYXZlcyBsaWtlIFtvZl9hbGlzdCBjIChTZXF1ZW5jZS50b19saXN0IHNlcSldIGJ1dFxuICAgICAgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuXG4gICAgICBJZiB5b3VyIHNlcXVlbmNlIGlzIGluY3JlYXNpbmcsIHVzZSBbb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZV0uXG4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZVxuICAgIDogICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnayAqICd2KSBTZXF1ZW5jZS50XG4gICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIF1cblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIHNlcXVlbmNlIHdpdGggdW5pcXVlIGtleXMsIHJldHVybmluZyBhbiBlcnJvciBpZlxuICAgICAgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZV9vcl9lcnJvciBjIHNlcV0gYmVoYXZlcyBsaWtlIFtvZl9hbGlzdF9vcl9lcnJvciBjIChTZXF1ZW5jZS50b19saXN0IHNlcSldXG4gICAgICBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2Vfb3JfZXJyb3JcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gc2VxdWVuY2Ugd2l0aCB1bmlxdWUga2V5cywgcmFpc2luZyBhbiBleGNlcHRpb24gaWZcbiAgICAgIGR1cGxpY2F0ZSBbJ2FdIGtleXMgYXJlIGZvdW5kLlxuXG4gICAgICBbb2Zfc2VxdWVuY2VfZXhuIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X2V4biBjIChTZXF1ZW5jZS50b19saXN0IHNlcSldIGJ1dFxuICAgICAgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VfZXhuXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSB3aXRoIHBvc3NpYmx5IHJlcGVhdGVkIGtleXMuIFRoZSB2YWx1ZXMgaW5cbiAgICAgIHRoZSBtYXAgZm9yIGEgZ2l2ZW4ga2V5IGFwcGVhciBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGV5IGRpZCBpbiB0aGUgYXNzb2NpYXRpb25cbiAgICAgIGxpc3QuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZV9tdWx0aSBjIHNlcV0gYmVoYXZlcyBsaWtlIFtvZl9hbGlzdF9leG4gYyAoU2VxdWVuY2UudG9fbGlzdCBzZXEpXSBidXRcbiAgICAgIGRvZXMgbm90IGFsbG9jYXRlIHRoZSBpbnRlcm1lZGlhdGUgbGlzdC5cbiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlX211bHRpXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcblxuICAoKiogQ29tYmluZXMgYW4gYXNzb2NpYXRpb24gc2VxdWVuY2UgaW50byBhIG1hcCwgZm9sZGluZyB0b2dldGhlciBib3VuZCB2YWx1ZXMgd2l0aCBjb21tb25cbiAgICAgIGtleXMuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZV9mb2xkIGMgc2VxIH5pbml0IH5mXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X2ZvbGQgYyAoU2VxdWVuY2UudG9fbGlzdCBzZXEpIH5pbml0IH5mXVxuICAgICAgYnV0IGRvZXMgbm90IGFsbG9jYXRlIHRoZSBpbnRlcm1lZGlhdGUgbGlzdC5cbiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlX2ZvbGRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOignYyAtPiAnYiAtPiAnYylcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG5cbiAgKCoqIENvbWJpbmVzIGFuIGFzc29jaWF0aW9uIHNlcXVlbmNlIGludG8gYSBtYXAsIHJlZHVjaW5nIHRvZ2V0aGVyIGJvdW5kIHZhbHVlcyB3aXRoIGNvbW1vblxuICAgICAga2V5cy5cblxuICAgICAgW29mX3NlcXVlbmNlX3JlZHVjZSBjIHNlcSB+Zl0gYmVoYXZlcyBsaWtlIFtvZl9hbGlzdF9yZWR1Y2UgYyAoU2VxdWVuY2UudG9fbGlzdCBzZXEpIH5mXVxuICAgICAgYnV0IGRvZXMgbm90IGFsbG9jYXRlIHRoZSBpbnRlcm1lZGlhdGUgbGlzdC4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZV9yZWR1Y2VcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+IGY6KCdiIC0+ICdiIC0+ICdiKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogVGVzdHMgd2hldGhlciBhIG1hcCBpcyBlbXB0eS4gKilcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8sIF8pIHQgLT4gYm9vbFxuXG4gICgqKiBbbGVuZ3RoIG1hcF0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIFttYXBdLiAgTygxKSwgYnV0IFtUcmVlLmxlbmd0aF0gaXNcbiAgICAgIE8obikuICopXG4gIHZhbCBsZW5ndGggOiAoXywgXywgXykgdCAtPiBpbnRcblxuICAoKiogUmV0dXJucyBhIG5ldyBtYXAgd2l0aCB0aGUgc3BlY2lmaWVkIG5ldyBiaW5kaW5nOyBpZiB0aGUga2V5IHdhcyBhbHJlYWR5IGJvdW5kLCBpdHNcbiAgICAgIHByZXZpb3VzIGJpbmRpbmcgZGlzYXBwZWFycy4gKilcbiAgdmFsIHNldCA6ICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbYWRkIHQgfmtleSB+ZGF0YV0gYWRkcyBhIG5ldyBlbnRyeSB0byBbdF0gbWFwcGluZyBba2V5XSB0byBbZGF0YV0gYW5kIHJldHVybnMgW2BPa11cbiAgICAgIHdpdGggdGhlIG5ldyBtYXAsIG9yIGlmIFtrZXldIGlzIGFscmVhZHkgcHJlc2VudCBpbiBbdF0sIHJldHVybnMgW2BEdXBsaWNhdGVdLiAqKVxuICB2YWwgYWRkIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2R1cGxpY2F0ZS50XG5cbiAgdmFsIGFkZF9leG4gOiAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogSWYgW2tleV0gaXMgbm90IHByZXNlbnQgdGhlbiBhZGQgYSBzaW5nbGV0b24gbGlzdCwgb3RoZXJ3aXNlLCBjb25zIGRhdGEgb250byB0aGVcbiAgICAgIGhlYWQgb2YgdGhlIGV4aXN0aW5nIGxpc3QuICopXG4gIHZhbCBhZGRfbXVsdGkgOiAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4ga2V5OidrIC0+IGRhdGE6J3YgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0XG5cbiAgKCoqIElmIHRoZSBrZXkgaXMgcHJlc2VudCwgdGhlbiByZW1vdmUgaXRzIGhlYWQgZWxlbWVudDsgaWYgdGhlIHJlc3VsdCBpcyBlbXB0eSwgcmVtb3ZlXG4gICAgICB0aGUga2V5LiAqKVxuICB2YWwgcmVtb3ZlX211bHRpIDogKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+ICdrIC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdFxuXG4gICgqKiBSZXR1cm5zIHRoZSB2YWx1ZSBib3VuZCB0byB0aGUgZ2l2ZW4ga2V5LCBvciB0aGUgZW1wdHkgbGlzdCBpZiB0aGVyZSBpcyBub25lLiAqKVxuICB2YWwgZmluZF9tdWx0aSA6ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiAnayAtPiAndiBsaXN0XG5cbiAgKCoqIFtjaGFuZ2UgdCBrZXkgfmZdIHJldHVybnMgYSBuZXcgbWFwIFttXSB0aGF0IGlzIHRoZSBzYW1lIGFzIFt0XSBvbiBhbGwga2V5cyBleGNlcHRcbiAgICAgIGZvciBba2V5XSwgYW5kIHdob3NlIHZhbHVlIGZvciBba2V5XSBpcyBkZWZpbmVkIGJ5IFtmXSwgaS5lLiwgW2ZpbmQgbSBrZXkgPSBmIChmaW5kXG4gICAgICB0IGtleSldLiAqKVxuICB2YWwgY2hhbmdlIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiBmOigndiBvcHRpb24gLT4gJ3Ygb3B0aW9uKSAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFt1cGRhdGUgdCBrZXkgfmZdIGlzIFtjaGFuZ2UgdCBrZXkgfmY6KGZ1biBvIC0+IFNvbWUgKGYgbykpXS4gKilcbiAgdmFsIHVwZGF0ZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gZjooJ3Ygb3B0aW9uIC0+ICd2KSAtPiAoJ2ssICd2LCAnY21wKSB0XG5cblxuICAoKiogUmV0dXJucyBbU29tZSB2YWx1ZV0gYm91bmQgdG8gdGhlIGdpdmVuIGtleSwgb3IgW05vbmVdIGlmIG5vbmUgZXhpc3RzLiAqKVxuICB2YWwgZmluZCA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gJ3Ygb3B0aW9uXG5cbiAgKCoqIFJldHVybnMgdGhlIHZhbHVlIGJvdW5kIHRvIHRoZSBnaXZlbiBrZXksIHJhaXNpbmcgW0NhbWwuTm90X2ZvdW5kXSBvciBbTm90X2ZvdW5kX3NdXG4gICAgICBpZiBub25lIGV4aXN0cy4gKilcbiAgdmFsIGZpbmRfZXhuIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiAndlxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IG1hcCB3aXRoIGFueSBiaW5kaW5nIGZvciB0aGUga2V5IGluIHF1ZXN0aW9uIHJlbW92ZWQuICopXG4gIHZhbCByZW1vdmUgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW21lbSBtYXAga2V5XSB0ZXN0cyB3aGV0aGVyIFttYXBdIGNvbnRhaW5zIGEgYmluZGluZyBmb3IgW2tleV0uICopXG4gIHZhbCBtZW0gOiAoJ2ssIF8sICdjbXApIHQgLT4gJ2sgLT4gYm9vbFxuXG4gIHZhbCBpdGVyX2tleXMgOiAoJ2ssIF8sIF8pIHQgLT4gZjooJ2sgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlciA6IChfLCAndiwgXykgdCAtPiBmOigndiAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyaSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBJdGVyYXRlcyB1bnRpbCB0aGUgZmlyc3QgdGltZSBbZl0gcmV0dXJucyBbU3RvcF0uIElmIFtmXSByZXR1cm5zIFtTdG9wXSwgdGhlIGZpbmFsXG4gICAgICByZXN1bHQgaXMgW1VuZmluaXNoZWRdLiBPdGhlcndpc2UsIHRoZSBmaW5hbCByZXN1bHQgaXMgW0ZpbmlzaGVkXS4gKilcbiAgdmFsIGl0ZXJpX3VudGlsXG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLnRcblxuICAoKiogSXRlcmF0ZXMgdHdvIG1hcHMgc2lkZSBieSBzaWRlLiBUaGUgY29tcGxleGl0eSBvZiB0aGlzIGZ1bmN0aW9uIGlzIE8oTSArIE4pLiAgSWYgdHdvXG4gICAgICBpbnB1dHMgYXJlIFtbKDAsIGEpOyAoMSwgYSldXSBhbmQgW1soMSwgYik7ICgyLCBiKV1dLCBbZl0gd2lsbCBiZSBjYWxsZWQgd2l0aCBbWygwLFxuICAgICAgYExlZnQgYSk7ICgxLCBgQm90aCAoYSwgYikpOyAoMiwgYFJpZ2h0IGIpXV0uICopXG4gIHZhbCBpdGVyMlxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTooJ3YxLCAndjIpIE1lcmdlX2VsZW1lbnQudCAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICAoKiogUmV0dXJucyBhIG5ldyBtYXAgd2l0aCBib3VuZCB2YWx1ZXMgcmVwbGFjZWQgYnkgW2ZdIGFwcGxpZWQgdG8gdGhlIGJvdW5kIHZhbHVlcy4qKVxuICB2YWwgbWFwIDogKCdrLCAndjEsICdjbXApIHQgLT4gZjooJ3YxIC0+ICd2MikgLT4gKCdrLCAndjIsICdjbXApIHRcblxuICAoKiogTGlrZSBbbWFwXSwgYnV0IHRoZSBwYXNzZWQgZnVuY3Rpb24gdGFrZXMgYm90aCBba2V5XSBhbmQgW2RhdGFdIGFzIGFyZ3VtZW50cy4gKilcbiAgdmFsIG1hcGkgOiAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondjEgLT4gJ3YyKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gICgqKiBDb252ZXJ0IG1hcCB3aXRoIGtleXMgb2YgdHlwZSBbJ2syXSB0byBhIG1hcCB3aXRoIGtleXMgb2YgdHlwZSBbJ2syXSB1c2luZyBbZl0uICopXG4gIHZhbCBtYXBfa2V5c1xuICAgIDogICgnazIsICdjbXAyKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrMSwgJ3YsICdjbXAxKSB0XG4gICAgLT4gZjooJ2sxIC0+ICdrMilcbiAgICAtPiBbIGBPayBvZiAoJ2syLCAndiwgJ2NtcDIpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnazIgXVxuXG4gICgqKiBMaWtlIFttYXBfa2V5c10sIGJ1dCByYWlzZXMgb24gZHVwbGljYXRlIGtleS4gKilcbiAgdmFsIG1hcF9rZXlzX2V4blxuICAgIDogICgnazIsICdjbXAyKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrMSwgJ3YsICdjbXAxKSB0XG4gICAgLT4gZjooJ2sxIC0+ICdrMilcbiAgICAtPiAoJ2syLCAndiwgJ2NtcDIpIHRcblxuICAoKiogRm9sZHMgb3ZlciBrZXlzIGFuZCBkYXRhIGluIHRoZSBtYXAgaW4gaW5jcmVhc2luZyBvcmRlciBvZiBba2V5XS4gKilcbiAgdmFsIGZvbGQgOiAoJ2ssICd2LCBfKSB0IC0+IGluaXQ6J2EgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2EgLT4gJ2EpIC0+ICdhXG5cbiAgKCoqIEZvbGRzIG92ZXIga2V5cyBhbmQgZGF0YSBpbiB0aGUgbWFwIGluIGluY3JlYXNpbmcgb3JkZXIgb2YgW2tleV0sIHVudGlsIHRoZSBmaXJzdFxuICAgICAgdGltZSB0aGF0IFtmXSByZXR1cm5zIFtTdG9wIF9dLiBJZiBbZl0gcmV0dXJucyBbU3RvcCBmaW5hbF0sIHRoaXMgZnVuY3Rpb24gcmV0dXJuc1xuICAgICAgaW1tZWRpYXRlbHkgd2l0aCB0aGUgdmFsdWUgW2ZpbmFsXS4gSWYgW2ZdIG5ldmVyIHJldHVybnMgW1N0b3AgX10sIGFuZCB0aGUgZmluYWxcbiAgICAgIGNhbGwgdG8gW2ZdIHJldHVybnMgW0NvbnRpbnVlIGxhc3RdLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgW2ZpbmlzaCBsYXN0XS4gKilcbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2FjYyAtPiAoJ2FjYywgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjYyAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIEZvbGRzIG92ZXIga2V5cyBhbmQgZGF0YSBpbiB0aGUgbWFwIGluIGRlY3JlYXNpbmcgb3JkZXIgb2YgW2tleV0uICopXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdrLCAndiwgXykgdCAtPiBpbml0OidhIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhIC0+ICdhKSAtPiAnYVxuXG4gICgqKiBGb2xkcyBvdmVyIHR3byBtYXBzIHNpZGUgYnkgc2lkZSwgbGlrZSBbaXRlcjJdLiAqKVxuICB2YWwgZm9sZDJcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgLT4gaW5pdDonYVxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOigndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+ICdhIC0+ICdhKVxuICAgIC0+ICdhXG5cbiAgKCoqIFtmaWx0ZXJdLCBbZmlsdGVyaV0sIFtmaWx0ZXJfa2V5c10sIFtmaWx0ZXJfbWFwXSwgYW5kIFtmaWx0ZXJfbWFwaV0gcnVuIGluIE8obiAqIGxnXG4gICAgICBuKSB0aW1lOyB0aGV5IHNpbXBseSBhY2N1bXVsYXRlIGVhY2gga2V5ICYgZGF0YSBwYWlyIHJldGFpbmVkIGJ5IFtmXSBpbnRvIGEgbmV3IG1hcFxuICAgICAgdXNpbmcgW2FkZF0uICopXG4gIHZhbCBmaWx0ZXJfa2V5cyA6ICgnaywgJ3YsICdjbXApIHQgLT4gZjooJ2sgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBmaWx0ZXIgOiAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgdmFsIGZpbHRlcmkgOiAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogUmV0dXJucyBhIG5ldyBtYXAgd2l0aCBib3VuZCB2YWx1ZXMgZmlsdGVyZWQgYnkgW2ZdIGFwcGxpZWQgdG8gdGhlIGJvdW5kIHZhbHVlcy4gKilcbiAgdmFsIGZpbHRlcl9tYXAgOiAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOigndjEgLT4gJ3YyIG9wdGlvbikgLT4gKCdrLCAndjIsICdjbXApIHRcblxuICAoKiogTGlrZSBbZmlsdGVyX21hcF0sIGJ1dCB0aGUgcGFzc2VkIGZ1bmN0aW9uIHRha2VzIGJvdGggW2tleV0gYW5kIFtkYXRhXSBhc1xuICAgICAgYXJndW1lbnRzLiAqKVxuICB2YWwgZmlsdGVyX21hcGlcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAndjIgb3B0aW9uKVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgKCoqIFtwYXJ0aXRpb25fbWFwaSB0IH5mXSByZXR1cm5zIHR3byBuZXcgW3Rdcywgd2l0aCBlYWNoIGtleSBpbiBbdF0gYXBwZWFyaW5nIGluXG4gICAgICBleGFjdGx5IG9uZSBvZiB0aGUgcmVzdWx0aW5nIG1hcHMgZGVwZW5kaW5nIG9uIGl0cyBtYXBwaW5nIGluIFtmXS4gKilcbiAgdmFsIHBhcnRpdGlvbl9tYXBpXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondjEgLT4gKCd2MiwgJ3YzKSBFaXRoZXIudClcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCAqICgnaywgJ3YzLCAnY21wKSB0XG5cbiAgKCoqIFtwYXJ0aXRpb25fbWFwIHQgfmYgPSBwYXJ0aXRpb25fbWFwaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSldICopXG4gIHZhbCBwYXJ0aXRpb25fbWFwXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiBmOigndjEgLT4gKCd2MiwgJ3YzKSBFaXRoZXIudClcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCAqICgnaywgJ3YzLCAnY21wKSB0XG5cbiAgKCoqXG4gICAgIHtbXG4gICAgICAgcGFydGl0aW9uaV90ZiB0IH5mXG4gICAgICAgPVxuICAgICAgIHBhcnRpdGlvbl9tYXBpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICAgICBpZiBmIH5rZXkgfmRhdGFcbiAgICAgICAgIHRoZW4gRmlyc3QgZGF0YVxuICAgICAgICAgZWxzZSBTZWNvbmQgZGF0YSlcbiAgICAgXX0gKilcbiAgdmFsIHBhcnRpdGlvbmlfdGZcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0ICogKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbcGFydGl0aW9uX3RmIHQgfmYgPSBwYXJ0aXRpb25pX3RmIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKV0gKilcbiAgdmFsIHBhcnRpdGlvbl90ZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBmOigndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFByb2R1Y2VzIFtPa10gb2YgYSBtYXAgaW5jbHVkaW5nIGFsbCBrZXlzIGlmIGFsbCBkYXRhIGlzIFtPa10sIG9yIGFuIFtFcnJvcl1cbiAgICAgIGluY2x1ZGluZyBhbGwgZXJyb3JzIG90aGVyd2lzZS4gKilcbiAgdmFsIGNvbWJpbmVfZXJyb3JzIDogKCdrLCAndiBPcl9lcnJvci50LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBSZXR1cm5zIGEgdG90YWwgb3JkZXJpbmcgYmV0d2VlbiBtYXBzLiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgYSB0b3RhbCBvcmRlcmluZyB1c2VkXG4gICAgICB0byBjb21wYXJlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGVxdWFsIGtleXMgaW4gdGhlIHR3byBtYXBzLiAqKVxuICB2YWwgY29tcGFyZV9kaXJlY3QgOiAoJ3YgLT4gJ3YgLT4gaW50KSAtPiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgLT4gaW50XG5cbiAgKCoqIEhhc2ggZnVuY3Rpb246IGEgYnVpbGRpbmcgYmxvY2sgdG8gdXNlIHdoZW4gaGFzaGluZyBkYXRhIHN0cnVjdHVyZXMgY29udGFpbmluZyBtYXBzIGluXG4gICAgICB0aGVtLiBbaGFzaF9mb2xkX2RpcmVjdCBoYXNoX2ZvbGRfa2V5XSBpcyBjb21wYXRpYmxlIHdpdGggW2NvbXBhcmVfZGlyZWN0XSBpZmZcbiAgICAgIFtoYXNoX2ZvbGRfa2V5XSBpcyBjb21wYXRpYmxlIHdpdGggWyhjb21wYXJhdG9yIG0pLmNvbXBhcmVdIG9mIHRoZSBtYXAgW21dIGJlaW5nXG4gICAgICBoYXNoZWQuICopXG4gIHZhbCBoYXNoX2ZvbGRfZGlyZWN0IDogJ2sgSGFzaC5mb2xkZXIgLT4gJ3YgSGFzaC5mb2xkZXIgLT4gKCdrLCAndiwgJ2NtcCkgdCBIYXNoLmZvbGRlclxuXG4gICgqKiBbZXF1YWwgY21wIG0xIG0yXSB0ZXN0cyB3aGV0aGVyIHRoZSBtYXBzIFttMV0gYW5kIFttMl0gYXJlIGVxdWFsLCB0aGF0IGlzLCBjb250YWluXG4gICAgICB0aGUgc2FtZSBrZXlzIGFuZCBhc3NvY2lhdGUgZWFjaCBrZXkgd2l0aCB0aGUgc2FtZSB2YWx1ZS4gIFtjbXBdIGlzIHRoZSBlcXVhbGl0eVxuICAgICAgcHJlZGljYXRlIHVzZWQgdG8gY29tcGFyZSB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5cy4gKilcbiAgdmFsIGVxdWFsIDogKCd2IC0+ICd2IC0+IGJvb2wpIC0+ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgYSBsaXN0IG9mIHRoZSBrZXlzIGluIHRoZSBnaXZlbiBtYXAuICopXG4gIHZhbCBrZXlzIDogKCdrLCBfLCBfKSB0IC0+ICdrIGxpc3RcblxuICAoKiogUmV0dXJucyBhIGxpc3Qgb2YgdGhlIGRhdGEgaW4gdGhlIGdpdmVuIG1hcC4gKilcbiAgdmFsIGRhdGEgOiAoXywgJ3YsIF8pIHQgLT4gJ3YgbGlzdFxuXG4gICgqKiBDcmVhdGVzIGFuIGFzc29jaWF0aW9uIGxpc3QgZnJvbSB0aGUgZ2l2ZW4gbWFwLiAqKVxuICB2YWwgdG9fYWxpc3RcbiAgICA6ICA/a2V5X29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdICgqKiBkZWZhdWx0IGlzIFtgSW5jcmVhc2luZ10gKilcbiAgICAtPiAoJ2ssICd2LCBfKSB0XG4gICAgLT4gKCdrICogJ3YpIGxpc3RcblxuICAoKiogezIgQWRkaXRpb25hbCBvcGVyYXRpb25zIG9uIG1hcHN9ICopXG5cbiAgKCoqIE1lcmdlcyB0d28gbWFwcy4gVGhlIHJ1bnRpbWUgaXMgTyhsZW5ndGgodDEpICsgbGVuZ3RoKHQyKSkuIFlvdSBzaG91bGRuJ3QgdXNlIHRoaXNcbiAgICAgIGZ1bmN0aW9uIHRvIG1lcmdlIGEgbGlzdCBvZiBtYXBzOyBjb25zaWRlciB1c2luZyBbbWVyZ2Vfc2tld2VkXSBpbnN0ZWFkLiAqKVxuICB2YWwgbWVyZ2VcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidrIC0+ICgndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+ICd2MyBvcHRpb24pXG4gICAgLT4gKCdrLCAndjMsICdjbXApIHRcblxuICAoKiogQSBzcGVjaWFsIGNhc2Ugb2YgW21lcmdlXSwgW21lcmdlX3NrZXdlZCB0MSB0Ml0gaXMgYSBtYXAgY29udGFpbmluZyBhbGwgdGhlXG4gICAgICBiaW5kaW5ncyBvZiBbdDFdIGFuZCBbdDJdLiBCaW5kaW5ncyB0aGF0IGFwcGVhciBpbiBib3RoIFt0MV0gYW5kIFt0Ml0gYXJlXG4gICAgICBjb21iaW5lZCBpbnRvIGEgc2luZ2xlIHZhbHVlIHVzaW5nIHRoZSBbY29tYmluZV0gZnVuY3Rpb24uIEluIGEgY2FsbFxuICAgICAgW2NvbWJpbmUgfmtleSB2MSB2Ml0sIHRoZSB2YWx1ZSBbdjFdIGNvbWVzIGZyb20gW3QxXSBhbmQgW3YyXSBmcm9tIFt0Ml0uXG5cbiAgICAgIFRoZSBydW50aW1lIG9mIFttZXJnZV9za2V3ZWRdIGlzIFtPKG1pbihsMSwgbDIpICogbG9nKG1heChsMSwgbDIpKSldLCB3aGVyZSBbbDFdIGlzXG4gICAgICB0aGUgbGVuZ3RoIG9mIFt0MV0gYW5kIFtsMl0gdGhlIGxlbmd0aCBvZiBbdDJdLiBUaGlzIGlzIGxpa2VseSB0byBiZSBmYXN0ZXIgdGhhblxuICAgICAgW21lcmdlXSB3aGVuIG9uZSBvZiB0aGUgbWFwcyBpcyBhIGxvdCBzbWFsbGVyLCBvciB3aGVuIHlvdSBtZXJnZSBhIGxpc3Qgb2YgbWFwcy4gKilcbiAgdmFsIG1lcmdlX3NrZXdlZFxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tYmluZTooa2V5OidrIC0+ICd2IC0+ICd2IC0+ICd2KVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICBtb2R1bGUgU3ltbWV0cmljX2RpZmZfZWxlbWVudCA6IHNpZ1xuICAgIHR5cGUgKCdrLCAndikgdCA9ICdrICogWyBgTGVmdCBvZiAndiB8IGBSaWdodCBvZiAndiB8IGBVbmVxdWFsIG9mICd2ICogJ3YgXVxuICAgIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMiB3aXRoIHR5cGUgKCdrLCAndikgdCA6PSAoJ2ssICd2KSB0XG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuRXF1YWwuUzIgd2l0aCB0eXBlICgnaywgJ3YpIHQgOj0gKCdrLCAndikgdFxuICAgIGluY2x1ZGUgU2V4cGxpYjAuU2V4cGFibGUuUzIgd2l0aCB0eXBlICgnaywgJ3YpIHQgOj0gKCdrLCAndikgdFxuXG4gICAgdmFsIHRfc2V4cF9ncmFtbWFyXG4gICAgICA6ICAnayBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgLT4gJ3YgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgIC0+ICgnaywgJ3YpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gICgqKiBbc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWxdIHJldHVybnMgYSBsaXN0IG9mIGNoYW5nZXMgYmV0d2VlbiBbdDFdIGFuZCBbdDJdLlxuICAgICAgSXQgaXMgaW50ZW5kZWQgdG8gYmUgZWZmaWNpZW50IGluIHRoZSBjYXNlIHdoZXJlIFt0MV0gYW5kIFt0Ml0gc2hhcmUgYSBsYXJnZSBhbW91bnRcbiAgICAgIG9mIHN0cnVjdHVyZS4gVGhlIGtleXMgaW4gdGhlIG91dHB1dCBzZXF1ZW5jZSB3aWxsIGJlIGluIHNvcnRlZCBvcmRlci5cblxuICAgICAgSXQgaXMgYXNzdW1lZCB0aGF0IFtkYXRhX2VxdWFsXSBpcyBhdCBsZWFzdCBhcyBlcXVhdGluZyBhcyBwaHlzaWNhbCBlcXVhbGl0eTogdGhhdFxuICAgICAgW3BoeXNfZXF1YWwgeCB5XSBpbXBsaWVzIFtkYXRhX2VxdWFsIHggeV0uIE90aGVyd2lzZSwgW3N5bW1ldHJpY19kaWZmXSBtYXkgYmVoYXZlIGluXG4gICAgICB1bmV4cGVjdGVkIHdheXMuIEZvciBleGFtcGxlLCB3aXRoIFt+ZGF0YV9lcXVhbDooZnVuIF8gXyAtPiBmYWxzZSldIGl0IGlzIE5PVFxuICAgICAgbmVjZXNzYXJpbHkgdGhlIGNhc2UgdGhlIHJlc3VsdGluZyBjaGFuZ2Ugc2VxdWVuY2Ugd2lsbCBjb250YWluIGFuIGVsZW1lbnRcbiAgICAgIFsoaywgYFVuZXF1YWwgXyldIGZvciBldmVyeSBrZXkgW2tdIHNoYXJlZCBieSBib3RoIG1hcHMuXG5cbiAgICAgIFdhcm5pbmc6IEZsb2F0IGVxdWFsaXR5IHZpb2xhdGVzIHRoaXMgcHJvcGVydHkhIFtwaHlzX2VxdWFsIEZsb2F0Lm5hbiBGbG9hdC5uYW5dIGlzXG4gICAgICB0cnVlLCBidXQgW0Zsb2F0Lig9KSBGbG9hdC5uYW4gRmxvYXQubmFuXSBpcyBmYWxzZS4gKilcbiAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBkYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5cbiAgKCoqIFtmb2xkX3N5bW1ldHJpY19kaWZmIHQxIHQyIH5kYXRhX2VxdWFsXSBmb2xkcyBhY3Jvc3MgYW4gaW1wbGljaXQgc2VxdWVuY2Ugb2YgY2hhbmdlc1xuICAgICAgYmV0d2VlbiBbdDFdIGFuZCBbdDJdLCBpbiBzb3J0ZWQgb3JkZXIgYnkga2V5cy4gRXF1aXZhbGVudCB0b1xuICAgICAgW1NlcXVlbmNlLmZvbGQgKHN5bW1ldHJpY19kaWZmIHQxIHQyIH5kYXRhX2VxdWFsKV0sIGFuZCBtb3JlIGVmZmljaWVudC4gKilcbiAgdmFsIGZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gaW5pdDonYVxuICAgIC0+IGY6KCdhIC0+ICgnaywgJ3YpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYSlcbiAgICAtPiAnYVxuXG4gICgqKiBbbWluX2VsdCBtYXBdIHJldHVybnMgW1NvbWUgKGtleSwgZGF0YSldIHBhaXIgY29ycmVzcG9uZGluZyB0byB0aGUgbWluaW11bSBrZXkgaW5cbiAgICAgIFttYXBdLCBvciBbTm9uZV0gaWYgZW1wdHkuICopXG4gIHZhbCBtaW5fZWx0IDogKCdrLCAndiwgXykgdCAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdrLCAndiwgXykgdCAtPiAnayAqICd2XG5cbiAgKCoqIFttYXhfZWx0IG1hcF0gcmV0dXJucyBbU29tZSAoa2V5LCBkYXRhKV0gcGFpciBjb3JyZXNwb25kaW5nIHRvIHRoZSBtYXhpbXVtIGtleSBpblxuICAgICAgW21hcF0sIG9yIFtOb25lXSBpZiBbbWFwXSBpcyBlbXB0eS4gKilcbiAgdmFsIG1heF9lbHQgOiAoJ2ssICd2LCBfKSB0IC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2ssICd2LCBfKSB0IC0+ICdrICogJ3ZcblxuICAoKiogVGhlc2UgZnVuY3Rpb25zIGhhdmUgdGhlIHNhbWUgc2VtYW50aWNzIGFzIHNpbWlsYXIgZnVuY3Rpb25zIGluIFtMaXN0XS4gKilcblxuICB2YWwgZm9yX2FsbCA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0cyA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzaSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGludFxuICB2YWwgY291bnRpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKSAtPiBpbnRcblxuXG4gICgqKiBbc3BsaXQgdCBrZXldIHJldHVybnMgYSBtYXAgb2Yga2V5cyBzdHJpY3RseSBsZXNzIHRoYW4gW2tleV0sIHRoZSBtYXBwaW5nIG9mIFtrZXldIGlmXG4gICAgICBhbnksIGFuZCBhIG1hcCBvZiBrZXlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiBba2V5XS5cblxuICAgICAgUnVudGltZSBpcyBPKG0gKyBsb2cgbiksIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIGlucHV0IG1hcCBhbmQgbSBpcyB0aGUgc2l6ZSBvZlxuICAgICAgdGhlIHNtYWxsZXIgb2YgdGhlIHR3byBvdXRwdXQgbWFwcy4gIFRoZSBPKG0pIHRlcm0gaXMgZHVlIHRvIHRoZSBuZWVkIHRvIGNhbGN1bGF0ZVxuICAgICAgdGhlIGxlbmd0aCBvZiB0aGUgb3V0cHV0IG1hcHMuICopXG4gIHZhbCBzcGxpdFxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAna1xuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2sgKiAndikgb3B0aW9uICogKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0XSByZXR1cm5zIFtgT2sgbWFwXSB3aGVyZSBbbWFwXSBjb250YWlucyBhbGwgdGhlXG4gICAgICBbKGtleSwgdmFsdWUpXSBwYWlycyBmcm9tIHRoZSB0d28gaW5wdXQgbWFwcyBpZiBhbGwgdGhlIGtleXMgZnJvbSBbbG93ZXJfcGFydF0gYXJlXG4gICAgICBsZXNzIHRoYW4gYWxsIHRoZSBrZXlzIGZyb20gW3VwcGVyX3BhcnRdLiAgT3RoZXJ3aXNlIGl0IHJldHVybnNcbiAgICAgIFtgT3ZlcmxhcHBpbmdfa2V5X3Jhbmdlc10uXG5cbiAgICAgIFJ1bnRpbWUgaXMgTyhsb2cgbikgd2hlcmUgbiBpcyB0aGUgc2l6ZSBvZiB0aGUgbGFyZ2VyIGlucHV0IG1hcC4gIFRoaXMgY2FuIGJlXG4gICAgICBzaWduaWZpY2FudGx5IGZhc3RlciB0aGFuIFtNYXAubWVyZ2VdIG9yIHJlcGVhdGVkIFtNYXAuYWRkXS5cblxuICAgICAge1tcbiAgICAgICAgYXNzZXJ0IChtYXRjaCBNYXAuYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0IHdpdGhcbiAgICAgICAgICB8IGBPayB3aG9sZV9tYXAgLT5cbiAgICAgICAgICAgIE1hcC50b19hbGlzdCB3aG9sZV9tYXBcbiAgICAgICAgICAgID0gTGlzdC5hcHBlbmQgKHRvX2FsaXN0IGxvd2VyX3BhcnQpICh0b19hbGlzdCB1cHBlcl9wYXJ0KVxuICAgICAgICAgIHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgLT4gdHJ1ZSk7XG4gICAgICBdfSAqKVxuICB2YWwgYXBwZW5kXG4gICAgOiAgbG93ZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gdXBwZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIF1cblxuICAoKiogW3N1YnJhbmdlIHQgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZF0gcmV0dXJucyBhIG1hcCBjb250YWluaW5nIGFsbCB0aGUgZW50cmllcyBmcm9tXG4gICAgICBbdF0gd2hvc2Uga2V5cyBsaWUgaW5zaWRlIHRoZSBpbnRlcnZhbCBpbmRpY2F0ZWQgYnkgW35sb3dlcl9ib3VuZF0gYW5kXG4gICAgICBbfnVwcGVyX2JvdW5kXS4gIElmIHRoaXMgaW50ZXJ2YWwgaXMgZW1wdHksIGFuIGVtcHR5IG1hcCBpcyByZXR1cm5lZC5cblxuICAgICAgUnVudGltZSBpcyBPKG0gKyBsb2cgbiksIHdoZXJlIG4gaXMgdGhlIHNpemUgb2YgdGhlIGlucHV0IG1hcCBhbmQgbSBpcyB0aGUgc2l6ZSBvZlxuICAgICAgdGhlIG91dHB1dCBtYXAuICBUaGUgTyhtKSB0ZXJtIGlzIGR1ZSB0byB0aGUgbmVlZCB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICAgIG91dHB1dCBtYXAuICopXG4gIHZhbCBzdWJyYW5nZVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBsb3dlcl9ib3VuZDonayBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2sgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW2ZvbGRfcmFuZ2VfaW5jbHVzaXZlIHQgfm1pbiB+bWF4IH5pbml0IH5mXSBmb2xkcyBbZl0gKHdpdGggaW5pdGlhbCB2YWx1ZSBbfmluaXRdKVxuICAgICAgb3ZlciBhbGwga2V5cyAoYW5kIHRoZWlyIGFzc29jaWF0ZWQgdmFsdWVzKSB0aGF0IGFyZSBpbiB0aGUgcmFuZ2UgW1ttaW4sIG1heF1dXG4gICAgICAoaW5jbHVzaXZlKS4gICopXG4gIHZhbCBmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBtaW46J2tcbiAgICAtPiBtYXg6J2tcbiAgICAtPiBpbml0OidhXG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2EgLT4gJ2EpXG4gICAgLT4gJ2FcblxuICAoKiogW3JhbmdlX3RvX2FsaXN0IHQgfm1pbiB+bWF4XSByZXR1cm5zIGFuIGFzc29jaWF0aXZlIGxpc3Qgb2YgdGhlIGVsZW1lbnRzIHdob3NlIGtleXNcbiAgICAgIGxpZSBpbiBbW21pbiwgbWF4XV0gKGluY2x1c2l2ZSksIHdpdGggdGhlIHNtYWxsZXN0IGtleSBiZWluZyBhdCB0aGUgaGVhZCBvZiB0aGVcbiAgICAgIGxpc3QuICopXG4gIHZhbCByYW5nZV90b19hbGlzdCA6ICgnaywgJ3YsICdjbXApIHQgLT4gbWluOidrIC0+IG1heDonayAtPiAoJ2sgKiAndikgbGlzdFxuXG4gICgqKiBbY2xvc2VzdF9rZXkgdCBkaXIga10gcmV0dXJucyB0aGUgWyhrZXksIHZhbHVlKV0gcGFpciBpbiBbdF0gd2l0aCBba2V5XSBjbG9zZXN0IHRvXG4gICAgICBba10gdGhhdCBzYXRpc2ZpZXMgdGhlIGdpdmVuIGluZXF1YWxpdHkgYm91bmQuXG5cbiAgICAgIEZvciBleGFtcGxlLCBbY2xvc2VzdF9rZXkgdCBgTGVzc190aGFuIGtdIHdvdWxkIGJlIHRoZSBwYWlyIHdpdGggdGhlIGNsb3Nlc3Qga2V5IHRvXG4gICAgICBba10gd2hlcmUgW2tleSA8IGtdLlxuXG4gICAgICBbdG9fc2VxdWVuY2VdIGNhbiBiZSB1c2VkIHRvIGdldCB0aGUgc2FtZSByZXN1bHRzIGFzIFtjbG9zZXN0X2tleV0uICBJdCBpcyBsZXNzXG4gICAgICBlZmZpY2llbnQgZm9yIGluZGl2aWR1YWwgbG9va3VwcyBidXQgbW9yZSBlZmZpY2llbnQgZm9yIGZpbmRpbmcgbWFueSBlbGVtZW50cyBzdGFydGluZ1xuICAgICAgYXQgc29tZSB2YWx1ZS4gKilcbiAgdmFsIGNsb3Nlc3Rfa2V5XG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAtPiAna1xuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICAoKiogW250aCB0IG5dIGZpbmRzIHRoZSAoa2V5LCB2YWx1ZSkgcGFpciBvZiByYW5rIG4gKGkuZS4sIHN1Y2ggdGhhdCB0aGVyZSBhcmUgZXhhY3RseSBuXG4gICAgICBrZXlzIHN0cmljdGx5IGxlc3MgdGhhbiB0aGUgZm91bmQga2V5KSwgaWYgb25lIGV4aXN0cy4gIE8obG9nKGxlbmd0aCB0KSArIG4pIHRpbWUuICopXG4gIHZhbCBudGggOiAoJ2ssICd2LCBfKSB0IC0+IGludCAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIG50aF9leG4gOiAoJ2ssICd2LCBfKSB0IC0+IGludCAtPiAnayAqICd2XG5cbiAgKCoqIFtyYW5rIHQga10gSWYgW2tdIGlzIGluIFt0XSwgcmV0dXJucyB0aGUgbnVtYmVyIG9mIGtleXMgc3RyaWN0bHkgbGVzcyB0aGFuIFtrXSBpblxuICAgICAgW3RdLCBhbmQgW05vbmVdIG90aGVyd2lzZS4gKilcbiAgdmFsIHJhbmsgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+IGludCBvcHRpb25cblxuXG5cbiAgKCoqIFt0b19zZXF1ZW5jZSA/b3JkZXIgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA/a2V5c19sZXNzX29yX2VxdWFsX3RvIHRdXG4gICAgICBnaXZlcyBhIHNlcXVlbmNlIG9mIGtleS12YWx1ZSBwYWlycyBiZXR3ZWVuIFtrZXlzX2xlc3Nfb3JfZXF1YWxfdG9dIGFuZFxuICAgICAgW2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90b10gaW5jbHVzaXZlLCBwcmVzZW50ZWQgaW4gW29yZGVyXS4gIElmXG4gICAgICBba2V5c19ncmVhdGVyX29yX2VxdWFsX3RvID4ga2V5c19sZXNzX29yX2VxdWFsX3RvXSwgdGhlIHNlcXVlbmNlIGlzXG4gICAgICBlbXB0eS5cblxuICAgICAgV2hlbiBuZWl0aGVyIFtrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG9dIG5vciBba2V5c19sZXNzX29yX2VxdWFsX3RvXSBhcmVcbiAgICAgIHByb3ZpZGVkLCB0aGUgY29zdCBpcyBPKGxvZyBuKSB1cCBmcm9udCBhbmQgYW1vcnRpemVkIE8oMSkgdG8gcHJvZHVjZVxuICAgICAgZWFjaCBlbGVtZW50LiBJZiBlaXRoZXIgaXMgcHJvdmlkZWQgKGFuZCBpcyB1c2VkIGJ5IHRoZSBvcmRlciBwYXJhbWV0ZXJcbiAgICAgIHByb3ZpZGVkKSwgdGhlbiB0aGUgdGhlIGNvc3QgaXMgTyhuKSB1cCBmcm9udCwgYW5kIGFtb3J0aXplZCBPKDEpIHRvXG4gICAgICBwcm9kdWNlIGVhY2ggZWxlbWVudC4gKilcbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmdfa2V5ICgqKiBkZWZhdWx0ICopIHwgYERlY3JlYXNpbmdfa2V5IF1cbiAgICAtPiA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvOidrXG4gICAgLT4gP2tleXNfbGVzc19vcl9lcXVhbF90bzona1xuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2sgKiAndikgU2VxdWVuY2UudFxuXG4gICgqKiBbYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIHdoaWNoIGVsdF0gcmV0dXJucyB0aGUgWyhrZXksIHZhbHVlKV0gcGFpciBpbiBbdF1cbiAgICAgIHNwZWNpZmllZCBieSBbY29tcGFyZV0gYW5kIFt3aGljaF0sIGlmIG9uZSBleGlzdHMuXG5cbiAgICAgIFt0XSBtdXN0IGJlIHNvcnRlZCBpbiBpbmNyZWFzaW5nIG9yZGVyIGFjY29yZGluZyB0byBbY29tcGFyZV0sIHdoZXJlIFtjb21wYXJlXSBhbmRcbiAgICAgIFtlbHRdIGRpdmlkZSBbdF0gaW50byB0aHJlZSAocG9zc2libHkgZW1wdHkpIHNlZ21lbnRzOlxuXG4gICAgICB7dlxuICAgICAgICB8ICA8IGVsdCAgfCAgPSBlbHQgIHwgID4gZWx0ICB8XG4gICAgICB2fVxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF0gcmV0dXJucyBhbiBlbGVtZW50IG9uIHRoZSBib3VuZGFyeSBvZiBzZWdtZW50cyBhcyBzcGVjaWZpZWQgYnlcbiAgICAgIFt3aGljaF0uICBTZWUgdGhlIGRpYWdyYW0gYmVsb3cgbmV4dCB0byB0aGUgW3doaWNoXSB2YXJpYW50cy5cblxuICAgICAgW2JpbmFyeV9zZWFyY2hdIGRvZXMgbm90IGNoZWNrIHRoYXQgW2NvbXBhcmVdIG9yZGVycyBbdF0sIGFuZCBiZWhhdmlvciBpc1xuICAgICAgdW5zcGVjaWZpZWQgaWYgW2NvbXBhcmVdIGRvZXNuJ3Qgb3JkZXIgW3RdLiAgQmVoYXZpb3IgaXMgYWxzbyB1bnNwZWNpZmllZCBpZlxuICAgICAgW2NvbXBhcmVdIG11dGF0ZXMgW3RdLiAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAna2V5IC0+IGludClcbiAgICAtPiBbIGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAoKiogICAgICAgIHt2IHwgPCBlbHQgWCB8ICAgICAgICAgICAgICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvICgqKiAgICAge3YgfCAgICAgIDw9IGVsdCAgICAgICBYIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgTGFzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgICB7diAgICAgICAgICAgfCAgID0gZWx0IFggfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBGaXJzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8IFggPSBlbHQgICB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAoKioge3YgICAgICAgICAgIHwgWCAgICAgICA+PSBlbHQgICAgICB8IHZ9ICopXG4gICAgICAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuICgqKiAgICB7diAgICAgICAgICAgICAgICAgICAgICAgfCBYID4gZWx0IHwgdn0gKilcbiAgICAgICBdXG4gICAgLT4gJ2tleVxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICAoKiogW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2Ygd2hpY2hdIHRha2VzIGEgW3NlZ21lbnRfb2ZdIGZ1bmN0aW9uIHRoYXRcbiAgICAgIGRpdmlkZXMgW3RdIGludG8gdHdvIChwb3NzaWJseSBlbXB0eSkgc2VnbWVudHM6XG5cbiAgICAgIHt2XG4gICAgICAgIHwgc2VnbWVudF9vZiBlbHQgPSBgTGVmdCB8IHNlZ21lbnRfb2YgZWx0ID0gYFJpZ2h0IHxcbiAgICAgIHZ9XG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZF0gcmV0dXJucyB0aGUgWyhrZXksIHZhbHVlKV0gcGFpciBvbiB0aGUgYm91bmRhcnkgb2YgdGhlXG4gICAgICBzZWdtZW50cyBhcyBzcGVjaWZpZWQgYnkgW3doaWNoXTogW2BMYXN0X29uX2xlZnRdIHlpZWxkcyB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZVxuICAgICAgbGVmdCBzZWdtZW50LCB3aGlsZSBbYEZpcnN0X29uX3JpZ2h0XSB5aWVsZHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIHJpZ2h0IHNlZ21lbnQuXG4gICAgICBJdCByZXR1cm5zIFtOb25lXSBpZiB0aGUgc2VnbWVudCBpcyBlbXB0eS5cblxuICAgICAgW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkXSBkb2VzIG5vdCBjaGVjayB0aGF0IFtzZWdtZW50X29mXSBzZWdtZW50cyBbdF0gYXMgaW4gdGhlXG4gICAgICBkaWFncmFtLCBhbmQgYmVoYXZpb3IgaXMgdW5zcGVjaWZpZWQgaWYgW3NlZ21lbnRfb2ZdIGRvZXNuJ3Qgc2VnbWVudCBbdF0uICBCZWhhdmlvclxuICAgICAgaXMgYWxzbyB1bnNwZWNpZmllZCBpZiBbc2VnbWVudF9vZl0gbXV0YXRlcyBbdF0uICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBzZWdtZW50X29mOihrZXk6J2sgLT4gZGF0YTondiAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gWyBgTGFzdF9vbl9sZWZ0IHwgYEZpcnN0X29uX3JpZ2h0IF1cbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgKCoqIFtiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXSB0YWtlcyBhIFtjb21wYXJlXSBmdW5jdGlvbiB0aGF0IGRpdmlkZXMgW3RdIGludG8gdGhyZWVcbiAgICAgIChwb3NzaWJseSBlbXB0eSkgc2VnbWVudHMgd2l0aCByZXNwZWN0IHRvIFtsb3dlcl9ib3VuZF0gYW5kIFt1cHBlcl9ib3VuZF06XG5cbiAgICAgIHt2XG4gICAgICAgIHwgQmVsb3dfbG93ZXJfYm91bmQgfCBJbl9yYW5nZSB8IEFib3ZlX3VwcGVyX2JvdW5kIHxcbiAgICAgIHZ9XG5cbiAgICAgIGFuZCByZXR1cm5zIGEgbWFwIG9mIHRoZSBbSW5fcmFuZ2VdIHNlZ21lbnQuXG5cbiAgICAgIFJ1bnRpbWUgaXMgTyhsb2cgbSArIG4pIHdoZXJlIFttXSBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBpbnB1dCBtYXAgYW5kIFtuXSBpcyB0aGVcbiAgICAgIGxlbmd0aCBvZiB0aGUgb3V0cHV0LiBUaGUgbGluZWFyIHRlcm0gaW4gW25dIGlzIHRvIGNvbXB1dGUgdGhlIGxlbmd0aCBvZiB0aGUgb3V0cHV0LlxuXG4gICAgICBCZWhhdmlvciBpcyB1bmRlZmluZWQgaWYgW2NvbXBhcmVdIGRvZXMgbm90IHNlZ21lbnQgW3RdIGFzIHNob3duIGFib3ZlLCBvciBpZlxuICAgICAgW2NvbXBhcmVdIG11dGF0ZXMgaXRzIGlucHV0cy4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hfc3VicmFuZ2VcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2JvdW5kIC0+IGludClcbiAgICAtPiBsb3dlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+IHVwcGVyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbTV0gaXMgbWVhbnQgdG8gYmUgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIE9DYW1sIGFwcGxpY2F0aXZlIGZ1bmN0b3IgdHlwZXM6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgc3RyaW5nX3RvX2ludF9tYXAgPSBpbnQgTWFwLk0oU3RyaW5nKS50XG4gICAgICBdfVxuXG4gICAgICB3aGljaCBzdGFuZHMgZm9yOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHN0cmluZ190b19pbnRfbWFwID0gKFN0cmluZy50LCBpbnQsIFN0cmluZy5jb21wYXJhdG9yX3dpdG5lc3MpIE1hcC50XG4gICAgICBdfVxuXG4gICAgICBUaGUgcG9pbnQgaXMgdGhhdCBbaW50IE1hcC5NKFN0cmluZykudF0gc3VwcG9ydHMgZGVyaXZpbmcsIHdoZXJlYXMgdGhlIHNlY29uZCBzeW50YXhcbiAgICAgIGRvZXNuJ3QgKGJlY2F1c2UgdGhlcmUgaXMgbm8gc3VjaCB0aGluZyBhcywgc2F5LCBbU3RyaW5nLnNleHBfb2ZfY29tcGFyYXRvcl93aXRuZXNzXVxuICAgICAgLS0gaW5zdGVhZCB5b3Ugd291bGQgd2FudCB0byBwYXNzIHRoZSBjb21wYXJhdG9yIGRpcmVjdGx5KS5cblxuICAgICAgSW4gYWRkaXRpb24sIHdoZW4gdXNpbmcgW0BAZGVyaXZpbmddLCB0aGUgcmVxdWlyZW1lbnRzIG9uIHRoZSBrZXkgbW9kdWxlIGFyZSBvbmx5XG4gICAgICB0aG9zZSBuZWVkZWQgdG8gc2F0aXNmeSB3aGF0IHlvdSBhcmUgdHJ5aW5nIHRvIGRlcml2ZSBvbiB0aGUgbWFwIGl0c2VsZi4gU2F5IHlvdVxuICAgICAgd3JpdGU6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgdCA9IGludCBNYXAuTShYKS50IFtAQGRlcml2aW5nIGhhc2hdXG4gICAgICBdfVxuXG4gICAgICB0aGVuIHRoaXMgd2lsbCBiZSB3ZWxsIHR5cGVkIGV4YWN0bHkgaWYgW1hdIGNvbnRhaW5zIGF0IGxlYXN0OlxuICAgICAgLSBhIHR5cGUgW3RdIHdpdGggbm8gcGFyYW1ldGVyc1xuICAgICAgLSBhIGNvbXBhcmF0b3Igd2l0bmVzc1xuICAgICAgLSBhIFtoYXNoX2ZvbGRfdF0gZnVuY3Rpb24gd2l0aCB0aGUgcmlnaHQgdHlwZSAqKVxuICBtb2R1bGUgTSAoSyA6IHNpZ1xuICAgICAgdHlwZSB0XG4gICAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZCkgOiBzaWdcbiAgICB0eXBlIG5vbnJlYyAndiB0ID0gKEsudCwgJ3YsIEsuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gIGVuZFxuXG4gIGluY2x1ZGUgRm9yX2Rlcml2aW5nIHdpdGggdHlwZSAoJ2tleSwgJ3ZhbHVlLCAnY21wKSB0IDo9ICgna2V5LCAndmFsdWUsICdjbXApIHRcblxuICAoKiogW1VzaW5nX2NvbXBhcmF0b3JdIGlzIGEgc2ltaWxhciBpbnRlcmZhY2UgYXMgdGhlIHRvcGxldmVsIG9mIFtNYXBdLCBleGNlcHQgdGhlXG4gICAgICBmdW5jdGlvbnMgdGFrZSBhIFt+Y29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudF0sIHdoZXJlYXMgdGhlIGZ1bmN0aW9ucyBhdCB0aGVcbiAgICAgIHRvcGxldmVsIG9mIFtNYXBdIHRha2UgYSBbKCdrLCAnY21wKSBjb21wYXJhdG9yXS4gKilcbiAgbW9kdWxlIFVzaW5nX2NvbXBhcmF0b3IgOiBzaWdcbiAgICB0eXBlIG5vbnJlYyAoJ2ssICsndiwgJ2NtcCkgdCA9ICgnaywgJ3YsICdjbXApIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90XG4gICAgICA6ICAoJ2sgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCd2IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnY21wIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgIHZhbCB0X29mX3NleHBfZGlyZWN0XG4gICAgICA6ICBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAtPiAoU2V4cC50IC0+ICdrKVxuICAgICAgLT4gKFNleHAudCAtPiAndilcbiAgICAgIC0+IFNleHAudFxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICAgbW9kdWxlIFRyZWUgOiBzaWdcbiAgICAgIHR5cGUgKCsnaywgKyd2LCAnY21wKSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgICB2YWwgc2V4cF9vZl90XG4gICAgICAgIDogICgnayAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgndiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgnY21wIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgICAgW0BAQGVuZF1cblxuICAgICAgdmFsIHRfb2Zfc2V4cF9kaXJlY3RcbiAgICAgICAgOiAgY29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgICAtPiAoU2V4cC50IC0+ICdrKVxuICAgICAgICAtPiAoU2V4cC50IC0+ICd2KVxuICAgICAgICAtPiBTZXhwLnRcbiAgICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICAgICBpbmNsdWRlXG4gICAgICAgIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvclxuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSB0XG5cbiAgICAgIHZhbCBlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIDogKF8sIF8sIF8pIHRcblxuICAgICAgKCoqIFtCdWlsZF9pbmNyZWFzaW5nXSBjYW4gYmUgdXNlZCB0byBjb25zdHJ1Y3QgYSBtYXAgaW5jcmVtZW50YWxseSBmcm9tIGFcbiAgICAgICAgICBzZXF1ZW5jZSB0aGF0IGlzIGtub3duIHRvIGJlIGluY3JlYXNpbmcuXG5cbiAgICAgICAgICBUaGUgdG90YWwgdGltZSBjb21wbGV4aXR5IG9mIGNvbnN0cnVjdGluZyBhIG1hcCB0aGlzIHdheSBpcyBPKG4pLCB3aGljaCBpcyBtb3JlXG4gICAgICAgICAgZWZmaWNpZW50IHRoYW4gdXNpbmcgW01hcC5hZGRdIGJ5IGEgbG9nYXJpdGhtaWMgZmFjdG9yLlxuXG4gICAgICAgICAgVGhpcyBpbnRlcmZhY2UgY2FuIGJlIHRob3VnaHQgb2YgYXMgYSBkdWFsIG9mIFt0b19zZXF1ZW5jZV0sIGJ1dCB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAgYW4gZXF1YWxseSBuZWF0IGlkaW9tIGZvciB0aGUgZHVhbHMgb2Ygc2VxdWVuY2VzIChbb2Zfc2VxdWVuY2VdIGlzIG11Y2ggbGVzc1xuICAgICAgICAgIGdlbmVyYWwgYmVjYXVzZSBpdCBkb2VzIG5vdCBhbGxvdyB0aGUgc2VxdWVuY2UgdG8gYmUgcHJvZHVjZWQgYXN5bmNocm9ub3VzbHkpLiAqKVxuICAgICAgbW9kdWxlIEJ1aWxkX2luY3JlYXNpbmcgOiBzaWdcbiAgICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgdFxuICAgICAgICB0eXBlICgnaywgJ3YsICd3KSB0XG5cbiAgICAgICAgdmFsIGVtcHR5IDogKCdrLCAndiwgJ3cpIHRcblxuICAgICAgICAoKiogVGltZSBjb21wbGV4aXR5IG9mIFthZGRfZXhuXSBpcyBhbW9ydGl6ZWQgY29uc3RhbnQtdGltZSAoaWYgW3RdIGlzIHVzZWRcbiAgICAgICAgICAgIGxpbmVhcmx5KSwgd2l0aCBhIHdvcnN0LWNhc2UgTyhsb2cobikpIHRpbWUuICopXG4gICAgICAgIHZhbCBhZGRfZXhuXG4gICAgICAgICAgOiAgKCdrLCAndiwgJ3cpIHRcbiAgICAgICAgICAtPiBjb21wYXJhdG9yOignaywgJ3cpIENvbXBhcmF0b3IudFxuICAgICAgICAgIC0+IGtleTona1xuICAgICAgICAgIC0+IGRhdGE6J3ZcbiAgICAgICAgICAtPiAoJ2ssICd2LCAndykgdFxuXG4gICAgICAgICgqKiBUaW1lIGNvbXBsZXhpdHkgaXMgTyhsb2cobikpLiAqKVxuICAgICAgICB2YWwgdG9fdHJlZSA6ICgnaywgJ3YsICd3KSB0IC0+ICgnaywgJ3YsICd3KSB0cmVlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGluY2x1ZGVcbiAgICAgIEFjY2Vzc29yczNcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSBUcmVlLnRcblxuICAgIGluY2x1ZGVcbiAgICAgIENyZWF0b3JzM193aXRoX2NvbXBhcmF0b3JcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSBUcmVlLnRcblxuICAgIHZhbCBjb21wYXJhdG9yIDogKCdhLCBfLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci50XG5cbiAgICB2YWwgaGFzaF9mb2xkX2RpcmVjdFxuICAgICAgOiAgJ2sgSGFzaC5mb2xkZXJcbiAgICAgIC0+ICd2IEhhc2guZm9sZGVyXG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgICAoKiogVG8gZ2V0IGFyb3VuZCB0aGUgdmFsdWUgcmVzdHJpY3Rpb24sIGFwcGx5IHRoZSBmdW5jdG9yIGFuZCBpbmNsdWRlIGl0LiBZb3VcbiAgICAgICAgY2FuIHNlZSBhbiBleGFtcGxlIG9mIHRoaXMgaW4gdGhlIFtQb2x5XSBzdWJtb2R1bGUgYmVsb3cuICopXG4gICAgbW9kdWxlIEVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gKEsgOiBDb21wYXJhdG9yLlMxKSA6IHNpZ1xuICAgICAgdmFsIGVtcHR5IDogKCdhIEsudCwgJ3YsIEsuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gICAgZW5kXG4gIGVuZFxuXG4gICgqKiBBIHBvbHltb3JwaGljIE1hcC4gKilcbiAgbW9kdWxlIFBvbHkgOlxuICAgIFNfcG9seVxuICAgIHdpdGggdHlwZSAoJ2tleSwgKyd2YWx1ZSkgdCA9ICgna2V5LCAndmFsdWUsIENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgICAgYW5kIHR5cGUgKCdrZXksICsndmFsdWUpIHRyZWUgPVxuICAgICAgICAgICAoJ2tleSwgJ3ZhbHVlLCBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzKSBVc2luZ19jb21wYXJhdG9yLlRyZWUudFxuICAgICBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgKCoqIENyZWF0ZSBhIG1hcCBmcm9tIGEgdHJlZSB1c2luZyB0aGUgZ2l2ZW4gY29tcGFyYXRvci4gKilcbiAgdmFsIG9mX3RyZWVcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSBVc2luZ19jb21wYXJhdG9yLlRyZWUudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogRXh0cmFjdCBhIHRyZWUgZnJvbSBhIG1hcC4gKilcbiAgdmFsIHRvX3RyZWUgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIFVzaW5nX2NvbXBhcmF0b3IuVHJlZS50XG5cblxuICAoKiogezIgTW9kdWxlcyBhbmQgbW9kdWxlIHR5cGVzIGZvciBleHRlbmRpbmcgW01hcF19XG5cbiAgICAgIEZvciB1c2UgaW4gZXh0ZW5zaW9ucyBvZiBCYXNlLCBsaWtlIFtDb3JlXS4gKilcblxuICBtb2R1bGUgV2l0aF9jb21wYXJhdG9yID0gV2l0aF9jb21wYXJhdG9yXG4gIG1vZHVsZSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZSA9IFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlXG4gIG1vZHVsZSBXaXRob3V0X2NvbXBhcmF0b3IgPSBXaXRob3V0X2NvbXBhcmF0b3JcblxuICBtb2R1bGUgdHlwZSBGb3JfZGVyaXZpbmcgPSBGb3JfZGVyaXZpbmdcbiAgbW9kdWxlIHR5cGUgU19wb2x5ID0gU19wb2x5XG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczEgPSBBY2Nlc3NvcnMxXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczIgPSBBY2Nlc3NvcnMyXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczMgPSBBY2Nlc3NvcnMzXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yID0gQWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3JcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzX2dlbmVyaWMgPSBBY2Nlc3NvcnNfZ2VuZXJpY1xuICBtb2R1bGUgdHlwZSBDcmVhdG9yczEgPSBDcmVhdG9yczFcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMyID0gQ3JlYXRvcnMyXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzM193aXRoX2NvbXBhcmF0b3IgPSBDcmVhdG9yczNfd2l0aF9jb21wYXJhdG9yXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMxID0gQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczFcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczIgPSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMlxuXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvciA9XG4gICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yXG5cbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljID0gQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBDcmVhdG9yc19nZW5lcmljXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxub3BlbiEgVFxuXG5tb2R1bGUgdHlwZSBFbHRfcGxhaW4gPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgV2l0aG91dF9jb21wYXJhdG9yID0gTWFwX2ludGYuV2l0aG91dF9jb21wYXJhdG9yXG5tb2R1bGUgV2l0aF9jb21wYXJhdG9yID0gTWFwX2ludGYuV2l0aF9jb21wYXJhdG9yXG5tb2R1bGUgV2l0aF9maXJzdF9jbGFzc19tb2R1bGUgPSBNYXBfaW50Zi5XaXRoX2ZpcnN0X2NsYXNzX21vZHVsZVxubW9kdWxlIE1lcmdlX3RvX3NlcXVlbmNlX2VsZW1lbnQgPSBTZXF1ZW5jZS5NZXJnZV93aXRoX2R1cGxpY2F0ZXNfZWxlbWVudFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnNfZ2VuZXJpYyA9IHNpZ1xuICBpbmNsdWRlIENvbnRhaW5lci5HZW5lcmljX3BoYW50b21cblxuICB0eXBlICgnYSwgJ2NtcCkgdHJlZVxuXG4gICgqKiBUaGUgW29wdGlvbnNdIHR5cGUgaXMgdXNlZCB0byBtYWtlIFtBY2Nlc3NvcnNfZ2VuZXJpY10gZmxleGlibGUgYXMgdG8gd2hldGhlciBhXG4gICAgICBjb21wYXJhdG9yIGlzIHJlcXVpcmVkIHRvIGJlIHBhc3NlZCB0byBjZXJ0YWluIGZ1bmN0aW9ucy4gKilcbiAgdHlwZSAoJ2EsICdjbXAsICd6KSBvcHRpb25zXG5cbiAgdHlwZSAnY21wIGNtcFxuXG4gIHZhbCBpbnZhcmlhbnRzIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gYm9vbCkgb3B0aW9uc1xuXG4gICgqKiBvdmVycmlkZSBbQ29udGFpbmVyXSdzIFttZW1dICopXG4gIHZhbCBtZW0gOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAnYSBlbHQgLT4gYm9vbCkgb3B0aW9uc1xuXG4gIHZhbCBhZGQgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAnYSBlbHQgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCByZW1vdmUgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAnYSBlbHQgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCB1bmlvbiA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIGludGVyIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgZGlmZiA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSBlbHQsICdhIGVsdCkgRWl0aGVyLnQgU2VxdWVuY2UudCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgY29tcGFyZV9kaXJlY3QgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gaW50KSBvcHRpb25zXG4gIHZhbCBlcXVhbCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBib29sKSBvcHRpb25zXG4gIHZhbCBpc19zdWJzZXQgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiBvZl86KCdhLCAnY21wKSB0IC0+IGJvb2wpIG9wdGlvbnNcbiAgdmFsIGFyZV9kaXNqb2ludCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBib29sKSBvcHRpb25zXG5cbiAgdHlwZSAoJ2EsICdjbXApIG5hbWVkXG5cbiAgbW9kdWxlIE5hbWVkIDogc2lnXG4gICAgdmFsIGlzX3N1YnNldFxuICAgICAgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgbmFtZWQgLT4gb2ZfOignYSwgJ2NtcCkgbmFtZWQgLT4gdW5pdCBPcl9lcnJvci50KSBvcHRpb25zXG5cbiAgICB2YWwgZXF1YWxcbiAgICAgIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIG5hbWVkIC0+ICgnYSwgJ2NtcCkgbmFtZWQgLT4gdW5pdCBPcl9lcnJvci50KSBvcHRpb25zXG4gIGVuZFxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYlxuICAgIC0+IGY6KCdiIC0+ICdhIGVsdCAtPiAoJ2IsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdiIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6ICgnYSwgXykgdCAtPiBpbml0OidiIC0+IGY6KCdhIGVsdCAtPiAnYiAtPiAnYikgLT4gJ2JcblxuICB2YWwgaXRlcjJcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2EsICdjbXApIHRcbiAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgLT4gZjooWyBgTGVmdCBvZiAnYSBlbHQgfCBgUmlnaHQgb2YgJ2EgZWx0IHwgYEJvdGggb2YgJ2EgZWx0ICogJ2EgZWx0IF0gLT4gdW5pdClcbiAgICAgIC0+IHVuaXQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGZpbHRlciA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgcGFydGl0aW9uX3RmXG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdhLCAnY21wKSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiAoJ2EsICdjbXApIHQgKiAoJ2EsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGVsZW1lbnRzIDogKCdhLCBfKSB0IC0+ICdhIGVsdCBsaXN0XG4gIHZhbCBtaW5fZWx0IDogKCdhLCBfKSB0IC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhIGVsdFxuICB2YWwgbWF4X2VsdCA6ICgnYSwgXykgdCAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnYSwgXykgdCAtPiAnYSBlbHRcbiAgdmFsIGNob29zZSA6ICgnYSwgXykgdCAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCBjaG9vc2VfZXhuIDogKCdhLCBfKSB0IC0+ICdhIGVsdFxuXG4gIHZhbCBzcGxpdFxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdCAtPiAnYSBlbHQgLT4gKCdhLCAnY21wKSB0ICogJ2EgZWx0IG9wdGlvbiAqICgnYSwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZ3JvdXBfYnlcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2EsICdjbXApIHQgLT4gZXF1aXY6KCdhIGVsdCAtPiAnYSBlbHQgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0IGxpc3QgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGZpbmRfZXhuIDogKCdhLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiAnYSBlbHRcbiAgdmFsIG50aCA6ICgnYSwgXykgdCAtPiBpbnQgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgcmVtb3ZlX2luZGV4IDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gaW50IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgdG9fdHJlZSA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EgZWx0LCAnY21wKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgP29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYSBlbHRcbiAgICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhIGVsdFxuICAgICAgLT4gKCdhLCAnY21wKSB0XG4gICAgICAtPiAnYSBlbHQgU2VxdWVuY2UudCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdFxuICAgICAgLT4gY29tcGFyZTooJ2EgZWx0IC0+ICdrZXkgLT4gaW50KVxuICAgICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgICAtPiAna2V5XG4gICAgICAtPiAnYSBlbHQgb3B0aW9uIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdFxuICAgICAgLT4gc2VnbWVudF9vZjooJ2EgZWx0IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAgIC0+ICdhIGVsdCBvcHRpb24gKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG1lcmdlX3RvX3NlcXVlbmNlXG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgP29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYSBlbHRcbiAgICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhIGVsdFxuICAgICAgLT4gKCdhLCAnY21wKSB0XG4gICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgIC0+ICgnYSBlbHQsICdhIGVsdCkgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudC50IFNlcXVlbmNlLnQgKVxuICAgICAgICBvcHRpb25zXG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzMCA9IHNpZ1xuICBpbmNsdWRlIENvbnRhaW5lci5TMFxuXG4gIHR5cGUgdHJlZVxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBpbnZhcmlhbnRzIDogdCAtPiBib29sXG4gIHZhbCBtZW0gOiB0IC0+IGVsdCAtPiBib29sXG4gIHZhbCBhZGQgOiB0IC0+IGVsdCAtPiB0XG4gIHZhbCByZW1vdmUgOiB0IC0+IGVsdCAtPiB0XG4gIHZhbCB1bmlvbiA6IHQgLT4gdCAtPiB0XG4gIHZhbCBpbnRlciA6IHQgLT4gdCAtPiB0XG4gIHZhbCBkaWZmIDogdCAtPiB0IC0+IHRcbiAgdmFsIHN5bW1ldHJpY19kaWZmIDogdCAtPiB0IC0+IChlbHQsIGVsdCkgRWl0aGVyLnQgU2VxdWVuY2UudFxuICB2YWwgY29tcGFyZV9kaXJlY3QgOiB0IC0+IHQgLT4gaW50XG4gIHZhbCBlcXVhbCA6IHQgLT4gdCAtPiBib29sXG4gIHZhbCBpc19zdWJzZXQgOiB0IC0+IG9mXzp0IC0+IGJvb2xcbiAgdmFsIGFyZV9kaXNqb2ludCA6IHQgLT4gdCAtPiBib29sXG5cbiAgdHlwZSBuYW1lZFxuXG4gIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgIHZhbCBpc19zdWJzZXQgOiBuYW1lZCAtPiBvZl86bmFtZWQgLT4gdW5pdCBPcl9lcnJvci50XG4gICAgdmFsIGVxdWFsIDogbmFtZWQgLT4gbmFtZWQgLT4gdW5pdCBPcl9lcnJvci50XG4gIGVuZFxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgdFxuICAgIC0+IGluaXQ6J2JcbiAgICAtPiBmOignYiAtPiBlbHQgLT4gKCdiLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYiAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGZvbGRfcmlnaHQgOiB0IC0+IGluaXQ6J2IgLT4gZjooZWx0IC0+ICdiIC0+ICdiKSAtPiAnYlxuXG4gIHZhbCBpdGVyMlxuICAgIDogIHRcbiAgICAtPiB0XG4gICAgLT4gZjooWyBgTGVmdCBvZiBlbHQgfCBgUmlnaHQgb2YgZWx0IHwgYEJvdGggb2YgZWx0ICogZWx0IF0gLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgdmFsIGZpbHRlciA6IHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IHRcbiAgdmFsIHBhcnRpdGlvbl90ZiA6IHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IHQgKiB0XG4gIHZhbCBlbGVtZW50cyA6IHQgLT4gZWx0IGxpc3RcbiAgdmFsIG1pbl9lbHQgOiB0IC0+IGVsdCBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogdCAtPiBlbHRcbiAgdmFsIG1heF9lbHQgOiB0IC0+IGVsdCBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogdCAtPiBlbHRcbiAgdmFsIGNob29zZSA6IHQgLT4gZWx0IG9wdGlvblxuICB2YWwgY2hvb3NlX2V4biA6IHQgLT4gZWx0XG4gIHZhbCBzcGxpdCA6IHQgLT4gZWx0IC0+IHQgKiBlbHQgb3B0aW9uICogdFxuICB2YWwgZ3JvdXBfYnkgOiB0IC0+IGVxdWl2OihlbHQgLT4gZWx0IC0+IGJvb2wpIC0+IHQgbGlzdFxuICB2YWwgZmluZF9leG4gOiB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBlbHRcbiAgdmFsIG50aCA6IHQgLT4gaW50IC0+IGVsdCBvcHRpb25cbiAgdmFsIHJlbW92ZV9pbmRleCA6IHQgLT4gaW50IC0+IHRcbiAgdmFsIHRvX3RyZWUgOiB0IC0+IHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzplbHRcbiAgICAtPiA/bGVzc19vcl9lcXVhbF90bzplbHRcbiAgICAtPiB0XG4gICAgLT4gZWx0IFNlcXVlbmNlLnRcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogIHRcbiAgICAtPiBjb21wYXJlOihlbHQgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgLT4gJ2tleVxuICAgIC0+IGVsdCBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICB0XG4gICAgLT4gc2VnbWVudF9vZjooZWx0IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgLT4gZWx0IG9wdGlvblxuXG4gIHZhbCBtZXJnZV90b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOmVsdFxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOmVsdFxuICAgIC0+IHRcbiAgICAtPiB0XG4gICAgLT4gKGVsdCwgZWx0KSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50LnQgU2VxdWVuY2UudFxuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yczEgPSBzaWdcbiAgaW5jbHVkZSBDb250YWluZXIuUzFcblxuICB0eXBlICdhIHRyZWVcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgaW52YXJpYW50cyA6IF8gdCAtPiBib29sXG4gIHZhbCBtZW0gOiAnYSB0IC0+ICdhIC0+IGJvb2xcbiAgdmFsIGFkZCA6ICdhIHQgLT4gJ2EgLT4gJ2EgdFxuICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiAnYSAtPiAnYSB0XG4gIHZhbCB1bmlvbiA6ICdhIHQgLT4gJ2EgdCAtPiAnYSB0XG4gIHZhbCBpbnRlciA6ICdhIHQgLT4gJ2EgdCAtPiAnYSB0XG4gIHZhbCBkaWZmIDogJ2EgdCAtPiAnYSB0IC0+ICdhIHRcbiAgdmFsIHN5bW1ldHJpY19kaWZmIDogJ2EgdCAtPiAnYSB0IC0+ICgnYSwgJ2EpIEVpdGhlci50IFNlcXVlbmNlLnRcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogJ2EgdCAtPiAnYSB0IC0+IGludFxuICB2YWwgZXF1YWwgOiAnYSB0IC0+ICdhIHQgLT4gYm9vbFxuICB2YWwgaXNfc3Vic2V0IDogJ2EgdCAtPiBvZl86J2EgdCAtPiBib29sXG4gIHZhbCBhcmVfZGlzam9pbnQgOiAnYSB0IC0+ICdhIHQgLT4gYm9vbFxuXG4gIHR5cGUgJ2EgbmFtZWRcblxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICB2YWwgaXNfc3Vic2V0IDogJ2EgbmFtZWQgLT4gb2ZfOidhIG5hbWVkIC0+IHVuaXQgT3JfZXJyb3IudFxuICAgIHZhbCBlcXVhbCA6ICdhIG5hbWVkIC0+ICdhIG5hbWVkIC0+IHVuaXQgT3JfZXJyb3IudFxuICBlbmRcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICdhIHRcbiAgICAtPiBpbml0OidiXG4gICAgLT4gZjooJ2IgLT4gJ2EgLT4gKCdiLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYiAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgdmFsIGZvbGRfcmlnaHQgOiAnYSB0IC0+IGluaXQ6J2IgLT4gZjooJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdiXG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAgJ2EgdFxuICAgIC0+ICdhIHRcbiAgICAtPiBmOihbIGBMZWZ0IG9mICdhIHwgYFJpZ2h0IG9mICdhIHwgYEJvdGggb2YgJ2EgKiAnYSBdIC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gIHZhbCBmaWx0ZXIgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIHRcbiAgdmFsIHBhcnRpdGlvbl90ZiA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2EgdCAqICdhIHRcbiAgdmFsIGVsZW1lbnRzIDogJ2EgdCAtPiAnYSBsaXN0XG4gIHZhbCBtaW5fZWx0IDogJ2EgdCAtPiAnYSBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogJ2EgdCAtPiAnYVxuICB2YWwgbWF4X2VsdCA6ICdhIHQgLT4gJ2Egb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6ICdhIHQgLT4gJ2FcbiAgdmFsIGNob29zZSA6ICdhIHQgLT4gJ2Egb3B0aW9uXG4gIHZhbCBjaG9vc2VfZXhuIDogJ2EgdCAtPiAnYVxuICB2YWwgc3BsaXQgOiAnYSB0IC0+ICdhIC0+ICdhIHQgKiAnYSBvcHRpb24gKiAnYSB0XG4gIHZhbCBncm91cF9ieSA6ICdhIHQgLT4gZXF1aXY6KCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgbGlzdFxuICB2YWwgZmluZF9leG4gOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhXG4gIHZhbCBudGggOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb25cbiAgdmFsIHJlbW92ZV9pbmRleCA6ICdhIHQgLT4gaW50IC0+ICdhIHRcbiAgdmFsIHRvX3RyZWUgOiAnYSB0IC0+ICdhIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gJ2EgdFxuICAgIC0+ICdhIFNlcXVlbmNlLnRcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogICdhIHRcbiAgICAtPiBjb21wYXJlOignYSAtPiAna2V5IC0+IGludClcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAtPiAna2V5XG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgJ2EgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KCdhIC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIG1lcmdlX3RvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICdhIHRcbiAgICAtPiAnYSB0XG4gICAgLT4gKCdhLCAnYSkgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudC50IFNlcXVlbmNlLnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMyID0gc2lnXG4gIGluY2x1ZGUgQ29udGFpbmVyLlMxX3BoYW50b21faW52YXJpYW50XG5cbiAgdHlwZSAoJ2EsICdjbXApIHRyZWVcblxuICB2YWwgaW52YXJpYW50cyA6IChfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIG1lbSA6ICgnYSwgXykgdCAtPiAnYSAtPiBib29sXG4gIHZhbCBhZGQgOiAoJ2EsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCByZW1vdmUgOiAoJ2EsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCB1bmlvbiA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBpbnRlciA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBkaWZmIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHN5bW1ldHJpY19kaWZmIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdhKSBFaXRoZXIudCBTZXF1ZW5jZS50XG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gaW50XG4gIHZhbCBlcXVhbCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbFxuICB2YWwgaXNfc3Vic2V0IDogKCdhLCAnY21wKSB0IC0+IG9mXzooJ2EsICdjbXApIHQgLT4gYm9vbFxuICB2YWwgYXJlX2Rpc2pvaW50IDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBib29sXG5cbiAgdHlwZSAoJ2EsICdjbXApIG5hbWVkXG5cbiAgbW9kdWxlIE5hbWVkIDogc2lnXG4gICAgdmFsIGlzX3N1YnNldCA6ICgnYSwgJ2NtcCkgbmFtZWQgLT4gb2ZfOignYSwgJ2NtcCkgbmFtZWQgLT4gdW5pdCBPcl9lcnJvci50XG4gICAgdmFsIGVxdWFsIDogKCdhLCAnY21wKSBuYW1lZCAtPiAoJ2EsICdjbXApIG5hbWVkIC0+IHVuaXQgT3JfZXJyb3IudFxuICBlbmRcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2JcbiAgICAtPiBmOignYiAtPiAnYSAtPiAoJ2IsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdiIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6ICgnYSwgXykgdCAtPiBpbml0OidiIC0+IGY6KCdhIC0+ICdiIC0+ICdiKSAtPiAnYlxuXG4gIHZhbCBpdGVyMlxuICAgIDogICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGY6KFsgYExlZnQgb2YgJ2EgfCBgUmlnaHQgb2YgJ2EgfCBgQm90aCBvZiAnYSAqICdhIF0gLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgdmFsIGZpbHRlciA6ICgnYSwgJ2NtcCkgdCAtPiBmOignYSAtPiBib29sKSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHBhcnRpdGlvbl90ZiA6ICgnYSwgJ2NtcCkgdCAtPiBmOignYSAtPiBib29sKSAtPiAoJ2EsICdjbXApIHQgKiAoJ2EsICdjbXApIHRcbiAgdmFsIGVsZW1lbnRzIDogKCdhLCBfKSB0IC0+ICdhIGxpc3RcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnYSwgXykgdCAtPiAnYVxuICB2YWwgbWF4X2VsdCA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG4gIHZhbCBjaG9vc2UgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG4gIHZhbCBjaG9vc2VfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG4gIHZhbCBzcGxpdCA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHQgKiAnYSBvcHRpb24gKiAoJ2EsICdjbXApIHRcbiAgdmFsIGdyb3VwX2J5IDogKCdhLCAnY21wKSB0IC0+IGVxdWl2OignYSAtPiAnYSAtPiBib29sKSAtPiAoJ2EsICdjbXApIHQgbGlzdFxuICB2YWwgZmluZF9leG4gOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2FcbiAgdmFsIG50aCA6ICgnYSwgXykgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uXG4gIHZhbCByZW1vdmVfaW5kZXggOiAoJ2EsICdjbXApIHQgLT4gaW50IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgdG9fdHJlZSA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gJ2EgU2VxdWVuY2UudFxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgKCdhLCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooJ2EgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgLT4gJ2tleVxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogICgnYSwgJ2NtcCkgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KCdhIC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIG1lcmdlX3RvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2EpIE1lcmdlX3RvX3NlcXVlbmNlX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzMl93aXRoX2NvbXBhcmF0b3IgPSBzaWdcbiAgaW5jbHVkZSBDb250YWluZXIuUzFfcGhhbnRvbV9pbnZhcmlhbnRcblxuICB0eXBlICgnYSwgJ2NtcCkgdHJlZVxuXG4gIHZhbCBpbnZhcmlhbnRzIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbFxuICB2YWwgbWVtIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdjbXApIHQgLT4gJ2EgLT4gYm9vbFxuICB2YWwgYWRkIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCByZW1vdmUgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgdW5pb25cbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIGludGVyXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBkaWZmXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdhKSBFaXRoZXIudCBTZXF1ZW5jZS50XG5cbiAgdmFsIGNvbXBhcmVfZGlyZWN0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGludFxuXG4gIHZhbCBlcXVhbCA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBib29sXG5cbiAgdmFsIGlzX3N1YnNldFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBvZl86KCdhLCAnY21wKSB0XG4gICAgLT4gYm9vbFxuXG4gIHZhbCBhcmVfZGlzam9pbnRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gYm9vbFxuXG4gIHR5cGUgKCdhLCAnY21wKSBuYW1lZFxuXG4gIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgIHZhbCBpc19zdWJzZXRcbiAgICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAgIC0+ICgnYSwgJ2NtcCkgbmFtZWRcbiAgICAgIC0+IG9mXzooJ2EsICdjbXApIG5hbWVkXG4gICAgICAtPiB1bml0IE9yX2Vycm9yLnRcblxuICAgIHZhbCBlcXVhbFxuICAgICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgLT4gKCdhLCAnY21wKSBuYW1lZFxuICAgICAgLT4gKCdhLCAnY21wKSBuYW1lZFxuICAgICAgLT4gdW5pdCBPcl9lcnJvci50XG4gIGVuZFxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgLT4gKCdhY2N1bSwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjY3VtIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6ICgnYSwgXykgdCAtPiBpbml0OidhY2N1bSAtPiBmOignYSAtPiAnYWNjdW0gLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICB2YWwgaXRlcjJcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gZjooWyBgTGVmdCBvZiAnYSB8IGBSaWdodCBvZiAnYSB8IGBCb3RoIG9mICdhICogJ2EgXSAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgZmlsdGVyXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGY6KCdhIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl90ZlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBmOignYSAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2NtcCkgdCAqICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBlbGVtZW50cyA6ICgnYSwgXykgdCAtPiAnYSBsaXN0XG4gIHZhbCBtaW5fZWx0IDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcbiAgdmFsIG1heF9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnYSwgXykgdCAtPiAnYVxuICB2YWwgY2hvb3NlIDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuICB2YWwgY2hvb3NlX2V4biA6ICgnYSwgXykgdCAtPiAnYVxuXG4gIHZhbCBzcGxpdFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAnYVxuICAgIC0+ICgnYSwgJ2NtcCkgdCAqICdhIG9wdGlvbiAqICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBncm91cF9ieVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBlcXVpdjooJ2EgLT4gJ2EgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdjbXApIHQgbGlzdFxuXG4gIHZhbCBmaW5kX2V4biA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYVxuICB2YWwgbnRoIDogKCdhLCBfKSB0IC0+IGludCAtPiAnYSBvcHRpb25cblxuICB2YWwgcmVtb3ZlX2luZGV4XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGludFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCB0b190cmVlIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gJ2EgU2VxdWVuY2UudFxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgIC0+ICdrZXlcbiAgICAtPiAnYSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gc2VnbWVudF9vZjooJ2EgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAtPiAnYSBvcHRpb25cblxuICB2YWwgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gP29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2EpIE1lcmdlX3RvX3NlcXVlbmNlX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5lbmRcblxuKCoqIENvbnNpc3RlbmN5IGNoZWNrcyAoc2FtZSBhcyBpbiBbQ29udGFpbmVyXSkuICopXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKFQgOiBUMilcbiAgICAoVHJlZSA6IFQyKVxuICAgIChFbHQgOiBUMSlcbiAgICAoTmFtZWQgOiBUMilcbiAgICAoQ21wIDogVDEpXG4gICAgKE9wdGlvbnMgOiBUMylcbiAgICAoXyA6IEFjY2Vzc29yc19nZW5lcmljXG4gICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgT3B0aW9ucy50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIFQudFxuICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdHJlZSA6PSAoJ2EsICdiKSBUcmVlLnRcbiAgICAgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBFbHQudFxuICAgICB3aXRoIHR5cGUgJ2NtcCBjbXAgOj0gJ2NtcCBDbXAudFxuICAgICB3aXRoIHR5cGUgKCdhLCAnYikgbmFtZWQgOj0gKCdhLCAnYikgTmFtZWQudCkgPVxuc3RydWN0IGVuZFxuXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzMCAoTSA6IEFjY2Vzc29yczApID1cbiAgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9IE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmVsdFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSBNLm5hbWVkXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0uY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19hY2Nlc3NvcnMxIChNIDogQWNjZXNzb3JzMSkgPVxuICBDaGVja19hY2Nlc3NvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAnYSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gJ2EgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICdhIE0ubmFtZWRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5jb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2FjY2Vzc29yczIgKE0gOiBBY2Nlc3NvcnMyKSA9XG4gIENoZWNrX2FjY2Vzc29yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS5uYW1lZFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzMl93aXRoX2NvbXBhcmF0b3IgKE0gOiBBY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvcikgPVxuICBDaGVja19hY2Nlc3NvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0ubmFtZWRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKFdpdGhfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IHNpZ1xuICB0eXBlICgnYSwgJ2NtcCkgdFxuICB0eXBlICgnYSwgJ2NtcCkgc2V0XG4gIHR5cGUgKCdhLCAnY21wKSB0cmVlXG4gIHR5cGUgJ2EgZWx0XG4gIHR5cGUgKCdhLCAnY21wLCAneikgb3B0aW9uc1xuICB0eXBlICdjbXAgY21wXG5cbiAgdmFsIGVtcHR5IDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIHNpbmdsZXRvbiA6ICgnYSwgJ2NtcCwgJ2EgZWx0IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgdW5pb25fbGlzdCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IGxpc3QgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBvZl9saXN0IDogKCdhLCAnY21wLCAnYSBlbHQgbGlzdCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIG9mX3NlcXVlbmNlIDogKCdhLCAnY21wLCAnYSBlbHQgU2VxdWVuY2UudCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIG9mX2FycmF5IDogKCdhLCAnY21wLCAnYSBlbHQgYXJyYXkgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXkgOiAoJ2EsICdjbXAsICdhIGVsdCBhcnJheSAtPiAoJ2EsICdjbXApIHQgT3JfZXJyb3IudCkgb3B0aW9uc1xuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCA6ICgnYSwgJ2NtcCwgJ2EgZWx0IGFycmF5IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZFxuICAgIDogKCdhLCAnY21wLCBsZW46aW50IC0+IGY6KGludCAtPiAnYSBlbHQpIC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBzdGFibGVfZGVkdXBfbGlzdCA6ICgnYSwgXywgJ2EgZWx0IGxpc3QgLT4gJ2EgZWx0IGxpc3QpIG9wdGlvbnNcblxuICAoKiogVGhlIHR5cGVzIG9mIFttYXBdIGFuZCBbZmlsdGVyX21hcF0gYXJlIHN1YnRsZS4gIFRoZSBpbnB1dCBzZXQsIFsoJ2EsIF8pIHNldF0sXG4gICAgICByZWZsZWN0cyB0aGUgZmFjdCB0aGF0IHRoZXNlIGZ1bmN0aW9ucyB0YWtlIGEgc2V0IG9mICphbnkqIHR5cGUsIHdpdGggYW55XG4gICAgICBjb21wYXJhdG9yLCB3aGlsZSB0aGUgb3V0cHV0IHNldCwgWygnYiwgJ2NtcCkgdF0sIHJlZmxlY3RzIHRoYXQgdGhlIG91dHB1dCBzZXQgaGFzXG4gICAgICB0aGUgcGFydGljdWxhciBbJ2NtcF0gb2YgdGhlIGNyZWF0aW9uIGZ1bmN0aW9uLiAgVGhlIGNvbXBhcmF0b3IgY2FuIGNvbWUgaW4gb25lIG9mXG4gICAgICB0aHJlZSB3YXlzLCBkZXBlbmRpbmcgb24gd2hpY2ggc2V0IG1vZHVsZSBpcyB1c2VkXG5cbiAgICAgIC0gW1NldC5tYXBdIC0tIGNvbXBhcmF0b3IgY29tZXMgYXMgYW4gYXJndW1lbnRcbiAgICAgIC0gW1NldC5Qb2x5Lm1hcF0gLS0gY29tcGFyYXRvciBpcyBwb2x5bW9ycGhpYyBjb21wYXJpc29uXG4gICAgICAtIFtGb28uU2V0Lm1hcF0gLS0gY29tcGFyYXRvciBpcyBbRm9vLmNvbXBhcmF0b3JdICopXG4gIHZhbCBtYXAgOiAoJ2IsICdjbXAsICgnYSwgXykgc2V0IC0+IGY6KCdhIC0+ICdiIGVsdCkgLT4gKCdiLCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIGZpbHRlcl9tYXBcbiAgICA6ICgnYiwgJ2NtcCwgKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gJ2IgZWx0IG9wdGlvbikgLT4gKCdiLCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG9mX3RyZWUgOiAoJ2EsICdjbXAsICgnYSBlbHQsICdjbXApIHRyZWUgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMwID0gc2lnXG4gIHR5cGUgKCdhLCAnY21wKSBzZXRcbiAgdHlwZSB0XG4gIHR5cGUgdHJlZVxuICB0eXBlIGVsdFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBlbXB0eSA6IHRcbiAgdmFsIHNpbmdsZXRvbiA6IGVsdCAtPiB0XG4gIHZhbCB1bmlvbl9saXN0IDogdCBsaXN0IC0+IHRcbiAgdmFsIG9mX2xpc3QgOiBlbHQgbGlzdCAtPiB0XG4gIHZhbCBvZl9zZXF1ZW5jZSA6IGVsdCBTZXF1ZW5jZS50IC0+IHRcbiAgdmFsIG9mX2FycmF5IDogZWx0IGFycmF5IC0+IHRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheSA6IGVsdCBhcnJheSAtPiB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgOiBlbHQgYXJyYXkgLT4gdFxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgOiBsZW46aW50IC0+IGY6KGludCAtPiBlbHQpIC0+IHRcbiAgdmFsIHN0YWJsZV9kZWR1cF9saXN0IDogZWx0IGxpc3QgLT4gZWx0IGxpc3RcbiAgdmFsIG1hcCA6ICgnYSwgXykgc2V0IC0+IGY6KCdhIC0+IGVsdCkgLT4gdFxuICB2YWwgZmlsdGVyX21hcCA6ICgnYSwgXykgc2V0IC0+IGY6KCdhIC0+IGVsdCBvcHRpb24pIC0+IHRcbiAgdmFsIG9mX3RyZWUgOiB0cmVlIC0+IHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yczEgPSBzaWdcbiAgdHlwZSAoJ2EsICdjbXApIHNldFxuICB0eXBlICdhIHRcbiAgdHlwZSAnYSB0cmVlXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGVtcHR5IDogJ2EgdFxuICB2YWwgc2luZ2xldG9uIDogJ2EgLT4gJ2EgdFxuICB2YWwgdW5pb25fbGlzdCA6ICdhIHQgbGlzdCAtPiAnYSB0XG4gIHZhbCBvZl9saXN0IDogJ2EgbGlzdCAtPiAnYSB0XG4gIHZhbCBvZl9zZXF1ZW5jZSA6ICdhIFNlcXVlbmNlLnQgLT4gJ2EgdFxuICB2YWwgb2ZfYXJyYXkgOiAnYSBhcnJheSAtPiAnYSB0XG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXkgOiAnYSBhcnJheSAtPiAnYSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgOiAnYSBhcnJheSAtPiAnYSB0XG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCA6IGxlbjppbnQgLT4gZjooaW50IC0+ICdhKSAtPiAnYSB0XG4gIHZhbCBzdGFibGVfZGVkdXBfbGlzdCA6ICdhIGxpc3QgLT4gJ2EgbGlzdFxuICB2YWwgbWFwIDogKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gJ2IpIC0+ICdiIHRcbiAgdmFsIGZpbHRlcl9tYXAgOiAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiAnYiBvcHRpb24pIC0+ICdiIHRcbiAgdmFsIG9mX3RyZWUgOiAnYSB0cmVlIC0+ICdhIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yczIgPSBzaWdcbiAgdHlwZSAoJ2EsICdjbXApIHNldFxuICB0eXBlICgnYSwgJ2NtcCkgdFxuICB0eXBlICgnYSwgJ2NtcCkgdHJlZVxuXG4gIHZhbCBlbXB0eSA6ICgnYSwgJ2NtcCkgdFxuICB2YWwgc2luZ2xldG9uIDogJ2EgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCB1bmlvbl9saXN0IDogKCdhLCAnY21wKSB0IGxpc3QgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBvZl9saXN0IDogJ2EgbGlzdCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX3NlcXVlbmNlIDogJ2EgU2VxdWVuY2UudCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX2FycmF5IDogJ2EgYXJyYXkgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXkgOiAnYSBhcnJheSAtPiAoJ2EsICdjbXApIHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCA6ICdhIGFycmF5IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgOiBsZW46aW50IC0+IGY6KGludCAtPiAnYSkgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBzdGFibGVfZGVkdXBfbGlzdCA6ICdhIGxpc3QgLT4gJ2EgbGlzdFxuICB2YWwgbWFwIDogKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2NtcCkgdFxuICB2YWwgZmlsdGVyX21hcCA6ICgnYSwgXykgc2V0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbikgLT4gKCdiLCAnY21wKSB0XG4gIHZhbCBvZl90cmVlIDogKCdhLCAnY21wKSB0cmVlIC0+ICgnYSwgJ2NtcCkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzMl93aXRoX2NvbXBhcmF0b3IgPSBzaWdcbiAgdHlwZSAoJ2EsICdjbXApIHNldFxuICB0eXBlICgnYSwgJ2NtcCkgdFxuICB0eXBlICgnYSwgJ2NtcCkgdHJlZVxuXG4gIHZhbCBlbXB0eSA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBzaW5nbGV0b24gOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgdW5pb25fbGlzdCA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnY21wKSB0IGxpc3QgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBvZl9saXN0IDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAnYSBsaXN0IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2Zfc2VxdWVuY2UgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICdhIFNlcXVlbmNlLnQgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBvZl9hcnJheSA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gJ2EgYXJyYXkgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIG9mX3NvcnRlZF9hcnJheVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAnYSBhcnJheVxuICAgIC0+ICgnYSwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gJ2EgYXJyYXlcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gbGVuOmludFxuICAgIC0+IGY6KGludCAtPiAnYSlcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgc3RhYmxlX2RlZHVwX2xpc3QgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICdhIGxpc3QgLT4gJ2EgbGlzdFxuXG4gIHZhbCBtYXBcbiAgICA6ICBjb21wYXJhdG9yOignYiwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCBfKSBzZXRcbiAgICAtPiBmOignYSAtPiAnYilcbiAgICAtPiAoJ2IsICdjbXApIHRcblxuICB2YWwgZmlsdGVyX21hcFxuICAgIDogIGNvbXBhcmF0b3I6KCdiLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsIF8pIHNldFxuICAgIC0+IGY6KCdhIC0+ICdiIG9wdGlvbilcbiAgICAtPiAoJ2IsICdjbXApIHRcblxuICB2YWwgb2ZfdHJlZSA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnY21wKSB0cmVlIC0+ICgnYSwgJ2NtcCkgdFxuZW5kXG5cbm1vZHVsZSBDaGVja19jcmVhdG9yc1xuICAgIChUIDogVDIpXG4gICAgKFRyZWUgOiBUMilcbiAgICAoRWx0IDogVDEpXG4gICAgKENtcCA6IFQxKVxuICAgIChPcHRpb25zIDogVDMpXG4gICAgKF8gOiBDcmVhdG9yc19nZW5lcmljXG4gICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgT3B0aW9ucy50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIFQudFxuICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdHJlZSA6PSAoJ2EsICdiKSBUcmVlLnRcbiAgICAgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBFbHQudFxuICAgICB3aXRoIHR5cGUgJ2NtcCBjbXAgOj0gJ2NtcCBDbXAudCkgPVxuc3RydWN0IGVuZFxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnMwIChNIDogQ3JlYXRvcnMwKSA9XG4gIENoZWNrX2NyZWF0b3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9IE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmVsdFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdjbXAgdCA9IE0uY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19jcmVhdG9yczEgKE0gOiBDcmVhdG9yczEpID1cbiAgQ2hlY2tfY3JlYXRvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAnYSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gJ2EgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2NtcCB0ID0gTS5jb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzMiAoTSA6IENyZWF0b3JzMikgPVxuICBDaGVja19jcmVhdG9yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnY21wIHQgPSAnY21wXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19jcmVhdG9yczJfd2l0aF9jb21wYXJhdG9yIChNIDogQ3JlYXRvcnMyX3dpdGhfY29tcGFyYXRvcikgPVxuICBDaGVja19jcmVhdG9yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnY21wIHQgPSAnY21wXG4gICAgZW5kKVxuICAgIChXaXRoX2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpYyA9IHNpZ1xuICBpbmNsdWRlIEFjY2Vzc29yc19nZW5lcmljXG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzX2dlbmVyaWNcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIG9wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIG9wdGlvbnNcbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgdHJlZVxuICAgIHdpdGggdHlwZSAnYSBlbHQgOj0gJ2EgZWx0XG4gICAgd2l0aCB0eXBlICdjbXAgY21wIDo9ICdjbXAgY21wXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczAgPSBzaWdcbiAgaW5jbHVkZSBBY2Nlc3NvcnMwXG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzMFxuICAgIHdpdGggdHlwZSB0IDo9IHRcbiAgICB3aXRoIHR5cGUgdHJlZSA6PSB0cmVlXG4gICAgd2l0aCB0eXBlIGVsdCA6PSBlbHRcbiAgICB3aXRoIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzIDo9IGNvbXBhcmF0b3Jfd2l0bmVzc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMxID0gc2lnXG4gIGluY2x1ZGUgQWNjZXNzb3JzMVxuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yczFcbiAgICB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gICAgd2l0aCB0eXBlICdhIHRyZWUgOj0gJ2EgdHJlZVxuICAgIHdpdGggdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgOj0gY29tcGFyYXRvcl93aXRuZXNzXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczIgPSBzaWdcbiAgaW5jbHVkZSBBY2Nlc3NvcnMyXG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0IHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIHRyZWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMl93aXRoX2NvbXBhcmF0b3IgPSBzaWdcbiAgaW5jbHVkZSBBY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvclxuXG4gIGluY2x1ZGVcbiAgICBDcmVhdG9yczJfd2l0aF9jb21wYXJhdG9yXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIHRyZWVcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX3BvbHkgPSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMVxuXG5tb2R1bGUgdHlwZSBGb3JfZGVyaXZpbmcgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgbW9kdWxlIHR5cGUgU2V4cF9vZl9tID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIG9mX3NleHBdXG5cbiAgICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICAgIFtAQEBlbmRdXG5cbiAgICBpbmNsdWRlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA6PSB0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIE1fc2V4cF9ncmFtbWFyID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX2dyYW1tYXJdXG5cbiAgICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBDb21wYXJlX20gPSBzaWcgZW5kXG4gIG1vZHVsZSB0eXBlIEVxdWFsX20gPSBzaWcgZW5kXG4gIG1vZHVsZSB0eXBlIEhhc2hfZm9sZF9tID0gSGFzaGVyLlNcblxuICB2YWwgc2V4cF9vZl9tX190IDogKG1vZHVsZSBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSAnZWx0KSAtPiAoJ2VsdCwgJ2NtcCkgdCAtPiBTZXhwLnRcblxuICB2YWwgbV9fdF9vZl9zZXhwXG4gICAgOiAgKG1vZHVsZSBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSAnZWx0IGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9ICdjbXApXG4gICAgLT4gU2V4cC50XG4gICAgLT4gKCdlbHQsICdjbXApIHRcblxuICB2YWwgbV9fdF9zZXhwX2dyYW1tYXJcbiAgICA6ICAobW9kdWxlIE1fc2V4cF9ncmFtbWFyIHdpdGggdHlwZSB0ID0gJ2VsdClcbiAgICAtPiAoJ2VsdCwgJ2NtcCkgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIHZhbCBjb21wYXJlX21fX3QgOiAobW9kdWxlIENvbXBhcmVfbSkgLT4gKCdlbHQsICdjbXApIHQgLT4gKCdlbHQsICdjbXApIHQgLT4gaW50XG4gIHZhbCBlcXVhbF9tX190IDogKG1vZHVsZSBFcXVhbF9tKSAtPiAoJ2VsdCwgJ2NtcCkgdCAtPiAoJ2VsdCwgJ2NtcCkgdCAtPiBib29sXG5cbiAgdmFsIGhhc2hfZm9sZF9tX190XG4gICAgOiAgKG1vZHVsZSBIYXNoX2ZvbGRfbSB3aXRoIHR5cGUgdCA9ICdlbHQpXG4gICAgLT4gSGFzaC5zdGF0ZVxuICAgIC0+ICgnZWx0LCBfKSB0XG4gICAgLT4gSGFzaC5zdGF0ZVxuXG4gIHZhbCBoYXNoX21fX3QgOiAobW9kdWxlIEhhc2hfZm9sZF9tIHdpdGggdHlwZSB0ID0gJ2VsdCkgLT4gKCdlbHQsIF8pIHQgLT4gaW50XG5lbmRcblxubW9kdWxlIHR5cGUgU2V0ID0gc2lnXG4gICgqKiBTZXRzIGJhc2VkIG9uIHshQ29tcGFyYXRvci5TfS5cblxuICAgICAgQ3JlYXRvcnMgcmVxdWlyZSBhIGNvbXBhcmF0b3IgYXJndW1lbnQgdG8gYmUgcGFzc2VkIGluLCB3aGVyZWFzIGFjY2Vzc29ycyB1c2UgdGhlXG4gICAgICBjb21wYXJhdG9yIHByb3ZpZGVkIGJ5IHRoZSBpbnB1dCBzZXQuICopXG5cbiAgKCoqIFRoZSB0eXBlIG9mIGEgc2V0LiAgVGhlIGZpcnN0IHR5cGUgcGFyYW1ldGVyIGlkZW50aWZpZXMgdGhlIHR5cGUgb2YgdGhlIGVsZW1lbnQsIGFuZFxuICAgICAgdGhlIHNlY29uZCBpZGVudGlmaWVzIHRoZSBjb21wYXJhdG9yLCB3aGljaCBkZXRlcm1pbmVzIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uIHRoYXRcbiAgICAgIGlzIHVzZWQgZm9yIG9yZGVyaW5nIGVsZW1lbnRzIGluIHRoaXMgc2V0LiAgTWFueSBvcGVyYXRpb25zIChlLmcuLCB7IXVuaW9ufSksXG4gICAgICByZXF1aXJlIHRoYXQgdGhleSBiZSBwYXNzZWQgc2V0cyB3aXRoIHRoZSBzYW1lIGVsZW1lbnQgdHlwZSBhbmQgdGhlIHNhbWUgY29tcGFyYXRvclxuICAgICAgdHlwZS4gKilcbiAgdHlwZSAoJ2VsdCwgJ2NtcCkgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZV1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMyIHdpdGggdHlwZSAoJ2VsdCwgJ2NtcCkgdCA6PSAoJ2VsdCwgJ2NtcCkgdFxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSAoJ2ssICdjbXApIGNvbXBhcmF0b3IgPSAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDIxLTEyXSB1c2UgW0NvbXBhcmF0b3IuTW9kdWxlLnRdIGluc3RlYWRcIl1cblxuICAoKiogVGVzdHMgaW50ZXJuYWwgaW52YXJpYW50cyBvZiB0aGUgc2V0IGRhdGEgc3RydWN0dXJlLiAgUmV0dXJucyB0cnVlIG9uIHN1Y2Nlc3MuICopXG4gIHZhbCBpbnZhcmlhbnRzIDogKF8sIF8pIHQgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIGEgZmlyc3QtY2xhc3MgbW9kdWxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gYnVpbGQgb3RoZXIgbWFwL3NldC9ldGNcbiAgICAgIHdpdGggdGhlIHNhbWUgbm90aW9uIG9mIGNvbXBhcmlzb24uICopXG4gIHZhbCBjb21wYXJhdG9yX3MgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG5cbiAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSBDb21wYXJhdG9yLnRcblxuICAoKiogQ3JlYXRlcyBhbiBlbXB0eSBzZXQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGNvbXBhcmF0b3IuICopXG4gIHZhbCBlbXB0eSA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyBhIHNldCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgY29tcGFyYXRvciB0aGF0IGNvbnRhaW5zIG9ubHkgdGhlIHByb3ZpZGVkXG4gICAgICBlbGVtZW50LiAqKVxuICB2YWwgc2luZ2xldG9uIDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBSZXR1cm5zIHRoZSBjYXJkaW5hbGl0eSBvZiB0aGUgc2V0LiBbTygxKV0uICopXG4gIHZhbCBsZW5ndGggOiAoXywgXykgdCAtPiBpbnRcblxuICAoKiogW2lzX2VtcHR5IHRdIGlzIFt0cnVlXSBpZmYgW3RdIGlzIGVtcHR5LiAgW08oMSldLiAqKVxuICB2YWwgaXNfZW1wdHkgOiAoXywgXykgdCAtPiBib29sXG5cbiAgKCoqIFttZW0gdCBhXSByZXR1cm5zIFt0cnVlXSBpZmYgW2FdIGlzIGluIFt0XS4gIFtPKGxvZyBuKV0uICopXG4gIHZhbCBtZW0gOiAoJ2EsIF8pIHQgLT4gJ2EgLT4gYm9vbFxuXG4gICgqKiBbYWRkIHQgYV0gcmV0dXJucyBhIG5ldyBzZXQgd2l0aCBbYV0gYWRkZWQgdG8gW3RdLCBvciByZXR1cm5zIFt0XSBpZiBbbWVtIHQgYV0uXG4gICAgICBbTyhsb2cgbildLiAqKVxuICB2YWwgYWRkIDogKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbcmVtb3ZlIHQgYV0gcmV0dXJucyBhIG5ldyBzZXQgd2l0aCBbYV0gcmVtb3ZlZCBmcm9tIFt0XSBpZiBbbWVtIHQgYV0sIG9yIHJldHVybnMgW3RdXG4gICAgICBvdGhlcndpc2UuICBbTyhsb2cgbildLiAqKVxuICB2YWwgcmVtb3ZlIDogKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbdW5pb24gdDEgdDJdIHJldHVybnMgdGhlIHVuaW9uIG9mIHRoZSB0d28gc2V0cy4gIFtPKGxlbmd0aCB0MSArIGxlbmd0aCB0MildLiAqKVxuICB2YWwgdW5pb24gOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbdW5pb24gYyBsaXN0XSByZXR1cm5zIHRoZSB1bmlvbiBvZiBhbGwgdGhlIHNldHMgaW4gW2xpc3RdLiAgVGhlXG4gICAgICBbY29tcGFyYXRvcl0gYXJndW1lbnQgaXMgcmVxdWlyZWQgZm9yIHRoZSBjYXNlIHdoZXJlIFtsaXN0XSBpcyBlbXB0eS5cbiAgICAgIFtPKG1heChMaXN0Lmxlbmd0aCBsaXN0LCBuIGxvZyBuKSldLCB3aGVyZSBbbl0gaXMgdGhlIHN1bSBvZiBzaXplcyBvZiB0aGUgaW5wdXQgc2V0cy4gKilcbiAgdmFsIHVuaW9uX2xpc3QgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhLCAnY21wKSB0IGxpc3QgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFtpbnRlciB0MSB0Ml0gY29tcHV0ZXMgdGhlIGludGVyc2VjdGlvbiBvZiBzZXRzIFt0MV0gYW5kIFt0Ml0uICBbTyhsZW5ndGggdDEgK1xuICAgICAgbGVuZ3RoIHQyKV0uICopXG4gIHZhbCBpbnRlciA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFtkaWZmIHQxIHQyXSBjb21wdXRlcyB0aGUgc2V0IGRpZmZlcmVuY2UgW3QxIC0gdDJdLCBpLmUuLCB0aGUgc2V0IGNvbnRhaW5pbmcgYWxsXG4gICAgICBlbGVtZW50cyBpbiBbdDFdIHRoYXQgYXJlIG5vdCBpbiBbdDJdLiAgW08obGVuZ3RoIHQxICsgbGVuZ3RoIHQyKV0uICopXG4gIHZhbCBkaWZmIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW3N5bW1ldHJpY19kaWZmIHQxIHQyXSByZXR1cm5zIGEgc2VxdWVuY2Ugb2YgY2hhbmdlcyBiZXR3ZWVuIFt0MV0gYW5kIFt0Ml0uIEl0IGlzXG4gICAgICBpbnRlbmRlZCB0byBiZSBlZmZpY2llbnQgaW4gdGhlIGNhc2Ugd2hlcmUgW3QxXSBhbmQgW3QyXSBzaGFyZSBhIGxhcmdlIGFtb3VudCBvZlxuICAgICAgc3RydWN0dXJlLiAqKVxuICB2YWwgc3ltbWV0cmljX2RpZmYgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2EpIEVpdGhlci50IFNlcXVlbmNlLnRcblxuICAoKiogW2NvbXBhcmVfZGlyZWN0IHQxIHQyXSBjb21wYXJlcyB0aGUgc2V0cyBbdDFdIGFuZCBbdDJdLiAgSXQgcmV0dXJucyB0aGUgc2FtZSByZXN1bHRcbiAgICAgIGFzIFtjb21wYXJlXSwgYnV0IHVubGlrZSBjb21wYXJlLCBkb2Vzbid0IHJlcXVpcmUgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCBpbiBmb3IgdGhlXG4gICAgICB0eXBlIHBhcmFtZXRlcnMgb2YgdGhlIHNldC4gIFtPKGxlbmd0aCB0MSArIGxlbmd0aCB0MildLiAqKVxuICB2YWwgY29tcGFyZV9kaXJlY3QgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGludFxuXG4gICgqKiBIYXNoIGZ1bmN0aW9uOiBhIGJ1aWxkaW5nIGJsb2NrIHRvIHVzZSB3aGVuIGhhc2hpbmcgZGF0YSBzdHJ1Y3R1cmVzIGNvbnRhaW5pbmcgc2V0cyBpblxuICAgICAgdGhlbS4gW2hhc2hfZm9sZF9kaXJlY3QgaGFzaF9mb2xkX2tleV0gaXMgY29tcGF0aWJsZSB3aXRoIFtjb21wYXJlX2RpcmVjdF0gaWZmXG4gICAgICBbaGFzaF9mb2xkX2tleV0gaXMgY29tcGF0aWJsZSB3aXRoIFsoY29tcGFyYXRvciBzKS5jb21wYXJlXSBvZiB0aGUgc2V0IFtzXSBiZWluZ1xuICAgICAgaGFzaGVkLiAqKVxuICB2YWwgaGFzaF9mb2xkX2RpcmVjdCA6ICdhIEhhc2guZm9sZGVyIC0+ICgnYSwgJ2NtcCkgdCBIYXNoLmZvbGRlclxuXG4gICgqKiBbZXF1YWwgdDEgdDJdIHJldHVybnMgW3RydWVdIGlmZiB0aGUgdHdvIHNldHMgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cy4gIFtPKGxlbmd0aCB0MSArXG4gICAgICBsZW5ndGggdDIpXSAqKVxuICB2YWwgZXF1YWwgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2xcblxuICAoKiogW2V4aXN0cyB0IH5mXSByZXR1cm5zIFt0cnVlXSBpZmYgdGhlcmUgZXhpc3RzIGFuIFthXSBpbiBbdF0gZm9yIHdoaWNoIFtmIGFdLiAgW08obildLFxuICAgICAgYnV0IHJldHVybnMgYXMgc29vbiBhcyBpdCBmaW5kcyBhbiBbYV0gZm9yIHdoaWNoIFtmIGFdLiAqKVxuICB2YWwgZXhpc3RzIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogW2Zvcl9hbGwgdCB+Zl0gcmV0dXJucyBbdHJ1ZV0gaWZmIGZvciBhbGwgW2FdIGluIFt0XSwgW2YgYV0uICBbTyhuKV0sIGJ1dCByZXR1cm5zIGFzXG4gICAgICBzb29uIGFzIGl0IGZpbmRzIGFuIFthXSBmb3Igd2hpY2ggW25vdCAoZiBhKV0uICopXG4gIHZhbCBmb3JfYWxsIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogW2NvdW50IHRdIHJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBbdF0gZm9yIHdoaWNoIFtmXSByZXR1cm5zIFt0cnVlXS5cbiAgICAgIFtPKG4pXS4gKilcbiAgdmFsIGNvdW50IDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGludFxuXG4gICgqKiBbc3VtIHRdIHJldHVybnMgdGhlIHN1bSBvZiBbZiB0XSBmb3IgZWFjaCBbdF0gaW4gdGhlIHNldC5cbiAgICAgIFtPKG4pXS4gKilcbiAgdmFsIHN1bVxuICAgIDogIChtb2R1bGUgQ29udGFpbmVyLlN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSlcbiAgICAtPiAoJ2EsIF8pIHRcbiAgICAtPiBmOignYSAtPiAnc3VtKVxuICAgIC0+ICdzdW1cblxuICAoKiogW2ZpbmQgdCBmXSByZXR1cm5zIGFuIGVsZW1lbnQgb2YgW3RdIGZvciB3aGljaCBbZl0gcmV0dXJucyB0cnVlLCB3aXRoIG5vIGd1YXJhbnRlZSBhc1xuICAgICAgdG8gd2hpY2ggZWxlbWVudCBpcyByZXR1cm5lZC4gIFtPKG4pXSwgYnV0IHJldHVybnMgYXMgc29vbiBhcyBhIHN1aXRhYmxlIGVsZW1lbnQgaXNcbiAgICAgIGZvdW5kLiAqKVxuICB2YWwgZmluZCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSBvcHRpb25cblxuICAoKiogW2ZpbmRfbWFwIHQgZl0gcmV0dXJucyBbYl0gZm9yIHNvbWUgW2FdIGluIFt0XSBmb3Igd2hpY2ggW2YgYSA9IFNvbWUgYl0uICBJZiBubyBzdWNoXG4gICAgICBbYV0gZXhpc3RzLCB0aGVuIFtmaW5kXSByZXR1cm5zIFtOb25lXS4gIFtPKG4pXSwgYnV0IHJldHVybnMgYXMgc29vbiBhcyBhIHN1aXRhYmxlXG4gICAgICBlbGVtZW50IGlzIGZvdW5kLiAqKVxuICB2YWwgZmluZF9tYXAgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cblxuICAoKiogTGlrZSBbZmluZF0sIGJ1dCB0aHJvd3MgYW4gZXhjZXB0aW9uIG9uIGZhaWx1cmUuICopXG4gIHZhbCBmaW5kX2V4biA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYVxuXG4gICgqKiBbbnRoIHQgaV0gcmV0dXJucyB0aGUgW2lddGggc21hbGxlc3QgZWxlbWVudCBvZiBbdF0sIGluIFtPKGxvZyBuKV0gdGltZS4gIFRoZVxuICAgICAgc21hbGxlc3QgZWxlbWVudCBoYXMgW2kgPSAwXS4gIFJldHVybnMgW05vbmVdIGlmIFtpIDwgMF0gb3IgW2kgPj0gbGVuZ3RoIHRdLiAqKVxuICB2YWwgbnRoIDogKCdhLCBfKSB0IC0+IGludCAtPiAnYSBvcHRpb25cblxuICAoKiogW3JlbW92ZV9pbmRleCB0IGldIHJldHVybnMgYSB2ZXJzaW9uIG9mIFt0XSB3aXRoIHRoZSBbaV10aCBzbWFsbGVzdCBlbGVtZW50IHJlbW92ZWQsXG4gICAgICBpbiBbTyhsb2cgbildIHRpbWUuICBUaGUgc21hbGxlc3QgZWxlbWVudCBoYXMgW2kgPSAwXS4gIFJldHVybnMgW3RdIGlmIFtpIDwgMF0gb3JcbiAgICAgIFtpID49IGxlbmd0aCB0XS4gKilcbiAgdmFsIHJlbW92ZV9pbmRleCA6ICgnYSwgJ2NtcCkgdCAtPiBpbnQgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFtpc19zdWJzZXQgdDEgfm9mXzp0Ml0gcmV0dXJucyB0cnVlIGlmZiBbdDFdIGlzIGEgc3Vic2V0IG9mIFt0Ml0uICopXG4gIHZhbCBpc19zdWJzZXQgOiAoJ2EsICdjbXApIHQgLT4gb2ZfOignYSwgJ2NtcCkgdCAtPiBib29sXG5cbiAgKCoqIFthcmVfZGlzam9pbnQgdDEgdDJdIHJldHVybnMgW3RydWVdIGlmZiBbaXNfZW1wdHkgKGludGVyIHQxIHQyKV0sIGJ1dCBpcyBtb3JlXG4gICAgICBlZmZpY2llbnQuICopXG4gIHZhbCBhcmVfZGlzam9pbnQgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2xcblxuICAoKiogW05hbWVkXSBhbGxvd3MgdGhlIHZhbGlkYXRpb24gb2Ygc3Vic2V0IGFuZCBlcXVhbGl0eSByZWxhdGlvbnNoaXBzIGJldHdlZW4gc2V0cy4gIEFcbiAgICAgIFtOYW1lZC50XSBpcyBhIHJlY29yZCBvZiBhIHNldCBhbmQgYSBuYW1lLCB3aGVyZSB0aGUgbmFtZSBpcyB1c2VkIGluIGVycm9yIG1lc3NhZ2VzLFxuICAgICAgYW5kIFtOYW1lZC5pc19zdWJzZXRdIGFuZCBbTmFtZWQuZXF1YWxdIHZhbGlkYXRlIHN1YnNldCBhbmQgZXF1YWxpdHkgcmVsYXRpb25zaGlwc1xuICAgICAgcmVzcGVjdGl2ZWx5LlxuXG4gICAgICBUaGUgZXJyb3IgbWVzc2FnZSBmb3IsIGUuZy4sXG4gICAgICB7W1xuICAgICAgICBOYW1lZC5pc19zdWJzZXQgeyBzZXQgPSBzZXQxOyBuYW1lID0gXCJzZXQxXCIgfSB+b2ZfOntzZXQgPSBzZXQyOyBuYW1lID0gXCJzZXQyXCIgfVxuICAgICAgXX1cblxuICAgICAgbG9va3MgbGlrZVxuICAgICAge3ZcbiAgICAgICAgKFwic2V0MSBpcyBub3QgYSBzdWJzZXQgb2Ygc2V0MlwiIChpbnZhbGlkX2VsZW1lbnRzICguLi5lbGVtZW50cyBvZiBzZXQxIC0gc2V0Mi4uLikpKVxuICAgICB2fVxuXG4gICAgICBzbyBbbmFtZV0gc2hvdWxkIGJlIGEgbm91biBwaHJhc2UgdGhhdCBkb2Vzbid0IHNvdW5kIGF3a3dhcmQgaW4gdGhlIGFib3ZlIGVycm9yXG4gICAgICBtZXNzYWdlLiAgRXZlbiB0aG91Z2ggaXQgYWRkcyB2ZXJib3NpdHksIGNob29zaW5nIFtuYW1lXXMgdGhhdCBzdGFydCB3aXRoIHRoZSBwaHJhc2VcbiAgICAgIFwidGhlIHNldCBvZlwiIG9mdGVuIG1ha2VzIHRoZSBlcnJvciBtZXNzYWdlIHNvdW5kIG1vcmUgbmF0dXJhbC5cbiAgKilcbiAgbW9kdWxlIE5hbWVkIDogc2lnXG4gICAgdHlwZSBub25yZWMgKCdhLCAnY21wKSB0ID1cbiAgICAgIHsgc2V0IDogKCdhLCAnY21wKSB0XG4gICAgICA7IG5hbWUgOiBzdHJpbmdcbiAgICAgIH1cblxuICAgICgqKiBbaXNfc3Vic2V0IHQxIH5vZl86dDJdIHJldHVybnMgW09rICgpXSBpZiBbdDFdIGlzIGEgc3Vic2V0IG9mIFt0Ml0gYW5kIGFcbiAgICAgICAgaHVtYW4tcmVhZGFibGUgZXJyb3Igb3RoZXJ3aXNlLiAgKilcbiAgICB2YWwgaXNfc3Vic2V0IDogKCdhLCAnY21wKSB0IC0+IG9mXzooJ2EsICdjbXApIHQgLT4gdW5pdCBPcl9lcnJvci50XG5cbiAgICAoKiogW2VxdWFsIHQxIHQyXSByZXR1cm5zIFtPayAoKV0gaWYgW3QxXSBpcyBlcXVhbCB0byBbdDJdIGFuZCBhIGh1bWFuLXJlYWRhYmxlXG4gICAgICAgIGVycm9yIG90aGVyd2lzZS4gICopXG4gICAgdmFsIGVxdWFsIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiB1bml0IE9yX2Vycm9yLnRcbiAgZW5kXG5cbiAgKCoqIFRoZSBsaXN0IG9yIGFycmF5IGdpdmVuIHRvIFtvZl9saXN0XSBhbmQgW29mX2FycmF5XSBuZWVkIG5vdCBiZSBzb3J0ZWQuICopXG4gIHZhbCBvZl9saXN0IDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIGxpc3QgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIG9mX3NlcXVlbmNlIDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIFNlcXVlbmNlLnQgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBvZl9hcnJheSA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnYSBhcnJheSAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW3RvX2xpc3RdIGFuZCBbdG9fYXJyYXldIHByb2R1Y2Ugc2VxdWVuY2VzIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAgY29tcGFyYXRvci4gKilcbiAgdmFsIHRvX2xpc3QgOiAoJ2EsIF8pIHQgLT4gJ2EgbGlzdFxuXG4gIHZhbCB0b19hcnJheSA6ICgnYSwgXykgdCAtPiAnYSBhcnJheVxuXG4gICgqKiBDcmVhdGUgc2V0IGZyb20gc29ydGVkIGFycmF5LiAgVGhlIGlucHV0IG11c3QgYmUgc29ydGVkIChlaXRoZXIgaW4gYXNjZW5kaW5nIG9yXG4gICAgICBkZXNjZW5kaW5nIG9yZGVyIGFzIGdpdmVuIGJ5IHRoZSBjb21wYXJhdG9yKSBhbmQgY29udGFpbiBubyBkdXBsaWNhdGVzLCBvdGhlcndpc2UgdGhlXG4gICAgICByZXN1bHQgaXMgYW4gZXJyb3IuICBUaGUgY29tcGxleGl0eSBvZiB0aGlzIGZ1bmN0aW9uIGlzIFtPKG4pXS4gKilcbiAgdmFsIG9mX3NvcnRlZF9hcnJheVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICdhIGFycmF5XG4gICAgLT4gKCdhLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICAoKiogU2ltaWxhciB0byBbb2Zfc29ydGVkX2FycmF5XSwgYnV0IHdpdGhvdXQgY2hlY2tpbmcgdGhlIGlucHV0IGFycmF5LiAqKVxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICdhIGFycmF5XG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFtvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCBjIH5sZW4gfmZdIGJlaGF2ZXMgbGlrZSBbb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBjXG4gICAgICAoQXJyYXkuaW5pdCBsZW4gfmYpXSwgd2l0aCB0aGUgYWRkaXRpb25hbCByZXN0cmljdGlvbiB0aGF0IGEgZGVjcmVhc2luZyBvcmRlciBpcyBub3RcbiAgICAgIHN1cHBvcnRlZC4gIFRoZSBhZHZhbnRhZ2UgaXMgbm90IHJlcXVpcmluZyB5b3UgdG8gYWxsb2NhdGUgYW4gaW50ZXJtZWRpYXRlIGFycmF5LiAgW2ZdXG4gICAgICB3aWxsIGJlIGNhbGxlZCB3aXRoIDAsIDEsIC4uLiBbbGVuIC0gMV0sIGluIG9yZGVyLiAqKVxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gZjooaW50IC0+ICdhKVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbc3RhYmxlX2RlZHVwX2xpc3RdIGlzIGhlcmUgcmF0aGVyIHRoYW4gaW4gdGhlIFtMaXN0XSBtb2R1bGUgYmVjYXVzZSB0aGVcbiAgICAgIGltcGxlbWVudGF0aW9uIHJlbGllcyBjcnVjaWFsbHkgb24gc2V0cywgYW5kIGJlY2F1c2UgZG9pbmcgc28gYWxsb3dzIG9uZSB0byBhdm9pZCB1c2VzXG4gICAgICBvZiBwb2x5bW9ycGhpYyBjb21wYXJpc29uIGJ5IGluc3RhbnRpYXRpbmcgdGhlIGZ1bmN0b3IgYXQgYSBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb25cbiAgICAgIG9mIFtDb21wYXJhdG9yXSBhbmQgdXNpbmcgdGhlIHJlc3VsdGluZyBbc3RhYmxlX2RlZHVwX2xpc3RdLiAqKVxuICB2YWwgc3RhYmxlX2RlZHVwX2xpc3QgOiAoJ2EsIF8pIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ2EgbGlzdCAtPiAnYSBsaXN0XG5cbiAgKCoqIFttYXAgYyB0IH5mXSByZXR1cm5zIGEgbmV3IHNldCBjcmVhdGVkIGJ5IGFwcGx5aW5nIFtmXSB0byBldmVyeSBlbGVtZW50IGluXG4gICAgICBbdF0uICBUaGUgcmV0dXJuZWQgc2V0IGlzIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBbY29tcGFyYXRvcl0uICBbTyhuIGxvZyBuKV0uICopXG4gIHZhbCBtYXAgOiAoJ2IsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhLCBfKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdjbXApIHRcblxuICAoKiogTGlrZSB7IW1hcH0sIGV4Y2VwdCBlbGVtZW50cyBmb3Igd2hpY2ggW2ZdIHJldHVybnMgW05vbmVdIHdpbGwgYmUgZHJvcHBlZC4gICopXG4gIHZhbCBmaWx0ZXJfbWFwXG4gICAgOiAgKCdiLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhLCBfKSB0XG4gICAgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKVxuICAgIC0+ICgnYiwgJ2NtcCkgdFxuXG4gICgqKiBbZmlsdGVyIHQgfmZdIHJldHVybnMgdGhlIHN1YnNldCBvZiBbdF0gZm9yIHdoaWNoIFtmXSBldmFsdWF0ZXMgdG8gdHJ1ZS4gIFtPKG4gbG9nXG4gICAgICBuKV0uICopXG4gIHZhbCBmaWx0ZXIgOiAoJ2EsICdjbXApIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFtmb2xkIHQgfmluaXQgfmZdIGZvbGRzIG92ZXIgdGhlIGVsZW1lbnRzIG9mIHRoZSBzZXQgZnJvbSBzbWFsbGVzdCB0byBsYXJnZXN0LiAqKVxuICB2YWwgZm9sZCA6ICgnYSwgXykgdCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gJ2EgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICAoKiogW2ZvbGRfcmVzdWx0IH5pbml0IH5mXSBmb2xkcyBvdmVyIHRoZSBlbGVtZW50cyBvZiB0aGUgc2V0IGZyb20gc21hbGxlc3QgdG9cbiAgICAgIGxhcmdlc3QsIHNob3J0IGNpcmN1aXRpbmcgdGhlIGZvbGQgaWYgW2YgYWNjdW0geF0gaXMgYW4gW0Vycm9yIF9dICopXG4gIHZhbCBmb2xkX3Jlc3VsdFxuICAgIDogICgnYSwgXykgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnRcblxuICAoKiogW2ZvbGRfdW50aWwgdCB+aW5pdCB+Zl0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdLiBJZiBbZl1cbiAgICAgIHJldHVybnMgW1N0b3AgX10gdGhlIGNvbXB1dGF0aW9uIGNlYXNlcyBhbmQgcmVzdWx0cyBpbiB0aGF0IHZhbHVlLiBJZiBbZl0gcmV0dXJuc1xuICAgICAgW0NvbnRpbnVlIF9dLCB0aGUgZm9sZCB3aWxsIHByb2NlZWQuICopXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgLT4gKCdhY2N1bSwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjY3VtIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuXG4gICgqKiBMaWtlIHshZm9sZH0sIGV4Y2VwdCB0aGF0IGl0IGdvZXMgZnJvbSB0aGUgbGFyZ2VzdCB0byB0aGUgc21hbGxlc3QgZWxlbWVudC4gKilcbiAgdmFsIGZvbGRfcmlnaHQgOiAoJ2EsIF8pIHQgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2EgLT4gJ2FjY3VtIC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgKCoqIFtpdGVyIHQgfmZdIGNhbGxzIFtmXSBvbiBldmVyeSBlbGVtZW50IG9mIFt0XSwgZ29pbmcgaW4gb3JkZXIgZnJvbSB0aGUgc21hbGxlc3QgdG9cbiAgICAgIGxhcmdlc3QuICAqKVxuICB2YWwgaXRlciA6ICgnYSwgXykgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIEl0ZXJhdGUgdHdvIHNldHMgc2lkZSBieSBzaWRlLiAgQ29tcGxleGl0eSBpcyBbTyhtK24pXSB3aGVyZSBbbV0gYW5kIFtuXSBhcmUgdGhlIHNpemVzXG4gICAgICBvZiB0aGUgdHdvIGlucHV0IHNldHMuICBBcyBhbiBleGFtcGxlLCB3aXRoIHRoZSBpbnB1dHMgWzA7IDFdIGFuZCBbMTsgMl0sIFtmXSB3aWxsIGJlXG4gICAgICBjYWxsZWQgd2l0aCBbYExlZnQgMF07IFtgQm90aCAoMSwgMSldOyBhbmQgW2BSaWdodCAyXS4gKilcbiAgdmFsIGl0ZXIyXG4gICAgOiAgKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gZjooWyBgTGVmdCBvZiAnYSB8IGBSaWdodCBvZiAnYSB8IGBCb3RoIG9mICdhICogJ2EgXSAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICAoKiogaWYgW2EsIGIgPSBwYXJ0aXRpb25fdGYgc2V0IH5mXSB0aGVuIFthXSBpcyB0aGUgZWxlbWVudHMgb24gd2hpY2ggW2ZdIHByb2R1Y2VkIFt0cnVlXSxcbiAgICAgIGFuZCBbYl0gaXMgdGhlIGVsZW1lbnRzIG9uIHdoaWNoIFtmXSBwcm9kdWNlcyBbZmFsc2VdLiAqKVxuICB2YWwgcGFydGl0aW9uX3RmIDogKCdhLCAnY21wKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCAqICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBTYW1lIGFzIHshdG9fbGlzdH0uICopXG4gIHZhbCBlbGVtZW50cyA6ICgnYSwgXykgdCAtPiAnYSBsaXN0XG5cbiAgKCoqIFJldHVybnMgdGhlIHNtYWxsZXN0IGVsZW1lbnQgb2YgdGhlIHNldC4gIFtPKGxvZyBuKV0uICopXG4gIHZhbCBtaW5fZWx0IDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuXG4gICgqKiBMaWtlIHshbWluX2VsdH0sIGJ1dCB0aHJvd3MgYW4gZXhjZXB0aW9uIHdoZW4gZ2l2ZW4gYW4gZW1wdHkgc2V0LiAqKVxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcblxuICAoKiogUmV0dXJucyB0aGUgbGFyZ2VzdCBlbGVtZW50IG9mIHRoZSBzZXQuICBbTyhsb2cgbildLiAgKilcbiAgdmFsIG1heF9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIExpa2UgeyFtYXhfZWx0fSwgYnV0IHRocm93cyBhbiBleGNlcHRpb24gd2hlbiBnaXZlbiBhbiBlbXB0eSBzZXQuICopXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnYSwgXykgdCAtPiAnYVxuXG4gICgqKiByZXR1cm5zIGFuIGFyYml0cmFyeSBlbGVtZW50LCBvciBbTm9uZV0gaWYgdGhlIHNldCBpcyBlbXB0eS4gKilcbiAgdmFsIGNob29zZSA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cblxuICAoKiogTGlrZSB7IWNob29zZX0sIGJ1dCB0aHJvd3MgYW4gZXhjZXB0aW9uIG9uIGFuIGVtcHR5IHNldC4gKilcbiAgdmFsIGNob29zZV9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcblxuICAoKiogW3NwbGl0IHQgeF0gcHJvZHVjZXMgYSB0cmlwbGUgWyh0MSwgbWF5YmVfeCwgdDIpXSB3aGVyZSBbdDFdIGlzIHRoZSBzZXQgb2YgZWxlbWVudHNcbiAgICAgIHN0cmljdGx5IGxlc3MgdGhhbiBbeF0sIFttYXliZV94XSBpcyB0aGUgbWVtYmVyIChpZiBhbnkpIG9mIFt0XSB3aGljaCBjb21wYXJlcyBlcXVhbFxuICAgICAgdG8gW3hdLCBhbmQgW3QyXSBpcyB0aGUgc2V0IG9mIGVsZW1lbnRzIHN0cmljdGx5IGxhcmdlciB0aGFuIFt4XS4gKilcbiAgdmFsIHNwbGl0IDogKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdCAqICdhIG9wdGlvbiAqICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBpZiBbZXF1aXZdIGlzIGFuIGVxdWl2YWxlbmNlIHByZWRpY2F0ZSwgdGhlbiBbZ3JvdXBfYnkgc2V0IH5lcXVpdl0gcHJvZHVjZXMgYSBsaXN0XG4gICAgICBvZiBlcXVpdmFsZW5jZSBjbGFzc2VzIChpLmUuLCBhIHNldC10aGVvcmV0aWMgcXVvdGllbnQpLiAgRS5nLixcblxuICAgICAge1tcbiAgICAgICAgbGV0IGNoYXJzID0gU2V0Lm9mX2xpc3QgWydBJzsgJ2EnOyAnYic7ICdjJ10gaW5cbiAgICAgICAgbGV0IGVxdWl2IGMgYycgPSBDaGFyLmVxdWFsIChDaGFyLnVwcGVyY2FzZSBjKSAoQ2hhci51cHBlcmNhc2UgYycpIGluXG4gICAgICAgIGdyb3VwX2J5IGNoYXJzIH5lcXVpdlxuICAgICAgXX1cblxuICAgICAgcHJvZHVjZXM6XG5cbiAgICAgIHtbXG4gICAgICAgIFtTZXQub2ZfbGlzdCBbJ0EnOydhJ107IFNldC5zaW5nbGV0b24gJ2InOyBTZXQuc2luZ2xldG9uICdjJ11cbiAgICAgIF19XG5cbiAgICAgIFtncm91cF9ieV0gcnVucyBpbiBPKG5eMikgdGltZSwgc28gaWYgeW91IGhhdmUgYSBjb21wYXJpc29uIGZ1bmN0aW9uLCBpdCdzIHVzdWFsbHlcbiAgICAgIG11Y2ggZmFzdGVyIHRvIHVzZSBbU2V0Lm9mX2xpc3RdLiAqKVxuICB2YWwgZ3JvdXBfYnkgOiAoJ2EsICdjbXApIHQgLT4gZXF1aXY6KCdhIC0+ICdhIC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCBsaXN0XG5cbiAgKCoqIFt0b19zZXF1ZW5jZSB0XSBjb252ZXJ0cyB0aGUgc2V0IFt0XSB0byBhIHNlcXVlbmNlIG9mIHRoZSBlbGVtZW50cyBiZXR3ZWVuXG4gICAgICBbZ3JlYXRlcl9vcl9lcXVhbF90b10gYW5kIFtsZXNzX29yX2VxdWFsX3RvXSBpbmNsdXNpdmUgaW4gdGhlIG9yZGVyIGluZGljYXRlZCBieVxuICAgICAgW29yZGVyXS4gIElmIFtncmVhdGVyX29yX2VxdWFsX3RvID4gbGVzc19vcl9lcXVhbF90b10gdGhlIHNlcXVlbmNlIGlzIGVtcHR5LiAgQ29zdCBpc1xuICAgICAgTyhsb2cgbikgdXAgZnJvbnQgYW5kIGFtb3J0aXplZCBPKDEpIGZvciBlYWNoIGVsZW1lbnQgcHJvZHVjZWQuICopXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nICgqKiBkZWZhdWx0ICopIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAnYSBTZXF1ZW5jZS50XG5cbiAgKCoqIFtiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgd2hpY2ggZWx0XSByZXR1cm5zIHRoZSBlbGVtZW50IGluIFt0XSBzcGVjaWZpZWQgYnlcbiAgICAgIFtjb21wYXJlXSBhbmQgW3doaWNoXSwgaWYgb25lIGV4aXN0cy5cblxuICAgICAgW3RdIG11c3QgYmUgc29ydGVkIGluIGluY3JlYXNpbmcgb3JkZXIgYWNjb3JkaW5nIHRvIFtjb21wYXJlXSwgd2hlcmUgW2NvbXBhcmVdIGFuZFxuICAgICAgW2VsdF0gZGl2aWRlIFt0XSBpbnRvIHRocmVlIChwb3NzaWJseSBlbXB0eSkgc2VnbWVudHM6XG5cbiAgICAgIHt2XG4gICAgICAgIHwgIDwgZWx0ICB8ICA9IGVsdCAgfCAgPiBlbHQgIHxcbiAgICAgIHZ9XG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoXSByZXR1cm5zIGFuIGVsZW1lbnQgb24gdGhlIGJvdW5kYXJ5IG9mIHNlZ21lbnRzIGFzIHNwZWNpZmllZCBieVxuICAgICAgW3doaWNoXS4gIFNlZSB0aGUgZGlhZ3JhbSBiZWxvdyBuZXh0IHRvIHRoZSBbd2hpY2hdIHZhcmlhbnRzLlxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF0gZG9lcyBub3QgY2hlY2sgdGhhdCBbY29tcGFyZV0gb3JkZXJzIFt0XSwgYW5kIGJlaGF2aW9yIGlzXG4gICAgICB1bnNwZWNpZmllZCBpZiBbY29tcGFyZV0gZG9lc24ndCBvcmRlciBbdF0uICBCZWhhdmlvciBpcyBhbHNvIHVuc3BlY2lmaWVkIGlmXG4gICAgICBbY29tcGFyZV0gbXV0YXRlcyBbdF0uICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgKCdhLCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooJ2EgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gWyBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gKCoqICAgICAgICB7diB8IDwgZWx0IFggfCAgICAgICAgICAgICAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAoKiogICAgIHt2IHwgICAgICA8PSBlbHQgICAgICAgWCB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYExhc3RfZXF1YWxfdG8gKCoqICAgICAgICAgICAgICAgICAge3YgICAgICAgICAgIHwgICA9IGVsdCBYIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgRmlyc3RfZXF1YWxfdG8gKCoqICAgICAgICAgICAgICAgICB7diAgICAgICAgICAgfCBYID0gZWx0ICAgfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG8gKCoqIHt2ICAgICAgICAgICB8IFggICAgICAgPj0gZWx0ICAgICAgfCB2fSAqKVxuICAgICAgIHwgYEZpcnN0X3N0cmljdGx5X2dyZWF0ZXJfdGhhbiAoKiogICAge3YgICAgICAgICAgICAgICAgICAgICAgIHwgWCA+IGVsdCB8IHZ9ICopXG4gICAgICAgXVxuICAgIC0+ICdrZXlcbiAgICAtPiAnYSBvcHRpb25cblxuICAoKiogW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2Ygd2hpY2hdIHRha2VzIGEgW3NlZ21lbnRfb2ZdIGZ1bmN0aW9uIHRoYXRcbiAgICAgIGRpdmlkZXMgW3RdIGludG8gdHdvIChwb3NzaWJseSBlbXB0eSkgc2VnbWVudHM6XG5cbiAgICAgIHt2XG4gICAgICAgIHwgc2VnbWVudF9vZiBlbHQgPSBgTGVmdCB8IHNlZ21lbnRfb2YgZWx0ID0gYFJpZ2h0IHxcbiAgICAgIHZ9XG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZF0gcmV0dXJucyB0aGUgZWxlbWVudCBvbiB0aGUgYm91bmRhcnkgb2YgdGhlIHNlZ21lbnRzIGFzXG4gICAgICBzcGVjaWZpZWQgYnkgW3doaWNoXTogW2BMYXN0X29uX2xlZnRdIHlpZWxkcyB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBsZWZ0IHNlZ21lbnQsXG4gICAgICB3aGlsZSBbYEZpcnN0X29uX3JpZ2h0XSB5aWVsZHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIHJpZ2h0IHNlZ21lbnQuICBJdCByZXR1cm5zXG4gICAgICBbTm9uZV0gaWYgdGhlIHNlZ21lbnQgaXMgZW1wdHkuXG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZF0gZG9lcyBub3QgY2hlY2sgdGhhdCBbc2VnbWVudF9vZl0gc2VnbWVudHMgW3RdIGFzIGluIHRoZVxuICAgICAgZGlhZ3JhbSwgYW5kIGJlaGF2aW9yIGlzIHVuc3BlY2lmaWVkIGlmIFtzZWdtZW50X29mXSBkb2Vzbid0IHNlZ21lbnQgW3RdLiAgQmVoYXZpb3JcbiAgICAgIGlzIGFsc28gdW5zcGVjaWZpZWQgaWYgW3NlZ21lbnRfb2ZdIG11dGF0ZXMgW3RdLiAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICAoJ2EsICdjbXApIHRcbiAgICAtPiBzZWdtZW50X29mOignYSAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gWyBgTGFzdF9vbl9sZWZ0IHwgYEZpcnN0X29uX3JpZ2h0IF1cbiAgICAtPiAnYSBvcHRpb25cblxuICAoKiogUHJvZHVjZXMgdGhlIGVsZW1lbnRzIG9mIHRoZSB0d28gc2V0cyBiZXR3ZWVuIFtncmVhdGVyX29yX2VxdWFsX3RvXSBhbmRcbiAgICAgIFtsZXNzX29yX2VxdWFsX3RvXSBpbiBbb3JkZXJdLCBub3Rpbmcgd2hldGhlciBlYWNoIGVsZW1lbnQgYXBwZWFycyBpbiB0aGUgbGVmdCBzZXQsXG4gICAgICB0aGUgcmlnaHQgc2V0LCBvciBib3RoLiAgSW4gdGhlIGJvdGggY2FzZSwgYm90aCBlbGVtZW50cyBhcmUgcmV0dXJuZWQsIGluIGNhc2UgdGhlXG4gICAgICBjYWxsZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW4gZWxlbWVudHMgdGhhdCBhcmUgZXF1YWwgdG8gdGhlIHNldHMnIGNvbXBhcmF0b3IuICBSdW5zXG4gICAgICBpbiBPKGxlbmd0aCB0ICsgbGVuZ3RoIHQnKS4gKilcbiAgbW9kdWxlIE1lcmdlX3RvX3NlcXVlbmNlX2VsZW1lbnQgOiBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBTZXF1ZW5jZS5NZXJnZV93aXRoX2R1cGxpY2F0ZXNfZWxlbWVudC50ID1cbiAgICAgIHwgTGVmdCBvZiAnYVxuICAgICAgfCBSaWdodCBvZiAnYlxuICAgICAgfCBCb3RoIG9mICdhICogJ2JcbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgIGluY2x1ZGUgU2V4cGxpYjAuU2V4cGFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgdmFsIG1lcmdlX3RvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmcgKCoqIGRlZmF1bHQgKikgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2EpIE1lcmdlX3RvX3NlcXVlbmNlX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5cbiAgKCoqIFtNXSBpcyBtZWFudCB0byBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggT0NhbWwgYXBwbGljYXRpdmUgZnVuY3RvciB0eXBlczpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBzdHJpbmdfc2V0ID0gU2V0Lk0oU3RyaW5nKS50XG4gICAgICBdfVxuXG4gICAgICB3aGljaCBzdGFuZHMgZm9yOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHN0cmluZ19zZXQgPSAoU3RyaW5nLnQsIFN0cmluZy5jb21wYXJhdG9yX3dpdG5lc3MpIFNldC50XG4gICAgICBdfVxuXG4gICAgICBUaGUgcG9pbnQgaXMgdGhhdCBbU2V0Lk0oU3RyaW5nKS50XSBzdXBwb3J0cyBkZXJpdmluZywgd2hlcmVhcyB0aGUgc2Vjb25kIHN5bnRheFxuICAgICAgZG9lc24ndCAoYmVjYXVzZSB0aGVyZSBpcyBubyBzdWNoIHRoaW5nIGFzLCBzYXksIFN0cmluZy5zZXhwX29mX2NvbXBhcmF0b3Jfd2l0bmVzcyxcbiAgICAgIGluc3RlYWQgeW91IHdvdWxkIHdhbnQgdG8gcGFzcyB0aGUgY29tcGFyYXRvciBkaXJlY3RseSkuICopXG4gIG1vZHVsZSBNIChFbHQgOiBzaWdcbiAgICAgIHR5cGUgdFxuICAgICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpIDogc2lnXG4gICAgdHlwZSBub25yZWMgdCA9IChFbHQudCwgRWx0LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICBlbmRcblxuICBpbmNsdWRlIEZvcl9kZXJpdmluZyB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgKCoqIEEgcG9seW1vcnBoaWMgU2V0LiAqKVxuICBtb2R1bGUgUG9seSA6IFNfcG9seSB3aXRoIHR5cGUgJ2VsdCB0ID0gKCdlbHQsIENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3MpIHRcblxuICAoKiogVXNpbmcgY29tcGFyYXRvciBpcyBhIHNpbWlsYXIgaW50ZXJmYWNlIGFzIHRoZSB0b3BsZXZlbCBvZiBbU2V0XSwgZXhjZXB0IHRoZSBmdW5jdGlvbnNcbiAgICAgIHRha2UgYSBbfmNvbXBhcmF0b3I6KCdlbHQsICdjbXApIENvbXBhcmF0b3IudF0gd2hlcmUgdGhlIGZ1bmN0aW9ucyBhdCB0aGUgdG9wbGV2ZWwgb2ZcbiAgICAgIFtTZXRdIHRha2VzIGEgWygnZWx0LCAnY21wKSBjb21wYXJhdG9yXS4gKilcbiAgbW9kdWxlIFVzaW5nX2NvbXBhcmF0b3IgOiBzaWdcbiAgICB0eXBlIG5vbnJlYyAoJ2VsdCwgJ2NtcCkgdCA9ICgnZWx0LCAnY21wKSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdFxuICAgICAgOiAgKCdlbHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdjbXAgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdlbHQsICdjbXApIHRcbiAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgIHZhbCB0X29mX3NleHBfZGlyZWN0XG4gICAgICA6ICBjb21wYXJhdG9yOignZWx0LCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAgIC0+IChTZXhwLnQgLT4gJ2VsdClcbiAgICAgIC0+IFNleHAudFxuICAgICAgLT4gKCdlbHQsICdjbXApIHRcblxuICAgIG1vZHVsZSBUcmVlIDogc2lnXG4gICAgICAoKiogQSBbVHJlZS50XSBjb250YWlucyBqdXN0IHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlIHRoYXQgYSBzZXQgaXMgYmFzZWQgb24sIHdpdGhvdXRcbiAgICAgICAgICBpbmNsdWRpbmcgdGhlIGNvbXBhcmF0b3IuICBBY2NvcmRpbmdseSwgYW55IG9wZXJhdGlvbiBvbiBhIFtUcmVlLnRdIG11c3QgYWxzbyB0YWtlXG4gICAgICAgICAgYXMgYW4gYXJndW1lbnQgdGhlIGNvcnJlc3BvbmRpbmcgY29tcGFyYXRvci4gKilcbiAgICAgIHR5cGUgKCdhLCAnY21wKSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgICB2YWwgc2V4cF9vZl90XG4gICAgICAgIDogICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgIC0+ICgnY21wIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdhLCAnY21wKSB0XG4gICAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgICBbQEBAZW5kXVxuXG4gICAgICB2YWwgdF9vZl9zZXhwX2RpcmVjdFxuICAgICAgICA6ICBjb21wYXJhdG9yOignZWx0LCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAgICAgLT4gKFNleHAudCAtPiAnZWx0KVxuICAgICAgICAtPiBTZXhwLnRcbiAgICAgICAgLT4gKCdlbHQsICdjbXApIHRcblxuICAgICAgbW9kdWxlIE5hbWVkIDogc2lnXG4gICAgICAgIHR5cGUgbm9ucmVjICgnYSwgJ2NtcCkgdCA9XG4gICAgICAgICAgeyB0cmVlIDogKCdhLCAnY21wKSB0XG4gICAgICAgICAgOyBuYW1lIDogc3RyaW5nXG4gICAgICAgICAgfVxuXG4gICAgICAgIHZhbCBpc19zdWJzZXRcbiAgICAgICAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAgICAgLT4gKCdhLCAnY21wKSB0XG4gICAgICAgICAgLT4gb2ZfOignYSwgJ2NtcCkgdFxuICAgICAgICAgIC0+IHVuaXQgT3JfZXJyb3IudFxuXG4gICAgICAgIHZhbCBlcXVhbFxuICAgICAgICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAgICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgICAgICAtPiB1bml0IE9yX2Vycm9yLnRcbiAgICAgIGVuZFxuXG4gICAgICBpbmNsdWRlXG4gICAgICAgIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvclxuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYikgc2V0IDo9ICgnYSwgJ2IpIHRcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdHJlZSA6PSAoJ2EsICdiKSB0XG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSBuYW1lZCA6PSAoJ2EsICdiKSBOYW1lZC50XG4gICAgICAgIHdpdGggbW9kdWxlIE5hbWVkIDo9IE5hbWVkXG5cbiAgICAgIHZhbCBlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIDogKF8sIF8pIHRcbiAgICBlbmRcblxuICAgIGluY2x1ZGVcbiAgICAgIEFjY2Vzc29yczJcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIFRyZWUudFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIG5hbWVkIDo9ICgnYSwgJ2IpIE5hbWVkLnRcblxuICAgIGluY2x1ZGVcbiAgICAgIENyZWF0b3JzMl93aXRoX2NvbXBhcmF0b3JcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIFRyZWUudFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHNldCA6PSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgY29tcGFyYXRvciA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIHZhbCBoYXNoX2ZvbGRfZGlyZWN0IDogJ2VsdCBIYXNoLmZvbGRlciAtPiAoJ2VsdCwgJ2NtcCkgdCBIYXNoLmZvbGRlclxuXG4gICAgbW9kdWxlIEVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gKEVsdCA6IENvbXBhcmF0b3IuUzEpIDogc2lnXG4gICAgICB2YWwgZW1wdHkgOiAoJ2EgRWx0LnQsIEVsdC5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgICBlbmRcbiAgZW5kXG5cbiAgKCoqIHsyIE1vZHVsZXMgYW5kIG1vZHVsZSB0eXBlcyBmb3IgZXh0ZW5kaW5nIFtTZXRdfVxuXG4gICAgICBGb3IgdXNlIGluIGV4dGVuc2lvbnMgb2YgQmFzZSwgbGlrZSBbQ29yZV0uICopXG5cbiAgbW9kdWxlIFdpdGhfY29tcGFyYXRvciA9IFdpdGhfY29tcGFyYXRvclxuICBtb2R1bGUgV2l0aF9maXJzdF9jbGFzc19tb2R1bGUgPSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZVxuICBtb2R1bGUgV2l0aG91dF9jb21wYXJhdG9yID0gV2l0aG91dF9jb21wYXJhdG9yXG5cbiAgbW9kdWxlIHR5cGUgRm9yX2Rlcml2aW5nID0gRm9yX2Rlcml2aW5nXG4gIG1vZHVsZSB0eXBlIFNfcG9seSA9IFNfcG9seVxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnMwID0gQWNjZXNzb3JzMFxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnMxID0gQWNjZXNzb3JzMVxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnMyID0gQWNjZXNzb3JzMlxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvciA9IEFjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yc19nZW5lcmljID0gQWNjZXNzb3JzX2dlbmVyaWNcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMwID0gQ3JlYXRvcnMwXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMSA9IENyZWF0b3JzMVxuICBtb2R1bGUgdHlwZSBDcmVhdG9yczIgPSBDcmVhdG9yczJcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMyX3dpdGhfY29tcGFyYXRvciA9IENyZWF0b3JzMl93aXRoX2NvbXBhcmF0b3JcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczAgPSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMFxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMSA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMxXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyID0gQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczJcblxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMl93aXRoX2NvbXBhcmF0b3IgPVxuICAgIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvclxuXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBDcmVhdG9yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIEVsdF9wbGFpbiA9IEVsdF9wbGFpblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICopXG4oKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICopXG4oKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgMi4wIGxpY2Vuc2UuIFNlZSAuLi9USElSRC1QQVJUWS50eHQgICopXG4oKiAgZm9yIGRldGFpbHMuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFNldHMgb3ZlciBvcmRlcmVkIHR5cGVzICopXG5cbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBTZXRfaW50ZlxuXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxuXG5cbm1vZHVsZSBUcmVlMCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHwgRW1wdHlcbiAgICAoKiAoTGVhZiB4KSBpcyB0aGUgc2FtZSBhcyAoTm9kZSAoRW1wdHksIHgsIEVtcHR5LCAxLCAxKSkgYnV0IHVzZXMgbGVzcyBzcGFjZS4gKilcbiAgICB8IExlYWYgb2YgJ2FcbiAgICAoKiBmaXJzdCBpbnQgaXMgaGVpZ2h0LCBzZWNvbmQgaXMgc3ViLXRyZWUgc2l6ZSAqKVxuICAgIHwgTm9kZSBvZiAnYSB0ICogJ2EgKiAnYSB0ICogaW50ICogaW50XG5cbiAgdHlwZSAnYSB0cmVlID0gJ2EgdFxuXG4gICgqIFNldHMgYXJlIHJlcHJlc2VudGVkIGJ5IGJhbGFuY2VkIGJpbmFyeSB0cmVlcyAodGhlIGhlaWdodHMgb2YgdGhlIGNoaWxkcmVuIGRpZmZlciBieVxuICAgICBhdCBtb3N0IDIuICopXG4gIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gMFxuICAgIHwgTGVhZiBfIC0+IDFcbiAgICB8IE5vZGUgKF8sIF8sIF8sIGgsIF8pIC0+IGhcbiAgOztcblxuICBsZXQgbGVuZ3RoID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IDBcbiAgICB8IExlYWYgXyAtPiAxXG4gICAgfCBOb2RlIChfLCBfLCBfLCBfLCBzKSAtPiBzXG4gIDs7XG5cbiAgbGV0IGludmFyaWFudHMgPVxuICAgIGxldCBpbl9yYW5nZSBsb3dlciB1cHBlciBjb21wYXJlX2VsdCB2ID1cbiAgICAgIChtYXRjaCBsb3dlciB3aXRoXG4gICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgICB8IFNvbWUgbG93ZXIgLT4gY29tcGFyZV9lbHQgbG93ZXIgdiA8IDApXG4gICAgICAmJlxuICAgICAgbWF0Y2ggdXBwZXIgd2l0aFxuICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgIHwgU29tZSB1cHBlciAtPiBjb21wYXJlX2VsdCB2IHVwcGVyIDwgMFxuICAgIGluXG4gICAgbGV0IHJlYyBsb29wIGxvd2VyIHVwcGVyIGNvbXBhcmVfZWx0IHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTGVhZiB2IC0+IGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfZWx0IHZcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgaCwgbikgLT5cbiAgICAgICAgbGV0IGhsID0gaGVpZ2h0IGxcbiAgICAgICAgYW5kIGhyID0gaGVpZ2h0IHIgaW5cbiAgICAgICAgYWJzIChobCAtIGhyKSA8PSAyXG4gICAgICAgICYmIGggPSBtYXggaGwgaHIgKyAxXG4gICAgICAgICYmIG4gPSBsZW5ndGggbCArIGxlbmd0aCByICsgMVxuICAgICAgICAmJiBpbl9yYW5nZSBsb3dlciB1cHBlciBjb21wYXJlX2VsdCB2XG4gICAgICAgICYmIGxvb3AgbG93ZXIgKFNvbWUgdikgY29tcGFyZV9lbHQgbFxuICAgICAgICAmJiBsb29wIChTb21lIHYpIHVwcGVyIGNvbXBhcmVfZWx0IHJcbiAgICBpblxuICAgIGZ1biB0IH5jb21wYXJlX2VsdCAtPiBsb29wIE5vbmUgTm9uZSBjb21wYXJlX2VsdCB0XG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IHRydWVcbiAgICB8IExlYWYgXyB8IE5vZGUgXyAtPiBmYWxzZVxuICA7O1xuXG4gICgqIENyZWF0ZXMgYSBuZXcgbm9kZSB3aXRoIGxlZnQgc29uIGwsIHZhbHVlIHYgYW5kIHJpZ2h0IHNvbiByLlxuICAgICBXZSBtdXN0IGhhdmUgYWxsIGVsZW1lbnRzIG9mIGwgPCB2IDwgYWxsIGVsZW1lbnRzIG9mIHIuXG4gICAgIGwgYW5kIHIgbXVzdCBiZSBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi5cbiAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBoZWlnaHQgZm9yIGJldHRlciBzcGVlZC4gKilcblxuICBsZXQgY3JlYXRlIGwgdiByID1cbiAgICBsZXQgaGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IDBcbiAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgIHwgTm9kZSAoXywgXywgXywgaCwgXykgLT4gaFxuICAgIGluXG4gICAgbGV0IGhyID1cbiAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgfCBFbXB0eSAtPiAwXG4gICAgICB8IExlYWYgXyAtPiAxXG4gICAgICB8IE5vZGUgKF8sIF8sIF8sIGgsIF8pIC0+IGhcbiAgICBpblxuICAgIGxldCBoID0gaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEgaW5cbiAgICBpZiBoID0gMVxuICAgIHRoZW4gTGVhZiB2XG4gICAgZWxzZSAoXG4gICAgICBsZXQgc2wgPVxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiAwXG4gICAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgICAgfCBOb2RlIChfLCBfLCBfLCBfLCBzKSAtPiBzXG4gICAgICBpblxuICAgICAgbGV0IHNyID1cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgICB8IExlYWYgXyAtPiAxXG4gICAgICAgIHwgTm9kZSAoXywgXywgXywgXywgcykgLT4gc1xuICAgICAgaW5cbiAgICAgIE5vZGUgKGwsIHYsIHIsIGgsIHNsICsgc3IgKyAxKSlcbiAgOztcblxuICAoKiBXZSBtdXN0IGNhbGwgW2ZdIHdpdGggaW5jcmVhc2luZyBpbmRleGVzLCBiZWNhdXNlIHRoZSBiaW5fcHJvdCByZWFkZXIgaW5cbiAgICAgQ29yZS5TZXQgbmVlZHMgaXQuICopXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mID1cbiAgICBsZXQgcmVjIGxvb3AgbiB+ZiBpID1cbiAgICAgIG1hdGNoIG4gd2l0aFxuICAgICAgfCAwIC0+IEVtcHR5XG4gICAgICB8IDEgLT5cbiAgICAgICAgbGV0IGsgPSBmIGkgaW5cbiAgICAgICAgTGVhZiBrXG4gICAgICB8IDIgLT5cbiAgICAgICAgbGV0IGtsID0gZiBpIGluXG4gICAgICAgIGxldCBrID0gZiAoaSArIDEpIGluXG4gICAgICAgIGNyZWF0ZSAoTGVhZiBrbCkgayBFbXB0eVxuICAgICAgfCAzIC0+XG4gICAgICAgIGxldCBrbCA9IGYgaSBpblxuICAgICAgICBsZXQgayA9IGYgKGkgKyAxKSBpblxuICAgICAgICBsZXQga3IgPSBmIChpICsgMikgaW5cbiAgICAgICAgY3JlYXRlIChMZWFmIGtsKSBrIChMZWFmIGtyKVxuICAgICAgfCBuIC0+XG4gICAgICAgIGxldCBsZWZ0X2xlbmd0aCA9IG4gbHNyIDEgaW5cbiAgICAgICAgbGV0IHJpZ2h0X2xlbmd0aCA9IG4gLSBsZWZ0X2xlbmd0aCAtIDEgaW5cbiAgICAgICAgbGV0IGxlZnQgPSBsb29wIGxlZnRfbGVuZ3RoIH5mIGkgaW5cbiAgICAgICAgbGV0IGsgPSBmIChpICsgbGVmdF9sZW5ndGgpIGluXG4gICAgICAgIGxldCByaWdodCA9IGxvb3AgcmlnaHRfbGVuZ3RoIH5mIChpICsgbGVmdF9sZW5ndGggKyAxKSBpblxuICAgICAgICBjcmVhdGUgbGVmdCBrIHJpZ2h0XG4gICAgaW5cbiAgICBsb29wIGxlbiB+ZiAwXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgYXJyYXlfbGVuZ3RoID0gQXJyYXkubGVuZ3RoIGFycmF5IGluXG4gICAgbGV0IG5leHQgPVxuICAgICAgKCogV2UgZG9uJ3QgY2hlY2sgaWYgdGhlIGFycmF5IGlzIHNvcnRlZCBvciBrZXlzIGFyZSBkdXBsaWNhdGVkLCBiZWNhdXNlIHRoYXRcbiAgICAgICAgIGNoZWNraW5nIGlzIHNsb3dlciB0aGFuIHRoZSB3aG9sZSBbb2Zfc29ydGVkX2FycmF5XSBmdW5jdGlvbiAqKVxuICAgICAgaWYgYXJyYXlfbGVuZ3RoIDwgMiB8fCBjb21wYXJlX2VsdCBhcnJheS4oMCkgYXJyYXkuKDEpIDwgMFxuICAgICAgdGhlbiBmdW4gaSAtPiBhcnJheS4oaSlcbiAgICAgIGVsc2UgZnVuIGkgLT4gYXJyYXkuKGFycmF5X2xlbmd0aCAtIDEgLSBpKVxuICAgIGluXG4gICAgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbjphcnJheV9sZW5ndGggfmY6bmV4dFxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgYXJyYXkgfmNvbXBhcmVfZWx0ID1cbiAgICBtYXRjaCBhcnJheSB3aXRoXG4gICAgfCBbfHxdIHwgW3wgXyB8XSAtPiBSZXN1bHQuT2sgKG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfZWx0KVxuICAgIHwgXyAtPlxuICAgICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICAgIGxldCBpbmNyZWFzaW5nID1cbiAgICAgICAgICBtYXRjaCBjb21wYXJlX2VsdCBhcnJheS4oMCkgYXJyYXkuKDEpIHdpdGhcbiAgICAgICAgICB8IDAgLT4gci5yZXR1cm4gKE9yX2Vycm9yLmVycm9yX3N0cmluZyBcIm9mX3NvcnRlZF9hcnJheTogZHVwbGljYXRlZCBlbGVtZW50c1wiKVxuICAgICAgICAgIHwgaSAtPiBpIDwgMFxuICAgICAgICBpblxuICAgICAgICBmb3IgaSA9IDEgdG8gQXJyYXkubGVuZ3RoIGFycmF5IC0gMiBkb1xuICAgICAgICAgIG1hdGNoIGNvbXBhcmVfZWx0IGFycmF5LihpKSBhcnJheS4oaSArIDEpIHdpdGhcbiAgICAgICAgICB8IDAgLT4gci5yZXR1cm4gKE9yX2Vycm9yLmVycm9yX3N0cmluZyBcIm9mX3NvcnRlZF9hcnJheTogZHVwbGljYXRlZCBlbGVtZW50c1wiKVxuICAgICAgICAgIHwgaSAtPlxuICAgICAgICAgICAgaWYgUG9seS4oIDw+ICkgKGkgPCAwKSBpbmNyZWFzaW5nXG4gICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgIHIucmV0dXJuXG4gICAgICAgICAgICAgICAgKE9yX2Vycm9yLmVycm9yX3N0cmluZyBcIm9mX3NvcnRlZF9hcnJheTogZWxlbWVudHMgYXJlIG5vdCBvcmRlcmVkXCIpXG4gICAgICAgIGRvbmU7XG4gICAgICAgIFJlc3VsdC5PayAob2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9lbHQpKVxuICA7O1xuXG4gICgqIFNhbWUgYXMgY3JlYXRlLCBidXQgcGVyZm9ybXMgb25lIHN0ZXAgb2YgcmViYWxhbmNpbmcgaWYgbmVjZXNzYXJ5LlxuICAgICBBc3N1bWVzIGwgYW5kIHIgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDMuXG4gICAgIElubGluZSBleHBhbnNpb24gb2YgY3JlYXRlIGZvciBiZXR0ZXIgc3BlZWQgaW4gdGhlIG1vc3QgZnJlcXVlbnQgY2FzZVxuICAgICB3aGVyZSBubyByZWJhbGFuY2luZyBpcyByZXF1aXJlZC4gKilcblxuICBsZXQgYmFsIGwgdiByID1cbiAgICBsZXQgaGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IDBcbiAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgIHwgTm9kZSAoXywgXywgXywgaCwgXykgLT4gaFxuICAgIGluXG4gICAgbGV0IGhyID1cbiAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgfCBFbXB0eSAtPiAwXG4gICAgICB8IExlYWYgXyAtPiAxXG4gICAgICB8IE5vZGUgKF8sIF8sIF8sIGgsIF8pIC0+IGhcbiAgICBpblxuICAgIGlmIGhsID4gaHIgKyAyXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2UgKCogYmVjYXVzZSBoKGwpPmgocikrMiBhbmQgaChsZWFmKT0xICopXG4gICAgICB8IE5vZGUgKGxsLCBsdiwgbHIsIF8sIF8pIC0+XG4gICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHJcbiAgICAgICAgdGhlbiBjcmVhdGUgbGwgbHYgKGNyZWF0ZSBsciB2IHIpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIG1hdGNoIGxyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgTGVhZiBscnYgLT5cbiAgICAgICAgICAgIGFzc2VydCAoaXNfZW1wdHkgbGwpO1xuICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgRW1wdHkpIGxydiAoY3JlYXRlIEVtcHR5IHYgcilcbiAgICAgICAgICB8IE5vZGUgKGxybCwgbHJ2LCBscnIsIF8sIF8pIC0+IGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxybCkgbHJ2IChjcmVhdGUgbHJyIHYgcikpKVxuICAgIGVsc2UgaWYgaHIgPiBobCArIDJcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZSAoKiBiZWNhdXNlIGgocik+aChsKSsyIGFuZCBoKGxlYWYpPTEgKilcbiAgICAgIHwgTm9kZSAocmwsIHJ2LCByciwgXywgXykgLT5cbiAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybFxuICAgICAgICB0aGVuIGNyZWF0ZSAoY3JlYXRlIGwgdiBybCkgcnYgcnJcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggcmwgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBMZWFmIHJsdiAtPlxuICAgICAgICAgICAgYXNzZXJ0IChpc19lbXB0eSBycik7XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgRW1wdHkpIHJsdiAoY3JlYXRlIEVtcHR5IHJ2IHJyKVxuICAgICAgICAgIHwgTm9kZSAocmxsLCBybHYsIHJsciwgXywgXykgLT4gY3JlYXRlIChjcmVhdGUgbCB2IHJsbCkgcmx2IChjcmVhdGUgcmxyIHJ2IHJyKSkpXG4gICAgZWxzZSAoXG4gICAgICBsZXQgaCA9IGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxIGluXG4gICAgICBsZXQgc2wgPVxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiAwXG4gICAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgICAgfCBOb2RlIChfLCBfLCBfLCBfLCBzKSAtPiBzXG4gICAgICBpblxuICAgICAgbGV0IHNyID1cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgICB8IExlYWYgXyAtPiAxXG4gICAgICAgIHwgTm9kZSAoXywgXywgXywgXywgcykgLT4gc1xuICAgICAgaW5cbiAgICAgIGlmIGggPSAxIHRoZW4gTGVhZiB2IGVsc2UgTm9kZSAobCwgdiwgciwgaCwgc2wgKyBzciArIDEpKVxuICA7O1xuXG4gICgqIEluc2VydGlvbiBvZiBvbmUgZWxlbWVudCAqKVxuXG4gIGV4Y2VwdGlvbiBTYW1lXG5cbiAgbGV0IGFkZCB0IHggfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGF1eCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IExlYWYgeFxuICAgICAgfCBMZWFmIHYgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiByYWlzZSBTYW1lXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBjcmVhdGUgKExlYWYgeCkgdiBFbXB0eVxuICAgICAgICBlbHNlIGNyZWF0ZSBFbXB0eSB2IChMZWFmIHgpXG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gcmFpc2UgU2FtZSBlbHNlIGlmIGMgPCAwIHRoZW4gYmFsIChhdXggbCkgdiByIGVsc2UgYmFsIGwgdiAoYXV4IHIpXG4gICAgaW5cbiAgICB0cnkgYXV4IHQgd2l0aFxuICAgIHwgU2FtZSAtPiB0XG4gIDs7XG5cbiAgKCogU2FtZSBhcyBjcmVhdGUgYW5kIGJhbCwgYnV0IG5vIGFzc3VtcHRpb25zIGFyZSBtYWRlIG9uIHRoZSByZWxhdGl2ZSBoZWlnaHRzIG9mIGwgYW5kXG4gICAgIHIuICopXG4gIGxldCByZWMgam9pbiBsIHYgciB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIGwsIHIgd2l0aFxuICAgIHwgRW1wdHksIF8gLT4gYWRkIHIgdiB+Y29tcGFyZV9lbHRcbiAgICB8IF8sIEVtcHR5IC0+IGFkZCBsIHYgfmNvbXBhcmVfZWx0XG4gICAgfCBMZWFmIGx2LCBfIC0+IGFkZCAoYWRkIHIgdiB+Y29tcGFyZV9lbHQpIGx2IH5jb21wYXJlX2VsdFxuICAgIHwgXywgTGVhZiBydiAtPiBhZGQgKGFkZCBsIHYgfmNvbXBhcmVfZWx0KSBydiB+Y29tcGFyZV9lbHRcbiAgICB8IE5vZGUgKGxsLCBsdiwgbHIsIGxoLCBfKSwgTm9kZSAocmwsIHJ2LCByciwgcmgsIF8pIC0+XG4gICAgICBpZiBsaCA+IHJoICsgMlxuICAgICAgdGhlbiBiYWwgbGwgbHYgKGpvaW4gbHIgdiByIH5jb21wYXJlX2VsdClcbiAgICAgIGVsc2UgaWYgcmggPiBsaCArIDJcbiAgICAgIHRoZW4gYmFsIChqb2luIGwgdiBybCB+Y29tcGFyZV9lbHQpIHJ2IHJyXG4gICAgICBlbHNlIGNyZWF0ZSBsIHYgclxuICA7O1xuXG4gICgqIFNtYWxsZXN0IGFuZCBncmVhdGVzdCBlbGVtZW50IG9mIGEgc2V0ICopXG4gIGxldCByZWMgbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgfCBOb2RlIChFbXB0eSwgdiwgXywgXywgXykgLT4gU29tZSB2XG4gICAgfCBOb2RlIChsLCBfLCBfLCBfLCBfKSAtPiBtaW5fZWx0IGxcbiAgOztcblxuICBleGNlcHRpb24gU2V0X21pbl9lbHRfZXhuX29mX2VtcHR5X3NldCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxuICBsZXQgKCkgPVxuICAgIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZFxuICAgICAgWyVleHRlbnNpb25fY29uc3RydWN0b3IgU2V0X21pbl9lbHRfZXhuX29mX2VtcHR5X3NldF1cbiAgICAgIChmdW5jdGlvblxuICAgICAgICB8IFNldF9taW5fZWx0X2V4bl9vZl9lbXB0eV9zZXQgLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkF0b20gXCJzZXQubWwuVHJlZTAuU2V0X21pbl9lbHRfZXhuX29mX2VtcHR5X3NldFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBleGNlcHRpb24gU2V0X21heF9lbHRfZXhuX29mX2VtcHR5X3NldCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxuICBsZXQgKCkgPVxuICAgIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZFxuICAgICAgWyVleHRlbnNpb25fY29uc3RydWN0b3IgU2V0X21heF9lbHRfZXhuX29mX2VtcHR5X3NldF1cbiAgICAgIChmdW5jdGlvblxuICAgICAgICB8IFNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXQgLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkF0b20gXCJzZXQubWwuVHJlZTAuU2V0X21heF9lbHRfZXhuX29mX2VtcHR5X3NldFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgbWluX2VsdF9leG4gdCA9XG4gICAgbWF0Y2ggbWluX2VsdCB0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2UgU2V0X21pbl9lbHRfZXhuX29mX2VtcHR5X3NldFxuICAgIHwgU29tZSB2IC0+IHZcbiAgOztcblxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPVxuICAgIGxldCByZWMgZm9sZF91bnRpbF9oZWxwZXIgfmYgdCBhY2MgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLkNvbnRpbnVlIGFjY1xuICAgICAgfCBMZWFmIHZhbHVlIC0+IGYgYWNjIHZhbHVlXG4gICAgICB8IE5vZGUgKGxlZnQsIHZhbHVlLCByaWdodCwgXywgXykgLT5cbiAgICAgICAgKG1hdGNoIGZvbGRfdW50aWxfaGVscGVyIH5mIGxlZnQgYWNjIHdpdGhcbiAgICAgICAgIHwgU3RvcCBfYSBhcyB4IC0+IHhcbiAgICAgICAgIHwgQ29udGludWUgYWNjIC0+XG4gICAgICAgICAgIChtYXRjaCBmIGFjYyB2YWx1ZSB3aXRoXG4gICAgICAgICAgICB8IFN0b3AgX2EgYXMgeCAtPiB4XG4gICAgICAgICAgICB8IENvbnRpbnVlIGEgLT4gZm9sZF91bnRpbF9oZWxwZXIgfmYgcmlnaHQgYSkpXG4gICAgaW5cbiAgICBtYXRjaCBmb2xkX3VudGlsX2hlbHBlciB+ZiB0IGluaXQgd2l0aFxuICAgIHwgQ29udGludWUgeCAtPiBmaW5pc2ggeFxuICAgIHwgU3RvcCB4IC0+IHhcbiAgOztcblxuICBsZXQgcmVjIG1heF9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IHwgTm9kZSAoXywgdiwgRW1wdHksIF8sIF8pIC0+IFNvbWUgdlxuICAgIHwgTm9kZSAoXywgXywgciwgXywgXykgLT4gbWF4X2VsdCByXG4gIDs7XG5cbiAgbGV0IG1heF9lbHRfZXhuIHQgPVxuICAgIG1hdGNoIG1heF9lbHQgdCB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIFNldF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9zZXRcbiAgICB8IFNvbWUgdiAtPiB2XG4gIDs7XG5cbiAgKCogUmVtb3ZlIHRoZSBzbWFsbGVzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBzZXQgKilcblxuICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LnJlbW92ZV9taW5fZWx0XCJcbiAgICB8IExlYWYgXyAtPiBFbXB0eVxuICAgIHwgTm9kZSAoRW1wdHksIF8sIHIsIF8sIF8pIC0+IHJcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGJhbCAocmVtb3ZlX21pbl9lbHQgbCkgdiByXG4gIDs7XG5cbiAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgIEFzc3VtZSB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLiAqKVxuICBsZXQgbWVyZ2UgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBFbXB0eSwgdCAtPiB0XG4gICAgfCB0LCBFbXB0eSAtPiB0XG4gICAgfCBfLCBfIC0+IGJhbCB0MSAobWluX2VsdF9leG4gdDIpIChyZW1vdmVfbWluX2VsdCB0MilcbiAgOztcblxuICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS4gIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuICBsZXQgY29uY2F0IHQxIHQyIH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEVtcHR5LCB0IHwgdCwgRW1wdHkgLT4gdFxuICAgIHwgXywgXyAtPiBqb2luIHQxIChtaW5fZWx0X2V4biB0MikgKHJlbW92ZV9taW5fZWx0IHQyKSB+Y29tcGFyZV9lbHRcbiAgOztcblxuICBsZXQgc3BsaXQgdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBzcGxpdCB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBFbXB0eSwgTm9uZSwgRW1wdHlcbiAgICAgIHwgTGVhZiB2IC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gRW1wdHksIFNvbWUgdiwgRW1wdHlcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIEVtcHR5LCBOb25lLCBMZWFmIHZcbiAgICAgICAgZWxzZSBMZWFmIHYsIE5vbmUsIEVtcHR5XG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gbCwgU29tZSB2LCByXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGxsLCBtYXliZV9lbHQsIHJsID0gc3BsaXQgbCBpblxuICAgICAgICAgIGxsLCBtYXliZV9lbHQsIGpvaW4gcmwgdiByIH5jb21wYXJlX2VsdClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IGxyLCBtYXliZV9lbHQsIHJyID0gc3BsaXQgciBpblxuICAgICAgICAgIGpvaW4gbCB2IGxyIH5jb21wYXJlX2VsdCwgbWF5YmVfZWx0LCBycilcbiAgICBpblxuICAgIHNwbGl0IHRcbiAgOztcblxuICAoKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgc2V0IG9wZXJhdGlvbnMgKilcblxuICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gIGxldCByZWMgbWVtIHQgeCB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gZmFsc2VcbiAgICB8IExlYWYgdiAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgIGMgPSAwXG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgIGMgPSAwIHx8IG1lbSAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcikgeCB+Y29tcGFyZV9lbHRcbiAgOztcblxuICBsZXQgc2luZ2xldG9uIHggPSBMZWFmIHhcblxuICBsZXQgcmVtb3ZlIHQgeCB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgYXV4IHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIFNhbWVcbiAgICAgIHwgTGVhZiB2IC0+IGlmIGNvbXBhcmVfZWx0IHggdiA9IDAgdGhlbiBFbXB0eSBlbHNlIHJhaXNlIFNhbWVcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiBtZXJnZSBsIHIgZWxzZSBpZiBjIDwgMCB0aGVuIGJhbCAoYXV4IGwpIHYgciBlbHNlIGJhbCBsIHYgKGF1eCByKVxuICAgIGluXG4gICAgdHJ5IGF1eCB0IHdpdGhcbiAgICB8IFNhbWUgLT4gdFxuICA7O1xuXG4gIGxldCByZW1vdmVfaW5kZXggdCBpIH5jb21wYXJlX2VsdDpfID1cbiAgICBsZXQgcmVjIGF1eCB0IGkgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIFNhbWVcbiAgICAgIHwgTGVhZiBfIC0+IGlmIGkgPSAwIHRoZW4gRW1wdHkgZWxzZSByYWlzZSBTYW1lXG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgIGxldCBsX3NpemUgPSBsZW5ndGggbCBpblxuICAgICAgICBsZXQgYyA9IFBvbHkuY29tcGFyZSBpIGxfc2l6ZSBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIG1lcmdlIGwgclxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gYmFsIChhdXggbCBpKSB2IHJcbiAgICAgICAgZWxzZSBiYWwgbCB2IChhdXggciAoaSAtIGxfc2l6ZSAtIDEpKVxuICAgIGluXG4gICAgdHJ5IGF1eCB0IGkgd2l0aFxuICAgIHwgU2FtZSAtPiB0XG4gIDs7XG5cbiAgbGV0IHVuaW9uIHMxIHMyIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyB1bmlvbiBzMSBzMiA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHMxIHMyXG4gICAgICB0aGVuIHMxXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggczEsIHMyIHdpdGhcbiAgICAgICAgfCBFbXB0eSwgdCB8IHQsIEVtcHR5IC0+IHRcbiAgICAgICAgfCBMZWFmIHYxLCBfIC0+IHVuaW9uIChOb2RlIChFbXB0eSwgdjEsIEVtcHR5LCAxLCAxKSkgczJcbiAgICAgICAgfCBfLCBMZWFmIHYyIC0+IHVuaW9uIHMxIChOb2RlIChFbXB0eSwgdjIsIEVtcHR5LCAxLCAxKSlcbiAgICAgICAgfCBOb2RlIChsMSwgdjEsIHIxLCBoMSwgXyksIE5vZGUgKGwyLCB2MiwgcjIsIGgyLCBfKSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyXG4gICAgICAgICAgdGhlblxuICAgICAgICAgICAgaWYgaDIgPSAxXG4gICAgICAgICAgICB0aGVuIGFkZCBzMSB2MiB+Y29tcGFyZV9lbHRcbiAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICBsZXQgbDIsIF8sIHIyID0gc3BsaXQgczIgdjEgfmNvbXBhcmVfZWx0IGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MSAodW5pb24gcjEgcjIpIH5jb21wYXJlX2VsdClcbiAgICAgICAgICBlbHNlIGlmIGgxID0gMVxuICAgICAgICAgIHRoZW4gYWRkIHMyIHYxIH5jb21wYXJlX2VsdFxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IGwxLCBfLCByMSA9IHNwbGl0IHMxIHYyIH5jb21wYXJlX2VsdCBpblxuICAgICAgICAgICAgam9pbiAodW5pb24gbDEgbDIpIHYyICh1bmlvbiByMSByMikgfmNvbXBhcmVfZWx0KSlcbiAgICBpblxuICAgIHVuaW9uIHMxIHMyXG4gIDs7XG5cbiAgbGV0IHVuaW9uX2xpc3QgfmNvbXBhcmF0b3IgfnRvX3RyZWUgeHMgPVxuICAgIGxldCBjb21wYXJlX2VsdCA9IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGluXG4gICAgTGlzdC5mb2xkIHhzIH5pbml0OmVtcHR5IH5mOihmdW4gYWMgeCAtPiB1bmlvbiBhYyAodG9fdHJlZSB4KSB+Y29tcGFyZV9lbHQpXG4gIDs7XG5cbiAgbGV0IGludGVyIHMxIHMyIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBpbnRlciBzMSBzMiA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHMxIHMyXG4gICAgICB0aGVuIHMxXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggczEsIHMyIHdpdGhcbiAgICAgICAgfCBFbXB0eSwgXyB8IF8sIEVtcHR5IC0+IEVtcHR5XG4gICAgICAgIHwgKExlYWYgZWx0IGFzIHNpbmdsZXRvbiksIG90aGVyX3NldCB8IG90aGVyX3NldCwgKExlYWYgZWx0IGFzIHNpbmdsZXRvbikgLT5cbiAgICAgICAgICBpZiBtZW0gb3RoZXJfc2V0IGVsdCB+Y29tcGFyZV9lbHQgdGhlbiBzaW5nbGV0b24gZWxzZSBFbXB0eVxuICAgICAgICB8IE5vZGUgKGwxLCB2MSwgcjEsIF8sIF8pLCB0MiAtPlxuICAgICAgICAgIChtYXRjaCBzcGxpdCB0MiB2MSB+Y29tcGFyZV9lbHQgd2l0aFxuICAgICAgICAgICB8IGwyLCBOb25lLCByMiAtPiBjb25jYXQgKGludGVyIGwxIGwyKSAoaW50ZXIgcjEgcjIpIH5jb21wYXJlX2VsdFxuICAgICAgICAgICB8IGwyLCBTb21lIHYxLCByMiAtPiBqb2luIChpbnRlciBsMSBsMikgdjEgKGludGVyIHIxIHIyKSB+Y29tcGFyZV9lbHQpKVxuICAgIGluXG4gICAgaW50ZXIgczEgczJcbiAgOztcblxuICBsZXQgZGlmZiBzMSBzMiB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgZGlmZiBzMSBzMiA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHMxIHMyXG4gICAgICB0aGVuIEVtcHR5XG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggczEsIHMyIHdpdGhcbiAgICAgICAgfCBFbXB0eSwgXyAtPiBFbXB0eVxuICAgICAgICB8IHQxLCBFbXB0eSAtPiB0MVxuICAgICAgICB8IExlYWYgdjEsIHQyIC0+IGRpZmYgKE5vZGUgKEVtcHR5LCB2MSwgRW1wdHksIDEsIDEpKSB0MlxuICAgICAgICB8IE5vZGUgKGwxLCB2MSwgcjEsIF8sIF8pLCB0MiAtPlxuICAgICAgICAgIChtYXRjaCBzcGxpdCB0MiB2MSB+Y29tcGFyZV9lbHQgd2l0aFxuICAgICAgICAgICB8IGwyLCBOb25lLCByMiAtPiBqb2luIChkaWZmIGwxIGwyKSB2MSAoZGlmZiByMSByMikgfmNvbXBhcmVfZWx0XG4gICAgICAgICAgIHwgbDIsIFNvbWUgXywgcjIgLT4gY29uY2F0IChkaWZmIGwxIGwyKSAoZGlmZiByMSByMikgfmNvbXBhcmVfZWx0KSlcbiAgICBpblxuICAgIGRpZmYgczEgczJcbiAgOztcblxuICBtb2R1bGUgRW51bSA9IHN0cnVjdFxuICAgIHR5cGUgaW5jcmVhc2luZ1xuICAgIHR5cGUgZGVjcmVhc2luZ1xuXG4gICAgdHlwZSAoJ2EsICdkaXJlY3Rpb24pIHQgPVxuICAgICAgfCBFbmRcbiAgICAgIHwgTW9yZSBvZiAnYSAqICdhIHRyZWUgKiAoJ2EsICdkaXJlY3Rpb24pIHRcblxuICAgIGxldCByZWMgY29ucyBzIChlIDogKF8sIGluY3JlYXNpbmcpIHQpIDogKF8sIGluY3JlYXNpbmcpIHQgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGVcbiAgICAgIHwgTGVhZiB2IC0+IE1vcmUgKHYsIEVtcHR5LCBlKVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBjb25zIGwgKE1vcmUgKHYsIHIsIGUpKVxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGNvbnNfcmlnaHQgcyAoZSA6IChfLCBkZWNyZWFzaW5nKSB0KSA6IChfLCBkZWNyZWFzaW5nKSB0ID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICB8IExlYWYgdiAtPiBNb3JlICh2LCBFbXB0eSwgZSlcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gY29uc19yaWdodCByIChNb3JlICh2LCBsLCBlKSlcbiAgICA7O1xuXG4gICAgbGV0IG9mX3NldCBzIDogKF8sIGluY3JlYXNpbmcpIHQgPSBjb25zIHMgRW5kXG4gICAgbGV0IG9mX3NldF9yaWdodCBzIDogKF8sIGRlY3JlYXNpbmcpIHQgPSBjb25zX3JpZ2h0IHMgRW5kXG5cbiAgICBsZXQgc3RhcnRpbmdfYXRfaW5jcmVhc2luZyB0IGtleSBjb21wYXJlIDogKF8sIGluY3JlYXNpbmcpIHQgPVxuICAgICAgbGV0IHJlYyBsb29wIHQgZSA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGVcbiAgICAgICAgfCBMZWFmIHYgLT4gbG9vcCAoTm9kZSAoRW1wdHksIHYsIEVtcHR5LCAxLCAxKSkgZVxuICAgICAgICB8IE5vZGUgKF8sIHYsIHIsIF8sIF8pIHdoZW4gY29tcGFyZSB2IGtleSA8IDAgLT4gbG9vcCByIGVcbiAgICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBsb29wIGwgKE1vcmUgKHYsIHIsIGUpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdCBFbmRcbiAgICA7O1xuXG4gICAgbGV0IHN0YXJ0aW5nX2F0X2RlY3JlYXNpbmcgdCBrZXkgY29tcGFyZSA6IChfLCBkZWNyZWFzaW5nKSB0ID1cbiAgICAgIGxldCByZWMgbG9vcCB0IGUgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICAgIHwgTGVhZiB2IC0+IGxvb3AgKE5vZGUgKEVtcHR5LCB2LCBFbXB0eSwgMSwgMSkpIGVcbiAgICAgICAgfCBOb2RlIChsLCB2LCBfLCBfLCBfKSB3aGVuIGNvbXBhcmUgdiBrZXkgPiAwIC0+IGxvb3AgbCBlXG4gICAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gbG9vcCByIChNb3JlICh2LCBsLCBlKSlcbiAgICAgIGluXG4gICAgICBsb29wIHQgRW5kXG4gICAgOztcblxuICAgIGxldCBjb21wYXJlIGNvbXBhcmVfZWx0IGUxIGUyID1cbiAgICAgIGxldCByZWMgbG9vcCBlMSBlMiA9XG4gICAgICAgIG1hdGNoIGUxLCBlMiB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gMFxuICAgICAgICB8IEVuZCwgXyAtPiAtMVxuICAgICAgICB8IF8sIEVuZCAtPiAxXG4gICAgICAgIHwgTW9yZSAodjEsIHIxLCBlMSksIE1vcmUgKHYyLCByMiwgZTIpIC0+XG4gICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB2MSB2MiBpblxuICAgICAgICAgIGlmIGMgPD4gMFxuICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgIGVsc2UgaWYgcGh5c19lcXVhbCByMSByMlxuICAgICAgICAgIHRoZW4gbG9vcCBlMSBlMlxuICAgICAgICAgIGVsc2UgbG9vcCAoY29ucyByMSBlMSkgKGNvbnMgcjIgZTIpXG4gICAgICBpblxuICAgICAgbG9vcCBlMSBlMlxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGl0ZXIgfmYgPSBmdW5jdGlvblxuICAgICAgfCBFbmQgLT4gKClcbiAgICAgIHwgTW9yZSAoYSwgdHJlZSwgZW51bSkgLT5cbiAgICAgICAgZiBhO1xuICAgICAgICBpdGVyIChjb25zIHRyZWUgZW51bSkgfmZcbiAgICA7O1xuXG4gICAgbGV0IGl0ZXIyIGNvbXBhcmVfZWx0IHQxIHQyIH5mID1cbiAgICAgIGxldCByZWMgbG9vcCB0MSB0MiA9XG4gICAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gKClcbiAgICAgICAgfCBFbmQsIF8gLT4gaXRlciB0MiB+ZjooZnVuIGEgLT4gZiAoYFJpZ2h0IGEpKVxuICAgICAgICB8IF8sIEVuZCAtPiBpdGVyIHQxIH5mOihmdW4gYSAtPiBmIChgTGVmdCBhKSlcbiAgICAgICAgfCBNb3JlIChhMSwgdHJlZTEsIGVudW0xKSwgTW9yZSAoYTIsIHRyZWUyLCBlbnVtMikgLT5cbiAgICAgICAgICBsZXQgY29tcGFyZV9yZXN1bHQgPSBjb21wYXJlX2VsdCBhMSBhMiBpblxuICAgICAgICAgIGlmIGNvbXBhcmVfcmVzdWx0ID0gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgZiAoYEJvdGggKGExLCBhMikpO1xuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgKGNvbnMgdHJlZTIgZW51bTIpKVxuICAgICAgICAgIGVsc2UgaWYgY29tcGFyZV9yZXN1bHQgPCAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBmIChgTGVmdCBhMSk7XG4gICAgICAgICAgICBsb29wIChjb25zIHRyZWUxIGVudW0xKSB0MilcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGYgKGBSaWdodCBhMik7XG4gICAgICAgICAgICBsb29wIHQxIChjb25zIHRyZWUyIGVudW0yKSlcbiAgICAgIGluXG4gICAgICBsb29wIHQxIHQyXG4gICAgOztcblxuICAgIGxldCBzeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9lbHQgPVxuICAgICAgbGV0IHN0ZXAgc3RhdGUgOiAoKF8sIF8pIEVpdGhlci50LCBfKSBTZXF1ZW5jZS5TdGVwLnQgPVxuICAgICAgICBtYXRjaCBzdGF0ZSB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gRG9uZVxuICAgICAgICB8IEVuZCwgTW9yZSAoZWx0LCB0cmVlLCBlbnVtKSAtPiBZaWVsZCAoU2Vjb25kIGVsdCwgKEVuZCwgY29ucyB0cmVlIGVudW0pKVxuICAgICAgICB8IE1vcmUgKGVsdCwgdHJlZSwgZW51bSksIEVuZCAtPiBZaWVsZCAoRmlyc3QgZWx0LCAoY29ucyB0cmVlIGVudW0sIEVuZCkpXG4gICAgICAgIHwgKE1vcmUgKGExLCB0cmVlMSwgZW51bTEpIGFzIGxlZnQpLCAoTW9yZSAoYTIsIHRyZWUyLCBlbnVtMikgYXMgcmlnaHQpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9lbHQgYTEgYTIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBuZXh0X3N0YXRlID1cbiAgICAgICAgICAgICAgaWYgcGh5c19lcXVhbCB0cmVlMSB0cmVlMlxuICAgICAgICAgICAgICB0aGVuIGVudW0xLCBlbnVtMlxuICAgICAgICAgICAgICBlbHNlIGNvbnMgdHJlZTEgZW51bTEsIGNvbnMgdHJlZTIgZW51bTJcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBTa2lwIG5leHRfc3RhdGUpXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuIFlpZWxkIChGaXJzdCBhMSwgKGNvbnMgdHJlZTEgZW51bTEsIHJpZ2h0KSlcbiAgICAgICAgICBlbHNlIFlpZWxkIChTZWNvbmQgYTIsIChsZWZ0LCBjb25zIHRyZWUyIGVudW0yKSlcbiAgICAgIGluXG4gICAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdDoob2Zfc2V0IHQxLCBvZl9zZXQgdDIpIH5mOnN0ZXBcbiAgICA7O1xuICBlbmRcblxuICBsZXQgdG9fc2VxdWVuY2VfaW5jcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2VsdCB0ID1cbiAgICBsZXQgbmV4dCBlbnVtID1cbiAgICAgIG1hdGNoIGVudW0gd2l0aFxuICAgICAgfCBFbnVtLkVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgIHwgRW51bS5Nb3JlIChrLCB0LCBlKSAtPiBTZXF1ZW5jZS5TdGVwLllpZWxkIChrLCBFbnVtLmNvbnMgdCBlKVxuICAgIGluXG4gICAgbGV0IGluaXQgPVxuICAgICAgbWF0Y2ggZnJvbV9lbHQgd2l0aFxuICAgICAgfCBOb25lIC0+IEVudW0ub2Zfc2V0IHRcbiAgICAgIHwgU29tZSBrZXkgLT4gRW51bS5zdGFydGluZ19hdF9pbmNyZWFzaW5nIHQga2V5IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlX2RlY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9lbHQgdCA9XG4gICAgbGV0IG5leHQgZW51bSA9XG4gICAgICBtYXRjaCBlbnVtIHdpdGhcbiAgICAgIHwgRW51bS5FbmQgLT4gU2VxdWVuY2UuU3RlcC5Eb25lXG4gICAgICB8IEVudW0uTW9yZSAoaywgdCwgZSkgLT4gU2VxdWVuY2UuU3RlcC5ZaWVsZCAoaywgRW51bS5jb25zX3JpZ2h0IHQgZSlcbiAgICBpblxuICAgIGxldCBpbml0ID1cbiAgICAgIG1hdGNoIGZyb21fZWx0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBFbnVtLm9mX3NldF9yaWdodCB0XG4gICAgICB8IFNvbWUga2V5IC0+IEVudW0uc3RhcnRpbmdfYXRfZGVjcmVhc2luZyB0IGtleSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQgfmY6bmV4dFxuICA7O1xuXG4gIGxldCB0b19zZXF1ZW5jZVxuICAgICAgICBjb21wYXJhdG9yXG4gICAgICAgID8ob3JkZXIgPSBgSW5jcmVhc2luZylcbiAgICAgICAgP2dyZWF0ZXJfb3JfZXF1YWxfdG9cbiAgICAgICAgP2xlc3Nfb3JfZXF1YWxfdG9cbiAgICAgICAgdFxuICAgID1cbiAgICBsZXQgaW5jbHVzaXZlX2JvdW5kIHNpZGUgdCBib3VuZCA9XG4gICAgICBsZXQgY29tcGFyZV9lbHQgPSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBpblxuICAgICAgbGV0IGwsIG1heWJlLCByID0gc3BsaXQgdCBib3VuZCB+Y29tcGFyZV9lbHQgaW5cbiAgICAgIGxldCB0ID0gc2lkZSAobCwgcikgaW5cbiAgICAgIG1hdGNoIG1heWJlIHdpdGhcbiAgICAgIHwgTm9uZSAtPiB0XG4gICAgICB8IFNvbWUgZWx0IC0+IGFkZCB0IGVsdCB+Y29tcGFyZV9lbHRcbiAgICBpblxuICAgIG1hdGNoIG9yZGVyIHdpdGhcbiAgICB8IGBJbmNyZWFzaW5nIC0+XG4gICAgICBsZXQgdCA9IE9wdGlvbi5mb2xkIGxlc3Nfb3JfZXF1YWxfdG8gfmluaXQ6dCB+ZjooaW5jbHVzaXZlX2JvdW5kIGZzdCkgaW5cbiAgICAgIHRvX3NlcXVlbmNlX2luY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9lbHQ6Z3JlYXRlcl9vcl9lcXVhbF90byB0XG4gICAgfCBgRGVjcmVhc2luZyAtPlxuICAgICAgbGV0IHQgPSBPcHRpb24uZm9sZCBncmVhdGVyX29yX2VxdWFsX3RvIH5pbml0OnQgfmY6KGluY2x1c2l2ZV9ib3VuZCBzbmQpIGluXG4gICAgICB0b19zZXF1ZW5jZV9kZWNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fZWx0Omxlc3Nfb3JfZXF1YWxfdG8gdFxuICA7O1xuXG5cbiAgbGV0IHJlYyBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgLT4gaWYgZiB2IHRoZW4gU29tZSB2IGVsc2UgTm9uZVxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgIGlmIGYgdlxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyBsIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFNvbWUgdlxuICAgICAgICB8IFNvbWUgXyBhcyB4IC0+IHgpXG4gICAgICBlbHNlIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyByIH5mXG4gIDs7XG5cbiAgbGV0IHJlYyBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiAtPiBpZiBmIHYgdGhlbiBTb21lIHYgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgaWYgZiB2XG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggZmluZF9sYXN0X3NhdGlzZnlpbmcgciB+ZiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBTb21lIHZcbiAgICAgICAgfCBTb21lIF8gYXMgeCAtPiB4KVxuICAgICAgZWxzZSBmaW5kX2xhc3Rfc2F0aXNmeWluZyBsIH5mXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdiA9XG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAtPiBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA8IDApXG4gICAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gLT4gZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPD0gMClcbiAgICB8IGBGaXJzdF9lcXVhbF90byAtPlxuICAgICAgKG1hdGNoIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA+PSAwKSB3aXRoXG4gICAgICAgfCBTb21lIHggYXMgZWx0IHdoZW4gY29tcGFyZSB4IHYgPSAwIC0+IGVsdFxuICAgICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICAgIHwgYExhc3RfZXF1YWxfdG8gLT5cbiAgICAgIChtYXRjaCBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA8PSAwKSB3aXRoXG4gICAgICAgfCBTb21lIHggYXMgZWx0IHdoZW4gY29tcGFyZSB4IHYgPSAwIC0+IGVsdFxuICAgICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICAgIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAtPlxuICAgICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID49IDApXG4gICAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuIC0+XG4gICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPiAwKVxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgbGV0IGlzX2xlZnQgeCA9XG4gICAgICBtYXRjaCBzZWdtZW50X29mIHggd2l0aFxuICAgICAgfCBgTGVmdCAtPiB0cnVlXG4gICAgICB8IGBSaWdodCAtPiBmYWxzZVxuICAgIGluXG4gICAgbGV0IGlzX3JpZ2h0IHggPSBub3QgKGlzX2xlZnQgeCkgaW5cbiAgICBtYXRjaCBob3cgd2l0aFxuICAgIHwgYExhc3Rfb25fbGVmdCAtPiBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOmlzX2xlZnRcbiAgICB8IGBGaXJzdF9vbl9yaWdodCAtPiBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Zjppc19yaWdodFxuICA7O1xuXG4gIGxldCBtZXJnZV90b19zZXF1ZW5jZVxuICAgICAgICBjb21wYXJhdG9yXG4gICAgICAgID8ob3JkZXIgPSBgSW5jcmVhc2luZylcbiAgICAgICAgP2dyZWF0ZXJfb3JfZXF1YWxfdG9cbiAgICAgICAgP2xlc3Nfb3JfZXF1YWxfdG9cbiAgICAgICAgdFxuICAgICAgICB0J1xuICAgID1cbiAgICBTZXF1ZW5jZS5tZXJnZV93aXRoX2R1cGxpY2F0ZXNcbiAgICAgICh0b19zZXF1ZW5jZSBjb21wYXJhdG9yIH5vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0KVxuICAgICAgKHRvX3NlcXVlbmNlIGNvbXBhcmF0b3Igfm9yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQnKVxuICAgICAgfmNvbXBhcmU6XG4gICAgICAgIChtYXRjaCBvcmRlciB3aXRoXG4gICAgICAgICB8IGBJbmNyZWFzaW5nIC0+IGNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgICAgfCBgRGVjcmVhc2luZyAtPiBGbi5mbGlwIGNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgY29tcGFyZSBjb21wYXJlX2VsdCBzMSBzMiA9XG4gICAgRW51bS5jb21wYXJlIGNvbXBhcmVfZWx0IChFbnVtLm9mX3NldCBzMSkgKEVudW0ub2Zfc2V0IHMyKVxuICA7O1xuXG4gIGxldCBpdGVyMiBzMSBzMiB+Y29tcGFyZV9lbHQgPSBFbnVtLml0ZXIyIGNvbXBhcmVfZWx0IChFbnVtLm9mX3NldCBzMSkgKEVudW0ub2Zfc2V0IHMyKVxuICBsZXQgZXF1YWwgczEgczIgfmNvbXBhcmVfZWx0ID0gY29tcGFyZSBjb21wYXJlX2VsdCBzMSBzMiA9IDBcblxuICBsZXQgaXNfc3Vic2V0IHMxIH5vZl86czIgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGlzX3N1YnNldCBzMSB+b2ZfOnMyID1cbiAgICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgICB8IEVtcHR5LCBfIC0+IHRydWVcbiAgICAgIHwgXywgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTGVhZiB2MSwgdDIgLT4gbWVtIHQyIHYxIH5jb21wYXJlX2VsdFxuICAgICAgfCBOb2RlIChsMSwgdjEsIHIxLCBfLCBfKSwgTGVhZiB2MiAtPlxuICAgICAgICAobWF0Y2ggbDEsIHIxIHdpdGhcbiAgICAgICAgIHwgRW1wdHksIEVtcHR5IC0+XG4gICAgICAgICAgICgqIFRoaXMgY2FzZSBzaG91bGRuJ3Qgb2NjdXIgaW4gcHJhY3RpY2UgYmVjYXVzZSB3ZSBzaG91bGQgaGF2ZSBjb25zdHJ1Y3RlZFxuICAgICAgICAgICAgICBhIExlYWYgcmF0aGVyIHRoYW4gYSBOb2RlIHdpdGggdHdvIEVtcHR5IHN1YnRyZWVzICopXG4gICAgICAgICAgIGNvbXBhcmVfZWx0IHYxIHYyID0gMFxuICAgICAgICAgfCBfLCBfIC0+IGZhbHNlKVxuICAgICAgfCBOb2RlIChsMSwgdjEsIHIxLCBfLCBfKSwgKE5vZGUgKGwyLCB2MiwgcjIsIF8sIF8pIGFzIHQyKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHYxIHYyIGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBwaHlzX2VxdWFsIHMxIHMyIHx8IChpc19zdWJzZXQgbDEgfm9mXzpsMiAmJiBpc19zdWJzZXQgcjEgfm9mXzpyMilcbiAgICAgICAgICAoKiBOb3RlIHRoYXQgaGVpZ2h0IGFuZCBzaXplIGRvbid0IG1hdHRlciBoZXJlLiAqKVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gaXNfc3Vic2V0IChOb2RlIChsMSwgdjEsIEVtcHR5LCAwLCAwKSkgfm9mXzpsMiAmJiBpc19zdWJzZXQgcjEgfm9mXzp0MlxuICAgICAgICBlbHNlIGlzX3N1YnNldCAoTm9kZSAoRW1wdHksIHYxLCByMSwgMCwgMCkpIH5vZl86cjIgJiYgaXNfc3Vic2V0IGwxIH5vZl86dDJcbiAgICBpblxuICAgIGlzX3N1YnNldCBzMSB+b2ZfOnMyXG4gIDs7XG5cbiAgbGV0IHJlYyBhcmVfZGlzam9pbnQgczEgczIgfmNvbXBhcmVfZWx0ID1cbiAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgIHwgRW1wdHksIF8gfCBfLCBFbXB0eSAtPiB0cnVlXG4gICAgfCBMZWFmIGVsdCwgb3RoZXJfc2V0IHwgb3RoZXJfc2V0LCBMZWFmIGVsdCAtPiBub3QgKG1lbSBvdGhlcl9zZXQgZWx0IH5jb21wYXJlX2VsdClcbiAgICB8IE5vZGUgKGwxLCB2MSwgcjEsIF8sIF8pLCB0MiAtPlxuICAgICAgaWYgcGh5c19lcXVhbCBzMSBzMlxuICAgICAgdGhlbiBmYWxzZVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHNwbGl0IHQyIHYxIH5jb21wYXJlX2VsdCB3aXRoXG4gICAgICAgIHwgbDIsIE5vbmUsIHIyIC0+XG4gICAgICAgICAgYXJlX2Rpc2pvaW50IGwxIGwyIH5jb21wYXJlX2VsdCAmJiBhcmVfZGlzam9pbnQgcjEgcjIgfmNvbXBhcmVfZWx0XG4gICAgICAgIHwgXywgU29tZSBfLCBfIC0+IGZhbHNlKVxuICA7O1xuXG4gIGxldCBpdGVyIHQgfmYgPVxuICAgIGxldCByZWMgaXRlciA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICB8IExlYWYgdiAtPiBmIHZcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgaXRlciBsO1xuICAgICAgICBmIHY7XG4gICAgICAgIGl0ZXIgclxuICAgIGluXG4gICAgaXRlciB0XG4gIDs7XG5cbiAgbGV0IHN5bW1ldHJpY19kaWZmID0gRW51bS5zeW1tZXRyaWNfZGlmZlxuXG4gIGxldCByZWMgZm9sZCBzIH5pbml0OmFjY3UgfmYgPVxuICAgIG1hdGNoIHMgd2l0aFxuICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgIHwgTGVhZiB2IC0+IGYgYWNjdSB2XG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBmb2xkIH5mIHIgfmluaXQ6KGYgKGZvbGQgfmYgbCB+aW5pdDphY2N1KSB2KVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfdF9pZ25vcmluZ19zdHJ1Y3R1cmUgaGFzaF9mb2xkX2VsZW0gc3RhdGUgdCA9XG4gICAgZm9sZCB0IH5pbml0OihoYXNoX2ZvbGRfaW50IHN0YXRlIChsZW5ndGggdCkpIH5mOmhhc2hfZm9sZF9lbGVtXG4gIDs7XG5cbiAgbGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxuICBsZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG5cbiAgbGV0IHJlYyBmb2xkX3JpZ2h0IHMgfmluaXQ6YWNjdSB+ZiA9XG4gICAgbWF0Y2ggcyB3aXRoXG4gICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgfCBMZWFmIHYgLT4gZiB2IGFjY3VcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGZvbGRfcmlnaHQgfmYgbCB+aW5pdDooZiB2IChmb2xkX3JpZ2h0IH5mIHIgfmluaXQ6YWNjdSkpXG4gIDs7XG5cbiAgbGV0IHJlYyBmb3JfYWxsIHQgfmY6cCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiB0cnVlXG4gICAgfCBMZWFmIHYgLT4gcCB2XG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBwIHYgJiYgZm9yX2FsbCB+ZjpwIGwgJiYgZm9yX2FsbCB+ZjpwIHJcbiAgOztcblxuICBsZXQgcmVjIGV4aXN0cyB0IH5mOnAgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gZmFsc2VcbiAgICB8IExlYWYgdiAtPiBwIHZcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IHAgdiB8fCBleGlzdHMgfmY6cCBsIHx8IGV4aXN0cyB+ZjpwIHJcbiAgOztcblxuICBsZXQgZmlsdGVyIHMgfmY6cCB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgZmlsdCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBMZWFmIHYgLT4gaWYgcCB2IHRoZW4gYWRkIGFjY3UgdiB+Y29tcGFyZV9lbHQgZWxzZSBhY2N1XG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgIGZpbHQgKGZpbHQgKGlmIHAgdiB0aGVuIGFkZCBhY2N1IHYgfmNvbXBhcmVfZWx0IGVsc2UgYWNjdSkgbCkgclxuICAgIGluXG4gICAgZmlsdCBFbXB0eSBzXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXAgcyB+ZjpwIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBmaWx0IGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IExlYWYgdiAtPlxuICAgICAgICAobWF0Y2ggcCB2IHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPiBhY2N1XG4gICAgICAgICB8IFNvbWUgdiAtPiBhZGQgYWNjdSB2IH5jb21wYXJlX2VsdClcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgZmlsdFxuICAgICAgICAgIChmaWx0XG4gICAgICAgICAgICAgKG1hdGNoIHAgdiB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBhY2N1XG4gICAgICAgICAgICAgIHwgU29tZSB2IC0+IGFkZCBhY2N1IHYgfmNvbXBhcmVfZWx0KVxuICAgICAgICAgICAgIGwpXG4gICAgICAgICAgclxuICAgIGluXG4gICAgZmlsdCBFbXB0eSBzXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl90ZiBzIH5mOnAgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIHBhcnQgKCh0LCBmKSBhcyBhY2N1KSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTGVhZiB2IC0+IGlmIHAgdiB0aGVuIGFkZCB0IHYgfmNvbXBhcmVfZWx0LCBmIGVsc2UgdCwgYWRkIGYgdiB+Y29tcGFyZV9lbHRcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgcGFydCAocGFydCAoaWYgcCB2IHRoZW4gYWRkIHQgdiB+Y29tcGFyZV9lbHQsIGYgZWxzZSB0LCBhZGQgZiB2IH5jb21wYXJlX2VsdCkgbCkgclxuICAgIGluXG4gICAgcGFydCAoRW1wdHksIEVtcHR5KSBzXG4gIDs7XG5cbiAgbGV0IHJlYyBlbGVtZW50c19hdXggYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgfCBMZWFmIHYgLT4gdiA6OiBhY2N1XG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBlbGVtZW50c19hdXggKHYgOjogZWxlbWVudHNfYXV4IGFjY3UgcikgbFxuICA7O1xuXG4gIGxldCBlbGVtZW50cyBzID0gZWxlbWVudHNfYXV4IFtdIHNcblxuICBsZXQgY2hvb3NlIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IC0+IFNvbWUgdlxuICAgIHwgTm9kZSAoXywgdiwgXywgXywgXykgLT4gU29tZSB2XG4gIDs7XG5cbiAgbGV0IGNob29zZV9leG4gPVxuICAgIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIlNldC5jaG9vc2VfZXhuOiBlbXB0eSBzZXRcIikgaW5cbiAgICBsZXQgY2hvb3NlX2V4biB0ID1cbiAgICAgIG1hdGNoIGNob29zZSB0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICAgIHwgU29tZSB2IC0+IHZcbiAgICBpblxuICAgICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgICBjaG9vc2VfZXhuXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3QgbHN0IH5jb21wYXJlX2VsdCA9XG4gICAgTGlzdC5mb2xkIGxzdCB+aW5pdDplbXB0eSB+ZjooZnVuIHQgeCAtPiBhZGQgdCB4IH5jb21wYXJlX2VsdClcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2Ugc2VxdWVuY2UgfmNvbXBhcmVfZWx0ID1cbiAgICBTZXF1ZW5jZS5mb2xkIHNlcXVlbmNlIH5pbml0OmVtcHR5IH5mOihmdW4gdCB4IC0+IGFkZCB0IHggfmNvbXBhcmVfZWx0KVxuICA7O1xuXG4gIGxldCB0b19saXN0IHMgPSBlbGVtZW50cyBzXG5cbiAgbGV0IG9mX2FycmF5IGEgfmNvbXBhcmVfZWx0ID1cbiAgICBBcnJheS5mb2xkIGEgfmluaXQ6ZW1wdHkgfmY6KGZ1biB0IHggLT4gYWRkIHQgeCB+Y29tcGFyZV9lbHQpXG4gIDs7XG5cbiAgKCogZmFzdGVyIGJ1dCBlcXVpdmFsZW50IHRvIFtBcnJheS5vZl9saXN0ICh0b19saXN0IHQpXSAqKVxuICBsZXQgdG9fYXJyYXkgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gW3x8XVxuICAgIHwgTGVhZiB2IC0+IFt8IHYgfF1cbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIHMpIC0+XG4gICAgICBsZXQgcmVzID0gQXJyYXkuY3JlYXRlIH5sZW46cyB2IGluXG4gICAgICBsZXQgcG9zX3JlZiA9IHJlZiAwIGluXG4gICAgICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgICAgICAoKiBJbnZhcmlhbnQ6IG9uIGVudHJ5IGFuZCBvbiBleGl0IHRvIFtsb29wXSwgIXBvc19yZWYgaXMgdGhlIG5leHRcbiAgICAgICAgICAgYXZhaWxhYmxlIGNlbGwgaW4gdGhlIGFycmF5LiAqKVxuICAgICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICAgIHwgTGVhZiB2IC0+XG4gICAgICAgICAgcmVzLighcG9zX3JlZikgPC0gdjtcbiAgICAgICAgICBpbmNyIHBvc19yZWZcbiAgICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICAgIGxvb3AgbDtcbiAgICAgICAgICByZXMuKCFwb3NfcmVmKSA8LSB2O1xuICAgICAgICAgIGluY3IgcG9zX3JlZjtcbiAgICAgICAgICBsb29wIHJcbiAgICAgIGluXG4gICAgICBsb29wIGw7XG4gICAgICAoKiByZXMuKCFwb3NfcmVmKSBpcyBhbHJlYWR5IGluaXRpYWxpemVkIChieSBBcnJheS5jcmVhdGUgfmxlbjphYm92ZSkuICopXG4gICAgICBpbmNyIHBvc19yZWY7XG4gICAgICBsb29wIHI7XG4gICAgICByZXNcbiAgOztcblxuICBsZXQgbWFwIHQgfmYgfmNvbXBhcmVfZWx0ID0gZm9sZCB0IH5pbml0OmVtcHR5IH5mOihmdW4gdCB4IC0+IGFkZCB0IChmIHgpIH5jb21wYXJlX2VsdClcblxuICBsZXQgZ3JvdXBfYnkgc2V0IH5lcXVpdiB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgbG9vcCBzZXQgZXF1aXZfY2xhc3NlcyA9XG4gICAgICBpZiBpc19lbXB0eSBzZXRcbiAgICAgIHRoZW4gZXF1aXZfY2xhc3Nlc1xuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCB4ID0gY2hvb3NlX2V4biBzZXQgaW5cbiAgICAgICAgbGV0IGVxdWl2X3gsIG5vdF9lcXVpdl94ID1cbiAgICAgICAgICBwYXJ0aXRpb25fdGYgc2V0IH5mOihmdW4gZWx0IC0+IHBoeXNfZXF1YWwgeCBlbHQgfHwgZXF1aXYgeCBlbHQpIH5jb21wYXJlX2VsdFxuICAgICAgICBpblxuICAgICAgICBsb29wIG5vdF9lcXVpdl94IChlcXVpdl94IDo6IGVxdWl2X2NsYXNzZXMpKVxuICAgIGluXG4gICAgbG9vcCBzZXQgW11cbiAgOztcblxuICBsZXQgcmVjIGZpbmQgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgLT4gaWYgZiB2IHRoZW4gU29tZSB2IGVsc2UgTm9uZVxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgIGlmIGYgdlxuICAgICAgdGhlbiBTb21lIHZcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBmaW5kIGwgfmYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gZmluZCByIH5mXG4gICAgICAgIHwgU29tZSBfIGFzIHIgLT4gcilcbiAgOztcblxuICBsZXQgcmVjIGZpbmRfbWFwIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IC0+IGYgdlxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgIChtYXRjaCBmIHYgd2l0aFxuICAgICAgIHwgU29tZSBfIGFzIHIgLT4gclxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgKG1hdGNoIGZpbmRfbWFwIGwgfmYgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBmaW5kX21hcCByIH5mXG4gICAgICAgICAgfCBTb21lIF8gYXMgciAtPiByKSlcbiAgOztcblxuICBsZXQgZmluZF9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZCB0IH5mIHdpdGhcbiAgICB8IE5vbmUgLT4gZmFpbHdpdGggXCJTZXQuZmluZF9leG4gZmFpbGVkIHRvIGZpbmQgYSBtYXRjaGluZyBlbGVtZW50XCJcbiAgICB8IFNvbWUgZSAtPiBlXG4gIDs7XG5cbiAgbGV0IHJlYyBudGggdCBpID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiAtPiBpZiBpID0gMCB0aGVuIFNvbWUgdiBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIHMpIC0+XG4gICAgICBpZiBpID49IHNcbiAgICAgIHRoZW4gTm9uZVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBsX3NpemUgPSBsZW5ndGggbCBpblxuICAgICAgICBsZXQgYyA9IFBvbHkuY29tcGFyZSBpIGxfc2l6ZSBpblxuICAgICAgICBpZiBjIDwgMCB0aGVuIG50aCBsIGkgZWxzZSBpZiBjID0gMCB0aGVuIFNvbWUgdiBlbHNlIG50aCByIChpIC0gbF9zaXplIC0gMSkpXG4gIDs7XG5cbiAgbGV0IHN0YWJsZV9kZWR1cF9saXN0IHhzIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBsb29wIHhzIGxlZnRvdmVycyBhbHJlYWR5X3NlZW4gPVxuICAgICAgbWF0Y2ggeHMgd2l0aFxuICAgICAgfCBbXSAtPiBMaXN0LnJldiBsZWZ0b3ZlcnNcbiAgICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgaWYgbWVtIGFscmVhZHlfc2VlbiBoZCB+Y29tcGFyZV9lbHRcbiAgICAgICAgdGhlbiBsb29wIHRsIGxlZnRvdmVycyBhbHJlYWR5X3NlZW5cbiAgICAgICAgZWxzZSBsb29wIHRsIChoZCA6OiBsZWZ0b3ZlcnMpIChhZGQgYWxyZWFkeV9zZWVuIGhkIH5jb21wYXJlX2VsdClcbiAgICBpblxuICAgIGxvb3AgeHMgW10gZW1wdHlcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCBhX29mX3NleHAgc2V4cCB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIHNleHAgd2l0aFxuICAgIHwgU2V4cC5MaXN0IGxzdCAtPlxuICAgICAgbGV0IGVsdF9sc3QgPSBMaXN0Lm1hcCBsc3QgfmY6YV9vZl9zZXhwIGluXG4gICAgICBsZXQgc2V0ID0gb2ZfbGlzdCBlbHRfbHN0IH5jb21wYXJlX2VsdCBpblxuICAgICAgaWYgbGVuZ3RoIHNldCA9IExpc3QubGVuZ3RoIGxzdFxuICAgICAgdGhlbiBzZXRcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgc2V0ID0gcmVmIGVtcHR5IGluXG4gICAgICAgIExpc3QuaXRlcjJfZXhuIGxzdCBlbHRfbHN0IH5mOihmdW4gZWxfc2V4cCBlbCAtPlxuICAgICAgICAgIGlmIG1lbSAhc2V0IGVsIH5jb21wYXJlX2VsdFxuICAgICAgICAgIHRoZW4gb2Zfc2V4cF9lcnJvciBcIlNldC50X29mX3NleHA6IGR1cGxpY2F0ZSBlbGVtZW50IGluIHNldFwiIGVsX3NleHBcbiAgICAgICAgICBlbHNlIHNldCA6PSBhZGQgIXNldCBlbCB+Y29tcGFyZV9lbHQpO1xuICAgICAgICBhc3NlcnQgZmFsc2UpXG4gICAgfCBzZXhwIC0+IG9mX3NleHBfZXJyb3IgXCJTZXQudF9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID1cbiAgICBTZXhwLkxpc3QgKGZvbGRfcmlnaHQgdCB+aW5pdDpbXSB+ZjooZnVuIGVsIGFjYyAtPiBzZXhwX29mX2EgZWwgOjogYWNjKSlcbiAgOztcblxuICBtb2R1bGUgTmFtZWQgPSBzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdjbXApIHQgPVxuICAgICAgeyB0cmVlIDogJ2EgdFxuICAgICAgOyBuYW1lIDogc3RyaW5nXG4gICAgICB9XG5cbiAgICBsZXQgaXNfc3Vic2V0IChzdWJzZXQgOiBfIHQpIH5vZl86KHN1cGVyc2V0IDogXyB0KSB+c2V4cF9vZl9lbHQgfmNvbXBhcmVfZWx0ID1cbiAgICAgIGxldCBpbnZhbGlkX2VsZW1lbnRzID0gZGlmZiBzdWJzZXQudHJlZSBzdXBlcnNldC50cmVlIH5jb21wYXJlX2VsdCBpblxuICAgICAgaWYgaXNfZW1wdHkgaW52YWxpZF9lbGVtZW50c1xuICAgICAgdGhlbiBPayAoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBpbnZhbGlkX2VsZW1lbnRzX3NleHAgPSBzZXhwX29mX3Qgc2V4cF9vZl9lbHQgaW52YWxpZF9lbGVtZW50cyBpblxuICAgICAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICAgIChzdWJzZXQubmFtZSBeIFwiIGlzIG5vdCBhIHN1YnNldCBvZiBcIiBeIHN1cGVyc2V0Lm5hbWUpXG4gICAgICAgICAgICAgWyBcImludmFsaWRfZWxlbWVudHNcIiwgaW52YWxpZF9lbGVtZW50c19zZXhwIF0pKVxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgczEgczIgfnNleHBfb2ZfZWx0IH5jb21wYXJlX2VsdCA9XG4gICAgICBPcl9lcnJvci5jb21iaW5lX2Vycm9yc191bml0XG4gICAgICAgIFsgaXNfc3Vic2V0IHMxIH5vZl86czIgfnNleHBfb2ZfZWx0IH5jb21wYXJlX2VsdFxuICAgICAgICA7IGlzX3N1YnNldCBzMiB+b2ZfOnMxIH5zZXhwX29mX2VsdCB+Y29tcGFyZV9lbHRcbiAgICAgICAgXVxuICAgIDs7XG4gIGVuZFxuZW5kXG5cbnR5cGUgKCdhLCAnY29tcGFyYXRvcikgdCA9XG4gIHsgKCogW2NvbXBhcmF0b3JdIGlzIHRoZSBmaXJzdCBmaWVsZCBzbyB0aGF0IHBvbHltb3JwaGljIGVxdWFsaXR5IGZhaWxzIG9uIGEgbWFwIGR1ZVxuICAgICAgIHRvIHRoZSBmdW5jdGlvbmFsIHZhbHVlIGluIHRoZSBjb21wYXJhdG9yLlxuICAgICAgIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGFmZmVjdCBwb2x5bW9ycGhpYyBbY29tcGFyZV06IHRoYXQgc3RpbGwgcHJvZHVjZXNcbiAgICAgICBub25zZW5zZS4gKilcbiAgICBjb21wYXJhdG9yIDogKCdhLCAnY29tcGFyYXRvcikgQ29tcGFyYXRvci50XG4gIDsgdHJlZSA6ICdhIFRyZWUwLnRcbiAgfVxuXG50eXBlICgnYSwgJ2NvbXBhcmF0b3IpIHRyZWUgPSAnYSBUcmVlMC50XG5cbmxldCBsaWtlIHsgdHJlZSA9IF87IGNvbXBhcmF0b3IgfSB0cmVlID0geyB0cmVlOyBjb21wYXJhdG9yIH1cbmxldCBjb21wYXJlX2VsdCB0ID0gdC5jb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuXG5tb2R1bGUgQWNjZXNzb3JzID0gc3RydWN0XG4gIGxldCBjb21wYXJhdG9yIHQgPSB0LmNvbXBhcmF0b3JcbiAgbGV0IGludmFyaWFudHMgdCA9IFRyZWUwLmludmFyaWFudHMgdC50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdClcbiAgbGV0IGxlbmd0aCB0ID0gVHJlZTAubGVuZ3RoIHQudHJlZVxuICBsZXQgaXNfZW1wdHkgdCA9IFRyZWUwLmlzX2VtcHR5IHQudHJlZVxuICBsZXQgZWxlbWVudHMgdCA9IFRyZWUwLmVsZW1lbnRzIHQudHJlZVxuICBsZXQgbWluX2VsdCB0ID0gVHJlZTAubWluX2VsdCB0LnRyZWVcbiAgbGV0IG1pbl9lbHRfZXhuIHQgPSBUcmVlMC5taW5fZWx0X2V4biB0LnRyZWVcbiAgbGV0IG1heF9lbHQgdCA9IFRyZWUwLm1heF9lbHQgdC50cmVlXG4gIGxldCBtYXhfZWx0X2V4biB0ID0gVHJlZTAubWF4X2VsdF9leG4gdC50cmVlXG4gIGxldCBjaG9vc2UgdCA9IFRyZWUwLmNob29zZSB0LnRyZWVcbiAgbGV0IGNob29zZV9leG4gdCA9IFRyZWUwLmNob29zZV9leG4gdC50cmVlXG4gIGxldCB0b19saXN0IHQgPSBUcmVlMC50b19saXN0IHQudHJlZVxuICBsZXQgdG9fYXJyYXkgdCA9IFRyZWUwLnRvX2FycmF5IHQudHJlZVxuICBsZXQgZm9sZCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZCB0LnRyZWUgfmluaXQgfmZcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfdW50aWwgdC50cmVlIH5pbml0IH5mXG4gIGxldCBmb2xkX3JpZ2h0IHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3JpZ2h0IHQudHJlZSB+aW5pdCB+ZlxuICBsZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG4gIGxldCBpdGVyIHQgfmYgPSBUcmVlMC5pdGVyIHQudHJlZSB+ZlxuICBsZXQgaXRlcjIgYSBiIH5mID0gVHJlZTAuaXRlcjIgYS50cmVlIGIudHJlZSB+ZiB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IGEpXG4gIGxldCBleGlzdHMgdCB+ZiA9IFRyZWUwLmV4aXN0cyB0LnRyZWUgfmZcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IFRyZWUwLmZvcl9hbGwgdC50cmVlIH5mXG4gIGxldCBjb3VudCB0IH5mID0gVHJlZTAuY291bnQgdC50cmVlIH5mXG4gIGxldCBzdW0gbSB0IH5mID0gVHJlZTAuc3VtIG0gdC50cmVlIH5mXG4gIGxldCBmaW5kIHQgfmYgPSBUcmVlMC5maW5kIHQudHJlZSB+ZlxuICBsZXQgZmluZF9leG4gdCB+ZiA9IFRyZWUwLmZpbmRfZXhuIHQudHJlZSB+ZlxuICBsZXQgZmluZF9tYXAgdCB+ZiA9IFRyZWUwLmZpbmRfbWFwIHQudHJlZSB+ZlxuICBsZXQgbWVtIHQgYSA9IFRyZWUwLm1lbSB0LnRyZWUgYSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpXG4gIGxldCBmaWx0ZXIgdCB+ZiA9IGxpa2UgdCAoVHJlZTAuZmlsdGVyIHQudHJlZSB+ZiB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpKVxuICBsZXQgYWRkIHQgYSA9IGxpa2UgdCAoVHJlZTAuYWRkIHQudHJlZSBhIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkpXG4gIGxldCByZW1vdmUgdCBhID0gbGlrZSB0IChUcmVlMC5yZW1vdmUgdC50cmVlIGEgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSlcbiAgbGV0IHVuaW9uIHQxIHQyID0gbGlrZSB0MSAoVHJlZTAudW5pb24gdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpKVxuICBsZXQgaW50ZXIgdDEgdDIgPSBsaWtlIHQxIChUcmVlMC5pbnRlciB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSkpXG4gIGxldCBkaWZmIHQxIHQyID0gbGlrZSB0MSAoVHJlZTAuZGlmZiB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSkpXG5cbiAgbGV0IHN5bW1ldHJpY19kaWZmIHQxIHQyID1cbiAgICBUcmVlMC5zeW1tZXRyaWNfZGlmZiB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSlcbiAgOztcblxuICBsZXQgY29tcGFyZV9kaXJlY3QgdDEgdDIgPSBUcmVlMC5jb21wYXJlIChjb21wYXJlX2VsdCB0MSkgdDEudHJlZSB0Mi50cmVlXG4gIGxldCBlcXVhbCB0MSB0MiA9IFRyZWUwLmVxdWFsIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKVxuICBsZXQgaXNfc3Vic2V0IHQgfm9mXyA9IFRyZWUwLmlzX3N1YnNldCB0LnRyZWUgfm9mXzpvZl8udHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpXG5cbiAgbGV0IGFyZV9kaXNqb2ludCB0MSB0MiA9XG4gICAgVHJlZTAuYXJlX2Rpc2pvaW50IHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKVxuICA7O1xuXG4gIG1vZHVsZSBOYW1lZCA9IHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2NtcCkgdCA9XG4gICAgICB7IHNldCA6ICgnYSwgJ2NtcCkgdFxuICAgICAgOyBuYW1lIDogc3RyaW5nXG4gICAgICB9XG5cbiAgICBsZXQgdG9fbmFtZWRfdHJlZSB7IHNldDsgbmFtZSB9ID0geyBUcmVlMC5OYW1lZC50cmVlID0gc2V0LnRyZWU7IG5hbWUgfVxuXG4gICAgbGV0IGlzX3N1YnNldCAoc3Vic2V0IDogKF8sIF8pIHQpIH5vZl86KHN1cGVyc2V0IDogKF8sIF8pIHQpID1cbiAgICAgIFRyZWUwLk5hbWVkLmlzX3N1YnNldFxuICAgICAgICAodG9fbmFtZWRfdHJlZSBzdWJzZXQpXG4gICAgICAgIH5vZl86KHRvX25hbWVkX3RyZWUgc3VwZXJzZXQpXG4gICAgICAgIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgc3Vic2V0LnNldClcbiAgICAgICAgfnNleHBfb2ZfZWx0OnN1YnNldC5zZXQuY29tcGFyYXRvci5zZXhwX29mX3RcbiAgICA7O1xuXG4gICAgbGV0IGVxdWFsIHQxIHQyID1cbiAgICAgIE9yX2Vycm9yLmNvbWJpbmVfZXJyb3JzX3VuaXQgWyBpc19zdWJzZXQgdDEgfm9mXzp0MjsgaXNfc3Vic2V0IHQyIH5vZl86dDEgXVxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9XG4gICAgbGV0IHRyZWVfdCwgdHJlZV9mID0gVHJlZTAucGFydGl0aW9uX3RmIHQudHJlZSB+ZiB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpIGluXG4gICAgbGlrZSB0IHRyZWVfdCwgbGlrZSB0IHRyZWVfZlxuICA7O1xuXG4gIGxldCBzcGxpdCB0IGEgPVxuICAgIGxldCB0cmVlMSwgYiwgdHJlZTIgPSBUcmVlMC5zcGxpdCB0LnRyZWUgYSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpIGluXG4gICAgbGlrZSB0IHRyZWUxLCBiLCBsaWtlIHQgdHJlZTJcbiAgOztcblxuICBsZXQgZ3JvdXBfYnkgdCB+ZXF1aXYgPVxuICAgIExpc3QubWFwIChUcmVlMC5ncm91cF9ieSB0LnRyZWUgfmVxdWl2IH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkpIH5mOihsaWtlIHQpXG4gIDs7XG5cbiAgbGV0IG50aCB0IGkgPSBUcmVlMC5udGggdC50cmVlIGlcbiAgbGV0IHJlbW92ZV9pbmRleCB0IGkgPSBsaWtlIHQgKFRyZWUwLnJlbW92ZV9pbmRleCB0LnRyZWUgaSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpKVxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSBfIHQgPSBUcmVlMC5zZXhwX29mX3Qgc2V4cF9vZl9hIHQudHJlZVxuXG4gIGxldCB0b19zZXF1ZW5jZSA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCA9XG4gICAgVHJlZTAudG9fc2VxdWVuY2UgdC5jb21wYXJhdG9yID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0LnRyZWVcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2ID0gVHJlZTAuYmluYXJ5X3NlYXJjaCB0LnRyZWUgfmNvbXBhcmUgaG93IHZcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIFRyZWUwLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQudHJlZSB+c2VnbWVudF9vZiBob3dcbiAgOztcblxuICBsZXQgbWVyZ2VfdG9fc2VxdWVuY2UgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQgdCcgPVxuICAgIFRyZWUwLm1lcmdlX3RvX3NlcXVlbmNlXG4gICAgICB0LmNvbXBhcmF0b3JcbiAgICAgID9vcmRlclxuICAgICAgP2dyZWF0ZXJfb3JfZXF1YWxfdG9cbiAgICAgID9sZXNzX29yX2VxdWFsX3RvXG4gICAgICB0LnRyZWVcbiAgICAgIHQnLnRyZWVcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX2RpcmVjdCBoYXNoX2ZvbGRfa2V5IHN0YXRlIHQgPVxuICAgIFRyZWUwLmhhc2hfZm9sZF90X2lnbm9yaW5nX3N0cnVjdHVyZSBoYXNoX2ZvbGRfa2V5IHN0YXRlIHQudHJlZVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgQWNjZXNzb3JzXG5cbmxldCBjb21wYXJlIF8gXyB0MSB0MiA9IGNvbXBhcmVfZGlyZWN0IHQxIHQyXG5cbm1vZHVsZSBUcmVlID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnY29tcGFyYXRvcikgdCA9ICgnYSwgJ2NvbXBhcmF0b3IpIHRyZWVcblxuICBsZXQgY2UgY29tcGFyYXRvciA9IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG5cbiAgbGV0IHRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmF0b3IgYV9vZl9zZXhwIHNleHAgPVxuICAgIFRyZWUwLnRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKSBhX29mX3NleHAgc2V4cFxuICA7O1xuXG4gIGxldCBlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uID0gVHJlZTAuZW1wdHlcbiAgbGV0IGVtcHR5IH5jb21wYXJhdG9yOl8gPSBlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uXG4gIGxldCBzaW5nbGV0b24gfmNvbXBhcmF0b3I6XyBlID0gVHJlZTAuc2luZ2xldG9uIGVcbiAgbGV0IGxlbmd0aCB0ID0gVHJlZTAubGVuZ3RoIHRcbiAgbGV0IGludmFyaWFudHMgfmNvbXBhcmF0b3IgdCA9IFRyZWUwLmludmFyaWFudHMgdCB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBpc19lbXB0eSB0ID0gVHJlZTAuaXNfZW1wdHkgdFxuICBsZXQgZWxlbWVudHMgdCA9IFRyZWUwLmVsZW1lbnRzIHRcbiAgbGV0IG1pbl9lbHQgdCA9IFRyZWUwLm1pbl9lbHQgdFxuICBsZXQgbWluX2VsdF9leG4gdCA9IFRyZWUwLm1pbl9lbHRfZXhuIHRcbiAgbGV0IG1heF9lbHQgdCA9IFRyZWUwLm1heF9lbHQgdFxuICBsZXQgbWF4X2VsdF9leG4gdCA9IFRyZWUwLm1heF9lbHRfZXhuIHRcbiAgbGV0IGNob29zZSB0ID0gVHJlZTAuY2hvb3NlIHRcbiAgbGV0IGNob29zZV9leG4gdCA9IFRyZWUwLmNob29zZV9leG4gdFxuICBsZXQgdG9fbGlzdCB0ID0gVHJlZTAudG9fbGlzdCB0XG4gIGxldCB0b19hcnJheSB0ID0gVHJlZTAudG9fYXJyYXkgdFxuICBsZXQgaXRlciB0IH5mID0gVHJlZTAuaXRlciB0IH5mXG4gIGxldCBleGlzdHMgdCB+ZiA9IFRyZWUwLmV4aXN0cyB0IH5mXG4gIGxldCBmb3JfYWxsIHQgfmYgPSBUcmVlMC5mb3JfYWxsIHQgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBUcmVlMC5jb3VudCB0IH5mXG4gIGxldCBzdW0gbSB0IH5mID0gVHJlZTAuc3VtIG0gdCB+ZlxuICBsZXQgZmluZCB0IH5mID0gVHJlZTAuZmluZCB0IH5mXG4gIGxldCBmaW5kX2V4biB0IH5mID0gVHJlZTAuZmluZF9leG4gdCB+ZlxuICBsZXQgZmluZF9tYXAgdCB+ZiA9IFRyZWUwLmZpbmRfbWFwIHQgfmZcbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGQgdCB+aW5pdCB+ZlxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF91bnRpbCB0IH5pbml0IH5mXG4gIGxldCBmb2xkX3JpZ2h0IHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3JpZ2h0IHQgfmluaXQgfmZcbiAgbGV0IG1hcCB+Y29tcGFyYXRvciB0IH5mID0gVHJlZTAubWFwIHQgfmYgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgZmlsdGVyIH5jb21wYXJhdG9yIHQgfmYgPSBUcmVlMC5maWx0ZXIgdCB+ZiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBmaWx0ZXJfbWFwIH5jb21wYXJhdG9yIHQgfmYgPSBUcmVlMC5maWx0ZXJfbWFwIHQgfmYgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgcGFydGl0aW9uX3RmIH5jb21wYXJhdG9yIHQgfmYgPSBUcmVlMC5wYXJ0aXRpb25fdGYgdCB+ZiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBpdGVyMiB+Y29tcGFyYXRvciBhIGIgfmYgPSBUcmVlMC5pdGVyMiBhIGIgfmYgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgbWVtIH5jb21wYXJhdG9yIHQgYSA9IFRyZWUwLm1lbSB0IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgYWRkIH5jb21wYXJhdG9yIHQgYSA9IFRyZWUwLmFkZCB0IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgcmVtb3ZlIH5jb21wYXJhdG9yIHQgYSA9IFRyZWUwLnJlbW92ZSB0IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgdW5pb24gfmNvbXBhcmF0b3IgdDEgdDIgPSBUcmVlMC51bmlvbiB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBpbnRlciB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLmludGVyIHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGRpZmYgfmNvbXBhcmF0b3IgdDEgdDIgPSBUcmVlMC5kaWZmIHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgfmNvbXBhcmF0b3IgdDEgdDIgPVxuICAgIFRyZWUwLnN5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgY29tcGFyZV9kaXJlY3QgfmNvbXBhcmF0b3IgdDEgdDIgPSBUcmVlMC5jb21wYXJlIChjZSBjb21wYXJhdG9yKSB0MSB0MlxuICBsZXQgZXF1YWwgfmNvbXBhcmF0b3IgdDEgdDIgPSBUcmVlMC5lcXVhbCB0MSB0MiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBpc19zdWJzZXQgfmNvbXBhcmF0b3IgdCB+b2ZfID0gVHJlZTAuaXNfc3Vic2V0IHQgfm9mXyB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG5cbiAgbGV0IGFyZV9kaXNqb2ludCB+Y29tcGFyYXRvciB0MSB0MiA9XG4gICAgVHJlZTAuYXJlX2Rpc2pvaW50IHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgb2ZfbGlzdCB+Y29tcGFyYXRvciBsID0gVHJlZTAub2ZfbGlzdCBsIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IG9mX3NlcXVlbmNlIH5jb21wYXJhdG9yIHMgPSBUcmVlMC5vZl9zZXF1ZW5jZSBzIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IG9mX2FycmF5IH5jb21wYXJhdG9yIGEgPSBUcmVlMC5vZl9hcnJheSBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhID1cbiAgICBUcmVlMC5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvcjpfIH5sZW4gfmYgPVxuICAgIFRyZWUwLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmZcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGEgPSBUcmVlMC5vZl9zb3J0ZWRfYXJyYXkgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCB1bmlvbl9saXN0IH5jb21wYXJhdG9yIGwgPSBUcmVlMC51bmlvbl9saXN0IGwgfnRvX3RyZWU6Rm4uaWQgfmNvbXBhcmF0b3JcblxuICBsZXQgc3RhYmxlX2RlZHVwX2xpc3QgfmNvbXBhcmF0b3IgeHMgPVxuICAgIFRyZWUwLnN0YWJsZV9kZWR1cF9saXN0IHhzIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgZ3JvdXBfYnkgfmNvbXBhcmF0b3IgdCB+ZXF1aXYgPSBUcmVlMC5ncm91cF9ieSB0IH5lcXVpdiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBzcGxpdCB+Y29tcGFyYXRvciB0IGEgPSBUcmVlMC5zcGxpdCB0IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgbnRoIHQgaSA9IFRyZWUwLm50aCB0IGlcbiAgbGV0IHJlbW92ZV9pbmRleCB+Y29tcGFyYXRvciB0IGkgPSBUcmVlMC5yZW1vdmVfaW5kZXggdCBpIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgXyB0ID0gVHJlZTAuc2V4cF9vZl90IHNleHBfb2ZfYSB0XG4gIGxldCB0b190cmVlIHQgPSB0XG4gIGxldCBvZl90cmVlIH5jb21wYXJhdG9yOl8gdCA9IHRcblxuICBsZXQgdG9fc2VxdWVuY2UgfmNvbXBhcmF0b3IgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQgPVxuICAgIFRyZWUwLnRvX3NlcXVlbmNlIGNvbXBhcmF0b3IgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHRcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB+Y29tcGFyYXRvcjpfIHQgfmNvbXBhcmUgaG93IHYgPSBUcmVlMC5iaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHZcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgfmNvbXBhcmF0b3I6XyB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgVHJlZTAuYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiBob3dcbiAgOztcblxuICBsZXQgbWVyZ2VfdG9fc2VxdWVuY2UgfmNvbXBhcmF0b3IgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQgdCcgPVxuICAgIFRyZWUwLm1lcmdlX3RvX3NlcXVlbmNlIGNvbXBhcmF0b3IgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQgdCdcbiAgOztcblxuICBsZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5cbiAgbW9kdWxlIE5hbWVkID0gc3RydWN0XG4gICAgaW5jbHVkZSBUcmVlMC5OYW1lZFxuXG4gICAgbGV0IGlzX3N1YnNldCB+Y29tcGFyYXRvciB0MSB+b2ZfOnQyID1cbiAgICAgIFRyZWUwLk5hbWVkLmlzX3N1YnNldFxuICAgICAgICB0MVxuICAgICAgICB+b2ZfOnQyXG4gICAgICAgIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgICAgICAgfnNleHBfb2ZfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3RcbiAgICA7O1xuXG4gICAgbGV0IGVxdWFsIH5jb21wYXJhdG9yIHQxIHQyID1cbiAgICAgIFRyZWUwLk5hbWVkLmVxdWFsXG4gICAgICAgIHQxXG4gICAgICAgIHQyXG4gICAgICAgIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgICAgICAgfnNleHBfb2ZfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3RcbiAgICA7O1xuICBlbmRcbmVuZFxuXG5tb2R1bGUgVXNpbmdfY29tcGFyYXRvciA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2VsdCwgJ2NtcCkgdCA9ICgnZWx0LCAnY21wKSB0XG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgdG9fdHJlZSB0ID0gdC50cmVlXG4gIGxldCBvZl90cmVlIH5jb21wYXJhdG9yIHRyZWUgPSB7IGNvbXBhcmF0b3I7IHRyZWUgfVxuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yIGFfb2Zfc2V4cCBzZXhwID1cbiAgICBvZl90cmVlXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLnRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuY29tcGFyZSBhX29mX3NleHAgc2V4cClcbiAgOztcblxuICBsZXQgZW1wdHkgfmNvbXBhcmF0b3IgPSB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5lbXB0eSB9XG5cbiAgbW9kdWxlIEVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gKEVsdCA6IENvbXBhcmF0b3IuUzEpID0gc3RydWN0XG4gICAgbGV0IGVtcHR5ID0geyBjb21wYXJhdG9yID0gRWx0LmNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5lbXB0eSB9XG4gIGVuZFxuXG4gIGxldCBzaW5nbGV0b24gfmNvbXBhcmF0b3IgZSA9IHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLnNpbmdsZXRvbiBlIH1cblxuICBsZXQgdW5pb25fbGlzdCB+Y29tcGFyYXRvciBsID1cbiAgICBvZl90cmVlIH5jb21wYXJhdG9yIChUcmVlMC51bmlvbl9saXN0IH5jb21wYXJhdG9yIH50b190cmVlIGwpXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIGxldCB0cmVlID1cbiAgICAgIFRyZWUwLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICB7IGNvbXBhcmF0b3I7IHRyZWUgfVxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvciB+bGVuIH5mID1cbiAgICBvZl90cmVlIH5jb21wYXJhdG9yIChUcmVlMC5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mKVxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIE9yX2Vycm9yLk1vbmFkX2luZml4LihcbiAgICAgIFRyZWUwLm9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgID4+fCBmdW4gdHJlZSAtPiB7IGNvbXBhcmF0b3I7IHRyZWUgfSlcbiAgOztcblxuICBsZXQgb2ZfbGlzdCB+Y29tcGFyYXRvciBsID1cbiAgICB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5vZl9saXN0IGwgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH1cbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3IgcyA9XG4gICAgeyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAub2Zfc2VxdWVuY2UgcyB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfVxuICA7O1xuXG4gIGxldCBvZl9hcnJheSB+Y29tcGFyYXRvciBhID1cbiAgICB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5vZl9hcnJheSBhIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB9XG4gIDs7XG5cbiAgbGV0IHN0YWJsZV9kZWR1cF9saXN0IH5jb21wYXJhdG9yIHhzID1cbiAgICBUcmVlMC5zdGFibGVfZGVkdXBfbGlzdCB4cyB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgbWFwIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLm1hcCB0LnRyZWUgfmYgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH1cbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCB+Y29tcGFyYXRvciB0IH5mID1cbiAgICB7IGNvbXBhcmF0b3JcbiAgICA7IHRyZWUgPSBUcmVlMC5maWx0ZXJfbWFwIHQudHJlZSB+ZiB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICB9XG4gIDs7XG5cbiAgbW9kdWxlIFRyZWUgPSBUcmVlXG5lbmRcblxudHlwZSAoJ2VsdCwgJ2NtcCkgY29tcGFyYXRvciA9XG4gIChtb2R1bGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0ID0gJ2VsdCBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSAnY21wKVxuXG5sZXQgY29tcGFyYXRvcl9zICh0eXBlIGsgY21wKSB0IDogKGssIGNtcCkgY29tcGFyYXRvciA9XG4gIChtb2R1bGUgc3RydWN0XG4gICAgdHlwZSB0ID0ga1xuICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wXG5cbiAgICBsZXQgY29tcGFyYXRvciA9IHQuY29tcGFyYXRvclxuICBlbmQpXG47O1xuXG5sZXQgdG9fY29tcGFyYXRvciAodHlwZSBlbHQgY21wKSAoKG1vZHVsZSBNKSA6IChlbHQsIGNtcCkgY29tcGFyYXRvcikgPSBNLmNvbXBhcmF0b3JcbmxldCBlbXB0eSBtID0gVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKVxubGV0IHNpbmdsZXRvbiBtIGEgPSBVc2luZ19jb21wYXJhdG9yLnNpbmdsZXRvbiB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgdW5pb25fbGlzdCBtIGEgPSBVc2luZ19jb21wYXJhdG9yLnVuaW9uX2xpc3QgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuXG5sZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBtIGEgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuOztcblxubGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIG0gfmxlbiB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgfmxlbiB+ZlxuOztcblxubGV0IG9mX3NvcnRlZF9hcnJheSBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2ZfbGlzdCBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2xpc3QgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IG9mX3NlcXVlbmNlIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IG9mX2FycmF5IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYXJyYXkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuXG5sZXQgc3RhYmxlX2RlZHVwX2xpc3QgbSBhID1cbiAgVXNpbmdfY29tcGFyYXRvci5zdGFibGVfZGVkdXBfbGlzdCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG47O1xuXG5sZXQgbWFwIG0gYSB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IubWFwIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGEgfmZcbmxldCBmaWx0ZXJfbWFwIG0gYSB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IuZmlsdGVyX21hcCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhIH5mXG5cbm1vZHVsZSBNIChFbHQgOiBzaWdcbiAgICB0eXBlIHRcbiAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuICBlbmQpID1cbnN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gKEVsdC50LCBFbHQuY29tcGFyYXRvcl93aXRuZXNzKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU2V4cF9vZl9tID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIE1fb2Zfc2V4cCA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIG9mX3NleHBdXG5cbiAgdmFsIHRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0XG5cbiAgW0BAQGVuZF1cblxuICBpbmNsdWRlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA6PSB0XG5lbmRcblxubW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX2dyYW1tYXJdXG5cbiAgdmFsIHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgQ29tcGFyZV9tID0gc2lnIGVuZFxubW9kdWxlIHR5cGUgRXF1YWxfbSA9IHNpZyBlbmRcbm1vZHVsZSB0eXBlIEhhc2hfZm9sZF9tID0gSGFzaGVyLlNcblxubGV0IHNleHBfb2ZfbV9fdCAodHlwZSBlbHQpIChtb2R1bGUgRWx0IDogU2V4cF9vZl9tIHdpdGggdHlwZSB0ID0gZWx0KSB0ID1cbiAgc2V4cF9vZl90IEVsdC5zZXhwX29mX3QgKGZ1biBfIC0+IFNleHAuQXRvbSBcIl9cIikgdFxuOztcblxubGV0IG1fX3Rfb2Zfc2V4cFxuICAgICAgKHR5cGUgZWx0IGNtcClcbiAgICAgIChtb2R1bGUgRWx0IDogTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gZWx0IGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGNtcClcbiAgICAgIHNleHBcbiAgPVxuICBVc2luZ19jb21wYXJhdG9yLnRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmF0b3I6RWx0LmNvbXBhcmF0b3IgRWx0LnRfb2Zfc2V4cCBzZXhwXG47O1xuXG5sZXQgbV9fdF9zZXhwX2dyYW1tYXIgKHR5cGUgZWx0KSAobW9kdWxlIEVsdCA6IE1fc2V4cF9ncmFtbWFyIHdpdGggdHlwZSB0ID0gZWx0KVxuICA6IChlbHQsIF8pIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChsaXN0X3NleHBfZ3JhbW1hciBFbHQudF9zZXhwX2dyYW1tYXIpXG47O1xuXG5sZXQgY29tcGFyZV9tX190IChtb2R1bGUgXyA6IENvbXBhcmVfbSkgdDEgdDIgPSBjb21wYXJlX2RpcmVjdCB0MSB0MlxubGV0IGVxdWFsX21fX3QgKG1vZHVsZSBfIDogRXF1YWxfbSkgdDEgdDIgPSBlcXVhbCB0MSB0MlxuXG5sZXQgaGFzaF9mb2xkX21fX3QgKHR5cGUgZWx0KSAobW9kdWxlIEVsdCA6IEhhc2hfZm9sZF9tIHdpdGggdHlwZSB0ID0gZWx0KSBzdGF0ZSA9XG4gIGhhc2hfZm9sZF9kaXJlY3QgRWx0Lmhhc2hfZm9sZF90IHN0YXRlXG47O1xuXG5sZXQgaGFzaF9tX190IGZvbGRlciB0ID1cbiAgbGV0IHN0YXRlID0gaGFzaF9mb2xkX21fX3QgZm9sZGVyIChIYXNoLmNyZWF0ZSAoKSkgdCBpblxuICBIYXNoLmdldF9oYXNoX3ZhbHVlIHN0YXRlXG47O1xuXG5tb2R1bGUgUG9seSA9IHN0cnVjdFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3NcbiAgdHlwZSBub25yZWMgKCdlbHQsICdjbXApIHNldCA9ICgnZWx0LCBjb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgdHlwZSBub25yZWMgJ2VsdCB0ID0gKCdlbHQsIGNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICB0eXBlIG5vbnJlYyAnZWx0IHRyZWUgPSAoJ2VsdCwgY29tcGFyYXRvcl93aXRuZXNzKSB0cmVlXG4gIHR5cGUgbm9ucmVjICdlbHQgbmFtZWQgPSAoJ2VsdCwgY29tcGFyYXRvcl93aXRuZXNzKSBOYW1lZC50XG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgY29tcGFyYXRvciA9IENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yXG5cbiAgaW5jbHVkZSBVc2luZ19jb21wYXJhdG9yLkVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gKENvbXBhcmF0b3IuUG9seSlcblxuICBsZXQgc2luZ2xldG9uIGEgPSBVc2luZ19jb21wYXJhdG9yLnNpbmdsZXRvbiB+Y29tcGFyYXRvciBhXG4gIGxldCB1bmlvbl9saXN0IGEgPSBVc2luZ19jb21wYXJhdG9yLnVuaW9uX2xpc3QgfmNvbXBhcmF0b3IgYVxuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGEgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmNvbXBhcmF0b3IgfmxlbiB+ZlxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2xpc3QgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdCB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9zZXF1ZW5jZSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9hcnJheSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hcnJheSB+Y29tcGFyYXRvciBhXG4gIGxldCBzdGFibGVfZGVkdXBfbGlzdCBhID0gVXNpbmdfY29tcGFyYXRvci5zdGFibGVfZGVkdXBfbGlzdCB+Y29tcGFyYXRvciBhXG4gIGxldCBtYXAgYSB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IubWFwIH5jb21wYXJhdG9yIGEgfmZcbiAgbGV0IGZpbHRlcl9tYXAgYSB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IuZmlsdGVyX21hcCB+Y29tcGFyYXRvciBhIH5mXG4gIGxldCBvZl90cmVlIHRyZWUgPSB7IGNvbXBhcmF0b3I7IHRyZWUgfVxuICBsZXQgdG9fdHJlZSB0ID0gdC50cmVlXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG5pbmNsdWRlIChcbnN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSByZWYgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9IGNvbXBhcmVfcmVmXG4gIGxldCBlcXVhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2wgPSBlcXVhbF9yZWZcbiAgbGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9IHJlZl9vZl9zZXhwXG4gIGxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPSBzZXhwX29mX3JlZlxuXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gcmVmX3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZCA6XG5zaWdcbiAgdHlwZSAnYSB0ID0gJ2EgcmVmIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5FcXVhbC5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gIGluY2x1ZGUgU2V4cGxpYjAuU2V4cGFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuXG4gIHZhbCB0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICBbQEBAZW5kXVxuZW5kKVxuXG4oKiBJbiB0aGUgZGVmaW5pdGlvbiBvZiBbdF0sIHdlIGRvIG5vdCBoYXZlIFtbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXV0gYmVjYXVzZVxuICAgaW4gZ2VuZXJhbCwgc3ludGF4IGV4dGVuc2lvbnMgdGVuZCB0byB1c2UgdGhlIGltcGxlbWVudGF0aW9uIHdoZW4gYXZhaWxhYmxlIHJhdGhlciB0aGFuXG4gICB1c2luZyB0aGUgYWxpYXMuICBIZXJlIHRoYXQgd291bGQgbGVhZCB0byB1c2UgdGhlIHJlY29yZCByZXByZXNlbnRhdGlvbiBbIHsgbXV0YWJsZVxuICAgY29udGVudHMgOiAnYSB9IF0gd2hpY2ggd291bGQgcmVzdWx0IGluIGRpZmZlcmVudCAoYW5kIHVud2FudGVkKSBiZWhhdmlvci4gICopXG50eXBlICdhIHQgPSAnYSByZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5cbmV4dGVybmFsIGNyZWF0ZSA6ICdhIC0+ICdhIHQgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCAoICEgKSA6ICdhIHQgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgKCA6PSApIDogJ2EgdCAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcblxubGV0IHN3YXAgdDEgdDIgPVxuICBsZXQgdG1wID0gIXQxIGluXG4gIHQxIDo9ICF0MjtcbiAgdDIgOj0gdG1wXG47O1xuXG5sZXQgcmVwbGFjZSB0IGYgPSB0IDo9IGYgIXRcblxubGV0IHNldF90ZW1wb3JhcmlseSB0IGEgfmYgPVxuICBsZXQgcmVzdG9yZV90byA9ICF0IGluXG4gIHQgOj0gYTtcbiAgRXhuLnByb3RlY3QgfmYgfmZpbmFsbHk6KGZ1biAoKSAtPiB0IDo9IHJlc3RvcmVfdG8pXG47O1xuXG5tb2R1bGUgQW5kX3ZhbHVlID0gc3RydWN0XG4gIHR5cGUgdCA9IFQgOiAnYSByZWYgKiAnYSAtPiB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IHNldCAoVCAociwgYSkpID0gciA6PSBhXG4gIGxldCBzZXRzIHRzID0gTGlzdC5pdGVyIHRzIH5mOnNldFxuICBsZXQgc25hcHNob3QgKFQgKHIsIF8pKSA9IFQgKHIsICFyKVxuICBsZXQgc25hcHNob3RzIHRzID0gTGlzdC5tYXAgdHMgfmY6c25hcHNob3RcbmVuZFxuXG5sZXQgc2V0c190ZW1wb3JhcmlseSBhbmRfdmFsdWVzIH5mID1cbiAgbGV0IHJlc3RvcmVfdG8gPSBBbmRfdmFsdWUuc25hcHNob3RzIGFuZF92YWx1ZXMgaW5cbiAgQW5kX3ZhbHVlLnNldHMgYW5kX3ZhbHVlcztcbiAgRXhuLnByb3RlY3QgfmYgfmZpbmFsbHk6KGZ1biAoKSAtPiBBbmRfdmFsdWUuc2V0cyByZXN0b3JlX3RvKVxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG5cbigqIFt0XSBzdG9yZXMgdGhlIFt0Lmxlbmd0aF0gcXVldWUgZWxlbWVudHMgYXQgY29uc2VjdXRpdmUgaW5jcmVhc2luZyBpbmRpY2VzIG9mIFt0LmVsdHNdLFxuICAgbW9kIHRoZSBjYXBhY2l0eSBvZiBbdF0sIHdoaWNoIGlzIFtPcHRpb25fYXJyYXkubGVuZ3RoIHQuZWx0c10uICBUaGUgY2FwYWNpdHkgaXNcbiAgIHJlcXVpcmVkIHRvIGJlIGEgcG93ZXIgb2YgdHdvICh1c2VyLXJlcXVlc3RlZCBjYXBhY2l0aWVzIGFyZSByb3VuZGVkIHVwIHRvIHRoZSBuZWFyZXN0XG4gICBwb3dlciksIHNvIHRoYXQgbW9kIGNhbiBxdWlja2x5IGJlIGNvbXB1dGVkIHVzaW5nIFtsYW5kIHQubWFza10sIHdoZXJlIFt0Lm1hc2sgPVxuICAgY2FwYWNpdHkgdCAtIDFdLiAgU28sIHF1ZXVlIGVsZW1lbnQgW2ldIGlzIGF0IFt0LmVsdHMuKCAodC5mcm9udCArIGkpIGxhbmQgdC5tYXNrICldLlxuXG4gICBbbnVtX211dGF0aW9uc10gaXMgdXNlZCB0byBkZXRlY3QgbW9kaWZpY2F0aW9uIGR1cmluZyBpdGVyYXRpb24uICopXG50eXBlICdhIHQgPVxuICB7IG11dGFibGUgbnVtX211dGF0aW9ucyA6IGludFxuICA7IG11dGFibGUgZnJvbnQgOiBpbnRcbiAgOyBtdXRhYmxlIG1hc2sgOiBpbnRcbiAgOyBtdXRhYmxlIGxlbmd0aCA6IGludFxuICA7IG11dGFibGUgZWx0cyA6ICdhIE9wdGlvbl9hcnJheS50XG4gIH1cbltAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgZnVuIF9vZl9hX18wMDFfXG4gICAgeyBudW1fbXV0YXRpb25zID0gbnVtX211dGF0aW9uc19fMDAzX1xuICAgIDsgZnJvbnQgPSBmcm9udF9fMDA1X1xuICAgIDsgbWFzayA9IG1hc2tfXzAwN19cbiAgICA7IGxlbmd0aCA9IGxlbmd0aF9fMDA5X1xuICAgIDsgZWx0cyA9IGVsdHNfXzAxMV9cbiAgICB9IC0+XG4gICAgbGV0IGJuZHNfXzAwMl8gPSBbXSBpblxuICAgIGxldCBibmRzX18wMDJfID1cbiAgICAgIGxldCBhcmdfXzAxMl8gPSBPcHRpb25fYXJyYXkuc2V4cF9vZl90IF9vZl9hX18wMDFfIGVsdHNfXzAxMV8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImVsdHNcIjsgYXJnX18wMTJfIF0gOjogYm5kc19fMDAyX1xuICAgIGluXG4gICAgbGV0IGJuZHNfXzAwMl8gPVxuICAgICAgbGV0IGFyZ19fMDEwXyA9IHNleHBfb2ZfaW50IGxlbmd0aF9fMDA5XyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwibGVuZ3RoXCI7IGFyZ19fMDEwXyBdIDo6IGJuZHNfXzAwMl9cbiAgICBpblxuICAgIGxldCBibmRzX18wMDJfID1cbiAgICAgIGxldCBhcmdfXzAwOF8gPSBzZXhwX29mX2ludCBtYXNrX18wMDdfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJtYXNrXCI7IGFyZ19fMDA4XyBdIDo6IGJuZHNfXzAwMl9cbiAgICBpblxuICAgIGxldCBibmRzX18wMDJfID1cbiAgICAgIGxldCBhcmdfXzAwNl8gPSBzZXhwX29mX2ludCBmcm9udF9fMDA1XyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiZnJvbnRcIjsgYXJnX18wMDZfIF0gOjogYm5kc19fMDAyX1xuICAgIGluXG4gICAgbGV0IGJuZHNfXzAwMl8gPVxuICAgICAgbGV0IGFyZ19fMDA0XyA9IHNleHBfb2ZfaW50IG51bV9tdXRhdGlvbnNfXzAwM18gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIm51bV9tdXRhdGlvbnNcIjsgYXJnX18wMDRfIF0gOjogYm5kc19fMDAyX1xuICAgIGluXG4gICAgU2V4cGxpYjAuU2V4cC5MaXN0IGJuZHNfXzAwMl9cbjs7XG5cbltAQEBlbmRdXG5cbm1vZHVsZSB0eXBlIFMgPSBRdWV1ZV9pbnRmLlNcblxubGV0IGluY19udW1fbXV0YXRpb25zIHQgPSB0Lm51bV9tdXRhdGlvbnMgPC0gdC5udW1fbXV0YXRpb25zICsgMVxubGV0IGNhcGFjaXR5IHQgPSB0Lm1hc2sgKyAxXG5sZXQgZWx0c19pbmRleCB0IGkgPSAodC5mcm9udCArIGkpIGxhbmQgdC5tYXNrXG5sZXQgdW5zYWZlX2dldCB0IGkgPSBPcHRpb25fYXJyYXkudW5zYWZlX2dldF9zb21lX2V4biB0LmVsdHMgKGVsdHNfaW5kZXggdCBpKVxubGV0IHVuc2FmZV9pc19zZXQgdCBpID0gT3B0aW9uX2FycmF5LnVuc2FmZV9pc19zb21lIHQuZWx0cyAoZWx0c19pbmRleCB0IGkpXG5sZXQgdW5zYWZlX3NldCB0IGkgYSA9IE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X3NvbWUgdC5lbHRzIChlbHRzX2luZGV4IHQgaSkgYVxubGV0IHVuc2FmZV91bnNldCB0IGkgPSBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9ub25lIHQuZWx0cyAoZWx0c19pbmRleCB0IGkpXG5cbmxldCBjaGVja19pbmRleF9leG4gdCBpID1cbiAgaWYgaSA8IDAgfHwgaSA+PSB0Lmxlbmd0aFxuICB0aGVuXG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJRdWV1ZSBpbmRleCBvdXQgb2YgYm91bmRzXCJcbiAgICAgICAgIFsgXCJpbmRleFwiLCBpIHw+IEludC5zZXhwX29mX3Q7IFwibGVuZ3RoXCIsIHQubGVuZ3RoIHw+IEludC5zZXhwX29mX3QgXSlcbjs7XG5cbmxldCBnZXQgdCBpID1cbiAgY2hlY2tfaW5kZXhfZXhuIHQgaTtcbiAgdW5zYWZlX2dldCB0IGlcbjs7XG5cbmxldCBzZXQgdCBpIGEgPVxuICBjaGVja19pbmRleF9leG4gdCBpO1xuICBpbmNfbnVtX211dGF0aW9ucyB0O1xuICB1bnNhZmVfc2V0IHQgaSBhXG47O1xuXG5sZXQgaXNfZW1wdHkgdCA9IHQubGVuZ3RoID0gMFxubGV0IGxlbmd0aCB7IGxlbmd0aDsgXyB9ID0gbGVuZ3RoXG5cbmxldCBlbnN1cmVfbm9fbXV0YXRpb24gdCBudW1fbXV0YXRpb25zID1cbiAgaWYgdC5udW1fbXV0YXRpb25zIDw+IG51bV9tdXRhdGlvbnNcbiAgdGhlblxuICAgIEVycm9yLnJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwibXV0YXRpb24gb2YgcXVldWUgZHVyaW5nIGl0ZXJhdGlvblwiXG4gICAgICAgICBbIFwiXCIsIHQgfD4gc2V4cF9vZl90IChmdW4gXyAtPiBTZXhwLkF0b20gXCJfXCIpIF0pXG47O1xuXG5sZXQgY29tcGFyZSA9XG4gIGxldCByZWMgdW5zYWZlX2NvbXBhcmVfZnJvbSBjb21wYXJlX2VsdCBwb3MgfnQxIH50MiB+bGVuMSB+bGVuMiB+bXV0MSB+bXV0MiA9XG4gICAgbWF0Y2ggcG9zID0gbGVuMSwgcG9zID0gbGVuMiB3aXRoXG4gICAgfCB0cnVlLCB0cnVlIC0+IDBcbiAgICB8IHRydWUsIGZhbHNlIC0+IC0xXG4gICAgfCBmYWxzZSwgdHJ1ZSAtPiAxXG4gICAgfCBmYWxzZSwgZmFsc2UgLT5cbiAgICAgIGxldCB4ID0gY29tcGFyZV9lbHQgKHVuc2FmZV9nZXQgdDEgcG9zKSAodW5zYWZlX2dldCB0MiBwb3MpIGluXG4gICAgICBlbnN1cmVfbm9fbXV0YXRpb24gdDEgbXV0MTtcbiAgICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0MiBtdXQyO1xuICAgICAgKG1hdGNoIHggd2l0aFxuICAgICAgIHwgMCAtPiB1bnNhZmVfY29tcGFyZV9mcm9tIGNvbXBhcmVfZWx0IChwb3MgKyAxKSB+dDEgfnQyIH5sZW4xIH5sZW4yIH5tdXQxIH5tdXQyXG4gICAgICAgfCBuIC0+IG4pXG4gIGluXG4gIGZ1biBjb21wYXJlX2VsdCB0MSB0MiAtPlxuICAgIGlmIHBoeXNfZXF1YWwgdDEgdDJcbiAgICB0aGVuIDBcbiAgICBlbHNlXG4gICAgICB1bnNhZmVfY29tcGFyZV9mcm9tXG4gICAgICAgIGNvbXBhcmVfZWx0XG4gICAgICAgIDBcbiAgICAgICAgfnQxXG4gICAgICAgIH50MlxuICAgICAgICB+bGVuMTp0MS5sZW5ndGhcbiAgICAgICAgfmxlbjI6dDIubGVuZ3RoXG4gICAgICAgIH5tdXQxOnQxLm51bV9tdXRhdGlvbnNcbiAgICAgICAgfm11dDI6dDIubnVtX211dGF0aW9uc1xuOztcblxubGV0IGVxdWFsID1cbiAgbGV0IHJlYyB1bnNhZmVfZXF1YWxfZnJvbSBlcXVhbF9lbHQgcG9zIH50MSB+dDIgfm11dDEgfm11dDIgfmxlbiA9XG4gICAgcG9zID0gbGVuXG4gICAgfHxcbiAgICBsZXQgYiA9IGVxdWFsX2VsdCAodW5zYWZlX2dldCB0MSBwb3MpICh1bnNhZmVfZ2V0IHQyIHBvcykgaW5cbiAgICBlbnN1cmVfbm9fbXV0YXRpb24gdDEgbXV0MTtcbiAgICBlbnN1cmVfbm9fbXV0YXRpb24gdDIgbXV0MjtcbiAgICBiICYmIHVuc2FmZV9lcXVhbF9mcm9tIGVxdWFsX2VsdCAocG9zICsgMSkgfnQxIH50MiB+bXV0MSB+bXV0MiB+bGVuXG4gIGluXG4gIGZ1biBlcXVhbF9lbHQgdDEgdDIgLT5cbiAgICBwaHlzX2VxdWFsIHQxIHQyXG4gICAgfHxcbiAgICBsZXQgbGVuMSA9IHQxLmxlbmd0aCBpblxuICAgIGxldCBsZW4yID0gdDIubGVuZ3RoIGluXG4gICAgbGVuMSA9IGxlbjJcbiAgICAmJiB1bnNhZmVfZXF1YWxfZnJvbVxuICAgICAgICAgZXF1YWxfZWx0XG4gICAgICAgICAwXG4gICAgICAgICB+dDFcbiAgICAgICAgIH50MlxuICAgICAgICAgfmxlbjpsZW4xXG4gICAgICAgICB+bXV0MTp0MS5udW1fbXV0YXRpb25zXG4gICAgICAgICB+bXV0Mjp0Mi5udW1fbXV0YXRpb25zXG47O1xuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hIHQgPVxuICBsZXQgeyBudW1fbXV0YXRpb25zOyBtYXNrID0gXzsgZWx0czsgZnJvbnQ7IGxlbmd0aCB9ID0gdCBpblxuICBhc3NlcnQgKGZyb250ID49IDApO1xuICBhc3NlcnQgKGZyb250IDwgY2FwYWNpdHkgdCk7XG4gIGxldCBjYXBhY2l0eSA9IGNhcGFjaXR5IHQgaW5cbiAgYXNzZXJ0IChjYXBhY2l0eSA9IE9wdGlvbl9hcnJheS5sZW5ndGggZWx0cyk7XG4gIGFzc2VydCAoY2FwYWNpdHkgPj0gMSk7XG4gIGFzc2VydCAoSW50LmlzX3BvdzIgY2FwYWNpdHkpO1xuICBhc3NlcnQgKGxlbmd0aCA+PSAwKTtcbiAgYXNzZXJ0IChsZW5ndGggPD0gY2FwYWNpdHkpO1xuICBmb3IgaSA9IDAgdG8gY2FwYWNpdHkgLSAxIGRvXG4gICAgaWYgaSA8IHQubGVuZ3RoXG4gICAgdGhlbiAoXG4gICAgICBpbnZhcmlhbnRfYSAodW5zYWZlX2dldCB0IGkpO1xuICAgICAgZW5zdXJlX25vX211dGF0aW9uIHQgbnVtX211dGF0aW9ucylcbiAgICBlbHNlIGFzc2VydCAobm90ICh1bnNhZmVfaXNfc2V0IHQgaSkpXG4gIGRvbmVcbjs7XG5cbmxldCBjcmVhdGUgKHR5cGUgYSkgP2NhcGFjaXR5ICgpIDogYSB0ID1cbiAgbGV0IGNhcGFjaXR5ID1cbiAgICBtYXRjaCBjYXBhY2l0eSB3aXRoXG4gICAgfCBOb25lIC0+IDFcbiAgICB8IFNvbWUgY2FwYWNpdHkgLT5cbiAgICAgIGlmIGNhcGFjaXR5IDwgMFxuICAgICAgdGhlblxuICAgICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICAgIFwiY2Fubm90IGhhdmUgcXVldWUgd2l0aCBuZWdhdGl2ZSBjYXBhY2l0eVwiXG4gICAgICAgICAgICAgWyBcImNhcGFjaXR5XCIsIGNhcGFjaXR5IHw+IEludC5zZXhwX29mX3QgXSlcbiAgICAgIGVsc2UgaWYgY2FwYWNpdHkgPSAwXG4gICAgICB0aGVuIDFcbiAgICAgIGVsc2UgSW50LmNlaWxfcG93MiBjYXBhY2l0eVxuICBpblxuICB7IG51bV9tdXRhdGlvbnMgPSAwXG4gIDsgZnJvbnQgPSAwXG4gIDsgbWFzayA9IGNhcGFjaXR5IC0gMVxuICA7IGxlbmd0aCA9IDBcbiAgOyBlbHRzID0gT3B0aW9uX2FycmF5LmNyZWF0ZSB+bGVuOmNhcGFjaXR5XG4gIH1cbjs7XG5cbmxldCBibGl0X3RvX2FycmF5IH5zcmMgZHN0ID1cbiAgYXNzZXJ0IChzcmMubGVuZ3RoIDw9IE9wdGlvbl9hcnJheS5sZW5ndGggZHN0KTtcbiAgbGV0IGZyb250X2xlbiA9IEludC5taW4gc3JjLmxlbmd0aCAoY2FwYWNpdHkgc3JjIC0gc3JjLmZyb250KSBpblxuICBsZXQgcmVzdF9sZW4gPSBzcmMubGVuZ3RoIC0gZnJvbnRfbGVuIGluXG4gIE9wdGlvbl9hcnJheS5ibGl0IH5sZW46ZnJvbnRfbGVuIH5zcmM6c3JjLmVsdHMgfnNyY19wb3M6c3JjLmZyb250IH5kc3QgfmRzdF9wb3M6MDtcbiAgT3B0aW9uX2FycmF5LmJsaXQgfmxlbjpyZXN0X2xlbiB+c3JjOnNyYy5lbHRzIH5zcmNfcG9zOjAgfmRzdCB+ZHN0X3Bvczpmcm9udF9sZW5cbjs7XG5cbmxldCBzZXRfY2FwYWNpdHkgdCBkZXNpcmVkX2NhcGFjaXR5ID1cbiAgKCogV2UgYWxsb3cgYXJndW1lbnRzIGxlc3MgdGhhbiAxIHRvIFtzZXRfY2FwYWNpdHldLCBidXQgdHJhbnNsYXRlIHRoZW0gdG8gMSB0byBzaW1wbGlmeVxuICAgICB0aGUgY29kZSB0aGF0IHJlbGllcyBvbiB0aGUgYXJyYXkgbGVuZ3RoIGJlaW5nIGEgcG93ZXIgb2YgMi4gKilcbiAgaW5jX251bV9tdXRhdGlvbnMgdDtcbiAgbGV0IG5ld19jYXBhY2l0eSA9IEludC5jZWlsX3BvdzIgKG1heCAxIChtYXggZGVzaXJlZF9jYXBhY2l0eSB0Lmxlbmd0aCkpIGluXG4gIGlmIG5ld19jYXBhY2l0eSA8PiBjYXBhY2l0eSB0XG4gIHRoZW4gKFxuICAgIGxldCBkc3QgPSBPcHRpb25fYXJyYXkuY3JlYXRlIH5sZW46bmV3X2NhcGFjaXR5IGluXG4gICAgYmxpdF90b19hcnJheSB+c3JjOnQgZHN0O1xuICAgIHQuZnJvbnQgPC0gMDtcbiAgICB0Lm1hc2sgPC0gbmV3X2NhcGFjaXR5IC0gMTtcbiAgICB0LmVsdHMgPC0gZHN0KVxuOztcblxubGV0IGVucXVldWUgdCBhID1cbiAgaW5jX251bV9tdXRhdGlvbnMgdDtcbiAgaWYgdC5sZW5ndGggPSBjYXBhY2l0eSB0IHRoZW4gc2V0X2NhcGFjaXR5IHQgKDIgKiB0Lmxlbmd0aCk7XG4gIHVuc2FmZV9zZXQgdCB0Lmxlbmd0aCBhO1xuICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCArIDFcbjs7XG5cbmxldCBkZXF1ZXVlX25vbmVtcHR5IHQgPVxuICBpbmNfbnVtX211dGF0aW9ucyB0O1xuICBsZXQgZWx0cyA9IHQuZWx0cyBpblxuICBsZXQgZnJvbnQgPSB0LmZyb250IGluXG4gIGxldCByZXMgPSBPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIGVsdHMgZnJvbnQgaW5cbiAgT3B0aW9uX2FycmF5LnNldF9ub25lIGVsdHMgZnJvbnQ7XG4gIHQuZnJvbnQgPC0gZWx0c19pbmRleCB0IDE7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoIC0gMTtcbiAgcmVzXG47O1xuXG5sZXQgZGVxdWV1ZV9leG4gdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiByYWlzZSBDYW1sLlF1ZXVlLkVtcHR5IGVsc2UgZGVxdWV1ZV9ub25lbXB0eSB0XG5sZXQgZGVxdWV1ZSB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChkZXF1ZXVlX25vbmVtcHR5IHQpXG5sZXQgZnJvbnRfbm9uZW1wdHkgdCA9IE9wdGlvbl9hcnJheS51bnNhZmVfZ2V0X3NvbWVfZXhuIHQuZWx0cyB0LmZyb250XG5sZXQgbGFzdF9ub25lbXB0eSB0ID0gdW5zYWZlX2dldCB0ICh0Lmxlbmd0aCAtIDEpXG5sZXQgcGVlayB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChmcm9udF9ub25lbXB0eSB0KVxubGV0IHBlZWtfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gcmFpc2UgQ2FtbC5RdWV1ZS5FbXB0eSBlbHNlIGZyb250X25vbmVtcHR5IHRcbmxldCBsYXN0IHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGxhc3Rfbm9uZW1wdHkgdClcbmxldCBsYXN0X2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlIENhbWwuUXVldWUuRW1wdHkgZWxzZSBsYXN0X25vbmVtcHR5IHRcblxubGV0IGNsZWFyIHQgPVxuICBpbmNfbnVtX211dGF0aW9ucyB0O1xuICBpZiB0Lmxlbmd0aCA+IDBcbiAgdGhlbiAoXG4gICAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgICAgdW5zYWZlX3Vuc2V0IHQgaVxuICAgIGRvbmU7XG4gICAgdC5sZW5ndGggPC0gMDtcbiAgICB0LmZyb250IDwtIDApXG47O1xuXG5sZXQgYmxpdF90cmFuc2ZlciB+c3JjIH5kc3QgP2xlbiAoKSA9XG4gIGluY19udW1fbXV0YXRpb25zIHNyYztcbiAgaW5jX251bV9tdXRhdGlvbnMgZHN0O1xuICBsZXQgbGVuID1cbiAgICBtYXRjaCBsZW4gd2l0aFxuICAgIHwgTm9uZSAtPiBzcmMubGVuZ3RoXG4gICAgfCBTb21lIGxlbiAtPlxuICAgICAgaWYgbGVuIDwgMFxuICAgICAgdGhlblxuICAgICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICAgIFwiUXVldWUuYmxpdF90cmFuc2ZlcjogbmVnYXRpdmUgbGVuZ3RoXCJcbiAgICAgICAgICAgICBbIFwibGVuZ3RoXCIsIGxlbiB8PiBJbnQuc2V4cF9vZl90IF0pO1xuICAgICAgbWluIGxlbiBzcmMubGVuZ3RoXG4gIGluXG4gIGlmIGxlbiA+IDBcbiAgdGhlbiAoXG4gICAgc2V0X2NhcGFjaXR5IGRzdCAobWF4IChjYXBhY2l0eSBkc3QpIChkc3QubGVuZ3RoICsgbGVuKSk7XG4gICAgbGV0IGRzdF9zdGFydCA9IGRzdC5mcm9udCArIGRzdC5sZW5ndGggaW5cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgKCogVGhpcyBpcyBzaWduaWZpY2FudGx5IGZhc3RlciB0aGFuIHNpbXBseSBbZW5xdWV1ZSBkc3QgKGRlcXVldWVfbm9uZW1wdHkgc3JjKV0gKilcbiAgICAgIGxldCBzcmNfaSA9IChzcmMuZnJvbnQgKyBpKSBsYW5kIHNyYy5tYXNrIGluXG4gICAgICBsZXQgZHN0X2kgPSAoZHN0X3N0YXJ0ICsgaSkgbGFuZCBkc3QubWFzayBpblxuICAgICAgT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfc29tZVxuICAgICAgICBkc3QuZWx0c1xuICAgICAgICBkc3RfaVxuICAgICAgICAoT3B0aW9uX2FycmF5LnVuc2FmZV9nZXRfc29tZV9leG4gc3JjLmVsdHMgc3JjX2kpO1xuICAgICAgT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfbm9uZSBzcmMuZWx0cyBzcmNfaVxuICAgIGRvbmU7XG4gICAgZHN0Lmxlbmd0aCA8LSBkc3QubGVuZ3RoICsgbGVuO1xuICAgIHNyYy5mcm9udCA8LSAoc3JjLmZyb250ICsgbGVuKSBsYW5kIHNyYy5tYXNrO1xuICAgIHNyYy5sZW5ndGggPC0gc3JjLmxlbmd0aCAtIGxlbilcbjs7XG5cbmxldCBlbnF1ZXVlX2FsbCB0IGwgPVxuICAoKiBUcmF2ZXJzaW5nIHRoZSBsaXN0IHVwIGZyb250IHRvIGNvbXB1dGUgaXRzIGxlbmd0aCBpcyBwcm9iYWJseSAoYnV0IG5vdCBkZWZpbml0ZWx5KVxuICAgICBiZXR0ZXIgdGhhbiBkb3VibGluZyB0aGUgdW5kZXJseWluZyBhcnJheSBzaXplIHNldmVyYWwgdGltZXMgZm9yIGxhcmdlIHF1ZXVlcy4gKilcbiAgc2V0X2NhcGFjaXR5IHQgKEludC5tYXggKGNhcGFjaXR5IHQpICh0Lmxlbmd0aCArIExpc3QubGVuZ3RoIGwpKTtcbiAgTGlzdC5pdGVyIGwgfmY6KGZ1biB4IC0+IGVucXVldWUgdCB4KVxuOztcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGlmIHQubGVuZ3RoID0gMFxuICB0aGVuIGluaXRcbiAgZWxzZSAoXG4gICAgbGV0IG51bV9tdXRhdGlvbnMgPSB0Lm51bV9tdXRhdGlvbnMgaW5cbiAgICBsZXQgciA9IHJlZiBpbml0IGluXG4gICAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IHQgaSk7XG4gICAgICBlbnN1cmVfbm9fbXV0YXRpb24gdCBudW1fbXV0YXRpb25zXG4gICAgZG9uZTtcbiAgICAhcilcbjs7XG5cbmxldCBmb2xkaSB0IH5pbml0IH5mID1cbiAgbGV0IGkgPSByZWYgMCBpblxuICBmb2xkIHQgfmluaXQgfmY6KGZ1biBhY2MgYSAtPlxuICAgIGxldCBhY2MgPSBmICFpIGFjYyBhIGluXG4gICAgaSA6PSAhaSArIDE7XG4gICAgYWNjKVxuOztcblxuXG4oKiBbaXRlcl0gaXMgaW1wbGVtZW50ZWQgZGlyZWN0bHkgYmVjYXVzZSBpbXBsZW1lbnRpbmcgaXQgaW4gdGVybXMgb2YgW2ZvbGRdIGlzXG4gICBzbG93ZXIuICopXG5sZXQgaXRlciB0IH5mID1cbiAgbGV0IG51bV9tdXRhdGlvbnMgPSB0Lm51bV9tdXRhdGlvbnMgaW5cbiAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgIGYgKHVuc2FmZV9nZXQgdCBpKTtcbiAgICBlbnN1cmVfbm9fbXV0YXRpb24gdCBudW1fbXV0YXRpb25zXG4gIGRvbmVcbjs7XG5cbmxldCBpdGVyaSB0IH5mID1cbiAgbGV0IG51bV9tdXRhdGlvbnMgPSB0Lm51bV9tdXRhdGlvbnMgaW5cbiAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgIGYgaSAodW5zYWZlX2dldCB0IGkpO1xuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnNcbiAgZG9uZVxuOztcblxubGV0IHRvX2xpc3QgdCA9XG4gIGxldCByZXN1bHQgPSByZWYgW10gaW5cbiAgZm9yIGkgPSB0Lmxlbmd0aCAtIDEgZG93bnRvIDAgZG9cbiAgICByZXN1bHQgOj0gdW5zYWZlX2dldCB0IGkgOjogIXJlc3VsdFxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5tb2R1bGUgQyA9IEluZGV4ZWRfY29udGFpbmVyLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgaXRlciA9IGBDdXN0b20gaXRlclxuICAgIGxldCBsZW5ndGggPSBgQ3VzdG9tIGxlbmd0aFxuICAgIGxldCBmb2xkaSA9IGBDdXN0b20gZm9sZGlcbiAgICBsZXQgaXRlcmkgPSBgQ3VzdG9tIGl0ZXJpXG4gIGVuZClcblxubGV0IGNvdW50ID0gQy5jb3VudFxubGV0IGV4aXN0cyA9IEMuZXhpc3RzXG5sZXQgZmluZCA9IEMuZmluZFxubGV0IGZpbmRfbWFwID0gQy5maW5kX21hcFxubGV0IGZvbGRfcmVzdWx0ID0gQy5mb2xkX3Jlc3VsdFxubGV0IGZvbGRfdW50aWwgPSBDLmZvbGRfdW50aWxcbmxldCBmb3JfYWxsID0gQy5mb3JfYWxsXG5sZXQgbWF4X2VsdCA9IEMubWF4X2VsdFxubGV0IG1lbSA9IEMubWVtXG5sZXQgbWluX2VsdCA9IEMubWluX2VsdFxubGV0IHN1bSA9IEMuc3VtXG5sZXQgY291bnRpID0gQy5jb3VudGlcbmxldCBleGlzdHNpID0gQy5leGlzdHNpXG5sZXQgZmluZF9tYXBpID0gQy5maW5kX21hcGlcbmxldCBmaW5kaSA9IEMuZmluZGlcbmxldCBmb3JfYWxsaSA9IEMuZm9yX2FsbGlcblxuXG4oKiBGb3IgW2NvbmNhdF9tYXBdLCBbZmlsdGVyX21hcF0sIGFuZCBbZmlsdGVyXSwgd2UgZG9uJ3QgY3JlYXRlIFt0X3Jlc3VsdF0gd2l0aCBbdF0nc1xuICAgY2FwYWNpdHkgYmVjYXVzZSB3ZSBoYXZlIG5vIGlkZWEgaG93IG1hbnkgZWxlbWVudHMgW3RfcmVzdWx0XSB3aWxsIHVsdGltYXRlbHkgaG9sZC4gKilcbmxldCBjb25jYXRfbWFwIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPiBMaXN0Lml0ZXIgKGYgYSkgfmY6KGZ1biBiIC0+IGVucXVldWUgdF9yZXN1bHQgYikpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGNvbmNhdF9tYXBpIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPiBMaXN0Lml0ZXIgKGYgaSBhKSB+ZjooZnVuIGIgLT4gZW5xdWV1ZSB0X3Jlc3VsdCBiKSk7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyX21hcCB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT5cbiAgICBtYXRjaCBmIGEgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBiIC0+IGVucXVldWUgdF9yZXN1bHQgYik7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+XG4gICAgbWF0Y2ggZiBpIGEgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBiIC0+IGVucXVldWUgdF9yZXN1bHQgYik7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPiBpZiBmIGEgdGhlbiBlbnF1ZXVlIHRfcmVzdWx0IGEpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlcmkgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+IGlmIGYgaSBhIHRoZW4gZW5xdWV1ZSB0X3Jlc3VsdCBhKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJfaW5wbGFjZSB0IH5mID1cbiAgbGV0IHQyID0gZmlsdGVyIHQgfmYgaW5cbiAgY2xlYXIgdDtcbiAgYmxpdF90cmFuc2ZlciB+c3JjOnQyIH5kc3Q6dCAoKVxuOztcblxubGV0IGZpbHRlcmlfaW5wbGFjZSB0IH5mID1cbiAgbGV0IHQyID0gZmlsdGVyaSB0IH5mIGluXG4gIGNsZWFyIHQ7XG4gIGJsaXRfdHJhbnNmZXIgfnNyYzp0MiB+ZHN0OnQgKClcbjs7XG5cbmxldCBjb3B5IHNyYyA9XG4gIGxldCBkc3QgPSBjcmVhdGUgfmNhcGFjaXR5OnNyYy5sZW5ndGggKCkgaW5cbiAgYmxpdF90b19hcnJheSB+c3JjIGRzdC5lbHRzO1xuICBkc3QubGVuZ3RoIDwtIHNyYy5sZW5ndGg7XG4gIGRzdFxuOztcblxubGV0IG9mX2xpc3QgbCA9XG4gICgqIFRyYXZlcnNpbmcgdGhlIGxpc3QgdXAgZnJvbnQgdG8gY29tcHV0ZSBpdHMgbGVuZ3RoIGlzIHByb2JhYmx5IChidXQgbm90IGRlZmluaXRlbHkpXG4gICAgIGJldHRlciB0aGFuIGRvdWJsaW5nIHRoZSB1bmRlcmx5aW5nIGFycmF5IHNpemUgc2V2ZXJhbCB0aW1lcyBmb3IgbGFyZ2UgcXVldWVzLiAqKVxuICBsZXQgdCA9IGNyZWF0ZSB+Y2FwYWNpdHk6KExpc3QubGVuZ3RoIGwpICgpIGluXG4gIExpc3QuaXRlciBsIH5mOihmdW4geCAtPiBlbnF1ZXVlIHQgeCk7XG4gIHRcbjs7XG5cbigqIFRoZSBxdWV1ZSBbdF0gcmV0dXJuZWQgYnkgW2NyZWF0ZV0gd2lsbCBoYXZlIFt0Lmxlbmd0aCA9IDBdLCBbdC5mcm9udCA9IDBdLCBhbmRcbiAgIFtjYXBhY2l0eSB0ID0gSW50LmNlaWxfcG93MiBsZW5dLiAgU28sIHdlIG9ubHkgaGF2ZSB0byBzZXQgW3QubGVuZ3RoXSB0byBbbGVuXSBhZnRlclxuICAgdGhlIGJsaXQgdG8gbWFpbnRhaW4gYWxsIHRoZSBpbnZhcmlhbnRzOiBbdC5sZW5ndGhdIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZWxlbWVudHNcbiAgIGluIHRoZSBxdWV1ZSwgW3QuZnJvbnRdIGlzIHRoZSBhcnJheSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgcXVldWUsIGFuZFxuICAgW2NhcGFjaXR5IHQgPSBPcHRpb25fYXJyYXkubGVuZ3RoIHQuZWx0c10uICopXG5sZXQgaW5pdCBsZW4gfmYgPVxuICBpZiBsZW4gPCAwXG4gIHRoZW5cbiAgICBFcnJvci5yYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlIFwiUXVldWUuaW5pdDogbmVnYXRpdmUgbGVuZ3RoXCIgWyBcImxlbmd0aFwiLCBsZW4gfD4gSW50LnNleHBfb2ZfdCBdKTtcbiAgbGV0IHQgPSBjcmVhdGUgfmNhcGFjaXR5OmxlbiAoKSBpblxuICBhc3NlcnQgKE9wdGlvbl9hcnJheS5sZW5ndGggdC5lbHRzID49IGxlbik7XG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfc29tZSB0LmVsdHMgaSAoZiBpKVxuICBkb25lO1xuICB0Lmxlbmd0aCA8LSBsZW47XG4gIHRcbjs7XG5cbmxldCBvZl9hcnJheSBhID0gaW5pdCAoQXJyYXkubGVuZ3RoIGEpIH5mOihBcnJheS51bnNhZmVfZ2V0IGEpXG5sZXQgdG9fYXJyYXkgdCA9IEFycmF5LmluaXQgdC5sZW5ndGggfmY6KGZ1biBpIC0+IHVuc2FmZV9nZXQgdCBpKVxuXG5sZXQgbWFwIHRhIH5mID1cbiAgbGV0IG51bV9tdXRhdGlvbnMgPSB0YS5udW1fbXV0YXRpb25zIGluXG4gIGxldCB0YiA9IGNyZWF0ZSB+Y2FwYWNpdHk6dGEubGVuZ3RoICgpIGluXG4gIHRiLmxlbmd0aCA8LSB0YS5sZW5ndGg7XG4gIGZvciBpID0gMCB0byB0YS5sZW5ndGggLSAxIGRvXG4gICAgbGV0IGIgPSBmICh1bnNhZmVfZ2V0IHRhIGkpIGluXG4gICAgZW5zdXJlX25vX211dGF0aW9uIHRhIG51bV9tdXRhdGlvbnM7XG4gICAgT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfc29tZSB0Yi5lbHRzIGkgYlxuICBkb25lO1xuICB0YlxuOztcblxubGV0IG1hcGkgdCB+ZiA9XG4gIGxldCBpID0gcmVmIDAgaW5cbiAgbWFwIHQgfmY6KGZ1biBhIC0+XG4gICAgbGV0IHJlc3VsdCA9IGYgIWkgYSBpblxuICAgIGkgOj0gIWkgKyAxO1xuICAgIHJlc3VsdClcbjs7XG5cbmxldCBzaW5nbGV0b24geCA9XG4gIGxldCB0ID0gY3JlYXRlICgpIGluXG4gIGVucXVldWUgdCB4O1xuICB0XG47O1xuXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID0gdG9fbGlzdCB0IHw+IExpc3Quc2V4cF9vZl90IHNleHBfb2ZfYVxubGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCA9IExpc3QudF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwIHw+IG9mX2xpc3RcblxubGV0IHRfc2V4cF9ncmFtbWFyICh0eXBlIGEpIChncmFtbWFyIDogYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiBhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IHxcblxuICBsZXQgdW5yZWFjaGFibGVfY29kZSA9IGZ1bmN0aW9uXG4gICAgfCAoXyA6IHQpIC0+IC5cbiAgOztcblxuICBsZXQgYWxsID0gW11cbiAgbGV0IGhhc2hfZm9sZF90IF8gdCA9IHVucmVhY2hhYmxlX2NvZGUgdFxuICBsZXQgaGFzaCA9IHVucmVhY2hhYmxlX2NvZGVcbiAgbGV0IGNvbXBhcmUgYSBfID0gdW5yZWFjaGFibGVfY29kZSBhXG4gIGxldCBzZXhwX29mX3QgPSB1bnJlYWNoYWJsZV9jb2RlXG4gIGxldCB0X29mX3NleHAgc2V4cCA9IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV90eXBlIFwiQmFzZS5Ob3RoaW5nLnRcIiBzZXhwXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHsgdW50eXBlZCA9IFVuaW9uIFtdIH1cbiAgbGV0IHRvX3N0cmluZyA9IHVucmVhY2hhYmxlX2NvZGVcbiAgbGV0IG9mX3N0cmluZyAoXyA6IHN0cmluZykgPSBmYWlsd2l0aCBcIkJhc2UuTm90aGluZy5vZl9zdHJpbmc6IG5vdCBzdXBwb3J0ZWRcIlxuZW5kXG5cbmluY2x1ZGUgVFxuXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5Ob3RoaW5nXCJcbiAgZW5kKVxuIiwib3BlbiEgSW1wb3J0XG5vcGVuISBDYW1sLk5hdGl2ZWludFxuaW5jbHVkZSBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IG5hdGl2ZWludCBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfbmF0aXZlaW50XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9uYXRpdmVpbnQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKG5hdGl2ZWludF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9uYXRpdmVpbnQgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gbmF0aXZlaW50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgY29tcGFyZSA9IE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuY29tcGFyZVxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gIGxldCBvZl9zdHJpbmcgPSBvZl9zdHJpbmdcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCB6ZXJvID0gemVyb1xuICBlbmQpXG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5pbmNsdWRlIENvbnYuTWFrZSAoVClcblxuaW5jbHVkZSBDb252Lk1ha2VfaGV4IChzdHJ1Y3RcbiAgICBvcGVuIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICAgIHR5cGUgdCA9IG5hdGl2ZWludCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxuICAgIGxldCBjb21wYXJlID0gKGNvbXBhcmVfbmF0aXZlaW50IDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIGhhc2hfZm9sZF9uYXRpdmVpbnRcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gaGFzaF9uYXRpdmVpbnQgaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gICAgbGV0IG5lZyA9IG5lZ1xuICAgIGxldCAoIDwgKSA9ICggPCApXG4gICAgbGV0IHRvX3N0cmluZyBpID0gUHJpbnRmLnNwcmludGYgXCIlbnhcIiBpXG4gICAgbGV0IG9mX3N0cmluZyBzID0gQ2FtbC5TY2FuZi5zc2NhbmYgcyBcIiVueFwiIEZuLmlkXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLk5hdGl2ZWludC5IZXhcIlxuICBlbmQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLk5hdGl2ZWludFwiXG4gIGVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IG51bV9iaXRzID0gV29yZF9zaXplLm51bV9iaXRzIFdvcmRfc2l6ZS53b3JkX3NpemVcbmxldCBmbG9hdF9sb3dlcl9ib3VuZCA9IEZsb2F0MC5sb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfdXBwZXJfYm91bmQgPSBGbG9hdDAudXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5sZXQgc2hpZnRfcmlnaHQgPSBzaGlmdF9yaWdodFxubGV0IHNoaWZ0X2xlZnQgPSBzaGlmdF9sZWZ0XG5sZXQgYml0X25vdCA9IGxvZ25vdFxubGV0IGJpdF94b3IgPSBsb2d4b3JcbmxldCBiaXRfb3IgPSBsb2dvclxubGV0IGJpdF9hbmQgPSBsb2dhbmRcbmxldCBtaW5fdmFsdWUgPSBtaW5faW50XG5sZXQgbWF4X3ZhbHVlID0gbWF4X2ludFxubGV0IGFicyA9IGFic1xubGV0IHByZWQgPSBwcmVkXG5sZXQgc3VjYyA9IHN1Y2NcbmxldCByZW0gPSByZW1cbmxldCBuZWcgPSBuZWdcbmxldCBtaW51c19vbmUgPSBtaW51c19vbmVcbmxldCBvbmUgPSBvbmVcbmxldCB6ZXJvID0gemVyb1xubGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgPSBvZl9mbG9hdFxuXG5sZXQgb2ZfZmxvYXQgZiA9XG4gIGlmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgZiBmbG9hdF9sb3dlcl9ib3VuZFxuICAmJiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIGYgZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiBvZl9mbG9hdCBmXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIk5hdGl2ZWludC5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IGYpXG4gICAgICAoKVxuOztcblxubW9kdWxlIFBvdzIgPSBzdHJ1Y3RcbiAgb3BlbiEgSW1wb3J0XG4gIG9wZW4gTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gIGxldCBub25fcG9zaXRpdmVfYXJndW1lbnQgKCkgPVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJhcmd1bWVudCBtdXN0IGJlIHN0cmljdGx5IHBvc2l0aXZlXCIgKClcbiAgOztcblxuICBsZXQgKCBsb3IgKSA9IENhbWwuTmF0aXZlaW50LmxvZ29yXG4gIGxldCAoIGxzciApID0gQ2FtbC5OYXRpdmVpbnQuc2hpZnRfcmlnaHRfbG9naWNhbFxuICBsZXQgKCBsYW5kICkgPSBDYW1sLk5hdGl2ZWludC5sb2dhbmRcblxuICAoKiogXCJjZWlsaW5nIHBvd2VyIG9mIDJcIiAtIExlYXN0IHBvd2VyIG9mIDIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBjZWlsX3BvdzIgKHggOiBuYXRpdmVpbnQpID1cbiAgICBpZiB4IDw9IDBuIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0gQ2FtbC5OYXRpdmVpbnQucHJlZCB4IGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICAoKiBUaGUgbmV4dCBsaW5lIGlzIHN1cGVyZmx1b3VzIG9uIDMyLWJpdCBhcmNoaXRlY3R1cmVzLCBidXQgaXQncyBmYXN0ZXIgdG8gZG8gaXRcbiAgICAgICBhbnl3YXkgdGhhbiB0byBicmFuY2ggKilcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICBDYW1sLk5hdGl2ZWludC5zdWNjIHhcbiAgOztcblxuICAoKiogXCJmbG9vciBwb3dlciBvZiAyXCIgLSBMYXJnZXN0IHBvd2VyIG9mIDIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBmbG9vcl9wb3cyIHggPVxuICAgIGlmIHggPD0gMG4gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICBDYW1sLk5hdGl2ZWludC5zdWIgeCAoeCBsc3IgMSlcbiAgOztcblxuICBsZXQgaXNfcG93MiB4ID1cbiAgICBpZiB4IDw9IDBuIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIHggbGFuZCBDYW1sLk5hdGl2ZWludC5wcmVkIHggPSAwblxuICA7O1xuXG4gICgqIEMgc3R1YnMgZm9yIG5hdGl2ZWludCBjbHogYW5kIGN0eiB0byB1c2UgdGhlIENMWi9CU1IvQ1RaL0JTRiBpbnN0cnVjdGlvbiB3aGVyZSBwb3NzaWJsZSAqKVxuICBleHRlcm5hbCBjbHpcbiAgICA6ICAobmF0aXZlaW50W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2NselwiIFwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY2x6X3VuYm94ZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGN0elxuICAgIDogIChuYXRpdmVpbnRbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY3R6XCIgXCJCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jdHpfdW5ib3hlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgZmxvb3JfbG9nMiBpID1cbiAgICBpZiBQb2x5LiggPD0gKSBpIENhbWwuTmF0aXZlaW50Lnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJbTmF0aXZlaW50LmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCJcbiAgICAgICAgICAgWyBcIlwiLCBzZXhwX29mX25hdGl2ZWludCBpIF0pO1xuICAgIG51bV9iaXRzIC0gMSAtIGNseiBpXG4gIDs7XG5cbiAgKCoqIEhhY2tlcidzIERlbGlnaHQgU2Vjb25kIEVkaXRpb24gcDEwNiAqKVxuICBsZXQgY2VpbF9sb2cyIGkgPVxuICAgIGlmIFBvbHkuKCA8PSApIGkgQ2FtbC5OYXRpdmVpbnQuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIltOYXRpdmVpbnQuY2VpbF9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiXG4gICAgICAgICAgIFsgXCJcIiwgc2V4cF9vZl9uYXRpdmVpbnQgaSBdKTtcbiAgICBpZiBDYW1sLk5hdGl2ZWludC5lcXVhbCBpIENhbWwuTmF0aXZlaW50Lm9uZVxuICAgIHRoZW4gMFxuICAgIGVsc2UgbnVtX2JpdHMgLSBjbHogKENhbWwuTmF0aXZlaW50LnByZWQgaSlcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFBvdzJcblxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxubGV0ICggLyApID0gZGl2XG5sZXQgKCAqICkgPSBtdWxcbmxldCAoIC0gKSA9IHN1YlxubGV0ICggKyApID0gYWRkXG5sZXQgKCB+LSApID0gbmVnXG5sZXQgaW5jciByID0gciA6PSAhciArIG9uZVxubGV0IGRlY3IgciA9IHIgOj0gIXIgLSBvbmVcbmxldCBvZl9uYXRpdmVpbnQgdCA9IHRcbmxldCBvZl9uYXRpdmVpbnRfZXhuID0gb2ZfbmF0aXZlaW50XG5sZXQgdG9fbmF0aXZlaW50IHQgPSB0XG5sZXQgdG9fbmF0aXZlaW50X2V4biA9IHRvX25hdGl2ZWludFxubGV0IHBvcGNvdW50ID0gUG9wY291bnQubmF0aXZlaW50X3BvcGNvdW50XG5sZXQgb2ZfaW50ID0gQ29udi5pbnRfdG9fbmF0aXZlaW50XG5sZXQgb2ZfaW50X2V4biA9IG9mX2ludFxubGV0IHRvX2ludCA9IENvbnYubmF0aXZlaW50X3RvX2ludFxubGV0IHRvX2ludF9leG4gPSBDb252Lm5hdGl2ZWludF90b19pbnRfZXhuXG5sZXQgdG9faW50X3RydW5jID0gQ29udi5uYXRpdmVpbnRfdG9faW50X3RydW5jXG5sZXQgb2ZfaW50MzIgPSBDb252LmludDMyX3RvX25hdGl2ZWludFxubGV0IG9mX2ludDMyX2V4biA9IG9mX2ludDMyXG5sZXQgdG9faW50MzIgPSBDb252Lm5hdGl2ZWludF90b19pbnQzMlxubGV0IHRvX2ludDMyX2V4biA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyX2V4blxubGV0IHRvX2ludDMyX3RydW5jID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJfdHJ1bmNcbmxldCBvZl9pbnQ2NCA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50XG5sZXQgb2ZfaW50NjRfZXhuID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfZXhuXG5sZXQgb2ZfaW50NjRfdHJ1bmMgPSBDb252LmludDY0X3RvX25hdGl2ZWludF90cnVuY1xubGV0IHRvX2ludDY0ID0gQ29udi5uYXRpdmVpbnRfdG9faW50NjRcbmxldCBwb3cgYiBlID0gb2ZfaW50X2V4biAoSW50X21hdGguUHJpdmF0ZS5pbnRfcG93ICh0b19pbnRfZXhuIGIpICh0b19pbnRfZXhuIGUpKVxubGV0ICggKiogKSBiIGUgPSBwb3cgYiBlXG5cbm1vZHVsZSBQcmVfTyA9IHN0cnVjdFxuICBsZXQgKCArICkgPSAoICsgKVxuICBsZXQgKCAtICkgPSAoIC0gKVxuICBsZXQgKCAqICkgPSAoICogKVxuICBsZXQgKCAvICkgPSAoIC8gKVxuICBsZXQgKCB+LSApID0gKCB+LSApXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIChOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIDogQ29tcGFyaXNvbnMuSW5maXggd2l0aCB0eXBlIHQgOj0gdClcblxuICBsZXQgYWJzID0gYWJzXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfaW50X2V4blxuZW5kXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGluY2x1ZGUgUHJlX09cblxuICBpbmNsdWRlIEludF9tYXRoLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgaW5jbHVkZSBQcmVfT1xuXG4gICAgICBsZXQgcmVtID0gcmVtXG4gICAgICBsZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxuICAgICAgbGV0IG9mX2Zsb2F0ID0gb2ZfZmxvYXRcbiAgICAgIGxldCBvZl9zdHJpbmcgPSBULm9mX3N0cmluZ1xuICAgICAgbGV0IHRvX3N0cmluZyA9IFQudG9fc3RyaW5nXG4gICAgZW5kKVxuXG4gIGxldCAoIGxhbmQgKSA9IGJpdF9hbmRcbiAgbGV0ICggbG9yICkgPSBiaXRfb3JcbiAgbGV0ICggbHhvciApID0gYml0X3hvclxuICBsZXQgbG5vdCA9IGJpdF9ub3RcbiAgbGV0ICggbHNsICkgPSBzaGlmdF9sZWZ0XG4gIGxldCAoIGFzciApID0gc2hpZnRfcmlnaHRcbiAgbGV0ICggbHNyICkgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtOYXRpdmVpbnRdIGFuZCBbTmF0aXZlaW50Lk9dIGFncmVlIHZhbHVlLXdpc2UgKilcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuZXh0ZXJuYWwgYnN3YXAgOiB0IC0+IHQgPSBcIiVic3dhcF9uYXRpdmVcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqKVxuKCogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqKVxuKCogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIDIuMCBsaWNlbnNlLiBTZWUgLi4vVEhJUkQtUEFSVFkudHh0ICAqKVxuKCogIGZvciBkZXRhaWxzLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBMaXN0ID0gTGlzdDBcbmluY2x1ZGUgTWFwX2ludGZcblxubW9kdWxlIEZpbmlzaGVkX29yX3VuZmluaXNoZWQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYXBfaW50Zi5GaW5pc2hlZF9vcl91bmZpbmlzaGVkXG5cbiAgKCogVGhlc2UgdHdvIGZ1bmN0aW9ucyBhcmUgdGVzdGVkIGluIFt0ZXN0X21hcC5tbF0gdG8gbWFrZSBzdXJlIG91ciB1c2Ugb2ZcbiAgICAgW0NhbWwuT2JqLm1hZ2ljXSBpcyBjb3JyZWN0IGFuZCBzYWZlLiAqKVxuICBsZXQgb2ZfY29udGludWVfb3Jfc3RvcCA6IENvbnRpbnVlX29yX3N0b3AudCAtPiB0ID0gQ2FtbC5PYmoubWFnaWNcbiAgbGV0IHRvX2NvbnRpbnVlX29yX3N0b3AgOiB0IC0+IENvbnRpbnVlX29yX3N0b3AudCA9IENhbWwuT2JqLm1hZ2ljXG5lbmRcblxubW9kdWxlIE1lcmdlX2VsZW1lbnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYXBfaW50Zi5NZXJnZV9lbGVtZW50XG5cbiAgbGV0IGxlZnQgPSBmdW5jdGlvblxuICAgIHwgYFJpZ2h0IF8gLT4gTm9uZVxuICAgIHwgYExlZnQgbGVmdCB8IGBCb3RoIChsZWZ0LCBfKSAtPiBTb21lIGxlZnRcbiAgOztcblxuICBsZXQgcmlnaHQgPSBmdW5jdGlvblxuICAgIHwgYExlZnQgXyAtPiBOb25lXG4gICAgfCBgUmlnaHQgcmlnaHQgfCBgQm90aCAoXywgcmlnaHQpIC0+IFNvbWUgcmlnaHRcbiAgOztcblxuICBsZXQgbGVmdF92YWx1ZSB0IH5kZWZhdWx0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IGBSaWdodCBfIC0+IGRlZmF1bHRcbiAgICB8IGBMZWZ0IGxlZnQgfCBgQm90aCAobGVmdCwgXykgLT4gbGVmdFxuICA7O1xuXG4gIGxldCByaWdodF92YWx1ZSB0IH5kZWZhdWx0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IGBMZWZ0IF8gLT4gZGVmYXVsdFxuICAgIHwgYFJpZ2h0IHJpZ2h0IHwgYEJvdGggKF8sIHJpZ2h0KSAtPiByaWdodFxuICA7O1xuXG4gIGxldCB2YWx1ZXMgdCB+bGVmdF9kZWZhdWx0IH5yaWdodF9kZWZhdWx0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IGBMZWZ0IGxlZnQgLT4gbGVmdCwgcmlnaHRfZGVmYXVsdFxuICAgIHwgYFJpZ2h0IHJpZ2h0IC0+IGxlZnRfZGVmYXVsdCwgcmlnaHRcbiAgICB8IGBCb3RoIChsZWZ0LCByaWdodCkgLT4gbGVmdCwgcmlnaHRcbiAgOztcbmVuZFxuXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxuXG5leGNlcHRpb24gRHVwbGljYXRlIFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG5sZXQgKCkgPVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgRHVwbGljYXRlXSAoZnVuY3Rpb25cbiAgICB8IER1cGxpY2F0ZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJtYXAubWwuRHVwbGljYXRlXCJcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuOztcblxuW0BAQGVuZF1cblxubW9kdWxlIFRyZWUwID0gc3RydWN0XG4gIHR5cGUgKCdrLCAndikgdCA9XG4gICAgfCBFbXB0eVxuICAgIHwgTGVhZiBvZiAnayAqICd2XG4gICAgfCBOb2RlIG9mICgnaywgJ3YpIHQgKiAnayAqICd2ICogKCdrLCAndikgdCAqIGludFxuXG4gIHR5cGUgKCdrLCAndikgdHJlZSA9ICgnaywgJ3YpIHRcblxuICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IDBcbiAgICB8IExlYWYgXyAtPiAxXG4gICAgfCBOb2RlIChfLCBfLCBfLCBfLCBoKSAtPiBoXG4gIDs7XG5cbiAgbGV0IGludmFyaWFudHMgPVxuICAgIGxldCBpbl9yYW5nZSBsb3dlciB1cHBlciBjb21wYXJlX2tleSBrID1cbiAgICAgIChtYXRjaCBsb3dlciB3aXRoXG4gICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgICB8IFNvbWUgbG93ZXIgLT4gY29tcGFyZV9rZXkgbG93ZXIgayA8IDApXG4gICAgICAmJlxuICAgICAgbWF0Y2ggdXBwZXIgd2l0aFxuICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgIHwgU29tZSB1cHBlciAtPiBjb21wYXJlX2tleSBrIHVwcGVyIDwgMFxuICAgIGluXG4gICAgbGV0IHJlYyBsb29wIGxvd2VyIHVwcGVyIGNvbXBhcmVfa2V5IHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTGVhZiAoaywgXykgLT4gaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9rZXkga1xuICAgICAgfCBOb2RlIChsLCBrLCBfLCByLCBoKSAtPlxuICAgICAgICBsZXQgaGwgPSBoZWlnaHQgbFxuICAgICAgICBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgICBhYnMgKGhsIC0gaHIpIDw9IDJcbiAgICAgICAgJiYgaCA9IG1heCBobCBociArIDFcbiAgICAgICAgJiYgaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9rZXkga1xuICAgICAgICAmJiBsb29wIGxvd2VyIChTb21lIGspIGNvbXBhcmVfa2V5IGxcbiAgICAgICAgJiYgbG9vcCAoU29tZSBrKSB1cHBlciBjb21wYXJlX2tleSByXG4gICAgaW5cbiAgICBmdW4gdCB+Y29tcGFyZV9rZXkgLT4gbG9vcCBOb25lIE5vbmUgY29tcGFyZV9rZXkgdFxuICA7O1xuXG4gICgqIHByZWNvbmRpdGlvbjogfGhlaWdodChsKSAtIGhlaWdodChyKXwgPD0gMiAqKVxuICBsZXQgY3JlYXRlIGwgeCBkIHIgPVxuICAgIGxldCBobCA9IGhlaWdodCBsXG4gICAgYW5kIGhyID0gaGVpZ2h0IHIgaW5cbiAgICBpZiBobCA9IDAgJiYgaHIgPSAwXG4gICAgdGhlbiBMZWFmICh4LCBkKVxuICAgIGVsc2UgTm9kZSAobCwgeCwgZCwgciwgaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpXG4gIDs7XG5cbiAgbGV0IHNpbmdsZXRvbiBrZXkgZGF0YSA9IExlYWYgKGtleSwgZGF0YSlcblxuICAoKiBXZSBtdXN0IGNhbGwgW2ZdIHdpdGggaW5jcmVhc2luZyBpbmRleGVzLCBiZWNhdXNlIHRoZSBiaW5fcHJvdCByZWFkZXIgaW5cbiAgICAgQ29yZS5NYXAgbmVlZHMgaXQuICopXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mID1cbiAgICBsZXQgcmVjIGxvb3AgbiB+ZiBpIDogKF8sIF8pIHQgPVxuICAgICAgbWF0Y2ggbiB3aXRoXG4gICAgICB8IDAgLT4gRW1wdHlcbiAgICAgIHwgMSAtPlxuICAgICAgICBsZXQgaywgdiA9IGYgaSBpblxuICAgICAgICBMZWFmIChrLCB2KVxuICAgICAgfCAyIC0+XG4gICAgICAgIGxldCBrbCwgdmwgPSBmIGkgaW5cbiAgICAgICAgbGV0IGssIHYgPSBmIChpICsgMSkgaW5cbiAgICAgICAgTm9kZSAoTGVhZiAoa2wsIHZsKSwgaywgdiwgRW1wdHksIDIpXG4gICAgICB8IDMgLT5cbiAgICAgICAgbGV0IGtsLCB2bCA9IGYgaSBpblxuICAgICAgICBsZXQgaywgdiA9IGYgKGkgKyAxKSBpblxuICAgICAgICBsZXQga3IsIHZyID0gZiAoaSArIDIpIGluXG4gICAgICAgIE5vZGUgKExlYWYgKGtsLCB2bCksIGssIHYsIExlYWYgKGtyLCB2ciksIDIpXG4gICAgICB8IG4gLT5cbiAgICAgICAgbGV0IGxlZnRfbGVuZ3RoID0gbiBsc3IgMSBpblxuICAgICAgICBsZXQgcmlnaHRfbGVuZ3RoID0gbiAtIGxlZnRfbGVuZ3RoIC0gMSBpblxuICAgICAgICBsZXQgbGVmdCA9IGxvb3AgbGVmdF9sZW5ndGggfmYgaSBpblxuICAgICAgICBsZXQgaywgdiA9IGYgKGkgKyBsZWZ0X2xlbmd0aCkgaW5cbiAgICAgICAgbGV0IHJpZ2h0ID0gbG9vcCByaWdodF9sZW5ndGggfmYgKGkgKyBsZWZ0X2xlbmd0aCArIDEpIGluXG4gICAgICAgIGNyZWF0ZSBsZWZ0IGsgdiByaWdodFxuICAgIGluXG4gICAgbG9vcCBsZW4gfmYgMFxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGFycmF5X2xlbmd0aCA9IEFycmF5Lmxlbmd0aCBhcnJheSBpblxuICAgIGxldCBuZXh0ID1cbiAgICAgIGlmIGFycmF5X2xlbmd0aCA8IDJcbiAgICAgICAgIHx8XG4gICAgICAgICBsZXQgazAsIF8gPSBhcnJheS4oMCkgaW5cbiAgICAgICAgIGxldCBrMSwgXyA9IGFycmF5LigxKSBpblxuICAgICAgICAgY29tcGFyZV9rZXkgazAgazEgPCAwXG4gICAgICB0aGVuIGZ1biBpIC0+IGFycmF5LihpKVxuICAgICAgZWxzZSBmdW4gaSAtPiBhcnJheS4oYXJyYXlfbGVuZ3RoIC0gMSAtIGkpXG4gICAgaW5cbiAgICBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuOmFycmF5X2xlbmd0aCB+ZjpuZXh0LCBhcnJheV9sZW5ndGhcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IGFycmF5IH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggYXJyYXkgd2l0aFxuICAgIHwgW3x8XSB8IFt8IF8gfF0gLT4gUmVzdWx0Lk9rIChvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2tleSlcbiAgICB8IF8gLT5cbiAgICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgICBsZXQgaW5jcmVhc2luZyA9XG4gICAgICAgICAgbWF0Y2ggY29tcGFyZV9rZXkgKGZzdCBhcnJheS4oMCkpIChmc3QgYXJyYXkuKDEpKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT4gaSA8IDBcbiAgICAgICAgaW5cbiAgICAgICAgZm9yIGkgPSAxIHRvIEFycmF5Lmxlbmd0aCBhcnJheSAtIDIgZG9cbiAgICAgICAgICBtYXRjaCBjb21wYXJlX2tleSAoZnN0IGFycmF5LihpKSkgKGZzdCBhcnJheS4oaSArIDEpKSB3aXRoXG4gICAgICAgICAgfCAwIC0+IHIucmV0dXJuIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGR1cGxpY2F0ZWQgZWxlbWVudHNcIilcbiAgICAgICAgICB8IGkgLT5cbiAgICAgICAgICAgIGlmIFBvbHkuKCA8PiApIChpIDwgMCkgaW5jcmVhc2luZ1xuICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICByLnJldHVyblxuICAgICAgICAgICAgICAgIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9zb3J0ZWRfYXJyYXk6IGVsZW1lbnRzIGFyZSBub3Qgb3JkZXJlZFwiKVxuICAgICAgICBkb25lO1xuICAgICAgICBSZXN1bHQuT2sgKG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfa2V5KSlcbiAgOztcblxuICAoKiBwcmVjb25kaXRpb246IHxoZWlnaHQobCkgLSBoZWlnaHQocil8IDw9IDMgKilcbiAgbGV0IGJhbCBsIHggZCByID1cbiAgICBsZXQgaGwgPSBoZWlnaHQgbCBpblxuICAgIGxldCBociA9IGhlaWdodCByIGluXG4gICAgaWYgaGwgPiBociArIDJcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGhlaWdodChMZWFmKSA9IDEgJiYgMSBpcyBub3QgbGFyZ2VyIHRoYW4gaHIgKyAyICopXG4gICAgICB8IE5vZGUgKGxsLCBsdiwgbGQsIGxyLCBfKSAtPlxuICAgICAgICBpZiBoZWlnaHQgbGwgPj0gaGVpZ2h0IGxyXG4gICAgICAgIHRoZW4gY3JlYXRlIGxsIGx2IGxkIChjcmVhdGUgbHIgeCBkIHIpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIG1hdGNoIGxyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgfCBMZWFmIChscnYsIGxyZCkgLT4gY3JlYXRlIChjcmVhdGUgbGwgbHYgbGQgRW1wdHkpIGxydiBscmQgKGNyZWF0ZSBFbXB0eSB4IGQgcilcbiAgICAgICAgICB8IE5vZGUgKGxybCwgbHJ2LCBscmQsIGxyciwgXykgLT5cbiAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxkIGxybCkgbHJ2IGxyZCAoY3JlYXRlIGxyciB4IGQgcikpKVxuICAgIGVsc2UgaWYgaHIgPiBobCArIDJcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGhlaWdodChMZWFmKSA9IDEgJiYgMSBpcyBub3QgbGFyZ2VyIHRoYW4gaGwgKyAyICopXG4gICAgICB8IE5vZGUgKHJsLCBydiwgcmQsIHJyLCBfKSAtPlxuICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsXG4gICAgICAgIHRoZW4gY3JlYXRlIChjcmVhdGUgbCB4IGQgcmwpIHJ2IHJkIHJyXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgfCBMZWFmIChybHYsIHJsZCkgLT4gY3JlYXRlIChjcmVhdGUgbCB4IGQgRW1wdHkpIHJsdiBybGQgKGNyZWF0ZSBFbXB0eSBydiByZCBycilcbiAgICAgICAgICB8IE5vZGUgKHJsbCwgcmx2LCBybGQsIHJsciwgXykgLT5cbiAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsbCkgcmx2IHJsZCAoY3JlYXRlIHJsciBydiByZCBycikpKVxuICAgIGVsc2UgY3JlYXRlIGwgeCBkIHJcbiAgOztcblxuICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IHJhaXNlX2tleV9hbHJlYWR5X3ByZXNlbnQgfmtleSB+c2V4cF9vZl9rZXkgPVxuICAgIEVycm9yLnJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2UgXCJbTWFwLmFkZF9leG5dIGdvdCBrZXkgYWxyZWFkeSBwcmVzZW50XCIgWyBcImtleVwiLCBrZXkgfD4gc2V4cF9vZl9rZXkgXSlcbiAgOztcblxuICBtb2R1bGUgQWRkX29yX3NldCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB8IEFkZF9leG5faW50ZXJuYWxcbiAgICAgIHwgQWRkX2V4blxuICAgICAgfCBTZXRcbiAgZW5kXG5cblxuICBsZXQgcmVjIGZpbmRfYW5kX2FkZF9vcl9zZXRcbiAgICAgICAgICAgIHRcbiAgICAgICAgICAgIH5sZW5ndGhcbiAgICAgICAgICAgIH5rZXk6eFxuICAgICAgICAgICAgfmRhdGFcbiAgICAgICAgICAgIH5jb21wYXJlX2tleVxuICAgICAgICAgICAgfnNleHBfb2Zfa2V5XG4gICAgICAgICAgICB+KGFkZF9vcl9zZXQgOiBBZGRfb3Jfc2V0LnQpXG4gICAgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTGVhZiAoeCwgZGF0YSksIGxlbmd0aCArIDFcbiAgICB8IExlYWYgKHYsIGQpIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHggdiBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBhZGRfb3Jfc2V0IHdpdGhcbiAgICAgICAgfCBBZGRfZXhuX2ludGVybmFsIC0+IEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBEdXBsaWNhdGVcbiAgICAgICAgfCBBZGRfZXhuIC0+IHJhaXNlX2tleV9hbHJlYWR5X3ByZXNlbnQgfmtleTp4IH5zZXhwX29mX2tleVxuICAgICAgICB8IFNldCAtPiBMZWFmICh4LCBkYXRhKSwgbGVuZ3RoKVxuICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgdGhlbiBOb2RlIChMZWFmICh4LCBkYXRhKSwgdiwgZCwgRW1wdHksIDIpLCBsZW5ndGggKyAxXG4gICAgICBlbHNlIE5vZGUgKEVtcHR5LCB2LCBkLCBMZWFmICh4LCBkYXRhKSwgMiksIGxlbmd0aCArIDFcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIGgpIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHggdiBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBhZGRfb3Jfc2V0IHdpdGhcbiAgICAgICAgfCBBZGRfZXhuX2ludGVybmFsIC0+IEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBEdXBsaWNhdGVcbiAgICAgICAgfCBBZGRfZXhuIC0+IHJhaXNlX2tleV9hbHJlYWR5X3ByZXNlbnQgfmtleTp4IH5zZXhwX29mX2tleVxuICAgICAgICB8IFNldCAtPiBOb2RlIChsLCB4LCBkYXRhLCByLCBoKSwgbGVuZ3RoKVxuICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCBsLCBsZW5ndGggPVxuICAgICAgICAgIGZpbmRfYW5kX2FkZF9vcl9zZXQgfmxlbmd0aCB+a2V5OnggfmRhdGEgbCB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5IH5hZGRfb3Jfc2V0XG4gICAgICAgIGluXG4gICAgICAgIGJhbCBsIHYgZCByLCBsZW5ndGgpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHIsIGxlbmd0aCA9XG4gICAgICAgICAgZmluZF9hbmRfYWRkX29yX3NldCB+bGVuZ3RoIH5rZXk6eCB+ZGF0YSByIH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgfmFkZF9vcl9zZXRcbiAgICAgICAgaW5cbiAgICAgICAgYmFsIGwgdiBkIHIsIGxlbmd0aClcbiAgOztcblxuICBsZXQgYWRkX2V4biB0IH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5ID1cbiAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0IHQgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgfmFkZF9vcl9zZXQ6QWRkX2V4blxuICA7O1xuXG4gIGxldCBhZGRfZXhuX2ludGVybmFsIHQgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgPVxuICAgIGZpbmRfYW5kX2FkZF9vcl9zZXRcbiAgICAgIHRcbiAgICAgIH5sZW5ndGhcbiAgICAgIH5rZXlcbiAgICAgIH5kYXRhXG4gICAgICB+Y29tcGFyZV9rZXlcbiAgICAgIH5zZXhwX29mX2tleVxuICAgICAgfmFkZF9vcl9zZXQ6QWRkX2V4bl9pbnRlcm5hbFxuICA7O1xuXG4gIGxldCBzZXQgdCB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5ID1cbiAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0XG4gICAgICB0XG4gICAgICB+bGVuZ3RoXG4gICAgICB+a2V5XG4gICAgICB+ZGF0YVxuICAgICAgfmNvbXBhcmVfa2V5XG4gICAgICB+c2V4cF9vZl9rZXk6KGZ1biBfIC0+IExpc3QgW10pXG4gICAgICB+YWRkX29yX3NldDpTZXRcbiAgOztcblxuICBsZXQgc2V0JyB0IGtleSBkYXRhIH5jb21wYXJlX2tleSA9IGZzdCAoc2V0IHQgfmxlbmd0aDowIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5KVxuXG4gIG1vZHVsZSBCdWlsZF9pbmNyZWFzaW5nID0gc3RydWN0XG4gICAgbW9kdWxlIEZyYWdtZW50ID0gc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAoJ2ssICd2KSB0ID1cbiAgICAgICAgeyBsZWZ0X3N1YnRyZWUgOiAoJ2ssICd2KSB0XG4gICAgICAgIDsga2V5IDogJ2tcbiAgICAgICAgOyBkYXRhIDogJ3ZcbiAgICAgICAgfVxuXG4gICAgICBsZXQgc2luZ2xldG9uX3RvX3RyZWVfZXhuID0gZnVuY3Rpb25cbiAgICAgICAgfCB7IGxlZnRfc3VidHJlZSA9IEVtcHR5OyBrZXk7IGRhdGEgfSAtPiBzaW5nbGV0b24ga2V5IGRhdGFcbiAgICAgICAgfCBfIC0+IGZhaWx3aXRoIFwiTWFwLnNpbmdsZXRvbl90b190cmVlX2V4bjogbm90IGEgc2luZ2xldG9uXCJcbiAgICAgIDs7XG5cbiAgICAgIGxldCBzaW5nbGV0b24gfmtleSB+ZGF0YSA9IHsgbGVmdF9zdWJ0cmVlID0gRW1wdHk7IGtleTsgZGF0YSB9XG5cbiAgICAgICgqIHByZWNvbmRpdGlvbjogfGhlaWdodChsLmxlZnRfc3VidHJlZSkgLSBoZWlnaHQocil8IDw9IDIsXG4gICAgICAgICBtYXhfa2V5KGwpIDwgbWluX2tleShyKVxuICAgICAgKilcbiAgICAgIGxldCBjb2xsYXBzZSBsIHIgPSBjcmVhdGUgbC5sZWZ0X3N1YnRyZWUgbC5rZXkgbC5kYXRhIHJcblxuICAgICAgKCogcHJlY29uZGl0aW9uOiB8aGVpZ2h0KGwubGVmdF9zdWJ0cmVlKSAtIGhlaWdodChyLmxlZnRfc3VidHJlZSl8IDw9IDIsXG4gICAgICAgICBtYXhfa2V5KGwpIDwgbWluX2tleShyKVxuICAgICAgKilcbiAgICAgIGxldCBqb2luIGwgciA9IHsgciB3aXRoIGxlZnRfc3VidHJlZSA9IGNvbGxhcHNlIGwgci5sZWZ0X3N1YnRyZWUgfVxuICAgICAgbGV0IG1heF9rZXkgdCA9IHQua2V5XG4gICAgZW5kXG5cbiAgICAoKiogQnVpbGQgdHJlZXMgZnJvbSBzaW5nbGV0b25zIGluIGEgYmFsYW5jZWQgd2F5IGJ5IHVzaW5nIHNrZXcgYmluYXJ5IGVuY29kaW5nLlxuICAgICAgICBFYWNoIGxldmVsIGNvbnRhaW5zIHRyZWVzIG9mIHRoZSBzYW1lIGhlaWdodCwgY29uc2VjdXRpdmUgbGV2ZWxzIGhhdmUgY29uc2VjdXRpdmVcbiAgICAgICAgaGVpZ2h0cy4gVGhlcmUgYXJlIG5vIGdhcHMuIFRoZSBmaXJzdCBsZXZlbCBhcmUgc2luZ2xlIGtleXMuXG4gICAgKilcbiAgICB0eXBlICgnaywgJ3YpIHQgPVxuICAgICAgfCBaZXJvIG9mIHVuaXRcbiAgICAgICgqIFt1bml0XSB0byBtYWtlIHBhdHRlcm4gbWF0Y2hpbmcgZmFzdGVyICopXG4gICAgICB8IE9uZSBvZiAoJ2ssICd2KSB0ICogKCdrLCAndikgRnJhZ21lbnQudFxuICAgICAgfCBUd28gb2YgKCdrLCAndikgdCAqICgnaywgJ3YpIEZyYWdtZW50LnQgKiAoJ2ssICd2KSBGcmFnbWVudC50XG5cbiAgICBsZXQgZW1wdHkgPSBaZXJvICgpXG5cbiAgICBsZXQgYWRkX3VuY2hlY2tlZCA9XG4gICAgICBsZXQgcmVjIGdvIHQgeCA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IFplcm8gKCkgLT4gT25lICh0LCB4KVxuICAgICAgICB8IE9uZSAodCwgeSkgLT4gVHdvICh0LCB5LCB4KVxuICAgICAgICB8IFR3byAodCwgeiwgeSkgLT4gT25lIChnbyB0IChGcmFnbWVudC5qb2luIHogeSksIHgpXG4gICAgICBpblxuICAgICAgZnVuIHQgfmtleSB+ZGF0YSAtPiBnbyB0IChGcmFnbWVudC5zaW5nbGV0b24gfmtleSB+ZGF0YSlcbiAgICA7O1xuXG4gICAgbGV0IHRvX3RyZWVfdW5jaGVja2VkID1cbiAgICAgIGxldCByZWMgZ28gdCByID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgWmVybyAoKSAtPiByXG4gICAgICAgIHwgT25lICh0LCBsKSAtPiBnbyB0IChGcmFnbWVudC5jb2xsYXBzZSBsIHIpXG4gICAgICAgIHwgVHdvICh0LCBsbCwgbCkgLT4gZ28gdCAoRnJhZ21lbnQuY29sbGFwc2UgKEZyYWdtZW50LmpvaW4gbGwgbCkgcilcbiAgICAgIGluXG4gICAgICBmdW5jdGlvblxuICAgICAgfCBaZXJvICgpIC0+IEVtcHR5XG4gICAgICB8IE9uZSAodCwgcikgLT4gZ28gdCAoRnJhZ21lbnQuc2luZ2xldG9uX3RvX3RyZWVfZXhuIHIpXG4gICAgICB8IFR3byAodCwgbCwgcikgLT4gZ28gKE9uZSAodCwgbCkpIChGcmFnbWVudC5zaW5nbGV0b25fdG9fdHJlZV9leG4gcilcbiAgICA7O1xuXG4gICAgbGV0IG1heF9rZXkgPSBmdW5jdGlvblxuICAgICAgfCBaZXJvICgpIC0+IE5vbmVcbiAgICAgIHwgT25lIChfLCByKSB8IFR3byAoXywgXywgcikgLT4gU29tZSAoRnJhZ21lbnQubWF4X2tleSByKVxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIHNlcSB+Y29tcGFyZV9rZXkgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgICAgbGV0IGJ1aWxkZXIsIGxlbmd0aCA9XG4gICAgICAgIFNlcXVlbmNlLmZvbGRcbiAgICAgICAgICBzZXFcbiAgICAgICAgICB+aW5pdDooQnVpbGRfaW5jcmVhc2luZy5lbXB0eSwgMClcbiAgICAgICAgICB+ZjooZnVuIChidWlsZGVyLCBsZW5ndGgpIChrZXksIGRhdGEpIC0+XG4gICAgICAgICAgICBtYXRjaCBCdWlsZF9pbmNyZWFzaW5nLm1heF9rZXkgYnVpbGRlciB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgcHJldl9rZXkgd2hlbiBjb21wYXJlX2tleSBwcmV2X2tleSBrZXkgPj0gMCAtPlxuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2ZfaW5jcmVhc2luZ19zZXF1ZW5jZTogbm9uLWluY3JlYXNpbmcga2V5XCIpXG4gICAgICAgICAgICB8IF8gLT4gQnVpbGRfaW5jcmVhc2luZy5hZGRfdW5jaGVja2VkIGJ1aWxkZXIgfmtleSB+ZGF0YSwgbGVuZ3RoICsgMSlcbiAgICAgIGluXG4gICAgICBPayAoQnVpbGRfaW5jcmVhc2luZy50b190cmVlX3VuY2hlY2tlZCBidWlsZGVyLCBsZW5ndGgpKVxuICA7O1xuXG4gICgqIExpa2UgW2JhbF0gYnV0IGFsbG93cyBhbnkgZGlmZmVyZW5jZSBpbiBoZWlnaHQgYmV0d2VlbiBbbF0gYW5kIFtyXS5cblxuICAgICBPKHxoZWlnaHQgbCAtIGhlaWdodCByfCkgKilcbiAgbGV0IHJlYyBqb2luIGwgayBkIHIgfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCBsLCByIHdpdGhcbiAgICB8IEVtcHR5LCBfIC0+IHNldCcgciBrIGQgfmNvbXBhcmVfa2V5XG4gICAgfCBfLCBFbXB0eSAtPiBzZXQnIGwgayBkIH5jb21wYXJlX2tleVxuICAgIHwgTGVhZiAobGssIGxkKSwgXyAtPiBzZXQnIChzZXQnIHIgayBkIH5jb21wYXJlX2tleSkgbGsgbGQgfmNvbXBhcmVfa2V5XG4gICAgfCBfLCBMZWFmIChyaywgcmQpIC0+IHNldCcgKHNldCcgbCBrIGQgfmNvbXBhcmVfa2V5KSByayByZCB+Y29tcGFyZV9rZXlcbiAgICB8IE5vZGUgKGxsLCBsaywgbGQsIGxyLCBsaCksIE5vZGUgKHJsLCByaywgcmQsIHJyLCByaCkgLT5cbiAgICAgICgqIFtiYWxdIHJlcXVpcmVzIGhlaWdodCBkaWZmZXJlbmNlIDw9IDMuICopXG4gICAgICBpZiBsaCA+IHJoICsgM1xuICAgICAgKCogW2hlaWdodCBsciA+PSBoZWlnaHQgcl0sXG4gICAgICAgICB0aGVyZWZvcmUgW2hlaWdodCAoam9pbiBsciBrIGQgciAuLi4pXSBpcyBbaGVpZ2h0IHJsICsgMV0gb3IgW2hlaWdodCBybF1cbiAgICAgICAgIHRoZXJlZm9yZSB0aGUgaGVpZ2h0IGRpZmZlcmVuY2Ugd2l0aCBbbGxdIHdpbGwgYmUgPD0gMyAqKVxuICAgICAgdGhlbiBiYWwgbGwgbGsgbGQgKGpvaW4gbHIgayBkIHIgfmNvbXBhcmVfa2V5KVxuICAgICAgZWxzZSBpZiByaCA+IGxoICsgM1xuICAgICAgdGhlbiBiYWwgKGpvaW4gbCBrIGQgcmwgfmNvbXBhcmVfa2V5KSByayByZCByclxuICAgICAgZWxzZSBiYWwgbCBrIGQgclxuICA7O1xuXG4gIGxldCByZWMgc3BsaXQgdCB4IH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eSwgTm9uZSwgRW1wdHlcbiAgICB8IExlYWYgKGssIGQpIC0+XG4gICAgICBsZXQgY21wID0gY29tcGFyZV9rZXkgeCBrIGluXG4gICAgICBpZiBjbXAgPSAwXG4gICAgICB0aGVuIEVtcHR5LCBTb21lIChrLCBkKSwgRW1wdHlcbiAgICAgIGVsc2UgaWYgY21wIDwgMFxuICAgICAgdGhlbiBFbXB0eSwgTm9uZSwgdFxuICAgICAgZWxzZSB0LCBOb25lLCBFbXB0eVxuICAgIHwgTm9kZSAobCwgaywgZCwgciwgXykgLT5cbiAgICAgIGxldCBjbXAgPSBjb21wYXJlX2tleSB4IGsgaW5cbiAgICAgIGlmIGNtcCA9IDBcbiAgICAgIHRoZW4gbCwgU29tZSAoaywgZCksIHJcbiAgICAgIGVsc2UgaWYgY21wIDwgMFxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCBsbCwgbWF5YmUsIGxyID0gc3BsaXQgbCB4IH5jb21wYXJlX2tleSBpblxuICAgICAgICBsbCwgbWF5YmUsIGpvaW4gbHIgayBkIHIgfmNvbXBhcmVfa2V5KVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBybCwgbWF5YmUsIHJyID0gc3BsaXQgciB4IH5jb21wYXJlX2tleSBpblxuICAgICAgICBqb2luIGwgayBkIHJsIH5jb21wYXJlX2tleSwgbWF5YmUsIHJyKVxuICA7O1xuXG4gIGxldCBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgdCB+aW50byB4IH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGxlZnQsIGJvdW5kYXJ5X29wdCwgcmlnaHQgPSBzcGxpdCB0IHggfmNvbXBhcmVfa2V5IGluXG4gICAgbWF0Y2ggYm91bmRhcnlfb3B0IHdpdGhcbiAgICB8IE5vbmUgLT4gbGVmdCwgcmlnaHRcbiAgICB8IFNvbWUgKGtleSwgZGF0YSkgLT5cbiAgICAgIGxldCBpbnNlcnRfaW50byB0cmVlID0gZnN0IChzZXQgdHJlZSB+a2V5IH5kYXRhIH5sZW5ndGg6MCB+Y29tcGFyZV9rZXkpIGluXG4gICAgICAobWF0Y2ggaW50byB3aXRoXG4gICAgICAgfCBgTGVmdCAtPiBpbnNlcnRfaW50byBsZWZ0LCByaWdodFxuICAgICAgIHwgYFJpZ2h0IC0+IGxlZnQsIGluc2VydF9pbnRvIHJpZ2h0KVxuICA7O1xuXG4gIGxldCBzcGxpdF9yYW5nZVxuICAgICAgICB0XG4gICAgICAgIH4obG93ZXJfYm91bmQgOiAnYSBNYXliZV9ib3VuZC50KVxuICAgICAgICB+KHVwcGVyX2JvdW5kIDogJ2EgTWF5YmVfYm91bmQudClcbiAgICAgICAgfmNvbXBhcmVfa2V5XG4gICAgPVxuICAgIGlmIE1heWJlX2JvdW5kLmJvdW5kc19jcm9zc2VkXG4gICAgICAgICB+Y29tcGFyZTpjb21wYXJlX2tleVxuICAgICAgICAgfmxvd2VyOmxvd2VyX2JvdW5kXG4gICAgICAgICB+dXBwZXI6dXBwZXJfYm91bmRcbiAgICB0aGVuIGVtcHR5LCBlbXB0eSwgZW1wdHlcbiAgICBlbHNlIChcbiAgICAgIGxldCBsZWZ0LCBtaWRfYW5kX3JpZ2h0ID1cbiAgICAgICAgbWF0Y2ggbG93ZXJfYm91bmQgd2l0aFxuICAgICAgICB8IFVuYm91bmRlZCAtPiBlbXB0eSwgdFxuICAgICAgICB8IEluY2wgbGIgLT4gc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IH5pbnRvOmBSaWdodCB0IGxiIH5jb21wYXJlX2tleVxuICAgICAgICB8IEV4Y2wgbGIgLT4gc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IH5pbnRvOmBMZWZ0IHQgbGIgfmNvbXBhcmVfa2V5XG4gICAgICBpblxuICAgICAgbGV0IG1pZCwgcmlnaHQgPVxuICAgICAgICBtYXRjaCB1cHBlcl9ib3VuZCB3aXRoXG4gICAgICAgIHwgVW5ib3VuZGVkIC0+IG1pZF9hbmRfcmlnaHQsIGVtcHR5XG4gICAgICAgIHwgSW5jbCBsYiAtPiBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgfmludG86YExlZnQgbWlkX2FuZF9yaWdodCBsYiB+Y29tcGFyZV9rZXlcbiAgICAgICAgfCBFeGNsIGxiIC0+XG4gICAgICAgICAgc3BsaXRfYW5kX3JlaW5zZXJ0X2JvdW5kYXJ5IH5pbnRvOmBSaWdodCBtaWRfYW5kX3JpZ2h0IGxiIH5jb21wYXJlX2tleVxuICAgICAgaW5cbiAgICAgIGxlZnQsIG1pZCwgcmlnaHQpXG4gIDs7XG5cbiAgbGV0IHJlYyBmaW5kIHQgeCB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiAodiwgZCkgLT4gaWYgY29tcGFyZV9rZXkgeCB2ID0gMCB0aGVuIFNvbWUgZCBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHggdiBpblxuICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIGQgZWxzZSBmaW5kIChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKSB4IH5jb21wYXJlX2tleVxuICA7O1xuXG4gIGxldCBhZGRfbXVsdGkgdCB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgZGF0YSA9IGRhdGEgOjogT3B0aW9uLnZhbHVlIChmaW5kIHQga2V5IH5jb21wYXJlX2tleSkgfmRlZmF1bHQ6W10gaW5cbiAgICBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhIHQgfmNvbXBhcmVfa2V5XG4gIDs7XG5cbiAgbGV0IGZpbmRfbXVsdGkgdCB4IH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggZmluZCB0IHggfmNvbXBhcmVfa2V5IHdpdGhcbiAgICB8IE5vbmUgLT4gW11cbiAgICB8IFNvbWUgbCAtPiBsXG4gIDs7XG5cbiAgbGV0IGZpbmRfZXhuID1cbiAgICBsZXQgaWZfbm90X2ZvdW5kIGtleSB+c2V4cF9vZl9rZXkgPVxuICAgICAgcmFpc2UgKE5vdF9mb3VuZF9zIChMaXN0IFsgQXRvbSBcIk1hcC5maW5kX2V4bjogbm90IGZvdW5kXCI7IHNleHBfb2Zfa2V5IGtleSBdKSlcbiAgICBpblxuICAgIGxldCByZWMgZmluZF9leG4gdCB4IH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGlmX25vdF9mb3VuZCB4IH5zZXhwX29mX2tleVxuICAgICAgfCBMZWFmICh2LCBkKSAtPiBpZiBjb21wYXJlX2tleSB4IHYgPSAwIHRoZW4gZCBlbHNlIGlmX25vdF9mb3VuZCB4IH5zZXhwX29mX2tleVxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHggdiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIGQgZWxzZSBmaW5kX2V4biAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcikgeCB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5XG4gICAgaW5cbiAgICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gICAgZmluZF9leG5cbiAgOztcblxuICBsZXQgbWVtIHQgeCB+Y29tcGFyZV9rZXkgPSBPcHRpb24uaXNfc29tZSAoZmluZCB0IHggfmNvbXBhcmVfa2V5KVxuXG4gIGxldCByZWMgbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIChrLCBkKSAtPiBTb21lIChrLCBkKVxuICAgIHwgTm9kZSAoRW1wdHksIGssIGQsIF8sIF8pIC0+IFNvbWUgKGssIGQpXG4gICAgfCBOb2RlIChsLCBfLCBfLCBfLCBfKSAtPiBtaW5fZWx0IGxcbiAgOztcblxuICBleGNlcHRpb24gTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxuICBsZXQgKCkgPVxuICAgIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZFxuICAgICAgWyVleHRlbnNpb25fY29uc3RydWN0b3IgTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcF1cbiAgICAgIChmdW5jdGlvblxuICAgICAgICB8IE1hcF9taW5fZWx0X2V4bl9vZl9lbXB0eV9tYXAgLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkF0b20gXCJtYXAubWwuVHJlZTAuTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBleGNlcHRpb24gTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxuICBsZXQgKCkgPVxuICAgIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZFxuICAgICAgWyVleHRlbnNpb25fY29uc3RydWN0b3IgTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcF1cbiAgICAgIChmdW5jdGlvblxuICAgICAgICB8IE1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXAgLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkF0b20gXCJtYXAubWwuVHJlZTAuTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgbWluX2VsdF9leG4gdCA9XG4gICAgbWF0Y2ggbWluX2VsdCB0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2UgTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcFxuICAgIHwgU29tZSB2IC0+IHZcbiAgOztcblxuICBsZXQgcmVjIG1heF9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiAoaywgZCkgLT4gU29tZSAoaywgZClcbiAgICB8IE5vZGUgKF8sIGssIGQsIEVtcHR5LCBfKSAtPiBTb21lIChrLCBkKVxuICAgIHwgTm9kZSAoXywgXywgXywgciwgXykgLT4gbWF4X2VsdCByXG4gIDs7XG5cbiAgbGV0IG1heF9lbHRfZXhuIHQgPVxuICAgIG1hdGNoIG1heF9lbHQgdCB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIE1hcF9tYXhfZWx0X2V4bl9vZl9lbXB0eV9tYXBcbiAgICB8IFNvbWUgdiAtPiB2XG4gIDs7XG5cbiAgbGV0IHJlYyByZW1vdmVfbWluX2VsdCB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLnJlbW92ZV9taW5fZWx0XCJcbiAgICB8IExlYWYgXyAtPiBFbXB0eVxuICAgIHwgTm9kZSAoRW1wdHksIF8sIF8sIHIsIF8pIC0+IHJcbiAgICB8IE5vZGUgKGwsIHgsIGQsIHIsIF8pIC0+IGJhbCAocmVtb3ZlX21pbl9lbHQgbCkgeCBkIHJcbiAgOztcblxuICBsZXQgYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0IH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggbWF4X2VsdCBsb3dlcl9wYXJ0LCBtaW5fZWx0IHVwcGVyX3BhcnQgd2l0aFxuICAgIHwgTm9uZSwgXyAtPiBgT2sgdXBwZXJfcGFydFxuICAgIHwgXywgTm9uZSAtPiBgT2sgbG93ZXJfcGFydFxuICAgIHwgU29tZSAobWF4X2xvd2VyLCBfKSwgU29tZSAobWluX3VwcGVyLCB2KSB3aGVuIGNvbXBhcmVfa2V5IG1heF9sb3dlciBtaW5fdXBwZXIgPCAwIC0+XG4gICAgICBsZXQgdXBwZXJfcGFydF93aXRob3V0X21pbiA9IHJlbW92ZV9taW5fZWx0IHVwcGVyX3BhcnQgaW5cbiAgICAgIGBPayAoam9pbiB+Y29tcGFyZV9rZXkgbG93ZXJfcGFydCBtaW5fdXBwZXIgdiB1cHBlcl9wYXJ0X3dpdGhvdXRfbWluKVxuICAgIHwgXyAtPiBgT3ZlcmxhcHBpbmdfa2V5X3Jhbmdlc1xuICA7O1xuXG4gIGxldCBmb2xkX3JhbmdlX2luY2x1c2l2ZSA9XG4gICAgKCogVGhpcyBhc3N1bWVzIHRoYXQgbWluIDw9IG1heCwgd2hpY2ggaXMgY2hlY2tlZCBieSB0aGUgb3V0ZXIgZnVuY3Rpb24uICopXG4gICAgbGV0IHJlYyBnbyB0IH5taW4gfm1heCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGluaXRcbiAgICAgIHwgTGVhZiAoaywgZCkgLT5cbiAgICAgICAgaWYgY29tcGFyZV9rZXkgayBtaW4gPCAwIHx8IGNvbXBhcmVfa2V5IGsgbWF4ID4gMFxuICAgICAgICB0aGVuICgqIGsgPCBtaW4gfHwgayA+IG1heCAqKVxuICAgICAgICAgIGluaXRcbiAgICAgICAgZWxzZSBmIH5rZXk6ayB+ZGF0YTpkIGluaXRcbiAgICAgIHwgTm9kZSAobCwgaywgZCwgciwgXykgLT5cbiAgICAgICAgbGV0IGNfbWluID0gY29tcGFyZV9rZXkgayBtaW4gaW5cbiAgICAgICAgaWYgY19taW4gPCAwXG4gICAgICAgIHRoZW5cbiAgICAgICAgICAoKiBpZiBrIDwgbWluLCB0aGVuIHRoaXMgbm9kZSBhbmQgaXRzIGxlZnQgYnJhbmNoIGFyZSBvdXRzaWRlIG91ciByYW5nZSAqKVxuICAgICAgICAgIGdvIHIgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleVxuICAgICAgICBlbHNlIGlmIGNfbWluID0gMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgKCogaWYgayA9IG1pbiwgdGhlbiB0aGlzIG5vZGUncyBsZWZ0IGJyYW5jaCBpcyBvdXRzaWRlIG91ciByYW5nZSAqKVxuICAgICAgICAgIGdvIHIgfm1pbiB+bWF4IH5pbml0OihmIH5rZXk6ayB+ZGF0YTpkIGluaXQpIH5mIH5jb21wYXJlX2tleVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBrID4gbWluICopXG4gICAgICAgICAgbGV0IHogPSBnbyBsIH5taW4gfm1heCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgICBsZXQgY19tYXggPSBjb21wYXJlX2tleSBrIG1heCBpblxuICAgICAgICAgICgqIGlmIGsgPiBtYXgsIHdlJ3JlIGRvbmUgKilcbiAgICAgICAgICBpZiBjX21heCA+IDBcbiAgICAgICAgICB0aGVuIHpcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCB6ID0gZiB+a2V5OmsgfmRhdGE6ZCB6IGluXG4gICAgICAgICAgICAoKiBpZiBrID0gbWF4LCB0aGVuIHdlIGZvbGQgaW4gdGhpcyBvbmUgbGFzdCB2YWx1ZSBhbmQgd2UncmUgZG9uZSAqKVxuICAgICAgICAgICAgaWYgY19tYXggPSAwIHRoZW4geiBlbHNlIGdvIHIgfm1pbiB+bWF4IH5pbml0OnogfmYgfmNvbXBhcmVfa2V5KSlcbiAgICBpblxuICAgIGZ1biB0IH5taW4gfm1heCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXkgLT5cbiAgICAgIGlmIGNvbXBhcmVfa2V5IG1pbiBtYXggPD0gMCB0aGVuIGdvIHQgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleSBlbHNlIGluaXRcbiAgOztcblxuICBsZXQgcmFuZ2VfdG9fYWxpc3QgdCB+bWluIH5tYXggfmNvbXBhcmVfa2V5ID1cbiAgICBMaXN0LnJldlxuICAgICAgKGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgICAgICB0XG4gICAgICAgICB+bWluXG4gICAgICAgICB+bWF4XG4gICAgICAgICB+aW5pdDpbXVxuICAgICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhIGwgLT4gKGtleSwgZGF0YSkgOjogbClcbiAgICAgICAgIH5jb21wYXJlX2tleSlcbiAgOztcblxuICBsZXQgY29uY2F0X3VuY2hlY2tlZCB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEVtcHR5LCB0IC0+IHRcbiAgICB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT5cbiAgICAgIGxldCB4LCBkID0gbWluX2VsdF9leG4gdDIgaW5cbiAgICAgIGJhbCB0MSB4IGQgKHJlbW92ZV9taW5fZWx0IHQyKVxuICA7O1xuXG4gIGV4Y2VwdGlvbiBSZW1vdmVfbm9fb3BcblxuICBsZXQgcmVtb3ZlIHQgeCB+bGVuZ3RoIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IHJlYyByZW1vdmVfbG9vcCB0IHggfmxlbmd0aCB+Y29tcGFyZV9rZXkgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IEV4bi5yYWlzZV93aXRob3V0X2JhY2t0cmFjZSBSZW1vdmVfbm9fb3BcbiAgICAgIHwgTGVhZiAodiwgXykgLT5cbiAgICAgICAgaWYgY29tcGFyZV9rZXkgeCB2ID0gMFxuICAgICAgICB0aGVuIEVtcHR5LCBsZW5ndGggLSAxXG4gICAgICAgIGVsc2UgRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIFJlbW92ZV9ub19vcFxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHggdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIGNvbmNhdF91bmNoZWNrZWQgbCByLCBsZW5ndGggLSAxXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGwsIGxlbmd0aCA9IHJlbW92ZV9sb29wIGwgeCB+bGVuZ3RoIH5jb21wYXJlX2tleSBpblxuICAgICAgICAgIGJhbCBsIHYgZCByLCBsZW5ndGgpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCByLCBsZW5ndGggPSByZW1vdmVfbG9vcCByIHggfmxlbmd0aCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgICAgICBiYWwgbCB2IGQgciwgbGVuZ3RoKVxuICAgIGluXG4gICAgdHJ5IHJlbW92ZV9sb29wIHQgeCB+bGVuZ3RoIH5jb21wYXJlX2tleSB3aXRoXG4gICAgfCBSZW1vdmVfbm9fb3AgLT4gdCwgbGVuZ3RoXG4gIDs7XG5cbiAgKCogVXNlIGV4Y2VwdGlvbiB0byBhdm9pZCB0cmVlLXJlYnVpbGQgaW4gbm8tb3AgY2FzZSAqKVxuICBleGNlcHRpb24gQ2hhbmdlX25vX29wXG5cbiAgbGV0IGNoYW5nZSB0IGtleSB+ZiB+bGVuZ3RoIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IHJlYyBjaGFuZ2VfY29yZSB0IGtleSBmID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAobWF0Y2ggZiBOb25lIHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPiByYWlzZSBDaGFuZ2Vfbm9fb3AgKCogZXF1aXZhbGVudCB0byByZXR1cm5pbmc6IEVtcHR5ICopXG4gICAgICAgICB8IFNvbWUgZGF0YSAtPiBMZWFmIChrZXksIGRhdGEpLCBsZW5ndGggKyAxKVxuICAgICAgfCBMZWFmICh2LCBkKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGtleSB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIG1hdGNoIGYgKFNvbWUgZCkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBFbXB0eSwgbGVuZ3RoIC0gMVxuICAgICAgICAgIHwgU29tZSBkJyAtPiBMZWFmICh2LCBkJyksIGxlbmd0aClcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbCwgbGVuZ3RoID0gY2hhbmdlX2NvcmUgRW1wdHkga2V5IGYgaW5cbiAgICAgICAgICBiYWwgbCB2IGQgRW1wdHksIGxlbmd0aClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHIsIGxlbmd0aCA9IGNoYW5nZV9jb3JlIEVtcHR5IGtleSBmIGluXG4gICAgICAgICAgYmFsIEVtcHR5IHYgZCByLCBsZW5ndGgpXG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIGgpIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkga2V5IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbWF0Y2ggZiAoU29tZSBkKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGNvbmNhdF91bmNoZWNrZWQgbCByLCBsZW5ndGggLSAxXG4gICAgICAgICAgfCBTb21lIGRhdGEgLT4gTm9kZSAobCwga2V5LCBkYXRhLCByLCBoKSwgbGVuZ3RoKVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBsLCBsZW5ndGggPSBjaGFuZ2VfY29yZSBsIGtleSBmIGluXG4gICAgICAgICAgYmFsIGwgdiBkIHIsIGxlbmd0aClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHIsIGxlbmd0aCA9IGNoYW5nZV9jb3JlIHIga2V5IGYgaW5cbiAgICAgICAgICBiYWwgbCB2IGQgciwgbGVuZ3RoKVxuICAgIGluXG4gICAgdHJ5IGNoYW5nZV9jb3JlIHQga2V5IGYgd2l0aFxuICAgIHwgQ2hhbmdlX25vX29wIC0+IHQsIGxlbmd0aFxuICA7O1xuXG4gIGxldCB1cGRhdGUgdCBrZXkgfmYgfmxlbmd0aCB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCByZWMgdXBkYXRlX2NvcmUgdCBrZXkgZiA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgbGV0IGRhdGEgPSBmIE5vbmUgaW5cbiAgICAgICAgTGVhZiAoa2V5LCBkYXRhKSwgbGVuZ3RoICsgMVxuICAgICAgfCBMZWFmICh2LCBkKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGtleSB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBkJyA9IGYgKFNvbWUgZCkgaW5cbiAgICAgICAgICBMZWFmICh2LCBkJyksIGxlbmd0aClcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbCwgbGVuZ3RoID0gdXBkYXRlX2NvcmUgRW1wdHkga2V5IGYgaW5cbiAgICAgICAgICBiYWwgbCB2IGQgRW1wdHksIGxlbmd0aClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHIsIGxlbmd0aCA9IHVwZGF0ZV9jb3JlIEVtcHR5IGtleSBmIGluXG4gICAgICAgICAgYmFsIEVtcHR5IHYgZCByLCBsZW5ndGgpXG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIGgpIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkga2V5IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGRhdGEgPSBmIChTb21lIGQpIGluXG4gICAgICAgICAgTm9kZSAobCwga2V5LCBkYXRhLCByLCBoKSwgbGVuZ3RoKVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBsLCBsZW5ndGggPSB1cGRhdGVfY29yZSBsIGtleSBmIGluXG4gICAgICAgICAgYmFsIGwgdiBkIHIsIGxlbmd0aClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHIsIGxlbmd0aCA9IHVwZGF0ZV9jb3JlIHIga2V5IGYgaW5cbiAgICAgICAgICBiYWwgbCB2IGQgciwgbGVuZ3RoKVxuICAgIGluXG4gICAgdXBkYXRlX2NvcmUgdCBrZXkgZlxuICA7O1xuXG4gIGxldCByZW1vdmVfbXVsdGkgdCBrZXkgfmxlbmd0aCB+Y29tcGFyZV9rZXkgPVxuICAgIGNoYW5nZSB0IGtleSB+bGVuZ3RoIH5jb21wYXJlX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgIHwgTm9uZSB8IFNvbWUgKFtdIHwgWyBfIF0pIC0+IE5vbmVcbiAgICAgIHwgU29tZSAoXyA6OiAoXyA6OiBfIGFzIG5vbl9lbXB0eV90YWlsKSkgLT4gU29tZSBub25fZW1wdHlfdGFpbClcbiAgOztcblxuICBsZXQgcmVjIGl0ZXJfa2V5cyB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmICh2LCBfKSAtPiBmIHZcbiAgICB8IE5vZGUgKGwsIHYsIF8sIHIsIF8pIC0+XG4gICAgICBpdGVyX2tleXMgfmYgbDtcbiAgICAgIGYgdjtcbiAgICAgIGl0ZXJfa2V5cyB+ZiByXG4gIDs7XG5cbiAgbGV0IHJlYyBpdGVyIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IExlYWYgKF8sIGQpIC0+IGYgZFxuICAgIHwgTm9kZSAobCwgXywgZCwgciwgXykgLT5cbiAgICAgIGl0ZXIgfmYgbDtcbiAgICAgIGYgZDtcbiAgICAgIGl0ZXIgfmYgclxuICA7O1xuXG4gIGxldCByZWMgaXRlcmkgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgTGVhZiAodiwgZCkgLT4gZiB+a2V5OnYgfmRhdGE6ZFxuICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT5cbiAgICAgIGl0ZXJpIH5mIGw7XG4gICAgICBmIH5rZXk6diB+ZGF0YTpkO1xuICAgICAgaXRlcmkgfmYgclxuICA7O1xuXG4gIGxldCBpdGVyaV91bnRpbCA9XG4gICAgbGV0IHJlYyBpdGVyaV91bnRpbF9sb29wIHQgfmYgOiBDb250aW51ZV9vcl9zdG9wLnQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IENvbnRpbnVlXG4gICAgICB8IExlYWYgKHYsIGQpIC0+IGYgfmtleTp2IH5kYXRhOmRcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT5cbiAgICAgICAgKG1hdGNoIGl0ZXJpX3VudGlsX2xvb3AgfmYgbCB3aXRoXG4gICAgICAgICB8IFN0b3AgLT4gU3RvcFxuICAgICAgICAgfCBDb250aW51ZSAtPlxuICAgICAgICAgICAobWF0Y2ggZiB+a2V5OnYgfmRhdGE6ZCB3aXRoXG4gICAgICAgICAgICB8IFN0b3AgLT4gU3RvcFxuICAgICAgICAgICAgfCBDb250aW51ZSAtPiBpdGVyaV91bnRpbF9sb29wIH5mIHIpKVxuICAgIGluXG4gICAgZnVuIHQgfmYgLT4gRmluaXNoZWRfb3JfdW5maW5pc2hlZC5vZl9jb250aW51ZV9vcl9zdG9wIChpdGVyaV91bnRpbF9sb29wIHQgfmYpXG4gIDs7XG5cbiAgbGV0IHJlYyBtYXAgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgIHwgTGVhZiAodiwgZCkgLT4gTGVhZiAodiwgZiBkKVxuICAgIHwgTm9kZSAobCwgdiwgZCwgciwgaCkgLT5cbiAgICAgIGxldCBsJyA9IG1hcCB+ZiBsIGluXG4gICAgICBsZXQgZCcgPSBmIGQgaW5cbiAgICAgIGxldCByJyA9IG1hcCB+ZiByIGluXG4gICAgICBOb2RlIChsJywgdiwgZCcsIHInLCBoKVxuICA7O1xuXG4gIGxldCByZWMgbWFwaSB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgfCBMZWFmICh2LCBkKSAtPiBMZWFmICh2LCBmIH5rZXk6diB+ZGF0YTpkKVxuICAgIHwgTm9kZSAobCwgdiwgZCwgciwgaCkgLT5cbiAgICAgIGxldCBsJyA9IG1hcGkgfmYgbCBpblxuICAgICAgbGV0IGQnID0gZiB+a2V5OnYgfmRhdGE6ZCBpblxuICAgICAgbGV0IHInID0gbWFwaSB+ZiByIGluXG4gICAgICBOb2RlIChsJywgdiwgZCcsIHInLCBoKVxuICA7O1xuXG4gIGxldCByZWMgZm9sZCB0IH5pbml0OmFjY3UgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgIHwgTGVhZiAodiwgZCkgLT4gZiB+a2V5OnYgfmRhdGE6ZCBhY2N1XG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPiBmb2xkIH5mIHIgfmluaXQ6KGYgfmtleTp2IH5kYXRhOmQgKGZvbGQgfmYgbCB+aW5pdDphY2N1KSlcbiAgOztcblxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPVxuICAgIGxldCByZWMgZm9sZF91bnRpbF9sb29wIHQgfmFjYyB+ZiA6IChfLCBfKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBDb250aW51ZSBhY2NcbiAgICAgIHwgTGVhZiAodiwgZCkgLT4gZiB+a2V5OnYgfmRhdGE6ZCBhY2NcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT5cbiAgICAgICAgKG1hdGNoIGZvbGRfdW50aWxfbG9vcCBsIH5hY2MgfmYgd2l0aFxuICAgICAgICAgfCBTdG9wIGZpbmFsIC0+IFN0b3AgZmluYWxcbiAgICAgICAgIHwgQ29udGludWUgYWNjIC0+XG4gICAgICAgICAgIChtYXRjaCBmIH5rZXk6diB+ZGF0YTpkIGFjYyB3aXRoXG4gICAgICAgICAgICB8IFN0b3AgZmluYWwgLT4gU3RvcCBmaW5hbFxuICAgICAgICAgICAgfCBDb250aW51ZSBhY2MgLT4gZm9sZF91bnRpbF9sb29wIHIgfmFjYyB+ZikpXG4gICAgaW5cbiAgICBtYXRjaCBmb2xkX3VudGlsX2xvb3AgdCB+YWNjOmluaXQgfmYgd2l0aFxuICAgIHwgQ29udGludWUgYWNjIC0+IGZpbmlzaCBhY2NcbiAgICB8IFN0b3Agc3RvcCAtPiBzdG9wXG4gIDs7XG5cbiAgbGV0IHJlYyBmb2xkX3JpZ2h0IHQgfmluaXQ6YWNjdSB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgfCBMZWFmICh2LCBkKSAtPiBmIH5rZXk6diB+ZGF0YTpkIGFjY3VcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+XG4gICAgICBmb2xkX3JpZ2h0IH5mIGwgfmluaXQ6KGYgfmtleTp2IH5kYXRhOmQgKGZvbGRfcmlnaHQgfmYgciB+aW5pdDphY2N1KSlcbiAgOztcblxuICBsZXQgZmlsdGVyX2tleXMgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIGZvbGQgfmluaXQ6KEVtcHR5LCAwKSB0IH5mOihmdW4gfmtleSB+ZGF0YSAoYWNjdSwgbGVuZ3RoKSAtPlxuICAgICAgaWYgZiBrZXkgdGhlbiBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhIGFjY3UgfmNvbXBhcmVfa2V5IGVsc2UgYWNjdSwgbGVuZ3RoKVxuICA7O1xuXG5cbiAgbGV0IGZpbHRlciB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgZm9sZCB+aW5pdDooRW1wdHksIDApIHQgfmY6KGZ1biB+a2V5IH5kYXRhIChhY2N1LCBsZW5ndGgpIC0+XG4gICAgICBpZiBmIGRhdGEgdGhlbiBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhIGFjY3UgfmNvbXBhcmVfa2V5IGVsc2UgYWNjdSwgbGVuZ3RoKVxuICA7O1xuXG4gIGxldCBmaWx0ZXJpIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBmb2xkIH5pbml0OihFbXB0eSwgMCkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgKGFjY3UsIGxlbmd0aCkgLT5cbiAgICAgIGlmIGYgfmtleSB+ZGF0YSB0aGVuIHNldCB+bGVuZ3RoIH5rZXkgfmRhdGEgYWNjdSB+Y29tcGFyZV9rZXkgZWxzZSBhY2N1LCBsZW5ndGgpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXAgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIGZvbGQgfmluaXQ6KEVtcHR5LCAwKSB0IH5mOihmdW4gfmtleSB+ZGF0YSAoYWNjdSwgbGVuZ3RoKSAtPlxuICAgICAgbWF0Y2ggZiBkYXRhIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBhY2N1LCBsZW5ndGhcbiAgICAgIHwgU29tZSBiIC0+IHNldCB+bGVuZ3RoIH5rZXkgfmRhdGE6YiBhY2N1IH5jb21wYXJlX2tleSlcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcGkgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIGZvbGQgfmluaXQ6KEVtcHR5LCAwKSB0IH5mOihmdW4gfmtleSB+ZGF0YSAoYWNjdSwgbGVuZ3RoKSAtPlxuICAgICAgbWF0Y2ggZiB+a2V5IH5kYXRhIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBhY2N1LCBsZW5ndGhcbiAgICAgIHwgU29tZSBiIC0+IHNldCB+bGVuZ3RoIH5rZXkgfmRhdGE6YiBhY2N1IH5jb21wYXJlX2tleSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcGkgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIGZvbGRcbiAgICAgIHRcbiAgICAgIH5pbml0OigoRW1wdHksIDApLCAoRW1wdHksIDApKVxuICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhIChwYWlyMSwgcGFpcjIpIC0+XG4gICAgICAgIG1hdGNoIChmIH5rZXkgfmRhdGEgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgICAgIHwgRmlyc3QgeCAtPlxuICAgICAgICAgIGxldCB0LCBsZW5ndGggPSBwYWlyMSBpblxuICAgICAgICAgIHNldCB0IH5rZXkgfmRhdGE6eCB+Y29tcGFyZV9rZXkgfmxlbmd0aCwgcGFpcjJcbiAgICAgICAgfCBTZWNvbmQgeSAtPlxuICAgICAgICAgIGxldCB0LCBsZW5ndGggPSBwYWlyMiBpblxuICAgICAgICAgIHBhaXIxLCBzZXQgdCB+a2V5IH5kYXRhOnkgfmNvbXBhcmVfa2V5IH5sZW5ndGgpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl9tYXAgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIHBhcnRpdGlvbl9tYXBpIHQgfmNvbXBhcmVfa2V5IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uaV90ZiB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgcGFydGl0aW9uX21hcGkgdCB+Y29tcGFyZV9rZXkgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICBpZiBmIH5rZXkgfmRhdGEgdGhlbiBGaXJzdCBkYXRhIGVsc2UgU2Vjb25kIGRhdGEpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl90ZiB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgcGFydGl0aW9uX21hcGkgdCB+Y29tcGFyZV9rZXkgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT5cbiAgICAgIGlmIGYgZGF0YSB0aGVuIEZpcnN0IGRhdGEgZWxzZSBTZWNvbmQgZGF0YSlcbiAgOztcblxuICBtb2R1bGUgRW51bSA9IHN0cnVjdFxuICAgIHR5cGUgaW5jcmVhc2luZ1xuICAgIHR5cGUgZGVjcmVhc2luZ1xuXG4gICAgdHlwZSAoJ2ssICd2LCAnZGlyZWN0aW9uKSB0ID1cbiAgICAgIHwgRW5kXG4gICAgICB8IE1vcmUgb2YgJ2sgKiAndiAqICgnaywgJ3YpIHRyZWUgKiAoJ2ssICd2LCAnZGlyZWN0aW9uKSB0XG5cbiAgICBsZXQgcmVjIGNvbnMgdCAoZSA6IChfLCBfLCBpbmNyZWFzaW5nKSB0KSA6IChfLCBfLCBpbmNyZWFzaW5nKSB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICB8IExlYWYgKHYsIGQpIC0+IE1vcmUgKHYsIGQsIEVtcHR5LCBlKVxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPiBjb25zIGwgKE1vcmUgKHYsIGQsIHIsIGUpKVxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGNvbnNfcmlnaHQgdCAoZSA6IChfLCBfLCBkZWNyZWFzaW5nKSB0KSA6IChfLCBfLCBkZWNyZWFzaW5nKSB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICB8IExlYWYgKHYsIGQpIC0+IE1vcmUgKHYsIGQsIEVtcHR5LCBlKVxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPiBjb25zX3JpZ2h0IHIgKE1vcmUgKHYsIGQsIGwsIGUpKVxuICAgIDs7XG5cbiAgICBsZXQgb2ZfdHJlZSB0cmVlIDogKF8sIF8sIGluY3JlYXNpbmcpIHQgPSBjb25zIHRyZWUgRW5kXG4gICAgbGV0IG9mX3RyZWVfcmlnaHQgdHJlZSA6IChfLCBfLCBkZWNyZWFzaW5nKSB0ID0gY29uc19yaWdodCB0cmVlIEVuZFxuXG4gICAgbGV0IHN0YXJ0aW5nX2F0X2luY3JlYXNpbmcgdCBrZXkgY29tcGFyZSA6IChfLCBfLCBpbmNyZWFzaW5nKSB0ID1cbiAgICAgIGxldCByZWMgbG9vcCB0IGUgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICAgIHwgTGVhZiAodiwgZCkgLT4gbG9vcCAoTm9kZSAoRW1wdHksIHYsIGQsIEVtcHR5LCAxKSkgZVxuICAgICAgICB8IE5vZGUgKF8sIHYsIF8sIHIsIF8pIHdoZW4gY29tcGFyZSB2IGtleSA8IDAgLT4gbG9vcCByIGVcbiAgICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPiBsb29wIGwgKE1vcmUgKHYsIGQsIHIsIGUpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdCBFbmRcbiAgICA7O1xuXG4gICAgbGV0IHN0YXJ0aW5nX2F0X2RlY3JlYXNpbmcgdCBrZXkgY29tcGFyZSA6IChfLCBfLCBkZWNyZWFzaW5nKSB0ID1cbiAgICAgIGxldCByZWMgbG9vcCB0IGUgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBlXG4gICAgICAgIHwgTGVhZiAodiwgZCkgLT4gbG9vcCAoTm9kZSAoRW1wdHksIHYsIGQsIEVtcHR5LCAxKSkgZVxuICAgICAgICB8IE5vZGUgKGwsIHYsIF8sIF8sIF8pIHdoZW4gY29tcGFyZSB2IGtleSA+IDAgLT4gbG9vcCBsIGVcbiAgICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPiBsb29wIHIgKE1vcmUgKHYsIGQsIGwsIGUpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdCBFbmRcbiAgICA7O1xuXG4gICAgbGV0IGNvbXBhcmUgY29tcGFyZV9rZXkgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICAgIGxldCByZWMgbG9vcCB0MSB0MiA9XG4gICAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gMFxuICAgICAgICB8IEVuZCwgXyAtPiAtMVxuICAgICAgICB8IF8sIEVuZCAtPiAxXG4gICAgICAgIHwgTW9yZSAodjEsIGQxLCByMSwgZTEpLCBNb3JlICh2MiwgZDIsIHIyLCBlMikgLT5cbiAgICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA8PiAwXG4gICAgICAgICAgdGhlbiBjXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZGF0YSBkMSBkMiBpblxuICAgICAgICAgICAgaWYgYyA8PiAwXG4gICAgICAgICAgICB0aGVuIGNcbiAgICAgICAgICAgIGVsc2UgaWYgcGh5c19lcXVhbCByMSByMlxuICAgICAgICAgICAgdGhlbiBsb29wIGUxIGUyXG4gICAgICAgICAgICBlbHNlIGxvb3AgKGNvbnMgcjEgZTEpIChjb25zIHIyIGUyKSlcbiAgICAgIGluXG4gICAgICBsb29wIHQxIHQyXG4gICAgOztcblxuICAgIGxldCBlcXVhbCBjb21wYXJlX2tleSBkYXRhX2VxdWFsIHQxIHQyID1cbiAgICAgIGxldCByZWMgbG9vcCB0MSB0MiA9XG4gICAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gdHJ1ZVxuICAgICAgICB8IEVuZCwgXyB8IF8sIEVuZCAtPiBmYWxzZVxuICAgICAgICB8IE1vcmUgKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSAodjIsIGQyLCByMiwgZTIpIC0+XG4gICAgICAgICAgY29tcGFyZV9rZXkgdjEgdjIgPSAwXG4gICAgICAgICAgJiYgZGF0YV9lcXVhbCBkMSBkMlxuICAgICAgICAgICYmIGlmIHBoeXNfZXF1YWwgcjEgcjIgdGhlbiBsb29wIGUxIGUyIGVsc2UgbG9vcCAoY29ucyByMSBlMSkgKGNvbnMgcjIgZTIpXG4gICAgICBpblxuICAgICAgbG9vcCB0MSB0MlxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGZvbGQgfmluaXQgfmYgPSBmdW5jdGlvblxuICAgICAgfCBFbmQgLT4gaW5pdFxuICAgICAgfCBNb3JlIChrZXksIGRhdGEsIHRyZWUsIGVudW0pIC0+XG4gICAgICAgIGxldCBuZXh0ID0gZiB+a2V5IH5kYXRhIGluaXQgaW5cbiAgICAgICAgZm9sZCAoY29ucyB0cmVlIGVudW0pIH5pbml0Om5leHQgfmZcbiAgICA7O1xuXG4gICAgbGV0IGZvbGQyIGNvbXBhcmVfa2V5IHQxIHQyIH5pbml0IH5mID1cbiAgICAgIGxldCByZWMgbG9vcCB0MSB0MiBjdXJyID1cbiAgICAgICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiBjdXJyXG4gICAgICAgIHwgRW5kLCBfIC0+XG4gICAgICAgICAgZm9sZCB0MiB+aW5pdDpjdXJyIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gZiB+a2V5IH5kYXRhOihgUmlnaHQgZGF0YSkgYWNjKVxuICAgICAgICB8IF8sIEVuZCAtPlxuICAgICAgICAgIGZvbGQgdDEgfmluaXQ6Y3VyciB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGYgfmtleSB+ZGF0YTooYExlZnQgZGF0YSkgYWNjKVxuICAgICAgICB8IE1vcmUgKGsxLCB2MSwgdHJlZTEsIGVudW0xKSwgTW9yZSAoazIsIHYyLCB0cmVlMiwgZW51bTIpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9rZXkgazEgazIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZiB+a2V5OmsxIH5kYXRhOihgQm90aCAodjEsIHYyKSkgY3VyciBpblxuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgKGNvbnMgdHJlZTIgZW51bTIpIG5leHQpXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZiB+a2V5OmsxIH5kYXRhOihgTGVmdCB2MSkgY3VyciBpblxuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgdDIgbmV4dClcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZiB+a2V5OmsyIH5kYXRhOihgUmlnaHQgdjIpIGN1cnIgaW5cbiAgICAgICAgICAgIGxvb3AgdDEgKGNvbnMgdHJlZTIgZW51bTIpIG5leHQpXG4gICAgICBpblxuICAgICAgbG9vcCB0MSB0MiBpbml0XG4gICAgOztcblxuICAgIGxldCBzeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9rZXkgfmRhdGFfZXF1YWwgPVxuICAgICAgbGV0IHN0ZXAgc3RhdGUgPVxuICAgICAgICBtYXRjaCBzdGF0ZSB3aXRoXG4gICAgICAgIHwgRW5kLCBFbmQgLT4gU2VxdWVuY2UuU3RlcC5Eb25lXG4gICAgICAgIHwgRW5kLCBNb3JlIChrZXksIGRhdGEsIHRyZWUsIGVudW0pIC0+XG4gICAgICAgICAgU2VxdWVuY2UuU3RlcC5ZaWVsZCAoKGtleSwgYFJpZ2h0IGRhdGEpLCAoRW5kLCBjb25zIHRyZWUgZW51bSkpXG4gICAgICAgIHwgTW9yZSAoa2V5LCBkYXRhLCB0cmVlLCBlbnVtKSwgRW5kIC0+XG4gICAgICAgICAgU2VxdWVuY2UuU3RlcC5ZaWVsZCAoKGtleSwgYExlZnQgZGF0YSksIChjb25zIHRyZWUgZW51bSwgRW5kKSlcbiAgICAgICAgfCAoTW9yZSAoazEsIHYxLCB0cmVlMSwgZW51bTEpIGFzIGxlZnQpLCAoTW9yZSAoazIsIHYyLCB0cmVlMiwgZW51bTIpIGFzIHJpZ2h0KSAtPlxuICAgICAgICAgIGxldCBjb21wYXJlX3Jlc3VsdCA9IGNvbXBhcmVfa2V5IGsxIGsyIGluXG4gICAgICAgICAgaWYgY29tcGFyZV9yZXN1bHQgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgbmV4dF9zdGF0ZSA9XG4gICAgICAgICAgICAgIGlmIHBoeXNfZXF1YWwgdHJlZTEgdHJlZTJcbiAgICAgICAgICAgICAgdGhlbiBlbnVtMSwgZW51bTJcbiAgICAgICAgICAgICAgZWxzZSBjb25zIHRyZWUxIGVudW0xLCBjb25zIHRyZWUyIGVudW0yXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgaWYgZGF0YV9lcXVhbCB2MSB2MlxuICAgICAgICAgICAgdGhlbiBTZXF1ZW5jZS5TdGVwLlNraXAgbmV4dF9zdGF0ZVxuICAgICAgICAgICAgZWxzZSBTZXF1ZW5jZS5TdGVwLllpZWxkICgoazEsIGBVbmVxdWFsICh2MSwgdjIpKSwgbmV4dF9zdGF0ZSkpXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuIFNlcXVlbmNlLlN0ZXAuWWllbGQgKChrMSwgYExlZnQgdjEpLCAoY29ucyB0cmVlMSBlbnVtMSwgcmlnaHQpKVxuICAgICAgICAgIGVsc2UgU2VxdWVuY2UuU3RlcC5ZaWVsZCAoKGsyLCBgUmlnaHQgdjIpLCAobGVmdCwgY29ucyB0cmVlMiBlbnVtMikpXG4gICAgICBpblxuICAgICAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQ6KG9mX3RyZWUgdDEsIG9mX3RyZWUgdDIpIH5mOnN0ZXBcbiAgICA7O1xuXG4gICAgbGV0IGZvbGRfc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfa2V5IH5kYXRhX2VxdWFsIH5pbml0IH5mID1cbiAgICAgIGxldCBhZGQgYWNjIGsgdiA9IGYgYWNjIChrLCBgUmlnaHQgdikgaW5cbiAgICAgIGxldCByZW1vdmUgYWNjIGsgdiA9IGYgYWNjIChrLCBgTGVmdCB2KSBpblxuICAgICAgbGV0IHJlYyBsb29wIGxlZnQgcmlnaHQgYWNjID1cbiAgICAgICAgbWF0Y2ggbGVmdCwgcmlnaHQgd2l0aFxuICAgICAgICB8IEVuZCwgZW51bSAtPiBmb2xkIGVudW0gfmluaXQ6YWNjIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gYWRkIGFjYyBrZXkgZGF0YSlcbiAgICAgICAgfCBlbnVtLCBFbmQgLT4gZm9sZCBlbnVtIH5pbml0OmFjYyB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IHJlbW92ZSBhY2Mga2V5IGRhdGEpXG4gICAgICAgIHwgKE1vcmUgKGsxLCB2MSwgdHJlZTEsIGVudW0xKSBhcyBsZWZ0KSwgKE1vcmUgKGsyLCB2MiwgdHJlZTIsIGVudW0yKSBhcyByaWdodCkgLT5cbiAgICAgICAgICBsZXQgY29tcGFyZV9yZXN1bHQgPSBjb21wYXJlX2tleSBrMSBrMiBpblxuICAgICAgICAgIGlmIGNvbXBhcmVfcmVzdWx0ID0gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IGFjYyA9IGlmIGRhdGFfZXF1YWwgdjEgdjIgdGhlbiBhY2MgZWxzZSBmIGFjYyAoazEsIGBVbmVxdWFsICh2MSwgdjIpKSBpblxuICAgICAgICAgICAgaWYgcGh5c19lcXVhbCB0cmVlMSB0cmVlMlxuICAgICAgICAgICAgdGhlbiBsb29wIGVudW0xIGVudW0yIGFjY1xuICAgICAgICAgICAgZWxzZSBsb29wIChjb25zIHRyZWUxIGVudW0xKSAoY29ucyB0cmVlMiBlbnVtMikgYWNjKVxuICAgICAgICAgIGVsc2UgaWYgY29tcGFyZV9yZXN1bHQgPCAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgYWNjID0gcmVtb3ZlIGFjYyBrMSB2MSBpblxuICAgICAgICAgICAgbG9vcCAoY29ucyB0cmVlMSBlbnVtMSkgcmlnaHQgYWNjKVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IGFjYyA9IGFkZCBhY2MgazIgdjIgaW5cbiAgICAgICAgICAgIGxvb3AgbGVmdCAoY29ucyB0cmVlMiBlbnVtMikgYWNjKVxuICAgICAgaW5cbiAgICAgIGxvb3AgKG9mX3RyZWUgdDEpIChvZl90cmVlIHQyKSBpbml0XG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IHRvX3NlcXVlbmNlX2luY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9rZXkgdCA9XG4gICAgbGV0IG5leHQgZW51bSA9XG4gICAgICBtYXRjaCBlbnVtIHdpdGhcbiAgICAgIHwgRW51bS5FbmQgLT4gU2VxdWVuY2UuU3RlcC5Eb25lXG4gICAgICB8IEVudW0uTW9yZSAoaywgdiwgdCwgZSkgLT4gU2VxdWVuY2UuU3RlcC5ZaWVsZCAoKGssIHYpLCBFbnVtLmNvbnMgdCBlKVxuICAgIGluXG4gICAgbGV0IGluaXQgPVxuICAgICAgbWF0Y2ggZnJvbV9rZXkgd2l0aFxuICAgICAgfCBOb25lIC0+IEVudW0ub2ZfdHJlZSB0XG4gICAgICB8IFNvbWUga2V5IC0+IEVudW0uc3RhcnRpbmdfYXRfaW5jcmVhc2luZyB0IGtleSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQgfmY6bmV4dFxuICA7O1xuXG4gIGxldCB0b19zZXF1ZW5jZV9kZWNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fa2V5IHQgPVxuICAgIGxldCBuZXh0IGVudW0gPVxuICAgICAgbWF0Y2ggZW51bSB3aXRoXG4gICAgICB8IEVudW0uRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgfCBFbnVtLk1vcmUgKGssIHYsIHQsIGUpIC0+IFNlcXVlbmNlLlN0ZXAuWWllbGQgKChrLCB2KSwgRW51bS5jb25zX3JpZ2h0IHQgZSlcbiAgICBpblxuICAgIGxldCBpbml0ID1cbiAgICAgIG1hdGNoIGZyb21fa2V5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBFbnVtLm9mX3RyZWVfcmlnaHQgdFxuICAgICAgfCBTb21lIGtleSAtPiBFbnVtLnN0YXJ0aW5nX2F0X2RlY3JlYXNpbmcgdCBrZXkgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0IH5mOm5leHRcbiAgOztcblxuICBsZXQgdG9fc2VxdWVuY2VcbiAgICAgICAgY29tcGFyYXRvclxuICAgICAgICA/KG9yZGVyID0gYEluY3JlYXNpbmdfa2V5KVxuICAgICAgICA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvXG4gICAgICAgID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG9cbiAgICAgICAgdFxuICAgID1cbiAgICBsZXQgaW5jbHVzaXZlX2JvdW5kIHNpZGUgdCBib3VuZCA9XG4gICAgICBsZXQgY29tcGFyZV9rZXkgPSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBpblxuICAgICAgbGV0IGwsIG1heWJlLCByID0gc3BsaXQgdCBib3VuZCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgIGxldCB0ID0gc2lkZSAobCwgcikgaW5cbiAgICAgIG1hdGNoIG1heWJlIHdpdGhcbiAgICAgIHwgTm9uZSAtPiB0XG4gICAgICB8IFNvbWUgKGtleSwgZGF0YSkgLT4gc2V0JyB0IGtleSBkYXRhIH5jb21wYXJlX2tleVxuICAgIGluXG4gICAgbWF0Y2ggb3JkZXIgd2l0aFxuICAgIHwgYEluY3JlYXNpbmdfa2V5IC0+XG4gICAgICBsZXQgdCA9IE9wdGlvbi5mb2xkIGtleXNfbGVzc19vcl9lcXVhbF90byB+aW5pdDp0IH5mOihpbmNsdXNpdmVfYm91bmQgZnN0KSBpblxuICAgICAgdG9fc2VxdWVuY2VfaW5jcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2tleTprZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gdFxuICAgIHwgYERlY3JlYXNpbmdfa2V5IC0+XG4gICAgICBsZXQgdCA9IE9wdGlvbi5mb2xkIGtleXNfZ3JlYXRlcl9vcl9lcXVhbF90byB+aW5pdDp0IH5mOihpbmNsdXNpdmVfYm91bmQgc25kKSBpblxuICAgICAgdG9fc2VxdWVuY2VfZGVjcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2tleTprZXlzX2xlc3Nfb3JfZXF1YWxfdG8gdFxuICA7O1xuXG4gIGxldCBjb21wYXJlIGNvbXBhcmVfa2V5IGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgRW51bS5jb21wYXJlIGNvbXBhcmVfa2V5IGNvbXBhcmVfZGF0YSAoRW51bS5vZl90cmVlIHQxKSAoRW51bS5vZl90cmVlIHQyKVxuICA7O1xuXG4gIGxldCBlcXVhbCBjb21wYXJlX2tleSBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgIEVudW0uZXF1YWwgY29tcGFyZV9rZXkgY29tcGFyZV9kYXRhIChFbnVtLm9mX3RyZWUgdDEpIChFbnVtLm9mX3RyZWUgdDIpXG4gIDs7XG5cbiAgbGV0IGl0ZXIyIHQxIHQyIH5mIH5jb21wYXJlX2tleSA9XG4gICAgRW51bS5mb2xkMlxuICAgICAgY29tcGFyZV9rZXlcbiAgICAgIChFbnVtLm9mX3RyZWUgdDEpXG4gICAgICAoRW51bS5vZl90cmVlIHQyKVxuICAgICAgfmluaXQ6KClcbiAgICAgIH5mOihmdW4gfmtleSB+ZGF0YSAoKSAtPiBmIH5rZXkgfmRhdGEpXG4gIDs7XG5cbiAgbGV0IGZvbGQyIHQxIHQyIH5pbml0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgRW51bS5mb2xkMiBjb21wYXJlX2tleSAoRW51bS5vZl90cmVlIHQxKSAoRW51bS5vZl90cmVlIHQyKSB+ZiB+aW5pdFxuICA7O1xuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiA9IEVudW0uc3ltbWV0cmljX2RpZmZcblxuICBsZXQgZm9sZF9zeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9rZXkgfmRhdGFfZXF1YWwgfmluaXQgfmYgPVxuICAgICgqIFtFbnVtLmZvbGRfZGlmZnNdIGlzIGEgY29ycmVjdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uLCBidXQgaXMgY29uc2lkZXJhYmx5XG4gICAgICAgc2xvd2VyLCBhcyB3ZSBoYXZlIHRvIGFsbG9jYXRlIHF1aXRlIGEgbG90IG9mIHN0YXRlIHRvIHRyYWNrIGVudW1lcmF0aW9uIG9mIGEgdHJlZS5cbiAgICAgICBBdm9pZCBpZiB3ZSBjYW4uXG4gICAgKilcbiAgICBsZXQgc2xvdyB4IHkgfmluaXQgPSBFbnVtLmZvbGRfc3ltbWV0cmljX2RpZmYgeCB5IH5jb21wYXJlX2tleSB+ZGF0YV9lcXVhbCB+ZiB+aW5pdCBpblxuICAgIGxldCBhZGQgYWNjIGsgdiA9IGYgYWNjIChrLCBgUmlnaHQgdikgaW5cbiAgICBsZXQgcmVtb3ZlIGFjYyBrIHYgPSBmIGFjYyAoaywgYExlZnQgdikgaW5cbiAgICBsZXQgZGVsdGEgYWNjIGsgdiB2JyA9IGlmIGRhdGFfZXF1YWwgdiB2JyB0aGVuIGFjYyBlbHNlIGYgYWNjIChrLCBgVW5lcXVhbCAodiwgdicpKSBpblxuICAgICgqIElmIHR3byB0cmVlcyBoYXZlIHRoZSBzYW1lIHN0cnVjdHVyZSBhdCB0aGUgcm9vdCAoYW5kIHRoZSBzYW1lIGtleSwgaWYgdGhleSdyZVxuICAgICAgIFtOb2RlXXMpIHdlIGNhbiB0cml2aWFsbHkgZGlmZiBlYWNoIHN1YnBhcnQgaW4gb2J2aW91cyB3YXlzLiAqKVxuICAgIGxldCByZWMgbG9vcCB0IHQnIGFjYyA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHQgdCdcbiAgICAgIHRoZW4gYWNjXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggdCwgdCcgd2l0aFxuICAgICAgICB8IEVtcHR5LCBuZXdfdmFscyAtPlxuICAgICAgICAgIGZvbGQgbmV3X3ZhbHMgfmluaXQ6YWNjIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gYWRkIGFjYyBrZXkgZGF0YSlcbiAgICAgICAgfCBvbGRfdmFscywgRW1wdHkgLT5cbiAgICAgICAgICBmb2xkIG9sZF92YWxzIH5pbml0OmFjYyB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IHJlbW92ZSBhY2Mga2V5IGRhdGEpXG4gICAgICAgIHwgTGVhZiAoaywgdiksIExlYWYgKGsnLCB2JykgLT5cbiAgICAgICAgICAobWF0Y2ggY29tcGFyZV9rZXkgayBrJyB3aXRoXG4gICAgICAgICAgIHwgeCB3aGVuIHggPSAwIC0+IGRlbHRhIGFjYyBrIHYgdidcbiAgICAgICAgICAgfCB4IHdoZW4geCA8IDAgLT5cbiAgICAgICAgICAgICBsZXQgYWNjID0gcmVtb3ZlIGFjYyBrIHYgaW5cbiAgICAgICAgICAgICBhZGQgYWNjIGsnIHYnXG4gICAgICAgICAgIHwgXyAoKiB3aGVuIHggPiAwICopIC0+XG4gICAgICAgICAgICAgbGV0IGFjYyA9IGFkZCBhY2MgaycgdicgaW5cbiAgICAgICAgICAgICByZW1vdmUgYWNjIGsgdilcbiAgICAgICAgfCBOb2RlIChsLCBrLCB2LCByLCBfKSwgTm9kZSAobCcsIGsnLCB2JywgcicsIF8pIHdoZW4gY29tcGFyZV9rZXkgayBrJyA9IDAgLT5cbiAgICAgICAgICBsZXQgYWNjID0gbG9vcCBsIGwnIGFjYyBpblxuICAgICAgICAgIGxldCBhY2MgPSBkZWx0YSBhY2MgayB2IHYnIGluXG4gICAgICAgICAgbG9vcCByIHInIGFjY1xuICAgICAgICAoKiBPdXIgcm9vdHMgYXJlbid0IHRoZSBzYW1lIGtleS4gRmFsbGJhY2sgdG8gdGhlIHNsb3cgbW9kZS4gVHJlZXMgd2l0aCBzbWFsbFxuICAgICAgICAgICBkaWZmcyB3aWxsIG9ubHkgZG8gdGhpcyBvbiB2ZXJ5IHNtYWxsIHBhcnRzIG9mIHRoZSB0cmVlIChob3BlZnVsbHkgLSBpZiB0aGVcbiAgICAgICAgICAgb3ZlcmFsbCByb290IGlzIHJlYmFsYW5jZWQsIHdlJ2xsIGVhdCB0aGUgd2hvbGUgY29zdCwgdW5mb3J0dW5hdGVseS4pICopXG4gICAgICAgIHwgTm9kZSBfLCBOb2RlIF8gfCBOb2RlIF8sIExlYWYgXyB8IExlYWYgXywgTm9kZSBfIC0+IHNsb3cgdCB0JyB+aW5pdDphY2MpXG4gICAgaW5cbiAgICBsb29wIHQxIHQyIGluaXRcbiAgOztcblxuICBsZXQgcmVjIGxlbmd0aCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAwXG4gICAgfCBMZWFmIF8gLT4gMVxuICAgIHwgTm9kZSAobCwgXywgXywgciwgXykgLT4gbGVuZ3RoIGwgKyBsZW5ndGggciArIDFcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX3RfaWdub3Jpbmdfc3RydWN0dXJlIGhhc2hfZm9sZF9rZXkgaGFzaF9mb2xkX2RhdGEgc3RhdGUgdCA9XG4gICAgZm9sZFxuICAgICAgdFxuICAgICAgfmluaXQ6KGhhc2hfZm9sZF9pbnQgc3RhdGUgKGxlbmd0aCB0KSlcbiAgICAgIH5mOihmdW4gfmtleSB+ZGF0YSBzdGF0ZSAtPiBoYXNoX2ZvbGRfZGF0YSAoaGFzaF9mb2xkX2tleSBzdGF0ZSBrZXkpIGRhdGEpXG4gIDs7XG5cbiAgbGV0IGtleXMgdCA9IGZvbGRfcmlnaHQgfmY6KGZ1biB+a2V5IH5kYXRhOl8gbGlzdCAtPiBrZXkgOjogbGlzdCkgdCB+aW5pdDpbXVxuICBsZXQgZGF0YSB0ID0gZm9sZF9yaWdodCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSBsaXN0IC0+IGRhdGEgOjogbGlzdCkgdCB+aW5pdDpbXVxuXG4gIG1vZHVsZSB0eXBlIEZvbGRhYmxlID0gc2lnXG4gICAgdmFsIG5hbWUgOiBzdHJpbmdcblxuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2IgLT4gZjooJ2IgLT4gJ2EgLT4gJ2IpIC0+ICdiXG4gIGVuZFxuXG4gIG1vZHVsZSBPZl9mb2xkYWJsZSAoTSA6IEZvbGRhYmxlKSA9IHN0cnVjdFxuICAgIGxldCBvZl9mb2xkYWJsZV9mb2xkIGZvbGRhYmxlIH5pbml0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgICBNLmZvbGQgZm9sZGFibGUgfmluaXQ6KGVtcHR5LCAwKSB+ZjooZnVuIChhY2N1bSwgbGVuZ3RoKSAoa2V5LCBkYXRhKSAtPlxuICAgICAgICBsZXQgcHJldl9kYXRhID1cbiAgICAgICAgICBtYXRjaCBmaW5kIGFjY3VtIGtleSB+Y29tcGFyZV9rZXkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBpbml0XG4gICAgICAgICAgfCBTb21lIHByZXYgLT4gcHJldlxuICAgICAgICBpblxuICAgICAgICBsZXQgZGF0YSA9IGYgcHJldl9kYXRhIGRhdGEgaW5cbiAgICAgICAgc2V0IGFjY3VtIH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkpXG4gICAgOztcblxuICAgIGxldCBvZl9mb2xkYWJsZV9yZWR1Y2UgZm9sZGFibGUgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICAgIE0uZm9sZCBmb2xkYWJsZSB+aW5pdDooZW1wdHksIDApIH5mOihmdW4gKGFjY3VtLCBsZW5ndGgpIChrZXksIGRhdGEpIC0+XG4gICAgICAgIGxldCBuZXdfZGF0YSA9XG4gICAgICAgICAgbWF0Y2ggZmluZCBhY2N1bSBrZXkgfmNvbXBhcmVfa2V5IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gZGF0YVxuICAgICAgICAgIHwgU29tZSBwcmV2IC0+IGYgcHJldiBkYXRhXG4gICAgICAgIGluXG4gICAgICAgIHNldCBhY2N1bSB+bGVuZ3RoIH5rZXkgfmRhdGE6bmV3X2RhdGEgfmNvbXBhcmVfa2V5KVxuICAgIDs7XG5cbiAgICBsZXQgb2ZfZm9sZGFibGUgZm9sZGFibGUgfmNvbXBhcmVfa2V5ID1cbiAgICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgICBsZXQgbWFwID1cbiAgICAgICAgICBNLmZvbGQgZm9sZGFibGUgfmluaXQ6KGVtcHR5LCAwKSB+ZjooZnVuICh0LCBsZW5ndGgpIChrZXksIGRhdGEpIC0+XG4gICAgICAgICAgICBsZXQgKChfLCBsZW5ndGgnKSBhcyBhY2MpID0gc2V0IH5sZW5ndGggfmtleSB+ZGF0YSB0IH5jb21wYXJlX2tleSBpblxuICAgICAgICAgICAgaWYgbGVuZ3RoID0gbGVuZ3RoJyB0aGVuIHIucmV0dXJuIChgRHVwbGljYXRlX2tleSBrZXkpIGVsc2UgYWNjKVxuICAgICAgICBpblxuICAgICAgICBgT2sgbWFwKVxuICAgIDs7XG5cbiAgICBsZXQgb2ZfZm9sZGFibGVfb3JfZXJyb3IgZm9sZGFibGUgfmNvbXBhcmF0b3IgPVxuICAgICAgbWF0Y2ggb2ZfZm9sZGFibGUgZm9sZGFibGUgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICAgIHwgYE9rIHggLT4gUmVzdWx0Lk9rIHhcbiAgICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICAgIE9yX2Vycm9yLmVycm9yXG4gICAgICAgICAgKFwiTWFwLm9mX1wiIF4gTS5uYW1lIF4gXCJfb3JfZXJyb3I6IGR1cGxpY2F0ZSBrZXlcIilcbiAgICAgICAgICBrZXlcbiAgICAgICAgICBjb21wYXJhdG9yLnNleHBfb2ZfdFxuICAgIDs7XG5cbiAgICBsZXQgb2ZfZm9sZGFibGVfZXhuIGZvbGRhYmxlIH5jb21wYXJhdG9yID1cbiAgICAgIG1hdGNoIG9mX2ZvbGRhYmxlIGZvbGRhYmxlIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgICB8IGBPayB4IC0+IHhcbiAgICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICAgIEVycm9yLmNyZWF0ZSAoXCJNYXAub2ZfXCIgXiBNLm5hbWUgXiBcIl9leG46IGR1cGxpY2F0ZSBrZXlcIikga2V5IGNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgICAgIHw+IEVycm9yLnJhaXNlXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIE9mX2FsaXN0ID0gT2ZfZm9sZGFibGUgKHN0cnVjdFxuICAgICAgbGV0IG5hbWUgPSBcImFsaXN0XCJcblxuICAgICAgdHlwZSAnYSB0ID0gJ2EgbGlzdFxuXG4gICAgICBsZXQgZm9sZCA9IExpc3QuZm9sZFxuICAgIGVuZClcblxuICBsZXQgb2ZfYWxpc3RfZm9sZCA9IE9mX2FsaXN0Lm9mX2ZvbGRhYmxlX2ZvbGRcbiAgbGV0IG9mX2FsaXN0X3JlZHVjZSA9IE9mX2FsaXN0Lm9mX2ZvbGRhYmxlX3JlZHVjZVxuICBsZXQgb2ZfYWxpc3QgPSBPZl9hbGlzdC5vZl9mb2xkYWJsZVxuICBsZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgPSBPZl9hbGlzdC5vZl9mb2xkYWJsZV9vcl9lcnJvclxuICBsZXQgb2ZfYWxpc3RfZXhuID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVfZXhuXG5cbiAgKCogUmV2ZXJzZSB0aGUgaW5wdXQsIHRoZW4gZm9sZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFRoZSByZXN1bHRpbmcgbWFwIHVzZXMgdGhlIGZpcnN0XG4gICAgIGluc3RhbmNlIG9mIGVhY2gga2V5IGZyb20gdGhlIGlucHV0IGxpc3QuIFRoZSByZWxhdGl2ZSBvcmRlcmluZyBvZiBlbGVtZW50cyBpbiBlYWNoXG4gICAgIG91dHB1dCBsaXN0IGlzIHRoZSBzYW1lIGFzIGluIHRoZSBpbnB1dCBsaXN0LiAqKVxuICBsZXQgb2ZfZm9sZGFibGVfbXVsdGkgZm9sZGFibGUgfmZvbGQgfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgYWxpc3QgPSBmb2xkIGZvbGRhYmxlIH5pbml0OltdIH5mOihmdW4gbCB4IC0+IHggOjogbCkgaW5cbiAgICBvZl9hbGlzdF9mb2xkIGFsaXN0IH5pbml0OltdIH5mOihmdW4gbCB4IC0+IHggOjogbCkgfmNvbXBhcmVfa2V5XG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X211bHRpIGFsaXN0IH5jb21wYXJlX2tleSA9XG4gICAgb2ZfZm9sZGFibGVfbXVsdGkgYWxpc3QgfmZvbGQ6TGlzdC5mb2xkIH5jb21wYXJlX2tleVxuICA7O1xuXG4gIG1vZHVsZSBPZl9zZXF1ZW5jZSA9IE9mX2ZvbGRhYmxlIChzdHJ1Y3RcbiAgICAgIGxldCBuYW1lID0gXCJzZXF1ZW5jZVwiXG5cbiAgICAgIHR5cGUgJ2EgdCA9ICdhIFNlcXVlbmNlLnRcblxuICAgICAgbGV0IGZvbGQgPSBTZXF1ZW5jZS5mb2xkXG4gICAgZW5kKVxuXG4gIGxldCBvZl9zZXF1ZW5jZV9mb2xkID0gT2Zfc2VxdWVuY2Uub2ZfZm9sZGFibGVfZm9sZFxuICBsZXQgb2Zfc2VxdWVuY2VfcmVkdWNlID0gT2Zfc2VxdWVuY2Uub2ZfZm9sZGFibGVfcmVkdWNlXG4gIGxldCBvZl9zZXF1ZW5jZSA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlXG4gIGxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX29yX2Vycm9yXG4gIGxldCBvZl9zZXF1ZW5jZV9leG4gPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZV9leG5cblxuICBsZXQgb2Zfc2VxdWVuY2VfbXVsdGkgc2VxdWVuY2UgfmNvbXBhcmVfa2V5ID1cbiAgICBvZl9mb2xkYWJsZV9tdWx0aSBzZXF1ZW5jZSB+Zm9sZDpTZXF1ZW5jZS5mb2xkIH5jb21wYXJlX2tleVxuICA7O1xuXG4gIGxldCBmb3JfYWxsIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgaXRlciB0IH5mOihmdW4gZGF0YSAtPiBpZiBub3QgKGYgZGF0YSkgdGhlbiByLnJldHVybiBmYWxzZSk7XG4gICAgICB0cnVlKVxuICA7O1xuXG4gIGxldCBmb3JfYWxsaSB0IH5mID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGlmIG5vdCAoZiB+a2V5IH5kYXRhKSB0aGVuIHIucmV0dXJuIGZhbHNlKTtcbiAgICAgIHRydWUpXG4gIDs7XG5cbiAgbGV0IGV4aXN0cyB0IH5mID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgIGl0ZXIgdCB+ZjooZnVuIGRhdGEgLT4gaWYgZiBkYXRhIHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgICBmYWxzZSlcbiAgOztcblxuICBsZXQgZXhpc3RzaSB0IH5mID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIHIucmV0dXJuIHRydWUpO1xuICAgICAgZmFsc2UpXG4gIDs7XG5cbiAgbGV0IGNvdW50IHQgfmYgPVxuICAgIGZvbGQgdCB+aW5pdDowIH5mOihmdW4gfmtleTpfIH5kYXRhIGFjYyAtPiBpZiBmIGRhdGEgdGhlbiBhY2MgKyAxIGVsc2UgYWNjKVxuICA7O1xuXG4gIGxldCBjb3VudGkgdCB+ZiA9XG4gICAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBhY2MgKyAxIGVsc2UgYWNjKVxuICA7O1xuXG4gIGxldCB0b19hbGlzdCA/KGtleV9vcmRlciA9IGBJbmNyZWFzaW5nKSB0ID1cbiAgICBtYXRjaCBrZXlfb3JkZXIgd2l0aFxuICAgIHwgYEluY3JlYXNpbmcgLT4gZm9sZF9yaWdodCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSB4IC0+IChrZXksIGRhdGEpIDo6IHgpXG4gICAgfCBgRGVjcmVhc2luZyAtPiBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhIHggLT4gKGtleSwgZGF0YSkgOjogeClcbiAgOztcblxuICBsZXQgbWVyZ2UgdDEgdDIgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgZWx0cyA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW46KGxlbmd0aCB0MSArIGxlbmd0aCB0MikgaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgaXRlcjIgdDEgdDIgfmNvbXBhcmVfa2V5IH5mOihmdW4gfmtleSB+ZGF0YTp2YWx1ZXMgLT5cbiAgICAgIG1hdGNoIGYgfmtleSB2YWx1ZXMgd2l0aFxuICAgICAgfCBTb21lIHZhbHVlIC0+XG4gICAgICAgIFVuaWZvcm1fYXJyYXkuc2V0IGVsdHMgIWkgKGtleSwgdmFsdWUpO1xuICAgICAgICBpbmNyIGlcbiAgICAgIHwgTm9uZSAtPiAoKSk7XG4gICAgbGV0IGxlbiA9ICFpIGluXG4gICAgbGV0IGdldCBpID0gVW5pZm9ybV9hcnJheS5nZXQgZWx0cyBpIGluXG4gICAgbGV0IHRyZWUgPSBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mOmdldCBpblxuICAgIHRyZWUsIGxlblxuICA7O1xuXG4gIGxldCBtZXJnZV9za2V3ZWQgPVxuICAgIGxldCBtZXJnZV9sYXJnZV9maXJzdCBsZW5ndGhfbGFyZ2UgdF9sYXJnZSB0X3NtYWxsIH5jYWxsIH5jb21iaW5lIH5jb21wYXJlX2tleSA9XG4gICAgICBmb2xkIHRfc21hbGwgfmluaXQ6KHRfbGFyZ2UsIGxlbmd0aF9sYXJnZSkgfmY6KGZ1biB+a2V5IH5kYXRhOmRhdGEnICh0LCBsZW5ndGgpIC0+XG4gICAgICAgIHVwZGF0ZSB0IGtleSB+bGVuZ3RoIH5jb21wYXJlX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICB8IE5vbmUgLT4gZGF0YSdcbiAgICAgICAgICB8IFNvbWUgZGF0YSAtPiBjYWxsIGNvbWJpbmUgfmtleSBkYXRhIGRhdGEnKSlcbiAgICBpblxuICAgIGxldCBjYWxsIGYgfmtleSB4IHkgPSBmIH5rZXkgeCB5IGluXG4gICAgbGV0IHN3YXAgZiB+a2V5IHggeSA9IGYgfmtleSB5IHggaW5cbiAgICBmdW4gdDEgdDIgfmxlbmd0aDEgfmxlbmd0aDIgfmNvbWJpbmUgfmNvbXBhcmVfa2V5IC0+XG4gICAgICBpZiBsZW5ndGgyIDw9IGxlbmd0aDFcbiAgICAgIHRoZW4gbWVyZ2VfbGFyZ2VfZmlyc3QgbGVuZ3RoMSB0MSB0MiB+Y2FsbCB+Y29tYmluZSB+Y29tcGFyZV9rZXlcbiAgICAgIGVsc2UgbWVyZ2VfbGFyZ2VfZmlyc3QgbGVuZ3RoMiB0MiB0MSB+Y2FsbDpzd2FwIH5jb21iaW5lIH5jb21wYXJlX2tleVxuICA7O1xuXG4gIG1vZHVsZSBDbG9zZXN0X2tleV9pbXBsID0gc3RydWN0XG4gICAgKCogW21hcmtlcl0gYW5kIFtyZXBhY2thZ2VdIGFsbG93IHVzIHRvIGNyZWF0ZSBcImxvZ2ljYWxcIiBvcHRpb25zIHdpdGhvdXQgYWN0dWFsbHlcbiAgICAgICBhbGxvY2F0aW5nIGFueSBvcHRpb25zLiBQYXNzaW5nIFtGb3VuZCBrZXkgdmFsdWVdIHRvIGEgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0b1xuICAgICAgIHBhc3NpbmcgW1NvbWUgKGtleSwgdmFsdWUpXTsgcGFzc2luZyBbTWlzc2luZyAoKSAoKV0gaXMgZXF1aXZhbGVudCB0byBwYXNzaW5nXG4gICAgICAgW05vbmVdLiAqKVxuICAgIHR5cGUgKCdrLCAndiwgJ2tfb3B0LCAndl9vcHQpIG1hcmtlciA9XG4gICAgICB8IE1pc3NpbmcgOiAoJ2ssICd2LCB1bml0LCB1bml0KSBtYXJrZXJcbiAgICAgIHwgRm91bmQgOiAoJ2ssICd2LCAnaywgJ3YpIG1hcmtlclxuXG4gICAgbGV0IHJlcGFja2FnZVxuICAgICAgICAgICh0eXBlIGsgdiBrX29wdCB2X29wdClcbiAgICAgICAgICAobWFya2VyIDogKGssIHYsIGtfb3B0LCB2X29wdCkgbWFya2VyKVxuICAgICAgICAgIChrIDoga19vcHQpXG4gICAgICAgICAgKHYgOiB2X29wdClcbiAgICAgIDogKGsgKiB2KSBvcHRpb25cbiAgICAgID1cbiAgICAgIG1hdGNoIG1hcmtlciB3aXRoXG4gICAgICB8IE1pc3NpbmcgLT4gTm9uZVxuICAgICAgfCBGb3VuZCAtPiBTb21lIChrLCB2KVxuICAgIDs7XG5cbiAgICAoKiBUaGUgdHlwZSBzaWduYXR1cmUgaXMgZXhwbGljaXQgaGVyZSB0byBhbGxvdyBwb2x5bW9ycGhpYyByZWN1cnNpb24uICopXG4gICAgbGV0IHJlYyBsb29wIDpcbiAgICAgICdrICd2ICdrX29wdCAndl9vcHQuXG4gICAgICAoJ2ssICd2KSB0cmVlXG4gICAgICAtPiBbIGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiBdXG4gICAgICAtPiAna1xuICAgICAgLT4gY29tcGFyZV9rZXk6KCdrIC0+ICdrIC0+IGludClcbiAgICAgIC0+ICgnaywgJ3YsICdrX29wdCwgJ3Zfb3B0KSBtYXJrZXJcbiAgICAgIC0+ICdrX29wdFxuICAgICAgLT4gJ3Zfb3B0XG4gICAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG4gICAgICA9XG4gICAgICBmdW4gdCBkaXIgayB+Y29tcGFyZV9rZXkgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZSAtPlxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiByZXBhY2thZ2UgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZVxuICAgICAgICB8IExlYWYgKGsnLCB2JykgLT5cbiAgICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGsnIGsgaW5cbiAgICAgICAgICBpZiBtYXRjaCBkaXIgd2l0aFxuICAgICAgICAgICAgfCBgR3JlYXRlcl9vcl9lcXVhbF90byAtPiBjID49IDBcbiAgICAgICAgICAgIHwgYEdyZWF0ZXJfdGhhbiAtPiBjID4gMFxuICAgICAgICAgICAgfCBgTGVzc19vcl9lcXVhbF90byAtPiBjIDw9IDBcbiAgICAgICAgICAgIHwgYExlc3NfdGhhbiAtPiBjIDwgMFxuICAgICAgICAgIHRoZW4gU29tZSAoaycsIHYnKVxuICAgICAgICAgIGVsc2UgcmVwYWNrYWdlIGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWVcbiAgICAgICAgfCBOb2RlIChsLCBrJywgdicsIHIsIF8pIC0+XG4gICAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrJyBrIGluXG4gICAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICgqIFRoaXMgaXMgYSBiYXNlIGNhc2UgKG5vIHJlY3Vyc2l2ZSBjYWxsKS4gKilcbiAgICAgICAgICAgIG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgICB8IGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYExlc3Nfb3JfZXF1YWxfdG8gLT4gU29tZSAoaycsIHYnKVxuICAgICAgICAgICAgfCBgR3JlYXRlcl90aGFuIC0+XG4gICAgICAgICAgICAgIGlmIGlzX2VtcHR5IHIgdGhlbiByZXBhY2thZ2UgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZSBlbHNlIG1pbl9lbHQgclxuICAgICAgICAgICAgfCBgTGVzc190aGFuIC0+XG4gICAgICAgICAgICAgIGlmIGlzX2VtcHR5IGwgdGhlbiByZXBhY2thZ2UgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZSBlbHNlIG1heF9lbHQgbClcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICgqIFdlIGFyZSBndWFyYW50ZWVkIGhlcmUgdGhhdCBrJyA8PiBrLiAqKVxuICAgICAgICAgICAgKCogVGhpcyBpcyB0aGUgb25seSByZWN1cnNpdmUgY2FzZS4gKilcbiAgICAgICAgICAgIG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgICB8IGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiAtPlxuICAgICAgICAgICAgICBpZiBjID4gMFxuICAgICAgICAgICAgICB0aGVuIGxvb3AgbCBkaXIgayB+Y29tcGFyZV9rZXkgRm91bmQgaycgdidcbiAgICAgICAgICAgICAgZWxzZSBsb29wIHIgZGlyIGsgfmNvbXBhcmVfa2V5IGZvdW5kX21hcmtlciBmb3VuZF9rZXkgZm91bmRfdmFsdWVcbiAgICAgICAgICAgIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIC0+XG4gICAgICAgICAgICAgIGlmIGMgPCAwXG4gICAgICAgICAgICAgIHRoZW4gbG9vcCByIGRpciBrIH5jb21wYXJlX2tleSBGb3VuZCBrJyB2J1xuICAgICAgICAgICAgICBlbHNlIGxvb3AgbCBkaXIgayB+Y29tcGFyZV9rZXkgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZSlcbiAgICA7O1xuXG4gICAgbGV0IGNsb3Nlc3Rfa2V5IHQgZGlyIGsgfmNvbXBhcmVfa2V5ID0gbG9vcCB0IGRpciBrIH5jb21wYXJlX2tleSBNaXNzaW5nICgpICgpXG4gIGVuZFxuXG4gIGxldCBjbG9zZXN0X2tleSA9IENsb3Nlc3Rfa2V5X2ltcGwuY2xvc2VzdF9rZXlcblxuICBsZXQgcmVjIHJhbmsgdCBrIH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIChrJywgXykgLT4gaWYgY29tcGFyZV9rZXkgaycgayA9IDAgdGhlbiBTb21lIDAgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCBrJywgXywgciwgXykgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgaycgayBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gU29tZSAobGVuZ3RoIGwpXG4gICAgICBlbHNlIGlmIGMgPiAwXG4gICAgICB0aGVuIHJhbmsgbCBrIH5jb21wYXJlX2tleVxuICAgICAgZWxzZSBPcHRpb24ubWFwIChyYW5rIHIgayB+Y29tcGFyZV9rZXkpIH5mOihmdW4gcmFuayAtPiByYW5rICsgMSArIGxlbmd0aCBsKVxuICA7O1xuXG4gICgqIHRoaXMgY291bGQgYmUgaW1wbGVtZW50ZWQgdXNpbmcgW1NlcXVlbmNlXSBpbnRlcmZhY2UgYnV0IHRoZSBmb2xsb3dpbmcgaW1wbGVtZW50YXRpb25cbiAgICAgYWxsb2NhdGVzIG9ubHkgMiB3b3JkcyBhbmQgZG9lc24ndCByZXF1aXJlIHdyaXRlLWJhcnJpZXIgKilcbiAgbGV0IHJlYyBudGgnIG51bV90b19zZWFyY2ggPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiAoaywgdikgLT5cbiAgICAgIGlmICFudW1fdG9fc2VhcmNoID0gMFxuICAgICAgdGhlbiBTb21lIChrLCB2KVxuICAgICAgZWxzZSAoXG4gICAgICAgIGRlY3IgbnVtX3RvX3NlYXJjaDtcbiAgICAgICAgTm9uZSlcbiAgICB8IE5vZGUgKGwsIGssIHYsIHIsIF8pIC0+XG4gICAgICAobWF0Y2ggbnRoJyBudW1fdG9fc2VhcmNoIGwgd2l0aFxuICAgICAgIHwgU29tZSBfIGFzIHNvbWUgLT4gc29tZVxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgaWYgIW51bV90b19zZWFyY2ggPSAwXG4gICAgICAgICB0aGVuIFNvbWUgKGssIHYpXG4gICAgICAgICBlbHNlIChcbiAgICAgICAgICAgZGVjciBudW1fdG9fc2VhcmNoO1xuICAgICAgICAgICBudGgnIG51bV90b19zZWFyY2ggcikpXG4gIDs7XG5cbiAgbGV0IG50aCB0IG4gPSBudGgnIChyZWYgbikgdFxuXG5cbiAgbGV0IHJlYyBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIChrLCB2KSAtPiBpZiBmIH5rZXk6ayB+ZGF0YTp2IHRoZW4gU29tZSAoaywgdikgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCBrLCB2LCByLCBfKSAtPlxuICAgICAgaWYgZiB+a2V5OmsgfmRhdGE6dlxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyBsIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFNvbWUgKGssIHYpXG4gICAgICAgIHwgU29tZSBfIGFzIHggLT4geClcbiAgICAgIGVsc2UgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHIgfmZcbiAgOztcblxuICBsZXQgcmVjIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiAoaywgdikgLT4gaWYgZiB+a2V5OmsgfmRhdGE6diB0aGVuIFNvbWUgKGssIHYpIGVsc2UgTm9uZVxuICAgIHwgTm9kZSAobCwgaywgdiwgciwgXykgLT5cbiAgICAgIGlmIGYgfmtleTprIH5kYXRhOnZcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBmaW5kX2xhc3Rfc2F0aXNmeWluZyByIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFNvbWUgKGssIHYpXG4gICAgICAgIHwgU29tZSBfIGFzIHggLT4geClcbiAgICAgIGVsc2UgZmluZF9sYXN0X3NhdGlzZnlpbmcgbCB+ZlxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHYgPVxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gLT5cbiAgICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2IDwgMClcbiAgICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAtPlxuICAgICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPD0gMClcbiAgICB8IGBGaXJzdF9lcXVhbF90byAtPlxuICAgICAgKG1hdGNoIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA+PSAwKSB3aXRoXG4gICAgICAgfCBTb21lIChrZXksIGRhdGEpIGFzIHBhaXIgd2hlbiBjb21wYXJlIH5rZXkgfmRhdGEgdiA9IDAgLT4gcGFpclxuICAgICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICAgIHwgYExhc3RfZXF1YWxfdG8gLT5cbiAgICAgIChtYXRjaCBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA8PSAwKSB3aXRoXG4gICAgICAgfCBTb21lIChrZXksIGRhdGEpIGFzIHBhaXIgd2hlbiBjb21wYXJlIH5rZXkgfmRhdGEgdiA9IDAgLT4gcGFpclxuICAgICAgIHwgTm9uZSB8IFNvbWUgXyAtPiBOb25lKVxuICAgIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAtPlxuICAgICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2ID49IDApXG4gICAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuIC0+XG4gICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPiAwKVxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgbGV0IGlzX2xlZnQgfmtleSB+ZGF0YSA9XG4gICAgICBtYXRjaCBzZWdtZW50X29mIH5rZXkgfmRhdGEgd2l0aFxuICAgICAgfCBgTGVmdCAtPiB0cnVlXG4gICAgICB8IGBSaWdodCAtPiBmYWxzZVxuICAgIGluXG4gICAgbGV0IGlzX3JpZ2h0IH5rZXkgfmRhdGEgPSBub3QgKGlzX2xlZnQgfmtleSB+ZGF0YSkgaW5cbiAgICBtYXRjaCBob3cgd2l0aFxuICAgIHwgYExhc3Rfb25fbGVmdCAtPiBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOmlzX2xlZnRcbiAgICB8IGBGaXJzdF9vbl9yaWdodCAtPiBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Zjppc19yaWdodFxuICA7O1xuXG4gICgqIFtiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZF0gZmluZHMgdGhlIGtleSBpbiBbdF0gd2hpY2ggc2F0aXNmaWVzIFttYXliZV9ib3VuZF1cbiAgICAgYW5kIHRoZSByZWxldmFudCBvbmUgb2YgW2lmX2V4Y2x1c2l2ZV0gb3IgW2lmX2luY2x1c2l2ZV0sIGFzIGp1ZGdlZCBieSBbY29tcGFyZV0uICopXG4gIGxldCBiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZCB0IG1heWJlX2JvdW5kIH5jb21wYXJlIH5pZl9leGNsdXNpdmUgfmlmX2luY2x1c2l2ZSA9XG4gICAgbGV0IGZpbmRfYm91bmQgdCBob3cgYm91bmQgfmNvbXBhcmUgOiBfIE1heWJlX2JvdW5kLnQgb3B0aW9uID1cbiAgICAgIG1hdGNoIGJpbmFyeV9zZWFyY2ggdCBob3cgYm91bmQgfmNvbXBhcmUgd2l0aFxuICAgICAgfCBTb21lIChib3VuZCwgXykgLT4gU29tZSAoSW5jbCBib3VuZClcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgaW5cbiAgICBtYXRjaCAobWF5YmVfYm91bmQgOiBfIE1heWJlX2JvdW5kLnQpIHdpdGhcbiAgICB8IEV4Y2wgYm91bmQgLT4gZmluZF9ib3VuZCB0IGlmX2V4Y2x1c2l2ZSBib3VuZCB+Y29tcGFyZVxuICAgIHwgSW5jbCBib3VuZCAtPiBmaW5kX2JvdW5kIHQgaWZfaW5jbHVzaXZlIGJvdW5kIH5jb21wYXJlXG4gICAgfCBVbmJvdW5kZWQgLT4gU29tZSBVbmJvdW5kZWRcbiAgOztcblxuICAoKiBbYmluYXJ5X3NlYXJjaF90d29fc2lkZWRfYm91bmRzXSBmaW5kcyB0aGUgKG5vdCBuZWNlc3NhcmlseSBkaXN0aW5jdCkga2V5cyBpbiBbdF1cbiAgICAgd2hpY2ggbW9zdCBjbG9zZWx5IGFwcHJvYWNoIChidXQgZG8gbm90IGNyb3NzKSBbbG93ZXJfYm91bmRdIGFuZCBbdXBwZXJfYm91bmRdLCBhc1xuICAgICBqdWRnZWQgYnkgW2NvbXBhcmVdLiBJdCByZXR1cm5zIFtOb25lXSBpZiBubyBrZXlzIGluIFt0XSBhcmUgd2l0aGluIHRoYXQgcmFuZ2UuICopXG4gIGxldCBiaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMgdCB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBsZXQgZmluZF9sb3dlcl9ib3VuZCB0IG1heWJlX2JvdW5kIH5jb21wYXJlID1cbiAgICAgIGJpbmFyeV9zZWFyY2hfb25lX3NpZGVkX2JvdW5kXG4gICAgICAgIHRcbiAgICAgICAgbWF5YmVfYm91bmRcbiAgICAgICAgfmNvbXBhcmVcbiAgICAgICAgfmlmX2V4Y2x1c2l2ZTpgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuXG4gICAgICAgIH5pZl9pbmNsdXNpdmU6YEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90b1xuICAgIGluXG4gICAgbGV0IGZpbmRfdXBwZXJfYm91bmQgdCBtYXliZV9ib3VuZCB+Y29tcGFyZSA9XG4gICAgICBiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZFxuICAgICAgICB0XG4gICAgICAgIG1heWJlX2JvdW5kXG4gICAgICAgIH5jb21wYXJlXG4gICAgICAgIH5pZl9leGNsdXNpdmU6YExhc3Rfc3RyaWN0bHlfbGVzc190aGFuXG4gICAgICAgIH5pZl9pbmNsdXNpdmU6YExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvXG4gICAgaW5cbiAgICBtYXRjaCBmaW5kX2xvd2VyX2JvdW5kIHQgbG93ZXJfYm91bmQgfmNvbXBhcmUgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGxvd2VyX2JvdW5kIC0+XG4gICAgICAobWF0Y2ggZmluZF91cHBlcl9ib3VuZCB0IHVwcGVyX2JvdW5kIH5jb21wYXJlIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgIHwgU29tZSB1cHBlcl9ib3VuZCAtPiBTb21lIChsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQpKVxuICA7O1xuXG4gIHR5cGUgKCdrLCAndikgYWNjID1cbiAgICB7IG11dGFibGUgYmFkX2tleSA6ICdrIG9wdGlvblxuICAgIDsgbXV0YWJsZSBtYXBfbGVuZ3RoIDogKCdrLCAndikgdCAqIGludFxuICAgIH1cblxuICBsZXQgb2ZfaXRlcmkgfml0ZXJpIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IGFjYyA9IHsgYmFkX2tleSA9IE5vbmU7IG1hcF9sZW5ndGggPSBlbXB0eSwgMCB9IGluXG4gICAgaXRlcmkgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICBsZXQgbWFwLCBsZW5ndGggPSBhY2MubWFwX2xlbmd0aCBpblxuICAgICAgbGV0ICgoXywgbGVuZ3RoJykgYXMgcGFpcikgPSBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhIG1hcCB+Y29tcGFyZV9rZXkgaW5cbiAgICAgIGlmIGxlbmd0aCA9IGxlbmd0aCcgJiYgT3B0aW9uLmlzX25vbmUgYWNjLmJhZF9rZXlcbiAgICAgIHRoZW4gYWNjLmJhZF9rZXkgPC0gU29tZSBrZXlcbiAgICAgIGVsc2UgYWNjLm1hcF9sZW5ndGggPC0gcGFpcik7XG4gICAgbWF0Y2ggYWNjLmJhZF9rZXkgd2l0aFxuICAgIHwgTm9uZSAtPiBgT2sgYWNjLm1hcF9sZW5ndGhcbiAgICB8IFNvbWUga2V5IC0+IGBEdXBsaWNhdGVfa2V5IGtleVxuICA7O1xuXG4gIGxldCBvZl9pdGVyaV9leG4gfml0ZXJpIH4oY29tcGFyYXRvciA6IF8gQ29tcGFyYXRvci50KSA9XG4gICAgbWF0Y2ggb2ZfaXRlcmkgfml0ZXJpIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rIHYgLT4gdlxuICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICBFcnJvci5jcmVhdGUgXCJNYXAub2ZfaXRlcmlfZXhuOiBkdXBsaWNhdGUga2V5XCIga2V5IGNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgICB8PiBFcnJvci5yYWlzZVxuICA7O1xuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IGtleV9vZl9zZXhwIHZhbHVlX29mX3NleHAgc2V4cCB+KGNvbXBhcmF0b3IgOiBfIENvbXBhcmF0b3IudCkgPVxuICAgIGxldCBhbGlzdCA9IGxpc3Rfb2Zfc2V4cCAocGFpcl9vZl9zZXhwIGtleV9vZl9zZXhwIHZhbHVlX29mX3NleHApIHNleHAgaW5cbiAgICBsZXQgY29tcGFyZV9rZXkgPSBjb21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgICBtYXRjaCBvZl9hbGlzdCBhbGlzdCB+Y29tcGFyZV9rZXkgd2l0aFxuICAgIHwgYE9rIHYgLT4gdlxuICAgIHwgYER1cGxpY2F0ZV9rZXkgayAtPlxuICAgICAgKCogZmluZCB0aGUgc2V4cCBvZiBhIGR1cGxpY2F0ZSBrZXksIHNvIHRoZSBlcnJvciBpcyBuYXJyb3dlZCB0byBhIGtleSBhbmQgbm90XG4gICAgICAgICB0aGUgd2hvbGUgbWFwICopXG4gICAgICBsZXQgYWxpc3Rfc2V4cHMgPSBsaXN0X29mX3NleHAgKHBhaXJfb2Zfc2V4cCBGbi5pZCBGbi5pZCkgc2V4cCBpblxuICAgICAgbGV0IGZvdW5kX2ZpcnN0X2sgPSByZWYgZmFsc2UgaW5cbiAgICAgIExpc3QuaXRlcjJfb2sgYWxpc3QgYWxpc3Rfc2V4cHMgfmY6KGZ1biAoazIsIF8pIChrMl9zZXhwLCBfKSAtPlxuICAgICAgICBpZiBjb21wYXJlX2tleSBrIGsyID0gMFxuICAgICAgICB0aGVuXG4gICAgICAgICAgaWYgIWZvdW5kX2ZpcnN0X2tcbiAgICAgICAgICB0aGVuIG9mX3NleHBfZXJyb3IgXCJNYXAudF9vZl9zZXhwX2RpcmVjdDogZHVwbGljYXRlIGtleVwiIGsyX3NleHBcbiAgICAgICAgICBlbHNlIGZvdW5kX2ZpcnN0X2sgOj0gdHJ1ZSk7XG4gICAgICBhc3NlcnQgZmFsc2VcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2Zfa2V5IHNleHBfb2ZfdmFsdWUgdCA9XG4gICAgbGV0IGYgfmtleSB+ZGF0YSBhY2MgPSBTZXhwLkxpc3QgWyBzZXhwX29mX2tleSBrZXk7IHNleHBfb2ZfdmFsdWUgZGF0YSBdIDo6IGFjYyBpblxuICAgIFNleHAuTGlzdCAoZm9sZF9yaWdodCB+ZiB0IH5pbml0OltdKVxuICA7O1xuXG4gIGxldCBjb21iaW5lX2Vycm9ycyB0IH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgPVxuICAgIGxldCBva3MsIChlcnJvcl90cmVlLCBfKSA9IHBhcnRpdGlvbl9tYXAgdCB+Y29tcGFyZV9rZXkgfmY6UmVzdWx0LnRvX2VpdGhlciBpblxuICAgIGlmIGlzX2VtcHR5IGVycm9yX3RyZWVcbiAgICB0aGVuIE9rIG9rc1xuICAgIGVsc2UgT3JfZXJyb3IuZXJyb3JfcyAoc2V4cF9vZl90IHNleHBfb2Zfa2V5IEVycm9yLnNleHBfb2ZfdCBlcnJvcl90cmVlKVxuICA7O1xuXG4gIGxldCBtYXBfa2V5c1xuICAgICAgICB0MVxuICAgICAgICB+ZlxuICAgICAgICB+Y29tcGFyYXRvcjooeyBjb21wYXJlID0gY29tcGFyZV9rZXk7IHNleHBfb2ZfdCA9IHNleHBfb2Zfa2V5IH0gOiBfIENvbXBhcmF0b3IudClcbiAgICA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgICBgT2tcbiAgICAgICAgKGZvbGQgdDEgfmluaXQ6KGVtcHR5LCAwKSB+ZjooZnVuIH5rZXkgfmRhdGEgKHQyLCBsZW5ndGgpIC0+XG4gICAgICAgICAgIGxldCBrZXkgPSBmIGtleSBpblxuICAgICAgICAgICB0cnkgYWRkX2V4bl9pbnRlcm5hbCB0MiB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSB3aXRoXG4gICAgICAgICAgIHwgRHVwbGljYXRlIC0+IHJldHVybiAoYER1cGxpY2F0ZV9rZXkga2V5KSkpKVxuICA7O1xuXG4gIGxldCBtYXBfa2V5c19leG4gdCB+ZiB+Y29tcGFyYXRvciA9XG4gICAgbWF0Y2ggbWFwX2tleXMgdCB+ZiB+Y29tcGFyYXRvciB3aXRoXG4gICAgfCBgT2sgcmVzdWx0IC0+IHJlc3VsdFxuICAgIHwgYER1cGxpY2F0ZV9rZXkga2V5IC0+XG4gICAgICBsZXQgc2V4cF9vZl9rZXkgPSBjb21wYXJhdG9yLkNvbXBhcmF0b3Iuc2V4cF9vZl90IGluXG4gICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2UgXCJNYXAubWFwX2tleXNfZXhuOiBkdXBsaWNhdGUga2V5XCIgWyBcImtleVwiLCBrZXkgfD4gc2V4cF9vZl9rZXkgXSlcbiAgOztcbmVuZFxuXG50eXBlICgnaywgJ3YsICdjb21wYXJhdG9yKSB0ID1cbiAgeyAoKiBbY29tcGFyYXRvcl0gaXMgdGhlIGZpcnN0IGZpZWxkIHNvIHRoYXQgcG9seW1vcnBoaWMgZXF1YWxpdHkgZmFpbHMgb24gYSBtYXAgZHVlXG4gICAgICAgdG8gdGhlIGZ1bmN0aW9uYWwgdmFsdWUgaW4gdGhlIGNvbXBhcmF0b3IuXG4gICAgICAgTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgYWZmZWN0IHBvbHltb3JwaGljIFtjb21wYXJlXTogdGhhdCBzdGlsbCBwcm9kdWNlc1xuICAgICAgIG5vbnNlbnNlLiAqKVxuICAgIGNvbXBhcmF0b3IgOiAoJ2ssICdjb21wYXJhdG9yKSBDb21wYXJhdG9yLnRcbiAgOyB0cmVlIDogKCdrLCAndikgVHJlZTAudFxuICA7IGxlbmd0aCA6IGludFxuICB9XG5cbnR5cGUgKCdrLCAndiwgJ2NvbXBhcmF0b3IpIHRyZWUgPSAoJ2ssICd2KSBUcmVlMC50XG5cbmxldCBjb21wYXJlX2tleSB0ID0gdC5jb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuXG5cbmxldCBsaWtlIHsgdHJlZSA9IF87IGxlbmd0aCA9IF87IGNvbXBhcmF0b3IgfSAodHJlZSwgbGVuZ3RoKSA9XG4gIHsgdHJlZTsgbGVuZ3RoOyBjb21wYXJhdG9yIH1cbjs7XG5cbmxldCBsaWtlMiB4ICh5LCB6KSA9IGxpa2UgeCB5LCBsaWtlIHggelxuXG5sZXQgbGlrZV9tYXliZV9ub19vcCAoeyB0cmVlID0gb2xkX3RyZWU7IGxlbmd0aCA9IF87IGNvbXBhcmF0b3IgfSBhcyBvbGRfdCkgKHRyZWUsIGxlbmd0aClcbiAgPVxuICBpZiBwaHlzX2VxdWFsIG9sZF90cmVlIHRyZWUgdGhlbiBvbGRfdCBlbHNlIHsgdHJlZTsgbGVuZ3RoOyBjb21wYXJhdG9yIH1cbjs7XG5cbmxldCB3aXRoX3NhbWVfbGVuZ3RoIHsgdHJlZSA9IF87IGNvbXBhcmF0b3I7IGxlbmd0aCB9IHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3I7IGxlbmd0aCB9XG5sZXQgb2ZfdHJlZSB+Y29tcGFyYXRvciB0cmVlID0geyB0cmVlOyBjb21wYXJhdG9yOyBsZW5ndGggPSBUcmVlMC5sZW5ndGggdHJlZSB9XG5cbigqIEV4cG9zaW5nIHRoaXMgZnVuY3Rpb24gd291bGQgbWFrZSBpdCB2ZXJ5IGVhc3kgZm9yIHRoZSBpbnZhcmlhbnRzXG4gICBvZiB0aGlzIG1vZHVsZSB0byBiZSBicm9rZW4uICopXG5sZXQgb2ZfdHJlZV91bnNhZmUgfmNvbXBhcmF0b3Igfmxlbmd0aCB0cmVlID0geyB0cmVlOyBjb21wYXJhdG9yOyBsZW5ndGggfVxuXG5tb2R1bGUgQWNjZXNzb3JzID0gc3RydWN0XG4gIGxldCBjb21wYXJhdG9yIHQgPSB0LmNvbXBhcmF0b3JcbiAgbGV0IHRvX3RyZWUgdCA9IHQudHJlZVxuXG4gIGxldCBpbnZhcmlhbnRzIHQgPVxuICAgIFRyZWUwLmludmFyaWFudHMgdC50cmVlIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkgJiYgVHJlZTAubGVuZ3RoIHQudHJlZSA9IHQubGVuZ3RoXG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5IHQgPSBUcmVlMC5pc19lbXB0eSB0LnRyZWVcbiAgbGV0IGxlbmd0aCB0ID0gdC5sZW5ndGhcblxuICBsZXQgc2V0IHQgfmtleSB+ZGF0YSA9XG4gICAgbGlrZSB0IChUcmVlMC5zZXQgdC50cmVlIH5sZW5ndGg6dC5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCBhZGRfZXhuIHQgfmtleSB+ZGF0YSA9XG4gICAgbGlrZVxuICAgICAgdFxuICAgICAgKFRyZWUwLmFkZF9leG5cbiAgICAgICAgIHQudHJlZVxuICAgICAgICAgfmxlbmd0aDp0Lmxlbmd0aFxuICAgICAgICAgfmtleVxuICAgICAgICAgfmRhdGFcbiAgICAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgICAgICAgIH5zZXhwX29mX2tleTp0LmNvbXBhcmF0b3Iuc2V4cF9vZl90KVxuICA7O1xuXG4gIGxldCBhZGRfZXhuX2ludGVybmFsIHQgfmtleSB+ZGF0YSA9XG4gICAgbGlrZVxuICAgICAgdFxuICAgICAgKFRyZWUwLmFkZF9leG5faW50ZXJuYWxcbiAgICAgICAgIHQudHJlZVxuICAgICAgICAgfmxlbmd0aDp0Lmxlbmd0aFxuICAgICAgICAgfmtleVxuICAgICAgICAgfmRhdGFcbiAgICAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgICAgICAgIH5zZXhwX29mX2tleTp0LmNvbXBhcmF0b3Iuc2V4cF9vZl90KVxuICA7O1xuXG4gIGxldCBhZGQgdCB+a2V5IH5kYXRhID1cbiAgICBtYXRjaCBhZGRfZXhuX2ludGVybmFsIHQgfmtleSB+ZGF0YSB3aXRoXG4gICAgfCByZXN1bHQgLT4gYE9rIHJlc3VsdFxuICAgIHwgZXhjZXB0aW9uIER1cGxpY2F0ZSAtPiBgRHVwbGljYXRlXG4gIDs7XG5cbiAgbGV0IGFkZF9tdWx0aSB0IH5rZXkgfmRhdGEgPVxuICAgIGxpa2VcbiAgICAgIHRcbiAgICAgIChUcmVlMC5hZGRfbXVsdGkgdC50cmVlIH5sZW5ndGg6dC5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCByZW1vdmVfbXVsdGkgdCBrZXkgPVxuICAgIGxpa2UgdCAoVHJlZTAucmVtb3ZlX211bHRpIHQudHJlZSB+bGVuZ3RoOnQubGVuZ3RoIGtleSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCBmaW5kX211bHRpIHQga2V5ID0gVHJlZTAuZmluZF9tdWx0aSB0LnRyZWUga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcblxuICBsZXQgY2hhbmdlIHQga2V5IH5mID1cbiAgICBsaWtlIHQgKFRyZWUwLmNoYW5nZSB0LnRyZWUga2V5IH5mIH5sZW5ndGg6dC5sZW5ndGggfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgdXBkYXRlIHQga2V5IH5mID1cbiAgICBsaWtlIHQgKFRyZWUwLnVwZGF0ZSB0LnRyZWUga2V5IH5mIH5sZW5ndGg6dC5sZW5ndGggfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgZmluZF9leG4gdCBrZXkgPVxuICAgIFRyZWUwLmZpbmRfZXhuXG4gICAgICB0LnRyZWVcbiAgICAgIGtleVxuICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgICAgfnNleHBfb2Zfa2V5OnQuY29tcGFyYXRvci5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgZmluZCB0IGtleSA9IFRyZWUwLmZpbmQgdC50cmVlIGtleSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG5cbiAgbGV0IHJlbW92ZSB0IGtleSA9XG4gICAgbGlrZV9tYXliZV9ub19vcFxuICAgICAgdFxuICAgICAgKFRyZWUwLnJlbW92ZSB0LnRyZWUga2V5IH5sZW5ndGg6dC5sZW5ndGggfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgbWVtIHQga2V5ID0gVHJlZTAubWVtIHQudHJlZSBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICBsZXQgaXRlcl9rZXlzIHQgfmYgPSBUcmVlMC5pdGVyX2tleXMgdC50cmVlIH5mXG4gIGxldCBpdGVyIHQgfmYgPSBUcmVlMC5pdGVyIHQudHJlZSB+ZlxuICBsZXQgaXRlcmkgdCB+ZiA9IFRyZWUwLml0ZXJpIHQudHJlZSB+ZlxuICBsZXQgaXRlcmlfdW50aWwgdCB+ZiA9IFRyZWUwLml0ZXJpX3VudGlsIHQudHJlZSB+ZlxuICBsZXQgaXRlcjIgdDEgdDIgfmYgPSBUcmVlMC5pdGVyMiB0MS50cmVlIHQyLnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSlcbiAgbGV0IG1hcCB0IH5mID0gd2l0aF9zYW1lX2xlbmd0aCB0IChUcmVlMC5tYXAgdC50cmVlIH5mKVxuICBsZXQgbWFwaSB0IH5mID0gd2l0aF9zYW1lX2xlbmd0aCB0IChUcmVlMC5tYXBpIHQudHJlZSB+ZilcbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGQgdC50cmVlIH5mIH5pbml0XG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3VudGlsIHQudHJlZSB+ZiB+aW5pdFxuICBsZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF9yaWdodCB0LnRyZWUgfmYgfmluaXRcblxuICBsZXQgZm9sZDIgdDEgdDIgfmluaXQgfmYgPVxuICAgIFRyZWUwLmZvbGQyIHQxLnRyZWUgdDIudHJlZSB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQxKVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfa2V5cyB0IH5mID0gbGlrZSB0IChUcmVlMC5maWx0ZXJfa2V5cyB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgbGV0IGZpbHRlciB0IH5mID0gbGlrZSB0IChUcmVlMC5maWx0ZXIgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIGxldCBmaWx0ZXJpIHQgfmYgPSBsaWtlIHQgKFRyZWUwLmZpbHRlcmkgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIGxldCBmaWx0ZXJfbWFwIHQgfmYgPSBsaWtlIHQgKFRyZWUwLmZpbHRlcl9tYXAgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIGxldCBmaWx0ZXJfbWFwaSB0IH5mID0gbGlrZSB0IChUcmVlMC5maWx0ZXJfbWFwaSB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcblxuICBsZXQgcGFydGl0aW9uX21hcGkgdCB+ZiA9XG4gICAgbGlrZTIgdCAoVHJlZTAucGFydGl0aW9uX21hcGkgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl9tYXAgdCB+ZiA9XG4gICAgbGlrZTIgdCAoVHJlZTAucGFydGl0aW9uX21hcCB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uaV90ZiB0IH5mID1cbiAgICBsaWtlMiB0IChUcmVlMC5wYXJ0aXRpb25pX3RmIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fdGYgdCB+ZiA9XG4gICAgbGlrZTIgdCAoVHJlZTAucGFydGl0aW9uX3RmIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCBjb21iaW5lX2Vycm9ycyB0ID1cbiAgICBPcl9lcnJvci5tYXBcbiAgICAgIH5mOihsaWtlIHQpXG4gICAgICAoVHJlZTAuY29tYmluZV9lcnJvcnNcbiAgICAgICAgIHQudHJlZVxuICAgICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgICAgICAgfnNleHBfb2Zfa2V5OnQuY29tcGFyYXRvci5zZXhwX29mX3QpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfZGlyZWN0IGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgVHJlZTAuY29tcGFyZSAoY29tcGFyZV9rZXkgdDEpIGNvbXBhcmVfZGF0YSB0MS50cmVlIHQyLnRyZWVcbiAgOztcblxuICBsZXQgZXF1YWwgY29tcGFyZV9kYXRhIHQxIHQyID0gVHJlZTAuZXF1YWwgKGNvbXBhcmVfa2V5IHQxKSBjb21wYXJlX2RhdGEgdDEudHJlZSB0Mi50cmVlXG4gIGxldCBrZXlzIHQgPSBUcmVlMC5rZXlzIHQudHJlZVxuICBsZXQgZGF0YSB0ID0gVHJlZTAuZGF0YSB0LnRyZWVcbiAgbGV0IHRvX2FsaXN0ID9rZXlfb3JkZXIgdCA9IFRyZWUwLnRvX2FsaXN0ID9rZXlfb3JkZXIgdC50cmVlXG5cbiAgbGV0IHN5bW1ldHJpY19kaWZmIHQxIHQyIH5kYXRhX2VxdWFsID1cbiAgICBUcmVlMC5zeW1tZXRyaWNfZGlmZiB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSkgfmRhdGFfZXF1YWxcbiAgOztcblxuICBsZXQgZm9sZF9zeW1tZXRyaWNfZGlmZiB0MSB0MiB+ZGF0YV9lcXVhbCB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgdDEudHJlZVxuICAgICAgdDIudHJlZVxuICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0MSlcbiAgICAgIH5kYXRhX2VxdWFsXG4gICAgICB+aW5pdFxuICAgICAgfmZcbiAgOztcblxuICBsZXQgbWVyZ2UgdDEgdDIgfmYgPVxuICAgIGxpa2UgdDEgKFRyZWUwLm1lcmdlIHQxLnRyZWUgdDIudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQxKSlcbiAgOztcblxuICBsZXQgbWVyZ2Vfc2tld2VkIHQxIHQyIH5jb21iaW5lID1cbiAgICAoKiBUaGlzIGlzIG9ubHkgYSBuby1vcCBpbiB0aGUgY2FzZSB3aGVyZSBhdCBsZWFzdCBvbmUgb2YgdGhlIG1hcHMgaXMgZW1wdHkuICopXG4gICAgbGlrZV9tYXliZV9ub19vcFxuICAgICAgKGlmIHQyLmxlbmd0aCA8PSB0MS5sZW5ndGggdGhlbiB0MSBlbHNlIHQyKVxuICAgICAgKFRyZWUwLm1lcmdlX3NrZXdlZFxuICAgICAgICAgdDEudHJlZVxuICAgICAgICAgdDIudHJlZVxuICAgICAgICAgfmxlbmd0aDE6dDEubGVuZ3RoXG4gICAgICAgICB+bGVuZ3RoMjp0Mi5sZW5ndGhcbiAgICAgICAgIH5jb21iaW5lXG4gICAgICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQxKSlcbiAgOztcblxuICBsZXQgbWluX2VsdCB0ID0gVHJlZTAubWluX2VsdCB0LnRyZWVcbiAgbGV0IG1pbl9lbHRfZXhuIHQgPSBUcmVlMC5taW5fZWx0X2V4biB0LnRyZWVcbiAgbGV0IG1heF9lbHQgdCA9IFRyZWUwLm1heF9lbHQgdC50cmVlXG4gIGxldCBtYXhfZWx0X2V4biB0ID0gVHJlZTAubWF4X2VsdF9leG4gdC50cmVlXG4gIGxldCBmb3JfYWxsIHQgfmYgPSBUcmVlMC5mb3JfYWxsIHQudHJlZSB+ZlxuICBsZXQgZm9yX2FsbGkgdCB+ZiA9IFRyZWUwLmZvcl9hbGxpIHQudHJlZSB+ZlxuICBsZXQgZXhpc3RzIHQgfmYgPSBUcmVlMC5leGlzdHMgdC50cmVlIH5mXG4gIGxldCBleGlzdHNpIHQgfmYgPSBUcmVlMC5leGlzdHNpIHQudHJlZSB+ZlxuICBsZXQgY291bnQgdCB+ZiA9IFRyZWUwLmNvdW50IHQudHJlZSB+ZlxuICBsZXQgY291bnRpIHQgfmYgPSBUcmVlMC5jb3VudGkgdC50cmVlIH5mXG5cbiAgbGV0IHNwbGl0IHQgayA9XG4gICAgbGV0IGwsIG1heWJlLCByID0gVHJlZTAuc3BsaXQgdC50cmVlIGsgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSBpblxuICAgIGxldCBjb21wYXJhdG9yID0gY29tcGFyYXRvciB0IGluXG4gICAgKCogVHJ5IHRvIHRyYXZlcnNlIHRoZSBsZWFzdCBhbW91bnQgcG9zc2libGUgdG8gY2FsY3VsYXRlIHRoZSBsZW5ndGgsXG4gICAgICAgdXNpbmcgaGVpZ2h0IGFzIGEgaGV1cmlzdGljLiAqKVxuICAgIGxldCBib3RoX2xlbiA9IGlmIE9wdGlvbi5pc19zb21lIG1heWJlIHRoZW4gdC5sZW5ndGggLSAxIGVsc2UgdC5sZW5ndGggaW5cbiAgICBpZiBUcmVlMC5oZWlnaHQgbCA8IFRyZWUwLmhlaWdodCByXG4gICAgdGhlbiAoXG4gICAgICBsZXQgbCA9IG9mX3RyZWUgbCB+Y29tcGFyYXRvciBpblxuICAgICAgbCwgbWF5YmUsIG9mX3RyZWVfdW5zYWZlIHIgfmNvbXBhcmF0b3Igfmxlbmd0aDooYm90aF9sZW4gLSBsZW5ndGggbCkpXG4gICAgZWxzZSAoXG4gICAgICBsZXQgciA9IG9mX3RyZWUgciB+Y29tcGFyYXRvciBpblxuICAgICAgb2ZfdHJlZV91bnNhZmUgbCB+Y29tcGFyYXRvciB+bGVuZ3RoOihib3RoX2xlbiAtIGxlbmd0aCByKSwgbWF5YmUsIHIpXG4gIDs7XG5cbiAgbGV0IHN1YnJhbmdlIHQgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCA9XG4gICAgbGV0IGxlZnQsIG1pZCwgcmlnaHQgPVxuICAgICAgVHJlZTAuc3BsaXRfcmFuZ2UgdC50cmVlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgIGluXG4gICAgKCogVHJ5IHRvIHRyYXZlcnNlIHRoZSBsZWFzdCBhbW91bnQgcG9zc2libGUgdG8gY2FsY3VsYXRlIHRoZSBsZW5ndGgsXG4gICAgICAgdXNpbmcgaGVpZ2h0IGFzIGEgaGV1cmlzdGljLiAqKVxuICAgIGxldCBvdXRlcl9qb2luZWRfaGVpZ2h0ID1cbiAgICAgIGxldCBoX2wgPSBUcmVlMC5oZWlnaHQgbGVmdFxuICAgICAgYW5kIGhfciA9IFRyZWUwLmhlaWdodCByaWdodCBpblxuICAgICAgaWYgaF9sID0gaF9yIHRoZW4gaF9sICsgMSBlbHNlIG1heCBoX2wgaF9yXG4gICAgaW5cbiAgICBpZiBvdXRlcl9qb2luZWRfaGVpZ2h0IDwgVHJlZTAuaGVpZ2h0IG1pZFxuICAgIHRoZW4gKFxuICAgICAgbGV0IG1pZF9sZW5ndGggPSB0Lmxlbmd0aCAtIChUcmVlMC5sZW5ndGggbGVmdCArIFRyZWUwLmxlbmd0aCByaWdodCkgaW5cbiAgICAgIG9mX3RyZWVfdW5zYWZlIG1pZCB+Y29tcGFyYXRvcjooY29tcGFyYXRvciB0KSB+bGVuZ3RoOm1pZF9sZW5ndGgpXG4gICAgZWxzZSBvZl90cmVlIG1pZCB+Y29tcGFyYXRvcjooY29tcGFyYXRvciB0KVxuICA7O1xuXG4gIGxldCBhcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgPVxuICAgIG1hdGNoXG4gICAgICBUcmVlMC5hcHBlbmRcbiAgICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSBsb3dlcl9wYXJ0KVxuICAgICAgICB+bG93ZXJfcGFydDpsb3dlcl9wYXJ0LnRyZWVcbiAgICAgICAgfnVwcGVyX3BhcnQ6dXBwZXJfcGFydC50cmVlXG4gICAgd2l0aFxuICAgIHwgYE9rIHRyZWUgLT5cbiAgICAgIGBPa1xuICAgICAgICAob2ZfdHJlZV91bnNhZmVcbiAgICAgICAgICAgdHJlZVxuICAgICAgICAgICB+Y29tcGFyYXRvcjooY29tcGFyYXRvciBsb3dlcl9wYXJ0KVxuICAgICAgICAgICB+bGVuZ3RoOihsb3dlcl9wYXJ0Lmxlbmd0aCArIHVwcGVyX3BhcnQubGVuZ3RoKSlcbiAgICB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIC0+IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzXG4gIDs7XG5cbiAgbGV0IGZvbGRfcmFuZ2VfaW5jbHVzaXZlIHQgfm1pbiB+bWF4IH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkX3JhbmdlX2luY2x1c2l2ZSB0LnRyZWUgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgOztcblxuICBsZXQgcmFuZ2VfdG9fYWxpc3QgdCB+bWluIH5tYXggPVxuICAgIFRyZWUwLnJhbmdlX3RvX2FsaXN0IHQudHJlZSB+bWluIH5tYXggfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICA7O1xuXG4gIGxldCBjbG9zZXN0X2tleSB0IGRpciBrZXkgPVxuICAgIFRyZWUwLmNsb3Nlc3Rfa2V5IHQudHJlZSBkaXIga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgOztcblxuICBsZXQgbnRoIHQgbiA9IFRyZWUwLm50aCB0LnRyZWUgblxuICBsZXQgbnRoX2V4biB0IG4gPSBPcHRpb24udmFsdWVfZXhuIChudGggdCBuKVxuICBsZXQgcmFuayB0IGtleSA9IFRyZWUwLnJhbmsgdC50cmVlIGtleSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9rIHNleHBfb2ZfdiBfIHQgPSBUcmVlMC5zZXhwX29mX3Qgc2V4cF9vZl9rIHNleHBfb2ZfdiB0LnRyZWVcblxuICBsZXQgdG9fc2VxdWVuY2UgP29yZGVyID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2tleXNfbGVzc19vcl9lcXVhbF90byB0ID1cbiAgICBUcmVlMC50b19zZXF1ZW5jZVxuICAgICAgdC5jb21wYXJhdG9yXG4gICAgICA/b3JkZXJcbiAgICAgID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG9cbiAgICAgID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG9cbiAgICAgIHQudHJlZVxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHYgPSBUcmVlMC5iaW5hcnlfc2VhcmNoIHQudHJlZSB+Y29tcGFyZSBob3cgdlxuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgVHJlZTAuYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdC50cmVlIH5zZWdtZW50X29mIGhvd1xuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfZGlyZWN0IGhhc2hfZm9sZF9rZXkgaGFzaF9mb2xkX2RhdGEgc3RhdGUgdCA9XG4gICAgVHJlZTAuaGFzaF9mb2xkX3RfaWdub3Jpbmdfc3RydWN0dXJlIGhhc2hfZm9sZF9rZXkgaGFzaF9mb2xkX2RhdGEgc3RhdGUgdC50cmVlXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc3VicmFuZ2UgdCB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBtYXRjaFxuICAgICAgVHJlZTAuYmluYXJ5X3NlYXJjaF90d29fc2lkZWRfYm91bmRzIHQudHJlZSB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kXG4gICAgd2l0aFxuICAgIHwgU29tZSAobG93ZXJfYm91bmQsIHVwcGVyX2JvdW5kKSAtPiBzdWJyYW5nZSB0IH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmRcbiAgICB8IE5vbmUgLT4gbGlrZV9tYXliZV9ub19vcCB0IChFbXB0eSwgMClcbiAgOztcbmVuZFxuXG4oKiBbMF0gaXMgdXNlZCBhcyB0aGUgW2xlbmd0aF0gYXJndW1lbnQgZXZlcnl3aGVyZSBpbiB0aGlzIG1vZHVsZSwgc2luY2UgdHJlZXMgZG8gbm90XG4gICBoYXZlIHRoZWlyIGxlbmd0aHMgc3RvcmVkIGF0IHRoZSByb290LCB1bmxpa2UgbWFwcy4gVGhlIHZhbHVlcyBhcmUgZGlzY2FyZGVkIGFsd2F5cy4gKilcbm1vZHVsZSBUcmVlID0gc3RydWN0XG4gIHR5cGUgKCdrLCAndiwgJ2NvbXBhcmF0b3IpIHQgPSAoJ2ssICd2LCAnY29tcGFyYXRvcikgdHJlZVxuXG4gIGxldCBlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uID0gVHJlZTAuZW1wdHlcbiAgbGV0IGVtcHR5IH5jb21wYXJhdG9yOl8gPSBlbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uXG4gIGxldCBvZl90cmVlIH5jb21wYXJhdG9yOl8gdHJlZSA9IHRyZWVcbiAgbGV0IHNpbmdsZXRvbiB+Y29tcGFyYXRvcjpfIGsgdiA9IFRyZWUwLnNpbmdsZXRvbiBrIHZcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgZnN0IChUcmVlMC5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBUcmVlMC5vZl9zb3J0ZWRfYXJyYXkgYXJyYXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgfD4gT3JfZXJyb3IubWFwIH5mOmZzdFxuICA7O1xuXG4gIGxldCBvZl9hbGlzdCB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgbWF0Y2ggVHJlZTAub2ZfYWxpc3QgYWxpc3QgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZCAtPiBkXG4gICAgfCBgT2sgKHRyZWUsIF9zaXplKSAtPiBgT2sgdHJlZVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9vcl9lcnJvciB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgVHJlZTAub2ZfYWxpc3Rfb3JfZXJyb3IgYWxpc3QgfmNvbXBhcmF0b3IgfD4gT3JfZXJyb3IubWFwIH5mOmZzdFxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9leG4gfmNvbXBhcmF0b3IgYWxpc3QgPSBmc3QgKFRyZWUwLm9mX2FsaXN0X2V4biBhbGlzdCB+Y29tcGFyYXRvcilcblxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIGZzdCAoVHJlZTAub2ZfYWxpc3RfbXVsdGkgYWxpc3QgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9mb2xkIH5jb21wYXJhdG9yIGFsaXN0IH5pbml0IH5mID1cbiAgICBmc3QgKFRyZWUwLm9mX2FsaXN0X2ZvbGQgYWxpc3QgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9yZWR1Y2UgfmNvbXBhcmF0b3IgYWxpc3QgfmYgPVxuICAgIGZzdCAoVHJlZTAub2ZfYWxpc3RfcmVkdWNlIGFsaXN0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfaXRlcmkgfmNvbXBhcmF0b3Igfml0ZXJpID1cbiAgICBtYXRjaCBUcmVlMC5vZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBPayAodHJlZSwgX3NpemUpIC0+IGBPayB0cmVlXG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIGQgLT4gZFxuICA7O1xuXG4gIGxldCBvZl9pdGVyaV9leG4gfmNvbXBhcmF0b3Igfml0ZXJpID0gZnN0IChUcmVlMC5vZl9pdGVyaV9leG4gfml0ZXJpIH5jb21wYXJhdG9yKVxuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvcjpfcmVxdWlyZWRfYnlfaW50ZiB+bGVuIH5mID1cbiAgICBUcmVlMC5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBPcl9lcnJvci5tYXBcbiAgICAgIH5mOmZzdFxuICAgICAgKFRyZWUwLm9mX2luY3JlYXNpbmdfc2VxdWVuY2Ugc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBtYXRjaCBUcmVlMC5vZl9zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZCAtPiBkXG4gICAgfCBgT2sgKHRyZWUsIF9zaXplKSAtPiBgT2sgdHJlZVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciB+Y29tcGFyYXRvciBzZXEgPVxuICAgIFRyZWUwLm9mX3NlcXVlbmNlX29yX2Vycm9yIHNlcSB+Y29tcGFyYXRvciB8PiBPcl9lcnJvci5tYXAgfmY6ZnN0XG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX2V4biB+Y29tcGFyYXRvciBzZXEgPSBmc3QgKFRyZWUwLm9mX3NlcXVlbmNlX2V4biBzZXEgfmNvbXBhcmF0b3IpXG5cbiAgbGV0IG9mX3NlcXVlbmNlX211bHRpIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgZnN0IChUcmVlMC5vZl9zZXF1ZW5jZV9tdWx0aSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9mb2xkIH5jb21wYXJhdG9yIHNlcSB+aW5pdCB+ZiA9XG4gICAgZnN0IChUcmVlMC5vZl9zZXF1ZW5jZV9mb2xkIHNlcSB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX3JlZHVjZSB+Y29tcGFyYXRvciBzZXEgfmYgPVxuICAgIGZzdCAoVHJlZTAub2Zfc2VxdWVuY2VfcmVkdWNlIHNlcSB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IHRvX3RyZWUgdCA9IHRcblxuICBsZXQgaW52YXJpYW50cyB+Y29tcGFyYXRvciB0ID1cbiAgICBUcmVlMC5pbnZhcmlhbnRzIHQgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5IHQgPSBUcmVlMC5pc19lbXB0eSB0XG4gIGxldCBsZW5ndGggdCA9IFRyZWUwLmxlbmd0aCB0XG5cbiAgbGV0IHNldCB+Y29tcGFyYXRvciB0IH5rZXkgfmRhdGEgPVxuICAgIGZzdCAoVHJlZTAuc2V0IHQgfmtleSB+ZGF0YSB+bGVuZ3RoOjAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBhZGRfZXhuIH5jb21wYXJhdG9yIHQgfmtleSB+ZGF0YSA9XG4gICAgZnN0XG4gICAgICAoVHJlZTAuYWRkX2V4blxuICAgICAgICAgdFxuICAgICAgICAgfmtleVxuICAgICAgICAgfmRhdGFcbiAgICAgICAgIH5sZW5ndGg6MFxuICAgICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgICAgICB+c2V4cF9vZl9rZXk6Y29tcGFyYXRvci5zZXhwX29mX3QpXG4gIDs7XG5cbiAgbGV0IGFkZCB+Y29tcGFyYXRvciB0IH5rZXkgfmRhdGEgPVxuICAgIHRyeSBgT2sgKGFkZF9leG4gdCB+Y29tcGFyYXRvciB+a2V5IH5kYXRhKSB3aXRoXG4gICAgfCBfIC0+IGBEdXBsaWNhdGVcbiAgOztcblxuICBsZXQgYWRkX211bHRpIH5jb21wYXJhdG9yIHQgfmtleSB+ZGF0YSA9XG4gICAgVHJlZTAuYWRkX211bHRpIHQgfmtleSB+ZGF0YSB+bGVuZ3RoOjAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgfD4gZnN0XG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9tdWx0aSB+Y29tcGFyYXRvciB0IGtleSA9XG4gICAgVHJlZTAucmVtb3ZlX211bHRpIHQga2V5IH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfD4gZnN0XG4gIDs7XG5cbiAgbGV0IGZpbmRfbXVsdGkgfmNvbXBhcmF0b3IgdCBrZXkgPVxuICAgIFRyZWUwLmZpbmRfbXVsdGkgdCBrZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGNoYW5nZSB+Y29tcGFyYXRvciB0IGtleSB+ZiA9XG4gICAgZnN0IChUcmVlMC5jaGFuZ2UgdCBrZXkgfmYgfmxlbmd0aDowIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgdXBkYXRlIH5jb21wYXJhdG9yIHQga2V5IH5mID1cbiAgICBjaGFuZ2UgfmNvbXBhcmF0b3IgdCBrZXkgfmY6KGZ1biBkYXRhIC0+IFNvbWUgKGYgZGF0YSkpXG4gIDs7XG5cbiAgbGV0IGZpbmRfZXhuIH5jb21wYXJhdG9yIHQga2V5ID1cbiAgICBUcmVlMC5maW5kX2V4blxuICAgICAgdFxuICAgICAga2V5XG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgIH5zZXhwX29mX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IGZpbmQgfmNvbXBhcmF0b3IgdCBrZXkgPSBUcmVlMC5maW5kIHQga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuXG4gIGxldCByZW1vdmUgfmNvbXBhcmF0b3IgdCBrZXkgPVxuICAgIGZzdCAoVHJlZTAucmVtb3ZlIHQga2V5IH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG1lbSB+Y29tcGFyYXRvciB0IGtleSA9IFRyZWUwLm1lbSB0IGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgbGV0IGl0ZXJfa2V5cyB0IH5mID0gVHJlZTAuaXRlcl9rZXlzIHQgfmZcbiAgbGV0IGl0ZXIgdCB+ZiA9IFRyZWUwLml0ZXIgdCB+ZlxuICBsZXQgaXRlcmkgdCB+ZiA9IFRyZWUwLml0ZXJpIHQgfmZcbiAgbGV0IGl0ZXJpX3VudGlsIHQgfmYgPSBUcmVlMC5pdGVyaV91bnRpbCB0IH5mXG5cbiAgbGV0IGl0ZXIyIH5jb21wYXJhdG9yIHQxIHQyIH5mID1cbiAgICBUcmVlMC5pdGVyMiB0MSB0MiB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgbWFwIHQgfmYgPSBUcmVlMC5tYXAgdCB+ZlxuICBsZXQgbWFwaSB0IH5mID0gVHJlZTAubWFwaSB0IH5mXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkIHQgfmYgfmluaXRcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID0gVHJlZTAuZm9sZF91bnRpbCB0IH5mIH5pbml0IH5maW5pc2hcbiAgbGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfcmlnaHQgdCB+ZiB+aW5pdFxuXG4gIGxldCBmb2xkMiB+Y29tcGFyYXRvciB0MSB0MiB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZDIgdDEgdDIgfmluaXQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9rZXlzIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGZzdCAoVHJlZTAuZmlsdGVyX2tleXMgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IGZpbHRlciB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBmc3QgKFRyZWUwLmZpbHRlciB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgZmlsdGVyaSB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBmc3QgKFRyZWUwLmZpbHRlcmkgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXAgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgZnN0IChUcmVlMC5maWx0ZXJfbWFwIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwaSB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBmc3QgKFRyZWUwLmZpbHRlcl9tYXBpIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fbWFwaSB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBsZXQgKGEsIF8pLCAoYiwgXykgPVxuICAgICAgVHJlZTAucGFydGl0aW9uX21hcGkgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIGEsIGJcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcCB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBsZXQgKGEsIF8pLCAoYiwgXykgPVxuICAgICAgVHJlZTAucGFydGl0aW9uX21hcCB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgYSwgYlxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25pX3RmIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGxldCAoYSwgXyksIChiLCBfKSA9XG4gICAgICBUcmVlMC5wYXJ0aXRpb25pX3RmIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBhLCBiXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl90ZiB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBsZXQgKGEsIF8pLCAoYiwgXykgPVxuICAgICAgVHJlZTAucGFydGl0aW9uX3RmIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBhLCBiXG4gIDs7XG5cbiAgbGV0IGNvbWJpbmVfZXJyb3JzIH5jb21wYXJhdG9yIHQgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgfmY6ZnN0XG4gICAgICAoVHJlZTAuY29tYmluZV9lcnJvcnNcbiAgICAgICAgIHRcbiAgICAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgICAgfnNleHBfb2Zfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3QpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmVfZGlyZWN0IH5jb21wYXJhdG9yIGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgVHJlZTAuY29tcGFyZSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBjb21wYXJlX2RhdGEgdDEgdDJcbiAgOztcblxuICBsZXQgZXF1YWwgfmNvbXBhcmF0b3IgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICBUcmVlMC5lcXVhbCBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBjb21wYXJlX2RhdGEgdDEgdDJcbiAgOztcblxuICBsZXQga2V5cyB0ID0gVHJlZTAua2V5cyB0XG4gIGxldCBkYXRhIHQgPSBUcmVlMC5kYXRhIHRcbiAgbGV0IHRvX2FsaXN0ID9rZXlfb3JkZXIgdCA9IFRyZWUwLnRvX2FsaXN0ID9rZXlfb3JkZXIgdFxuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiB+Y29tcGFyYXRvciB0MSB0MiB+ZGF0YV9lcXVhbCA9XG4gICAgVHJlZTAuc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH5kYXRhX2VxdWFsXG4gIDs7XG5cbiAgbGV0IGZvbGRfc3ltbWV0cmljX2RpZmYgfmNvbXBhcmF0b3IgdDEgdDIgfmRhdGFfZXF1YWwgfmluaXQgfmYgPVxuICAgIFRyZWUwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgIHQxXG4gICAgICB0MlxuICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgICB+ZGF0YV9lcXVhbFxuICAgICAgfmluaXRcbiAgICAgIH5mXG4gIDs7XG5cbiAgbGV0IG1lcmdlIH5jb21wYXJhdG9yIHQxIHQyIH5mID1cbiAgICBmc3QgKFRyZWUwLm1lcmdlIHQxIHQyIH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgbWVyZ2Vfc2tld2VkIH5jb21wYXJhdG9yIHQxIHQyIH5jb21iaW5lID1cbiAgICAoKiBMZW5ndGggY29tcHV0YXRpb24gbWFrZXMgdGhpcyBzaWduaWZpY2FudGx5IHNsb3dlciB0aGFuIFttZXJnZV9za2V3ZWRdIG9uIGEgbWFwXG4gICAgICAgd2l0aCBhIFtsZW5ndGhdIGZpZWxkLCBidXQgZG9lcyBwcmVzZXJ2ZSBhbW91bnQgb2YgYWxsb2NhdGlvbi4gKilcbiAgICBmc3RcbiAgICAgIChUcmVlMC5tZXJnZV9za2V3ZWRcbiAgICAgICAgIHQxXG4gICAgICAgICB0MlxuICAgICAgICAgfmxlbmd0aDE6KGxlbmd0aCB0MSlcbiAgICAgICAgIH5sZW5ndGgyOihsZW5ndGggdDIpXG4gICAgICAgICB+Y29tYmluZVxuICAgICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBtaW5fZWx0IHQgPSBUcmVlMC5taW5fZWx0IHRcbiAgbGV0IG1pbl9lbHRfZXhuIHQgPSBUcmVlMC5taW5fZWx0X2V4biB0XG4gIGxldCBtYXhfZWx0IHQgPSBUcmVlMC5tYXhfZWx0IHRcbiAgbGV0IG1heF9lbHRfZXhuIHQgPSBUcmVlMC5tYXhfZWx0X2V4biB0XG4gIGxldCBmb3JfYWxsIHQgfmYgPSBUcmVlMC5mb3JfYWxsIHQgfmZcbiAgbGV0IGZvcl9hbGxpIHQgfmYgPSBUcmVlMC5mb3JfYWxsaSB0IH5mXG4gIGxldCBleGlzdHMgdCB+ZiA9IFRyZWUwLmV4aXN0cyB0IH5mXG4gIGxldCBleGlzdHNpIHQgfmYgPSBUcmVlMC5leGlzdHNpIHQgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBUcmVlMC5jb3VudCB0IH5mXG4gIGxldCBjb3VudGkgdCB+ZiA9IFRyZWUwLmNvdW50aSB0IH5mXG4gIGxldCBzcGxpdCB+Y29tcGFyYXRvciB0IGsgPSBUcmVlMC5zcGxpdCB0IGsgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG5cbiAgbGV0IGFwcGVuZCB+Y29tcGFyYXRvciB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCA9XG4gICAgVHJlZTAuYXBwZW5kIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBzdWJyYW5nZSB+Y29tcGFyYXRvciB0IH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIGxldCBfLCByZXQsIF8gPVxuICAgICAgVHJlZTAuc3BsaXRfcmFuZ2VcbiAgICAgICAgdFxuICAgICAgICB+bG93ZXJfYm91bmRcbiAgICAgICAgfnVwcGVyX2JvdW5kXG4gICAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgcmV0XG4gIDs7XG5cbiAgbGV0IGZvbGRfcmFuZ2VfaW5jbHVzaXZlIH5jb21wYXJhdG9yIHQgfm1pbiB+bWF4IH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgICAgdFxuICAgICAgfm1pblxuICAgICAgfm1heFxuICAgICAgfmluaXRcbiAgICAgIH5mXG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgcmFuZ2VfdG9fYWxpc3QgfmNvbXBhcmF0b3IgdCB+bWluIH5tYXggPVxuICAgIFRyZWUwLnJhbmdlX3RvX2FsaXN0IHQgfm1pbiB+bWF4IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBjbG9zZXN0X2tleSB+Y29tcGFyYXRvciB0IGRpciBrZXkgPVxuICAgIFRyZWUwLmNsb3Nlc3Rfa2V5IHQgZGlyIGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgbnRoIHQgbiA9IFRyZWUwLm50aCB0IG5cbiAgbGV0IG50aF9leG4gdCBuID0gT3B0aW9uLnZhbHVlX2V4biAobnRoIHQgbilcbiAgbGV0IHJhbmsgfmNvbXBhcmF0b3IgdCBrZXkgPSBUcmVlMC5yYW5rIHQga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfayBzZXhwX29mX3YgXyB0ID0gVHJlZTAuc2V4cF9vZl90IHNleHBfb2ZfayBzZXhwX29mX3YgdFxuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yIGtfb2Zfc2V4cCB2X29mX3NleHAgc2V4cCA9XG4gICAgZnN0IChUcmVlMC50X29mX3NleHBfZGlyZWN0IGtfb2Zfc2V4cCB2X29mX3NleHAgc2V4cCB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgdG9fc2VxdWVuY2UgfmNvbXBhcmF0b3IgP29yZGVyID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2tleXNfbGVzc19vcl9lcXVhbF90byB0ID1cbiAgICBUcmVlMC50b19zZXF1ZW5jZSBjb21wYXJhdG9yID9vcmRlciA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG8gdFxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIH5jb21wYXJhdG9yOl8gdCB+Y29tcGFyZSBob3cgdiA9IFRyZWUwLmJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdlxuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB+Y29tcGFyYXRvcjpfIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvd1xuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlIH5jb21wYXJhdG9yIHQgfmNvbXBhcmUgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCA9XG4gICAgbWF0Y2ggVHJlZTAuYmluYXJ5X3NlYXJjaF90d29fc2lkZWRfYm91bmRzIHQgfmNvbXBhcmUgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCB3aXRoXG4gICAgfCBTb21lIChsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQpIC0+IHN1YnJhbmdlIH5jb21wYXJhdG9yIHQgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZFxuICAgIHwgTm9uZSAtPiBFbXB0eVxuICA7O1xuXG4gIGxldCBtYXBfa2V5cyB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBtYXRjaCBUcmVlMC5tYXBfa2V5cyB+Y29tcGFyYXRvciB0IH5mIHdpdGhcbiAgICB8IGBPayAodCwgXykgLT4gYE9rIHRcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZHVwIC0+IGR1cFxuICA7O1xuXG4gIGxldCBtYXBfa2V5c19leG4gfmNvbXBhcmF0b3IgdCB+ZiA9IGZzdCAoVHJlZTAubWFwX2tleXNfZXhuIH5jb21wYXJhdG9yIHQgfmYpXG5cbiAgbW9kdWxlIEJ1aWxkX2luY3JlYXNpbmcgPSBzdHJ1Y3RcbiAgICB0eXBlICgnaywgJ3YsICd3KSB0ID0gKCdrLCAndikgVHJlZTAuQnVpbGRfaW5jcmVhc2luZy50XG5cbiAgICBsZXQgZW1wdHkgPSBUcmVlMC5CdWlsZF9pbmNyZWFzaW5nLmVtcHR5XG5cbiAgICBsZXQgYWRkX2V4biB0IH5jb21wYXJhdG9yIH5rZXkgfmRhdGEgPVxuICAgICAgbWF0Y2ggVHJlZTAuQnVpbGRfaW5jcmVhc2luZy5tYXhfa2V5IHQgd2l0aFxuICAgICAgfCBTb21lIHByZXZfa2V5IHdoZW4gY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgcHJldl9rZXkga2V5ID49IDAgLT5cbiAgICAgICAgRXJyb3IucmFpc2VfcyAoU2V4cC5BdG9tIFwiTWFwLkJ1aWxkX2luY3JlYXNpbmcuYWRkOiBub24taW5jcmVhc2luZyBrZXlcIilcbiAgICAgIHwgXyAtPiBUcmVlMC5CdWlsZF9pbmNyZWFzaW5nLmFkZF91bmNoZWNrZWQgdCB+a2V5IH5kYXRhXG4gICAgOztcblxuICAgIGxldCB0b190cmVlIHQgPSBUcmVlMC5CdWlsZF9pbmNyZWFzaW5nLnRvX3RyZWVfdW5jaGVja2VkIHRcbiAgZW5kXG5lbmRcblxubW9kdWxlIFVzaW5nX2NvbXBhcmF0b3IgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdrLCAndiwgJ2NtcCkgdCA9ICgnaywgJ3YsICdjbXApIHRcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBlbXB0eSB+Y29tcGFyYXRvciA9IHsgdHJlZSA9IFRyZWUwLmVtcHR5OyBjb21wYXJhdG9yOyBsZW5ndGggPSAwIH1cbiAgbGV0IHNpbmdsZXRvbiB+Y29tcGFyYXRvciBrIHYgPSB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5zaW5nbGV0b24gayB2OyBsZW5ndGggPSAxIH1cbiAgbGV0IG9mX3RyZWUwIH5jb21wYXJhdG9yICh0cmVlLCBsZW5ndGgpID0geyBjb21wYXJhdG9yOyB0cmVlOyBsZW5ndGggfVxuICBsZXQgb2ZfdHJlZSB+Y29tcGFyYXRvciB0cmVlID0gb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKHRyZWUsIFRyZWUwLmxlbmd0aCB0cmVlKVxuICBsZXQgdG9fdHJlZSA9IHRvX3RyZWVcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgT3JfZXJyb3IubWFwXG4gICAgICAoVHJlZTAub2Zfc29ydGVkX2FycmF5IGFycmF5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgICAgIH5mOihmdW4gdHJlZSAtPiBvZl90cmVlMCB+Y29tcGFyYXRvciB0cmVlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdCB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgbWF0Y2ggVHJlZTAub2ZfYWxpc3QgYWxpc3QgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBPayAodHJlZSwgbGVuZ3RoKSAtPiBgT2sgeyBjb21wYXJhdG9yOyB0cmVlOyBsZW5ndGggfVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyB6IC0+IHpcbiAgOztcblxuICBsZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIFJlc3VsdC5tYXAgKFRyZWUwLm9mX2FsaXN0X29yX2Vycm9yIGFsaXN0IH5jb21wYXJhdG9yKSB+ZjooZnVuIHRyZWUgLT5cbiAgICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2V4biB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLm9mX2FsaXN0X2V4biBhbGlzdCB+Y29tcGFyYXRvcilcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgfmNvbXBhcmF0b3IgYWxpc3QgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX2FsaXN0X211bHRpIGFsaXN0IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZm9sZCB+Y29tcGFyYXRvciBhbGlzdCB+aW5pdCB+ZiA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2ZfYWxpc3RfZm9sZCBhbGlzdCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X3JlZHVjZSB+Y29tcGFyYXRvciBhbGlzdCB+ZiA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2ZfYWxpc3RfcmVkdWNlIGFsaXN0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfaXRlcmkgfmNvbXBhcmF0b3Igfml0ZXJpID1cbiAgICBtYXRjaCBUcmVlMC5vZl9pdGVyaSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfml0ZXJpIHdpdGhcbiAgICB8IGBPayB0cmVlX2xlbmd0aCAtPiBgT2sgKG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWVfbGVuZ3RoKVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyB6IC0+IHpcbiAgOztcblxuICBsZXQgb2ZfaXRlcmlfZXhuIH5jb21wYXJhdG9yIH5pdGVyaSA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLm9mX2l0ZXJpX2V4biB+Y29tcGFyYXRvciB+aXRlcmkpXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yIH5sZW4gfmYgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mLCBsZW4pXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBPcl9lcnJvci5tYXBcbiAgICAgIH5mOihvZl90cmVlMCB+Y29tcGFyYXRvcilcbiAgICAgIChUcmVlMC5vZl9pbmNyZWFzaW5nX3NlcXVlbmNlIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgbWF0Y2ggVHJlZTAub2Zfc2VxdWVuY2Ugc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgT2sgKHRyZWUsIGxlbmd0aCkgLT4gYE9rIHsgY29tcGFyYXRvcjsgdHJlZTsgbGVuZ3RoIH1cbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgeiAtPiB6XG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX29yX2Vycm9yIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgUmVzdWx0Lm1hcCAoVHJlZTAub2Zfc2VxdWVuY2Vfb3JfZXJyb3Igc2VxIH5jb21wYXJhdG9yKSB+ZjooZnVuIHRyZWUgLT5cbiAgICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX2V4biB+Y29tcGFyYXRvciBzZXEgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5vZl9zZXF1ZW5jZV9leG4gc2VxIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9tdWx0aSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX3NlcXVlbmNlX211bHRpIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX2ZvbGQgfmNvbXBhcmF0b3Igc2VxIH5pbml0IH5mID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9zZXF1ZW5jZV9mb2xkIHNlcSB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX3JlZHVjZSB+Y29tcGFyYXRvciBzZXEgfmYgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX3NlcXVlbmNlX3JlZHVjZSBzZXEgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yIGtfb2Zfc2V4cCB2X29mX3NleHAgc2V4cCA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLnRfb2Zfc2V4cF9kaXJlY3Qga19vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBtYXBfa2V5cyB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBtYXRjaCBUcmVlMC5tYXBfa2V5cyB0LnRyZWUgfmYgfmNvbXBhcmF0b3Igd2l0aFxuICAgIHwgYE9rIHBhaXIgLT4gYE9rIChvZl90cmVlMCB+Y29tcGFyYXRvciBwYWlyKVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkdXAgLT4gZHVwXG4gIDs7XG5cbiAgbGV0IG1hcF9rZXlzX2V4biB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAubWFwX2tleXNfZXhuIHQudHJlZSB+ZiB+Y29tcGFyYXRvcilcbiAgOztcblxuICBtb2R1bGUgRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoSyA6IENvbXBhcmF0b3IuUzEpID0gc3RydWN0XG4gICAgbGV0IGVtcHR5ID0geyB0cmVlID0gVHJlZTAuZW1wdHk7IGNvbXBhcmF0b3IgPSBLLmNvbXBhcmF0b3I7IGxlbmd0aCA9IDAgfVxuICBlbmRcblxuICBtb2R1bGUgVHJlZSA9IFRyZWVcbmVuZFxuXG5pbmNsdWRlIEFjY2Vzc29yc1xuXG50eXBlICgnaywgJ2NtcCkgY29tcGFyYXRvciA9XG4gIChtb2R1bGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0ID0gJ2sgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gJ2NtcClcblxubGV0IGNvbXBhcmF0b3JfcyAodHlwZSBrIGNtcCkgdCA6IChrLCBjbXApIGNvbXBhcmF0b3IgPVxuICAobW9kdWxlIHN0cnVjdFxuICAgIHR5cGUgdCA9IGtcbiAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGNtcFxuXG4gICAgbGV0IGNvbXBhcmF0b3IgPSB0LmNvbXBhcmF0b3JcbiAgZW5kKVxuOztcblxubGV0IHRvX2NvbXBhcmF0b3IgKHR5cGUgayBjbXApICgobW9kdWxlIE0pIDogKGssIGNtcCkgY29tcGFyYXRvcikgPSBNLmNvbXBhcmF0b3JcblxubGV0IG9mX3RyZWUgKHR5cGUgayBjbXApICgobW9kdWxlIE0pIDogKGssIGNtcCkgY29tcGFyYXRvcikgdHJlZSA9XG4gIG9mX3RyZWUgfmNvbXBhcmF0b3I6TS5jb21wYXJhdG9yIHRyZWVcbjs7XG5cbmxldCBlbXB0eSBtID0gVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKVxubGV0IHNpbmdsZXRvbiBtIGEgPSBVc2luZ19jb21wYXJhdG9yLnNpbmdsZXRvbiB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2ZfYWxpc3QgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBvZl9hbGlzdF9vcl9lcnJvciBtIGEgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X29yX2Vycm9yIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbjs7XG5cbmxldCBvZl9hbGlzdF9leG4gbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9leG4gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxubGV0IG9mX2FsaXN0X211bHRpIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfbXVsdGkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuXG5sZXQgb2ZfYWxpc3RfZm9sZCBtIGEgfmluaXQgfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X2ZvbGQgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYSB+aW5pdCB+ZlxuOztcblxubGV0IG9mX2FsaXN0X3JlZHVjZSBtIGEgfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X3JlZHVjZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhIH5mXG47O1xuXG5sZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBtIGEgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuOztcblxubGV0IG9mX3NvcnRlZF9hcnJheSBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2ZfaXRlcmkgbSB+aXRlcmkgPSBVc2luZ19jb21wYXJhdG9yLm9mX2l0ZXJpIH5pdGVyaSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKVxuXG5sZXQgb2ZfaXRlcmlfZXhuIG0gfml0ZXJpID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9pdGVyaV9leG4gfml0ZXJpIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG47O1xuXG5sZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgbSB+bGVuIH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG47O1xuXG5sZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBtIHNlcSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzZXFcbjs7XG5cbmxldCBvZl9zZXF1ZW5jZSBtIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHNcblxubGV0IG9mX3NlcXVlbmNlX29yX2Vycm9yIG0gcyA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2Vfb3JfZXJyb3IgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgc1xuOztcblxubGV0IG9mX3NlcXVlbmNlX2V4biBtIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX2V4biB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzXG5cbmxldCBvZl9zZXF1ZW5jZV9tdWx0aSBtIHMgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX211bHRpIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHNcbjs7XG5cbmxldCBvZl9zZXF1ZW5jZV9mb2xkIG0gcyB+aW5pdCB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfZm9sZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzIH5pbml0IH5mXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2VfcmVkdWNlIG0gcyB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfcmVkdWNlIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHMgfmZcbjs7XG5cbmxldCBtYXBfa2V5cyBtIHQgfmYgPSBVc2luZ19jb21wYXJhdG9yLm1hcF9rZXlzIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHQgfmZcbmxldCBtYXBfa2V5c19leG4gbSB0IH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXBfa2V5c19leG4gfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgdCB+ZlxuXG5tb2R1bGUgTSAoSyA6IHNpZ1xuICAgIHR5cGUgdFxuICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICBbQEBAZW5kXVxuXG4gIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBDb21wYXJlX20gPSBzaWcgZW5kXG5tb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxubW9kdWxlIHR5cGUgSGFzaF9mb2xkX20gPSBIYXNoZXIuU1xuXG5sZXQgc2V4cF9vZl9tX190ICh0eXBlIGspIChtb2R1bGUgSyA6IFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9IGspIHNleHBfb2ZfdiB0ID1cbiAgc2V4cF9vZl90IEsuc2V4cF9vZl90IHNleHBfb2ZfdiAoZnVuIF8gLT4gU2V4cC5BdG9tIFwiX1wiKSB0XG47O1xuXG5sZXQgbV9fdF9vZl9zZXhwXG4gICAgICAodHlwZSBrIGNtcClcbiAgICAgIChtb2R1bGUgSyA6IE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9IGsgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wKVxuICAgICAgdl9vZl9zZXhwXG4gICAgICBzZXhwXG4gID1cbiAgVXNpbmdfY29tcGFyYXRvci50X29mX3NleHBfZGlyZWN0IH5jb21wYXJhdG9yOksuY29tcGFyYXRvciBLLnRfb2Zfc2V4cCB2X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyXG4gICAgICAodHlwZSBrKVxuICAgICAgKG1vZHVsZSBLIDogTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSBrKVxuICAgICAgKHZfZ3JhbW1hciA6IF8gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogXyBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBMaXN0XG4gICAgICAgIChNYW55IChMaXN0IChDb25zIChLLnRfc2V4cF9ncmFtbWFyLnVudHlwZWQsIENvbnMgKHZfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkpKSkpXG4gIH1cbjs7XG5cbmxldCBjb21wYXJlX21fX3QgKG1vZHVsZSBfIDogQ29tcGFyZV9tKSBjb21wYXJlX3YgdDEgdDIgPSBjb21wYXJlX2RpcmVjdCBjb21wYXJlX3YgdDEgdDJcbmxldCBlcXVhbF9tX190IChtb2R1bGUgXyA6IEVxdWFsX20pIGVxdWFsX3YgdDEgdDIgPSBlcXVhbCBlcXVhbF92IHQxIHQyXG5cbmxldCBoYXNoX2ZvbGRfbV9fdCAodHlwZSBrKSAobW9kdWxlIEsgOiBIYXNoX2ZvbGRfbSB3aXRoIHR5cGUgdCA9IGspIGhhc2hfZm9sZF92IHN0YXRlID1cbiAgaGFzaF9mb2xkX2RpcmVjdCBLLmhhc2hfZm9sZF90IGhhc2hfZm9sZF92IHN0YXRlXG47O1xuXG5tb2R1bGUgUG9seSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2ssICd2KSB0ID0gKCdrLCAndiwgQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICB0eXBlIG5vbnJlYyAoJ2ssICd2KSB0cmVlID0gKCdrLCAndikgVHJlZTAudFxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3NcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBjb21wYXJhdG9yID0gQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3JcbiAgbGV0IG9mX3RyZWUgdHJlZSA9IHsgdHJlZTsgY29tcGFyYXRvcjsgbGVuZ3RoID0gVHJlZTAubGVuZ3RoIHRyZWUgfVxuXG4gIGluY2x1ZGUgVXNpbmdfY29tcGFyYXRvci5FbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChDb21wYXJhdG9yLlBvbHkpXG5cbiAgbGV0IHNpbmdsZXRvbiBhID0gVXNpbmdfY29tcGFyYXRvci5zaW5nbGV0b24gfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3QgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3QgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3Rfb3JfZXJyb3IgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfYWxpc3RfZXhuIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X2V4biB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9hbGlzdF9tdWx0aSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9tdWx0aSB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9hbGlzdF9mb2xkIGEgfmluaXQgfmYgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X2ZvbGQgfmNvbXBhcmF0b3IgYSB+aW5pdCB+ZlxuICBsZXQgb2ZfYWxpc3RfcmVkdWNlIGEgfmYgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X3JlZHVjZSB+Y29tcGFyYXRvciBhIH5mXG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYSA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9pdGVyaSB+aXRlcmkgPSBVc2luZ19jb21wYXJhdG9yLm9mX2l0ZXJpIH5pdGVyaSB+Y29tcGFyYXRvclxuICBsZXQgb2ZfaXRlcmlfZXhuIH5pdGVyaSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfaXRlcmlfZXhuIH5pdGVyaSB+Y29tcGFyYXRvclxuXG4gIGxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuIH5mID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgfmNvbXBhcmF0b3JcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBzZXEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxXG4gIGxldCBvZl9zZXF1ZW5jZSBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzXG4gIGxldCBvZl9zZXF1ZW5jZV9vcl9lcnJvciBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9vcl9lcnJvciB+Y29tcGFyYXRvciBzXG4gIGxldCBvZl9zZXF1ZW5jZV9leG4gcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfZXhuIH5jb21wYXJhdG9yIHNcbiAgbGV0IG9mX3NlcXVlbmNlX211bHRpIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX211bHRpIH5jb21wYXJhdG9yIHNcblxuICBsZXQgb2Zfc2VxdWVuY2VfZm9sZCBzIH5pbml0IH5mID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX2ZvbGQgfmNvbXBhcmF0b3IgcyB+aW5pdCB+ZlxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgcyB+ZiA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfcmVkdWNlIH5jb21wYXJhdG9yIHMgfmZcbiAgbGV0IG1hcF9rZXlzIHQgfmYgPSBVc2luZ19jb21wYXJhdG9yLm1hcF9rZXlzIH5jb21wYXJhdG9yIHQgfmZcbiAgbGV0IG1hcF9rZXlzX2V4biB0IH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXBfa2V5c19leG4gfmNvbXBhcmF0b3IgdCB+ZlxuZW5kXG4iLCJvcGVuISBJbXBvcnQwXG5cbnR5cGUgJ2EgdCA9ICdhIENhbWwuUXVldWUudFxuXG5sZXQgY3JlYXRlID0gQ2FtbC5RdWV1ZS5jcmVhdGVcbmxldCBjbGVhciA9IENhbWwuUXVldWUuY2xlYXJcbmxldCBjb3B5ID0gQ2FtbC5RdWV1ZS5jb3B5XG5sZXQgaXNfZW1wdHkgPSBDYW1sLlF1ZXVlLmlzX2VtcHR5XG5sZXQgbGVuZ3RoID0gQ2FtbC5RdWV1ZS5sZW5ndGhcbmxldCBwZWVrID0gQ2FtbC5RdWV1ZS5wZWVrXG5sZXQgcG9wID0gQ2FtbC5RdWV1ZS5wb3BcbmxldCBwdXNoID0gQ2FtbC5RdWV1ZS5wdXNoXG5sZXQgdHJhbnNmZXIgPSBDYW1sLlF1ZXVlLnRyYW5zZmVyXG5sZXQgaXRlciB0IH5mID0gQ2FtbC5RdWV1ZS5pdGVyIGYgdFxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9IENhbWwuUXVldWUuZm9sZCBmIGluaXQgdFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIExpbmtlZF9xdWV1ZTBcblxubGV0IGVucXVldWUgdCB4ID0gTGlua2VkX3F1ZXVlMC5wdXNoIHggdFxubGV0IGRlcXVldWUgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAoTGlua2VkX3F1ZXVlMC5wb3AgdClcbmxldCBkZXF1ZXVlX2V4biA9IExpbmtlZF9xdWV1ZTAucG9wXG5sZXQgcGVlayB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChMaW5rZWRfcXVldWUwLnBlZWsgdClcbmxldCBwZWVrX2V4biA9IExpbmtlZF9xdWV1ZTAucGVla1xuXG5tb2R1bGUgQyA9IEluZGV4ZWRfY29udGFpbmVyLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgaXRlciA9IGBDdXN0b20gaXRlclxuICAgIGxldCBsZW5ndGggPSBgQ3VzdG9tIGxlbmd0aFxuICAgIGxldCBmb2xkaSA9IGBEZWZpbmVfdXNpbmdfZm9sZFxuICAgIGxldCBpdGVyaSA9IGBEZWZpbmVfdXNpbmdfZm9sZFxuICBlbmQpXG5cbmxldCBjb3VudCA9IEMuY291bnRcbmxldCBleGlzdHMgPSBDLmV4aXN0c1xubGV0IGZpbmQgPSBDLmZpbmRcbmxldCBmaW5kX21hcCA9IEMuZmluZF9tYXBcbmxldCBmb2xkX3Jlc3VsdCA9IEMuZm9sZF9yZXN1bHRcbmxldCBmb2xkX3VudGlsID0gQy5mb2xkX3VudGlsXG5sZXQgZm9yX2FsbCA9IEMuZm9yX2FsbFxubGV0IG1heF9lbHQgPSBDLm1heF9lbHRcbmxldCBtZW0gPSBDLm1lbVxubGV0IG1pbl9lbHQgPSBDLm1pbl9lbHRcbmxldCBzdW0gPSBDLnN1bVxubGV0IHRvX2xpc3QgPSBDLnRvX2xpc3RcbmxldCBjb3VudGkgPSBDLmNvdW50aVxubGV0IGV4aXN0c2kgPSBDLmV4aXN0c2lcbmxldCBmaW5kX21hcGkgPSBDLmZpbmRfbWFwaVxubGV0IGZpbmRpID0gQy5maW5kaVxubGV0IGZvbGRpID0gQy5mb2xkaVxubGV0IGZvcl9hbGxpID0gQy5mb3JfYWxsaVxubGV0IGl0ZXJpID0gQy5pdGVyaVxubGV0IHRyYW5zZmVyIH5zcmMgfmRzdCA9IExpbmtlZF9xdWV1ZTAudHJhbnNmZXIgc3JjIGRzdFxuXG5sZXQgY29uY2F0X21hcCB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IExpc3QuaXRlciAoZiBhKSB+ZjooZnVuIGIgLT4gZW5xdWV1ZSByZXMgYikpO1xuICByZXNcbjs7XG5cbmxldCBjb25jYXRfbWFwaSB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+IExpc3QuaXRlciAoZiBpIGEpIH5mOihmdW4gYiAtPiBlbnF1ZXVlIHJlcyBiKSk7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPlxuICAgIG1hdGNoIGYgYSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGIgLT4gZW5xdWV1ZSByZXMgYik7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT5cbiAgICBtYXRjaCBmIGkgYSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGIgLT4gZW5xdWV1ZSByZXMgYik7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlciB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IGlmIGYgYSB0aGVuIGVucXVldWUgcmVzIGEpO1xuICByZXNcbjs7XG5cbmxldCBmaWx0ZXJpIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gaWYgZiBpIGEgdGhlbiBlbnF1ZXVlIHJlcyBhKTtcbiAgcmVzXG47O1xuXG5sZXQgbWFwIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gZW5xdWV1ZSByZXMgKGYgYSkpO1xuICByZXNcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gZW5xdWV1ZSByZXMgKGYgaSBhKSk7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlcl9pbnBsYWNlIHEgfmYgPVxuICBsZXQgcScgPSBmaWx0ZXIgcSB+ZiBpblxuICBjbGVhciBxO1xuICB0cmFuc2ZlciB+c3JjOnEnIH5kc3Q6cVxuOztcblxubGV0IGZpbHRlcmlfaW5wbGFjZSBxIH5mID1cbiAgbGV0IHEnID0gZmlsdGVyaSBxIH5mIGluXG4gIGNsZWFyIHE7XG4gIHRyYW5zZmVyIH5zcmM6cScgfmRzdDpxXG47O1xuXG5sZXQgZW5xdWV1ZV9hbGwgdCBsaXN0ID0gTGlzdC5pdGVyIGxpc3QgfmY6KGZ1biB4IC0+IGVucXVldWUgdCB4KVxuXG5sZXQgb2ZfbGlzdCBsaXN0ID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgTGlzdC5pdGVyIGxpc3QgfmY6KGZ1biB4IC0+IGVucXVldWUgdCB4KTtcbiAgdFxuOztcblxubGV0IG9mX2FycmF5IGFycmF5ID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgQXJyYXkuaXRlciBhcnJheSB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpO1xuICB0XG47O1xuXG5sZXQgaW5pdCBsZW4gfmYgPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGVucXVldWUgdCAoZiBpKVxuICBkb25lO1xuICB0XG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9XG4gIG1hdGNoIGxlbmd0aCB0IHdpdGhcbiAgfCAwIC0+IFt8fF1cbiAgfCBsZW4gLT5cbiAgICBsZXQgYXJyID0gQXJyYXkuY3JlYXRlIH5sZW4gKHBlZWtfZXhuIHQpIGluXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGl0ZXIgdCB+ZjooZnVuIHYgLT5cbiAgICAgIGFyci4oIWkpIDwtIHY7XG4gICAgICBpbmNyIGkpO1xuICAgIGFyclxuOztcblxubGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCA9IG9mX2xpc3QgKGxpc3Rfb2Zfc2V4cCBhX29mX3NleHAgc2V4cClcbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSBzZXhwX29mX2xpc3Qgc2V4cF9vZl9hICh0b19saXN0IHQpXG5cbmxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBhKSAoZ3JhbW1hciA6IGEgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoTGlzdC50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuOztcblxubGV0IHNpbmdsZXRvbiBhID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgZW5xdWV1ZSB0IGE7XG4gIHRcbjs7XG4iLCJvcGVuISBJbXBvcnRcbm9wZW4hIENhbWwuSW50NjRcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50NjQgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludDY0XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQ2NCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoaW50NjRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfaW50NjQgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gaW50NjRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5cbiAgbGV0IGNvbXBhcmUgPSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuY29tcGFyZVxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gIGxldCBvZl9zdHJpbmcgPSBvZl9zdHJpbmdcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5sZXQgbnVtX2JpdHMgPSA2NFxubGV0IGZsb2F0X2xvd2VyX2JvdW5kID0gRmxvYXQwLmxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF91cHBlcl9ib3VuZCA9IEZsb2F0MC51cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfb2ZfYml0cyA9IGZsb2F0X29mX2JpdHNcbmxldCBiaXRzX29mX2Zsb2F0ID0gYml0c19vZl9mbG9hdFxubGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5sZXQgc2hpZnRfcmlnaHQgPSBzaGlmdF9yaWdodFxubGV0IHNoaWZ0X2xlZnQgPSBzaGlmdF9sZWZ0XG5sZXQgYml0X25vdCA9IGxvZ25vdFxubGV0IGJpdF94b3IgPSBsb2d4b3JcbmxldCBiaXRfb3IgPSBsb2dvclxubGV0IGJpdF9hbmQgPSBsb2dhbmRcbmxldCBtaW5fdmFsdWUgPSBtaW5faW50XG5sZXQgbWF4X3ZhbHVlID0gbWF4X2ludFxubGV0IGFicyA9IGFic1xubGV0IHByZWQgPSBwcmVkXG5sZXQgc3VjYyA9IHN1Y2NcbmxldCBwb3cgPSBJbnRfbWF0aC5Qcml2YXRlLmludDY0X3Bvd1xubGV0IHJlbSA9IHJlbVxubGV0IG5lZyA9IG5lZ1xubGV0IG1pbnVzX29uZSA9IG1pbnVzX29uZVxubGV0IG9uZSA9IG9uZVxubGV0IHplcm8gPSB6ZXJvXG5sZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxubGV0IG9mX2Zsb2F0X3VuY2hlY2tlZCA9IENhbWwuSW50NjQub2ZfZmxvYXRcblxubGV0IG9mX2Zsb2F0IGYgPVxuICBpZiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIGYgZmxvYXRfbG93ZXJfYm91bmRcbiAgJiYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBmIGZsb2F0X3VwcGVyX2JvdW5kXG4gIHRoZW4gQ2FtbC5JbnQ2NC5vZl9mbG9hdCBmXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIkludDY0Lm9mX2Zsb2F0OiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggZilcbiAgICAgICgpXG47O1xuXG5sZXQgKCAqKiApIGIgZSA9IHBvdyBiIGVcblxuZXh0ZXJuYWwgYnN3YXA2NCA6IHQgLT4gdCA9IFwiJWJzd2FwX2ludDY0XCJcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBic3dhcDE2IHggPSBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKGJzd2FwNjQgeCkgNDhcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBic3dhcDMyIHggPVxuICAoKiBUaGlzIGlzIHN0cmljdGx5IGJldHRlciB0aGFuIGNvZXJjaW5nIHRvIGFuIGludDMyIHRvIHBlcmZvcm0gYnl0ZXN3YXAuIENvZXJjaW5nXG4gICAgIGZyb20gYW4gaW50MzIgd2lsbCBhZGQgdW5uZWNlc3Nhcnkgc2hpZnQgb3BlcmF0aW9ucyB0byBzaWduIGV4dGVuZCB0aGUgbnVtYmVyXG4gICAgIGFwcHJvcHJpYXRlbHkuXG4gICopXG4gIENhbWwuSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCAoYnN3YXA2NCB4KSAzMlxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBic3dhcDQ4IHggPSBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKGJzd2FwNjQgeCkgMTZcblxuaW5jbHVkZSBDb21wYXJhYmxlLldpdGhfemVybyAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgZW5kKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxubGV0IGluY3IgciA9IHIgOj0gYWRkICFyIG9uZVxubGV0IGRlY3IgciA9IHIgOj0gc3ViICFyIG9uZVxuXG5leHRlcm5hbCBvZl9pbnQ2NCA6IHQgLT4gdCA9IFwiJWlkZW50aXR5XCJcblxubGV0IG9mX2ludDY0X2V4biA9IG9mX2ludDY0XG5sZXQgdG9faW50NjQgdCA9IHRcbmxldCBwb3Bjb3VudCA9IFBvcGNvdW50LmludDY0X3BvcGNvdW50XG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5cbmV4dGVybmFsIHRvX2ludF90cnVuYyA6IHQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIHRvX2ludDMyX3RydW5jIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5leHRlcm5hbCB0b19uYXRpdmVpbnRfdHJ1bmMgOiBpbnQ2NCAtPiBuYXRpdmVpbnQgPSBcIiVpbnQ2NF90b19uYXRpdmVpbnRcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50XCJcbmV4dGVybmFsIG9mX2ludDMyIDogaW50MzIgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnQzMlwiXG5cbmxldCBvZl9pbnRfZXhuID0gb2ZfaW50XG5sZXQgdG9faW50ID0gQ29udi5pbnQ2NF90b19pbnRcbmxldCB0b19pbnRfZXhuID0gQ29udi5pbnQ2NF90b19pbnRfZXhuXG5sZXQgb2ZfaW50MzJfZXhuID0gb2ZfaW50MzJcbmxldCB0b19pbnQzMiA9IENvbnYuaW50NjRfdG9faW50MzJcbmxldCB0b19pbnQzMl9leG4gPSBDb252LmludDY0X3RvX2ludDMyX2V4blxubGV0IG9mX25hdGl2ZWludCA9IENvbnYubmF0aXZlaW50X3RvX2ludDY0XG5sZXQgb2ZfbmF0aXZlaW50X2V4biA9IG9mX25hdGl2ZWludFxubGV0IHRvX25hdGl2ZWludCA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50XG5sZXQgdG9fbmF0aXZlaW50X2V4biA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50X2V4blxuXG5tb2R1bGUgUG93MiA9IHN0cnVjdFxuICBvcGVuISBJbXBvcnRcbiAgb3BlbiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuICBsZXQgbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpID1cbiAgICBQcmludGYuaW52YWxpZF9hcmdmIFwiYXJndW1lbnQgbXVzdCBiZSBzdHJpY3RseSBwb3NpdGl2ZVwiICgpXG4gIDs7XG5cbiAgbGV0ICggbG9yICkgPSBDYW1sLkludDY0LmxvZ29yXG4gIGxldCAoIGxzciApID0gQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsXG4gIGxldCAoIGxhbmQgKSA9IENhbWwuSW50NjQubG9nYW5kXG5cbiAgKCoqIFwiY2VpbGluZyBwb3dlciBvZiAyXCIgLSBMZWFzdCBwb3dlciBvZiAyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgY2VpbF9wb3cyIHggPVxuICAgIGlmIHggPD0gQ2FtbC5JbnQ2NC56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0gQ2FtbC5JbnQ2NC5wcmVkIHggaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIENhbWwuSW50NjQuc3VjYyB4XG4gIDs7XG5cbiAgKCoqIFwiZmxvb3IgcG93ZXIgb2YgMlwiIC0gTGFyZ2VzdCBwb3dlciBvZiAyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgZmxvb3JfcG93MiB4ID1cbiAgICBpZiB4IDw9IENhbWwuSW50NjQuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIENhbWwuSW50NjQuc3ViIHggKHggbHNyIDEpXG4gIDs7XG5cbiAgbGV0IGlzX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBDYW1sLkludDY0Lnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgeCBsYW5kIENhbWwuSW50NjQucHJlZCB4ID0gQ2FtbC5JbnQ2NC56ZXJvXG4gIDs7XG5cbiAgKCogQyBzdHVicyBmb3IgaW50IGNseiBhbmQgY3R6IHRvIHVzZSB0aGUgQ0xaL0JTUi9DVFovQlNGIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG4gIGV4dGVybmFsIGNselxuICAgIDogIChpbnQ2NFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludDY0X2NselwiIFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9jbHpfdW5ib3hlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgY3R6XG4gICAgOiAgKGludDY0W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50NjRfY3R6XCIgXCJCYXNlX2ludF9tYXRoX2ludDY0X2N0el91bmJveGVkXCJcbiAgW0BAbm9hbGxvY11cblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBmbG9vcl9sb2cyIGkgPVxuICAgIGlmIGkgPD0gQ2FtbC5JbnQ2NC56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlIFwiW0ludDY0LmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludDY0IGkgXSk7XG4gICAgbnVtX2JpdHMgLSAxIC0gY2x6IGlcbiAgOztcblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBjZWlsX2xvZzIgaSA9XG4gICAgaWYgUG9seS4oIDw9ICkgaSBDYW1sLkludDY0Lnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSW50NjQuY2VpbF9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl9pbnQ2NCBpIF0pO1xuICAgIGlmIENhbWwuSW50NjQuZXF1YWwgaSBDYW1sLkludDY0Lm9uZSB0aGVuIDAgZWxzZSBudW1fYml0cyAtIGNseiAoQ2FtbC5JbnQ2NC5wcmVkIGkpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb3cyXG5pbmNsdWRlIENvbnYuTWFrZSAoVClcblxuaW5jbHVkZSBDb252Lk1ha2VfaGV4IChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnQ2NCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxuICAgIGxldCBjb21wYXJlID0gKGNvbXBhcmVfaW50NjQgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgaGFzaF9mb2xkX2ludDY0XG5cbiAgICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgICBsZXQgZnVuYyA9IGhhc2hfaW50NjQgaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gICAgbGV0IG5lZyA9IG5lZ1xuICAgIGxldCAoIDwgKSA9ICggPCApXG4gICAgbGV0IHRvX3N0cmluZyBpID0gUHJpbnRmLnNwcmludGYgXCIlTHhcIiBpXG4gICAgbGV0IG9mX3N0cmluZyBzID0gQ2FtbC5TY2FuZi5zc2NhbmYgcyBcIiVMeFwiIEZuLmlkXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDY0LkhleFwiXG4gIGVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50NjRcIlxuICBlbmQpXG5cbm1vZHVsZSBQcmVfTyA9IHN0cnVjdFxuICBleHRlcm5hbCAoICsgKSA6IHQgLT4gdCAtPiB0ID0gXCIlaW50NjRfYWRkXCJcbiAgZXh0ZXJuYWwgKCAtICkgOiB0IC0+IHQgLT4gdCA9IFwiJWludDY0X3N1YlwiXG4gIGV4dGVybmFsICggKiApIDogdCAtPiB0IC0+IHQgPSBcIiVpbnQ2NF9tdWxcIlxuICBleHRlcm5hbCAoIC8gKSA6IHQgLT4gdCAtPiB0ID0gXCIlaW50NjRfZGl2XCJcbiAgZXh0ZXJuYWwgKCB+LSApIDogdCAtPiB0ID0gXCIlaW50NjRfbmVnXCJcblxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgYWJzID0gYWJzXG5cbiAgZXh0ZXJuYWwgbmVnIDogdCAtPiB0ID0gXCIlaW50NjRfbmVnXCJcblxuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIGluY2x1ZGUgSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBpbmNsdWRlIFByZV9PXG5cbiAgICAgIGxldCByZW0gPSByZW1cbiAgICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgICBlbmQpXG5cbiAgZXh0ZXJuYWwgKCBsYW5kICkgOiB0IC0+IHQgLT4gdCA9IFwiJWludDY0X2FuZFwiXG4gIGV4dGVybmFsICggbG9yICkgOiB0IC0+IHQgLT4gdCA9IFwiJWludDY0X29yXCJcbiAgZXh0ZXJuYWwgKCBseG9yICkgOiB0IC0+IHQgLT4gdCA9IFwiJWludDY0X3hvclwiXG5cbiAgbGV0IGxub3QgPSBiaXRfbm90XG5cbiAgZXh0ZXJuYWwgKCBsc2wgKSA6IHQgLT4gaW50IC0+IHQgPSBcIiVpbnQ2NF9sc2xcIlxuICBleHRlcm5hbCAoIGFzciApIDogdCAtPiBpbnQgLT4gdCA9IFwiJWludDY0X2FzclwiXG4gIGV4dGVybmFsICggbHNyICkgOiB0IC0+IGludCAtPiB0ID0gXCIlaW50NjRfbHNyXCJcbmVuZFxuXG5pbmNsdWRlIE9cblxuKCogW0ludDY0XSBhbmQgW0ludDY0Lk9dIGFncmVlIHZhbHVlLXdpc2UgKilcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwiKCogQSA2M2JpdCBpbnRlZ2VyIGlzIGEgNjRiaXQgaW50ZWdlciB3aXRoIGl0cyBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnRcbiAgIGFuZCBpdHMgbG93ZXN0IGJpdCBzZXQgdG8gMC5cbiAgIFRoaXMgaXMgdGhlIHNhbWUga2luZCBvZiBlbmNvZGluZyBhcyBPQ2FtbCBpbnQgb24gNjRiaXQgYXJjaGl0ZWN0dXJlLlxuICAgVGhlIG9ubHkgZGlmZmVyZW5jZSBiZWluZyB0aGUgbG93ZXN0IGJpdCAoaW1tZWRpYXRlIGJpdCkgc2V0IHRvIDEuICopXG5cbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuXG5tb2R1bGUgVDAgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnQ2NCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9pbnQ2NCA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBoYXNoX2ZvbGRfaW50NjRcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gaGFzaF9pbnQ2NCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIGxldCB0X29mX3NleHAgPSAoaW50NjRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICAgIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9pbnQ2NCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGludDY0X3NleHBfZ3JhbW1hclxuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuZW5kXG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5cbm1vZHVsZSBXIDogc2lnXG5cbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBzdHJ1Y3RcbiAgICBpbmNsdWRlIFQwXG4gIGVuZFxuXG4gIHR5cGUgdCA9IGludDY0XG5cbiAgdmFsIHdyYXBfZXhuIDogQ2FtbC5JbnQ2NC50IC0+IHRcbiAgdmFsIHdyYXBfbW9kdWxvIDogQ2FtbC5JbnQ2NC50IC0+IHRcbiAgdmFsIHVud3JhcCA6IHQgLT4gQ2FtbC5JbnQ2NC50XG5cbiAgKCoqIFJldHVybnMgYSBub24tbmVnYXRpdmUgaW50NjQgdGhhdCBpcyBlcXVhbCB0byB0aGUgaW5wdXQgaW50NjMgbW9kdWxvIDJeNjMuICopXG4gIHZhbCB1bndyYXBfdW5zaWduZWQgOiB0IC0+IENhbWwuSW50NjQudFxuXG4gIHZhbCBpbnZhcmlhbnQgOiB0IC0+IHVuaXRcbiAgdmFsIGFkZCA6IHQgLT4gdCAtPiB0XG4gIHZhbCBzdWIgOiB0IC0+IHQgLT4gdFxuICB2YWwgbmVnIDogdCAtPiB0XG4gIHZhbCBhYnMgOiB0IC0+IHRcbiAgdmFsIHN1Y2MgOiB0IC0+IHRcbiAgdmFsIHByZWQgOiB0IC0+IHRcbiAgdmFsIG11bCA6IHQgLT4gdCAtPiB0XG4gIHZhbCBwb3cgOiB0IC0+IHQgLT4gdFxuICB2YWwgZGl2IDogdCAtPiB0IC0+IHRcbiAgdmFsIHJlbSA6IHQgLT4gdCAtPiB0XG4gIHZhbCBwb3Bjb3VudCA6IHQgLT4gaW50XG4gIHZhbCBiaXRfbm90IDogdCAtPiB0XG4gIHZhbCBiaXRfeG9yIDogdCAtPiB0IC0+IHRcbiAgdmFsIGJpdF9vciA6IHQgLT4gdCAtPiB0XG4gIHZhbCBiaXRfYW5kIDogdCAtPiB0IC0+IHRcbiAgdmFsIHNoaWZ0X2xlZnQgOiB0IC0+IGludCAtPiB0XG4gIHZhbCBzaGlmdF9yaWdodCA6IHQgLT4gaW50IC0+IHRcbiAgdmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiB0IC0+IGludCAtPiB0XG4gIHZhbCBtaW5fdmFsdWUgOiB0XG4gIHZhbCBtYXhfdmFsdWUgOiB0XG4gIHZhbCB0b19pbnQ2NCA6IHQgLT4gQ2FtbC5JbnQ2NC50XG4gIHZhbCBvZl9pbnQ2NCA6IENhbWwuSW50NjQudCAtPiB0IG9wdGlvblxuICB2YWwgb2ZfaW50NjRfZXhuIDogQ2FtbC5JbnQ2NC50IC0+IHRcbiAgdmFsIG9mX2ludDY0X3RydW5jIDogQ2FtbC5JbnQ2NC50IC0+IHRcbiAgdmFsIGNvbXBhcmUgOiB0IC0+IHQgLT4gaW50XG4gIHZhbCBjZWlsX3BvdzIgOiB0IC0+IHRcbiAgdmFsIGZsb29yX3BvdzIgOiB0IC0+IHRcbiAgdmFsIGNlaWxfbG9nMiA6IHQgLT4gaW50XG4gIHZhbCBmbG9vcl9sb2cyIDogdCAtPiBpbnRcbiAgdmFsIGlzX3BvdzIgOiB0IC0+IGJvb2xcbiAgdmFsIGNseiA6IHQgLT4gaW50XG4gIHZhbCBjdHogOiB0IC0+IGludFxuZW5kID0gc3RydWN0XG4gIGluY2x1ZGUgVDBcblxuICB0eXBlIHQgPSBpbnQ2NFxuXG4gIGxldCB3cmFwX2V4biB4ID1cbiAgICAoKiBSYWlzZXMgaWYgdGhlIGludDY0IHZhbHVlIGRvZXMgbm90IGZpdCBvbiBpbnQ2My4gKilcbiAgICBDb252LmludDY0X2ZpdF9vbl9pbnQ2M19leG4geDtcbiAgICBDYW1sLkludDY0Lm11bCB4IDJMXG4gIDs7XG5cbiAgbGV0IHdyYXAgeCA9XG4gICAgaWYgQ29udi5pbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDYzIHggdGhlbiBTb21lIChDYW1sLkludDY0Lm11bCB4IDJMKSBlbHNlIE5vbmVcbiAgOztcblxuICBsZXQgd3JhcF9tb2R1bG8geCA9IENhbWwuSW50NjQubXVsIHggMkxcbiAgbGV0IHVud3JhcCB4ID0gQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodCB4IDFcbiAgbGV0IHVud3JhcF91bnNpZ25lZCB4ID0gQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIHggMVxuXG4gICgqIFRoaXMgZG9lcyBub3QgdXNlIHdyYXAgb3IgdW53cmFwIHRvIGF2b2lkIGdlbmVyYXRpbmcgZXhjZXB0aW9ucyBpbiB0aGUgY2FzZSBvZlxuICAgICBvdmVyZmxvd3MuIFRoaXMgaXMgdG8gcHJlc2VydmUgdGhlIHNlbWFudGljcyBvZiBpbnQgdHlwZSBvbiA2NCBiaXQgYXJjaGl0ZWN0dXJlLiAqKVxuICBsZXQgZjIgZiBhIGIgPVxuICAgIENhbWwuSW50NjQubXVsIChmIChDYW1sLkludDY0LnNoaWZ0X3JpZ2h0IGEgMSkgKENhbWwuSW50NjQuc2hpZnRfcmlnaHQgYiAxKSkgMkxcbiAgOztcblxuICBsZXQgbWFzayA9IDB4ZmZmZl9mZmZmX2ZmZmZfZmZmZUxcbiAgbGV0IG0geCA9IENhbWwuSW50NjQubG9nYW5kIHggbWFza1xuICBsZXQgaW52YXJpYW50IHQgPSBhc3NlcnQgKG0gdCA9IHQpXG4gIGxldCBhZGQgeCB5ID0gQ2FtbC5JbnQ2NC5hZGQgeCB5XG4gIGxldCBzdWIgeCB5ID0gQ2FtbC5JbnQ2NC5zdWIgeCB5XG4gIGxldCBuZWcgeCA9IENhbWwuSW50NjQubmVnIHhcbiAgbGV0IGFicyB4ID0gQ2FtbC5JbnQ2NC5hYnMgeFxuICBsZXQgb25lID0gd3JhcF9leG4gMUxcbiAgbGV0IHN1Y2MgYSA9IGFkZCBhIG9uZVxuICBsZXQgcHJlZCBhID0gc3ViIGEgb25lXG4gIGxldCBtaW5fdmFsdWUgPSBtIENhbWwuSW50NjQubWluX2ludFxuICBsZXQgbWF4X3ZhbHVlID0gbSBDYW1sLkludDY0Lm1heF9pbnRcbiAgbGV0IGJpdF9ub3QgeCA9IG0gKENhbWwuSW50NjQubG9nbm90IHgpXG4gIGxldCBiaXRfYW5kID0gQ2FtbC5JbnQ2NC5sb2dhbmRcbiAgbGV0IGJpdF94b3IgPSBDYW1sLkludDY0LmxvZ3hvclxuICBsZXQgYml0X29yID0gQ2FtbC5JbnQ2NC5sb2dvclxuICBsZXQgc2hpZnRfbGVmdCB4IGkgPSBDYW1sLkludDY0LnNoaWZ0X2xlZnQgeCBpXG4gIGxldCBzaGlmdF9yaWdodCB4IGkgPSBtIChDYW1sLkludDY0LnNoaWZ0X3JpZ2h0IHggaSlcbiAgbGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgeCBpID0gbSAoQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIHggaSlcbiAgbGV0IHBvdyA9IGYyIEludF9tYXRoLlByaXZhdGUuaW50NjNfcG93X29uX2ludDY0XG4gIGxldCBtdWwgYSBiID0gQ2FtbC5JbnQ2NC5tdWwgYSAoQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodCBiIDEpXG4gIGxldCBkaXYgYSBiID0gd3JhcF9tb2R1bG8gKENhbWwuSW50NjQuZGl2IGEgYilcbiAgbGV0IHJlbSBhIGIgPSBDYW1sLkludDY0LnJlbSBhIGJcbiAgbGV0IHBvcGNvdW50IHggPSBQb3Bjb3VudC5pbnQ2NF9wb3Bjb3VudCB4XG4gIGxldCB0b19pbnQ2NCB0ID0gdW53cmFwIHRcbiAgbGV0IG9mX2ludDY0IHQgPSB3cmFwIHRcbiAgbGV0IG9mX2ludDY0X2V4biB0ID0gd3JhcF9leG4gdFxuICBsZXQgb2ZfaW50NjRfdHJ1bmMgdCA9IHdyYXBfbW9kdWxvIHRcbiAgbGV0IHRfb2Zfc2V4cCB4ID0gd3JhcF9leG4gKGludDY0X29mX3NleHAgeClcbiAgbGV0IHNleHBfb2ZfdCB4ID0gc2V4cF9vZl9pbnQ2NCAodW53cmFwIHgpXG4gIGxldCBjb21wYXJlICh4IDogdCkgeSA9IGNvbXBhcmUgeCB5XG4gIGxldCBpc19wb3cyIHggPSBJbnQ2NC5pc19wb3cyICh1bndyYXAgeClcblxuICBsZXQgY2x6IHggPVxuICAgICgqIFdlIHJ1biBJbnQ2NC5jbHogZGlyZWN0bHkgb24gdGhlIHdyYXBwZWQgaW50NjMgdmFsdWUuIFRoaXMgaXMgY29ycmVjdCBiZWNhdXNlIHRoZVxuICAgICAgIGJpdHMgb2YgdGhlIGludDYzX2VtdWwgYXJlIGxlZnQtYWxpZ25lZCBpbiB0aGUgSW50NjQuICopXG4gICAgSW50NjQuY2x6IHhcbiAgOztcblxuICBsZXQgY3R6IHggPSBJbnQ2NC5jdHogKHVud3JhcCB4KVxuICBsZXQgZmxvb3JfcG93MiB4ID0gSW50NjQuZmxvb3JfcG93MiAodW53cmFwIHgpIHw+IHdyYXBfZXhuXG4gIGxldCBjZWlsX3BvdzIgeCA9IEludDY0LmZsb29yX3BvdzIgKHVud3JhcCB4KSB8PiB3cmFwX2V4blxuICBsZXQgZmxvb3JfbG9nMiB4ID0gSW50NjQuZmxvb3JfbG9nMiAodW53cmFwIHgpXG4gIGxldCBjZWlsX2xvZzIgeCA9IEludDY0LmNlaWxfbG9nMiAodW53cmFwIHgpXG5lbmRcblxub3BlbiBXXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IFcudCBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBXLmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gVy5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChXLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKFcuc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IFcudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gVy5jb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciA9IFcuY29tcGFyYXRvclxuICBsZXQgY29tcGFyZSA9IFcuY29tcGFyZVxuICBsZXQgaW52YXJpYW50ID0gVy5pbnZhcmlhbnRcblxuICAoKiBXZSBkb24ndCBleHBlY3QgW2hhc2hdIHRvIGZvbGxvdyB0aGUgYmVoYXZpb3Igb2YgaW50IGluIDY0Yml0IGFyY2hpdGVjdHVyZSAqKVxuICBsZXQgXyA9IGhhc2hcbiAgbGV0IGhhc2ggKHggOiB0KSA9IENhbWwuSGFzaHRibC5oYXNoIHhcbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgaW52YWxpZF9zdHIgeCA9IFByaW50Zi5mYWlsd2l0aGYgXCJJbnQ2My5vZl9zdHJpbmc6IGludmFsaWQgaW5wdXQgJVNcIiB4ICgpXG5cbiAgKCpcbiAgICAgXCJzaWduXCIgcmVmZXJzIHRvIHdoZXRoZXIgdGhlIG51bWJlciBzdGFydHMgd2l0aCBhICctJ1xuICAgICBcInNpZ25lZG5lc3MgPSBmYWxzZVwiIG1lYW5zIHRoZSByZXN0IG9mIHRoZSBudW1iZXIgaXMgcGFyc2VkIGFzIHVuc2lnbmVkIGFuZCB0aGVuIGNhc3RcbiAgICAgdG8gc2lnbmVkIHdpdGggd3JhcC1hcm91bmQgbW9kdWxvIDJeaVxuICAgICBcInNpZ25lZG5lc3MgPSB0cnVlXCIgbWVhbnMgbm8gc3VjaCBjcmF6aW5lc3MgaGFwcGVuc1xuXG4gICAgIFRoZSB0ZXJtaW5vbG9neSBhbmQgdGhlIGxvZ2ljIGlzIGR1ZSB0byB0aGUgY29kZSBpbiBieXRlcnVuL2ludHMuYyBpbiBvY2FtbCA0LjAzXG4gICAgIChbcGFyc2Vfc2lnbl9hbmRfYmFzZV0gZnVuY3Rpb24pLlxuXG4gICAgIFNpZ25lZG5lc3MgZXF1YWxzIHRydWUgZm9yIHBsYWluIGRlY2ltYWwgbnVtYmVyIChlLmcuIDEyMzUsIC02Nzg5KVxuXG4gICAgIFNpZ25lZG5lc3MgZXF1YWxzIGZhbHNlIGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgIC0gWzB4ZmZmZl0sIFstMHhmZmZmXSAoaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24pXG4gICAgIC0gWzBiMDEwMV0sIFstMGIwMTAxXSAoYmluYXJ5IHJlcHJlc2VudGF0aW9uKVxuICAgICAtIFswbzEyMzddLCBbLTBvMTIzN10gKG9jdGFsIHJlcHJlc2VudGF0aW9uKVxuICAgICAtIFswdTk4MTJdLCBbLTB1OTgxMl0gKHVuc2lnbmVkIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gLSBhdmFpbGFibGUgZnJvbSBPQ2FtbCA0LjAzKSAqKVxuICBsZXQgc2lnbl9hbmRfc2lnbmVkbmVzcyB4ID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCB4IGluXG4gICAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCBwb3MsIHNpZ24gPVxuICAgICAgaWYgMCA8IGxlblxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIHguWzBdIHdpdGhcbiAgICAgICAgfCAnLScgLT4gMSwgYE5lZ1xuICAgICAgICB8ICcrJyAtPiAxLCBgUG9zXG4gICAgICAgIHwgXyAtPiAwLCBgUG9zKVxuICAgICAgZWxzZSAwLCBgUG9zXG4gICAgaW5cbiAgICBpZiBwb3MgKyAyIDwgbGVuXG4gICAgdGhlbiAoXG4gICAgICBsZXQgYzEgPSB4Lltwb3NdIGluXG4gICAgICBsZXQgYzIgPSB4Lltwb3MgKyAxXSBpblxuICAgICAgbWF0Y2ggYzEsIGMyIHdpdGhcbiAgICAgIHwgJzAnLCAnMCcgLi4gJzknIC0+IHNpZ24sIHRydWVcbiAgICAgIHwgJzAnLCBfIC0+IHNpZ24sIGZhbHNlXG4gICAgICB8IF8gLT4gc2lnbiwgdHJ1ZSlcbiAgICBlbHNlIHNpZ24sIHRydWVcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nIHggPSBDYW1sLkludDY0LnRvX3N0cmluZyAodW53cmFwIHgpXG5cbiAgbGV0IG9mX3N0cmluZyBzdHIgPVxuICAgIHRyeVxuICAgICAgbGV0IHNpZ24sIHNpZ25lZG5lc3MgPSBzaWduX2FuZF9zaWduZWRuZXNzIHN0ciBpblxuICAgICAgaWYgc2lnbmVkbmVzc1xuICAgICAgdGhlbiBvZl9pbnQ2NF9leG4gKENhbWwuSW50NjQub2Zfc3RyaW5nIHN0cilcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgcG9zX3N0ciA9XG4gICAgICAgICAgbWF0Y2ggc2lnbiB3aXRoXG4gICAgICAgICAgfCBgTmVnIC0+IFN0cmluZy5zdWIgc3RyIH5wb3M6MSB+bGVuOihTdHJpbmcubGVuZ3RoIHN0ciAtIDEpXG4gICAgICAgICAgfCBgUG9zIC0+IHN0clxuICAgICAgICBpblxuICAgICAgICBsZXQgaW50NjQgPSBDYW1sLkludDY0Lm9mX3N0cmluZyBwb3Nfc3RyIGluXG4gICAgICAgICgqIHVuc2lnbmVkIDYzLWJpdCBpbnQgbXVzdCBwYXJzZSBhcyBhIHBvc2l0aXZlIHNpZ25lZCA2NC1iaXQgaW50ICopXG4gICAgICAgIGlmIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBpbnQ2NCAwTCB0aGVuIGludmFsaWRfc3RyIHN0cjtcbiAgICAgICAgbGV0IGludDYzID0gd3JhcF9tb2R1bG8gaW50NjQgaW5cbiAgICAgICAgbWF0Y2ggc2lnbiB3aXRoXG4gICAgICAgIHwgYE5lZyAtPiBuZWcgaW50NjNcbiAgICAgICAgfCBgUG9zIC0+IGludDYzKVxuICAgIHdpdGhcbiAgICB8IF8gLT4gaW52YWxpZF9zdHIgc3RyXG4gIDs7XG5cbiAgbGV0IGJzd2FwMTYgdCA9IHdyYXBfbW9kdWxvIChJbnQ2NC5ic3dhcDE2ICh1bndyYXAgdCkpXG4gIGxldCBic3dhcDMyIHQgPSB3cmFwX21vZHVsbyAoSW50NjQuYnN3YXAzMiAodW53cmFwIHQpKVxuICBsZXQgYnN3YXA0OCB0ID0gd3JhcF9tb2R1bG8gKEludDY0LmJzd2FwNDggKHVud3JhcCB0KSlcbmVuZFxuXG5pbmNsdWRlIFRcblxubGV0IG51bV9iaXRzID0gNjNcbmxldCBmbG9hdF9sb3dlcl9ib3VuZCA9IEZsb2F0MC5sb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfdXBwZXJfYm91bmQgPSBGbG9hdDAudXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5sZXQgc2hpZnRfcmlnaHQgPSBzaGlmdF9yaWdodFxubGV0IHNoaWZ0X2xlZnQgPSBzaGlmdF9sZWZ0XG5sZXQgYml0X25vdCA9IGJpdF9ub3RcbmxldCBiaXRfeG9yID0gYml0X3hvclxubGV0IGJpdF9vciA9IGJpdF9vclxubGV0IGJpdF9hbmQgPSBiaXRfYW5kXG5sZXQgcG9wY291bnQgPSBwb3Bjb3VudFxubGV0IGFicyA9IGFic1xubGV0IHByZWQgPSBwcmVkXG5sZXQgc3VjYyA9IHN1Y2NcbmxldCBwb3cgPSBwb3dcbmxldCByZW0gPSByZW1cbmxldCBuZWcgPSBuZWdcbmxldCBtYXhfdmFsdWUgPSBtYXhfdmFsdWVcbmxldCBtaW5fdmFsdWUgPSBtaW5fdmFsdWVcbmxldCBtaW51c19vbmUgPSB3cmFwX2V4biBDYW1sLkludDY0Lm1pbnVzX29uZVxubGV0IG9uZSA9IHdyYXBfZXhuIENhbWwuSW50NjQub25lXG5sZXQgemVybyA9IHdyYXBfZXhuIENhbWwuSW50NjQuemVyb1xubGV0IGlzX3BvdzIgPSBpc19wb3cyXG5sZXQgZmxvb3JfcG93MiA9IGZsb29yX3BvdzJcbmxldCBjZWlsX3BvdzIgPSBjZWlsX3BvdzJcbmxldCBmbG9vcl9sb2cyID0gZmxvb3JfbG9nMlxubGV0IGNlaWxfbG9nMiA9IGNlaWxfbG9nMlxubGV0IGNseiA9IGNselxubGV0IGN0eiA9IGN0elxubGV0IHRvX2Zsb2F0IHggPSBDYW1sLkludDY0LnRvX2Zsb2F0ICh1bndyYXAgeClcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgeCA9IHdyYXBfbW9kdWxvIChDYW1sLkludDY0Lm9mX2Zsb2F0IHgpXG5cbmxldCBvZl9mbG9hdCB0ID1cbiAgbGV0IG9wZW4gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gIGlmIHQgPj0gZmxvYXRfbG93ZXJfYm91bmQgJiYgdCA8PSBmbG9hdF91cHBlcl9ib3VuZFxuICB0aGVuIHdyYXBfbW9kdWxvIChDYW1sLkludDY0Lm9mX2Zsb2F0IHQpXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIkludDYzLm9mX2Zsb2F0OiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggdClcbiAgICAgICgpXG47O1xuXG5sZXQgb2ZfaW50NjQgPSBvZl9pbnQ2NFxubGV0IG9mX2ludDY0X2V4biA9IG9mX2ludDY0X2V4blxubGV0IG9mX2ludDY0X3RydW5jID0gb2ZfaW50NjRfdHJ1bmNcbmxldCB0b19pbnQ2NCA9IHRvX2ludDY0XG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gIGVuZClcblxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxubGV0ICggLyApID0gZGl2XG5sZXQgKCAqICkgPSBtdWxcbmxldCAoIC0gKSA9IHN1YlxubGV0ICggKyApID0gYWRkXG5sZXQgKCB+LSApID0gbmVnXG5sZXQgKCAqKiApIGIgZSA9IHBvdyBiIGVcbmxldCBpbmNyIHIgPSByIDo9ICFyICsgb25lXG5sZXQgZGVjciByID0gciA6PSAhciAtIG9uZVxuXG4oKiBXZSBjYW4gcmV1c2UgY29udmVyc2lvbiBmdW5jdGlvbiBmcm9tL3RvIGludDY0IGhlcmUuICopXG5sZXQgb2ZfaW50IHggPSB3cmFwX2V4biAoQ29udi5pbnRfdG9faW50NjQgeClcbmxldCBvZl9pbnRfZXhuIHggPSBvZl9pbnQgeFxubGV0IHRvX2ludCB4ID0gQ29udi5pbnQ2NF90b19pbnQgKHVud3JhcCB4KVxubGV0IHRvX2ludF9leG4geCA9IENvbnYuaW50NjRfdG9faW50X2V4biAodW53cmFwIHgpXG5sZXQgdG9faW50X3RydW5jIHggPSBDb252LmludDY0X3RvX2ludF90cnVuYyAodW53cmFwIHgpXG5sZXQgb2ZfaW50MzIgeCA9IHdyYXBfZXhuIChDb252LmludDMyX3RvX2ludDY0IHgpXG5sZXQgb2ZfaW50MzJfZXhuIHggPSBvZl9pbnQzMiB4XG5sZXQgdG9faW50MzIgeCA9IENvbnYuaW50NjRfdG9faW50MzIgKHVud3JhcCB4KVxubGV0IHRvX2ludDMyX2V4biB4ID0gQ29udi5pbnQ2NF90b19pbnQzMl9leG4gKHVud3JhcCB4KVxubGV0IHRvX2ludDMyX3RydW5jIHggPSBDb252LmludDY0X3RvX2ludDMyX3RydW5jICh1bndyYXAgeClcbmxldCBvZl9uYXRpdmVpbnQgeCA9IG9mX2ludDY0IChDb252Lm5hdGl2ZWludF90b19pbnQ2NCB4KVxubGV0IG9mX25hdGl2ZWludF9leG4geCA9IHdyYXBfZXhuIChDb252Lm5hdGl2ZWludF90b19pbnQ2NCB4KVxubGV0IG9mX25hdGl2ZWludF90cnVuYyB4ID0gb2ZfaW50NjRfdHJ1bmMgKENvbnYubmF0aXZlaW50X3RvX2ludDY0IHgpXG5sZXQgdG9fbmF0aXZlaW50IHggPSBDb252LmludDY0X3RvX25hdGl2ZWludCAodW53cmFwIHgpXG5sZXQgdG9fbmF0aXZlaW50X2V4biB4ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfZXhuICh1bndyYXAgeClcbmxldCB0b19uYXRpdmVpbnRfdHJ1bmMgeCA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50X3RydW5jICh1bndyYXAgeClcblxuaW5jbHVkZSBDb252Lk1ha2UgKFQpXG5cbmluY2x1ZGUgQ29udi5NYWtlX2hleCAoc3RydWN0XG4gICAgdHlwZSB0ID0gVC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoVC5jb21wYXJlIDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIFQuaGFzaF9mb2xkX3RcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gVC5oYXNoIGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCB6ZXJvID0gemVyb1xuICAgIGxldCBuZWcgPSAoIH4tIClcbiAgICBsZXQgKCA8ICkgPSAoIDwgKVxuXG4gICAgbGV0IHRvX3N0cmluZyBpID1cbiAgICAgICgqIHRoZSB1c2Ugb2YgW3Vud3JhcF91bnNpZ25lZF0gaGVyZSBpcyBpbXBvcnRhbnQgZm9yIHRoZSBjYXNlIG9mIFttaW5fdmFsdWVdICopXG4gICAgICBQcmludGYuc3ByaW50ZiBcIiVMeFwiICh1bndyYXBfdW5zaWduZWQgaSlcbiAgICA7O1xuXG4gICAgbGV0IG9mX3N0cmluZyBzID0gb2Zfc3RyaW5nIChcIjB4XCIgXiBzKVxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQ2My5IZXhcIlxuICBlbmQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgdG9fc3RyaW5nIHggPSB0b19zdHJpbmcgeFxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQ2M1wiXG4gIGVuZClcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGxldCAoICsgKSA9ICggKyApXG4gIGxldCAoIC0gKSA9ICggLSApXG4gIGxldCAoICogKSA9ICggKiApXG4gIGxldCAoIC8gKSA9ICggLyApXG4gIGxldCAoIH4tICkgPSAoIH4tIClcbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgKEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA6IENvbXBhcmlzb25zLkluZml4IHdpdGggdHlwZSB0IDo9IHQpXG5cbiAgbGV0IGFicyA9IGFic1xuICBsZXQgbmVnID0gbmVnXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgb2ZfaW50X2V4biA9IG9mX2ludF9leG5cbmVuZFxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBpbmNsdWRlIFByZV9PXG5cbiAgaW5jbHVkZSBJbnRfbWF0aC5NYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGluY2x1ZGUgUHJlX09cblxuICAgICAgbGV0IHJlbSA9IHJlbVxuICAgICAgbGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbiAgICAgIGxldCBvZl9mbG9hdCA9IG9mX2Zsb2F0XG4gICAgICBsZXQgb2Zfc3RyaW5nID0gVC5vZl9zdHJpbmdcbiAgICAgIGxldCB0b19zdHJpbmcgPSBULnRvX3N0cmluZ1xuICAgIGVuZClcblxuICBsZXQgKCBsYW5kICkgPSBiaXRfYW5kXG4gIGxldCAoIGxvciApID0gYml0X29yXG4gIGxldCAoIGx4b3IgKSA9IGJpdF94b3JcbiAgbGV0IGxub3QgPSBiaXRfbm90XG4gIGxldCAoIGxzbCApID0gc2hpZnRfbGVmdFxuICBsZXQgKCBhc3IgKSA9IHNoaWZ0X3JpZ2h0XG4gIGxldCAoIGxzciApID0gc2hpZnRfcmlnaHRfbG9naWNhbFxuZW5kXG5cbmluY2x1ZGUgT1xuXG4oKiBbSW50NjNdIGFuZCBbSW50NjMuT10gYWdyZWUgdmFsdWUtd2lzZSAqKVxuXG5tb2R1bGUgUmVwciA9IHN0cnVjdFxuICB0eXBlIGVtdWxhdGVkID0gdFxuXG4gIHR5cGUgKCd1bmRlcmx5aW5nX3R5cGUsICdpbnRlcm1lZGlhdGVfdHlwZSkgdCA9XG4gICAgfCBJbnQgOiAoaW50LCBpbnQpIHRcbiAgICB8IEludDY0IDogKGludDY0LCBlbXVsYXRlZCkgdFxuZW5kXG5cbmxldCByZXByID0gUmVwci5JbnQ2NFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gYm9vbCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZW51bWVyYXRlLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9ib29sIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGFsbCA9IChbIGZhbHNlOyB0cnVlIF0gOiB0IGxpc3QpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9ib29sXG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9ib29sIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChib29sX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2Jvb2wgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gYm9vbF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cblxuICBsZXQgb2Zfc3RyaW5nID0gZnVuY3Rpb25cbiAgICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICAgIHwgcyAtPiBpbnZhbGlkX2FyZ2YgXCJCb29sLm9mX3N0cmluZzogZXhwZWN0ZWQgdHJ1ZSBvciBmYWxzZSBidXQgZ290ICVzXCIgcyAoKVxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgPSBDYW1sLnN0cmluZ19vZl9ib29sXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuQm9vbFwiXG4gIGVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgQm9vbF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxubGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxubGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gIGFzc2VydCAobWluIDw9IG1heCk7XG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgaWYgbWluID4gbWF4XG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbjs7XG5cbmxldCB0b19pbnQgeCA9IGJvb2xfdG9faW50IHhcblxubW9kdWxlIE5vbl9zaG9ydF9jaXJjdWl0aW5nID0gc3RydWN0XG4gICgqIFdlIGRvbid0IGV4cG9zZSB0aGlzLCBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIGJyZWFrIHRoZSBpbnZhcmlhbnQgbWVudGlvbmVkIGJlbG93IG9mXG4gICAgICh0b19pbnQgdHJ1ZSA9IDEpIGFuZCAodG9faW50IGZhbHNlID0gMCkuICopXG4gIGxldCB1bnNhZmVfb2ZfaW50ICh4IDogaW50KSA6IGJvb2wgPSBDYW1sLk9iai5tYWdpYyB4XG4gIGxldCAoIHx8ICkgYSBiID0gdW5zYWZlX29mX2ludCAodG9faW50IGEgbG9yIHRvX2ludCBiKVxuICBsZXQgKCAmJiApIGEgYiA9IHVuc2FmZV9vZl9pbnQgKHRvX2ludCBhIGxhbmQgdG9faW50IGIpXG5lbmRcblxuKCogV2UgZG8gdGhpcyBhcyBhIGRpcmVjdCBhc3NlcnQgb24gdGhlIHRoZW9yeSB0aGF0IGl0J3MgYSBjaGVhcCB0aGluZyB0byB0ZXN0IGFuZCBhXG4gICByZWFsbHkgY29yZSBpbnZhcmlhbnQgdGhhdCB3ZSBuZXZlciBleHBlY3QgdG8gYnJlYWssIGFuZCB3ZSBzaG91bGQgYmUgaGFwcHkgZm9yIGFcbiAgIHByb2dyYW0gdG8gZmFpbCBpbW1lZGlhdGVseSBpZiB0aGlzIGlzIHZpb2xhdGVkLiAqKVxubGV0ICgpID0gYXNzZXJ0IChQb2x5LiggPSApICh0b19pbnQgdHJ1ZSkgMSAmJiBQb2x5LiggPSApICh0b19pbnQgZmFsc2UpIDApXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBCb29sX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0XG5vcGVuISBDYW1sLkludDMyXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGludDMyIFtAQGRlcml2aW5nX2lubGluZSBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9pbnQzMlxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfaW50MzIgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKGludDMyX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2ludDMyIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGludDMyX3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgY29tcGFyZSAoeCA6IHQpIHkgPSBjb21wYXJlIHggeVxuICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gIGxldCBvZl9zdHJpbmcgPSBvZl9zdHJpbmdcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5sZXQgbnVtX2JpdHMgPSAzMlxubGV0IGZsb2F0X2xvd2VyX2JvdW5kID0gRmxvYXQwLmxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF91cHBlcl9ib3VuZCA9IEZsb2F0MC51cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfb2ZfYml0cyA9IGZsb2F0X29mX2JpdHNcbmxldCBiaXRzX29mX2Zsb2F0ID0gYml0c19vZl9mbG9hdFxubGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5sZXQgc2hpZnRfcmlnaHQgPSBzaGlmdF9yaWdodFxubGV0IHNoaWZ0X2xlZnQgPSBzaGlmdF9sZWZ0XG5sZXQgYml0X25vdCA9IGxvZ25vdFxubGV0IGJpdF94b3IgPSBsb2d4b3JcbmxldCBiaXRfb3IgPSBsb2dvclxubGV0IGJpdF9hbmQgPSBsb2dhbmRcbmxldCBtaW5fdmFsdWUgPSBtaW5faW50XG5sZXQgbWF4X3ZhbHVlID0gbWF4X2ludFxubGV0IGFicyA9IGFic1xubGV0IHByZWQgPSBwcmVkXG5sZXQgc3VjYyA9IHN1Y2NcbmxldCByZW0gPSByZW1cbmxldCBuZWcgPSBuZWdcbmxldCBtaW51c19vbmUgPSBtaW51c19vbmVcbmxldCBvbmUgPSBvbmVcbmxldCB6ZXJvID0gemVyb1xubGV0IGNvbXBhcmUgPSBjb21wYXJlXG5sZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxubGV0IG9mX2Zsb2F0X3VuY2hlY2tlZCA9IG9mX2Zsb2F0XG5cbmxldCBvZl9mbG9hdCBmID1cbiAgaWYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSBmIGZsb2F0X2xvd2VyX2JvdW5kXG4gICYmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw9ICkgZiBmbG9hdF91cHBlcl9ib3VuZFxuICB0aGVuIG9mX2Zsb2F0IGZcbiAgZWxzZVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgIFwiSW50MzIub2ZfZmxvYXQ6IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCBmKVxuICAgICAgKClcbjs7XG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gIGVuZClcblxubW9kdWxlIEluZml4X2NvbXBhcmUgPSBzdHJ1Y3RcbiAgb3BlbiBQb2x5XG5cbiAgbGV0ICggPj0gKSAoeCA6IHQpIHkgPSB4ID49IHlcbiAgbGV0ICggPD0gKSAoeCA6IHQpIHkgPSB4IDw9IHlcbiAgbGV0ICggPSApICh4IDogdCkgeSA9IHggPSB5XG4gIGxldCAoID4gKSAoeCA6IHQpIHkgPSB4ID4geVxuICBsZXQgKCA8ICkgKHggOiB0KSB5ID0geCA8IHlcbiAgbGV0ICggPD4gKSAoeCA6IHQpIHkgPSB4IDw+IHlcbmVuZFxuXG5tb2R1bGUgQ29tcGFyZSA9IHN0cnVjdFxuICBpbmNsdWRlIEluZml4X2NvbXBhcmVcblxuICBsZXQgY29tcGFyZSA9IGNvbXBhcmVcbiAgbGV0IGFzY2VuZGluZyA9IGNvbXBhcmVcbiAgbGV0IGRlc2NlbmRpbmcgeCB5ID0gY29tcGFyZSB5IHhcbiAgbGV0IG1pbiAoeCA6IHQpIHkgPSBpZiB4IDwgeSB0aGVuIHggZWxzZSB5XG4gIGxldCBtYXggKHggOiB0KSB5ID0gaWYgeCA+IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgZXF1YWwgKHggOiB0KSB5ID0geCA9IHlcbiAgbGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG4gIGxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbiAgbGV0IGNsYW1wX2V4biB0IH5taW4gfm1heCA9XG4gICAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbiAgOztcblxuICBsZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICAgIGlmIG1pbiA+IG1heFxuICAgIHRoZW5cbiAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBDb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgKCAvICkgPSBkaXZcbmxldCAoICogKSA9IG11bFxubGV0ICggLSApID0gc3ViXG5sZXQgKCArICkgPSBhZGRcbmxldCAoIH4tICkgPSBuZWdcbmxldCBpbmNyIHIgPSByIDo9ICFyICsgb25lXG5sZXQgZGVjciByID0gciA6PSAhciAtIG9uZVxubGV0IG9mX2ludDMyIHQgPSB0XG5sZXQgb2ZfaW50MzJfZXhuID0gb2ZfaW50MzJcbmxldCB0b19pbnQzMiB0ID0gdFxubGV0IHRvX2ludDMyX2V4biA9IHRvX2ludDMyXG5sZXQgcG9wY291bnQgPSBQb3Bjb3VudC5pbnQzMl9wb3Bjb3VudFxuXG5tb2R1bGUgQ29udiA9IEludF9jb252ZXJzaW9uc1xuXG5sZXQgb2ZfaW50ID0gQ29udi5pbnRfdG9faW50MzJcbmxldCBvZl9pbnRfZXhuID0gQ29udi5pbnRfdG9faW50MzJfZXhuXG5sZXQgb2ZfaW50X3RydW5jID0gQ29udi5pbnRfdG9faW50MzJfdHJ1bmNcbmxldCB0b19pbnQgPSBDb252LmludDMyX3RvX2ludFxubGV0IHRvX2ludF9leG4gPSBDb252LmludDMyX3RvX2ludF9leG5cbmxldCB0b19pbnRfdHJ1bmMgPSBDb252LmludDMyX3RvX2ludF90cnVuY1xubGV0IG9mX2ludDY0ID0gQ29udi5pbnQ2NF90b19pbnQzMlxubGV0IG9mX2ludDY0X2V4biA9IENvbnYuaW50NjRfdG9faW50MzJfZXhuXG5sZXQgb2ZfaW50NjRfdHJ1bmMgPSBDb252LmludDY0X3RvX2ludDMyX3RydW5jXG5sZXQgdG9faW50NjQgPSBDb252LmludDMyX3RvX2ludDY0XG5sZXQgb2ZfbmF0aXZlaW50ID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJcbmxldCBvZl9uYXRpdmVpbnRfZXhuID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJfZXhuXG5sZXQgb2ZfbmF0aXZlaW50X3RydW5jID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJfdHJ1bmNcbmxldCB0b19uYXRpdmVpbnQgPSBDb252LmludDMyX3RvX25hdGl2ZWludFxubGV0IHRvX25hdGl2ZWludF9leG4gPSB0b19uYXRpdmVpbnRcbmxldCBwb3cgYiBlID0gb2ZfaW50X2V4biAoSW50X21hdGguUHJpdmF0ZS5pbnRfcG93ICh0b19pbnRfZXhuIGIpICh0b19pbnRfZXhuIGUpKVxubGV0ICggKiogKSBiIGUgPSBwb3cgYiBlXG5cbmV4dGVybmFsIGJzd2FwMzIgOiB0IC0+IHQgPSBcIiVic3dhcF9pbnQzMlwiXG5cbmxldCBic3dhcDE2IHggPSBDYW1sLkludDMyLnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKGJzd2FwMzIgeCkgMTZcblxubW9kdWxlIFBvdzIgPSBzdHJ1Y3RcbiAgb3BlbiEgSW1wb3J0XG4gIG9wZW4gSW50MzJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbiAgbGV0IG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKSA9XG4gICAgUHJpbnRmLmludmFsaWRfYXJnZiBcImFyZ3VtZW50IG11c3QgYmUgc3RyaWN0bHkgcG9zaXRpdmVcIiAoKVxuICA7O1xuXG4gIGxldCAoIGxvciApID0gQ2FtbC5JbnQzMi5sb2dvclxuICBsZXQgKCBsc3IgKSA9IENhbWwuSW50MzIuc2hpZnRfcmlnaHRfbG9naWNhbFxuICBsZXQgKCBsYW5kICkgPSBDYW1sLkludDMyLmxvZ2FuZFxuXG4gICgqKiBcImNlaWxpbmcgcG93ZXIgb2YgMlwiIC0gTGVhc3QgcG93ZXIgb2YgMiBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGNlaWxfcG93MiB4ID1cbiAgICBpZiB4IDw9IENhbWwuSW50MzIuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IENhbWwuSW50MzIucHJlZCB4IGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICBDYW1sLkludDMyLnN1Y2MgeFxuICA7O1xuXG4gICgqKiBcImZsb29yIHBvd2VyIG9mIDJcIiAtIExhcmdlc3QgcG93ZXIgb2YgMiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGZsb29yX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBDYW1sLkludDMyLnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICBDYW1sLkludDMyLnN1YiB4ICh4IGxzciAxKVxuICA7O1xuXG4gIGxldCBpc19wb3cyIHggPVxuICAgIGlmIHggPD0gQ2FtbC5JbnQzMi56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIHggbGFuZCBDYW1sLkludDMyLnByZWQgeCA9IENhbWwuSW50MzIuemVyb1xuICA7O1xuXG4gICgqIEMgc3R1YnMgZm9yIGludDMyIGNseiBhbmQgY3R6IHRvIHVzZSB0aGUgQ0xaL0JTUi9DVFovQlNGIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG4gIGV4dGVybmFsIGNselxuICAgIDogIChpbnQzMltAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludDMyX2NselwiIFwiQmFzZV9pbnRfbWF0aF9pbnQzMl9jbHpfdW5ib3hlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgY3R6XG4gICAgOiAgKGludDMyW0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50MzJfY3R6XCIgXCJCYXNlX2ludF9tYXRoX2ludDMyX2N0el91bmJveGVkXCJcbiAgW0BAbm9hbGxvY11cblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBmbG9vcl9sb2cyIGkgPVxuICAgIGlmIGkgPD0gQ2FtbC5JbnQzMi56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlIFwiW0ludDMyLmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludDMyIGkgXSk7XG4gICAgbnVtX2JpdHMgLSAxIC0gY2x6IGlcbiAgOztcblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBjZWlsX2xvZzIgaSA9XG4gICAgaWYgaSA8PSBDYW1sLkludDMyLnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSW50MzIuY2VpbF9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl9pbnQzMiBpIF0pO1xuICAgICgqIFRoZSBbaSA9IDFdIGNoZWNrIGlzIG5lZWRlZCBiZWNhdXNlIGNseigwKSBpcyB1bmRlZmluZWQgKilcbiAgICBpZiBDYW1sLkludDMyLmVxdWFsIGkgQ2FtbC5JbnQzMi5vbmUgdGhlbiAwIGVsc2UgbnVtX2JpdHMgLSBjbHogKENhbWwuSW50MzIucHJlZCBpKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgUG93MlxuaW5jbHVkZSBDb252Lk1ha2UgKFQpXG5cbmluY2x1ZGUgQ29udi5NYWtlX2hleCAoc3RydWN0XG4gICAgdHlwZSB0ID0gaW50MzIgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2hdXG5cbiAgICBsZXQgY29tcGFyZSA9IChjb21wYXJlX2ludDMyIDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIGhhc2hfZm9sZF9pbnQzMlxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBoYXNoX2ludDMyIGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCB6ZXJvID0gemVyb1xuICAgIGxldCBuZWcgPSAoIH4tIClcbiAgICBsZXQgKCA8ICkgPSAoIDwgKVxuICAgIGxldCB0b19zdHJpbmcgaSA9IFByaW50Zi5zcHJpbnRmIFwiJWx4XCIgaVxuICAgIGxldCBvZl9zdHJpbmcgcyA9IENhbWwuU2NhbmYuc3NjYW5mIHMgXCIlbHhcIiBGbi5pZFxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQzMi5IZXhcIlxuICBlbmQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDMyXCJcbiAgZW5kKVxuXG5tb2R1bGUgUHJlX08gPSBzdHJ1Y3RcbiAgbGV0ICggKyApID0gKCArIClcbiAgbGV0ICggLSApID0gKCAtIClcbiAgbGV0ICggKiApID0gKCAqIClcbiAgbGV0ICggLyApID0gKCAvIClcbiAgbGV0ICggfi0gKSA9ICggfi0gKVxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSAoQ29tcGFyZSA6IENvbXBhcmlzb25zLkluZml4IHdpdGggdHlwZSB0IDo9IHQpXG5cbiAgbGV0IGFicyA9IGFic1xuICBsZXQgbmVnID0gbmVnXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgb2ZfaW50X2V4biA9IG9mX2ludF9leG5cbmVuZFxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBpbmNsdWRlIFByZV9PXG5cbiAgaW5jbHVkZSBJbnRfbWF0aC5NYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGluY2x1ZGUgUHJlX09cblxuICAgICAgbGV0IHJlbSA9IHJlbVxuICAgICAgbGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbiAgICAgIGxldCBvZl9mbG9hdCA9IG9mX2Zsb2F0XG4gICAgICBsZXQgb2Zfc3RyaW5nID0gVC5vZl9zdHJpbmdcbiAgICAgIGxldCB0b19zdHJpbmcgPSBULnRvX3N0cmluZ1xuICAgIGVuZClcblxuICBsZXQgKCBsYW5kICkgPSBiaXRfYW5kXG4gIGxldCAoIGxvciApID0gYml0X29yXG4gIGxldCAoIGx4b3IgKSA9IGJpdF94b3JcbiAgbGV0IGxub3QgPSBiaXRfbm90XG4gIGxldCAoIGxzbCApID0gc2hpZnRfbGVmdFxuICBsZXQgKCBhc3IgKSA9IHNoaWZ0X3JpZ2h0XG4gIGxldCAoIGxzciApID0gc2hpZnRfcmlnaHRfbG9naWNhbFxuZW5kXG5cbmluY2x1ZGUgT1xuXG4oKiBbSW50MzJdIGFuZCBbSW50MzIuT10gYWdyZWUgdmFsdWUtd2lzZSAqKVxuIiwib3BlbiEgSW1wb3J0XG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG5tb2R1bGUgUmVwciA9IEludDYzX2VtdWwuUmVwclxuXG4oKiBJbiBhIHdvcmxkIHdoZXJlIHRoZSBjb21waWxlciB3b3VsZCB1bmRlcnN0YW5kIFtAQGltbWVkaWF0ZTY0XSBhdHRyaWJ1dGVzIG9uIHR5cGVcbiAgIGRlY2xhcmF0aW9ucywgdGhpcyBtb2R1bGUgaXMgaG93IG9uZSB3b3VsZCBwcm9kdWNlIGEgW3R5cGUgdF0gd2l0aCB0aGlzIGF0dHJpYnV0ZS4gKilcbm1vZHVsZSBJbW1lZGlhdGU2NCA6IHNpZ1xuICBtb2R1bGUgdHlwZSBOb25faW1tZWRpYXRlID0gc2lnXG4gICAgdHlwZSB0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIEltbWVkaWF0ZSA9IHNpZ1xuICAgIHR5cGUgdCBbQEBpbW1lZGlhdGVdXG4gIGVuZFxuXG4gIG1vZHVsZSBNYWtlIChJbW1lZGlhdGUgOiBJbW1lZGlhdGUpIChOb25faW1tZWRpYXRlIDogTm9uX2ltbWVkaWF0ZSkgOiBzaWdcbiAgICB0eXBlIHQgW0BAaW1tZWRpYXRlNjRdXG5cbiAgICB0eXBlICdhIHJlcHIgPVxuICAgICAgfCBJbW1lZGlhdGUgOiBJbW1lZGlhdGUudCByZXByXG4gICAgICB8IE5vbl9pbW1lZGlhdGUgOiBOb25faW1tZWRpYXRlLnQgcmVwclxuXG4gICAgdmFsIHJlcHIgOiB0IHJlcHJcbiAgZW5kXG5lbmQgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgTm9uX2ltbWVkaWF0ZSA9IHNpZ1xuICAgIHR5cGUgdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBJbW1lZGlhdGUgPSBzaWdcbiAgICB0eXBlIHQgW0BAaW1tZWRpYXRlXVxuICBlbmRcblxuICBtb2R1bGUgTWFrZSAoSW1tZWRpYXRlIDogSW1tZWRpYXRlKSAoTm9uX2ltbWVkaWF0ZSA6IE5vbl9pbW1lZGlhdGUpID0gc3RydWN0XG4gICAgdHlwZSB0IFtAQGltbWVkaWF0ZTY0XVxuXG4gICAgdHlwZSAnYSByZXByID1cbiAgICAgIHwgSW1tZWRpYXRlIDogSW1tZWRpYXRlLnQgcmVwclxuICAgICAgfCBOb25faW1tZWRpYXRlIDogTm9uX2ltbWVkaWF0ZS50IHJlcHJcblxuICAgIGxldCByZXByID1cbiAgICAgIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICAgICAgfCBXNjQgLT4gKENhbWwuT2JqLm1hZ2ljIEltbWVkaWF0ZSA6IHQgcmVwcilcbiAgICAgIHwgVzMyIC0+IChDYW1sLk9iai5tYWdpYyBOb25faW1tZWRpYXRlIDogdCByZXByKVxuICAgIDs7XG4gIGVuZFxuZW5kXG5cbmluY2x1ZGUgSW1tZWRpYXRlNjQuTWFrZSAoSW50KSAoSW50NjNfZW11bClcblxubW9kdWxlIEJhY2tlbmQgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgaW5jbHVkZSBJbnRfaW50Zi5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBvZl9pbnQgOiBpbnQgLT4gdFxuICAgIHZhbCB0b19pbnQgOiB0IC0+IGludCBvcHRpb25cbiAgICB2YWwgdG9faW50X3RydW5jIDogdCAtPiBpbnRcbiAgICB2YWwgb2ZfaW50MzIgOiBpbnQzMiAtPiB0XG4gICAgdmFsIHRvX2ludDMyIDogdCAtPiBJbnQzMi50IG9wdGlvblxuICAgIHZhbCB0b19pbnQzMl90cnVuYyA6IHQgLT4gSW50MzIudFxuICAgIHZhbCBvZl9pbnQ2NCA6IEludDY0LnQgLT4gdCBvcHRpb25cbiAgICB2YWwgb2ZfaW50NjRfdHJ1bmMgOiBJbnQ2NC50IC0+IHRcbiAgICB2YWwgb2ZfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IHQgb3B0aW9uXG4gICAgdmFsIHRvX25hdGl2ZWludCA6IHQgLT4gbmF0aXZlaW50IG9wdGlvblxuICAgIHZhbCBvZl9uYXRpdmVpbnRfdHJ1bmMgOiBuYXRpdmVpbnQgLT4gdFxuICAgIHZhbCB0b19uYXRpdmVpbnRfdHJ1bmMgOiB0IC0+IG5hdGl2ZWludFxuICAgIHZhbCBvZl9mbG9hdF91bmNoZWNrZWQgOiBmbG9hdCAtPiB0XG4gICAgdmFsIHJlcHIgOiAodCwgdCkgSW50NjNfZW11bC5SZXByLnRcbiAgICB2YWwgYnN3YXAxNiA6IHQgLT4gdFxuICAgIHZhbCBic3dhcDMyIDogdCAtPiB0XG4gICAgdmFsIGJzd2FwNDggOiB0IC0+IHRcbiAgZW5kXG4gIHdpdGggdHlwZSB0IDo9IHRcblxuICBtb2R1bGUgTmF0aXZlID0gc3RydWN0XG4gICAgaW5jbHVkZSBJbnRcblxuICAgIGxldCB0b19pbnQgeCA9IFNvbWUgeFxuICAgIGxldCB0b19pbnRfdHJ1bmMgeCA9IHhcblxuICAgICgqIFtvZl9pbnQzMl9leG5dIGlzIGEgc2FmZSBvcGVyYXRpb24gb24gcGxhdGZvcm1zIHdpdGggNjQtYml0IHdvcmQgc2l6ZXMuICopXG4gICAgbGV0IG9mX2ludDMyID0gb2ZfaW50MzJfZXhuXG4gICAgbGV0IHRvX25hdGl2ZWludF90cnVuYyB4ID0gdG9fbmF0aXZlaW50IHhcbiAgICBsZXQgdG9fbmF0aXZlaW50IHggPSBTb21lICh0b19uYXRpdmVpbnQgeClcbiAgICBsZXQgcmVwciA9IEludDYzX2VtdWwuUmVwci5JbnRcbiAgICBsZXQgYnN3YXAzMiB0ID0gSW50NjQudG9faW50X3RydW5jIChJbnQ2NC5ic3dhcDMyIChJbnQ2NC5vZl9pbnQgdCkpXG4gICAgbGV0IGJzd2FwNDggdCA9IEludDY0LnRvX2ludF90cnVuYyAoSW50NjQuYnN3YXA0OCAoSW50NjQub2ZfaW50IHQpKVxuICBlbmRcblxuICBsZXQgaW1wbCA6IChtb2R1bGUgUykgPVxuICAgIG1hdGNoIHJlcHIgd2l0aFxuICAgIHwgSW1tZWRpYXRlIC0+IChtb2R1bGUgTmF0aXZlIDogUylcbiAgICB8IE5vbl9pbW1lZGlhdGUgLT4gKG1vZHVsZSBJbnQ2M19lbXVsIDogUylcbiAgOztcbmVuZFxuXG5pbmNsdWRlICh2YWwgQmFja2VuZC5pbXBsIDogQmFja2VuZC5TKVxuXG5tb2R1bGUgT3ZlcmZsb3dfZXhuID0gc3RydWN0XG4gIGxldCAoICsgKSB0IHUgPVxuICAgIGxldCBzdW0gPSB0ICsgdSBpblxuICAgIGlmIGJpdF9vciAoYml0X3hvciB0IHUpIChiaXRfeG9yIHQgKGJpdF9ub3Qgc3VtKSkgPCB6ZXJvXG4gICAgdGhlbiBzdW1cbiAgICBlbHNlXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCIoICsgKSBvdmVyZmxvd1wiXG4gICAgICAgICAgIFsgXCJ0XCIsIHNleHBfb2ZfdCB0OyBcInVcIiwgc2V4cF9vZl90IHU7IFwic3VtXCIsIHNleHBfb2ZfdCBzdW0gXSlcbiAgOztcblxuICBsZXQgKCAtICkgdCB1ID1cbiAgICBsZXQgZGlmZiA9IHQgLSB1IGluXG4gICAgbGV0IHBvc19kaWZmID0gdCA+IHUgaW5cbiAgICBpZiB0IDw+IHUgJiYgQm9vbC4oIDw+ICkgcG9zX2RpZmYgKGlzX3Bvc2l0aXZlIGRpZmYpXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiKCAtICkgb3ZlcmZsb3dcIlxuICAgICAgICAgICBbIFwidFwiLCBzZXhwX29mX3QgdDsgXCJ1XCIsIHNleHBfb2ZfdCB1OyBcImRpZmZcIiwgc2V4cF9vZl90IGRpZmYgXSlcbiAgICBlbHNlIGRpZmZcbiAgOztcblxuICBsZXQgbmVnYXRpdmVfb25lID0gb2ZfaW50ICgtMSlcbiAgbGV0IGRpdl93b3VsZF9vdmVyZmxvdyB0IHUgPSB0ID0gbWluX3ZhbHVlICYmIHUgPSBuZWdhdGl2ZV9vbmVcblxuICBsZXQgKCAqICkgdCB1ID1cbiAgICBsZXQgcHJvZHVjdCA9IHQgKiB1IGluXG4gICAgaWYgdSA8PiB6ZXJvICYmIChkaXZfd291bGRfb3ZlcmZsb3cgcHJvZHVjdCB1IHx8IHByb2R1Y3QgLyB1IDw+IHQpXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiKCAqICkgb3ZlcmZsb3dcIlxuICAgICAgICAgICBbIFwidFwiLCBzZXhwX29mX3QgdDsgXCJ1XCIsIHNleHBfb2ZfdCB1OyBcInByb2R1Y3RcIiwgc2V4cF9vZl90IHByb2R1Y3QgXSlcbiAgICBlbHNlIHByb2R1Y3RcbiAgOztcblxuICBsZXQgKCAvICkgdCB1ID1cbiAgICBpZiBkaXZfd291bGRfb3ZlcmZsb3cgdCB1XG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiKCAvICkgb3ZlcmZsb3dcIlxuICAgICAgICAgICBbIFwidFwiLCBzZXhwX29mX3QgdDsgXCJ1XCIsIHNleHBfb2ZfdCB1OyBcInByb2R1Y3RcIiwgc2V4cF9vZl90ICh0IC8gdSkgXSlcbiAgICBlbHNlIHQgLyB1XG4gIDs7XG5cbiAgbGV0IGFicyB0ID0gaWYgdCA9IG1pbl92YWx1ZSB0aGVuIGZhaWx3aXRoIFwiYWJzIG92ZXJmbG93XCIgZWxzZSBhYnMgdFxuICBsZXQgbmVnIHQgPSBpZiB0ID0gbWluX3ZhbHVlIHRoZW4gZmFpbHdpdGggXCJuZWcgb3ZlcmZsb3dcIiBlbHNlIG5lZyB0XG5lbmRcblxubGV0ICgpID0gYXNzZXJ0IChJbnQuKCA9ICkgbnVtX2JpdHMgNjMpXG5cbmxldCByYW5kb21fb2ZfaW50ID8oc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgYm91bmQgPVxuICBvZl9pbnQgKFJhbmRvbS5TdGF0ZS5pbnQgc3RhdGUgKHRvX2ludF9leG4gYm91bmQpKVxuOztcblxubGV0IHJhbmRvbV9vZl9pbnQ2NCA/KHN0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGJvdW5kID1cbiAgb2ZfaW50NjRfZXhuIChSYW5kb20uU3RhdGUuaW50NjQgc3RhdGUgKHRvX2ludDY0IGJvdW5kKSlcbjs7XG5cbmxldCByYW5kb20gPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gcmFuZG9tX29mX2ludFxuICB8IFczMiAtPiByYW5kb21fb2ZfaW50NjRcbjs7XG5cbmxldCByYW5kb21faW5jbF9vZl9pbnQgPyhzdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsbyBoaSA9XG4gIG9mX2ludCAoUmFuZG9tLlN0YXRlLmludF9pbmNsIHN0YXRlICh0b19pbnRfZXhuIGxvKSAodG9faW50X2V4biBoaSkpXG47O1xuXG5sZXQgcmFuZG9tX2luY2xfb2ZfaW50NjQgPyhzdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBsbyBoaSA9XG4gIG9mX2ludDY0X2V4biAoUmFuZG9tLlN0YXRlLmludDY0X2luY2wgc3RhdGUgKHRvX2ludDY0IGxvKSAodG9faW50NjQgaGkpKVxuOztcblxubGV0IHJhbmRvbV9pbmNsID1cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+IHJhbmRvbV9pbmNsX29mX2ludFxuICB8IFczMiAtPiByYW5kb21faW5jbF9vZl9pbnQ2NFxuOztcblxubGV0IGZsb29yX2xvZzIgdCA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiB0IHw+IHRvX2ludF9leG4gfD4gSW50LmZsb29yX2xvZzJcbiAgfCBXMzIgLT5cbiAgICBpZiB0IDw9IHplcm9cbiAgICB0aGVuIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfdCB0IF0pO1xuICAgIGxldCBmbG9vcl9sb2cyID0gcmVmIChJbnQuKCAtICkgbnVtX2JpdHMgMikgaW5cbiAgICB3aGlsZSBlcXVhbCB6ZXJvIChiaXRfYW5kIHQgKHNoaWZ0X2xlZnQgb25lICFmbG9vcl9sb2cyKSkgZG9cbiAgICAgIGZsb29yX2xvZzIgOj0gSW50LiggLSApICFmbG9vcl9sb2cyIDFcbiAgICBkb25lO1xuICAgICFmbG9vcl9sb2cyXG47O1xuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgUmVwciA9IFJlcHJcblxuICBsZXQgcmVwciA9IHJlcHJcblxuICBtb2R1bGUgRW11bCA9IEludDYzX2VtdWxcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbigqKiBAY2Fub25pY2FsIEJhc2UuSGFzaHRibC5LZXkgKilcbm1vZHVsZSBLZXkgPSBzdHJ1Y3RcbiAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG5cbiAgICAoKiogVHdvIFt0XXMgdGhhdCBbY29tcGFyZV0gZXF1YWwgbXVzdCBoYXZlIGVxdWFsIGhhc2hlcyBmb3IgdGhlIGhhc2h0YWJsZVxuICAgICAgICB0byBiZWhhdmUgcHJvcGVybHkuICopXG4gICAgdmFsIGhhc2ggOiB0IC0+IGludFxuICBlbmRcblxuICB0eXBlICdhIHQgPSAobW9kdWxlIFMgd2l0aCB0eXBlIHQgPSAnYSlcbmVuZFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLkhhc2h0YmwuTWVyZ2VfaW50b19hY3Rpb24gKilcbm1vZHVsZSBNZXJnZV9pbnRvX2FjdGlvbiA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHwgUmVtb3ZlXG4gICAgfCBTZXRfdG8gb2YgJ2FcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMgPSBzaWdcbiAgKCoqIHsyIEFjY2Vzc29yc30gKilcblxuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAnYSBrZXlcblxuICB2YWwgc2V4cF9vZl9rZXkgOiAoJ2EsIF8pIHQgLT4gJ2Ega2V5IC0+IFNleHAudFxuICB2YWwgY2xlYXIgOiAoXywgXykgdCAtPiB1bml0XG4gIHZhbCBjb3B5IDogKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0XG5cbiAgKCoqIEF0dGVtcHRpbmcgdG8gbW9kaWZ5IChbc2V0XSwgW3JlbW92ZV0sIGV0Yy4pIHRoZSBoYXNodGFibGUgZHVyaW5nIGl0ZXJhdGlvbiAoW2ZvbGRdLFxuICAgICAgW2l0ZXJdLCBbaXRlcl9rZXlzXSwgW2l0ZXJpXSkgd2lsbCByYWlzZSBhbiBleGNlcHRpb24uICopXG4gIHZhbCBmb2xkIDogKCdhLCAnYikgdCAtPiBpbml0OidjIC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAnYyAtPiAnYykgLT4gJ2NcblxuICB2YWwgaXRlcl9rZXlzIDogKCdhLCBfKSB0IC0+IGY6KCdhIGtleSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICdiKSB0IC0+IGY6KCdiIC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogSXRlcmF0ZXMgb3ZlciBib3RoIGtleXMgYW5kIHZhbHVlcy5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge3ZcbiAgICAgIGxldCBoID0gSGFzaHRibC5vZl9hbGlzdF9leG4gKG1vZHVsZSBJbnQpIFsoMSwgNCk7ICg1LCA2KV0gaW5cbiAgICAgIEhhc2h0YmwuaXRlcmkgaCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgICAgcHJpbnRfZW5kbGluZSAoUHJpbnRmLnNwcmludGYgXCIlZC0lZFwiIGtleSBkYXRhKSk7O1xuICAgICAgMS00XG4gICAgICA1LTZcbiAgICAgIC0gOiB1bml0ID0gKClcbiAgICAgIHZ9ICopXG4gIHZhbCBpdGVyaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXRcblxuICB2YWwgZXhpc3RzaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0cyA6IChfLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGwgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnRpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudCA6IChfLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiBpbnRcbiAgdmFsIGxlbmd0aCA6IChfLCBfKSB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiAoXywgXykgdCAtPiBib29sXG4gIHZhbCBtZW0gOiAoJ2EsIF8pIHQgLT4gJ2Ega2V5IC0+IGJvb2xcbiAgdmFsIHJlbW92ZSA6ICgnYSwgXykgdCAtPiAnYSBrZXkgLT4gdW5pdFxuICB2YWwgY2hvb3NlIDogKCdhLCAnYikgdCAtPiAoJ2Ega2V5ICogJ2IpIG9wdGlvblxuICB2YWwgY2hvb3NlX2V4biA6ICgnYSwgJ2IpIHQgLT4gJ2Ega2V5ICogJ2JcblxuICAoKiogU2V0cyB0aGUgZ2l2ZW4gW2tleV0gdG8gW2RhdGFdLiAqKVxuICB2YWwgc2V0IDogKCdhLCAnYikgdCAtPiBrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gdW5pdFxuXG4gICgqKiBbYWRkXSBhbmQgW2FkZF9leG5dIGxlYXZlIHRoZSB0YWJsZSB1bmNoYW5nZWQgaWYgdGhlIGtleSB3YXMgYWxyZWFkeSBwcmVzZW50LiAqKVxuICB2YWwgYWRkIDogKCdhLCAnYikgdCAtPiBrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gWyBgT2sgfCBgRHVwbGljYXRlIF1cblxuICB2YWwgYWRkX2V4biA6ICgnYSwgJ2IpIHQgLT4ga2V5OidhIGtleSAtPiBkYXRhOidiIC0+IHVuaXRcblxuICAoKiogW2NoYW5nZSB0IGtleSB+Zl0gY2hhbmdlcyBbdF0ncyB2YWx1ZSBmb3IgW2tleV0gdG8gYmUgW2YgKGZpbmQgdCBrZXkpXS4gKilcbiAgdmFsIGNoYW5nZSA6ICgnYSwgJ2IpIHQgLT4gJ2Ega2V5IC0+IGY6KCdiIG9wdGlvbiAtPiAnYiBvcHRpb24pIC0+IHVuaXRcblxuICAoKiogW3VwZGF0ZSB0IGtleSB+Zl0gaXMgW2NoYW5nZSB0IGtleSB+ZjooZnVuIG8gLT4gU29tZSAoZiBvKSldLiAqKVxuICB2YWwgdXBkYXRlIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gZjooJ2Igb3B0aW9uIC0+ICdiKSAtPiB1bml0XG5cbiAgKCoqIFt1cGRhdGVfYW5kX3JldHVybiB0IGtleSB+Zl0gaXMgW3VwZGF0ZV0sIGJ1dCByZXR1cm5zIHRoZSByZXN1bHQgb2YgW2Ygb10uICopXG4gIHZhbCB1cGRhdGVfYW5kX3JldHVybiA6ICgnYSwgJ2IpIHQgLT4gJ2Ega2V5IC0+IGY6KCdiIG9wdGlvbiAtPiAnYikgLT4gJ2JcblxuICAoKiogW21hcCB0IGZdIHJldHVybnMgYSBuZXcgdGFibGUgd2l0aCB2YWx1ZXMgcmVwbGFjZWQgYnkgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBbZl1cbiAgICAgIHRvIHRoZSBjdXJyZW50IHZhbHVlcy5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge3ZcbiAgICAgIGxldCBoID0gSGFzaHRibC5vZl9hbGlzdF9leG4gKG1vZHVsZSBJbnQpIFsoMSwgNCk7ICg1LCA2KV0gaW5cbiAgICAgIGxldCBoJyA9IEhhc2h0YmwubWFwIGggfmY6KGZ1biB4IC0+IHggKiAyKSBpblxuICAgICAgSGFzaHRibC50b19hbGlzdCBoJzs7XG4gICAgICAtIDogKGludCAqIGludCkgbGlzdCA9IFsoNSwgMTIpOyAoMSwgOCldXG4gICAgICB2fSAqKVxuICB2YWwgbWFwIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiAnYykgLT4gKCdhLCAnYykgdFxuXG4gICgqKiBMaWtlIFttYXBdLCBidXQgdGhlIGZ1bmN0aW9uIFtmXSB0YWtlcyBib3RoIGtleSBhbmQgZGF0YSBhcyBhcmd1bWVudHMuICopXG4gIHZhbCBtYXBpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gJ2MpIC0+ICgnYSwgJ2MpIHRcblxuICAoKiogUmV0dXJucyBhIG5ldyB0YWJsZSBieSBmaWx0ZXJpbmcgdGhlIGdpdmVuIHRhYmxlJ3MgdmFsdWVzIGJ5IFtmXTogdGhlIGtleXMgZm9yIHdoaWNoXG4gICAgICBbZl0gYXBwbGllZCB0byB0aGUgY3VycmVudCB2YWx1ZSByZXR1cm5zIFtTb21lXSBhcmUga2VwdCwgYW5kIHRob3NlIGZvciB3aGljaCBpdFxuICAgICAgcmV0dXJucyBbTm9uZV0gYXJlIGRpc2NhcmRlZC5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge3ZcbiAgICAgIGxldCBoID0gSGFzaHRibC5vZl9hbGlzdF9leG4gKG1vZHVsZSBJbnQpIFsoMSwgNCk7ICg1LCA2KV0gaW5cbiAgICAgIEhhc2h0YmwuZmlsdGVyX21hcCBoIH5mOihmdW4geCAtPiBpZiB4ID4gNSB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpXG4gICAgICB8PiBIYXNodGJsLnRvX2FsaXN0OztcbiAgICAgIC0gOiAoaW50ICogaW50KSBsaXN0ID0gWyg1LCA2KV1cbiAgICAgIHZ9ICopXG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiAnYyBvcHRpb24pIC0+ICgnYSwgJ2MpIHRcblxuICAoKiogTGlrZSBbZmlsdGVyX21hcF0sIGJ1dCB0aGUgZnVuY3Rpb24gW2ZdIHRha2VzIGJvdGgga2V5IGFuZCBkYXRhIGFzIGFyZ3VtZW50cy4gKilcbiAgdmFsIGZpbHRlcl9tYXBpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gJ2Mgb3B0aW9uKSAtPiAoJ2EsICdjKSB0XG5cbiAgdmFsIGZpbHRlcl9rZXlzIDogKCdhLCAnYikgdCAtPiBmOignYSBrZXkgLT4gYm9vbCkgLT4gKCdhLCAnYikgdFxuICB2YWwgZmlsdGVyIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBmaWx0ZXJpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdFxuXG4gICgqKiBSZXR1cm5zIG5ldyB0YWJsZXMgd2l0aCBib3VuZCB2YWx1ZXMgcGFydGl0aW9uZWQgYnkgW2ZdIGFwcGxpZWQgdG8gdGhlIGJvdW5kXG4gICAgICB2YWx1ZXMuICopXG4gIHZhbCBwYXJ0aXRpb25fbWFwIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiAoJ2MsICdkKSBFaXRoZXIudCkgLT4gKCdhLCAnYykgdCAqICgnYSwgJ2QpIHRcblxuICAoKiogTGlrZSBbcGFydGl0aW9uX21hcF0sIGJ1dCB0aGUgZnVuY3Rpb24gW2ZdIHRha2VzIGJvdGgga2V5IGFuZCBkYXRhIGFzIGFyZ3VtZW50cy4gKilcbiAgdmFsIHBhcnRpdGlvbl9tYXBpXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAoJ2MsICdkKSBFaXRoZXIudClcbiAgICAtPiAoJ2EsICdjKSB0ICogKCdhLCAnZCkgdFxuXG4gICgqKiBSZXR1cm5zIGEgcGFpciBvZiB0YWJsZXMgWyh0MSwgdDIpXSwgd2hlcmUgW3QxXSBjb250YWlucyBhbGwgdGhlIGVsZW1lbnRzIG9mIHRoZVxuICAgICAgaW5pdGlhbCB0YWJsZSB3aGljaCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUgW2ZdLCBhbmQgW3QyXSBjb250YWlucyB0aGUgcmVzdC4gKilcbiAgdmFsIHBhcnRpdGlvbl90ZiA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdCAqICgnYSwgJ2IpIHRcblxuICAoKiogTGlrZSBbcGFydGl0aW9uX3RmXSwgYnV0IHRoZSBmdW5jdGlvbiBbZl0gdGFrZXMgYm90aCBrZXkgYW5kIGRhdGEgYXMgYXJndW1lbnRzLiAqKVxuICB2YWwgcGFydGl0aW9uaV90ZlxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiKSB0ICogKCdhLCAnYikgdFxuXG4gICgqKiBbZmluZF9vcl9hZGQgdCBrIH5kZWZhdWx0XSByZXR1cm5zIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCBrZXkgW2tdIGlmIGl0IGlzIGluIHRoZVxuICAgICAgdGFibGUgW3RdLCBhbmQgb3RoZXJ3aXNlIGFzc2lnbnMgW2tdIHRoZSB2YWx1ZSByZXR1cm5lZCBieSBbZGVmYXVsdCAoKV0uICopXG4gIHZhbCBmaW5kX29yX2FkZCA6ICgnYSwgJ2IpIHQgLT4gJ2Ega2V5IC0+IGRlZmF1bHQ6KHVuaXQgLT4gJ2IpIC0+ICdiXG5cbiAgKCoqIExpa2UgW2ZpbmRfb3JfYWRkXSBidXQgW2RlZmF1bHRdIHRha2VzIHRoZSBrZXkgYXMgYW4gYXJndW1lbnQuICopXG4gIHZhbCBmaW5kaV9vcl9hZGQgOiAoJ2EsICdiKSB0IC0+ICdhIGtleSAtPiBkZWZhdWx0OignYSBrZXkgLT4gJ2IpIC0+ICdiXG5cbiAgKCoqIFtmaW5kIHQga10gcmV0dXJucyBbU29tZV0gKHRoZSBjdXJyZW50IGJpbmRpbmcpIG9mIFtrXSBpbiBbdF0sIG9yIFtOb25lXSBpZiBubyBzdWNoXG4gICAgICBiaW5kaW5nIGV4aXN0cy4gKilcbiAgdmFsIGZpbmQgOiAoJ2EsICdiKSB0IC0+ICdhIGtleSAtPiAnYiBvcHRpb25cblxuICAoKiogW2ZpbmRfZXhuIHQga10gcmV0dXJucyB0aGUgY3VycmVudCBiaW5kaW5nIG9mIFtrXSBpbiBbdF0sIG9yIHJhaXNlcyBbQ2FtbC5Ob3RfZm91bmRdXG4gICAgICBvciBbTm90X2ZvdW5kX3NdIGlmIG5vIHN1Y2ggYmluZGluZyBleGlzdHMuICopXG4gIHZhbCBmaW5kX2V4biA6ICgnYSwgJ2IpIHQgLT4gJ2Ega2V5IC0+ICdiXG5cbiAgKCoqIFtmaW5kX2FuZF9jYWxsIHQgayB+aWZfZm91bmQgfmlmX25vdF9mb3VuZF1cblxuICAgICAgaXMgZXF1aXZhbGVudCB0bzpcblxuICAgICAgW21hdGNoIGZpbmQgdCBrIHdpdGggU29tZSB2IC0+IGlmX2ZvdW5kIHYgfCBOb25lIC0+IGlmX25vdF9mb3VuZCBrXVxuXG4gICAgICBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFsbG9jYXRlIHRoZSBvcHRpb24uICopXG4gIHZhbCBmaW5kX2FuZF9jYWxsXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICdhIGtleVxuICAgIC0+IGlmX2ZvdW5kOignYiAtPiAnYylcbiAgICAtPiBpZl9ub3RfZm91bmQ6KCdhIGtleSAtPiAnYylcbiAgICAtPiAnY1xuXG4gICgqKiBKdXN0IGxpa2UgW2ZpbmRfYW5kX2NhbGxdLCBidXQgdGFrZXMgYW4gZXh0cmEgYXJndW1lbnQgd2hpY2ggaXMgcGFzc2VkIHRvIFtpZl9mb3VuZF1cbiAgICAgIGFuZCBbaWZfbm90X2ZvdW5kXSwgc28gdGhhdCB0aGUgY2xpZW50IGNvZGUgY2FuIGF2b2lkIGFsbG9jYXRpbmcgY2xvc3VyZXMgb3IgdXNpbmdcbiAgICAgIHJlZnMgdG8gcGFzcyB0aGlzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uICBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgdXNlZnVsIGluIGNvZGVcbiAgICAgIHdoaWNoIHRyaWVzIHRvIG1pbmltaXplIGhlYXAgYWxsb2NhdGlvbi4gKilcbiAgdmFsIGZpbmRfYW5kX2NhbGwxXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICdhIGtleVxuICAgIC0+IGE6J2RcbiAgICAtPiBpZl9mb3VuZDooJ2IgLT4gJ2QgLT4gJ2MpXG4gICAgLT4gaWZfbm90X2ZvdW5kOignYSBrZXkgLT4gJ2QgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgZmluZF9hbmRfY2FsbDJcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gJ2Ega2V5XG4gICAgLT4gYTonZFxuICAgIC0+IGI6J2VcbiAgICAtPiBpZl9mb3VuZDooJ2IgLT4gJ2QgLT4gJ2UgLT4gJ2MpXG4gICAgLT4gaWZfbm90X2ZvdW5kOignYSBrZXkgLT4gJ2QgLT4gJ2UgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgZmluZGlfYW5kX2NhbGxcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gJ2Ega2V5XG4gICAgLT4gaWZfZm91bmQ6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAnYylcbiAgICAtPiBpZl9ub3RfZm91bmQ6KCdhIGtleSAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBmaW5kaV9hbmRfY2FsbDFcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gJ2Ega2V5XG4gICAgLT4gYTonZFxuICAgIC0+IGlmX2ZvdW5kOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gJ2QgLT4gJ2MpXG4gICAgLT4gaWZfbm90X2ZvdW5kOignYSBrZXkgLT4gJ2QgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgZmluZGlfYW5kX2NhbGwyXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICdhIGtleVxuICAgIC0+IGE6J2RcbiAgICAtPiBiOidlXG4gICAgLT4gaWZfZm91bmQ6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAnZCAtPiAnZSAtPiAnYylcbiAgICAtPiBpZl9ub3RfZm91bmQ6KCdhIGtleSAtPiAnZCAtPiAnZSAtPiAnYylcbiAgICAtPiAnY1xuXG4gICgqKiBbZmluZF9hbmRfcmVtb3ZlIHQga10gcmV0dXJucyBTb21lICh0aGUgY3VycmVudCBiaW5kaW5nKSBvZiBrIGluIHQgYW5kIHJlbW92ZXMgaXQsXG4gICAgICBvciBOb25lIGlzIG5vIHN1Y2ggYmluZGluZyBleGlzdHMuICopXG4gIHZhbCBmaW5kX2FuZF9yZW1vdmUgOiAoJ2EsICdiKSB0IC0+ICdhIGtleSAtPiAnYiBvcHRpb25cblxuICAoKiogTWVyZ2VzIHR3byBoYXNodGFibGVzLlxuXG4gICAgICBUaGUgcmVzdWx0IG9mIFttZXJnZSBmIGgxIGgyXSBoYXMgYXMga2V5cyB0aGUgc2V0IG9mIGFsbCBba10gaW4gdGhlIHVuaW9uIG9mIHRoZVxuICAgICAgc2V0cyBvZiBrZXlzIG9mIFtoMV0gYW5kIFtoMl0gZm9yIHdoaWNoIFtkKGspXSBpcyBub3QgTm9uZSwgd2hlcmU6XG5cbiAgICAgIGQoaykgPVxuICAgICAgLSBbZiB+a2V5OmsgKGBMZWZ0IGQxKV1cbiAgICAgICAgaWYgW2tdIGluIFtoMV0gbWFwcyB0byBkMSwgYW5kIFtoMl0gZG9lcyBub3QgaGF2ZSBkYXRhIGZvciBba107XG5cbiAgICAgIC0gW2YgfmtleTprIChgUmlnaHQgZDIpXVxuICAgICAgICBpZiBba10gaW4gW2gyXSBtYXBzIHRvIGQyLCBhbmQgW2gxXSBkb2VzIG5vdCBoYXZlIGRhdGEgZm9yIFtrXTtcblxuICAgICAgLSBbZiB+a2V5OmsgKGBCb3RoIChkMSwgZDIpKV1cbiAgICAgICAgb3RoZXJ3aXNlLCB3aGVyZSBba10gaW4gW2gxXSBtYXBzIHRvIFtkMV0gYW5kIFtrXSBpbiBbaDJdIG1hcHMgdG8gW2QyXS5cblxuICAgICAgRWFjaCBrZXkgW2tdIGlzIG1hcHBlZCB0byBhIHNpbmdsZSBwaWVjZSBvZiBkYXRhIFt4XSwgd2hlcmUgW2QoaykgPSBTb21lIHhdLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgbGV0IGgxID0gSGFzaHRibC5vZl9hbGlzdF9leG4gKG1vZHVsZSBJbnQpIFsoMSwgNSk7ICgyLCAzMjMyKV0gaW5cbiAgICAgIGxldCBoMiA9IEhhc2h0Ymwub2ZfYWxpc3RfZXhuIChtb2R1bGUgSW50KSBbKDEsIDMpXSBpblxuICAgICAgSGFzaHRibC5tZXJnZSBoMSBoMiB+ZjooZnVuIH5rZXk6XyAtPiBmdW5jdGlvblxuICAgICAgICB8IGBMZWZ0IHggLT4gU29tZSAoYExlZnQgeClcbiAgICAgICAgfCBgUmlnaHQgeCAtPiBTb21lIChgUmlnaHQgeClcbiAgICAgICAgfCBgQm90aCAoeCwgeSkgLT4gaWYgeD15IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGBCb3RoICh4LHkpKVxuICAgICAgKSB8PiBIYXNodGJsLnRvX2FsaXN0OztcbiAgICAgIC0gOiAoaW50ICogWz4gYEJvdGggb2YgaW50ICogaW50IHwgYExlZnQgb2YgaW50IHwgYFJpZ2h0IG9mIGludCBdKSBsaXN0ID1cbiAgICAgIFsoMiwgYExlZnQgMzIzMik7ICgxLCBgQm90aCAoNSwgMykpXVxuICAgICAgdn0gKilcbiAgdmFsIG1lcmdlXG4gICAgOiAgKCdrLCAnYSkgdFxuICAgIC0+ICgnaywgJ2IpIHRcbiAgICAtPiBmOihrZXk6J2sga2V5IC0+IFsgYExlZnQgb2YgJ2EgfCBgUmlnaHQgb2YgJ2IgfCBgQm90aCBvZiAnYSAqICdiIF0gLT4gJ2Mgb3B0aW9uKVxuICAgIC0+ICgnaywgJ2MpIHRcblxuXG4gICgqKiBFdmVyeSBba2V5XSBpbiBbc3JjXSB3aWxsIGJlIHJlbW92ZWQgb3Igc2V0IGluIFtkc3RdIGFjY29yZGluZyB0byB0aGUgcmV0dXJuIHZhbHVlXG4gICAgICBvZiBbZl0uICopXG4gIHZhbCBtZXJnZV9pbnRvXG4gICAgOiAgc3JjOignaywgJ2EpIHRcbiAgICAtPiBkc3Q6KCdrLCAnYikgdFxuICAgIC0+IGY6KGtleTonayBrZXkgLT4gJ2EgLT4gJ2Igb3B0aW9uIC0+ICdiIE1lcmdlX2ludG9fYWN0aW9uLnQpXG4gICAgLT4gdW5pdFxuXG4gICgqKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGFsbCBrZXlzIGZvciBnaXZlbiBoYXNodGFibGUuICopXG4gIHZhbCBrZXlzIDogKCdhLCBfKSB0IC0+ICdhIGtleSBsaXN0XG5cbiAgKCoqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIGRhdGEgZm9yIGdpdmVuIGhhc2h0YWJsZS4gKilcbiAgdmFsIGRhdGEgOiAoXywgJ2IpIHQgLT4gJ2IgbGlzdFxuXG4gICgqKiBbZmlsdGVyX2lucGxhY2UgdCB+Zl0gcmVtb3ZlcyBhbGwgdGhlIGVsZW1lbnRzIGZyb20gW3RdIHRoYXQgZG9uJ3Qgc2F0aXNmeSBbZl0uICopXG4gIHZhbCBmaWx0ZXJfa2V5c19pbnBsYWNlIDogKCdhLCBfKSB0IC0+IGY6KCdhIGtleSAtPiBib29sKSAtPiB1bml0XG5cbiAgdmFsIGZpbHRlcl9pbnBsYWNlIDogKF8sICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IHVuaXRcbiAgdmFsIGZpbHRlcmlfaW5wbGFjZSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IHVuaXRcblxuICAoKiogW21hcF9pbnBsYWNlIHQgfmZdIGFwcGxpZXMgW2ZdIHRvIGFsbCBlbGVtZW50cyBpbiBbdF0sIHRyYW5zZm9ybWluZyB0aGVtIGluXG4gICAgICBwbGFjZS4gKilcbiAgdmFsIG1hcF9pbnBsYWNlIDogKF8sICdiKSB0IC0+IGY6KCdiIC0+ICdiKSAtPiB1bml0XG5cbiAgdmFsIG1hcGlfaW5wbGFjZSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICdiKSAtPiB1bml0XG5cbiAgKCoqIFtmaWx0ZXJfbWFwX2lucGxhY2VdIGNvbWJpbmVzIHRoZSBlZmZlY3RzIG9mIFttYXBfaW5wbGFjZV0gYW5kIFtmaWx0ZXJfaW5wbGFjZV0uICopXG4gIHZhbCBmaWx0ZXJfbWFwX2lucGxhY2UgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gJ2Igb3B0aW9uKSAtPiB1bml0XG5cbiAgdmFsIGZpbHRlcl9tYXBpX2lucGxhY2UgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAnYiBvcHRpb24pIC0+IHVuaXRcblxuICAoKiogW2VxdWFsIGYgdDEgdDJdIGFuZCBbc2ltaWxhciBmIHQxIHQyXSBib3RoIHJldHVybiB0cnVlIGlmZiBbdDFdIGFuZCBbdDJdIGhhdmUgdGhlXG4gICAgICBzYW1lIGtleXMgYW5kIGZvciBhbGwga2V5cyBba10sIFtmIChmaW5kX2V4biB0MSBrKSAoZmluZF9leG4gdDIgayldLiAgW2VxdWFsXSBhbmRcbiAgICAgIFtzaW1pbGFyXSBvbmx5IGRpZmZlciBpbiB0aGVpciB0eXBlcy4gKilcbiAgdmFsIGVxdWFsIDogKCdiIC0+ICdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBib29sXG5cbiAgdmFsIHNpbWlsYXIgOiAoJ2IxIC0+ICdiMiAtPiBib29sKSAtPiAoJ2EsICdiMSkgdCAtPiAoJ2EsICdiMikgdCAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIChrZXksIGRhdGEpIHBhaXJzIGZvciBnaXZlbiBoYXNodGFibGUuICopXG4gIHZhbCB0b19hbGlzdCA6ICgnYSwgJ2IpIHQgLT4gKCdhIGtleSAqICdiKSBsaXN0XG5cblxuICAoKiogW3JlbW92ZV9pZl96ZXJvXSdzIGRlZmF1bHQgaXMgW2ZhbHNlXS4gKilcbiAgdmFsIGluY3IgOiA/Ynk6aW50IC0+ID9yZW1vdmVfaWZfemVybzpib29sIC0+ICgnYSwgaW50KSB0IC0+ICdhIGtleSAtPiB1bml0XG5cbiAgdmFsIGRlY3IgOiA/Ynk6aW50IC0+ID9yZW1vdmVfaWZfemVybzpib29sIC0+ICgnYSwgaW50KSB0IC0+ICdhIGtleSAtPiB1bml0XG5lbmRcblxubW9kdWxlIHR5cGUgTXVsdGkgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG4gIHR5cGUgJ2Ega2V5XG5cbiAgKCoqIFthZGRfbXVsdGkgdCB+a2V5IH5kYXRhXSBpZiBba2V5XSBpcyBwcmVzZW50IGluIHRoZSB0YWJsZSB0aGVuIGNvbnNcbiAgICAgIFtkYXRhXSBvbiB0aGUgbGlzdCwgb3RoZXJ3aXNlIGFkZCBba2V5XSB3aXRoIGEgc2luZ2xlIGVsZW1lbnQgbGlzdC4gKilcbiAgdmFsIGFkZF9tdWx0aSA6ICgnYSwgJ2IgbGlzdCkgdCAtPiBrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gdW5pdFxuXG4gICgqKiBbcmVtb3ZlX211bHRpIHQga2V5XSB1cGRhdGVzIHRoZSB0YWJsZSwgcmVtb3ZpbmcgdGhlIGhlYWQgb2YgdGhlIGxpc3QgYm91bmQgdG9cbiAgICAgIFtrZXldLiBJZiB0aGUgbGlzdCBoYXMgb25seSBvbmUgZWxlbWVudCAob3IgaXMgZW1wdHkpIHRoZW4gdGhlIGJpbmRpbmcgaXNcbiAgICAgIHJlbW92ZWQuICopXG4gIHZhbCByZW1vdmVfbXVsdGkgOiAoJ2EsIF8gbGlzdCkgdCAtPiAnYSBrZXkgLT4gdW5pdFxuXG4gICgqKiBbZmluZF9tdWx0aSB0IGtleV0gcmV0dXJucyB0aGUgZW1wdHkgbGlzdCBpZiBba2V5XSBpcyBub3QgcHJlc2VudCBpbiB0aGUgdGFibGUsXG4gICAgICByZXR1cm5zIFt0XSdzIHZhbHVlcyBmb3IgW2tleV0gb3RoZXJ3aXNlLiAqKVxuICB2YWwgZmluZF9tdWx0aSA6ICgnYSwgJ2IgbGlzdCkgdCAtPiAnYSBrZXkgLT4gJ2IgbGlzdFxuZW5kXG5cbnR5cGUgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnMgPVxuICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAtPiAna2V5IEtleS50XG4gIC0+ICd6XG5cbnR5cGUgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGUgPVxuICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAtPiAnelxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19nZW5lcmljID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICdhIGtleVxuICB0eXBlICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIGNyZWF0ZSA6ICgnYSBrZXksICdiLCB1bml0IC0+ICgnYSwgJ2IpIHQpIGNyZWF0ZV9vcHRpb25zXG5cblxuICB2YWwgb2ZfYWxpc3RcbiAgICA6ICggJ2Ega2V5XG4gICAgICAsICdiXG4gICAgICAsICgnYSBrZXkgKiAnYikgbGlzdCAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2Ega2V5IF0gKVxuICAgICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHNcbiAgICA6ICggJ2Ega2V5XG4gICAgICAsICdiXG4gICAgICAsICgnYSBrZXkgKiAnYikgbGlzdCAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYER1cGxpY2F0ZV9rZXlzIG9mICdhIGtleSBsaXN0IF0gKVxuICAgICAgICBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvclxuICAgIDogKCdhIGtleSwgJ2IsICgnYSBrZXkgKiAnYikgbGlzdCAtPiAoJ2EsICdiKSB0IE9yX2Vycm9yLnQpIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X2V4biA6ICgnYSBrZXksICdiLCAoJ2Ega2V5ICogJ2IpIGxpc3QgLT4gKCdhLCAnYikgdCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RfbXVsdGlcbiAgICA6ICgnYSBrZXksICdiIGxpc3QsICgnYSBrZXkgKiAnYikgbGlzdCAtPiAoJ2EsICdiIGxpc3QpIHQpIGNyZWF0ZV9vcHRpb25zXG5cblxuICAoKioge1sgY3JlYXRlX21hcHBlZCBnZXRfa2V5IGdldF9kYXRhIFt4MSwuLi4seG5dXG4gICAgICAgICA9IG9mX2FsaXN0IFtnZXRfa2V5IHgxLCBnZXRfZGF0YSB4MTsgLi4uOyBnZXRfa2V5IHhuLCBnZXRfZGF0YSB4bl0gXX0gKilcbiAgdmFsIGNyZWF0ZV9tYXBwZWRcbiAgICA6ICggJ2Ega2V5XG4gICAgICAsICdiXG4gICAgICAsIGdldF9rZXk6KCdyIC0+ICdhIGtleSlcbiAgICAgICAgLT4gZ2V0X2RhdGE6KCdyIC0+ICdiKVxuICAgICAgICAtPiAnciBsaXN0XG4gICAgICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleXMgb2YgJ2Ega2V5IGxpc3QgXSApXG4gICAgICAgIGNyZWF0ZV9vcHRpb25zXG5cblxuICAoKioge1sgY3JlYXRlX3dpdGhfa2V5IH5nZXRfa2V5IFt4MSwuLi4seG5dXG4gICAgICAgICA9IG9mX2FsaXN0IFtnZXRfa2V5IHgxLCB4MTsgLi4uOyBnZXRfa2V5IHhuLCB4bl0gXX0gKilcbiAgdmFsIGNyZWF0ZV93aXRoX2tleVxuICAgIDogKCAnYSBrZXlcbiAgICAgICwgJ3JcbiAgICAgICwgZ2V0X2tleTooJ3IgLT4gJ2Ega2V5KVxuICAgICAgICAtPiAnciBsaXN0XG4gICAgICAgIC0+IFsgYE9rIG9mICgnYSwgJ3IpIHQgfCBgRHVwbGljYXRlX2tleXMgb2YgJ2Ega2V5IGxpc3QgXSApXG4gICAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvclxuICAgIDogKCAnYSBrZXlcbiAgICAgICwgJ3JcbiAgICAgICwgZ2V0X2tleTooJ3IgLT4gJ2Ega2V5KSAtPiAnciBsaXN0IC0+ICgnYSwgJ3IpIHQgT3JfZXJyb3IudCApXG4gICAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIGNyZWF0ZV93aXRoX2tleV9leG5cbiAgICA6ICgnYSBrZXksICdyLCBnZXRfa2V5OignciAtPiAnYSBrZXkpIC0+ICdyIGxpc3QgLT4gKCdhLCAncikgdCkgY3JlYXRlX29wdGlvbnNcblxuXG4gIHZhbCBncm91cFxuICAgIDogKCAnYSBrZXlcbiAgICAgICwgJ2JcbiAgICAgICwgZ2V0X2tleTooJ3IgLT4gJ2Ega2V5KVxuICAgICAgICAtPiBnZXRfZGF0YTooJ3IgLT4gJ2IpXG4gICAgICAgIC0+IGNvbWJpbmU6KCdiIC0+ICdiIC0+ICdiKVxuICAgICAgICAtPiAnciBsaXN0XG4gICAgICAgIC0+ICgnYSwgJ2IpIHQgKVxuICAgICAgICBjcmVhdGVfb3B0aW9uc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuXG4gICgqKiB7MiBDcmVhdG9yc30gKilcblxuICAoKiogVGhlIG1vZHVsZSB5b3UgcGFzcyB0byBbY3JlYXRlXSBtdXN0IGhhdmUgYSB0eXBlIHRoYXQgaXMgaGFzaGFibGUsIHNleHBhYmxlLCBhbmRcbiAgICAgIGNvbXBhcmFibGUuXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICAgIEhhc2h0YmwuY3JlYXRlIChtb2R1bGUgSW50KTs7XG4gICAgICAgIC0gOiAoaW50LCAnX2EpIEhhc2h0YmwudCA9IDxhYnN0cj47O1xuICAgICAgdn0gKilcbiAgdmFsIGNyZWF0ZVxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+ICgnYSwgJ2IpIHRcblxuICAoKiogRXhhbXBsZTpcblxuICAgICAge3ZcbiAgICAgICAgIEhhc2h0Ymwub2ZfYWxpc3QgKG1vZHVsZSBJbnQpIFsoMywgXCJzb21ldGhpbmdcIik7ICgyLCBcIndoYXRldmVyXCIpXVxuICAgICAgICAgLSA6IFsgYER1cGxpY2F0ZV9rZXkgb2YgaW50IHwgYE9rIG9mIChpbnQsIHN0cmluZykgSGFzaHRibC50IF0gPSBgT2sgPGFic3RyPlxuICAgICAgdn0gKilcbiAgdmFsIG9mX2FsaXN0XG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gICgqKiBXaGVyZWFzIFtvZl9hbGlzdF0gd2lsbCByZXBvcnQgW0R1cGxpY2F0ZV9rZXldIG5vIG1hdHRlciBob3cgbWFueSBkdXBzIHRoZXJlIGFyZSBpblxuICAgICAgeW91ciBsaXN0LCBbb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzXSB3aWxsIHJlcG9ydCBlYWNoIGFuZCBldmVyeSBkdXBsaWNhdGUgZW50cnkuXG5cbiAgICAgIEZvciBleGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgICBIYXNodGJsLm9mX2FsaXN0IChtb2R1bGUgSW50KSBbKDEsIFwiZm9vXCIpOyAoMSwgXCJiYXJcIik7ICgyLCBcImZvb1wiKTsgKDIsIFwiYmFyXCIpXTs7XG4gICAgICAgIC0gOiBbIGBEdXBsaWNhdGVfa2V5IG9mIGludCB8IGBPayBvZiAoaW50LCBzdHJpbmcpIEhhc2h0YmwudCBdID0gYER1cGxpY2F0ZV9rZXkgMVxuXG4gICAgICAgIEhhc2h0Ymwub2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzIChtb2R1bGUgSW50KSBbKDEsIFwiZm9vXCIpOyAoMSwgXCJiYXJcIik7ICgyLCBcImZvb1wiKTsgKDIsIFwiYmFyXCIpXTs7XG4gICAgICAgIC0gOiBbIGBEdXBsaWNhdGVfa2V5cyBvZiBpbnQgbGlzdCB8IGBPayBvZiAoaW50LCBzdHJpbmcpIEhhc2h0YmwudCBdID0gYER1cGxpY2F0ZV9rZXlzIFsxOyAyXVxuICAgICAgdn0gKilcbiAgdmFsIG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwc1xuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBEdXBsaWNhdGVfa2V5cyBvZiAnYSBsaXN0IF1cblxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3JcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IpIHQgT3JfZXJyb3IudFxuXG4gIHZhbCBvZl9hbGlzdF9leG5cbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IpIHRcblxuICAoKiogQ3JlYXRlcyBhIHt7IU11bHRpfSBcIm11bHRpXCJ9IGhhc2h0YWJsZSwgaS5lLiwgYSBoYXNodGFibGUgd2hlcmUgZWFjaCBrZXkgcG9pbnRzIHRvIGFcbiAgICAgIGxpc3QgcG90ZW50aWFsbHkgY29udGFpbmluZyBtdWx0aXBsZSB2YWx1ZXMuIFNvIGluc3RlYWQgb2Ygc2hvcnQtY2lyY3VpdGluZyB3aXRoIGFcbiAgICAgIFtgRHVwbGljYXRlX2tleV0gdmFyaWFudCBvbiBkdXBsaWNhdGVzLCBhcyBpbiBbb2ZfYWxpc3RdLCBbb2ZfYWxpc3RfbXVsdGldIGZvbGRzXG4gICAgICB0aG9zZSB2YWx1ZXMgaW50byBhIGxpc3QgZm9yIHRoZSBnaXZlbiBrZXk6XG5cbiAgICAgIHt2XG4gICAgICBsZXQgaCA9IEhhc2h0Ymwub2ZfYWxpc3RfbXVsdGkgKG1vZHVsZSBJbnQpIFsoMSwgXCJhXCIpOyAoMSwgXCJiXCIpOyAoMiwgXCJjXCIpOyAoMiwgXCJkXCIpXTs7XG4gICAgICB2YWwgaCA6IChpbnQsIHN0cmluZyBsaXN0KSBIYXNodGJsLnQgPSA8YWJzdHI+XG5cbiAgICAgIEhhc2h0YmwuZmluZF9leG4gaCAxOztcbiAgICAgIC0gOiBzdHJpbmcgbGlzdCA9IFtcImJcIjsgXCJhXCJdXG4gICAgICB2fSAqKVxuICB2YWwgb2ZfYWxpc3RfbXVsdGlcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IgbGlzdCkgdFxuXG4gICgqKiBBcHBsaWVzIHRoZSBbZ2V0X2tleV0gYW5kIFtnZXRfZGF0YV0gZnVuY3Rpb25zIHRvIHRoZSBbJ3IgbGlzdF0gdG8gY3JlYXRlIHRoZVxuICAgICAgaW5pdGlhbCBrZXlzIGFuZCB2YWx1ZXMsIHJlc3BlY3RpdmVseSwgZm9yIHRoZSBuZXcgaGFzaHRhYmxlLlxuXG4gICAgICB7WyBjcmVhdGVfbWFwcGVkIGdldF9rZXkgZ2V0X2RhdGEgW3gxOy4uLjt4bl1cbiAgICAgICAgID0gb2ZfYWxpc3QgW2dldF9rZXkgeDEsIGdldF9kYXRhIHgxOyAuLi47IGdldF9rZXkgeG4sIGdldF9kYXRhIHhuXVxuICAgICAgXX1cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge3ZcbiAgICAgICAgbGV0IGggPVxuICAgICAgICAgIEhhc2h0YmwuY3JlYXRlX21hcHBlZCAobW9kdWxlIEludClcbiAgICAgICAgICAgIH5nZXRfa2V5OihmdW4geCAtPiB4KVxuICAgICAgICAgICAgfmdldF9kYXRhOihmdW4geCAtPiB4ICsgMSlcbiAgICAgICAgICAgWzE7IDI7IDNdOztcbiAgICAgICAgdmFsIGggOiBbIGBEdXBsaWNhdGVfa2V5cyBvZiBpbnQgbGlzdCB8IGBPayBvZiAoaW50LCBpbnQpIEhhc2h0YmwudCBdID0gYE9rIDxhYnN0cj5cblxuICAgICAgICBsZXQgaCA9XG4gICAgICAgICAgbWF0Y2ggaCB3aXRoXG4gICAgICAgICAgfCBgT2sgeCAtPiB4XG4gICAgICAgICAgfCBgRHVwbGljYXRlX2tleXMgXyAtPiBmYWlsd2l0aCBcIlwiXG4gICAgICAgIGluXG4gICAgICAgIEhhc2h0YmwuZmluZF9leG4gaCAxOztcbiAgICAgICAgLSA6IGludCA9IDJcbiAgICAgIHZ9ICopXG4gIHZhbCBjcmVhdGVfbWFwcGVkXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gZ2V0X2tleTooJ3IgLT4gJ2EpXG4gICAgLT4gZ2V0X2RhdGE6KCdyIC0+ICdiKVxuICAgIC0+ICdyIGxpc3RcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYER1cGxpY2F0ZV9rZXlzIG9mICdhIGxpc3QgXVxuXG4gICgqKiB7WyBjcmVhdGVfd2l0aF9rZXkgfmdldF9rZXkgW3gxOy4uLjt4bl1cbiAgICAgICAgID0gb2ZfYWxpc3QgW2dldF9rZXkgeDEsIHgxOyAuLi47IGdldF9rZXkgeG4sIHhuXSBdfSAqKVxuICB2YWwgY3JlYXRlX3dpdGhfa2V5XG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gZ2V0X2tleTooJ3IgLT4gJ2EpXG4gICAgLT4gJ3IgbGlzdFxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ3IpIHQgfCBgRHVwbGljYXRlX2tleXMgb2YgJ2EgbGlzdCBdXG5cbiAgdmFsIGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvclxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+IGdldF9rZXk6KCdyIC0+ICdhKVxuICAgIC0+ICdyIGxpc3RcbiAgICAtPiAoJ2EsICdyKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgY3JlYXRlX3dpdGhfa2V5X2V4blxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+IGdldF9rZXk6KCdyIC0+ICdhKVxuICAgIC0+ICdyIGxpc3RcbiAgICAtPiAoJ2EsICdyKSB0XG5cbiAgKCoqIExpa2UgW2NyZWF0ZV9tYXBwZWRdLCBhcHBsaWVzIHRoZSBbZ2V0X2tleV0gYW5kIFtnZXRfZGF0YV0gZnVuY3Rpb25zIHRvIHRoZSBbJ3JcbiAgICAgIGxpc3RdIHRvIGNyZWF0ZSB0aGUgaW5pdGlhbCBrZXlzIGFuZCB2YWx1ZXMsIHJlc3BlY3RpdmVseSwgZm9yIHRoZSBuZXcgaGFzaHRhYmxlIC0tXG4gICAgICBhbmQgdGhlbiwgbGlrZSBbYWRkX211bHRpXSwgZm9sZHMgdG9nZXRoZXIgdmFsdWVzIGJlbG9uZ2luZyB0byB0aGUgc2FtZSBrZXlzLiBIZXJlLFxuICAgICAgdGhvdWdoLCB0aGUgZnVuY3Rpb24gdXNlZCBmb3IgdGhlIGZvbGRpbmcgaXMgZ2l2ZW4gYnkgW2NvbWJpbmVdIChpbnN0ZWFkIG9mIGp1c3RcbiAgICAgIGJlaW5nIGEgW2NvbnNdKS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge3ZcbiAgICAgICAgIEhhc2h0YmwuZ3JvdXAgKG1vZHVsZSBJbnQpXG4gICAgICAgICAgIH5nZXRfa2V5OihmdW4geCAtPiB4IC8gMilcbiAgICAgICAgICAgfmdldF9kYXRhOihmdW4geCAtPiB4KVxuICAgICAgICAgICB+Y29tYmluZTooZnVuIHggeSAtPiB4ICogeSlcbiAgICAgICAgICAgIFsgMTsgMjsgMzsgNF1cbiAgICAgICAgIHw+IEhhc2h0YmwudG9fYWxpc3Q7O1xuICAgICAgICAgLSA6IChpbnQgKiBpbnQpIGxpc3QgPSBbKDIsIDQpOyAoMSwgNik7ICgwLCAxKV1cbiAgICAgICB2fSAqKVxuICB2YWwgZ3JvdXBcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiBnZXRfa2V5OignciAtPiAnYSlcbiAgICAtPiBnZXRfZGF0YTooJ3IgLT4gJ2IpXG4gICAgLT4gY29tYmluZTooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gJ3IgbGlzdFxuICAgIC0+ICgnYSwgJ2IpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX3dpdGhvdXRfc3VibW9kdWxlcyA9IHNpZ1xuICB2YWwgaGFzaCA6ICdhIC0+IGludFxuICB2YWwgaGFzaF9wYXJhbSA6IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50XG5cbiAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgKCoqIFdlIHByb3ZpZGUgYSBbc2V4cF9vZl90XSBidXQgbm90IGEgW3Rfb2Zfc2V4cF0gZm9yIHRoaXMgdHlwZSBiZWNhdXNlIG9uZSBuZWVkcyB0byBiZVxuICAgICAgZXhwbGljaXQgYWJvdXQgdGhlIGhhc2ggYW5kIGNvbXBhcmlzb24gZnVuY3Rpb25zIHVzZWQgd2hlbiBjcmVhdGluZyBhIGhhc2h0YWJsZS5cbiAgICAgIE5vdGUgdGhhdCBbSGFzaHRibC5Qb2x5LnRdIGRvZXMgaGF2ZSBbW0BAZGVyaXZpbmcgc2V4cF1dLCBhbmQgdXNlcyBPQ2FtbCdzIGJ1aWx0LWluXG4gICAgICBwb2x5bW9ycGhpYyBjb21wYXJpc29uIGFuZCBhbmQgcG9seW1vcnBoaWMgaGFzaGluZy4gKilcbiAgdmFsIHNleHBfb2ZfdCA6ICgnYSAtPiBTZXhwLnQpIC0+ICgnYiAtPiBTZXhwLnQpIC0+ICgnYSwgJ2IpIHQgLT4gU2V4cC50XG5cbiAgaW5jbHVkZSBDcmVhdG9ycyB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0ICgqKiBAaW5saW5lICopXG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnMgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdCB3aXRoIHR5cGUgJ2Ega2V5ID0gJ2FcbiAgKCoqIEBpbmxpbmUgKilcblxuXG4gIGluY2x1ZGUgTXVsdGkgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdCB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIGtleVxuICAoKiogQGlubGluZSAqKVxuXG4gIHZhbCBoYXNoYWJsZV9zIDogKCdrZXksIF8pIHQgLT4gJ2tleSBLZXkudFxuXG4gIGluY2x1ZGUgSW52YXJpYW50LlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX3BvbHkgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgdmFsIHRfc2V4cF9ncmFtbWFyXG4gICAgOiAgJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAtPiAnYiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgIC0+ICgnYSwgJ2IpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICBbQEBAZW5kXVxuXG4gIHZhbCBoYXNoYWJsZSA6ICdhIEhhc2hhYmxlLnRcblxuICBpbmNsdWRlIEludmFyaWFudC5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzX2dlbmVyaWNcbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgd2l0aCB0eXBlICdhIGtleSA9ICdhXG4gICAgd2l0aCB0eXBlICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zIDo9XG4gICAgICAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZVxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHQgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBrZXlcbiAgaW5jbHVkZSBNdWx0aSB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0IHdpdGggdHlwZSAnYSBrZXkgOj0gJ2Ega2V5XG5lbmRcblxubW9kdWxlIHR5cGUgRm9yX2Rlcml2aW5nID0gc2lnXG4gIHR5cGUgKCdrLCAndikgdFxuXG4gIG1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gICAgdmFsIHRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgaW5jbHVkZSBLZXkuUyB3aXRoIHR5cGUgdCA6PSB0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIE1fc2V4cF9ncmFtbWFyID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX2dyYW1tYXJdXG5cbiAgICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxuXG4gIHZhbCBzZXhwX29mX21fX3RcbiAgICA6ICAobW9kdWxlIFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9ICdrKVxuICAgIC0+ICgndiAtPiBTZXhwLnQpXG4gICAgLT4gKCdrLCAndikgdFxuICAgIC0+IFNleHAudFxuXG4gIHZhbCBtX190X29mX3NleHBcbiAgICA6ICAobW9kdWxlIE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9ICdrKVxuICAgIC0+IChTZXhwLnQgLT4gJ3YpXG4gICAgLT4gU2V4cC50XG4gICAgLT4gKCdrLCAndikgdFxuXG4gIHZhbCBtX190X3NleHBfZ3JhbW1hclxuICAgIDogIChtb2R1bGUgTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSAnaylcbiAgICAtPiAndiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgIC0+ICgnaywgJ3YpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICB2YWwgZXF1YWxfbV9fdFxuICAgIDogIChtb2R1bGUgRXF1YWxfbSlcbiAgICAtPiAoJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiAoJ2ssICd2KSB0XG4gICAgLT4gKCdrLCAndikgdFxuICAgIC0+IGJvb2xcbmVuZFxuXG5tb2R1bGUgdHlwZSBIYXNodGJsID0gc2lnXG4gICgqKiBBIGhhc2ggdGFibGUgaXMgYSBtdXRhYmxlIGRhdGEgc3RydWN0dXJlIGltcGxlbWVudGluZyBhIG1hcCBiZXR3ZWVuIGtleXMgYW5kIHZhbHVlcy5cbiAgICAgIEl0IHN1cHBvcnRzIGNvbnN0YW50LXRpbWUgbG9va3VwIGFuZCBpbi1wbGFjZSBtb2RpZmljYXRpb24uXG5cbiAgICAgIHsxIFVzYWdlfVxuXG4gICAgICBBcyBhIHNpbXBsZSBleGFtcGxlLCB3ZSdsbCBjcmVhdGUgYSBoYXNoIHRhYmxlIHdpdGggc3RyaW5nIGtleXMgdXNpbmcgdGhlXG4gICAgICB7eyFjcmVhdGV9W2NyZWF0ZV19IGNvbnN0cnVjdG9yLCB3aGljaCBleHBlY3RzIGEgbW9kdWxlIGRlZmluaW5nIHRoZSBrZXkncyB0eXBlOlxuXG4gICAgICB7W1xuICAgICAgICBsZXQgaCA9IEhhc2h0YmwuY3JlYXRlIChtb2R1bGUgU3RyaW5nKTs7XG4gICAgICAgIHZhbCBoIDogKHN0cmluZywgJ19hKSBIYXNodGJsLnQgPSA8YWJzdHI+XG4gICAgICBdfVxuXG4gICAgICBXZSBjYW4gc2V0IHRoZSB2YWx1ZXMgb2YgaW5kaXZpZHVhbCBrZXlzIHdpdGgge3shc2V0fVtzZXRdfS4gSWYgdGhlIGtleSBhbHJlYWR5IGhhc1xuICAgICAgYSB2YWx1ZSwgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbi5cblxuICAgICAge3ZcbiAgICAgIEhhc2h0Ymwuc2V0IGggfmtleTpcImZvb1wiIH5kYXRhOjU7O1xuICAgICAgLSA6IHVuaXQgPSAoKVxuXG4gICAgICBIYXNodGJsLnNldCBoIH5rZXk6XCJmb29cIiB+ZGF0YTo2OztcbiAgICAgIC0gOiB1bml0ID0gKClcblxuICAgICAgSGFzaHRibC5zZXQgaCB+a2V5OlwiYmFyXCIgfmRhdGE6Njs7XG4gICAgICAtIDogdW5pdCA9ICgpXG4gICAgICB2fVxuXG4gICAgICBXZSBjYW4gYWNjZXNzIHZhbHVlcyBieSBrZXksIG9yIGR1bXAgYWxsIG9mIHRoZSBoYXNoIHRhYmxlJ3MgZGF0YTpcblxuICAgICAge3ZcbiAgICAgIEhhc2h0YmwuZmluZCBoIFwiZm9vXCI7O1xuICAgICAgLSA6IGludCBvcHRpb24gPSBTb21lIDZcblxuICAgICAgSGFzaHRibC5maW5kX2V4biBoIFwiZm9vXCI7O1xuICAgICAgLSA6IGludCA9IDZcblxuICAgICAgSGFzaHRibC50b19hbGlzdCBoOztcbiAgICAgIC0gOiAoc3RyaW5nICogaW50KSBsaXN0ID0gWyhcImZvb1wiLCA2KTsgKFwiYmFyXCIsIDYpXVxuICAgICAgdn1cblxuICAgICAge3shY2hhbmdlfVtjaGFuZ2VdfSBsZXRzIHVzIGNoYW5nZSBhIGtleSdzIHZhbHVlIGJ5IGFwcGx5aW5nIHRoZSBnaXZlbiBmdW5jdGlvbjpcblxuICAgICAge3ZcbiAgICAgIEhhc2h0YmwuY2hhbmdlIGggXCJmb29cIiAoZnVuIHggLT5cbiAgICAgICBtYXRjaCB4IHdpdGhcbiAgICAgICB8IFNvbWUgeCAtPiBTb21lICh4ICogMilcbiAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgKTs7XG4gICAgICAtIDogdW5pdCA9ICgpXG5cbiAgICAgIEhhc2h0YmwudG9fYWxpc3QgaDs7XG4gICAgICAtIDogKHN0cmluZyAqIGludCkgbGlzdCA9IFsoXCJmb29cIiwgMTIpOyAoXCJiYXJcIiwgNildXG4gICAgICB2fVxuXG5cbiAgICAgIFdlIGNhbiB1c2Uge3shbWVyZ2V9W21lcmdlXX0gdG8gbWVyZ2UgdHdvIGhhc2h0YWJsZXMgd2l0aCBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyXG4gICAgICBob3cgd2UgY2hvb3NlIHZhbHVlcyB3aGVuIGEga2V5IGlzIHByZXNlbnQgaW4gdGhlIGZpcnN0IChcImxlZnRcIikgaGFzaHRhYmxlLCB0aGVcbiAgICAgIHNlY29uZCAoXCJyaWdodFwiKSwgb3IgYm90aC4gSGVyZSwgd2UnbGwgY29ucyB0aGUgdmFsdWVzIHdoZW4gYm90aCBoYXNodGFibGVzIGhhdmUgYVxuICAgICAga2V5OlxuXG4gICAgICB7dlxuICAgICAgbGV0IGgxID0gSGFzaHRibC5vZl9hbGlzdF9leG4gKG1vZHVsZSBJbnQpIFsoMSwgNSk7ICgyLCAzMjMyKV0gaW5cbiAgICAgIGxldCBoMiA9IEhhc2h0Ymwub2ZfYWxpc3RfZXhuIChtb2R1bGUgSW50KSBbKDEsIDMpXSBpblxuICAgICAgSGFzaHRibC5tZXJnZSBoMSBoMiB+ZjooZnVuIH5rZXk6XyAtPiBmdW5jdGlvblxuICAgICAgICB8IGBMZWZ0IHggLT4gU29tZSAoYExlZnQgeClcbiAgICAgICAgfCBgUmlnaHQgeCAtPiBTb21lIChgUmlnaHQgeClcbiAgICAgICAgfCBgQm90aCAoeCwgeSkgLT4gaWYgeD15IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGBCb3RoICh4LHkpKVxuICAgICAgKSB8PiBIYXNodGJsLnRvX2FsaXN0OztcbiAgICAgIC0gOiAoaW50ICogWz4gYEJvdGggb2YgaW50ICogaW50IHwgYExlZnQgb2YgaW50IHwgYFJpZ2h0IG9mIGludCBdKSBsaXN0ID1cbiAgICAgIFsoMiwgYExlZnQgMzIzMik7ICgxLCBgQm90aCAoNSwgMykpXVxuICAgICAgdn1cblxuICAgICAgezEgSW50ZXJmYWNlfSAqKVxuXG4gIGluY2x1ZGUgU193aXRob3V0X3N1Ym1vZHVsZXMgKCoqIEBpbmxpbmUgKilcblxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnMgPSBBY2Nlc3NvcnNcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMgPSBDcmVhdG9yc1xuICBtb2R1bGUgdHlwZSBNdWx0aSA9IE11bHRpXG4gIG1vZHVsZSB0eXBlIFNfcG9seSA9IFNfcG9seVxuICBtb2R1bGUgdHlwZSBTX3dpdGhvdXRfc3VibW9kdWxlcyA9IFNfd2l0aG91dF9zdWJtb2R1bGVzXG4gIG1vZHVsZSB0eXBlIEZvcl9kZXJpdmluZyA9IEZvcl9kZXJpdmluZ1xuXG4gIG1vZHVsZSBLZXkgPSBLZXlcbiAgbW9kdWxlIE1lcmdlX2ludG9fYWN0aW9uID0gTWVyZ2VfaW50b19hY3Rpb25cblxuICB0eXBlIG5vbnJlYyAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9ucyA9ICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zXG5cbiAgbW9kdWxlIENyZWF0b3JzIChLZXkgOiBzaWdcbiAgICAgIHR5cGUgJ2EgdFxuXG4gICAgICB2YWwgaGFzaGFibGUgOiAnYSB0IEhhc2hhYmxlLnRcbiAgICBlbmQpIDogc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XyA9ICgnYSBLZXkudCwgJ2IpIHRcblxuICAgIHZhbCB0X29mX3NleHAgOiAoU2V4cC50IC0+ICdhIEtleS50KSAtPiAoU2V4cC50IC0+ICdiKSAtPiBTZXhwLnQgLT4gKCdhLCAnYikgdF9cblxuICAgIGluY2x1ZGVcbiAgICAgIENyZWF0b3JzX2dlbmVyaWNcbiAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRfXG4gICAgICB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIEtleS50XG4gICAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCAnYSkgY3JlYXRlX29wdGlvbnMgOj1cbiAgICAgICAgKCdrZXksICdkYXRhLCAnYSkgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcbiAgZW5kXG5cbiAgbW9kdWxlIFBvbHkgOiBTX3BvbHkgd2l0aCB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG5cbiAgKCoqIFtNXSBpcyBtZWFudCB0byBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggT0NhbWwgYXBwbGljYXRpdmUgZnVuY3RvciB0eXBlczpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBzdHJpbmdfdG9faW50X3RhYmxlID0gaW50IEhhc2h0YmwuTShTdHJpbmcpLnRcbiAgICAgIF19XG5cbiAgICAgIHdoaWNoIHN0YW5kcyBmb3I6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgc3RyaW5nX3RvX2ludF90YWJsZSA9IChTdHJpbmcudCwgaW50KSBIYXNodGJsLnRcbiAgICAgIF19XG5cbiAgICAgIFRoZSBwb2ludCBpcyB0aGF0IFtpbnQgSGFzaHRibC5NKFN0cmluZykudF0gc3VwcG9ydHMgZGVyaXZpbmcsIHdoZXJlYXMgdGhlIHNlY29uZFxuICAgICAgc3ludGF4IGRvZXNuJ3QgKGJlY2F1c2UgW3Rfb2Zfc2V4cF0gZG9lc24ndCBrbm93IHdoYXQgY29tcGFyaXNvbi9oYXNoIGZ1bmN0aW9uIHRvXG4gICAgICB1c2UpLiAqKVxuICBtb2R1bGUgTSAoSyA6IFQuVCkgOiBzaWdcbiAgICB0eXBlIG5vbnJlYyAndiB0ID0gKEsudCwgJ3YpIHRcbiAgZW5kXG5cbiAgaW5jbHVkZSBGb3JfZGVyaXZpbmcgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gICgqKi8qKilcblxuICAoKl8gU2VlIHRoZSBKYW5lIFN0cmVldCBTdHlsZSBHdWlkZSBmb3IgYW4gZXhwbGFuYXRpb24gb2YgW1ByaXZhdGVdIHN1Ym1vZHVsZXM6XG5cbiAgICBodHRwczovL29wZW5zb3VyY2UuamFuZXN0cmVldC5jb20vc3RhbmRhcmRzLyNwcml2YXRlLXN1Ym1vZHVsZXMgKilcbiAgbW9kdWxlIFByaXZhdGUgOiBzaWdcbiAgICBtb2R1bGUgdHlwZSBDcmVhdG9yc19nZW5lcmljID0gQ3JlYXRvcnNfZ2VuZXJpY1xuXG4gICAgdHlwZSBub25yZWMgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGUgPVxuICAgICAgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcblxuICAgIHZhbCBoYXNoYWJsZSA6ICgna2V5LCBfKSB0IC0+ICdrZXkgSGFzaGFibGUudFxuICBlbmRcbmVuZFxuIiwiKCogQSBmZXcgc21hbGwgdGhpbmdzIGNvcGllZCBmcm9tIG90aGVyIHBhcnRzIG9mIEJhc2UgYmVjYXVzZSB0aGV5IGRlcGVuZCBvbiB1cywgc28gd2VcbiAgIGNhbid0IHVzZSB0aGVtLiAqKVxuXG5vcGVuISBJbXBvcnRcblxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbm1vZHVsZSBJbnQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50XG5cbiAgbGV0IG1heCAoeCA6IHQpIHkgPSBpZiB4ID4geSB0aGVuIHggZWxzZSB5XG5lbmRcblxuKCogSXRzIGltcG9ydGFudCB0aGF0IEVtcHR5IGhhdmUgbm8gYXJncy4gSXQncyB0ZW1wdGluZyB0byBtYWtlIHRoaXMgdHlwZSBhIHJlY29yZFxuICAgKGUuZy4gdG8gaG9sZCB0aGUgY29tcGFyZSBmdW5jdGlvbiksIGJ1dCBhIGxvdCBvZiBtZW1vcnkgaXMgc2F2ZWQgYnkgRW1wdHkgYmVpbmcgYW5cbiAgIGltbWVkaWF0ZSwgc2luY2UgYWxsIHVudXNlZCBidWNrZXRzIGluIHRoZSBoYXNodGJsIGRvbid0IHVzZSBhbnkgbWVtb3J5IChiZXNpZGVzIHRoZVxuICAgYXJyYXkgY2VsbCkgKilcbnR5cGUgKCdrLCAndikgdCA9XG4gIHwgRW1wdHlcbiAgfCBOb2RlIG9mXG4gICAgICB7IG11dGFibGUgbGVmdCA6ICgnaywgJ3YpIHRcbiAgICAgIDsga2V5IDogJ2tcbiAgICAgIDsgbXV0YWJsZSB2YWx1ZSA6ICd2XG4gICAgICA7IG11dGFibGUgaGVpZ2h0IDogaW50XG4gICAgICA7IG11dGFibGUgcmlnaHQgOiAoJ2ssICd2KSB0XG4gICAgICB9XG4gIHwgTGVhZiBvZlxuICAgICAgeyBrZXkgOiAna1xuICAgICAgOyBtdXRhYmxlIHZhbHVlIDogJ3ZcbiAgICAgIH1cblxubGV0IGVtcHR5ID0gRW1wdHlcblxubGV0IGlzX2VtcHR5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiB0cnVlXG4gIHwgTGVhZiBfIHwgTm9kZSBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiAwXG4gIHwgTGVhZiBfIC0+IDFcbiAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0OyByaWdodCA9IF8gfSAtPiBoZWlnaHRcbjs7XG5cbmxldCBpbnZhcmlhbnQgY29tcGFyZSA9XG4gIGxldCBsZWdhbF9sZWZ0X2tleSBrZXkgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IExlYWYgeyBrZXkgPSBsZWZ0X2tleTsgdmFsdWUgPSBfIH1cbiAgICB8IE5vZGUgeyBsZWZ0ID0gXzsga2V5ID0gbGVmdF9rZXk7IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT5cbiAgICAgIGFzc2VydCAoY29tcGFyZSBsZWZ0X2tleSBrZXkgPCAwKVxuICBpblxuICBsZXQgbGVnYWxfcmlnaHRfa2V5IGtleSA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgTGVhZiB7IGtleSA9IHJpZ2h0X2tleTsgdmFsdWUgPSBfIH1cbiAgICB8IE5vZGUgeyBsZWZ0ID0gXzsga2V5ID0gcmlnaHRfa2V5OyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+XG4gICAgICBhc3NlcnQgKGNvbXBhcmUgcmlnaHRfa2V5IGtleSA+IDApXG4gIGluXG4gIGxldCByZWMgaW52ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IHwgTGVhZiBfIC0+ICgpXG4gICAgfCBOb2RlIHsgbGVmdDsga2V5ID0gazsgdmFsdWUgPSBfOyBoZWlnaHQgPSBoOyByaWdodCB9IC0+XG4gICAgICBsZXQgaGwsIGhyID0gaGVpZ2h0IGxlZnQsIGhlaWdodCByaWdodCBpblxuICAgICAgaW52IGxlZnQ7XG4gICAgICBpbnYgcmlnaHQ7XG4gICAgICBsZWdhbF9sZWZ0X2tleSBrIGxlZnQ7XG4gICAgICBsZWdhbF9yaWdodF9rZXkgayByaWdodDtcbiAgICAgIGFzc2VydCAoaCA9IEludC5tYXggaGwgaHIgKyAxKTtcbiAgICAgIGFzc2VydCAoYWJzIChobCAtIGhyKSA8PSAyKVxuICBpblxuICBpbnZcbjs7XG5cbmxldCBpbnZhcmlhbnQgdCB+Y29tcGFyZSA9IGludmFyaWFudCBjb21wYXJlIHRcblxuKCogSW4gdGhlIGZvbGxvd2luZyBjb21tZW50cyxcbiAgICd0IGlzIGJhbGFuY2VkJyBtZWFucyB0aGF0ICdpbnZhcmlhbnQgdCcgZG9lcyBub3RcbiAgIHJhaXNlIGFuIGV4Y2VwdGlvbi4gIFRoaXMgaW1wbGllcyBvZiBjb3Vyc2UgdGhhdCBlYWNoIG5vZGUncyBoZWlnaHQgZmllbGQgaXNcbiAgIGNvcnJlY3QuXG4gICAndCBpcyBiYWxhbmNlYWJsZScgbWVhbnMgdGhhdCBoZWlnaHQgb2YgdGhlIGxlZnQgYW5kIHJpZ2h0IHN1YnRyZWVzIG9mIHRcbiAgIGRpZmZlciBieSBhdCBtb3N0IDMuICopXG5cbigqIEBwcmU6IGxlZnQgYW5kIHJpZ2h0IHN1YnRyZWVzIGhhdmUgY29ycmVjdCBoZWlnaHRzXG4gICBAcG9zdDogb3V0cHV0IGhhcyB0aGUgY29ycmVjdCBoZWlnaHQgKilcbmxldCB1cGRhdGVfaGVpZ2h0ID0gZnVuY3Rpb25cbiAgfCBOb2RlICh7IGxlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gb2xkX2hlaWdodDsgcmlnaHQgfSBhcyB4KSAtPlxuICAgIGxldCBuZXdfaGVpZ2h0ID0gSW50Lm1heCAoaGVpZ2h0IGxlZnQpIChoZWlnaHQgcmlnaHQpICsgMSBpblxuICAgIGlmIG5ld19oZWlnaHQgPD4gb2xkX2hlaWdodCB0aGVuIHguaGVpZ2h0IDwtIG5ld19oZWlnaHRcbiAgfCBFbXB0eSB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2Vcbjs7XG5cbigqIEBwcmU6IGxlZnQgYW5kIHJpZ2h0IHN1YnRyZWVzIGFyZSBiYWxhbmNlZFxuICAgQHByZTogdHJlZSBpcyBiYWxhbmNlYWJsZVxuICAgQHBvc3Q6IG91dHB1dCBpcyBiYWxhbmNlZCAoaW4gcGFydGljdWxhciwgaGVpZ2h0IGlzIGNvcnJlY3QpICopXG5sZXQgYmFsYW5jZSB0cmVlID1cbiAgbWF0Y2ggdHJlZSB3aXRoXG4gIHwgRW1wdHkgfCBMZWFmIF8gLT4gdHJlZVxuICB8IE5vZGUgKHsgbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCB9IGFzIHJvb3Rfbm9kZSkgLT5cbiAgICBsZXQgaGwgPSBoZWlnaHQgbGVmdFxuICAgIGFuZCBociA9IGhlaWdodCByaWdodCBpblxuICAgICgqICsgMiBpcyBjcml0aWNhbGx5IGltcG9ydGFudCwgbG93ZXJpbmcgaXQgdG8gMSB3aWxsIGJyZWFrIHRoZSBMZWFmXG4gICAgICAgYXNzdW1wdGlvbnMgaW4gdGhlIGNvZGUgYmVsb3csIGFuZCB3aWxsIGZvcmNlIHVzIHRvIHByb21vdGUgbGVhZiBub2RlcyBpblxuICAgICAgIHRoZSBiYWxhbmNlIHJvdXRpbmUuIEl0J3MgYWxzbyBmYXN0ZXIsIHNpbmNlIGl0IHdpbGwgYmFsYW5jZSBsZXNzIG9mdGVuLlxuICAgICAgIE5vdGUgdGhhdCB0aGUgZm9sbG93aW5nIGNvZGUgaXMgZGVsaWNhdGUuICBUaGUgdXBkYXRlX2hlaWdodCBjYWxscyBtdXN0XG4gICAgICAgb2NjdXIgaW4gdGhlIGNvcnJlY3Qgb3JkZXIsIHNpbmNlIHVwZGF0ZV9oZWlnaHQgYXNzdW1lcyBpdHMgY2hpbGRyZW4gaGF2ZVxuICAgICAgIHRoZSBjb3JyZWN0IGhlaWdodHMuICAqKVxuICAgIGlmIGhsID4gaHIgKyAyXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCBsZWZ0IHdpdGhcbiAgICAgICgqIEl0IGNhbm5vdCBiZSBhIGxlYWYsIGJlY2F1c2UgZXZlbiBpZiByaWdodCBpcyBlbXB0eSwgYSBsZWFmXG4gICAgICAgICBpcyBvbmx5IGhlaWdodCAxICopXG4gICAgICB8IEVtcHR5IHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBOb2RlXG4gICAgICAgICAgKHsgbGVmdCA9IGxlZnRfbm9kZV9sZWZ0XG4gICAgICAgICAgIDsga2V5ID0gX1xuICAgICAgICAgICA7IHZhbHVlID0gX1xuICAgICAgICAgICA7IGhlaWdodCA9IF9cbiAgICAgICAgICAgOyByaWdodCA9IGxlZnRfbm9kZV9yaWdodFxuICAgICAgICAgICB9IGFzIGxlZnRfbm9kZSkgLT5cbiAgICAgICAgaWYgaGVpZ2h0IGxlZnRfbm9kZV9sZWZ0ID49IGhlaWdodCBsZWZ0X25vZGVfcmlnaHRcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgcm9vdF9ub2RlLmxlZnQgPC0gbGVmdF9ub2RlX3JpZ2h0O1xuICAgICAgICAgIGxlZnRfbm9kZS5yaWdodCA8LSB0cmVlO1xuICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgdHJlZTtcbiAgICAgICAgICB1cGRhdGVfaGVpZ2h0IGxlZnQ7XG4gICAgICAgICAgbGVmdClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogaWYgcmlnaHQgaXMgYSBsZWFmLCB0aGVuIGxlZnQgbXVzdCBiZSBlbXB0eS4gVGhhdCBtZWFuc1xuICAgICAgICAgICAgIGhlaWdodCBpcyAyLiBFdmVuIGlmIGhyIGlzIGVtcHR5IHdlIHN0aWxsIGNhbid0IGdldCBoZXJlLiAqKVxuICAgICAgICAgIG1hdGNoIGxlZnRfbm9kZV9yaWdodCB3aXRoXG4gICAgICAgICAgfCBFbXB0eSB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IE5vZGVcbiAgICAgICAgICAgICAgKHsgbGVmdCA9IGxyX2xlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBscl9yaWdodCB9IGFzXG4gICAgICAgICAgICAgICBscl9ub2RlKSAtPlxuICAgICAgICAgICAgbGVmdF9ub2RlLnJpZ2h0IDwtIGxyX2xlZnQ7XG4gICAgICAgICAgICByb290X25vZGUubGVmdCA8LSBscl9yaWdodDtcbiAgICAgICAgICAgIGxyX25vZGUucmlnaHQgPC0gdHJlZTtcbiAgICAgICAgICAgIGxyX25vZGUubGVmdCA8LSBsZWZ0O1xuICAgICAgICAgICAgdXBkYXRlX2hlaWdodCBsZWZ0O1xuICAgICAgICAgICAgdXBkYXRlX2hlaWdodCB0cmVlO1xuICAgICAgICAgICAgdXBkYXRlX2hlaWdodCBsZWZ0X25vZGVfcmlnaHQ7XG4gICAgICAgICAgICBsZWZ0X25vZGVfcmlnaHQpKVxuICAgIGVsc2UgaWYgaHIgPiBobCArIDJcbiAgICB0aGVuIChcbiAgICAgICgqIHNlZSBhYm92ZSBmb3IgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHJpZ2h0IGNhbm5vdCBiZSBhIGxlYWYgKilcbiAgICAgIG1hdGNoIHJpZ2h0IHdpdGhcbiAgICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IE5vZGVcbiAgICAgICAgICAoeyBsZWZ0ID0gcmlnaHRfbm9kZV9sZWZ0XG4gICAgICAgICAgIDsga2V5ID0gX1xuICAgICAgICAgICA7IHZhbHVlID0gX1xuICAgICAgICAgICA7IGhlaWdodCA9IF9cbiAgICAgICAgICAgOyByaWdodCA9IHJpZ2h0X25vZGVfcmlnaHRcbiAgICAgICAgICAgfSBhcyByaWdodF9ub2RlKSAtPlxuICAgICAgICBpZiBoZWlnaHQgcmlnaHRfbm9kZV9yaWdodCA+PSBoZWlnaHQgcmlnaHRfbm9kZV9sZWZ0XG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHJvb3Rfbm9kZS5yaWdodCA8LSByaWdodF9ub2RlX2xlZnQ7XG4gICAgICAgICAgcmlnaHRfbm9kZS5sZWZ0IDwtIHRyZWU7XG4gICAgICAgICAgdXBkYXRlX2hlaWdodCB0cmVlO1xuICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgcmlnaHQ7XG4gICAgICAgICAgcmlnaHQpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIHNlZSBhYm92ZSBmb3IgYW4gZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgY2Fubm90IGJlIGEgbGVhZiAqKVxuICAgICAgICAgIG1hdGNoIHJpZ2h0X25vZGVfbGVmdCB3aXRoXG4gICAgICAgICAgfCBFbXB0eSB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IE5vZGVcbiAgICAgICAgICAgICAgKHsgbGVmdCA9IHJsX2xlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBybF9yaWdodCB9IGFzXG4gICAgICAgICAgICAgICBybF9ub2RlKSAtPlxuICAgICAgICAgICAgcmlnaHRfbm9kZS5sZWZ0IDwtIHJsX3JpZ2h0O1xuICAgICAgICAgICAgcm9vdF9ub2RlLnJpZ2h0IDwtIHJsX2xlZnQ7XG4gICAgICAgICAgICBybF9ub2RlLmxlZnQgPC0gdHJlZTtcbiAgICAgICAgICAgIHJsX25vZGUucmlnaHQgPC0gcmlnaHQ7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHJpZ2h0O1xuICAgICAgICAgICAgdXBkYXRlX2hlaWdodCB0cmVlO1xuICAgICAgICAgICAgdXBkYXRlX2hlaWdodCByaWdodF9ub2RlX2xlZnQ7XG4gICAgICAgICAgICByaWdodF9ub2RlX2xlZnQpKVxuICAgIGVsc2UgKFxuICAgICAgdXBkYXRlX2hlaWdodCB0cmVlO1xuICAgICAgdHJlZSlcbjs7XG5cbigqIEBwcmU6IHRyZWUgaXMgYmFsYW5jZWFibGVcbiAgIEBwcmU6IGFicyAoaGVpZ2h0IChyaWdodCBub2RlKSAtIGhlaWdodCAoYmFsYW5jZSB0cmVlKSkgPD0gM1xuICAgQHBvc3Q6IHJlc3VsdCBpcyBiYWxhbmNlYWJsZSAqKVxuXG4oKiBAcHJlOiB0cmVlIGlzIGJhbGFuY2VhYmxlXG4gICBAcHJlOiBhYnMgKGhlaWdodCAocmlnaHQgbm9kZSkgLSBoZWlnaHQgKGJhbGFuY2UgdHJlZSkpIDw9IDNcbiAgIEBwb3N0OiByZXN1bHQgaXMgYmFsYW5jZWFibGUgKilcbmxldCBzZXRfbGVmdCBub2RlIHRyZWUgPVxuICBsZXQgdHJlZSA9IGJhbGFuY2UgdHJlZSBpblxuICBtYXRjaCBub2RlIHdpdGhcbiAgfCBOb2RlICh7IGxlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gYXMgcikgLT5cbiAgICBpZiBwaHlzX2VxdWFsIGxlZnQgdHJlZSB0aGVuICgpIGVsc2Ugci5sZWZ0IDwtIHRyZWU7XG4gICAgdXBkYXRlX2hlaWdodCBub2RlXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2Vcbjs7XG5cbigqIEBwcmU6IHRyZWUgaXMgYmFsYW5jZWFibGVcbiAgIEBwcmU6IGFicyAoaGVpZ2h0IChsZWZ0IG5vZGUpIC0gaGVpZ2h0IChiYWxhbmNlIHRyZWUpKSA8PSAzXG4gICBAcG9zdDogcmVzdWx0IGlzIGJhbGFuY2VhYmxlICopXG5sZXQgc2V0X3JpZ2h0IG5vZGUgdHJlZSA9XG4gIGxldCB0cmVlID0gYmFsYW5jZSB0cmVlIGluXG4gIG1hdGNoIG5vZGUgd2l0aFxuICB8IE5vZGUgKHsgbGVmdCA9IF87IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSBhcyByKSAtPlxuICAgIGlmIHBoeXNfZXF1YWwgcmlnaHQgdHJlZSB0aGVuICgpIGVsc2Ugci5yaWdodCA8LSB0cmVlO1xuICAgIHVwZGF0ZV9oZWlnaHQgbm9kZVxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG47O1xuXG4oKiBAcHJlOiB0IGlzIGJhbGFuY2VkLlxuICAgQHBvc3Q6IHJlc3VsdCBpcyBiYWxhbmNlZCwgd2l0aCBuZXcgbm9kZSBpbnNlcnRlZFxuICAgQHBvc3Q6ICFhZGRlZCA9IHRydWUgaWZmIHRoZSBzaGFwZSBvZiB0aGUgaW5wdXQgdHJlZSBjaGFuZ2VkLiAgKilcbmxldCBhZGQgPVxuICBsZXQgcmVjIGFkZCB0IHJlcGxhY2UgYWRkZWQgY29tcGFyZSBrIHYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT5cbiAgICAgIGFkZGVkIDo9IHRydWU7XG4gICAgICBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH1cbiAgICB8IExlYWYgKHsga2V5ID0gayc7IHZhbHVlID0gXyB9IGFzIHIpIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmUgaycgayBpblxuICAgICAgKCogVGhpcyBjb21wYXJlIGlzIHJldmVyc2VkIG9uIHB1cnBvc2UsIHdlIGFyZSBwcmV0ZW5kaW5nXG4gICAgICAgICB0aGF0IHRoZSBsZWFmIHdhcyBqdXN0IGluc2VydGVkIGluc3RlYWQgb2YgdGhlIG90aGVyIHdheVxuICAgICAgICAgcm91bmQsIHRoYXQgd2F5IHdlIG9ubHkgYWxsb2NhdGUgb25lIG5vZGUuICopXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIGFkZGVkIDo9IGZhbHNlO1xuICAgICAgICBpZiByZXBsYWNlIHRoZW4gci52YWx1ZSA8LSB2O1xuICAgICAgICB0KVxuICAgICAgZWxzZSAoXG4gICAgICAgIGFkZGVkIDo9IHRydWU7XG4gICAgICAgIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gTm9kZSB7IGxlZnQgPSB0OyBrZXkgPSBrOyB2YWx1ZSA9IHY7IGhlaWdodCA9IDI7IHJpZ2h0ID0gRW1wdHkgfVxuICAgICAgICBlbHNlIE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gMjsgcmlnaHQgPSB0IH0pXG4gICAgfCBOb2RlICh7IGxlZnQ7IGtleSA9IGsnOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0IH0gYXMgcikgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZSBrIGsnIGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIGFkZGVkIDo9IGZhbHNlO1xuICAgICAgICBpZiByZXBsYWNlIHRoZW4gci52YWx1ZSA8LSB2KVxuICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgdGhlbiBzZXRfbGVmdCB0IChhZGQgbGVmdCByZXBsYWNlIGFkZGVkIGNvbXBhcmUgayB2KVxuICAgICAgZWxzZSBzZXRfcmlnaHQgdCAoYWRkIHJpZ2h0IHJlcGxhY2UgYWRkZWQgY29tcGFyZSBrIHYpO1xuICAgICAgdFxuICBpblxuICBmdW4gdCB+cmVwbGFjZSB+Y29tcGFyZSB+YWRkZWQgfmtleSB+ZGF0YSAtPlxuICAgIGxldCB0ID0gYWRkIHQgcmVwbGFjZSBhZGRlZCBjb21wYXJlIGtleSBkYXRhIGluXG4gICAgaWYgIWFkZGVkIHRoZW4gYmFsYW5jZSB0IGVsc2UgdFxuOztcblxubGV0IHJlYyBmaXJzdCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gTm9uZVxuICB8IExlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfVxuICB8IE5vZGUgeyBsZWZ0ID0gRW1wdHk7IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT4gU29tZSAoaywgdilcbiAgfCBOb2RlIHsgbGVmdCA9IGw7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT4gZmlyc3QgbFxuOztcblxubGV0IHJlYyBsYXN0IHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiBOb25lXG4gIHwgTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9XG4gIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBrOyB2YWx1ZSA9IHY7IGhlaWdodCA9IF87IHJpZ2h0ID0gRW1wdHkgfSAtPiBTb21lIChrLCB2KVxuICB8IE5vZGUgeyBsZWZ0ID0gXzsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IHIgfSAtPiBsYXN0IHJcbjs7XG5cblxubGV0W0BpbmxpbmUgYWx3YXlzXSByZWMgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH5jb21wYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnMVxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICB+aWZfZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfmlmX25vdF9mb3VuZFxuICA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQgayBhcmcxIGFyZzJcbiAgfCBMZWFmIHsga2V5ID0gayc7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZSBrIGsnID0gMFxuICAgIHRoZW4gY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleTprJyB+ZGF0YTp2IGFyZzEgYXJnMlxuICAgIGVsc2UgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrIGFyZzEgYXJnMlxuICB8IE5vZGUgeyBsZWZ0OyBrZXkgPSBrJzsgdmFsdWUgPSB2OyBoZWlnaHQgPSBfOyByaWdodCB9IC0+XG4gICAgbGV0IGMgPSBjb21wYXJlIGsgaycgaW5cbiAgICBpZiBjID0gMFxuICAgIHRoZW4gY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleTprJyB+ZGF0YTp2IGFyZzEgYXJnMlxuICAgIGVsc2VcbiAgICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgICAgKGlmIGMgPCAwIHRoZW4gbGVmdCBlbHNlIHJpZ2h0KVxuICAgICAgICB+Y29tcGFyZVxuICAgICAgICBrXG4gICAgICAgIGFyZzFcbiAgICAgICAgYXJnMlxuICAgICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgICAgfmlmX2ZvdW5kXG4gICAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXk6XyB+ZGF0YSAoKSAoKSA9IGlmX2ZvdW5kIGRhdGEgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5ICgpICgpID0gaWZfbm90X2ZvdW5kIGtleSBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgICgpXG4gICAgICAoKVxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleSB+ZGF0YSAoKSAoKSA9IGlmX2ZvdW5kIH5rZXkgfmRhdGEgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5ICgpICgpID0gaWZfbm90X2ZvdW5kIGtleSBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgICgpXG4gICAgICAoKVxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbDEgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleTpfIH5kYXRhIGFyZyAoKSA9IGlmX2ZvdW5kIGRhdGEgYXJnIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSBhcmcgKCkgPSBpZl9ub3RfZm91bmQga2V5IGFyZyBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgIGFcbiAgICAgICgpXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbDEgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleSB+ZGF0YSBhcmcgKCkgPSBpZl9mb3VuZCB+a2V5IH5kYXRhIGFyZyBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgYXJnICgpID0gaWZfbm90X2ZvdW5kIGtleSBhcmcgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCAtPlxuICAgIGZpbmRpX2FuZF9jYWxsX2ltcGxcbiAgICAgIHRcbiAgICAgIH5jb21wYXJlXG4gICAgICBrXG4gICAgICBhXG4gICAgICAoKVxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbDIgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleTpfIH5kYXRhIGFyZzEgYXJnMiA9IGlmX2ZvdW5kIGRhdGEgYXJnMSBhcmcyIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSBhcmcxIGFyZzIgPSBpZl9ub3RfZm91bmQga2V5IGFyZzEgYXJnMiBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5hIH5iIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgIGFcbiAgICAgIGJcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsMiA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5IH5kYXRhIGFyZzEgYXJnMiA9IGlmX2ZvdW5kIH5rZXkgfmRhdGEgYXJnMSBhcmcyIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSBhcmcxIGFyZzIgPSBpZl9ub3RfZm91bmQga2V5IGFyZzEgYXJnMiBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5hIH5iIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgIGFcbiAgICAgIGJcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmQgPVxuICBsZXQgaWZfZm91bmQgdiA9IFNvbWUgdiBpblxuICBsZXQgaWZfbm90X2ZvdW5kIF8gPSBOb25lIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgLT4gZmluZF9hbmRfY2FsbCB0IH5jb21wYXJlIGsgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBtZW0gPVxuICBsZXQgaWZfZm91bmQgXyA9IHRydWUgaW5cbiAgbGV0IGlmX25vdF9mb3VuZCBfID0gZmFsc2UgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayAtPiBmaW5kX2FuZF9jYWxsIHQgfmNvbXBhcmUgayB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IHJlbW92ZSA9XG4gIGxldCByZWMgbWluX2VsdCB0cmVlID1cbiAgICBtYXRjaCB0cmVlIHdpdGhcbiAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgfCBMZWFmIF8gLT4gdHJlZVxuICAgIHwgTm9kZSB7IGxlZnQgPSBFbXB0eTsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPiB0cmVlXG4gICAgfCBOb2RlIHsgbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPiBtaW5fZWx0IGxlZnRcbiAgaW5cbiAgbGV0IHJlYyByZW1vdmVfbWluX2VsdCB0cmVlID1cbiAgICBtYXRjaCB0cmVlIHdpdGhcbiAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgIHwgTGVhZiBfIC0+IEVtcHR5ICgqIFRoaXMgbXVzdCBiZSB0aGUgcm9vdCAqKVxuICAgIHwgTm9kZSB7IGxlZnQgPSBFbXB0eTsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCB9IC0+IHJpZ2h0XG4gICAgfCBOb2RlIHsgbGVmdCA9IExlYWYgXzsga2V5ID0gazsgdmFsdWUgPSB2OyBoZWlnaHQgPSBfOyByaWdodCA9IEVtcHR5IH0gLT5cbiAgICAgIExlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfVxuICAgIHwgTm9kZSB7IGxlZnQgPSBMZWFmIF87IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gYXMgbm9kZSAtPlxuICAgICAgc2V0X2xlZnQgbm9kZSBFbXB0eTtcbiAgICAgIHRyZWVcbiAgICB8IE5vZGUgeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IGFzIG5vZGUgLT5cbiAgICAgIHNldF9sZWZ0IG5vZGUgKHJlbW92ZV9taW5fZWx0IGxlZnQpO1xuICAgICAgdHJlZVxuICBpblxuICBsZXQgbWVyZ2UgdDEgdDIgPVxuICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBFbXB0eSwgdCAtPiB0XG4gICAgfCB0LCBFbXB0eSAtPiB0XG4gICAgfCBfLCBfIC0+XG4gICAgICBsZXQgdHJlZSA9IG1pbl9lbHQgdDIgaW5cbiAgICAgIChtYXRjaCB0cmVlIHdpdGhcbiAgICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgIHwgTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgICAgICBsZXQgdDIgPSBiYWxhbmNlIChyZW1vdmVfbWluX2VsdCB0MikgaW5cbiAgICAgICAgIE5vZGVcbiAgICAgICAgICAgeyBsZWZ0ID0gdDFcbiAgICAgICAgICAgOyBrZXkgPSBrXG4gICAgICAgICAgIDsgdmFsdWUgPSB2XG4gICAgICAgICAgIDsgaGVpZ2h0ID0gSW50Lm1heCAoaGVpZ2h0IHQxKSAoaGVpZ2h0IHQyKSArIDFcbiAgICAgICAgICAgOyByaWdodCA9IHQyXG4gICAgICAgICAgIH1cbiAgICAgICB8IE5vZGUgXyBhcyBub2RlIC0+XG4gICAgICAgICBzZXRfcmlnaHQgbm9kZSAocmVtb3ZlX21pbl9lbHQgdDIpO1xuICAgICAgICAgc2V0X2xlZnQgbm9kZSB0MTtcbiAgICAgICAgIG5vZGUpXG4gIGluXG4gIGxldCByZWMgcmVtb3ZlIHQgcmVtb3ZlZCBjb21wYXJlIGsgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT5cbiAgICAgIHJlbW92ZWQgOj0gZmFsc2U7XG4gICAgICBFbXB0eVxuICAgIHwgTGVhZiB7IGtleSA9IGsnOyB2YWx1ZSA9IF8gfSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGsnID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIHJlbW92ZWQgOj0gdHJ1ZTtcbiAgICAgICAgRW1wdHkpXG4gICAgICBlbHNlIChcbiAgICAgICAgcmVtb3ZlZCA6PSBmYWxzZTtcbiAgICAgICAgdClcbiAgICB8IE5vZGUgeyBsZWZ0OyBrZXkgPSBrJzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCB9IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmUgayBrJyBpblxuICAgICAgaWYgYyA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICByZW1vdmVkIDo9IHRydWU7XG4gICAgICAgIG1lcmdlIGxlZnQgcmlnaHQpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgc2V0X2xlZnQgdCAocmVtb3ZlIGxlZnQgcmVtb3ZlZCBjb21wYXJlIGspO1xuICAgICAgICB0KVxuICAgICAgZWxzZSAoXG4gICAgICAgIHNldF9yaWdodCB0IChyZW1vdmUgcmlnaHQgcmVtb3ZlZCBjb21wYXJlIGspO1xuICAgICAgICB0KVxuICBpblxuICBmdW4gdCB+cmVtb3ZlZCB+Y29tcGFyZSBrIC0+IGJhbGFuY2UgKHJlbW92ZSB0IHJlbW92ZWQgY29tcGFyZSBrKVxuOztcblxubGV0IHJlYyBmb2xkIHQgfmluaXQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiBpbml0XG4gIHwgTGVhZiB7IGtleTsgdmFsdWUgPSBkYXRhIH0gLT4gZiB+a2V5IH5kYXRhIGluaXRcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQgPSBMZWFmIHsga2V5ID0gbGtleTsgdmFsdWUgPSBsZGF0YSB9XG4gICAgICA7IGtleVxuICAgICAgOyB2YWx1ZSA9IGRhdGFcbiAgICAgIDsgaGVpZ2h0ID0gX1xuICAgICAgOyByaWdodCA9IExlYWYgeyBrZXkgPSBya2V5OyB2YWx1ZSA9IHJkYXRhIH1cbiAgICAgIH0gLT4gZiB+a2V5OnJrZXkgfmRhdGE6cmRhdGEgKGYgfmtleSB+ZGF0YSAoZiB+a2V5OmxrZXkgfmRhdGE6bGRhdGEgaW5pdCkpXG4gIHwgTm9kZVxuICAgICAgeyBsZWZ0ID0gTGVhZiB7IGtleSA9IGxrZXk7IHZhbHVlID0gbGRhdGEgfVxuICAgICAgOyBrZXlcbiAgICAgIDsgdmFsdWUgPSBkYXRhXG4gICAgICA7IGhlaWdodCA9IF9cbiAgICAgIDsgcmlnaHQgPSBFbXB0eVxuICAgICAgfSAtPiBmIH5rZXkgfmRhdGEgKGYgfmtleTpsa2V5IH5kYXRhOmxkYXRhIGluaXQpXG4gIHwgTm9kZVxuICAgICAgeyBsZWZ0ID0gRW1wdHlcbiAgICAgIDsga2V5XG4gICAgICA7IHZhbHVlID0gZGF0YVxuICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICA7IHJpZ2h0ID0gTGVhZiB7IGtleSA9IHJrZXk7IHZhbHVlID0gcmRhdGEgfVxuICAgICAgfSAtPiBmIH5rZXk6cmtleSB+ZGF0YTpyZGF0YSAoZiB+a2V5IH5kYXRhIGluaXQpXG4gIHwgTm9kZVxuICAgICAgeyBsZWZ0OyBrZXk7IHZhbHVlID0gZGF0YTsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBMZWFmIHsga2V5ID0gcmtleTsgdmFsdWUgPSByZGF0YSB9IH1cbiAgICAtPiBmIH5rZXk6cmtleSB+ZGF0YTpyZGF0YSAoZiB+a2V5IH5kYXRhIChmb2xkIGxlZnQgfmluaXQgfmYpKVxuICB8IE5vZGVcbiAgICAgIHsgbGVmdCA9IExlYWYgeyBrZXkgPSBsa2V5OyB2YWx1ZSA9IGxkYXRhIH07IGtleTsgdmFsdWUgPSBkYXRhOyBoZWlnaHQgPSBfOyByaWdodCB9XG4gICAgLT4gZm9sZCByaWdodCB+aW5pdDooZiB+a2V5IH5kYXRhIChmIH5rZXk6bGtleSB+ZGF0YTpsZGF0YSBpbml0KSkgfmZcbiAgfCBOb2RlIHsgbGVmdDsga2V5OyB2YWx1ZSA9IGRhdGE7IGhlaWdodCA9IF87IHJpZ2h0IH0gLT5cbiAgICBmb2xkIHJpZ2h0IH5pbml0OihmIH5rZXkgfmRhdGEgKGZvbGQgbGVmdCB+aW5pdCB+ZikpIH5mXG47O1xuXG5sZXQgcmVjIGl0ZXIgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+ICgpXG4gIHwgTGVhZiB7IGtleTsgdmFsdWUgPSBkYXRhIH0gLT4gZiB+a2V5IH5kYXRhXG4gIHwgTm9kZSB7IGxlZnQ7IGtleTsgdmFsdWUgPSBkYXRhOyBoZWlnaHQgPSBfOyByaWdodCB9IC0+XG4gICAgaXRlciBsZWZ0IH5mO1xuICAgIGYgfmtleSB+ZGF0YTtcbiAgICBpdGVyIHJpZ2h0IH5mXG47O1xuXG5sZXQgcmVjIG1hcGlfaW5wbGFjZSB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gKClcbiAgfCBMZWFmICh7IGtleTsgdmFsdWUgfSBhcyB0KSAtPiB0LnZhbHVlIDwtIGYgfmtleSB+ZGF0YTp2YWx1ZVxuICB8IE5vZGUgKHsgbGVmdDsga2V5OyB2YWx1ZTsgaGVpZ2h0ID0gXzsgcmlnaHQgfSBhcyB0KSAtPlxuICAgIG1hcGlfaW5wbGFjZSB+ZiBsZWZ0O1xuICAgIHQudmFsdWUgPC0gZiB+a2V5IH5kYXRhOnZhbHVlO1xuICAgIG1hcGlfaW5wbGFjZSB+ZiByaWdodFxuOztcblxubGV0IGNob29zZV9leG4gPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltBdmx0cmVlLmNob29zZV9leG5dIG9mIGVtcHR5IGhhc2h0YmxcIiBbXSlcbiAgfCBMZWFmIHsga2V5OyB2YWx1ZTsgXyB9IHwgTm9kZSB7IGtleTsgdmFsdWU7IF8gfSAtPiBrZXksIHZhbHVlXG47O1xuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEhhc2h0YmxfaW50ZlxuXG5tb2R1bGUgdHlwZSBLZXkgPSBLZXkuU1xuXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxubGV0IGhhc2hfcGFyYW0gPSBIYXNoYWJsZS5oYXNoX3BhcmFtXG5sZXQgaGFzaCA9IEhhc2hhYmxlLmhhc2hcbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG50eXBlICgnaywgJ3YpIHQgPVxuICB7IG11dGFibGUgdGFibGUgOiAoJ2ssICd2KSBBdmx0cmVlLnQgYXJyYXlcbiAgOyBtdXRhYmxlIGxlbmd0aCA6IGludFxuICAoKiBbcmVjZW50bHlfYWRkZWRdIGlzIHRoZSByZWZlcmVuY2UgcGFzc2VkIHRvIFtBdmx0cmVlLmFkZF0uIFdlIHB1dCBpdCBpbiB0aGUgaGFzaFxuICAgICB0YWJsZSB0byBhdm9pZCBhbGxvY2F0aW5nIGl0IGF0IGV2ZXJ5IFtzZXRdLiAqKVxuICA7IHJlY2VudGx5X2FkZGVkIDogYm9vbCByZWZcbiAgOyBncm93dGhfYWxsb3dlZCA6IGJvb2xcbiAgOyBoYXNoYWJsZSA6ICdrIEhhc2hhYmxlLnRcbiAgOyBtdXRhYmxlIG11dGF0aW9uX2FsbG93ZWQgOiBib29sICgqIFNldCBkdXJpbmcgYWxsIGl0ZXJhdGlvbiBvcGVyYXRpb25zICopXG4gIH1cblxudHlwZSAnYSBrZXkgPSAnYVxuXG5sZXQgc2V4cF9vZl9rZXkgdCA9IHQuaGFzaGFibGUuSGFzaGFibGUuc2V4cF9vZl90XG5sZXQgY29tcGFyZV9rZXkgdCA9IHQuaGFzaGFibGUuSGFzaGFibGUuY29tcGFyZVxuXG5sZXQgZW5zdXJlX211dGF0aW9uX2FsbG93ZWQgdCA9XG4gIGlmIG5vdCB0Lm11dGF0aW9uX2FsbG93ZWQgdGhlbiBmYWlsd2l0aCBcIkhhc2h0Ymw6IG11dGF0aW9uIG5vdCBhbGxvd2VkIGR1cmluZyBpdGVyYXRpb25cIlxuOztcblxubGV0IHdpdGhvdXRfbXV0YXRpbmcgdCBmID1cbiAgaWYgdC5tdXRhdGlvbl9hbGxvd2VkXG4gIHRoZW4gKFxuICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSBmYWxzZTtcbiAgICBtYXRjaCBmICgpIHdpdGhcbiAgICB8IHggLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSB0cnVlO1xuICAgICAgeFxuICAgIHwgZXhjZXB0aW9uIGV4biAtPlxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIHRydWU7XG4gICAgICByYWlzZSBleG4pXG4gIGVsc2UgZiAoKVxuOztcblxuKCoqIEludGVybmFsbHkgdXNlIGEgbWF4aW11bSBzaXplIHRoYXQgaXMgYSBwb3dlciBvZiAyLiBSZXZlcnNlcyB0aGUgYWJvdmUgdG8gZmluZCB0aGVcbiAgICBmbG9vciBwb3dlciBvZiAyIGJlbG93IHRoZSBzeXN0ZW0gbWF4IGFycmF5IGxlbmd0aCAqKVxubGV0IG1heF90YWJsZV9sZW5ndGggPSBJbnQuZmxvb3JfcG93MiBBcnJheS5tYXhfbGVuZ3RoXG5cbigqIFRoZSBkZWZhdWx0IHNpemUgaXMgY2hvc2VuIHRvIGJlIDAgKGFzIG9wcG9zZWQgdG8gMTI4IGFzIGl0IHdhcyBiZWZvcmUpIGJlY2F1c2U6XG4gICAtIDEyOCBjYW4gY3JlYXRlIHN1YnN0YW50aWFsIG1lbW9yeSBvdmVyaGVhZCAoeDEwKSB3aGVuIGNyZWF0aW5nIG1hbnkgdGFibGVzLCBtb3N0XG4gICAgIG9mIHdoaWNoIGFyZSBub3QgYmlnIChzYXksIGlmIHlvdSBoYXZlIGEgaGFzaHRibCBvZiBoYXNodGJsKS4gQW5kIG1lbW9yeSBvdmVyaGVhZCBpc1xuICAgICBub3QgdGhhdCBlYXN5IHRvIHByb2ZpbGUuXG4gICAtIGlmIGEgaGFzaHRibCBpcyBnb2luZyB0byBncm93LCBpdCdzIG5vdCBjbGVhciB3aHkgMTI4IGlzIG1hcmtlZGx5IGJldHRlciB0aGFuIG90aGVyXG4gICAgIHNpemVzIChpZiB5b3UgZ29pbmcgdG8gc3RpY2sgMTAwMCBlbGVtZW50cywgeW91J3JlIGdvaW5nIHRvIGdyb3cgdGhlIGhhc2h0YWJsZSBvbmNlXG4gICAgIG9yIHR3aWNlIGFueXdheSlcbiAgIC0gaW4gb3RoZXIgbGFuZ3VhZ2VzIChsaWtlIHJ1c3QsIHB5dGhvbiwgYW5kIGFwcGFyZW50bHkgZ28pLCB0aGUgZGVmYXVsdCBpcyBhbHNvIGFcbiAgICAgc21hbGwgc2l6ZS4gKilcbmxldCBjcmVhdGUgPyhncm93dGhfYWxsb3dlZCA9IHRydWUpID8oc2l6ZSA9IDApIH5oYXNoYWJsZSAoKSA9XG4gIGxldCBzaXplID0gSW50Lm1pbiAoSW50Lm1heCAxIHNpemUpIG1heF90YWJsZV9sZW5ndGggaW5cbiAgbGV0IHNpemUgPSBJbnQuY2VpbF9wb3cyIHNpemUgaW5cbiAgeyB0YWJsZSA9IEFycmF5LmNyZWF0ZSB+bGVuOnNpemUgQXZsdHJlZS5lbXB0eVxuICA7IGxlbmd0aCA9IDBcbiAgOyBncm93dGhfYWxsb3dlZFxuICA7IHJlY2VudGx5X2FkZGVkID0gcmVmIGZhbHNlXG4gIDsgaGFzaGFibGVcbiAgOyBtdXRhdGlvbl9hbGxvd2VkID0gdHJ1ZVxuICB9XG47O1xuXG4oKiogU3VwcGxlbWVudGFsIGhhc2guIFRoaXMgbWF5IG5vdCBiZSBuZWNlc3NhcnksIGl0IGlzIGludGVuZGVkIGFzIGEgZGVmZW5zZSBhZ2FpbnN0IHBvb3JcbiAgICBoYXNoIGZ1bmN0aW9ucywgZm9yIHdoaWNoIHRoZSBwb3dlciBvZiAyIHNpemVkIHRhYmxlIHdpbGwgYmUgZXNwZWNpYWxseSBzZW5zaXRpdmUuXG4gICAgV2l0aCBzb21lIHRlc3Rpbmcgd2UgbWF5IGNob29zZSB0byBhZGQgaXQsIGJ1dCB0aGlzIHRhYmxlIGlzIGRlc2lnbmVkIHRvIGJlIHJvYnVzdCB0b1xuICAgIGNvbGxpc2lvbnMsIGFuZCBpbiBtb3N0IG9mIG15IHRlc3RpbmcgdGhpcyBkZWdyYWRlcyBwZXJmb3JtYW5jZS4gKilcbmxldCBfc3VwcGxlbWVudGFsX2hhc2ggaCA9XG4gIGxldCBoID0gaCBseG9yICgoaCBsc3IgMjApIGx4b3IgKGggbHNyIDEyKSkgaW5cbiAgaCBseG9yIChoIGxzciA3KSBseG9yIChoIGxzciA0KVxuOztcblxubGV0IHNsb3QgdCBrZXkgPVxuICBsZXQgaGFzaCA9IHQuaGFzaGFibGUuSGFzaGFibGUuaGFzaCBrZXkgaW5cbiAgKCogdGhpcyBpcyBhbHdheXMgbm9uLW5lZ2F0aXZlIGJlY2F1c2Ugd2UgZG8gW2xhbmRdIHdpdGggbm9uLW5lZ2F0aXZlIG51bWJlciAqKVxuICBoYXNoIGxhbmQgKEFycmF5Lmxlbmd0aCB0LnRhYmxlIC0gMSlcbjs7XG5cbmxldCBhZGRfd29ya2VyIHQgfnJlcGxhY2UgfmtleSB+ZGF0YSA9XG4gIGxldCBpID0gc2xvdCB0IGtleSBpblxuICBsZXQgcm9vdCA9IHQudGFibGUuKGkpIGluXG4gIGxldCBhZGRlZCA9IHQucmVjZW50bHlfYWRkZWQgaW5cbiAgYWRkZWQgOj0gZmFsc2U7XG4gIGxldCBuZXdfcm9vdCA9XG4gICAgKCogVGhlIGF2bCB0cmVlIG1pZ2h0IHJlcGxhY2UgdGhlIHZhbHVlIFtyZXBsYWNlPXRydWVdIG9yIGRvIG5vdGhpbmcgW3JlcGxhY2U9ZmFsc2VdXG4gICAgICAgdG8gdGhlIGVudHJ5LCBpbiB0aGF0IGNhc2UgdGhlIHRhYmxlIGRpZCBub3QgZ2V0IGJpZ2dlciwgc28gd2Ugc2hvdWxkIG5vdFxuICAgICAgIGluY3JlbWVudCBsZW5ndGgsIHdlIHBhc3MgaW4gdGhlIGJvb2wgcmVmIHQuYWRkZWQgc28gdGhhdCBpdCBjYW4gdGVsbCB1cyB3aGV0aGVyXG4gICAgICAgaXQgYWRkZWQgb3IgcmVwbGFjZWQuIFdlIGRvIGl0IHRoaXMgd2F5IHRvIGF2b2lkIGV4dHJhIGFsbG9jYXRpb24uIFNpbmNlIHRoZSBib29sXG4gICAgICAgaXMgYW4gaW1tZWRpYXRlIGl0IGRvZXMgbm90IGdvIHRocm91Z2ggdGhlIHdyaXRlIGJhcnJpZXIuICopXG4gICAgQXZsdHJlZS5hZGQgfnJlcGxhY2Ugcm9vdCB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkgfmFkZGVkIH5rZXkgfmRhdGFcbiAgaW5cbiAgaWYgIWFkZGVkIHRoZW4gdC5sZW5ndGggPC0gdC5sZW5ndGggKyAxO1xuICAoKiBUaGlzIGxpdHRsZSBvcHRpbWl6YXRpb24gc2F2ZXMgYSBjYW1sX21vZGlmeSB3aGVuIHRoZSB0cmVlXG4gICAgIGhhc24ndCBiZWVuIHJlYmFsYW5jZWQuICopXG4gIGlmIG5vdCAocGh5c19lcXVhbCBuZXdfcm9vdCByb290KSB0aGVuIHQudGFibGUuKGkpIDwtIG5ld19yb290XG47O1xuXG5sZXQgbWF5YmVfcmVzaXplX3RhYmxlIHQgPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgbGV0IHNob3VsZF9ncm93ID0gdC5sZW5ndGggPiBsZW4gaW5cbiAgaWYgc2hvdWxkX2dyb3cgJiYgdC5ncm93dGhfYWxsb3dlZFxuICB0aGVuIChcbiAgICBsZXQgbmV3X2FycmF5X2xlbmd0aCA9IEludC5taW4gKGxlbiAqIDIpIG1heF90YWJsZV9sZW5ndGggaW5cbiAgICBpZiBuZXdfYXJyYXlfbGVuZ3RoID4gbGVuXG4gICAgdGhlbiAoXG4gICAgICBsZXQgbmV3X3RhYmxlID0gQXJyYXkuY3JlYXRlIH5sZW46bmV3X2FycmF5X2xlbmd0aCBBdmx0cmVlLmVtcHR5IGluXG4gICAgICBsZXQgb2xkX3RhYmxlID0gdC50YWJsZSBpblxuICAgICAgdC50YWJsZSA8LSBuZXdfdGFibGU7XG4gICAgICB0Lmxlbmd0aCA8LSAwO1xuICAgICAgbGV0IGYgfmtleSB+ZGF0YSA9IGFkZF93b3JrZXIgfnJlcGxhY2U6dHJ1ZSB0IH5rZXkgfmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggb2xkX3RhYmxlIC0gMSBkb1xuICAgICAgICBBdmx0cmVlLml0ZXIgb2xkX3RhYmxlLihpKSB+ZlxuICAgICAgZG9uZSkpXG47O1xuXG5sZXQgc2V0IHQgfmtleSB+ZGF0YSA9XG4gIGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQ7XG4gIGFkZF93b3JrZXIgfnJlcGxhY2U6dHJ1ZSB0IH5rZXkgfmRhdGE7XG4gIG1heWJlX3Jlc2l6ZV90YWJsZSB0XG47O1xuXG5sZXQgYWRkIHQgfmtleSB+ZGF0YSA9XG4gIGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQ7XG4gIGFkZF93b3JrZXIgfnJlcGxhY2U6ZmFsc2UgdCB+a2V5IH5kYXRhO1xuICBpZiAhKHQucmVjZW50bHlfYWRkZWQpXG4gIHRoZW4gKFxuICAgIG1heWJlX3Jlc2l6ZV90YWJsZSB0O1xuICAgIGBPaylcbiAgZWxzZSBgRHVwbGljYXRlXG47O1xuXG5sZXQgYWRkX2V4biB0IH5rZXkgfmRhdGEgPVxuICBtYXRjaCBhZGQgdCB+a2V5IH5kYXRhIHdpdGhcbiAgfCBgT2sgLT4gKClcbiAgfCBgRHVwbGljYXRlIC0+XG4gICAgbGV0IHNleHBfb2Zfa2V5ID0gc2V4cF9vZl9rZXkgdCBpblxuICAgIGxldCBlcnJvciA9IEVycm9yLmNyZWF0ZSBcIkhhc2h0YmwuYWRkX2V4biBnb3Qga2V5IGFscmVhZHkgcHJlc2VudFwiIGtleSBzZXhwX29mX2tleSBpblxuICAgIEVycm9yLnJhaXNlIGVycm9yXG47O1xuXG5sZXQgY2xlYXIgdCA9XG4gIGVuc3VyZV9tdXRhdGlvbl9hbGxvd2VkIHQ7XG4gIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC50YWJsZSAtIDEgZG9cbiAgICB0LnRhYmxlLihpKSA8LSBBdmx0cmVlLmVtcHR5XG4gIGRvbmU7XG4gIHQubGVuZ3RoIDwtIDBcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsIHQga2V5IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgKCogd2l0aCBhIGdvb2QgaGFzaCBmdW5jdGlvbiB0aGVzZSBmaXJzdCB0d28gY2FzZXMgd2lsbCBiZSB0aGUgb3ZlcndoZWxtaW5nIG1ham9yaXR5LFxuICAgICBhbmQgQXZsdHJlZS5maW5kIGlzIHJlY3Vyc2l2ZSwgc28gaXQgY2FuJ3QgYmUgaW5saW5lZCwgc28gZG9pbmcgdGhpcyBhdm9pZHMgYVxuICAgICBmdW5jdGlvbiBjYWxsIGluIG1vc3QgY2FzZXMuICopXG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXlcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgdiBlbHNlIGlmX25vdF9mb3VuZCBrZXlcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kX2FuZF9jYWxsIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwxIHQga2V5IH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleSBhXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIHYgYSBlbHNlIGlmX25vdF9mb3VuZCBrZXkgYVxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRfYW5kX2NhbGwxIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSB+YSB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwyIHQga2V5IH5hIH5iIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleSBhIGJcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgdiBhIGIgZWxzZSBpZl9ub3RfZm91bmQga2V5IGEgYlxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRfYW5kX2NhbGwyIHRyZWUgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleSB+YSB+YiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsIHQga2V5IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgKCogd2l0aCBhIGdvb2QgaGFzaCBmdW5jdGlvbiB0aGVzZSBmaXJzdCB0d28gY2FzZXMgd2lsbCBiZSB0aGUgb3ZlcndoZWxtaW5nIG1ham9yaXR5LFxuICAgICBhbmQgQXZsdHJlZS5maW5kIGlzIHJlY3Vyc2l2ZSwgc28gaXQgY2FuJ3QgYmUgaW5saW5lZCwgc28gZG9pbmcgdGhpcyBhdm9pZHMgYVxuICAgICBmdW5jdGlvbiBjYWxsIGluIG1vc3QgY2FzZXMuICopXG4gIG1hdGNoIHQudGFibGUuKHNsb3QgdCBrZXkpIHdpdGhcbiAgfCBBdmx0cmVlLkVtcHR5IC0+IGlmX25vdF9mb3VuZCBrZXlcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgfmtleTprIH5kYXRhOnYgZWxzZSBpZl9ub3RfZm91bmQga2V5XG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZGlfYW5kX2NhbGwgdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwxIHQga2V5IH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleSBhXG4gIHwgQXZsdHJlZS5MZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlX2tleSB0IGsga2V5ID0gMCB0aGVuIGlmX2ZvdW5kIH5rZXk6ayB+ZGF0YTp2IGEgZWxzZSBpZl9ub3RfZm91bmQga2V5IGFcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kaV9hbmRfY2FsbDEgdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5IH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwyIHQga2V5IH5hIH5iIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kID1cbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleSBhIGJcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgfmtleTprIH5kYXRhOnYgYSBiIGVsc2UgaWZfbm90X2ZvdW5kIGtleSBhIGJcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kaV9hbmRfY2FsbDJcbiAgICAgIHRyZWVcbiAgICAgIH5jb21wYXJlOihjb21wYXJlX2tleSB0KVxuICAgICAga2V5XG4gICAgICB+YVxuICAgICAgfmJcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmQgPVxuICBsZXQgaWZfZm91bmQgdiA9IFNvbWUgdiBpblxuICBsZXQgaWZfbm90X2ZvdW5kIF8gPSBOb25lIGluXG4gIGZ1biB0IGtleSAtPiBmaW5kX2FuZF9jYWxsIHQga2V5IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgbWVtIHQga2V5ID1cbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gZmFsc2VcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IF8gfSAtPiBjb21wYXJlX2tleSB0IGsga2V5ID0gMFxuICB8IHRyZWUgLT4gQXZsdHJlZS5tZW0gdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5XG47O1xuXG5sZXQgcmVtb3ZlIHQga2V5ID1cbiAgZW5zdXJlX211dGF0aW9uX2FsbG93ZWQgdDtcbiAgbGV0IGkgPSBzbG90IHQga2V5IGluXG4gIGxldCByb290ID0gdC50YWJsZS4oaSkgaW5cbiAgbGV0IGFkZGVkX29yX3JlbW92ZWQgPSB0LnJlY2VudGx5X2FkZGVkIGluXG4gIGFkZGVkX29yX3JlbW92ZWQgOj0gZmFsc2U7XG4gIGxldCBuZXdfcm9vdCA9XG4gICAgQXZsdHJlZS5yZW1vdmUgcm9vdCB+cmVtb3ZlZDphZGRlZF9vcl9yZW1vdmVkIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXlcbiAgaW5cbiAgaWYgbm90IChwaHlzX2VxdWFsIHJvb3QgbmV3X3Jvb3QpIHRoZW4gdC50YWJsZS4oaSkgPC0gbmV3X3Jvb3Q7XG4gIGlmICFhZGRlZF9vcl9yZW1vdmVkIHRoZW4gdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxXG47O1xuXG5sZXQgbGVuZ3RoIHQgPSB0Lmxlbmd0aFxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGlmIGxlbmd0aCB0ID0gMFxuICB0aGVuIGluaXRcbiAgZWxzZSAoXG4gICAgbGV0IG4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICAgIGxldCBtID0gdC5tdXRhdGlvbl9hbGxvd2VkIGluXG4gICAgbWF0Y2hcbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSBmYWxzZTtcbiAgICAgIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgICAgICBtYXRjaCBBcnJheS51bnNhZmVfZ2V0IHQudGFibGUgaSB3aXRoXG4gICAgICAgIHwgQXZsdHJlZS5FbXB0eSAtPiAoKVxuICAgICAgICB8IEF2bHRyZWUuTGVhZiB7IGtleTsgdmFsdWUgPSBkYXRhIH0gLT4gYWNjIDo9IGYgfmtleSB+ZGF0YSAhYWNjXG4gICAgICAgIHwgYnVja2V0IC0+IGFjYyA6PSBBdmx0cmVlLmZvbGQgYnVja2V0IH5pbml0OiFhY2MgfmZcbiAgICAgIGRvbmVcbiAgICB3aXRoXG4gICAgfCAoKSAtPlxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIG07XG4gICAgICAhYWNjXG4gICAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gbTtcbiAgICAgIHJhaXNlIGV4bilcbjs7XG5cbmxldCBpdGVyaSB0IH5mID1cbiAgaWYgdC5sZW5ndGggPSAwXG4gIHRoZW4gKClcbiAgZWxzZSAoXG4gICAgbGV0IG4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBtID0gdC5tdXRhdGlvbl9hbGxvd2VkIGluXG4gICAgbWF0Y2hcbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSBmYWxzZTtcbiAgICAgIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgICAgICBtYXRjaCBBcnJheS51bnNhZmVfZ2V0IHQudGFibGUgaSB3aXRoXG4gICAgICAgIHwgQXZsdHJlZS5FbXB0eSAtPiAoKVxuICAgICAgICB8IEF2bHRyZWUuTGVhZiB7IGtleTsgdmFsdWUgPSBkYXRhIH0gLT4gZiB+a2V5IH5kYXRhXG4gICAgICAgIHwgYnVja2V0IC0+IEF2bHRyZWUuaXRlciBidWNrZXQgfmZcbiAgICAgIGRvbmVcbiAgICB3aXRoXG4gICAgfCAoKSAtPiB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gbVxuICAgIHwgZXhjZXB0aW9uIGV4biAtPlxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIG07XG4gICAgICByYWlzZSBleG4pXG47O1xuXG5sZXQgaXRlciB0IH5mID0gaXRlcmkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5sZXQgaXRlcl9rZXlzIHQgfmYgPSBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YTpfIC0+IGYga2V5KVxuXG5sZXQgcmVjIGNob29zZV9ub25lbXB0eSB0YWJsZSBpID1cbiAgbGV0IGF2bHRyZWUgPSB0YWJsZS4oaSkgaW5cbiAgaWYgQXZsdHJlZS5pc19lbXB0eSBhdmx0cmVlXG4gIHRoZW4gY2hvb3NlX25vbmVtcHR5IHRhYmxlIChpICsgMSlcbiAgZWxzZSBBdmx0cmVlLmNob29zZV9leG4gYXZsdHJlZVxuOztcblxubGV0IGNob29zZV9leG4gdCA9XG4gIGlmIHQubGVuZ3RoID0gMCB0aGVuIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltIYXNodGJsLmNob29zZV9leG5dIG9mIGVtcHR5IGhhc2h0YmxcIiBbXSk7XG4gIGNob29zZV9ub25lbXB0eSB0LnRhYmxlIDBcbjs7XG5cbmxldCBjaG9vc2UgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAoY2hvb3NlX25vbmVtcHR5IHQudGFibGUgMClcblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfa2V5IGludmFyaWFudF9kYXRhIHQgPVxuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxIGRvXG4gICAgQXZsdHJlZS5pbnZhcmlhbnQgdC50YWJsZS4oaSkgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpXG4gIGRvbmU7XG4gIGxldCByZWFsX2xlbiA9XG4gICAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5IH5kYXRhIGkgLT5cbiAgICAgIGludmFyaWFudF9rZXkga2V5O1xuICAgICAgaW52YXJpYW50X2RhdGEgZGF0YTtcbiAgICAgIGkgKyAxKVxuICBpblxuICBhc3NlcnQgKHJlYWxfbGVuID0gdC5sZW5ndGgpXG47O1xuXG5sZXQgZmluZF9leG4gPVxuICBsZXQgaWZfZm91bmQgdiBfID0gdiBpblxuICBsZXQgaWZfbm90X2ZvdW5kIGsgdCA9XG4gICAgcmFpc2VcbiAgICAgIChOb3RfZm91bmRfcyAoTGlzdCBbIEF0b20gXCJIYXNodGJsLmZpbmRfZXhuOiBub3QgZm91bmRcIjsgdC5oYXNoYWJsZS5zZXhwX29mX3QgayBdKSlcbiAgaW5cbiAgbGV0IGZpbmRfZXhuIHQga2V5ID0gZmluZF9hbmRfY2FsbDEgdCBrZXkgfmE6dCB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfZXhuXG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgZmFsc2UpXG47O1xuXG5sZXQgZXhpc3RzIHQgfmYgPSBleGlzdHNpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxubGV0IGZvcl9hbGxpIHQgfmYgPSBub3QgKGV4aXN0c2kgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gbm90IChmIH5rZXkgfmRhdGEpKSlcbmxldCBmb3JfYWxsIHQgfmYgPSBub3QgKGV4aXN0c2kgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBub3QgKGYgZGF0YSkpKVxuXG5sZXQgY291bnRpIHQgfmYgPVxuICBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIGFjYyArIDEgZWxzZSBhY2MpXG47O1xuXG5sZXQgY291bnQgdCB+ZiA9XG4gIGZvbGQgdCB+aW5pdDowIH5mOihmdW4gfmtleTpfIH5kYXRhIGFjYyAtPiBpZiBmIGRhdGEgdGhlbiBhY2MgKyAxIGVsc2UgYWNjKVxuOztcblxubGV0IG1hcGkgdCB+ZiA9XG4gIGxldCBuZXdfdCA9XG4gICAgY3JlYXRlIH5ncm93dGhfYWxsb3dlZDp0Lmdyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZTp0Lmhhc2hhYmxlIH5zaXplOnQubGVuZ3RoICgpXG4gIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IHNldCBuZXdfdCB+a2V5IH5kYXRhOihmIH5rZXkgfmRhdGEpKTtcbiAgbmV3X3Rcbjs7XG5cbmxldCBtYXAgdCB+ZiA9IG1hcGkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5sZXQgY29weSB0ID0gbWFwIHQgfmY6Rm4uaWRcblxubGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICBsZXQgbmV3X3QgPVxuICAgIGNyZWF0ZSB+Z3Jvd3RoX2FsbG93ZWQ6dC5ncm93dGhfYWxsb3dlZCB+aGFzaGFibGU6dC5oYXNoYWJsZSB+c2l6ZTp0Lmxlbmd0aCAoKVxuICBpblxuICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgIG1hdGNoIGYgfmtleSB+ZGF0YSB3aXRoXG4gICAgfCBTb21lIG5ld19kYXRhIC0+IHNldCBuZXdfdCB+a2V5IH5kYXRhOm5ld19kYXRhXG4gICAgfCBOb25lIC0+ICgpKTtcbiAgbmV3X3Rcbjs7XG5cbmxldCBmaWx0ZXJfbWFwIHQgfmYgPSBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcblxubGV0IGZpbHRlcmkgdCB+ZiA9XG4gIGZpbHRlcl9tYXBpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIFNvbWUgZGF0YSBlbHNlIE5vbmUpXG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPSBmaWx0ZXJpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxubGV0IGZpbHRlcl9rZXlzIHQgfmYgPSBmaWx0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOl8gLT4gZiBrZXkpXG5cbmxldCBwYXJ0aXRpb25fbWFwaSB0IH5mID1cbiAgbGV0IHQwID1cbiAgICBjcmVhdGUgfmdyb3d0aF9hbGxvd2VkOnQuZ3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlOnQuaGFzaGFibGUgfnNpemU6dC5sZW5ndGggKClcbiAgaW5cbiAgbGV0IHQxID1cbiAgICBjcmVhdGUgfmdyb3d0aF9hbGxvd2VkOnQuZ3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlOnQuaGFzaGFibGUgfnNpemU6dC5sZW5ndGggKClcbiAgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICBtYXRjaCAoZiB+a2V5IH5kYXRhIDogXyBFaXRoZXIudCkgd2l0aFxuICAgIHwgRmlyc3QgbmV3X2RhdGEgLT4gc2V0IHQwIH5rZXkgfmRhdGE6bmV3X2RhdGFcbiAgICB8IFNlY29uZCBuZXdfZGF0YSAtPiBzZXQgdDEgfmtleSB+ZGF0YTpuZXdfZGF0YSk7XG4gIHQwLCB0MVxuOztcblxubGV0IHBhcnRpdGlvbl9tYXAgdCB+ZiA9IHBhcnRpdGlvbl9tYXBpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuXG5sZXQgcGFydGl0aW9uaV90ZiB0IH5mID1cbiAgcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gRmlyc3QgZGF0YSBlbHNlIFNlY29uZCBkYXRhKVxuOztcblxubGV0IHBhcnRpdGlvbl90ZiB0IH5mID0gcGFydGl0aW9uaV90ZiB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcblxubGV0IGZpbmRfb3JfYWRkIHQgaWQgfmRlZmF1bHQgPVxuICBmaW5kX2FuZF9jYWxsMlxuICAgIHRcbiAgICBpZFxuICAgIH5hOnRcbiAgICB+YjpkZWZhdWx0XG4gICAgfmlmX2ZvdW5kOihmdW4gZGF0YSBfIF8gLT4gZGF0YSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4ga2V5IHQgZGVmYXVsdCAtPlxuICAgICAgbGV0IGRlZmF1bHQgPSBkZWZhdWx0ICgpIGluXG4gICAgICBzZXQgdCB+a2V5IH5kYXRhOmRlZmF1bHQ7XG4gICAgICBkZWZhdWx0KVxuOztcblxubGV0IGZpbmRpX29yX2FkZCB0IGlkIH5kZWZhdWx0ID1cbiAgZmluZF9hbmRfY2FsbDJcbiAgICB0XG4gICAgaWRcbiAgICB+YTp0XG4gICAgfmI6ZGVmYXVsdFxuICAgIH5pZl9mb3VuZDooZnVuIGRhdGEgXyBfIC0+IGRhdGEpXG4gICAgfmlmX25vdF9mb3VuZDooZnVuIGtleSB0IGRlZmF1bHQgLT5cbiAgICAgIGxldCBkZWZhdWx0ID0gZGVmYXVsdCBrZXkgaW5cbiAgICAgIHNldCB0IH5rZXkgfmRhdGE6ZGVmYXVsdDtcbiAgICAgIGRlZmF1bHQpXG47O1xuXG4oKiBTb21lIGhhc2h0YmwgaW1wbGVtZW50YXRpb25zIG1heSBiZSBhYmxlIHRvIHBlcmZvcm0gdGhpcyBtb3JlIGVmZmljaWVudGx5IHRoYW4gdHdvXG4gICBzZXBhcmF0ZSBsb29rdXBzICopXG5sZXQgZmluZF9hbmRfcmVtb3ZlIHQgaWQgPVxuICBsZXQgcmVzdWx0ID0gZmluZCB0IGlkIGluXG4gIGlmIE9wdGlvbi5pc19zb21lIHJlc3VsdCB0aGVuIHJlbW92ZSB0IGlkO1xuICByZXN1bHRcbjs7XG5cblxubGV0IGNoYW5nZSB0IGlkIH5mID1cbiAgbWF0Y2ggZiAoZmluZCB0IGlkKSB3aXRoXG4gIHwgTm9uZSAtPiByZW1vdmUgdCBpZFxuICB8IFNvbWUgZGF0YSAtPiBzZXQgdCB+a2V5OmlkIH5kYXRhXG47O1xuXG5sZXQgdXBkYXRlX2FuZF9yZXR1cm4gdCBpZCB+ZiA9XG4gIGxldCBkYXRhID0gZiAoZmluZCB0IGlkKSBpblxuICBzZXQgdCB+a2V5OmlkIH5kYXRhO1xuICBkYXRhXG47O1xuXG5sZXQgdXBkYXRlIHQgaWQgfmYgPSBpZ25vcmUgKHVwZGF0ZV9hbmRfcmV0dXJuIHQgaWQgfmYgOiBfKVxuXG5sZXQgaW5jcl9ieSB+cmVtb3ZlX2lmX3plcm8gdCBrZXkgYnkgPVxuICBpZiByZW1vdmVfaWZfemVyb1xuICB0aGVuXG4gICAgY2hhbmdlIHQga2V5IH5mOihmdW4gb3B0IC0+XG4gICAgICBtYXRjaCBieSArIE9wdGlvbi52YWx1ZSBvcHQgfmRlZmF1bHQ6MCB3aXRoXG4gICAgICB8IDAgLT4gTm9uZVxuICAgICAgfCBuIC0+IFNvbWUgbilcbiAgZWxzZVxuICAgIHVwZGF0ZSB0IGtleSB+ZjooZnVuY3Rpb25cbiAgICAgIHwgTm9uZSAtPiBieVxuICAgICAgfCBTb21lIGkgLT4gYnkgKyBpKVxuOztcblxubGV0IGluY3IgPyhieSA9IDEpID8ocmVtb3ZlX2lmX3plcm8gPSBmYWxzZSkgdCBrZXkgPSBpbmNyX2J5IH5yZW1vdmVfaWZfemVybyB0IGtleSBieVxubGV0IGRlY3IgPyhieSA9IDEpID8ocmVtb3ZlX2lmX3plcm8gPSBmYWxzZSkgdCBrZXkgPSBpbmNyX2J5IH5yZW1vdmVfaWZfemVybyB0IGtleSAoLWJ5KVxuXG5sZXQgYWRkX211bHRpIHQgfmtleSB+ZGF0YSA9XG4gIHVwZGF0ZSB0IGtleSB+ZjooZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gWyBkYXRhIF1cbiAgICB8IFNvbWUgbCAtPiBkYXRhIDo6IGwpXG47O1xuXG5sZXQgcmVtb3ZlX211bHRpIHQga2V5ID1cbiAgbWF0Y2ggZmluZCB0IGtleSB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgW10gfCBTb21lIFsgXyBdIC0+IHJlbW92ZSB0IGtleVxuICB8IFNvbWUgKF8gOjogdGwpIC0+IHNldCB0IH5rZXkgfmRhdGE6dGxcbjs7XG5cbmxldCBmaW5kX211bHRpIHQga2V5ID1cbiAgbWF0Y2ggZmluZCB0IGtleSB3aXRoXG4gIHwgTm9uZSAtPiBbXVxuICB8IFNvbWUgbCAtPiBsXG47O1xuXG5sZXQgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IH5nZXRfZGF0YSByb3dzID1cbiAgbGV0IHNpemUgPVxuICAgIG1hdGNoIHNpemUgd2l0aFxuICAgIHwgU29tZSBzIC0+IHNcbiAgICB8IE5vbmUgLT4gTGlzdC5sZW5ndGggcm93c1xuICBpblxuICBsZXQgcmVzID0gY3JlYXRlID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgfnNpemUgKCkgaW5cbiAgbGV0IGR1cGVzID0gcmVmIFtdIGluXG4gIExpc3QuaXRlciByb3dzIH5mOihmdW4gciAtPlxuICAgIGxldCBrZXkgPSBnZXRfa2V5IHIgaW5cbiAgICBsZXQgZGF0YSA9IGdldF9kYXRhIHIgaW5cbiAgICBpZiBtZW0gcmVzIGtleSB0aGVuIGR1cGVzIDo9IGtleSA6OiAhZHVwZXMgZWxzZSBzZXQgcmVzIH5rZXkgfmRhdGEpO1xuICBtYXRjaCAhZHVwZXMgd2l0aFxuICB8IFtdIC0+IGBPayByZXNcbiAgfCBrZXlzIC0+IGBEdXBsaWNhdGVfa2V5cyAoTGlzdC5kZWR1cF9hbmRfc29ydCB+Y29tcGFyZTpoYXNoYWJsZS5IYXNoYWJsZS5jb21wYXJlIGtleXMpXG47O1xuXG5sZXQgY3JlYXRlX21hcHBlZF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IH5nZXRfZGF0YSByb3dzID1cbiAgbGV0IHNpemUgPVxuICAgIG1hdGNoIHNpemUgd2l0aFxuICAgIHwgU29tZSBzIC0+IHNcbiAgICB8IE5vbmUgLT4gTGlzdC5sZW5ndGggcm93c1xuICBpblxuICBsZXQgcmVzID0gY3JlYXRlID9ncm93dGhfYWxsb3dlZCB+c2l6ZSB+aGFzaGFibGUgKCkgaW5cbiAgTGlzdC5pdGVyIHJvd3MgfmY6KGZ1biByIC0+XG4gICAgbGV0IGtleSA9IGdldF9rZXkgciBpblxuICAgIGxldCBkYXRhID0gZ2V0X2RhdGEgciBpblxuICAgIGFkZF9tdWx0aSByZXMgfmtleSB+ZGF0YSk7XG4gIHJlc1xuOztcblxubGV0IG9mX2FsaXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0ID1cbiAgbWF0Y2ggY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5OmZzdCB+Z2V0X2RhdGE6c25kIGxzdCB3aXRoXG4gIHwgYE9rIHQgLT4gYE9rIHRcbiAgfCBgRHVwbGljYXRlX2tleXMgayAtPiBgRHVwbGljYXRlX2tleSAoTGlzdC5oZF9leG4gaylcbjs7XG5cbmxldCBvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSBsc3QgPVxuICBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXk6ZnN0IH5nZXRfZGF0YTpzbmQgbHN0XG47O1xuXG5sZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSBsc3QgPVxuICBtYXRjaCBvZl9hbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCB3aXRoXG4gIHwgYE9rIHYgLT4gUmVzdWx0Lk9rIHZcbiAgfCBgRHVwbGljYXRlX2tleSBrZXkgLT5cbiAgICBsZXQgc2V4cF9vZl9rZXkgPSBoYXNoYWJsZS5IYXNoYWJsZS5zZXhwX29mX3QgaW5cbiAgICBPcl9lcnJvci5lcnJvciBcIkhhc2h0Ymwub2ZfYWxpc3RfZXhuOiBkdXBsaWNhdGUga2V5XCIga2V5IHNleHBfb2Zfa2V5XG47O1xuXG5sZXQgb2ZfYWxpc3RfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0ID1cbiAgbWF0Y2ggb2ZfYWxpc3Rfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSBsc3Qgd2l0aFxuICB8IFJlc3VsdC5PayB2IC0+IHZcbiAgfCBSZXN1bHQuRXJyb3IgZSAtPiBFcnJvci5yYWlzZSBlXG47O1xuXG5sZXQgb2ZfYWxpc3RfbXVsdGkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSBsc3QgPVxuICBjcmVhdGVfbWFwcGVkX211bHRpID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXk6ZnN0IH5nZXRfZGF0YTpzbmQgbHN0XG47O1xuXG5sZXQgdG9fYWxpc3QgdCA9IGZvbGQgfmY6KGZ1biB+a2V5IH5kYXRhIGxpc3QgLT4gKGtleSwgZGF0YSkgOjogbGlzdCkgfmluaXQ6W10gdFxuXG5sZXQgc2V4cF9vZl90IHNleHBfb2Zfa2V5IHNleHBfb2ZfZGF0YSB0ID1cbiAgdFxuICB8PiB0b19hbGlzdFxuICB8PiBMaXN0LnNvcnQgfmNvbXBhcmU6KGZ1biAoazEsIF8pIChrMiwgXykgLT4gdC5oYXNoYWJsZS5jb21wYXJlIGsxIGsyKVxuICB8PiBzZXhwX29mX2xpc3QgKHNleHBfb2ZfcGFpciBzZXhwX29mX2tleSBzZXhwX29mX2RhdGEpXG47O1xuXG5sZXQgdF9vZl9zZXhwIH5oYXNoYWJsZSBrX29mX3NleHAgZF9vZl9zZXhwIHNleHAgPVxuICBsZXQgYWxpc3QgPSBsaXN0X29mX3NleHAgKHBhaXJfb2Zfc2V4cCBrX29mX3NleHAgZF9vZl9zZXhwKSBzZXhwIGluXG4gIG1hdGNoIG9mX2FsaXN0IH5oYXNoYWJsZSBhbGlzdCB+c2l6ZTooTGlzdC5sZW5ndGggYWxpc3QpIHdpdGhcbiAgfCBgT2sgdiAtPiB2XG4gIHwgYER1cGxpY2F0ZV9rZXkgayAtPlxuICAgICgqIGZpbmQgdGhlIHNleHAgb2YgYSBkdXBsaWNhdGUga2V5LCBzbyB0aGUgZXJyb3IgaXMgbmFycm93ZWQgdG8gYSBrZXkgYW5kIG5vdFxuICAgICAgIHRoZSB3aG9sZSBtYXAgKilcbiAgICBsZXQgYWxpc3Rfc2V4cHMgPSBsaXN0X29mX3NleHAgKHBhaXJfb2Zfc2V4cCBGbi5pZCBGbi5pZCkgc2V4cCBpblxuICAgIGxldCBmb3VuZF9maXJzdF9rID0gcmVmIGZhbHNlIGluXG4gICAgTGlzdC5pdGVyMl9leG4gYWxpc3QgYWxpc3Rfc2V4cHMgfmY6KGZ1biAoazIsIF8pIChrMl9zZXhwLCBfKSAtPlxuICAgICAgaWYgaGFzaGFibGUuY29tcGFyZSBrIGsyID0gMFxuICAgICAgdGhlblxuICAgICAgICBpZiAhZm91bmRfZmlyc3Rfa1xuICAgICAgICB0aGVuIG9mX3NleHBfZXJyb3IgXCJIYXNodGJsLnRfb2Zfc2V4cDogZHVwbGljYXRlIGtleVwiIGsyX3NleHBcbiAgICAgICAgZWxzZSBmb3VuZF9maXJzdF9rIDo9IHRydWUpO1xuICAgIGFzc2VydCBmYWxzZVxuOztcblxubGV0IHRfc2V4cF9ncmFtbWFyXG4gICAgICAodHlwZSBrIHYpXG4gICAgICAoa19ncmFtbWFyIDogayBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICAgICh2X2dyYW1tYXIgOiB2IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA6IChrLCB2KSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoTGlzdC5Bc3NvYy50X3NleHBfZ3JhbW1hciBrX2dyYW1tYXIgdl9ncmFtbWFyKVxuOztcblxubGV0IGtleXMgdCA9IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGE6XyBhY2MgLT4ga2V5IDo6IGFjYylcbmxldCBkYXRhIHQgPSBmb2xkIH5mOihmdW4gfmtleTpfIH5kYXRhIGxpc3QgLT4gZGF0YSA6OiBsaXN0KSB+aW5pdDpbXSB0XG5cbmxldCBhZGRfdG9fZ3JvdXBzIGdyb3VwcyB+Z2V0X2tleSB+Z2V0X2RhdGEgfmNvbWJpbmUgfnJvd3MgPVxuICBMaXN0Lml0ZXIgcm93cyB+ZjooZnVuIHJvdyAtPlxuICAgIGxldCBrZXkgPSBnZXRfa2V5IHJvdyBpblxuICAgIGxldCBkYXRhID0gZ2V0X2RhdGEgcm93IGluXG4gICAgbGV0IGRhdGEgPVxuICAgICAgbWF0Y2ggZmluZCBncm91cHMga2V5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBkYXRhXG4gICAgICB8IFNvbWUgb2xkIC0+IGNvbWJpbmUgb2xkIGRhdGFcbiAgICBpblxuICAgIHNldCBncm91cHMgfmtleSB+ZGF0YSlcbjs7XG5cbmxldCBncm91cCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSByb3dzID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlICgpIGluXG4gIGFkZF90b19ncm91cHMgcmVzIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSB+cm93cztcbiAgcmVzXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cyA9XG4gIGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSB+Z2V0X2RhdGE6Rm4uaWQgcm93c1xuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IHJvd3MgPVxuICBtYXRjaCBjcmVhdGVfd2l0aF9rZXkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSByb3dzIHdpdGhcbiAgfCBgT2sgdCAtPiBSZXN1bHQuT2sgdFxuICB8IGBEdXBsaWNhdGVfa2V5cyBrZXlzIC0+XG4gICAgbGV0IHNleHBfb2Zfa2V5ID0gaGFzaGFibGUuSGFzaGFibGUuc2V4cF9vZl90IGluXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJIYXNodGJsLmNyZWF0ZV93aXRoX2tleTogZHVwbGljYXRlIGtleXNcIlxuICAgICAgICAgWyBcImtleXNcIiwgc2V4cF9vZl9saXN0IHNleHBfb2Zfa2V5IGtleXMgXSlcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXlfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cyA9XG4gIE9yX2Vycm9yLm9rX2V4biAoY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cylcbjs7XG5cbmxldCBtZXJnZSA9XG4gIGxldCBtYXliZV9zZXQgdCB+a2V5IH5mIGQgPVxuICAgIG1hdGNoIGYgfmtleSBkIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgdiAtPiBzZXQgdCB+a2V5IH5kYXRhOnZcbiAgaW5cbiAgZnVuIHRfbGVmdCB0X3JpZ2h0IH5mIC0+XG4gICAgaWYgbm90IChIYXNoYWJsZS5lcXVhbCB0X2xlZnQuaGFzaGFibGUgdF9yaWdodC5oYXNoYWJsZSlcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiSGFzaHRibC5tZXJnZTogZGlmZmVyZW50ICdoYXNoYWJsZScgdmFsdWVzXCI7XG4gICAgbGV0IG5ld190ID1cbiAgICAgIGNyZWF0ZVxuICAgICAgICB+Z3Jvd3RoX2FsbG93ZWQ6dF9sZWZ0Lmdyb3d0aF9hbGxvd2VkXG4gICAgICAgIH5oYXNoYWJsZTp0X2xlZnQuaGFzaGFibGVcbiAgICAgICAgfnNpemU6dF9sZWZ0Lmxlbmd0aFxuICAgICAgICAoKVxuICAgIGluXG4gICAgd2l0aG91dF9tdXRhdGluZyB0X2xlZnQgKGZ1biAoKSAtPlxuICAgICAgd2l0aG91dF9tdXRhdGluZyB0X3JpZ2h0IChmdW4gKCkgLT5cbiAgICAgICAgaXRlcmkgdF9sZWZ0IH5mOihmdW4gfmtleSB+ZGF0YTpsZWZ0IC0+XG4gICAgICAgICAgbWF0Y2ggZmluZCB0X3JpZ2h0IGtleSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IG1heWJlX3NldCBuZXdfdCB+a2V5IH5mIChgTGVmdCBsZWZ0KVxuICAgICAgICAgIHwgU29tZSByaWdodCAtPiBtYXliZV9zZXQgbmV3X3QgfmtleSB+ZiAoYEJvdGggKGxlZnQsIHJpZ2h0KSkpO1xuICAgICAgICBpdGVyaSB0X3JpZ2h0IH5mOihmdW4gfmtleSB+ZGF0YTpyaWdodCAtPlxuICAgICAgICAgIG1hdGNoIGZpbmQgdF9sZWZ0IGtleSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IG1heWJlX3NldCBuZXdfdCB+a2V5IH5mIChgUmlnaHQgcmlnaHQpXG4gICAgICAgICAgfCBTb21lIF8gLT4gKClcbiAgICAgICAgICAoKiBhbHJlYWR5IGRvbmUgYWJvdmUgKikpKSk7XG4gICAgbmV3X3Rcbjs7XG5cbmxldCBtZXJnZV9pbnRvIH5zcmMgfmRzdCB+ZiA9XG4gIGl0ZXJpIHNyYyB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICBsZXQgZHN0X2RhdGEgPSBmaW5kIGRzdCBrZXkgaW5cbiAgICBsZXQgYWN0aW9uID0gd2l0aG91dF9tdXRhdGluZyBkc3QgKGZ1biAoKSAtPiBmIH5rZXkgZGF0YSBkc3RfZGF0YSkgaW5cbiAgICBtYXRjaCAoYWN0aW9uIDogXyBNZXJnZV9pbnRvX2FjdGlvbi50KSB3aXRoXG4gICAgfCBSZW1vdmUgLT4gcmVtb3ZlIGRzdCBrZXlcbiAgICB8IFNldF90byBkYXRhIC0+XG4gICAgICAobWF0Y2ggZHN0X2RhdGEgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBzZXQgZHN0IH5rZXkgfmRhdGFcbiAgICAgICB8IFNvbWUgZHN0X2RhdGEgLT4gaWYgbm90IChwaHlzX2VxdWFsIGRzdF9kYXRhIGRhdGEpIHRoZW4gc2V0IGRzdCB+a2V5IH5kYXRhKSlcbjs7XG5cbmxldCBmaWx0ZXJpX2lucGxhY2UgdCB+ZiA9XG4gIGxldCB0b19yZW1vdmUgPVxuICAgIGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgYWMgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gYWMgZWxzZSBrZXkgOjogYWMpXG4gIGluXG4gIExpc3QuaXRlciB0b19yZW1vdmUgfmY6KGZ1biBrZXkgLT4gcmVtb3ZlIHQga2V5KVxuOztcblxubGV0IGZpbHRlcl9pbnBsYWNlIHQgfmYgPSBmaWx0ZXJpX2lucGxhY2UgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5sZXQgZmlsdGVyX2tleXNfaW5wbGFjZSB0IH5mID0gZmlsdGVyaV9pbnBsYWNlIHQgfmY6KGZ1biB+a2V5IH5kYXRhOl8gLT4gZiBrZXkpXG5cbmxldCBmaWx0ZXJfbWFwaV9pbnBsYWNlIHQgfmYgPVxuICBsZXQgbWFwX3Jlc3VsdHMgPSBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhIGFjIC0+IChrZXksIGYgfmtleSB+ZGF0YSkgOjogYWMpIGluXG4gIExpc3QuaXRlciBtYXBfcmVzdWx0cyB+ZjooZnVuIChrZXksIHJlc3VsdCkgLT5cbiAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgIHwgTm9uZSAtPiByZW1vdmUgdCBrZXlcbiAgICB8IFNvbWUgZGF0YSAtPiBzZXQgdCB+a2V5IH5kYXRhKVxuOztcblxubGV0IGZpbHRlcl9tYXBfaW5wbGFjZSB0IH5mID0gZmlsdGVyX21hcGlfaW5wbGFjZSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcblxubGV0IG1hcGlfaW5wbGFjZSB0IH5mID1cbiAgZW5zdXJlX211dGF0aW9uX2FsbG93ZWQgdDtcbiAgd2l0aG91dF9tdXRhdGluZyB0IChmdW4gKCkgLT4gQXJyYXkuaXRlciB0LnRhYmxlIH5mOihBdmx0cmVlLm1hcGlfaW5wbGFjZSB+ZikpXG47O1xuXG5sZXQgbWFwX2lucGxhY2UgdCB+ZiA9IG1hcGlfaW5wbGFjZSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcblxubGV0IGVxdWFsIGVxdWFsIHQgdCcgPVxuICBsZW5ndGggdCA9IGxlbmd0aCB0J1xuICAmJiB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICB3aXRob3V0X211dGF0aW5nIHQnIChmdW4gKCkgLT5cbiAgICAgIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgICAgIG1hdGNoIGZpbmQgdCcga2V5IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHIucmV0dXJuIGZhbHNlXG4gICAgICAgIHwgU29tZSBkYXRhJyAtPiBpZiBub3QgKGVxdWFsIGRhdGEgZGF0YScpIHRoZW4gci5yZXR1cm4gZmFsc2UpKTtcbiAgICB0cnVlKVxuOztcblxubGV0IHNpbWlsYXIgPSBlcXVhbFxuXG5tb2R1bGUgQWNjZXNzb3JzID0gc3RydWN0XG4gIGxldCBpbnZhcmlhbnQgPSBpbnZhcmlhbnRcbiAgbGV0IGNob29zZSA9IGNob29zZVxuICBsZXQgY2hvb3NlX2V4biA9IGNob29zZV9leG5cbiAgbGV0IGNsZWFyID0gY2xlYXJcbiAgbGV0IGNvcHkgPSBjb3B5XG4gIGxldCByZW1vdmUgPSByZW1vdmVcbiAgbGV0IHNldCA9IHNldFxuICBsZXQgYWRkID0gYWRkXG4gIGxldCBhZGRfZXhuID0gYWRkX2V4blxuICBsZXQgY2hhbmdlID0gY2hhbmdlXG4gIGxldCB1cGRhdGUgPSB1cGRhdGVcbiAgbGV0IHVwZGF0ZV9hbmRfcmV0dXJuID0gdXBkYXRlX2FuZF9yZXR1cm5cbiAgbGV0IGFkZF9tdWx0aSA9IGFkZF9tdWx0aVxuICBsZXQgcmVtb3ZlX211bHRpID0gcmVtb3ZlX211bHRpXG4gIGxldCBmaW5kX211bHRpID0gZmluZF9tdWx0aVxuICBsZXQgbWVtID0gbWVtXG4gIGxldCBpdGVyX2tleXMgPSBpdGVyX2tleXNcbiAgbGV0IGl0ZXIgPSBpdGVyXG4gIGxldCBpdGVyaSA9IGl0ZXJpXG4gIGxldCBleGlzdHMgPSBleGlzdHNcbiAgbGV0IGV4aXN0c2kgPSBleGlzdHNpXG4gIGxldCBmb3JfYWxsID0gZm9yX2FsbFxuICBsZXQgZm9yX2FsbGkgPSBmb3JfYWxsaVxuICBsZXQgY291bnQgPSBjb3VudFxuICBsZXQgY291bnRpID0gY291bnRpXG4gIGxldCBmb2xkID0gZm9sZFxuICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gIGxldCBpc19lbXB0eSA9IGlzX2VtcHR5XG4gIGxldCBtYXAgPSBtYXBcbiAgbGV0IG1hcGkgPSBtYXBpXG4gIGxldCBmaWx0ZXJfbWFwID0gZmlsdGVyX21hcFxuICBsZXQgZmlsdGVyX21hcGkgPSBmaWx0ZXJfbWFwaVxuICBsZXQgZmlsdGVyX2tleXMgPSBmaWx0ZXJfa2V5c1xuICBsZXQgZmlsdGVyID0gZmlsdGVyXG4gIGxldCBmaWx0ZXJpID0gZmlsdGVyaVxuICBsZXQgcGFydGl0aW9uX21hcCA9IHBhcnRpdGlvbl9tYXBcbiAgbGV0IHBhcnRpdGlvbl9tYXBpID0gcGFydGl0aW9uX21hcGlcbiAgbGV0IHBhcnRpdGlvbl90ZiA9IHBhcnRpdGlvbl90ZlxuICBsZXQgcGFydGl0aW9uaV90ZiA9IHBhcnRpdGlvbmlfdGZcbiAgbGV0IGZpbmRfb3JfYWRkID0gZmluZF9vcl9hZGRcbiAgbGV0IGZpbmRpX29yX2FkZCA9IGZpbmRpX29yX2FkZFxuICBsZXQgZmluZCA9IGZpbmRcbiAgbGV0IGZpbmRfZXhuID0gZmluZF9leG5cbiAgbGV0IGZpbmRfYW5kX2NhbGwgPSBmaW5kX2FuZF9jYWxsXG4gIGxldCBmaW5kX2FuZF9jYWxsMSA9IGZpbmRfYW5kX2NhbGwxXG4gIGxldCBmaW5kX2FuZF9jYWxsMiA9IGZpbmRfYW5kX2NhbGwyXG4gIGxldCBmaW5kaV9hbmRfY2FsbCA9IGZpbmRpX2FuZF9jYWxsXG4gIGxldCBmaW5kaV9hbmRfY2FsbDEgPSBmaW5kaV9hbmRfY2FsbDFcbiAgbGV0IGZpbmRpX2FuZF9jYWxsMiA9IGZpbmRpX2FuZF9jYWxsMlxuICBsZXQgZmluZF9hbmRfcmVtb3ZlID0gZmluZF9hbmRfcmVtb3ZlXG4gIGxldCB0b19hbGlzdCA9IHRvX2FsaXN0XG4gIGxldCBtZXJnZSA9IG1lcmdlXG4gIGxldCBtZXJnZV9pbnRvID0gbWVyZ2VfaW50b1xuICBsZXQga2V5cyA9IGtleXNcbiAgbGV0IGRhdGEgPSBkYXRhXG4gIGxldCBmaWx0ZXJfa2V5c19pbnBsYWNlID0gZmlsdGVyX2tleXNfaW5wbGFjZVxuICBsZXQgZmlsdGVyX2lucGxhY2UgPSBmaWx0ZXJfaW5wbGFjZVxuICBsZXQgZmlsdGVyaV9pbnBsYWNlID0gZmlsdGVyaV9pbnBsYWNlXG4gIGxldCBtYXBfaW5wbGFjZSA9IG1hcF9pbnBsYWNlXG4gIGxldCBtYXBpX2lucGxhY2UgPSBtYXBpX2lucGxhY2VcbiAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSA9IGZpbHRlcl9tYXBfaW5wbGFjZVxuICBsZXQgZmlsdGVyX21hcGlfaW5wbGFjZSA9IGZpbHRlcl9tYXBpX2lucGxhY2VcbiAgbGV0IGVxdWFsID0gZXF1YWxcbiAgbGV0IHNpbWlsYXIgPSBzaW1pbGFyXG4gIGxldCBpbmNyID0gaW5jclxuICBsZXQgZGVjciA9IGRlY3JcbiAgbGV0IHNleHBfb2Zfa2V5ID0gc2V4cF9vZl9rZXlcbmVuZFxuXG5tb2R1bGUgQ3JlYXRvcnMgKEtleSA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGhhc2hhYmxlIDogJ2EgdCBIYXNoYWJsZS50XG4gIGVuZCkgOiBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XyA9ICgnYSBLZXkudCwgJ2IpIHRcblxuICB2YWwgdF9vZl9zZXhwIDogKFNleHAudCAtPiAnYSBLZXkudCkgLT4gKFNleHAudCAtPiAnYikgLT4gU2V4cC50IC0+ICgnYSwgJ2IpIHRfXG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzX2dlbmVyaWNcbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0X1xuICAgIHdpdGggdHlwZSAnYSBrZXkgOj0gJ2EgS2V5LnRcbiAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCAnYSkgY3JlYXRlX29wdGlvbnMgOj1cbiAgICAgICgna2V5LCAnZGF0YSwgJ2EpIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlXG5lbmQgPSBzdHJ1Y3RcbiAgbGV0IGhhc2hhYmxlID0gS2V5Lmhhc2hhYmxlXG5cbiAgdHlwZSAoJ2EsICdiKSB0XyA9ICgnYSBLZXkudCwgJ2IpIHRcblxuICBsZXQgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoKSA9IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlICgpXG4gIGxldCBvZl9hbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9IG9mX2FsaXN0ID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuXG4gIGxldCBvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMgP2dyb3d0aF9hbGxvd2VkID9zaXplIGwgPVxuICAgIG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIGxcbiAgOztcblxuICBsZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIGwgPVxuICAgIG9mX2FsaXN0X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9leG4gP2dyb3d0aF9hbGxvd2VkID9zaXplIGwgPVxuICAgIG9mX2FsaXN0X2V4biA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIGxcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIGtfb2Zfc2V4cCBkX29mX3NleHAgc2V4cCA9IHRfb2Zfc2V4cCB+aGFzaGFibGUga19vZl9zZXhwIGRfb2Zfc2V4cCBzZXhwXG5cbiAgbGV0IG9mX2FsaXN0X211bHRpID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID1cbiAgICBvZl9hbGlzdF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIGxcbiAgOztcblxuICBsZXQgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIGwgPVxuICAgIGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSB+Z2V0X2tleSB+Z2V0X2RhdGEgbFxuICA7O1xuXG4gIGxldCBjcmVhdGVfd2l0aF9rZXkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IGwgPVxuICAgIGNyZWF0ZV93aXRoX2tleSA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IGxcbiAgOztcblxuICBsZXQgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsID1cbiAgICBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSB+Z2V0X2tleSBsXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV93aXRoX2tleV9leG4gP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IGwgPVxuICAgIGNyZWF0ZV93aXRoX2tleV9leG4gP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSB+Z2V0X2tleSBsXG4gIDs7XG5cbiAgbGV0IGdyb3VwID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSB+Z2V0X2RhdGEgfmNvbWJpbmUgbCA9XG4gICAgZ3JvdXAgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSB+Z2V0X2tleSB+Z2V0X2RhdGEgfmNvbWJpbmUgbFxuICA7O1xuZW5kXG5cbm1vZHVsZSBQb2x5ID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG4gIHR5cGUgJ2Ega2V5ID0gJ2FcblxuICBsZXQgaGFzaGFibGUgPSBIYXNoYWJsZS5wb2x5XG5cbiAgaW5jbHVkZSBDcmVhdG9ycyAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuXG4gICAgICBsZXQgaGFzaGFibGUgPSBoYXNoYWJsZVxuICAgIGVuZClcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBzZXhwX29mX3QgPSBzZXhwX29mX3RcbiAgbGV0IHRfc2V4cF9ncmFtbWFyID0gdF9zZXhwX2dyYW1tYXJcbmVuZFxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19nZW5lcmljID0gQ3JlYXRvcnNfZ2VuZXJpY1xuICBtb2R1bGUgdHlwZSBIYXNoYWJsZSA9IEhhc2hhYmxlLkhhc2hhYmxlXG5cbiAgdHlwZSBub25yZWMgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGUgPVxuICAgICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlXG5cbiAgbGV0IGhhc2hhYmxlIHQgPSB0Lmhhc2hhYmxlXG5lbmRcblxubGV0IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSA9XG4gIGNyZWF0ZSB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgKClcbjs7XG5cbmxldCBvZl9hbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgb2ZfYWxpc3Qgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbFxuOztcblxubGV0IG9mX2FsaXN0X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdF9vcl9lcnJvciB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbFxuOztcblxubGV0IG9mX2FsaXN0X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgb2ZfYWxpc3RfZXhuIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsXG47O1xuXG5sZXQgb2ZfYWxpc3RfbXVsdGkgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIG9mX2FsaXN0X211bHRpIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsXG47O1xuXG5sZXQgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSB+Z2V0X2tleSB+Z2V0X2RhdGEgbCA9XG4gIGNyZWF0ZV9tYXBwZWQgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSBsXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IGwgPVxuICBjcmVhdGVfd2l0aF9rZXkgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IGxcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gfmdldF9rZXkgbCA9XG4gIGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbFxuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleV9leG4gP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gfmdldF9rZXkgbCA9XG4gIGNyZWF0ZV93aXRoX2tleV9leG4gfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IGxcbjs7XG5cbmxldCBncm91cCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSB+Z2V0X2tleSB+Z2V0X2RhdGEgfmNvbWJpbmUgbCA9XG4gIGdyb3VwIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSB+Z2V0X2RhdGEgfmNvbWJpbmUgbFxuOztcblxubGV0IGhhc2hhYmxlX3MgdCA9IEhhc2hhYmxlLnRvX2tleSB0Lmhhc2hhYmxlXG5cbm1vZHVsZSBNIChLIDogVC5UKSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAndiB0ID0gKEsudCwgJ3YpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICBbQEBAZW5kXVxuXG4gIGluY2x1ZGUgS2V5LlMgd2l0aCB0eXBlIHQgOj0gdFxuZW5kXG5cbm1vZHVsZSB0eXBlIE1fc2V4cF9ncmFtbWFyID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9ncmFtbWFyXVxuXG4gIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIEVxdWFsX20gPSBzaWcgZW5kXG5cbmxldCBzZXhwX29mX21fX3QgKHR5cGUgaykgKG1vZHVsZSBLIDogU2V4cF9vZl9tIHdpdGggdHlwZSB0ID0gaykgc2V4cF9vZl92IHQgPVxuICBzZXhwX29mX3QgSy5zZXhwX29mX3Qgc2V4cF9vZl92IHRcbjs7XG5cbmxldCBtX190X29mX3NleHAgKHR5cGUgaykgKG1vZHVsZSBLIDogTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gaykgdl9vZl9zZXhwIHNleHAgPVxuICB0X29mX3NleHAgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgKG1vZHVsZSBLKSkgSy50X29mX3NleHAgdl9vZl9zZXhwIHNleHBcbjs7XG5cbmxldCBtX190X3NleHBfZ3JhbW1hciAodHlwZSBrKSAobW9kdWxlIEsgOiBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9IGspIHZfZ3JhbW1hciA9XG4gIHRfc2V4cF9ncmFtbWFyIEsudF9zZXhwX2dyYW1tYXIgdl9ncmFtbWFyXG47O1xuXG5sZXQgZXF1YWxfbV9fdCAobW9kdWxlIF8gOiBFcXVhbF9tKSBlcXVhbF92IHQxIHQyID0gZXF1YWwgZXF1YWxfdiB0MSB0MlxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEhhc2hfc2V0X2ludGZcblxubGV0IGhhc2hhYmxlX3MgPSBIYXNodGJsLmhhc2hhYmxlX3NcbmxldCBoYXNoYWJsZSA9IEhhc2h0YmwuUHJpdmF0ZS5oYXNoYWJsZVxubGV0IHBvbHlfaGFzaGFibGUgPSBIYXNodGJsLlBvbHkuaGFzaGFibGVcbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5cbnR5cGUgJ2EgdCA9ICgnYSwgdW5pdCkgSGFzaHRibC50XG50eXBlICdhIGhhc2hfc2V0ID0gJ2EgdFxudHlwZSAnYSBlbHQgPSAnYVxuXG5tb2R1bGUgQWNjZXNzb3JzID0gc3RydWN0XG4gIGxldCBoYXNoYWJsZSA9IGhhc2hhYmxlXG4gIGxldCBjbGVhciA9IEhhc2h0YmwuY2xlYXJcbiAgbGV0IGxlbmd0aCA9IEhhc2h0YmwubGVuZ3RoXG4gIGxldCBtZW0gPSBIYXNodGJsLm1lbVxuICBsZXQgaXNfZW1wdHkgdCA9IEhhc2h0YmwuaXNfZW1wdHkgdFxuXG4gIGxldCBmaW5kX21hcCB0IH5mID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgIEhhc2h0YmwuaXRlcl9rZXlzIHQgfmY6KGZ1biBlbHQgLT5cbiAgICAgICAgbWF0Y2ggZiBlbHQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgfCBTb21lIF8gYXMgbyAtPiByLnJldHVybiBvKTtcbiAgICAgIE5vbmUpXG4gIDs7XG5cbiAgbGV0IGZpbmQgdCB+ZiA9IGZpbmRfbWFwIHQgfmY6KGZ1biBhIC0+IGlmIGYgYSB0aGVuIFNvbWUgYSBlbHNlIE5vbmUpXG4gIGxldCBhZGQgdCBrID0gSGFzaHRibC5zZXQgdCB+a2V5OmsgfmRhdGE6KClcblxuICBsZXQgc3RyaWN0X2FkZCB0IGsgPVxuICAgIGlmIG1lbSB0IGtcbiAgICB0aGVuIE9yX2Vycm9yLmVycm9yX3N0cmluZyBcImVsZW1lbnQgYWxyZWFkeSBleGlzdHNcIlxuICAgIGVsc2UgKFxuICAgICAgSGFzaHRibC5zZXQgdCB+a2V5OmsgfmRhdGE6KCk7XG4gICAgICBSZXN1bHQuT2sgKCkpXG4gIDs7XG5cbiAgbGV0IHN0cmljdF9hZGRfZXhuIHQgayA9IE9yX2Vycm9yLm9rX2V4biAoc3RyaWN0X2FkZCB0IGspXG4gIGxldCByZW1vdmUgPSBIYXNodGJsLnJlbW92ZVxuXG4gIGxldCBzdHJpY3RfcmVtb3ZlIHQgayA9XG4gICAgaWYgbWVtIHQga1xuICAgIHRoZW4gKFxuICAgICAgcmVtb3ZlIHQgaztcbiAgICAgIFJlc3VsdC5PayAoKSlcbiAgICBlbHNlIE9yX2Vycm9yLmVycm9yIFwiZWxlbWVudCBub3QgaW4gc2V0XCIgayAoSGFzaHRibC5zZXhwX29mX2tleSB0KVxuICA7O1xuXG4gIGxldCBzdHJpY3RfcmVtb3ZlX2V4biB0IGsgPSBPcl9lcnJvci5va19leG4gKHN0cmljdF9yZW1vdmUgdCBrKVxuICBsZXQgZm9sZCB0IH5pbml0IH5mID0gSGFzaHRibC5mb2xkIHQgfmluaXQgfmY6KGZ1biB+a2V5IH5kYXRhOigpIGFjYyAtPiBmIGFjYyBrZXkpXG4gIGxldCBpdGVyIHQgfmYgPSBIYXNodGJsLml0ZXJfa2V5cyB0IH5mXG4gIGxldCBjb3VudCB0IH5mID0gQ29udGFpbmVyLmNvdW50IH5mb2xkIHQgfmZcbiAgbGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxuICBsZXQgbWluX2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuICBsZXQgbWF4X2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuICBsZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB0XG4gIGxldCB0b19saXN0ID0gSGFzaHRibC5rZXlzXG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2UgdCA9XG4gICAgc2V4cF9vZl9saXN0IHNleHBfb2ZfZSAodG9fbGlzdCB0IHw+IExpc3Quc29ydCB+Y29tcGFyZTooaGFzaGFibGUgdCkuY29tcGFyZSlcbiAgOztcblxuICBsZXQgdG9fYXJyYXkgdCA9XG4gICAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gICAgbGV0IGluZGV4ID0gcmVmIChsZW4gLSAxKSBpblxuICAgIGZvbGQgdCB+aW5pdDpbfHxdIH5mOihmdW4gYWNjIGtleSAtPlxuICAgICAgaWYgQXJyYXkubGVuZ3RoIGFjYyA9IDBcbiAgICAgIHRoZW4gQXJyYXkuY3JlYXRlIH5sZW4ga2V5XG4gICAgICBlbHNlIChcbiAgICAgICAgaW5kZXggOj0gIWluZGV4IC0gMTtcbiAgICAgICAgYWNjLighaW5kZXgpIDwtIGtleTtcbiAgICAgICAgYWNjKSlcbiAgOztcblxuICBsZXQgZXhpc3RzIHQgfmYgPSBIYXNodGJsLmV4aXN0c2kgdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gZiBrZXkpXG4gIGxldCBmb3JfYWxsIHQgfmYgPSBub3QgKEhhc2h0YmwuZXhpc3RzaSB0IH5mOihmdW4gfmtleSB+ZGF0YTooKSAtPiBub3QgKGYga2V5KSkpXG4gIGxldCBlcXVhbCB0MSB0MiA9IEhhc2h0YmwuZXF1YWwgKGZ1biAoKSAoKSAtPiB0cnVlKSB0MSB0MlxuICBsZXQgY29weSB0ID0gSGFzaHRibC5jb3B5IHRcbiAgbGV0IGZpbHRlciB0IH5mID0gSGFzaHRibC5maWx0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOigpIC0+IGYga2V5KVxuICBsZXQgdW5pb24gdDEgdDIgPSBIYXNodGJsLm1lcmdlIHQxIHQyIH5mOihmdW4gfmtleTpfIF8gLT4gU29tZSAoKSlcbiAgbGV0IGRpZmYgdDEgdDIgPSBmaWx0ZXIgdDEgfmY6KGZ1biBrZXkgLT4gbm90IChIYXNodGJsLm1lbSB0MiBrZXkpKVxuXG4gIGxldCBpbnRlciB0MSB0MiA9XG4gICAgbGV0IHNtYWxsZXIsIGxhcmdlciA9IGlmIGxlbmd0aCB0MSA+IGxlbmd0aCB0MiB0aGVuIHQyLCB0MSBlbHNlIHQxLCB0MiBpblxuICAgIEhhc2h0YmwuZmlsdGVyaSBzbWFsbGVyIH5mOihmdW4gfmtleSB+ZGF0YTooKSAtPiBIYXNodGJsLm1lbSBsYXJnZXIga2V5KVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfaW5wbGFjZSB0IH5mID1cbiAgICBsZXQgdG9fcmVtb3ZlID0gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gYWMgeCAtPiBpZiBmIHggdGhlbiBhYyBlbHNlIHggOjogYWMpIGluXG4gICAgTGlzdC5pdGVyIHRvX3JlbW92ZSB+ZjooZnVuIHggLT4gcmVtb3ZlIHQgeClcbiAgOztcblxuICBsZXQgb2ZfaGFzaHRibF9rZXlzIGhhc2h0YmwgPSBIYXNodGJsLm1hcCBoYXNodGJsIH5mOmlnbm9yZVxuICBsZXQgdG9faGFzaHRibCB0IH5mID0gSGFzaHRibC5tYXBpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOigpIC0+IGYga2V5KVxuZW5kXG5cbmluY2x1ZGUgQWNjZXNzb3JzXG5cbmxldCBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gPSBIYXNodGJsLmNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbVxuXG5sZXQgb2ZfbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgbGV0IHNpemUgPVxuICAgIG1hdGNoIHNpemUgd2l0aFxuICAgIHwgU29tZSB4IC0+IHhcbiAgICB8IE5vbmUgLT4gTGlzdC5sZW5ndGggbFxuICBpblxuICBsZXQgdCA9IEhhc2h0YmwuY3JlYXRlID9ncm93dGhfYWxsb3dlZCB+c2l6ZSBtIGluXG4gIExpc3QuaXRlciBsIH5mOihmdW4gayAtPiBhZGQgdCBrKTtcbiAgdFxuOztcblxubGV0IHRfb2Zfc2V4cCBtIGVfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgU2V4cC5BdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcIkhhc2hfc2V0LnRfb2Zfc2V4cCByZXF1aXJlcyBhIGxpc3RcIiBzZXhwXG4gIHwgU2V4cC5MaXN0IGxpc3QgLT5cbiAgICBsZXQgdCA9IGNyZWF0ZSBtIH5zaXplOihMaXN0Lmxlbmd0aCBsaXN0KSBpblxuICAgIExpc3QuaXRlciBsaXN0IH5mOihmdW4gc2V4cCAtPlxuICAgICAgbGV0IGUgPSBlX29mX3NleHAgc2V4cCBpblxuICAgICAgbWF0Y2ggc3RyaWN0X2FkZCB0IGUgd2l0aFxuICAgICAgfCBPayAoKSAtPiAoKVxuICAgICAgfCBFcnJvciBfIC0+IG9mX3NleHBfZXJyb3IgXCJIYXNoX3NldC50X29mX3NleHAgZ290IGEgZHVwbGljYXRlIGVsZW1lbnRcIiBzZXhwKTtcbiAgICB0XG47O1xuXG5tb2R1bGUgQ3JlYXRvcnMgKEVsdCA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGhhc2hhYmxlIDogJ2EgdCBIYXNoYWJsZS50XG4gIGVuZCkgOiBzaWdcbiAgdmFsIHRfb2Zfc2V4cCA6IChTZXhwLnQgLT4gJ2EgRWx0LnQpIC0+IFNleHAudCAtPiAnYSBFbHQudCB0XG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzX2dlbmVyaWNcbiAgICB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBFbHQudCB0XG4gICAgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBFbHQudFxuICAgIHdpdGggdHlwZSAoJ2VsdCwgJ3opIGNyZWF0ZV9vcHRpb25zIDo9XG4gICAgICAoJ2VsdCwgJ3opIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlXG5lbmQgPSBzdHJ1Y3RcbiAgbGV0IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgKCkgPVxuICAgIGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgKEhhc2hhYmxlLnRvX2tleSBFbHQuaGFzaGFibGUpXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIGwgPVxuICAgIG9mX2xpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIChIYXNoYWJsZS50b19rZXkgRWx0Lmhhc2hhYmxlKSBsXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCBlX29mX3NleHAgc2V4cCA9IHRfb2Zfc2V4cCAoSGFzaGFibGUudG9fa2V5IEVsdC5oYXNoYWJsZSkgZV9vZl9zZXhwIHNleHBcbmVuZFxuXG5tb2R1bGUgUG9seSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBoYXNoX3NldFxuICB0eXBlICdhIGVsdCA9ICdhXG5cbiAgbGV0IGhhc2hhYmxlID0gcG9seV9oYXNoYWJsZVxuXG4gIGluY2x1ZGUgQ3JlYXRvcnMgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcblxuICAgICAgbGV0IGhhc2hhYmxlID0gaGFzaGFibGVcbiAgICBlbmQpXG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnNcblxuICBsZXQgc2V4cF9vZl90ID0gc2V4cF9vZl90XG4gIGxldCB0X3NleHBfZ3JhbW1hciBncmFtbWFyID0gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoTGlzdC50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuZW5kXG5cbm1vZHVsZSBNIChFbHQgOiBULlQpID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSBFbHQudCB0XG5lbmRcblxubGV0IHNleHBfb2ZfbV9fdCAodHlwZSBlbHQpIChtb2R1bGUgRWx0IDogU2V4cF9vZl9tIHdpdGggdHlwZSB0ID0gZWx0KSB0ID1cbiAgc2V4cF9vZl90IEVsdC5zZXhwX29mX3QgdFxuOztcblxubGV0IG1fX3Rfb2Zfc2V4cCAodHlwZSBlbHQpIChtb2R1bGUgRWx0IDogTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gZWx0KSBzZXhwID1cbiAgdF9vZl9zZXhwIChtb2R1bGUgRWx0KSBFbHQudF9vZl9zZXhwIHNleHBcbjs7XG5cbmxldCBtX190X3NleHBfZ3JhbW1hciAodHlwZSBlbHQpIChtb2R1bGUgRWx0IDogTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSBlbHQpID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAobGlzdF9zZXhwX2dyYW1tYXIgRWx0LnRfc2V4cF9ncmFtbWFyKVxuOztcblxubGV0IGVxdWFsX21fX3QgKG1vZHVsZSBfIDogRXF1YWxfbSkgdDEgdDIgPSBlcXVhbCB0MSB0MlxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgaGFzaGFibGUgPSBIYXNodGJsLlByaXZhdGUuaGFzaGFibGVcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5vcGVuISBQcmludGZcbm1vZHVsZSBCeXRlcyA9IEJ5dGVzMFxuaW5jbHVkZSBGbG9hdDBcblxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGZsb2F0IFtAQGRlcml2aW5nX2lubGluZSBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9mbG9hdFxuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfZmxvYXQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKGZsb2F0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2Zsb2F0IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGZsb2F0X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgY29tcGFyZSA9IEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCB0b19mbG9hdCB4ID0geFxubGV0IG9mX2Zsb2F0IHggPSB4XG5cbmxldCBvZl9zdHJpbmcgcyA9XG4gIHRyeSBmbG9hdF9vZl9zdHJpbmcgcyB3aXRoXG4gIHwgXyAtPiBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5vZl9zdHJpbmcgJXNcIiBzICgpXG47O1xuXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQgOiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5cbigqIFN0b2xlbiBmcm9tIFtwZXJ2YXNpdmVzLm1sXS4gIEFkZHMgYSBcIi5cIiBhdCB0aGUgZW5kIGlmIG5lZWRlZC4gIEl0IGlzIGluXG4gICBbcGVydmFzaXZlcy5tbGldLCBidXQgaXQgYWxzbyBzYXlzIG5vdCB0byB1c2UgaXQgZGlyZWN0bHksIHNvIHdlIGNvcHkgYW5kIHBhc3RlIHRoZVxuICAgY29kZS4gSXQgbWFrZXMgdGhlIGFzc3VtcHRpb24gb24gdGhlIHN0cmluZyBwYXNzZWQgaW4gYXJndW1lbnQgdGhhdCBpdCB3YXMgcmV0dXJuZWQgYnlcbiAgIFtmb3JtYXRfZmxvYXRdLiAqKVxubGV0IHZhbGlkX2Zsb2F0X2xleGVtIHMgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgaSBsXG4gICAgdGhlbiBzIF4gXCIuXCJcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBsb29wIChpICsgMSlcbiAgICAgIHwgXyAtPiBzKVxuICBpblxuICBsb29wIDBcbjs7XG5cbigqIExldCBbeV0gYmUgYSBwb3dlciBvZiAyLiAgVGhlbiB0aGUgbmV4dCByZXByZXNlbnRhYmxlIGZsb2F0IGlzOlxuICAgW3ogPSB5ICogKDEgKyAyICoqIC01MildXG4gICBhbmQgdGhlIHByZXZpb3VzIG9uZSBpc1xuICAgW3ggPSB5ICogKDEgLSAyICoqIC01MyldXG5cbiAgIEluIGdlbmVyYWwsIGV2ZXJ5IHR3byBhZGphY2VudCBmbG9hdHMgYXJlIHdpdGhpbiBhIGZhY3RvciBvZiBiZXR3ZWVuIFsxICsgMioqLTUzXVxuICAgYW5kIFsxICsgMioqLTUyXSBmcm9tIGVhY2ggb3RoZXIsIHRoYXQgaXMgd2l0aGluIFsxICsgMS4xZS0xNl0gYW5kIFsxICsgMi4zZS0xNl0uXG5cbiAgIFNvIGlmIHRoZSBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGEgZmxvYXQgc3RhcnRzIHdpdGggXCIxXCIsIHRoZW4gaXRzIGFkamFjZW50IGZsb2F0c1xuICAgd2lsbCB1c3VhbGx5IGRpZmZlciBmcm9tIGl0IGJ5IDEsIGFuZCBzb21ldGltZXMgYnkgMiwgYXQgdGhlIDE3dGggc2lnbmlmaWNhbnQgZGlnaXRcbiAgIChjb3VudGluZyBmcm9tIDEpLlxuXG4gICBPbiB0aGUgb3RoZXIgaGFuZCwgaWYgdGhlIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gc3RhcnRzIHdpdGggXCI5XCIsIHRoZW4gdGhlIGFkamFjZW50XG4gICBmbG9hdHMgd2lsbCBiZSBvZmYgYnkgbm8gbW9yZSB0aGFuIDIzIGF0IHRoZSAxNnRoIGFuZCAxN3RoIHNpZ25pZmljYW50IGRpZ2l0cy5cblxuICAgRS5nLjpcblxuICAge3ZcbiAgICAgIyBzcHJpbnRmIFwiJS4xN2dcIiAoMTAyNC4gKi4gKDEuIC0uIDIuKiogKC01My4pKSk7O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMTExMVxuICAgICAgICAgICAgICAgICAgIDEyMzQgNTY3ODkwMTIzNDU2N1xuICAgICAtIDogc3RyaW5nID0gXCIxMDIzLjk5OTk5OTk5OTk5OTlcIlxuICAgdn1cbiAgIFByaW50aW5nIGEgY291cGxlIG9mIGV4dHJhIGRpZ2l0cyByZXZlYWxzIHRoYXQgdGhlIGRpZmZlcmVuY2UgaW5kZWVkIGlzIHJvdWdobHkgMTEgYXRcbiAgIGRpZ2l0cyAxN3RoIGFuZCAxOHRoICh0aGF0IGlzLCAxM3RoIGFuZCAxNHRoIGFmdGVyIFwiLlwiKTpcblxuICAge3ZcbiAgICAgIyBzcHJpbnRmIFwiJS4xOWdcIiAoMTAyNC4gKi4gKDEuIC0uIDIuKiogKC01My4pKSk7O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMTExMTExXG4gICAgICAgICAgICAgICAgICAgMTIzNCA1Njc4OTAxMjM0NTY3ODlcbiAgICAgLSA6IHN0cmluZyA9IFwiMTAyMy45OTk5OTk5OTk5OTk4ODZcIlxuICAgdn1cblxuICAgVGhlIHVscCAodGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBhZGphY2VudCBmbG9hdHMpIGlzIHR3aWNlIGFzIGJpZyBvbiB0aGUgb3RoZXIgc2lkZSBvZlxuICAgMTAyNC46XG5cbiAgIHt2XG4gICAgICMgc3ByaW50ZiBcIiUuMTlnXCIgKDEwMjQuICouICgxLiArLiAyLioqICgtNTIuKSkpOztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTExMTExMVxuICAgICAgICAgICAgICAgICAgIDEyMzQgNTY3ODkwMTIzNDU2Nzg5XG4gICAgIC0gOiBzdHJpbmcgPSBcIjEwMjQuMDAwMDAwMDAwMDAwMjI3XCJcbiAgIHZ9XG5cbiAgIE5vdyB0YWtlIGEgcG93ZXIgb2YgMiB3aGljaCBzdGFydHMgd2l0aCA5OTpcblxuICAge3ZcbiAgICAgIyAyLioqOTMuIDs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExMTExMTFcbiAgICAgICAgICAgICAgICAgMSAyMzQ1Njc4OTAxMjM0NTY3OFxuICAgICAtIDogZmxvYXQgPSA5LjkwMzUyMDMxNDI4MzA0MjJlKzI3XG5cbiAgICAgIyAyLioqOTMuICouICgxLiArLiAyLioqICgtNTIuKSk7O1xuICAgICAtIDogZmxvYXQgPSA5LjkwMzUyMDMxNDI4MzA0NDRlKzI3XG5cbiAgICAgIyAyLioqOTMuICouICgxLiAtLiAyLioqICgtNTMuKSk7O1xuICAgICAtIDogZmxvYXQgPSA5LjkwMzUyMDMxNDI4MzA0MTFlKzI3XG4gICB2fVxuXG4gICBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIDIqKjkzIGFuZCBpdHMgdHdvIG5laWdoYm9ycyBpcyBzbGlnaHRseSBtb3JlIHRoYW4sIHJlc3BlY3RpdmVseSxcbiAgIDEgYW5kIDIgYXQgc2lnbmlmaWNhbnQgZGlnaXQgMTYuXG5cbiAgIFRob3NlIGV4YW1wbGVzIHNob3cgdGhhdDpcbiAgIC0gMTcgc2lnbmlmaWNhbnQgZGlnaXRzIGlzIGFsd2F5cyBzdWZmaWNpZW50IHRvIHJlcHJlc2VudCBhIGZsb2F0IHdpdGhvdXQgYW1iaWd1aXR5XG4gICAtIDE1dGggc2lnbmlmaWNhbnQgZGlnaXQgY2FuIGFsd2F5cyBiZSByZXByZXNlbnRlZCBhY2N1cmF0ZWx5XG4gICAtIGNvbnZlcnRpbmcgYSBkZWNpbWFsIG51bWJlciB3aXRoIDE2IHNpZ25pZmljYW50IGRpZ2l0cyB0byBpdHMgbmVhcmVzdCBmbG9hdCBhbmQgYmFja1xuICAgICBjYW4gY2hhbmdlIHRoZSBsYXN0IGRlY2ltYWwgZGlnaXQgYnkgbm8gbW9yZSB0aGFuIDFcblxuICAgVG8gbWFrZSBzdXJlIHRoYXQgZmxvYXRzIG9idGFpbmVkIGJ5IGNvbnZlcnNpb24gZnJvbSBkZWNpbWFsIGZyYWN0aW9ucyAoZS5nLiBcIjMuMTRcIilcbiAgIGFyZSBwcmludGVkIHdpdGhvdXQgdHJhaWxpbmcgbm9uLXplcm8gZGlnaXRzLCBvbmUgc2hvdWxkIGNob29zZSB0aGUgZmlyc3QgYW1vbmcgdGhlXG4gICAnJS4xNWcnLCAnJS4xNmcnLCBhbmQgJyUuMTdnJyByZXByZXNlbnRhdGlvbnMgd2hpY2ggZG9lcyByb3VuZC10cmlwOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE1Z1wiIDMuMTQ7O1xuICAgICAtIDogc3RyaW5nID0gXCIzLjE0XCIgICAgICAgICAgICAgICAgICAgICAoKiBwaWNrIHRoaXMgb25lICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTZnXCIgMy4xNDs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjMuMTRcIlxuICAgICAjIHNwcmludGYgXCIlLjE3Z1wiIDMuMTQ7O1xuICAgICAtIDogc3RyaW5nID0gXCIzLjE0MDAwMDAwMDAwMDAwMDFcIiAgICAgICAoKiBkbyBub3QgcGljayB0aGlzIG9uZSAqKVxuXG4gICAgICMgc3ByaW50ZiBcIiUuMTVnXCIgOC4wMDAwMDAwMDAwMDAwMDI7O1xuICAgICAtIDogc3RyaW5nID0gXCI4XCIgICAgICAgICAgICAgICAgICAgICAgICAoKiBkbyBub3QgcGljayB0aGlzIG9uZS0tZG9lcyBub3Qgcm91bmQtdHJpcCAqKVxuICAgICAjIHNwcmludGYgXCIlLjE2Z1wiIDguMDAwMDAwMDAwMDAwMDAyOztcbiAgICAgLSA6IHN0cmluZyA9IFwiOC4wMDAwMDAwMDAwMDAwMDJcIiAgICAgICAgKCogcHJlZmVyIHRoaXMgb25lICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTdnXCIgOC4wMDAwMDAwMDAwMDAwMDI7O1xuICAgICAtIDogc3RyaW5nID0gXCI4LjAwMDAwMDAwMDAwMDAwMThcIiAgICAgICAoKiB0aGlzIG9uZSBoYXMgb25lIGRpZ2l0IG9mIGp1bmsgYXQgdGhlIGVuZCAqKVxuICAgdn1cblxuICAgU2tpcHBpbmcgdGhlICclLjE2ZycgaW4gdGhlIGFib3ZlIHByb2NlZHVyZSBzYXZlcyB1cyBzb21lIHRpbWUsIGJ1dCBpdCBtZWFucyB0aGF0LCBhc1xuICAgc2VlbiBpbiB0aGUgc2Vjb25kIGV4YW1wbGUgYWJvdmUsIG9jY2FzaW9uYWxseSBudW1iZXJzIHdpdGggZXhhY3RseSAxNiBzaWduaWZpY2FudFxuICAgZGlnaXRzIHdpbGwgaGF2ZSBhbiBlcnJvciBpbnRyb2R1Y2VkIGF0IHRoZSAxN3RoIGRpZ2l0LiAgVGhhdCBpcyBwcm9iYWJseSBPSyBmb3JcbiAgIHR5cGljYWwgdXNlLCBiZWNhdXNlIGEgbnVtYmVyIHdpdGggMTYgc2lnbmlmaWNhbnQgZGlnaXRzIGlzIFwidWdseVwiIGFscmVhZHkuICBBZGRpbmcgb25lXG4gICBtb3JlIGRvZXNuJ3QgbWFrZSBpdCBtdWNoIHdvcnNlIGZvciBhIGh1bWFuIHJlYWRlci5cblxuICAgT24gdGhlIG90aGVyIGhhbmQsIHdlIGNhbm5vdCBza2lwICclLjE1ZycgYW5kIG9ubHkgbG9vayBhdCAnJS4xNmcnIGFuZCAnJS4xN2cnLCBzaW5jZVxuICAgdGhlIGluYWNjdXJhY3kgYXQgdGhlIDE2dGggZGlnaXQgbWlnaHQgaW50cm9kdWNlIHRoZSBub2lzZSB3ZSB3YW50IHRvIGF2b2lkOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE1Z1wiIDkuOTkyOztcbiAgICAgLSA6IHN0cmluZyA9IFwiOS45OTJcIiAgICAgICAgICAgICAgICAgICAgKCogcGljayB0aGlzIG9uZSAqKVxuICAgICAjIHNwcmludGYgXCIlLjE2Z1wiIDkuOTkyOztcbiAgICAgLSA6IHN0cmluZyA9IFwiOS45OTIwMDAwMDAwMDAwMDFcIiAgICAgICAgKCogZG8gbm90IHBpY2sgdGhpcyBvbmUtLWp1bmsgYXQgdGhlIGVuZCAqKVxuICAgICAjIHNwcmludGYgXCIlLjE3Z1wiIDkuOTkyOztcbiAgICAgLSA6IHN0cmluZyA9IFwiOS45OTIwMDAwMDAwMDAwMDA5XCJcbiAgIHZ9XG4qKVxubGV0IHRvX3N0cmluZyB4ID1cbiAgdmFsaWRfZmxvYXRfbGV4ZW1cbiAgICAobGV0IHkgPSBmb3JtYXRfZmxvYXQgXCIlLjE1Z1wiIHggaW5cbiAgICAgaWYgZmxvYXRfb2Zfc3RyaW5nIHkgPSB4IHRoZW4geSBlbHNlIGZvcm1hdF9mbG9hdCBcIiUuMTdnXCIgeClcbjs7XG5cbmxldCBtYXhfdmFsdWUgPSBpbmZpbml0eVxubGV0IG1pbl92YWx1ZSA9IG5lZ19pbmZpbml0eVxubGV0IG1pbl9wb3NpdGl2ZV9zdWJub3JtYWxfdmFsdWUgPSAyLiAqKiAtMTA3NC5cbmxldCBtaW5fcG9zaXRpdmVfbm9ybWFsX3ZhbHVlID0gMi4gKiogLTEwMjIuXG5sZXQgemVybyA9IDAuXG5sZXQgb25lID0gMS5cbmxldCBtaW51c19vbmUgPSAtMS5cbmxldCBwaSA9IDB4My4yNDNGNkE4ODg1QTMwOEQzMTMxOThBMkUwMzcwNzNcbmxldCBzcXJ0X3BpID0gMHgxLkM1QkY4OTFCNEVGNkFBNzlDM0IwNTIwRDVEQjkzOFxubGV0IHNxcnRfMnBpID0gMHgyLjgxQjI2M0ZFQzRFMEIyQ0FGOTQ4M0Y1Q0U0NTlEQ1xubGV0IGV1bGVyID0gMHgwLjkzQzQ2N0UzN0RCMEM3QTREMUJFM0Y4MTAxNTJDQlxubGV0IG9mX2ludCA9IEludC50b19mbG9hdFxubGV0IHRvX2ludCA9IEludC5vZl9mbG9hdFxubGV0IG9mX2ludDYzIGkgPSBJbnQ2My50b19mbG9hdCBpXG5sZXQgb2ZfaW50NjQgaSA9IENhbWwuSW50NjQudG9fZmxvYXQgaVxubGV0IHRvX2ludDY0ID0gQ2FtbC5JbnQ2NC5vZl9mbG9hdFxubGV0IGlyb3VuZF9sYm91bmQgPSBsb3dlcl9ib3VuZF9mb3JfaW50IEludC5udW1fYml0c1xubGV0IGlyb3VuZF91Ym91bmQgPSB1cHBlcl9ib3VuZF9mb3JfaW50IEludC5udW1fYml0c1xuXG4oKiBUaGUgcGVyZm9ybWFuY2Ugb2YgdGhlIFwiZXhuXCIgcm91bmRpbmcgZnVuY3Rpb25zIGlzIGltcG9ydGFudCwgc28gdGhleSBhcmUgd3JpdHRlblxuICAgb3V0IHNlcGFyYXRlbHksIGFuZCB0dW5lZCBpbmRpdmlkdWFsbHkuICAoV2UgY291bGQgaGF2ZSB0aGUgb3B0aW9uIHZlcnNpb25zIGNhbGxcbiAgIHRoZSBcImV4blwiIHZlcnNpb25zLCBidXQgdGhhdCBpbXBvc2VzIGFyZ3VhYmx5IGdyYXR1aXRvdXMgb3ZlcmhlYWQtLS1lc3BlY2lhbGx5XG4gICBpbiB0aGUgY2FzZSB3aGVyZSB0aGUgY2FwdHVyZSBvZiBiYWNrdHJhY2VzIGlzIGVuYWJsZWQgdXBvbiBcIndpdGhcIi0tLWFuZCB0aGF0IHNlZW1zXG4gICBub3Qgd29ydGggaXQgd2hlbiBjb21wYXJlZCB0byB0aGUgcmVsYXRpdmVseSBzbWFsbCBhbW91bnQgb2YgY29kZSBkdXBsaWNhdGlvbi4pICopXG5cbigqIEVycm9yIHJlcG9ydGluZyBiZWxvdyBpcyB2ZXJ5IGNhcmVmdWxseSBhcnJhbmdlZCBzbyB0aGF0LCBlLmcuLCBbaXJvdW5kX25lYXJlc3RfZXhuXVxuICAgaXRzZWxmIGNhbiBiZSBpbmxpbmVkIGludG8gY2FsbGVycyBzdWNoIHRoYXQgdGhleSBkb24ndCBuZWVkIHRvIGFsbG9jYXRlIGEgYm94IGZvciB0aGVcbiAgIFtmbG9hdF0gYXJndW1lbnQuICBUaGlzIGlzIGRvbmUgd2l0aCBhIGJveCBbYm94XSBmdW5jdGlvbiBjYXJlZnVsbHkgY2hvc2VuIHRvIGFsbG93IHRoZVxuICAgY29tcGlsZXIgdG8gY3JlYXRlIGEgc2VwYXJhdGUgYm94IGZvciB0aGUgZmxvYXQgb25seSBpbiBlcnJvciBjYXNlcy4gIFNlZSwgZS5nLixcbiAgIFsuLi8uLi96ZXJvL3Rlc3QvcHJpY2VfdGVzdC5tbF0gZm9yIGEgbWVjaGFuaWNhbCB0ZXN0IG9mIHRoaXMgcHJvcGVydHkgd2hlbiBidWlsZGluZ1xuICAgd2l0aCBbWF9MSUJSQVJZX0lOTElOSU5HPXRydWVdLiAqKVxuXG5sZXQgaXJvdW5kX3VwIHQgPVxuICBpZiB0ID4gMC4wXG4gIHRoZW4gKFxuICAgIGxldCB0JyA9IGNlaWwgdCBpblxuICAgIGlmIHQnIDw9IGlyb3VuZF91Ym91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnKSBlbHNlIE5vbmUpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gaXJvdW5kX3VwX2V4biB0ID1cbiAgaWYgdCA+IDAuMFxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBjZWlsIHQgaW5cbiAgICBpZiB0JyA8PSBpcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfdXBfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKCkpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX3VwX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCIgKGJveCB0KSAoKVxuOztcblxubGV0IGlyb3VuZF9kb3duIHQgPVxuICBpZiB0ID49IDAuMFxuICB0aGVuIGlmIHQgPD0gaXJvdW5kX3Vib3VuZCB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCkgZWxzZSBOb25lXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yIHQgaW5cbiAgICBpZiB0JyA+PSBpcm91bmRfbGJvdW5kIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0JykgZWxzZSBOb25lKVxuOztcblxubGV0W0BvY2FtbC5pbmxpbmUgYWx3YXlzXSBpcm91bmRfZG93bl9leG4gdCA9XG4gIGlmIHQgPj0gMC4wXG4gIHRoZW5cbiAgICBpZiB0IDw9IGlyb3VuZF91Ym91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKClcbiAgZWxzZSAoXG4gICAgbGV0IHQnID0gZmxvb3IgdCBpblxuICAgIGlmIHQnID49IGlyb3VuZF9sYm91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCdcbiAgICBlbHNlXG4gICAgICBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfZG93bl9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiIChib3ggdCkgKCkpXG47O1xuXG5sZXQgaXJvdW5kX3Rvd2FyZHNfemVybyB0ID1cbiAgaWYgdCA+PSBpcm91bmRfbGJvdW5kICYmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdClcbiAgZWxzZSBOb25lXG47O1xuXG5sZXRbQG9jYW1sLmlubGluZSBhbHdheXNdIGlyb3VuZF90b3dhcmRzX3plcm9fZXhuIHQgPVxuICBpZiB0ID49IGlyb3VuZF9sYm91bmQgJiYgdCA8PSBpcm91bmRfdWJvdW5kXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2VcbiAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgIFwiRmxvYXQuaXJvdW5kX3Rvd2FyZHNfemVyb19leG46IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoYm94IHQpXG4gICAgICAoKVxuOztcblxuKCogT3V0c2lkZSBvZiB0aGUgcmFuZ2UgKHJvdW5kX25lYXJlc3RfbGIuLnJvdW5kX25lYXJlc3RfdWIpLCBhbGwgcmVwcmVzZW50YWJsZSBkb3VibGVzXG4gICBhcmUgaW50ZWdlcnMgaW4gdGhlIG1hdGhlbWF0aWNhbCBzZW5zZSwgYW5kIFtyb3VuZF9uZWFyZXN0XSBzaG91bGQgYmUgaWRlbnRpdHkuXG5cbiAgIEhvd2V2ZXIsIGZvciBvZGQgbnVtYmVycyB3aXRoIHRoZSBhYnNvbHV0ZSB2YWx1ZSBiZXR3ZWVuIDIqKjUyIGFuZCAyKio1MywgdGhlIGZvcm11bGFcbiAgIFtyb3VuZF9uZWFyZXN0IHggPSBmbG9vciAoeCArIDAuNSldIGRvZXMgbm90IGhvbGQ6XG5cbiAgIHt2XG4gICAgICMgbGV0IG5haXZlX3JvdW5kX25lYXJlc3QgeCA9IGZsb29yICh4ICsuIDAuNSk7O1xuICAgICAjIGxldCB4ID0gMi4gKiogNTIuICsuIDEuOztcbiAgICAgdmFsIHggOiBmbG9hdCA9IDQ1MDM1OTk2MjczNzA0OTcuXG4gICAgICMgbmFpdmVfcm91bmRfbmVhcmVzdCB4OztcbiAgICAgLSA6ICAgICBmbG9hdCA9IDQ1MDM1OTk2MjczNzA0OTguXG4gICB2fVxuKilcblxubGV0IHJvdW5kX25lYXJlc3RfbGIgPSAtLigyLiAqKiA1Mi4pXG5sZXQgcm91bmRfbmVhcmVzdF91YiA9IDIuICoqIDUyLlxuXG4oKiBGb3IgW3ggPSBvbmVfdWxwIGBEb3duIDAuNV0sIHRoZSBmb3JtdWxhIFtmbG9vciAoeCArLiAwLjUpXSBmb3Igcm91bmRpbmcgdG8gbmVhcmVzdFxuICAgZG9lcyBub3Qgd29yaywgYmVjYXVzZSB0aGUgZXhhY3QgcmVzdWx0IGlzIGhhbGZ3YXkgYmV0d2VlbiBbb25lX3VscCBgRG93biAxLl0gYW5kIFsxLl0sXG4gICBhbmQgaXQgZ2V0cyByb3VuZGVkIHVwIHRvIFsxLl0gZHVlIHRvIHRoZSByb3VuZC10aWVzLXRvLWV2ZW4gcnVsZS4gKilcbmxldCBvbmVfdWxwX2xlc3NfdGhhbl9oYWxmID0gb25lX3VscCBgRG93biAwLjVcblxubGV0W0BvY2FtbC5pbmxpbmUgYWx3YXlzXSBhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0ID1cbiAgdFxuICArLlxuICBpZiB0ID0gb25lX3VscF9sZXNzX3RoYW5faGFsZlxuICB0aGVuIG9uZV91bHBfbGVzc190aGFuX2hhbGYgKCogc2luY2UgdCA8IDAuNSwgbWFrZSBzdXJlIHRoZSByZXN1bHQgaXMgPCAxLjAgKilcbiAgZWxzZSAwLjVcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdF8zMiB0ID1cbiAgaWYgdCA+PSAwLlxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0IGluXG4gICAgaWYgdCcgPD0gaXJvdW5kX3Vib3VuZCB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCcpIGVsc2UgTm9uZSlcbiAgZWxzZSAoXG4gICAgbGV0IHQnID0gZmxvb3IgKHQgKy4gMC41KSBpblxuICAgIGlmIHQnID49IGlyb3VuZF9sYm91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnKSBlbHNlIE5vbmUpXG47O1xuXG5sZXQgaXJvdW5kX25lYXJlc3RfNjQgdCA9XG4gIGlmIHQgPj0gMC5cbiAgdGhlblxuICAgIGlmIHQgPCByb3VuZF9uZWFyZXN0X3ViXG4gICAgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIChhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0KSlcbiAgICBlbHNlIGlmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KVxuICAgIGVsc2UgTm9uZVxuICBlbHNlIGlmIHQgPiByb3VuZF9uZWFyZXN0X2xiXG4gIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoZmxvb3IgKHQgKy4gMC41KSkpXG4gIGVsc2UgaWYgdCA+PSBpcm91bmRfbGJvdW5kXG4gIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdCA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiBpcm91bmRfbmVhcmVzdF82NFxuICB8IFczMiAtPiBpcm91bmRfbmVhcmVzdF8zMlxuOztcblxubGV0IGlyb3VuZF9uZWFyZXN0X2V4bl8zMiB0ID1cbiAgaWYgdCA+PSAwLlxuICB0aGVuIChcbiAgICBsZXQgdCcgPSBhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0IGluXG4gICAgaWYgdCcgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2UgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX25lYXJlc3RfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiIChib3ggdCkgKCkpXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yICh0ICsuIDAuNSkgaW5cbiAgICBpZiB0JyA+PSBpcm91bmRfbGJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfbmVhcmVzdF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsXCIgKGJveCB0KSAoKSlcbjs7XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gaXJvdW5kX25lYXJlc3RfZXhuXzY0IHQgPVxuICBpZiB0ID49IDAuXG4gIHRoZW5cbiAgICBpZiB0IDwgcm91bmRfbmVhcmVzdF91YlxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdClcbiAgICBlbHNlIGlmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfbmVhcmVzdF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIGxhcmdlXCIgKGJveCB0KSAoKVxuICBlbHNlIGlmIHQgPiByb3VuZF9uZWFyZXN0X2xiXG4gIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCAoZmxvb3IgKHQgKy4gMC41KSlcbiAgZWxzZSBpZiB0ID49IGlyb3VuZF9sYm91bmRcbiAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF9uZWFyZXN0X2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCIgKGJveCB0KSAoKVxuOztcblxubGV0IGlyb3VuZF9uZWFyZXN0X2V4biA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiBpcm91bmRfbmVhcmVzdF9leG5fNjRcbiAgfCBXMzIgLT4gaXJvdW5kX25lYXJlc3RfZXhuXzMyXG47O1xuXG4oKiBUaGUgZm9sbG93aW5nIFtpcm91bmRfZXhuXSBhbmQgW2lyb3VuZF0gZnVuY3Rpb25zIGFyZSBzbG93ZXIgdGhhbiB0aGUgb25lcyBhYm92ZS5cbiAgIFRoZWlyIGVxdWl2YWxlbmNlIHRvIHRob3NlIGZ1bmN0aW9ucyBpcyB0ZXN0ZWQgaW4gdGhlIHVuaXQgdGVzdHMgYmVsb3cuICopXG5cbmxldFtAaW5saW5lXSBpcm91bmRfZXhuID8oZGlyID0gYE5lYXJlc3QpIHQgPVxuICBtYXRjaCBkaXIgd2l0aFxuICB8IGBaZXJvIC0+IGlyb3VuZF90b3dhcmRzX3plcm9fZXhuIHRcbiAgfCBgTmVhcmVzdCAtPiBpcm91bmRfbmVhcmVzdF9leG4gdFxuICB8IGBVcCAtPiBpcm91bmRfdXBfZXhuIHRcbiAgfCBgRG93biAtPiBpcm91bmRfZG93bl9leG4gdFxuOztcblxubGV0IGlyb3VuZCA/KGRpciA9IGBOZWFyZXN0KSB0ID1cbiAgdHJ5IFNvbWUgKGlyb3VuZF9leG4gfmRpciB0KSB3aXRoXG4gIHwgXyAtPiBOb25lXG47O1xuXG5sZXQgaXNfaW5mIHQgPSAxLiAvLiB0ID0gMC5cbmxldCBpc19maW5pdGUgdCA9IHQgLS4gdCA9IDAuXG5cbmxldCBtaW5faW5hbiAoeCA6IHQpIHkgPVxuICBpZiBpc19uYW4geSB0aGVuIHggZWxzZSBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSBpZiB4IDwgeSB0aGVuIHggZWxzZSB5XG47O1xuXG5sZXQgbWF4X2luYW4gKHggOiB0KSB5ID1cbiAgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgaWYgeCA+IHkgdGhlbiB4IGVsc2UgeVxuOztcblxubGV0IGFkZCA9ICggKy4gKVxubGV0IHN1YiA9ICggLS4gKVxubGV0IG5lZyA9ICggfi0uIClcbmxldCBhYnMgPSBhYnNfZmxvYXRcbmxldCBzY2FsZSA9ICggKi4gKVxubGV0IHNxdWFyZSB4ID0geCAqLiB4XG5cbm1vZHVsZSBQYXJ0cyA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgZnJhY3Rpb25hbCA6IHQgLT4gZmxvYXRcbiAgdmFsIGludGVncmFsIDogdCAtPiBmbG9hdFxuICB2YWwgbW9kZiA6IGZsb2F0IC0+IHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBmbG9hdCAqIGZsb2F0XG5cbiAgbGV0IGZyYWN0aW9uYWwgdCA9IGZzdCB0XG4gIGxldCBpbnRlZ3JhbCB0ID0gc25kIHRcbiAgbGV0IG1vZGYgPSBtb2RmXG5lbmRcblxubGV0IG1vZGYgPSBQYXJ0cy5tb2RmXG5sZXQgcm91bmRfZG93biA9IGZsb29yXG5sZXQgcm91bmRfdXAgPSBjZWlsXG5sZXQgcm91bmRfdG93YXJkc196ZXJvIHQgPSBpZiB0ID49IDAuIHRoZW4gcm91bmRfZG93biB0IGVsc2Ugcm91bmRfdXAgdFxuXG4oKiBzZWUgdGhlIGNvbW1lbnQgYWJvdmUgW3JvdW5kX25lYXJlc3RfbGJdIGFuZCBbcm91bmRfbmVhcmVzdF91Yl0gZm9yIGFuIGV4cGxhbmF0aW9uICopXG5sZXRbQG9jYW1sLmlubGluZV0gcm91bmRfbmVhcmVzdF9pbmxpbmUgdCA9XG4gIGlmIHQgPiByb3VuZF9uZWFyZXN0X2xiICYmIHQgPCByb3VuZF9uZWFyZXN0X3ViXG4gIHRoZW4gZmxvb3IgKGFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IHQpXG4gIGVsc2UgdCArLiAwLlxuOztcblxubGV0IHJvdW5kX25lYXJlc3QgdCA9IChyb3VuZF9uZWFyZXN0X2lubGluZSBbQG9jYW1sLmlubGluZWQgYWx3YXlzXSkgdFxuXG5sZXQgcm91bmRfbmVhcmVzdF9oYWxmX3RvX2V2ZW4gdCA9XG4gIGlmIHQgPD0gcm91bmRfbmVhcmVzdF9sYiB8fCB0ID49IHJvdW5kX25lYXJlc3RfdWJcbiAgdGhlbiB0ICsuIDAuXG4gIGVsc2UgKFxuICAgIGxldCBmbG9vciA9IGZsb29yIHQgaW5cbiAgICAoKiBbY2VpbF9vcl9zdWNjID0gaWYgdCBpcyBhbiBpbnRlZ2VyIHRoZW4gdCArLiAxLiBlbHNlIGNlaWwgdF0uICBGYXN0ZXIgdGhhbiBbY2VpbF0uICopXG4gICAgbGV0IGNlaWxfb3Jfc3VjYyA9IGZsb29yICsuIDEuIGluXG4gICAgbGV0IGRpZmZfZmxvb3IgPSB0IC0uIGZsb29yIGluXG4gICAgbGV0IGRpZmZfY2VpbCA9IGNlaWxfb3Jfc3VjYyAtLiB0IGluXG4gICAgaWYgZGlmZl9mbG9vciA8IGRpZmZfY2VpbFxuICAgIHRoZW4gZmxvb3JcbiAgICBlbHNlIGlmIGRpZmZfZmxvb3IgPiBkaWZmX2NlaWxcbiAgICB0aGVuIGNlaWxfb3Jfc3VjY1xuICAgIGVsc2UgaWYgKCogZXhhY3QgdGllLCBwaWNrIHRoZSBldmVuICopXG4gICAgICBtb2RfZmxvYXQgZmxvb3IgMi4gPSAwLlxuICAgIHRoZW4gZmxvb3JcbiAgICBlbHNlIGNlaWxfb3Jfc3VjYylcbjs7XG5cbmxldCBpbnQ2M19yb3VuZF9sYm91bmQgPSBsb3dlcl9ib3VuZF9mb3JfaW50IEludDYzLm51bV9iaXRzXG5sZXQgaW50NjNfcm91bmRfdWJvdW5kID0gdXBwZXJfYm91bmRfZm9yX2ludCBJbnQ2My5udW1fYml0c1xuXG5sZXQgaW50NjNfcm91bmRfdXBfZXhuIHQgPVxuICBpZiB0ID4gMC4wXG4gIHRoZW4gKFxuICAgIGxldCB0JyA9IGNlaWwgdCBpblxuICAgIGlmIHQnIDw9IGludDYzX3JvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZVxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiRmxvYXQuaW50NjNfcm91bmRfdXBfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiXG4gICAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAgICgpKVxuICBlbHNlIGlmIHQgPj0gaW50NjNfcm91bmRfbGJvdW5kXG4gIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnZlxuICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF91cF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgKClcbjs7XG5cbmxldCBpbnQ2M19yb3VuZF9kb3duX2V4biB0ID1cbiAgaWYgdCA+PSAwLjBcbiAgdGhlblxuICAgIGlmIHQgPD0gaW50NjNfcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiXG4gICAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAgICgpXG4gIGVsc2UgKFxuICAgIGxldCB0JyA9IGZsb29yIHQgaW5cbiAgICBpZiB0JyA+PSBpbnQ2M19yb3VuZF9sYm91bmRcbiAgICB0aGVuIEludDYzLm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX2Rvd25fZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIlxuICAgICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgICAoKSlcbjs7XG5cbmxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4biB0MCA9XG4gIGxldCB0ID0gKHJvdW5kX25lYXJlc3RfaW5saW5lIFtAb2NhbWwuaW5saW5lZCBhbHdheXNdKSB0MCBpblxuICBpZiB0ID4gMC5cbiAgdGhlblxuICAgIGlmIHQgPD0gaW50NjNfcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIkZsb2F0LmludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBsYXJnZVwiXG4gICAgICAgIChib3ggdDApXG4gICAgICAgICgpXG4gIGVsc2UgaWYgdCA+PSBpbnQ2M19yb3VuZF9sYm91bmRcbiAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICBlbHNlXG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcIkZsb2F0LmludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIlxuICAgICAgKGJveCB0MClcbiAgICAgICgpXG47O1xuXG5sZXQgaW50NjNfcm91bmRfbmVhcmVzdF9hcmNoNjRfbm9hbGxvY19leG4gZiA9IEludDYzLm9mX2ludCAoaXJvdW5kX25lYXJlc3RfZXhuIGYpXG5cbmxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X2V4biA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiBpbnQ2M19yb3VuZF9uZWFyZXN0X2FyY2g2NF9ub2FsbG9jX2V4blxuICB8IFczMiAtPiBpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4blxuOztcblxubGV0IHJvdW5kID8oZGlyID0gYE5lYXJlc3QpIHQgPVxuICBtYXRjaCBkaXIgd2l0aFxuICB8IGBOZWFyZXN0IC0+IHJvdW5kX25lYXJlc3QgdFxuICB8IGBEb3duIC0+IHJvdW5kX2Rvd24gdFxuICB8IGBVcCAtPiByb3VuZF91cCB0XG4gIHwgYFplcm8gLT4gcm91bmRfdG93YXJkc196ZXJvIHRcbjs7XG5cbm1vZHVsZSBDbGFzcyA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgSW5maW5pdGVcbiAgICB8IE5hblxuICAgIHwgTm9ybWFsXG4gICAgfCBTdWJub3JtYWxcbiAgICB8IFplcm9cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVudW1lcmF0ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlID0gKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIDogdCAtPiB0IC0+IGludClcbiAgbGV0IGFsbCA9IChbIEluZmluaXRlOyBOYW47IE5vcm1hbDsgU3Vibm9ybWFsOyBaZXJvIF0gOiB0IGxpc3QpXG5cbiAgbGV0IHRfb2Zfc2V4cCA9XG4gICAgKGxldCBlcnJvcl9zb3VyY2VfXzAwNl8gPSBcImZsb2F0Lm1sLkNsYXNzLnRcIiBpblxuICAgICBmdW5jdGlvblxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbmZpbml0ZVwiIHwgXCJJbmZpbml0ZVwiKSAtPiBJbmZpbml0ZVxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJuYW5cIiB8IFwiTmFuXCIpIC0+IE5hblxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJub3JtYWxcIiB8IFwiTm9ybWFsXCIpIC0+IE5vcm1hbFxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJzdWJub3JtYWxcIiB8IFwiU3Vibm9ybWFsXCIpIC0+IFN1Ym5vcm1hbFxuICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgLT4gWmVyb1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImluZmluaXRlXCIgfCBcIkluZmluaXRlXCIpIDo6IF8pIGFzXG4gICAgICAgc2V4cF9fMDA3XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibmFuXCIgfCBcIk5hblwiKSA6OiBfKSBhcyBzZXhwX18wMDdfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5vcm1hbFwiIHwgXCJOb3JtYWxcIikgOjogXykgYXMgc2V4cF9fMDA3XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJzdWJub3JtYWxcIiB8IFwiU3Vibm9ybWFsXCIpIDo6IF8pIGFzXG4gICAgICAgc2V4cF9fMDA3XyAtPiBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiemVyb1wiIHwgXCJaZXJvXCIpIDo6IF8pIGFzIHNleHBfXzAwN18gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDVfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDVfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwNV8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA1X1xuICAgICB8IHNleHBfXzAwNV8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDVfXG4gICAgICAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgOztcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgSW5maW5pdGUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiSW5maW5pdGVcIlxuICAgICAgfCBOYW4gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTmFuXCJcbiAgICAgIHwgTm9ybWFsIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIk5vcm1hbFwiXG4gICAgICB8IFN1Ym5vcm1hbCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJTdWJub3JtYWxcIlxuICAgICAgfCBaZXJvIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlplcm9cIlxuICAgICAgICAgICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICB7IHVudHlwZWQgPVxuICAgICAgICBWYXJpYW50XG4gICAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiSW5maW5pdGVcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiTmFuXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIk5vcm1hbFwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJTdWJub3JtYWxcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiWmVyb1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICB9XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgdG9fc3RyaW5nIHQgPSBzdHJpbmdfb2Zfc2V4cCAoc2V4cF9vZl90IHQpXG4gIGxldCBvZl9zdHJpbmcgcyA9IHRfb2Zfc2V4cCAoc2V4cF9vZl9zdHJpbmcgcylcbmVuZFxuXG5sZXQgY2xhc3NpZnkgdCA9XG4gIGxldCBtb2R1bGUgQyA9IENsYXNzIGluXG4gIG1hdGNoIGNsYXNzaWZ5X2Zsb2F0IHQgd2l0aFxuICB8IEZQX25vcm1hbCAtPiBDLk5vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbCAtPiBDLlN1Ym5vcm1hbFxuICB8IEZQX3plcm8gLT4gQy5aZXJvXG4gIHwgRlBfaW5maW5pdGUgLT4gQy5JbmZpbml0ZVxuICB8IEZQX25hbiAtPiBDLk5hblxuOztcblxubGV0IGluc2VydF91bmRlcnNjb3JlcyA/KGRlbGltaXRlciA9ICdfJykgPyhzdHJpcF96ZXJvID0gZmFsc2UpIHN0cmluZyA9XG4gIG1hdGNoIFN0cmluZy5sc3BsaXQyIHN0cmluZyB+b246Jy4nIHdpdGhcbiAgfCBOb25lIC0+IEludF9jb252ZXJzaW9ucy5pbnNlcnRfZGVsaW1pdGVyIHN0cmluZyB+ZGVsaW1pdGVyXG4gIHwgU29tZSAobGVmdCwgcmlnaHQpIC0+XG4gICAgbGV0IGxlZnQgPSBJbnRfY29udmVyc2lvbnMuaW5zZXJ0X2RlbGltaXRlciBsZWZ0IH5kZWxpbWl0ZXIgaW5cbiAgICBsZXQgcmlnaHQgPVxuICAgICAgaWYgc3RyaXBfemVybyB0aGVuIFN0cmluZy5yc3RyaXAgcmlnaHQgfmRyb3A6KGZ1biBjIC0+IENoYXIuKCA9ICkgYyAnMCcpIGVsc2UgcmlnaHRcbiAgICBpblxuICAgIChtYXRjaCByaWdodCB3aXRoXG4gICAgIHwgXCJcIiAtPiBsZWZ0XG4gICAgIHwgXyAtPiBsZWZ0IF4gXCIuXCIgXiByaWdodClcbjs7XG5cbmxldCB0b19zdHJpbmdfaHVtID9kZWxpbWl0ZXIgPyhkZWNpbWFscyA9IDMpID9zdHJpcF96ZXJvID8oZXhwbGljaXRfcGx1cyA9IGZhbHNlKSBmID1cbiAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBkZWNpbWFscyAwXG4gIHRoZW4gaW52YWxpZF9hcmdmIFwidG9fc3RyaW5nX2h1bTogaW52YWxpZCBhcmd1bWVudCB+ZGVjaW1hbHM9JWRcIiBkZWNpbWFscyAoKTtcbiAgbWF0Y2ggY2xhc3NpZnkgZiB3aXRoXG4gIHwgQ2xhc3MuSW5maW5pdGUgLT4gaWYgZiA+IDAuIHRoZW4gXCJpbmZcIiBlbHNlIFwiLWluZlwiXG4gIHwgQ2xhc3MuTmFuIC0+IFwibmFuXCJcbiAgfCBDbGFzcy5Ob3JtYWwgfCBDbGFzcy5TdWJub3JtYWwgfCBDbGFzcy5aZXJvIC0+XG4gICAgbGV0IHMgPVxuICAgICAgaWYgZXhwbGljaXRfcGx1cyB0aGVuIHNwcmludGYgXCIlKy4qZlwiIGRlY2ltYWxzIGYgZWxzZSBzcHJpbnRmIFwiJS4qZlwiIGRlY2ltYWxzIGZcbiAgICBpblxuICAgIGluc2VydF91bmRlcnNjb3JlcyBzID9kZWxpbWl0ZXIgP3N0cmlwX3plcm9cbjs7XG5cbmxldCBzZXhwX29mX3QgdCA9XG4gIGxldCBzZXhwID0gc2V4cF9vZl90IHQgaW5cbiAgbWF0Y2ggIVNleHAub2ZfZmxvYXRfc3R5bGUgd2l0aFxuICB8IGBOb191bmRlcnNjb3JlcyAtPiBzZXhwXG4gIHwgYFVuZGVyc2NvcmVzIC0+XG4gICAgKG1hdGNoIHNleHAgd2l0aFxuICAgICB8IExpc3QgXyAtPlxuICAgICAgIHJhaXNlX3NcbiAgICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgIFwiW3NleHBfb2ZfZmxvYXRdIHByb2R1Y2VkIHN0cmFuZ2Ugc2V4cFwiXG4gICAgICAgICAgICBbIFwic2V4cFwiLCBTZXhwLnNleHBfb2ZfdCBzZXhwIF0pXG4gICAgIHwgQXRvbSBzdHJpbmcgLT5cbiAgICAgICBpZiBTdHJpbmcuY29udGFpbnMgc3RyaW5nICdFJyB0aGVuIHNleHAgZWxzZSBBdG9tIChpbnNlcnRfdW5kZXJzY29yZXMgc3RyaW5nKSlcbjs7XG5cbmxldCB0b19wYWRkZWRfY29tcGFjdF9zdHJpbmdfY3VzdG9tIHQgPyhwcmVmaXggPSBcIlwiKSB+a2lsbyB+bWVnYSB+Z2lnYSB+dGVyYSA/cGV0YSAoKSA9XG4gICgqIFJvdW5kIGEgcmF0aW8gdG93YXJkIHRoZSBuZWFyZXN0IGludGVnZXIsIHJlc29sdmluZyB0aWVzIHRvd2FyZCB0aGUgbmVhcmVzdCBldmVuXG4gICAgIG51bWJlci4gIEZvciBzYW5lIGlucHV0cyAoaW4gcGFydGljdWxhciwgd2hlbiBbZGVub21pbmF0b3JdIGlzIGFuIGludGVnZXIgYW5kXG4gICAgIFthYnMgbnVtZXJhdG9yIDwgMmU1Ml0pIHRoaXMgc2hvdWxkIGJlIGFjY3VyYXRlLiAgT3RoZXJ3aXNlLCB0aGUgcmVzdWx0IG1pZ2h0IGJlIGFcbiAgICAgbGl0dGxlIGJpdCBvZmYsIGJ1dCB3ZSBkb24ndCByZWFsbHkgdXNlIHRoYXQgY2FzZS4gKilcbiAgbGV0IGlyb3VuZF9yYXRpb19leG4gfm51bWVyYXRvciB+ZGVub21pbmF0b3IgPVxuICAgIGxldCBrID0gZmxvb3IgKG51bWVyYXRvciAvLiBkZW5vbWluYXRvcikgaW5cbiAgICAoKiBpZiBbYWJzIGsgPCAyZTUzXSwgdGhlbiBib3RoIFtrXSBhbmQgW2sgKy4gMS5dIGFyZSBhY2N1cmF0ZWx5IHJlcHJlc2VudGVkLCBhbmQgaW5cbiAgICAgICBwYXJ0aWN1bGFyIFtrICsuIDEuID4ga10uICBJZiBbZGVub21pbmF0b3JdIGlzIGFsc28gYW4gaW50ZWdlciwgYW5kXG4gICAgICAgW2FicyAoZGVub21pbmF0b3IgKi4gKGsgKy4gMSkpIDwgMmU1M10gKGFuZCBpbiBzb21lIG90aGVyIGNhc2VzLCB0b28pLCB0aGVuIFtsb3dlcl1cbiAgICAgICBhbmQgW2hpZ2hlcl0gYXJlIGFjdHVhbGx5IGJvdGggYWNjdXJhdGUuICBTaW5jZSAocm91Z2hseSlcbiAgICAgICBbbnVtZXJhdG9yID0gZGVub21pbmF0b3IgKi4ga10gdGhlbiBmb3IgW2FicyBudW1lcmF0b3IgPCAyZTUyXSB3ZSBzaG91bGQgYmVcbiAgICAgICBmaW5lLiAqKVxuICAgIGxldCBsb3dlciA9IGRlbm9taW5hdG9yICouIGsgaW5cbiAgICBsZXQgaGlnaGVyID0gZGVub21pbmF0b3IgKi4gKGsgKy4gMS4pIGluXG4gICAgKCogU3VidHJhY3RpbmcgbnVtYmVycyB3aXRoaW4gYSBmYWN0b3Igb2YgdHdvIGZyb20gZWFjaCBvdGhlciBpcyBhY2N1cmF0ZS5cbiAgICAgICBTbyBlaXRoZXIgdGhlIHR3byBzdWJ0cmFjdGlvbnMgYmVsb3cgYXJlIGFjY3VyYXRlLCBvciBrID0gMCwgb3IgayA9IC0xLlxuICAgICAgIEluIGNhc2Ugb2YgYSB0aWUsIHJvdW5kIHRvIGV2ZW4uICopXG4gICAgbGV0IGRpZmZfcmlnaHQgPSBoaWdoZXIgLS4gbnVtZXJhdG9yIGluXG4gICAgbGV0IGRpZmZfbGVmdCA9IG51bWVyYXRvciAtLiBsb3dlciBpblxuICAgIGxldCBrID0gaXJvdW5kX25lYXJlc3RfZXhuIGsgaW5cbiAgICBpZiBkaWZmX3JpZ2h0IDwgZGlmZl9sZWZ0XG4gICAgdGhlbiBrICsgMVxuICAgIGVsc2UgaWYgZGlmZl9yaWdodCA+IGRpZmZfbGVmdFxuICAgIHRoZW4ga1xuICAgIGVsc2UgaWYgKCogYSB0aWUgKilcbiAgICAgIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA9ICkgKGsgbW9kIDIpIDBcbiAgICB0aGVuIGtcbiAgICBlbHNlIGsgKyAxXG4gIGluXG4gIG1hdGNoIGNsYXNzaWZ5IHQgd2l0aFxuICB8IENsYXNzLkluZmluaXRlIC0+IGlmIHQgPCAwLjAgdGhlbiBcIi1pbmYgIFwiIGVsc2UgXCJpbmYgIFwiXG4gIHwgQ2xhc3MuTmFuIC0+IFwibmFuICBcIlxuICB8IENsYXNzLlN1Ym5vcm1hbCB8IENsYXNzLk5vcm1hbCB8IENsYXNzLlplcm8gLT5cbiAgICBsZXQgZ28gdCA9XG4gICAgICBsZXQgY29udl9vbmUgdCA9XG4gICAgICAgIGFzc2VydCAoMC4gPD0gdCAmJiB0IDwgOTk5Ljk1KTtcbiAgICAgICAgbGV0IHggPSBwcmVmaXggXiBmb3JtYXRfZmxvYXQgXCIlLjFmXCIgdCBpblxuICAgICAgICAoKiBGaXggdGhlIFwiLjBcIiBzdWZmaXggKilcbiAgICAgICAgaWYgU3RyaW5nLmlzX3N1ZmZpeCB4IH5zdWZmaXg6XCIuMFwiXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCB4ID0gQnl0ZXMub2Zfc3RyaW5nIHggaW5cbiAgICAgICAgICBsZXQgbiA9IEJ5dGVzLmxlbmd0aCB4IGluXG4gICAgICAgICAgQnl0ZXMuc2V0IHggKG4gLSAxKSAnICc7XG4gICAgICAgICAgQnl0ZXMuc2V0IHggKG4gLSAyKSAnICc7XG4gICAgICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp4KVxuICAgICAgICBlbHNlIHhcbiAgICAgIGluXG4gICAgICBsZXQgY29udiBtYWcgdCBkZW5vbWluYXRvciA9XG4gICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgKGRlbm9taW5hdG9yID0gMTAwLiAmJiB0ID49IDk5OS45NSlcbiAgICAgICAgICB8fCAoZGVub21pbmF0b3IgPj0gMTAwXzAwMC4gJiYgdCA+PSByb3VuZF9uZWFyZXN0IChkZW5vbWluYXRvciAqLiA5Ljk5OV81KSkpO1xuICAgICAgICBhc3NlcnQgKHQgPCByb3VuZF9uZWFyZXN0IChkZW5vbWluYXRvciAqLiA5Xzk5OS41KSk7XG4gICAgICAgIGxldCBpLCBkID1cbiAgICAgICAgICBsZXQgayA9IGlyb3VuZF9yYXRpb19leG4gfm51bWVyYXRvcjp0IH5kZW5vbWluYXRvciBpblxuICAgICAgICAgICgqIFttb2RdIGlzIG9rYXkgaGVyZSBiZWNhdXNlIHdlIGtub3cgaSA+PSAwLiAqKVxuICAgICAgICAgIGsgLyAxMCwgayBtb2QgMTBcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgICAgICBhc3NlcnQgKDAgPD0gaSAmJiBpIDwgMTAwMCk7XG4gICAgICAgIGFzc2VydCAoMCA8PSBkICYmIGQgPCAxMCk7XG4gICAgICAgIGlmIGQgPSAwXG4gICAgICAgIHRoZW4gc3ByaW50ZiBcIiVzJWQlcyBcIiBwcmVmaXggaSBtYWdcbiAgICAgICAgZWxzZSBzcHJpbnRmIFwiJXMlZCVzJWRcIiBwcmVmaXggaSBtYWcgZFxuICAgICAgaW5cbiAgICAgICgqIFdoaWxlIHRoZSBzdGFuZGFyZCBtZXRyaWMgcHJlZml4ZXMgKGUuZy4gY2FwaXRhbCBcIk1cIiByYXRoZXIgdGhhbiBcIm1cIiwgWzFdKSBhcmVcbiAgICAgICAgIG5vbWluYWxseSBtb3JlIGNvcnJlY3QsIHRoaXMgaGluZGVycyByZWFkYWJpbGl0eSBpbiBvdXIgY2FzZS4gIEUuZy4sIDEwRzYgYW5kXG4gICAgICAgICAxMDY2IGxvb2sgdG9vIHNpbWlsYXIuICBUaGF0J3MgYW4gZXh0cmVtZSBleGFtcGxlLCBidXQgaW4gZ2VuZXJhbCBrLG0sZyx0LHBcbiAgICAgICAgIHByb2JhYmx5IHN0YW5kIG91dCBiZXR0ZXIgdGhhbiBLLE0sRyxULFAgd2hlbiBpbnRlcnNwZXJzZWQgd2l0aCBkaWdpdHMuXG5cbiAgICAgICAgIFsxXSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01ldHJpY19wcmVmaXggKilcbiAgICAgICgqIFRoZSB0cmljayBoZXJlIGlzIHRoYXQ6XG4gICAgICAgICAtIHRoZSBmaXJzdCBib3VuZGFyeSAoOTk5Ljk1KSBhcyBhIGZsb2F0IGlzIHNsaWdodGx5IG92ZXItcmVwcmVzZW50ZWQgKHNvIGl0IGlzXG4gICAgICAgICAgIGJldHRlciBhcHByb3hpbWF0ZWQgYXMgXCIxa1wiIHRoYW4gYXMgXCI5OTkuOVwiKSxcbiAgICAgICAgIC0gdGhlIG90aGVyIGJvdW5kYXJpZXMgYXJlIGFjY3VyYXRlbHkgcmVwcmVzZW50ZWQsIGJlY2F1c2UgdGhleSBhcmUgaW50ZWdlcnMuXG4gICAgICAgICAgIFRoYXQncyB3aHkgdGhlIHN0cmljdCBlcXVhbGl0aWVzIGJlbG93IGRvIGV4YWN0bHkgd2hhdCB3ZSB3YW50LiAqKVxuICAgICAgaWYgdCA8IDk5OS45NUUwXG4gICAgICB0aGVuIGNvbnZfb25lIHRcbiAgICAgIGVsc2UgaWYgdCA8IDk5OS45NUUzXG4gICAgICB0aGVuIGNvbnYga2lsbyB0IDEwMC5cbiAgICAgIGVsc2UgaWYgdCA8IDk5OS45NUU2XG4gICAgICB0aGVuIGNvbnYgbWVnYSB0IDEwMF8wMDAuXG4gICAgICBlbHNlIGlmIHQgPCA5OTkuOTVFOVxuICAgICAgdGhlbiBjb252IGdpZ2EgdCAxMDBfMDAwXzAwMC5cbiAgICAgIGVsc2UgaWYgdCA8IDk5OS45NUUxMlxuICAgICAgdGhlbiBjb252IHRlcmEgdCAxMDBfMDAwXzAwMF8wMDAuXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggcGV0YSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBzcHJpbnRmIFwiJXMlLjFlXCIgcHJlZml4IHRcbiAgICAgICAgfCBTb21lIHBldGEgLT5cbiAgICAgICAgICBpZiB0IDwgOTk5Ljk1RTE1XG4gICAgICAgICAgdGhlbiBjb252IHBldGEgdCAxMDBfMDAwXzAwMF8wMDBfMDAwLlxuICAgICAgICAgIGVsc2Ugc3ByaW50ZiBcIiVzJS4xZVwiIHByZWZpeCB0KVxuICAgIGluXG4gICAgaWYgdCA+PSAwLiB0aGVuIGdvIHQgZWxzZSBcIi1cIiBeIGdvIH4tLnRcbjs7XG5cbmxldCB0b19wYWRkZWRfY29tcGFjdF9zdHJpbmcgdCA9XG4gIHRvX3BhZGRlZF9jb21wYWN0X3N0cmluZ19jdXN0b20gdCB+a2lsbzpcImtcIiB+bWVnYTpcIm1cIiB+Z2lnYTpcImdcIiB+dGVyYTpcInRcIiB+cGV0YTpcInBcIiAoKVxuOztcblxuKCogUGVyZm9ybWFuY2Ugbm90ZTogSW5pdGlhbGl6aW5nIHRoZSBhY2N1bXVsYXRvciB0byAxIHJlc3VsdHMgaW4gb25lIGV4dHJhXG4gICBtdWx0aXBseTsgZS5nLiwgdG8gY29tcHV0ZSB4ICoqIDQsIHdlIGluIHByaW5jaXBsZSBvbmx5IG5lZWQgMiBtdWx0aXBsaWVzLFxuICAgYnV0IHRoaXMgZnVuY3Rpb24gd2lsbCBoYXZlIDMgbXVsdGlwbGllcy4gIEhvd2V2ZXIsIGF0dGVtcHRzIHRvIGF2b2lkIHRoaXNcbiAgIChsaWtlIGRlY3JlbWVudGluZyBuIGFuZCBpbml0aWFsaXppbmcgYWNjdW0gdG8gYmUgeCwgb3IgaGFuZGxpbmcgc21hbGxcbiAgIGV4cG9uZW50cyBhcyBhIHNwZWNpYWwgY2FzZSkgaGF2ZSBub3QgeWllbGRlZCBhbnl0aGluZyB0aGF0IGlzIGEgbmV0XG4gICBpbXByb3ZlbWVudC5cbiopXG5sZXQgaW50X3BvdyB4IG4gPVxuICBsZXQgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gIGlmIG4gPSAwXG4gIHRoZW4gMS5cbiAgZWxzZSAoXG4gICAgKCogVXNpbmcgW3ggKy4gKC0wLildIG9uIHRoZSBmb2xsb3dpbmcgbGluZSBjb252aW5jZXMgdGhlIGNvbXBpbGVyIHRvIGF2b2lkIGEgY2VydGFpblxuICAgICAgIGJveGluZyAodGhhdCB3b3VsZCByZXN1bHQgaW4gYWxsb2NhdGlvbiBpbiBlYWNoIGl0ZXJhdGlvbikuICBTb29uLCB0aGUgY29tcGlsZXJcbiAgICAgICBzaG91bGRuJ3QgbmVlZCB0aGlzIFwiaGludFwiIHRvIGF2b2lkIHRoZSBib3hpbmcuICBUaGUgcmVhc29uIHdlIGFkZCAtMCByYXRoZXIgdGhhbiAwXG4gICAgICAgaXMgdGhhdCBbeCArLiAoLTAuKV0gaXMgYXBwYXJlbnRseSBhbHdheXMgdGhlIHNhbWUgYXMgW3hdLCB3aGVyZWFzIFt4ICsuIDAuXSBpc1xuICAgICAgIG5vdCwgaW4gdGhhdCBpdCBzZW5kcyBbLTAuXSB0byBbMC5dLiAgVGhpcyBtYWtlcyBhIGRpZmZlcmVuY2UgYmVjYXVzZSB3ZSB3YW50XG4gICAgICAgW2ludF9wb3cgKC0wLikgKC0xKV0gdG8gcmV0dXJuIG5lZ19pbmZpbml0eSBqdXN0IGxpa2UgWy0wLiAqKiAtMS5dIHdvdWxkLiAgKilcbiAgICBsZXQgeCA9IHJlZiAoeCArLiAtMC4pIGluXG4gICAgbGV0IG4gPSByZWYgbiBpblxuICAgIGxldCBhY2N1bSA9IHJlZiAxLiBpblxuICAgIGlmICFuIDwgMFxuICAgIHRoZW4gKFxuICAgICAgKCogeCAqKiBuID0gKDEveCkgKiogLW4gKilcbiAgICAgIHggOj0gMS4gLy4gIXg7XG4gICAgICBuIDo9IH4tICghbik7XG4gICAgICBpZiAhbiA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICAoKiBuIG11c3QgaGF2ZSBiZWVuIG1pbl9pbnQsIHNvIGl0IGlzIG5vdyBzbyBiaWcgdGhhdCBpdCBoYXMgd3JhcHBlZCBhcm91bmQuXG4gICAgICAgICAgIFdlIGRlY3JlbWVudCBpdCBzbyB0aGF0IGl0IGxvb2tzIHBvc2l0aXZlIGFnYWluLCBidXQgYWNjb3JkaW5nbHkgaGF2ZVxuICAgICAgICAgICB0byBwdXQgYW4gZXh0cmEgZmFjdG9yIG9mIHggaW4gdGhlIGFjY3VtdWxhdG9yLlxuICAgICAgICAqKVxuICAgICAgICBhY2N1bSA6PSAheDtcbiAgICAgICAgZGVjciBuKSk7XG4gICAgKCogTGV0dGluZyBbYV0gZGVub3RlICh0aGUgb3JpZ2luYWwgdmFsdWUgb2YpIFt4ICoqIG5dLCB3ZSBtYWludGFpblxuICAgICAgIHRoZSBpbnZhcmlhbnQgdGhhdCBbKHggKiogbikgKi4gYWNjdW0gPSBhXS4gKilcbiAgICB3aGlsZSAhbiA+IDEgZG9cbiAgICAgIGlmICFuIGxhbmQgMSA8PiAwIHRoZW4gYWNjdW0gOj0gIXggKi4gIWFjY3VtO1xuICAgICAgeCA6PSAheCAqLiAheDtcbiAgICAgIG4gOj0gIW4gbHNyIDFcbiAgICBkb25lO1xuICAgICgqIG4gaXMgbmVjZXNzYXJpbHkgMSBhdCB0aGlzIHBvaW50LCBzbyB0aGVyZSBpcyBvbmUgYWRkaXRpb25hbFxuICAgICAgIG11bHRpcGxpY2F0aW9uIGJ5IHguICopXG4gICAgIXggKi4gIWFjY3VtKVxuOztcblxubGV0IHJvdW5kX2dlbiB4IH5ob3cgPVxuICBpZiB4ID0gMC5cbiAgdGhlbiAwLlxuICBlbHNlIGlmIG5vdCAoaXNfZmluaXRlIHgpXG4gIHRoZW4geFxuICBlbHNlIChcbiAgICAoKiBTaWduaWZpY2FudCBkaWdpdHMgYW5kIGRlY2ltYWwgZGlnaXRzLiAqKVxuICAgIGxldCBzZCwgZGQgPVxuICAgICAgbWF0Y2ggaG93IHdpdGhcbiAgICAgIHwgYHNpZ25pZmljYW50X2RpZ2l0cyBzZCAtPlxuICAgICAgICBsZXQgZGQgPSBzZCAtIHRvX2ludCAocm91bmRfdXAgKGxvZzEwIChhYnMgeCkpKSBpblxuICAgICAgICBzZCwgZGRcbiAgICAgIHwgYGRlY2ltYWxfZGlnaXRzIGRkIC0+XG4gICAgICAgIGxldCBzZCA9IGRkICsgdG9faW50IChyb3VuZF91cCAobG9nMTAgKGFicyB4KSkpIGluXG4gICAgICAgIHNkLCBkZFxuICAgIGluXG4gICAgbGV0IG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGlmIHNkIDwgMFxuICAgIHRoZW4gMC5cbiAgICBlbHNlIGlmIHNkID49IDE3XG4gICAgdGhlbiB4XG4gICAgZWxzZSAoXG4gICAgICAoKiBDaG9vc2UgdGhlIG9yZGVyIHRoYXQgaXMgZXhhY3RseSByZXByZXNlbnRhYmxlIGFzIGEgZmxvYXQuIFNtYWxsIHBvc2l0aXZlXG4gICAgICAgICBpbnRlZ2VycyBhcmUsIGJ1dCB0aGVpciBpbnZlcnNlcyBpbiBtb3N0IGNhc2VzIGFyZSBub3QuICopXG4gICAgICBsZXQgYWJzX2RkID0gSW50LmFicyBkZCBpblxuICAgICAgaWYgYWJzX2RkID4gMjIgfHwgc2QgPj0gMTZcbiAgICAgICgqIDEwKioyMiBpcyBleGFjdGx5IHJlcHJlc2VudGFibGUgYXMgYSBmbG9hdCwgYnV0IDEwKioyMyBpcyBub3QsIHNvIHVzZSB0aGUgc2xvd1xuICAgICAgICAgcGF0aC4gIFNpbWlsYXJseSwgaWYgd2UgbmVlZCAxNiBzaWduaWZpY2FudCBkaWdpdHMgaW4gdGhlIHJlc3VsdCwgdGhlbiB0aGUgaW50ZWdlclxuICAgICAgICAgW3JvdW5kX25lYXJlc3QgKHggPG9wPiBvcmRlcildIG1pZ2h0IG5vdCBiZSBleGFjdGx5IHJlcHJlc2VudGFibGUgYXMgYSBmbG9hdCwgc2luY2VcbiAgICAgICAgIGZvciBzb21lIHJhbmdlcyB3ZSBvbmx5IGhhdmUgMTUgZGlnaXRzIG9mIHByZWNpc2lvbiBndWFyYW50ZWVkLlxuXG4gICAgICAgICBUaGF0IHNhaWQsIHdlIGFyZSBzdGlsbCByb3VuZGluZyB0d2ljZSBoZXJlOlxuXG4gICAgICAgICAxKSBmaXJzdCB0aW1lIHdoZW4gcm91bmRpbmcgW3ggKi4gb3JkZXJdIG9yIFt4IC8uIG9yZGVyXSB0byB0aGUgbmVhcmVzdCBmbG9hdFxuICAgICAgICAgKGp1c3QgdGhlIG5vcm1hbCB3YXkgZmxvYXRpbmctcG9pbnQgbXVsdGlwbGljYXRpb24gb3IgZGl2aXNpb24gd29ya3MpLFxuXG4gICAgICAgICAyKSBzZWNvbmQgdGltZSB3aGVuIGFwcGx5aW5nIFtyb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbl0gdG8gdGhlIHJlc3VsdCBvZiB0aGVcbiAgICAgICAgIGFib3ZlIG9wZXJhdGlvblxuXG4gICAgICAgICBTbyBmb3IgYXJndW1lbnRzIHdpdGhpbiBhbiB1bHAgZnJvbSBhIHRpZSB3ZSBtaWdodCBzdGlsbCBwcm9kdWNlIGFuIG9mZi1ieS1vbmVcbiAgICAgICAgIHJlc3VsdC4gKilcbiAgICAgIHRoZW4gb2Zfc3RyaW5nIChzcHJpbnRmIFwiJS4qZ1wiIHNkIHgpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IG9yZGVyID0gaW50X3BvdyAxMC4gYWJzX2RkIGluXG4gICAgICAgIGlmIGRkID49IDBcbiAgICAgICAgdGhlbiByb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiAoeCAqLiBvcmRlcikgLy4gb3JkZXJcbiAgICAgICAgZWxzZSByb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiAoeCAvLiBvcmRlcikgKi4gb3JkZXIpKSlcbjs7XG5cbmxldCByb3VuZF9zaWduaWZpY2FudCB4IH5zaWduaWZpY2FudF9kaWdpdHMgPVxuICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBzaWduaWZpY2FudF9kaWdpdHMgMFxuICB0aGVuXG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcIkZsb2F0LnJvdW5kX3NpZ25pZmljYW50OiBpbnZhbGlkIGFyZ3VtZW50IHNpZ25pZmljYW50X2RpZ2l0czolZFwiXG4gICAgICBzaWduaWZpY2FudF9kaWdpdHNcbiAgICAgICgpXG4gIGVsc2Ugcm91bmRfZ2VuIHggfmhvdzooYHNpZ25pZmljYW50X2RpZ2l0cyBzaWduaWZpY2FudF9kaWdpdHMpXG47O1xuXG5sZXQgcm91bmRfZGVjaW1hbCB4IH5kZWNpbWFsX2RpZ2l0cyA9IHJvdW5kX2dlbiB4IH5ob3c6KGBkZWNpbWFsX2RpZ2l0cyBkZWNpbWFsX2RpZ2l0cylcbmxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgKCogQWxzbyBmYWlscyBpZiBbbWluXSBvciBbbWF4XSBpcyBuYW4gKilcbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgKCogY2xhbXBfdW5jaGVja2VkIGlzIGluIGZsb2F0MC5tbCAqKVxuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gICgqIEFsc28gZmFpbHMgaWYgW21pbl0gb3IgW21heF0gaXMgbmFuICopXG4gIGlmIG1pbiA8PSBtYXhcbiAgdGhlbiBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuICBlbHNlXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuOztcblxubGV0ICggKyApID0gKCArLiApXG5sZXQgKCAtICkgPSAoIC0uIClcbmxldCAoICogKSA9ICggKi4gKVxubGV0ICggKiogKSA9ICggKiogKVxubGV0ICggLyApID0gKCAvLiApXG5sZXQgKCAlICkgPSAoICUuIClcbmxldCAoIH4tICkgPSAoIH4tLiApXG5cbmxldCBzaWduX2V4biB0IDogU2lnbi50ID1cbiAgaWYgdCA+IDAuXG4gIHRoZW4gUG9zXG4gIGVsc2UgaWYgdCA8IDAuXG4gIHRoZW4gTmVnXG4gIGVsc2UgaWYgdCA9IDAuXG4gIHRoZW4gWmVyb1xuICBlbHNlIEVycm9yLnJhaXNlX3MgKFNleHAubWVzc2FnZSBcIkZsb2F0LnNpZ25fZXhuIG9mIE5BTlwiIFsgXCJcIiwgc2V4cF9vZl90IHQgXSlcbjs7XG5cbmxldCBzaWduX29yX25hbiB0IDogU2lnbl9vcl9uYW4udCA9XG4gIGlmIHQgPiAwLiB0aGVuIFBvcyBlbHNlIGlmIHQgPCAwLiB0aGVuIE5lZyBlbHNlIGlmIHQgPSAwLiB0aGVuIFplcm8gZWxzZSBOYW5cbjs7XG5cbmxldCBpZWVlX25lZ2F0aXZlIHQgPVxuICBsZXQgYml0cyA9IENhbWwuSW50NjQuYml0c19vZl9mbG9hdCB0IGluXG4gIFBvbHkuKGJpdHMgPCBDYW1sLkludDY0Lnplcm8pXG47O1xuXG5sZXQgZXhwb25lbnRfYml0cyA9IDExXG5sZXQgbWFudGlzc2FfYml0cyA9IDUyXG5sZXQgZXhwb25lbnRfbWFzazY0ID0gSW50NjQuKHNoaWZ0X2xlZnQgb25lIGV4cG9uZW50X2JpdHMgLSBvbmUpXG5sZXQgZXhwb25lbnRfbWFzayA9IEludDY0LnRvX2ludF9leG4gZXhwb25lbnRfbWFzazY0XG5sZXQgbWFudGlzc2FfbWFzayA9IEludDYzLihzaGlmdF9sZWZ0IG9uZSBtYW50aXNzYV9iaXRzIC0gb25lKVxubGV0IG1hbnRpc3NhX21hc2s2NCA9IEludDYzLnRvX2ludDY0IG1hbnRpc3NhX21hc2tcblxubGV0IGllZWVfZXhwb25lbnQgdCA9XG4gIGxldCBiaXRzID0gQ2FtbC5JbnQ2NC5iaXRzX29mX2Zsb2F0IHQgaW5cbiAgSW50NjQuKGJpdF9hbmQgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgYml0cyBtYW50aXNzYV9iaXRzKSBleHBvbmVudF9tYXNrNjQpXG4gIHw+IENhbWwuSW50NjQudG9faW50XG47O1xuXG5sZXQgaWVlZV9tYW50aXNzYSB0ID1cbiAgbGV0IGJpdHMgPSBDYW1sLkludDY0LmJpdHNfb2ZfZmxvYXQgdCBpblxuICBJbnQ2My5vZl9pbnQ2NF9leG4gQ2FtbC5JbnQ2NC4obG9nYW5kIGJpdHMgbWFudGlzc2FfbWFzazY0KVxuOztcblxubGV0IGNyZWF0ZV9pZWVlX2V4biB+bmVnYXRpdmUgfmV4cG9uZW50IH5tYW50aXNzYSA9XG4gIGlmIEludC4oYml0X2FuZCBleHBvbmVudCBleHBvbmVudF9tYXNrIDw+IGV4cG9uZW50KVxuICB0aGVuIGZhaWx3aXRoZiBcImV4cG9uZW50ICVkIG91dCBvZiByYW5nZSBbMCwgJWRdXCIgZXhwb25lbnQgZXhwb25lbnRfbWFzayAoKVxuICBlbHNlIGlmIEludDYzLihiaXRfYW5kIG1hbnRpc3NhIG1hbnRpc3NhX21hc2sgPD4gbWFudGlzc2EpXG4gIHRoZW5cbiAgICBmYWlsd2l0aGZcbiAgICAgIFwibWFudGlzc2EgJXMgb3V0IG9mIHJhbmdlIFswLCAlc11cIlxuICAgICAgKEludDYzLnRvX3N0cmluZyBtYW50aXNzYSlcbiAgICAgIChJbnQ2My50b19zdHJpbmcgbWFudGlzc2FfbWFzaylcbiAgICAgICgpXG4gIGVsc2UgKFxuICAgIGxldCBzaWduX2JpdHMgPSBpZiBuZWdhdGl2ZSB0aGVuIENhbWwuSW50NjQubWluX2ludCBlbHNlIENhbWwuSW50NjQuemVybyBpblxuICAgIGxldCBleHB0X2JpdHMgPSBDYW1sLkludDY0LnNoaWZ0X2xlZnQgKENhbWwuSW50NjQub2ZfaW50IGV4cG9uZW50KSBtYW50aXNzYV9iaXRzIGluXG4gICAgbGV0IG1hbnRfYml0cyA9IEludDYzLnRvX2ludDY0IG1hbnRpc3NhIGluXG4gICAgbGV0IGJpdHMgPSBDYW1sLkludDY0Lihsb2dvciBzaWduX2JpdHMgKGxvZ29yIGV4cHRfYml0cyBtYW50X2JpdHMpKSBpblxuICAgIENhbWwuSW50NjQuZmxvYXRfb2ZfYml0cyBiaXRzKVxuOztcblxubGV0IGNyZWF0ZV9pZWVlIH5uZWdhdGl2ZSB+ZXhwb25lbnQgfm1hbnRpc3NhID1cbiAgT3JfZXJyb3IudHJ5X3dpdGggKGZ1biAoKSAtPiBjcmVhdGVfaWVlZV9leG4gfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2EpXG47O1xuXG5tb2R1bGUgVGVyc2UgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IHRcblxuICBsZXQgdF9vZl9zZXhwID0gdF9vZl9zZXhwXG4gIGxldCB0b19zdHJpbmcgeCA9IFByaW50Zi5zcHJpbnRmIFwiJS44R1wiIHhcbiAgbGV0IHNleHBfb2ZfdCB4ID0gU2V4cC5BdG9tICh0b19zdHJpbmcgeClcbiAgbGV0IG9mX3N0cmluZyB4ID0gb2Zfc3RyaW5nIHhcbiAgbGV0IHRfc2V4cF9ncmFtbWFyID0gdF9zZXhwX2dyYW1tYXJcbmVuZFxuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCB6ZXJvID0gemVyb1xuICBlbmQpXG5cbigqIFRoZXNlIGFyZSBwYXJ0bHkgaGVyZSBhcyBhIHBlcmZvcm1hbmNlIGhhY2sgdG8gYXZvaWQgc29tZSBib3hpbmcgd2UncmUgZ2V0dGluZyB3aXRoXG4gICB0aGUgdmVyc2lvbnMgd2UgZ2V0IGZyb20gW1dpdGhfemVyb10uICBUaGV5IGFsc28gbWFrZSBbRmxvYXQuaXNfbmVnYXRpdmUgbmFuXSBhbmRcbiAgIFtGbG9hdC5pc19ub25fcG9zaXRpdmUgbmFuXSByZXR1cm4gW2ZhbHNlXTsgdGhlIHZlcnNpb25zIHdlIGdldCBmcm9tIFtXaXRoX3plcm9dIHJldHVyblxuICAgW3RydWVdLiAqKVxubGV0IGlzX3Bvc2l0aXZlIHQgPSB0ID4gMC5cbmxldCBpc19ub25fbmVnYXRpdmUgdCA9IHQgPj0gMC5cbmxldCBpc19uZWdhdGl2ZSB0ID0gdCA8IDAuXG5sZXQgaXNfbm9uX3Bvc2l0aXZlIHQgPSB0IDw9IDAuXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkZsb2F0XCJcbiAgICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gIGVuZClcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgbGV0ICggKyApID0gKCArIClcbiAgbGV0ICggLSApID0gKCAtIClcbiAgbGV0ICggKiApID0gKCAqIClcbiAgbGV0ICggLyApID0gKCAvIClcbiAgbGV0ICggJSApID0gKCAlIClcbiAgbGV0ICggfi0gKSA9ICggfi0gKVxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSAoRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIDogQ29tcGFyaXNvbnMuSW5maXggd2l0aCB0eXBlIHQgOj0gdClcblxuICBsZXQgYWJzID0gYWJzXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnQgPSBvZl9pbnRcbiAgbGV0IG9mX2Zsb2F0IHggPSB4XG5lbmRcblxubW9kdWxlIE9fZG90ID0gc3RydWN0XG4gIGxldCAoICouICkgPSAoICogKVxuICBsZXQgKCArLiApID0gKCArIClcbiAgbGV0ICggLS4gKSA9ICggLSApXG4gIGxldCAoIC8uICkgPSAoIC8gKVxuICBsZXQgKCAlLiApID0gKCAlIClcbiAgbGV0ICggfi0uICkgPSAoIH4tIClcbiAgbGV0ICggKiouICkgPSAoICoqIClcbmVuZFxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBsZXQgYm94ID0gYm94XG4gIGxldCBjbGFtcF91bmNoZWNrZWQgPSBjbGFtcF91bmNoZWNrZWRcbiAgbGV0IGxvd2VyX2JvdW5kX2Zvcl9pbnQgPSBsb3dlcl9ib3VuZF9mb3JfaW50XG4gIGxldCB1cHBlcl9ib3VuZF9mb3JfaW50ID0gdXBwZXJfYm91bmRfZm9yX2ludFxuICBsZXQgc3BlY2lhbGl6ZWRfaGFzaCA9IGhhc2hfZmxvYXRcbiAgbGV0IG9uZV91bHBfbGVzc190aGFuX2hhbGYgPSBvbmVfdWxwX2xlc3NfdGhhbl9oYWxmXG4gIGxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2FsbG9jX2V4biA9IGludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuXG4gIGxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X2FyY2g2NF9ub2FsbG9jX2V4biA9IGludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYWxsb2NfZXhuXG4gIGxldCBpcm91bmRfbmVhcmVzdF9leG5fNjQgPSBpcm91bmRfbmVhcmVzdF9leG5fNjRcbmVuZFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbigqIFRoZXNlIGZ1bmN0aW9ucyBzcGVjaWZpY2FsbHkgcmVwbGFjZSBkZWZhdWx0cyBpbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuXG5cbiAgIFRoZSBkZXNpcmVkIGJlaGF2aW9yIGhlcmUgaXMgdG8gcHJvcGFnYXRlIGEgbmFuIGlmIGVpdGhlciBhcmd1bWVudCBpcyBuYW4uIEJlY2F1c2UgdGhlXG4gICBmaXJzdCBjb21wYXJpc29uIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZSBpZiBlaXRoZXIgYXJndW1lbnQgaXMgbmFuLCBpdCBzdWZmaWNlcyB0b1xuICAgY2hlY2sgaWYgeCBpcyBuYW4uIFRoZW4sIHdoZW4geCBpcyBuYW4gb3IgYm90aCB4IGFuZCB5IGFyZSBuYW4sIHdlIHJldHVybiB4ID0gbmFuOyBhbmRcbiAgIHdoZW4geSBpcyBuYW4gYnV0IG5vdCB4LCB3ZSByZXR1cm4geSA9IG5hbi5cblxuICAgVGhlcmUgYXJlIHZhcmlvdXMgd2F5cyB0byBpbXBsZW1lbnQgdGhlc2UgZnVuY3Rpb25zLiAgVGhlIGJlbmNobWFyayBiZWxvdyBzaG93cyBhIGZld1xuICAgZGlmZmVyZW50IHZlcnNpb25zLiAgVGhpcyBiZW5jaG1hcmsgd2FzIHJ1biBvdmVyIGFuIGFycmF5IG9mIHJhbmRvbSBmbG9hdHMgKG5vbmUgb2ZcbiAgIHdoaWNoIGFyZSBuYW4pLlxuXG4gICDilIzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcbiAgIOKUgiBOYW1lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiBUaW1lL1J1biDilIJcbiAgIOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuICAg4pSCIGlmIGlzX25hbiB4IHRoZW4geCBlbHNlIGlmIHggPCB5IHRoZW4geCBlbHNlIHkg4pSCICAgMi40MnVzIOKUglxuICAg4pSCIGlmIGlzX25hbiB4IHx8IHggPCB5IHRoZW4geCBlbHNlIHkgICAgICAgICAgICAg4pSCICAgMi4wMnVzIOKUglxuICAg4pSCIGlmIHggPCB5IHx8IGlzX25hbiB4IHRoZW4geCBlbHNlIHkgICAgICAgICAgICAg4pSCICAgMS44OHVzIOKUglxuICAg4pSU4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG5cbiAgIFRoZSBiZW5jaG1hcmsgYmVsb3cgd2FzIHJ1biB3aGVuIHggPiB5IGlzIGFsd2F5cyB0cnVlIChhZ2Fpbiwgbm8gbmFuIHZhbHVlcykuXG5cbiAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAg4pSCIE5hbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCIFRpbWUvUnVuIOKUglxuICAg4pSc4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICDilIIgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgaWYgeCA8IHkgdGhlbiB4IGVsc2UgeSDilIIgICAyLjgzdXMg4pSCXG4gICDilIIgaWYgaXNfbmFuIHggfHwgeCA8IHkgdGhlbiB4IGVsc2UgeSAgICAgICAgICAgICDilIIgICAxLjk3dXMg4pSCXG4gICDilIIgaWYgeCA8IHkgfHwgaXNfbmFuIHggdGhlbiB4IGVsc2UgeSAgICAgICAgICAgICDilIIgICAxLjU2dXMg4pSCXG4gICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcbiopXG5sZXQgbWluICh4IDogdCkgeSA9IGlmIHggPCB5IHx8IGlzX25hbiB4IHRoZW4geCBlbHNlIHlcbmxldCBtYXggKHggOiB0KSB5ID0gaWYgeCA+IHkgfHwgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEJ1ZmZlcl9pbnRmXG5pbmNsdWRlIENhbWwuQnVmZmVyXG5cbmxldCBjb250ZW50c19ieXRlcyA9IHRvX2J5dGVzXG5sZXQgYWRkX3N1YnN0cmluZyB0IHMgfnBvcyB+bGVuID0gYWRkX3N1YnN0cmluZyB0IHMgcG9zIGxlblxubGV0IGFkZF9zdWJieXRlcyB0IHMgfnBvcyB+bGVuID0gYWRkX3N1YmJ5dGVzIHQgcyBwb3MgbGVuXG5sZXQgc2V4cF9vZl90IHQgPSBzZXhwX29mX3N0cmluZyAoY29udGVudHMgdClcblxubW9kdWxlIFRvX2J5dGVzID1cbiAgQmxpdC5NYWtlX2Rpc3RpbmN0XG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIHQgPSBCeXRlcy50XG5cbiAgICAgIGxldCBjcmVhdGUgfmxlbiA9IEJ5dGVzLmNyZWF0ZSBsZW5cbiAgICAgIGxldCBsZW5ndGggPSBCeXRlcy5sZW5ndGhcblxuICAgICAgbGV0IHVuc2FmZV9ibGl0IH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuID1cbiAgICAgICAgQ2FtbC5CdWZmZXIuYmxpdCBzcmMgc3JjX3BvcyBkc3QgZHN0X3BvcyBsZW5cbiAgICAgIDs7XG4gICAgZW5kKVxuXG5pbmNsdWRlIFRvX2J5dGVzXG5tb2R1bGUgVG9fc3RyaW5nID0gQmxpdC5NYWtlX3RvX3N0cmluZyAoQ2FtbC5CdWZmZXIpIChUb19ieXRlcylcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIFN5cyA9IFN5czBcblxudHlwZSB0ID0gQ2FtbC5QcmludGV4Yy5yYXdfYmFja3RyYWNlXG5cbmxldCBlbGlkZSA9IHJlZiBmYWxzZVxubGV0IGVsaWRlZF9tZXNzYWdlID0gXCI8YmFja3RyYWNlIGVsaWRlZCBpbiB0ZXN0PlwiXG5cbmxldCBnZXQgPyhhdF9tb3N0X251bV9mcmFtZXMgPSBJbnQubWF4X3ZhbHVlKSAoKSA9XG4gIENhbWwuUHJpbnRleGMuZ2V0X2NhbGxzdGFjayBhdF9tb3N0X251bV9mcmFtZXNcbjs7XG5cbmxldCB0b19zdHJpbmcgdCA9XG4gIGlmICFlbGlkZSB0aGVuIGVsaWRlZF9tZXNzYWdlIGVsc2UgQ2FtbC5QcmludGV4Yy5yYXdfYmFja3RyYWNlX3RvX3N0cmluZyB0XG47O1xuXG5sZXQgdG9fc3RyaW5nX2xpc3QgdCA9IFN0cmluZy5zcGxpdF9saW5lcyAodG9fc3RyaW5nIHQpXG5sZXQgc2V4cF9vZl90IHQgPSBTZXhwLkxpc3QgKExpc3QubWFwICh0b19zdHJpbmdfbGlzdCB0KSB+ZjooZnVuIHggLT4gU2V4cC5BdG9tIHgpKVxuXG5tb2R1bGUgRXhuID0gc3RydWN0XG4gIGxldCBzZXRfcmVjb3JkaW5nID0gQ2FtbC5QcmludGV4Yy5yZWNvcmRfYmFja3RyYWNlXG4gIGxldCBhbV9yZWNvcmRpbmcgPSBDYW1sLlByaW50ZXhjLmJhY2t0cmFjZV9zdGF0dXNcbiAgbGV0IG1vc3RfcmVjZW50ICgpID0gQ2FtbC5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKVxuXG4gIGxldCBtb3N0X3JlY2VudF9mb3JfZXhuIGV4biA9XG4gICAgaWYgRXhuLmlzX3BoeXNfZXF1YWxfbW9zdF9yZWNlbnQgZXhuIHRoZW4gU29tZSAobW9zdF9yZWNlbnQgKCkpIGVsc2UgTm9uZVxuICA7O1xuXG4gICgqIFdlIHR1cm4gb24gYmFja3RyYWNlcyBieSBkZWZhdWx0IGlmIE9DQU1MUlVOUEFSQU0gZG9lc24ndCBleHBsaWNpdGx5IG1lbnRpb24gdGhlbS4gKilcbiAgbGV0IG1heWJlX3NldF9yZWNvcmRpbmcgKCkgPVxuICAgIGxldCBvY2FtbHJ1bnBhcmFtX21lbnRpb25zX2JhY2t0cmFjZXMgPVxuICAgICAgbWF0Y2ggU3lzLmdldGVudiBcIk9DQU1MUlVOUEFSQU1cIiB3aXRoXG4gICAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICAgIHwgU29tZSB4IC0+IExpc3QuZXhpc3RzIChTdHJpbmcuc3BsaXQgeCB+b246JywnKSB+ZjooU3RyaW5nLmlzX3ByZWZpeCB+cHJlZml4OlwiYlwiKVxuICAgIGluXG4gICAgaWYgbm90IG9jYW1scnVucGFyYW1fbWVudGlvbnNfYmFja3RyYWNlcyB0aGVuIHNldF9yZWNvcmRpbmcgdHJ1ZVxuICA7O1xuXG4gICgqIHRoZSBjYWxsZXIgc2V0IHNvbWV0aGluZywgdGhleSBhcmUgcmVzcG9uc2libGUgKilcblxuICBsZXQgd2l0aF9yZWNvcmRpbmcgYiB+ZiA9XG4gICAgbGV0IHNhdmVkID0gYW1fcmVjb3JkaW5nICgpIGluXG4gICAgc2V0X3JlY29yZGluZyBiO1xuICAgIEV4bi5wcm90ZWN0IH5mIH5maW5hbGx5OihmdW4gKCkgLT4gc2V0X3JlY29yZGluZyBzYXZlZClcbiAgOztcbmVuZFxuXG5sZXQgaW5pdGlhbGl6ZV9tb2R1bGUgKCkgPSBFeG4ubWF5YmVfc2V0X3JlY29yZGluZyAoKVxuIiwiKCoqIFRoaXMgbW9kdWxlIGlzIHRoZSB0b3BsZXZlbCBvZiB0aGUgQmFzZSBsaWJyYXJ5OyBpdCdzIHdoYXQgeW91IGdldCB3aGVuIHlvdSB3cml0ZVxuICAgIFtvcGVuIEJhc2VdLlxuXG4gICAgVGhlIGdvYWwgb2YgQmFzZSBpcyBib3RoIHRvIGJlIGEgbW9yZSBjb21wbGV0ZSBzdGFuZGFyZCBsaWJyYXJ5LCB3aXRoIHJpY2hlciBBUElzLFxuICAgIGFuZCB0byBiZSBtb3JlIGNvbnNpc3RlbnQgaW4gaXRzIGRlc2lnbi4gRm9yIGluc3RhbmNlLCBpbiB0aGUgc3RhbmRhcmQgbGlicmFyeVxuICAgIHNvbWUgdGhpbmdzIGhhdmUgbW9kdWxlcyBhbmQgb3RoZXJzIGRvbid0OyBpbiBCYXNlLCBldmVyeXRoaW5nIGlzIGEgbW9kdWxlLlxuXG4gICAgQmFzZSBleHRlbmRzIHNvbWUgbW9kdWxlcyBhbmQgZGF0YSBzdHJ1Y3R1cmVzIGZyb20gdGhlIHN0YW5kYXJkIGxpYnJhcnksIGxpa2UgW0FycmF5XSxcbiAgICBbQnVmZmVyXSwgW0J5dGVzXSwgW0NoYXJdLCBbSGFzaHRibF0sIFtJbnQzMl0sIFtJbnQ2NF0sIFtMYXp5XSwgW0xpc3RdLCBbTWFwXSxcbiAgICBbTmF0aXZlaW50XSwgW1ByaW50Zl0sIFtSYW5kb21dLCBbU2V0XSwgW1N0cmluZ10sIFtTeXNdLCBhbmQgW1VjaGFyXS4gT25lIGtleVxuICAgIGRpZmZlcmVuY2UgaXMgdGhhdCBCYXNlIGRvZXNuJ3QgdXNlIGV4Y2VwdGlvbnMgYXMgbXVjaCBhcyB0aGUgc3RhbmRhcmQgbGlicmFyeSBhbmRcbiAgICBpbnN0ZWFkIG1ha2VzIGhlYXZ5IHVzZSBvZiB0aGUgW1Jlc3VsdF0gdHlwZSwgYXMgaW46XG5cbiAgICB7WyB0eXBlICgnYSwnYikgcmVzdWx0ID0gT2sgb2YgJ2EgfCBFcnJvciBvZiAnYiBdfVxuXG4gICAgQmFzZSBhbHNvIGFkZHMgZW50aXJlbHkgbmV3IG1vZHVsZXMsIG1vc3Qgbm90YWJseTpcblxuICAgIC0gW0NvbXBhcmFibGVdLCBbQ29tcGFyYXRvcl0sIGFuZCBbQ29tcGFyaXNvbnNdIGluIGxpZXUgb2YgcG9seW1vcnBoaWMgY29tcGFyZS5cbiAgICAtIFtDb250YWluZXJdLCB3aGljaCBwcm92aWRlcyBhIGNvbnNpc3RlbnQgaW50ZXJmYWNlIGFjcm9zcyBjb250YWluZXItbGlrZSBkYXRhXG4gICAgICBzdHJ1Y3R1cmVzIChhcnJheXMsIGxpc3RzLCBzdHJpbmdzKS5cbiAgICAtIFtSZXN1bHRdLCBbRXJyb3JdLCBhbmQgW09yX2Vycm9yXSwgc3VwcG9ydGluZyB0aGUgb3ItZXJyb3IgcGF0dGVybi5cbiopXG5cbigqXyBXZSBoaWRlIHRoaXMgZnJvbSB0aGUgd2ViIGRvY3MgYmVjYXVzZSB0aGUgbGluZSB3cmFwcGluZyBpcyBiYWQsIG1ha2luZyBpdFxuICBwcmV0dHkgbXVjaCBpbnNjcnV0YWJsZS4gKilcbigqKi8qKilcblxuKCogVGhlIGludGVudCBpcyB0byBzaGFkb3cgYWxsIG9mIElOUklBJ3Mgc3RhbmRhcmQgbGlicmFyeS4gIE1vZHVsZXMgYmVsb3cgd291bGQgY2F1c2VcbiAgIGNvbXBpbGF0aW9uIGVycm9ycyB3aXRob3V0IGJlaW5nIHJlbW92ZWQgZnJvbSBbU2hhZG93X3N0ZGxpYl0gYmVmb3JlIGluY2x1c2lvbi4gKilcblxuaW5jbHVkZSAoXG4gIFNoYWRvd19zdGRsaWIgOlxuICAgIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgIGluY2x1ZGUgU2hhZG93X3N0ZGxpYlxuICBlbmRcbiAgKCogTW9kdWxlcyBkZWZpbmVkIGluIEJhc2UgKilcbiAgd2l0aCBtb2R1bGUgQXJyYXkgOj0gU2hhZG93X3N0ZGxpYi5BcnJheVxuICB3aXRoIG1vZHVsZSBBdG9taWMgOj0gU2hhZG93X3N0ZGxpYi5BdG9taWNcbiAgd2l0aCBtb2R1bGUgQm9vbCA6PSBTaGFkb3dfc3RkbGliLkJvb2xcbiAgd2l0aCBtb2R1bGUgQnVmZmVyIDo9IFNoYWRvd19zdGRsaWIuQnVmZmVyXG4gIHdpdGggbW9kdWxlIEJ5dGVzIDo9IFNoYWRvd19zdGRsaWIuQnl0ZXNcbiAgd2l0aCBtb2R1bGUgQ2hhciA6PSBTaGFkb3dfc3RkbGliLkNoYXJcbiAgd2l0aCBtb2R1bGUgRWl0aGVyIDo9IFNoYWRvd19zdGRsaWIuRWl0aGVyXG4gIHdpdGggbW9kdWxlIEZsb2F0IDo9IFNoYWRvd19zdGRsaWIuRmxvYXRcbiAgd2l0aCBtb2R1bGUgSGFzaHRibCA6PSBTaGFkb3dfc3RkbGliLkhhc2h0YmxcbiAgd2l0aCBtb2R1bGUgSW5fY2hhbm5lbCA6PSBTaGFkb3dfc3RkbGliLkluX2NoYW5uZWxcbiAgd2l0aCBtb2R1bGUgSW50IDo9IFNoYWRvd19zdGRsaWIuSW50XG4gIHdpdGggbW9kdWxlIEludDMyIDo9IFNoYWRvd19zdGRsaWIuSW50MzJcbiAgd2l0aCBtb2R1bGUgSW50NjQgOj0gU2hhZG93X3N0ZGxpYi5JbnQ2NFxuICB3aXRoIG1vZHVsZSBMYXp5IDo9IFNoYWRvd19zdGRsaWIuTGF6eVxuICB3aXRoIG1vZHVsZSBMaXN0IDo9IFNoYWRvd19zdGRsaWIuTGlzdFxuICB3aXRoIG1vZHVsZSBNYXAgOj0gU2hhZG93X3N0ZGxpYi5NYXBcbiAgd2l0aCBtb2R1bGUgTmF0aXZlaW50IDo9IFNoYWRvd19zdGRsaWIuTmF0aXZlaW50XG4gIHdpdGggbW9kdWxlIE9wdGlvbiA6PSBTaGFkb3dfc3RkbGliLk9wdGlvblxuICB3aXRoIG1vZHVsZSBPdXRfY2hhbm5lbCA6PSBTaGFkb3dfc3RkbGliLk91dF9jaGFubmVsXG4gIHdpdGggbW9kdWxlIFByaW50ZiA6PSBTaGFkb3dfc3RkbGliLlByaW50ZlxuICB3aXRoIG1vZHVsZSBRdWV1ZSA6PSBTaGFkb3dfc3RkbGliLlF1ZXVlXG4gIHdpdGggbW9kdWxlIFJhbmRvbSA6PSBTaGFkb3dfc3RkbGliLlJhbmRvbVxuICB3aXRoIG1vZHVsZSBSZXN1bHQgOj0gU2hhZG93X3N0ZGxpYi5SZXN1bHRcbiAgd2l0aCBtb2R1bGUgU2V0IDo9IFNoYWRvd19zdGRsaWIuU2V0XG4gIHdpdGggbW9kdWxlIFN0YWNrIDo9IFNoYWRvd19zdGRsaWIuU3RhY2tcbiAgd2l0aCBtb2R1bGUgU3RyaW5nIDo9IFNoYWRvd19zdGRsaWIuU3RyaW5nXG4gIHdpdGggbW9kdWxlIFN5cyA6PSBTaGFkb3dfc3RkbGliLlN5c1xuICB3aXRoIG1vZHVsZSBVY2hhciA6PSBTaGFkb3dfc3RkbGliLlVjaGFyXG4gIHdpdGggbW9kdWxlIFVuaXQgOj0gU2hhZG93X3N0ZGxpYi5Vbml0XG4gICgqIFN1cHBvcnQgZm9yIGdlbmVyYXRlZCBsZXhlcnMgKilcbiAgd2l0aCBtb2R1bGUgTGV4aW5nIDo9IFNoYWRvd19zdGRsaWIuTGV4aW5nXG4gIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgZm9ybWF0IDo9ICgnYSwgJ2IsICdjKSBmb3JtYXRcbiAgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA6PSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDRcbiAgd2l0aCB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IDo9ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2XG4gIHdpdGggdHlwZSAnYSByZWYgOj0gJ2EgcmVmKSBbQG9jYW1sLndhcm5pbmcgXCItM1wiXVxuXG4oKiovKiopXG5cbm9wZW4hIEltcG9ydFxubW9kdWxlIEFwcGxpY2F0aXZlID0gQXBwbGljYXRpdmVcbm1vZHVsZSBBcnJheSA9IEFycmF5XG5tb2R1bGUgQXZsdHJlZSA9IEF2bHRyZWVcbm1vZHVsZSBCYWNrdHJhY2UgPSBCYWNrdHJhY2Vcbm1vZHVsZSBCaW5hcnlfc2VhcmNoID0gQmluYXJ5X3NlYXJjaFxubW9kdWxlIEJpbmFyeV9zZWFyY2hhYmxlID0gQmluYXJ5X3NlYXJjaGFibGVcbm1vZHVsZSBCbGl0ID0gQmxpdFxubW9kdWxlIEJvb2wgPSBCb29sXG5tb2R1bGUgQnVmZmVyID0gQnVmZmVyXG5tb2R1bGUgQnl0ZXMgPSBCeXRlc1xubW9kdWxlIENoYXIgPSBDaGFyXG5tb2R1bGUgQ29tcGFyYWJsZSA9IENvbXBhcmFibGVcbm1vZHVsZSBDb21wYXJhdG9yID0gQ29tcGFyYXRvclxubW9kdWxlIENvbXBhcmlzb25zID0gQ29tcGFyaXNvbnNcbm1vZHVsZSBDb250YWluZXIgPSBDb250YWluZXJcbm1vZHVsZSBFaXRoZXIgPSBFaXRoZXJcbm1vZHVsZSBFcXVhbCA9IEVxdWFsXG5tb2R1bGUgRXJyb3IgPSBFcnJvclxubW9kdWxlIEV4biA9IEV4blxubW9kdWxlIEZpZWxkID0gRmllbGRcbm1vZHVsZSBGbG9hdCA9IEZsb2F0XG5tb2R1bGUgRmxvYXRhYmxlID0gRmxvYXRhYmxlXG5tb2R1bGUgRm4gPSBGblxubW9kdWxlIEZvcm1hdHRlciA9IEZvcm1hdHRlclxubW9kdWxlIEhhc2ggPSBIYXNoXG5tb2R1bGUgSGFzaF9zZXQgPSBIYXNoX3NldFxubW9kdWxlIEhhc2hhYmxlID0gSGFzaGFibGVcbm1vZHVsZSBIYXNoZXIgPSBIYXNoZXJcbm1vZHVsZSBIYXNodGJsID0gSGFzaHRibFxubW9kdWxlIElkZW50aWZpYWJsZSA9IElkZW50aWZpYWJsZVxubW9kdWxlIEluZGV4ZWRfY29udGFpbmVyID0gSW5kZXhlZF9jb250YWluZXJcbm1vZHVsZSBJbmZvID0gSW5mb1xubW9kdWxlIEludCA9IEludFxubW9kdWxlIEludF9jb252ZXJzaW9ucyA9IEludF9jb252ZXJzaW9uc1xubW9kdWxlIEludDMyID0gSW50MzJcbm1vZHVsZSBJbnQ2MyA9IEludDYzXG5tb2R1bGUgSW50NjQgPSBJbnQ2NFxubW9kdWxlIEludGFibGUgPSBJbnRhYmxlXG5tb2R1bGUgSW50X21hdGggPSBJbnRfbWF0aFxubW9kdWxlIEludmFyaWFudCA9IEludmFyaWFudFxubW9kdWxlIExhenkgPSBMYXp5XG5tb2R1bGUgTGlzdCA9IExpc3Rcbm1vZHVsZSBNYXAgPSBNYXBcbm1vZHVsZSBNYXliZV9ib3VuZCA9IE1heWJlX2JvdW5kXG5tb2R1bGUgTW9uYWQgPSBNb25hZFxubW9kdWxlIE5hdGl2ZWludCA9IE5hdGl2ZWludFxubW9kdWxlIE5vdGhpbmcgPSBOb3RoaW5nXG5tb2R1bGUgT3B0aW9uID0gT3B0aW9uXG5tb2R1bGUgT3B0aW9uX2FycmF5ID0gT3B0aW9uX2FycmF5XG5tb2R1bGUgT3JfZXJyb3IgPSBPcl9lcnJvclxubW9kdWxlIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24gPSBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uXG5tb2R1bGUgT3JkZXJpbmcgPSBPcmRlcmluZ1xubW9kdWxlIFBvbHkgPSBQb2x5XG5tb2R1bGUgUG9seW1vcnBoaWNfY29tcGFyZSA9IFBvbHkgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE4LTExXSB1c2UgW1BvbHldIGluc3RlYWRcIl1cblxubW9kdWxlIFBvcGNvdW50ID0gUG9wY291bnRcbltAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxOC0xMF0gdXNlIFtwb3Bjb3VudF0gZnVuY3Rpb25zIGluIHRoZSBpbmRpdmlkdWFsIGludCBtb2R1bGVzXCJdXG5cbm1vZHVsZSBQcmV0dHlfcHJpbnRlciA9IFByZXR0eV9wcmludGVyXG5tb2R1bGUgUHJpbnRmID0gUHJpbnRmXG5tb2R1bGUgTGlua2VkX3F1ZXVlID0gTGlua2VkX3F1ZXVlXG5tb2R1bGUgUXVldWUgPSBRdWV1ZVxubW9kdWxlIFJhbmRvbSA9IFJhbmRvbVxubW9kdWxlIFJlZiA9IFJlZlxubW9kdWxlIFJlc3VsdCA9IFJlc3VsdFxubW9kdWxlIFNlcXVlbmNlID0gU2VxdWVuY2Vcbm1vZHVsZSBTZXQgPSBTZXRcbm1vZHVsZSBTZXhwYWJsZSA9IFNleHBhYmxlXG5tb2R1bGUgU2lnbiA9IFNpZ25cbm1vZHVsZSBTaWduX29yX25hbiA9IFNpZ25fb3JfbmFuXG5tb2R1bGUgU291cmNlX2NvZGVfcG9zaXRpb24gPSBTb3VyY2VfY29kZV9wb3NpdGlvblxubW9kdWxlIFN0YWNrID0gU3RhY2tcbm1vZHVsZSBTdGFnZWQgPSBTdGFnZWRcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmdcbm1vZHVsZSBTdHJpbmdhYmxlID0gU3RyaW5nYWJsZVxubW9kdWxlIFN5cyA9IFN5c1xubW9kdWxlIFQgPSBUXG5tb2R1bGUgVHlwZV9lcXVhbCA9IFR5cGVfZXF1YWxcbm1vZHVsZSBVbmlmb3JtX2FycmF5ID0gVW5pZm9ybV9hcnJheVxubW9kdWxlIFVuaXQgPSBVbml0XG5tb2R1bGUgVWNoYXIgPSBVY2hhclxubW9kdWxlIFZhcmlhbnQgPSBWYXJpYW50XG5tb2R1bGUgV2l0aF9yZXR1cm4gPSBXaXRoX3JldHVyblxubW9kdWxlIFdvcmRfc2l6ZSA9IFdvcmRfc2l6ZVxuXG4oKiBBdm9pZCBhIGxldmVsIG9mIGluZGlyZWN0aW9uIGZvciB1c2VzIG9mIHRoZSBzaWduYXR1cmVzIGRlZmluZWQgaW4gW1RdLiAqKVxuaW5jbHVkZSBUXG5cbigqIFRoaXMgaXMgYSBoYWNrIHNvIHRoYXQgb2RvYyBjcmVhdGVzIGJldHRlciBkb2N1bWVudGF0aW9uLiAqKVxubW9kdWxlIFNleHAgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTZXhwX3dpdGhfY29tcGFyYWJsZSAoKiogQGlubGluZSAqKVxuZW5kXG5cbigqKi8qKilcblxubW9kdWxlIEV4cG9ydGVkX2Zvcl9zcGVjaWZpY191c2VzID0gc3RydWN0XG4gIG1vZHVsZSBGaWVsZHNsaWIgPSBGaWVsZHNsaWJcbiAgbW9kdWxlIFBweF9oYXNoX2xpYiA9IFBweF9oYXNoX2xpYlxuICBtb2R1bGUgVmFyaWFudHNsaWIgPSBWYXJpYW50c2xpYlxuICBtb2R1bGUgUHB4X2NvbXBhcmVfbGliID0gUHB4X2NvbXBhcmVfbGliXG4gIG1vZHVsZSBQcHhfZW51bWVyYXRlX2xpYiA9IFBweF9lbnVtZXJhdGVfbGliXG5cbiAgbGV0IGFtX3Rlc3RpbmcgPSBhbV90ZXN0aW5nXG5lbmRcblxuKCoqLyoqKVxuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gICgqIFtkZXJpdmluZyBoYXNoXSBpcyBtaXNzaW5nIGZvciBbYXJyYXldIGFuZCBbcmVmXSBzaW5jZSB0aGVzZSB0eXBlcyBhcmUgbXV0YWJsZS4gKilcbiAgdHlwZSAnYSBhcnJheSA9ICdhIEFycmF5LnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfYXJyYXkgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gaW50ID0gQXJyYXkuY29tcGFyZVxuICBsZXQgZXF1YWxfYXJyYXkgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIGFycmF5IC0+ICdhIGFycmF5IC0+IGJvb2wgPSBBcnJheS5lcXVhbFxuXG4gIGxldCBhcnJheV9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSBhcnJheSA9XG4gICAgQXJyYXkudF9vZl9zZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfYXJyYXkgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgYXJyYXkgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBBcnJheS5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgKGFycmF5X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSBhcnJheSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gQXJyYXkudF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBib29sID0gQm9vbC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2Jvb2wgPSAoQm9vbC5jb21wYXJlIDogYm9vbCAtPiBib29sIC0+IGludClcbiAgbGV0IGVxdWFsX2Jvb2wgPSAoQm9vbC5lcXVhbCA6IGJvb2wgLT4gYm9vbCAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX2Jvb2wgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGJvb2wgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBCb29sLmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2Jvb2wgOiBib29sIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBCb29sLmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgYm9vbF9vZl9zZXhwID0gKEJvb2wudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGJvb2wpXG4gIGxldCBzZXhwX29mX2Jvb2wgPSAoQm9vbC5zZXhwX29mX3QgOiBib29sIC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChib29sX3NleHBfZ3JhbW1hciA6IGJvb2wgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gQm9vbC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBjaGFyID0gQ2hhci50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2NoYXIgPSAoQ2hhci5jb21wYXJlIDogY2hhciAtPiBjaGFyIC0+IGludClcbiAgbGV0IGVxdWFsX2NoYXIgPSAoQ2hhci5lcXVhbCA6IGNoYXIgLT4gY2hhciAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX2NoYXIgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGNoYXIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBDaGFyLmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2NoYXIgOiBjaGFyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBDaGFyLmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgY2hhcl9vZl9zZXhwID0gKENoYXIudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGNoYXIpXG4gIGxldCBzZXhwX29mX2NoYXIgPSAoQ2hhci5zZXhwX29mX3QgOiBjaGFyIC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChjaGFyX3NleHBfZ3JhbW1hciA6IGNoYXIgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gQ2hhci50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBleG4gPSBFeG4udCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICBsZXQgc2V4cF9vZl9leG4gPSAoRXhuLnNleHBfb2ZfdCA6IGV4biAtPiBTZXhwbGliMC5TZXhwLnQpXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGZsb2F0ID0gRmxvYXQudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9mbG9hdCA9IChGbG9hdC5jb21wYXJlIDogZmxvYXQgLT4gZmxvYXQgLT4gaW50KVxuICBsZXQgZXF1YWxfZmxvYXQgPSAoRmxvYXQuZXF1YWwgOiBmbG9hdCAtPiBmbG9hdCAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX2Zsb2F0IDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBmbG9hdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIEZsb2F0Lmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2Zsb2F0IDogZmxvYXQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IEZsb2F0Lmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgZmxvYXRfb2Zfc2V4cCA9IChGbG9hdC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gZmxvYXQpXG4gIGxldCBzZXhwX29mX2Zsb2F0ID0gKEZsb2F0LnNleHBfb2ZfdCA6IGZsb2F0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChmbG9hdF9zZXhwX2dyYW1tYXIgOiBmbG9hdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBGbG9hdC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBpbnQgPSBJbnQudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9pbnQgPSAoSW50LmNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludClcbiAgbGV0IGVxdWFsX2ludCA9IChJbnQuZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfaW50IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGludCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBJbnQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfaW50IDogaW50IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBJbnQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBpbnRfb2Zfc2V4cCA9IChJbnQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGludClcbiAgbGV0IHNleHBfb2ZfaW50ID0gKEludC5zZXhwX29mX3QgOiBpbnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGludF9zZXhwX2dyYW1tYXIgOiBpbnQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gSW50LnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGludDMyID0gSW50MzIudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9pbnQzMiA9IChJbnQzMi5jb21wYXJlIDogaW50MzIgLT4gaW50MzIgLT4gaW50KVxuICBsZXQgZXF1YWxfaW50MzIgPSAoSW50MzIuZXF1YWwgOiBpbnQzMiAtPiBpbnQzMiAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX2ludDMyIDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBpbnQzMiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIEludDMyLmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2ludDMyIDogaW50MzIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IEludDMyLmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgaW50MzJfb2Zfc2V4cCA9IChJbnQzMi50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gaW50MzIpXG4gIGxldCBzZXhwX29mX2ludDMyID0gKEludDMyLnNleHBfb2ZfdCA6IGludDMyIC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChpbnQzMl9zZXhwX2dyYW1tYXIgOiBpbnQzMiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBJbnQzMi50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBpbnQ2NCA9IEludDY0LnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfaW50NjQgPSAoSW50NjQuY29tcGFyZSA6IGludDY0IC0+IGludDY0IC0+IGludClcbiAgbGV0IGVxdWFsX2ludDY0ID0gKEludDY0LmVxdWFsIDogaW50NjQgLT4gaW50NjQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9pbnQ2NCA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50NjQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBJbnQ2NC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9pbnQ2NCA6IGludDY0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBJbnQ2NC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGludDY0X29mX3NleHAgPSAoSW50NjQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IGludDY0KVxuICBsZXQgc2V4cF9vZl9pbnQ2NCA9IChJbnQ2NC5zZXhwX29mX3QgOiBpbnQ2NCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoaW50NjRfc2V4cF9ncmFtbWFyIDogaW50NjQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gSW50NjQudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgJ2EgbGlzdCA9ICdhIExpc3QudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9saXN0IDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIGxpc3QgLT4gJ2EgbGlzdCAtPiBpbnQgPSBMaXN0LmNvbXBhcmVcbiAgbGV0IGVxdWFsX2xpc3QgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIGxpc3QgLT4gJ2EgbGlzdCAtPiBib29sID0gTGlzdC5lcXVhbFxuXG4gIGxldCBoYXNoX2ZvbGRfbGlzdCA6XG4gICAgJ2EuXG4gICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiAnYSAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgLT4gJ2EgbGlzdFxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgID1cbiAgICBMaXN0Lmhhc2hfZm9sZF90XG4gIDs7XG5cbiAgbGV0IGxpc3Rfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgbGlzdCA9XG4gICAgTGlzdC50X29mX3NleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl9saXN0IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIGxpc3QgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBMaXN0LnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCAobGlzdF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSBsaXN0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gTGlzdC50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIG5hdGl2ZWludCA9IE5hdGl2ZWludC50XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX25hdGl2ZWludCA9IChOYXRpdmVpbnQuY29tcGFyZSA6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gaW50KVxuICBsZXQgZXF1YWxfbmF0aXZlaW50ID0gKE5hdGl2ZWludC5lcXVhbCA6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9uYXRpdmVpbnQgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IG5hdGl2ZWludCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIE5hdGl2ZWludC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IE5hdGl2ZWludC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IG5hdGl2ZWludF9vZl9zZXhwID0gKE5hdGl2ZWludC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gbmF0aXZlaW50KVxuICBsZXQgc2V4cF9vZl9uYXRpdmVpbnQgPSAoTmF0aXZlaW50LnNleHBfb2ZfdCA6IG5hdGl2ZWludCAtPiBTZXhwbGliMC5TZXhwLnQpXG5cbiAgbGV0IChuYXRpdmVpbnRfc2V4cF9ncmFtbWFyIDogbmF0aXZlaW50IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gICAgTmF0aXZlaW50LnRfc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlICdhIG9wdGlvbiA9ICdhIE9wdGlvbi50XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX29wdGlvbiA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBvcHRpb24gLT4gJ2Egb3B0aW9uIC0+IGludCA9XG4gICAgT3B0aW9uLmNvbXBhcmVcbiAgOztcblxuICBsZXQgZXF1YWxfb3B0aW9uIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSBvcHRpb24gLT4gJ2Egb3B0aW9uIC0+IGJvb2wgPVxuICAgIE9wdGlvbi5lcXVhbFxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfb3B0aW9uIDpcbiAgICAnYS5cbiAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+ICdhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAtPiAnYSBvcHRpb25cbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICA9XG4gICAgT3B0aW9uLmhhc2hfZm9sZF90XG4gIDs7XG5cbiAgbGV0IG9wdGlvbl9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSBvcHRpb24gPVxuICAgIE9wdGlvbi50X29mX3NleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl9vcHRpb24gOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2Egb3B0aW9uIC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgT3B0aW9uLnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCAob3B0aW9uX3NleHBfZ3JhbW1hciA6XG4gICAgICAgICAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSBvcHRpb24gU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gICAgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IE9wdGlvbi50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlICdhIHJlZiA9ICdhIFJlZi50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX3JlZiA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSByZWYgLT4gJ2EgcmVmIC0+IGludCA9IFJlZi5jb21wYXJlXG4gIGxldCBlcXVhbF9yZWYgOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHJlZiAtPiAnYSByZWYgLT4gYm9vbCA9IFJlZi5lcXVhbFxuXG4gIGxldCByZWZfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgcmVmID1cbiAgICBSZWYudF9vZl9zZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfcmVmIDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHJlZiAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIFJlZi5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgKHJlZl9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSByZWYgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBSZWYudF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBzdHJpbmcgPSBTdHJpbmcudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9zdHJpbmcgPSAoU3RyaW5nLmNvbXBhcmUgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGludClcbiAgbGV0IGVxdWFsX3N0cmluZyA9IChTdHJpbmcuZXF1YWwgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfc3RyaW5nIDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBzdHJpbmcgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBTdHJpbmcuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfc3RyaW5nIDogc3RyaW5nIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBTdHJpbmcuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBzdHJpbmdfb2Zfc2V4cCA9IChTdHJpbmcudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHN0cmluZylcbiAgbGV0IHNleHBfb2Zfc3RyaW5nID0gKFN0cmluZy5zZXhwX29mX3QgOiBzdHJpbmcgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHN0cmluZ19zZXhwX2dyYW1tYXIgOiBzdHJpbmcgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gU3RyaW5nLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGJ5dGVzID0gQnl0ZXMudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9ieXRlcyA9IChCeXRlcy5jb21wYXJlIDogYnl0ZXMgLT4gYnl0ZXMgLT4gaW50KVxuICBsZXQgZXF1YWxfYnl0ZXMgPSAoQnl0ZXMuZXF1YWwgOiBieXRlcyAtPiBieXRlcyAtPiBib29sKVxuICBsZXQgYnl0ZXNfb2Zfc2V4cCA9IChCeXRlcy50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gYnl0ZXMpXG4gIGxldCBzZXhwX29mX2J5dGVzID0gKEJ5dGVzLnNleHBfb2ZfdCA6IGJ5dGVzIC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChieXRlc19zZXhwX2dyYW1tYXIgOiBieXRlcyBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBCeXRlcy50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSB1bml0ID0gVW5pdC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX3VuaXQgPSAoVW5pdC5jb21wYXJlIDogdW5pdCAtPiB1bml0IC0+IGludClcbiAgbGV0IGVxdWFsX3VuaXQgPSAoVW5pdC5lcXVhbCA6IHVuaXQgLT4gdW5pdCAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX3VuaXQgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHVuaXQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgID1cbiAgICBVbml0Lmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX3VuaXQgOiB1bml0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBVbml0Lmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdW5pdF9vZl9zZXhwID0gKFVuaXQudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHVuaXQpXG4gIGxldCBzZXhwX29mX3VuaXQgPSAoVW5pdC5zZXhwX29mX3QgOiB1bml0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh1bml0X3NleHBfZ3JhbW1hciA6IHVuaXQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gVW5pdC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgKCoqIEZvcm1hdCBzdHVmZiAqKVxuXG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYykgZm9ybWF0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA9ICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NFxuICB0eXBlIG5vbnJlYyAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2XG5cbiAgKCoqIExpc3Qgb3BlcmF0b3JzICopXG5cbiAgaW5jbHVkZSBMaXN0LkluZml4XG5cbiAgKCoqIEludCBvcGVyYXRvcnMgYW5kIGNvbXBhcmlzb25zICopXG5cbiAgaW5jbHVkZSBJbnQuT1xuICBpbmNsdWRlIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICAoKiogRmxvYXQgb3BlcmF0b3JzICopXG5cbiAgaW5jbHVkZSBGbG9hdC5PX2RvdFxuXG4gICgqIFRoaXMgaXMgZGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgdG8gYmUgb3B0aW1pemVkIGF3YXkgaW4gbW9yZSBjb250ZXh0cy4gKilcblxuICAoKiogUmV2ZXJzZSBhcHBsaWNhdGlvbiBvcGVyYXRvci4gW3ggfD4gZyB8PiBmXSBpcyBlcXVpdmFsZW50IHRvIFtmIChnICh4KSldLiAqKVxuICBleHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuXG4gICgqKiBBcHBsaWNhdGlvbiBvcGVyYXRvci4gW2cgQEAgZiBAQCB4XSBpcyBlcXVpdmFsZW50IHRvIFtnIChmICh4KSldLiAqKVxuICBleHRlcm5hbCAoIEBAICkgOiAoJ2EgLT4gJ2IpIC0+ICdhIC0+ICdiID0gXCIlYXBwbHlcIlxuXG4gICgqKiBCb29sZWFuIG9wZXJhdGlvbnMgKilcblxuICAoKiBUaGVzZSBuZWVkIHRvIGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIHRvIGdldCB0aGUgbGF6eSBiZWhhdmlvciAqKVxuICBleHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuICBleHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG4gIGV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuXG4gICgqIFRoaXMgbXVzdCBiZSBkZWNsYXJlZCBhcyBhbiBleHRlcm5hbCBmb3IgdGhlIHdhcm5pbmdzIHRvIHdvcmsgcHJvcGVybHkuICopXG4gIGV4dGVybmFsIGlnbm9yZSA6IF8gLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbiAgKCoqIENvbW1vbiBzdHJpbmcgb3BlcmF0aW9ucyAqKVxuICBsZXQgKCBeICkgPSBTdHJpbmcuKCBeIClcblxuICAoKiogUmVmZXJlbmNlIG9wZXJhdGlvbnMgKilcblxuICAoKiBEZWNsYXJlZCBhcyBhbiBleHRlcm5hbHMgc28gdGhhdCB0aGUgY29tcGlsZXIgc2tpcHMgdGhlIGNhbWxfbW9kaWZ5IHdoZW4gcG9zc2libGUgYW5kXG4gICAgIHRvIGtlZXAgcmVmZXJlbmNlIHVuYm94aW5nIHdvcmtpbmcgKilcbiAgZXh0ZXJuYWwgKCAhICkgOiAnYSByZWYgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuICBleHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG4gIGV4dGVybmFsICggOj0gKSA6ICdhIHJlZiAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcblxuICAoKiogUGFpciBvcGVyYXRpb25zICopXG5cbiAgbGV0IGZzdCA9IGZzdFxuICBsZXQgc25kID0gc25kXG5cbiAgKCoqIEV4Y2VwdGlvbnMgc3R1ZmYgKilcblxuICAoKiBEZWNsYXJlZCBhcyBhbiBleHRlcm5hbCBzbyB0aGF0IHRoZSBjb21waWxlciBtYXkgcmV3cml0ZSAnJXJhaXNlJyBhcyAnJXJlcmFpc2UnLiAqKVxuICBleHRlcm5hbCByYWlzZSA6IGV4biAtPiBfID0gXCIlcmFpc2VcIlxuXG4gIGxldCBmYWlsd2l0aCA9IGZhaWx3aXRoXG4gIGxldCBpbnZhbGlkX2FyZyA9IGludmFsaWRfYXJnXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gICgqKiBNaXNjICopXG5cbiAgbGV0IHBoeXNfZXF1YWwgPSBwaHlzX2VxdWFsXG5cbiAgZXh0ZXJuYWwgZm9yY2UgOiAnYSBMYXp5LnQgLT4gJ2EgPSBcIiVsYXp5X2ZvcmNlXCJcbmVuZFxuXG5pbmNsdWRlIEV4cG9ydFxuXG5pbmNsdWRlIENvbnRhaW5lcl9pbnRmLkV4cG9ydCAoKiogQGlubGluZSAqKVxuXG5leGNlcHRpb24gTm90X2ZvdW5kX3MgPSBOb3RfZm91bmRfc1xuXG4oKiBXZSBwZXJmb3JtIHRoZXNlIHNpZGUgZWZmZWN0cyBoZXJlIGJlY2F1c2Ugd2Ugd2FudCB0aGVtIHRvIHJ1biBmb3IgYW55IGNvZGUgdGhhdCB1c2VzXG4gICBbQmFzZV0uICBJZiB0aGlzIHdlcmUgaW4gYW5vdGhlciBtb2R1bGUgaW4gW0Jhc2VdIHRoYXQgd2FzIG5vdCB1c2VkIGluIHNvbWUgcHJvZ3JhbSxcbiAgIHRoZW4gdGhlIHNpZGUgZWZmZWN0cyBtaWdodCBub3QgYmUgcnVuIGluIHRoYXQgcHJvZ3JhbS4gIFRoaXMgd2lsbCBydW4gYXMgbG9uZyBhcyB0aGVcbiAgIHByb2dyYW0gcmVmZXJzIHRvIGF0IGxlYXN0IG9uZSB2YWx1ZSBkaXJlY3RseSBpbiBbQmFzZV07IHJlZmVycmluZyB0byB2YWx1ZXMgaW5cbiAgIFtCYXNlLkJvb2xdLCBmb3IgZXhhbXBsZSwgaXMgbm90IHN1ZmZpY2llbnQuICopXG5sZXQgKCkgPSBCYWNrdHJhY2UuaW5pdGlhbGl6ZV9tb2R1bGUgKClcbiJdfQ==
