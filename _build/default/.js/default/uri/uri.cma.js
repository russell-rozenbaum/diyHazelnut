// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1+5.8.1

//# unitInfo: Provides: Uri
//# unitInfo: Requires: Angstrom, CamlinternalLazy, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Char, Stdlib__Format, Stdlib__Lazy, Stdlib__List, Stdlib__Option, Stdlib__Printf, Stdlib__Result, Stdlib__String, Stringext
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$34 = "",
    cst$37 = ",",
    cst$36 = ".",
    cst$39 = "..",
    cst$33 = "/",
    cst$38 = "//",
    cst$35 = ":",
    cst_http = "http",
    cst_https = "https",
    cst_int_of_hex_char$1 = "int_of_hex_char",
    cst_localhost$0 = "localhost",
    caml_check_bound = runtime.caml_check_bound,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$32 = cst$33,
    x = cst_http,
    x$0 = cst_https,
    cst$31 = cst$34,
    cst$30 = cst$33,
    cst$28 = cst$34,
    cst$24 = cst$35,
    cst$25 = cst$35,
    cst$26 = "::",
    cst$23 = cst$34,
    cst$21 = cst$36,
    cst$22 = cst$36,
    cst$20 = cst$34,
    cst$19 = cst$34,
    cst$18 = cst$33,
    cst$17 = cst$37,
    cst$16 = cst$33,
    cst$15 = cst$34,
    cst$13 = cst$34,
    cst$14 = cst$34,
    cst$12 = cst$34,
    cst$9 = cst$38,
    cst$10 = cst$35,
    cst$11 = "./",
    cst$8 = cst$37,
    cst$7 = "&",
    cst$6 = cst$33,
    cst$5 = cst$33,
    cst$4 = cst$34,
    cst$2 = cst$33,
    cst$3 = cst$33,
    cst$0 = cst$33,
    cst$1 = cst$33,
    cst = cst$34,
    cst$27 = cst$34,
    cst$29 = cst$38,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Angstrom = global_data.Angstrom,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Format = global_data.Stdlib__Format,
    Stringext = global_data.Stringext,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Result = global_data.Stdlib__Result;
   function iter_concat(fn, sep, buf, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var last = param$0[1];
     if(! param$0[2]) return caml_call2(fn, buf, last);
     var rest = param$0[2];
     caml_call2(fn, buf, last);
     caml_call2(Stdlib_Buffer[16], buf, sep);
     param$0 = rest;
    }
   }
   function compare_opt(c, t$0, t){
    if(! t$0) return t ? -1 : 0;
    var a = t$0[1];
    if(! t) return 1;
    var b = t[1];
    return caml_call2(c, a, b);
   }
   function compare_list(f, t$0, t){
    var t$2 = t$0, t$1 = t;
    for(;;){
     if(! t$2) return t$1 ? -1 : 0;
     var xs = t$2[2], x = t$2[1];
     if(! t$1) return 1;
     var ys = t$1[2], y = t$1[1], c = caml_call2(f, x, y);
     if(0 !== c) return c;
     t$2 = xs;
     t$1 = ys;
    }
   }
   function sub_delims(a){
    var i = 0;
    for(;;){
     var c = caml_string_get("!$&'()*+,;=", i);
     caml_check_bound(a, c)[1 + c] = 1;
     var _dg_ = i + 1 | 0;
     if(10 === i) return a;
     i = _dg_;
    }
   }
   var
    safe_chars = caml_make_vect(256, 0),
    i = 0,
    _au_ = [0, 0],
    _ap_ = [0, 3854881, "host is required for HTTP(S) uris"],
    _ar_ = [0, -1042355253],
    _as_ = [0, 804243368],
    _aq_ =
      [0,
       [11,
        "Only http and https URIs are supported. ",
        [2, 0, [11, " is invalid.", 0]]],
       "Only http and https URIs are supported. %s is invalid."],
    _at_ = [1, [0, 3854881, "No scheme present in URI"]],
    _ao_ = [0, cst$34],
    _an_ = [0, 0],
    _v_ = [0, 0, 0],
    cst_too_many_parts_in_IPv6_add = "too many parts in IPv6 address",
    _u_ = [0, cst$34, 0],
    cst_invalid_octect = "invalid octect",
    _k_ = [0, [11, "/?", [2, 0, 0]], "/?%s"],
    _j_ = [0, [2, 0, [12, 63, [2, 0, 0]]], "%s?%s"],
    cst_localhost = cst_localhost$0,
    _f_ = [0, cst$34, 0],
    _g_ = [0, cst$34, 0],
    _h_ = [0, 2],
    _i_ = [0, [0, cst$34, 0], 0],
    _c_ = [0, 2],
    _d_ = [0, cst$34, 0],
    cst_int_of_hex_char = cst_int_of_hex_char$1,
    cst_int_of_hex_char$0 = cst_int_of_hex_char$1,
    _b_ = [0, [12, 37, [4, 8, [0, 2, 2], 0, 0]], "%%%02X"],
    _a_ = [0, cst$33, 0],
    _W_ = [0, 0, 0, 0];
   for(;;){
    var
     c =
       caml_string_get
        ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-~",
         i);
    caml_check_bound(safe_chars, c)[1 + c] = 1;
    var _av_ = i + 1 | 0;
    if(65 === i) break;
    i = _av_;
   }
   var pchar = sub_delims(caml_call1(Stdlib_Array[8], safe_chars));
   caml_check_bound(pchar, 58)[59] = 1;
   caml_check_bound(pchar, 64)[65] = 1;
   var safe_chars_for_scheme = caml_call1(Stdlib_Array[8], safe_chars);
   caml_check_bound(safe_chars_for_scheme, 43)[44] = 1;
   var safe_chars_for_path = sub_delims(caml_call1(Stdlib_Array[8], pchar));
   caml_check_bound(safe_chars_for_path, 47)[48] = 0;
   var safe_chars_for_query = caml_call1(Stdlib_Array[8], pchar);
   caml_check_bound(safe_chars_for_query, 47)[48] = 1;
   caml_check_bound(safe_chars_for_query, 63)[64] = 1;
   caml_check_bound(safe_chars_for_query, 38)[39] = 0;
   caml_check_bound(safe_chars_for_query, 59)[60] = 0;
   caml_check_bound(safe_chars_for_query, 43)[44] = 0;
   var
    safe_chars_for_query_key =
      caml_call1(Stdlib_Array[8], safe_chars_for_query);
   caml_check_bound(safe_chars_for_query_key, 61)[62] = 0;
   var
    safe_chars_for_query_value =
      caml_call1(Stdlib_Array[8], safe_chars_for_query);
   caml_check_bound(safe_chars_for_query_value, 44)[45] = 0;
   var safe_chars_for_userinfo = caml_call1(Stdlib_Array[8], safe_chars);
   caml_check_bound(safe_chars_for_userinfo, 58)[59] = 0;
   function safe_chars_for_component(param){
    if(typeof param === "number")
     if(-145160102 <= param){
      if(127343601 <= param){
       if(795008922 === param) return safe_chars_for_query_value;
       if(892015045 === param) return safe_chars_for_path;
      }
      else if(61643255 !== param && 127343600 <= param)
       return safe_chars_for_query;
     }
     else if(-250086679 <= param){
      if(-178940859 === param) return safe_chars_for_scheme;
      if(-145160103 <= param) return safe_chars_for_userinfo;
     }
     else{
      if(-911188600 === param) return safe_chars_for_query_key;
      if(-250086680 <= param) return safe_chars_for_query;
     }
    else if(-198771759 === param[1]){
     var
      match = param[2],
      unsafe = match[3],
      safe = match[2],
      component = match[1],
      _c$_ = safe_chars_for_component(component),
      safe_chars$0 = caml_call1(Stdlib_Array[8], _c$_),
      _db_ = caml_ml_string_length(safe) - 1 | 0,
      _da_ = 0;
     if(_db_ >= 0){
      var i$0 = _da_;
      for(;;){
       var c$0 = caml_string_get(safe, i$0);
       caml_check_bound(safe_chars$0, c$0)[1 + c$0] = 1;
       var _df_ = i$0 + 1 | 0;
       if(_db_ === i$0) break;
       i$0 = _df_;
      }
     }
     var _dd_ = caml_ml_string_length(unsafe) - 1 | 0, _dc_ = 0;
     if(_dd_ >= 0){
      var i = _dc_;
      for(;;){
       var c = caml_string_get(unsafe, i);
       caml_check_bound(safe_chars$0, c)[1 + c] = 0;
       var _de_ = i + 1 | 0;
       if(_dd_ === i) break;
       i = _de_;
      }
     }
     return safe_chars$0;
    }
    return safe_chars;
   }
   function normalize_host(hso){return hso;}
   function canonicalize_port(port){return port;}
   function canonicalize_path(path){return path;}
   var
    Generic =
      [0,
       safe_chars_for_component,
       normalize_host,
       canonicalize_port,
       canonicalize_path],
    safe_chars_for_component$0 = Generic[1];
   function normalize_host$0(hs){return caml_call1(Stdlib_String[26], hs);}
   function canonicalize_port$0(param){
    if(! param) return 0;
    var x = param[1];
    return 80 === x ? 0 : [0, x];
   }
   function canonicalize_path$0(x){return x ? x : _a_;}
   var
    Http =
      [0,
       safe_chars_for_component$0,
       normalize_host$0,
       canonicalize_port$0,
       canonicalize_path$0],
    safe_chars_for_component$1 = Http[1],
    normalize_host$1 = Http[2],
    canonicalize_path$1 = Http[4];
   function canonicalize_port$1(param){
    if(! param) return 0;
    var x = param[1];
    return 443 === x ? 0 : [0, x];
   }
   var
    Https =
      [0,
       safe_chars_for_component$1,
       normalize_host$1,
       canonicalize_port$1,
       canonicalize_path$1],
    safe_chars_for_component$2 = Generic[1],
    canonicalize_port$2 = Generic[3],
    canonicalize_path$2 = Generic[4];
   function normalize_host$2(hs){
    var hs$0 = caml_call1(Stdlib_String[26], hs);
    return hs$0 == cst_localhost$0 ? cst : hs$0;
   }
   var
    File =
      [0,
       safe_chars_for_component$2,
       normalize_host$2,
       canonicalize_port$2,
       canonicalize_path$2],
    safe_chars_for_component$3 = Generic[1],
    normalize_host$3 = Generic[2],
    canonicalize_port$3 = Generic[3],
    canonicalize_path$3 = Generic[4],
    Urn =
      [0,
       safe_chars_for_component$3,
       normalize_host$3,
       canonicalize_port$3,
       canonicalize_path$3];
   function module_of_scheme(param){
    if(! param) return Generic;
    var s = param[1], match = caml_call1(Stdlib_String[26], s);
    return match !== "file"
            ? match
              !== cst_http
              ? match !== cst_https ? match !== "urn" ? Generic : Urn : Https
              : Http
            : File;
   }
   function encode(scheme, opt, b){
    if(opt) var sth = opt[1], component = sth; else var component = 892015045;
    var
     Scheme = module_of_scheme(scheme),
     safe_chars = Scheme[1].call(null, component),
     len = caml_ml_string_length(b),
     buf = caml_call1(Stdlib_Buffer[1], len),
     start = 0,
     cur = 0;
    for(;;){
     if(len <= cur){
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      return caml_call1(Stdlib_Buffer[2], buf);
     }
     var c = caml_string_get(b, cur);
     if(caml_check_bound(safe_chars, c)[1 + c]){var cur$0 = cur + 1 | 0; cur = cur$0;}
     else{
      if(start < cur)
       caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      var _c__ = caml_call2(Stdlib_Printf[4], _b_, c);
      caml_call2(Stdlib_Buffer[16], buf, _c__);
      var cur$1 = cur + 1 | 0, start$0 = cur + 1 | 0;
      start = start$0;
      cur = cur$1;
     }
    }
   }
   function int_of_hex_char(c){
    var c$0 = caml_call1(Stdlib_Char[6], c) - 48 | 0;
    if(9 >= c$0)
     return 0 <= c$0 ? c$0 : caml_call1(Stdlib[2], cst_int_of_hex_char$0);
    if(16 < c$0 && 23 > c$0) return c$0 - 7 | 0;
    return caml_call1(Stdlib[2], cst_int_of_hex_char);
   }
   function decode(b){
    var
     len = caml_ml_string_length(b),
     buf = caml_call1(Stdlib_Buffer[1], len),
     start = 0,
     cur = 0;
    for(;;){
     if(len <= cur)
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
     else{
      if(37 !== caml_string_get(b, cur)){
       var cur$1 = cur + 1 | 0;
       cur = cur$1;
       continue;
      }
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      var start$0 = cur + 1 | 0;
      if(len <= start$0)
       caml_call2(Stdlib_Buffer[12], buf, 37);
      else{
       try{var highbits = int_of_hex_char(caml_string_get(b, start$0));}
       catch(_c9_){
        caml_call2(Stdlib_Buffer[12], buf, 37);
        start = start$0;
        cur = start$0;
        continue;
       }
       var cur$0 = start$0 + 1 | 0;
       if(len > cur$0){
        a:
        {
         try{var lowbits = int_of_hex_char(caml_string_get(b, cur$0));}
         catch(_c8_){
          caml_call2(Stdlib_Buffer[12], buf, 37);
          var _c6_ = caml_string_get(b, cur$0 - 1 | 0);
          caml_call2(Stdlib_Buffer[12], buf, _c6_);
          var start_at = cur$0;
          break a;
         }
         var _c7_ = caml_call1(Stdlib_Char[1], (highbits << 4) + lowbits | 0);
         caml_call2(Stdlib_Buffer[12], buf, _c7_);
         var start_at = cur$0 + 1 | 0;
        }
        start = start_at;
        cur = start_at;
        continue;
       }
       caml_call2(Stdlib_Buffer[12], buf, 37);
       var _c5_ = caml_string_get(b, cur$0 - 1 | 0);
       caml_call2(Stdlib_Buffer[12], buf, _c5_);
      }
     }
     return caml_call1(Stdlib_Buffer[2], buf);
    }
   }
   function pct_encode(scheme, opt, s){
    if(opt) var sth = opt[1], component = sth; else var component = 892015045;
    var x = encode(scheme, [0, component], s);
    return x;
   }
   function pct_encoder(opt, _c4_, _c3_, _c2_, _c1_, _c0_, _cZ_, param){
    if(opt) var sth = opt[1], scheme = sth; else var scheme = -178940859;
    if(_c4_)
     var sth$0 = _c4_[1], userinfo = sth$0;
    else
     var userinfo = -145160103;
    if(_c3_) var sth$1 = _c3_[1], host = sth$1; else var host = 803994504;
    if(_c2_) var sth$2 = _c2_[1], path = sth$2; else var path = 892015045;
    if(_c1_)
     var sth$3 = _c1_[1], query_key = sth$3;
    else
     var query_key = -911188600;
    if(_c0_)
     var sth$4 = _c0_[1], query_value = sth$4;
    else
     var query_value = 795008922;
    if(_cZ_)
     var sth$5 = _cZ_[1], fragment = sth$5;
    else
     var fragment = 127343600;
    return [0, scheme, userinfo, host, path, query_key, query_value, fragment];
   }
   function pct_decode(s){var x = decode(s); return x;}
   function compare(param, _cY_){
    var
     p = _cY_[2],
     u = _cY_[1],
     p$0 = param[2],
     u$0 = param[1],
     c = caml_call2(Stdlib_String[9], u$0, u);
    return 0 === c ? compare_opt(Stdlib_String[9], p$0, p) : c;
   }
   function userinfo_of_encoded(us){
    var match = caml_call3(Stringext[3], _c_, us, 58);
    if(! match) return _d_;
    var match$0 = match[2], u = match[1];
    if(match$0){
     var p = match$0[1], x$0 = decode(p), x = decode(u);
     return [0, x, [0, x$0]];
    }
    var x$1 = decode(u);
    return [0, x$1, 0];
   }
   function encoded_of_userinfo(scheme, component){
    return function(param){
     var po = param[2], u = param[1];
     if(po) var p = po[1], _cV_ = caml_ml_string_length(p); else var _cV_ = 0;
     var
      len = (1 + caml_ml_string_length(u) | 0) + _cV_ | 0,
      buf = caml_call1(Stdlib_Buffer[1], len),
      _cW_ = pct_encode(scheme, [0, component], u);
     caml_call2(Stdlib_Buffer[16], buf, _cW_);
     if(po){
      var p$0 = po[1];
      caml_call2(Stdlib_Buffer[12], buf, 58);
      var _cX_ = pct_encode(scheme, [0, component], p$0);
      caml_call2(Stdlib_Buffer[16], buf, _cX_);
     }
     var x = caml_call1(Stdlib_Buffer[2], buf);
     return x;};
   }
   function path_of_encoded(ps){
    var tokl = caml_call2(Stringext[4], ps, 47);
    return caml_call2(Stdlib_List[19], pct_decode, tokl);
   }
   function remove_dot_segments(p){
    var
     revp = caml_call1(Stdlib_List[9], p),
     ascension = 0,
     outp = 0,
     param$0 = revp;
    for(;;){
     a:
     {
      b:
      if(param$0){
       var _cR_ = param$0[1];
       c:
       {
        if(_cR_ !== cst$36){
         if(_cR_ !== cst$39){
          if(_cR_ !== cst$33) break a;
          var _cT_ = param$0[2];
          if(! _cT_) break b;
          var _cU_ = _cT_[1];
          if(_cU_ === cst$36){var r$3 = _cT_[2]; break c;}
          if(_cU_ !== cst$39){
           if(_cU_ === cst$33){
            var r$1 = _cT_[2];
            if(0 < ascension){
             var ascension$1 = ascension - 1 | 0;
             ascension = ascension$1;
             param$0 = [0, cst$2, r$1];
             continue;
            }
           }
           var r$0 = _cT_[2];
           if(0 >= ascension) break a;
           var ascension$0 = ascension - 1 | 0;
           ascension = ascension$0;
           param$0 = r$0;
           continue;
          }
          var r$2 = _cT_[2];
         }
         else
          var r$2 = param$0[2];
         var ascension$2 = ascension + 1 | 0;
         ascension = ascension$2;
         param$0 = r$2;
         continue;
        }
        var r$3 = param$0[2];
       }
       param$0 = r$3;
       continue;
      }
      if
       (0 < caml_call1(Stdlib_List[1], p)
        && caml_call1(Stdlib_List[5], p) == cst$33)
       return [0, cst$3, outp];
     }
     if(! param$0) break;
     var r = param$0[2], s = param$0[1], outp$0 = [0, s, outp];
     ascension = 0;
     outp = outp$0;
     param$0 = r;
    }
    if(0 >= ascension){
     if
      (0 < caml_call1(Stdlib_List[1], outp)
       && caml_call1(Stdlib_List[5], outp) == cst$33)
      return caml_call1(Stdlib_List[6], outp);
     return outp;
    }
    var lst = caml_call1(Stdlib_Array[11], caml_make_vect(ascension, cst$39));
    if(lst){
     var t = lst[2], h = lst[1], acc$1 = [0, h, 0], acc = acc$1, param = t;
     for(;;){
      if(! param){var _cS_ = acc; break;}
      var xs = param[2], x = param[1], acc$0 = [0, x, [0, cst$0, acc]];
      acc = acc$0;
      param = xs;
     }
    }
    else
     var _cS_ = 0;
    return caml_call2(Stdlib_List[12], [0, cst$1, _cS_], outp);
   }
   function encoded_of_path(scheme, component){
    return function(p){
     var
      len =
        caml_call3
         (Stdlib_List[25],
          function(c, tok){return caml_ml_string_length(tok) + c | 0;},
          0,
          p),
      buf = caml_call1(Stdlib_Buffer[1], len);
     iter_concat
      (function(buf, seg){
        if(seg === cst$33) return caml_call2(Stdlib_Buffer[12], buf, 47);
        var _cQ_ = pct_encode(scheme, [0, component], seg);
        return caml_call2(Stdlib_Buffer[16], buf, _cQ_);
       },
       cst$4,
       buf,
       p);
     var x = caml_call1(Stdlib_Buffer[2], buf);
     return x;};
   }
   function query_of_encoded(qs){
    var els = caml_call3(Stringext[3], 0, qs, 38);
    function plus_to_space(s){
     var
      s$0 = caml_call1(Stdlib_Bytes[49], s),
      _cO_ = runtime.caml_ml_bytes_length(s$0) - 1 | 0,
      _cN_ = 0;
     if(_cO_ >= 0){
      var i = _cN_;
      for(;;){
       if(43 === runtime.caml_bytes_get(s$0, i))
        runtime.caml_bytes_set(s$0, i, 32);
       var _cP_ = i + 1 | 0;
       if(_cO_ === i) break;
       i = _cP_;
      }
     }
     return caml_call1(Stdlib_Bytes[48], s$0);
    }
    if(els){
     var
      acc = 0,
      param =
        caml_call2
         (Stdlib_List[21],
          function(el){return caml_call3(Stringext[3], _h_, el, 61);},
          els);
     for(;;){
      if(! param) break;
      var _cJ_ = param[1];
      if(_cJ_){
       var match = _cJ_[2], k = _cJ_[1];
       if(match){
        var
         tl = param[2],
         v = match[1],
         _cK_ = plus_to_space(v),
         l = caml_call3(Stringext[3], 0, _cK_, 44),
         l$0 = l || _f_,
         n = [0, plus_to_space(k), l$0],
         acc$0 = [0, n, acc];
        acc = acc$0;
        param = tl;
       }
       else{
        var
         tl$0 = param[2],
         n$0 = [0, plus_to_space(k), 0],
         acc$1 = [0, n$0, acc];
        acc = acc$1;
        param = tl$0;
       }
      }
      else{
       var tl$1 = param[2], acc$2 = [0, _g_, acc];
       acc = acc$2;
       param = tl$1;
      }
     }
     var _cL_ = acc;
    }
    else
     var _cL_ = _i_;
    return caml_call2
            (Stdlib_List[19],
             function(param){
              var
               v = param[2],
               k = param[1],
               _cM_ = caml_call2(Stdlib_List[19], pct_decode, v),
               x = decode(k);
              return [0, x, _cM_];
             },
             _cL_);
   }
   function encoded_of_query(scheme, opt, l){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var
     len =
       caml_call3
        (Stdlib_List[25],
         function(a, param){
          var v = param[2], k = param[1];
          return ((a + caml_ml_string_length(k) | 0)
                 +
                  caml_call3
                   (Stdlib_List[25],
                    function(a, s){
                     return (a + caml_ml_string_length(s) | 0) + 1 | 0;
                    },
                    0,
                    v)
                 | 0)
                 + 2
                 | 0;
         },
         -1,
         l),
     buf = caml_call1(Stdlib_Buffer[1], len);
    iter_concat
     (function(buf, param){
       var
        v = param[2],
        k = param[1],
        _cG_ = pct_encode(scheme, [0, pct_encoder$0[5]], k);
       caml_call2(Stdlib_Buffer[16], buf, _cG_);
       var _cH_ = 0 !== v ? 1 : 0;
       return _cH_
               ? (caml_call2
                  (Stdlib_Buffer[12], buf, 61),
                 iter_concat
                  (function(buf, s){
                    var _cI_ = pct_encode(scheme, [0, pct_encoder$0[6]], s);
                    return caml_call2(Stdlib_Buffer[16], buf, _cI_);
                   },
                   cst$8,
                   buf,
                   v))
               : _cH_;
      },
      cst$7,
      buf,
      l);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function of_raw(qs){
    var
     lazy_query =
       caml_call1
        (Stdlib_Lazy[6], function(param){return query_of_encoded(qs);});
    return [1, [0, qs], lazy_query];
   }
   function kv(param){
    if(0 === param[0])
     var kv = param[1];
    else
     var
      _cD_ = param[2],
      _cE_ = caml_obj_tag(_cD_),
      _cF_ =
        250 === _cE_
         ? _cD_[1]
         : 246 === _cE_ ? caml_call1(CamlinternalLazy[2], _cD_) : _cD_,
      kv = _cF_;
    return kv;
   }
   function encoded_of_query$0(scheme){
    return function(_cB_, _cC_){return encoded_of_query(scheme, _cB_, _cC_);};
   }
   var
    _e_ = Stdlib_String[9],
    empty = [0, 0, 0, 0, 0, 0, [1, 0, caml_call1(Stdlib_Lazy[4], 0)], 0],
    compare_decoded = Stdlib_String[9];
   function compare_host(h1, h2){
    if(typeof h1 !== "number"){
     var _cA_ = h1[1];
     if(-367671627 === _cA_){
      if(typeof h2 !== "number" && -367671627 === h2[1]){
       var ip2 = h2[2], ip1 = h1[2];
       return caml_call2(Stdlib_String[9], ip1, ip2);
      }
     }
     else
      if(267950263 === _cA_){
       if(typeof h2 !== "number" && 267950263 === h2[1]){
        var ip2$0 = h2[2], ip1$0 = h1[2];
        return caml_call2(Stdlib_String[9], ip1$0, ip2$0);
       }
      }
      else if
       (803994504 === _cA_ && typeof h2 !== "number" && 803994504 === h2[1]){
       var h2$0 = h2[2], h1$0 = h1[2];
       return caml_call2(compare_decoded, h1$0, h2$0);
      }
    }
    return -1;
   }
   function compare$0(t$0, t){
    var c$2 = compare_opt(compare_host, t$0[3], t[3]);
    if(0 !== c$2) return c$2;
    var c$3 = compare_opt(compare_decoded, t$0[1], t[1]);
    if(0 !== c$3) return c$3;
    var
     c =
       compare_opt
        (function(p$0, p){return p$0 < p ? -1 : p < p$0 ? 1 : 0;},
         t$0[4],
         t[4]);
    if(0 !== c) return c;
    var c$0 = compare_opt(compare, t$0[2], t[2]);
    if(0 !== c$0) return c$0;
    var c$4 = compare_list(_e_, t$0[5], t[5]);
    if(0 !== c$4) return c$4;
    var y = t[6], x = t$0[6];
    a:
    {
     if(0 === x[0]){
      var _cs_ = x[1];
      if(0 === y[0])
       var kvl$0 = y[1], kvl = _cs_;
      else
       var
        _ct_ = y[2],
        _cu_ = caml_obj_tag(_ct_),
        _cv_ =
          250 === _cu_
           ? _ct_[1]
           : 246 === _cu_ ? caml_call1(CamlinternalLazy[2], _ct_) : _ct_,
        kvl$0 = _cv_,
        kvl = _cs_;
     }
     else{
      var _cw_ = x[2], raw = x[1];
      if(0 !== y[0]){
       var raw$0 = y[1], c$1 = compare_opt(Stdlib_String[9], raw, raw$0);
       break a;
      }
      var
       _cx_ = caml_obj_tag(_cw_),
       _cy_ =
         250 === _cx_
          ? _cw_[1]
          : 246 === _cx_ ? caml_call1(CamlinternalLazy[2], _cw_) : _cw_,
       kvl$0 = y[1],
       kvl = _cy_;
     }
     var
      c$1 =
        compare_list
         (function(param, _cz_){
           var
            vl = _cz_[2],
            k = _cz_[1],
            vl$0 = param[2],
            k$0 = param[1],
            c = caml_call2(Stdlib_String[9], k$0, k);
           return 0 === c ? compare_list(Stdlib_String[9], vl$0, vl) : c;
          },
          kvl,
          kvl$0);
    }
    return 0 === c$1 ? compare_opt(compare_decoded, t$0[7], t[7]) : c$1;
   }
   function equal(t$0, t){return 0 === compare$0(t$0, t) ? 1 : 0;}
   function uncast_opt(param){
    if(! param) return 0;
    var h = param[1];
    return [0, h];
   }
   function normalize(schem, init){
    var
     Scheme = module_of_scheme(uncast_opt(schem)),
     _cm_ = init[3],
     _ci_ = init[7],
     _cj_ = init[6],
     _ck_ = init[5],
     _cl_ = init[4];
    if(_cm_){
     var match = _cm_[1], _cn_ = match[1];
     if(267950263 === _cn_)
      var
       host = match[2],
       _co_ = [0, [0, 267950263, Scheme[2].call(null, host)]];
     else if(803994504 <= _cn_)
      var
       host$0 = match[2],
       x$0 = Scheme[2].call(null, host$0),
       _co_ = [0, [0, 803994504, x$0]];
     else
      var
       host$1 = match[2],
       _co_ = [0, [0, -367671627, Scheme[2].call(null, host$1)]];
     var _cp_ = _co_;
    }
    else
     var _cp_ = 0;
    var param = init[1], f = Stdlib_String[26], _cq_ = init[2];
    if(param)
     var x = param[1], _cr_ = [0, caml_call1(f, x)];
    else
     var _cr_ = 0;
    return [0, _cr_, _cq_, _cp_, _cl_, _ck_, _cj_, _ci_];
   }
   function to_string(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[1];
    if(match) var s = match[1], scheme = [0, s]; else var scheme = 0;
    var buf = caml_call1(Stdlib_Buffer[1], 128);
    function add_pct_string(opt, x){
     if(opt)
      var sth = opt[1], component = sth;
     else
      var component = 892015045;
     var x$0 = encode(scheme, [0, component], x);
     return caml_call2(Stdlib_Buffer[16], buf, x$0);
    }
    var match$0 = uri[1];
    if(match$0){
     var x = match$0[1];
     add_pct_string([0, pct_encoder$0[1]], x);
     caml_call2(Stdlib_Buffer[12], buf, 58);
    }
    a:
    {
     var _b5_ = uri[3], _b6_ = uri[4];
     if(! uri[2] && ! _b5_ && ! _b6_){var _b7_ = 0; break a;}
     var _b7_ = 1;
    }
    if(_b7_) caml_call2(Stdlib_Buffer[16], buf, cst$9);
    var match$1 = uri[2];
    if(match$1){
     var
      userinfo = match$1[1],
      x$0 = encoded_of_userinfo(scheme, pct_encoder$0[2])(userinfo);
     caml_call2(Stdlib_Buffer[16], buf, x$0);
     caml_call2(Stdlib_Buffer[12], buf, 64);
    }
    var _b8_ = uri[3];
    if(_b8_){
     var match$2 = _b8_[1], _b9_ = match$2[1];
     if(267950263 === _b9_){
      var host = match$2[2];
      caml_call2(Stdlib_Buffer[12], buf, 91);
      caml_call2(Stdlib_Buffer[16], buf, host);
      caml_call2(Stdlib_Buffer[12], buf, 93);
     }
     else if(803994504 <= _b9_){
      var host$0 = match$2[2];
      add_pct_string([0, pct_encoder$0[3]], host$0);
     }
     else{var host$1 = match$2[2]; caml_call2(Stdlib_Buffer[16], buf, host$1);
     }
    }
    var match$3 = uri[4];
    if(match$3){
     var port = match$3[1];
     caml_call2(Stdlib_Buffer[12], buf, 58);
     var _b__ = caml_call1(Stdlib[33], port);
     caml_call2(Stdlib_Buffer[16], buf, _b__);
    }
    var _b$_ = uri[5];
    if(_b$_){
     var first_segment = _b$_[1];
     if(first_segment !== cst$33){
      if(uri[3])
       caml_call2(Stdlib_Buffer[12], buf, 47);
      else if(caml_call3(Stringext[12], 0, first_segment, cst$10) && ! scheme)
       caml_call2(Stdlib_Buffer[16], buf, cst$11);
      var
       _ca_ = uri[5],
       x$1 = encoded_of_path(scheme, pct_encoder$0[4])(_ca_);
      caml_call2(Stdlib_Buffer[16], buf, x$1);
     }
     else{
      var
       _ch_ = uri[5],
       x$2 = encoded_of_path(scheme, pct_encoder$0[4])(_ch_);
      caml_call2(Stdlib_Buffer[16], buf, x$2);
     }
    }
    var _cb_ = uri[6];
    a:
    {
     b:
     {
      if(0 === _cb_[0]){
       var _cc_ = _cb_[1];
       if(_cc_){var q = _cc_; break b;}
      }
      else if(_cb_[1]){
       var
        _ce_ = _cb_[2],
        _cf_ = caml_obj_tag(_ce_),
        _cg_ =
          250 === _cf_
           ? _ce_[1]
           : 246 === _cf_ ? caml_call1(CamlinternalLazy[2], _ce_) : _ce_,
        q = _cg_;
       break b;
      }
      break a;
     }
     caml_call2(Stdlib_Buffer[12], buf, 63);
     var _cd_ = encoded_of_query(scheme, [0, pct_encoder$0], q);
     caml_call2(Stdlib_Buffer[16], buf, _cd_);
    }
    var match$4 = uri[7];
    if(match$4){
     var f = match$4[1];
     caml_call2(Stdlib_Buffer[12], buf, 35);
     add_pct_string([0, pct_encoder$0[7]], f);
    }
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function get_decoded_opt(param){
    if(! param) return 0;
    var x = param[1];
    return [0, x];
   }
   function scheme(uri){return get_decoded_opt(uri[1]);}
   function with_scheme(uri, param){
    if(! param) return [0, 0, uri[2], uri[3], uri[4], uri[5], uri[6], uri[7]];
    var scheme = param[1];
    return [0, [0, scheme], uri[2], uri[3], uri[4], uri[5], uri[6], uri[7]];
   }
   function host(uri){
    var _b4_ = uri[3];
    if(! _b4_) return 0;
    var match = _b4_[1];
    if(803994504 <= match[1]){var h = match[2]; return [0, h];}
    var h$0 = match[2];
    return [0, h$0];
   }
   function host_with_default(opt, uri){
    if(opt)
     var sth = opt[1], default$0 = sth;
    else
     var default$0 = cst_localhost;
    var match = host(uri);
    if(! match) return default$0;
    var h = match[1];
    return h;
   }
   function userinfo(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[2];
    if(! match) return 0;
    var userinfo = match[1], match$0 = uri[1];
    if(match$0)
     var
      s = match$0[1],
      x = encoded_of_userinfo([0, s], pct_encoder$0[2])(userinfo);
    else
     var x = encoded_of_userinfo(0, pct_encoder$0[2])(userinfo);
    return [0, x];
   }
   function with_userinfo(uri, userinfo){
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    return host(uri)
            ? [0, uri[1], userinfo$0, uri[3], uri[4], uri[5], uri[6], uri[7]]
            : [0,
              uri[1],
              userinfo$0,
              [0, [0, 803994504, cst$12]],
              uri[4],
              uri[5],
              uri[6],
              uri[7]];
   }
   function user(uri){
    var _b3_ = uri[2];
    if(! _b3_) return 0;
    var user = _b3_[1][1];
    return [0, user];
   }
   function password(uri){
    var _b2_ = uri[2];
    if(_b2_){
     var match = _b2_[1][2];
     if(match){var pass = match[1]; return [0, pass];}
    }
    return 0;
   }
   function with_password(uri, password){
    function result(userinfo){
     return host(uri)
             ? [0, uri[1], userinfo, uri[3], uri[4], uri[5], uri[6], uri[7]]
             : [0,
               uri[1],
               userinfo,
               [0, [0, 803994504, cst$13]],
               uri[4],
               uri[5],
               uri[6],
               uri[7]];
    }
    var _b1_ = uri[2];
    if(! _b1_) return password ? result([0, [0, cst$14, password]]) : uri;
    var user = _b1_[1][1];
    return result([0, [0, user, password]]);
   }
   function port(uri){return uri[4];}
   function with_port(uri, port){
    return host(uri)
            ? [0, uri[1], uri[2], uri[3], port, uri[5], uri[6], uri[7]]
            : port
              ? [0,
                uri[1],
                uri[2],
                [0, [0, 803994504, cst$15]],
                port,
                uri[5],
                uri[6],
                uri[7]]
              : [0, uri[1], uri[2], 0, 0, uri[5], uri[6], uri[7]];
   }
   function path(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[1];
    if(match)
     var
      s = match[1],
      _bZ_ = uri[5],
      x = encoded_of_path([0, s], pct_encoder$0[4])(_bZ_);
    else
     var _b0_ = uri[5], x = encoded_of_path(0, pct_encoder$0[4])(_b0_);
    return x;
   }
   function with_path(uri, path){
    var path$0 = path_of_encoded(path);
    if(host(uri) && path$0 && path$0[1] !== cst$33)
     return [0,
             uri[1],
             uri[2],
             uri[3],
             uri[4],
             [0, cst$16, path$0],
             uri[6],
             uri[7]];
    return [0, uri[1], uri[2], uri[3], uri[4], path$0, uri[6], uri[7]];
   }
   function fragment(uri){return get_decoded_opt(uri[7]);}
   function with_fragment(uri, param){
    if(! param) return [0, uri[1], uri[2], uri[3], uri[4], uri[5], uri[6], 0];
    var frag = param[1];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], uri[6], [0, frag]];
   }
   function query(uri){return kv(uri[6]);}
   function verbatim_query(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[6];
    if(0 === match[0]){
     var kv = match[1];
     return kv
             ? [0, encoded_of_query(scheme(uri), [0, pct_encoder$0], kv)]
             : 0;
    }
    var qs = match[1];
    return qs;
   }
   function get_query_param(uri, k){
    var q = kv(uri[6]);
    try{var _bX_ = [0, caml_call2(Stdlib_List[46], k, q)]; return _bX_;}
    catch(_bY_){
     var _bW_ = caml_wrap_exception(_bY_);
     if(_bW_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_bW_, 0);
    }
   }
   function get_query_param$0(uri, k){
    var match = get_query_param(uri, k);
    if(! match) return 0;
    var v = match[1];
    return [0, caml_call2(Stdlib_String[6], cst$17, v)];
   }
   function with_query(uri, query){
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], [0, query], uri[7]];
   }
   function q_s(q){
    return caml_call2
            (Stdlib_List[19],
             function(param){
              var v = param[2], k = param[1];
              return [0, k, [0, v, 0]];
             },
             q);
   }
   function with_query$0(uri, query){return with_query(uri, q_s(query));}
   function add_query_param(uri, p){
    var _bU_ = uri[7], _bV_ = [0, [0, p, kv(uri[6])]];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _bV_, _bU_];
   }
   function add_query_param$0(uri, param){
    var
     v = param[2],
     k = param[1],
     _bS_ = uri[7],
     _bT_ = [0, [0, [0, k, [0, v, 0]], kv(uri[6])]];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _bT_, _bS_];
   }
   function add_query_params(uri, ps){
    var
     _bP_ = uri[7],
     _bQ_ = kv(uri[6]),
     _bR_ = [0, caml_call2(Stdlib[37], ps, _bQ_)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _bR_, _bP_];
   }
   function add_query_params$0(uri, ps){
    var
     _bL_ = uri[7],
     _bM_ = kv(uri[6]),
     _bN_ = q_s(ps),
     _bO_ = [0, caml_call2(Stdlib[37], _bN_, _bM_)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _bO_, _bL_];
   }
   function remove_query_param(uri, k){
    var
     _bI_ = uri[7],
     _bJ_ = kv(uri[6]),
     _bK_ =
       [0,
        caml_call2
         (Stdlib_List[41],
          function(param){var k$0 = param[1]; return k !== k$0 ? 1 : 0;},
          _bJ_)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _bK_, _bI_];
   }
   function path_and_query(uri){
    var p = path(0, uri), match = query(uri);
    if(p !== cst$34){
     if(! match) return p;
     var
      scheme = uncast_opt(uri[1]),
      _bG_ = encoded_of_query$0(scheme)(0, match);
     return caml_call3(Stdlib_Printf[4], _j_, p, _bG_);
    }
    if(! match) return cst$18;
    var
     scheme$0 = uncast_opt(uri[1]),
     _bH_ = encoded_of_query$0(scheme$0)(0, match);
    return caml_call2(Stdlib_Printf[4], _k_, _bH_);
   }
   function resolve(schem, base, uri){
    var match$0 = scheme(base);
    if(match$0)
     var scheme$0 = match$0[1], scheme$1 = scheme$0;
    else
     var scheme$1 = schem;
    var
     schem$0 = [0, scheme$1],
     match$1 = scheme(uri),
     match$2 = userinfo(0, uri);
    a:
    {
     var match$3 = host(uri);
     if(match$1)
      var
       _bp_ = uri[7],
       _bq_ = uri[6],
       _br_ = remove_dot_segments(uri[5]),
       _bs_ = [0, uri[1], uri[2], uri[3], uri[4], _br_, _bq_, _bp_];
     else{
      if(! match$2 && ! match$3){
       var
        init = [0, base[1], base[2], base[3], base[4], uri[5], uri[6], uri[7]],
        path_str = path(0, init);
       if(path_str == cst$34)
        var
         _bw_ = init[7],
         _bx_ = init[6][1] ? init[6] : base[6],
         _by_ = [0, init[1], init[2], init[3], init[4], base[5], _bx_, _bw_];
       else if(47 === caml_string_get(path_str, 0))
        var
         _bz_ = init[7],
         _bA_ = init[6],
         _bB_ = remove_dot_segments(init[5]),
         _by_ = [0, init[1], init[2], init[3], init[4], _bB_, _bA_, _bz_];
       else{
        var
         relpath = init[5],
         bpath = base[5],
         bhost = base[3],
         _bC_ = init[7],
         _bD_ = init[6],
         match = caml_call1(Stdlib_List[9], bpath);
        b:
        {
         if(bhost && ! match){var _bE_ = [0, cst$6, relpath]; break b;}
         c:
         if(match){
          if(match[1] !== cst$33){
           var _bo_ = match[2];
           if(! _bo_) break c;
           if(_bo_[1] !== cst$33) break c;
           var rbpath = _bo_[2];
          }
          else
           var rbpath = match[2];
          var _bE_ = caml_call2(Stdlib_List[12], [0, cst$5, rbpath], relpath);
          break b;
         }
         var _bE_ = relpath;
        }
        var
         _bF_ = remove_dot_segments(_bE_),
         _by_ = [0, init[1], init[2], init[3], init[4], _bF_, _bD_, _bC_];
       }
       var _bs_ = _by_;
       break a;
      }
      var
       _bt_ = uri[7],
       _bu_ = uri[6],
       _bv_ = remove_dot_segments(uri[5]),
       _bs_ = [0, base[1], uri[2], uri[3], uri[4], _bv_, _bu_, _bt_];
     }
    }
    return normalize(schem$0, _bs_);
   }
   function canonicalize(uri){
    var
     uri$0 = resolve(cst$19, empty, uri),
     Scheme = module_of_scheme(uncast_opt(uri$0[1])),
     _bk_ = uri$0[7],
     _bl_ = uri$0[6],
     _bm_ = Scheme[4].call(null, uri$0[5]),
     _bn_ = Scheme[3].call(null, uri$0[4]);
    return [0, uri$0[1], uri$0[2], uri$0[3], _bn_, _bm_, _bl_, _bk_];
   }
   function pp(ppf, uri){
    var _bj_ = to_string(0, uri);
    return caml_call2(Stdlib_Format[13], ppf, _bj_);
   }
   function pp_hum(ppf, uri){
    var _bi_ = to_string(0, uri);
    return caml_call2(Stdlib_Format[13], ppf, _bi_);
   }
   var string_of_char = caml_call1(Stdlib_String[1], 1);
   function string_of_char_list(chars){
    var _bh_ = caml_call2(Stdlib_List[19], string_of_char, chars);
    return caml_call2(Stdlib_String[6], cst$20, _bh_);
   }
   var
    _l_ = caml_call1(Angstrom[51], 0),
    _m_ = caml_call1(Angstrom[4], 58),
    _n_ =
      caml_call1
       (Angstrom[13],
        function(c){
         var _bd_ = 58 !== c ? 1 : 0;
         if(_bd_){
          var _be_ = 47 !== c ? 1 : 0;
          if(_be_)
           var _bf_ = 63 !== c ? 1 : 0, _bg_ = _bf_ ? 35 !== c ? 1 : 0 : _bf_;
          else
           var _bg_ = _be_;
         }
         else
          var _bg_ = _bd_;
         return _bg_;
        }),
    _o_ = caml_call2(Angstrom[59], _n_, _m_),
    _p_ = caml_call2(Angstrom[60], function(s){return [0, decode(s)];}, _o_),
    scheme$0 = caml_call2(Angstrom[47], _p_, _l_);
   function is_digit(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   var
    hex_digit =
      caml_call1
       (Angstrom[7],
        function(param){
         var _bc_ = param - 48 | 0;
         a:
         {
          if(22 < _bc_ >>> 0){
           if(5 < _bc_ - 49 >>> 0) break a;
          }
          else if(6 >= _bc_ - 10 >>> 0) break a;
          return 1;
         }
         return 0;
        }),
    _q_ = caml_call1(Angstrom[38], hex_digit),
    hexadecimal = caml_call2(Angstrom[60], string_of_char_list, _q_),
    c_dot = caml_call1(Angstrom[4], 46),
    c_at = caml_call1(Angstrom[4], 64),
    c_colon = caml_call1(Angstrom[4], 58),
    _r_ =
      caml_call1
       (Angstrom[14], function(param){return 9 < param - 48 >>> 0 ? 0 : 1;}),
    dec_octet =
      caml_call2
       (Angstrom[53],
        _r_,
        function(num){
         return 256 <= caml_int_of_string(num)
                 ? caml_call1(Angstrom[52], cst_invalid_octect)
                 : caml_call1(Angstrom[51], num);
        }),
    _s_ = caml_call2(Angstrom[59], dec_octet, c_dot),
    _t_ = caml_call2(Angstrom[37], 3, _s_),
    ipv4_address =
      caml_call3
       (Angstrom[61],
        function(three, one){
         var
          _ba_ = caml_call2(Stdlib[28], cst$21, one),
          _bb_ = caml_call2(Stdlib_String[6], cst$22, three);
         return caml_call2(Stdlib[28], _bb_, _ba_);
        },
        _t_,
        dec_octet),
    after_double_colon =
      caml_call1
       (Angstrom[45],
        function(f){
         var
          _a7_ = caml_call1(Angstrom[51], 0),
          _a8_ = caml_call2(Angstrom[58], c_colon, f),
          _a9_ = caml_call2(Angstrom[47], _a8_, _a7_),
          _a__ =
            caml_call3
             (Angstrom[61],
              function(x, y){return [0, x, y];},
              hexadecimal,
              _a9_),
          _a$_ = caml_call1(Angstrom[36], [0, ipv4_address, 0]);
         return caml_call2(Angstrom[47], _a$_, _a__);
        });
   function double_colon(count){
    var
     _a5_ = caml_call1(Angstrom[51], _u_),
     _a6_ =
       caml_call2
        (Angstrom[53],
         after_double_colon,
         function(rest){
          var
           filler_length =
             (8 - count | 0) - caml_call1(Stdlib_List[1], rest) | 0;
          return 0 < filler_length
                  ? caml_call1(Angstrom[51], [0, cst$23, rest])
                  : caml_call1(Angstrom[52], cst_too_many_parts_in_IPv6_add);
         });
    return caml_call2(Angstrom[47], _a6_, _a5_);
   }
   function part(n){
    if(6 !== n)
     return 7 === n
             ? caml_call2
               (Angstrom[60], function(x){return [0, x, 0];}, hexadecimal)
             : hex_part(n);
    var
     _a3_ = hex_part(6),
     _a4_ = caml_call1(Angstrom[36], [0, ipv4_address, 0]);
    return caml_call2(Angstrom[47], _a4_, _a3_);
   }
   function hex_part(n){
    var
     _aY_ = part(n + 1 | 0),
     _aZ_ = double_colon(n + 1 | 0),
     _a0_ = caml_call2(Angstrom[58], c_colon, _aZ_),
     _a1_ = caml_call2(Angstrom[47], _a0_, _aY_),
     _a2_ = caml_call2(Angstrom[58], c_colon, _a1_);
    return caml_call3
            (Angstrom[61],
             function(x, y){return [0, x, y];},
             hexadecimal,
             _a2_);
   }
   function split_with(f, xs){
    if(! xs) return _v_;
    var ys = xs[2], y = xs[1];
    if(! caml_call1(f, y)) return [0, 0, xs];
    var match = split_with(f, ys), ts = match[2], zs = match[1];
    return [0, [0, y, zs], ts];
   }
   function format_addr(segments){
    var
     match =
       split_with
        (function(segment){return segment !== cst$34 ? 1 : 0;}, segments),
     after_double_colon = match[2],
     before_double_colon = match[1],
     before = caml_call2(Stdlib_String[6], cst$24, before_double_colon);
    a:
    {
     if(after_double_colon && after_double_colon[1] === cst$34){
      var
       xs = after_double_colon[2],
       _aW_ = caml_call2(Stdlib_String[6], cst$25, xs),
       _aX_ = caml_call2(Stdlib[28], cst$26, _aW_),
       res = caml_call2(Stdlib[28], before, _aX_);
      break a;
     }
     var res = before;
    }
    return res;
   }
   var
    _w_ = part(0),
    _x_ = double_colon(0),
    _y_ = caml_call2(Angstrom[58], c_colon, c_colon),
    _z_ = caml_call2(Angstrom[58], _y_, _x_),
    _A_ = caml_call2(Angstrom[47], _z_, _w_),
    ipv6 = caml_call2(Angstrom[60], format_addr, _A_),
    _B_ = caml_call1(Angstrom[4], 93),
    _C_ = caml_call1(Angstrom[4], 91),
    _D_ = caml_call2(Angstrom[58], _C_, ipv6),
    ipv6_address = caml_call2(Angstrom[59], _D_, _B_),
    _E_ = caml_call2(Angstrom[37], 2, hex_digit),
    _F_ = caml_call1(Angstrom[4], 37),
    pct_encoded =
      caml_call3
       (Angstrom[61],
        function(pct, digits){return string_of_char_list([0, pct, digits]);},
        _F_,
        _E_),
    sub_delims$0 =
      caml_call1
       (Angstrom[7],
        function(param){
         var _aU_ = param - 59 | 0;
         a:
         {
          if(2 < _aU_ >>> 0){
           var _aV_ = _aU_ + 26 | 0;
           if(11 < _aV_ >>> 0) break a;
           switch(_aV_){case 1:case 2:case 4: break a;
           }
          }
          else if(1 === _aU_) break a;
          return 1;
         }
         return 0;
        }),
    unreserved =
      caml_call1
       (Angstrom[7],
        function(param){
         a:
         {
          if(91 <= param){
           var _aS_ = param - 95 | 0;
           if(27 < _aS_ >>> 0){
            if(31 !== _aS_) break a;
           }
           else if(1 === _aS_) break a;
          }
          else{
           var _aT_ = param - 45 | 0;
           if(12 < _aT_ >>> 0){
            if(20 > _aT_) break a;
           }
           else if(2 === _aT_) break a;
          }
          return 1;
         }
         return 0;
        }),
    _G_ =
      [0,
       pct_encoded,
       [0, caml_call2(Angstrom[57], string_of_char, sub_delims$0), 0]],
    _H_ = [0, caml_call2(Angstrom[57], string_of_char, unreserved), _G_],
    _I_ = caml_call2(Angstrom[48], 0, _H_),
    _J_ = caml_call1(Angstrom[38], _I_),
    _K_ = caml_call1(Stdlib_String[6], cst$27),
    reg_name = caml_call2(Angstrom[60], _K_, _J_),
    _L_ =
      [0,
       caml_call2
        (Angstrom[55],
         reg_name,
         function(s){return [0, 803994504, decode(s)];}),
       0],
    _M_ =
      [0,
       caml_call2
        (Angstrom[55], ipv6_address, function(h){return [0, 267950263, h];}),
       _L_],
    _N_ =
      [0,
       caml_call2
        (Angstrom[55], ipv4_address, function(h){return [0, -367671627, h];}),
       _M_],
    host$0 = caml_call2(Angstrom[48], 0, _N_),
    _O_ = caml_call1(Angstrom[51], 0),
    _P_ = [0, caml_call2(Angstrom[57], string_of_char, c_colon), 0],
    _Q_ =
      [0,
       pct_encoded,
       [0, caml_call2(Angstrom[57], string_of_char, sub_delims$0), _P_]],
    _R_ = [0, caml_call2(Angstrom[57], string_of_char, unreserved), _Q_],
    _S_ = caml_call2(Angstrom[48], 0, _R_),
    _T_ = caml_call1(Angstrom[38], _S_),
    _U_ = caml_call2(Angstrom[59], _T_, c_at),
    _V_ =
      caml_call2
       (Angstrom[60],
        function(x){
         var s = caml_call2(Stdlib_String[6], cst$28, x);
         return [0, userinfo_of_encoded(s)];
        },
        _U_),
    userinfo$0 = caml_call2(Angstrom[47], _V_, _O_),
    port$0 =
      caml_call2
       (Angstrom[53],
        Angstrom[1],
        function(param){
         if(param && 58 === param[1]){
          var
           _aO_ = caml_call1(Angstrom[13], is_digit),
           _aP_ = caml_call2(Angstrom[58], c_colon, _aO_);
          return caml_call2
                  (Angstrom[55],
                   _aP_,
                   function(port){
                    var decoded = decode(port);
                    try{
                     var _aQ_ = [0, caml_int_of_string(decoded)];
                     return _aQ_;
                    }
                    catch(_aR_){return 0;}
                   });
         }
         return caml_call1(Angstrom[51], 0);
        }),
    _X_ = caml_call1(Angstrom[51], _W_),
    _Y_ =
      caml_call4
       (Angstrom[62],
        function(userinfo, host, port){return [0, userinfo, [0, host], port];},
        userinfo$0,
        host$0,
        port$0),
    _Z_ = caml_call1(Angstrom[8], cst$29),
    ___ = caml_call2(Angstrom[58], _Z_, _Y_),
    authority = caml_call2(Angstrom[47], ___, _X_),
    _$_ =
      caml_call1
       (Angstrom[13],
        function(param){if(35 !== param && 63 !== param) return 1; return 0;}),
    path$0 = caml_call2(Angstrom[60], path_of_encoded, _$_),
    _aa_ = [1, 0, caml_call1(Stdlib_Lazy[4], 0)],
    _ab_ = caml_call1(Angstrom[51], _aa_),
    _ac_ =
      caml_call1(Angstrom[15], function(param){return 35 === param ? 1 : 0;}),
    _ad_ = caml_call1(Angstrom[4], 63),
    _ae_ = caml_call2(Angstrom[58], _ad_, _ac_),
    _af_ = caml_call2(Angstrom[60], of_raw, _ae_),
    query$0 = caml_call2(Angstrom[47], _af_, _ab_),
    _ag_ = caml_call1(Angstrom[51], 0),
    _ah_ = caml_call1(Angstrom[13], function(param){return 1;}),
    _ai_ = caml_call1(Angstrom[4], 35),
    _aj_ = caml_call2(Angstrom[58], _ai_, _ah_),
    _ak_ = caml_call2(Angstrom[60], function(s){return [0, decode(s)];}, _aj_),
    fragment$0 = caml_call2(Angstrom[47], _ak_, _ag_),
    _al_ =
      caml_call5
       (Angstrom[63],
        function(scheme, param, path, query, fragment){
         var port = param[3], host = param[2], userinfo = param[1];
         return normalize
                 (scheme,
                  [0, scheme, userinfo, host, port, path, query, fragment]);
        },
        scheme$0,
        authority,
        path$0,
        query$0),
    uri_reference = caml_call2(Angstrom[56], _al_, fragment$0),
    _am_ =
      caml_call1(Angstrom[13], function(param){return 10 === param ? 0 : 1;}),
    uri_reference$0 =
      caml_call2
       (Angstrom[55],
        _am_,
        function(s){
         var match = caml_call3(Angstrom[75], 1, uri_reference, s);
         if(0 !== match[0]) return empty;
         var t = match[1];
         return t;
        });
   function decode_host(host){
    var match = caml_call3(Angstrom[75], 1, host$0, host);
    if(0 === match[0]){var parsed = match[1]; return parsed;}
    var match$0 = caml_call3(Angstrom[75], 1, ipv6, host);
    if(0 !== match$0[0]) return [0, 803994504, host];
    var parsed$0 = match$0[1];
    return [0, 267950263, parsed$0];
   }
   function make(scheme, userinfo, host, port, path, query, fragment, param){
    function decode(param){
     if(! param) return 0;
     var x = param[1];
     return [0, x];
    }
    a:
    {
     b:
     if(! host){if(! port && ! userinfo) break b; var host$0 = _ao_; break a;}
     var host$0 = host;
    }
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    if(path){
     var p = path[1], path$0 = path_of_encoded(p);
     a:
     {
      if(host$0 && path$0 && path$0[1] !== cst$33){var _aL_ = [0, cst$30, path$0]; break a;}
      var _aL_ = path$0;
     }
     var path$1 = _aL_;
    }
    else
     var path$1 = 0;
    if(query) var p$0 = query[1], query$0 = [0, p$0]; else var query$0 = _an_;
    var scheme$0 = decode(scheme), _aM_ = decode(fragment);
    if(host$0)
     var host$1 = host$0[1], _aN_ = [0, decode_host(host$1)];
    else
     var _aN_ = 0;
    return normalize
            (scheme$0,
             [0, scheme$0, userinfo$0, _aN_, port, path$1, query$0, _aM_]);
   }
   function with_host(init, host){
    var _aG_ = init[7], _aH_ = init[6], _aI_ = init[5], _aJ_ = init[4];
    if(host)
     var host$0 = host[1], _aK_ = [0, decode_host(host$0)];
    else
     var _aK_ = 0;
    return [0, init[1], init[2], _aK_, _aJ_, _aI_, _aH_, _aG_];
   }
   function with_uri(scheme, userinfo, host, port, path, query, fragment, uri){
    function with$0(f, o, u){
     if(! o) return u;
     var x = o[1];
     return caml_call2(f, u, x);
    }
    var
     u$0 =
       with$0
        (with_port,
         port,
         with$0
          (with_host,
           host,
           with$0(with_userinfo, userinfo, with$0(with_scheme, scheme, uri))));
    if(path){
     var x$0 = path[1];
     if(x$0)
      var p = x$0[1], _aF_ = with_path(u$0, p);
     else
      var _aF_ = with_path(u$0, cst$31);
     var u = _aF_;
    }
    else
     var u = u$0;
    if(query){
     var x = query[1];
     if(x)
      var q = x[1], _aE_ = with_query(u, q);
     else
      var _aE_ = with_query(u, 0);
     var _aD_ = _aE_;
    }
    else
     var _aD_ = u;
    return with$0(with_fragment, fragment, _aD_);
   }
   function of_string(s){
    var match = caml_call3(Angstrom[75], 0, uri_reference$0, s);
    if(0 !== match[0]) return empty;
    var t = match[1];
    return t;
   }
   var let$0 = Stdlib_Result[6];
   function to_uri(param){
    var
     fragment = param[7],
     query = param[6],
     path = param[5],
     port = param[4],
     host = param[3],
     userinfo = param[2],
     scheme = param[1],
     scheme$0 = 804243368 <= scheme ? x : x$0;
    return [0,
            [0, scheme$0],
            userinfo,
            [0, host],
            port,
            path,
            query,
            fragment];
   }
   function of_uri(param){
    var
     fragment = param[7],
     query = param[6],
     path = param[5],
     port = param[4],
     host = param[3],
     userinfo = param[2],
     scheme = param[1];
    function _aA_(scheme){
     return caml_call2
             (let$0,
              caml_call2(Stdlib_Option[14], _ap_, host),
              function(host){
               return [0,
                       [0, scheme, userinfo, host, port, path, query, fragment]];
              });
    }
    if(scheme)
     var
      unsupported_scheme = scheme[1],
      _aB_ =
        unsupported_scheme !== cst_http
         ? unsupported_scheme
           !== cst_https
           ? [1,
             [0,
              3854881,
              caml_call2(Stdlib_Printf[4], _aq_, unsupported_scheme)]]
           : _ar_
         : _as_,
      _aC_ = _aB_;
    else
     var _aC_ = _at_;
    return caml_call2(let$0, _aC_, _aA_);
   }
   function of_string$0(s){
    var match = of_uri(of_string(s));
    if(0 === match[0]){var t = match[1]; return t;}
    var error = match[1][2];
    return caml_call1(Stdlib[2], error);
   }
   function to_string$0(pct_encoder, t){
    return to_string(pct_encoder, to_uri(t));
   }
   function make$0
   (scheme, host$2, userinfo, port, path, query, fragment, param){
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    if(path){
     var p = path[1], path$0 = path_of_encoded(p);
     a:
     {
      if(path$0 && path$0[1] !== cst$33){
       var _ay_ = [0, cst$32, path$0];
       break a;
      }
      var _ay_ = path$0;
     }
     var path$1 = _ay_;
    }
    else
     var path$1 = 0;
    if(query) var p$0 = query[1], query$0 = [0, p$0]; else var query$0 = _au_;
    if(fragment) var x$0 = fragment[1], _az_ = [0, x$0]; else var _az_ = 0;
    var match = decode_host(host$2), _aw_ = match[1];
    if(267950263 === _aw_)
     var
      host = match[2],
      _ax_ = [0, 267950263, caml_call1(Stdlib_String[26], host)];
    else if(803994504 <= _aw_)
     var
      host$0 = match[2],
      x = caml_call1(Stdlib_String[26], host$0),
      _ax_ = [0, 803994504, x];
    else
     var
      host$1 = match[2],
      _ax_ = [0, -367671627, caml_call1(Stdlib_String[26], host$1)];
    return [0, scheme, userinfo$0, _ax_, port, path$1, query$0, _az_];
   }
   function host$1(t){
    var match = t[3];
    if(803994504 <= match[1]){var h = match[2]; return h;}
    var h$0 = match[2];
    return h$0;
   }
   function scheme$1(t){return t[1];}
   var
    Uri =
      [0,
       empty,
       compare$0,
       equal,
       pct_encode,
       pct_encoder,
       pct_decode,
       of_string,
       to_string,
       resolve,
       canonicalize,
       make,
       with_uri,
       query,
       verbatim_query,
       encoded_of_query$0,
       query_of_encoded,
       with_query,
       with_query$0,
       get_query_param,
       get_query_param$0,
       add_query_param,
       add_query_param$0,
       add_query_params,
       add_query_params$0,
       remove_query_param,
       path,
       path_and_query,
       with_path,
       scheme,
       with_scheme,
       userinfo,
       with_userinfo,
       user,
       password,
       with_password,
       host,
       with_host,
       host_with_default,
       port,
       with_port,
       fragment,
       with_fragment,
       pp,
       pp_hum,
       [0, ipv6, uri_reference$0],
       [0, of_uri, to_uri, of_string$0, to_string$0, make$0, host$1, scheme$1]];
   runtime.caml_register_global(107, Uri, "Uri");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ1cmkuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbIngiLCJ4JDAiLCJjc3QkMTUiLCJjc3QkMTMiLCJjc3QkMTIiLCJjc3QkMCIsIml0ZXJfY29uY2F0IiwiZm4iLCJzZXAiLCJidWYiLCJsYXN0IiwicmVzdCIsImNvbXBhcmVfb3B0IiwiYyIsInQkMCIsInQiLCJhIiwiYiIsImNvbXBhcmVfbGlzdCIsImYiLCJ0JDIiLCJ0JDEiLCJ4cyIsInlzIiwieSIsInN1Yl9kZWxpbXMiLCJpIiwic2FmZV9jaGFycyIsInBjaGFyIiwic2FmZV9jaGFyc19mb3Jfc2NoZW1lIiwic2FmZV9jaGFyc19mb3JfcGF0aCIsInNhZmVfY2hhcnNfZm9yX3F1ZXJ5Iiwic2FmZV9jaGFyc19mb3JfcXVlcnlfa2V5Iiwic2FmZV9jaGFyc19mb3JfcXVlcnlfdmFsdWUiLCJzYWZlX2NoYXJzX2Zvcl91c2VyaW5mbyIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCIsInVuc2FmZSIsInNhZmUiLCJjb21wb25lbnQiLCJzYWZlX2NoYXJzJDAiLCJpJDAiLCJjJDAiLCJub3JtYWxpemVfaG9zdCIsImhzbyIsImNhbm9uaWNhbGl6ZV9wb3J0IiwicG9ydCIsImNhbm9uaWNhbGl6ZV9wYXRoIiwicGF0aCIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCQwIiwibm9ybWFsaXplX2hvc3QkMCIsImhzIiwiY2Fub25pY2FsaXplX3BvcnQkMCIsImNhbm9uaWNhbGl6ZV9wYXRoJDAiLCJzYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQkMSIsIm5vcm1hbGl6ZV9ob3N0JDEiLCJjYW5vbmljYWxpemVfcGF0aCQxIiwiY2Fub25pY2FsaXplX3BvcnQkMSIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCQyIiwiY2Fub25pY2FsaXplX3BvcnQkMiIsImNhbm9uaWNhbGl6ZV9wYXRoJDIiLCJub3JtYWxpemVfaG9zdCQyIiwiaHMkMCIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCQzIiwibm9ybWFsaXplX2hvc3QkMyIsImNhbm9uaWNhbGl6ZV9wb3J0JDMiLCJjYW5vbmljYWxpemVfcGF0aCQzIiwibW9kdWxlX29mX3NjaGVtZSIsInMiLCJlbmNvZGUiLCJzY2hlbWUiLCJvcHQiLCJzdGgiLCJsZW4iLCJzdGFydCIsImN1ciIsImN1ciQwIiwiY3VyJDEiLCJzdGFydCQwIiwiaW50X29mX2hleF9jaGFyIiwiZGVjb2RlIiwiaGlnaGJpdHMiLCJsb3diaXRzIiwic3RhcnRfYXQiLCJwY3RfZW5jb2RlIiwicGN0X2VuY29kZXIiLCJzdGgkMCIsInVzZXJpbmZvIiwic3RoJDEiLCJob3N0Iiwic3RoJDIiLCJzdGgkMyIsInF1ZXJ5X2tleSIsInN0aCQ0IiwicXVlcnlfdmFsdWUiLCJzdGgkNSIsImZyYWdtZW50IiwicGN0X2RlY29kZSIsImNvbXBhcmUiLCJwIiwidSIsInAkMCIsInUkMCIsInVzZXJpbmZvX29mX2VuY29kZWQiLCJ1cyIsIngkMSIsImVuY29kZWRfb2ZfdXNlcmluZm8iLCJwbyIsInBhdGhfb2ZfZW5jb2RlZCIsInBzIiwidG9rbCIsInJlbW92ZV9kb3Rfc2VnbWVudHMiLCJyZXZwIiwiYXNjZW5zaW9uIiwib3V0cCIsInIkMyIsInIkMSIsInIkMCIsInIkMiIsInIiLCJsc3QiLCJoIiwiYWNjIiwiZW5jb2RlZF9vZl9wYXRoIiwidG9rIiwic2VnIiwicXVlcnlfb2ZfZW5jb2RlZCIsInFzIiwiZWxzIiwicGx1c190b19zcGFjZSIsInMkMCIsImVsIiwiayIsInRsIiwidiIsImwiLCJsJDAiLCJuIiwidGwkMCIsIm4kMCIsInRsJDEiLCJlbmNvZGVkX29mX3F1ZXJ5IiwicGN0X2VuY29kZXIkMCIsIm9mX3JhdyIsImxhenlfcXVlcnkiLCJrdiIsImVuY29kZWRfb2ZfcXVlcnkkMCIsImVtcHR5IiwiY29tcGFyZV9kZWNvZGVkIiwiY29tcGFyZV9ob3N0IiwiaDEiLCJoMiIsImlwMiIsImlwMSIsImlwMiQwIiwiaXAxJDAiLCJoMiQwIiwiaDEkMCIsImNvbXBhcmUkMCIsImMkMiIsImMkMyIsImMkNCIsImt2bCQwIiwia3ZsIiwicmF3IiwicmF3JDAiLCJjJDEiLCJ2bCIsInZsJDAiLCJrJDAiLCJlcXVhbCIsInVuY2FzdF9vcHQiLCJub3JtYWxpemUiLCJzY2hlbSIsImluaXQiLCJob3N0JDAiLCJob3N0JDEiLCJ0b19zdHJpbmciLCJ1cmkiLCJhZGRfcGN0X3N0cmluZyIsImZpcnN0X3NlZ21lbnQiLCJ4JDIiLCJxIiwiZ2V0X2RlY29kZWRfb3B0Iiwid2l0aF9zY2hlbWUiLCJoJDAiLCJob3N0X3dpdGhfZGVmYXVsdCIsImRlZmF1bHQkMCIsIndpdGhfdXNlcmluZm8iLCJ1c2VyaW5mbyQwIiwidXNlciIsInBhc3N3b3JkIiwicGFzcyIsIndpdGhfcGFzc3dvcmQiLCJyZXN1bHQiLCJ3aXRoX3BvcnQiLCJ3aXRoX3BhdGgiLCJwYXRoJDAiLCJ3aXRoX2ZyYWdtZW50IiwiZnJhZyIsInF1ZXJ5IiwidmVyYmF0aW1fcXVlcnkiLCJnZXRfcXVlcnlfcGFyYW0iLCJnZXRfcXVlcnlfcGFyYW0kMCIsIndpdGhfcXVlcnkiLCJxX3MiLCJ3aXRoX3F1ZXJ5JDAiLCJhZGRfcXVlcnlfcGFyYW0iLCJhZGRfcXVlcnlfcGFyYW0kMCIsImFkZF9xdWVyeV9wYXJhbXMiLCJhZGRfcXVlcnlfcGFyYW1zJDAiLCJyZW1vdmVfcXVlcnlfcGFyYW0iLCJwYXRoX2FuZF9xdWVyeSIsIm1hdGNoIiwic2NoZW1lJDAiLCJyZXNvbHZlIiwiYmFzZSIsInNjaGVtZSQxIiwic2NoZW0kMCIsInBhdGhfc3RyIiwicmVscGF0aCIsImJwYXRoIiwiYmhvc3QiLCJyYnBhdGgiLCJjYW5vbmljYWxpemUiLCJ1cmkkMCIsInBwIiwicHBmIiwicHBfaHVtIiwic3RyaW5nX29mX2NoYXIiLCJzdHJpbmdfb2ZfY2hhcl9saXN0IiwiY2hhcnMiLCJpc19kaWdpdCIsImhleF9kaWdpdCIsImhleGFkZWNpbWFsIiwiY19kb3QiLCJjX2F0IiwiY19jb2xvbiIsImRlY19vY3RldCIsIm51bSIsImlwdjRfYWRkcmVzcyIsInRocmVlIiwib25lIiwiYWZ0ZXJfZG91YmxlX2NvbG9uIiwiZG91YmxlX2NvbG9uIiwiY291bnQiLCJmaWxsZXJfbGVuZ3RoIiwicGFydCIsImhleF9wYXJ0Iiwic3BsaXRfd2l0aCIsInRzIiwienMiLCJmb3JtYXRfYWRkciIsInNlZ21lbnRzIiwic2VnbWVudCIsImJlZm9yZV9kb3VibGVfY29sb24iLCJiZWZvcmUiLCJyZXMiLCJpcHY2IiwiaXB2Nl9hZGRyZXNzIiwicGN0X2VuY29kZWQiLCJwY3QiLCJkaWdpdHMiLCJzdWJfZGVsaW1zJDAiLCJ1bnJlc2VydmVkIiwicmVnX25hbWUiLCJwb3J0JDAiLCJkZWNvZGVkIiwiYXV0aG9yaXR5IiwicXVlcnkkMCIsImZyYWdtZW50JDAiLCJ1cmlfcmVmZXJlbmNlIiwidXJpX3JlZmVyZW5jZSQwIiwiZGVjb2RlX2hvc3QiLCJwYXJzZWQiLCJwYXJzZWQkMCIsIm1ha2UiLCJwYXRoJDEiLCJ3aXRoX2hvc3QiLCJ3aXRoX3VyaSIsIndpdGgkMCIsIm8iLCJvZl9zdHJpbmciLCJsZXQkMCIsInRvX3VyaSIsIm9mX3VyaSIsInVuc3VwcG9ydGVkX3NjaGVtZSIsIm9mX3N0cmluZyQwIiwiZXJyb3IiLCJ0b19zdHJpbmckMCIsIm1ha2UkMCIsImhvc3QkMiJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvdXJpL3VyaS5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7SUF5UW1CQTtJQUFBQzs7Ozs7Ozs7Ozs7Ozs7O0lBQUFDO0lBQUFDOztJQUFBQzs7Ozs7Ozs7Ozs7SUFyTkRDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQVJWQyxZQUFZQyxJQUFHQyxLQUFJQzs7O21CQU1qQjtTQUxOQztzQkFBWSxPQUFBLFdBRElILElBQU9FLEtBQ3ZCQztTQUNJQztLQUNKLFdBSGdCSixJQUFPRSxLQUN2QkM7S0FHQSw4QkFK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eEc7T0FtYUE2TDtPQTdaQTVGO09Bb0NBNUk7T0FDQXFKO09BbUJBbkc7T0FDQXNHO09Bb0ZBNEI7T0FDQUU7V0F5RkU4QixNQW9JQWM7V0F5SEFhLFFBZkFELFFBa0NBRyxhQUlBRSxhQWFBQyxRQXFCQWxILFFBS0F5Qzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgQW5pbCBNYWRoYXZhcGVkZHkgPGFuaWxAcmVjb2lsLm9yZz5cbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE0IERhdmlkIFNoZWV0cyA8c2hlZXRzQGFsdW0ubWl0LmVkdT5cbiAqXG4gKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAqIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbiAqIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4gKiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4gKiBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbiAqIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4gKiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICpcbiAqKVxuXG5bQEBAb2NhbWwud2FybmluZyBcIi0zMlwiXVxuXG50eXBlIGNvbXBvbmVudCA9IFtcbiAgfCBgU2NoZW1lXG4gIHwgYEF1dGhvcml0eVxuICB8IGBVc2VyaW5mbyAoKiBzdWJjb21wb25lbnQgb2YgYXV0aG9yaXR5IGluIHNvbWUgc2NoZW1lcyAqKVxuICB8IGBIb3N0ICgqIHN1YmNvbXBvbmVudCBvZiBhdXRob3JpdHkgaW4gc29tZSBzY2hlbWVzICopXG4gIHwgYFBhdGhcbiAgfCBgUXVlcnlcbiAgfCBgUXVlcnlfa2V5XG4gIHwgYFF1ZXJ5X3ZhbHVlXG4gIHwgYEZyYWdtZW50XG4gIHwgYEdlbmVyaWNcbiAgfCBgQ3VzdG9tIG9mIChjb21wb25lbnQgKiBzdHJpbmcgKiBzdHJpbmcpICgqIChjb21wb25lbnQgKiBzYWZlIGNoYXJzICogdW5zYWZlIGNoYXJzKSAqKVxuXVxuXG50eXBlIHBjdF9lbmNvZGVyID0ge1xuICAgIHNjaGVtZTogY29tcG9uZW50O1xuICAgIHVzZXJpbmZvOiBjb21wb25lbnQ7XG4gICAgaG9zdDogY29tcG9uZW50O1xuICAgIHBhdGg6IGNvbXBvbmVudDtcbiAgICBxdWVyeV9rZXk6IGNvbXBvbmVudDtcbiAgICBxdWVyeV92YWx1ZTogY29tcG9uZW50O1xuICAgIGZyYWdtZW50OiBjb21wb25lbnQ7XG4gIH1cblxubGV0IHJlYyBpdGVyX2NvbmNhdCBmbiBzZXAgYnVmID0gZnVuY3Rpb25cbiAgfCBsYXN0OjpbXSAtPiBmbiBidWYgbGFzdFxuICB8IGVsOjpyZXN0IC0+XG4gICAgZm4gYnVmIGVsO1xuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBzZXA7XG4gICAgaXRlcl9jb25jYXQgZm4gc2VwIGJ1ZiByZXN0XG4gIHwgW10gLT4gKClcblxubGV0IHJldl9pbnRlcmplY3QgZSBsc3QgPVxuICBsZXQgcmVjIGF1eCBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gIC0+IGFjY1xuICAgIHwgeDo6eHMgLT4gYXV4ICh4OjplOjphY2MpIHhzXG4gIGluIG1hdGNoIGxzdCB3aXRoXG4gIHwgW10gIC0+IFtdXG4gIHwgaDo6dCAtPiBhdXggW2hdIHRcblxubGV0IGNvbXBhcmVfb3B0IGMgdCB0JyA9IG1hdGNoIHQsIHQnIHdpdGhcbiAgfCBOb25lLCAgIE5vbmUgICAtPiAwXG4gIHwgU29tZSBfLCBOb25lICAgLT4gMVxuICB8IE5vbmUsICAgU29tZSBfIC0+IC0xXG4gIHwgU29tZSBhLCBTb21lIGIgLT4gYyBhIGJcblxubGV0IHJlYyBjb21wYXJlX2xpc3QgZiB0IHQnID0gbWF0Y2ggdCwgdCcgd2l0aFxuICB8IFtdLCAgICBbXSAgICAtPiAgMFxuICB8IF86Ol8sICBbXSAgICAtPiAgMVxuICB8IFtdLCAgICBfOjpfICAtPiAtMVxuICB8IHg6OnhzLCB5Ojp5cyAtPlxuICAgIG1hdGNoIGYgeCB5IHdpdGggMCAtPiBjb21wYXJlX2xpc3QgZiB4cyB5cyB8IGMgLT4gY1xuXG4oKiogU2FmZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIGFsd2F5cyBhbGxvd2VkIGluIGEgVVJJXG4gICogVW5mb3J0dW5hdGVseSwgdGhpcyB2YXJpZXMgZGVwZW5kaW5nIG9uIHdoaWNoIGJpdCBvZiB0aGUgVVJJXG4gICogaXMgYmVpbmcgcGFyc2VkLCBzbyB0aGVyZSBhcmUgbXVsdGlwbGUgdmFyaWFudHMgKGFuZCB0aGlzXG4gICogc2V0IGlzIHByb2JhYmx5IG5vdCBleGhhdXN0aXZlLiBUT0RPOiBjaGVjay5cbiopXG50eXBlIHNhZmVfY2hhcnMgPSBib29sIGFycmF5XG5cbm1vZHVsZSB0eXBlIFNjaGVtZSA9IHNpZ1xuICB2YWwgc2FmZV9jaGFyc19mb3JfY29tcG9uZW50IDogY29tcG9uZW50IC0+IHNhZmVfY2hhcnNcbiAgdmFsIG5vcm1hbGl6ZV9ob3N0IDogc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgY2Fub25pY2FsaXplX3BvcnQgOiBpbnQgb3B0aW9uIC0+IGludCBvcHRpb25cbiAgdmFsIGNhbm9uaWNhbGl6ZV9wYXRoIDogc3RyaW5nIGxpc3QgLT4gc3RyaW5nIGxpc3RcbmVuZFxuXG5tb2R1bGUgR2VuZXJpYyA6IFNjaGVtZSA9IHN0cnVjdFxuICBsZXQgc3ViX2RlbGltcyBhID1cbiAgICBsZXQgc3ViZCA9IFwiISQmJygpKissOz1cIiBpblxuICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHN1YmQgLSAxIGRvXG4gICAgICBsZXQgYyA9IENoYXIuY29kZSBzdWJkLltpXSBpblxuICAgICAgYS4oYykgPC0gdHJ1ZVxuICAgIGRvbmU7XG4gICAgYVxuXG4gIGxldCBzYWZlX2NoYXJzIDogc2FmZV9jaGFycyA9XG4gICAgbGV0IGEgPSBBcnJheS5tYWtlIDI1NiBmYWxzZSBpblxuICAgIGxldCBhbHdheXNfc2FmZSA9XG4gICAgICBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Xy4tflwiIGluXG4gICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggYWx3YXlzX3NhZmUgLSAxIGRvXG4gICAgICBsZXQgYyA9IENoYXIuY29kZSBhbHdheXNfc2FmZS5baV0gaW5cbiAgICAgIGEuKGMpIDwtIHRydWVcbiAgICBkb25lO1xuICAgIGFcblxuICBsZXQgcGNoYXIgOiBzYWZlX2NoYXJzID1cbiAgICBsZXQgYSA9IHN1Yl9kZWxpbXMgKEFycmF5LmNvcHkgc2FmZV9jaGFycykgaW5cbiAgICBhLihDaGFyLmNvZGUgJzonKSA8LSB0cnVlO1xuICAgIGEuKENoYXIuY29kZSAnQCcpIDwtIHRydWU7XG4gICAgYVxuXG4gIGxldCBzYWZlX2NoYXJzX2Zvcl9zY2hlbWUgOiBzYWZlX2NoYXJzID1cbiAgICBsZXQgYSA9IEFycmF5LmNvcHkgc2FmZV9jaGFycyBpblxuICAgIGEuKENoYXIuY29kZSAnKycpIDwtIHRydWU7XG4gICAgYVxuXG4gICgqKiBTYWZlIGNoYXJhY3RlcnMgZm9yIHRoZSBwYXRoIGNvbXBvbmVudCBvZiBhIFVSSSAqKVxuICBsZXQgc2FmZV9jaGFyc19mb3JfcGF0aCA6IHNhZmVfY2hhcnMgPVxuICAgIGxldCBhID0gc3ViX2RlbGltcyAoQXJyYXkuY29weSBwY2hhcikgaW5cbiAgICAoKiBkZWxpbWl0ZXI6IG5vbi1zZWdtZW50IGRlbGltaXRpbmcgdXNlcyBzaG91bGQgYmUgcGN0IGVuY29kZWQgKilcbiAgICBhLihDaGFyLmNvZGUgJy8nKSA8LSBmYWxzZTtcbiAgICBhXG5cbiAgbGV0IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5IDogc2FmZV9jaGFycyA9XG4gICAgKCogVE9ETzogV2hhdCBhYm91dCB7XCIhXCIsXCIkXCIsXCIsXCJ9PyBTZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9hdnNtL29jYW1sLXVyaS9jb21taXQvMWVmM2YxZGZiNDFiZGI0ZjMzZjIyM2ZmZTE2ZTYyYTMzOTc1NjYxYSNkaWZmLTc0MGYyZGU1M2M5ZWIzNmU5NjcwZGRmYmRiOWJhOTE0UjE3MT4gKilcbiAgICBsZXQgYSA9IEFycmF5LmNvcHkgcGNoYXIgaW5cbiAgICBhLihDaGFyLmNvZGUgJy8nKSA8LSB0cnVlO1xuICAgIGEuKENoYXIuY29kZSAnPycpIDwtIHRydWU7XG4gICAgKCogJyYnIGlzIHNhZmUgYnV0IHdlIHNob3VsZCBlbmNvZGUgbGl0ZXJhbHMgdG8gYXZvaWQgYW1iaWd1aXR5XG4gICAgICAgd2l0aCB0aGUgYWxyZWFkeSBwYXJzZWQgcXMgcGFyYW1zICopXG4gICAgYS4oQ2hhci5jb2RlICcmJykgPC0gZmFsc2U7XG4gICAgKCogJzsnIGlzIHNhZmUgYnV0IHNvbWUgc3lzdGVtcyB0cmVhdCBpdCBsaWtlICcmJy4gKilcbiAgICBhLihDaGFyLmNvZGUgJzsnKSA8LSBmYWxzZTtcbiAgICBhLihDaGFyLmNvZGUgJysnKSA8LSBmYWxzZTtcbiAgICBhXG5cbiAgbGV0IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5X2tleSA6IHNhZmVfY2hhcnMgPVxuICAgIGxldCBhID0gQXJyYXkuY29weSBzYWZlX2NoYXJzX2Zvcl9xdWVyeSBpblxuICAgIGEuKENoYXIuY29kZSAnPScpIDwtIGZhbHNlO1xuICAgIGFcblxuICBsZXQgc2FmZV9jaGFyc19mb3JfcXVlcnlfdmFsdWUgOiBzYWZlX2NoYXJzID1cbiAgICBsZXQgYSA9IEFycmF5LmNvcHkgc2FmZV9jaGFyc19mb3JfcXVlcnkgaW5cbiAgICBhLihDaGFyLmNvZGUgJywnKSA8LSBmYWxzZTtcbiAgICBhXG5cbiAgbGV0IHNhZmVfY2hhcnNfZm9yX2ZyYWdtZW50IDogc2FmZV9jaGFycyA9IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5XG5cbiAgKCoqIFNhZmUgY2hhcmFjdGVycyBmb3IgdGhlIHVzZXJpbmZvIHN1YmNvbXBvbmVudCBvZiBhIFVSSS5cbiAgICAgIFRPRE86IHRoaXMgbmVlZHMgbW9yZSByZXNlcnZlZCBjaGFyYWN0ZXJzIGFkZGVkICopXG4gIGxldCBzYWZlX2NoYXJzX2Zvcl91c2VyaW5mbyA6IHNhZmVfY2hhcnMgPVxuICAgIGxldCBhID0gQXJyYXkuY29weSBzYWZlX2NoYXJzIGluXG4gICAgKCogZGVsaW1pdGVyOiBub24tc2VnbWVudCBkZWxpbWl0aW5nIHVzZXMgc2hvdWxkIGJlIHBjdCBlbmNvZGVkICopXG4gICAgYS4oQ2hhci5jb2RlICc6JykgPC0gZmFsc2U7XG4gICAgYVxuXG4gIGxldCByZWMgc2FmZV9jaGFyc19mb3JfY29tcG9uZW50ID0gZnVuY3Rpb25cbiAgICB8IGBQYXRoIC0+IHNhZmVfY2hhcnNfZm9yX3BhdGhcbiAgICB8IGBVc2VyaW5mbyAtPiBzYWZlX2NoYXJzX2Zvcl91c2VyaW5mb1xuICAgIHwgYFF1ZXJ5IC0+IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5XG4gICAgfCBgUXVlcnlfa2V5IC0+IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5X2tleVxuICAgIHwgYFF1ZXJ5X3ZhbHVlIC0+IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5X3ZhbHVlXG4gICAgfCBgRnJhZ21lbnQgLT4gc2FmZV9jaGFyc19mb3JfZnJhZ21lbnRcbiAgICB8IGBTY2hlbWUgLT4gc2FmZV9jaGFyc19mb3Jfc2NoZW1lXG4gICAgfCBgQ3VzdG9tICgoY29tcG9uZW50IDogY29tcG9uZW50KSwgc2FmZSwgdW5zYWZlKSAtPlxuICAgICAgIGxldCBzYWZlX2NoYXJzID0gQXJyYXkuY29weSAoc2FmZV9jaGFyc19mb3JfY29tcG9uZW50IGNvbXBvbmVudCkgaW5cbiAgICAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzYWZlIC0gMSBkb1xuICAgICAgICAgbGV0IGMgPSBDaGFyLmNvZGUgc2FmZS5baV0gaW5cbiAgICAgICAgIHNhZmVfY2hhcnMuKGMpIDwtIHRydWVcbiAgICAgICBkb25lO1xuICAgICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHVuc2FmZSAtIDEgZG9cbiAgICAgICAgIGxldCBjID0gQ2hhci5jb2RlIHVuc2FmZS5baV0gaW5cbiAgICAgICAgIHNhZmVfY2hhcnMuKGMpIDwtIGZhbHNlXG4gICAgICAgZG9uZTtcbiAgICAgICBzYWZlX2NoYXJzXG4gICAgfCBgR2VuZXJpY1xuICAgIHwgXyAtPiBzYWZlX2NoYXJzXG5cbiAgbGV0IG5vcm1hbGl6ZV9ob3N0IGhzbyA9IGhzb1xuXG4gIGxldCBjYW5vbmljYWxpemVfcG9ydCBwb3J0ID0gcG9ydFxuICBsZXQgY2Fub25pY2FsaXplX3BhdGggcGF0aCA9IHBhdGhcbmVuZFxuXG5tb2R1bGUgSHR0cCA6IFNjaGVtZSA9IHN0cnVjdFxuICBpbmNsdWRlIEdlbmVyaWNcblxuICBsZXQgbm9ybWFsaXplX2hvc3QgaHMgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIGhzXG5cbiAgbGV0IGNhbm9uaWNhbGl6ZV9wb3J0ID0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSA4MCAtPiBOb25lXG4gICAgfCBTb21lIHggLT4gU29tZSB4XG5cbiAgbGV0IGNhbm9uaWNhbGl6ZV9wYXRoID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IFtcIi9cIl1cbiAgICB8IHggIC0+IHhcbmVuZFxuXG5tb2R1bGUgSHR0cHMgOiBTY2hlbWUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBIdHRwXG5cbiAgbGV0IGNhbm9uaWNhbGl6ZV9wb3J0ID0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSA0NDMgLT4gTm9uZVxuICAgIHwgU29tZSB4IC0+IFNvbWUgeFxuZW5kXG5cbm1vZHVsZSBGaWxlIDogU2NoZW1lID0gc3RydWN0XG4gIGluY2x1ZGUgR2VuZXJpY1xuXG4gIGxldCBub3JtYWxpemVfaG9zdCBocyA9XG4gICAgbGV0IGhzID0gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBocyBpblxuICAgIGlmIGhzPVwibG9jYWxob3N0XCIgdGhlbiBcIlwiIGVsc2UgaHNcbmVuZFxuXG5tb2R1bGUgVXJuIDogU2NoZW1lID0gc3RydWN0XG4gIGluY2x1ZGUgR2VuZXJpY1xuXG5lbmRcblxubGV0IG1vZHVsZV9vZl9zY2hlbWUgPSBmdW5jdGlvblxuICB8IFNvbWUgcyAtPiBiZWdpbiBtYXRjaCBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHMgd2l0aFxuICAgICAgfCBcImh0dHBcIiAtPiAobW9kdWxlIEh0dHAgOiBTY2hlbWUpXG4gICAgICB8IFwiaHR0cHNcIiAgLT4gKG1vZHVsZSBIdHRwcyA6IFNjaGVtZSlcbiAgICAgIHwgXCJmaWxlXCIgLT4gKG1vZHVsZSBGaWxlIDogU2NoZW1lKVxuICAgICAgfCBcInVyblwiICAtPiAobW9kdWxlIFVybiA6IFNjaGVtZSlcbiAgICAgIHwgXyAtPiAobW9kdWxlIEdlbmVyaWMgOiBTY2hlbWUpXG4gICAgZW5kXG4gIHwgTm9uZSAtPiAobW9kdWxlIEdlbmVyaWMgOiBTY2hlbWUpXG5cbigqKiBQb3J0aW9ucyBvZiB0aGUgVVJMIG11c3QgYmUgY29udmVydGVkIHRvLWFuZC1mcm9tIHBlcmNlbnQtZW5jb2RpbmdcbiAgKiBhbmQgdGhpcyByZWFsbHksIHJlYWxseSBzaG91bGRuJ3QgYmUgbWl4ZWQgdXAuIFNvIHRoaXMgUGN0IG1vZHVsZVxuICAqIGRlZmluZXMgYWJzdHJhY3QgUGN0LmVuY29kZWQgYW5kIFBjdC5kZWNvZGVkIHR5cGVzIHdoaWNoIHNldHMgdGhlXG4gICogc3RhdGUgb2YgdGhlIHVuZGVybHlpbmcgc3RyaW5nLiAgVGhlcmUgYXJlIGZ1bmN0aW9ucyB0byBcImNhc3RcIiB0b1xuICAqIGFuZCBmcm9tIHRoZXNlIGFuZCBub3JtYWwgc3RyaW5ncywgYW5kIHRoaXMgcHJvbW90ZXMgYSBiaXQgb2ZcbiAgKiBpbnRlcm5hbCBzYWZldHkuICBUaGVzZSB0eXBlcyBhcmUgbm90IGV4cG9zZWQgdG8gdGhlIGV4dGVybmFsXG4gICogaW50ZXJmYWNlLCBhcyBjYXN0aW5nIHRvLWFuZC1mcm9tIGlzIHF1aXRlIGEgYml0IG9mIGhhc3NsZSBhbmRcbiAgKiBwcm9iYWJseSBub3QgYSBsb3Qgb2YgdXNlIHRvIHRoZSBhdmVyYWdlIGNvbnN1bWVyIG9mIHRoaXMgbGlicmFyeVxuKilcbm1vZHVsZSBQY3QgOiBzaWdcbiAgdHlwZSBlbmNvZGVkXG4gIHR5cGUgZGVjb2RlZFxuXG4gIHZhbCBlbmNvZGUgOiA/c2NoZW1lOnN0cmluZyAtPiA/Y29tcG9uZW50OmNvbXBvbmVudCAtPiBkZWNvZGVkIC0+IGVuY29kZWRcbiAgdmFsIGRlY29kZSA6IGVuY29kZWQgLT4gZGVjb2RlZFxuXG4gICgqIFRoZSBlbXB0eSBkZWNvZGVkIHN0cmluZyAqKVxuICB2YWwgZW1wdHlfZGVjb2RlZCA6IGRlY29kZWRcbiAgKCogSWRlbnRpdHkgZnVuY3Rpb25zIHNvIHdlIG5lZWQgdG8gZXhwbGljaXRseSBjYXN0IHdoZW4gdXNpbmcgdGhlbSBiZWxvdyAqKVxuICB2YWwgY2FzdF9lbmNvZGVkIDogc3RyaW5nIC0+IGVuY29kZWRcbiAgdmFsIGNhc3RfZGVjb2RlZCA6IHN0cmluZyAtPiBkZWNvZGVkXG4gIHZhbCB1bmNhc3RfZW5jb2RlZCA6IGVuY29kZWQgLT4gc3RyaW5nXG4gIHZhbCB1bmNhc3RfZGVjb2RlZCA6IGRlY29kZWQgLT4gc3RyaW5nXG4gICgqIExpZnQgSE9GcyBmb3IgbWFwcyBvdmVyIGVuY29kaW5ncywgZGVjb2RpbmdzLCBhbmQgc3RyaW5ncyAqKVxuICB2YWwgbGlmdF9lbmNvZGVkIDogKGVuY29kZWQgLT4gZW5jb2RlZCkgLT4gc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgbGlmdF9kZWNvZGVkIDogKGRlY29kZWQgLT4gZGVjb2RlZCkgLT4gc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgdW5saWZ0X2VuY29kZWQgOiAoc3RyaW5nIC0+IHN0cmluZykgLT4gZW5jb2RlZCAtPiBlbmNvZGVkXG4gIHZhbCB1bmxpZnRfZGVjb2RlZCA6IChzdHJpbmcgLT4gc3RyaW5nKSAtPiBkZWNvZGVkIC0+IGRlY29kZWRcbiAgdmFsIHVubGlmdF9kZWNvZGVkMiA6IChzdHJpbmcgLT4gc3RyaW5nIC0+ICdhKSAtPiBkZWNvZGVkIC0+IGRlY29kZWQgLT4gJ2FcbmVuZCA9IHN0cnVjdFxuICB0eXBlIGVuY29kZWQgPSBzdHJpbmdcbiAgdHlwZSBkZWNvZGVkID0gc3RyaW5nXG4gIGxldCBjYXN0X2VuY29kZWQgeCA9IHhcbiAgbGV0IGNhc3RfZGVjb2RlZCB4ID0geFxuICBsZXQgZW1wdHlfZGVjb2RlZCA9IFwiXCJcbiAgbGV0IHVuY2FzdF9kZWNvZGVkIHggPSB4XG4gIGxldCB1bmNhc3RfZW5jb2RlZCB4ID0geFxuXG4gIGxldCBsaWZ0X2VuY29kZWQgZiA9IGZcbiAgbGV0IGxpZnRfZGVjb2RlZCBmID0gZlxuICBsZXQgdW5saWZ0X2VuY29kZWQgZiA9IGZcbiAgbGV0IHVubGlmdF9kZWNvZGVkIGYgPSBmXG4gIGxldCB1bmxpZnRfZGVjb2RlZDIgZiA9IGZcblxuICAoKiogU2NhbiBmb3IgcmVzZXJ2ZWQgY2hhcmFjdGVycyBhbmQgcmVwbGFjZSB0aGVtIHdpdGhcbiAgICAgIHBlcmNlbnQtZW5jb2RlZCBlcXVpdmFsZW50cy5cbiAgICAgIEByZXR1cm4gYSBwZXJjZW50LWVuY29kZWQgc3RyaW5nICopXG4gIGxldCBlbmNvZGUgP3NjaGVtZSA/KGNvbXBvbmVudD1gUGF0aCkgYiA9XG4gICAgbGV0IG1vZHVsZSBTY2hlbWUgPSAodmFsIChtb2R1bGVfb2Zfc2NoZW1lIHNjaGVtZSkgOiBTY2hlbWUpIGluXG4gICAgbGV0IHNhZmVfY2hhcnMgPSBTY2hlbWUuc2FmZV9jaGFyc19mb3JfY29tcG9uZW50IGNvbXBvbmVudCBpblxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIGIgaW5cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIHNjYW4gc3RhcnQgY3VyID1cbiAgICAgIGlmIGN1ciA+PSBsZW4gdGhlbiBiZWdpblxuICAgICAgICBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgYiBzdGFydCAoY3VyLXN0YXJ0KTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBjID0gQ2hhci5jb2RlIGIuW2N1cl0gaW5cbiAgICAgICAgaWYgc2FmZV9jaGFycy4oYykgdGhlblxuICAgICAgICAgIHNjYW4gc3RhcnQgKGN1cisxKVxuICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgaWYgY3VyID4gc3RhcnQgdGhlbiBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgYiBzdGFydCAoY3VyLXN0YXJ0KTtcbiAgICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKFByaW50Zi5zcHJpbnRmIFwiJSUlMDJYXCIgYyk7XG4gICAgICAgICAgc2NhbiAoY3VyKzEpIChjdXIrMSlcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBpblxuICAgIHNjYW4gMCAwO1xuICAgIEJ1ZmZlci5jb250ZW50cyBidWZcblxuICBsZXQgaW50X29mX2hleF9jaGFyIGMgPVxuICAgIGxldCBjID0gaW50X29mX2NoYXIgKENoYXIudXBwZXJjYXNlX2FzY2lpIGMpIC0gNDggaW5cbiAgICBpZiBjID4gOVxuICAgIHRoZW4gaWYgYyA+IDE2ICYmIGMgPCAyM1xuICAgICAgdGhlbiBjIC0gN1xuICAgICAgZWxzZSBmYWlsd2l0aCBcImludF9vZl9oZXhfY2hhclwiXG4gICAgZWxzZSBpZiBjID49IDBcbiAgICB0aGVuIGNcbiAgICBlbHNlIGZhaWx3aXRoIFwiaW50X29mX2hleF9jaGFyXCJcblxuICAoKiogU2NhbiBmb3IgcGVyY2VudC1lbmNvZGluZyBhbmQgY29udmVydCB0aGVtIGludG8gQVNDSUkuXG4gICAgICBAcmV0dXJuIGEgcGVyY2VudC1kZWNvZGVkIHN0cmluZyAqKVxuICBsZXQgZGVjb2RlIGIgPVxuICAgICgqIFRPRE86IFNob3VsZCBib3RoIHN0cmljdCBhbmQgbm9uLXN0cmljdCB2ZXJzaW9ucyBiZSBleHBvc2VkPyAqKVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIGIgaW5cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIHNjYW4gc3RhcnQgY3VyID1cbiAgICAgIGlmIGN1ciA+PSBsZW4gdGhlbiBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgYiBzdGFydCAoY3VyLXN0YXJ0KVxuICAgICAgZWxzZSBpZiBiLltjdXJdID0gJyUnIHRoZW4gYmVnaW5cbiAgICAgICAgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIGIgc3RhcnQgKGN1ci1zdGFydCk7XG4gICAgICAgIGxldCBjdXIgPSBjdXIgKyAxIGluXG4gICAgICAgIGlmIGN1ciA+PSBsZW4gdGhlbiBCdWZmZXIuYWRkX2NoYXIgYnVmICclJ1xuICAgICAgICBlbHNlIG1hdGNoIGludF9vZl9oZXhfY2hhciBiLltjdXJdIHdpdGhcbiAgICAgICAgfCBleGNlcHRpb24gXyAtPlxuICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJyUnO1xuICAgICAgICAgIHNjYW4gY3VyIGN1clxuICAgICAgICB8IGhpZ2hiaXRzIC0+IGJlZ2luXG4gICAgICAgICAgbGV0IGN1ciA9IGN1ciArIDEgaW5cbiAgICAgICAgICBpZiBjdXIgPj0gbGVuIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJyUnO1xuICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiBiLltjdXItMV1cbiAgICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgICAgbGV0IHN0YXJ0X2F0ID1cbiAgICAgICAgICAgICAgbWF0Y2ggaW50X29mX2hleF9jaGFyIGIuW2N1cl0gd2l0aFxuICAgICAgICAgICAgICB8IGxvd2JpdHMgLT5cbiAgICAgICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmIChDaGFyLmNociAoaGlnaGJpdHMgbHNsIDQgKyBsb3diaXRzKSk7XG4gICAgICAgICAgICAgICAgY3VyKzFcbiAgICAgICAgICAgICAgfCBleGNlcHRpb24gXyAtPlxuICAgICAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJyUnO1xuICAgICAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgYi5bY3VyLTFdO1xuICAgICAgICAgICAgICAgIGN1clxuICAgICAgICAgICAgaW4gc2NhbiBzdGFydF9hdCBzdGFydF9hdFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIHNjYW4gc3RhcnQgKGN1cisxKVxuICAgIGluXG4gICAgc2NhbiAwIDA7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuZW5kXG5cbigqIFBlcmNlbnQgZW5jb2RlIGEgc3RyaW5nICopXG5sZXQgcGN0X2VuY29kZSA/c2NoZW1lID8oY29tcG9uZW50PWBQYXRoKSBzID1cbiAgUGN0Lih1bmNhc3RfZW5jb2RlZCAoZW5jb2RlID9zY2hlbWUgfmNvbXBvbmVudCAoY2FzdF9kZWNvZGVkIHMpKSlcblxubGV0IHBjdF9lbmNvZGVyXG4gICAgICA/KHNjaGVtZT1gU2NoZW1lKVxuICAgICAgPyh1c2VyaW5mbz1gVXNlcmluZm8pXG4gICAgICA/KGhvc3Q9YEhvc3QpXG4gICAgICA/KHBhdGg9YFBhdGgpXG4gICAgICA/KHF1ZXJ5X2tleT1gUXVlcnlfa2V5KVxuICAgICAgPyhxdWVyeV92YWx1ZT1gUXVlcnlfdmFsdWUpXG4gICAgICA/KGZyYWdtZW50PWBGcmFnbWVudClcbiAgICAgICgpID1cbiAgeyBzY2hlbWU7IHVzZXJpbmZvOyBob3N0OyBwYXRoOyBxdWVyeV9rZXk7IHF1ZXJ5X3ZhbHVlOyBmcmFnbWVudCB9XG5cbigqIFBlcmNlbnQgZGVjb2RlIGEgc3RyaW5nICopXG5sZXQgcGN0X2RlY29kZSBzID0gUGN0Lih1bmNhc3RfZGVjb2RlZCAoZGVjb2RlIChjYXN0X2VuY29kZWQgcykpKVxuXG4oKiBVc2VyaW5mbyBzdHJpbmcgaGFuZGxpbmcsIHRvIGFuZCBmcm9tIGFuIGlkICogY3JlZGVudGlhbCBwYWlyICopXG5tb2R1bGUgVXNlcmluZm8gPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gc3RyaW5nICogc3RyaW5nIG9wdGlvblxuXG4gIGxldCBjb21wYXJlICh1LHApICh1JyxwJykgPVxuICAgIG1hdGNoIFN0cmluZy5jb21wYXJlIHUgdScgd2l0aFxuICAgIHwgMCAtPiBjb21wYXJlX29wdCBTdHJpbmcuY29tcGFyZSBwIHAnXG4gICAgfCBjIC0+IGNcblxuICBsZXQgdXNlcmluZm9fb2ZfZW5jb2RlZCB1cyA9XG4gICAgbWF0Y2ggU3RyaW5nZXh0LnNwbGl0IH5tYXg6MiB+b246JzonIHVzIHdpdGhcbiAgICB8IFtdIC0+IChcIlwiLE5vbmUpXG4gICAgfCBbdV0gLT4gKHBjdF9kZWNvZGUgdSxOb25lKVxuICAgIHwgdTo6cDo6XyAtPiAocGN0X2RlY29kZSB1LFNvbWUgKHBjdF9kZWNvZGUgcCkpXG5cbiAgbGV0IGVuY29kZWRfb2ZfdXNlcmluZm8gP3NjaGVtZSB+Y29tcG9uZW50ICh1LHBvKSA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy4oXG4gICAgICAxICsgKGxlbmd0aCB1KSArIChtYXRjaCBwbyB3aXRoIE5vbmUgLT4gMCB8IFNvbWUgcCAtPiBsZW5ndGggcCkpXG4gICAgaW5cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBsZW4gaW5cbiAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKHBjdF9lbmNvZGUgP3NjaGVtZSB+Y29tcG9uZW50IHUpO1xuICAgIGJlZ2luIG1hdGNoIHBvIHdpdGggTm9uZSAtPiAoKTtcbiAgICB8IFNvbWUgcCAtPlxuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnOic7XG4gICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKHBjdF9lbmNvZGUgP3NjaGVtZSB+Y29tcG9uZW50IHApXG4gICAgZW5kO1xuICAgIFBjdC5jYXN0X2VuY29kZWQgKEJ1ZmZlci5jb250ZW50cyBidWYpXG5lbmRcblxubGV0IHVzZXJpbmZvX29mX2VuY29kZWQgPSBVc2VyaW5mby51c2VyaW5mb19vZl9lbmNvZGVkXG5sZXQgZW5jb2RlZF9vZl91c2VyaW5mbyA/c2NoZW1lIH5jb21wb25lbnQgPSBVc2VyaW5mby5lbmNvZGVkX29mX3VzZXJpbmZvID9zY2hlbWUgfmNvbXBvbmVudFxuXG4oKiBQYXRoIHN0cmluZyBoYW5kbGluZywgdG8gYW5kIGZyb20gYSBsaXN0IG9mIHBhdGggdG9rZW5zICopXG5tb2R1bGUgUGF0aCA9IHN0cnVjdFxuICAoKiBJbnZhcmlhbnQ6IGV2ZXJ5IGVsZW1lbnQgaXMgbm9uLXplcm8sIHNsYXNoZXMgKC8pIG9ubHkgb2NjdXIgYWxvbmUuICopXG4gICgqIFllcywgaXQncyBiZXR0ZXIgdGhpcyB3YXkuIFRoaXMgbWVhbnMgeW91IGNhbiByZXRhaW4gc2VwYXJhdG9yXG4gICAgIGNvbnRleHQgaW4gcmVjdXJzaW9uIChlLmcuIHJlbW92ZV9kb3Rfc2VnbWVudHMgZm9yIHJlbGF0aXZlIHJlc29sdXRpb24pLiAqKVxuXG4gIHR5cGUgdCA9IHN0cmluZyBsaXN0XG5cbiAgbGV0IGNvbXBhcmUgPSBjb21wYXJlX2xpc3QgU3RyaW5nLmNvbXBhcmVcblxuICAoKiBNYWtlIGEgcGF0aCB0b2tlbiBsaXN0IGZyb20gYSBwZXJjZW50LWVuY29kZWQgc3RyaW5nICopXG4gIGxldCBwYXRoX29mX2VuY29kZWQgcHMgPVxuICAgIGxldCB0b2tsID0gU3RyaW5nZXh0LmZ1bGxfc3BsaXQgcHMgfm9uOicvJyBpblxuICAgIExpc3QubWFwIHBjdF9kZWNvZGUgdG9rbFxuXG4gICgqIFN1YnJvdXRpbmUgZm9yIHJlc29sdmUgPGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi01LjIuND4gKilcbiAgbGV0IHJlbW92ZV9kb3Rfc2VnbWVudHMgcCA9XG4gICAgbGV0IHJldnAgPSBMaXN0LnJldiBwIGluXG4gICAgbGV0IHJlYyBsb29wIGFzY2Vuc2lvbiBvdXRwID0gZnVuY3Rpb25cbiAgICAgIHwgXCIvXCI6OlwiLi5cIjo6ciB8IFwiLi5cIjo6ciAtPiBsb29wIChhc2NlbnNpb24gKyAxKSBvdXRwIHJcbiAgICAgIHwgXCIvXCI6OlwiLlwiOjpyICB8IFwiLlwiOjpyICAtPiBsb29wIGFzY2Vuc2lvbiBvdXRwIHJcbiAgICAgIHwgXCIvXCI6OltdIHwgW10gd2hlbiBMaXN0LihsZW5ndGggcCA+IDAgJiYgaGQgcCA9IFwiL1wiKSAtPiBcIi9cIjo6b3V0cFxuICAgICAgfCBbXSB3aGVuIGFzY2Vuc2lvbiA+IDAgLT4gTGlzdC5yZXZfYXBwZW5kXG4gICAgICAgIChcIi9cIjo6KHJldl9pbnRlcmplY3QgXCIvXCIgQXJyYXkuKHRvX2xpc3QgKG1ha2UgYXNjZW5zaW9uIFwiLi5cIikpKSkgb3V0cFxuICAgICAgfCBbXSAtPiBMaXN0LihpZiBsZW5ndGggb3V0cCA+IDAgJiYgaGQgb3V0cCA9IFwiL1wiIHRoZW4gdGwgb3V0cCBlbHNlIG91dHApXG4gICAgICB8IFwiL1wiOjpcIi9cIjo6ciB3aGVuIGFzY2Vuc2lvbiA+IDAgLT4gbG9vcCAoYXNjZW5zaW9uIC0gMSkgb3V0cCAoXCIvXCI6OnIpXG4gICAgICB8IFwiL1wiOjpfOjpyIHdoZW4gYXNjZW5zaW9uID4gMCAtPiBsb29wIChhc2NlbnNpb24gLSAxKSBvdXRwIHJcbiAgICAgIHwgczo6ciAtPiBsb29wIDAgKHM6Om91dHApIHJcbiAgICBpbiBsb29wIDAgW10gcmV2cFxuXG4gIGxldCBlbmNvZGVkX29mX3BhdGggP3NjaGVtZSB+Y29tcG9uZW50IHAgPVxuICAgIGxldCBsZW4gPSBMaXN0LmZvbGRfbGVmdCAoZnVuIGMgdG9rIC0+IFN0cmluZy5sZW5ndGggdG9rICsgYykgMCBwIGluXG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgbGVuIGluXG4gICAgaXRlcl9jb25jYXQgKGZ1biBidWYgLT4gZnVuY3Rpb25cbiAgICB8IFwiL1wiIC0+IEJ1ZmZlci5hZGRfY2hhciBidWYgJy8nXG4gICAgfCBzZWcgLT4gQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChwY3RfZW5jb2RlID9zY2hlbWUgfmNvbXBvbmVudCBzZWcpXG4gICAgKSBcIlwiIGJ1ZiBwO1xuICAgIFBjdC5jYXN0X2VuY29kZWQgKEJ1ZmZlci5jb250ZW50cyBidWYpXG5cbiAgKCogU3Vicm91dGluZSBmb3IgcmVzb2x2ZSA8aHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMi4zPiAqKVxuICBsZXQgbWVyZ2UgYmhvc3QgYnBhdGggcmVscGF0aCA9XG4gICAgbWF0Y2ggYmhvc3QsIExpc3QucmV2IGJwYXRoIHdpdGhcbiAgICB8IFNvbWUgXywgW10gLT4gXCIvXCI6OnJlbHBhdGhcbiAgICB8IF8sIChcIi9cIjo6cmJwYXRoIHwgXzo6XCIvXCI6OnJicGF0aCkgLT4gTGlzdC5yZXZfYXBwZW5kIChcIi9cIjo6cmJwYXRoKSByZWxwYXRoXG4gICAgfCBfLCBfIC0+IHJlbHBhdGhcbmVuZFxuXG5sZXQgcGF0aF9vZl9lbmNvZGVkID0gUGF0aC5wYXRoX29mX2VuY29kZWRcbmxldCBlbmNvZGVkX29mX3BhdGggP3NjaGVtZSB+Y29tcG9uZW50ID0gUGF0aC5lbmNvZGVkX29mX3BhdGggP3NjaGVtZSB+Y29tcG9uZW50XG5cbigqIFF1ZXJ5IHN0cmluZyBoYW5kbGluZywgdG8gYW5kIGZyb20gYW4gYXNzb2MgbGlzdCBvZiBrZXkvdmFsdWVzICopXG5tb2R1bGUgUXVlcnkgPSBzdHJ1Y3RcblxuICB0eXBlIGt2ID0gKHN0cmluZyAqIHN0cmluZyBsaXN0KSBsaXN0XG5cbiAgdHlwZSB0ID1cbiAgICB8IEtWIG9mIGt2XG4gICAgfCBSYXcgb2Ygc3RyaW5nIG9wdGlvbiAqIGt2IExhenkudFxuXG4gIGxldCBjb21wYXJlIHggeSA9IG1hdGNoIHgsIHkgd2l0aFxuICAgIHwgS1Yga3ZsLCBLViBrdmwnXG4gICAgfCBSYXcgKF8sIGxhenkga3ZsKSwgS1Yga3ZsJ1xuICAgIHwgS1Yga3ZsLCBSYXcgKF8sIGxhenkga3ZsJykgLT5cbiAgICAgIGNvbXBhcmVfbGlzdCAoZnVuIChrLHZsKSAoaycsdmwnKSAtPlxuICAgICAgICBtYXRjaCBTdHJpbmcuY29tcGFyZSBrIGsnIHdpdGhcbiAgICAgICAgfCAwIC0+IGNvbXBhcmVfbGlzdCBTdHJpbmcuY29tcGFyZSB2bCB2bCdcbiAgICAgICAgfCBjIC0+IGNcbiAgICAgICkga3ZsIGt2bCdcbiAgICB8IFJhdyAocmF3LF8pLCBSYXcgKHJhdycsXykgLT4gY29tcGFyZV9vcHQgU3RyaW5nLmNvbXBhcmUgcmF3IHJhdydcblxuICBsZXQgZmluZCBxIGsgPSB0cnkgU29tZSAoTGlzdC5hc3NvYyBrIHEpIHdpdGggTm90X2ZvdW5kIC0+IE5vbmVcblxuICBsZXQgc3BsaXRfcXVlcnkgcXMgPVxuICAgIGxldCBlbHMgPSBTdHJpbmdleHQuc3BsaXQgfm9uOicmJyBxcyBpblxuICAgICgqIFJlcGxhY2UgYSArIGluIGEgcXVlcnkgc3RyaW5nIHdpdGggYSBzcGFjZSBpbi1wbGFjZSAqKVxuICAgIGxldCBwbHVzX3RvX3NwYWNlIHMgPVxuICAgICAgbGV0IHMgPSBCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIHMgaW5cbiAgICAgIGZvciBpID0gMCB0byBCeXRlcy5sZW5ndGggcyAtIDEgZG9cbiAgICAgICAgaWYgQnl0ZXMuZ2V0IHMgaSA9ICcrJyB0aGVuIEJ5dGVzLnNldCBzIGkgJyAnXG4gICAgICBkb25lO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzXG4gICAgaW5cbiAgICBsZXQgcmVjIGxvb3AgYWNjID0gZnVuY3Rpb25cbiAgICAgIHwgKGs6OnY6Ol8pOjp0bCAtPlxuICAgICAgICBsZXQgbiA9IHBsdXNfdG9fc3BhY2UgayxcbiAgICAgICAgICAgICAgICAobWF0Y2ggU3RyaW5nZXh0LnNwbGl0IH5vbjonLCcgKHBsdXNfdG9fc3BhY2Ugdikgd2l0aFxuICAgICAgICAgICAgICAgICB8IFtdIC0+IFtcIlwiXSB8IGwgLT4gbCkgaW5cbiAgICAgICAgbG9vcCAobjo6YWNjKSB0bFxuICAgICAgfCBba106OnRsIC0+XG4gICAgICAgIGxldCBuID0gcGx1c190b19zcGFjZSBrLCBbXSBpblxuICAgICAgICBsb29wIChuOjphY2MpIHRsXG4gICAgICB8IFtdOjp0bCAtPiBsb29wICgoXCJcIiwgW10pOjphY2MpIHRsXG4gICAgICB8IFtdIC0+IGFjY1xuICAgIGluXG4gICAgbWF0Y2ggZWxzIHdpdGhcbiAgICB8IFtdICAtPiBbXCJcIixbXV1cbiAgICB8IGVscyAtPiBsb29wIFtdXG4gICAgICAoTGlzdC5yZXZfbWFwIChmdW4gZWwgLT4gU3RyaW5nZXh0LnNwbGl0IH5vbjonPScgZWwgfm1heDoyKSBlbHMpXG5cbiAgKCogTWFrZSBhIHF1ZXJ5IHR1cGxlIGxpc3QgZnJvbSBhIHBlcmNlbnQtZW5jb2RlZCBzdHJpbmcgKilcbiAgbGV0IHF1ZXJ5X29mX2VuY29kZWQgcXMgPVxuICAgIExpc3QubWFwXG4gICAgICAoZnVuIChrLCB2KSAtPiAocGN0X2RlY29kZSBrLCBMaXN0Lm1hcCBwY3RfZGVjb2RlIHYpKVxuICAgICAgKHNwbGl0X3F1ZXJ5IHFzKVxuXG4gICgqIEFzc2VtYmxlIGEgcXVlcnkgc3RyaW5nIHN1aXRhYmxlIGZvciBwdXR0aW5nIGludG8gYSBVUkkuXG4gICAqIFR1cGxlIGlucHV0cyBhcmUgcGVyY2VudCBkZWNvZGVkIGFuZCB3aWxsIGJlIGVuY29kZWQgYnlcbiAgICogdGhpcyBmdW5jdGlvbi5cbiAgKilcbiAgbGV0IGVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZSA/KHBjdF9lbmNvZGVyPXBjdF9lbmNvZGVyICgpKSBsID1cbiAgICBsZXQgbGVuID0gTGlzdC5mb2xkX2xlZnQgKGZ1biBhIChrLHYpIC0+XG4gICAgICAgIGEgKyAoU3RyaW5nLmxlbmd0aCBrKVxuICAgICAgICArIChMaXN0LmZvbGRfbGVmdCAoZnVuIGEgcyAtPiBhKyhTdHJpbmcubGVuZ3RoIHMpKzEpIDAgdikgKyAyKSAoLTEpIGwgaW5cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSBsZW4gaW5cbiAgICBpdGVyX2NvbmNhdCAoZnVuIGJ1ZiAoayx2KSAtPlxuICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKHBjdF9lbmNvZGUgP3NjaGVtZSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnF1ZXJ5X2tleSBrKTtcbiAgICAgICAgaWYgdiA8PiBbXSB0aGVuIChcbiAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICc9JztcbiAgICAgICAgICBpdGVyX2NvbmNhdCAoZnVuIGJ1ZiBzIC0+XG4gICAgICAgICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZlxuICAgICAgICAgICAgICAgIChwY3RfZW5jb2RlID9zY2hlbWUgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5xdWVyeV92YWx1ZSBzKVxuICAgICAgICAgICAgKSBcIixcIiBidWYgdilcbiAgICAgICkgXCImXCIgYnVmIGw7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuXG4gIGxldCBvZl9yYXcgcXMgPVxuICAgIGxldCBsYXp5X3F1ZXJ5ID0gTGF6eS5mcm9tX2Z1biAoZnVuICgpIC0+IHF1ZXJ5X29mX2VuY29kZWQgcXMpIGluXG4gICAgUmF3IChTb21lIHFzLCBsYXp5X3F1ZXJ5KVxuXG4gIGxldCBrdiA9IGZ1bmN0aW9uIFJhdyAoXywgbGF6eSBrdikgfCBLViBrdiAtPiBrdlxuZW5kXG5cbmxldCBxdWVyeV9vZl9lbmNvZGVkID0gUXVlcnkucXVlcnlfb2ZfZW5jb2RlZFxubGV0IGVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZSA9IFF1ZXJ5LmVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZVxuXG4oKiBUeXBlIG9mIHRoZSBVUkksIHdpdGggbW9zdCBiaXRzIGJlaW5nIG9wdGlvbmFsICopXG50eXBlIHQgPSB7XG4gIHNjaGVtZTogUGN0LmRlY29kZWQgb3B0aW9uO1xuICB1c2VyaW5mbzogVXNlcmluZm8udCBvcHRpb247XG4gIGhvc3Q6IFsgYElwdjRfbGl0ZXJhbCBvZiBzdHJpbmdcbiAgICAgICAgfCBgSXB2Nl9saXRlcmFsIG9mIHN0cmluZ1xuICAgICAgICB8IGBIb3N0IG9mIFBjdC5kZWNvZGVkXSBvcHRpb24gO1xuICBwb3J0OiBpbnQgb3B0aW9uO1xuICBwYXRoOiBQYXRoLnQ7XG4gIHF1ZXJ5OiBRdWVyeS50O1xuICBmcmFnbWVudDogUGN0LmRlY29kZWQgb3B0aW9uO1xufVxuXG5sZXQgZW1wdHkgPSB7XG4gIHNjaGVtZSA9IE5vbmU7XG4gIHVzZXJpbmZvID0gTm9uZTtcbiAgaG9zdCA9IE5vbmU7XG4gIHBvcnQgPSBOb25lO1xuICBwYXRoID0gW107XG4gIHF1ZXJ5ID0gUXVlcnkuUmF3IChOb25lLCBMYXp5LmZyb21fdmFsIFtdKTtcbiAgZnJhZ21lbnQgPSBOb25lO1xufVxuXG5sZXQgY29tcGFyZV9kZWNvZGVkID0gUGN0LnVubGlmdF9kZWNvZGVkMiBTdHJpbmcuY29tcGFyZVxubGV0IGNvbXBhcmVfZGVjb2RlZF9vcHQgPSBjb21wYXJlX29wdCBjb21wYXJlX2RlY29kZWRcbmxldCBjb21wYXJlX2hvc3QgaDEgaDIgPVxuICBtYXRjaCBoMSwgaDIgd2l0aFxuICB8IGBJcHY0X2xpdGVyYWwgaXAxLCBgSXB2NF9saXRlcmFsIGlwMiAtPiBTdHJpbmcuY29tcGFyZSBpcDEgaXAyXG4gIHwgYElwdjZfbGl0ZXJhbCBpcDEsIGBJcHY2X2xpdGVyYWwgaXAyIC0+IFN0cmluZy5jb21wYXJlIGlwMSBpcDJcbiAgfCBgSG9zdCBoMSwgYEhvc3QgaDIgLT4gY29tcGFyZV9kZWNvZGVkIGgxIGgyXG4gIHwgXyAtPiAtMVxubGV0IGNvbXBhcmVfaG9zdF9vcHQgPSBjb21wYXJlX29wdCBjb21wYXJlX2hvc3RcblxubGV0IGNvbXBhcmUgdCB0JyA9XG4gIChtYXRjaCBjb21wYXJlX2hvc3Rfb3B0IHQuaG9zdCB0Jy5ob3N0IHdpdGhcbiAgfCAwIC0+IChtYXRjaCBjb21wYXJlX2RlY29kZWRfb3B0IHQuc2NoZW1lIHQnLnNjaGVtZSB3aXRoXG4gICAgfCAwIC0+IChtYXRjaCBjb21wYXJlX29wdCAoZnVuIHAgcCcgLT5cbiAgICAgIGlmIHAgPCBwJyB0aGVuIC0xIGVsc2UgaWYgcCA+IHAnIHRoZW4gMSBlbHNlIDBcbiAgICApIHQucG9ydCB0Jy5wb3J0IHdpdGhcbiAgICAgIHwgMCAtPiAobWF0Y2ggY29tcGFyZV9vcHQgVXNlcmluZm8uY29tcGFyZSB0LnVzZXJpbmZvIHQnLnVzZXJpbmZvIHdpdGhcbiAgICAgICAgfCAwIC0+IChtYXRjaCBQYXRoLmNvbXBhcmUgdC5wYXRoIHQnLnBhdGggd2l0aFxuICAgICAgICAgIHwgMCAtPiAobWF0Y2ggUXVlcnkuY29tcGFyZSB0LnF1ZXJ5IHQnLnF1ZXJ5IHdpdGhcbiAgICAgICAgICAgIHwgMCAtPiBjb21wYXJlX2RlY29kZWRfb3B0IHQuZnJhZ21lbnQgdCcuZnJhZ21lbnRcbiAgICAgICAgICAgIHwgYyAtPiBjKVxuICAgICAgICAgIHwgYyAtPiBjKVxuICAgICAgICB8IGMgLT4gYylcbiAgICAgIHwgYyAtPiBjKVxuICAgIHwgYyAtPiBjKVxuICB8IGMgLT4gYylcblxubGV0IGVxdWFsIHQgdCcgPSBjb21wYXJlIHQgdCcgPSAwXG5cbmxldCB1bmNhc3Rfb3B0ID0gZnVuY3Rpb25cbiAgfCBTb21lIGggLT4gU29tZSAoUGN0LnVuY2FzdF9kZWNvZGVkIGgpXG4gIHwgTm9uZSAtPiBOb25lXG5cbmxldCBub3JtYWxpemUgc2NoZW0gdXJpID1cbiAgbGV0IG1vZHVsZSBTY2hlbWUgPVxuICAgICh2YWwgKG1vZHVsZV9vZl9zY2hlbWUgKHVuY2FzdF9vcHQgc2NoZW0pKSA6IFNjaGVtZSkgaW5cbiAgbGV0IGRvYiBmID0gZnVuY3Rpb25cbiAgICB8IFNvbWUgeCAtPiBTb21lIChQY3QudW5saWZ0X2RlY29kZWQgZiB4KVxuICAgIHwgTm9uZSAtPiBOb25lXG4gIGluIHt1cmkgd2l0aFxuICAgICAgc2NoZW1lPWRvYiBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHVyaS5zY2hlbWU7XG4gICAgICBob3N0PSBtYXRjaCB1cmkuaG9zdCB3aXRoXG4gICAgICAgfCBTb21lIChgSXB2NF9saXRlcmFsIGhvc3QpIC0+XG4gICAgICAgICBTb21lIChgSXB2NF9saXRlcmFsIChTY2hlbWUubm9ybWFsaXplX2hvc3QgaG9zdCkpXG4gICAgICAgfCBTb21lIChgSXB2Nl9saXRlcmFsIGhvc3QpIC0+XG4gICAgICAgICBTb21lIChgSXB2Nl9saXRlcmFsIChTY2hlbWUubm9ybWFsaXplX2hvc3QgaG9zdCkpXG4gICAgICAgfCBTb21lIChgSG9zdCBob3N0KSAtPlxuICAgICAgICAgU29tZSAoYEhvc3QgKFBjdC5jYXN0X2RlY29kZWQgKFNjaGVtZS5ub3JtYWxpemVfaG9zdCAoUGN0LnVuY2FzdF9kZWNvZGVkIGhvc3QpKSkpXG4gICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgfVxuXG4oKiogQ29udmVydCBhIFVSSSBzdHJ1Y3R1cmUgaW50byBhIHBlcmNlbnQtZW5jb2RlZCBzdHJpbmdcbiAgICA8aHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMz5cbiopXG5sZXQgdG9fc3RyaW5nID8ocGN0X2VuY29kZXI9cGN0X2VuY29kZXIgKCkpIHVyaSA9XG4gIGxldCBzY2hlbWUgPSBtYXRjaCB1cmkuc2NoZW1lIHdpdGhcbiAgICB8IFNvbWUgcyAtPiBTb21lIChQY3QudW5jYXN0X2RlY29kZWQgcylcbiAgICB8IE5vbmUgLT4gTm9uZSBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAxMjggaW5cbiAgKCogUGVyY2VudCBlbmNvZGUgYSBkZWNvZGVkIHN0cmluZyBhbmQgYWRkIGl0IHRvIHRoZSBidWZmZXIgKilcbiAgbGV0IGFkZF9wY3Rfc3RyaW5nID8oY29tcG9uZW50PWBQYXRoKSB4ID1cbiAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKFBjdC51bmNhc3RfZW5jb2RlZCAoUGN0LmVuY29kZSA/c2NoZW1lIH5jb21wb25lbnQgeCkpXG4gIGluXG4gIChtYXRjaCB1cmkuc2NoZW1lIHdpdGhcbiAgIHxOb25lIC0+ICgpXG4gICB8U29tZSB4IC0+XG4gICAgIGFkZF9wY3Rfc3RyaW5nIH5jb21wb25lbnQ6cGN0X2VuY29kZXIuc2NoZW1lIHg7XG4gICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJzonXG4gICk7XG4gICgqIFVSSSBoYXMgYSBob3N0IGlmIGFueSBob3N0LXJlbGF0ZWQgY29tcG9uZW50IGlzIHNldC4gRGVmYXVsdHMgdG8gXCJcIi4gKilcbiAgaWYgKG1hdGNoIHVyaS51c2VyaW5mbywgdXJpLmhvc3QsIHVyaS5wb3J0IHdpdGhcbiAgfCBTb21lIF8sIF8sIF8gfCBfLCBTb21lIF8sIF8gfCBfLCBfLCBTb21lIF8gLT4gdHJ1ZSB8IF8gLT4gZmFsc2UpXG4gIHRoZW4gQnVmZmVyLmFkZF9zdHJpbmcgYnVmIFwiLy9cIjtcbiAgKG1hdGNoIHVyaS51c2VyaW5mbyB3aXRoXG4gIHxOb25lIC0+ICgpXG4gIHxTb21lIHVzZXJpbmZvIC0+XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmXG4gICAgICAoUGN0LnVuY2FzdF9lbmNvZGVkIChlbmNvZGVkX29mX3VzZXJpbmZvID9zY2hlbWUgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci51c2VyaW5mbyB1c2VyaW5mbykpO1xuICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJ0AnXG4gICk7XG4gIChtYXRjaCB1cmkuaG9zdCB3aXRoXG4gIHxOb25lIC0+ICgpXG4gIHxTb21lIChgSG9zdCBob3N0KSAtPlxuICAgIGFkZF9wY3Rfc3RyaW5nIH5jb21wb25lbnQ6cGN0X2VuY29kZXIuaG9zdCBob3N0O1xuICB8U29tZSAoYElwdjRfbGl0ZXJhbCBob3N0KSAtPiBCdWZmZXIuYWRkX3N0cmluZyBidWYgaG9zdFxuICB8U29tZSAoYElwdjZfbGl0ZXJhbCBob3N0KSAtPlxuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnWyc7XG4gICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgaG9zdDtcbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJ10nXG4gICk7XG4gIChtYXRjaCB1cmkucG9ydCB3aXRoXG4gIHxOb25lIC0+ICgpXG4gIHxTb21lIHBvcnQgLT5cbiAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICc6JztcbiAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKHN0cmluZ19vZl9pbnQgcG9ydClcbiAgKTtcbiAgKG1hdGNoIHVyaS5wYXRoIHdpdGggKCogSGFuZGxlIHJlbGF0aXZlIHBhdGhzIGNvcnJlY3RseSAqKVxuICB8IFtdIC0+ICgpXG4gIHwgXCIvXCI6Ol8gLT5cbiAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgKFBjdC51bmNhc3RfZW5jb2RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVuY29kZWRfb2ZfcGF0aCA/c2NoZW1lIH5jb21wb25lbnQ6cGN0X2VuY29kZXIucGF0aCB1cmkucGF0aCkpXG4gIHwgZmlyc3Rfc2VnbWVudDo6XyAtPlxuICAgIChtYXRjaCB1cmkuaG9zdCB3aXRoXG4gICAgIHwgU29tZSBfIC0+IEJ1ZmZlci5hZGRfY2hhciBidWYgJy8nXG4gICAgIHwgTm9uZSAtPlxuICAgICAgICgqIGVuc3VyZSByb3VuZHRyaXAgYnkgZm9yY2luZyByZWxhdGl2ZSBwYXRoIGludGVycHJldGF0aW9uIG5vdCBzY2hlbWUgKilcbiAgICAgICBtYXRjaCBTdHJpbmdleHQuZmluZF9mcm9tIGZpcnN0X3NlZ21lbnQgfnBhdHRlcm46XCI6XCIgd2l0aFxuICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgIHwgU29tZSBfIC0+IG1hdGNoIHNjaGVtZSB3aXRoXG4gICAgICAgICB8IFNvbWUgXyAtPiAoKVxuICAgICAgICAgfCBOb25lIC0+IEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBcIi4vXCJcbiAgICApO1xuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZlxuICAgICAgKFBjdC51bmNhc3RfZW5jb2RlZCAoZW5jb2RlZF9vZl9wYXRoID9zY2hlbWUgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5wYXRoIHVyaS5wYXRoKSlcbiAgKTtcbiAgUXVlcnkuKG1hdGNoIHVyaS5xdWVyeSB3aXRoXG4gICAgfCBSYXcgKE5vbmUsXykgfCBLViBbXSAtPiAoKVxuICAgIHwgUmF3IChfLGxhenkgcSkgfCBLViBxIC0+ICgqIG5vcm1hbGl6ZSBlLmcuIHBlcmNlbnQgY2FwaXRhbGl6YXRpb24gKilcbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJz8nO1xuICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChlbmNvZGVkX29mX3F1ZXJ5ID9zY2hlbWUgfnBjdF9lbmNvZGVyIHEpXG4gICk7XG4gIChtYXRjaCB1cmkuZnJhZ21lbnQgd2l0aFxuICAgfE5vbmUgLT4gKClcbiAgIHxTb21lIGYgLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnIyc7IGFkZF9wY3Rfc3RyaW5nIH5jb21wb25lbnQ6cGN0X2VuY29kZXIuZnJhZ21lbnQgZlxuICApO1xuICBCdWZmZXIuY29udGVudHMgYnVmXG5cbigqIFZhcmlvdXMgYWNjZXNzb3IgZnVuY3Rpb25zLCBhcyB0aGUgZXh0ZXJuYWwgdXJpIHR5cGUgaXMgYWJzdHJhY3QgICopXG5sZXQgZ2V0X2RlY29kZWRfb3B0ID0gZnVuY3Rpb24gTm9uZSAtPiBOb25lIHxTb21lIHggLT4gU29tZSAoUGN0LnVuY2FzdF9kZWNvZGVkIHgpXG5sZXQgc2NoZW1lIHVyaSA9IGdldF9kZWNvZGVkX29wdCB1cmkuc2NoZW1lXG5sZXQgd2l0aF9zY2hlbWUgdXJpID1cbiAgZnVuY3Rpb25cbiAgfFNvbWUgc2NoZW1lIC0+IHsgdXJpIHdpdGggc2NoZW1lPVNvbWUgKFBjdC5jYXN0X2RlY29kZWQgc2NoZW1lKSB9XG4gIHxOb25lIC0+IHsgdXJpIHdpdGggc2NoZW1lPU5vbmUgfVxuXG5sZXQgaG9zdCB1cmkgPVxuICBtYXRjaCB1cmkuaG9zdCB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSAoYElwdjRfbGl0ZXJhbCBoIHwgYElwdjZfbGl0ZXJhbCBoKSAtPiBTb21lIGhcbiAgfCBTb21lIChgSG9zdCBoKSAtPiBTb21lIChQY3QudW5jYXN0X2RlY29kZWQgaClcblxubGV0IGhvc3Rfd2l0aF9kZWZhdWx0ID8oZGVmYXVsdD1cImxvY2FsaG9zdFwiKSB1cmkgPVxuICBtYXRjaCBob3N0IHVyaSB3aXRoXG4gIHxOb25lIC0+IGRlZmF1bHRcbiAgfFNvbWUgaCAtPiBoXG5cbmxldCB1c2VyaW5mbyA/KHBjdF9lbmNvZGVyPXBjdF9lbmNvZGVyICgpKSB1cmkgPSBtYXRjaCB1cmkudXNlcmluZm8gd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgdXNlcmluZm8gLT4gU29tZSAoUGN0LnVuY2FzdF9lbmNvZGVkIChtYXRjaCB1cmkuc2NoZW1lIHdpdGhcbiAgICB8IE5vbmUgLT4gZW5jb2RlZF9vZl91c2VyaW5mbyB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnVzZXJpbmZvIHVzZXJpbmZvXG4gICAgfCBTb21lIHMgLT4gZW5jb2RlZF9vZl91c2VyaW5mbyB+c2NoZW1lOihQY3QudW5jYXN0X2RlY29kZWQgcykgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci51c2VyaW5mbyB1c2VyaW5mbykpXG5sZXQgd2l0aF91c2VyaW5mbyB1cmkgdXNlcmluZm8gPVxuICBsZXQgdXNlcmluZm8gPSBtYXRjaCB1c2VyaW5mbyB3aXRoXG4gICAgfCBTb21lIHUgLT4gU29tZSAodXNlcmluZm9fb2ZfZW5jb2RlZCB1KVxuICAgIHwgTm9uZSAtPiBOb25lXG4gIGluXG4gIG1hdGNoIGhvc3QgdXJpIHdpdGhcbiAgfCBOb25lIC0+IHsgdXJpIHdpdGggaG9zdD1Tb21lIChgSG9zdCAoUGN0LmNhc3RfZGVjb2RlZCBcIlwiKSk7IHVzZXJpbmZvPXVzZXJpbmZvIH1cbiAgfCBTb21lIF8gLT4geyB1cmkgd2l0aCB1c2VyaW5mbz11c2VyaW5mbyB9XG5cbmxldCB1c2VyIHVyaSA9IG1hdGNoIHVyaS51c2VyaW5mbyB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSAodXNlciwgXykgLT4gU29tZSB1c2VyXG5cbmxldCBwYXNzd29yZCB1cmkgPSBtYXRjaCB1cmkudXNlcmluZm8gd2l0aFxuICB8IE5vbmUgfCBTb21lIChfLCBOb25lKSAtPiBOb25lXG4gIHwgU29tZSAoXywgU29tZSBwYXNzKSAtPiBTb21lIHBhc3NcbmxldCB3aXRoX3Bhc3N3b3JkIHVyaSBwYXNzd29yZCA9XG4gIGxldCByZXN1bHQgdXNlcmluZm8gPSBtYXRjaCBob3N0IHVyaSB3aXRoXG4gICAgfCBOb25lIC0+IHsgdXJpIHdpdGggaG9zdD1Tb21lIChgSG9zdCAoUGN0LmNhc3RfZGVjb2RlZCBcIlwiKSk7IHVzZXJpbmZvPXVzZXJpbmZvIH1cbiAgICB8IFNvbWUgXyAtPiB7IHVyaSB3aXRoIHVzZXJpbmZvPXVzZXJpbmZvIH1cbiAgaW5cbiAgbWF0Y2ggdXJpLnVzZXJpbmZvLCBwYXNzd29yZCB3aXRoXG4gIHwgTm9uZSwgTm9uZSAtPiB1cmlcbiAgfCBOb25lLCBTb21lIF8gLT4gcmVzdWx0IChTb21lIChcIlwiLHBhc3N3b3JkKSlcbiAgfCBTb21lICh1c2VyLF8pLCBfIC0+IHJlc3VsdCAoU29tZSAodXNlciwgcGFzc3dvcmQpKVxuXG5sZXQgcG9ydCB1cmkgPSB1cmkucG9ydFxubGV0IHdpdGhfcG9ydCB1cmkgcG9ydCA9XG4gIG1hdGNoIGhvc3QgdXJpIHdpdGhcbiAgfCBTb21lIF8gLT4geyB1cmkgd2l0aCBwb3J0PXBvcnQgfVxuICB8IE5vbmUgLT4gYmVnaW5cbiAgICAgbWF0Y2ggcG9ydCB3aXRoXG4gICAgIHwgTm9uZSAtPiB7IHVyaSB3aXRoIGhvc3Q9Tm9uZTsgcG9ydD1Ob25lIH1cbiAgICAgfCBTb21lIF8gLT4geyB1cmkgd2l0aCBob3N0PVNvbWUgKGBIb3N0IChQY3QuY2FzdF9kZWNvZGVkIFwiXCIpKTsgcG9ydD1wb3J0IH1cbiAgZW5kXG5cbigqIFJldHVybiB0aGUgcGF0aCBjb21wb25lbnQgKilcbmxldCBwYXRoID8ocGN0X2VuY29kZXI9cGN0X2VuY29kZXIgKCkpIHVyaSA9IFBjdC51bmNhc3RfZW5jb2RlZCAobWF0Y2ggdXJpLnNjaGVtZSB3aXRoXG4gIHwgTm9uZSAtPiBlbmNvZGVkX29mX3BhdGggfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5wYXRoIHVyaS5wYXRoXG4gIHwgU29tZSBzIC0+IGVuY29kZWRfb2ZfcGF0aCB+c2NoZW1lOihQY3QudW5jYXN0X2RlY29kZWQgcykgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5wYXRoIHVyaS5wYXRoKVxubGV0IHdpdGhfcGF0aCB1cmkgcGF0aCA9XG4gIGxldCBwYXRoID0gcGF0aF9vZl9lbmNvZGVkIHBhdGggaW5cbiAgbWF0Y2ggaG9zdCB1cmksIHBhdGggd2l0aFxuICB8IE5vbmUsIF8gfCBTb21lIF8sIFwiL1wiOjpfIHwgU29tZSBfLCBbXSAtPiB7IHVyaSB3aXRoIHBhdGg9cGF0aCB9XG4gIHwgU29tZSBfLCBfICAtPiB7IHVyaSB3aXRoIHBhdGg9XCIvXCI6OnBhdGggfVxuXG5sZXQgZnJhZ21lbnQgdXJpID0gZ2V0X2RlY29kZWRfb3B0IHVyaS5mcmFnbWVudFxubGV0IHdpdGhfZnJhZ21lbnQgdXJpID1cbiAgZnVuY3Rpb25cbiAgfE5vbmUgLT4geyB1cmkgd2l0aCBmcmFnbWVudD1Ob25lIH1cbiAgfFNvbWUgZnJhZyAtPiB7IHVyaSB3aXRoIGZyYWdtZW50PVNvbWUgKFBjdC5jYXN0X2RlY29kZWQgZnJhZykgfVxuXG5sZXQgcXVlcnkgdXJpID0gUXVlcnkua3YgdXJpLnF1ZXJ5XG5sZXQgdmVyYmF0aW1fcXVlcnkgPyhwY3RfZW5jb2Rlcj1wY3RfZW5jb2RlciAoKSkgdXJpID0gUXVlcnkuKG1hdGNoIHVyaS5xdWVyeSB3aXRoXG4gIHwgUmF3IChxcyxfKSAtPiBxc1xuICB8IEtWIFtdIC0+IE5vbmVcbiAgfCBLViBrdiAtPiBTb21lIChlbmNvZGVkX29mX3F1ZXJ5ID9zY2hlbWU6KHNjaGVtZSB1cmkpIH5wY3RfZW5jb2RlciBrdilcbilcbmxldCBnZXRfcXVlcnlfcGFyYW0nIHVyaSBrID0gUXVlcnkuKGZpbmQgKGt2IHVyaS5xdWVyeSkgaylcbmxldCBnZXRfcXVlcnlfcGFyYW0gdXJpIGsgPVxuICBtYXRjaCBnZXRfcXVlcnlfcGFyYW0nIHVyaSBrIHdpdGhcbiAgfE5vbmUgLT4gTm9uZVxuICB8U29tZSB2IC0+IFNvbWUgKFN0cmluZy5jb25jYXQgXCIsXCIgdilcblxubGV0IHdpdGhfcXVlcnkgdXJpIHF1ZXJ5ID0geyB1cmkgd2l0aCBxdWVyeT1RdWVyeS5LViBxdWVyeSB9XG5sZXQgcV9zIHEgPSBMaXN0Lm1hcCAoZnVuIChrLHYpIC0+IGssW3ZdKSBxXG5sZXQgd2l0aF9xdWVyeScgdXJpIHF1ZXJ5ID0gd2l0aF9xdWVyeSB1cmkgKHFfcyBxdWVyeSlcbmxldCBhZGRfcXVlcnlfcGFyYW0gdXJpIHAgPSBRdWVyeS4oeyB1cmkgd2l0aCBxdWVyeT1LViAocDo6KGt2IHVyaS5xdWVyeSkpIH0pXG5sZXQgYWRkX3F1ZXJ5X3BhcmFtJyB1cmkgKGssdikgPVxuICBRdWVyeS4oeyB1cmkgd2l0aCBxdWVyeT1LViAoKGssW3ZdKTo6KGt2IHVyaS5xdWVyeSkpIH0pXG5sZXQgYWRkX3F1ZXJ5X3BhcmFtcyB1cmkgcHMgPSBRdWVyeS4oeyB1cmkgd2l0aCBxdWVyeT1LViAocHNAKGt2IHVyaS5xdWVyeSkpIH0pXG5sZXQgYWRkX3F1ZXJ5X3BhcmFtcycgdXJpIHBzID1cbiAgUXVlcnkuKHsgdXJpIHdpdGggcXVlcnk9S1YgKChxX3MgcHMpQChrdiB1cmkucXVlcnkpKSB9KVxubGV0IHJlbW92ZV9xdWVyeV9wYXJhbSB1cmkgayA9IFF1ZXJ5LihcbiAgeyB1cmkgd2l0aCBxdWVyeT1LViAoTGlzdC5maWx0ZXIgKGZ1biAoaycsXykgLT4gazw+aycpIChrdiB1cmkucXVlcnkpKSB9XG4pXG5cbigqIENvbnN0cnVjdCBlbmNvZGVkIHBhdGggYW5kIHF1ZXJ5IGNvbXBvbmVudHMgKilcbmxldCBwYXRoX2FuZF9xdWVyeSB1cmkgPVxuICBtYXRjaCAocGF0aCB1cmkpLCAocXVlcnkgdXJpKSB3aXRoXG4gIHxcIlwiLCBbXSAtPiBcIi9cIiAoKiBUT0RPOiBXaGF0IGFib3V0IHNhbWUgZG9jdW1lbnQ/ICgvKSAqKVxuICB8XCJcIiwgcSAtPiAoKiBUT0RPOiBXaGF0IGFib3V0IHNhbWUgZG9jdW1lbnQ/ICgvKSAqKVxuICAgIGxldCBzY2hlbWUgPSB1bmNhc3Rfb3B0IHVyaS5zY2hlbWUgaW5cbiAgICBQcmludGYuc3ByaW50ZiBcIi8/JXNcIiAoZW5jb2RlZF9vZl9xdWVyeSA/c2NoZW1lIHEpXG4gIHxwLCBbXSAtPiBwXG4gIHxwLCBxIC0+XG4gICAgbGV0IHNjaGVtZSA9IHVuY2FzdF9vcHQgdXJpLnNjaGVtZSBpblxuICAgIFByaW50Zi5zcHJpbnRmIFwiJXM/JXNcIiBwIChlbmNvZGVkX29mX3F1ZXJ5ID9zY2hlbWUgcSlcblxuKCogVE9ETzogZnVuY3Rpb25zIHRvIGFkZCBhbmQgcmVtb3ZlIGZyb20gYSBVUkkgKilcblxuKCogUmVzb2x2ZSBhIFVSSSB3cnQgYSBiYXNlIFVSSSA8aHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMj4gKilcbmxldCByZXNvbHZlIHNjaGVtIGJhc2UgdXJpID1cbiAgbGV0IHNjaGVtID0gU29tZSAoUGN0LmNhc3RfZGVjb2RlZCAobWF0Y2ggc2NoZW1lIGJhc2Ugd2l0aFxuICAgICAgfCBOb25lIC0+ICBzY2hlbVxuICAgICAgfCBTb21lIHNjaGVtZSAtPiBzY2hlbWVcbiAgICApKSBpblxuICBub3JtYWxpemUgc2NoZW1cbiAgICBQYXRoLihtYXRjaCBzY2hlbWUgdXJpLCB1c2VyaW5mbyB1cmksIGhvc3QgdXJpIHdpdGhcbiAgICB8IFNvbWUgXywgXywgXyAtPlxuICAgICAge3VyaSB3aXRoIHBhdGg9cmVtb3ZlX2RvdF9zZWdtZW50cyB1cmkucGF0aH1cbiAgICB8IE5vbmUsIFNvbWUgXywgX1xuICAgIHwgTm9uZSwgXywgU29tZSBfIC0+XG4gICAgICB7dXJpIHdpdGggc2NoZW1lPWJhc2Uuc2NoZW1lOyBwYXRoPXJlbW92ZV9kb3Rfc2VnbWVudHMgdXJpLnBhdGh9XG4gICAgfCBOb25lLCBOb25lLCBOb25lIC0+XG4gICAgICBsZXQgdXJpID0ge3VyaSB3aXRoIHNjaGVtZT1iYXNlLnNjaGVtZTsgdXNlcmluZm89YmFzZS51c2VyaW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdD1iYXNlLmhvc3Q7IHBvcnQ9YmFzZS5wb3J0fSBpblxuICAgICAgbGV0IHBhdGhfc3RyID0gcGF0aCB1cmkgaW5cbiAgICAgIGlmIHBhdGhfc3RyPVwiXCJcbiAgICAgIHRoZW4geyB1cmkgd2l0aFxuICAgICAgICAgICAgIHBhdGg9YmFzZS5wYXRoO1xuICAgICAgICAgICAgIHF1ZXJ5PW1hdGNoIHVyaS5xdWVyeSB3aXRoXG4gICAgICAgICAgICAgICB8IFF1ZXJ5LlJhdyAoTm9uZSxfKSB8IFF1ZXJ5LktWIFtdIC0+IGJhc2UucXVlcnlcbiAgICAgICAgICAgICAgIHwgXyAtPiB1cmkucXVlcnlcbiAgICAgICAgICAgfVxuICAgICAgZWxzZSBpZiBwYXRoX3N0ci5bMF09Jy8nXG4gICAgICB0aGVuIHt1cmkgd2l0aCBwYXRoPXJlbW92ZV9kb3Rfc2VnbWVudHMgdXJpLnBhdGh9XG4gICAgICBlbHNlIHt1cmkgd2l0aFxuICAgICAgICBwYXRoPXJlbW92ZV9kb3Rfc2VnbWVudHMgKG1lcmdlIGJhc2UuaG9zdCBiYXNlLnBhdGggdXJpLnBhdGgpO1xuICAgICAgfVxuICAgIClcblxubGV0IGNhbm9uaWNhbGl6ZSB1cmkgPVxuICBsZXQgdXJpID0gcmVzb2x2ZSBcIlwiIGVtcHR5IHVyaSBpblxuICBsZXQgbW9kdWxlIFNjaGVtZSA9XG4gICAgKHZhbCAobW9kdWxlX29mX3NjaGVtZSAodW5jYXN0X29wdCB1cmkuc2NoZW1lKSkgOiBTY2hlbWUpIGluXG4gIHsgdXJpIHdpdGhcbiAgICBwb3J0PVNjaGVtZS5jYW5vbmljYWxpemVfcG9ydCB1cmkucG9ydDtcbiAgICBwYXRoPVNjaGVtZS5jYW5vbmljYWxpemVfcGF0aCB1cmkucGF0aDtcbiAgfVxuXG5sZXQgcHAgcHBmIHVyaSA9IEZvcm1hdC5wcF9wcmludF9zdHJpbmcgcHBmICh0b19zdHJpbmcgdXJpKVxubGV0IHBwX2h1bSBwcGYgdXJpID0gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgKHRvX3N0cmluZyB1cmkpXG5cbm1vZHVsZSBQYXJzZXIgPSBzdHJ1Y3RcbiAgb3BlbiBBbmdzdHJvbVxuXG4gIGxldCBzdHJpbmdfb2ZfY2hhciA9IFN0cmluZy5tYWtlIDFcblxuICBsZXQgc3RyaW5nX29mX2NoYXJfbGlzdCBjaGFycyA9XG4gICAgU3RyaW5nLmNvbmNhdCBcIlwiIChMaXN0Lm1hcCBzdHJpbmdfb2ZfY2hhciBjaGFycylcblxuICBsZXQgc2NoZW1lID1cbiAgICBsaWZ0XG4gICAgICAoZnVuIHMgLT4gU29tZSAoUGN0LmRlY29kZSAoUGN0LmNhc3RfZW5jb2RlZCBzKSkpXG4gICAgICAodGFrZV93aGlsZSAoZnVuIGMgLT4gYyA8PiAnOicgJiYgYyA8PiAnLycgJiYgYyA8PiAnPycgJiYgYyA8PiAnIycpXG4gICAgICA8KiBjaGFyICc6JylcbiAgICA8fD4gcmV0dXJuIE5vbmVcblxuICBsZXQgaXNfZGlnaXQgPSBmdW5jdGlvbiAnMCcgLi4gJzknIC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgbGV0IGhleF9kaWdpdCA9XG4gICAgc2F0aXNmeSAoZnVuY3Rpb25cbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJ0EnIC4uICdGJyB8ICdhJyAuLiAnZicgLT5cbiAgICAgICAgICB0cnVlXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIGZhbHNlKVxuXG4gIGxldCBoZXhhZGVjaW1hbCA9IGxpZnQgc3RyaW5nX29mX2NoYXJfbGlzdCAobWFueSBoZXhfZGlnaXQpXG5cbiAgbGV0IGNfZG90ID0gY2hhciAnLidcblxuICBsZXQgY19hdCA9IGNoYXIgJ0AnXG5cbiAgbGV0IGNfY29sb24gPSBjaGFyICc6J1xuXG4gIGxldCBkZWNfb2N0ZXQgPVxuICAgIHRha2Vfd2hpbGUxIChmdW5jdGlvbiAnMCcgLi4gJzknIC0+IHRydWUgfCBfIC0+IGZhbHNlKSA+Pj0gZnVuIG51bSAtPlxuICAgIGlmIGludF9vZl9zdHJpbmcgbnVtIDwgMjU2IHRoZW5cbiAgICAgIHJldHVybiBudW1cbiAgICBlbHNlXG4gICAgICBmYWlsIFwiaW52YWxpZCBvY3RlY3RcIlxuXG4gIGxldCBpcHY0X2FkZHJlc3MgPVxuICAgIGxpZnQyXG4gICAgICAoZnVuIHRocmVlIG9uZSAtPiBTdHJpbmcuY29uY2F0IFwiLlwiIHRocmVlIF4gXCIuXCIgXiBvbmUpXG4gICAgICAoY291bnQgMyAoZGVjX29jdGV0IDwqIGNfZG90KSlcbiAgICAgIGRlY19vY3RldFxuXG4gICgqIC0tIGFmdGVyIGRvdWJsZSBjb2xvbiwgSVB2NCBkb3R0ZWQgbm90YXRpb24gY291bGQgYXBwZWFyIGFueXdoZXJlICopXG4gIGxldCBhZnRlcl9kb3VibGVfY29sb24gPVxuICAgIGZpeCAoZnVuIGYgLT5cbiAgICAgICAgbGlzdCBbIGlwdjRfYWRkcmVzcyBdXG4gICAgICAgIDx8PiBsaWZ0MiAoZnVuIHggeSAtPiB4IDo6IHkpIGhleGFkZWNpbWFsIChjX2NvbG9uICo+IGYgPHw+IHJldHVybiBbXSkpXG5cbiAgbGV0IGRvdWJsZV9jb2xvbiBjb3VudCA9XG4gICAgYWZ0ZXJfZG91YmxlX2NvbG9uID4+PSAoZnVuIHJlc3QgLT5cbiAgICBsZXQgZmlsbGVyX2xlbmd0aCA9IDggLSBjb3VudCAtIExpc3QubGVuZ3RoIHJlc3QgaW5cbiAgICBpZiBmaWxsZXJfbGVuZ3RoIDw9IDAgdGhlblxuICAgICAgZmFpbCBcInRvbyBtYW55IHBhcnRzIGluIElQdjYgYWRkcmVzc1wiXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIChcIlwiIDo6IHJlc3QpKVxuICAgIDx8PiByZXR1cm4gW1wiXCJdXG5cbiAgbGV0IHJlYyBwYXJ0ID0gZnVuY3Rpb25cbiAgICB8IDcgLT5cbiAgICAgICgqIG1heCA4IHBhcnRzIGluIGFuIElQdjYgYWRkcmVzcyAqKVxuICAgICAgbGlmdCAoZnVuIHggLT4gWyB4IF0pIGhleGFkZWNpbWFsXG4gICAgfCA2IC0+XG4gICAgICAoKiBhZnRlciA2IHBhcnRzIGl0IGNvdWxkIGVuZCBpbiBJUHY0IGRvdHRlZCBub3RhdGlvbiAqKVxuICAgICAgbGlzdCBbIGlwdjRfYWRkcmVzcyBdIDx8PiBoZXhfcGFydCA2XG4gICAgfCBuIC0+XG4gICAgICBoZXhfcGFydCBuXG5cbiAgYW5kIGhleF9wYXJ0IG4gPVxuICAgIGxpZnQyXG4gICAgICAoZnVuIHggeSAtPiB4IDo6IHkpXG4gICAgICBoZXhhZGVjaW1hbFxuICAgICAgKGNfY29sb24gKj4gKGNfY29sb24gKj4gZG91YmxlX2NvbG9uIChuICsgMSkgPHw+IHBhcnQgKG4gKyAxKSkpXG5cbiAgbGV0IHJlYyBzcGxpdF93aXRoIGYgeHMgPVxuICAgIG1hdGNoIHhzIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBbXSwgW11cbiAgICB8IHkgOjogeXMgLT5cbiAgICAgIGlmIGYgeSB0aGVuXG4gICAgICAgIGxldCB6cywgdHMgPSBzcGxpdF93aXRoIGYgeXMgaW5cbiAgICAgICAgeSA6OiB6cywgdHNcbiAgICAgIGVsc2VcbiAgICAgICAgW10sIHhzXG5cbiAgbGV0IGlwdjYgPVxuICAgIGxldCBmb3JtYXRfYWRkciBzZWdtZW50cyA9XG4gICAgICBsZXQgYmVmb3JlX2RvdWJsZV9jb2xvbiwgYWZ0ZXJfZG91YmxlX2NvbG9uID1cbiAgICAgICAgc3BsaXRfd2l0aCAoZnVuIHNlZ21lbnQgLT4gc2VnbWVudCA8PiBcIlwiKSBzZWdtZW50c1xuICAgICAgaW5cbiAgICAgIGxldCBiZWZvcmUgPSBTdHJpbmcuY29uY2F0IFwiOlwiIGJlZm9yZV9kb3VibGVfY29sb24gaW5cbiAgICAgIGxldCByZXMgPVxuICAgICAgICBtYXRjaCBhZnRlcl9kb3VibGVfY29sb24gd2l0aFxuICAgICAgICB8IFwiXCIgOjogeHMgLT5cbiAgICAgICAgICBiZWZvcmUgXiBcIjo6XCIgXiBTdHJpbmcuY29uY2F0IFwiOlwiIHhzXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIGJlZm9yZVxuICAgICAgaW5cbiAgICAgIHJlc1xuICAgIGluXG4gICAgbGlmdCBmb3JtYXRfYWRkciAoY19jb2xvbiAqPiBjX2NvbG9uICo+IGRvdWJsZV9jb2xvbiAwIDx8PiBwYXJ0IDApXG5cbiAgbGV0IGlwdjZfYWRkcmVzcyA9XG4gICAgKGNoYXIgJ1snKSAqPiBpcHY2IDwqIChjaGFyICddJylcblxuICBsZXQgcGN0X2VuY29kZWQgPVxuICAgIGxpZnQyXG4gICAgICAoZnVuIHBjdCBkaWdpdHMgLT4gc3RyaW5nX29mX2NoYXJfbGlzdCAocGN0IDo6IGRpZ2l0cykpXG4gICAgICAoY2hhciAnJScpXG4gICAgICAoY291bnQgMiBoZXhfZGlnaXQpXG5cbiAgbGV0IHN1Yl9kZWxpbXMgPVxuICAgIHNhdGlzZnkgKGZ1bmN0aW9uXG4gICAgICAgIHwgJyEnIHwgJyQnIHwgJyYnIHwgJ1xcJycgfCAnKCcgfCAnKScgfCAnKicgfCAnKycgfCAnLCcgfCAnOycgfCAnPScgLT5cbiAgICAgICAgICB0cnVlXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIGZhbHNlKVxuXG4gIGxldCB1bnJlc2VydmVkID1cbiAgICAoKiBcIltBLVphLXowLTktLl9+XVwiICopXG4gICAgc2F0aXNmeSAoZnVuY3Rpb25cbiAgICAgICAgfCAnQScgLi4gJ1onIHwgJ2EnIC4uICd6JyB8ICcwJyAuLiAnOScgfCAnLScgfCAnLicgfCAnXycgfCAnficgLT5cbiAgICAgICAgICB0cnVlXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIGZhbHNlKVxuXG4gIGxldCByZWdfbmFtZSA9XG4gICAgbGlmdFxuICAgICAgKFN0cmluZy5jb25jYXQgXCJcIilcbiAgICAgIChtYW55XG4gICAgICAgICAoY2hvaWNlXG4gICAgICAgICAgICBbIHN0cmluZ19vZl9jaGFyIDwkPiB1bnJlc2VydmVkXG4gICAgICAgICAgICA7IHBjdF9lbmNvZGVkXG4gICAgICAgICAgICA7IHN0cmluZ19vZl9jaGFyIDwkPiBzdWJfZGVsaW1zXG4gICAgICAgICAgICBdKSlcblxuICBsZXQgaG9zdCA9XG4gICAgY2hvaWNlXG4gICAgICBbIGlwdjRfYWRkcmVzcyA+PnwgKGZ1biBoIC0+IGBJcHY0X2xpdGVyYWwgaClcbiAgICAgIDsgaXB2Nl9hZGRyZXNzID4+fCAoZnVuIGggLT4gYElwdjZfbGl0ZXJhbCBoKVxuICAgICAgOyByZWdfbmFtZSA+PnwgKGZ1biBzIC0+IGBIb3N0IChQY3QuZGVjb2RlIChQY3QuY2FzdF9lbmNvZGVkIHMpKSlcbiAgICAgICgqIFRPRE8oZGlub3NhdXJlKTogQWNjb3JkaW5nIHRvIFJGQzM5ODY6XG5cbiAgICAgICAgIGhvc3QgICAgICAgID0gSVAtbGl0ZXJhbCAvIElQdjRhZGRyZXNzIC8gcmVnLW5hbWVcbiAgICAgICAgIElQLWxpdGVyYWwgID0gXCJbXCIgKCBJUHY2YWRkcmVzcyAvIElQdkZ1dHVyZSAgKSBcIl1cIlxuICAgICAgICAgSVB2RnV0dXJlICAgPSBcInZcIiAxKkhFWERJRyBcIi5cIiAxKiggdW5yZXNlcnZlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiApXG5cbiAgICAgICAgIElQdkZ1dHVyZSBpcyBub3QgaW1wbGVtZW50ZWQuIFdlIHNob3VsZCBoYW5kbGUgaXQ6XG5cbiAgICAgICAgIElQdkZ1dHVyZSAgID0gXCJ2XCIgMSpIRVhESUcgXCIuXCIgMSooIHVucmVzZXJ2ZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgKVxuICAgICAgICopXG4gICAgICBdXG5cbiAgbGV0IHVzZXJpbmZvID1cbiAgICBsaWZ0XG4gICAgICAoZnVuIHggLT5cbiAgICAgICAgbGV0IHMgPSBTdHJpbmcuY29uY2F0IFwiXCIgeCBpblxuICAgICAgICBTb21lIChVc2VyaW5mby51c2VyaW5mb19vZl9lbmNvZGVkIHMpKVxuICAgICAgKG1hbnlcbiAgICAgICAgIChjaG9pY2VcbiAgICAgICAgICAgIFsgc3RyaW5nX29mX2NoYXIgPCQ+IHVucmVzZXJ2ZWRcbiAgICAgICAgICAgIDsgcGN0X2VuY29kZWRcbiAgICAgICAgICAgIDsgc3RyaW5nX29mX2NoYXIgPCQ+IHN1Yl9kZWxpbXNcbiAgICAgICAgICAgIDsgc3RyaW5nX29mX2NoYXIgPCQ+IGNfY29sb25cbiAgICAgICAgICAgIF0pXG4gICAgICA8KiBjX2F0KVxuICAgIDx8PiByZXR1cm4gTm9uZVxuXG4gIGxldCBwb3J0ID1cbiAgICBwZWVrX2NoYXIgPj49IGZ1bmN0aW9uXG4gICAgfCBTb21lICc6JyAtPlxuICAgICAgY19jb2xvbiAqPiB0YWtlX3doaWxlIGlzX2RpZ2l0ID4+fCBmdW4gcG9ydCAtPlxuICAgICAgbGV0IGRlY29kZWQgPSBQY3QuZGVjb2RlIChQY3QuY2FzdF9lbmNvZGVkIHBvcnQpIGluXG4gICAgICAodHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgKFBjdC51bmNhc3RfZGVjb2RlZCBkZWNvZGVkKSkgd2l0aCBfIC0+IE5vbmUpXG4gICAgfCBTb21lIF8gfCBOb25lIC0+XG4gICAgICByZXR1cm4gTm9uZVxuXG4gIGxldCBhdXRob3JpdHkgPVxuICAgIHN0cmluZyBcIi8vXCJcbiAgICAqPiBsaWZ0M1xuICAgICAgICAgKGZ1biB1c2VyaW5mbyBob3N0IHBvcnQgLT5cbiAgICAgICAgICAgdXNlcmluZm8sIFNvbWUgaG9zdCwgcG9ydClcbiAgICAgICAgIHVzZXJpbmZvXG4gICAgICAgICBob3N0XG4gICAgICAgICBwb3J0XG4gICAgPHw+IHJldHVybiAoTm9uZSwgTm9uZSwgTm9uZSlcblxuICBsZXQgcGF0aCA9XG4gICAgbGlmdFxuICAgICAgUGF0aC5wYXRoX29mX2VuY29kZWRcbiAgICAgICh0YWtlX3doaWxlIChmdW5jdGlvbiAnPycgfCAnIycgLT4gZmFsc2UgfCBfIC0+IHRydWUpKVxuXG4gIGxldCBxdWVyeSA9XG4gICAgbGlmdFxuICAgICAgUXVlcnkub2ZfcmF3XG4gICAgICAoY2hhciAnPycgKj4gdGFrZV90aWxsIChmdW5jdGlvbiAnIycgLT4gdHJ1ZSB8IF8gLT4gZmFsc2UpKVxuICAgIDx8PiByZXR1cm4gKFF1ZXJ5LlJhdyAoTm9uZSwgTGF6eS5mcm9tX3ZhbCBbXSkpXG5cbiAgbGV0IGZyYWdtZW50ID1cbiAgICBsaWZ0XG4gICAgICAoZnVuIHMgLT4gU29tZSAoUGN0LmRlY29kZSAoUGN0LmNhc3RfZW5jb2RlZCBzKSkpXG4gICAgICAoY2hhciAnIycgKj4gdGFrZV93aGlsZSAoZnVuIF8gLT4gdHJ1ZSkpXG4gICAgPHw+IHJldHVybiBOb25lXG5cbiAgbGV0IF91cmlfcmVmZXJlbmNlID1cbiAgICBsaWZ0NFxuICAgICAgKGZ1biBzY2hlbWUgKHVzZXJpbmZvLCBob3N0LCBwb3J0KSBwYXRoIHF1ZXJ5IGZyYWdtZW50IC0+XG4gICAgICAgIG5vcm1hbGl6ZSBzY2hlbWUgeyBzY2hlbWU7IHVzZXJpbmZvOyBob3N0OyBwb3J0OyBwYXRoOyBxdWVyeTsgZnJhZ21lbnQgfSlcbiAgICAgIHNjaGVtZVxuICAgICAgYXV0aG9yaXR5XG4gICAgICBwYXRoXG4gICAgICBxdWVyeVxuICAgIDwqPiBmcmFnbWVudFxuXG4gICgqIFhYWChhbm1vbnRlaXJvKTogRm9yIGNvbXBhdGliaWxpdHkgcmVhc29ucyB3aXRoIHRoZSBvbGQgcmVnZXggcGFyc2VyLCB3ZVxuICAgKiBvbmx5IHBhcnNlIHVudGlsIHRoZSBmaXJzdCBuZXdsaW5lIGNoYXJhY3RlciBhbmQgZHJvcCBldmVyeXRoaW5nIGVsc2VcbiAgICogYWZ0ZXIgdGhhdCAqKVxuICBsZXQgdXJpX3JlZmVyZW5jZSA9XG4gICAgdGFrZV93aGlsZSAoZnVuY3Rpb24gfCAnXFxuJyAtPiBmYWxzZSB8IF8gLT4gdHJ1ZSkgPj58IGZ1biBzIC0+XG4gICAgICBtYXRjaCBBbmdzdHJvbS5wYXJzZV9zdHJpbmcgfmNvbnN1bWU6QWxsIF91cmlfcmVmZXJlbmNlIHMgd2l0aFxuICAgICAgfCBPayB0IC0+IHRcbiAgICAgIHwgRXJyb3IgXyAtPlxuICAgICAgICAoKiBTaG91bGRuJ3QgcmVhbGx5IGhhcHBlbiBpZiB0aGUgcGFyc2VyIGlzIGZvcmdpdmluZy4gKilcbiAgICAgICAgZW1wdHlcbmVuZFxuXG5sZXQgZGVjb2RlX2hvc3QgaG9zdCA9XG4gIG1hdGNoIEFuZ3N0cm9tLnBhcnNlX3N0cmluZyB+Y29uc3VtZTpBbGwgUGFyc2VyLmhvc3QgaG9zdCB3aXRoXG4gIHwgT2sgcGFyc2VkIC0+IHBhcnNlZFxuICB8IEVycm9yIF8gLT5cbiAgICBtYXRjaCBBbmdzdHJvbS5wYXJzZV9zdHJpbmcgfmNvbnN1bWU6QWxsIFBhcnNlci5pcHY2IGhvc3Qgd2l0aFxuICAgIHwgT2sgcGFyc2VkIC0+IChgSXB2Nl9saXRlcmFsIHBhcnNlZClcbiAgICB8IEVycm9yIF8gLT4gKGBIb3N0IChQY3QuY2FzdF9kZWNvZGVkIGhvc3QpKVxuXG4oKiBNYWtlIGEgVVJJIHJlY29yZC4gVGhpcyBpcyBhIGJpdCBtb3JlIGluZWZmaWNpZW50IHRoYW4gaXQgbmVlZHMgdG8gYmUgZHVlIHRvIHRoZVxuICogY2FzdGluZy91bmNhc3RpbmcgKHdoaWNoIGlzbid0IGZ1bGx5IGlkZW50aXR5IGR1ZSB0byB0aGUgb3B0aW9uIGJveCksIGJ1dCBpdCBpc1xuICogbm8gYmlnIGRlYWwgZm9yIG5vdy5cbiopXG5sZXQgbWFrZSA/c2NoZW1lID91c2VyaW5mbyA/aG9zdCA/cG9ydCA/cGF0aCA/cXVlcnkgP2ZyYWdtZW50ICgpID1cbiAgbGV0IGRlY29kZSA9IGZ1bmN0aW9uXG4gICAgfFNvbWUgeCAtPiBTb21lIChQY3QuY2FzdF9kZWNvZGVkIHgpIHxOb25lIC0+IE5vbmUgaW5cbiAgbGV0IGhvc3QgPSBtYXRjaCB1c2VyaW5mbywgaG9zdCwgcG9ydCB3aXRoXG4gICAgfCBfLCBTb21lIF8sIF8gfCBOb25lLCBOb25lLCBOb25lIC0+IGhvc3RcbiAgICB8IFNvbWUgXywgTm9uZSwgXyB8IF8sIE5vbmUsIFNvbWUgXyAtPiBTb21lIFwiXCJcbiAgaW5cbiAgbGV0IHVzZXJpbmZvID0gbWF0Y2ggdXNlcmluZm8gd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lIHwgU29tZSB1IC0+IFNvbWUgKHVzZXJpbmZvX29mX2VuY29kZWQgdSkgaW5cbiAgbGV0IHBhdGggPSBtYXRjaCBwYXRoIHdpdGhcbiAgICB8Tm9uZSAtPiBbXSB8IFNvbWUgcCAtPlxuICAgICAgbGV0IHBhdGggPSBwYXRoX29mX2VuY29kZWQgcCBpblxuICAgICAgbWF0Y2ggaG9zdCwgcGF0aCB3aXRoXG4gICAgICB8IE5vbmUsIF8gfCBTb21lIF8sIFwiL1wiOjpfIHwgU29tZSBfLCBbXSAtPiBwYXRoXG4gICAgICB8IFNvbWUgXywgXyAgLT4gXCIvXCI6OnBhdGhcbiAgaW5cbiAgbGV0IHF1ZXJ5ID0gbWF0Y2ggcXVlcnkgd2l0aFxuICAgIHwgTm9uZSAtPiBRdWVyeS5LViBbXVxuICAgIHwgU29tZSBwIC0+IFF1ZXJ5LktWIHBcbiAgaW5cbiAgbGV0IHNjaGVtZSA9IGRlY29kZSBzY2hlbWUgaW5cbiAgbm9ybWFsaXplIHNjaGVtZVxuICAgIHsgc2NoZW1lOyB1c2VyaW5mbztcbiAgICAgIGhvc3QgPVxuICAgICAgICAobWF0Y2ggaG9zdCB3aXRoXG4gICAgICAgIHwgU29tZSBob3N0IC0+IFNvbWUgKGRlY29kZV9ob3N0IGhvc3QpXG4gICAgICAgIHwgTm9uZSAtPiBOb25lKTtcbiAgICAgIHBvcnQ7IHBhdGg7IHF1ZXJ5OyBmcmFnbWVudD1kZWNvZGUgZnJhZ21lbnQgfVxuXG5sZXQgd2l0aF9ob3N0IHVyaSBob3N0ID1cbiAgeyB1cmkgd2l0aFxuICAgIGhvc3QgPSAobWF0Y2ggaG9zdCB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgaG9zdCAtPiBTb21lIChkZWNvZGVfaG9zdCBob3N0KVxuICAgICAgICAgICAgfCBOb25lIC0+IE5vbmUpXG4gIH1cblxubGV0IHdpdGhfdXJpID9zY2hlbWUgP3VzZXJpbmZvID9ob3N0ID9wb3J0ID9wYXRoID9xdWVyeSA/ZnJhZ21lbnQgdXJpID1cbiAgbGV0IHdpdGhfcGF0aF9vcHQgdSBvID1cbiAgICBtYXRjaCBvIHdpdGhcbiAgICB8IE5vbmUgLT4gd2l0aF9wYXRoIHUgXCJcIlxuICAgIHwgU29tZSBwIC0+IHdpdGhfcGF0aCB1IHBcbiAgaW5cbiAgbGV0IHdpdGhfcXVlcnlfb3B0IHUgbyA9XG4gICAgbWF0Y2ggbyB3aXRoXG4gICAgfCBOb25lIC0+IHdpdGhfcXVlcnkgdSBbXVxuICAgIHwgU29tZSBxIC0+IHdpdGhfcXVlcnkgdSBxXG4gIGluXG4gIGxldCB3aXRoXyBmIG8gdSA9XG4gICAgbWF0Y2ggbyB3aXRoXG4gICAgfCBOb25lIC0+IHVcbiAgICB8IFNvbWUgeCAtPiBmIHUgeFxuICBpblxuICB3aXRoXyB3aXRoX3NjaGVtZSBzY2hlbWUgdXJpXG4gIHw+IHdpdGhfIHdpdGhfdXNlcmluZm8gdXNlcmluZm9cbiAgfD4gd2l0aF8gd2l0aF9ob3N0IGhvc3RcbiAgfD4gd2l0aF8gd2l0aF9wb3J0IHBvcnRcbiAgfD4gd2l0aF8gd2l0aF9wYXRoX29wdCBwYXRoXG4gIHw+IHdpdGhfIHdpdGhfcXVlcnlfb3B0IHF1ZXJ5XG4gIHw+IHdpdGhfIHdpdGhfZnJhZ21lbnQgZnJhZ21lbnRcblxubGV0IG9mX3N0cmluZyBzID1cbiAgKCogVG8gcHJlc2VydmUgdGhlIG9sZCByZWdleCBwYXJzZXIncyBiZWhhdmlvciwgd2Ugb25seSBwYXJzZSBhIHByZWZpeCwgYW5kXG4gICAqIHN0b3Agd2hlbmV2ZXIgd2UgY2FuJ3QgcGFyc2UgbW9yZS4gKilcbiAgbWF0Y2ggQW5nc3Ryb20ucGFyc2Vfc3RyaW5nIH5jb25zdW1lOlByZWZpeCBQYXJzZXIudXJpX3JlZmVyZW5jZSBzIHdpdGhcbiAgfCBPayB0IC0+IHRcbiAgfCBFcnJvciBfIC0+XG4gICAgKCogU2hvdWxkbid0IHJlYWxseSBoYXBwZW4gaWYgdGhlIHBhcnNlciBpcyBmb3JnaXZpbmcuICopXG4gICAgZW1wdHlcblxubW9kdWxlIEFic29sdXRlX2h0dHAgPSBzdHJ1Y3RcbiAgdHlwZSB1cmkgPSB0XG4gIHR5cGUgdCA9XG4gICAgeyBzY2hlbWUgOiBbIGBIdHRwIHwgYEh0dHBzIF07XG4gICAgICB1c2VyaW5mbzogVXNlcmluZm8udCBvcHRpb247XG4gICAgICBob3N0OiBbIGBJcHY0X2xpdGVyYWwgb2Ygc3RyaW5nXG4gICAgICAgICAgICB8IGBJcHY2X2xpdGVyYWwgb2Ygc3RyaW5nXG4gICAgICAgICAgICB8IGBIb3N0IG9mIFBjdC5kZWNvZGVkXTtcbiAgICAgIHBvcnQgOiBpbnQgb3B0aW9uO1xuICAgICAgcGF0aCA6IFBhdGgudDtcbiAgICAgIHF1ZXJ5IDogUXVlcnkudDtcbiAgICAgIGZyYWdtZW50IDogUGN0LmRlY29kZWQgb3B0aW9uXG4gICAgfVxuXG4gIGxldCAoIGxldCogKSA9IFJlc3VsdC5iaW5kXG5cbiAgbGV0IHRvX3VyaSB7IHNjaGVtZTsgdXNlcmluZm87IGhvc3Q7IHBvcnQ7IHBhdGg7IHF1ZXJ5OyBmcmFnbWVudCB9ID1cbiAgICBsZXQgc2NoZW1lID1cbiAgICAgIG1hdGNoIHNjaGVtZSB3aXRoXG4gICAgICB8IGBIdHRwIC0+IFBjdC5jYXN0X2RlY29kZWQgXCJodHRwXCJcbiAgICAgIHwgYEh0dHBzIC0+IFBjdC5jYXN0X2RlY29kZWQgXCJodHRwc1wiXG4gICAgaW5cbiAgICAoeyBzY2hlbWUgPSBTb21lIHNjaGVtZTtcbiAgICAgICB1c2VyaW5mbztcbiAgICAgICBob3N0ID0gU29tZSBob3N0O1xuICAgICAgIHBvcnQ7XG4gICAgICAgcGF0aDtcbiAgICAgICBxdWVyeTtcbiAgICAgICBmcmFnbWVudCB9IDogdXJpKVxuICA7O1xuXG4gIGxldCBvZl91cmkgKHsgc2NoZW1lOyB1c2VyaW5mbzsgaG9zdDsgcG9ydDsgcGF0aDsgcXVlcnk7IGZyYWdtZW50IH06IHVyaSkgPVxuICAgIGxldCogc2NoZW1lID1cbiAgICAgIG1hdGNoIHNjaGVtZSB3aXRoXG4gICAgICB8IE5vbmUgLT4gRXJyb3IgKGBNc2cgXCJObyBzY2hlbWUgcHJlc2VudCBpbiBVUklcIilcbiAgICAgIHwgU29tZSBzY2hlbWUgLT5cbiAgICAgICAgKG1hdGNoIFBjdC51bmNhc3RfZGVjb2RlZCBzY2hlbWUgd2l0aFxuICAgICAgICAgfCBcImh0dHBcIiAtPiBPayBgSHR0cFxuICAgICAgICAgfCBcImh0dHBzXCIgLT4gT2sgYEh0dHBzXG4gICAgICAgICB8IHVuc3VwcG9ydGVkX3NjaGVtZSAtPlxuICAgICAgICAgICBFcnJvclxuICAgICAgICAgICAgIChgTXNnXG4gICAgICAgICAgICAgICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgICAgICAgICAgICAgXCJPbmx5IGh0dHAgYW5kIGh0dHBzIFVSSXMgYXJlIHN1cHBvcnRlZC4gJXMgaXMgaW52YWxpZC5cIlxuICAgICAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkX3NjaGVtZSkpKVxuICAgIGluXG4gICAgbGV0KiBob3N0ID0gT3B0aW9uLnRvX3Jlc3VsdCB+bm9uZTooYE1zZyBcImhvc3QgaXMgcmVxdWlyZWQgZm9yIEhUVFAoUykgdXJpc1wiKSBob3N0IGluXG4gICAgT2sgeyBzY2hlbWU7IHVzZXJpbmZvOyBob3N0OyBwb3J0OyBwYXRoOyBxdWVyeTsgZnJhZ21lbnQgfVxuICA7O1xuXG4gIGxldCBvZl9zdHJpbmcgcyA9IG1hdGNoIG9mX3N0cmluZyBzIHw+IG9mX3VyaSB3aXRoXG4gICAgfCBPayB0IC0+IHRcbiAgICB8IEVycm9yIChgTXNnIGVycm9yKSAtPiBmYWlsd2l0aCBlcnJvclxuXG4gIGxldCB0b19zdHJpbmcgP3BjdF9lbmNvZGVyIHQgPSB0b191cmkgdCB8PiB0b19zdHJpbmcgP3BjdF9lbmNvZGVyXG5cbiAgbGV0IG5vcm1hbGl6ZSB0ID1cbiAgICB7IHQgd2l0aFxuICAgICAgaG9zdCA9IG1hdGNoIHQuaG9zdCB3aXRoXG4gICAgICAgfCAoYElwdjRfbGl0ZXJhbCBob3N0KSAtPlxuICAgICAgICAgKGBJcHY0X2xpdGVyYWwgKFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgaG9zdCkpXG4gICAgICAgfCAoYElwdjZfbGl0ZXJhbCBob3N0KSAtPlxuICAgICAgICAgKGBJcHY2X2xpdGVyYWwgKFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgaG9zdCkpXG4gICAgICAgfCAoYEhvc3QgaG9zdCkgLT5cbiAgICAgICAgIChgSG9zdCAoUGN0LmNhc3RfZGVjb2RlZCAoU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSAoUGN0LnVuY2FzdF9kZWNvZGVkIGhvc3QpKSkpXG4gICAgfVxuXG4gIGxldCBtYWtlIH5zY2hlbWUgfmhvc3QgP3VzZXJpbmZvID9wb3J0ID9wYXRoID9xdWVyeSA/ZnJhZ21lbnQgKCkgPVxuICAgIGxldCBkZWNvZGUgPSBmdW5jdGlvblxuICAgICAgfFNvbWUgeCAtPiBTb21lIChQY3QuY2FzdF9kZWNvZGVkIHgpIHxOb25lIC0+IE5vbmUgaW5cbiAgICBsZXQgdXNlcmluZm8gPSBtYXRjaCB1c2VyaW5mbyB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZSB8IFNvbWUgdSAtPiBTb21lICh1c2VyaW5mb19vZl9lbmNvZGVkIHUpIGluXG4gICAgbGV0IHBhdGggPSBtYXRjaCBwYXRoIHdpdGhcbiAgICAgIHxOb25lIC0+IFtdIHwgU29tZSBwIC0+XG4gICAgICAgIGxldCBwYXRoID0gcGF0aF9vZl9lbmNvZGVkIHAgaW5cbiAgICAgICAgbWF0Y2ggcGF0aCB3aXRoXG4gICAgICAgIHwgIFwiL1wiOjpfIHwgIFtdIC0+IHBhdGhcbiAgICAgICAgfCBfICAtPiBcIi9cIjo6cGF0aFxuICAgIGluXG4gICAgbGV0IHF1ZXJ5ID0gbWF0Y2ggcXVlcnkgd2l0aFxuICAgICAgfCBOb25lIC0+IFF1ZXJ5LktWIFtdXG4gICAgICB8IFNvbWUgcCAtPiBRdWVyeS5LViBwXG4gICAgaW5cbiAgICBub3JtYWxpemVcbiAgICAgIHsgc2NoZW1lO1xuICAgICAgICB1c2VyaW5mbztcbiAgICAgICAgaG9zdD0gZGVjb2RlX2hvc3QgaG9zdDsgcG9ydDsgcGF0aDsgcXVlcnk7IGZyYWdtZW50PWRlY29kZSBmcmFnbWVudCB9XG5cbiAgbGV0IGhvc3QgdCA9XG4gICAgbWF0Y2ggdC5ob3N0IHdpdGhcbiAgICB8IChgSXB2NF9saXRlcmFsIGggfCBgSXB2Nl9saXRlcmFsIGgpIC0+IGhcbiAgICB8IChgSG9zdCBoKSAtPiAoUGN0LnVuY2FzdF9kZWNvZGVkIGgpXG5cbiAgbGV0IHNjaGVtZSB0ID0gdC5zY2hlbWVcbmVuZFxuIl19
