// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1+5.8.1

//# unitInfo: Provides: Protocol_version_header__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Protocol_version_header = [0];
   runtime.caml_register_global
    (0, Protocol_version_header, "Protocol_version_header__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Protocol_version_header__Known_protocol
//# unitInfo: Requires: Assert_failure, Bin_prot__Common, Bin_prot__Read, Bin_prot__Shape, Bin_prot__Write, Core, Core__Char, Core__Int, Core__List, Core__String, Expect_test_collector, Inline_test_config, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Krb = "Krb",
    cst_Krb_test_mode = "Krb_test_mode",
    cst_Protocol_version_header_Kn = "Protocol_version_header__Known_protocol",
    cst_Rpc = "Rpc",
    cst_krb = "krb",
    cst_krb_test_mode = "krb_test_mode",
    cst_protocol_version_header = "protocol_version_header",
    cst_rpc = "rpc",
    cst_src_known_protocol_ml = "src/known_protocol.ml",
    cst_t = "t",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos = "src/known_protocol.ml:50:15",
    cst = "",
    all = [0, 0, [0, 1, [0, 2, 0]]],
    error_source_005 = "src/known_protocol.ml.t",
    retired_krb_word = "KRB",
    Core = global_data.Core,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Core_Int = global_data.Core__Int,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Core_Char = global_data.Core__Char,
    Core_String = global_data.Core__String;
   global_data.Bin_prot__Read;
   global_data.Bin_prot__Common;
   global_data.Bin_prot__Write;
   var
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Protocol_version_header_Kn);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_protocol_version_header);
   caml_call1(Expect_test_collector[5][1], cst_src_known_protocol_ml);
   caml_call2
    (Ppx_inline_test_lib_Runtime[2], cst_protocol_version_header, cst);
   var
    compare = runtime.caml_int_compare,
    _a_ = [0, cst_Krb],
    _b_ = [0, cst_Krb_test_mode],
    _c_ = [0, cst_Rpc];
   function t_of_sexp(sexp_006){
    a:
    {
     if(0 === sexp_006[0]){
      var _u_ = sexp_006[1];
      b:
      if(_u_ !== cst_Krb){
       c:
       if(_u_ !== cst_Krb_test_mode){
        if(_u_ !== cst_Rpc){
         if(_u_ === cst_krb) break b;
         if(_u_ === cst_krb_test_mode) break c;
         if(_u_ !== cst_rpc) break a;
        }
        return 2;
       }
       return 1;
      }
      return 0;
     }
     var _v_ = sexp_006[1];
     if(! _v_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
     var _w_ = _v_[1];
     if(0 !== _w_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_005, sexp_006);
     var _x_ = _w_[1];
     b:
     if(_x_ !== cst_Krb){
      c:
      if(_x_ !== cst_Krb_test_mode){
       if(_x_ !== cst_Rpc){
        if(_x_ === cst_krb) break b;
        if(_x_ === cst_krb_test_mode) break c;
        if(_x_ !== cst_rpc) break a;
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
     }
     return caml_call2
             (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_005, sexp_006);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   var
    _d_ =
      caml_call1
       (Bin_prot_Shape[9],
        [0,
         [0, cst_Krb, 0],
         [0, [0, cst_Krb_test_mode, 0], [0, [0, cst_Rpc, 0], 0]]]),
    _e_ = [0, [0, caml_call1(Bin_prot_Shape[2][1], cst_t), 0, _d_], 0],
    _f_ = caml_call1(Bin_prot_Shape[4][1], "src/known_protocol.ml:3:0"),
    group = caml_call2(Bin_prot_Shape[6], _f_, _e_),
    _g_ = caml_call1(Bin_prot_Shape[2][1], cst_t);
   caml_call1(caml_call2(Bin_prot_Shape[14], group, _g_), 0);
   var cst_KRB2 = "KRB2", cst_KBT = "KBT", cst_RPC = "RPC";
   function magic_word(param){
    switch(param){
      case 0:
       return cst_KRB2;
      case 1:
       return cst_KBT;
      default: return cst_RPC;
    }
   }
   var magic_number_bin_size = 5;
   function gen_magic_number(word){
    var _t_ = caml_call1(Core_String[54], word);
    return caml_call3
            (Core_List[10],
             _t_,
             0,
             function(acc, c){
              return (acc * 256 | 0) + caml_call1(Core_Char[6], c) | 0;
             });
   }
   function magic_number(t){return gen_magic_number(magic_word(t));}
   var
    _h_ =
      caml_call2
       (Core_List[72], all, function(p){return [0, magic_number(p), p];}),
    by_magic_number = caml_call1(Core_Int[101][9], _h_),
    _i_ = [0, cst_src_known_protocol_ml, 35, 2],
    _j_ = [0, cst_src_known_protocol_ml, 33, 2];
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     "validate magic words",
     0,
     cst_src_known_protocol_ml,
     29,
     0,
     449,
     function(param){
      var
       magic_words =
         [0, retired_krb_word, caml_call2(Core_List[72], all, magic_word)],
       magic_numbers =
         caml_call2(Core_List[72], magic_words, gen_magic_number);
      if
       (!
        caml_call2
         (Core_List[14],
          magic_numbers,
          function(n){
           var _s_ = caml_call1(Core_Int[2], 1073741823.);
           return caml_call2(Core[89], n, _s_);
          }))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
      if(caml_call2(Core_List[112], magic_numbers, Core_Int[91]))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
      return 0;
     });
   var
    _k_ = [0, cst_src_known_protocol_ml, 43, 2],
    _l_ = [0, cst_src_known_protocol_ml, 42, 2],
    _m_ = [0, cst_src_known_protocol_ml, 41, 2],
    _n_ = [0, cst_src_known_protocol_ml, 40, 2];
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     "magic numbers",
     0,
     cst_src_known_protocol_ml,
     39,
     0,
     223,
     function(param){
      var _o_ = gen_magic_number(retired_krb_word);
      if(! caml_call2(Core[90], _o_, 4346443))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
      var _p_ = magic_number(0);
      if(! caml_call2(Core[90], _p_, 843207243))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
      var _q_ = magic_number(1);
      if(! caml_call2(Core[90], _q_, 5521995))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
      var _r_ = magic_number(2);
      if(caml_call2(Core[90], _r_, 4411474)) return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
     });
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     "magic_number_bin_size is correct",
     0,
     cst_src_known_protocol_ml,
     46,
     0,
     214,
     function(param){
      caml_call2
       (Core_List[9],
        all,
        function(t){
         var
          magic_number$0 = magic_number(t),
          size = caml_call1(Core_Int[71], magic_number$0),
          sexpifier = Core[356];
         function comparator(a_007, b_008){
          return caml_call2(Core[352], a_007, b_008);
         }
         return caml_call8
                 (Ppx_assert_lib_Runtime[2],
                  pos,
                  sexpifier,
                  comparator,
                  0,
                  0,
                  0,
                  size,
                  magic_number_bin_size);
        });
      return 0;
     });
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_protocol_version_header);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Protocol_version_header_Kn);
   var
    Protocol_version_header_Known_ =
      [0,
       compare,
       all,
       t_of_sexp,
       sexp_of_t,
       magic_number,
       by_magic_number,
       magic_number_bin_size];
   runtime.caml_register_global
    (67, Protocol_version_header_Known_, cst_Protocol_version_header_Kn);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Protocol_version_header__List_with_max_len_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Protocol_version_header_Li =
      "Protocol_version_header__List_with_max_len_intf",
    cst_protocol_version_header = "protocol_version_header";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Protocol_version_header_Li);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_protocol_version_header);
   caml_call1(Expect_test_collector[5][1], "src/list_with_max_len_intf.ml");
   caml_call2
    (Ppx_inline_test_lib_Runtime[2], cst_protocol_version_header, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_protocol_version_header);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Protocol_version_header_Li);
   var Protocol_version_header_List_w = [0];
   runtime.caml_register_global
    (11, Protocol_version_header_List_w, cst_Protocol_version_header_Li);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Protocol_version_header__List_with_max_len
//# unitInfo: Requires: Base__Exn, Bin_prot__Read, Bin_prot__Shape, Core, Core__Info, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Protocol_version_header__List_with_max_len_intf, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Protocol_version_header_Li =
      "Protocol_version_header__List_with_max_len",
    cst_a$1 = "a",
    cst_protocol_version_header = "protocol_version_header",
    cst_t$1 = "t",
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_List = global_data.Core__List,
    Core = global_data.Core,
    Core_Info = global_data.Core__Info,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Bin_prot_Read = global_data.Bin_prot__Read,
    Base_Exn = global_data.Base__Exn,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Protocol_version_header_Li);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_protocol_version_header);
   caml_call1(Expect_test_collector[5][1], "src/list_with_max_len.ml");
   caml_call2
    (Ppx_inline_test_lib_Runtime[2], cst_protocol_version_header, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_protocol_version_header);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Protocol_version_header_Li);
   var
    cst_a = cst_a$1,
    cst_src_list_with_max_len_ml_7 = "src/list_with_max_len.ml:7:14",
    cst_a$0 = cst_a$1,
    cst_t = cst_t$1,
    cst_src_list_with_max_len_ml_7$0 = "src/list_with_max_len.ml:7:2",
    cst_t$0 = cst_t$1,
    _a_ = [0, "max_len"],
    _b_ = [0, "len"],
    _c_ = [0, "context"],
    cst_List_is_too_large = "List is too large",
    Protocol_version_header_List_w =
      [0,
       function(Config){
        var
         max_len = Config[1],
         context = Config[2],
         _d_ = caml_call1(Bin_prot_Shape[3][1], cst_a),
         _e_ =
           caml_call1(Bin_prot_Shape[4][1], cst_src_list_with_max_len_ml_7),
         _f_ = caml_call2(Bin_prot_Shape[15], _e_, _d_),
         _g_ = caml_call1(Core[410], _f_),
         _h_ = [0, caml_call1(Bin_prot_Shape[3][1], cst_a$0), 0],
         _i_ = [0, [0, caml_call1(Bin_prot_Shape[2][1], cst_t), _h_, _g_], 0],
         _j_ =
           caml_call1(Bin_prot_Shape[4][1], cst_src_list_with_max_len_ml_7$0),
         group = caml_call2(Bin_prot_Shape[6], _j_, _i_);
        function bin_shape_t(a){
         var _z_ = caml_call1(Bin_prot_Shape[2][1], cst_t$0);
         return caml_call1
                 (caml_call2(Bin_prot_Shape[14], group, _z_), [0, a, 0]);
        }
        function bin_size_t(size_of_a, v){
         return caml_call2(Core[411], size_of_a, v);
        }
        function bin_write_t(write_a, buf, pos, v){
         return caml_call3(caml_call1(Core[412], write_a), buf, pos, v);
        }
        function bin_writer_t(bin_writer_a){
         return [0,
                 function(v){return bin_size_t(bin_writer_a[1], v);},
                 function(v){
                  var _w_ = bin_writer_a[2];
                  return function(_x_, _y_){
                   return bin_write_t(_w_, v, _x_, _y_);};
                 }];
        }
        var bin_read_t = Core_List[150];
        function bin_read_t$0(bin_read_el, buf, pos_ref){
         try{
          var
           _v_ =
             caml_call4(Bin_prot_Read[41], max_len, bin_read_el, buf, pos_ref);
          return _v_;
         }
         catch(exn$0){
          var
           exn = caml_wrap_exception(exn$0),
           _u_ = caml_call1(Core_Info[9], context);
          return caml_call2(Base_Exn[8], exn, _u_);
         }
        }
        function bin_reader_t(bin_reader_a){
         var
          _q_ = caml_call1(bin_read_t, bin_reader_a[1]),
          _r_ = bin_reader_a[1];
         return [0,
                 function(_s_, _t_){return bin_read_t$0(_r_, _s_, _t_);},
                 _q_];
        }
        function bin_t(bin_a){
         var _o_ = bin_reader_t(bin_a[3]), _p_ = bin_writer_t(bin_a[2]);
         return [0, bin_shape_t(bin_a[1]), _p_, _o_];
        }
        function of_list_exn(l){
         var len = caml_call1(Core_List[7], l);
         if(caml_call2(Core[91], len, max_len)){
          var
           _k_ = [0, [1, [0, _a_, [0, caml_call1(Core[356], max_len), 0]]], 0],
           _l_ = [0, [1, [0, _b_, [0, caml_call1(Core[356], len), 0]]], _k_],
           _m_ =
             [0,
              [1, [0, _c_, [0, caml_call1(Core_Info[6], context), 0]]],
              _l_],
           _n_ =
             [1,
              [0,
               caml_call1(Sexplib0_Sexp_conv[7], cst_List_is_too_large),
               _m_]];
          caml_call1(Core[253], _n_);
         }
         return l;
        }
        var sexp_of_t = Core_List[4];
        function t_of_sexp(t_of_a, sexp){
         var t = caml_call2(Core_List[3], t_of_a, sexp);
         return of_list_exn(t);
        }
        return [0,
                bin_shape_t,
                bin_size_t,
                bin_write_t,
                bin_read_t$0,
                bin_read_t,
                bin_writer_t,
                bin_reader_t,
                bin_t,
                t_of_sexp,
                sexp_of_t,
                of_list_exn,
                max_len];
       }];
   runtime.caml_register_global
    (28, Protocol_version_header_List_w, cst_Protocol_version_header_Li);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Protocol_version_header
//# unitInfo: Requires: Assert_failure, Base__Or_error, Bin_prot__Read, Bin_prot__Shape, Bin_prot__Type_class, Core, Core__Info, Core__Int, Core__List, Core__Map, Core__Or_error, Core__Set, Expect_test_collector, Inline_test_config, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Protocol_version_header__Known_protocol, Protocol_version_header__List_with_max_len, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Protocol_version_header = "Protocol_version_header",
    cst_Protocol_version_header_ne$3 =
      "[Protocol_version_header.negotiate]: conflicting magic protocol numbers",
    cst_peer_protocol = "peer_protocol",
    cst_protocol_version_header = "protocol_version_header",
    cst_src_protocol_version_heade = "src/protocol_version_header.ml",
    cst_t = "t",
    cst_us_protocol = "us_protocol",
    cst_us_versions = "us_versions",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Int = global_data.Core__Int,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Protocol_version_header_Known_ =
      global_data.Protocol_version_header__Known_protocol,
    Core_Map = global_data.Core__Map,
    Bin_prot_Read = global_data.Bin_prot__Read,
    Core_List = global_data.Core__List,
    Bin_prot_Type_class = global_data.Bin_prot__Type_class,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Or_error = global_data.Core__Or_error,
    Core_Set = global_data.Core__Set,
    Base_Or_error = global_data.Base__Or_error,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Info = global_data.Core__Info,
    Protocol_version_header_List_w =
      global_data.Protocol_version_header__List_with_max_len,
    Bin_prot_Shape = global_data.Bin_prot__Shape,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Protocol_version_header);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_protocol_version_header);
   caml_call1(Expect_test_collector[5][1], cst_src_protocol_version_heade);
   caml_call2
    (Ppx_inline_test_lib_Runtime[2], cst_protocol_version_header, cst);
   var
    context = caml_call1(Core_Info[12], cst_Protocol_version_header),
    Bounded_list_in_case_someone_s =
      caml_call1(Protocol_version_header_List_w[1], [0, 100, context]),
    _a_ = caml_call1(Bounded_list_in_case_someone_s[1], Core[344]),
    _b_ = [0, [0, caml_call1(Bin_prot_Shape[2][1], cst_t), 0, _a_], 0],
    _c_ =
      caml_call1(Bin_prot_Shape[4][1], "src/protocol_version_header.ml:10:0"),
    group = caml_call2(Bin_prot_Shape[6], _c_, _b_),
    _d_ = caml_call1(Bin_prot_Shape[2][1], cst_t),
    bin_shape_t = caml_call1(caml_call2(Bin_prot_Shape[14], group, _d_), 0);
   function bin_size_t(v){
    return caml_call2(Bounded_list_in_case_someone_s[2], Core[345], v);
   }
   function bin_write_t(buf, pos, v){
    return caml_call3
            (caml_call1(Bounded_list_in_case_someone_s[3], Core[346]),
             buf,
             pos,
             v);
   }
   var bin_writer_t = [0, bin_size_t, bin_write_t];
   function bin_read_t(buf, pos_ref, vint){
    return caml_call3
            (caml_call1(Bounded_list_in_case_someone_s[5], Core[348]),
             buf,
             pos_ref,
             vint);
   }
   function bin_read_t$0(buf, pos_ref){
    return caml_call2
            (caml_call1(Bounded_list_in_case_someone_s[4], Core[348]),
             buf,
             pos_ref);
   }
   var
    bin_reader_t = [0, bin_read_t$0, bin_read_t],
    bin_t = [0, bin_shape_t, bin_writer_t, bin_reader_t],
    _e_ = [0, "versions"],
    _f_ = [0, "protocols"],
    cst_Protocol_version_header_ne =
      "[Protocol_version_header.negotiate]: multiple magic numbers seen.",
    _g_ = [0, "protocol"],
    _h_ = [0, "peer_versions"],
    _i_ = [0, cst_us_versions],
    cst_Protocol_version_header_ne$0 =
      "[Protocol_version_header.negotiate]: no shared version numbers",
    _j_ = [0, cst_peer_protocol],
    _k_ = [0, cst_us_protocol],
    cst_Protocol_version_header_ne$1 = cst_Protocol_version_header_ne$3,
    _l_ = [0, "Unknown"],
    _m_ = [0, cst_peer_protocol],
    _n_ = [0, cst_us_protocol],
    cst_Protocol_version_header_ne$2 = cst_Protocol_version_header_ne$3,
    _o_ = [0, cst_us_versions],
    cst_No_magic_numbers_seen = "No magic numbers seen";
   function t_of_sexp(x_002){
    return caml_call2(Bounded_list_in_case_someone_s[9], Core[357], x_002);
   }
   function sexp_of_t(x_003){
    return caml_call2(Bounded_list_in_case_someone_s[10], Core[356], x_003);
   }
   function create_exn(protocol, supported_versions){
    var
     _U_ =
       [0,
        caml_call1(Protocol_version_header_Known_[5], protocol),
        supported_versions];
    return caml_call1(Bounded_list_in_case_someone_s[11], _U_);
   }
   function get_protocol(t){
    var
     match =
       caml_call2
        (Core_List[53],
         t,
         function(v){
          var
           match =
             caml_call2(Core_Map[38], Protocol_version_header_Known_[6], v);
          if(! match) return [1, v];
          var p = match[1];
          return [0, p];
         }),
     versions = match[2],
     protocols = match[1];
    if(! protocols)
     return [0, [0, 0, caml_call1(Core_Int[102][57], versions)]];
    if(protocols[2]){
     var
      _R_ =
        [0,
         [1, [0, _e_, [0, caml_call2(Core[421], Core[356], versions), 0]]],
         0],
      _S_ =
        [0,
         [1,
          [0,
           _f_,
           [0,
            caml_call2
             (Core[421], Protocol_version_header_Known_[4], protocols),
            0]]],
         _R_],
      _T_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Protocol_version_header_ne),
          _S_]];
     return caml_call1(Core_Or_error[40], _T_);
    }
    var p = protocols[1];
    return [0, [0, [0, p], caml_call1(Core_Int[102][57], versions)]];
   }
   function negotiate(allow_legacy_peer, us, peer){
    var _y_ = get_protocol(us);
    return caml_call2
            (Base_Or_error[25][4][2],
             _y_,
             function(param){
              var
               us_versions = param[2],
               us_protocol = param[1],
               _z_ = get_protocol(peer);
              return caml_call2
                      (Base_Or_error[25][4][2],
                       _z_,
                       function(param){
                        var peer_versions = param[2], peer_protocol = param[1];
                        function _A_(us_protocol){
                         function _E_(peer_protocol){
                          var
                           _I_ =
                             0
                              ===
                               caml_call2
                                (Protocol_version_header_Known_[1],
                                 us_protocol,
                                 peer_protocol)
                              ? 1
                              : 0;
                          if(! _I_){
                           var
                            _O_ =
                              [0,
                               [1,
                                [0,
                                 _j_,
                                 [0,
                                  caml_call1(Protocol_version_header_Known_[4], peer_protocol),
                                  0]]],
                               0],
                            _P_ =
                              [0,
                               [1,
                                [0,
                                 _k_,
                                 [0,
                                  caml_call1(Protocol_version_header_Known_[4], us_protocol),
                                  0]]],
                               _O_],
                            _Q_ =
                              [1,
                               [0,
                                caml_call1
                                 (Sexplib0_Sexp_conv[7], cst_Protocol_version_header_ne$1),
                                _P_]];
                           return caml_call1(Core_Or_error[40], _Q_);
                          }
                          var
                           _J_ = caml_call2(Core_Set[15], us_versions, peer_versions),
                           match = caml_call1(Core_Set[59], _J_);
                          if(match){var version = match[1]; return [0, version];}
                          var
                           _K_ =
                             [0,
                              [1,
                               [0,
                                _g_,
                                [0,
                                 caml_call1(Protocol_version_header_Known_[4], us_protocol),
                                 0]]],
                              0],
                           _L_ =
                             [0,
                              [1,
                               [0,
                                _h_,
                                [0, caml_call1(Core_Int[102][75], peer_versions), 0]]],
                              _K_],
                           _M_ =
                             [0,
                              [1,
                               [0, _i_, [0, caml_call1(Core_Int[102][75], us_versions), 0]]],
                              _L_],
                           _N_ =
                             [1,
                              [0,
                               caml_call1
                                (Sexplib0_Sexp_conv[7], cst_Protocol_version_header_ne$0),
                               _M_]];
                          return caml_call1(Core_Or_error[40], _N_);
                         }
                         if(peer_protocol)
                          var
                           x = peer_protocol[1],
                           _F_ = caml_call1(Base_Or_error[25][1], x);
                         else if(allow_legacy_peer)
                          var _F_ = caml_call1(Base_Or_error[25][1], us_protocol);
                         else
                          var
                           _G_ =
                             [0,
                              [1,
                               [0,
                                _n_,
                                [0,
                                 caml_call1(Protocol_version_header_Known_[4], us_protocol),
                                 0]]],
                              [0, [1, [0, _m_, [0, _l_, 0]]], 0]],
                           _H_ =
                             [1,
                              [0,
                               caml_call1
                                (Sexplib0_Sexp_conv[7], cst_Protocol_version_header_ne$2),
                               _G_]],
                           _F_ = caml_call1(Core_Or_error[40], _H_);
                         return caml_call2(Base_Or_error[25][4][2], _F_, _E_);
                        }
                        if(us_protocol)
                         var
                          x = us_protocol[1],
                          _B_ = caml_call1(Base_Or_error[25][1], x);
                        else
                         var
                          _C_ =
                            [0,
                             [1,
                              [0, _o_, [0, caml_call1(Core_Int[102][75], us_versions), 0]]],
                             0],
                          _D_ =
                            [1,
                             [0,
                              caml_call1(Sexplib0_Sexp_conv[7], cst_No_magic_numbers_seen),
                              _C_]],
                          _B_ = caml_call1(Core[233], _D_);
                        return caml_call2(Base_Or_error[25][4][2], _B_, _A_);
                       });
             });
   }
   function matches_magic_prefix(t, protocol){
    var
     magic_number = caml_call1(Protocol_version_header_Known_[5], protocol);
    return caml_call3(Core_List[6], t, magic_number, Core_Int[90]);
   }
   function contains_magic_prefix(protocol){
    return caml_call2
            (Bin_prot_Type_class[159],
             function(_x_){return matches_magic_prefix(_x_, protocol);},
             bin_t[3]);
   }
   function f(t){
    return caml_call2
            (Core_List[16],
             Protocol_version_header_Known_[2],
             function(protocol){return matches_magic_prefix(t, protocol);});
   }
   var
    any_magic_prefix = caml_call2(Bin_prot_Type_class[159], f, bin_t[3]),
    _p_ = Core[344],
    _q_ = [0, [0, caml_call1(Bin_prot_Shape[2][1], cst_t), 0, _p_], 0],
    _r_ =
      caml_call1(Bin_prot_Shape[4][1], "src/protocol_version_header.ml:99:2"),
    group$0 = caml_call2(Bin_prot_Shape[6], _r_, _q_),
    _s_ = caml_call1(Bin_prot_Shape[2][1], cst_t);
   caml_call1(caml_call2(Bin_prot_Shape[14], group$0, _s_), 0);
   var
    bin_size_t$0 = Core[345],
    _t_ = Protocol_version_header_Known_[7],
    any_magic_prefix_from_six_byte =
      caml_call1(bin_size_t$0, Bounded_list_in_case_someone_s[12]) + _t_ | 0;
   function bin_read_t$1(buf, pos_ref){
    caml_call2(Bin_prot_Read[7], buf, pos_ref);
    return caml_call2(Bin_prot_Read[6], buf, pos_ref);
   }
   var
    bin_reader_t$0 = [0, bin_read_t$1, Core_Int[74]],
    any_magic_prefix_from_six_byte$0 =
      caml_call2
       (Bin_prot_Type_class[159],
        function(magic_number){
         return caml_call1
                 (caml_call1(Core_Map[38], Protocol_version_header_Known_[6]),
                  magic_number);
        },
        bin_reader_t$0),
    _u_ = [0, cst_src_protocol_version_heade, 147, 2],
    _v_ = [0, cst_src_protocol_version_heade, 146, 2],
    _w_ = [0, cst_src_protocol_version_heade, 145, 2];
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     "bin sizes are not changed by accident",
     0,
     cst_src_protocol_version_heade,
     137,
     0,
     737,
     function(param){
      var
       bounded_list_bin_size =
         caml_call1(Core_Int[71], Bounded_list_in_case_someone_s[12]);
      if(! caml_call2(Core[90], bounded_list_bin_size, 1))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
      if
       (!
        caml_call2
         (Core[90],
          6,
          Protocol_version_header_Known_[7] + bounded_list_bin_size | 0))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
      if
       (caml_call2
         (Core[90],
          any_magic_prefix_from_six_byte,
          Protocol_version_header_Known_[7] + bounded_list_bin_size | 0))
       return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _u_], 1);
     });
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_protocol_version_header);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Protocol_version_header);
   var
    Protocol_version_header =
      [0,
       bin_size_t,
       bin_write_t,
       bin_read_t$0,
       bin_read_t,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       t_of_sexp,
       sexp_of_t,
       create_exn,
       negotiate,
       contains_magic_prefix,
       any_magic_prefix,
       any_magic_prefix_from_six_byte$0,
       any_magic_prefix_from_six_byte,
       [0, Protocol_version_header_List_w[1]]];
   runtime.caml_register_global
    (55, Protocol_version_header, cst_Protocol_version_header);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcm90b2NvbF92ZXJzaW9uX2hlYWRlci5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsicG9zIiwiYWxsIiwiZXJyb3Jfc291cmNlXzAwNSIsInJldGlyZWRfa3JiX3dvcmQiLCJjb21wYXJlIiwidF9vZl9zZXhwIiwic2V4cF8wMDYiLCJzZXhwX29mX3QiLCJncm91cCIsIm1hZ2ljX3dvcmQiLCJtYWdpY19udW1iZXJfYmluX3NpemUiLCJnZW5fbWFnaWNfbnVtYmVyIiwid29yZCIsImFjYyIsImMiLCJtYWdpY19udW1iZXIiLCJ0IiwicCIsImJ5X21hZ2ljX251bWJlciIsIm1hZ2ljX3dvcmRzIiwibWFnaWNfbnVtYmVycyIsIm4iLCJtYWdpY19udW1iZXIkMCIsInNpemUiLCJzZXhwaWZpZXIiLCJjb21wYXJhdG9yIiwiYV8wMDciLCJiXzAwOCIsImJpbl9zaGFwZV90IiwiYSIsImJpbl9zaXplX3QiLCJzaXplX29mX2EiLCJ2IiwiYmluX3dyaXRlX3QiLCJ3cml0ZV9hIiwiYnVmIiwiYmluX3dyaXRlcl90IiwiYmluX3dyaXRlcl9hIiwiYmluX3JlYWRfdCIsImJpbl9yZWFkX3QkMCIsImJpbl9yZWFkX2VsIiwicG9zX3JlZiIsImV4biQwIiwiZXhuIiwiYmluX3JlYWRlcl90IiwiYmluX3JlYWRlcl9hIiwiYmluX3QiLCJiaW5fYSIsIm9mX2xpc3RfZXhuIiwibCIsImxlbiIsInRfb2ZfYSIsInNleHAiLCJjb250ZXh0IiwidmludCIsInhfMDAyIiwieF8wMDMiLCJjcmVhdGVfZXhuIiwicHJvdG9jb2wiLCJzdXBwb3J0ZWRfdmVyc2lvbnMiLCJnZXRfcHJvdG9jb2wiLCJ2ZXJzaW9ucyIsInByb3RvY29scyIsIm5lZ290aWF0ZSIsImFsbG93X2xlZ2FjeV9wZWVyIiwidXMiLCJwZWVyIiwidXNfdmVyc2lvbnMiLCJ1c19wcm90b2NvbCIsInBlZXJfdmVyc2lvbnMiLCJwZWVyX3Byb3RvY29sIiwidmVyc2lvbiIsIngiLCJtYXRjaGVzX21hZ2ljX3ByZWZpeCIsImNvbnRhaW5zX21hZ2ljX3ByZWZpeCIsImYiLCJhbnlfbWFnaWNfcHJlZml4IiwiZ3JvdXAkMCIsImJpbl9zaXplX3QkMCIsImFueV9tYWdpY19wcmVmaXhfZnJvbV9zaXhfYnl0ZSIsImJpbl9yZWFkX3QkMSIsImJpbl9yZWFkZXJfdCQwIiwiYW55X21hZ2ljX3ByZWZpeF9mcm9tX3NpeF9ieXRlJDAiLCJib3VuZGVkX2xpc3RfYmluX3NpemUiXSwic291cmNlcyI6WyIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL3Byb3RvY29sX3ZlcnNpb25faGVhZGVyL2tub3duX3Byb3RvY29sLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9wcm90b2NvbF92ZXJzaW9uX2hlYWRlci9saXN0X3dpdGhfbWF4X2xlbi5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvcHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIvcHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7O0lBaURlQTs7SUEvQ2ZDO0lBQUFDO0lBd0JJQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F4Qko7SUFBQUM7Ozs7R0FBQSxTQUFBQyxVQUFBQztJQUFBOztjQUFBQTtnQkFBQUE7Ozs7Ozs7Ozs7UUFBQTs7T0FBQTs7TUFBQTs7ZUFBQUE7O01BQUEsT0FBQTs0Q0FBQUosa0JBQUFJOzs7TUFBQSxPQUFBOzRDQUFBSixrQkFBQUk7Ozs7Ozs7Ozs7O09BQUEsT0FBQTs2Q0FBQUosa0JBQUFJOztNQUFBLE9BQUE7NENBQUFKLGtCQUFBSTs7S0FBQSxPQUFBOzJDQUFBSixrQkFBQUk7O0lBQUEsT0FBQSx3Q0FBQUosa0JBQUFJO0dBSTZDO1lBSjdDQztJQUFBLHNCQUNFLG1C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QUtNO0lBQ3FCLDZCQUQxQk4sS0FBS007SUFFbEIsT0FBQSw2QkFGYU4sS0FBS007R0FFcUI7R0FJdkM7SUFERXdDLHFCQUxBRDtJQVVGRTtNQUNGOztpQkFDT25FO1NBQWdCLE9BQUE7a0JBQUE7a0JBQWhCQTtRQUFzRTtRQVB6RWtFOzs7Ozs7Ozs7Ozs7OztNQXVCRjtPQURFRTtTQUNGO01BRUssS0FBQSxxQkFISEE7T0FHSixNQUFBO01BQ087O1FBQUE7Ozs4Q0FKSEE7T0FJSixNQUFBO01BQ087UUFBQTs7VUFoQkxKOzhDQVdFSTs7TUFLSixNQUFBOzs7Ozs7Ozs7T0F6SUZyRDtPQUFBRztPQUFBTTtPQUFBRDtPQUFLVjtPQUFMUTtPQUFBUTtPQUFBRTtPQUFBekM7T0FBQUU7T0FHSWtEO09BeUJBTTtPQWlEQVc7T0FJQUU7T0FrQ0FNO09BTUFIOzs7OztFIiwic291cmNlc0NvbnRlbnQiOlsib3BlbiEgQ29yZVxuXG50eXBlIHQgPVxuICB8IEtyYlxuICB8IEtyYl90ZXN0X21vZGVcbiAgfCBScGNcbltAQGRlcml2aW5nIGNvbXBhcmUsIGVudW1lcmF0ZSwgc2V4cCwgYmluX2lvXVxuXG5sZXQgbWFnaWNfd29yZCA9IGZ1bmN0aW9uXG4gIHwgS3JiIC0+IFwiS1JCMlwiXG4gIHwgS3JiX3Rlc3RfbW9kZSAtPiBcIktCVFwiXG4gIHwgUnBjIC0+IFwiUlBDXCJcbjs7XG5cbmxldCBtYWdpY19udW1iZXJfYmluX3NpemUgPSA1XG5cbmxldCBnZW5fbWFnaWNfbnVtYmVyIHdvcmQgPVxuICBTdHJpbmcudG9fbGlzdF9yZXYgd29yZFxuICB8PiBMaXN0LmZvbGQgfmluaXQ6MCB+ZjooZnVuIGFjYyBjIC0+IChhY2MgKiAyNTYpICsgQ2hhci50b19pbnQgYylcbjs7XG5cbmxldCBtYWdpY19udW1iZXIgdCA9IGdlbl9tYWdpY19udW1iZXIgKG1hZ2ljX3dvcmQgdClcbmxldCBieV9tYWdpY19udW1iZXIgPSBJbnQuTWFwLm9mX2FsaXN0X2V4biAoTGlzdC5tYXAgYWxsIH5mOihmdW4gcCAtPiBtYWdpY19udW1iZXIgcCwgcCkpXG5cbigqIFdlIG9uY2UgbWludGVkIGEgbmV3IG1hZ2ljIG51bWJlciBmb3IgS3JiIGluIG9yZGVyIHRvIGNoYW5nZSB0aGUgcHJvdG9jb2xcbiAgIG5lZ290aWF0aW9uLiAgTGV0J3MgYmUgY2FyZWZ1bCB0aGF0IHdlIGRvbid0IHJldXNlIHRoZSBvbGQgbWFnaWMgbnVtYmVyICopXG5sZXQgcmV0aXJlZF9rcmJfd29yZCA9IFwiS1JCXCJcblxubGV0JXRlc3RfdW5pdCBcInZhbGlkYXRlIG1hZ2ljIHdvcmRzXCIgPVxuICBsZXQgbWFnaWNfd29yZHMgPSByZXRpcmVkX2tyYl93b3JkIDo6IExpc3QubWFwIGFsbCB+ZjptYWdpY193b3JkIGluXG4gIGxldCBtYWdpY19udW1iZXJzID0gTGlzdC5tYXAgbWFnaWNfd29yZHMgfmY6Z2VuX21hZ2ljX251bWJlciBpblxuICAoKiBNYWdpYyBudW1iZXJzIG11c3QgZml0IGludG8gT2NhbWwgaW50ZWdlcnMgKDMxIGJpdHMgb24gMzIgYml0IGJ1aWxkcykuICopXG4gIGFzc2VydCAoTGlzdC5mb3JfYWxsIG1hZ2ljX251bWJlcnMgfmY6KGZ1biBuIC0+IG4gPD0gSW50Lm9mX2Zsb2F0ICgoMi4gKiogMzAuKSAtLiAxLikpKTtcbiAgKCogTm8gZHVwbGljYXRlIG1hZ2ljIG51bWJlcnMgKilcbiAgYXNzZXJ0IChub3QgKExpc3QuY29udGFpbnNfZHVwIG1hZ2ljX251bWJlcnMgfmNvbXBhcmU6SW50LmNvbXBhcmUpKVxuOztcblxuKCogRW5zdXJlIHRlc3RzIGJyZWFrIGlmIHRoZSBtYWdpYyBudW1iZXJzIGFyZSBjaGFuZ2VkICopXG5sZXQldGVzdF91bml0IFwibWFnaWMgbnVtYmVyc1wiID1cbiAgYXNzZXJ0IChnZW5fbWFnaWNfbnVtYmVyIHJldGlyZWRfa3JiX3dvcmQgPSA0XzM0Nl80NDMpO1xuICBhc3NlcnQgKG1hZ2ljX251bWJlciBLcmIgPSA4NDNfMjA3XzI0Myk7XG4gIGFzc2VydCAobWFnaWNfbnVtYmVyIEtyYl90ZXN0X21vZGUgPSA1XzUyMV85OTUpO1xuICBhc3NlcnQgKG1hZ2ljX251bWJlciBScGMgPSA0XzQxMV80NzQpXG47O1xuXG5sZXQldGVzdF91bml0IFwibWFnaWNfbnVtYmVyX2Jpbl9zaXplIGlzIGNvcnJlY3RcIiA9XG4gIExpc3QuaXRlciBhbGwgfmY6KGZ1biB0IC0+XG4gICAgbGV0IG1hZ2ljX251bWJlciA9IG1hZ2ljX251bWJlciB0IGluXG4gICAgbGV0IHNpemUgPSBJbnQuYmluX3NpemVfdCBtYWdpY19udW1iZXIgaW5cbiAgICBbJXRlc3RfZXE6IGludF0gc2l6ZSBtYWdpY19udW1iZXJfYmluX3NpemUpXG47O1xuIiwib3BlbiEgQ29yZVxuaW5jbHVkZSBMaXN0X3dpdGhfbWF4X2xlbl9pbnRmXG5cbm1vZHVsZSBNYWtlIChDb25maWcgOiBDb25maWcpID0gc3RydWN0XG4gIGluY2x1ZGUgQ29uZmlnXG5cbiAgdHlwZSAnYSB0ID0gJ2EgbGlzdCBbQEBkZXJpdmluZyBiaW5fc2hhcGUsIGJpbl93cml0ZV1cblxuICBsZXQgX19iaW5fcmVhZF90X18gPSBMaXN0Ll9fYmluX3JlYWRfdF9fXG5cbiAgbGV0IGJpbl9yZWFkX3QgYmluX3JlYWRfZWwgYnVmIH5wb3NfcmVmID1cbiAgICB0cnkgQmluX3Byb3QuUmVhZC5iaW5fcmVhZF9saXN0X3dpdGhfbWF4X2xlbiB+bWF4X2xlbiBiaW5fcmVhZF9lbCBidWYgfnBvc19yZWYgd2l0aFxuICAgIHwgZXhuIC0+IEV4bi5yZXJhaXNlIGV4biAoSW5mby50b19zdHJpbmdfaHVtIGNvbnRleHQpXG4gIDs7XG5cbiAgbGV0IGJpbl9yZWFkZXJfdCAoYmluX3JlYWRlcl9hIDogJ2EgQmluX3Byb3QuVHlwZV9jbGFzcy5yZWFkZXIpID1cbiAgICB7IEJpbl9wcm90LlR5cGVfY2xhc3MucmVhZCA9IGJpbl9yZWFkX3QgYmluX3JlYWRlcl9hLnJlYWRcbiAgICA7IHZ0YWdfcmVhZCA9IF9fYmluX3JlYWRfdF9fIGJpbl9yZWFkZXJfYS5yZWFkXG4gICAgfVxuICA7O1xuXG4gIGxldCBiaW5fdCAoYmluX2EgOiAnYSBCaW5fcHJvdC5UeXBlX2NsYXNzLnQpID1cbiAgICB7IEJpbl9wcm90LlR5cGVfY2xhc3Muc2hhcGUgPSBiaW5fc2hhcGVfdCBiaW5fYS5zaGFwZVxuICAgIDsgd3JpdGVyID0gYmluX3dyaXRlcl90IGJpbl9hLndyaXRlclxuICAgIDsgcmVhZGVyID0gYmluX3JlYWRlcl90IGJpbl9hLnJlYWRlclxuICAgIH1cbiAgOztcblxuICBsZXQgb2ZfbGlzdF9leG4gbCA9XG4gICAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIGwgaW5cbiAgICBpZiBsZW4gPiBtYXhfbGVuXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2UgXCJMaXN0IGlzIHRvbyBsYXJnZVwiIChjb250ZXh0IDogSW5mby50KSAobGVuIDogaW50KSAobWF4X2xlbiA6IGludCldO1xuICAgIGxcbiAgOztcblxuICBsZXQgc2V4cF9vZl90ID0gTGlzdC5zZXhwX29mX3RcblxuICBsZXQgdF9vZl9zZXhwIHRfb2ZfYSBzZXhwID1cbiAgICBsZXQgdCA9IExpc3QudF9vZl9zZXhwIHRfb2ZfYSBzZXhwIGluXG4gICAgb2ZfbGlzdF9leG4gdFxuICA7O1xuZW5kXG4iLCJvcGVuISBDb3JlXG5tb2R1bGUgS25vd25fcHJvdG9jb2wgPSBLbm93bl9wcm90b2NvbFxuXG5tb2R1bGUgQm91bmRlZF9saXN0X2luX2Nhc2Vfc29tZW9uZV9zZW5kc19nYXJiYWdlX29uX3RoZV93aXJlID1cbiAgTGlzdF93aXRoX21heF9sZW4uTWFrZSAoc3RydWN0XG4gICAgbGV0IG1heF9sZW4gPSAxMDBcbiAgICBsZXQgY29udGV4dCA9IEluZm8ub2Zfc3RyaW5nIFwiUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXJcIlxuICBlbmQpXG5cbnR5cGUgdCA9IGludCBCb3VuZGVkX2xpc3RfaW5fY2FzZV9zb21lb25lX3NlbmRzX2dhcmJhZ2Vfb25fdGhlX3dpcmUudFxuW0BAZGVyaXZpbmcgYmluX2lvLCBzZXhwXVxuXG5sZXQgY3JlYXRlX2V4biB+cHJvdG9jb2wgfnN1cHBvcnRlZF92ZXJzaW9ucyA9XG4gIEtub3duX3Byb3RvY29sLm1hZ2ljX251bWJlciBwcm90b2NvbCA6OiBzdXBwb3J0ZWRfdmVyc2lvbnNcbiAgfD4gQm91bmRlZF9saXN0X2luX2Nhc2Vfc29tZW9uZV9zZW5kc19nYXJiYWdlX29uX3RoZV93aXJlLm9mX2xpc3RfZXhuXG47O1xuXG5sZXQgZ2V0X3Byb3RvY29sICh0IDogdCkgPVxuICBsZXQgcHJvdG9jb2xzLCB2ZXJzaW9ucyA9XG4gICAgTGlzdC5wYXJ0aXRpb25fbWFwXG4gICAgICAodCA6PiBpbnQgbGlzdClcbiAgICAgIH5mOihmdW4gdiAtPlxuICAgICAgICBtYXRjaCBNYXAuZmluZCBLbm93bl9wcm90b2NvbC5ieV9tYWdpY19udW1iZXIgdiB3aXRoXG4gICAgICAgIHwgU29tZSBwIC0+IEZpcnN0IHBcbiAgICAgICAgfCBOb25lIC0+IFNlY29uZCB2KVxuICBpblxuICBtYXRjaCBwcm90b2NvbHMgd2l0aFxuICB8IFtdIC0+IE9rIChOb25lLCBJbnQuU2V0Lm9mX2xpc3QgdmVyc2lvbnMpXG4gIHwgWyBwIF0gLT4gT2sgKFNvbWUgcCwgSW50LlNldC5vZl9saXN0IHZlcnNpb25zKVxuICB8IF8gLT5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJbUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIubmVnb3RpYXRlXTogbXVsdGlwbGUgbWFnaWMgbnVtYmVycyBzZWVuLlwiXG4gICAgICAgICAgKHByb3RvY29scyA6IEtub3duX3Byb3RvY29sLnQgbGlzdClcbiAgICAgICAgICAodmVyc2lvbnMgOiBpbnQgbGlzdCldXG47O1xuXG5sZXQgbmVnb3RpYXRlIH5hbGxvd19sZWdhY3lfcGVlciB+KHVzIDogdCkgfihwZWVyIDogdCkgPVxuICBsZXQgb3BlbiBPcl9lcnJvci5MZXRfc3ludGF4IGluXG4gIGxldCViaW5kIHVzX3Byb3RvY29sLCB1c192ZXJzaW9ucyA9IGdldF9wcm90b2NvbCB1cyBpblxuICBsZXQlYmluZCBwZWVyX3Byb3RvY29sLCBwZWVyX3ZlcnNpb25zID0gZ2V0X3Byb3RvY29sIHBlZXIgaW5cbiAgbGV0JWJpbmQgdXNfcHJvdG9jb2wgPVxuICAgIG1hdGNoIHVzX3Byb3RvY29sIHdpdGhcbiAgICB8IFNvbWUgeCAtPiByZXR1cm4geFxuICAgIHwgTm9uZSAtPiBlcnJvcl9zIFslbWVzc2FnZSBcIk5vIG1hZ2ljIG51bWJlcnMgc2VlblwiICh1c192ZXJzaW9ucyA6IEludC5TZXQudCldXG4gIGluXG4gIGxldCViaW5kIHBlZXJfcHJvdG9jb2wgPVxuICAgIG1hdGNoIHBlZXJfcHJvdG9jb2wgd2l0aFxuICAgIHwgU29tZSB4IC0+IHJldHVybiB4XG4gICAgfCBOb25lIC0+XG4gICAgICAoKiB3ZSBhc3N1bWUgcGVlciBpcyBzcGVha2luZyBvdXIgcHJvdG9jb2wgaWYgW2FsbG93X2xlZ2FjeV9wZWVyXSAqKVxuICAgICAgaWYgYWxsb3dfbGVnYWN5X3BlZXJcbiAgICAgIHRoZW4gcmV0dXJuIHVzX3Byb3RvY29sXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHBlZXJfcHJvdG9jb2wgPSBgVW5rbm93biBpblxuICAgICAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICBcIltQcm90b2NvbF92ZXJzaW9uX2hlYWRlci5uZWdvdGlhdGVdOiBjb25mbGljdGluZyBtYWdpYyBwcm90b2NvbCBudW1iZXJzXCJcbiAgICAgICAgICAgICAgKHVzX3Byb3RvY29sIDogS25vd25fcHJvdG9jb2wudClcbiAgICAgICAgICAgICAgKHBlZXJfcHJvdG9jb2wgOiBbIGBVbmtub3duIF0pXSlcbiAgaW5cbiAgaWYgbm90IChbJWNvbXBhcmUuZXF1YWw6IEtub3duX3Byb3RvY29sLnRdIHVzX3Byb3RvY29sIHBlZXJfcHJvdG9jb2wpXG4gIHRoZW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJbUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIubmVnb3RpYXRlXTogY29uZmxpY3RpbmcgbWFnaWMgcHJvdG9jb2wgbnVtYmVyc1wiXG4gICAgICAgICAgKHVzX3Byb3RvY29sIDogS25vd25fcHJvdG9jb2wudClcbiAgICAgICAgICAocGVlcl9wcm90b2NvbCA6IEtub3duX3Byb3RvY29sLnQpXVxuICBlbHNlIChcbiAgICBsZXQgcHJvdG9jb2wgPSB1c19wcm90b2NvbCBpblxuICAgIG1hdGNoIFNldC5tYXhfZWx0IChTZXQuaW50ZXIgdXNfdmVyc2lvbnMgcGVlcl92ZXJzaW9ucykgd2l0aFxuICAgIHwgU29tZSB2ZXJzaW9uIC0+IE9rIHZlcnNpb25cbiAgICB8IE5vbmUgLT5cbiAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJbUHJvdG9jb2xfdmVyc2lvbl9oZWFkZXIubmVnb3RpYXRlXTogbm8gc2hhcmVkIHZlcnNpb24gbnVtYmVyc1wiXG4gICAgICAgICAgICAodXNfdmVyc2lvbnMgOiBJbnQuU2V0LnQpXG4gICAgICAgICAgICAocGVlcl92ZXJzaW9ucyA6IEludC5TZXQudClcbiAgICAgICAgICAgIChwcm90b2NvbCA6IEtub3duX3Byb3RvY29sLnQpXSlcbjs7XG5cbmxldCBtYXRjaGVzX21hZ2ljX3ByZWZpeCAodCA6IHQpIH5wcm90b2NvbCA9XG4gIGxldCBtYWdpY19udW1iZXIgPSBLbm93bl9wcm90b2NvbC5tYWdpY19udW1iZXIgcHJvdG9jb2wgaW5cbiAgTGlzdC5tZW0gfmVxdWFsOkludC5lcXVhbCAodCA6PiBpbnQgbGlzdCkgbWFnaWNfbnVtYmVyXG47O1xuXG5sZXQgY29udGFpbnNfbWFnaWNfcHJlZml4IH5wcm90b2NvbCA9XG4gIEJpbl9wcm90LlR5cGVfY2xhc3MuY252X3JlYWRlciAobWF0Y2hlc19tYWdpY19wcmVmaXggfnByb3RvY29sKSBiaW5fdC5yZWFkZXJcbjs7XG5cbmxldCBhbnlfbWFnaWNfcHJlZml4ID1cbiAgbGV0IGYgdCA9XG4gICAgTGlzdC5maW5kIEtub3duX3Byb3RvY29sLmFsbCB+ZjooZnVuIHByb3RvY29sIC0+IG1hdGNoZXNfbWFnaWNfcHJlZml4IH5wcm90b2NvbCB0KVxuICBpblxuICBCaW5fcHJvdC5UeXBlX2NsYXNzLmNudl9yZWFkZXIgZiBiaW5fdC5yZWFkZXJcbjs7XG5cbm1vZHVsZSBNYWdpY19wcmVmaXhfYmluX3JlcHIgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50IFtAQGRlcml2aW5nIGJpbl9zaGFwZSwgYmluX3dyaXRlXVxuXG4gICgqIFRoZSBiaW4gcHJvdCByZXByZXNlbnRhdGlvbiBvZiBhIHByb3RvY29sIHZlcnNpb24gaGVhZGVyIGlzIHRoZSBzdGFuZGFyZFxuICAgICByZXByZXNlbnRhdGlvbiBmb3IgYW4gaW50IGxpc3Q6XG5cbiAgICAgfCBuYXQwIGluZGljYXRpbmcgc2l6ZSB8IGVsZW1lbnQgMCB8IGVsZW1lbnQgMSB8IC4uLlxuXG4gICAgIFtjcmVhdGVfZXhuXSB3aWxsIGFsd2F5cyBwdXQgdGhlIGtub3duIHByb3RvY29sIG1hZ2ljIG51bWJlciBhcyBcImVsZW1lbnQgMFwiLlxuXG4gICAgIFRoZSBiaW4gc2l6ZSBvZiBcIm5hdDAgaW5kaWNhdGluZyBzaXplXCIgYW5kIFwiZWxlbWVudCAwXCIgaXMgZml4ZWQgKHRoZXJlIGFyZSBleHBlY3RcbiAgICAgdGVzdHMgdG8gbWFrZSBzdXJlIHdlIG5ldmVyIGNoYW5nZSB0aGVtKS4gKilcbiAgbGV0IGJpbl9zaXplID1cbiAgICBiaW5fc2l6ZV90IEJvdW5kZWRfbGlzdF9pbl9jYXNlX3NvbWVvbmVfc2VuZHNfZ2FyYmFnZV9vbl90aGVfd2lyZS5tYXhfbGVuXG4gICAgKyBLbm93bl9wcm90b2NvbC5tYWdpY19udW1iZXJfYmluX3NpemVcbiAgOztcblxuICBsZXQgYmluX3JlYWRfdCBidWYgfnBvc19yZWYgPVxuICAgIGxldCAoX2xpc3RfbGVuZ3RoIDogQmluX3Byb3QuTmF0MC50KSA9IEJpbl9wcm90LlJlYWQuYmluX3JlYWRfbmF0MCBidWYgfnBvc19yZWYgaW5cbiAgICBCaW5fcHJvdC5SZWFkLmJpbl9yZWFkX2ludCBidWYgfnBvc19yZWZcbiAgOztcblxuICBsZXQgYmluX3JlYWRlcl90ID1cbiAgICB7IEJpbl9wcm90LlR5cGVfY2xhc3MucmVhZCA9IGJpbl9yZWFkX3Q7IHZ0YWdfcmVhZCA9IEludC5fX2Jpbl9yZWFkX3RfXyB9XG4gIDs7XG5lbmRcblxubGV0IGFueV9tYWdpY19wcmVmaXhfZnJvbV9zaXhfYnl0ZXMgPVxuICBCaW5fcHJvdC5UeXBlX2NsYXNzLmNudl9yZWFkZXJcbiAgICAoZnVuIG1hZ2ljX251bWJlciAtPiAoTWFwLmZpbmQgS25vd25fcHJvdG9jb2wuYnlfbWFnaWNfbnVtYmVyKSBtYWdpY19udW1iZXIpXG4gICAgTWFnaWNfcHJlZml4X2Jpbl9yZXByLmJpbl9yZWFkZXJfdFxuOztcblxubGV0IGFueV9tYWdpY19wcmVmaXhfZnJvbV9zaXhfYnl0ZXNfYmluX3NpemUgPSBNYWdpY19wcmVmaXhfYmluX3JlcHIuYmluX3NpemVcblxubW9kdWxlIEZvcl90ZXN0ID0gc3RydWN0XG4gIG1vZHVsZSBNYWtlX2xpc3Rfd2l0aF9tYXhfbGVuID0gTGlzdF93aXRoX21heF9sZW4uTWFrZVxuZW5kXG5cbmxldCV0ZXN0X3VuaXQgXCJiaW4gc2l6ZXMgYXJlIG5vdCBjaGFuZ2VkIGJ5IGFjY2lkZW50XCIgPVxuICAoKiBFbnN1cmUgdGhlIGJpbl9zaXplIG9mIEJvdW5kZWRfbGlzdF9pbl9jYXNlX3NvbWVvbmVfc2VuZHNfZ2FyYmFnZV9vbl90aGVfd2lyZS5tYXhfbGVuXG4gICAgIGlzIGFsd2F5cyAxLiBUaGlzIG1lYW5zIHRoYXQgcmVnYXJkbGVzcyBvZiBob3cgbG9uZyB0aGUgbGlzdCBvZiB2ZXJzaW9ucyBpbiB0aGVcbiAgICAgcHJvdG9jb2wgaGVhZGVyIGlzLCB0aGUgcmVwcmVzZW50YXRpb24gd2lsbCBiZSB0aGUgc2FtZSBudW1iZXIgb2YgYnl0ZXMuIFRoZVxuICAgICByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnQganVtcHMgdG8gMyBieXRlcyBhdCB0aGUgdmFsdWUgMTI4LiAqKVxuICBsZXQgYm91bmRlZF9saXN0X2Jpbl9zaXplID1cbiAgICBJbnQuYmluX3NpemVfdCBCb3VuZGVkX2xpc3RfaW5fY2FzZV9zb21lb25lX3NlbmRzX2dhcmJhZ2Vfb25fdGhlX3dpcmUubWF4X2xlblxuICBpblxuICBhc3NlcnQgKGJvdW5kZWRfbGlzdF9iaW5fc2l6ZSA9IDEpO1xuICBhc3NlcnQgKDYgPSBLbm93bl9wcm90b2NvbC5tYWdpY19udW1iZXJfYmluX3NpemUgKyBib3VuZGVkX2xpc3RfYmluX3NpemUpO1xuICBhc3NlcnQgKFxuICAgIGFueV9tYWdpY19wcmVmaXhfZnJvbV9zaXhfYnl0ZXNfYmluX3NpemVcbiAgICA9IEtub3duX3Byb3RvY29sLm1hZ2ljX251bWJlcl9iaW5fc2l6ZSArIGJvdW5kZWRfbGlzdF9iaW5fc2l6ZSlcbjs7XG4iXX0=
