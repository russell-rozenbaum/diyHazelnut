// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1+5.8.1

//# unitInfo: Provides: Timing_wheel__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Timing_wheel = [0];
   runtime.caml_register_global(0, Timing_wheel, "Timing_wheel__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel__Import
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel_Import = "Timing_wheel__Import",
    cst_timing_wheel = "timing_wheel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel_Import);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel);
   caml_call1(Expect_test_collector[5][1], "timing_wheel/src/import.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_timing_wheel, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_timing_wheel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel_Import);
   var Timing_wheel_Import = [0];
   runtime.caml_register_global
    (11, Timing_wheel_Import, cst_Timing_wheel_Import);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel__Timing_wheel_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel_Timing_wheel_ = "Timing_wheel__Timing_wheel_intf",
    cst_timing_wheel = "timing_wheel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel_Timing_wheel_);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel);
   caml_call1
    (Expect_test_collector[5][1], "timing_wheel/src/timing_wheel_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_timing_wheel, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_timing_wheel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel_Timing_wheel_);
   var Timing_wheel_Timing_wheel_intf = [0];
   runtime.caml_register_global
    (11, Timing_wheel_Timing_wheel_intf, cst_Timing_wheel_Timing_wheel_);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Timing_wheel
//# unitInfo: Requires: Assert_failure, Base__Field, Base__Invariant, Base__Sexpable, Core, Core__Array, Core__Binable, Core__Int, Core__Int63, Core__List, Core__Time_ns, Core__Time_ns_alternate_sexp, Expect_test_collector, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Timing_wheel = "Timing_wheel",
    cst_Timing_wheel_max_alarm_tim$1 =
      "Timing_wheel.max_alarm_time_in_min_interval_exn of empty timing wheel",
    cst$0 = "_",
    cst_alarm_precision$0 = "alarm_precision",
    cst_at = "at",
    cst_bits = "bits",
    cst_bits_per_slot = "bits_per_slot",
    cst_capacity = "capacity",
    cst_config = "config",
    cst_diff_max_min_allowed_key = "diff_max_min_allowed_key",
    cst_elt_key_lower_bound = "elt_key_lower_bound",
    cst_index = "index",
    cst_interval_num = "interval_num",
    cst_key = "key",
    cst_keys_per_slot = "keys_per_slot",
    cst_length = "length",
    cst_level_bits = "level_bits",
    cst_levels = "levels",
    cst_max_allowed_alarm_time = "max_allowed_alarm_time",
    cst_max_allowed_key = "max_allowed_key",
    cst_max_interval_num = "max_interval_num",
    cst_min_allowed_key = "min_allowed_key",
    cst_min_elt = "min_elt",
    cst_min_key_in_same_slot_mask = "min_key_in_same_slot_mask",
    cst_now = "now",
    cst_now_interval_num_start = "now_interval_num_start",
    cst_pool = "pool",
    cst_priority_queue = "priority_queue",
    cst_slots = "slots",
    cst_slots_mask = "slots_mask",
    cst_start = "start",
    cst_timing_wheel = "timing_wheel",
    cst_timing_wheel_src_timing_wh = "timing_wheel/src/timing_wheel.ml",
    cst_value = "value",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    pos$9 = "timing_wheel/src/timing_wheel.ml:1631:26",
    pos$8 = "timing_wheel/src/timing_wheel.ml:1628:26",
    pos$7 = "timing_wheel/src/timing_wheel.ml:1644:26",
    pos$6 = "timing_wheel/src/timing_wheel.ml:1649:26",
    arg_108 = [0, cst$0],
    pos$5 = "timing_wheel/src/timing_wheel.ml:1006:32",
    pos$4 = "timing_wheel/src/timing_wheel.ml:1003:32",
    pos$3 = "timing_wheel/src/timing_wheel.ml:902:31",
    pos$2 = "timing_wheel/src/timing_wheel.ml:909:30",
    pos$1 = "timing_wheel/src/timing_wheel.ml:921:31",
    pos$0 = "timing_wheel/src/timing_wheel.ml:939:32",
    pos = "timing_wheel/src/timing_wheel.ml:944:30",
    cst = "",
    error_source_039 = "timing_wheel/src/timing_wheel.ml.Config.t",
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Core_Time_ns_alternate_sexp = global_data.Core__Time_ns_alternate_sexp,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Core_Time_ns = global_data.Core__Time_ns,
    Core_List = global_data.Core__List;
   global_data.Base__Field;
   var
    Core_Int63 = global_data.Core__Int63,
    Core_Array = global_data.Core__Array,
    Tuple_pool = global_data.Tuple_pool,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Int = global_data.Core__Int,
    Core_Binable = global_data.Core__Binable,
    Base_Sexpable = global_data.Base__Sexpable;
   caml_call1(Ppx_module_timer_runtime[4], cst_Timing_wheel);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_timing_wheel);
   caml_call1(Expect_test_collector[5][1], cst_timing_wheel_src_timing_wh);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_timing_wheel, cst);
   var
    max_time = Core_Time_ns_alternate_sexp[45],
    min_time = Core_Time_ns_alternate_sexp[43],
    zero = Core_Int[55],
    to_int = Core_Int[61],
    t_of_sexp = Core_Int[79],
    sexp_of_t = Core_Int[80],
    symbol = Core_Int[84],
    symbol$0 = Core_Int[85],
    symbol$1 = Core_Int[87],
    equal = Core_Int[90],
    max_num_bits = Core_Int63[58] - 1 | 0,
    min_value = 0,
    _a_ = [0, cst_timing_wheel_src_timing_wh, 83, 4],
    _b_ = [0, cst_timing_wheel_src_timing_wh, 82, 4],
    _c_ = [0, cst_timing_wheel_src_timing_wh, 114, 4],
    _d_ = [0, cst_timing_wheel_src_timing_wh, 117, 6],
    cst_Level_bits_create_exn_requ =
      "Level_bits.create_exn requires a nonempty list",
    cst_Level_bits_create_exn_got_ =
      "Level_bits.create_exn got nonpositive num bits",
    _e_ = [0, "max_num_bits"],
    _f_ = [0, "got"],
    cst_Level_bits_create_exn_got_$0 =
      "Level_bits.create_exn got too many bits";
   function invariant(t){
    if(! caml_call2(symbol, t, min_value))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if(caml_call2(symbol$0, t, max_num_bits)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function of_int(i){invariant(i); return i;}
   function symbol$2(t1, t2){var t = t1 + t2 | 0; invariant(t); return t;}
   function symbol$3(t1, t2){var t = t1 - t2 | 0; invariant(t); return t;}
   function pow2(t){return caml_call2(Core_Int63[47], Core_Int63[14], t);}
   function sexp_of_t$0(x_007){
    return caml_call2(Core[421], sexp_of_t, x_007);
   }
   function num_bits_internal(t){
    return caml_call3(Core_List[10], t, zero, symbol$2);
   }
   function num_bits(t){return num_bits_internal(t);}
   function invariant$0(t){
    if(caml_call1(Core_List[8], t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    caml_call2
     (Core_List[9],
      t,
      function(num_key_bits){
       invariant(num_key_bits);
       if(caml_call2(symbol$1, num_key_bits, zero)) return 0;
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      });
    return invariant(num_bits_internal(t));
   }
   function t_of_sexp$0(x_006){
    var t = caml_call2(Core[422], t_of_sexp, x_006);
    invariant$0(t);
    return t;
   }
   function create_exn(opt, x_008){
    if(opt)
     var sth = opt[1], extend_to_max_num_bits = sth;
    else
     var extend_to_max_num_bits = 0;
    if(caml_call1(Core_List[8], x_008))
     caml_call1(Core[6], cst_Level_bits_create_exn_requ);
    if
     (caml_call2
       (Core_List[13],
        x_008,
        function(bits){return caml_call2(Core[89], bits, 0);})){
     var
      _dS_ = [0, caml_call2(Core[421], Core[356], x_008), 0],
      _dT_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Level_bits_create_exn_got_),
          _dS_]];
     caml_call1(Core[253], _dT_);
    }
    var
     num_bits =
       caml_call3
        (Core_List[10],
         x_008,
         0,
         function(_d1_, _d0_){return _d1_ + _d0_ | 0;});
    if(caml_call2(Core[91], num_bits, max_num_bits)){
     var
      _dU_ =
        [0, [1, [0, _e_, [0, caml_call1(Core[356], max_num_bits), 0]]], 0],
      _dV_ = [0, [1, [0, _f_, [0, caml_call1(Core[356], num_bits), 0]]], _dU_],
      _dW_ = [0, caml_call2(Core[421], Core[356], x_008), _dV_],
      _dX_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Level_bits_create_exn_got_$0),
          _dW_]];
     caml_call1(Core[253], _dX_);
    }
    if(extend_to_max_num_bits)
     var
      _dY_ = caml_call1(Core[230], 1),
      _dZ_ = caml_call2(Core_List[119], max_num_bits - num_bits | 0, _dY_),
      ints = caml_call2(Core[157], x_008, _dZ_);
    else
     var ints = x_008;
    return caml_call2(Core_List[72], ints, of_int);
   }
   var
    level_bits_default =
      create_exn
       (0, [0, 11, [0, 10, [0, 10, [0, 10, [0, 10, [0, 10, [0, 1, 0]]]]]]]),
    compare = Core[352],
    cst_Alarm_precision_to_span_of =
      "[Alarm_precision.to_span] of negative power of two nanoseconds";
   function equal$0(x_012, x_013){
    return 0 === caml_call2(compare, x_012, x_013) ? 1 : 0;
   }
   function to_sexpable(t){
    if(caml_call2(Core[92], t, 0)){
     var
      _dP_ = [0, caml_call1(Core[356], t), 0],
      _dQ_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Alarm_precision_to_span_of),
          _dP_]];
     caml_call1(Core[253], _dQ_);
    }
    var _dR_ = caml_call1(caml_call1(Core_Int63[47], Core_Int63[14]), t);
    return caml_call1(Core_Time_ns[1][127], _dR_);
   }
   function sexp_of_t$1(t){
    var _dO_ = to_sexpable(t);
    return caml_call1(Core_Time_ns[1][10], _dO_);
   }
   var
    about_one_microsecond = 10,
    _g_ = [0, "span"],
    cst_Alarm_precision_of_span_fl =
      "[Alarm_precision.of_span_floor_pow2_ns] got non-positive span";
   function mul(t, pow2){return t + pow2 | 0;}
   function div(t, pow2){return t - pow2 | 0;}
   function of_span_floor_pow2_ns(span){
    if(caml_call2(Core_Time_ns[1][16], span, Core_Time_ns[1][75])){
     var
      _dL_ =
        [0, [1, [0, _g_, [0, caml_call1(Core_Time_ns[1][10], span), 0]]], 0],
      _dM_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Alarm_precision_of_span_fl),
          _dL_]];
     caml_call1(Core[253], _dM_);
    }
    var _dN_ = caml_call1(Core_Time_ns[1][126], span);
    return caml_call1(Core_Int63[86], _dN_);
   }
   var
    _h_ = Core_Time_ns[1],
    _i_ =
      caml_call1
       (caml_call1
         (Core_Binable[6], [0, _h_[5], _h_[1], _h_[2], _h_[3], _h_[4]]),
        [0, to_sexpable, of_span_floor_pow2_ns]),
    bin_size_t = _i_[1],
    bin_write_t = _i_[2],
    bin_read_t = _i_[3],
    bin_read_t$0 = _i_[4],
    bin_shape_t = _i_[5],
    bin_writer_t = _i_[6],
    bin_reader_t = _i_[7],
    bin_t = _i_[8],
    _j_ = Core_Time_ns[1],
    include =
      caml_call1
       (caml_call1(Base_Sexpable[1], [0, _j_[9], _j_[10]]),
        [0, to_sexpable, of_span_floor_pow2_ns]),
    t_of_sexp$1 = include[1],
    sexp_of_t$2 = include[2],
    _k_ =
      [0,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       compare,
       t_of_sexp$1,
       sexp_of_t$2];
   function level_bits(r){return r[2];}
   var
    level_bits$0 =
      [0,
       function(param){return 0;},
       cst_level_bits,
       0,
       level_bits,
       function(r, v){return [0, r[1], v, r[3]];}],
    _l_ = [0, cst_timing_wheel_src_timing_wh, 235, 2],
    cst_alarm_precision = cst_alarm_precision$0,
    _m_ = [0, cst_capacity],
    _n_ = [0, cst_level_bits],
    _o_ = [0, cst_alarm_precision$0],
    _p_ = [0, cst_timing_wheel_src_timing_wh, 257, 6],
    _q_ = [0, cst_timing_wheel_src_timing_wh, 256, 8261, 8285],
    _r_ = [0, 10, [0, 10, [0, 6, [0, 6, [0, 5, 0]]]]];
   function t_of_sexp$2(sexp_019){
    if(0 === sexp_019[0])
     return caml_call2
             (Sexplib0_Sexp_conv_error[16], error_source_039, sexp_019);
    var
     field_sexps_020 = sexp_019[1],
     alarm_precision_021 = [0, 0],
     level_bits_023 = [0, 0],
     capacity_025 = [0, 0],
     duplicates_027 = [0, 0],
     extra_028 = [0, 0];
    a:
    {
     b:
     c:
     d:
     {
      e:
      {
       var param = field_sexps_020;
       for(;;){
        if(! param) break;
        var sexp_019$0 = param[1];
        if(1 !== sexp_019$0[0]) break b;
        var _dI_ = sexp_019$0[1];
        if(! _dI_) break c;
        var _dJ_ = _dI_[1];
        if(0 !== _dJ_[0]) break e;
        var field_sexps_031 = _dI_[2], field_name_029 = _dJ_[1];
        if(field_sexps_031 && field_sexps_031[2]) break d;
        var tail_041 = param[2];
        let field_sexps_031$0 = field_sexps_031;
        var
         field_sexp_030 =
           function(param){
            if(! field_sexps_031$0)
             return caml_call2
                     (Sexplib0_Sexp_conv_error[10], error_source_039, sexp_019);
            if(field_sexps_031$0[2])
             throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
            var x_042 = field_sexps_031$0[1];
            return x_042;
           };
        if(field_name_029 !== cst_alarm_precision$0)
         if(field_name_029 !== cst_capacity)
          if(field_name_029 !== cst_level_bits){
           if(Sexplib0_Sexp_conv[26][1])
            extra_028[1] = [0, field_name_029, extra_028[1]];
          }
          else if(level_bits_023[1])
           duplicates_027[1] = [0, field_name_029, duplicates_027[1]];
          else{
           var
            field_sexp_030$0 = field_sexp_030(0),
            fvalue_034 = t_of_sexp$0(field_sexp_030$0);
           level_bits_023[1] = [0, fvalue_034];
          }
         else if(capacity_025[1])
          duplicates_027[1] = [0, field_name_029, duplicates_027[1]];
         else{
          var
           field_sexp_030$1 = field_sexp_030(0),
           fvalue_032 = caml_call1(Core[357], field_sexp_030$1);
          capacity_025[1] = [0, fvalue_032];
         }
        else if(alarm_precision_021[1])
         duplicates_027[1] = [0, field_name_029, duplicates_027[1]];
        else{
         var
          field_sexp_030$2 = field_sexp_030(0),
          fvalue_035 = caml_call1(_k_[10], field_sexp_030$2);
         alarm_precision_021[1] = [0, fvalue_035];
        }
        param = tail_041;
       }
       break a;
      }
      break c;
     }
     caml_call2(Sexplib0_Sexp_conv_error[10], error_source_039, sexp_019$0);
    }
    if(duplicates_027[1])
     return caml_call3
             (Sexplib0_Sexp_conv_error[12],
              error_source_039,
              duplicates_027[1],
              sexp_019);
    if(extra_028[1])
     return caml_call3
             (Sexplib0_Sexp_conv_error[13],
              error_source_039,
              extra_028[1],
              sexp_019);
    var
     _dK_ = alarm_precision_021[1],
     level_bits_024 = level_bits_023[1],
     match = capacity_025[1];
    if(! _dK_)
     return caml_call3
             (Sexplib0_Sexp_conv_error[15],
              error_source_039,
              sexp_019,
              [0,
               [0, 0 === alarm_precision_021[1] ? 1 : 0, cst_alarm_precision],
               0]);
    var alarm_precision_022 = _dK_[1];
    if(level_bits_024)
     var v_038 = level_bits_024[1], v_038$0 = v_038;
    else
     var v_038$0 = level_bits_default;
    return [0, alarm_precision_022, v_038$0, match];
   }
   function sexp_of_t$3(param){
    var
     capacity_048 = param[3],
     level_bits_046 = param[2],
     alarm_precision_044 = param[1],
     bnds_043 = 0;
    if(capacity_048)
     var
      v_049 = capacity_048[1],
      arg_051 = caml_call1(Core[356], v_049),
      bnd_050 = [1, [0, _m_, [0, arg_051, 0]]],
      bnds_043$0 = [0, bnd_050, bnds_043];
    else
     var bnds_043$0 = bnds_043;
    var
     arg_047 = sexp_of_t$0(level_bits_046),
     bnds_043$1 = [0, [1, [0, _n_, [0, arg_047, 0]]], bnds_043$0],
     arg_045 = caml_call1(_k_[11], alarm_precision_044),
     bnds_043$2 = [0, [1, [0, _o_, [0, arg_045, 0]]], bnds_043$1];
    return [1, bnds_043$2];
   }
   function alarm_precision(t){return to_sexpable(t[1]);}
   function max_num_level_bits(alarm_precision){
    invariant(alarm_precision);
    return symbol$3(max_num_bits, alarm_precision);
   }
   function invariant$1(t){
    return caml_call4
            (Base_Invariant[1],
             _q_,
             t,
             sexp_of_t$3,
             function(param){
              var _dH_ = max_num_level_bits(t[1]);
              if(! caml_call2(symbol$0, num_bits_internal(t[2]), _dH_))
               throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
              var
               level_bits_fun = caml_call2(Base_Invariant[2], t, invariant$0);
              caml_call1(level_bits_fun, level_bits$0);
              return 0;
             });
   }
   function create(capacity, opt, alarm_precision, param){
    if(opt)
     var sth = opt[1], level_bits = sth;
    else
     var level_bits = level_bits_default;
    var max_num_bits = max_num_level_bits(alarm_precision);
    if(caml_call2(symbol$0, num_bits_internal(level_bits), max_num_bits))
     var level_bits$0 = level_bits;
    else
     var
      loop =
        function(t, remaining){
         if(! t) return 0;
         var t$0 = t[2], b = t[1];
         return caml_call2(symbol, b, remaining)
                 ? [0, remaining, 0]
                 : [0, b, loop(t$0, symbol$3(remaining, b))];
        },
      level_bits$0 = loop(level_bits, max_num_bits);
    return [0, alarm_precision, level_bits$0, capacity];
   }
   function microsecond_precision(param){
    return create(0, [0, create_exn(0, _r_)], about_one_microsecond, 0);
   }
   function durations(t){
    var t$0 = t[1];
    invariant(t$0);
    var _dF_ = caml_call1(to_int, t$0);
    return caml_call3
            (Core_List[73],
             t[2],
             _dF_,
             function(num_bits_accum, level_num_bits){
              var
               num_bits_accum$0 =
                 num_bits_accum + caml_call1(to_int, level_num_bits) | 0,
               _dG_ =
                 caml_call2
                   (Core[90], num_bits_accum$0, Core_Int63[58] - 1 | 0)
                  ? Core_Int63[59]
                  : caml_call2
                    (Core_Int63[47], Core_Int63[14], num_bits_accum$0),
               duration = caml_call1(Core_Time_ns[1][127], _dG_);
              return [0, num_bits_accum$0, duration];
             });
   }
   var compare$0 = Core_Int63[110], sexp_of_t$4 = Core_Int63[99];
   function create$0(level_bits){
    var _dD_ = Core_Int63[14], _dE_ = pow2(level_bits);
    return caml_call2(Core_Int63[17], _dE_, _dD_);
   }
   var
    one = Core_Int63[14],
    symbol$4 = Core_Int63[17],
    bit_not = Core_Int63[45],
    sexp_of_t$5 = Core_Int63[99],
    equal$1 = Core_Int63[109];
   function create$1(bits_per_slot){
    return caml_call1(bit_not, caml_call2(symbol$4, pow2(bits_per_slot), one));
   }
   var
    to_int_exn = Core_Int63[5],
    zero$0 = Core_Int63[13],
    one$0 = Core_Int63[14],
    symbol$5 = Core_Int63[16],
    symbol$6 = Core_Int63[18],
    succ = Core_Int63[39],
    pred = Core_Int63[40],
    max_value = Core_Int63[59],
    of_int$0 = Core_Int63[69],
    sexp_of_t$6 = Core_Int63[99],
    symbol$7 = Core_Int63[103],
    symbol$8 = Core_Int63[104],
    symbol$9 = Core_Int63[105],
    symbol$10 = Core_Int63[106],
    symbol$11 = Core_Int63[107],
    symbol$12 = Core_Int63[108],
    equal$2 = Core_Int63[109],
    compare$1 = Core_Int63[110],
    min = Core_Int63[111],
    max = Core_Int63[112],
    ascending = Core_Int63[113],
    descending = Core_Int63[114],
    between = Core_Int63[115],
    clamp_exn = Core_Int63[116],
    clamp = Core_Int63[117],
    Replace_polymorphic_compare = Core_Int63[118],
    comparator = Core_Int63[119],
    Map = Core_Int63[120],
    Set = Core_Int63[121],
    validate_lbound = Core_Int63[128],
    validate_ubound = Core_Int63[129],
    validate_bound = Core_Int63[130];
   function to_int63(t){return t;}
   function of_int63(i){return i;}
   function scale_int(t, i){
    return caml_call2(symbol$6, t, caml_call1(of_int$0, i));
   }
   var
    to_int_exn$0 = Core_Int63[5],
    zero$1 = Core_Int63[13],
    one$1 = Core_Int63[14],
    symbol$13 = Core_Int63[16],
    symbol$14 = Core_Int63[17],
    rem = Core_Int63[25],
    succ$0 = Core_Int63[39],
    pred$0 = Core_Int63[40],
    bit_and = Core_Int63[42],
    shift_right = Core_Int63[48],
    max_value$0 = Core_Int63[59],
    min_value$0 = Core_Int63[60],
    of_int$1 = Core_Int63[69],
    sexp_of_t$7 = Core_Int63[99],
    symbol$15 = Core_Int63[103],
    symbol$16 = Core_Int63[104],
    symbol$17 = Core_Int63[105],
    symbol$18 = Core_Int63[106],
    symbol$19 = Core_Int63[107],
    symbol$20 = Core_Int63[108],
    equal$3 = Core_Int63[109],
    compare$2 = Core_Int63[110],
    min$0 = Core_Int63[111],
    max$0 = Core_Int63[112],
    ascending$0 = Core_Int63[113],
    descending$0 = Core_Int63[114],
    between$0 = Core_Int63[115],
    clamp_exn$0 = Core_Int63[116],
    clamp$0 = Core_Int63[117],
    Replace_polymorphic_compare$0 = Core_Int63[118],
    comparator$0 = Core_Int63[119],
    Map$0 = Core_Int63[120],
    Set$0 = Core_Int63[121],
    hash_fold_t = Core_Int63[122],
    hash = Core_Int63[123],
    hashable = Core_Int63[124],
    Table = Core_Int63[125],
    Hash_set = Core_Int63[126],
    Hash_queue = Core_Int63[127],
    validate_lbound$0 = Core_Int63[128],
    validate_ubound$0 = Core_Int63[129],
    validate_bound$0 = Core_Int63[130];
   function of_int63$0(i){return i;}
   function to_int63$0(t){return t;}
   function add(t, i){return caml_call2(symbol$13, t, i);}
   function add_clamp_to_max(t, i){
    return caml_call2(symbol$18, t, caml_call2(symbol$14, max_value$0, i))
            ? max_value$0
            : caml_call2(symbol$13, t, i);
   }
   function sub(t, i){return caml_call2(symbol$14, t, i);}
   function diff(t1, t2){return caml_call2(symbol$14, t1, t2);}
   var
    _s_ = Set$0[1],
    _t_ = Map$0[1],
    _u_ = Set[1],
    _v_ = Map[1],
    _w_ =
      [0,
       sexp_of_t$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       equal$2,
       compare$1,
       min,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       Replace_polymorphic_compare,
       [0,
        [0, _v_[9], _v_[10], _v_[11]],
        Map[2],
        Map[3],
        Map[4],
        Map[5],
        Map[6],
        Map[7],
        Map[8],
        Map[9],
        Map[10],
        Map[11],
        Map[12],
        Map[13],
        Map[14],
        Map[15],
        Map[16],
        Map[17],
        Map[18],
        Map[19],
        Map[20],
        Map[21],
        Map[22],
        Map[23],
        Map[24],
        Map[25],
        Map[26],
        Map[27],
        Map[28],
        Map[29],
        Map[30],
        Map[31],
        Map[32],
        Map[33],
        Map[34],
        Map[35],
        Map[36],
        Map[37],
        Map[38],
        Map[39],
        Map[40],
        Map[41],
        Map[42],
        Map[43],
        Map[44],
        Map[45],
        Map[46],
        Map[47],
        Map[48],
        Map[49],
        Map[50],
        Map[51],
        Map[52],
        Map[53],
        Map[54],
        Map[55],
        Map[56],
        Map[57],
        Map[58],
        Map[59],
        Map[60],
        Map[61],
        Map[62],
        Map[63],
        Map[64],
        Map[65],
        Map[66],
        Map[67],
        Map[68],
        Map[69],
        Map[70],
        Map[71],
        Map[72],
        Map[73],
        Map[74],
        Map[75],
        Map[76],
        Map[77],
        Map[78],
        Map[79],
        Map[80],
        Map[81],
        Map[82],
        Map[83],
        Map[84],
        Map[85],
        Map[86],
        Map[87],
        Map[88],
        Map[89],
        Map[90],
        Map[91],
        Map[92],
        Map[93],
        Map[94],
        Map[95],
        Map[96],
        Map[97],
        Map[98],
        Map[99],
        Map[100],
        Map[101],
        Map[102],
        Map[103],
        Map[104],
        Map[105],
        Map[106],
        Map[107]],
       [0,
        [0, _u_[1], _u_[2], _u_[11]],
        Set[2],
        Set[3],
        Set[4],
        Set[5],
        Set[6],
        Set[7],
        Set[8],
        Set[9],
        Set[10],
        Set[11],
        Set[12],
        Set[13],
        Set[14],
        Set[15],
        Set[16],
        Set[17],
        Set[18],
        Set[19],
        Set[20],
        Set[21],
        Set[22],
        Set[23],
        Set[24],
        Set[25],
        Set[26],
        Set[27],
        Set[28],
        Set[29],
        Set[30],
        Set[31],
        Set[32],
        Set[33],
        Set[34],
        Set[35],
        Set[36],
        Set[37],
        Set[38],
        Set[39],
        Set[40],
        Set[41],
        Set[42],
        Set[43],
        Set[44],
        Set[45],
        Set[46],
        Set[47],
        Set[48],
        Set[49],
        Set[50],
        Set[51],
        Set[52],
        Set[53],
        Set[54],
        Set[55],
        Set[56],
        Set[57],
        Set[58],
        Set[59],
        Set[60],
        Set[61],
        Set[62],
        Set[63],
        Set[64],
        Set[65],
        Set[66],
        Set[67],
        Set[68],
        Set[69],
        Set[70],
        Set[71],
        Set[72],
        Set[73],
        Set[74],
        Set[75]],
       max,
       zero$0,
       one$0,
       max_value,
       of_int63,
       to_int63,
       of_int$0,
       to_int_exn,
       scale_int,
       pred,
       succ,
       symbol$5];
   function sexp_of_pool_slots(of_a_054, x_055){
    var
     _dz_ =
       caml_call1
        (Tuple_pool[36][3][1],
         function(_dC_){return sexp_of_pool_slots(of_a_054, _dC_);}),
     _dA_ =
       caml_call1
        (Tuple_pool[36][3][1],
         function(_dB_){return sexp_of_pool_slots(of_a_054, _dB_);});
    return caml_call7
            (Tuple_pool[36][1][8],
             sexp_of_t$7,
             Core_Time_ns_alternate_sexp[92],
             of_a_054,
             Core[356],
             _dA_,
             _dz_,
             x_055);
   }
   function sexp_of_t$8(of_a_056, x_057){
    return caml_call2
            (Tuple_pool[36][3][1],
             function(_dy_){return sexp_of_pool_slots(of_a_056, _dy_);},
             x_057);
   }
   var
    null$0 = Tuple_pool[36][3][4],
    null$1 = Tuple_pool[36][3][4],
    is_null = Tuple_pool[36][3][5],
    free = Tuple_pool[36][14];
   function key(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][3]);
   }
   function at(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][4]);
   }
   function value(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][5]);
   }
   function level_index(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][6]);
   }
   function prev(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][7]);
   }
   function set_prev(p, t, x){
    return caml_call4(Tuple_pool[36][33], p, t, Tuple_pool[36][2][7], x);
   }
   function next(p, t){
    return caml_call3(Tuple_pool[36][31], p, t, Tuple_pool[36][2][8]);
   }
   function set_next(p, t, x){
    return caml_call4(Tuple_pool[36][33], p, t, Tuple_pool[36][2][8], x);
   }
   function is_valid(p, t){return caml_call2(Tuple_pool[36][6], p, t);}
   var
    grow = Tuple_pool[36][12],
    is_full = Tuple_pool[36][13],
    cst_Timing_wheel_got_invalid_a = "Timing_wheel got invalid alarm";
   function of_external_exn(pool, t){
    if(is_valid(pool, t)) return t;
    var
     _dx_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_got_invalid_a);
    return caml_call1(Core[253], _dx_);
   }
   function link(pool, prev, next){
    set_next(pool, prev, next);
    return set_prev(pool, next, prev);
   }
   function iter(pool, first, f){
    var current = [0, first], continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return 0;
     var next$0 = next(pool, current[1]);
     caml_call1(f, current[1]);
     if(caml_call2(Core[246], next$0, first))
      continue$0[1] = 0;
     else
      current[1] = next$0;
    }
   }
   function slots(r){return r[11];}
   function max_allowed_key(r){return r[10];}
   function set_max_allowed_key(r, v){r[10] = v; return 0;}
   function min_allowed_key(r){return r[9];}
   function set_min_allowed_key(r, v){r[9] = v; return 0;}
   function length(r){return r[8];}
   function set_length(r, v){r[8] = v; return 0;}
   function diff_max_min_allowed_key(r){return r[7];}
   function min_key_in_same_slot_mask(r){return r[6];}
   function keys_per_slot(r){return r[5];}
   function bits_per_slot(r){return r[4];}
   function slots_mask(r){return r[3];}
   function bits(r){return r[2];}
   function index(r){return r[1];}
   var
    slots$0 =
      [0,
       function(param){return 0;},
       cst_slots,
       0,
       slots,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                v];
       }],
    max_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_max_allowed_key,
       [0, set_max_allowed_key],
       max_allowed_key,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                v,
                r[11]];
       }],
    min_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_min_allowed_key,
       [0, set_min_allowed_key],
       min_allowed_key,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                v,
                r[10],
                r[11]];
       }],
    length$0 =
      [0,
       function(param){return 0;},
       cst_length,
       [0, set_length],
       length,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                v,
                r[9],
                r[10],
                r[11]];
       }],
    diff_max_min_allowed_key$0 =
      [0,
       function(param){return 0;},
       cst_diff_max_min_allowed_key,
       0,
       diff_max_min_allowed_key,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                v,
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    min_key_in_same_slot_mask$0 =
      [0,
       function(param){return 0;},
       cst_min_key_in_same_slot_mask,
       0,
       min_key_in_same_slot_mask,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                v,
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    keys_per_slot$0 =
      [0,
       function(param){return 0;},
       cst_keys_per_slot,
       0,
       keys_per_slot,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                v,
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    bits_per_slot$0 =
      [0,
       function(param){return 0;},
       cst_bits_per_slot,
       0,
       bits_per_slot,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                v,
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    slots_mask$0 =
      [0,
       function(param){return 0;},
       cst_slots_mask,
       0,
       slots_mask,
       function(r, v){
        return [0,
                r[1],
                r[2],
                v,
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    bits$0 =
      [0,
       function(param){return 0;},
       cst_bits,
       0,
       bits,
       function(r, v){
        return [0,
                r[1],
                v,
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    index$0 =
      [0,
       function(param){return 0;},
       cst_index,
       0,
       index,
       function(r, v){
        return [0,
                v,
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11]];
       }],
    _C_ = [0, cst_slots],
    _D_ = [0, cst_max_allowed_key],
    _E_ = [0, cst_min_allowed_key],
    _F_ = [0, cst_length],
    _G_ = [0, cst_diff_max_min_allowed_key],
    _H_ = [0, cst_min_key_in_same_slot_mask],
    _I_ = [0, cst_keys_per_slot],
    _J_ = [0, cst_bits_per_slot],
    _K_ = [0, cst_slots_mask],
    _L_ = [0, cst_bits],
    _M_ = [0, cst_index];
   function sexp_of_t$9(of_a_065, param){
    var
     diff_max_min_allowed_key_079 = param[7],
     min_key_in_same_slot_mask_077 = param[6],
     keys_per_slot_075 = param[5],
     bits_per_slot_073 = param[4],
     slots_mask_071 = param[3],
     bits_069 = param[2],
     index_067 = param[1],
     length_081 = param[8],
     min_allowed_key_083 = param[9],
     max_allowed_key_085 = param[10],
     slots_087 = param[11],
     arg_088 = caml_call1(Sexplib0_Sexp_conv[23], slots_087),
     bnds_066 = [0, [1, [0, _C_, [0, arg_088, 0]]], 0],
     arg_086 = caml_call1(sexp_of_t$7, max_allowed_key_085),
     bnds_066$0 = [0, [1, [0, _D_, [0, arg_086, 0]]], bnds_066],
     arg_084 = caml_call1(sexp_of_t$7, min_allowed_key_083),
     bnds_066$1 = [0, [1, [0, _E_, [0, arg_084, 0]]], bnds_066$0],
     arg_082 = caml_call1(Core[356], length_081),
     bnds_066$2 = [0, [1, [0, _F_, [0, arg_082, 0]]], bnds_066$1],
     arg_080 = caml_call1(_w_[1], diff_max_min_allowed_key_079),
     bnds_066$3 = [0, [1, [0, _G_, [0, arg_080, 0]]], bnds_066$2],
     arg_078 = caml_call1(sexp_of_t$5, min_key_in_same_slot_mask_077),
     bnds_066$4 = [0, [1, [0, _H_, [0, arg_078, 0]]], bnds_066$3],
     arg_076 = caml_call1(_w_[1], keys_per_slot_075),
     bnds_066$5 = [0, [1, [0, _I_, [0, arg_076, 0]]], bnds_066$4],
     arg_074 = caml_call1(sexp_of_t, bits_per_slot_073),
     bnds_066$6 = [0, [1, [0, _J_, [0, arg_074, 0]]], bnds_066$5],
     arg_072 = caml_call1(sexp_of_t$4, slots_mask_071),
     bnds_066$7 = [0, [1, [0, _K_, [0, arg_072, 0]]], bnds_066$6],
     arg_070 = caml_call1(sexp_of_t, bits_069),
     bnds_066$8 = [0, [1, [0, _L_, [0, arg_070, 0]]], bnds_066$7],
     arg_068 = caml_call1(Core[356], index_067),
     bnds_066$9 = [0, [1, [0, _M_, [0, arg_068, 0]]], bnds_066$8];
    return [1, bnds_066$9];
   }
   function slot(t, key){
    var slots_mask = t[3], bits_per_slot = t[4];
    return caml_call1
            (to_int_exn$0,
             caml_call2
              (bit_and,
               caml_call2(shift_right, key, bits_per_slot),
               slots_mask));
   }
   function next_slot(t, slot){
    var t$0 = t[3];
    return (slot + 1 | 0) & caml_call1(Core_Int63[5], t$0);
   }
   function min_key_in_same_slot(t, key){
    var min_key_in_same_slot_mask = t[6];
    return caml_call2(bit_and, key, min_key_in_same_slot_mask);
   }
   function compute_min_allowed_key(t, prev_level_max_allowed_key){
    return caml_call2(equal$3, prev_level_max_allowed_key, max_value$0)
            ? max_value$0
            : min_key_in_same_slot
              (t, caml_call1(succ$0, prev_level_max_allowed_key));
   }
   function levels(r){return r[5];}
   function elt_key_lower_bound(r){return r[4];}
   function set_elt_key_lower_bound(r, v){r[4] = v; return 0;}
   function min_elt(r){return r[3];}
   function set_min_elt(r, v){r[3] = v; return 0;}
   function pool(r){return r[2];}
   function set_pool(r, v){r[2] = v; return 0;}
   function length$1(r){return r[1];}
   function set_length$0(r, v){r[1] = v; return 0;}
   var
    levels$0 =
      [0,
       function(param){return 0;},
       cst_levels,
       0,
       levels,
       function(r, v){return [0, r[1], r[2], r[3], r[4], v];}],
    elt_key_lower_bound$0 =
      [0,
       function(param){return 0;},
       cst_elt_key_lower_bound,
       [0, set_elt_key_lower_bound],
       elt_key_lower_bound,
       function(r, v){return [0, r[1], r[2], r[3], v, r[5]];}],
    min_elt$0 =
      [0,
       function(param){return 0;},
       cst_min_elt,
       [0, set_min_elt],
       min_elt,
       function(r, v){return [0, r[1], r[2], v, r[4], r[5]];}],
    pool$0 =
      [0,
       function(param){return 0;},
       cst_pool,
       [0, set_pool],
       pool,
       function(r, v){return [0, r[1], v, r[3], r[4], r[5]];}],
    length$2 =
      [0,
       function(param){return 0;},
       cst_length,
       [0, set_length$0],
       length$1,
       function(r, v){return [0, v, r[2], r[3], r[4], r[5]];}],
    _S_ = [0, cst_value],
    _T_ = [0, cst_key],
    _U_ = [0, "elts"],
    _V_ = [0, cst_max_allowed_key],
    _W_ = [0, cst_min_allowed_key],
    _at_ = [0, cst_priority_queue],
    _au_ = [0, "max_allowed_key t"],
    _av_ = [0, "min_allowed_key t"],
    _aw_ = [0, cst_key],
    cst_Priority_queue_add_elt_key =
      "Priority_queue.add_elt key out of bounds",
    _ax_ = [0, cst$0],
    _ay_ = [0, "level"],
    _az_ = [0, cst_key],
    cst_Priority_queue_add_elt_key$0 =
      "Priority_queue.add_elt key out of level bounds",
    _aA_ = [0, "max_allowed_alarm_interval_num"],
    _aB_ = [0, "min_allowed_alarm_interval_num"],
    _aC_ = [0, cst_interval_num],
    cst_Timing_wheel_add_at_interv =
      "Timing_wheel.add_at_interval_num got invalid interval num";
   function is_empty(t){return caml_call2(Core[90], t[1], 0);}
   function num_levels(t){return t[5].length - 1;}
   function min_allowed_key$1(t){
    var r = caml_check_bound(t[5], 0)[1];
    return r[9];
   }
   function max_allowed_key$1(t){
    var
     _dw_ = num_levels(t) - 1 | 0,
     r = caml_check_bound(t[5], _dw_)[1 + _dw_];
    return r[10];
   }
   function internal_iter(t, f){
    var _do_ = caml_call2(Core[91], t[1], 0);
    if(_do_){
     var pool = t[2], levels = t[5], _dq_ = levels.length - 2 | 0, _dp_ = 0;
     if(_dq_ >= 0){
      var level_index = _dp_;
      for(;;){
       var level = caml_check_bound(levels, level_index)[1 + level_index];
       if(caml_call2(Core[91], level[8], 0)){
        var slots = level[11], _dt_ = slots.length - 2 | 0, _ds_ = 0;
        if(_dt_ >= 0){
         var slot_index = _ds_;
         for(;;){
          var elt = caml_check_bound(slots, slot_index)[1 + slot_index];
          if(1 - caml_call1(is_null, elt)) iter(pool, elt, f);
          var _dv_ = slot_index + 1 | 0;
          if(_dt_ === slot_index) break;
          slot_index = _dv_;
         }
        }
       }
       var _du_ = level_index + 1 | 0;
       if(_dq_ === level_index) break;
       level_index = _du_;
      }
     }
     var _dr_ = 0;
    }
    else
     var _dr_ = _do_;
    return _dr_;
   }
   function compute_diff_max_min_allowed_k(level_bits, bits_per_slot){
    var num_bits = symbol$2(level_bits, bits_per_slot);
    if(caml_call2(equal, num_bits, max_num_bits)) return _w_[26];
    var _dn_ = pow2(num_bits);
    return caml_call1(_w_[32], _dn_);
   }
   function min_elt$1(t){
    if(is_empty(t)) return caml_call1(null$1, 0);
    if(! caml_call1(is_null, t[3])) return t[3];
    var
     pool = t[2],
     min_elt_already_found = [0, caml_call1(null$1, 0)],
     min_key_already_found = [0, max_value$0],
     level_index = [0, 0],
     num_levels$0 = num_levels(t);
    for(;;){
     if(! caml_call2(Core[92], level_index[1], num_levels$0)){
      t[3] = min_elt_already_found[1];
      t[4] = min_key_already_found[1];
      return t[3];
     }
     var
      _dk_ = level_index[1],
      level = caml_check_bound(t[5], _dk_)[1 + _dk_];
     if(caml_call2(symbol$18, level[9], min_key_already_found[1]))
      level_index[1] = num_levels$0;
     else if(caml_call2(Core[90], level[8], 0))
      level_index[1]++;
     else{
      var
       slots = level[11],
       slot_min_key =
         [0, min_key_in_same_slot(level, caml_call2(max$0, level[9], t[4]))],
       slot$0 = [0, slot(level, slot_min_key[1])];
      for(;;){
       var _dl_ = slot$0[1];
       if(! caml_call1(is_null, caml_check_bound(slots, _dl_)[1 + _dl_]))
        break;
       if(! caml_call2(symbol$19, slot_min_key[1], min_key_already_found[1]))
        break;
       slot$0[1] = next_slot(level, slot$0[1]);
       var i = level[5], t$0 = slot_min_key[1];
       slot_min_key[1] = caml_call2(symbol$13, t$0, i);
      }
      var _dm_ = slot$0[1], first = caml_check_bound(slots, _dm_)[1 + _dm_];
      if(1 - caml_call1(is_null, first)){
       var continue$0 = [0, 1], current = [0, first];
       for(;;){
        if(! continue$0[1]) break;
        var current_key = key(pool, current[1]);
        if(caml_call2(symbol$16, current_key, min_key_already_found[1])){
         min_elt_already_found[1] = current[1];
         min_key_already_found[1] = current_key;
        }
        var next$0 = next(pool, current[1]);
        a:
        {
         if
          (!
           caml_call2(Core[246], next$0, first)
           && ! caml_call2(Core[90], level_index[1], 0)){current[1] = next$0; break a;}
         continue$0[1] = 0;
        }
       }
      }
      level_index[1]++;
     }
    }
   }
   function add_elt(x_135, to_add){
    var
     pool$0 = x_135[2],
     key$0 = key(pool$0, to_add),
     _dd_ = caml_call2(symbol$15, key$0, min_allowed_key$1(x_135)),
     _de_ =
       _dd_ ? caml_call2(symbol$16, key$0, max_allowed_key$1(x_135)) : _dd_;
    if(1 - _de_){
     var pool = x_135[2], r = [0, 0];
     internal_iter
      (x_135,
       function(elt){
        var _di_ = r[1], _dj_ = value(pool, elt);
        r[1] = [0, [0, key(pool, elt), _dj_], _di_];
        return 0;
       });
     var
      elts_115 = caml_call1(Core_List[34], r[1]),
      max_allowed_key_113 = max_allowed_key$1(x_135),
      min_allowed_key_111 = min_allowed_key$1(x_135),
      arg_116 =
        caml_call2
         (Core[421],
          function(param){
           var
            key_105 = param[1],
            bnds_104 = [0, [1, [0, _S_, [0, arg_108, 0]]], 0],
            arg_106 = caml_call1(sexp_of_t$7, key_105),
            bnds_104$0 = [0, [1, [0, _T_, [0, arg_106, 0]]], bnds_104];
           return [1, bnds_104$0];
          },
          elts_115),
      bnds_110 = [0, [1, [0, _U_, [0, arg_116, 0]]], 0],
      arg_114 = caml_call1(sexp_of_t$7, max_allowed_key_113),
      bnds_110$0 = [0, [1, [0, _V_, [0, arg_114, 0]]], bnds_110],
      arg_112 = caml_call1(sexp_of_t$7, min_allowed_key_111),
      bnds_110$1 = [0, [1, [0, _W_, [0, arg_112, 0]]], bnds_110$0],
      _c8_ =
        [0,
         [1,
          [0, _au_, [0, caml_call1(sexp_of_t$7, max_allowed_key$1(x_135)), 0]]],
         [0, [1, [0, _at_, [0, [1, bnds_110$1], 0]]], 0]],
      _c9_ =
        [0,
         [1,
          [0, _av_, [0, caml_call1(sexp_of_t$7, min_allowed_key$1(x_135)), 0]]],
         _c8_],
      _c__ = [0, [1, [0, _aw_, [0, caml_call1(sexp_of_t$7, key$0), 0]]], _c9_],
      _c$_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Priority_queue_add_elt_key),
          _c__]];
     caml_call1(Core[253], _c$_);
    }
    var level_index = [0, 0];
    for(;;){
     var
      _df_ = level_index[1],
      r$0 = caml_check_bound(x_135[5], _df_)[1 + _df_];
     if(! caml_call2(symbol$18, key$0, r$0[10])) break;
     level_index[1]++;
    }
    var
     level_index$0 = level_index[1],
     level = caml_check_bound(x_135[5], level_index$0)[1 + level_index$0],
     _dg_ = caml_call2(symbol$15, key$0, level[9]),
     _dh_ = _dg_ ? caml_call2(symbol$16, key$0, level[10]) : _dg_;
    if(1 - _dh_){
     var
      _da_ =
        [0,
         [1,
          [0, _ay_, [0, sexp_of_t$9(function(param){return _ax_;}, level), 0]]],
         0],
      _db_ = [0, [1, [0, _az_, [0, caml_call1(sexp_of_t$7, key$0), 0]]], _da_],
      _dc_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Priority_queue_add_elt_key$0),
          _db_]];
     caml_call1(Core[253], _dc_);
    }
    level[8] = level[8] + 1 | 0;
    caml_call4
     (Tuple_pool[36][33], pool$0, to_add, Tuple_pool[36][2][6], level_index$0);
    var
     slot$0 = slot(level, key$0),
     slots = level[11],
     first = caml_check_bound(slots, slot$0)[1 + slot$0];
    if(caml_call1(is_null, first)){
     caml_check_bound(slots, slot$0)[1 + slot$0] = to_add;
     return link(pool$0, to_add, to_add);
    }
    var prev$0 = prev(pool$0, first);
    link(pool$0, prev$0, to_add);
    return link(pool$0, to_add, first);
   }
   function internal_add_elt(t, elt){
    var key$0 = key(t[2], elt);
    if(caml_call2(symbol$19, key$0, t[4])){t[3] = elt; t[4] = key$0;}
    add_elt(t, elt);
    t[1] = t[1] + 1 | 0;
    return 0;
   }
   function ensure_valid_key(t, key){
    var
     _c6_ = caml_call2(symbol$19, key, min_allowed_key$1(t)),
     _c7_ = _c6_ || caml_call2(symbol$18, key, max_allowed_key$1(t));
    if(! _c7_) return _c7_;
    var
     _c2_ =
       [0,
        [1, [0, _aA_, [0, caml_call1(sexp_of_t$7, max_allowed_key$1(t)), 0]]],
        0],
     _c3_ =
       [0,
        [1, [0, _aB_, [0, caml_call1(sexp_of_t$7, min_allowed_key$1(t)), 0]]],
        _c2_],
     _c4_ = [0, [1, [0, _aC_, [0, caml_call1(sexp_of_t$7, key), 0]]], _c3_],
     _c5_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_add_at_interv),
         _c4_]];
    return caml_call1(Core[253], _c5_);
   }
   function internal_add(t, key, at, value){
    ensure_valid_key(t, key);
    if(caml_call1(is_full, t[2])) t[2] = caml_call2(grow, 0, t[2]);
    var
     pool = t[2],
     _c0_ = caml_call1(null$1, 0),
     _c1_ = caml_call1(null$1, 0),
     elt =
       caml_call7(Tuple_pool[36][21], pool, key, at, value, -1, _c1_, _c0_);
    internal_add_elt(t, elt);
    return elt;
   }
   function internal_remove(t, elt){
    var pool = t[2], t2 = t[3];
    if(caml_call2(Tuple_pool[36][3][7], elt, t2))
     t[3] = caml_call1(null$1, 0);
    t[1] = t[1] - 1 | 0;
    var
     _cW_ = level_index(pool, elt),
     level = caml_check_bound(t[5], _cW_)[1 + _cW_];
    level[8] = level[8] - 1 | 0;
    var
     slots = level[11],
     slot$0 = slot(level, key(pool, elt)),
     first = caml_check_bound(slots, slot$0)[1 + slot$0],
     _cX_ = next(pool, elt);
    if(caml_call2(Core[246], elt, _cX_)){
     var _cY_ = caml_call1(null$1, 0);
     caml_check_bound(slots, slot$0)[1 + slot$0] = _cY_;
     return;
    }
    if(caml_call2(Core[246], elt, first)){
     var _cZ_ = next(pool, elt);
     caml_check_bound(slots, slot$0)[1 + slot$0] = _cZ_;
    }
    var _cU_ = next(pool, elt);
    set_next(pool, prev(pool, elt), _cU_);
    var _cV_ = prev(pool, elt);
    return set_prev(pool, next(pool, elt), _cV_);
   }
   var
    _aD_ =
      [0,
       _w_,
       sexp_of_t$7,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol$18,
       symbol$19,
       symbol$20,
       equal$3,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator$0,
       validate_lbound$0,
       validate_ubound$0,
       validate_bound$0,
       Replace_polymorphic_compare$0,
       [0,
        [0, _t_[9], _t_[10], _t_[11]],
        Map$0[2],
        Map$0[3],
        Map$0[4],
        Map$0[5],
        Map$0[6],
        Map$0[7],
        Map$0[8],
        Map$0[9],
        Map$0[10],
        Map$0[11],
        Map$0[12],
        Map$0[13],
        Map$0[14],
        Map$0[15],
        Map$0[16],
        Map$0[17],
        Map$0[18],
        Map$0[19],
        Map$0[20],
        Map$0[21],
        Map$0[22],
        Map$0[23],
        Map$0[24],
        Map$0[25],
        Map$0[26],
        Map$0[27],
        Map$0[28],
        Map$0[29],
        Map$0[30],
        Map$0[31],
        Map$0[32],
        Map$0[33],
        Map$0[34],
        Map$0[35],
        Map$0[36],
        Map$0[37],
        Map$0[38],
        Map$0[39],
        Map$0[40],
        Map$0[41],
        Map$0[42],
        Map$0[43],
        Map$0[44],
        Map$0[45],
        Map$0[46],
        Map$0[47],
        Map$0[48],
        Map$0[49],
        Map$0[50],
        Map$0[51],
        Map$0[52],
        Map$0[53],
        Map$0[54],
        Map$0[55],
        Map$0[56],
        Map$0[57],
        Map$0[58],
        Map$0[59],
        Map$0[60],
        Map$0[61],
        Map$0[62],
        Map$0[63],
        Map$0[64],
        Map$0[65],
        Map$0[66],
        Map$0[67],
        Map$0[68],
        Map$0[69],
        Map$0[70],
        Map$0[71],
        Map$0[72],
        Map$0[73],
        Map$0[74],
        Map$0[75],
        Map$0[76],
        Map$0[77],
        Map$0[78],
        Map$0[79],
        Map$0[80],
        Map$0[81],
        Map$0[82],
        Map$0[83],
        Map$0[84],
        Map$0[85],
        Map$0[86],
        Map$0[87],
        Map$0[88],
        Map$0[89],
        Map$0[90],
        Map$0[91],
        Map$0[92],
        Map$0[93],
        Map$0[94],
        Map$0[95],
        Map$0[96],
        Map$0[97],
        Map$0[98],
        Map$0[99],
        Map$0[100],
        Map$0[101],
        Map$0[102],
        Map$0[103],
        Map$0[104],
        Map$0[105],
        Map$0[106],
        Map$0[107]],
       [0,
        [0, _s_[1], _s_[2], _s_[11]],
        Set$0[2],
        Set$0[3],
        Set$0[4],
        Set$0[5],
        Set$0[6],
        Set$0[7],
        Set$0[8],
        Set$0[9],
        Set$0[10],
        Set$0[11],
        Set$0[12],
        Set$0[13],
        Set$0[14],
        Set$0[15],
        Set$0[16],
        Set$0[17],
        Set$0[18],
        Set$0[19],
        Set$0[20],
        Set$0[21],
        Set$0[22],
        Set$0[23],
        Set$0[24],
        Set$0[25],
        Set$0[26],
        Set$0[27],
        Set$0[28],
        Set$0[29],
        Set$0[30],
        Set$0[31],
        Set$0[32],
        Set$0[33],
        Set$0[34],
        Set$0[35],
        Set$0[36],
        Set$0[37],
        Set$0[38],
        Set$0[39],
        Set$0[40],
        Set$0[41],
        Set$0[42],
        Set$0[43],
        Set$0[44],
        Set$0[45],
        Set$0[46],
        Set$0[47],
        Set$0[48],
        Set$0[49],
        Set$0[50],
        Set$0[51],
        Set$0[52],
        Set$0[53],
        Set$0[54],
        Set$0[55],
        Set$0[56],
        Set$0[57],
        Set$0[58],
        Set$0[59],
        Set$0[60],
        Set$0[61],
        Set$0[62],
        Set$0[63],
        Set$0[64],
        Set$0[65],
        Set$0[66],
        Set$0[67],
        Set$0[68],
        Set$0[69],
        Set$0[70],
        Set$0[71],
        Set$0[72],
        Set$0[73],
        Set$0[74],
        Set$0[75]],
       compare$2,
       hash_fold_t,
       hash,
       hashable,
       [0,
        Table[1],
        Table[2],
        Table[3],
        Table[4],
        Table[5],
        Table[6],
        Table[7],
        Table[8],
        Table[9],
        Table[10],
        Table[11],
        Table[12],
        Table[13],
        Table[14],
        Table[15],
        Table[16],
        Table[17],
        Table[18],
        Table[19],
        Table[20],
        Table[21],
        Table[22],
        Table[23],
        Table[24],
        Table[25],
        Table[26],
        Table[27],
        Table[28],
        Table[29],
        Table[30],
        Table[31],
        Table[32],
        Table[33],
        Table[34],
        Table[35],
        Table[36],
        Table[37],
        Table[38],
        Table[39],
        Table[40],
        Table[41],
        Table[42],
        Table[43],
        Table[44],
        Table[45],
        Table[46],
        Table[47],
        Table[48],
        Table[49],
        Table[50],
        Table[51],
        Table[52],
        Table[53],
        Table[54],
        Table[55],
        Table[56],
        Table[57],
        Table[58],
        Table[59],
        Table[60],
        Table[61],
        Table[62],
        Table[63],
        Table[64],
        Table[65],
        Table[66],
        Table[67],
        Table[68],
        Table[69],
        Table[70],
        Table[71],
        Table[72],
        Table[73],
        Table[74],
        Table[75],
        Table[76],
        Table[77],
        Table[78],
        Table[79],
        Table[80],
        Table[81],
        Table[82],
        Table[83],
        Table[84]],
       [0,
        Hash_set[1],
        Hash_set[2],
        Hash_set[3],
        Hash_set[4],
        Hash_set[5],
        Hash_set[6],
        Hash_set[7]],
       Hash_queue,
       max$0,
       min$0,
       zero$1,
       one$1,
       min_value$0,
       max_value$0,
       of_int63$0,
       to_int63$0,
       of_int$1,
       to_int_exn$0,
       add,
       sub,
       diff,
       succ$0,
       pred$0,
       rem],
    min_interval_num = _aD_[31];
   function priority_queue(r){return r[7];}
   function max_allowed_alarm_time(r){return r[6];}
   function set_max_allowed_alarm_time(r, v){r[6] = v; return 0;}
   function now_interval_num_start(r){return r[5];}
   function set_now_interval_num_start(r, v){r[5] = v; return 0;}
   function now(r){return r[4];}
   function set_now(r, v){r[4] = v; return 0;}
   function max_interval_num(r){return r[3];}
   function start(r){return r[2];}
   function config(r){return r[1];}
   var
    priority_queue$0 =
      [0,
       function(param){return 0;},
       cst_priority_queue,
       0,
       priority_queue,
       function(r, v){return [0, r[1], r[2], r[3], r[4], r[5], r[6], v];}],
    max_allowed_alarm_time$0 =
      [0,
       function(param){return 0;},
       cst_max_allowed_alarm_time,
       [0, set_max_allowed_alarm_time],
       max_allowed_alarm_time,
       function(r, v){return [0, r[1], r[2], r[3], r[4], r[5], v, r[7]];}],
    now_interval_num_start$0 =
      [0,
       function(param){return 0;},
       cst_now_interval_num_start,
       [0, set_now_interval_num_start],
       now_interval_num_start,
       function(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6], r[7]];}],
    now$0 =
      [0,
       function(param){return 0;},
       cst_now,
       [0, set_now],
       now,
       function(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6], r[7]];}],
    max_interval_num$0 =
      [0,
       function(param){return 0;},
       cst_max_interval_num,
       0,
       max_interval_num,
       function(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6], r[7]];}],
    start$0 =
      [0,
       function(param){return 0;},
       cst_start,
       0,
       start,
       function(r, v){return [0, r[1], v, r[3], r[4], r[5], r[6], r[7]];}],
    config$0 =
      [0,
       function(param){return 0;},
       cst_config,
       0,
       config,
       function(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6], r[7]];}],
    _x_ = [0, cst_timing_wheel_src_timing_wh, 653, 8],
    _y_ = [0, cst_timing_wheel_src_timing_wh, 651, 8],
    _z_ = [0, cst_timing_wheel_src_timing_wh, 648, 8],
    _A_ = [0, cst$0],
    _B_ = [0, cst_timing_wheel_src_timing_wh, 647, 23049, 23075],
    _N_ = [0, cst_levels],
    _O_ = [0, cst_elt_key_lower_bound],
    _P_ = [0, cst_min_elt],
    _Q_ = [0, cst_pool],
    _R_ = [0, cst_length],
    _X_ = [0, cst_timing_wheel_src_timing_wh, 969, 21],
    _Y_ = [0, cst_timing_wheel_src_timing_wh, 965, 21],
    _Z_ = [0, cst_timing_wheel_src_timing_wh, 961, 21],
    ___ = [0, cst_timing_wheel_src_timing_wh, 957, 21],
    _$_ = [0, cst_timing_wheel_src_timing_wh, 936, 15],
    _aa_ = [0, cst_timing_wheel_src_timing_wh, 928, 15],
    _ab_ = [0, cst_timing_wheel_src_timing_wh, 914, 15],
    _ac_ = [0, cst_timing_wheel_src_timing_wh, 906, 15],
    _ad_ = [0, cst_timing_wheel_src_timing_wh, 899, 36],
    _ae_ = [0, cst_timing_wheel_src_timing_wh, 898, 38],
    _af_ = [0, cst$0],
    _ag_ = [0, cst_timing_wheel_src_timing_wh, 895, 31577, 31603],
    _ah_ = [0, cst_timing_wheel_src_timing_wh, 997, 15],
    _ai_ = [0, cst_timing_wheel_src_timing_wh, 995, 13],
    _aj_ = [0, cst_timing_wheel_src_timing_wh, 991, 15],
    _ak_ = [0, cst_timing_wheel_src_timing_wh, 988, 13],
    _al_ = [0, cst_timing_wheel_src_timing_wh, 987, 13],
    _am_ = [0, cst_timing_wheel_src_timing_wh, 984, 15],
    _an_ = [0, cst_timing_wheel_src_timing_wh, 983, 15],
    _ao_ = [0, cst_timing_wheel_src_timing_wh, 977, 38],
    _ap_ = [0, cst_timing_wheel_src_timing_wh, 975, 6],
    _aq_ = [0, cst_timing_wheel_src_timing_wh, 974, 6],
    _ar_ = [0, cst$0],
    _as_ = [0, cst_timing_wheel_src_timing_wh, 972, 34918, 34942],
    _aE_ = [0, cst_value],
    _aF_ = [0, cst_at],
    _aG_ = [0, "alarms"],
    _aH_ = [0, cst_now],
    _aI_ = [0, cst_max_interval_num],
    _aJ_ = [0, cst_start],
    _aK_ = [0, cst_config],
    _aL_ = [0, cst$0],
    _aM_ = [0, cst_timing_wheel],
    cst_Timing_wheel_next_alarm_fi =
      "Timing_wheel.next_alarm_fires_at_exn of empty timing wheel",
    _aN_ = [0, cst$0],
    _aO_ = [0, cst_timing_wheel],
    cst_Timing_wheel_next_alarm_fi$0 =
      "Timing_wheel.next_alarm_fires_at_exn with all alarms in max interval",
    _aP_ = [0, "time"],
    cst_Timing_wheel_interval_num_ =
      "Timing_wheel.interval_num got time too far in the past",
    _aQ_ = [0, "min_interval_num"],
    _aR_ = [0, cst_interval_num],
    cst_Timing_wheel_interval_num_$0 =
      "Timing_wheel.interval_num_start got too small interval_num",
    _aS_ = [0, "t.max_interval_num"],
    _aT_ = [0, cst_interval_num],
    cst_Timing_wheel_interval_num_$1 =
      "Timing_wheel.interval_num_start got too large interval_num",
    _aU_ = [0, cst_timing_wheel_src_timing_wh, 1638, 11],
    _aV_ = [0, cst_timing_wheel_src_timing_wh, 1637, 11],
    _aW_ = [0, cst_timing_wheel_src_timing_wh, 1636, 11],
    _aX_ = [0, cst_timing_wheel_src_timing_wh, 1625, 11],
    _aY_ = [0, cst_timing_wheel_src_timing_wh, 1624, 11],
    _aZ_ = [0, cst_timing_wheel_src_timing_wh, 1662, 6],
    _a0_ = [0, cst_timing_wheel_src_timing_wh, 1658, 6],
    _a1_ = [0, cst_timing_wheel_src_timing_wh, 1654, 6],
    _a2_ = [0, cst$0],
    _a3_ = [0, cst_timing_wheel_src_timing_wh, 1618, 58357, 58379];
   function sexp_of_t_now(param, t){
    return caml_call1(Core_Time_ns_alternate_sexp[92], t[4]);
   }
   function alarm_precision$0(t){return alarm_precision(t[1]);}
   function at$0(tw, t){
    var p = tw[7], _cT_ = of_external_exn(p[2], t);
    return at(p[2], _cT_);
   }
   function value$0(tw, t){
    var p = tw[7], _cS_ = of_external_exn(p[2], t);
    return value(p[2], _cS_);
   }
   function interval_num(tw, t){
    var p = tw[7], _cR_ = of_external_exn(p[2], t);
    return key(p[2], _cR_);
   }
   function iter$0(t, f){var t$0 = t[7]; return internal_iter(t$0, f);}
   function compare$3(t1, t2){
    return caml_call2(Core_Time_ns_alternate_sexp[101], t1[1], t2[1]);
   }
   function sexp_of_t$10(sexp_of_a, t){
    var
     max_interval_num_167 = t[3],
     start_165 = t[2],
     config_163 = t[1],
     now_169 = t[4],
     r = [0, 0];
    iter$0
     (t,
      function(alarm){
       var _cQ_ = r[1], _cP_ = value$0(t, alarm);
       r[1] = [0, [0, at$0(t, alarm), _cP_], _cQ_];
       return 0;
      });
    var
     alarms_171 = caml_call2(Core_List[58], r[1], compare$3),
     arg_172 =
       caml_call2
        (Core[421],
         function(param){
          var
           value_159 = param[2],
           at_157 = param[1],
           arg_160 = caml_call1(sexp_of_a, value_159),
           bnds_156 = [0, [1, [0, _aE_, [0, arg_160, 0]]], 0],
           arg_158 = caml_call1(Core_Time_ns_alternate_sexp[92], at_157),
           bnds_156$0 = [0, [1, [0, _aF_, [0, arg_158, 0]]], bnds_156];
          return [1, bnds_156$0];
         },
         alarms_171),
     bnds_162 = [0, [1, [0, _aG_, [0, arg_172, 0]]], 0],
     arg_170 = caml_call1(Core_Time_ns_alternate_sexp[92], now_169),
     bnds_162$0 = [0, [1, [0, _aH_, [0, arg_170, 0]]], bnds_162],
     arg_168 = caml_call1(_aD_[2], max_interval_num_167),
     bnds_162$1 = [0, [1, [0, _aI_, [0, arg_168, 0]]], bnds_162$0],
     arg_166 = caml_call1(Core_Time_ns_alternate_sexp[92], start_165),
     bnds_162$2 = [0, [1, [0, _aJ_, [0, arg_166, 0]]], bnds_162$1],
     arg_164 = sexp_of_t$3(config_163),
     bnds_162$3 = [0, [1, [0, _aK_, [0, arg_164, 0]]], bnds_162$2];
    return [1, bnds_162$3];
   }
   function length$3(t){var r = t[7]; return r[1];}
   function is_empty$0(t){
    var _cO_ = length$3(t);
    return caml_call2(Core[90], _cO_, 0);
   }
   function pool$1(t){var r = t[7]; return r[2];}
   function interval_num_internal(time, alarm_precision){
    var
     _cM_ = caml_call1(Core_Time_ns_alternate_sexp[61], time),
     _cN_ = caml_call2(Core_Int63[48], _cM_, alarm_precision);
    return caml_call1(_aD_[35], _cN_);
   }
   function interval_num_unchecked(t, time){
    return interval_num_internal(time, t[1][1]);
   }
   function interval_num$0(t, time){
    if(caml_call2(Core_Time_ns_alternate_sexp[98], time, min_time)){
     var
      _cK_ =
        [0,
         [1,
          [0, _aP_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], time), 0]]],
         0],
      _cL_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_),
          _cK_]];
     caml_call1(Core[253], _cL_);
    }
    return interval_num_unchecked(t, time);
   }
   function interval_num_start_unchecked(t, interval_num){
    var
     interval_num$0 = caml_call1(_aD_[36], interval_num),
     t$0 = t[1][1],
     _cJ_ = caml_call2(Core_Int63[47], interval_num$0, t$0);
    return caml_call1(Core_Time_ns_alternate_sexp[62], _cJ_);
   }
   function interval_num_start(t, interval_num){
    if(caml_call2(_aD_[7], interval_num, min_interval_num)){
     var
      _cD_ =
        [0, [1, [0, _aQ_, [0, caml_call1(_aD_[2], min_interval_num), 0]]], 0],
      _cE_ =
        [0, [1, [0, _aR_, [0, caml_call1(_aD_[2], interval_num), 0]]], _cD_],
      _cF_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_$0),
          _cE_]];
     caml_call1(Core[253], _cF_);
    }
    if(caml_call2(_aD_[6], interval_num, t[3])){
     var
      _cG_ = [0, [1, [0, _aS_, [0, caml_call1(_aD_[2], t[3]), 0]]], 0],
      _cH_ =
        [0, [1, [0, _aT_, [0, caml_call1(_aD_[2], interval_num), 0]]], _cG_],
      _cI_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_interval_num_$1),
          _cH_]];
     caml_call1(Core[253], _cI_);
    }
    return interval_num_start_unchecked(t, interval_num);
   }
   function next_alarm_fires_at_internal(t, key){
    return interval_num_start(t, caml_call1(_aD_[42], key));
   }
   function next_alarm_fires_at(t){
    var elt = min_elt$1(t[7]);
    if(caml_call1(is_null, elt)) return 0;
    var key$0 = key(pool$1(t), elt);
    return caml_call2(_aD_[9], key$0, t[3])
            ? 0
            : [0, next_alarm_fires_at_internal(t, key$0)];
   }
   function next_alarm_fires_at_exn(x_174){
    var elt = min_elt$1(x_174[7]);
    if(caml_call1(is_null, elt)){
     var
      _cz_ =
        [0,
         [1,
          [0,
           _aM_,
           [0, sexp_of_t$10(function(param){return _aL_;}, x_174), 0]]],
         0],
      _cA_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_next_alarm_fi),
          _cz_]];
     caml_call1(Core[253], _cA_);
    }
    var key$0 = key(pool$1(x_174), elt);
    if(caml_call2(_aD_[9], key$0, x_174[3])){
     var
      _cB_ =
        [0,
         [1,
          [0,
           _aO_,
           [0, sexp_of_t$10(function(param){return _aN_;}, x_174), 0]]],
         0],
      _cC_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_next_alarm_fi$0),
          _cB_]];
     caml_call1(Core[253], _cC_);
    }
    return next_alarm_fires_at_internal(x_174, key$0);
   }
   function compute_max_allowed_alarm_time(t){
    var max_allowed_key = max_allowed_key$1(t[7]);
    if(caml_call2(_aD_[3], max_allowed_key, t[3])) return max_time;
    var
     _cv_ = Core_Time_ns[1][67],
     _cw_ = alarm_precision$0(t),
     _cx_ = caml_call2(Core_Time_ns[1][98], _cw_, _cv_),
     _cy_ = interval_num_start_unchecked(t, max_allowed_key);
    return caml_call2(Core_Time_ns_alternate_sexp[51], _cy_, _cx_);
   }
   function now_interval_num(t){return min_allowed_key$1(t[7]);}
   function max_allowed_alarm_interval_num(t){return interval_num$0(t, t[6]);}
   function interval_start(t, time){
    return interval_num_start_unchecked(t, interval_num$0(t, time));
   }
   function invariant$2(invariant_a, t){
    return caml_call4
            (Base_Invariant[1],
             _a3_,
             t,
             function(x_176){
              return sexp_of_t$10(function(param){return _a2_;}, x_176);
             },
             function(param){
              function check(f){return caml_call2(Base_Invariant[2], t, f);}
              var
               priority_queue_fun =
                 check
                  (function(t){
                    var pool = t[2];
                    return caml_call4
                            (Base_Invariant[1],
                             _as_,
                             t,
                             function(x_130){
                              function of_a_089(param){return _ar_;}
                              var
                               length_091 = x_130[1],
                               pool_093 = x_130[2],
                               min_elt_095 = x_130[3],
                               elt_key_lower_bound_097 = x_130[4],
                               levels_099 = x_130[5],
                               arg_100 =
                                 caml_call2
                                  (Core[288],
                                   function(_cu_){return sexp_of_t$9(of_a_089, _cu_);},
                                   levels_099),
                               bnds_090 = [0, [1, [0, _N_, [0, arg_100, 0]]], 0],
                               arg_098 = caml_call1(sexp_of_t$7, elt_key_lower_bound_097),
                               bnds_090$0 = [0, [1, [0, _O_, [0, arg_098, 0]]], bnds_090],
                               arg_096 = sexp_of_t$8(of_a_089, min_elt_095),
                               bnds_090$1 = [0, [1, [0, _P_, [0, arg_096, 0]]], bnds_090$0],
                               arg_094 =
                                 caml_call2
                                  (Tuple_pool[36][4],
                                   function(_ct_){return sexp_of_pool_slots(of_a_089, _ct_);},
                                   pool_093),
                               bnds_090$2 = [0, [1, [0, _Q_, [0, arg_094, 0]]], bnds_090$1],
                               arg_092 = caml_call1(Core[356], length_091),
                               bnds_090$3 = [0, [1, [0, _R_, [0, arg_092, 0]]], bnds_090$2];
                              return [1, bnds_090$3];
                             },
                             function(param){
                              function check(f){
                               return caml_call2(Base_Invariant[2], t, f);
                              }
                              if(! caml_call2(symbol$15, min_allowed_key$1(t), zero$1))
                               throw caml_maybe_attach_backtrace
                                      ([0, Assert_failure, _aq_], 1);
                              var _cb_ = min_allowed_key$1(t);
                              if(! caml_call2(symbol$15, max_allowed_key$1(t), _cb_))
                               throw caml_maybe_attach_backtrace
                                      ([0, Assert_failure, _ap_], 1);
                              var
                               levels_fun =
                                 check
                                  (function(levels){
                                    var _cg_ = num_levels(t);
                                    if(caml_call2(Core[91], _cg_, 0))
                                     return caml_call2
                                             (Core_Array[58],
                                              levels,
                                              function(level_index$0, level){
                                               if(! caml_call2(Core[90], level_index$0, level[1]))
                                                throw caml_maybe_attach_backtrace
                                                       ([0, Assert_failure, _ah_], 1);
                                               caml_call4
                                                (Base_Invariant[1],
                                                 _ag_,
                                                 level,
                                                 function(x_119){
                                                  return sexp_of_t$9(function(param){return _af_;}, x_119);
                                                 },
                                                 function(param){
                                                  function check(f){
                                                   return caml_call2(Base_Invariant[2], level, f);
                                                  }
                                                  var
                                                   slots_fun =
                                                     check
                                                      (function(slots){
                                                        return caml_call2
                                                                (Core_Array[22],
                                                                 slots,
                                                                 function(elt){
                                                                  var _cl_ = 1 - caml_call1(is_null, elt);
                                                                  return _cl_
                                                                          ? (caml_call4
                                                                             (Base_Invariant[1],
                                                                              _B_,
                                                                              elt,
                                                                              function(x_062){
                                                                               return sexp_of_t$8(function(param){return _A_;}, x_062);
                                                                              },
                                                                              function(param){
                                                                               if(! is_valid(pool, elt))
                                                                                throw caml_maybe_attach_backtrace
                                                                                       ([0, Assert_failure, _z_], 1);
                                                                               caml_call1(invariant_a, value(pool, elt));
                                                                               var n = next(pool, elt);
                                                                               if(! caml_call1(is_null, n)){
                                                                                var _cn_ = prev(pool, n);
                                                                                if(! caml_call2(Tuple_pool[36][3][7], elt, _cn_))
                                                                                 throw caml_maybe_attach_backtrace
                                                                                        ([0, Assert_failure, _y_], 1);
                                                                               }
                                                                               var p = prev(pool, elt);
                                                                               if(! caml_call1(is_null, p)){
                                                                                var _cm_ = next(pool, p);
                                                                                if(! caml_call2(Tuple_pool[36][3][7], elt, _cm_))
                                                                                 throw caml_maybe_attach_backtrace
                                                                                        ([0, Assert_failure, _x_], 1);
                                                                               }
                                                                               return 0;
                                                                              }),
                                                                            iter
                                                                             (pool,
                                                                              elt,
                                                                              function(elt){
                                                                               var _co_ = level[9];
                                                                               if(! caml_call2(symbol$15, key(pool, elt), _co_))
                                                                                throw caml_maybe_attach_backtrace
                                                                                       ([0, Assert_failure, ___], 1);
                                                                               var _cp_ = level[10];
                                                                               if(! caml_call2(symbol$16, key(pool, elt), _cp_))
                                                                                throw caml_maybe_attach_backtrace
                                                                                       ([0, Assert_failure, _Z_], 1);
                                                                               var _cq_ = t[4];
                                                                               if(! caml_call2(symbol$15, key(pool, elt), _cq_))
                                                                                throw caml_maybe_attach_backtrace
                                                                                       ([0, Assert_failure, _Y_], 1);
                                                                               var _cr_ = level[1], _cs_ = level_index(pool, elt);
                                                                               if(caml_call2(Core[90], _cs_, _cr_))
                                                                                return caml_call1(invariant_a, value(pool, elt));
                                                                               throw caml_maybe_attach_backtrace
                                                                                      ([0, Assert_failure, _X_], 1);
                                                                              }))
                                                                          : _cl_;
                                                                 });
                                                       }),
                                                   max_allowed_key_fun =
                                                     check
                                                      (function(max_allowed_key){
                                                        var expect = add_clamp_to_max(level[9], level[7]);
                                                        function comparator(a_128, b_129){
                                                         return caml_call2(compare$2, a_128, b_129);
                                                        }
                                                        return caml_call8
                                                                (Ppx_assert_lib_Runtime[3],
                                                                 pos,
                                                                 sexp_of_t$7,
                                                                 comparator,
                                                                 0,
                                                                 0,
                                                                 0,
                                                                 expect,
                                                                 max_allowed_key);
                                                       }),
                                                   min_allowed_key_fun =
                                                     check
                                                      (function(min_allowed_key){
                                                        if(! caml_call2(symbol$15, min_allowed_key, zero$1))
                                                         throw caml_maybe_attach_backtrace
                                                                ([0, Assert_failure, _$_], 1);
                                                        var
                                                         _ck_ = caml_call2(symbol$19, min_allowed_key, max_value$0);
                                                        if(! _ck_) return _ck_;
                                                        var
                                                         got = caml_call2(rem, min_allowed_key, level[5]),
                                                         expect = _w_[24],
                                                         sexpifier = _w_[1];
                                                        function comparator(a_126, b_127){
                                                         return caml_call2(_w_[9], a_126, b_127);
                                                        }
                                                        return caml_call8
                                                                (Ppx_assert_lib_Runtime[3],
                                                                 pos$0,
                                                                 sexpifier,
                                                                 comparator,
                                                                 0,
                                                                 0,
                                                                 0,
                                                                 expect,
                                                                 got);
                                                       }),
                                                   length_fun =
                                                     check
                                                      (function(length){
                                                        var
                                                         _cj_ =
                                                           caml_call3
                                                            (Core_Array[23],
                                                             level[11],
                                                             0,
                                                             function(n, first){
                                                              if(caml_call1(is_null, first)) return n;
                                                              var r = [0, 0], current = [0, first], continue$0 = [0, 1];
                                                              for(;;){
                                                               if(! continue$0[1]) return n + r[1] | 0;
                                                               r[1]++;
                                                               var next$0 = next(pool, current[1]);
                                                               if(caml_call2(Core[246], next$0, first))
                                                                continue$0[1] = 0;
                                                               else
                                                                current[1] = next$0;
                                                              }
                                                             });
                                                        if(caml_call2(Core[90], length, _cj_)) return 0;
                                                        throw caml_maybe_attach_backtrace
                                                               ([0, Assert_failure, _aa_], 1);
                                                       }),
                                                   expect = compute_diff_max_min_allowed_k(level[2], level[4]),
                                                   diff_max_min_allowed_key_fun =
                                                     check
                                                      (function(eta){
                                                        var sexpifier = _w_[1];
                                                        function comparator(a_124, b_125){
                                                         return caml_call2(_w_[9], a_124, b_125);
                                                        }
                                                        return caml_call8
                                                                (Ppx_assert_lib_Runtime[3],
                                                                 pos$1,
                                                                 sexpifier,
                                                                 comparator,
                                                                 0,
                                                                 0,
                                                                 0,
                                                                 expect,
                                                                 eta);
                                                       }),
                                                   min_key_in_same_slot_mask_fun =
                                                     check
                                                      (function(min_key_in_same_slot_mask){
                                                        if
                                                         (caml_call2
                                                           (equal$1, min_key_in_same_slot_mask, create$1(level[4])))
                                                         return 0;
                                                        throw caml_maybe_attach_backtrace
                                                               ([0, Assert_failure, _ab_], 1);
                                                       }),
                                                   keys_per_slot_fun =
                                                     check
                                                      (function(keys_per_slot){
                                                        var
                                                         num_bits = level[4],
                                                         expect = pow2(num_bits),
                                                         sexpifier = _w_[1];
                                                        function comparator(a_122, b_123){
                                                         return caml_call2(_w_[9], a_122, b_123);
                                                        }
                                                        return caml_call8
                                                                (Ppx_assert_lib_Runtime[3],
                                                                 pos$2,
                                                                 sexpifier,
                                                                 comparator,
                                                                 0,
                                                                 0,
                                                                 0,
                                                                 expect,
                                                                 keys_per_slot);
                                                       }),
                                                   bits_per_slot_fun =
                                                     check
                                                      (function(bits_per_slot){
                                                        if(caml_call2(symbol, bits_per_slot, zero)) return 0;
                                                        throw caml_maybe_attach_backtrace
                                                               ([0, Assert_failure, _ac_], 1);
                                                       }),
                                                   expect$0 = create$0(level[2]),
                                                   slots_mask_fun =
                                                     check
                                                      (function(eta){
                                                        function comparator(a_120, b_121){
                                                         return caml_call2(compare$0, a_120, b_121);
                                                        }
                                                        return caml_call8
                                                                (Ppx_assert_lib_Runtime[3],
                                                                 pos$3,
                                                                 sexp_of_t$4,
                                                                 comparator,
                                                                 0,
                                                                 0,
                                                                 0,
                                                                 expect$0,
                                                                 eta);
                                                       }),
                                                   bits_fun =
                                                     check
                                                      (function(bits){
                                                        if(caml_call2(symbol$1, bits, zero)) return 0;
                                                        throw caml_maybe_attach_backtrace
                                                               ([0, Assert_failure, _ad_], 1);
                                                       }),
                                                   index_fun =
                                                     check
                                                      (function(index){
                                                        if(caml_call2(Core[88], index, 0)) return 0;
                                                        throw caml_maybe_attach_backtrace
                                                               ([0, Assert_failure, _ae_], 1);
                                                       });
                                                  caml_call1(index_fun, index$0);
                                                  caml_call1(bits_fun, bits$0);
                                                  caml_call1(slots_mask_fun, slots_mask$0);
                                                  caml_call1(bits_per_slot_fun, bits_per_slot$0);
                                                  caml_call1(keys_per_slot_fun, keys_per_slot$0);
                                                  caml_call1
                                                   (min_key_in_same_slot_mask_fun, min_key_in_same_slot_mask$0);
                                                  caml_call1
                                                   (diff_max_min_allowed_key_fun, diff_max_min_allowed_key$0);
                                                  caml_call1(length_fun, length$0);
                                                  caml_call1(min_allowed_key_fun, min_allowed_key$0);
                                                  caml_call1(max_allowed_key_fun, max_allowed_key$0);
                                                  return caml_call1(slots_fun, slots$0);
                                                 });
                                               var _ch_ = caml_call2(Core[91], level_index$0, 0);
                                               if(! _ch_) return _ch_;
                                               var
                                                _ci_ = level_index$0 - 1 | 0,
                                                prev_level = caml_check_bound(levels, _ci_)[1 + _ci_],
                                                got$0 = level[5],
                                                expect = caml_call1(_w_[33], prev_level[7]),
                                                sexpifier = _w_[1];
                                               function comparator(a_131, b_132){
                                                return caml_call2(_w_[9], a_131, b_132);
                                               }
                                               caml_call8
                                                (Ppx_assert_lib_Runtime[3],
                                                 pos$4,
                                                 sexpifier,
                                                 comparator,
                                                 0,
                                                 0,
                                                 0,
                                                 expect,
                                                 got$0);
                                               var
                                                got = level[9],
                                                expect$0 = compute_min_allowed_key(level, prev_level[10]);
                                               function comparator$0(a_133, b_134){
                                                return caml_call2(compare$2, a_133, b_134);
                                               }
                                               return caml_call8
                                                       (Ppx_assert_lib_Runtime[3],
                                                        pos$5,
                                                        sexp_of_t$7,
                                                        comparator$0,
                                                        0,
                                                        0,
                                                        0,
                                                        expect$0,
                                                        got);
                                              });
                                    throw caml_maybe_attach_backtrace
                                           ([0, Assert_failure, _ai_], 1);
                                   }),
                               elt_key_lower_bound_fun =
                                 check
                                  (function(elt_key_lower_bound){
                                    if
                                     (!
                                      caml_call2
                                       (symbol$15, elt_key_lower_bound, min_allowed_key$1(t)))
                                     throw caml_maybe_attach_backtrace
                                            ([0, Assert_failure, _al_], 1);
                                    if
                                     (!
                                      caml_call2
                                       (symbol$16, elt_key_lower_bound, max_allowed_key$1(t)))
                                     throw caml_maybe_attach_backtrace
                                            ([0, Assert_failure, _ak_], 1);
                                    var _cf_ = 1 - caml_call1(is_null, t[3]);
                                    if(! _cf_) return _cf_;
                                    if
                                     (caml_call2(equal$3, elt_key_lower_bound, key(t[2], t[3])))
                                     return 0;
                                    throw caml_maybe_attach_backtrace
                                           ([0, Assert_failure, _aj_], 1);
                                   }),
                               min_elt_fun =
                                 check
                                  (function(elt){
                                    var _cd_ = 1 - caml_call1(is_null, elt);
                                    if(! _cd_) return _cd_;
                                    if(! is_valid(t[2], elt))
                                     throw caml_maybe_attach_backtrace
                                            ([0, Assert_failure, _an_], 1);
                                    var _ce_ = key(t[2], elt);
                                    if(caml_call2(equal$3, t[4], _ce_)) return 0;
                                    throw caml_maybe_attach_backtrace
                                           ([0, Assert_failure, _am_], 1);
                                   }),
                               pool_fun =
                                 check
                                  (function(t){
                                    return caml_call2
                                            (Tuple_pool[36][5], function(_cc_){return 0;}, t);
                                   }),
                               length_fun =
                                 check
                                  (function(length){
                                    if(caml_call2(Core[88], length, 0)) return 0;
                                    throw caml_maybe_attach_backtrace
                                           ([0, Assert_failure, _ao_], 1);
                                   });
                              caml_call1(length_fun, length$2);
                              caml_call1(pool_fun, pool$0);
                              caml_call1(min_elt_fun, min_elt$0);
                              caml_call1(elt_key_lower_bound_fun, elt_key_lower_bound$0);
                              return caml_call1(levels_fun, levels$0);
                             });
                   }),
               max_allowed_alarm_time_fun =
                 check
                  (function(max_allowed_alarm_time){
                    var
                     expect = compute_max_allowed_alarm_time(t),
                     sexpifier = Core_Time_ns_alternate_sexp[92];
                    function comparator(a_183, b_184){
                     return caml_call2
                             (Core_Time_ns_alternate_sexp[101], a_183, b_184);
                    }
                    return caml_call8
                            (Ppx_assert_lib_Runtime[3],
                             pos$6,
                             sexpifier,
                             comparator,
                             0,
                             0,
                             0,
                             expect,
                             max_allowed_alarm_time);
                   }),
               now_interval_num_start_fun =
                 check
                  (function(now_interval_num_start){
                    var
                     expect = interval_num_start(t, now_interval_num(t)),
                     sexpifier = Core_Time_ns_alternate_sexp[92];
                    function comparator(a_181, b_182){
                     return caml_call2
                             (Core_Time_ns_alternate_sexp[101], a_181, b_182);
                    }
                    return caml_call8
                            (Ppx_assert_lib_Runtime[3],
                             pos$7,
                             sexpifier,
                             comparator,
                             0,
                             0,
                             0,
                             expect,
                             now_interval_num_start);
                   }),
               now_fun =
                 check
                  (function(now){
                    if(! caml_call2(Core_Time_ns_alternate_sexp[94], now, t[2]))
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _aW_], 1);
                    if
                     (!
                      caml_call2(Core_Time_ns_alternate_sexp[95], now, max_time))
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _aV_], 1);
                    var
                     _b$_ = min_allowed_key$1(t[7]),
                     _ca_ = interval_num$0(t, t[4]);
                    if(caml_call2(_aD_[9], _ca_, _b$_)) return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _aU_], 1);
                   }),
               max_interval_num_fun =
                 check
                  (function(max_interval_num){
                    var got = interval_num$0(t, max_time), sexpifier = _aD_[2];
                    function comparator(a_177, b_178){
                     return caml_call2(_aD_[22], a_177, b_178);
                    }
                    caml_call8
                     (Ppx_assert_lib_Runtime[3],
                      pos$8,
                      sexpifier,
                      comparator,
                      0,
                      0,
                      0,
                      max_interval_num,
                      got);
                    var
                     got$0 =
                       interval_num$0(t, interval_num_start(t, max_interval_num)),
                     sexpifier$0 = _aD_[2];
                    function comparator$0(a_179, b_180){
                     return caml_call2(_aD_[22], a_179, b_180);
                    }
                    return caml_call8
                            (Ppx_assert_lib_Runtime[3],
                             pos$9,
                             sexpifier$0,
                             comparator$0,
                             0,
                             0,
                             0,
                             max_interval_num,
                             got$0);
                   }),
               start_fun =
                 check
                  (function(start){
                    if
                     (!
                      caml_call2(Core_Time_ns_alternate_sexp[94], start, min_time))
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _aY_], 1);
                    if
                     (caml_call2
                       (Core_Time_ns_alternate_sexp[95], start, max_time))
                     return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _aX_], 1);
                   }),
               config_fun = check(invariant$1);
              caml_call1(config_fun, config$0);
              caml_call1(start_fun, start$0);
              caml_call1(max_interval_num_fun, max_interval_num$0);
              caml_call1(now_fun, now$0);
              caml_call1(now_interval_num_start_fun, now_interval_num_start$0);
              caml_call1(max_allowed_alarm_time_fun, max_allowed_alarm_time$0);
              caml_call1(priority_queue_fun, priority_queue$0);
              return iter$0
                      (t,
                       function(alarm){
                        var
                         _b4_ = interval_num$0(t, at$0(t, alarm)),
                         _b5_ = interval_num(t, alarm);
                        if(! caml_call2(_aD_[9], _b5_, _b4_))
                         throw caml_maybe_attach_backtrace
                                ([0, Assert_failure, _a1_], 1);
                        var
                         _b6_ = interval_start(t, t[4]),
                         _b7_ = interval_start(t, at$0(t, alarm));
                        if
                         (! caml_call2(Core_Time_ns_alternate_sexp[94], _b7_, _b6_))
                         throw caml_maybe_attach_backtrace
                                ([0, Assert_failure, _a0_], 1);
                        var
                         _b8_ = alarm_precision$0(t),
                         _b9_ =
                           caml_call2(Core_Time_ns_alternate_sexp[54], t[4], _b8_),
                         _b__ = at$0(t, alarm);
                        if(caml_call2(Core_Time_ns_alternate_sexp[97], _b__, _b9_))
                         return 0;
                        throw caml_maybe_attach_backtrace
                               ([0, Assert_failure, _aZ_], 1);
                       });
             });
   }
   var
    debug = 0,
    _a4_ = [0, cst_start],
    cst_Timing_wheel_create_got_st =
      "Timing_wheel.create got start before the epoch",
    _a5_ = [0, cst_timing_wheel_src_timing_wh, 1707, 53],
    _a6_ = [0, cst_max_allowed_alarm_time],
    _a7_ = [0, cst_at],
    cst_Timing_wheel_cannot_schedu =
      "Timing_wheel cannot schedule alarm that far in the future",
    _a8_ = [0, cst_now_interval_num_start],
    _a9_ = [0, cst_at],
    cst_Timing_wheel_cannot_schedu$0 =
      "Timing_wheel cannot schedule alarm before start of current interval",
    cst_Timing_wheel_cannot_resche =
      "Timing_wheel cannot reschedule alarm not in timing wheel",
    _a__ = [0, cst$0],
    _a$_ = [0, cst_timing_wheel],
    cst_Timing_wheel_min_alarm_int =
      "Timing_wheel.min_alarm_interval_num_exn of empty timing_wheel",
    _ba_ = [0, cst$0],
    _bb_ = [0, cst_timing_wheel],
    cst_Timing_wheel_max_alarm_tim = cst_Timing_wheel_max_alarm_tim$1,
    _bc_ = [0, cst$0],
    _bd_ = [0, cst_timing_wheel],
    cst_Timing_wheel_max_alarm_tim$0 = cst_Timing_wheel_max_alarm_tim$1;
   function advance_clock(t$0, to, handle_removed){
    var _b2_ = caml_call2(Core_Time_ns_alternate_sexp[97], to, t$0[4]);
    if(_b2_){
     t$0[4] = to;
     var t_min_allowed_key = interval_num_unchecked(t$0, to);
     t$0[5] = interval_num_start_unchecked(t$0, t_min_allowed_key);
     var t$1 = t$0[7];
     if(caml_call2(symbol$16, t_min_allowed_key, min_allowed_key$1(t$1)))
      var match = 0;
     else{
      var
       level_index = [0, 0],
       result = [0, 1],
       prev_level_max_allowed_key = [0, caml_call1(pred$0, t_min_allowed_key)],
       levels = t$1[5],
       num_levels$0 = num_levels(t$1);
      for(;;){
       if(! caml_call2(Core[92], level_index[1], num_levels$0)){
        if(caml_call2(symbol$18, t_min_allowed_key, t$1[4])){
         t$1[3] = caml_call1(null$1, 0);
         t$1[4] = min_allowed_key$1(t$1);
        }
        var match = result[1];
        break;
       }
       var
        _b1_ = level_index[1],
        level = caml_check_bound(levels, _b1_)[1 + _b1_],
        min_allowed_key_before = level[9],
        prev_level_max_allowed_key$0 = prev_level_max_allowed_key[1],
        desired_min_allowed_key =
          compute_min_allowed_key(level, prev_level_max_allowed_key$0),
        level_min_allowed_key =
          min_key_in_same_slot
           (level,
            caml_call2
             (min$0,
              desired_min_allowed_key,
              caml_call2(max$0, level[9], t$1[4]))),
        level_min_allowed_key$0 = [0, level_min_allowed_key],
        slot$0 = [0, slot(level, level_min_allowed_key$0[1])],
        keys_per_slot = level[5],
        slots = level[11];
       for(;;){
        if
         (!
          caml_call2
           (symbol$19, level_min_allowed_key$0[1], desired_min_allowed_key))
         break;
        if(caml_call2(Core[90], level[8], 0))
         level_min_allowed_key$0[1] = desired_min_allowed_key;
        else{
         var
          _bY_ = slot$0[1],
          first = caml_check_bound(slots, _bY_)[1 + _bY_];
         if(1 - caml_call1(is_null, first)){
          var _bZ_ = caml_call1(null$1, 0), _b0_ = slot$0[1];
          caml_check_bound(slots, _b0_)[1 + _b0_] = _bZ_;
          var pool = t$1[2], current = [0, first], continue$0 = [0, 1];
          for(;;){
           if(! continue$0[1]) break;
           var next$0 = next(pool, current[1]);
           level[8] = level[8] - 1 | 0;
           if(caml_call2(symbol$15, key(pool, current[1]), t_min_allowed_key))
            add_elt(t$1, current[1]);
           else{
            t$1[1] = t$1[1] - 1 | 0;
            var t = current[1];
            caml_call1(handle_removed, t);
            caml_call2(free, pool, current[1]);
           }
           if(caml_call2(Core[246], next$0, first))
            continue$0[1] = 0;
           else
            current[1] = next$0;
          }
         }
         slot$0[1] = next_slot(level, slot$0[1]);
         level_min_allowed_key$0[1] =
          add_clamp_to_max(level_min_allowed_key$0[1], keys_per_slot);
        }
       }
       level[9] = desired_min_allowed_key;
       level[10] = add_clamp_to_max(desired_min_allowed_key, level[7]);
       if(caml_call2(equal$3, level[9], min_allowed_key_before)){level_index[1] = num_levels$0; result[1] = 0;}
       else{
        level_index[1] = level_index[1] + 1 | 0;
        prev_level_max_allowed_key[1] = level[10];
       }
      }
     }
     if(match){t$0[6] = compute_max_allowed_alarm_time(t$0); return 0;}
     var _b3_ = debug;
    }
    else
     var _b3_ = _b2_;
    return _b3_;
   }
   function create$2(config, start){
    if
     (caml_call2
       (Core_Time_ns_alternate_sexp[98],
        start,
        Core_Time_ns_alternate_sexp[43])){
     var
      _bO_ =
        [0,
         [1,
          [0,
           _a4_,
           [0, caml_call1(Core_Time_ns_alternate_sexp[92], start), 0]]],
         0],
      _bP_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_create_got_st),
          _bO_]];
     caml_call1(Core[253], _bP_);
    }
    var
     level_bits = config[2],
     capacity$0 = config[3],
     levels =
       caml_call3
         (Core_List[95],
          level_bits,
          [0, zero, zero$1, 0],
          function(index, param, level_bits){
           var
            levels = param[3],
            max_level_min_allowed_key = param[2],
            bits_per_slot = param[1],
            keys_per_slot = pow2(bits_per_slot),
            diff_max_min_allowed_key =
              compute_diff_max_min_allowed_k(level_bits, bits_per_slot),
            min_key_in_same_slot_mask = create$1(bits_per_slot),
            min_allowed_key =
              caml_call2
               (bit_and, max_level_min_allowed_key, min_key_in_same_slot_mask),
            max_allowed_key =
              add_clamp_to_max(min_allowed_key, diff_max_min_allowed_key),
            _bS_ = caml_call1(null$1, 0),
            _bT_ = pow2(level_bits),
            _bU_ = caml_call1(Core_Int63[5], _bT_),
            _bV_ = caml_call2(Core_Array[38], _bU_, _bS_),
            level =
              [0,
               index,
               level_bits,
               create$0(level_bits),
               bits_per_slot,
               keys_per_slot,
               min_key_in_same_slot_mask,
               diff_max_min_allowed_key,
               0,
               min_allowed_key,
               max_allowed_key,
               _bV_],
            _bW_ = [0, level, levels],
            _bX_ =
              caml_call2(symbol$17, max_allowed_key, max_value$0)
               ? max_value$0
               : caml_call1(succ$0, max_allowed_key);
           return [0, symbol$2(level_bits, bits_per_slot), _bX_, _bW_];
          })
        [3],
     _bL_ = caml_call1(Core_Array[90], levels),
     _bM_ = caml_call1(null$1, 0);
    if(capacity$0)
     var sth = capacity$0[1], capacity = sth;
    else
     var capacity = 1;
    var
     _bN_ =
       [0,
        0,
        caml_call2(Tuple_pool[36][35], Tuple_pool[36][1][22], capacity),
        _bM_,
        zero$1,
        _bL_],
     _bQ_ = Core_Time_ns_alternate_sexp[46],
     _bR_ = Core_Time_ns_alternate_sexp[46],
     t =
       [0,
        config,
        start,
        interval_num_internal(max_time, config[1]),
        _bR_,
        _bQ_,
        max_time,
        _bN_];
    t[6] = compute_max_allowed_alarm_time(t);
    advance_clock
     (t,
      start,
      function(param){
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a5_], 1);
      });
    return t;
   }
   function add_at_interval_num(t, at, value){
    var
     _bK_ = interval_num_start(t, at),
     t$0 = internal_add(t[7], at, _bK_, value);
    return t$0;
   }
   function ensure_can_schedule_alarm(t, at){
    if(caml_call2(Core_Time_ns_alternate_sexp[97], at, t[6])){
     var
      _bD_ =
        [0,
         [1,
          [0, _a6_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], t[6]), 0]]],
         0],
      _bE_ =
        [0,
         [1,
          [0, _a7_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], at), 0]]],
         _bD_],
      _bF_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_cannot_schedu),
          _bE_]];
     caml_call1(Core[253], _bF_);
    }
    var _bJ_ = caml_call2(Core_Time_ns_alternate_sexp[98], at, t[5]);
    if(! _bJ_) return _bJ_;
    var
     _bG_ =
       [0,
        [1,
         [0, _a8_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], t[5]), 0]]],
        0],
     _bH_ =
       [0,
        [1,
         [0, _a9_, [0, caml_call1(Core_Time_ns_alternate_sexp[92], at), 0]]],
        _bG_],
     _bI_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_cannot_schedu$0),
         _bH_]];
    return caml_call1(Core[253], _bI_);
   }
   function add$0(t, at, value){
    ensure_can_schedule_alarm(t, at);
    var
     _bC_ = interval_num_unchecked(t, at),
     t$0 = internal_add(t[7], _bC_, at, value);
    return t$0;
   }
   function remove(t, alarm){
    var t$0 = t[7], pool = t$0[2], elt = of_external_exn(pool, alarm);
    internal_remove(t$0, elt);
    return caml_call2(free, pool, elt);
   }
   function clear(t){
    var t$0 = t[7], _bt_ = 1 - is_empty(t$0);
    if(_bt_){
     t$0[1] = 0;
     var
      pool = t$0[2],
      free_elt = function(elt){return caml_call2(free, pool, elt);},
      levels = t$0[5],
      _bv_ = levels.length - 2 | 0,
      _bu_ = 0;
     if(_bv_ >= 0){
      var level_index = _bu_;
      for(;;){
       var level = caml_check_bound(levels, level_index)[1 + level_index];
       if(caml_call2(Core[91], level[8], 0)){
        level[8] = 0;
        var slots = level[11], _by_ = slots.length - 2 | 0, _bx_ = 0;
        if(_by_ >= 0){
         var slot_index = _bx_;
         for(;;){
          var elt = caml_check_bound(slots, slot_index)[1 + slot_index];
          if(1 - caml_call1(is_null, elt)){
           iter(pool, elt, free_elt);
           var _bA_ = caml_call1(null$1, 0);
           caml_check_bound(slots, slot_index)[1 + slot_index] = _bA_;
          }
          var _bB_ = slot_index + 1 | 0;
          if(_by_ === slot_index) break;
          slot_index = _bB_;
         }
        }
       }
       var _bz_ = level_index + 1 | 0;
       if(_bv_ === level_index) break;
       level_index = _bz_;
      }
     }
     var _bw_ = 0;
    }
    else
     var _bw_ = _bt_;
    return _bw_;
   }
   function mem(t, alarm){var t$0 = t[7]; return is_valid(t$0[2], alarm);}
   function reschedule_gen(t, alarm, key, at){
    if(1 - mem(t, alarm)) caml_call1(Core[6], cst_Timing_wheel_cannot_resche);
    ensure_can_schedule_alarm(t, at);
    var t$0 = t[7];
    ensure_valid_key(t$0, key);
    var pool = t$0[2], elt = of_external_exn(pool, alarm);
    internal_remove(t$0, elt);
    caml_call4(Tuple_pool[36][33], pool, elt, Tuple_pool[36][2][3], key);
    caml_call4(Tuple_pool[36][33], pool, elt, Tuple_pool[36][2][4], at);
    return internal_add_elt(t$0, elt);
   }
   function reschedule(t, alarm, at){
    return reschedule_gen(t, alarm, interval_num_unchecked(t, at), at);
   }
   function reschedule_at_interval_num(t, alarm, at){
    return reschedule_gen(t, alarm, at, interval_num_start(t, at));
   }
   function min_alarm_interval_num(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, key(pool$1(t), elt)];
   }
   function min_alarm_interval_num_exn(x_185){
    var elt = min_elt$1(x_185[7]);
    if(! caml_call1(is_null, elt)) return key(pool$1(x_185), elt);
    var
     _br_ =
       [0,
        [1,
         [0, _a$_, [0, sexp_of_t$10(function(param){return _a__;}, x_185), 0]]],
        0],
     _bs_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_min_alarm_int),
         _br_]];
    return caml_call1(Core[253], _bs_);
   }
   function max_alarm_time_in_list(t, first){
    var
     pool = pool$1(t),
     with_key = key(pool, first),
     max_alarm_time = [0, Core_Time_ns_alternate_sexp[43]],
     current = [0, first],
     continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return max_alarm_time[1];
     var next$0 = next(pool, current[1]);
     if(caml_call2(equal$3, key(pool, current[1]), with_key)){
      var _bp_ = max_alarm_time[1], _bq_ = at(pool, current[1]);
      max_alarm_time[1] =
       caml_call2(Core_Time_ns_alternate_sexp[103], _bq_, _bp_);
     }
     if(caml_call2(Core[246], next$0, first))
      continue$0[1] = 0;
     else
      current[1] = next$0;
    }
   }
   function min_alarm_time_in_list(t, first){
    var
     pool = pool$1(t),
     with_key = key(pool, first),
     min_alarm_time = [0, Core_Time_ns_alternate_sexp[45]],
     current = [0, first],
     continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]) return min_alarm_time[1];
     var next$0 = next(pool, current[1]);
     if(caml_call2(equal$3, key(pool, current[1]), with_key)){
      var _bn_ = min_alarm_time[1], _bo_ = at(pool, current[1]);
      min_alarm_time[1] =
       caml_call2(Core_Time_ns_alternate_sexp[102], _bo_, _bn_);
     }
     if(caml_call2(Core[246], next$0, first))
      continue$0[1] = 0;
     else
      current[1] = next$0;
    }
   }
   function max_alarm_time_in_min_interval(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, max_alarm_time_in_list(t, elt)];
   }
   function min_alarm_time_in_min_interval(t){
    var elt = min_elt$1(t[7]);
    return caml_call1(is_null, elt) ? 0 : [0, min_alarm_time_in_list(t, elt)];
   }
   function max_alarm_time_in_min_interval$0(x_186){
    var elt = min_elt$1(x_186[7]);
    if(caml_call1(is_null, elt)){
     var
      _bl_ =
        [0,
         [1,
          [0,
           _bb_,
           [0, sexp_of_t$10(function(param){return _ba_;}, x_186), 0]]],
         0],
      _bm_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_max_alarm_tim),
          _bl_]];
     caml_call1(Core[253], _bm_);
    }
    return max_alarm_time_in_list(x_186, elt);
   }
   function min_alarm_time_in_min_interval$0(x_187){
    var elt = min_elt$1(x_187[7]);
    if(caml_call1(is_null, elt)){
     var
      _bj_ =
        [0,
         [1,
          [0,
           _bd_,
           [0, sexp_of_t$10(function(param){return _bc_;}, x_187), 0]]],
         0],
      _bk_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Timing_wheel_max_alarm_tim$0),
          _bj_]];
     caml_call1(Core[253], _bk_);
    }
    return min_alarm_time_in_list(x_187, elt);
   }
   function fire_past_alarms(t, handle_fired){
    var
     now = t[4],
     key = now_interval_num(t),
     t$0 = t[7],
     level = caml_check_bound(t$0[5], 0)[1],
     _be_ = caml_call2(Core[91], level[8], 0);
    if(_be_){
     var
      slot$0 = slot(level, key),
      slots = level[11],
      pool = t$0[2],
      first = [0, caml_check_bound(slots, slot$0)[1 + slot$0]],
      _bf_ = 1 - caml_call1(is_null, first[1]);
     if(_bf_){
      var current = [0, first[1]], continue$0 = [0, 1];
      for(;;){
       if(! continue$0[1]){var _bh_ = 0; break;}
       var elt = current[1], next$0 = next(pool, elt);
       if(caml_call2(Core[246], next$0, first[1]))
        continue$0[1] = 0;
       else
        current[1] = next$0;
       var _bg_ = at(pool, elt);
       if(caml_call2(Core_Time_ns_alternate_sexp[95], _bg_, now)){
        caml_call1(handle_fired, elt);
        internal_remove(t$0, elt);
        caml_call2(free, pool, elt);
        first[1] = caml_check_bound(slots, slot$0)[1 + slot$0];
       }
      }
     }
     else
      var _bh_ = _bf_;
     var _bi_ = _bh_;
    }
    else
     var _bi_ = _be_;
    return _bi_;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_timing_wheel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Timing_wheel);
   var
    Timing_wheel =
      [0,
       [0,
        compare,
        sexp_of_t$1,
        equal$0,
        of_span_floor_pow2_ns,
        of_span_floor_pow2_ns,
        to_sexpable,
        0,
        46,
        about_one_microsecond,
        20,
        30,
        mul,
        div,
        _k_],
       sexp_of_t$10,
       sexp_of_t_now,
       _aD_,
       [0, sexp_of_t$8, null$0, at$0, interval_num, value$0],
       invariant$2,
       [0,
        t_of_sexp$0,
        sexp_of_t$0,
        invariant$0,
        max_num_bits,
        create_exn,
        level_bits_default,
        num_bits],
       [0,
        t_of_sexp$2,
        sexp_of_t$3,
        invariant$1,
        create,
        alarm_precision,
        level_bits,
        durations,
        microsecond_precision],
       create$2,
       alarm_precision$0,
       now,
       start,
       is_empty$0,
       length$3,
       iter$0,
       interval_num$0,
       now_interval_num,
       interval_num_start,
       interval_start,
       advance_clock,
       fire_past_alarms,
       max_allowed_alarm_time,
       now_interval_num,
       max_allowed_alarm_interval_num,
       add$0,
       add_at_interval_num,
       mem,
       remove,
       reschedule,
       reschedule_at_interval_num,
       clear,
       min_alarm_interval_num,
       min_alarm_interval_num_exn,
       max_alarm_time_in_min_interval,
       min_alarm_time_in_min_interval,
       max_alarm_time_in_min_interval$0,
       min_alarm_time_in_min_interval$0,
       next_alarm_fires_at,
       next_alarm_fires_at_exn,
       [0, max_time, interval_num_internal, [0, invariant, zero]]];
   runtime.caml_register_global(219, Timing_wheel, cst_Timing_wheel);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ0aW1pbmdfd2hlZWwuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInBvcyQ5IiwicG9zJDgiLCJwb3MkNyIsInBvcyQ2IiwiYXJnXzEwOCIsInBvcyQ1IiwicG9zJDQiLCJwb3MkMyIsInBvcyQyIiwicG9zJDEiLCJwb3MkMCIsInBvcyIsImVycm9yX3NvdXJjZV8wMzkiLCJtYXhfdGltZSIsIm1pbl90aW1lIiwibWF4X251bV9iaXRzIiwibWluX3ZhbHVlIiwiaW52YXJpYW50IiwidCIsIm9mX2ludCIsImkiLCJzeW1ib2wkMiIsInQxIiwidDIiLCJzeW1ib2wkMyIsInBvdzIiLCJzZXhwX29mX3QkMCIsInhfMDA3IiwibnVtX2JpdHNfaW50ZXJuYWwiLCJudW1fYml0cyIsImludmFyaWFudCQwIiwibnVtX2tleV9iaXRzIiwidF9vZl9zZXhwJDAiLCJ4XzAwNiIsImNyZWF0ZV9leG4iLCJvcHQiLCJ4XzAwOCIsInN0aCIsImV4dGVuZF90b19tYXhfbnVtX2JpdHMiLCJiaXRzIiwiaW50cyIsImxldmVsX2JpdHNfZGVmYXVsdCIsImNvbXBhcmUiLCJlcXVhbCQwIiwieF8wMTIiLCJ4XzAxMyIsInRvX3NleHBhYmxlIiwic2V4cF9vZl90JDEiLCJhYm91dF9vbmVfbWljcm9zZWNvbmQiLCJtdWwiLCJkaXYiLCJvZl9zcGFuX2Zsb29yX3BvdzJfbnMiLCJzcGFuIiwibGV2ZWxfYml0cyIsInIiLCJsZXZlbF9iaXRzJDAiLCJ2IiwidF9vZl9zZXhwJDIiLCJzZXhwXzAxOSIsImZpZWxkX3NleHBzXzAyMCIsImFsYXJtX3ByZWNpc2lvbl8wMjEiLCJsZXZlbF9iaXRzXzAyMyIsImNhcGFjaXR5XzAyNSIsImR1cGxpY2F0ZXNfMDI3IiwiZXh0cmFfMDI4Iiwic2V4cF8wMTkkMCIsImZpZWxkX3NleHBzXzAzMSIsImZpZWxkX25hbWVfMDI5IiwidGFpbF8wNDEiLCJmaWVsZF9zZXhwc18wMzEkMCIsImZpZWxkX3NleHBfMDMwIiwieF8wNDIiLCJmaWVsZF9zZXhwXzAzMCQwIiwiZnZhbHVlXzAzNCIsImZpZWxkX3NleHBfMDMwJDEiLCJmdmFsdWVfMDMyIiwiZmllbGRfc2V4cF8wMzAkMiIsImZ2YWx1ZV8wMzUiLCJsZXZlbF9iaXRzXzAyNCIsIm1hdGNoIiwiYWxhcm1fcHJlY2lzaW9uXzAyMiIsInZfMDM4Iiwidl8wMzgkMCIsInNleHBfb2ZfdCQzIiwiY2FwYWNpdHlfMDQ4IiwibGV2ZWxfYml0c18wNDYiLCJhbGFybV9wcmVjaXNpb25fMDQ0IiwiYm5kc18wNDMiLCJ2XzA0OSIsImFyZ18wNTEiLCJibmRfMDUwIiwiYm5kc18wNDMkMCIsImFyZ18wNDciLCJibmRzXzA0MyQxIiwiYXJnXzA0NSIsImJuZHNfMDQzJDIiLCJhbGFybV9wcmVjaXNpb24iLCJtYXhfbnVtX2xldmVsX2JpdHMiLCJpbnZhcmlhbnQkMSIsImxldmVsX2JpdHNfZnVuIiwiY3JlYXRlIiwiY2FwYWNpdHkiLCJsb29wIiwicmVtYWluaW5nIiwidCQwIiwiYiIsIm1pY3Jvc2Vjb25kX3ByZWNpc2lvbiIsImR1cmF0aW9ucyIsIm51bV9iaXRzX2FjY3VtIiwibGV2ZWxfbnVtX2JpdHMiLCJudW1fYml0c19hY2N1bSQwIiwiZHVyYXRpb24iLCJjb21wYXJlJDAiLCJzZXhwX29mX3QkNCIsImNyZWF0ZSQwIiwiY3JlYXRlJDEiLCJiaXRzX3Blcl9zbG90IiwidG9faW50NjMiLCJvZl9pbnQ2MyIsInNjYWxlX2ludCIsInNleHBfb2ZfdCQ3Iiwib2ZfaW50NjMkMCIsInRvX2ludDYzJDAiLCJhZGQiLCJhZGRfY2xhbXBfdG9fbWF4Iiwic3ViIiwiZGlmZiIsInNleHBfb2ZfcG9vbF9zbG90cyIsIm9mX2FfMDU0IiwieF8wNTUiLCJzZXhwX29mX3QkOCIsIm9mX2FfMDU2IiwieF8wNTciLCJudWxsJDAiLCJudWxsJDEiLCJpc19udWxsIiwiZnJlZSIsImtleSIsInAiLCJhdCIsInZhbHVlIiwibGV2ZWxfaW5kZXgiLCJwcmV2Iiwic2V0X3ByZXYiLCJ4IiwibmV4dCIsInNldF9uZXh0IiwiaXNfdmFsaWQiLCJncm93IiwiaXNfZnVsbCIsIm9mX2V4dGVybmFsX2V4biIsInBvb2wiLCJsaW5rIiwiaXRlciIsImZpcnN0IiwiZiIsImN1cnJlbnQiLCJjb250aW51ZSQwIiwibmV4dCQwIiwic2xvdHMiLCJtYXhfYWxsb3dlZF9rZXkiLCJzZXRfbWF4X2FsbG93ZWRfa2V5IiwibWluX2FsbG93ZWRfa2V5Iiwic2V0X21pbl9hbGxvd2VkX2tleSIsImxlbmd0aCIsInNldF9sZW5ndGgiLCJkaWZmX21heF9taW5fYWxsb3dlZF9rZXkiLCJtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrIiwia2V5c19wZXJfc2xvdCIsInNsb3RzX21hc2siLCJpbmRleCIsInNsb3RzJDAiLCJtYXhfYWxsb3dlZF9rZXkkMCIsIm1pbl9hbGxvd2VkX2tleSQwIiwibGVuZ3RoJDAiLCJkaWZmX21heF9taW5fYWxsb3dlZF9rZXkkMCIsIm1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2skMCIsImtleXNfcGVyX3Nsb3QkMCIsImJpdHNfcGVyX3Nsb3QkMCIsInNsb3RzX21hc2skMCIsImJpdHMkMCIsImluZGV4JDAiLCJzZXhwX29mX3QkOSIsIm9mX2FfMDY1IiwiZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5XzA3OSIsIm1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tfMDc3Iiwia2V5c19wZXJfc2xvdF8wNzUiLCJiaXRzX3Blcl9zbG90XzA3MyIsInNsb3RzX21hc2tfMDcxIiwiYml0c18wNjkiLCJpbmRleF8wNjciLCJsZW5ndGhfMDgxIiwibWluX2FsbG93ZWRfa2V5XzA4MyIsIm1heF9hbGxvd2VkX2tleV8wODUiLCJzbG90c18wODciLCJhcmdfMDg4IiwiYm5kc18wNjYiLCJhcmdfMDg2IiwiYm5kc18wNjYkMCIsImFyZ18wODQiLCJibmRzXzA2NiQxIiwiYXJnXzA4MiIsImJuZHNfMDY2JDIiLCJhcmdfMDgwIiwiYm5kc18wNjYkMyIsImFyZ18wNzgiLCJibmRzXzA2NiQ0IiwiYXJnXzA3NiIsImJuZHNfMDY2JDUiLCJhcmdfMDc0IiwiYm5kc18wNjYkNiIsImFyZ18wNzIiLCJibmRzXzA2NiQ3IiwiYXJnXzA3MCIsImJuZHNfMDY2JDgiLCJhcmdfMDY4IiwiYm5kc18wNjYkOSIsInNsb3QiLCJuZXh0X3Nsb3QiLCJtaW5fa2V5X2luX3NhbWVfc2xvdCIsImNvbXB1dGVfbWluX2FsbG93ZWRfa2V5IiwicHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkiLCJsZXZlbHMiLCJlbHRfa2V5X2xvd2VyX2JvdW5kIiwic2V0X2VsdF9rZXlfbG93ZXJfYm91bmQiLCJtaW5fZWx0Iiwic2V0X21pbl9lbHQiLCJzZXRfcG9vbCIsImxlbmd0aCQxIiwic2V0X2xlbmd0aCQwIiwibGV2ZWxzJDAiLCJlbHRfa2V5X2xvd2VyX2JvdW5kJDAiLCJtaW5fZWx0JDAiLCJwb29sJDAiLCJsZW5ndGgkMiIsImlzX2VtcHR5IiwibnVtX2xldmVscyIsIm1pbl9hbGxvd2VkX2tleSQxIiwibWF4X2FsbG93ZWRfa2V5JDEiLCJpbnRlcm5hbF9pdGVyIiwibGV2ZWwiLCJzbG90X2luZGV4IiwiZWx0IiwiY29tcHV0ZV9kaWZmX21heF9taW5fYWxsb3dlZF9rIiwibWluX2VsdCQxIiwibWluX2VsdF9hbHJlYWR5X2ZvdW5kIiwibWluX2tleV9hbHJlYWR5X2ZvdW5kIiwibnVtX2xldmVscyQwIiwic2xvdF9taW5fa2V5Iiwic2xvdCQwIiwiY3VycmVudF9rZXkiLCJhZGRfZWx0IiwieF8xMzUiLCJ0b19hZGQiLCJrZXkkMCIsImVsdHNfMTE1IiwibWF4X2FsbG93ZWRfa2V5XzExMyIsIm1pbl9hbGxvd2VkX2tleV8xMTEiLCJhcmdfMTE2Iiwia2V5XzEwNSIsImJuZHNfMTA0IiwiYXJnXzEwNiIsImJuZHNfMTA0JDAiLCJibmRzXzExMCIsImFyZ18xMTQiLCJibmRzXzExMCQwIiwiYXJnXzExMiIsImJuZHNfMTEwJDEiLCJyJDAiLCJsZXZlbF9pbmRleCQwIiwicHJldiQwIiwiaW50ZXJuYWxfYWRkX2VsdCIsImVuc3VyZV92YWxpZF9rZXkiLCJpbnRlcm5hbF9hZGQiLCJpbnRlcm5hbF9yZW1vdmUiLCJtaW5faW50ZXJ2YWxfbnVtIiwicHJpb3JpdHlfcXVldWUiLCJtYXhfYWxsb3dlZF9hbGFybV90aW1lIiwic2V0X21heF9hbGxvd2VkX2FsYXJtX3RpbWUiLCJub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0Iiwic2V0X25vd19pbnRlcnZhbF9udW1fc3RhcnQiLCJub3ciLCJzZXRfbm93IiwibWF4X2ludGVydmFsX251bSIsInN0YXJ0IiwiY29uZmlnIiwicHJpb3JpdHlfcXVldWUkMCIsIm1heF9hbGxvd2VkX2FsYXJtX3RpbWUkMCIsIm5vd19pbnRlcnZhbF9udW1fc3RhcnQkMCIsIm5vdyQwIiwibWF4X2ludGVydmFsX251bSQwIiwic3RhcnQkMCIsImNvbmZpZyQwIiwic2V4cF9vZl90X25vdyIsImFsYXJtX3ByZWNpc2lvbiQwIiwiYXQkMCIsInR3IiwidmFsdWUkMCIsImludGVydmFsX251bSIsIml0ZXIkMCIsImNvbXBhcmUkMyIsInNleHBfb2ZfdCQxMCIsInNleHBfb2ZfYSIsIm1heF9pbnRlcnZhbF9udW1fMTY3Iiwic3RhcnRfMTY1IiwiY29uZmlnXzE2MyIsIm5vd18xNjkiLCJhbGFybSIsImFsYXJtc18xNzEiLCJhcmdfMTcyIiwidmFsdWVfMTU5IiwiYXRfMTU3IiwiYXJnXzE2MCIsImJuZHNfMTU2IiwiYXJnXzE1OCIsImJuZHNfMTU2JDAiLCJibmRzXzE2MiIsImFyZ18xNzAiLCJibmRzXzE2MiQwIiwiYXJnXzE2OCIsImJuZHNfMTYyJDEiLCJhcmdfMTY2IiwiYm5kc18xNjIkMiIsImFyZ18xNjQiLCJibmRzXzE2MiQzIiwibGVuZ3RoJDMiLCJpc19lbXB0eSQwIiwicG9vbCQxIiwiaW50ZXJ2YWxfbnVtX2ludGVybmFsIiwidGltZSIsImludGVydmFsX251bV91bmNoZWNrZWQiLCJpbnRlcnZhbF9udW0kMCIsImludGVydmFsX251bV9zdGFydF91bmNoZWNrZWQiLCJpbnRlcnZhbF9udW1fc3RhcnQiLCJuZXh0X2FsYXJtX2ZpcmVzX2F0X2ludGVybmFsIiwibmV4dF9hbGFybV9maXJlc19hdCIsIm5leHRfYWxhcm1fZmlyZXNfYXRfZXhuIiwieF8xNzQiLCJjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUiLCJub3dfaW50ZXJ2YWxfbnVtIiwibWF4X2FsbG93ZWRfYWxhcm1faW50ZXJ2YWxfbnVtIiwiaW50ZXJ2YWxfc3RhcnQiLCJpbnZhcmlhbnQkMiIsImludmFyaWFudF9hIiwieF8xNzYiLCJjaGVjayIsInByaW9yaXR5X3F1ZXVlX2Z1biIsInhfMTMwIiwib2ZfYV8wODkiLCJsZW5ndGhfMDkxIiwicG9vbF8wOTMiLCJtaW5fZWx0XzA5NSIsImVsdF9rZXlfbG93ZXJfYm91bmRfMDk3IiwibGV2ZWxzXzA5OSIsImFyZ18xMDAiLCJibmRzXzA5MCIsImFyZ18wOTgiLCJibmRzXzA5MCQwIiwiYXJnXzA5NiIsImJuZHNfMDkwJDEiLCJhcmdfMDk0IiwiYm5kc18wOTAkMiIsImFyZ18wOTIiLCJibmRzXzA5MCQzIiwibGV2ZWxzX2Z1biIsInhfMTE5Iiwic2xvdHNfZnVuIiwieF8wNjIiLCJuIiwibWF4X2FsbG93ZWRfa2V5X2Z1biIsImV4cGVjdCIsImNvbXBhcmF0b3IiLCJhXzEyOCIsImJfMTI5IiwibWluX2FsbG93ZWRfa2V5X2Z1biIsImdvdCIsInNleHBpZmllciIsImFfMTI2IiwiYl8xMjciLCJsZW5ndGhfZnVuIiwiZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5X2Z1biIsImV0YSIsImFfMTI0IiwiYl8xMjUiLCJtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrX2Z1biIsImtleXNfcGVyX3Nsb3RfZnVuIiwiYV8xMjIiLCJiXzEyMyIsImJpdHNfcGVyX3Nsb3RfZnVuIiwiZXhwZWN0JDAiLCJzbG90c19tYXNrX2Z1biIsImFfMTIwIiwiYl8xMjEiLCJiaXRzX2Z1biIsImluZGV4X2Z1biIsInByZXZfbGV2ZWwiLCJnb3QkMCIsImFfMTMxIiwiYl8xMzIiLCJjb21wYXJhdG9yJDAiLCJhXzEzMyIsImJfMTM0IiwiZWx0X2tleV9sb3dlcl9ib3VuZF9mdW4iLCJtaW5fZWx0X2Z1biIsInBvb2xfZnVuIiwibWF4X2FsbG93ZWRfYWxhcm1fdGltZV9mdW4iLCJhXzE4MyIsImJfMTg0Iiwibm93X2ludGVydmFsX251bV9zdGFydF9mdW4iLCJhXzE4MSIsImJfMTgyIiwibm93X2Z1biIsIm1heF9pbnRlcnZhbF9udW1fZnVuIiwiYV8xNzciLCJiXzE3OCIsInNleHBpZmllciQwIiwiYV8xNzkiLCJiXzE4MCIsInN0YXJ0X2Z1biIsImNvbmZpZ19mdW4iLCJkZWJ1ZyIsImFkdmFuY2VfY2xvY2siLCJ0byIsImhhbmRsZV9yZW1vdmVkIiwidF9taW5fYWxsb3dlZF9rZXkiLCJ0JDEiLCJyZXN1bHQiLCJtaW5fYWxsb3dlZF9rZXlfYmVmb3JlIiwicHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkkMCIsImRlc2lyZWRfbWluX2FsbG93ZWRfa2V5IiwibGV2ZWxfbWluX2FsbG93ZWRfa2V5IiwibGV2ZWxfbWluX2FsbG93ZWRfa2V5JDAiLCJjcmVhdGUkMiIsImNhcGFjaXR5JDAiLCJtYXhfbGV2ZWxfbWluX2FsbG93ZWRfa2V5IiwiYWRkX2F0X2ludGVydmFsX251bSIsImVuc3VyZV9jYW5fc2NoZWR1bGVfYWxhcm0iLCJhZGQkMCIsInJlbW92ZSIsImNsZWFyIiwiZnJlZV9lbHQiLCJtZW0iLCJyZXNjaGVkdWxlX2dlbiIsInJlc2NoZWR1bGUiLCJyZXNjaGVkdWxlX2F0X2ludGVydmFsX251bSIsIm1pbl9hbGFybV9pbnRlcnZhbF9udW0iLCJtaW5fYWxhcm1faW50ZXJ2YWxfbnVtX2V4biIsInhfMTg1IiwibWF4X2FsYXJtX3RpbWVfaW5fbGlzdCIsIndpdGhfa2V5IiwibWF4X2FsYXJtX3RpbWUiLCJtaW5fYWxhcm1fdGltZV9pbl9saXN0IiwibWluX2FsYXJtX3RpbWUiLCJtYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwiLCJtaW5fYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwiLCJtYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwkMCIsInhfMTg2IiwibWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsJDAiLCJ4XzE4NyIsImZpcmVfcGFzdF9hbGFybXMiLCJoYW5kbGVfZmlyZWQiXSwic291cmNlcyI6WyIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2NvcmVfa2VybmVsL3RpbWluZ193aGVlbC90aW1pbmdfd2hlZWwubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7O0lBOGxEMEJBO0lBSEFDO0lBZ0JBQztJQUtBQztJQS94QmhCQztJQTRKc0JDO0lBSEFDO0lBckdEQztJQU9EQztJQVlDQztJQWtCQ0M7SUFLRkM7O0lBcnNCNUJDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F6TGtEO0lBSWhEQztJQUNBQzs7Ozs7Ozs7O0lBc0RFQztJQWpDQUM7Ozs7Ozs7Ozs7Ozs7WUFLQUMsVUFBVUM7SUFDWixLQUFPLG1CQURLQSxHQUxWRjtLQU1GLE1BQUE7SUFDTyxHQUFBLHFCQUZLRSxHQTRCVkg7SUExQkYsTUFBQTtHQUF1QjtZQUdyQkksT0FBT0MsR0FMUEgsVUFLT0csSUFDVCxPQURTQSxFQUVSO1lBR0NDLFNBQU1DLElBQUdDLElBQ1gsSUFBSUwsSUFESUksS0FBR0MsUUFWVE4sVUFXRUMsSUFDSixPQURJQSxFQUVIO1lBR0NNLFNBQU1GLElBQUdDLElBQ1gsSUFBSUwsSUFESUksS0FBR0MsUUFoQlROLFVBaUJFQyxJQUNKLE9BRElBLEVBRUg7WUFHQ08sS0FBS1AsR0FBSSxPQUFBLDJDQUFKQSxHQUFnQztZQUl6Q1EsWUFBQUM7SUFBQSxP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QyxnQkE0QmlCMUssS0E1ckJIMEk7UUFndEJSLFdBbHZCSjFHLE1Bb3VCRWUsTUFsc0JVMkY7UUFtc0JWeEYsNEJBRkFLLE9BREEwRixZQUFBQTs7Ozs7Ozs7Ozs7R0ErY0k7Ozs7Ozs7OztRQTlrRFIvTTtRQTVCQUs7UUFaQUo7UUE0Q0lRO1FBQUFBO1FBQ0FMOzs7UUEvQkpFOzs7UUFJQUM7UUFDQUM7O09BeXhDRjJQO09BckRBUjs7V0FJRm5LLGFBRUlHLFFBQ0FrSyxNQUVBRyxjQURBRDtPQWdLRjZDOztRQXg5Q0V0VDtRQWRKTjtRQTBKY0k7UUF4SlZmO1FBa0JBbUI7UUEwR0FPO1FBMUhBWjs7UUE0SEo0QjtRQUFBMEI7UUFvQkllO1FBYUFFO1FBMUJBSjtRQUxBM0M7UUE2Q0FzRDtRQVBBRDtPQXE0Q0ZzVTtPQTlPQTFJO09BWFFiO09BSFJHO09BeUVBMEM7T0FEQUQ7T0E5Q0ExQjtPQXdFQWdDO09BOEVBUTtPQS9DQU47T0FrREFRO09BcURBZ0Y7T0ErSkFzQztPQWxZUXRMO09BMktSOEQ7T0FFQUM7T0FnSUFpRztPQS9CQUY7T0EyQ0FNO09BRkFIO09BV0FLO09BRUFDO09BWkFMO09BZ0JBTTtPQUtBQztPQXFCQU87T0FLQUM7T0FLQUM7T0FXQUU7T0ExT0ExSDtPQVdBQztXQW5nREFuVSxVQWc4Q0EyVCwyQkFyNkNFdlQ7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogQmUgc3VyZSBhbmQgZmlyc3QgcmVhZCB0aGUgaW1wbGVtZW50YXRpb24gb3ZlcnZpZXcgaW4gdGltaW5nX3doZWVsX2ludGYubWwuXG5cbiAgIEEgdGltaW5nIHdoZWVsIGlzIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIFwibGV2ZWxzXCIsIHdoZXJlIGVhY2ggbGV2ZWwgaXMgYW4gYXJyYXkgb2ZcbiAgIFwic2xvdHNcIi4gIEVhY2ggc2xvdCByZXByZXNlbnRzIGEgcmFuZ2Ugb2Yga2V5cywgYW5kIGhvbGRzIGVsZW1lbnRzIGFzc29jaWF0ZWQgd2l0aFxuICAgdGhvc2Uga2V5cy4gIEVhY2ggbGV2ZWwgaXMgZGV0ZXJtaW5lZCBieSB0d28gcGFyYW1ldGVyczogW2JpdHNdLCB0aGUgbnVtYmVyIG9mIGtleSBiaXRzXG4gICB0aGF0IHRoYXQgbGV2ZWwgaXMgcmVzcG9uc2libGUgZm9yIGRpc3Rpbmd1aXNoaW5nLCBhbmQgW2JpdHNfcGVyX3Nsb3RdLCB0aGUgc2l6ZSBvZiB0aGVcbiAgIHJhbmdlIG9mIGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIGEgc2luZ2xlIHNsb3QgaW4gdGhlIGFycmF5LiAgQ29uY2VwdHVhbGx5LCBlYWNoIGxldmVsXG4gICBicmVha3MgdXAgYWxsIHBvc3NpYmxlIGtleXMgaW50byByYW5nZXMgb2Ygc2l6ZSBbMl5iaXRzX3Blcl9zbG90XS4gIFRoZSBsZW5ndGggb2YgYVxuICAgbGV2ZWwgYXJyYXkgaXMgWzJeYml0c10sIGFuZCB0aGUgYXJyYXkgaXMgdXNlZCBsaWtlIGEgY2lyY3VsYXIgYnVmZmVyIHRvIHRyYXZlcnNlIHRoZVxuICAgcmFuZ2VzIGFzIHRoZSB0aW1pbmcgd2hlZWwncyBbbWluX2FsbG93ZWRfa2V5XSBpbmNyZWFzZXMuICBBIGtleSBba10sIGlmIHN0b3JlZCBpbiB0aGVcbiAgIGxldmVsLCBpcyBzdG9yZWQgYXQgaW5kZXggWyhrIC8gMl5iaXRzX3Blcl9zbG90KSBtb2QgMl5iaXRzXS5cblxuICAgVGhlIHNldHRpbmdzIG9mIHRoZSBbYml0c10gdmFsdWVzIGFyZSBjb25maWd1cmFibGUgYnkgdXNlciBjb2RlIHVzaW5nIFtMZXZlbF9iaXRzXSxcbiAgIGFsdGhvdWdoIHRoZXJlIGlzIGEgcmVhc29uYWJsZSBkZWZhdWx0IHNldHRpbmcuICBHaXZlbiB0aGUgW2JpdHNdIHZhbHVlcywgdGhlXG4gICBbYml0c19wZXJfc2xvdF0gYXJlIGNob3NlbiBzbyB0aGF0IFtiaXRzX3Blcl9zbG90XSBhdCBsZXZlbCBbaV0gaXMgdGhlIHN1bSBvZiB0aGVcbiAgIFtiaXRzXSBhdCBhbGwgbG93ZXIgbGV2ZWxzLiAgVGh1cywgYSBzbG90J3MgcmFuZ2UgYXQgbGV2ZWwgW2ldIGlzIGFzIGxhcmdlIGFzIHRoZVxuICAgZW50aXJlIHJhbmdlIG9mIHRoZSBhcnJheSBhdCBsZXZlbCBbaSAtIDFdLlxuXG4gICBFYWNoIGxldmVsIGhhcyBhIFttaW5fYWxsb3dlZF9rZXldIGFuZCBhIFttYXhfYWxsb3dlZF9rZXldIHRoYXQgZGV0ZXJtaW5lIHRoZSByYW5nZSBvZlxuICAga2V5cyB0aGF0IGl0IGN1cnJlbnRseSByZXByZXNlbnRzLiAgVGhlIGNydWNpYWwgaW52YXJpYW50IG9mIHRoZSB0aW1pbmcgd2hlZWwgZGF0YVxuICAgc3RydWN0dXJlIGlzIHRoYXQgdGhlIFttaW5fYWxsb3dlZF9rZXldIGF0IGxldmVsIFtpXSBpcyBubyBtb3JlIHRoYW4gdGhlXG4gICBbbWF4X2FsbG93ZWRfa2V5ICsgMV0gb2YgbGV2ZWwgW2kgLSAxXS4gIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBsZXZlbHMgY2FuIHJlcHJlc2VudCBhbGxcbiAgIGtleXMgZnJvbSB0aGUgW21pbl9hbGxvd2VkX2tleV0gb2YgdGhlIGxvd2VzdCBsZXZlbCB0byB0aGUgW21heF9hbGxvd2VkX2tleV0gb2YgdGhlXG4gICBoaWdoZXN0IGxldmVsLiAgVGhlIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciByZXN0b3JpbmdcbiAgIHRoaXMgaW52YXJpYW50LlxuXG4gICBBdCBsZXZlbCAwLCBbYml0c19wZXJfc2xvdCA9IDBdLCBhbmQgc28gdGhlIHNpemUgb2YgZWFjaCBzbG90IGlzIFsxXS4gIFRoYXQgaXMsIGxldmVsIDBcbiAgIHByZWNpc2VseSBkaXN0aW5ndWlzaGVzIGFsbCB0aGUga2V5cyBiZXR3ZWVuIGl0cyBbbWluX2FsbG93ZWRfa2V5XSAod2hpY2ggaXMgdGhlIHNhbWVcbiAgIGFzIHRoZSBbbWluX2FsbG93ZWRfa2V5XSBvZiB0aGUgZW50aXJlIHRpbWluZyB3aGVlbCkgYW5kIFttYXhfYWxsb3dlZF9rZXldLiAgQXMgdGhlXG4gICBsZXZlbHMgaW5jcmVhc2UsIHRoZSBbbWluX2FsbG93ZWRfa2V5XSBpbmNyZWFzZXMsIHRoZSBbYml0c19wZXJfc2xvdF0gaW5jcmVhc2VzLCBhbmRcbiAgIHRoZSByYW5nZSBvZiBrZXlzIHN0b3JlZCBpbiB0aGUgbGV2ZWwgaW5jcmVhc2VzIChkcmFtYXRpY2FsbHkpLlxuXG4gICBUaGUgaWRlYSBvZiB0aGUgaW1wbGVtZW50YXRpb24gaXMgc2ltaWxhciB0byB0aGUgaGllcmFyY2hpY2FsIGFwcHJvYWNoIGRlc2NyaWJlZCBpbjpcblxuICAge3ZcbiAgICAgSGFzaGVkIGFuZCBIaWVyYXJjaGljYWwgVGltaW5nIFdoZWVsczpcbiAgICAgRWZmaWNpZW50IERhdGEgU3RydWN0dXJlcyBmb3IgSW1wbGVtZW50aW5nIGEgVGltZXIgRmFjaWxpdHlcblxuICAgICBWYXJnaGVzZSAmIExhdWNrLCAxOTk2XG4gICB2fVxuXG4gICBIb3dldmVyLCB0aGUgY29kZSBpcyBjb21wbGV0ZWx5IG5ldy4gKilcblxub3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuISBUaW1pbmdfd2hlZWxfaW50ZlxubW9kdWxlIFBvb2wgPSBUdXBsZV9wb29sXG5tb2R1bGUgVGltZV9ucyA9IENvcmVfcHJpdmF0ZS5UaW1lX25zX2FsdGVybmF0ZV9zZXhwXG5cbmxldCBzZXhwX29mX3Rfc3R5bGUgOiBbIGBQcmV0dHkgfCBgSW50ZXJuYWwgXSByZWYgPSByZWYgYFByZXR0eVxuXG4oKiBbe21heCxtaW59X3RpbWVdIGFyZSBib3VuZHMgb24gdGhlIHRpbWVzIHN1cHBvcnRlZCBieSBhIHRpbWluZyB3aGVlbC4gKilcblxubGV0IG1heF90aW1lID0gVGltZV9ucy5tYXhfdmFsdWVfcmVwcmVzZW50YWJsZVxubGV0IG1pbl90aW1lID0gVGltZV9ucy5lcG9jaFxuXG5tb2R1bGUgTnVtX2tleV9iaXRzIDogc2lnXG4gIHR5cGUgdCA9IHByaXZhdGUgaW50IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG5cbiAgaW5jbHVkZSBDb21wYXJhYmxlIHdpdGggdHlwZSB0IDo9IHRcbiAgaW5jbHVkZSBJbnZhcmlhbnQuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsIHplcm8gOiB0XG5cbiAgKCogdmFsIG1pbl92YWx1ZSA6IHQgKilcblxuICB2YWwgbWF4X3ZhbHVlIDogdFxuICB2YWwgdG9faW50IDogdCAtPiBpbnRcbiAgdmFsIG9mX2ludCA6IGludCAtPiB0XG4gIHZhbCAoICsgKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCAoIC0gKSA6IHQgLT4gdCAtPiB0XG4gIHZhbCBwb3cyIDogdCAtPiBJbnQ2My50XG5lbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJbnRcblxuICBsZXQgbWluX3ZhbHVlID0gMFxuXG4gICgqKiBXZSBzdXBwb3J0IGFsbCBub24tbmVnYXRpdmUgW1RpbWVfbnMudF0gdmFsdWVzLiAqKVxuICBsZXQgbWF4X3ZhbHVlID0gSW50NjMubnVtX2JpdHMgLSAxXG5cbiAgbGV0IGludmFyaWFudCB0ID1cbiAgICBhc3NlcnQgKHQgPj0gbWluX3ZhbHVlKTtcbiAgICBhc3NlcnQgKHQgPD0gbWF4X3ZhbHVlKVxuICA7O1xuXG4gIGxldCBvZl9pbnQgaSA9XG4gICAgaW52YXJpYW50IGk7XG4gICAgaVxuICA7O1xuXG4gIGxldCAoICsgKSB0MSB0MiA9XG4gICAgbGV0IHQgPSB0MSArIHQyIGluXG4gICAgaW52YXJpYW50IHQ7XG4gICAgdFxuICA7O1xuXG4gIGxldCAoIC0gKSB0MSB0MiA9XG4gICAgbGV0IHQgPSB0MSAtIHQyIGluXG4gICAgaW52YXJpYW50IHQ7XG4gICAgdFxuICA7O1xuXG4gIGxldCBwb3cyIHQgPSBJbnQ2My5zaGlmdF9sZWZ0IEludDYzLm9uZSB0XG5lbmRcblxubW9kdWxlIExldmVsX2JpdHMgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gTnVtX2tleV9iaXRzLnQgbGlzdCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuXG4gIGxldCBtYXhfbnVtX2JpdHMgPSAoTnVtX2tleV9iaXRzLm1heF92YWx1ZSA6PiBpbnQpXG4gIGxldCBudW1fYml0c19pbnRlcm5hbCB0ID0gTGlzdC5mb2xkIHQgfmluaXQ6TnVtX2tleV9iaXRzLnplcm8gfmY6TnVtX2tleV9iaXRzLiggKyApXG4gIGxldCBudW1fYml0cyB0ID0gKG51bV9iaXRzX2ludGVybmFsIHQgOj4gaW50KVxuXG4gIGxldCBpbnZhcmlhbnQgdCA9XG4gICAgYXNzZXJ0IChub3QgKExpc3QuaXNfZW1wdHkgdCkpO1xuICAgIExpc3QuaXRlciB0IH5mOihmdW4gbnVtX2tleV9iaXRzIC0+XG4gICAgICBOdW1fa2V5X2JpdHMuaW52YXJpYW50IG51bV9rZXlfYml0cztcbiAgICAgIGFzc2VydCAoTnVtX2tleV9iaXRzLiggPiApIG51bV9rZXlfYml0cyBOdW1fa2V5X2JpdHMuemVybykpO1xuICAgIE51bV9rZXlfYml0cy5pbnZhcmlhbnQgKG51bV9iaXRzX2ludGVybmFsIHQpXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCBzZXhwID1cbiAgICBsZXQgdCA9IHNleHAgfD4gWyVvZl9zZXhwOiB0XSBpblxuICAgIGludmFyaWFudCB0O1xuICAgIHRcbiAgOztcblxuICBsZXQgY3JlYXRlX2V4biA/KGV4dGVuZF90b19tYXhfbnVtX2JpdHMgPSBmYWxzZSkgaW50cyA9XG4gICAgaWYgTGlzdC5pc19lbXB0eSBpbnRzIHRoZW4gZmFpbHdpdGggXCJMZXZlbF9iaXRzLmNyZWF0ZV9leG4gcmVxdWlyZXMgYSBub25lbXB0eSBsaXN0XCI7XG4gICAgaWYgTGlzdC5leGlzdHMgaW50cyB+ZjooZnVuIGJpdHMgLT4gYml0cyA8PSAwKVxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlIFwiTGV2ZWxfYml0cy5jcmVhdGVfZXhuIGdvdCBub25wb3NpdGl2ZSBudW0gYml0c1wiIH5fOihpbnRzIDogaW50IGxpc3QpXTtcbiAgICBsZXQgbnVtX2JpdHMgPSBMaXN0LmZvbGQgaW50cyB+aW5pdDowIH5mOiggKyApIGluXG4gICAgaWYgbnVtX2JpdHMgPiBtYXhfbnVtX2JpdHNcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiTGV2ZWxfYml0cy5jcmVhdGVfZXhuIGdvdCB0b28gbWFueSBiaXRzXCJcbiAgICAgICAgICAgIH5fOihpbnRzIDogaW50IGxpc3QpXG4gICAgICAgICAgICB+Z290OihudW1fYml0cyA6IGludClcbiAgICAgICAgICAgIChtYXhfbnVtX2JpdHMgOiBpbnQpXTtcbiAgICBsZXQgaW50cyA9XG4gICAgICBpZiBleHRlbmRfdG9fbWF4X251bV9iaXRzXG4gICAgICB0aGVuIGludHMgQCBMaXN0LmluaXQgKG1heF9udW1fYml0cyAtIG51bV9iaXRzKSB+ZjooY29uc3QgMSlcbiAgICAgIGVsc2UgaW50c1xuICAgIGluXG4gICAgTGlzdC5tYXAgaW50cyB+ZjpOdW1fa2V5X2JpdHMub2ZfaW50XG4gIDs7XG5cbiAgbGV0IGRlZmF1bHQgPSBjcmVhdGVfZXhuIFsgMTE7IDEwOyAxMDsgMTA7IDEwOyAxMDsgMSBdXG5cbiAgbGV0IHRyaW0gdCB+bWF4X251bV9iaXRzID1cbiAgICBpZiBOdW1fa2V5X2JpdHMuKCA8PSApIChudW1fYml0c19pbnRlcm5hbCB0KSBtYXhfbnVtX2JpdHNcbiAgICB0aGVuIHRcbiAgICBlbHNlIChcbiAgICAgIGxldCByZWMgbG9vcCB0IH5yZW1haW5pbmcgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBbXSAtPiBbXVxuICAgICAgICB8IGIgOjogdCAtPlxuICAgICAgICAgIGlmIE51bV9rZXlfYml0cy4oID49ICkgYiByZW1haW5pbmdcbiAgICAgICAgICB0aGVuIFsgcmVtYWluaW5nIF1cbiAgICAgICAgICBlbHNlIGIgOjogbG9vcCB0IH5yZW1haW5pbmc6KE51bV9rZXlfYml0cy4oIC0gKSByZW1haW5pbmcgYilcbiAgICAgIGluXG4gICAgICBsb29wIHQgfnJlbWFpbmluZzptYXhfbnVtX2JpdHMpXG4gIDs7XG5lbmRcblxubW9kdWxlIEFsYXJtX3ByZWNpc2lvbiA6IHNpZ1xuICBpbmNsdWRlIEFsYXJtX3ByZWNpc2lvblxuXG4gIHZhbCBudW1fa2V5X2JpdHMgOiB0IC0+IE51bV9rZXlfYml0cy50XG4gIHZhbCBpbnRlcnZhbF9udW0gOiB0IC0+IFRpbWVfbnMudCAtPiBJbnQ2My50XG4gIHZhbCBpbnRlcnZhbF9udW1fc3RhcnQgOiB0IC0+IEludDYzLnQgLT4gVGltZV9ucy50XG5lbmQgPSBzdHJ1Y3RcbiAgKCoqIFt0XSBpcyByZXByZXNlbnRlZCBhcyB0aGUgbG9nMiBvZiBhIG51bWJlciBvZiBuYW5vc2Vjb25kcy4gKilcbiAgdHlwZSB0ID0gaW50IFtAQGRlcml2aW5nIGNvbXBhcmUsIGhhc2hdXG5cbiAgbGV0IGVxdWFsID0gWyVjb21wYXJlLmVxdWFsOiB0XVxuICBsZXQgbnVtX2tleV9iaXRzIHQgPSB0IHw+IE51bV9rZXlfYml0cy5vZl9pbnRcblxuICBsZXQgdG9fc3BhbiB0ID1cbiAgICBpZiB0IDwgMFxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJbQWxhcm1fcHJlY2lzaW9uLnRvX3NwYW5dIG9mIG5lZ2F0aXZlIHBvd2VyIG9mIHR3byBuYW5vc2Vjb25kc1wiIH5fOih0IDogaW50KV07XG4gICAgSW50NjMuKHNoaWZ0X2xlZnQgb25lKSB0IHw+IFRpbWVfbnMuU3Bhbi5vZl9pbnQ2M19uc1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgdCA9IFslc2V4cCAodCB8PiB0b19zcGFuIDogVGltZV9ucy5TcGFuLnQpXVxuICBsZXQgb25lX25hbm9zZWNvbmQgPSAwXG4gIGxldCBhYm91dF9vbmVfbWljcm9zZWNvbmQgPSAxMFxuICBsZXQgYWJvdXRfb25lX21pbGxpc2Vjb25kID0gMjBcbiAgbGV0IGFib3V0X29uZV9zZWNvbmQgPSAzMFxuICBsZXQgYWJvdXRfb25lX2RheSA9IDQ2XG4gIGxldCBtdWwgdCB+cG93MiA9IHQgKyBwb3cyXG4gIGxldCBkaXYgdCB+cG93MiA9IHQgLSBwb3cyXG4gIGxldCBpbnRlcnZhbF9udW0gdCB0aW1lID0gSW50NjMuc2hpZnRfcmlnaHQgKHRpbWUgfD4gVGltZV9ucy50b19pbnQ2M19uc19zaW5jZV9lcG9jaCkgdFxuXG4gIGxldCBpbnRlcnZhbF9udW1fc3RhcnQgdCBpbnRlcnZhbF9udW0gPVxuICAgIEludDYzLnNoaWZ0X2xlZnQgaW50ZXJ2YWxfbnVtIHQgfD4gVGltZV9ucy5vZl9pbnQ2M19uc19zaW5jZV9lcG9jaFxuICA7O1xuXG4gIGxldCBvZl9zcGFuX2Zsb29yX3BvdzJfbnMgc3BhbiA9XG4gICAgaWYgVGltZV9ucy5TcGFuLiggPD0gKSBzcGFuIFRpbWVfbnMuU3Bhbi56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICBcIltBbGFybV9wcmVjaXNpb24ub2Zfc3Bhbl9mbG9vcl9wb3cyX25zXSBnb3Qgbm9uLXBvc2l0aXZlIHNwYW5cIlxuICAgICAgICAgICAgKHNwYW4gOiBUaW1lX25zLlNwYW4udCldO1xuICAgIHNwYW4gfD4gVGltZV9ucy5TcGFuLnRvX2ludDYzX25zIHw+IEludDYzLmZsb29yX2xvZzJcbiAgOztcblxuICBsZXQgb2Zfc3BhbiA9IG9mX3NwYW5fZmxvb3JfcG93Ml9uc1xuXG4gIG1vZHVsZSBVbnN0YWJsZSA9IHN0cnVjdFxuICAgIG1vZHVsZSBUID0gc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdCBbQEBkZXJpdmluZyBjb21wYXJlXVxuXG4gICAgICBsZXQgb2ZfYmluYWJsZSA9IG9mX3NwYW5fZmxvb3JfcG93Ml9uc1xuICAgICAgbGV0IHRvX2JpbmFibGUgPSB0b19zcGFuXG4gICAgICBsZXQgb2Zfc2V4cGFibGUgPSBvZl9zcGFuX2Zsb29yX3BvdzJfbnNcbiAgICAgIGxldCB0b19zZXhwYWJsZSA9IHRvX3NwYW5cbiAgICBlbmRcblxuICAgIGluY2x1ZGUgVFxuICAgIGluY2x1ZGUgQmluYWJsZS5PZl9iaW5hYmxlX3dpdGhvdXRfdXVpZCBbQGFsZXJ0IFwiLWxlZ2FjeVwiXSAoVGltZV9ucy5TcGFuKSAoVClcbiAgICBpbmNsdWRlIFNleHBhYmxlLk9mX3NleHBhYmxlIChUaW1lX25zLlNwYW4pIChUKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgQ29uZmlnID0gc3RydWN0XG4gIGxldCBsZXZlbF9iaXRzX2RlZmF1bHQgPSBMZXZlbF9iaXRzLmRlZmF1bHRcblxuICB0eXBlIHQgPVxuICAgIHsgYWxhcm1fcHJlY2lzaW9uIDogQWxhcm1fcHJlY2lzaW9uLlVuc3RhYmxlLnRcbiAgICA7IGxldmVsX2JpdHMgOiBMZXZlbF9iaXRzLnQgW0BkZWZhdWx0IGxldmVsX2JpdHNfZGVmYXVsdF1cbiAgICA7IGNhcGFjaXR5IDogaW50IG9wdGlvbiBbQHNleHAub3B0aW9uXVxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwXVxuXG4gIGxldCBhbGFybV9wcmVjaXNpb24gdCA9IEFsYXJtX3ByZWNpc2lvbi50b19zcGFuIHQuYWxhcm1fcHJlY2lzaW9uXG5cbiAgKCogW21heF9udW1fbGV2ZWxfYml0cyBhbGFybV9wcmVjaXNpb25dIHJldHVybnMgdGhlIG51bWJlciBvZiBsZXZlbCBiaXRzIG5lZWRlZCBmb3IgYVxuICAgICB0aW1pbmcgd2hlZWwgd2l0aCB0aGUgc3BlY2lmaWVkIFthbGFybV9wcmVjaXNpb25dIHRvIGJlIGFibGUgdG8gcmVwcmVzZW50IGFsbFxuICAgICBwb3NzaWJsZSB0aW1lcyBmcm9tIFtUaW1lX25zLmVwb2NoXSBvbndhcmQuICBTaW5jZSBub24tbmVnYXRpdmUgdGltZXMgaGF2ZSA2MiBiaXRzLFxuICAgICB3ZSByZXF1aXJlIFtMIDw9IDYyIC0gQV0sIHdoZXJlIFtBXSBpcyB0aGUgbnVtYmVyIG9mIGFsYXJtIGJpdHMgYW5kIFtMXSBpcyB0aGVcbiAgICAgbnVtYmVyIG9mIGxldmVsIGJpdHMuICopXG4gIGxldCBtYXhfbnVtX2xldmVsX2JpdHMgYWxhcm1fcHJlY2lzaW9uID1cbiAgICBOdW1fa2V5X2JpdHMuKCAtIClcbiAgICAgIE51bV9rZXlfYml0cy5tYXhfdmFsdWVcbiAgICAgIChBbGFybV9wcmVjaXNpb24ubnVtX2tleV9iaXRzIGFsYXJtX3ByZWNpc2lvbilcbiAgOztcblxuICBsZXQgaW52YXJpYW50IHQgPVxuICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgICAgYXNzZXJ0IChcbiAgICAgICAgTnVtX2tleV9iaXRzLiggPD0gKVxuICAgICAgICAgIChMZXZlbF9iaXRzLm51bV9iaXRzX2ludGVybmFsIHQubGV2ZWxfYml0cylcbiAgICAgICAgICAobWF4X251bV9sZXZlbF9iaXRzIHQuYWxhcm1fcHJlY2lzaW9uKSk7XG4gICAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH5hbGFybV9wcmVjaXNpb246aWdub3JlXG4gICAgICAgIH5jYXBhY2l0eTppZ25vcmVcbiAgICAgICAgfmxldmVsX2JpdHM6KGNoZWNrIExldmVsX2JpdHMuaW52YXJpYW50KSlcbiAgOztcblxuICBsZXQgY3JlYXRlID9jYXBhY2l0eSA/KGxldmVsX2JpdHMgPSBsZXZlbF9iaXRzX2RlZmF1bHQpIH5hbGFybV9wcmVjaXNpb24gKCkgPVxuICAgIGxldCBsZXZlbF9iaXRzID1cbiAgICAgIExldmVsX2JpdHMudHJpbSBsZXZlbF9iaXRzIH5tYXhfbnVtX2JpdHM6KG1heF9udW1fbGV2ZWxfYml0cyBhbGFybV9wcmVjaXNpb24pXG4gICAgaW5cbiAgICB7IGFsYXJtX3ByZWNpc2lvbjsgbGV2ZWxfYml0czsgY2FwYWNpdHkgfVxuICA7O1xuXG4gIGxldCBtaWNyb3NlY29uZF9wcmVjaXNpb24gKCkgPVxuICAgIGNyZWF0ZVxuICAgICAgKClcbiAgICAgIH5hbGFybV9wcmVjaXNpb246QWxhcm1fcHJlY2lzaW9uLmFib3V0X29uZV9taWNyb3NlY29uZFxuICAgICAgfmxldmVsX2JpdHM6KExldmVsX2JpdHMuY3JlYXRlX2V4biBbIDEwOyAxMDsgNjsgNjsgNSBdKVxuICA7O1xuXG4gIGxldCBkdXJhdGlvbnMgdCA9XG4gICAgTGlzdC5mb2xkaW5nX21hcFxuICAgICAgdC5sZXZlbF9iaXRzXG4gICAgICB+aW5pdDooQWxhcm1fcHJlY2lzaW9uLm51bV9rZXlfYml0cyB0LmFsYXJtX3ByZWNpc2lvbiB8PiBOdW1fa2V5X2JpdHMudG9faW50KVxuICAgICAgfmY6KGZ1biBudW1fYml0c19hY2N1bSBsZXZlbF9udW1fYml0cyAtPlxuICAgICAgICBsZXQgbnVtX2JpdHNfYWNjdW0gPSBudW1fYml0c19hY2N1bSArIChsZXZlbF9udW1fYml0cyB8PiBOdW1fa2V5X2JpdHMudG9faW50KSBpblxuICAgICAgICBsZXQgZHVyYXRpb24gPVxuICAgICAgICAgIFRpbWVfbnMuU3Bhbi5vZl9pbnQ2M19uc1xuICAgICAgICAgICAgKGlmIG51bV9iaXRzX2FjY3VtID0gSW50NjMubnVtX2JpdHMgLSAxXG4gICAgICAgICAgICAgdGhlbiBJbnQ2My5tYXhfdmFsdWVcbiAgICAgICAgICAgICBlbHNlIEludDYzLnNoaWZ0X2xlZnQgSW50NjMub25lIG51bV9iaXRzX2FjY3VtKVxuICAgICAgICBpblxuICAgICAgICBudW1fYml0c19hY2N1bSwgZHVyYXRpb24pXG4gIDs7XG5lbmRcblxuXG4oKiogVGltaW5nIHdoZWVsIGlzIGltcGxlbWVudGVkIGFzIGEgcHJpb3JpdHkgcXVldWUgaW4gd2hpY2ggdGhlIGtleXMgYXJlXG4gICAgbm9uLW5lZ2F0aXZlIGludGVnZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGludGVydmFscyBvZiB0aW1lLiAgVGhlIHByaW9yaXR5IHF1ZXVlIGlzXG4gICAgdW5saWtlIGEgdHlwaWNhbCBwcmlvcml0eSBxdWV1ZSBpbiB0aGF0IHJhdGhlciB0aGFuIGhhdmluZyBhIFwiZGVsZXRlIG1pblwiIG9wZXJhdGlvbixcbiAgICBpdCBoYXMgYSBub25kZWNyZWFzaW5nIG1pbmltdW0gYWxsb3dlZCBrZXksIHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBjdXJyZW50IHRpbWUsXG4gICAgYW5kIGFuIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIG9wZXJhdGlvbiwgd2hpY2ggaW1wbGVtZW50cyBbYWR2YW5jZV9jbG9ja10uXG4gICAgW2luY3JlYXNlX21pbl9hbGxvd2VkX2tleV0gYXMgYSBzaWRlIGVmZmVjdCByZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIHRoZSB0aW1pbmdcbiAgICB3aGVlbCB3aG9zZSBrZXkgaXMgc21hbGxlciB0aGFuIHRoZSBuZXcgbWluaW11bSwgd2hpY2ggaW1wbGVtZW50cyBmaXJpbmcgdGhlIGFsYXJtc1xuICAgIHdob3NlIHRpbWUgaGFzIGV4cGlyZWQuXG5cbiAgICBBZGRpbmcgZWxlbWVudHMgdG8gYW5kIHJlbW92aW5nIGVsZW1lbnRzIGZyb20gYSB0aW1pbmcgd2hlZWwgdGFrZXMgY29uc3RhbnQgdGltZSxcbiAgICB1bmxpa2UgYSBoZWFwLWJhc2VkIHByaW9yaXR5IHF1ZXVlIHdoaWNoIHRha2VzIGxvZyhOKSwgd2hlcmUgTiBpcyB0aGUgbnVtYmVyIG9mXG4gICAgZWxlbWVudHMgaW4gdGhlIGhlYXAuICBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSB0YWtlcyB0aW1lIHByb3BvcnRpb25hbCB0byB0aGVcbiAgICBhbW91bnQgb2YgaW5jcmVhc2UgaW4gdGhlIG1pbi1hbGxvd2VkIGtleSwgYXMgY29tcGFyZWQgdG8gbG9nKE4pIGZvciBhIGhlYXAuICBJdCBpc1xuICAgIHRoZXNlIHBlcmZvcm1hbmNlIGRpZmZlcmVuY2VzIHRoYXQgbW90aXZhdGUgdGhlIGV4aXN0ZW5jZSBvZiB0aW1pbmcgd2hlZWxzIGFuZCBtYWtlXG4gICAgdGhlbSBhIGdvb2QgY2hvaWNlIGZvciBtYWludGFpbmcgYSBzZXQgb2YgYWxhcm1zLiAgV2l0aCBhIHRpbWluZyB3aGVlbCwgb25lIGNhblxuICAgIHN1cHBvcnQgYW55IG51bWJlciBvZiBhbGFybXMgcGF5aW5nIGNvbnN0YW50IG92ZXJoZWFkIHBlciBhbGFybSwgd2hpbGUgcGF5aW5nIGFcbiAgICBzbWFsbCBjb25zdGFudCBvdmVyaGVhZCBwZXIgdW5pdCBvZiB0aW1lIHBhc3NlZC5cblxuICAgIEFzIHRoZSBtaW5pbXVtIGFsbG93ZWQga2V5IGluY3JlYXNlcywgdGhlIHRpbWluZyB3aGVlbCBkb2VzIGEgbGF6eSByYWRpeCBzb3J0IG9mIHRoZVxuICAgIGVsZW1lbnQga2V5cywgd2l0aCBsZXZlbCAwIGhhbmRsaW5nIHRoZSBsZWFzdCBzaWduaWZpY2FudCBbYl8wXSBiaXRzIGluIGEga2V5LCBhbmRcbiAgICBlYWNoIHN1YnNlcXVlbnQgbGV2ZWwgW2ldIGhhbmRsaW5nIHRoZSBuZXh0IG1vc3Qgc2lnbmlmaWNhbnQgW2JfaV0gYml0cy4gIFRoZSBsZXZlbHNcbiAgICBob2xkIGluY3JlYXNpbmdseSBsYXJnZXIgcmFuZ2VzIG9mIGtleXMsIHdoZXJlIHRoZSB1bmlvbiBvZiBhbGwgdGhlIGxldmVscyBjYW4gaG9sZFxuICAgIGFueSBrZXkgZnJvbSBbbWluX2FsbG93ZWRfa2V5IHRdIHRvIFttYXhfYWxsb3dlZF9rZXkgdF0uICBXaGVuIGEga2V5IGlzIGFkZGVkIHRvIHRoZVxuICAgIHRpbWluZyB3aGVlbCwgaXQgaXMgYWRkZWQgYXQgdGhlIGxvd2VzdCBwb3NzaWJsZSBsZXZlbCB0aGF0IGNhbiBzdG9yZSB0aGUga2V5LiAgQXNcbiAgICB0aGUgbWluaW11bSBhbGxvd2VkIGtleSBpbmNyZWFzZXMsIHRpbWluZy13aGVlbCBlbGVtZW50cyBtb3ZlIGRvd24gbGV2ZWxzIHVudGlsIHRoZXlcbiAgICByZWFjaCBsZXZlbCAwLCBhbmQgdGhlbiBhcmUgZXZlbnR1YWxseSByZW1vdmVkLiAgKilcbm1vZHVsZSBQcmlvcml0eV9xdWV1ZSA6IHNpZ1xuICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAnYSBwcmlvcml0eV9xdWV1ZSA9ICdhIHRcblxuICBtb2R1bGUgS2V5IDogSW50ZXJ2YWxfbnVtXG5cbiAgbW9kdWxlIEVsdCA6IHNpZ1xuICAgICgqKiBBbiBbRWx0LnRdIHJlcHJlc2VudHMgYW4gZWxlbWVudCB0aGF0IHdhcyBhZGRlZCB0byBhIHRpbWluZyB3aGVlbC4gKilcbiAgICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIHZhbCBhdCA6ICdhIHByaW9yaXR5X3F1ZXVlIC0+ICdhIHQgLT4gVGltZV9ucy50XG4gICAgdmFsIGtleSA6ICdhIHByaW9yaXR5X3F1ZXVlIC0+ICdhIHQgLT4gS2V5LnRcbiAgICB2YWwgdmFsdWUgOiAnYSBwcmlvcml0eV9xdWV1ZSAtPiAnYSB0IC0+ICdhXG4gICAgdmFsIG51bGwgOiB1bml0IC0+ICdhIHRcbiAgZW5kXG5cbiAgbW9kdWxlIEludGVybmFsX2VsdCA6IHNpZ1xuICAgIG1vZHVsZSBQb29sIDogc2lnXG4gICAgICB0eXBlICdhIHRcbiAgICBlbmRcblxuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGtleSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IEtleS50XG4gICAgdmFsIG1heF9hbGFybV90aW1lIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gd2l0aF9rZXk6S2V5LnQgLT4gVGltZV9ucy50XG4gICAgdmFsIG1pbl9hbGFybV90aW1lIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gd2l0aF9rZXk6S2V5LnQgLT4gVGltZV9ucy50XG4gICAgdmFsIGlzX251bGwgOiBfIHQgLT4gYm9vbFxuICAgIHZhbCB0b19leHRlcm5hbCA6ICdhIHQgLT4gJ2EgRWx0LnRcbiAgZW5kXG5cbiAgdmFsIHBvb2wgOiAnYSB0IC0+ICdhIEludGVybmFsX2VsdC5Qb29sLnRcblxuICBpbmNsdWRlIEludmFyaWFudC5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgKCoqIFtjcmVhdGUgP2xldmVsX2JpdHMgKCldIGNyZWF0ZXMgYSBuZXcgZW1wdHkgdGltaW5nIHdoZWVsLCBbdF0sIHdpdGggW2xlbmd0aCB0ID0gMF1cbiAgICAgIGFuZCBbbWluX2FsbG93ZWRfa2V5IHQgPSAwXS4gKilcbiAgdmFsIGNyZWF0ZSA6ID9jYXBhY2l0eTppbnQgLT4gP2xldmVsX2JpdHM6TGV2ZWxfYml0cy50IC0+IHVuaXQgLT4gJ2EgdFxuXG4gICgqKiBbbGVuZ3RoIHRdIHJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdGltaW5nIHdoZWVsLiAqKVxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuXG4gICgqKiBbbWluX2FsbG93ZWRfa2V5IHRdIGlzIHRoZSBtaW5pbXVtIGtleSB0aGF0IGNhbiBiZSBzdG9yZWQgaW4gW3RdLiAgVGhpcyBvbmx5XG4gICAgICBpbmRpY2F0ZXMgdGhlIHBvc3NpYmlsaXR5OyB0aGVyZSBuZWVkIG5vdCBiZSBhbiBlbGVtZW50IFtlbHRdIGluIFt0XSB3aXRoIFtFbHQua2V5XG4gICAgICBlbHQgPSBtaW5fYWxsb3dlZF9rZXkgdF0uICBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgXCJtaW5fa2V5XCIgb3BlcmF0aW9uIGluIGFcbiAgICAgIHR5cGljYWwgcHJpb3JpdHkgcXVldWUuXG5cbiAgICAgIFttaW5fYWxsb3dlZF9rZXkgdF0gY2FuIGluY3JlYXNlIG92ZXIgdGltZSwgdmlhIGNhbGxzIHRvXG4gICAgICBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XS4gKilcbiAgdmFsIG1pbl9hbGxvd2VkX2tleSA6IF8gdCAtPiBLZXkudFxuXG4gICgqKiBbbWF4X2FsbG93ZWRfa2V5IHRdIGlzIHRoZSBtYXhpbXVtIGFsbG93ZWQga2V5IHRoYXQgY2FuIGJlIHN0b3JlZCBpbiBbdF0uICBBc1xuICAgICAgW21pbl9hbGxvd2VkX2tleV0gaW5jcmVhc2VzLCBzbyBkb2VzIFttYXhfYWxsb3dlZF9rZXldOyBob3dldmVyIGl0IGlzIG5vdCB0aGUgY2FzZVxuICAgICAgdGhhdCBbbWF4X2FsbG93ZWRfa2V5IHQgLSBtaW5fYWxsb3dlZF9rZXkgdF0gaXMgYSBjb25zdGFudC4gIEl0IGlzIGd1YXJhbnRlZWQgdGhhdFxuICAgICAgW21heF9hbGxvd2VkX2tleSB0ID49IG1pbl9hbGxvd2VkX2tleSB0ICsgMl5CIC0gMV0sXG4gICAgICB3aGVyZSBbQl0gaXMgdGhlIHN1bSBvZiB0aGUgYl9pIGluIFtsZXZlbF9iaXRzXS4gKilcbiAgdmFsIG1heF9hbGxvd2VkX2tleSA6IF8gdCAtPiBLZXkudFxuXG4gIHZhbCBtaW5fZWx0XyA6ICdhIHQgLT4gJ2EgSW50ZXJuYWxfZWx0LnRcbiAgdmFsIGludGVybmFsX2FkZCA6ICdhIHQgLT4ga2V5OktleS50IC0+IGF0OlRpbWVfbnMudCAtPiAnYSAtPiAnYSBJbnRlcm5hbF9lbHQudFxuXG4gICgqKiBbcmVtb3ZlIHQgZWx0XSByZW1vdmVzIFtlbHRdIGZyb20gW3RdLiAgSXQgaXMgYW4gZXJyb3IgaWYgW2VsdF0gaXMgbm90IGN1cnJlbnRseVxuICAgICAgaW4gW3RdLCBhbmQgdGhpcyBlcnJvciBtYXkgb3IgbWF5IG5vdCBiZSBkZXRlY3RlZC4gKilcbiAgdmFsIHJlbW92ZSA6ICdhIHQgLT4gJ2EgRWx0LnQgLT4gdW5pdFxuXG4gIHZhbCBjaGFuZ2UgOiAnYSB0IC0+ICdhIEVsdC50IC0+IGtleTpLZXkudCAtPiBhdDpUaW1lX25zLnQgLT4gdW5pdFxuXG4gICgqKiBbY2xlYXIgdF0gcmVtb3ZlcyBhbGwgZWx0cyBmcm9tIFt0XS4gKilcbiAgdmFsIGNsZWFyIDogXyB0IC0+IHVuaXRcblxuICB2YWwgbWVtIDogJ2EgdCAtPiAnYSBFbHQudCAtPiBib29sXG5cbiAgbW9kdWxlIEluY3JlYXNlX21pbl9hbGxvd2VkX2tleV9yZXN1bHQgOiBzaWdcbiAgICB0eXBlIHQgPVxuICAgICAgfCBNYXhfYWxsb3dlZF9rZXlfZGlkX25vdF9jaGFuZ2VcbiAgICAgIHwgTWF4X2FsbG93ZWRfa2V5X21heWJlX2NoYW5nZWRcbiAgZW5kXG5cbiAgKCoqIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXkgdCB+a2V5IH5oYW5kbGVfcmVtb3ZlZF0gaW5jcmVhc2VzIHRoZSBtaW5pbXVtIGFsbG93ZWRcbiAgICAgIGtleSBpbiBbdF0gdG8gW2tleV0sIGFuZCByZW1vdmVzIGFsbCBlbGVtZW50cyB3aXRoIGtleXMgbGVzcyB0aGFuIFtrZXldLCBhcHBseWluZ1xuICAgICAgW2hhbmRsZV9yZW1vdmVkXSB0byBlYWNoIGVsZW1lbnQgdGhhdCBpcyByZW1vdmVkLiAgSWYgW2tleSA8PSBtaW5fYWxsb3dlZF9rZXkgdF0sXG4gICAgICB0aGVuIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIGRvZXMgbm90aGluZy4gIE90aGVyd2lzZSwgaWZcbiAgICAgIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldIHJldHVybnMgc3VjY2Vzc2Z1bGx5LCBbbWluX2FsbG93ZWRfa2V5IHQgPSBrZXldLlxuXG4gICAgICBbaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XSB0YWtlcyB0aW1lIHByb3BvcnRpb25hbCB0byBba2V5IC0gbWluX2FsbG93ZWRfa2V5IHRdLFxuICAgICAgYWx0aG91Z2ggcG9zc2libHkgbGVzcyB0aW1lLlxuXG4gICAgICBCZWhhdmlvciBpcyB1bnNwZWNpZmllZCBpZiBbaGFuZGxlX3JlbW92ZWRdIGFjY2Vzc2VzIFt0XSBpbiBhbnkgd2F5IG90aGVyIHRoYW5cbiAgICAgIFtFbHRdIGZ1bmN0aW9ucy4gKilcbiAgdmFsIGluY3JlYXNlX21pbl9hbGxvd2VkX2tleVxuICAgIDogICdhIHRcbiAgICAtPiBrZXk6S2V5LnRcbiAgICAtPiBoYW5kbGVfcmVtb3ZlZDooJ2EgRWx0LnQgLT4gdW5pdClcbiAgICAtPiBJbmNyZWFzZV9taW5fYWxsb3dlZF9rZXlfcmVzdWx0LnRcblxuICB2YWwgaXRlciA6ICdhIHQgLT4gZjooJ2EgRWx0LnQgLT4gdW5pdCkgLT4gdW5pdFxuXG4gIHZhbCBmaXJlX3Bhc3RfYWxhcm1zXG4gICAgOiAgJ2EgdFxuICAgIC0+IGhhbmRsZV9maXJlZDooJ2EgRWx0LnQgLT4gdW5pdClcbiAgICAtPiBrZXk6S2V5LnRcbiAgICAtPiBub3c6VGltZV9ucy50XG4gICAgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gICgqKiBFYWNoIHNsb3QgaW4gYSBsZXZlbCBpcyBhIChwb3NzaWJseSBudWxsKSBwb2ludGVyIHRvIGEgY2lyY3VsYXIgZG91Ymx5LWxpbmtlZCBsaXN0XG4gICAgICBvZiBlbGVtZW50cy4gIFdlIHBvb2wgdGhlIGVsZW1lbnRzIHNvIHRoYXQgd2UgY2FuIHJldXNlIHRoZW0gYWZ0ZXIgdGhleSBhcmUgcmVtb3ZlZFxuICAgICAgZnJvbSB0aGUgdGltaW5nIHdoZWVsIChlaXRoZXIgdmlhIFtyZW1vdmVdIG9yIFtpbmNyZWFzZV9taW5fYWxsb3dlZF9rZXldKS4gIEluXG4gICAgICBhZGRpdGlvbiB0byBzdG9yaW5nIHRoZSBba2V5XSwgW2F0XSwgYW5kIFt2YWx1ZV0gaW4gdGhlIGVsZW1lbnQsIHdlIHN0b3JlIHRoZVxuICAgICAgW2xldmVsX2luZGV4XSBzbyB0aGF0IHdlIGNhbiBxdWlja2x5IGdldCB0byB0aGUgbGV2ZWwgaG9sZGluZyBhbiBlbGVtZW50IHdoZW4gd2VcbiAgICAgIFtyZW1vdmVdIGl0LlxuXG4gICAgICBXZSBkaXN0aW5ndWlzaCBiZXR3ZWVuIFtFeHRlcm5hbF9lbHRdIGFuZCBbSW50ZXJuYWxfZWx0XSwgd2hpY2ggYXJlIHRoZSBzYW1lXG4gICAgICB1bmRlcm5lYXRoLiAgV2UgbWFpbnRhaW4gdGhlIGludmFyaWFudCB0aGF0IGFuIFtJbnRlcm5hbF9lbHRdIGlzIGVpdGhlciBbbnVsbF0gb3IgYVxuICAgICAgdmFsaWQgcG9pbnRlci4gIE9uIHRoZSBvdGhlciBoYW5kLCBbRXh0ZXJuYWxfZWx0XXMgYXJlIHJldHVybmVkIHRvIHVzZXIgY29kZSwgc29cbiAgICAgIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSBvZiB2YWxpZGl0eSAtLSB3ZSBhbHdheXMgdmFsaWRhdGUgYW4gW0V4dGVybmFsX2VsdF0gYmVmb3JlXG4gICAgICBkb2luZyBhbnl0aGluZyB3aXRoIGl0LlxuXG4gICAgICBJdCBpcyB0aGVyZWZvcmUgT0sgdG8gdXNlIFtQb29sLlVuc2FmZV0sIGJlY2F1c2Ugd2Ugd2lsbCBuZXZlciBhdHRlbXB0IHRvIGFjY2VzcyBhXG4gICAgICBzbG90IG9mIGFuIGludmFsaWQgcG9pbnRlci4gKilcbiAgbW9kdWxlIFBvb2wgPSBQb29sLlVuc2FmZVxuXG4gIG1vZHVsZSBQb2ludGVyID0gUG9vbC5Qb2ludGVyXG5cbiAgbW9kdWxlIEtleSA6IHNpZ1xuICAgICgqKiBbSW50ZXJ2YWxfbnVtXSBpcyB0aGUgcHVibGljIEFQSS4gIEV2ZXJ5dGhpbmcgZm9sbG93aW5nIGluIHRoZSBzaWduYXR1cmUgaXNcbiAgICAgICAgZm9yIGludGVybmFsIHVzZS4gKilcbiAgICBpbmNsdWRlIFRpbWluZ193aGVlbF9pbnRmLkludGVydmFsX251bVxuXG4gICAgKCoqIFthZGRfY2xhbXBfdG9fbWF4XSBkb2Vzbid0IHdvcmsgYXQgYWxsIHdpdGggbmVnYXRpdmUgc3BhbnMgKilcbiAgICB2YWwgYWRkX2NsYW1wX3RvX21heCA6IHQgLT4gU3Bhbi50IC0+IHRcblxuICAgIHZhbCBzdWNjX2NsYW1wX3RvX21heCA6IHQgLT4gdFxuXG4gICAgKCoqIFtTbG90c19tYXNrXSBpcyB1c2VkIHRvIHF1aWNrbHkgZGV0ZXJtaW5lIGEga2V5J3Mgc2xvdCBpbiBhIGdpdmVuIGxldmVsLiAqKVxuICAgIG1vZHVsZSBTbG90c19tYXNrIDogc2lnXG4gICAgICB0eXBlIHQgPSBwcml2YXRlIEludDYzLnQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgICAgdmFsIGNyZWF0ZSA6IGxldmVsX2JpdHM6TnVtX2tleV9iaXRzLnQgLT4gdFxuICAgICAgdmFsIG5leHRfc2xvdCA6IHQgLT4gaW50IC0+IGludFxuICAgIGVuZFxuXG4gICAgKCoqIFtNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXSBpcyB1c2VkIHRvIHF1aWNrbHkgZGV0ZXJtaW5lIHRoZSBtaW5pbXVtIGtleSBpbiB0aGVcbiAgICAgICAgc2FtZSBzbG90IGFzIGEgZ2l2ZW4ga2V5LiAqKVxuICAgIG1vZHVsZSBNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrIDogc2lnXG4gICAgICB0eXBlIHQgPSBwcml2YXRlIEludDYzLnQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgICAgaW5jbHVkZSBFcXVhbC5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgICAgdmFsIGNyZWF0ZSA6IGJpdHNfcGVyX3Nsb3Q6TnVtX2tleV9iaXRzLnQgLT4gdFxuICAgIGVuZFxuXG4gICAgdmFsIG51bV9rZXlzIDogTnVtX2tleV9iaXRzLnQgLT4gU3Bhbi50XG4gICAgdmFsIG1pbl9rZXlfaW5fc2FtZV9zbG90IDogdCAtPiBNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrLnQgLT4gdFxuICAgIHZhbCBzbG90IDogdCAtPiBiaXRzX3Blcl9zbG90Ok51bV9rZXlfYml0cy50IC0+IHNsb3RzX21hc2s6U2xvdHNfbWFzay50IC0+IGludFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgU2xvdHNfbWFzayA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID0gSW50NjMudCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgICBsZXQgY3JlYXRlIH5sZXZlbF9iaXRzID0gSW50NjMuKCAtICkgKE51bV9rZXlfYml0cy5wb3cyIGxldmVsX2JpdHMpIEludDYzLm9uZVxuICAgICAgbGV0IG5leHRfc2xvdCB0IHNsb3QgPSAoc2xvdCArIDEpIGxhbmQgSW50NjMudG9faW50X2V4biB0XG4gICAgZW5kXG5cbiAgICBsZXQgbnVtX2tleXMgbnVtX2JpdHMgPSBOdW1fa2V5X2JpdHMucG93MiBudW1fYml0c1xuXG4gICAgbW9kdWxlIE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sgPSBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgSW50NjNcblxuICAgICAgbGV0IGNyZWF0ZSB+Yml0c19wZXJfc2xvdCA9IGJpdF9ub3QgKE51bV9rZXlfYml0cy5wb3cyIGJpdHNfcGVyX3Nsb3QgLSBvbmUpXG4gICAgZW5kXG5cbiAgICBtb2R1bGUgU3BhbiA9IHN0cnVjdFxuICAgICAgaW5jbHVkZSBJbnQ2M1xuXG4gICAgICBsZXQgdG9faW50NjMgdCA9IHRcbiAgICAgIGxldCBvZl9pbnQ2MyBpID0gaVxuICAgICAgbGV0IHNjYWxlX2ludCB0IGkgPSB0ICogb2ZfaW50IGlcbiAgICBlbmRcblxuICAgIGluY2x1ZGUgSW50NjNcblxuICAgIGxldCBvZl9pbnQ2MyBpID0gaVxuICAgIGxldCB0b19pbnQ2MyB0ID0gdFxuICAgIGxldCBhZGQgdCBpID0gdCArIGlcbiAgICBsZXQgYWRkX2NsYW1wX3RvX21heCB0IGkgPSBpZiB0ID4gbWF4X3ZhbHVlIC0gaSB0aGVuIG1heF92YWx1ZSBlbHNlIHQgKyBpXG4gICAgbGV0IHN1Y2NfY2xhbXBfdG9fbWF4IHQgPSBpZiB0ID0gbWF4X3ZhbHVlIHRoZW4gbWF4X3ZhbHVlIGVsc2Ugc3VjYyB0XG4gICAgbGV0IHN1YiB0IGkgPSB0IC0gaVxuICAgIGxldCBkaWZmIHQxIHQyID0gdDEgLSB0MlxuXG4gICAgbGV0IHNsb3QgdCB+KGJpdHNfcGVyX3Nsb3QgOiBOdW1fa2V5X2JpdHMudCkgfnNsb3RzX21hc2sgPVxuICAgICAgdG9faW50X2V4biAoYml0X2FuZCAoc2hpZnRfcmlnaHQgdCAoYml0c19wZXJfc2xvdCA6PiBpbnQpKSBzbG90c19tYXNrKVxuICAgIDs7XG5cbiAgICBsZXQgbWluX2tleV9pbl9zYW1lX3Nsb3QgdCBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrID1cbiAgICAgIGJpdF9hbmQgdCBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2sgPSBLZXkuTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFza1xuICBtb2R1bGUgU2xvdHNfbWFzayA9IEtleS5TbG90c19tYXNrXG5cbiAgbW9kdWxlIEV4dGVybmFsX2VsdCA9IHN0cnVjdFxuXG4gICAgKCoqIFRoZSBbcG9vbF9zbG90c10gaGVyZSBoYXMgbm90aGluZyB0byBkbyB3aXRoIHRoZSBzbG90cyBpbiBhIGxldmVsIGFycmF5LiAgVGhpcyBpc1xuICAgICAgICBmb3IgdGhlIHNsb3RzIGluIHRoZSBwb29sIHR1cGxlIHJlcHJlc2VudGluZyBhIGxldmVsIGVsZW1lbnQuICopXG4gICAgdHlwZSAnYSBwb29sX3Nsb3RzID1cbiAgICAgICggS2V5LnRcbiAgICAgICwgVGltZV9ucy50XG4gICAgICAsICdhXG4gICAgICAsIGludFxuICAgICAgLCAnYSBwb29sX3Nsb3RzIFBvaW50ZXIudFxuICAgICAgLCAnYSBwb29sX3Nsb3RzIFBvaW50ZXIudCApXG4gICAgICAgIFBvb2wuU2xvdHMudDZcbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICAgdHlwZSAnYSB0ID0gJ2EgcG9vbF9zbG90cyBQb2ludGVyLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGxldCBudWxsID0gUG9pbnRlci5udWxsXG4gIGVuZFxuXG4gIG1vZHVsZSBJbnRlcm5hbF9lbHQgOiBzaWdcbiAgICBtb2R1bGUgUG9vbCA6IHNpZ1xuICAgICAgdHlwZSAnYSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICAgIGluY2x1ZGUgSW52YXJpYW50LlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICAgICAgdmFsIGNyZWF0ZSA6ID9jYXBhY2l0eTppbnQgLT4gdW5pdCAtPiBfIHRcbiAgICAgIHZhbCBpc19mdWxsIDogXyB0IC0+IGJvb2xcbiAgICAgIHZhbCBncm93IDogP2NhcGFjaXR5OmludCAtPiAnYSB0IC0+ICdhIHRcbiAgICBlbmRcblxuICAgIHR5cGUgJ2EgdCA9IHByaXZhdGUgJ2EgRXh0ZXJuYWxfZWx0LnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIHZhbCBudWxsIDogdW5pdCAtPiBfIHRcbiAgICB2YWwgaXNfbnVsbCA6IF8gdCAtPiBib29sXG4gICAgdmFsIGlzX3ZhbGlkIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gYm9vbFxuXG4gICAgKCoqIERlYWxpbmcgd2l0aCBbRXh0ZXJuYWxfZWx0XXMuICopXG5cbiAgICB2YWwgZXh0ZXJuYWxfaXNfdmFsaWQgOiAnYSBQb29sLnQgLT4gJ2EgRXh0ZXJuYWxfZWx0LnQgLT4gYm9vbFxuICAgIHZhbCB0b19leHRlcm5hbCA6ICdhIHQgLT4gJ2EgRXh0ZXJuYWxfZWx0LnRcbiAgICB2YWwgb2ZfZXh0ZXJuYWxfZXhuIDogJ2EgUG9vbC50IC0+ICdhIEV4dGVybmFsX2VsdC50IC0+ICdhIHRcbiAgICB2YWwgZXF1YWwgOiAnYSB0IC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBpbnZhcmlhbnQgOiAnYSBQb29sLnQgLT4gKCdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuXG4gICAgKCoqIFtjcmVhdGVdIHJldHVybnMgYW4gZWxlbWVudCB3aG9zZSBbbmV4dF0gYW5kIFtwcmV2XSBhcmUgW251bGxdLiAqKVxuICAgIHZhbCBjcmVhdGVcbiAgICAgIDogICdhIFBvb2wudFxuICAgICAgLT4ga2V5OktleS50XG4gICAgICAoKiogW2F0XSBpcyB1c2VkIHdoZW4gdGhlIHByaW9yaXR5IHF1ZXVlIGlzIHVzZWQgdG8gaW1wbGVtZW50IGEgdGltaW5nIHdoZWVsLiAgSWZcbiAgICAgICAgICB1bnVzZWQsIGl0IHdpbGwgYmUgW1RpbWVfbnMuZXBvY2hdLiAqKVxuICAgICAgLT4gYXQ6VGltZV9ucy50XG4gICAgICAtPiB2YWx1ZTonYVxuICAgICAgLT4gbGV2ZWxfaW5kZXg6aW50XG4gICAgICAtPiAnYSB0XG5cbiAgICB2YWwgZnJlZSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHVuaXRcblxuICAgICgqKiBhY2Nlc3NvcnMgKilcblxuICAgIHZhbCBrZXkgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBLZXkudFxuICAgIHZhbCBhdCA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IFRpbWVfbnMudFxuICAgIHZhbCBsZXZlbF9pbmRleCA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IGludFxuICAgIHZhbCBuZXh0IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCB2YWx1ZSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+ICdhXG5cbiAgICAoKiogbXV0YXRvcnMgKilcblxuICAgIHZhbCBzZXRfa2V5IDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gS2V5LnQgLT4gdW5pdFxuICAgIHZhbCBzZXRfYXQgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBUaW1lX25zLnQgLT4gdW5pdFxuICAgIHZhbCBzZXRfbGV2ZWxfaW5kZXggOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBpbnQgLT4gdW5pdFxuXG4gICAgKCoqIFtpbnNlcnRfYXRfZW5kIHBvb2wgdCB+dG9fYWRkXSB0cmVhdHMgW3RdIGFzIHRoZSBoZWFkIG9mIHRoZSBsaXN0IGFuZCBhZGRzIFt0b19hZGRdXG4gICAgICAgIHRvIHRoZSBlbmQgb2YgaXQuICopXG4gICAgdmFsIGluc2VydF9hdF9lbmQgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiB0b19hZGQ6J2EgdCAtPiB1bml0XG5cbiAgICAoKiogW2xpbmtfdG9fc2VsZiBwb29sIHRdIG1ha2VzIFt0XSBiZSBhIHNpbmdsZXRvbiBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3QuICopXG4gICAgdmFsIGxpbmtfdG9fc2VsZiA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHVuaXRcblxuICAgICgqKiBbdW5saW5rIHAgdF0gdW5saW5rcyBbdF0gZnJvbSB0aGUgY2lyY3VsYXJseSBkb3VibHktbGlua2VkIGxpc3QgdGhhdCBpdCBpcyBpbi4gIEl0XG4gICAgICAgIGNoYW5nZXMgdGhlIHBvaW50ZXJzIG9mIFt0XSdzIFtwcmV2XSBhbmQgW25leHRdIGVsdHMsIGJ1dCBub3QgW3RdJ3MgW3ByZXZdIGFuZFxuICAgICAgICBbbmV4dF0gcG9pbnRlcnMuICBbdW5saW5rXSBpcyBtZWFuaW5nbGVzcyBpZiBbdF0gaXMgYSBzaW5nbGV0b24uICopXG4gICAgdmFsIHVubGluayA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHVuaXRcblxuICAgICgqKiBJdGVyYXRvcnMuICBbaXRlciBwIHQgfmluaXQgfmZdIHZpc2l0cyBlYWNoIGVsZW1lbnQgaW4gdGhlIGRvdWJseS1saW5rZWQgbGlzdFxuICAgICAgICBjb250YWluaW5nIFt0XSwgc3RhcnRpbmcgYXQgW3RdLCBhbmQgZm9sbG93aW5nIFtuZXh0XSBwb2ludGVycy4gIFtsZW5ndGhdIGNvdW50c1xuICAgICAgICBieSB2aXNpdGluZyBlYWNoIGVsZW1lbnQgaW4gdGhlIGxpc3QuICopXG4gICAgdmFsIGl0ZXIgOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBmOignYSB0IC0+IHVuaXQpIC0+IHVuaXRcblxuICAgIHZhbCBsZW5ndGggOiAnYSBQb29sLnQgLT4gJ2EgdCAtPiBpbnRcblxuICAgICgqKiBbbWF4X2FsYXJtX3RpbWUgdCBlbHQgfndpdGhfa2V5XSBmaW5kcyB0aGUgbWF4IFthdF0gaW4gW2VsdF0ncyBsaXN0IGFtb25nIHRoZSBlbHRzXG4gICAgICAgIHdob3NlIGtleSBpcyBbd2l0aF9rZXldLCByZXR1cm5pbmcgW1RpbWVfbnMuZXBvY2hdIGlmIHRoZSBsaXN0IGlzIGVtcHR5LiAqKVxuICAgIHZhbCBtYXhfYWxhcm1fdGltZSA6ICdhIFBvb2wudCAtPiAnYSB0IC0+IHdpdGhfa2V5OktleS50IC0+IFRpbWVfbnMudFxuXG4gICAgdmFsIG1pbl9hbGFybV90aW1lIDogJ2EgUG9vbC50IC0+ICdhIHQgLT4gd2l0aF9rZXk6S2V5LnQgLT4gVGltZV9ucy50XG4gIGVuZCA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgcG9vbF9zbG90cyA9ICdhIEV4dGVybmFsX2VsdC5wb29sX3Nsb3RzIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gICAgdHlwZSAnYSB0ID0gJ2EgRXh0ZXJuYWxfZWx0LnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGxldCBudWxsID0gUG9pbnRlci5udWxsXG4gICAgbGV0IGlzX251bGwgPSBQb2ludGVyLmlzX251bGxcbiAgICBsZXQgZXF1YWwgdDEgdDIgPSBQb2ludGVyLnBoeXNfZXF1YWwgdDEgdDJcblxuICAgIGxldCBjcmVhdGUgcG9vbCB+a2V5IH5hdCB+dmFsdWUgfmxldmVsX2luZGV4ID1cbiAgICAgIFBvb2wubmV3NiBwb29sIGtleSBhdCB2YWx1ZSBsZXZlbF9pbmRleCAobnVsbCAoKSkgKG51bGwgKCkpXG4gICAgOztcblxuICAgIGxldCBmcmVlID0gUG9vbC5mcmVlXG4gICAgbGV0IGtleSBwIHQgPSBQb29sLmdldCBwIHQgUG9vbC5TbG90LnQwXG4gICAgbGV0IHNldF9rZXkgcCB0IGsgPSBQb29sLnNldCBwIHQgUG9vbC5TbG90LnQwIGtcbiAgICBsZXQgYXQgcCB0ID0gUG9vbC5nZXQgcCB0IFBvb2wuU2xvdC50MVxuICAgIGxldCBzZXRfYXQgcCB0IHggPSBQb29sLnNldCBwIHQgUG9vbC5TbG90LnQxIHhcbiAgICBsZXQgdmFsdWUgcCB0ID0gUG9vbC5nZXQgcCB0IFBvb2wuU2xvdC50MlxuICAgIGxldCBsZXZlbF9pbmRleCBwIHQgPSBQb29sLmdldCBwIHQgUG9vbC5TbG90LnQzXG4gICAgbGV0IHNldF9sZXZlbF9pbmRleCBwIHQgaSA9IFBvb2wuc2V0IHAgdCBQb29sLlNsb3QudDMgaVxuICAgIGxldCBwcmV2IHAgdCA9IFBvb2wuZ2V0IHAgdCBQb29sLlNsb3QudDRcbiAgICBsZXQgc2V0X3ByZXYgcCB0IHggPSBQb29sLnNldCBwIHQgUG9vbC5TbG90LnQ0IHhcbiAgICBsZXQgbmV4dCBwIHQgPSBQb29sLmdldCBwIHQgUG9vbC5TbG90LnQ1XG4gICAgbGV0IHNldF9uZXh0IHAgdCB4ID0gUG9vbC5zZXQgcCB0IFBvb2wuU2xvdC50NSB4XG4gICAgbGV0IGlzX3ZhbGlkIHAgdCA9IFBvb2wucG9pbnRlcl9pc192YWxpZCBwIHRcbiAgICBsZXQgZXh0ZXJuYWxfaXNfdmFsaWQgPSBpc192YWxpZFxuXG4gICAgbGV0IGludmFyaWFudCBwb29sIGludmFyaWFudF9hIHQgPVxuICAgICAgSW52YXJpYW50LmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiBfIHRdIChmdW4gKCkgLT5cbiAgICAgICAgYXNzZXJ0IChpc192YWxpZCBwb29sIHQpO1xuICAgICAgICBpbnZhcmlhbnRfYSAodmFsdWUgcG9vbCB0KTtcbiAgICAgICAgbGV0IG4gPSBuZXh0IHBvb2wgdCBpblxuICAgICAgICBhc3NlcnQgKGlzX251bGwgbiB8fCBQb2ludGVyLnBoeXNfZXF1YWwgdCAocHJldiBwb29sIG4pKTtcbiAgICAgICAgbGV0IHAgPSBwcmV2IHBvb2wgdCBpblxuICAgICAgICBhc3NlcnQgKGlzX251bGwgcCB8fCBQb2ludGVyLnBoeXNfZXF1YWwgdCAobmV4dCBwb29sIHApKSlcbiAgICA7O1xuXG4gICAgbW9kdWxlIFBvb2wgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhIHBvb2xfc2xvdHMgUG9vbC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICAgIGxldCBpbnZhcmlhbnQgX2ludmFyaWFudF9hIHQgPSBQb29sLmludmFyaWFudCBpZ25vcmUgdFxuICAgICAgbGV0IGNyZWF0ZSA/KGNhcGFjaXR5ID0gMSkgKCkgPSBQb29sLmNyZWF0ZSBQb29sLlNsb3RzLnQ2IH5jYXBhY2l0eVxuICAgICAgbGV0IGdyb3cgPSBQb29sLmdyb3dcbiAgICAgIGxldCBpc19mdWxsID0gUG9vbC5pc19mdWxsXG4gICAgZW5kXG5cbiAgICBsZXQgdG9fZXh0ZXJuYWwgdCA9IHRcblxuICAgIGxldCBvZl9leHRlcm5hbF9leG4gcG9vbCB0ID1cbiAgICAgIGlmIGlzX3ZhbGlkIHBvb2wgdCB0aGVuIHQgZWxzZSByYWlzZV9zIFslbWVzc2FnZSBcIlRpbWluZ193aGVlbCBnb3QgaW52YWxpZCBhbGFybVwiXVxuICAgIDs7XG5cbiAgICBsZXQgdW5saW5rIHBvb2wgdCA9XG4gICAgICBzZXRfbmV4dCBwb29sIChwcmV2IHBvb2wgdCkgKG5leHQgcG9vbCB0KTtcbiAgICAgIHNldF9wcmV2IHBvb2wgKG5leHQgcG9vbCB0KSAocHJldiBwb29sIHQpXG4gICAgOztcblxuICAgIGxldCBsaW5rIHBvb2wgcHJldiBuZXh0ID1cbiAgICAgIHNldF9uZXh0IHBvb2wgcHJldiBuZXh0O1xuICAgICAgc2V0X3ByZXYgcG9vbCBuZXh0IHByZXZcbiAgICA7O1xuXG4gICAgbGV0IGxpbmtfdG9fc2VsZiBwb29sIHQgPSBsaW5rIHBvb2wgdCB0XG5cbiAgICBsZXQgaW5zZXJ0X2F0X2VuZCBwb29sIHQgfnRvX2FkZCA9XG4gICAgICBsZXQgcHJldiA9IHByZXYgcG9vbCB0IGluXG4gICAgICBsaW5rIHBvb2wgcHJldiB0b19hZGQ7XG4gICAgICBsaW5rIHBvb2wgdG9fYWRkIHRcbiAgICA7O1xuXG4gICAgbGV0IGl0ZXIgcG9vbCBmaXJzdCB+ZiA9XG4gICAgICBsZXQgY3VycmVudCA9IHJlZiBmaXJzdCBpblxuICAgICAgbGV0IGNvbnRpbnVlID0gcmVmIHRydWUgaW5cbiAgICAgIHdoaWxlICFjb250aW51ZSBkb1xuICAgICAgICAoKiBXZSBnZXQgW25leHRdIGJlZm9yZSBjYWxsaW5nIFtmXSBzbyB0aGF0IFtmXSBjYW4gbW9kaWZ5IG9yIFtmcmVlXSBbIWN1cnJlbnRdLiAqKVxuICAgICAgICBsZXQgbmV4dCA9IG5leHQgcG9vbCAhY3VycmVudCBpblxuICAgICAgICBmICFjdXJyZW50O1xuICAgICAgICBpZiBwaHlzX2VxdWFsIG5leHQgZmlyc3QgdGhlbiBjb250aW51ZSA6PSBmYWxzZSBlbHNlIGN1cnJlbnQgOj0gbmV4dFxuICAgICAgZG9uZVxuICAgIDs7XG5cbiAgICBsZXQgbGVuZ3RoIHBvb2wgZmlyc3QgPVxuICAgICAgbGV0IHIgPSByZWYgMCBpblxuICAgICAgbGV0IGN1cnJlbnQgPSByZWYgZmlyc3QgaW5cbiAgICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgICB3aGlsZSAhY29udGludWUgZG9cbiAgICAgICAgaW5jciByO1xuICAgICAgICBsZXQgbmV4dCA9IG5leHQgcG9vbCAhY3VycmVudCBpblxuICAgICAgICBpZiBwaHlzX2VxdWFsIG5leHQgZmlyc3QgdGhlbiBjb250aW51ZSA6PSBmYWxzZSBlbHNlIGN1cnJlbnQgOj0gbmV4dFxuICAgICAgZG9uZTtcbiAgICAgICFyXG4gICAgOztcblxuICAgIGxldCBtYXhfYWxhcm1fdGltZSBwb29sIGZpcnN0IH53aXRoX2tleSA9XG4gICAgICBsZXQgbWF4X2FsYXJtX3RpbWUgPSByZWYgVGltZV9ucy5lcG9jaCBpblxuICAgICAgbGV0IGN1cnJlbnQgPSByZWYgZmlyc3QgaW5cbiAgICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgICB3aGlsZSAhY29udGludWUgZG9cbiAgICAgICAgbGV0IG5leHQgPSBuZXh0IHBvb2wgIWN1cnJlbnQgaW5cbiAgICAgICAgaWYgS2V5LmVxdWFsIChrZXkgcG9vbCAhY3VycmVudCkgd2l0aF9rZXlcbiAgICAgICAgdGhlbiBtYXhfYWxhcm1fdGltZSA6PSBUaW1lX25zLm1heCAoYXQgcG9vbCAhY3VycmVudCkgIW1heF9hbGFybV90aW1lO1xuICAgICAgICBpZiBwaHlzX2VxdWFsIG5leHQgZmlyc3QgdGhlbiBjb250aW51ZSA6PSBmYWxzZSBlbHNlIGN1cnJlbnQgOj0gbmV4dFxuICAgICAgZG9uZTtcbiAgICAgICFtYXhfYWxhcm1fdGltZVxuICAgIDs7XG5cbiAgICBsZXQgbWluX2FsYXJtX3RpbWUgcG9vbCBmaXJzdCB+d2l0aF9rZXkgPVxuICAgICAgbGV0IG1pbl9hbGFybV90aW1lID0gcmVmIFRpbWVfbnMubWF4X3ZhbHVlX3JlcHJlc2VudGFibGUgaW5cbiAgICAgIGxldCBjdXJyZW50ID0gcmVmIGZpcnN0IGluXG4gICAgICBsZXQgY29udGludWUgPSByZWYgdHJ1ZSBpblxuICAgICAgd2hpbGUgIWNvbnRpbnVlIGRvXG4gICAgICAgIGxldCBuZXh0ID0gbmV4dCBwb29sICFjdXJyZW50IGluXG4gICAgICAgICgqIFRoZSBba2V5XSBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBmb3IgW21heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF0gYmVjYXVzZVxuICAgICAgICAgICBtYXggdGltZSBwZXIgaW50ZXJ2YWwgaXMgbm90IHRoZSBzYW1lIGFzIG1heCB0aW1lIGdsb2JhbGx5LlxuXG4gICAgICAgICAgIFRoaXMgaXMgbm90IHNvIGZvciBbbWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsXSwgc28gdGhpcyBjYW4gcG90ZW50aWFsbHlcbiAgICAgICAgICAgYmUgc2ltcGxpZmllZC5cblxuICAgICAgICAgICBQcm9iYWJseSBhIGJldHRlciBjaGFuZ2Ugd291bGQgYmUgdG8gc2ltcGx5IHRyYW5zZmVyIHRoZSBldmVudHMgdG8gdGhlXG4gICAgICAgICAgIFwiZmlyZWRcIiBjb2xsZWN0aW9uIChhbmQgcmVuYW1lIGl0IHRvIFwiYWJvdXQgdG8gZmlyZVwiKSwgd2hpY2ggaXMgc29ydGVkIGJ5IHRpbWUsXG4gICAgICAgICAgIHNvIGdldHRpbmcgdGhlIGZpcnN0IGVsZW1lbnQgZnJvbSB0aGF0IGNvbGxlY3Rpb24gaXMgZWZmaWNpZW50LlxuICAgICAgICAqKVxuICAgICAgICBpZiBLZXkuZXF1YWwgKGtleSBwb29sICFjdXJyZW50KSB3aXRoX2tleVxuICAgICAgICB0aGVuIG1pbl9hbGFybV90aW1lIDo9IFRpbWVfbnMubWluIChhdCBwb29sICFjdXJyZW50KSAhbWluX2FsYXJtX3RpbWU7XG4gICAgICAgIGlmIHBoeXNfZXF1YWwgbmV4dCBmaXJzdCB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlIGVsc2UgY3VycmVudCA6PSBuZXh0XG4gICAgICBkb25lO1xuICAgICAgIW1pbl9hbGFybV90aW1lXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIExldmVsID0gc3RydWN0XG4gICAgKCoqIEZvciBnaXZlbiBsZXZlbCwgb25lIGNhbiBicmVhayB0aGUgYml0cyBpbnRvIGEga2V5IGludG8gdGhyZWUgcmVnaW9uczpcblxuICAgICAgICB7dlxuICAgICAgICAgfCBoaWdoZXIgbGV2ZWxzIHwgdGhpcyBsZXZlbCB8IGxvd2VyIGxldmVscyB8XG4gICAgICAgIHZ9XG5cbiAgICAgICAgXCJMb3dlciBsZXZlbHNcIiBpcyBbYml0c19wZXJfc2xvdF0gYml0cyB3aWRlLiAgXCJUaGlzIGxldmVsXCIgaXMgW2JpdHNdIHdpZGUuICopXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgKCogVGhlIFtpbmRleF0gaW4gdGhlIHRpbWluZyB3aGVlbCdzIGFycmF5IG9mIGxldmVscyB3aGVyZSB0aGlzIGxldmVsIGlzLiAqKVxuICAgICAgICBpbmRleCA6IGludFxuICAgICAgOyAoKiBIb3cgbWFueSBbYml0c10gdGhpcyBsZXZlbCBpcyByZXNwb25zaWJsZSBmb3IuICopXG4gICAgICAgIGJpdHMgOiBOdW1fa2V5X2JpdHMudFxuICAgICAgOyAoKiBbc2xvdHNfbWFzayA9IFNsb3RzX21hc2suY3JlYXRlIH5sZXZlbF9iaXRzOnQuYml0c10uICopXG4gICAgICAgIHNsb3RzX21hc2sgOiBTbG90c19tYXNrLnRcbiAgICAgIDsgKCogW2JpdHNfcGVyX3Nsb3RdIGlzIGhvdyBtYW55IGJpdHMgZWFjaCBzbG90IGRpc3Rpbmd1aXNoZXMsIGFuZCBpcyB0aGUgc3VtIG9mIG9mXG4gICAgICAgICAgIHRoZSBbYml0c10gb2YgYWxsIHRoZSBsb3dlciBsZXZlbHMuICopXG4gICAgICAgIGJpdHNfcGVyX3Nsb3QgOiBOdW1fa2V5X2JpdHMudFxuICAgICAgOyBrZXlzX3Blcl9zbG90IDogS2V5LlNwYW4udFxuICAgICAgOyBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrIDogTWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzay50XG4gICAgICA7ICgqIFtkaWZmX21heF9taW5fYWxsb3dlZF9rZXkgPSBrZXlzX3Blcl9zbG90ICogQXJyYXkubGVuZ3RoIHNsb3RzIC0gMV0gKilcbiAgICAgICAgZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5IDogS2V5LlNwYW4udFxuICAgICAgOyAoKiBbbGVuZ3RoXSBpcyB0aGUgbnVtYmVyIG9mIGVsdHMgY3VycmVudGx5IGluIHRoaXMgbGV2ZWwuICopXG4gICAgICAgIG11dGFibGUgbGVuZ3RoIDogaW50XG4gICAgICA7ICgqIEFsbCBlbGVtZW50cyBhdCB0aGlzIGxldmVsIGhhdmUgdGhlaXIgW2tleV0gc2F0aXNmeSBbbWluX2FsbG93ZWRfa2V5IDw9IGtleSA8PVxuICAgICAgICAgICBtYXhfYWxsb3dlZF9rZXldLiAgQWxzbywgW21pbl9hbGxvd2VkX2tleV0gaXMgYSBtdWx0aXBsZSBvZiBba2V5c19wZXJfc2xvdF0uICopXG4gICAgICAgIG11dGFibGUgbWluX2FsbG93ZWRfa2V5IDogS2V5LnRcbiAgICAgIDsgbXV0YWJsZSBtYXhfYWxsb3dlZF9rZXkgOiBLZXkudFxuICAgICAgOyAoKiBbc2xvdHNdIGhvbGRzIHRoZSAocG9zc2libHkgbnVsbCkgcG9pbnRlcnMgdG8gdGhlIGNpcmN1bGFyIGRvdWJseS1saW5rZWQgbGlzdHNcbiAgICAgICAgICAgb2YgZWx0cy4gIFtBcnJheS5sZW5ndGggc2xvdHMgPSAxIGxzbCBiaXRzXS4gKilcbiAgICAgICAgc2xvdHMgOiAoJ2EgSW50ZXJuYWxfZWx0LnQgYXJyYXlbQHNleHAub3BhcXVlXSlcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbiAgICBsZXQgc2xvdCB0IH5rZXkgPSBLZXkuc2xvdCBrZXkgfmJpdHNfcGVyX3Nsb3Q6dC5iaXRzX3Blcl9zbG90IH5zbG90c19tYXNrOnQuc2xvdHNfbWFza1xuICAgIGxldCBuZXh0X3Nsb3QgdCBzbG90ID0gU2xvdHNfbWFzay5uZXh0X3Nsb3QgdC5zbG90c19tYXNrIHNsb3RcblxuICAgIGxldCBtaW5fa2V5X2luX3NhbWVfc2xvdCB0IH5rZXkgPVxuICAgICAgS2V5Lm1pbl9rZXlfaW5fc2FtZV9zbG90IGtleSB0Lm1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tcbiAgICA7O1xuXG4gICAgbGV0IGNvbXB1dGVfbWluX2FsbG93ZWRfa2V5IHQgfnByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5ID1cbiAgICAgICgqIFRoaXMgY29tcHV0YXRpb24gZW5zdXJlcyB0aGF0IFt0XSdzIFttaW5fYWxsb3dlZF9rZXldIGlzIGFzIGxhcmdlIGFzIHBvc3NpYmxlXG4gICAgICAgICBzdWJqZWN0IHRvIHRoZSBjb25zdHJhaW50IHRoYXQgdGhlcmUgaXMgbm8gaW50ZXItbGV2ZWwgZ2FwLiAqKVxuICAgICAgaWYgS2V5LmVxdWFsIHByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5IEtleS5tYXhfdmFsdWVcbiAgICAgIHRoZW4gS2V5Lm1heF92YWx1ZVxuICAgICAgZWxzZSBtaW5fa2V5X2luX3NhbWVfc2xvdCB0IH5rZXk6KEtleS5zdWNjIHByZXZfbGV2ZWxfbWF4X2FsbG93ZWRfa2V5KVxuICAgIDs7XG4gIGVuZFxuXG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBtdXRhYmxlIGxlbmd0aCA6IGludFxuICAgIDsgbXV0YWJsZSBwb29sIDogJ2EgSW50ZXJuYWxfZWx0LlBvb2wudFxuICAgIDsgKCogW21pbl9lbHRdIGlzIGVpdGhlciBudWxsIG9yIGFuIGVsZW1lbnQgd2hvc2Uga2V5IGlzIFtlbHRfa2V5X2xvd2VyX2JvdW5kXS4gKilcbiAgICAgIG11dGFibGUgbWluX2VsdCA6ICdhIEludGVybmFsX2VsdC50XG4gICAgOyAoKiBBbGwgZWxlbWVudHMgaW4gdGhlIHByaW9yaXR5IHF1ZXVlIGhhdmUgdGhlaXIga2V5IFs+PSBlbHRfa2V5X2xvd2VyX2JvdW5kXS4gKilcbiAgICAgIG11dGFibGUgZWx0X2tleV9sb3dlcl9ib3VuZCA6IEtleS50XG4gICAgOyBsZXZlbHMgOiAnYSBMZXZlbC50IGFycmF5XG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbiAgdHlwZSAnYSBwcmlvcml0eV9xdWV1ZSA9ICdhIHRcblxuICBtb2R1bGUgRWx0ID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgRXh0ZXJuYWxfZWx0LnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGxldCBudWxsID0gRXh0ZXJuYWxfZWx0Lm51bGxcbiAgICBsZXQgYXQgcCB0ID0gSW50ZXJuYWxfZWx0LmF0IHAucG9vbCAoSW50ZXJuYWxfZWx0Lm9mX2V4dGVybmFsX2V4biBwLnBvb2wgdClcbiAgICBsZXQga2V5IHAgdCA9IEludGVybmFsX2VsdC5rZXkgcC5wb29sIChJbnRlcm5hbF9lbHQub2ZfZXh0ZXJuYWxfZXhuIHAucG9vbCB0KVxuICAgIGxldCB2YWx1ZSBwIHQgPSBJbnRlcm5hbF9lbHQudmFsdWUgcC5wb29sIChJbnRlcm5hbF9lbHQub2ZfZXh0ZXJuYWxfZXhuIHAucG9vbCB0KVxuICBlbmRcblxuICBsZXQgc2V4cF9vZl90X2ludGVybmFsID0gc2V4cF9vZl90XG4gIGxldCBpc19lbXB0eSB0ID0gbGVuZ3RoIHQgPSAwXG4gIGxldCBudW1fbGV2ZWxzIHQgPSBBcnJheS5sZW5ndGggdC5sZXZlbHNcbiAgbGV0IG1pbl9hbGxvd2VkX2tleSB0ID0gTGV2ZWwubWluX2FsbG93ZWRfa2V5IHQubGV2ZWxzLigwKVxuICBsZXQgbWF4X2FsbG93ZWRfa2V5IHQgPSBMZXZlbC5tYXhfYWxsb3dlZF9rZXkgdC5sZXZlbHMuKG51bV9sZXZlbHMgdCAtIDEpXG5cbiAgbGV0IGludGVybmFsX2l0ZXIgdCB+ZiA9XG4gICAgaWYgdC5sZW5ndGggPiAwXG4gICAgdGhlbiAoXG4gICAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgICAgbGV0IGxldmVscyA9IHQubGV2ZWxzIGluXG4gICAgICBmb3IgbGV2ZWxfaW5kZXggPSAwIHRvIEFycmF5Lmxlbmd0aCBsZXZlbHMgLSAxIGRvXG4gICAgICAgIGxldCBsZXZlbCA9IGxldmVscy4obGV2ZWxfaW5kZXgpIGluXG4gICAgICAgIGlmIGxldmVsLmxlbmd0aCA+IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IHNsb3RzID0gbGV2ZWwuc2xvdHMgaW5cbiAgICAgICAgICBmb3Igc2xvdF9pbmRleCA9IDAgdG8gQXJyYXkubGVuZ3RoIHNsb3RzIC0gMSBkb1xuICAgICAgICAgICAgbGV0IGVsdCA9IHNsb3RzLihzbG90X2luZGV4KSBpblxuICAgICAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQpIHRoZW4gSW50ZXJuYWxfZWx0Lml0ZXIgcG9vbCBlbHQgfmZcbiAgICAgICAgICBkb25lKVxuICAgICAgZG9uZSlcbiAgOztcblxuICBsZXQgaXRlciB0IH5mID0gaW50ZXJuYWxfaXRlciB0IH5mOihmIDogXyBFbHQudCAtPiB1bml0IDo+IF8gSW50ZXJuYWxfZWx0LnQgLT4gdW5pdClcblxuICBtb2R1bGUgUHJldHR5ID0gc3RydWN0XG4gICAgbW9kdWxlIEVsdCA9IHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID1cbiAgICAgICAgeyBrZXkgOiBLZXkudFxuICAgICAgICA7IHZhbHVlIDogJ2FcbiAgICAgICAgfVxuICAgICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICBlbmRcblxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7IG1pbl9hbGxvd2VkX2tleSA6IEtleS50XG4gICAgICA7IG1heF9hbGxvd2VkX2tleSA6IEtleS50XG4gICAgICA7IGVsdHMgOiAnYSBFbHQudCBsaXN0XG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kXG5cbiAgbGV0IHByZXR0eSB0ID1cbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIHsgUHJldHR5Lm1pbl9hbGxvd2VkX2tleSA9IG1pbl9hbGxvd2VkX2tleSB0XG4gICAgOyBtYXhfYWxsb3dlZF9rZXkgPSBtYXhfYWxsb3dlZF9rZXkgdFxuICAgIDsgZWx0cyA9XG4gICAgICAgIChsZXQgciA9IHJlZiBbXSBpblxuICAgICAgICAgaW50ZXJuYWxfaXRlciB0IH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgIHJcbiAgICAgICAgICAgOj0geyBQcmV0dHkuRWx0LmtleSA9IEludGVybmFsX2VsdC5rZXkgcG9vbCBlbHRcbiAgICAgICAgICAgICAgOyB2YWx1ZSA9IEludGVybmFsX2VsdC52YWx1ZSBwb29sIGVsdFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDo6ICFyKTtcbiAgICAgICAgIExpc3QucmV2ICFyKVxuICAgIH1cbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0ID1cbiAgICBtYXRjaCAhc2V4cF9vZl90X3N0eWxlIHdpdGhcbiAgICB8IGBJbnRlcm5hbCAtPiBbJXNleHAgKHQgOiBhIHRfaW50ZXJuYWwpXVxuICAgIHwgYFByZXR0eSAtPiBbJXNleHAgKHByZXR0eSB0IDogYSBQcmV0dHkudCldXG4gIDs7XG5cbiAgbGV0IGNvbXB1dGVfZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5IH5sZXZlbF9iaXRzIH5iaXRzX3Blcl9zbG90ID1cbiAgICBsZXQgYml0cyA9IE51bV9rZXlfYml0cy4oICsgKSBsZXZlbF9iaXRzIGJpdHNfcGVyX3Nsb3QgaW5cbiAgICBpZiBOdW1fa2V5X2JpdHMuZXF1YWwgYml0cyBOdW1fa2V5X2JpdHMubWF4X3ZhbHVlXG4gICAgdGhlbiBLZXkuU3Bhbi5tYXhfdmFsdWVcbiAgICBlbHNlIEtleS5TcGFuLnByZWQgKEtleS5udW1fa2V5cyBiaXRzKVxuICA7O1xuXG4gIGxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA6IHVuaXQgPVxuICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgbGV0IGxldmVsX2ludmFyaWFudCBsZXZlbCA9XG4gICAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gbGV2ZWwgWyVzZXhwX29mOiBfIExldmVsLnRdIChmdW4gKCkgLT5cbiAgICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgbGV2ZWwgZiBpblxuICAgICAgICBMZXZlbC5GaWVsZHMuaXRlclxuICAgICAgICAgIH5pbmRleDooY2hlY2sgKGZ1biBpbmRleCAtPiBhc3NlcnQgKGluZGV4ID49IDApKSlcbiAgICAgICAgICB+Yml0czooY2hlY2sgKGZ1biBiaXRzIC0+IGFzc2VydCAoTnVtX2tleV9iaXRzLiggPiApIGJpdHMgTnVtX2tleV9iaXRzLnplcm8pKSlcbiAgICAgICAgICB+c2xvdHNfbWFzazpcbiAgICAgICAgICAgIChjaGVja1xuICAgICAgICAgICAgICAgKFsldGVzdF9yZXN1bHQ6IFNsb3RzX21hc2sudF1cbiAgICAgICAgICAgICAgICAgIH5leHBlY3Q6KFNsb3RzX21hc2suY3JlYXRlIH5sZXZlbF9iaXRzOmxldmVsLmJpdHMpKSlcbiAgICAgICAgICB+Yml0c19wZXJfc2xvdDpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIGJpdHNfcGVyX3Nsb3QgLT5cbiAgICAgICAgICAgICAgIGFzc2VydCAoTnVtX2tleV9iaXRzLiggPj0gKSBiaXRzX3Blcl9zbG90IE51bV9rZXlfYml0cy56ZXJvKSkpXG4gICAgICAgICAgfmtleXNfcGVyX3Nsb3Q6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBrZXlzX3Blcl9zbG90IC0+XG4gICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBLZXkuU3Bhbi50XVxuICAgICAgICAgICAgICAgICBrZXlzX3Blcl9zbG90XG4gICAgICAgICAgICAgICAgIH5leHBlY3Q6KEtleS5udW1fa2V5cyBsZXZlbC5iaXRzX3Blcl9zbG90KSkpXG4gICAgICAgICAgfm1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2s6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBtaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrIC0+XG4gICAgICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgICAgICBNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrLmVxdWFsXG4gICAgICAgICAgICAgICAgICAgbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFza1xuICAgICAgICAgICAgICAgICAgIChNaW5fa2V5X2luX3NhbWVfc2xvdF9tYXNrLmNyZWF0ZVxuICAgICAgICAgICAgICAgICAgICAgIH5iaXRzX3Blcl9zbG90OmxldmVsLmJpdHNfcGVyX3Nsb3QpKSkpXG4gICAgICAgICAgfmRpZmZfbWF4X21pbl9hbGxvd2VkX2tleTpcbiAgICAgICAgICAgIChjaGVja1xuICAgICAgICAgICAgICAgKFsldGVzdF9yZXN1bHQ6IEtleS5TcGFuLnRdXG4gICAgICAgICAgICAgICAgICB+ZXhwZWN0OlxuICAgICAgICAgICAgICAgICAgICAoY29tcHV0ZV9kaWZmX21heF9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgICAgICAgICAgfmxldmVsX2JpdHM6bGV2ZWwuYml0c1xuICAgICAgICAgICAgICAgICAgICAgICB+Yml0c19wZXJfc2xvdDpsZXZlbC5iaXRzX3Blcl9zbG90KSkpXG4gICAgICAgICAgfmxlbmd0aDpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIGxlbmd0aCAtPlxuICAgICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgICAgbGVuZ3RoXG4gICAgICAgICAgICAgICAgID0gQXJyYXkuZm9sZCBsZXZlbC5zbG90cyB+aW5pdDowIH5mOihmdW4gbiBlbHQgLT5cbiAgICAgICAgICAgICAgICAgICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHRcbiAgICAgICAgICAgICAgICAgICB0aGVuIG5cbiAgICAgICAgICAgICAgICAgICBlbHNlIG4gKyBJbnRlcm5hbF9lbHQubGVuZ3RoIHBvb2wgZWx0KSkpKVxuICAgICAgICAgIH5taW5fYWxsb3dlZF9rZXk6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBtaW5fYWxsb3dlZF9rZXkgLT5cbiAgICAgICAgICAgICAgIGFzc2VydCAoS2V5LiggPj0gKSBtaW5fYWxsb3dlZF9rZXkgS2V5Lnplcm8pO1xuICAgICAgICAgICAgICAgaWYgS2V5LiggPCApIG1pbl9hbGxvd2VkX2tleSBLZXkubWF4X3ZhbHVlXG4gICAgICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEtleS5TcGFuLnRdXG4gICAgICAgICAgICAgICAgICAgKEtleS5yZW0gbWluX2FsbG93ZWRfa2V5IGxldmVsLmtleXNfcGVyX3Nsb3QpXG4gICAgICAgICAgICAgICAgICAgfmV4cGVjdDpLZXkuU3Bhbi56ZXJvKSlcbiAgICAgICAgICB+bWF4X2FsbG93ZWRfa2V5OlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gbWF4X2FsbG93ZWRfa2V5IC0+XG4gICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBLZXkudF1cbiAgICAgICAgICAgICAgICAgbWF4X2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAgIH5leHBlY3Q6XG4gICAgICAgICAgICAgICAgICAgKEtleS5hZGRfY2xhbXBfdG9fbWF4XG4gICAgICAgICAgICAgICAgICAgICAgbGV2ZWwubWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAgICAgICAgbGV2ZWwuZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5KSkpXG4gICAgICAgICAgfnNsb3RzOlxuICAgICAgICAgICAgKGNoZWNrIChmdW4gc2xvdHMgLT5cbiAgICAgICAgICAgICAgIEFycmF5Lml0ZXIgc2xvdHMgfmY6KGZ1biBlbHQgLT5cbiAgICAgICAgICAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQpXG4gICAgICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgICAgIEludGVybmFsX2VsdC5pbnZhcmlhbnQgcG9vbCBpbnZhcmlhbnRfYSBlbHQ7XG4gICAgICAgICAgICAgICAgICAgSW50ZXJuYWxfZWx0Lml0ZXIgcG9vbCBlbHQgfmY6KGZ1biBlbHQgLT5cbiAgICAgICAgICAgICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgICAgICAgICAgIEtleS4oID49IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAoSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdClcbiAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbC5taW5fYWxsb3dlZF9rZXkpO1xuICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICAgICAgICAgICAgS2V5LiggPD0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgIChJbnRlcm5hbF9lbHQua2V5IHBvb2wgZWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsLm1heF9hbGxvd2VkX2tleSk7XG4gICAgICAgICAgICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgICAgICAgICAgICBLZXkuKCA+PSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgKEludGVybmFsX2VsdC5rZXkgcG9vbCBlbHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgdC5lbHRfa2V5X2xvd2VyX2JvdW5kKTtcbiAgICAgICAgICAgICAgICAgICAgIGFzc2VydCAoSW50ZXJuYWxfZWx0LmxldmVsX2luZGV4IHBvb2wgZWx0ID0gbGV2ZWwuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgaW52YXJpYW50X2EgKEludGVybmFsX2VsdC52YWx1ZSBwb29sIGVsdCkpKSkpKSlcbiAgICBpblxuICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogXyB0X2ludGVybmFsXSAoZnVuICgpIC0+XG4gICAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICAgIGFzc2VydCAoS2V5LiggPj0gKSAobWluX2FsbG93ZWRfa2V5IHQpIEtleS56ZXJvKTtcbiAgICAgIGFzc2VydCAoS2V5LiggPj0gKSAobWF4X2FsbG93ZWRfa2V5IHQpIChtaW5fYWxsb3dlZF9rZXkgdCkpO1xuICAgICAgRmllbGRzLml0ZXJcbiAgICAgICAgfmxlbmd0aDooY2hlY2sgKGZ1biBsZW5ndGggLT4gYXNzZXJ0IChsZW5ndGggPj0gMCkpKVxuICAgICAgICB+cG9vbDooY2hlY2sgKEludGVybmFsX2VsdC5Qb29sLmludmFyaWFudCBpZ25vcmUpKVxuICAgICAgICB+bWluX2VsdDpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBlbHRfIC0+XG4gICAgICAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHRfKVxuICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgYXNzZXJ0IChJbnRlcm5hbF9lbHQuaXNfdmFsaWQgdC5wb29sIGVsdF8pO1xuICAgICAgICAgICAgICAgYXNzZXJ0IChLZXkuZXF1YWwgdC5lbHRfa2V5X2xvd2VyX2JvdW5kIChJbnRlcm5hbF9lbHQua2V5IHQucG9vbCBlbHRfKSkpKSlcbiAgICAgICAgfmVsdF9rZXlfbG93ZXJfYm91bmQ6XG4gICAgICAgICAgKGNoZWNrIChmdW4gZWx0X2tleV9sb3dlcl9ib3VuZCAtPlxuICAgICAgICAgICAgIGFzc2VydCAoS2V5LiggPj0gKSBlbHRfa2V5X2xvd2VyX2JvdW5kIChtaW5fYWxsb3dlZF9rZXkgdCkpO1xuICAgICAgICAgICAgIGFzc2VydCAoS2V5LiggPD0gKSBlbHRfa2V5X2xvd2VyX2JvdW5kIChtYXhfYWxsb3dlZF9rZXkgdCkpO1xuICAgICAgICAgICAgIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgdC5taW5fZWx0KVxuICAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgIGFzc2VydCAoXG4gICAgICAgICAgICAgICAgIEtleS5lcXVhbCBlbHRfa2V5X2xvd2VyX2JvdW5kIChJbnRlcm5hbF9lbHQua2V5IHQucG9vbCB0Lm1pbl9lbHQpKSkpXG4gICAgICAgIH5sZXZlbHM6XG4gICAgICAgICAgKGNoZWNrIChmdW4gbGV2ZWxzIC0+XG4gICAgICAgICAgICAgYXNzZXJ0IChudW1fbGV2ZWxzIHQgPiAwKTtcbiAgICAgICAgICAgICBBcnJheS5pdGVyaSBsZXZlbHMgfmY6KGZ1biBsZXZlbF9pbmRleCBsZXZlbCAtPlxuICAgICAgICAgICAgICAgYXNzZXJ0IChsZXZlbF9pbmRleCA9IExldmVsLmluZGV4IGxldmVsKTtcbiAgICAgICAgICAgICAgIGxldmVsX2ludmFyaWFudCBsZXZlbDtcbiAgICAgICAgICAgICAgIGlmIGxldmVsX2luZGV4ID4gMFxuICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgIGxldCBwcmV2X2xldmVsID0gbGV2ZWxzLihsZXZlbF9pbmRleCAtIDEpIGluXG4gICAgICAgICAgICAgICAgIGxldCBtb2R1bGUgTCA9IExldmVsIGluXG4gICAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEtleS5TcGFuLnRdXG4gICAgICAgICAgICAgICAgICAgKEwua2V5c19wZXJfc2xvdCBsZXZlbClcbiAgICAgICAgICAgICAgICAgICB+ZXhwZWN0OihLZXkuU3Bhbi5zdWNjIHByZXZfbGV2ZWwuZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5KTtcbiAgICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogS2V5LnRdXG4gICAgICAgICAgICAgICAgICAgbGV2ZWwubWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAgICAgfmV4cGVjdDpcbiAgICAgICAgICAgICAgICAgICAgIChMZXZlbC5jb21wdXRlX21pbl9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH5wcmV2X2xldmVsX21heF9hbGxvd2VkX2tleTpwcmV2X2xldmVsLm1heF9hbGxvd2VkX2tleSkpKSkpKVxuICA7O1xuXG4gICgqKiBbbWluX2VsdF9dIHJldHVybnMgW251bGxdIGlmIGl0IGNhbid0IGZpbmQgdGhlIGRlc2lyZWQgZWxlbWVudC4gIFdlIHdyYXAgaXQgdXBcbiAgICAgIGFmdGVyd2FyZHMgdG8gcmV0dXJuIGFuIFtvcHRpb25dLiAqKVxuICBsZXQgbWluX2VsdF8gdCA9XG4gICAgaWYgaXNfZW1wdHkgdFxuICAgIHRoZW4gSW50ZXJuYWxfZWx0Lm51bGwgKClcbiAgICBlbHNlIGlmIG5vdCAoSW50ZXJuYWxfZWx0LmlzX251bGwgdC5taW5fZWx0KVxuICAgIHRoZW4gdC5taW5fZWx0XG4gICAgZWxzZSAoXG4gICAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgICAgbGV0IG1pbl9lbHRfYWxyZWFkeV9mb3VuZCA9IHJlZiAoSW50ZXJuYWxfZWx0Lm51bGwgKCkpIGluXG4gICAgICBsZXQgbWluX2tleV9hbHJlYWR5X2ZvdW5kID0gcmVmIEtleS5tYXhfdmFsdWUgaW5cbiAgICAgIGxldCBsZXZlbF9pbmRleCA9IHJlZiAwIGluXG4gICAgICBsZXQgbnVtX2xldmVscyA9IG51bV9sZXZlbHMgdCBpblxuICAgICAgd2hpbGUgIWxldmVsX2luZGV4IDwgbnVtX2xldmVscyBkb1xuICAgICAgICBsZXQgbGV2ZWwgPSB0LmxldmVscy4oIWxldmVsX2luZGV4KSBpblxuICAgICAgICBpZiBLZXkuKCA+ICkgKExldmVsLm1pbl9hbGxvd2VkX2tleSBsZXZlbCkgIW1pbl9rZXlfYWxyZWFkeV9mb3VuZFxuICAgICAgICB0aGVuXG4gICAgICAgICAgKCogV2UgZG9uJ3QgbmVlZCB0byBjb25zaWRlciBhbnkgbW9yZSBsZXZlbHMuICBRdWl0IHRoZSBsb29wLiAqKVxuICAgICAgICAgIGxldmVsX2luZGV4IDo9IG51bV9sZXZlbHNcbiAgICAgICAgZWxzZSBpZiBsZXZlbC5sZW5ndGggPSAwXG4gICAgICAgIHRoZW4gaW5jciBsZXZlbF9pbmRleFxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBMb29rIGluIFtsZXZlbF0uICopXG4gICAgICAgICAgbGV0IHNsb3RzID0gbGV2ZWwuc2xvdHMgaW5cbiAgICAgICAgICBsZXQgc2xvdF9taW5fa2V5ID1cbiAgICAgICAgICAgIHJlZlxuICAgICAgICAgICAgICAoTGV2ZWwubWluX2tleV9pbl9zYW1lX3Nsb3RcbiAgICAgICAgICAgICAgICAgbGV2ZWxcbiAgICAgICAgICAgICAgICAgfmtleTooS2V5Lm1heCBsZXZlbC5taW5fYWxsb3dlZF9rZXkgdC5lbHRfa2V5X2xvd2VyX2JvdW5kKSlcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBzbG90ID0gcmVmIChMZXZlbC5zbG90IGxldmVsIH5rZXk6IXNsb3RfbWluX2tleSkgaW5cbiAgICAgICAgICAoKiBGaW5kIHRoZSBmaXJzdCBub25lbXB0eSBzbG90IHdpdGggYSBzbWFsbCBlbm91Z2ggW3Nsb3RfbWluX2tleV0uICopXG4gICAgICAgICAgd2hpbGVcbiAgICAgICAgICAgIEludGVybmFsX2VsdC5pc19udWxsIHNsb3RzLighc2xvdClcbiAgICAgICAgICAgICYmIEtleS4oIDwgKSAhc2xvdF9taW5fa2V5ICFtaW5fa2V5X2FscmVhZHlfZm91bmRcbiAgICAgICAgICBkb1xuICAgICAgICAgICAgc2xvdCA6PSBMZXZlbC5uZXh0X3Nsb3QgbGV2ZWwgIXNsb3Q7XG4gICAgICAgICAgICBzbG90X21pbl9rZXkgOj0gS2V5LmFkZCAhc2xvdF9taW5fa2V5IGxldmVsLmtleXNfcGVyX3Nsb3RcbiAgICAgICAgICBkb25lO1xuICAgICAgICAgIGxldCBmaXJzdCA9IHNsb3RzLighc2xvdCkgaW5cbiAgICAgICAgICBpZiBub3QgKEludGVybmFsX2VsdC5pc19udWxsIGZpcnN0KVxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgKCogVmlzaXQgYWxsIG9mIHRoZSBlbHRzIGluIHRoaXMgc2xvdCBhbmQgZmluZCBvbmUgd2l0aCBtaW5pbXVtIGtleS4gKilcbiAgICAgICAgICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHJlZiBmaXJzdCBpblxuICAgICAgICAgICAgd2hpbGUgIWNvbnRpbnVlIGRvXG4gICAgICAgICAgICAgIGxldCBjdXJyZW50X2tleSA9IEludGVybmFsX2VsdC5rZXkgcG9vbCAhY3VycmVudCBpblxuICAgICAgICAgICAgICBpZiBLZXkuKCA8PSApIGN1cnJlbnRfa2V5ICFtaW5fa2V5X2FscmVhZHlfZm91bmRcbiAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgbWluX2VsdF9hbHJlYWR5X2ZvdW5kIDo9ICFjdXJyZW50O1xuICAgICAgICAgICAgICAgIG1pbl9rZXlfYWxyZWFkeV9mb3VuZCA6PSBjdXJyZW50X2tleSk7XG4gICAgICAgICAgICAgIGxldCBuZXh0ID0gSW50ZXJuYWxfZWx0Lm5leHQgcG9vbCAhY3VycmVudCBpblxuICAgICAgICAgICAgICAoKiBJZiBbIWxldmVsX2luZGV4ID0gMF0gdGhlbiBhbGwgZWx0cyBpbiB0aGlzIHNsb3QgaGF2ZSB0aGUgc2FtZSBba2V5XSxcbiAgICAgICAgICAgICAgICAgaS5lLiBbIXNsb3RfbWluX2tleV0uICBTbywgd2UgZG9uJ3QgaGF2ZSB0byBjaGVjayBhbnkgZWxlbWVudHMgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgW2ZpcnN0XS4gIFRoaXMgaXMgYSB1c2VmdWwgc2hvcnQgY3V0IGluIHRoZSBjb21tb24gY2FzZSB0aGF0IHRoZXJlIGFyZVxuICAgICAgICAgICAgICAgICBtdWx0aXBsZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBtaW4gc2xvdCBpbiBsZXZlbCAwLiAqKVxuICAgICAgICAgICAgICBpZiBwaHlzX2VxdWFsIG5leHQgZmlyc3QgfHwgIWxldmVsX2luZGV4ID0gMFxuICAgICAgICAgICAgICB0aGVuIGNvbnRpbnVlIDo9IGZhbHNlXG4gICAgICAgICAgICAgIGVsc2UgY3VycmVudCA6PSBuZXh0XG4gICAgICAgICAgICBkb25lKTtcbiAgICAgICAgICAoKiBGaW5pc2hlZCBsb29raW5nIGluIFtsZXZlbF0uICBNb3ZlIHVwIHRvIHRoZSBuZXh0IGxldmVsLiAqKVxuICAgICAgICAgIGluY3IgbGV2ZWxfaW5kZXgpXG4gICAgICBkb25lO1xuICAgICAgdC5taW5fZWx0IDwtICFtaW5fZWx0X2FscmVhZHlfZm91bmQ7XG4gICAgICB0LmVsdF9rZXlfbG93ZXJfYm91bmQgPC0gIW1pbl9rZXlfYWxyZWFkeV9mb3VuZDtcbiAgICAgIHQubWluX2VsdClcbiAgOztcblxuICBsZXRbQGNvbGRdIHJhaXNlX2FkZF9lbHRfa2V5X291dF9vZl9ib3VuZHMgdCBrZXkgPVxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIlByaW9yaXR5X3F1ZXVlLmFkZF9lbHQga2V5IG91dCBvZiBib3VuZHNcIlxuICAgICAgICAgIChrZXkgOiBLZXkudClcbiAgICAgICAgICAobWluX2FsbG93ZWRfa2V5IHQgOiBLZXkudClcbiAgICAgICAgICAobWF4X2FsbG93ZWRfa2V5IHQgOiBLZXkudClcbiAgICAgICAgICB+cHJpb3JpdHlfcXVldWU6KHQgOiBfIHQpXVxuICA7O1xuXG4gIGxldFtAY29sZF0gcmFpc2VfYWRkX2VsdF9rZXlfb3V0X29mX2xldmVsX2JvdW5kcyBrZXkgbGV2ZWwgPVxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIlByaW9yaXR5X3F1ZXVlLmFkZF9lbHQga2V5IG91dCBvZiBsZXZlbCBib3VuZHNcIiAoa2V5IDogS2V5LnQpIChsZXZlbCA6IF8gTGV2ZWwudCldXG4gIDs7XG5cbiAgbGV0IGFkZF9lbHQgdCBlbHQgPVxuICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgbGV0IGtleSA9IEludGVybmFsX2VsdC5rZXkgcG9vbCBlbHQgaW5cbiAgICBpZiBub3QgKEtleS4oID49ICkga2V5IChtaW5fYWxsb3dlZF9rZXkgdCkgJiYgS2V5LiggPD0gKSBrZXkgKG1heF9hbGxvd2VkX2tleSB0KSlcbiAgICB0aGVuIHJhaXNlX2FkZF9lbHRfa2V5X291dF9vZl9ib3VuZHMgdCBrZXk7XG4gICAgKCogRmluZCB0aGUgbG93ZXN0IGxldmVsIHRoYXQgd2lsbCBob2xkIFtlbHRdLiAqKVxuICAgIGxldCBsZXZlbF9pbmRleCA9XG4gICAgICBsZXQgbGV2ZWxfaW5kZXggPSByZWYgMCBpblxuICAgICAgd2hpbGUgS2V5LiggPiApIGtleSAoTGV2ZWwubWF4X2FsbG93ZWRfa2V5IHQubGV2ZWxzLighbGV2ZWxfaW5kZXgpKSBkb1xuICAgICAgICBpbmNyIGxldmVsX2luZGV4XG4gICAgICBkb25lO1xuICAgICAgIWxldmVsX2luZGV4XG4gICAgaW5cbiAgICBsZXQgbGV2ZWwgPSB0LmxldmVscy4obGV2ZWxfaW5kZXgpIGluXG4gICAgaWYgbm90IChLZXkuKCA+PSApIGtleSBsZXZlbC5taW5fYWxsb3dlZF9rZXkgJiYgS2V5LiggPD0gKSBrZXkgbGV2ZWwubWF4X2FsbG93ZWRfa2V5KVxuICAgIHRoZW4gcmFpc2VfYWRkX2VsdF9rZXlfb3V0X29mX2xldmVsX2JvdW5kcyBrZXkgbGV2ZWw7XG4gICAgbGV2ZWwubGVuZ3RoIDwtIGxldmVsLmxlbmd0aCArIDE7XG4gICAgSW50ZXJuYWxfZWx0LnNldF9sZXZlbF9pbmRleCBwb29sIGVsdCBsZXZlbF9pbmRleDtcbiAgICBsZXQgc2xvdCA9IExldmVsLnNsb3QgbGV2ZWwgfmtleSBpblxuICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgbGV0IGZpcnN0ID0gc2xvdHMuKHNsb3QpIGluXG4gICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBmaXJzdClcbiAgICB0aGVuIEludGVybmFsX2VsdC5pbnNlcnRfYXRfZW5kIHBvb2wgZmlyc3QgfnRvX2FkZDplbHRcbiAgICBlbHNlIChcbiAgICAgIHNsb3RzLihzbG90KSA8LSBlbHQ7XG4gICAgICBJbnRlcm5hbF9lbHQubGlua190b19zZWxmIHBvb2wgZWx0KVxuICA7O1xuXG4gIGxldCBpbnRlcm5hbF9hZGRfZWx0IHQgZWx0ID1cbiAgICBsZXQga2V5ID0gSW50ZXJuYWxfZWx0LmtleSB0LnBvb2wgZWx0IGluXG4gICAgaWYgS2V5LiggPCApIGtleSB0LmVsdF9rZXlfbG93ZXJfYm91bmRcbiAgICB0aGVuIChcbiAgICAgIHQubWluX2VsdCA8LSBlbHQ7XG4gICAgICB0LmVsdF9rZXlfbG93ZXJfYm91bmQgPC0ga2V5KTtcbiAgICBhZGRfZWx0IHQgZWx0O1xuICAgIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMVxuICA7O1xuXG4gIGxldFtAY29sZF0gcmFpc2VfZ290X2ludmFsaWRfa2V5IHQga2V5ID1cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJUaW1pbmdfd2hlZWwuYWRkX2F0X2ludGVydmFsX251bSBnb3QgaW52YWxpZCBpbnRlcnZhbCBudW1cIlxuICAgICAgICAgIH5pbnRlcnZhbF9udW06KGtleSA6IEtleS50KVxuICAgICAgICAgIH5taW5fYWxsb3dlZF9hbGFybV9pbnRlcnZhbF9udW06KG1pbl9hbGxvd2VkX2tleSB0IDogS2V5LnQpXG4gICAgICAgICAgfm1heF9hbGxvd2VkX2FsYXJtX2ludGVydmFsX251bToobWF4X2FsbG93ZWRfa2V5IHQgOiBLZXkudCldXG4gIDs7XG5cbiAgbGV0IGVuc3VyZV92YWxpZF9rZXkgdCB+a2V5ID1cbiAgICBpZiBLZXkuKCA8ICkga2V5IChtaW5fYWxsb3dlZF9rZXkgdCkgfHwgS2V5LiggPiApIGtleSAobWF4X2FsbG93ZWRfa2V5IHQpXG4gICAgdGhlbiByYWlzZV9nb3RfaW52YWxpZF9rZXkgdCBrZXlcbiAgOztcblxuICBsZXQgaW50ZXJuYWxfYWRkIHQgfmtleSB+YXQgdmFsdWUgPVxuICAgIGVuc3VyZV92YWxpZF9rZXkgdCB+a2V5O1xuICAgIGlmIEludGVybmFsX2VsdC5Qb29sLmlzX2Z1bGwgdC5wb29sIHRoZW4gdC5wb29sIDwtIEludGVybmFsX2VsdC5Qb29sLmdyb3cgdC5wb29sO1xuICAgIGxldCBlbHQgPSBJbnRlcm5hbF9lbHQuY3JlYXRlIHQucG9vbCB+a2V5IH5hdCB+dmFsdWUgfmxldmVsX2luZGV4OigtMSkgaW5cbiAgICBpbnRlcm5hbF9hZGRfZWx0IHQgZWx0O1xuICAgIGVsdFxuICA7O1xuXG4gICgqKiBbcmVtb3ZlX29yX3JlX2FkZF9lbHRzXSB2aXNpdHMgZWFjaCBlbGVtZW50IGluIHRoZSBjaXJjdWxhciBkb3VibHktbGlua2VkIGxpc3RcbiAgICAgIFtmaXJzdF0uICBJZiB0aGUgZWxlbWVudCdzIGtleSBpcyBbPj0gdF9taW5fYWxsb3dlZF9rZXldLCB0aGVuIGl0IGFkZHMgdGhlIGVsZW1lbnRcbiAgICAgIGJhY2sgYXQgYSBsb3dlciBsZXZlbC4gIElmIG5vdCwgdGhlbiBpdCBjYWxscyBbaGFuZGxlX3JlbW92ZWRdIGFuZCBbZnJlZV1zIHRoZVxuICAgICAgZWxlbWVudC4gKilcbiAgbGV0IHJlbW92ZV9vcl9yZV9hZGRfZWx0cyB0IChsZXZlbCA6IF8gTGV2ZWwudCkgZmlyc3QgfnRfbWluX2FsbG93ZWRfa2V5IH5oYW5kbGVfcmVtb3ZlZFxuICAgID1cbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIGxldCBjdXJyZW50ID0gcmVmIGZpcnN0IGluXG4gICAgbGV0IGNvbnRpbnVlID0gcmVmIHRydWUgaW5cbiAgICB3aGlsZSAhY29udGludWUgZG9cbiAgICAgICgqIFdlIGV4dHJhY3QgW25leHRdIGZyb20gW2N1cnJlbnRdIGZpcnN0LCBiZWNhdXNlIHdlIHdpbGwgbW9kaWZ5IG9yIFtmcmVlXVxuICAgICAgICAgW2N1cnJlbnRdIGJlZm9yZSBjb250aW51aW5nIHRoZSBsb29wLiAqKVxuICAgICAgbGV0IG5leHQgPSBJbnRlcm5hbF9lbHQubmV4dCBwb29sICFjdXJyZW50IGluXG4gICAgICBsZXZlbC5sZW5ndGggPC0gbGV2ZWwubGVuZ3RoIC0gMTtcbiAgICAgIGlmIEtleS4oID49ICkgKEludGVybmFsX2VsdC5rZXkgcG9vbCAhY3VycmVudCkgdF9taW5fYWxsb3dlZF9rZXlcbiAgICAgIHRoZW4gYWRkX2VsdCB0ICFjdXJyZW50XG4gICAgICBlbHNlIChcbiAgICAgICAgdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxO1xuICAgICAgICBoYW5kbGVfcmVtb3ZlZCAoSW50ZXJuYWxfZWx0LnRvX2V4dGVybmFsICFjdXJyZW50KTtcbiAgICAgICAgSW50ZXJuYWxfZWx0LmZyZWUgcG9vbCAhY3VycmVudCk7XG4gICAgICBpZiBwaHlzX2VxdWFsIG5leHQgZmlyc3QgdGhlbiBjb250aW51ZSA6PSBmYWxzZSBlbHNlIGN1cnJlbnQgOj0gbmV4dFxuICAgIGRvbmVcbiAgOztcblxuICAoKiogW2luY3JlYXNlX2xldmVsX21pbl9hbGxvd2VkX2tleV0gaW5jcmVhc2VzIHRoZSBbbWluX2FsbG93ZWRfa2V5XSBvZiBbbGV2ZWxdIHRvIGFzXG4gICAgICBsYXJnZSBhIHZhbHVlIGFzIHBvc3NpYmxlLCBidXQgbm8gbW9yZSB0aGFuIFttYXhfbGV2ZWxfbWluX2FsbG93ZWRfa2V5XS5cbiAgICAgIFt0X21pbl9hbGxvd2VkX2tleV0gaXMgdGhlIG1pbmltdW0gYWxsb3dlZCBrZXkgZm9yIHRoZSBlbnRpcmUgdGltaW5nIHdoZWVsLiAgQXNcbiAgICAgIGVsZW1lbnRzIGFyZSBlbmNvdW50ZXJlZCwgdGhleSBhcmUgcmVtb3ZlZCBmcm9tIHRoZSB0aW1pbmcgd2hlZWwgaWYgdGhlaXIga2V5IGlzXG4gICAgICBzbWFsbGVyIHRoYW4gW3RfbWluX2FsbG93ZWRfa2V5XSwgb3IgYWRkZWQgYXQgYSBsb3dlciBsZXZlbCBpZiBub3QuICopXG4gIGxldCBpbmNyZWFzZV9sZXZlbF9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgdFxuICAgICAgICAobGV2ZWwgOiBfIExldmVsLnQpXG4gICAgICAgIH5wcmV2X2xldmVsX21heF9hbGxvd2VkX2tleVxuICAgICAgICB+dF9taW5fYWxsb3dlZF9rZXlcbiAgICAgICAgfmhhbmRsZV9yZW1vdmVkXG4gICAgPVxuICAgIGxldCBkZXNpcmVkX21pbl9hbGxvd2VkX2tleSA9XG4gICAgICBMZXZlbC5jb21wdXRlX21pbl9hbGxvd2VkX2tleSBsZXZlbCB+cHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXlcbiAgICBpblxuICAgICgqIFdlIHJlcXVpcmUgdGhhdCBbbW9kIGxldmVsLm1pbl9hbGxvd2VkX2tleSBsZXZlbC5rZXlzX3Blcl9zbG90ID0gMF0uICBTbyxcbiAgICAgICB3ZSBzdGFydCBbbGV2ZWxfbWluX2FsbG93ZWRfa2V5XSB3aGVyZSB0aGF0IGlzIHRydWUsIGFuZCB0aGVuIGluY3JlYXNlIGl0IGJ5XG4gICAgICAgW2tleXNfcGVyX3Nsb3RdIGVhY2ggaXRlcmF0aW9uIG9mIHRoZSBsb29wLiAqKVxuICAgIGxldCBsZXZlbF9taW5fYWxsb3dlZF9rZXkgPVxuICAgICAgTGV2ZWwubWluX2tleV9pbl9zYW1lX3Nsb3RcbiAgICAgICAgbGV2ZWxcbiAgICAgICAgfmtleTpcbiAgICAgICAgICAoS2V5Lm1pblxuICAgICAgICAgICAgIGRlc2lyZWRfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgKEtleS5tYXggbGV2ZWwubWluX2FsbG93ZWRfa2V5IHQuZWx0X2tleV9sb3dlcl9ib3VuZCkpXG4gICAgaW5cbiAgICBsZXQgbGV2ZWxfbWluX2FsbG93ZWRfa2V5ID0gcmVmIGxldmVsX21pbl9hbGxvd2VkX2tleSBpblxuICAgIGxldCBzbG90ID0gcmVmIChMZXZlbC5zbG90IGxldmVsIH5rZXk6IWxldmVsX21pbl9hbGxvd2VkX2tleSkgaW5cbiAgICBsZXQga2V5c19wZXJfc2xvdCA9IGxldmVsLmtleXNfcGVyX3Nsb3QgaW5cbiAgICBsZXQgc2xvdHMgPSBsZXZlbC5zbG90cyBpblxuICAgIHdoaWxlIEtleS4oIDwgKSAhbGV2ZWxfbWluX2FsbG93ZWRfa2V5IGRlc2lyZWRfbWluX2FsbG93ZWRfa2V5IGRvXG4gICAgICBpZiBsZXZlbC5sZW5ndGggPSAwXG4gICAgICB0aGVuXG4gICAgICAgICgqIElmIG5vIGVsZW1lbnRzIHJlbWFpbiBhdCB0aGlzIGxldmVsLCB3ZSBjYW4ganVzdCBzZXQgW21pbl9hbGxvd2VkX2tleV0gdG8gdGhlXG4gICAgICAgICAgIGRlc2lyZWQgdmFsdWUuICopXG4gICAgICAgIGxldmVsX21pbl9hbGxvd2VkX2tleSA6PSBkZXNpcmVkX21pbl9hbGxvd2VkX2tleVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBmaXJzdCA9IHNsb3RzLighc2xvdCkgaW5cbiAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBmaXJzdClcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgc2xvdHMuKCFzbG90KSA8LSBJbnRlcm5hbF9lbHQubnVsbCAoKTtcbiAgICAgICAgICByZW1vdmVfb3JfcmVfYWRkX2VsdHMgdCBsZXZlbCBmaXJzdCB+dF9taW5fYWxsb3dlZF9rZXkgfmhhbmRsZV9yZW1vdmVkKTtcbiAgICAgICAgc2xvdCA6PSBMZXZlbC5uZXh0X3Nsb3QgbGV2ZWwgIXNsb3Q7XG4gICAgICAgIGxldmVsX21pbl9hbGxvd2VkX2tleSA6PSBLZXkuYWRkX2NsYW1wX3RvX21heCAhbGV2ZWxfbWluX2FsbG93ZWRfa2V5IGtleXNfcGVyX3Nsb3QpXG4gICAgZG9uZTtcbiAgICBsZXZlbC5taW5fYWxsb3dlZF9rZXkgPC0gZGVzaXJlZF9taW5fYWxsb3dlZF9rZXk7XG4gICAgbGV2ZWwubWF4X2FsbG93ZWRfa2V5XG4gICAgPC0gS2V5LmFkZF9jbGFtcF90b19tYXggZGVzaXJlZF9taW5fYWxsb3dlZF9rZXkgbGV2ZWwuZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5XG4gIDs7XG5cbiAgbW9kdWxlIEluY3JlYXNlX21pbl9hbGxvd2VkX2tleV9yZXN1bHQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgfCBNYXhfYWxsb3dlZF9rZXlfZGlkX25vdF9jaGFuZ2VcbiAgICAgIHwgTWF4X2FsbG93ZWRfa2V5X21heWJlX2NoYW5nZWRcbiAgZW5kXG5cbiAgbGV0IGluY3JlYXNlX21pbl9hbGxvd2VkX2tleSB0IH5rZXkgfmhhbmRsZV9yZW1vdmVkIDogSW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5X3Jlc3VsdC50ID1cbiAgICBpZiBLZXkuKCA8PSApIGtleSAobWluX2FsbG93ZWRfa2V5IHQpXG4gICAgdGhlbiBNYXhfYWxsb3dlZF9rZXlfZGlkX25vdF9jaGFuZ2VcbiAgICBlbHNlIChcbiAgICAgICgqIFdlIGluY3JlYXNlIHRoZSBbbWluX2FsbG93ZWRfa2V5XSBvZiBsZXZlbHMgaW4gb3JkZXIgdG8gcmVzdG9yZSB0aGUgaW52YXJpYW50XG4gICAgICAgICB0aGF0IHRoZXkgaGF2ZSBhcyBsYXJnZSBhcyBwb3NzaWJsZSBhIFttaW5fYWxsb3dlZF9rZXldLCB3aGlsZSBsZWF2aW5nIG5vIGdhcHNcbiAgICAgICAgIGluIGtleXMuICopXG4gICAgICBsZXQgbGV2ZWxfaW5kZXggPSByZWYgMCBpblxuICAgICAgbGV0IHJlc3VsdCA9IHJlZiBJbmNyZWFzZV9taW5fYWxsb3dlZF9rZXlfcmVzdWx0Lk1heF9hbGxvd2VkX2tleV9tYXliZV9jaGFuZ2VkIGluXG4gICAgICBsZXQgcHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXkgPSByZWYgKEtleS5wcmVkIGtleSkgaW5cbiAgICAgIGxldCBsZXZlbHMgPSB0LmxldmVscyBpblxuICAgICAgbGV0IG51bV9sZXZlbHMgPSBudW1fbGV2ZWxzIHQgaW5cbiAgICAgIHdoaWxlICFsZXZlbF9pbmRleCA8IG51bV9sZXZlbHMgZG9cbiAgICAgICAgbGV0IGxldmVsID0gbGV2ZWxzLighbGV2ZWxfaW5kZXgpIGluXG4gICAgICAgIGxldCBtaW5fYWxsb3dlZF9rZXlfYmVmb3JlID0gbGV2ZWwubWluX2FsbG93ZWRfa2V5IGluXG4gICAgICAgIGluY3JlYXNlX2xldmVsX21pbl9hbGxvd2VkX2tleVxuICAgICAgICAgIHRcbiAgICAgICAgICBsZXZlbFxuICAgICAgICAgIH5wcmV2X2xldmVsX21heF9hbGxvd2VkX2tleTohcHJldl9sZXZlbF9tYXhfYWxsb3dlZF9rZXlcbiAgICAgICAgICB+dF9taW5fYWxsb3dlZF9rZXk6a2V5XG4gICAgICAgICAgfmhhbmRsZV9yZW1vdmVkO1xuICAgICAgICBpZiBLZXkuZXF1YWwgKExldmVsLm1pbl9hbGxvd2VkX2tleSBsZXZlbCkgbWluX2FsbG93ZWRfa2V5X2JlZm9yZVxuICAgICAgICB0aGVuIChcbiAgICAgICAgICAoKiBUaGlzIGxldmVsIGRpZCBub3Qgc2hpZnQuICBEb24ndCBzaGlmdCBhbnkgaGlnaGVyIGxldmVscy4gKilcbiAgICAgICAgICBsZXZlbF9pbmRleCA6PSBudW1fbGV2ZWxzO1xuICAgICAgICAgIHJlc3VsdCA6PSBNYXhfYWxsb3dlZF9rZXlfZGlkX25vdF9jaGFuZ2UpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIExldmVsIFtsZXZlbF9pbmRleF0gc2hpZnRlZC4gIENvbnNpZGVyIHNoaWZ0aW5nIGhpZ2hlciBsZXZlbHMuICopXG4gICAgICAgICAgbGV2ZWxfaW5kZXggOj0gIWxldmVsX2luZGV4ICsgMTtcbiAgICAgICAgICBwcmV2X2xldmVsX21heF9hbGxvd2VkX2tleSA6PSBMZXZlbC5tYXhfYWxsb3dlZF9rZXkgbGV2ZWwpXG4gICAgICBkb25lO1xuICAgICAgaWYgS2V5LiggPiApIGtleSB0LmVsdF9rZXlfbG93ZXJfYm91bmRcbiAgICAgIHRoZW4gKFxuICAgICAgICAoKiBXZSBoYXZlIHJlbW92ZWQgW3QubWluX2VsdF0gb3IgaXQgd2FzIGFscmVhZHkgbnVsbCwgc28ganVzdCBzZXQgaXQgdG9cbiAgICAgICAgICAgbnVsbC4gKilcbiAgICAgICAgdC5taW5fZWx0IDwtIEludGVybmFsX2VsdC5udWxsICgpO1xuICAgICAgICB0LmVsdF9rZXlfbG93ZXJfYm91bmQgPC0gbWluX2FsbG93ZWRfa2V5IHQpO1xuICAgICAgIXJlc3VsdClcbiAgOztcblxuICBsZXQgY3JlYXRlID9jYXBhY2l0eSA/bGV2ZWxfYml0cyAoKSA9XG4gICAgbGV0IGxldmVsX2JpdHMgPVxuICAgICAgbWF0Y2ggbGV2ZWxfYml0cyB3aXRoXG4gICAgICB8IFNvbWUgbCAtPiBsXG4gICAgICB8IE5vbmUgLT4gTGV2ZWxfYml0cy5kZWZhdWx0XG4gICAgaW5cbiAgICBsZXQgXywgXywgbGV2ZWxzID1cbiAgICAgIExpc3QuZm9sZGlcbiAgICAgICAgbGV2ZWxfYml0c1xuICAgICAgICB+aW5pdDooTnVtX2tleV9iaXRzLnplcm8sIEtleS56ZXJvLCBbXSlcbiAgICAgICAgfmY6KGZ1blxuICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICAgKGJpdHNfcGVyX3Nsb3QsIG1heF9sZXZlbF9taW5fYWxsb3dlZF9rZXksIGxldmVscylcbiAgICAgICAgICAgICAobGV2ZWxfYml0cyA6IE51bV9rZXlfYml0cy50KVxuICAgICAgICAgICAgIC0+XG4gICAgICAgICAgICAgICBsZXQga2V5c19wZXJfc2xvdCA9IEtleS5udW1fa2V5cyBiaXRzX3Blcl9zbG90IGluXG4gICAgICAgICAgICAgICBsZXQgZGlmZl9tYXhfbWluX2FsbG93ZWRfa2V5ID1cbiAgICAgICAgICAgICAgICAgY29tcHV0ZV9kaWZmX21heF9taW5fYWxsb3dlZF9rZXkgfmxldmVsX2JpdHMgfmJpdHNfcGVyX3Nsb3RcbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICBsZXQgbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFzayA9XG4gICAgICAgICAgICAgICAgIE1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2suY3JlYXRlIH5iaXRzX3Blcl9zbG90XG4gICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgbGV0IG1pbl9hbGxvd2VkX2tleSA9XG4gICAgICAgICAgICAgICAgIEtleS5taW5fa2V5X2luX3NhbWVfc2xvdCBtYXhfbGV2ZWxfbWluX2FsbG93ZWRfa2V5IG1pbl9rZXlfaW5fc2FtZV9zbG90X21hc2tcbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICBsZXQgbWF4X2FsbG93ZWRfa2V5ID1cbiAgICAgICAgICAgICAgICAgS2V5LmFkZF9jbGFtcF90b19tYXggbWluX2FsbG93ZWRfa2V5IGRpZmZfbWF4X21pbl9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgIGxldCBsZXZlbCA9XG4gICAgICAgICAgICAgICAgIHsgTGV2ZWwuaW5kZXhcbiAgICAgICAgICAgICAgICAgOyBiaXRzID0gbGV2ZWxfYml0c1xuICAgICAgICAgICAgICAgICA7IHNsb3RzX21hc2sgPSBTbG90c19tYXNrLmNyZWF0ZSB+bGV2ZWxfYml0c1xuICAgICAgICAgICAgICAgICA7IGJpdHNfcGVyX3Nsb3RcbiAgICAgICAgICAgICAgICAgOyBrZXlzX3Blcl9zbG90XG4gICAgICAgICAgICAgICAgIDsgbWluX2tleV9pbl9zYW1lX3Nsb3RfbWFza1xuICAgICAgICAgICAgICAgICA7IGRpZmZfbWF4X21pbl9hbGxvd2VkX2tleVxuICAgICAgICAgICAgICAgICA7IGxlbmd0aCA9IDBcbiAgICAgICAgICAgICAgICAgOyBtaW5fYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgICAgOyBtYXhfYWxsb3dlZF9rZXlcbiAgICAgICAgICAgICAgICAgOyBzbG90cyA9XG4gICAgICAgICAgICAgICAgICAgICBBcnJheS5jcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgfmxlbjooSW50NjMudG9faW50X2V4biAoTnVtX2tleV9iaXRzLnBvdzIgbGV2ZWxfYml0cykpXG4gICAgICAgICAgICAgICAgICAgICAgIChJbnRlcm5hbF9lbHQubnVsbCAoKSlcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICggTnVtX2tleV9iaXRzLiggKyApIGxldmVsX2JpdHMgYml0c19wZXJfc2xvdFxuICAgICAgICAgICAgICAgLCBLZXkuc3VjY19jbGFtcF90b19tYXggbWF4X2FsbG93ZWRfa2V5XG4gICAgICAgICAgICAgICAsIGxldmVsIDo6IGxldmVscyApKVxuICAgIGluXG4gICAgeyBsZW5ndGggPSAwXG4gICAgOyBwb29sID0gSW50ZXJuYWxfZWx0LlBvb2wuY3JlYXRlID9jYXBhY2l0eSAoKVxuICAgIDsgbWluX2VsdCA9IEludGVybmFsX2VsdC5udWxsICgpXG4gICAgOyBlbHRfa2V5X2xvd2VyX2JvdW5kID0gS2V5Lnplcm9cbiAgICA7IGxldmVscyA9IEFycmF5Lm9mX2xpc3RfcmV2IGxldmVsc1xuICAgIH1cbiAgOztcblxuICBsZXQgbWVtIHQgZWx0ID0gSW50ZXJuYWxfZWx0LmV4dGVybmFsX2lzX3ZhbGlkIHQucG9vbCBlbHRcblxuICBsZXQgaW50ZXJuYWxfcmVtb3ZlIHQgZWx0ID1cbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIGlmIEludGVybmFsX2VsdC5lcXVhbCBlbHQgdC5taW5fZWx0XG4gICAgdGhlblxuICAgICAgdC5taW5fZWx0IDwtIEludGVybmFsX2VsdC5udWxsICgpXG4gICAgKCogV2Uga2VlcCBbdC5lbHRfbG93ZXJfYm91bmRdIHNpbmNlIGl0IGlzIHZhbGlkIGV2ZW4gdGhvdWdoIFt0Lm1pbl9lbHRdIGlzIGJlaW5nXG4gICAgICAgcmVtb3ZlZC4gKik7XG4gICAgdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxO1xuICAgIGxldCBsZXZlbCA9IHQubGV2ZWxzLihJbnRlcm5hbF9lbHQubGV2ZWxfaW5kZXggcG9vbCBlbHQpIGluXG4gICAgbGV2ZWwubGVuZ3RoIDwtIGxldmVsLmxlbmd0aCAtIDE7XG4gICAgbGV0IHNsb3RzID0gbGV2ZWwuc2xvdHMgaW5cbiAgICBsZXQgc2xvdCA9IExldmVsLnNsb3QgbGV2ZWwgfmtleTooSW50ZXJuYWxfZWx0LmtleSBwb29sIGVsdCkgaW5cbiAgICBsZXQgZmlyc3QgPSBzbG90cy4oc2xvdCkgaW5cbiAgICBpZiBwaHlzX2VxdWFsIGVsdCAoSW50ZXJuYWxfZWx0Lm5leHQgcG9vbCBlbHQpXG4gICAgdGhlbiAoKiBbZWx0XSBpcyB0aGUgb25seSBlbGVtZW50IGluIHRoZSBzbG90ICopXG4gICAgICBzbG90cy4oc2xvdCkgPC0gSW50ZXJuYWxfZWx0Lm51bGwgKClcbiAgICBlbHNlIChcbiAgICAgIGlmIHBoeXNfZXF1YWwgZWx0IGZpcnN0IHRoZW4gc2xvdHMuKHNsb3QpIDwtIEludGVybmFsX2VsdC5uZXh0IHBvb2wgZWx0O1xuICAgICAgSW50ZXJuYWxfZWx0LnVubGluayBwb29sIGVsdClcbiAgOztcblxuICBsZXQgcmVtb3ZlIHQgZWx0ID1cbiAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgIGxldCBlbHQgPSBJbnRlcm5hbF9lbHQub2ZfZXh0ZXJuYWxfZXhuIHBvb2wgZWx0IGluXG4gICAgaW50ZXJuYWxfcmVtb3ZlIHQgZWx0O1xuICAgIEludGVybmFsX2VsdC5mcmVlIHBvb2wgZWx0XG4gIDs7XG5cbiAgbGV0IGZpcmVfcGFzdF9hbGFybXMgdCB+aGFuZGxlX2ZpcmVkIH5rZXkgfm5vdyA9XG4gICAgbGV0IGxldmVsID0gdC5sZXZlbHMuKDApIGluXG4gICAgaWYgbGV2ZWwubGVuZ3RoID4gMFxuICAgIHRoZW4gKFxuICAgICAgbGV0IHNsb3QgPSBMZXZlbC5zbG90IGxldmVsIH5rZXkgaW5cbiAgICAgIGxldCBzbG90cyA9IGxldmVsLnNsb3RzIGluXG4gICAgICBsZXQgcG9vbCA9IHQucG9vbCBpblxuICAgICAgbGV0IGZpcnN0ID0gcmVmIHNsb3RzLihzbG90KSBpblxuICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCAhZmlyc3QpXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IGN1cnJlbnQgPSByZWYgIWZpcnN0IGluXG4gICAgICAgIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gICAgICAgIHdoaWxlICFjb250aW51ZSBkb1xuICAgICAgICAgIGxldCBlbHQgPSAhY3VycmVudCBpblxuICAgICAgICAgIGxldCBuZXh0ID0gSW50ZXJuYWxfZWx0Lm5leHQgcG9vbCBlbHQgaW5cbiAgICAgICAgICBpZiBwaHlzX2VxdWFsIG5leHQgIWZpcnN0IHRoZW4gY29udGludWUgOj0gZmFsc2UgZWxzZSBjdXJyZW50IDo9IG5leHQ7XG4gICAgICAgICAgaWYgVGltZV9ucy4oIDw9ICkgKEludGVybmFsX2VsdC5hdCBwb29sIGVsdCkgbm93XG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBoYW5kbGVfZmlyZWQgKEludGVybmFsX2VsdC50b19leHRlcm5hbCBlbHQpO1xuICAgICAgICAgICAgaW50ZXJuYWxfcmVtb3ZlIHQgZWx0O1xuICAgICAgICAgICAgSW50ZXJuYWxfZWx0LmZyZWUgcG9vbCBlbHQ7XG4gICAgICAgICAgICAoKiBXZSByZWNvbXB1dGUgW2ZpcnN0XSBiZWNhdXNlIFtpbnRlcm5hbF9yZW1vdmVdIG1heSBoYXZlIGNoYW5nZWQgaXQuICopXG4gICAgICAgICAgICBmaXJzdCA6PSBzbG90cy4oc2xvdCkpXG4gICAgICAgIGRvbmUpKVxuICA7O1xuXG4gIGxldCBjaGFuZ2UgdCBlbHQgfmtleSB+YXQgPVxuICAgIGVuc3VyZV92YWxpZF9rZXkgdCB+a2V5O1xuICAgIGxldCBwb29sID0gdC5wb29sIGluXG4gICAgbGV0IGVsdCA9IEludGVybmFsX2VsdC5vZl9leHRlcm5hbF9leG4gcG9vbCBlbHQgaW5cbiAgICBpbnRlcm5hbF9yZW1vdmUgdCBlbHQ7XG4gICAgSW50ZXJuYWxfZWx0LnNldF9rZXkgcG9vbCBlbHQga2V5O1xuICAgIEludGVybmFsX2VsdC5zZXRfYXQgcG9vbCBlbHQgYXQ7XG4gICAgaW50ZXJuYWxfYWRkX2VsdCB0IGVsdFxuICA7O1xuXG4gIGxldCBjbGVhciB0ID1cbiAgICBpZiBub3QgKGlzX2VtcHR5IHQpXG4gICAgdGhlbiAoXG4gICAgICB0Lmxlbmd0aCA8LSAwO1xuICAgICAgbGV0IHBvb2wgPSB0LnBvb2wgaW5cbiAgICAgIGxldCBmcmVlX2VsdCBlbHQgPSBJbnRlcm5hbF9lbHQuZnJlZSBwb29sIGVsdCBpblxuICAgICAgbGV0IGxldmVscyA9IHQubGV2ZWxzIGluXG4gICAgICBmb3IgbGV2ZWxfaW5kZXggPSAwIHRvIEFycmF5Lmxlbmd0aCBsZXZlbHMgLSAxIGRvXG4gICAgICAgIGxldCBsZXZlbCA9IGxldmVscy4obGV2ZWxfaW5kZXgpIGluXG4gICAgICAgIGlmIGxldmVsLmxlbmd0aCA+IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV2ZWwubGVuZ3RoIDwtIDA7XG4gICAgICAgICAgbGV0IHNsb3RzID0gbGV2ZWwuc2xvdHMgaW5cbiAgICAgICAgICBmb3Igc2xvdF9pbmRleCA9IDAgdG8gQXJyYXkubGVuZ3RoIHNsb3RzIC0gMSBkb1xuICAgICAgICAgICAgbGV0IGVsdCA9IHNsb3RzLihzbG90X2luZGV4KSBpblxuICAgICAgICAgICAgaWYgbm90IChJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQpXG4gICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgSW50ZXJuYWxfZWx0Lml0ZXIgcG9vbCBlbHQgfmY6ZnJlZV9lbHQ7XG4gICAgICAgICAgICAgIHNsb3RzLihzbG90X2luZGV4KSA8LSBJbnRlcm5hbF9lbHQubnVsbCAoKSlcbiAgICAgICAgICBkb25lKVxuICAgICAgZG9uZSlcbiAgOztcbmVuZFxuXG5tb2R1bGUgSW50ZXJuYWxfZWx0ID0gUHJpb3JpdHlfcXVldWUuSW50ZXJuYWxfZWx0XG5tb2R1bGUgS2V5ID0gUHJpb3JpdHlfcXVldWUuS2V5XG5tb2R1bGUgSW50ZXJ2YWxfbnVtID0gS2V5XG5cbmxldCBtaW5faW50ZXJ2YWxfbnVtID0gSW50ZXJ2YWxfbnVtLnplcm9cblxuKCogQWxsIHRpbWUgZnJvbSB0aGUgZXBvY2ggb253YXJkcyBpcyBicm9rZW4gaW50byBoYWxmLW9wZW4gaW50ZXJ2YWxzIG9mIHNpemVcbiAgIFtDb25maWcuYWxhcm1fcHJlY2lzaW9uIGNvbmZpZ10uICBUaGUgaW50ZXJ2YWxzIGFyZSBudW1iZXJlZCBzdGFydGluZyBhdCB6ZXJvLCBhbmQgYVxuICAgdGltZSdzIGludGVydmFsIG51bWJlciBzZXJ2ZXMgYXMgaXRzIGtleSBpbiBbcHJpb3JpdHlfcXVldWVdLiAqKVxudHlwZSAnYSB0ID1cbiAgeyBjb25maWcgOiBDb25maWcudFxuICA7IHN0YXJ0IDogVGltZV9ucy50XG4gIDsgKCogW21heF9pbnRlcnZhbF9udW1dIGlzIHRoZSBpbnRlcnZhbCBudW1iZXIgb2YgW21heF90aW1lXS4gKilcbiAgICBtYXhfaW50ZXJ2YWxfbnVtIDogSW50ZXJ2YWxfbnVtLnRcbiAgOyBtdXRhYmxlIG5vdyA6IFRpbWVfbnMudFxuICA7IG11dGFibGUgbm93X2ludGVydmFsX251bV9zdGFydCA6IFRpbWVfbnMudFxuICA7IG11dGFibGUgbWF4X2FsbG93ZWRfYWxhcm1fdGltZSA6IFRpbWVfbnMudFxuICA7IHByaW9yaXR5X3F1ZXVlIDogJ2EgUHJpb3JpdHlfcXVldWUudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbnR5cGUgJ2EgdGltaW5nX3doZWVsID0gJ2EgdFxudHlwZSAnYSB0X25vdyA9ICdhIHRcblxubGV0IHNleHBfb2ZfdF9ub3cgXyB0ID0gWyVzZXhwICh0Lm5vdyA6IFRpbWVfbnMudCldXG5sZXQgYWxhcm1fcHJlY2lzaW9uIHQgPSBDb25maWcuYWxhcm1fcHJlY2lzaW9uIHQuY29uZmlnXG5cbm1vZHVsZSBBbGFybSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBQcmlvcml0eV9xdWV1ZS5FbHQudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBudWxsID0gUHJpb3JpdHlfcXVldWUuRWx0Lm51bGxcbiAgbGV0IGF0IHR3IHQgPSBQcmlvcml0eV9xdWV1ZS5FbHQuYXQgdHcucHJpb3JpdHlfcXVldWUgdFxuICBsZXQgdmFsdWUgdHcgdCA9IFByaW9yaXR5X3F1ZXVlLkVsdC52YWx1ZSB0dy5wcmlvcml0eV9xdWV1ZSB0XG4gIGxldCBpbnRlcnZhbF9udW0gdHcgdCA9IFByaW9yaXR5X3F1ZXVlLkVsdC5rZXkgdHcucHJpb3JpdHlfcXVldWUgdFxuZW5kXG5cbmxldCBzZXhwX29mX3RfaW50ZXJuYWwgPSBzZXhwX29mX3RcbmxldCBpdGVyIHQgfmYgPSBQcmlvcml0eV9xdWV1ZS5pdGVyIHQucHJpb3JpdHlfcXVldWUgfmZcblxubW9kdWxlIFByZXR0eSA9IHN0cnVjdFxuICBtb2R1bGUgQWxhcm0gPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyBhdCA6IFRpbWVfbnMudFxuICAgICAgOyB2YWx1ZSA6ICdhXG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG4gICAgbGV0IGNyZWF0ZSB0IGFsYXJtID0geyBhdCA9IEFsYXJtLmF0IHQgYWxhcm07IHZhbHVlID0gQWxhcm0udmFsdWUgdCBhbGFybSB9XG4gICAgbGV0IGNvbXBhcmUgdDEgdDIgPSBUaW1lX25zLmNvbXBhcmUgKGF0IHQxKSAoYXQgdDIpXG4gIGVuZFxuXG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBjb25maWcgOiBDb25maWcudFxuICAgIDsgc3RhcnQgOiBUaW1lX25zLnRcbiAgICA7IG1heF9pbnRlcnZhbF9udW0gOiBJbnRlcnZhbF9udW0udFxuICAgIDsgbm93IDogVGltZV9ucy50XG4gICAgOyBhbGFybXMgOiAnYSBBbGFybS50IGxpc3RcbiAgICB9XG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5lbmRcblxubGV0IHByZXR0eVxuICAgICAgKHsgY29uZmlnXG4gICAgICAgOyBzdGFydFxuICAgICAgIDsgbWF4X2ludGVydmFsX251bVxuICAgICAgIDsgbm93XG4gICAgICAgOyBub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0ID0gX1xuICAgICAgIDsgbWF4X2FsbG93ZWRfYWxhcm1fdGltZSA9IF9cbiAgICAgICA7IHByaW9yaXR5X3F1ZXVlID0gX1xuICAgICAgIH0gYXMgdClcbiAgPVxuICBsZXQgciA9IHJlZiBbXSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IHIgOj0gUHJldHR5LkFsYXJtLmNyZWF0ZSB0IGEgOjogIXIpO1xuICBsZXQgYWxhcm1zID0gTGlzdC5zb3J0ICFyIH5jb21wYXJlOlByZXR0eS5BbGFybS5jb21wYXJlIGluXG4gIHsgUHJldHR5LmNvbmZpZzsgc3RhcnQ7IG1heF9pbnRlcnZhbF9udW07IG5vdzsgYWxhcm1zIH1cbjs7XG5cbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPVxuICBtYXRjaCAhc2V4cF9vZl90X3N0eWxlIHdpdGhcbiAgfCBgSW50ZXJuYWwgLT4gc2V4cF9vZl90X2ludGVybmFsIHNleHBfb2ZfYSB0XG4gIHwgYFByZXR0eSAtPiBbJXNleHAgKHByZXR0eSB0IDogYSBQcmV0dHkudCldXG47O1xuXG5sZXQgbGVuZ3RoIHQgPSBQcmlvcml0eV9xdWV1ZS5sZW5ndGggdC5wcmlvcml0eV9xdWV1ZVxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxubGV0W0Bjb2xkXSByYWlzZV9uZXh0X2FsYXJtX2ZpcmVzX2F0X2V4bl9vZl9lbXB0eV90aW1pbmdfd2hlZWwgdCA9XG4gIHJhaXNlX3NcbiAgICBbJW1lc3NhZ2VcbiAgICAgIFwiVGltaW5nX3doZWVsLm5leHRfYWxhcm1fZmlyZXNfYXRfZXhuIG9mIGVtcHR5IHRpbWluZyB3aGVlbFwiIH50aW1pbmdfd2hlZWw6KHQgOiBfIHQpXVxuOztcblxubGV0W0Bjb2xkXSByYWlzZV9uZXh0X2FsYXJtX2ZpcmVzX2F0X3dpdGhfYWxsX2FsYXJtc19pbl9tYXhfaW50ZXJ2YWwgdCA9XG4gIHJhaXNlX3NcbiAgICBbJW1lc3NhZ2VcbiAgICAgIFwiVGltaW5nX3doZWVsLm5leHRfYWxhcm1fZmlyZXNfYXRfZXhuIHdpdGggYWxsIGFsYXJtcyBpbiBtYXggaW50ZXJ2YWxcIlxuICAgICAgICB+dGltaW5nX3doZWVsOih0IDogXyB0KV1cbjs7XG5cbmxldCBwb29sIHQgPSBQcmlvcml0eV9xdWV1ZS5wb29sIHQucHJpb3JpdHlfcXVldWVcblxubGV0IGludGVydmFsX251bV9pbnRlcm5hbCB+dGltZSB+YWxhcm1fcHJlY2lzaW9uID1cbiAgSW50ZXJ2YWxfbnVtLm9mX2ludDYzIChBbGFybV9wcmVjaXNpb24uaW50ZXJ2YWxfbnVtIGFsYXJtX3ByZWNpc2lvbiB0aW1lKVxuOztcblxubGV0IGludGVydmFsX251bV91bmNoZWNrZWQgdCB0aW1lID1cbiAgaW50ZXJ2YWxfbnVtX2ludGVybmFsIH50aW1lIH5hbGFybV9wcmVjaXNpb246dC5jb25maWcuYWxhcm1fcHJlY2lzaW9uXG47O1xuXG5sZXQgaW50ZXJ2YWxfbnVtIHQgdGltZSA9XG4gIGlmIFRpbWVfbnMuKCA8ICkgdGltZSBtaW5fdGltZVxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiVGltaW5nX3doZWVsLmludGVydmFsX251bSBnb3QgdGltZSB0b28gZmFyIGluIHRoZSBwYXN0XCIgKHRpbWUgOiBUaW1lX25zLnQpXTtcbiAgaW50ZXJ2YWxfbnVtX3VuY2hlY2tlZCB0IHRpbWVcbjs7XG5cbmxldCBpbnRlcnZhbF9udW1fc3RhcnRfdW5jaGVja2VkIHQgaW50ZXJ2YWxfbnVtID1cbiAgQWxhcm1fcHJlY2lzaW9uLmludGVydmFsX251bV9zdGFydFxuICAgIHQuY29uZmlnLmFsYXJtX3ByZWNpc2lvblxuICAgIChpbnRlcnZhbF9udW0gfD4gSW50ZXJ2YWxfbnVtLnRvX2ludDYzKVxuOztcblxubGV0W0Bjb2xkXSByYWlzZV9pbnRlcnZhbF9udW1fc3RhcnRfZ290X3Rvb19zbWFsbCBpbnRlcnZhbF9udW0gPVxuICByYWlzZV9zXG4gICAgWyVtZXNzYWdlXG4gICAgICBcIlRpbWluZ193aGVlbC5pbnRlcnZhbF9udW1fc3RhcnQgZ290IHRvbyBzbWFsbCBpbnRlcnZhbF9udW1cIlxuICAgICAgICAoaW50ZXJ2YWxfbnVtIDogSW50ZXJ2YWxfbnVtLnQpXG4gICAgICAgIChtaW5faW50ZXJ2YWxfbnVtIDogSW50ZXJ2YWxfbnVtLnQpXVxuOztcblxubGV0W0Bjb2xkXSByYWlzZV9pbnRlcnZhbF9udW1fc3RhcnRfZ290X3Rvb19sYXJnZSB0IGludGVydmFsX251bSA9XG4gIHJhaXNlX3NcbiAgICBbJW1lc3NhZ2VcbiAgICAgIFwiVGltaW5nX3doZWVsLmludGVydmFsX251bV9zdGFydCBnb3QgdG9vIGxhcmdlIGludGVydmFsX251bVwiXG4gICAgICAgIChpbnRlcnZhbF9udW0gOiBJbnRlcnZhbF9udW0udClcbiAgICAgICAgKHQubWF4X2ludGVydmFsX251bSA6IEludGVydmFsX251bS50KV1cbjs7XG5cbmxldCBpbnRlcnZhbF9udW1fc3RhcnQgdCBpbnRlcnZhbF9udW0gPVxuICBpZiBJbnRlcnZhbF9udW0uKCA8ICkgaW50ZXJ2YWxfbnVtIG1pbl9pbnRlcnZhbF9udW1cbiAgdGhlbiByYWlzZV9pbnRlcnZhbF9udW1fc3RhcnRfZ290X3Rvb19zbWFsbCBpbnRlcnZhbF9udW07XG4gIGlmIEludGVydmFsX251bS4oID4gKSBpbnRlcnZhbF9udW0gdC5tYXhfaW50ZXJ2YWxfbnVtXG4gIHRoZW4gcmFpc2VfaW50ZXJ2YWxfbnVtX3N0YXJ0X2dvdF90b29fbGFyZ2UgdCBpbnRlcnZhbF9udW07XG4gIGludGVydmFsX251bV9zdGFydF91bmNoZWNrZWQgdCBpbnRlcnZhbF9udW1cbjs7XG5cbmxldCBuZXh0X2FsYXJtX2ZpcmVzX2F0X2ludGVybmFsIHQga2V5ID1cbiAgKCogW2ludGVydmFsX251bV9zdGFydCB0IGtleV0gaXMgdGhlIGtleSBjb3JyZXNwb25kaW5nIHRvIHRoZSBzdGFydCBvZiB0aGUgdGltZSBpbnRlcnZhbFxuICAgICBob2xkaW5nIHRoZSBmaXJzdCBhbGFybSBpbiBbdF0uICBBZHZhbmNpbmcgdG8gdGhhdCB3b3VsZCBub3QgYmUgZW5vdWdoLCBzaW5jZSB0aGVcbiAgICAgYWxhcm1zIGluIHRoYXQgaW50ZXJ2YWwgZG9uJ3QgZmlyZSB1bnRpbCB0aGUgY2xvY2sgaXMgYWR2YW5jZWQgdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgICBuZXh0IGludGVydmFsLiAgU28sIHdlIHVzZSBbc3VjYyBrZXldIHRvIGFkdmFuY2UgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0XG4gICAgIGludGVydmFsLiAqKVxuICBpbnRlcnZhbF9udW1fc3RhcnQgdCAoS2V5LnN1Y2Mga2V5KVxuOztcblxubGV0IG5leHRfYWxhcm1fZmlyZXNfYXQgdCA9XG4gIGxldCBlbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IGtleSA9IEludGVybmFsX2VsdC5rZXkgKHBvb2wgdCkgZWx0IGluXG4gICAgaWYgSW50ZXJ2YWxfbnVtLmVxdWFsIGtleSB0Lm1heF9pbnRlcnZhbF9udW1cbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIFNvbWUgKG5leHRfYWxhcm1fZmlyZXNfYXRfaW50ZXJuYWwgdCBrZXkpKVxuOztcblxubGV0IG5leHRfYWxhcm1fZmlyZXNfYXRfZXhuIHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQgdGhlbiByYWlzZV9uZXh0X2FsYXJtX2ZpcmVzX2F0X2V4bl9vZl9lbXB0eV90aW1pbmdfd2hlZWwgdDtcbiAgbGV0IGtleSA9IEludGVybmFsX2VsdC5rZXkgKHBvb2wgdCkgZWx0IGluXG4gIGlmIEludGVydmFsX251bS5lcXVhbCBrZXkgdC5tYXhfaW50ZXJ2YWxfbnVtXG4gIHRoZW4gcmFpc2VfbmV4dF9hbGFybV9maXJlc19hdF93aXRoX2FsbF9hbGFybXNfaW5fbWF4X2ludGVydmFsIHQ7XG4gIG5leHRfYWxhcm1fZmlyZXNfYXRfaW50ZXJuYWwgdCBrZXlcbjs7XG5cbmxldCBjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUgdCA9XG4gIGxldCBtYXhfYWxsb3dlZF9rZXkgPSBQcmlvcml0eV9xdWV1ZS5tYXhfYWxsb3dlZF9rZXkgdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcnZhbF9udW0uKCA+PSApIG1heF9hbGxvd2VkX2tleSB0Lm1heF9pbnRlcnZhbF9udW1cbiAgdGhlbiBtYXhfdGltZVxuICBlbHNlXG4gICAgVGltZV9ucy5hZGRcbiAgICAgIChpbnRlcnZhbF9udW1fc3RhcnRfdW5jaGVja2VkIHQgbWF4X2FsbG93ZWRfa2V5KVxuICAgICAgKFRpbWVfbnMuU3Bhbi4oIC0gKSAoYWxhcm1fcHJlY2lzaW9uIHQpIFRpbWVfbnMuU3Bhbi5uYW5vc2Vjb25kKVxuOztcblxubGV0IG5vd19pbnRlcnZhbF9udW0gdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9hbGxvd2VkX2tleSB0LnByaW9yaXR5X3F1ZXVlXG5sZXQgbWluX2FsbG93ZWRfYWxhcm1faW50ZXJ2YWxfbnVtID0gbm93X2ludGVydmFsX251bVxubGV0IG1heF9hbGxvd2VkX2FsYXJtX2ludGVydmFsX251bSB0ID0gaW50ZXJ2YWxfbnVtIHQgKG1heF9hbGxvd2VkX2FsYXJtX3RpbWUgdClcbmxldCBpbnRlcnZhbF9zdGFydCB0IHRpbWUgPSBpbnRlcnZhbF9udW1fc3RhcnRfdW5jaGVja2VkIHQgKGludGVydmFsX251bSB0IHRpbWUpXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogXyB0XSAoZnVuICgpIC0+XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5jb25maWc6KGNoZWNrIENvbmZpZy5pbnZhcmlhbnQpXG4gICAgICB+c3RhcnQ6XG4gICAgICAgIChjaGVjayAoZnVuIHN0YXJ0IC0+XG4gICAgICAgICAgIGFzc2VydCAoVGltZV9ucy4oID49ICkgc3RhcnQgbWluX3RpbWUpO1xuICAgICAgICAgICBhc3NlcnQgKFRpbWVfbnMuKCA8PSApIHN0YXJ0IG1heF90aW1lKSkpXG4gICAgICB+bWF4X2ludGVydmFsX251bTpcbiAgICAgICAgKGNoZWNrIChmdW4gbWF4X2ludGVydmFsX251bSAtPlxuICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBJbnRlcnZhbF9udW0udF1cbiAgICAgICAgICAgICB+ZXhwZWN0Om1heF9pbnRlcnZhbF9udW1cbiAgICAgICAgICAgICAoaW50ZXJ2YWxfbnVtIHQgbWF4X3RpbWUpO1xuICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBJbnRlcnZhbF9udW0udF1cbiAgICAgICAgICAgICB+ZXhwZWN0Om1heF9pbnRlcnZhbF9udW1cbiAgICAgICAgICAgICAoaW50ZXJ2YWxfbnVtIHQgKGludGVydmFsX251bV9zdGFydCB0IG1heF9pbnRlcnZhbF9udW0pKSkpXG4gICAgICB+bm93OlxuICAgICAgICAoY2hlY2sgKGZ1biBub3cgLT5cbiAgICAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPj0gKSBub3cgdC5zdGFydCk7XG4gICAgICAgICAgIGFzc2VydCAoVGltZV9ucy4oIDw9ICkgbm93IG1heF90aW1lKTtcbiAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICBJbnRlcnZhbF9udW0uZXF1YWxcbiAgICAgICAgICAgICAgIChpbnRlcnZhbF9udW0gdCB0Lm5vdylcbiAgICAgICAgICAgICAgIChQcmlvcml0eV9xdWV1ZS5taW5fYWxsb3dlZF9rZXkgdC5wcmlvcml0eV9xdWV1ZSkpKSlcbiAgICAgIH5ub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0OlxuICAgICAgICAoY2hlY2sgKGZ1biBub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0IC0+XG4gICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IFRpbWVfbnMudF1cbiAgICAgICAgICAgICBub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0XG4gICAgICAgICAgICAgfmV4cGVjdDooaW50ZXJ2YWxfbnVtX3N0YXJ0IHQgKG5vd19pbnRlcnZhbF9udW0gdCkpKSlcbiAgICAgIH5tYXhfYWxsb3dlZF9hbGFybV90aW1lOlxuICAgICAgICAoY2hlY2sgKGZ1biBtYXhfYWxsb3dlZF9hbGFybV90aW1lIC0+XG4gICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IFRpbWVfbnMudF1cbiAgICAgICAgICAgICBtYXhfYWxsb3dlZF9hbGFybV90aW1lXG4gICAgICAgICAgICAgfmV4cGVjdDooY29tcHV0ZV9tYXhfYWxsb3dlZF9hbGFybV90aW1lIHQpKSlcbiAgICAgIH5wcmlvcml0eV9xdWV1ZTooY2hlY2sgKFByaW9yaXR5X3F1ZXVlLmludmFyaWFudCBpbnZhcmlhbnRfYSkpO1xuICAgIGl0ZXIgdCB+ZjooZnVuIGFsYXJtIC0+XG4gICAgICBhc3NlcnQgKFxuICAgICAgICBJbnRlcnZhbF9udW0uZXF1YWxcbiAgICAgICAgICAoQWxhcm0uaW50ZXJ2YWxfbnVtIHQgYWxhcm0pXG4gICAgICAgICAgKGludGVydmFsX251bSB0IChBbGFybS5hdCB0IGFsYXJtKSkpO1xuICAgICAgYXNzZXJ0IChcbiAgICAgICAgVGltZV9ucy4oID49IClcbiAgICAgICAgICAoaW50ZXJ2YWxfc3RhcnQgdCAoQWxhcm0uYXQgdCBhbGFybSkpXG4gICAgICAgICAgKGludGVydmFsX3N0YXJ0IHQgKG5vdyB0KSkpO1xuICAgICAgYXNzZXJ0IChcbiAgICAgICAgVGltZV9ucy4oID4gKSAoQWxhcm0uYXQgdCBhbGFybSkgKFRpbWVfbnMuc3ViIChub3cgdCkgKGFsYXJtX3ByZWNpc2lvbiB0KSkpKSlcbjs7XG5cbmxldCBkZWJ1ZyA9IGZhbHNlXG5cbmxldCBhZHZhbmNlX2Nsb2NrIHQgfnRvXyB+aGFuZGxlX2ZpcmVkID1cbiAgaWYgVGltZV9ucy4oID4gKSB0b18gKG5vdyB0KVxuICB0aGVuIChcbiAgICB0Lm5vdyA8LSB0b187XG4gICAgbGV0IGtleSA9IGludGVydmFsX251bV91bmNoZWNrZWQgdCB0b18gaW5cbiAgICB0Lm5vd19pbnRlcnZhbF9udW1fc3RhcnQgPC0gaW50ZXJ2YWxfbnVtX3N0YXJ0X3VuY2hlY2tlZCB0IGtleTtcbiAgICBtYXRjaFxuICAgICAgUHJpb3JpdHlfcXVldWUuaW5jcmVhc2VfbWluX2FsbG93ZWRfa2V5XG4gICAgICAgIHQucHJpb3JpdHlfcXVldWVcbiAgICAgICAgfmtleVxuICAgICAgICB+aGFuZGxlX3JlbW92ZWQ6aGFuZGxlX2ZpcmVkXG4gICAgd2l0aFxuICAgIHwgTWF4X2FsbG93ZWRfa2V5X2RpZF9ub3RfY2hhbmdlIC0+XG4gICAgICBpZiBkZWJ1Z1xuICAgICAgdGhlblxuICAgICAgICBhc3NlcnQgKFRpbWVfbnMuKCA9ICkgdC5tYXhfYWxsb3dlZF9hbGFybV90aW1lIChjb21wdXRlX21heF9hbGxvd2VkX2FsYXJtX3RpbWUgdCkpXG4gICAgfCBNYXhfYWxsb3dlZF9rZXlfbWF5YmVfY2hhbmdlZCAtPlxuICAgICAgdC5tYXhfYWxsb3dlZF9hbGFybV90aW1lIDwtIGNvbXB1dGVfbWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0KVxuOztcblxubGV0IGNyZWF0ZSB+Y29uZmlnIH5zdGFydCA9XG4gIGlmIFRpbWVfbnMuKCA8ICkgc3RhcnQgVGltZV9ucy5lcG9jaFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlIFwiVGltaW5nX3doZWVsLmNyZWF0ZSBnb3Qgc3RhcnQgYmVmb3JlIHRoZSBlcG9jaFwiIChzdGFydCA6IFRpbWVfbnMudCldO1xuICBsZXQgdCA9XG4gICAgeyBjb25maWdcbiAgICA7IHN0YXJ0XG4gICAgOyBtYXhfaW50ZXJ2YWxfbnVtID1cbiAgICAgICAgaW50ZXJ2YWxfbnVtX2ludGVybmFsIH50aW1lOm1heF90aW1lIH5hbGFybV9wcmVjaXNpb246Y29uZmlnLmFsYXJtX3ByZWNpc2lvblxuICAgIDsgbm93ID0gVGltZV9ucy5taW5fdmFsdWVfZm9yXzF1c19yb3VuZGluZyAoKiBzZXQgYnkgW2FkdmFuY2VfY2xvY2tdIGJlbG93ICopXG4gICAgOyBub3dfaW50ZXJ2YWxfbnVtX3N0YXJ0ID1cbiAgICAgICAgVGltZV9ucy5taW5fdmFsdWVfZm9yXzF1c19yb3VuZGluZyAoKiBzZXQgYnkgW2FkdmFuY2VfY2xvY2tdIGJlbG93ICopXG4gICAgOyBtYXhfYWxsb3dlZF9hbGFybV90aW1lID0gbWF4X3RpbWUgKCogc2V0IGJ5IFthZHZhbmNlX2Nsb2NrXSBiZWxvdyAqKVxuICAgIDsgcHJpb3JpdHlfcXVldWUgPVxuICAgICAgICBQcmlvcml0eV9xdWV1ZS5jcmVhdGUgP2NhcGFjaXR5OmNvbmZpZy5jYXBhY2l0eSB+bGV2ZWxfYml0czpjb25maWcubGV2ZWxfYml0cyAoKVxuICAgIH1cbiAgaW5cbiAgdC5tYXhfYWxsb3dlZF9hbGFybV90aW1lIDwtIGNvbXB1dGVfbWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0O1xuICBhZHZhbmNlX2Nsb2NrIHQgfnRvXzpzdGFydCB+aGFuZGxlX2ZpcmVkOihmdW4gXyAtPiBhc3NlcnQgZmFsc2UpO1xuICB0XG47O1xuXG5sZXQgYWRkX2F0X2ludGVydmFsX251bSB0IH5hdCB2YWx1ZSA9XG4gIEludGVybmFsX2VsdC50b19leHRlcm5hbFxuICAgIChQcmlvcml0eV9xdWV1ZS5pbnRlcm5hbF9hZGRcbiAgICAgICB0LnByaW9yaXR5X3F1ZXVlXG4gICAgICAgfmtleTphdFxuICAgICAgIH5hdDooaW50ZXJ2YWxfbnVtX3N0YXJ0IHQgYXQpXG4gICAgICAgdmFsdWUpXG47O1xuXG5sZXRbQGNvbGRdIHJhaXNlX3RoYXRfZmFyX2luX3RoZV9mdXR1cmUgdCBhdCA9XG4gIHJhaXNlX3NcbiAgICBbJW1lc3NhZ2VcbiAgICAgIFwiVGltaW5nX3doZWVsIGNhbm5vdCBzY2hlZHVsZSBhbGFybSB0aGF0IGZhciBpbiB0aGUgZnV0dXJlXCJcbiAgICAgICAgKGF0IDogVGltZV9ucy50KVxuICAgICAgICB+bWF4X2FsbG93ZWRfYWxhcm1fdGltZToodC5tYXhfYWxsb3dlZF9hbGFybV90aW1lIDogVGltZV9ucy50KV1cbjs7XG5cbmxldFtAY29sZF0gcmFpc2VfYmVmb3JlX3N0YXJ0X29mX2N1cnJlbnRfaW50ZXJ2YWwgdCBhdCA9XG4gIHJhaXNlX3NcbiAgICBbJW1lc3NhZ2VcbiAgICAgIFwiVGltaW5nX3doZWVsIGNhbm5vdCBzY2hlZHVsZSBhbGFybSBiZWZvcmUgc3RhcnQgb2YgY3VycmVudCBpbnRlcnZhbFwiXG4gICAgICAgIChhdCA6IFRpbWVfbnMudClcbiAgICAgICAgfm5vd19pbnRlcnZhbF9udW1fc3RhcnQ6KHQubm93X2ludGVydmFsX251bV9zdGFydCA6IFRpbWVfbnMudCldXG47O1xuXG5sZXQgZW5zdXJlX2Nhbl9zY2hlZHVsZV9hbGFybSB0IH5hdCA9XG4gIGlmIFRpbWVfbnMuKCA+ICkgYXQgdC5tYXhfYWxsb3dlZF9hbGFybV90aW1lIHRoZW4gcmFpc2VfdGhhdF9mYXJfaW5fdGhlX2Z1dHVyZSB0IGF0O1xuICBpZiBUaW1lX25zLiggPCApIGF0IHQubm93X2ludGVydmFsX251bV9zdGFydFxuICB0aGVuIHJhaXNlX2JlZm9yZV9zdGFydF9vZl9jdXJyZW50X2ludGVydmFsIHQgYXRcbjs7XG5cbmxldCBhZGQgdCB+YXQgdmFsdWUgPVxuICBlbnN1cmVfY2FuX3NjaGVkdWxlX2FsYXJtIHQgfmF0O1xuICBJbnRlcm5hbF9lbHQudG9fZXh0ZXJuYWxcbiAgICAoUHJpb3JpdHlfcXVldWUuaW50ZXJuYWxfYWRkXG4gICAgICAgdC5wcmlvcml0eV9xdWV1ZVxuICAgICAgIH5rZXk6KGludGVydmFsX251bV91bmNoZWNrZWQgdCBhdClcbiAgICAgICB+YXRcbiAgICAgICB2YWx1ZSlcbjs7XG5cbmxldCByZW1vdmUgdCBhbGFybSA9IFByaW9yaXR5X3F1ZXVlLnJlbW92ZSB0LnByaW9yaXR5X3F1ZXVlIGFsYXJtXG5sZXQgY2xlYXIgdCA9IFByaW9yaXR5X3F1ZXVlLmNsZWFyIHQucHJpb3JpdHlfcXVldWVcbmxldCBtZW0gdCBhbGFybSA9IFByaW9yaXR5X3F1ZXVlLm1lbSB0LnByaW9yaXR5X3F1ZXVlIGFsYXJtXG5cbmxldCByZXNjaGVkdWxlX2dlbiB0IGFsYXJtIH5rZXkgfmF0ID1cbiAgaWYgbm90IChtZW0gdCBhbGFybSlcbiAgdGhlbiBmYWlsd2l0aCBcIlRpbWluZ193aGVlbCBjYW5ub3QgcmVzY2hlZHVsZSBhbGFybSBub3QgaW4gdGltaW5nIHdoZWVsXCI7XG4gIGVuc3VyZV9jYW5fc2NoZWR1bGVfYWxhcm0gdCB+YXQ7XG4gIFByaW9yaXR5X3F1ZXVlLmNoYW5nZSB0LnByaW9yaXR5X3F1ZXVlIGFsYXJtIH5rZXkgfmF0XG47O1xuXG5sZXQgcmVzY2hlZHVsZSB0IGFsYXJtIH5hdCA9IHJlc2NoZWR1bGVfZ2VuIHQgYWxhcm0gfmtleTooaW50ZXJ2YWxfbnVtX3VuY2hlY2tlZCB0IGF0KSB+YXRcblxubGV0IHJlc2NoZWR1bGVfYXRfaW50ZXJ2YWxfbnVtIHQgYWxhcm0gfmF0ID1cbiAgcmVzY2hlZHVsZV9nZW4gdCBhbGFybSB+a2V5OmF0IH5hdDooaW50ZXJ2YWxfbnVtX3N0YXJ0IHQgYXQpXG47O1xuXG5sZXQgbWluX2FsYXJtX2ludGVydmFsX251bSB0ID1cbiAgbGV0IGVsdCA9IFByaW9yaXR5X3F1ZXVlLm1pbl9lbHRfIHQucHJpb3JpdHlfcXVldWUgaW5cbiAgaWYgSW50ZXJuYWxfZWx0LmlzX251bGwgZWx0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKEludGVybmFsX2VsdC5rZXkgKHBvb2wgdCkgZWx0KVxuOztcblxubGV0IG1pbl9hbGFybV9pbnRlcnZhbF9udW1fZXhuIHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHRcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIlRpbWluZ193aGVlbC5taW5fYWxhcm1faW50ZXJ2YWxfbnVtX2V4biBvZiBlbXB0eSB0aW1pbmdfd2hlZWxcIlxuICAgICAgICAgIH50aW1pbmdfd2hlZWw6KHQgOiBfIHQpXVxuICBlbHNlIEludGVybmFsX2VsdC5rZXkgKHBvb2wgdCkgZWx0XG47O1xuXG5sZXQgbWF4X2FsYXJtX3RpbWVfaW5fbGlzdCB0IGVsdCA9XG4gIGxldCBwb29sID0gcG9vbCB0IGluXG4gIEludGVybmFsX2VsdC5tYXhfYWxhcm1fdGltZSBwb29sIGVsdCB+d2l0aF9rZXk6KEludGVybmFsX2VsdC5rZXkgcG9vbCBlbHQpXG47O1xuXG5sZXQgbWluX2FsYXJtX3RpbWVfaW5fbGlzdCB0IGVsdCA9XG4gIGxldCBwb29sID0gcG9vbCB0IGluXG4gIEludGVybmFsX2VsdC5taW5fYWxhcm1fdGltZSBwb29sIGVsdCB+d2l0aF9rZXk6KEludGVybmFsX2VsdC5rZXkgcG9vbCBlbHQpXG47O1xuXG5sZXQgbWF4X2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsIHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHQgdGhlbiBOb25lIGVsc2UgU29tZSAobWF4X2FsYXJtX3RpbWVfaW5fbGlzdCB0IGVsdClcbjs7XG5cbmxldCBtaW5fYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwgdCA9XG4gIGxldCBlbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdCB0aGVuIE5vbmUgZWxzZSBTb21lIChtaW5fYWxhcm1fdGltZV9pbl9saXN0IHQgZWx0KVxuOztcblxubGV0IG1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF9leG4gdCA9XG4gIGxldCBlbHQgPSBQcmlvcml0eV9xdWV1ZS5taW5fZWx0XyB0LnByaW9yaXR5X3F1ZXVlIGluXG4gIGlmIEludGVybmFsX2VsdC5pc19udWxsIGVsdFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiVGltaW5nX3doZWVsLm1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF9leG4gb2YgZW1wdHkgdGltaW5nIHdoZWVsXCJcbiAgICAgICAgICB+dGltaW5nX3doZWVsOih0IDogXyB0KV07XG4gIG1heF9hbGFybV90aW1lX2luX2xpc3QgdCBlbHRcbjs7XG5cbmxldCBtaW5fYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxfZXhuIHQgPVxuICBsZXQgZWx0ID0gUHJpb3JpdHlfcXVldWUubWluX2VsdF8gdC5wcmlvcml0eV9xdWV1ZSBpblxuICBpZiBJbnRlcm5hbF9lbHQuaXNfbnVsbCBlbHRcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslbWVzc2FnZVxuICAgICAgICBcIlRpbWluZ193aGVlbC5tYXhfYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxfZXhuIG9mIGVtcHR5IHRpbWluZyB3aGVlbFwiXG4gICAgICAgICAgfnRpbWluZ193aGVlbDoodCA6IF8gdCldO1xuICBtaW5fYWxhcm1fdGltZV9pbl9saXN0IHQgZWx0XG47O1xuXG5sZXQgZmlyZV9wYXN0X2FsYXJtcyB0IH5oYW5kbGVfZmlyZWQgPVxuICBQcmlvcml0eV9xdWV1ZS5maXJlX3Bhc3RfYWxhcm1zXG4gICAgdC5wcmlvcml0eV9xdWV1ZVxuICAgIH5oYW5kbGVfZmlyZWRcbiAgICB+a2V5Oihub3dfaW50ZXJ2YWxfbnVtIHQpXG4gICAgfm5vdzp0Lm5vd1xuOztcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIE51bV9rZXlfYml0cyA9IE51bV9rZXlfYml0c1xuXG4gIGxldCBpbnRlcnZhbF9udW1faW50ZXJuYWwgPSBpbnRlcnZhbF9udW1faW50ZXJuYWxcbiAgbGV0IG1heF90aW1lID0gbWF4X3RpbWVcbmVuZFxuIl19
