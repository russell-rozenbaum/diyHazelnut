// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1+5.8.1

//# unitInfo: Provides: Angstrom__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Angstrom = [0];
   runtime.caml_register_global(0, Angstrom, "Angstrom__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__More
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Angstrom_More = [0];
   runtime.caml_register_global(0, Angstrom_More, "Angstrom__More");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Exported_state
//# unitInfo: Requires: Stdlib, Stdlib__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = ": ",
    cst$0 = " > ",
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    _a_ = [1, "incomplete input"];
   function state_to_option(x){
    switch(x[0]){
      case 0:
       return 0;
      case 1:
       var v = x[2]; return [0, v];
      default: return 0;
    }
   }
   function fail_to_string(marks, err){
    var
     _b_ = caml_call2(Stdlib[28], cst, err),
     _c_ = caml_call2(Stdlib_String[6], cst$0, marks);
    return caml_call2(Stdlib[28], _c_, _b_);
   }
   function state_to_result(x){
    switch(x[0]){
      case 0:
       return _a_;
      case 1:
       var v = x[2]; return [0, v];
      default:
       var err = x[3], marks = x[2]; return [1, fail_to_string(marks, err)];
    }
   }
   var
    Angstrom_Exported_state =
      [0, state_to_option, fail_to_string, state_to_result];
   runtime.caml_register_global
    (5, Angstrom_Exported_state, "Angstrom__Exported_state");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Input
//# unitInfo: Requires: Assert_failure, Bigstringaf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_input_ml = "lib/input.ml",
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Bigstringaf = global_data.Bigstringaf,
    Assert_failure = global_data.Assert_failure,
    _a_ = [0, cst_lib_input_ml, 60, 2],
    _b_ = [0, cst_lib_input_ml, 59, 2];
   function create(buffer, off, len, committed_bytes){
    return [0, committed_bytes, committed_bytes, off, len, buffer];
   }
   function length(t){return t[2] + t[4] | 0;}
   function client_committed_bytes(t){return t[2];}
   function parser_committed_bytes(t){return t[1];}
   function bytes_for_client_to_commit(t){return t[1] - t[2] | 0;}
   function parser_uncommitted_bytes(t){
    var _f_ = bytes_for_client_to_commit(t);
    return t[4] - _f_ | 0;
   }
   function invariant(t){
    var _c_ = length(t), _d_ = parser_uncommitted_bytes(t);
    if((t[1] + _d_ | 0) !== _c_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var _e_ = bytes_for_client_to_commit(t);
    if((t[1] - t[2] | 0) === _e_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function offset_in_buffer(t, pos){return (t[3] + pos | 0) - t[2] | 0;}
   function apply(t, pos, len, f){
    var off = offset_in_buffer(t, pos);
    return caml_call3(f, t[5], off, len);
   }
   function unsafe_get_char(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_ba_get_1(t[5], off);
   }
   function unsafe_get_int16_le(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[30], t[5], off);
   }
   function unsafe_get_int32_le(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[36], t[5], off);
   }
   function unsafe_get_int64_le(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[40], t[5], off);
   }
   function unsafe_get_int16_be(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[31], t[5], off);
   }
   function unsafe_get_int32_be(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[37], t[5], off);
   }
   function unsafe_get_int64_be(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[41], t[5], off);
   }
   function count_while(t, pos, f){
    var
     buffer = t[5],
     off = offset_in_buffer(t, pos),
     i = [0, off],
     limit = t[3] + t[4] | 0;
    for(;;){
     if(i[1] < limit && caml_call1(f, caml_ba_get_1(buffer, i[1]))){i[1]++; continue;}
     return i[1] - off | 0;
    }
   }
   function commit(t, pos){t[1] = pos; return 0;}
   var
    Angstrom_Input =
      [0,
       create,
       length,
       client_committed_bytes,
       parser_committed_bytes,
       parser_uncommitted_bytes,
       bytes_for_client_to_commit,
       unsafe_get_char,
       unsafe_get_int16_le,
       unsafe_get_int32_le,
       unsafe_get_int64_le,
       unsafe_get_int16_be,
       unsafe_get_int32_be,
       unsafe_get_int64_be,
       count_while,
       apply,
       commit,
       invariant];
   runtime.caml_register_global(4, Angstrom_Input, "Angstrom__Input");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Parser
//# unitInfo: Requires: Angstrom__Exported_state, Angstrom__Input, Bigstringaf, CamlinternalLazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Angstrom_Input = global_data.Angstrom__Input,
    Bigstringaf = global_data.Bigstringaf,
    Angstrom_Exported_state = global_data.Angstrom__Exported_state,
    State = [0];
   function fail_k(input, pos, param, marks, msg){
    return [3, pos - caml_call1(Angstrom_Input[3], input) | 0, marks, msg];
   }
   function succeed_k(input, pos, param, v){
    return [2, pos - caml_call1(Angstrom_Input[3], input) | 0, v];
   }
   function to_exported_state(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var match = param$0[1], continue$0 = match[2], committed = match[1];
        return [0,
                [0,
                 committed,
                 function(bs, off, len, more){
                  return to_exported_state
                          (caml_call4(continue$0, bs, off, len, more));
                 }]];
       case 1:
        var
         x = param$0[1],
         _c_ = runtime.caml_obj_tag(x),
         param$1 =
           250 === _c_
            ? x[1]
            : 246 === _c_ ? caml_call1(CamlinternalLazy[2], x) : x;
        param$0 = param$1;
        break;
       case 2:
        var x$0 = param$0[2], i = param$0[1]; return [1, i, x$0];
       default:
        var s = param$0[3], sl = param$0[2], i$0 = param$0[1];
        return [2, i$0, sl, s];
     }
   }
   function parse(p){
    var input = caml_call4(Angstrom_Input[1], Bigstringaf[2], 0, 0, 0);
    return to_exported_state(caml_call5(p[1], input, 0, 1, fail_k, succeed_k));
   }
   function parse_bigstring(p, input){
    var
     _a_ = caml_call1(Bigstringaf[6], input),
     input$0 = caml_call4(Angstrom_Input[1], input, 0, _a_, 0),
     _b_ =
       to_exported_state(caml_call5(p[1], input$0, 0, 0, fail_k, succeed_k));
    return caml_call1(Angstrom_Exported_state[3], _b_);
   }
   function return$0(v){
    return [0,
            function(input, pos, more, fail, succ){
             return caml_call4(succ, input, pos, more, v);
            }];
   }
   function fail(msg){
    return [0,
            function(input, pos, more, fail, succ){
             return caml_call5(fail, input, pos, more, 0, msg);
            }];
   }
   function symbol_bind(p, f){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, pos, more, v){
              return caml_call5
                      (caml_call1(f, v)[1], input, pos, more, fail, succ);
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   function symbol_map(p, f){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, pos, more, v){
              return caml_call4(succ, input, pos, more, caml_call1(f, v));
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   function symbol(f, m){return symbol_map(m, f);}
   function symbol$0(f, m){
    return [0,
            function(input, pos, more, fail, succ){
             function succ0(input0, pos0, more0, f){
              function succ1(input1, pos1, more1, m){
               return caml_call4(succ, input1, pos1, more1, caml_call1(f, m));
              }
              return caml_call5(m[1], input0, pos0, more0, fail, succ1);
             }
             return caml_call5(f[1], input, pos, more, fail, succ0);
            }];
   }
   function lift(f, m){return symbol_map(m, f);}
   function lift2(f, m1, m2){
    return [0,
            function(input, pos, more, fail, succ){
             function succ1(input1, pos1, more1, m1){
              function succ2(input2, pos2, more2, m2){
               return caml_call4
                       (succ, input2, pos2, more2, caml_call2(f, m1, m2));
              }
              return caml_call5(m2[1], input1, pos1, more1, fail, succ2);
             }
             return caml_call5(m1[1], input, pos, more, fail, succ1);
            }];
   }
   function lift3(f, m1, m2, m3){
    return [0,
            function(input, pos, more, fail, succ){
             function succ1(input1, pos1, more1, m1){
              function succ2(input2, pos2, more2, m2){
               function succ3(input3, pos3, more3, m3){
                return caml_call4
                        (succ, input3, pos3, more3, caml_call3(f, m1, m2, m3));
               }
               return caml_call5(m3[1], input2, pos2, more2, fail, succ3);
              }
              return caml_call5(m2[1], input1, pos1, more1, fail, succ2);
             }
             return caml_call5(m1[1], input, pos, more, fail, succ1);
            }];
   }
   function lift4(f, m1, m2, m3, m4){
    return [0,
            function(input, pos, more, fail, succ){
             function succ1(input1, pos1, more1, m1){
              function succ2(input2, pos2, more2, m2){
               function succ3(input3, pos3, more3, m3){
                function succ4(input4, pos4, more4, m4){
                 return caml_call4
                         (succ, input4, pos4, more4, caml_call4(f, m1, m2, m3, m4));
                }
                return caml_call5(m4[1], input3, pos3, more3, fail, succ4);
               }
               return caml_call5(m3[1], input2, pos2, more2, fail, succ3);
              }
              return caml_call5(m2[1], input1, pos1, more1, fail, succ2);
             }
             return caml_call5(m1[1], input, pos, more, fail, succ1);
            }];
   }
   function symbol$1(a, b){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, pos, more, param){
              return caml_call5(b[1], input, pos, more, fail, succ);
             }
             return caml_call5(a[1], input, pos, more, fail, succ$0);
            }];
   }
   function symbol$2(a, b){
    return [0,
            function(input, pos, more, fail, succ){
             function succ0(input0, pos0, more0, x){
              function succ1(input1, pos1, more1, param){
               return caml_call4(succ, input1, pos1, more1, x);
              }
              return caml_call5(b[1], input0, pos0, more0, fail, succ1);
             }
             return caml_call5(a[1], input, pos, more, fail, succ0);
            }];
   }
   var
    Monad =
      [0,
       return$0,
       fail,
       symbol_bind,
       symbol_map,
       symbol,
       symbol$0,
       lift,
       lift2,
       lift3,
       lift4,
       symbol$1,
       symbol$2];
   function symbol$3(p, mark){
    return [0,
            function(input, pos, more, fail, succ){
             function fail$0(input, pos, more, marks, msg){
              return caml_call5(fail, input, pos, more, [0, mark, marks], msg);
             }
             return caml_call5(p[1], input, pos, more, fail$0, succ);
            }];
   }
   function symbol$4(p, q){
    return [0,
            function(input, pos, more, fail, succ){
             function fail$0(input, pos$0, more$0, marks, msg){
              return pos < caml_call1(Angstrom_Input[4], input)
                      ? caml_call5(fail, input, pos$0, more, marks, msg)
                      : caml_call5(q[1], input, pos, more$0, fail, succ);
             }
             return caml_call5(p[1], input, pos, more, fail$0, succ);
            }];
   }
   var
    Choice = [0, symbol$3, symbol$4],
    return$1 = Monad[1],
    fail$0 = Monad[2],
    symbol_bind$0 = Monad[3];
   function symbol_map$0(m, f){
    return caml_call2
            (symbol_bind$0,
             m,
             function(x){return caml_call1(return$1, caml_call1(f, x));});
   }
   function symbol$5(f, m){return symbol_map$0(m, f);}
   function symbol$6(f, m){
    return caml_call2
            (symbol_bind$0, f, function(f){return symbol_map$0(m, f);});
   }
   function lift2$0(f, m1, m2){return symbol$6(symbol_map$0(m1, f), m2);}
   function lift3$0(f, m1, m2, m3){
    return symbol$6(symbol$6(symbol_map$0(m1, f), m2), m3);
   }
   function lift4$0(f, m1, m2, m3, m4){
    return symbol$6(symbol$6(symbol$6(symbol_map$0(m1, f), m2), m3), m4);
   }
   function symbol$7(a, b){
    return caml_call2(symbol_bind$0, a, function(param){return b;});
   }
   function symbol$8(a, b){
    return caml_call2
            (symbol_bind$0,
             a,
             function(x){return symbol_map$0(b, function(param){return x;});});
   }
   var
    Monad_use_for_debugging =
      [0,
       return$1,
       fail$0,
       symbol_bind$0,
       symbol_map$0,
       symbol$5,
       symbol$6,
       symbol_map$0,
       lift2$0,
       lift3$0,
       lift4$0,
       symbol$7,
       symbol$8],
    Angstrom_Parser =
      [0,
       State,
       fail_k,
       succeed_k,
       to_exported_state,
       parse,
       parse_bigstring,
       Monad,
       Choice,
       Monad_use_for_debugging];
   runtime.caml_register_global(4, Angstrom_Parser, "Angstrom__Parser");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Buffering
//# unitInfo: Requires: Assert_failure, Bigstringaf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_buffering_ml = "lib/buffering.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Bigstringaf = global_data.Bigstringaf,
    _a_ = [0, cst_lib_buffering_ml, 8, 2],
    _b_ = [0, cst_lib_buffering_ml, 7, 2],
    _c_ = [0, cst_lib_buffering_ml, 47, 2],
    _d_ = [0, cst_lib_buffering_ml, 46, 2],
    _e_ = [0, cst_lib_buffering_ml, 54, 2],
    _f_ = [0, cst_lib_buffering_ml, 53, 2],
    _g_ = [0, cst_lib_buffering_ml, 64, 2],
    _h_ = [0, cst_lib_buffering_ml, 79, 2];
   function of_bigstring(off, len, buf){
    if(0 > off)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if((len - off | 0) <= caml_call1(Bigstringaf[6], buf))
     return [0, buf, off, len];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function create(len){
    return of_bigstring(0, 0, caml_call1(Bigstringaf[1], len));
   }
   function writable_space(t){
    var _m_ = t[3];
    return caml_call1(Bigstringaf[6], t[1]) - _m_ | 0;
   }
   function ensure(t, to_copy){
    var
     _k_ = t[2] + t[3] | 0,
     _l_ = (caml_call1(Bigstringaf[6], t[1]) - _k_ | 0) < to_copy ? 1 : 0;
    if(! _l_) return _l_;
    if(to_copy <= writable_space(t)){
     caml_call5(Bigstringaf[44], t[1], t[2], t[1], 0, t[3]);
     t[2] = 0;
     return;
    }
    var
     old_len = caml_call1(Bigstringaf[6], t[1]),
     new_len = [0, old_len],
     space = writable_space(t);
    for(;;){
     if(((space + new_len[1] | 0) - old_len | 0) >= to_copy){
      var new_buf = caml_call1(Bigstringaf[1], new_len[1]);
      caml_call5(Bigstringaf[44], t[1], t[2], new_buf, 0, t[3]);
      t[1] = new_buf;
      t[2] = 0;
      return;
     }
     new_len[1] = (3 * new_len[1] | 0) / 2 | 0;
    }
   }
   function write_pos(t){return t[2] + t[3] | 0;}
   function feed_string(t, off, len, str){
    if(0 > off)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    if((len - off | 0) > caml_ml_string_length(str))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    ensure(t, len);
    var _j_ = write_pos(t);
    caml_call5(Bigstringaf[45], str, off, t[1], _j_, len);
    t[3] = t[3] + len | 0;
    return 0;
   }
   function feed_bigstring(t, off, len, b){
    if(0 > off)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    if((len - off | 0) > caml_call1(Bigstringaf[6], b))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
    ensure(t, len);
    var _i_ = write_pos(t);
    caml_call5(Bigstringaf[44], b, off, t[1], _i_, len);
    t[3] = t[3] + len | 0;
    return 0;
   }
   function feed_input(t, param){
    if(608227697 <= param[1]){
     var b = param[2];
     return feed_bigstring(t, 0, caml_call1(Bigstringaf[6], b), b);
    }
    var s = param[2];
    return feed_string(t, 0, caml_ml_string_length(s), s);
   }
   function shift(t, n){
    if(n > t[3])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    t[2] = t[2] + n | 0;
    t[3] = t[3] - n | 0;
    return 0;
   }
   function for_reading(param){
    var buf = param[1], off = param[2], len = param[3];
    return caml_call3(Bigstringaf[5], buf, off, len);
   }
   function unconsumed(opt, param){
    if(opt) var sth = opt[1], shift = sth; else var shift = 0;
    var buf = param[1], off = param[2], len = param[3];
    if(shift <= len) return [0, buf, off + shift | 0, len - shift | 0];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   }
   function of_unconsumed(param){
    var len = param[3], off = param[2], buf = param[1];
    return [0, buf, off, len];
   }
   var
    Angstrom_Buffering =
      [0,
       create,
       of_bigstring,
       feed_string,
       feed_bigstring,
       feed_input,
       shift,
       for_reading,
       unconsumed,
       of_unconsumed];
   runtime.caml_register_global(10, Angstrom_Buffering, "Angstrom__Buffering");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom
//# unitInfo: Requires: Angstrom__Buffering, Angstrom__Exported_state, Angstrom__Input, Angstrom__Parser, Bigstringaf, CamlinternalLazy, Stdlib, Stdlib__Char, Stdlib__Int32, Stdlib__Int64, Stdlib__List, Stdlib__Printf, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_count_while1$1 = "count_while1",
    cst_not_enough_input$1 = "not enough input",
    cst_satisfy = "satisfy: ",
    cst_satisfy_C = "satisfy: %C",
    caml_int32_float_of_bits = runtime.caml_int32_float_of_bits,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\r\n",
    Stdlib = global_data.Stdlib,
    Angstrom_Input = global_data.Angstrom__Input,
    Bigstringaf = global_data.Bigstringaf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Angstrom_Buffering = global_data.Angstrom__Buffering,
    Angstrom_Parser = global_data.Angstrom__Parser,
    Angstrom_Exported_state = global_data.Angstrom__Exported_state,
    Stdlib_Sys = global_data.Stdlib__Sys,
    parse = Angstrom_Parser[5],
    parse_bigstring = Angstrom_Parser[6],
    state_to_option = Angstrom_Exported_state[1],
    fail_to_string = Angstrom_Exported_state[2],
    state_to_result = Angstrom_Exported_state[3],
    _a_ = Angstrom_Parser[7],
    return$0 = _a_[1],
    fail = _a_[2],
    symbol_bind = _a_[3],
    symbol_map = _a_[4],
    symbol = _a_[5],
    symbol$0 = _a_[6],
    lift = _a_[7],
    lift2 = _a_[8],
    lift3 = _a_[9],
    lift4 = _a_[10],
    symbol$1 = _a_[11],
    symbol$2 = _a_[12],
    include = Angstrom_Parser[8],
    symbol$3 = include[1],
    symbol$4 = include[2],
    cst_parse_invalid_argument_ini =
      "parse: invalid argument, initial_buffer_size < 1",
    _b_ = [1, "incomplete input"],
    cst_prompt_input_shrunk = "prompt: input shrunk!",
    cst_not_enough_input = cst_not_enough_input$1,
    cst_not_enough_input$0 = cst_not_enough_input$1;
   function from_unbuffered_state(f, buffering, param){
    switch(param[0]){
      case 0:
       var p = param[1]; return [0, caml_call1(f, p)];
      case 1:
       var
        v = param[2],
        consumed = param[1],
        unconsumed =
          caml_call2(Angstrom_Buffering[8], [0, consumed], buffering);
       return [1, unconsumed, v];
      default:
       var
        msg = param[3],
        marks = param[2],
        consumed$0 = param[1],
        unconsumed$0 =
          caml_call2(Angstrom_Buffering[8], [0, consumed$0], buffering);
       return [2, unconsumed$0, marks, msg];
    }
   }
   function parse$0(opt, p){
    if(opt)
     var sth = opt[1], initial_buffer_size = sth;
    else
     var initial_buffer_size = 4096;
    if(initial_buffer_size < 1)
     caml_call1(Stdlib[2], cst_parse_invalid_argument_ini);
    var buffering = caml_call1(Angstrom_Buffering[1], initial_buffer_size);
    function f(p, input){
     caml_call2(Angstrom_Buffering[6], buffering, p[1]);
     var
      more =
        typeof input === "number"
         ? 0
         : (caml_call2(Angstrom_Buffering[5], buffering, input), 1),
      for_reading = caml_call1(Angstrom_Buffering[7], buffering),
      _P_ = caml_call1(Bigstringaf[6], for_reading);
     return from_unbuffered_state
             (f, buffering, caml_call4(p[2], for_reading, 0, _P_, more));
    }
    return from_unbuffered_state(f, buffering, caml_call1(parse, p));
   }
   function feed(state, input){
    switch(state[0]){
      case 0:
       var k = state[1]; return caml_call1(k, input);
      case 1:
       var v = state[2], unconsumed = state[1];
       if(typeof input === "number") return state;
       var buffering = caml_call1(Angstrom_Buffering[9], unconsumed);
       caml_call2(Angstrom_Buffering[5], buffering, input);
       return [1, caml_call2(Angstrom_Buffering[8], 0, buffering), v];
      default:
       var msg = state[3], marks = state[2], unconsumed$0 = state[1];
       if(typeof input === "number") return state;
       var buffering$0 = caml_call1(Angstrom_Buffering[9], unconsumed$0);
       caml_call2(Angstrom_Buffering[5], buffering$0, input);
       return [2,
               caml_call2(Angstrom_Buffering[8], 0, buffering$0),
               marks,
               msg];
    }
   }
   function state_to_option$0(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       var v = param[2]; return [0, v];
      default: return 0;
    }
   }
   function state_to_result$0(param){
    switch(param[0]){
      case 0:
       return _b_;
      case 1:
       var v = param[2]; return [0, v];
      default:
       var msg = param[3], marks = param[2];
       return [1, caml_call2(fail_to_string, marks, msg)];
    }
   }
   function state_to_unconsumed(param){
    if(0 === param[0]) return 0;
    var unconsumed = param[1];
    return [0, unconsumed];
   }
   function prompt(input, pos, fail, succ){
    var
     parser_uncommitted_bytes = caml_call1(Angstrom_Input[5], input),
     parser_committed_bytes = caml_call1(Angstrom_Input[4], input);
    function continue$0(input, off, len, more){
     if(len < parser_uncommitted_bytes)
      caml_call1(Stdlib[2], cst_prompt_input_shrunk);
     var
      input$0 =
        caml_call4(Angstrom_Input[1], input, off, len, parser_committed_bytes);
     return len === parser_uncommitted_bytes
             ? more
               ? prompt(input$0, pos, fail, succ)
               : caml_call3(fail, input$0, pos, 0)
             : caml_call3(succ, input$0, pos, more);
    }
    return [0, [0, caml_call1(Angstrom_Input[6], input), continue$0]];
   }
   var
    demand_input =
      [0,
       function(input, pos, more, fail, succ){
        if(! more)
         return caml_call5(fail, input, pos, more, 0, cst_not_enough_input$0);
        function succ$0(input, pos, more){
         return caml_call4(succ, input, pos, more, 0);
        }
        function fail$0(input, pos, more){
         return caml_call5(fail, input, pos, more, 0, cst_not_enough_input);
        }
        return prompt(input, pos, fail$0, succ$0);
       }];
   function ensure_suspended(n, input, pos, more, fail, succ){
    var go = [];
    caml_update_dummy
     (go,
      [0,
       function(input, pos, more, fail, succ){
        return (pos + n | 0) <= caml_call1(Angstrom_Input[2], input)
                ? caml_call4(succ, input, pos, more, 0)
                : caml_call5
                  (caml_call2(symbol$1, demand_input, go)[1],
                   input,
                   pos,
                   more,
                   fail,
                   succ);
       }]);
    return caml_call5
            (caml_call2(symbol$1, demand_input, go)[1],
             input,
             pos,
             more,
             fail,
             succ);
   }
   function unsafe_apply(len, f){
    return [0,
            function(input, pos, more, fail, succ){
             return caml_call4
                     (succ,
                      input,
                      pos + len | 0,
                      more,
                      caml_call4(Angstrom_Input[15], input, pos, len, f));
            }];
   }
   function ensure(n, p){
    return [0,
            function(input, pos, more, fail, succ){
             if((pos + n | 0) <= caml_call1(Angstrom_Input[2], input))
              return caml_call5(p[1], input, pos, more, fail, succ);
             function succ$0(input, pos, more, param){
              return caml_call5(p[1], input, pos, more, fail, succ);
             }
             return ensure_suspended(n, input, pos, more, fail, succ$0);
            }];
   }
   var
    at_end_of_input =
      [0,
       function(input, pos, more, param, succ){
        if(pos < caml_call1(Angstrom_Input[2], input))
         return caml_call4(succ, input, pos, more, 0);
        if(! more) return caml_call4(succ, input, pos, more, 1);
        function succ$0(input, pos, more){
         return caml_call4(succ, input, pos, more, 0);
        }
        function fail(input, pos, more){
         return caml_call4(succ, input, pos, more, 1);
        }
        return prompt(input, pos, fail, succ$0);
       }],
    cst_end_of_input = "end_of_input",
    end_of_input =
      caml_call2
       (symbol_bind,
        at_end_of_input,
        function(param){
         return param
                 ? caml_call1(return$0, 0)
                 : caml_call1(fail, cst_end_of_input);
        }),
    cst_advance = "advance";
   function advance(n){
    if(0 > n) return caml_call1(fail, cst_advance);
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call4(succ, input, pos + n | 0, more, 0);
        }];
    return ensure(n, p);
   }
   var
    pos =
      [0,
       function(input, pos, more, fail, succ){
        return caml_call4(succ, input, pos, more, pos);
       }],
    available =
      [0,
       function(input, pos, more, fail, succ){
        return caml_call4
                (succ,
                 input,
                 pos,
                 more,
                 caml_call1(Angstrom_Input[2], input) - pos | 0);
       }],
    commit =
      [0,
       function(input, pos, more, fail, succ){
        caml_call2(Angstrom_Input[16], input, pos);
        return caml_call4(succ, input, pos, more, 0);
       }];
   function unsafe_lookahead(p){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, param, more, v){
              return caml_call4(succ, input, pos, more, v);
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   var
    peek_char =
      [0,
       function(input, pos, more, fail, succ){
        if(pos < caml_call1(Angstrom_Input[2], input))
         return caml_call4
                 (succ,
                  input,
                  pos,
                  more,
                  [0, caml_call2(Angstrom_Input[7], input, pos)]);
        if(0 === more) return caml_call4(succ, input, pos, more, 0);
        function succ$0(input, pos, more){
         return caml_call4
                 (succ,
                  input,
                  pos,
                  more,
                  [0, caml_call2(Angstrom_Input[7], input, pos)]);
        }
        function fail$0(input, pos, more){
         return caml_call4(succ, input, pos, more, 0);
        }
        return prompt(input, pos, fail$0, succ$0);
       }],
    peek_char_fail = [];
   caml_update_dummy
    (peek_char_fail,
     [0,
      function(input, pos, more, fail, succ){
       if(pos < caml_call1(Angstrom_Input[2], input))
        return caml_call4
                (succ,
                 input,
                 pos,
                 more,
                 caml_call2(Angstrom_Input[7], input, pos));
       function succ$0(input, pos, more, param){
        return caml_call5(peek_char_fail[1], input, pos, more, fail, succ);
       }
       return ensure_suspended(1, input, pos, more, fail, succ$0);
      }]);
   var
    _c_ = [0, [11, cst_satisfy, [1, 0]], cst_satisfy_C],
    _d_ = [0, [11, cst_satisfy, [1, 0]], cst_satisfy_C],
    _e_ = [0, [11, "char ", [1, 0]], "char %C"],
    _f_ = [0, [11, "not char ", [1, 0]], "not char %C"];
   function satisfy(f){
    return [0,
            function(input, pos, more, fail, succ){
             if(pos >= caml_call1(Angstrom_Input[2], input)){
              var
               succ$0 =
                 function(input, pos, more, param){
                  var c = caml_call2(Angstrom_Input[7], input, pos);
                  if(caml_call1(f, c))
                   return caml_call4(succ, input, pos + 1 | 0, more, c);
                  var _O_ = caml_call4(fail, input, pos, more, 0);
                  return caml_call3(Stdlib_Printf[10], _O_, _d_, c);
                 };
              return ensure_suspended(1, input, pos, more, fail, succ$0);
             }
             var c = caml_call2(Angstrom_Input[7], input, pos);
             if(caml_call1(f, c))
              return caml_call4(succ, input, pos + 1 | 0, more, c);
             var _N_ = caml_call4(fail, input, pos, more, 0);
             return caml_call3(Stdlib_Printf[10], _N_, _c_, c);
            }];
   }
   function char$0(c){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call2(Angstrom_Input[7], input, pos) === c
                 ? caml_call4(succ, input, pos + 1 | 0, more, c)
                 : caml_call5
                   (fail,
                    input,
                    pos,
                    more,
                    0,
                    caml_call2(Stdlib_Printf[4], _e_, c));
        }];
    return ensure(1, p);
   }
   function not_char(c){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var c$0 = caml_call2(Angstrom_Input[7], input, pos);
         return c !== c$0
                 ? caml_call4(succ, input, pos + 1 | 0, more, c$0)
                 : caml_call5
                   (fail,
                    input,
                    pos,
                    more,
                    0,
                    caml_call2(Stdlib_Printf[4], _f_, c));
        }];
    return ensure(1, p);
   }
   var
    p =
      [0,
       function(input, pos, more, fail, succ){
        return caml_call4
                (succ,
                 input,
                 pos + 1 | 0,
                 more,
                 caml_call2(Angstrom_Input[7], input, pos));
       }],
    any_char = ensure(1, p),
    _g_ = [0, [11, "int8 ", [4, 0, 0, 0, 0]], "int8 %d"];
   function int8(i){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var c = caml_call2(Angstrom_Input[7], input, pos);
         return c === (i & 255)
                 ? caml_call4(succ, input, pos + 1 | 0, more, c)
                 : caml_call5
                   (fail,
                    input,
                    pos,
                    more,
                    0,
                    caml_call2(Stdlib_Printf[4], _g_, i));
        }];
    return ensure(1, p);
   }
   var
    p$0 =
      [0,
       function(input, pos, more, fail, succ){
        var c = caml_call2(Angstrom_Input[7], input, pos);
        return caml_call4(succ, input, pos + 1 | 0, more, c);
       }],
    any_uint8 = ensure(1, p$0),
    s = Stdlib_Sys[10] - 8 | 0,
    p$1 =
      [0,
       function(input, pos, more, fail, succ){
        var c = caml_call2(Angstrom_Input[7], input, pos);
        return caml_call4(succ, input, pos + 1 | 0, more, c << s >> s);
       }],
    any_int8 = ensure(1, p$1),
    cst_skip = "skip",
    cst_count_while1 = cst_count_while1$1,
    cst_count_while1$0 = cst_count_while1$1,
    _h_ = [1, "string"],
    cst_take_n_0 = "take: n < 0",
    cst_take_bigstring_n_0 = "take_bigstring: n < 0",
    cst_no_more_choices = "no more choices";
   function skip(f){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call1(f, caml_call2(Angstrom_Input[7], input, pos))
                 ? caml_call4(succ, input, pos + 1 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_skip);
        }];
    return ensure(1, p);
   }
   function count_while(init, f, with_buffer){
    return [0,
            function(input, pos, more, fail, succ){
             var
              len = caml_call3(Angstrom_Input[14], input, pos + init | 0, f),
              input_len = caml_call1(Angstrom_Input[2], input),
              init$0 = init + len | 0;
             if((pos + init$0 | 0) >= input_len && 0 !== more){
              var
               succ$0 =
                 function(input, pos, more){
                  return caml_call5
                          (count_while(init$0, f, with_buffer)[1],
                           input,
                           pos,
                           more,
                           fail,
                           succ);
                 },
               fail$0 =
                 function(input, pos, more){
                  return caml_call4
                          (succ,
                           input,
                           pos + init$0 | 0,
                           more,
                           caml_call4
                            (Angstrom_Input[15], input, pos, init$0, with_buffer));
                 };
              return prompt(input, pos, fail$0, succ$0);
             }
             return caml_call4
                     (succ,
                      input,
                      pos + init$0 | 0,
                      more,
                      caml_call4
                       (Angstrom_Input[15], input, pos, init$0, with_buffer));
            }];
   }
   function count_while1(f, with_buffer){
    return [0,
            function(input, pos, more, fail, succ){
             var
              len = caml_call3(Angstrom_Input[14], input, pos, f),
              input_len = caml_call1(Angstrom_Input[2], input);
             if(1 <= len){
              if((pos + len | 0) >= input_len && 0 !== more){
               var
                succ$0 =
                  function(input, pos, more){
                   return caml_call5
                           (count_while(len, f, with_buffer)[1],
                            input,
                            pos,
                            more,
                            fail,
                            succ);
                  },
                fail$0 =
                  function(input, pos, more){
                   return caml_call4
                           (succ,
                            input,
                            pos + len | 0,
                            more,
                            caml_call4(Angstrom_Input[15], input, pos, len, with_buffer));
                  };
               return prompt(input, pos, fail$0, succ$0);
              }
              return caml_call4
                      (succ,
                       input,
                       pos + len | 0,
                       more,
                       caml_call4(Angstrom_Input[15], input, pos, len, with_buffer));
             }
             if(pos >= input_len && 0 !== more){
              var
               succ$1 =
                 function(input, pos, more){
                  return caml_call5
                          (count_while1(f, with_buffer)[1],
                           input,
                           pos,
                           more,
                           fail,
                           succ);
                 },
               fail$1 =
                 function(input, pos, more){
                  return caml_call5
                          (fail, input, pos, more, 0, cst_count_while1$0);
                 };
              return prompt(input, pos, fail$1, succ$1);
             }
             return caml_call5(fail, input, pos, more, 0, cst_count_while1);
            }];
   }
   function string(f, s){
    var len = caml_ml_string_length(s);
    function f$0(buffer, off, len){
     var i = [0, 0];
     for(;;){
      if(i[1] < len){
       var
        _L_ = caml_call1(f, runtime.caml_string_unsafe_get(s, i[1])),
        _M_ = caml_call1(f, runtime.caml_ba_get_1(buffer, off + i[1] | 0));
       if(caml_call2(Stdlib_Char[8], _M_, _L_)){i[1]++; continue;}
      }
      return len === i[1]
              ? [0, caml_call3(Bigstringaf[7], buffer, off, len)]
              : _h_;
     }
    }
    return ensure
            (len,
             [0,
              function(input, pos, more, fail, succ){
               var
                match = caml_call4(Angstrom_Input[15], input, pos, len, f$0);
               if(0 === match[0]){
                var x = match[1];
                return caml_call4(succ, input, pos + len | 0, more, x);
               }
               var e = match[1];
               return caml_call5(fail, input, pos, more, 0, e);
              }]);
   }
   function string$0(s){return string(function(x){return x;}, s);}
   function string_ci(s){return string(Stdlib_Char[5], s);}
   function skip_while(f){
    return count_while(0, f, function(param, _K_, _J_){return 0;});
   }
   function take(n){
    if(0 > n) return caml_call1(fail, cst_take_n_0);
    var n$0 = caml_call2(Stdlib[17], n, 0);
    return ensure(n$0, unsafe_apply(n$0, Bigstringaf[7]));
   }
   function take_bigstring(n){
    if(0 > n) return caml_call1(fail, cst_take_bigstring_n_0);
    var n$0 = caml_call2(Stdlib[17], n, 0);
    return ensure(n$0, unsafe_apply(n$0, Bigstringaf[4]));
   }
   function take_bigstring_while(f){return count_while(0, f, Bigstringaf[4]);}
   function take_bigstring_while1(f){return count_while1(f, Bigstringaf[4]);}
   function take_bigstring_till(f){
    return take_bigstring_while(function(c){return 1 - caml_call1(f, c);});
   }
   function peek_string(n){return unsafe_lookahead(take(n));}
   function take_while(f){return count_while(0, f, Bigstringaf[7]);}
   function take_while1(f){return count_while1(f, Bigstringaf[7]);}
   function take_till(f){
    return take_while(function(c){return 1 - caml_call1(f, c);});
   }
   function choice(opt, ps){
    if(opt)
     var sth = opt[1], failure_msg = sth;
    else
     var failure_msg = cst_no_more_choices;
    var _I_ = caml_call1(fail, failure_msg);
    return caml_call3(Stdlib_List[26], symbol$4, ps, _I_);
   }
   function fix_direct(f){
    var p = [], r = [];
    caml_update_dummy(p, [246, function(_H_){return caml_call1(f, r);}]);
    caml_update_dummy
     (r,
      [0,
       function(buf, pos, more, fail, succ){
        var
         _F_ = caml_obj_tag(p),
         _G_ =
           250 === _F_
            ? p[1]
            : 246 === _F_ ? caml_call1(CamlinternalLazy[2], p) : p;
        return caml_call5(_G_[1], buf, pos, more, fail, succ);
       }]);
    return r;
   }
   function fix_lazy(max_steps, f){
    var steps = [0, max_steps], p = [], r = [];
    caml_update_dummy(p, [246, function(_E_){return caml_call1(f, r);}]);
    caml_update_dummy
     (r,
      [0,
       function(buf, pos, more, fail, succ){
        steps[1]--;
        if(0 <= steps[1]){
         var
          _z_ = caml_obj_tag(p),
          _A_ =
            250 === _z_
             ? p[1]
             : 246 === _z_ ? caml_call1(CamlinternalLazy[2], p) : p;
         return caml_call5(_A_[1], buf, pos, more, fail, succ);
        }
        steps[1] = max_steps;
        return [1,
                [246,
                 function(_B_){
                  var
                   _C_ = caml_obj_tag(p),
                   _D_ =
                     250 === _C_
                      ? p[1]
                      : 246 === _C_ ? caml_call1(CamlinternalLazy[2], p) : p;
                  return caml_call5(_D_[1], buf, pos, more, fail, succ);
                 }]];
       }]);
    return r;
   }
   var
    _i_ = Stdlib_Sys[5],
    cst_LE_int64 = "LE.int64",
    cst_LE_int32 = "LE.int32",
    cst_LE_int16 = "LE.int16",
    cst_BE_int64 = "BE.int64",
    cst_BE_int32 = "BE.int32",
    cst_BE_int16 = "BE.int16",
    cst_consumed_parser_committed = "consumed: parser committed",
    cst_count_n_0 = "count: n < 0",
    cst_end_of_line = "end_of_line",
    fix =
      typeof _i_ === "number"
       ? _i_ ? fix_direct : fix_direct
       : function(f){return fix_lazy(20, f);};
   function option(x, p){
    return caml_call2(symbol$4, p, caml_call1(return$0, x));
   }
   function cons(x, xs){return [0, x, xs];}
   function list(ps){
    if(! ps) return caml_call1(return$0, 0);
    var ps$0 = ps[2], p = ps[1];
    return caml_call3(lift2, cons, p, list(ps$0));
   }
   function count(n, p){
    if(0 > n) return caml_call1(fail, cst_count_n_0);
    function loop(n){
     return 0 === n
             ? caml_call1(return$0, 0)
             : caml_call3(lift2, cons, p, loop(n - 1 | 0));
    }
    return loop(n);
   }
   function many(p){
    return fix
            (function(m){
              var _y_ = caml_call1(return$0, 0);
              return caml_call2(symbol$4, caml_call3(lift2, cons, p, m), _y_);
             });
   }
   function many1(p){return caml_call3(lift2, cons, p, many(p));}
   function many_till(p, t){
    return fix
            (function(m){
              var _x_ = caml_call3(lift2, cons, p, m);
              return caml_call2
                      (symbol$4,
                       caml_call2(symbol$1, t, caml_call1(return$0, 0)),
                       _x_);
             });
   }
   function sep_by1(s, p){
    return fix
            (function(m){
              var _w_ = caml_call1(return$0, 0);
              return caml_call3
                      (lift2,
                       cons,
                       p,
                       caml_call2(symbol$4, caml_call2(symbol$1, s, m), _w_));
             });
   }
   function sep_by(s, p){
    var _u_ = caml_call1(return$0, 0), _v_ = caml_call1(return$0, 0);
    return caml_call2
            (symbol$4,
             caml_call3
              (lift2,
               cons,
               p,
               caml_call2
                (symbol$4, caml_call2(symbol$1, s, sep_by1(s, p)), _v_)),
             _u_);
   }
   function skip_many(p){
    return fix
            (function(m){
              var _t_ = caml_call1(return$0, 0);
              return caml_call2
                      (symbol_bind,
                       caml_call2
                        (symbol$4,
                         caml_call2(symbol_map, p, function(param){return 1;}),
                         _t_),
                       function(param){return param ? m : caml_call1(return$0, 0);});
             });
   }
   function skip_many1(p){return caml_call2(symbol$1, p, skip_many(p));}
   var
    _j_ = caml_call1(return$0, 0),
    _k_ = caml_call2(symbol$1, string$0(cst), _j_),
    _l_ = caml_call1(return$0, 0),
    end_of_line =
      caml_call2
       (symbol$3,
        caml_call2(symbol$4, caml_call2(symbol$1, char$0(10), _l_), _k_),
        cst_end_of_line);
   function scan(state, f, with_buffer){
    return [0,
            function(input, pos, more, fail, succ){
             var
              state$0 = [0, state],
              parser =
                caml_call2
                 (symbol_map,
                  count_while
                   (0,
                    function(c){
                     var match = caml_call2(f, state$0[1], c);
                     if(! match) return 0;
                     var state = match[1];
                     state$0[1] = state;
                     return 1;
                    },
                    with_buffer),
                  function(x){return [0, x, state$0[1]];});
             return caml_call5(parser[1], input, pos, more, fail, succ);
            }];
   }
   function scan$0(state, f){return scan(state, f, Bigstringaf[7]);}
   function scan_state(state, f){
    return caml_call2
            (symbol_map,
             scan(state, f, function(param, _s_, _r_){return 0;}),
             function(param){var state = param[2]; return state;});
   }
   function scan_string(state, f){
    return caml_call2
            (symbol_map, scan$0(state, f), function(_q_){return _q_[1];});
   }
   function consume_with(p, f){
    return [0,
            function(input, pos, more, fail, succ){
             var
              parser_committed_bytes = caml_call1(Angstrom_Input[4], input);
             function succ$0(input, pos$0, more, param){
              if
               (parser_committed_bytes
                !== caml_call1(Angstrom_Input[4], input))
               return caml_call5
                       (fail, input, pos$0, more, 0, cst_consumed_parser_committed);
              var
               len = pos$0 - pos | 0,
               consumed = caml_call4(Angstrom_Input[15], input, pos, len, f);
              return caml_call4(succ, input, pos$0, more, consumed);
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   function consumed(p){return consume_with(p, Bigstringaf[7]);}
   function consumed_bigstring(p){return consume_with(p, Bigstringaf[4]);}
   function both(a, b){
    return caml_call3(lift2, function(a, b){return [0, a, b];}, a, b);
   }
   function map(t, f){return caml_call2(symbol_map, t, f);}
   function bind(t, f){return caml_call2(symbol_bind, t, f);}
   function map2(a, b, f){return caml_call3(lift2, f, a, b);}
   function map3(a, b, c, f){return caml_call4(lift3, f, a, b, c);}
   function map4(a, b, c, d, f){return caml_call5(lift4, f, a, b, c, d);}
   var
    Let_syntax = [0, return$0, map, bind, both, map2, map3, map4],
    Let_syntax$0 = [0, return$0, symbol_map, symbol_bind, Let_syntax];
   function int16(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call2(Angstrom_Input[11], input, pos) === (n & 65535)
                 ? caml_call4(succ, input, pos + 2 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_BE_int16);
        }];
    return ensure(2, p);
   }
   function int32(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _p_ = caml_call2(Angstrom_Input[12], input, pos);
         return caml_call2(Stdlib_Int32[17], _p_, n)
                 ? caml_call4(succ, input, pos + 4 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_BE_int32);
        }];
    return ensure(4, p);
   }
   function int64(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _o_ = caml_call2(Angstrom_Input[13], input, pos);
         return caml_call2(Stdlib_Int64[17], _o_, n)
                 ? caml_call4(succ, input, pos + 8 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_BE_int64);
        }];
    return ensure(8, p);
   }
   var
    any_uint16 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[31], bs, off);
          })),
    any_int16 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[33], bs, off);
          })),
    any_int32 =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_call2(Bigstringaf[37], bs, off);
          })),
    any_int64 =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_call2(Bigstringaf[41], bs, off);
          })),
    any_float =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_int32_float_of_bits
                   (caml_call2(Bigstringaf[37], bs, off));
          })),
    any_double =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_int64_float_of_bits
                   (caml_call2(Bigstringaf[41], bs, off));
          }));
   function int16$0(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call2(Angstrom_Input[8], input, pos) === (n & 65535)
                 ? caml_call4(succ, input, pos + 2 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_LE_int16);
        }];
    return ensure(2, p);
   }
   function int32$0(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _n_ = caml_call2(Angstrom_Input[9], input, pos);
         return caml_call2(Stdlib_Int32[17], _n_, n)
                 ? caml_call4(succ, input, pos + 4 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_LE_int32);
        }];
    return ensure(4, p);
   }
   function int64$0(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _m_ = caml_call2(Angstrom_Input[10], input, pos);
         return caml_call2(Stdlib_Int64[17], _m_, n)
                 ? caml_call4(succ, input, pos + 8 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_LE_int64);
        }];
    return ensure(8, p);
   }
   var
    any_uint16$0 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[30], bs, off);
          })),
    any_int16$0 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[32], bs, off);
          })),
    any_int32$0 =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_call2(Bigstringaf[36], bs, off);
          })),
    any_int64$0 =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_call2(Bigstringaf[40], bs, off);
          })),
    any_float$0 =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_int32_float_of_bits
                   (caml_call2(Bigstringaf[36], bs, off));
          })),
    any_double$0 =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_int64_float_of_bits
                   (caml_call2(Bigstringaf[40], bs, off));
          }));
   function take$0(n, f){
    var n$0 = caml_call2(Stdlib[17], n, 0);
    return ensure(n$0, unsafe_apply(n$0, f));
   }
   function peek(n, f){return unsafe_lookahead(take$0(n, f));}
   function take_while$0(check, f){return count_while(0, check, f);}
   function take_while1$0(check, f){return count_while1(check, f);}
   function take_till$0(check, f){
    return take_while$0(function(c){return 1 - caml_call1(check, c);}, f);
   }
   var Consume = [0];
   function parse_bigstring$0(consume, p, bs){
    var p$0 = consume ? caml_call2(symbol$2, p, end_of_input) : p;
    return caml_call2(parse_bigstring, p$0, bs);
   }
   function parse_string(consume, p, s){
    var len = caml_ml_string_length(s), bs = caml_call1(Bigstringaf[1], len);
    caml_call5(Bigstringaf[45], s, 0, bs, 0, len);
    return parse_bigstring$0(consume, p, bs);
   }
   var
    Angstrom =
      [0,
       peek_char,
       peek_char_fail,
       peek_string,
       char$0,
       not_char,
       any_char,
       satisfy,
       string$0,
       string_ci,
       skip,
       skip_while,
       take,
       take_while,
       take_while1,
       take_till,
       consumed,
       take_bigstring,
       take_bigstring_while,
       take_bigstring_while1,
       take_bigstring_till,
       consumed_bigstring,
       advance,
       end_of_line,
       at_end_of_input,
       end_of_input,
       scan$0,
       scan_state,
       scan_string,
       int8,
       any_uint8,
       any_int8,
       [0,
        int16,
        int32,
        int64,
        any_int16,
        any_int32,
        any_int64,
        any_uint16,
        any_float,
        any_double],
       [0,
        int16$0,
        int32$0,
        int64$0,
        any_int16$0,
        any_int32$0,
        any_int64$0,
        any_uint16$0,
        any_float$0,
        any_double$0],
       option,
       both,
       list,
       count,
       many,
       many1,
       many_till,
       sep_by,
       sep_by1,
       skip_many,
       skip_many1,
       fix,
       fix_lazy,
       symbol$4,
       choice,
       symbol$3,
       commit,
       return$0,
       fail,
       symbol_bind,
       bind,
       symbol_map,
       symbol$0,
       symbol,
       symbol$1,
       symbol$2,
       lift,
       lift2,
       lift3,
       lift4,
       map,
       map2,
       map3,
       map4,
       Let_syntax$0,
       symbol_map,
       symbol_bind,
       both,
       [0, take$0, take_while$0, take_while1$0, take_till$0, peek],
       Consume,
       parse_bigstring$0,
       parse_string,
       [0,
        parse$0,
        feed,
        state_to_option$0,
        state_to_result$0,
        state_to_unconsumed],
       [0, parse, state_to_option, state_to_result],
       pos,
       available];
   runtime.caml_register_global(42, Angstrom, "Angstrom");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJhbmdzdHJvbS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic3RhdGVfdG9fb3B0aW9uIiwieCIsInYiLCJmYWlsX3RvX3N0cmluZyIsIm1hcmtzIiwiZXJyIiwic3RhdGVfdG9fcmVzdWx0IiwiY3JlYXRlIiwiYnVmZmVyIiwib2ZmIiwibGVuIiwiY29tbWl0dGVkX2J5dGVzIiwibGVuZ3RoIiwidCIsImNsaWVudF9jb21taXR0ZWRfYnl0ZXMiLCJwYXJzZXJfY29tbWl0dGVkX2J5dGVzIiwiYnl0ZXNfZm9yX2NsaWVudF90b19jb21taXQiLCJwYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMiLCJpbnZhcmlhbnQiLCJvZmZzZXRfaW5fYnVmZmVyIiwicG9zIiwiYXBwbHkiLCJmIiwidW5zYWZlX2dldF9jaGFyIiwidW5zYWZlX2dldF9pbnQxNl9sZSIsInVuc2FmZV9nZXRfaW50MzJfbGUiLCJ1bnNhZmVfZ2V0X2ludDY0X2xlIiwidW5zYWZlX2dldF9pbnQxNl9iZSIsInVuc2FmZV9nZXRfaW50MzJfYmUiLCJ1bnNhZmVfZ2V0X2ludDY0X2JlIiwiY291bnRfd2hpbGUiLCJpIiwibGltaXQiLCJjb21taXQiLCJmYWlsX2siLCJpbnB1dCIsIm1zZyIsInN1Y2NlZWRfayIsInRvX2V4cG9ydGVkX3N0YXRlIiwiY29udGludWUkMCIsImNvbW1pdHRlZCIsImJzIiwibW9yZSIsIngkMCIsInMiLCJzbCIsImkkMCIsInBhcnNlIiwicCIsInBhcnNlX2JpZ3N0cmluZyIsImlucHV0JDAiLCJyZXR1cm4kMCIsImZhaWwiLCJzdWNjIiwic3ltYm9sX2JpbmQiLCJzdWNjJDAiLCJzeW1ib2xfbWFwIiwic3ltYm9sIiwibSIsInN5bWJvbCQwIiwic3VjYzAiLCJpbnB1dDAiLCJwb3MwIiwibW9yZTAiLCJzdWNjMSIsImlucHV0MSIsInBvczEiLCJtb3JlMSIsImxpZnQiLCJsaWZ0MiIsIm0xIiwibTIiLCJzdWNjMiIsImlucHV0MiIsInBvczIiLCJtb3JlMiIsImxpZnQzIiwibTMiLCJzdWNjMyIsImlucHV0MyIsInBvczMiLCJtb3JlMyIsImxpZnQ0IiwibTQiLCJzdWNjNCIsImlucHV0NCIsInBvczQiLCJtb3JlNCIsInN5bWJvbCQxIiwiYSIsImIiLCJzeW1ib2wkMiIsInN5bWJvbCQzIiwibWFyayIsImZhaWwkMCIsInN5bWJvbCQ0IiwicSIsInBvcyQwIiwibW9yZSQwIiwicmV0dXJuJDEiLCJzeW1ib2xfYmluZCQwIiwic3ltYm9sX21hcCQwIiwic3ltYm9sJDUiLCJzeW1ib2wkNiIsImxpZnQyJDAiLCJsaWZ0MyQwIiwibGlmdDQkMCIsInN5bWJvbCQ3Iiwic3ltYm9sJDgiLCJvZl9iaWdzdHJpbmciLCJidWYiLCJ3cml0YWJsZV9zcGFjZSIsImVuc3VyZSIsInRvX2NvcHkiLCJvbGRfbGVuIiwibmV3X2xlbiIsInNwYWNlIiwibmV3X2J1ZiIsIndyaXRlX3BvcyIsImZlZWRfc3RyaW5nIiwic3RyIiwiZmVlZF9iaWdzdHJpbmciLCJmZWVkX2lucHV0Iiwic2hpZnQiLCJuIiwiZm9yX3JlYWRpbmciLCJ1bmNvbnN1bWVkIiwib3B0Iiwic3RoIiwib2ZfdW5jb25zdW1lZCIsImZyb21fdW5idWZmZXJlZF9zdGF0ZSIsImJ1ZmZlcmluZyIsImNvbnN1bWVkIiwiY29uc3VtZWQkMCIsInVuY29uc3VtZWQkMCIsInBhcnNlJDAiLCJpbml0aWFsX2J1ZmZlcl9zaXplIiwiZmVlZCIsInN0YXRlIiwiayIsImJ1ZmZlcmluZyQwIiwic3RhdGVfdG9fb3B0aW9uJDAiLCJzdGF0ZV90b19yZXN1bHQkMCIsInN0YXRlX3RvX3VuY29uc3VtZWQiLCJwcm9tcHQiLCJkZW1hbmRfaW5wdXQiLCJlbnN1cmVfc3VzcGVuZGVkIiwiZ28iLCJ1bnNhZmVfYXBwbHkiLCJhdF9lbmRfb2ZfaW5wdXQiLCJlbmRfb2ZfaW5wdXQiLCJhZHZhbmNlIiwiYXZhaWxhYmxlIiwidW5zYWZlX2xvb2thaGVhZCIsInBlZWtfY2hhciIsInBlZWtfY2hhcl9mYWlsIiwic2F0aXNmeSIsImMiLCJjaGFyJDAiLCJub3RfY2hhciIsImMkMCIsImFueV9jaGFyIiwiaW50OCIsInAkMCIsImFueV91aW50OCIsInAkMSIsImFueV9pbnQ4Iiwic2tpcCIsImluaXQiLCJ3aXRoX2J1ZmZlciIsImlucHV0X2xlbiIsImluaXQkMCIsImNvdW50X3doaWxlMSIsInN1Y2MkMSIsImZhaWwkMSIsInN0cmluZyIsImYkMCIsImUiLCJzdHJpbmckMCIsInN0cmluZ19jaSIsInNraXBfd2hpbGUiLCJ0YWtlIiwibiQwIiwidGFrZV9iaWdzdHJpbmciLCJ0YWtlX2JpZ3N0cmluZ193aGlsZSIsInRha2VfYmlnc3RyaW5nX3doaWxlMSIsInRha2VfYmlnc3RyaW5nX3RpbGwiLCJwZWVrX3N0cmluZyIsInRha2Vfd2hpbGUiLCJ0YWtlX3doaWxlMSIsInRha2VfdGlsbCIsImNob2ljZSIsInBzIiwiZmFpbHVyZV9tc2ciLCJmaXhfZGlyZWN0IiwiciIsImZpeF9sYXp5IiwibWF4X3N0ZXBzIiwic3RlcHMiLCJmaXgiLCJvcHRpb24iLCJjb25zIiwieHMiLCJsaXN0IiwicHMkMCIsImNvdW50IiwibG9vcCIsIm1hbnkiLCJtYW55MSIsIm1hbnlfdGlsbCIsInNlcF9ieTEiLCJzZXBfYnkiLCJza2lwX21hbnkiLCJza2lwX21hbnkxIiwiZW5kX29mX2xpbmUiLCJzY2FuIiwic3RhdGUkMCIsInBhcnNlciIsInNjYW4kMCIsInNjYW5fc3RhdGUiLCJzY2FuX3N0cmluZyIsImNvbnN1bWVfd2l0aCIsImNvbnN1bWVkX2JpZ3N0cmluZyIsImJvdGgiLCJtYXAiLCJiaW5kIiwibWFwMiIsIm1hcDMiLCJtYXA0IiwiZCIsImludDE2IiwiaW50MzIiLCJpbnQ2NCIsImFueV91aW50MTYiLCJhbnlfaW50MTYiLCJhbnlfaW50MzIiLCJhbnlfaW50NjQiLCJhbnlfZmxvYXQiLCJhbnlfZG91YmxlIiwiaW50MTYkMCIsImludDMyJDAiLCJpbnQ2NCQwIiwiYW55X3VpbnQxNiQwIiwiYW55X2ludDE2JDAiLCJhbnlfaW50MzIkMCIsImFueV9pbnQ2NCQwIiwiYW55X2Zsb2F0JDAiLCJhbnlfZG91YmxlJDAiLCJ0YWtlJDAiLCJwZWVrIiwidGFrZV93aGlsZSQwIiwiY2hlY2siLCJ0YWtlX3doaWxlMSQwIiwidGFrZV90aWxsJDAiLCJwYXJzZV9iaWdzdHJpbmckMCIsImNvbnN1bWUiLCJwYXJzZV9zdHJpbmciXSwic291cmNlcyI6WyIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FuZ3N0cm9tL2V4cG9ydGVkX3N0YXRlLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hbmdzdHJvbS9pbnB1dC5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYW5nc3Ryb20vcGFyc2VyLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hbmdzdHJvbS9idWZmZXJpbmcubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FuZ3N0cm9tL2FuZ3N0cm9tLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7Rzs7Ozs7Ozs7Ozs7O1lBVUlBLGdCQUFnQkM7SUFBSSxPQUFKQTs7T0FHRjs7V0FGTkMsSUFEUUQsTUFDRixXQUFOQztlQUNNOztHQUNJO1lBRWxCQyxlQUFlQyxPQUFNQztJQUN2QjtLQUE0QixNQUFBLDRCQURMQTtLQUN2QixNQUFBLG9DQURpQkQ7SUFDVyxPQUFBO0dBQVU7WUFFcENFLGdCQUFnQkw7SUFBSSxPQUFKQTs7T0FFTzs7V0FEZkMsSUFEUUQsTUFDTyxXQUFmQzs7V0FFT0csTUFIQ0osTUFHUkcsUUFIUUgsTUFHTyxXQU52QkUsZUFNUUMsT0FBT0M7O0dBQXdDOzs7VUFYdkRMLGlCQUtBRyxnQkFHQUc7Ozs7RTs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7OztZQ3VC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Z0J5QnRHO0lBTTNCLE9BQUEsNEJBTEltSCxLQUR5QjFIO0dBTUU7WUFFN0J1TixhQUFjRCxTQUFRL00sR0FBRUo7SUFDMUIsSUFBSWxDLDRCQURzQmtDLElBRXRCSCxLQUFNLDJCQUROL0I7SUFFSiw0QkFIMEJrQyxNQUV0QkgsT0FEQS9CO0lBRUosT0FYRW9QLGtCQVFjQyxTQUFRL00sR0FFcEJQO0dBRXlCOzs7O09BamYzQmlIO09BZUlDO09Ba0xKZ0M7T0F6SkE3QjtPQVNBQztPQVVBRTtPQW5DQUw7T0E0SUFzQjtPQUNBQztPQXZFQVo7T0F5RUFhO09BR0FDO09BMEJBTztPQUdBQztPQUdBQztPQTBIQTFEO09BbkpBbUQ7T0FPQUM7T0FHQUM7T0FHQUM7T0F1SUFvQztPQWpXQXZFO09BdVRBK0Q7T0F6VUFqRTtPQVlBQztPQTZVQW9FO09BR0FDO09BSUFDO09BaFBBMUQ7T0FVQUU7T0FRQUU7O1FBcVJFZ0U7UUFVQUM7UUFVQUM7UUFhQUU7UUFHQUM7UUFHQUM7UUFUQUg7UUFZQUk7UUFHQUM7O1FBS0FDO1FBVUFDO1FBVUFDO1FBY0FFO1FBR0FDO1FBR0FDO1FBVEFIO1FBWUFJO1FBR0FDO09BOU5GL0M7T0E0RkF1QjtPQXZGSXBCO09BS0pFO09BVUFFO09BSUFDO09BR0FDO09BUUFFO09BSkFEO09BT0FFO09BT0FDO09BbERBZDtPQWZBSDs7T0FWQUw7O09BeE5BOUo7Ozs7T0FvVkFnTTs7Ozs7Ozs7OztPQURBRDtPQUVBRTtPQUNBQztPQUNBQzs7OztPQUxBTDtXQXVJRXlCLFFBT0FFLGNBR0FFLGVBR0FDLGFBVEFKOztPQW1CRks7T0FRQUU7O1FBdHBCRXpIO1FBb0JBRTtRQW9CQUk7UUFLQUM7UUFLQUM7O09Bb0dGM0g7T0FHQW9JOzs7RSIsInNvdXJjZXNDb250ZW50IjpbInR5cGUgJ2Egc3RhdGUgPVxuICB8IFBhcnRpYWwgb2YgJ2EgcGFydGlhbFxuICB8IERvbmUgICAgb2YgaW50ICogJ2FcbiAgfCBGYWlsICAgIG9mIGludCAqIHN0cmluZyBsaXN0ICogc3RyaW5nXG5cbmFuZCAnYSBwYXJ0aWFsID1cbiAgeyBjb21taXR0ZWQgOiBpbnRcbiAgOyBjb250aW51ZSAgOiBCaWdzdHJpbmdhZi50IC0+IG9mZjppbnQgLT4gbGVuOmludCAtPiBNb3JlLnQgLT4gJ2Egc3RhdGUgfVxuXG5cbmxldCBzdGF0ZV90b19vcHRpb24geCA9IG1hdGNoIHggd2l0aFxuICB8IERvbmUoXywgdikgLT4gU29tZSB2XG4gIHwgRmFpbCBfICAgICAtPiBOb25lXG4gIHwgUGFydGlhbCBfICAtPiBOb25lXG5cbmxldCBmYWlsX3RvX3N0cmluZyBtYXJrcyBlcnIgPVxuICBTdHJpbmcuY29uY2F0IFwiID4gXCIgbWFya3MgXiBcIjogXCIgXiBlcnJcblxubGV0IHN0YXRlX3RvX3Jlc3VsdCB4ID0gbWF0Y2ggeCB3aXRoXG4gIHwgRG9uZShfLCB2KSAgICAgICAgICAtPiBPayB2XG4gIHwgUGFydGlhbCBfICAgICAgICAgICAtPiBFcnJvciBcImluY29tcGxldGUgaW5wdXRcIlxuICB8IEZhaWwoXywgbWFya3MsIGVycikgLT4gRXJyb3IgKGZhaWxfdG9fc3RyaW5nIG1hcmtzIGVycilcbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENvcHlyaWdodCAoYykgMjAxNyBJbmhhYml0ZWQgVHlwZSBMTEMuXG5cbiAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAgICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAgICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gICAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAgICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gICAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gICAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICAgIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gICAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gICAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICAgIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICAgIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICAgIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKilcblxudHlwZSB0ID1cbiAgeyBtdXRhYmxlIHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgOiBpbnRcbiAgOyBjbGllbnRfY29tbWl0dGVkX2J5dGVzICAgICAgICAgOiBpbnRcbiAgOyBvZmYgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpbnRcbiAgOyBsZW4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpbnRcbiAgOyBidWZmZXIgICAgICAgICAgICAgICAgICAgICAgICAgOiBCaWdzdHJpbmdhZi50XG4gIH1cblxubGV0IGNyZWF0ZSBidWZmZXIgfm9mZiB+bGVuIH5jb21taXR0ZWRfYnl0ZXMgPVxuICB7IHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgPSBjb21taXR0ZWRfYnl0ZXNcbiAgOyBjbGllbnRfY29tbWl0dGVkX2J5dGVzID0gY29tbWl0dGVkX2J5dGVzXG4gIDsgb2ZmXG4gIDsgbGVuXG4gIDsgYnVmZmVyIH1cblxubGV0IGxlbmd0aCAgICAgICAgICAgICAgICAgdCA9IHQuY2xpZW50X2NvbW1pdHRlZF9ieXRlcyArIHQubGVuXG5sZXQgY2xpZW50X2NvbW1pdHRlZF9ieXRlcyB0ID0gdC5jbGllbnRfY29tbWl0dGVkX2J5dGVzXG5sZXQgcGFyc2VyX2NvbW1pdHRlZF9ieXRlcyB0ID0gdC5wYXJzZXJfY29tbWl0dGVkX2J5dGVzXG5cbmxldCBjb21taXR0ZWRfYnl0ZXNfZGlzY3JlcGFuY3kgdCA9IHQucGFyc2VyX2NvbW1pdHRlZF9ieXRlcyAtIHQuY2xpZW50X2NvbW1pdHRlZF9ieXRlc1xubGV0IGJ5dGVzX2Zvcl9jbGllbnRfdG9fY29tbWl0ICB0ID0gY29tbWl0dGVkX2J5dGVzX2Rpc2NyZXBhbmN5IHRcblxubGV0IHBhcnNlcl91bmNvbW1pdHRlZF9ieXRlcyB0ID0gdC5sZW4gLSBieXRlc19mb3JfY2xpZW50X3RvX2NvbW1pdCB0XG5cbmxldCBpbnZhcmlhbnQgdCA9XG4gIGFzc2VydCAocGFyc2VyX2NvbW1pdHRlZF9ieXRlcyB0ICsgcGFyc2VyX3VuY29tbWl0dGVkX2J5dGVzIHQgPSBsZW5ndGggdCk7XG4gIGFzc2VydCAocGFyc2VyX2NvbW1pdHRlZF9ieXRlcyB0IC0gY2xpZW50X2NvbW1pdHRlZF9ieXRlcyAgIHQgPSBieXRlc19mb3JfY2xpZW50X3RvX2NvbW1pdCB0KTtcbjs7XG5cbmxldCBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zID1cbiAgdC5vZmYgKyBwb3MgLSB0LmNsaWVudF9jb21taXR0ZWRfYnl0ZXNcblxubGV0IGFwcGx5IHQgcG9zIGxlbiB+ZiA9XG4gIGxldCBvZmYgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIGYgdC5idWZmZXIgfm9mZiB+bGVuXG5cbmxldCB1bnNhZmVfZ2V0X2NoYXIgdCBwb3MgPVxuICBsZXQgb2ZmID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0IHQuYnVmZmVyIG9mZlxuXG5sZXQgdW5zYWZlX2dldF9pbnQxNl9sZSB0IHBvcyA9XG4gIGxldCBvZmYgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MTZfbGUgdC5idWZmZXIgb2ZmXG5cbmxldCB1bnNhZmVfZ2V0X2ludDMyX2xlIHQgcG9zID1cbiAgbGV0IG9mZiA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQzMl9sZSB0LmJ1ZmZlciBvZmZcblxubGV0IHVuc2FmZV9nZXRfaW50NjRfbGUgdCBwb3MgPVxuICBsZXQgb2ZmID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDY0X2xlIHQuYnVmZmVyIG9mZlxuXG5sZXQgdW5zYWZlX2dldF9pbnQxNl9iZSB0IHBvcyA9XG4gIGxldCBvZmYgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MTZfYmUgdC5idWZmZXIgb2ZmXG5cbmxldCB1bnNhZmVfZ2V0X2ludDMyX2JlIHQgcG9zID1cbiAgbGV0IG9mZiA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQzMl9iZSB0LmJ1ZmZlciBvZmZcblxubGV0IHVuc2FmZV9nZXRfaW50NjRfYmUgdCBwb3MgPVxuICBsZXQgb2ZmID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDY0X2JlIHQuYnVmZmVyIG9mZlxuXG5sZXQgY291bnRfd2hpbGUgdCBwb3MgfmYgPVxuICBsZXQgYnVmZmVyID0gdC5idWZmZXIgaW5cbiAgbGV0IG9mZiAgICA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgbGV0IGkgICAgICA9IHJlZiBvZmYgaW5cbiAgbGV0IGxpbWl0ICA9IHQub2ZmICsgdC5sZW4gaW5cbiAgd2hpbGUgIWkgPCBsaW1pdCAmJiBmIChCaWdzdHJpbmdhZi51bnNhZmVfZ2V0IGJ1ZmZlciAhaSkgZG9cbiAgICBpbmNyIGlcbiAgZG9uZTtcbiAgIWkgLSBvZmZcbjs7XG5cbmxldCBjb21taXQgdCBwb3MgPVxuICB0LnBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgPC0gcG9zXG47O1xuIiwibW9kdWxlIFN0YXRlID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgfCBQYXJ0aWFsIG9mICdhIHBhcnRpYWxcbiAgICB8IExhenkgICAgb2YgJ2EgdCBMYXp5LnRcbiAgICB8IERvbmUgICAgb2YgaW50ICogJ2FcbiAgICB8IEZhaWwgICAgb2YgaW50ICogc3RyaW5nIGxpc3QgKiBzdHJpbmdcblxuICBhbmQgJ2EgcGFydGlhbCA9XG4gICAgeyBjb21taXR0ZWQgOiBpbnRcbiAgICA7IGNvbnRpbnVlICA6IEJpZ3N0cmluZ2FmLnQgLT4gb2ZmOmludCAtPiBsZW46aW50IC0+IE1vcmUudCAtPiAnYSB0IH1cblxuZW5kXG50eXBlICdhIHdpdGhfc3RhdGUgPSBJbnB1dC50IC0+ICBpbnQgLT4gTW9yZS50IC0+ICdhXG5cbnR5cGUgJ2EgZmFpbHVyZSA9IChzdHJpbmcgbGlzdCAtPiBzdHJpbmcgLT4gJ2EgU3RhdGUudCkgd2l0aF9zdGF0ZVxudHlwZSAoJ2EsICdyKSBzdWNjZXNzID0gKCdhIC0+ICdyIFN0YXRlLnQpIHdpdGhfc3RhdGVcblxudHlwZSAnYSB0ID1cbiAgeyBydW4gOiAnci4gKCdyIGZhaWx1cmUgLT4gKCdhLCAncikgc3VjY2VzcyAtPiAnciBTdGF0ZS50KSB3aXRoX3N0YXRlIH1cblxubGV0IGZhaWxfayAgICBpbnB1dCBwb3MgXyBtYXJrcyBtc2cgPVxuICBTdGF0ZS5GYWlsKHBvcyAtIElucHV0LmNsaWVudF9jb21taXR0ZWRfYnl0ZXMgaW5wdXQsIG1hcmtzLCBtc2cpXG5sZXQgc3VjY2VlZF9rIGlucHV0IHBvcyBfICAgICAgIHYgICA9XG4gIFN0YXRlLkRvbmUocG9zIC0gSW5wdXQuY2xpZW50X2NvbW1pdHRlZF9ieXRlcyBpbnB1dCwgdilcblxubGV0IHJlYyB0b19leHBvcnRlZF9zdGF0ZSA9IGZ1bmN0aW9uXG4gIHwgU3RhdGUuUGFydGlhbCB7Y29tbWl0dGVkO2NvbnRpbnVlfSAtPlxuICAgICBFeHBvcnRlZF9zdGF0ZS5QYXJ0aWFsXG4gICAgICAgeyBjb21taXR0ZWRcbiAgICAgICA7IGNvbnRpbnVlID1cbiAgICAgICAgICAgZnVuIGJzIH5vZmYgfmxlbiBtb3JlIC0+XG4gICAgICAgICAgIHRvX2V4cG9ydGVkX3N0YXRlIChjb250aW51ZSBicyB+b2ZmIH5sZW4gbW9yZSl9XG4gIHwgU3RhdGUuRG9uZSAoaSx4KSAtPiBFeHBvcnRlZF9zdGF0ZS5Eb25lIChpLHgpXG4gIHwgU3RhdGUuRmFpbCAoaSwgc2wsIHMpIC0+IEV4cG9ydGVkX3N0YXRlLkZhaWwgKGksIHNsLCBzKVxuICB8IFN0YXRlLkxhenkgeCAtPiB0b19leHBvcnRlZF9zdGF0ZSAoTGF6eS5mb3JjZSB4KVxuXG5sZXQgcGFyc2UgcCA9XG4gIGxldCBpbnB1dCA9IElucHV0LmNyZWF0ZSBCaWdzdHJpbmdhZi5lbXB0eSB+Y29tbWl0dGVkX2J5dGVzOjAgfm9mZjowIH5sZW46MCBpblxuICB0b19leHBvcnRlZF9zdGF0ZSAocC5ydW4gaW5wdXQgMCBJbmNvbXBsZXRlIGZhaWxfayBzdWNjZWVkX2spXG5cbmxldCBwYXJzZV9iaWdzdHJpbmcgcCBpbnB1dCA9XG4gIGxldCBpbnB1dCA9IElucHV0LmNyZWF0ZSBpbnB1dCB+Y29tbWl0dGVkX2J5dGVzOjAgfm9mZjowIH5sZW46KEJpZ3N0cmluZ2FmLmxlbmd0aCBpbnB1dCkgaW5cbiAgRXhwb3J0ZWRfc3RhdGUuc3RhdGVfdG9fcmVzdWx0ICh0b19leHBvcnRlZF9zdGF0ZSAocC5ydW4gaW5wdXQgMCBDb21wbGV0ZSBmYWlsX2sgc3VjY2VlZF9rKSlcblxubW9kdWxlIE1vbmFkID0gc3RydWN0XG4gIGxldCByZXR1cm4gdiA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgX2ZhaWwgc3VjYyAtPlxuICAgICAgc3VjYyBpbnB1dCBwb3MgbW9yZSB2XG4gICAgfVxuXG4gIGxldCBmYWlsIG1zZyA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBfc3VjYyAtPlxuICAgICAgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBtc2dcbiAgICB9XG5cbiAgbGV0ICg+Pj0pIHAgZiA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgdiA9IChmIHYpLnJ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsIHN1Y2MgaW5cbiAgICAgIHAucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYydcbiAgICB9XG5cbiAgbGV0ICg+PnwpIHAgZiA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgdiA9IHN1Y2MgaW5wdXQnIHBvcycgbW9yZScgKGYgdikgaW5cbiAgICAgIHAucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYydcbiAgICB9XG5cbiAgbGV0ICg8JD4pIGYgbSA9XG4gICAgbSA+PnwgZlxuXG4gIGxldCAoPCo+KSBmIG0gPVxuICAgICgqIGYgPj49IGZ1biBmIC0+IG0gPj58IGYgKilcbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBzdWNjMCBpbnB1dDAgcG9zMCBtb3JlMCBmID1cbiAgICAgICAgbGV0IHN1Y2MxIGlucHV0MSBwb3MxIG1vcmUxIG0gPSBzdWNjIGlucHV0MSBwb3MxIG1vcmUxIChmIG0pIGluXG4gICAgICAgIG0ucnVuIGlucHV0MCBwb3MwIG1vcmUwIGZhaWwgc3VjYzFcbiAgICAgIGluXG4gICAgICBmLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MwIH1cblxuICBsZXQgbGlmdCBmIG0gPVxuICAgIGYgPCQ+IG1cblxuICBsZXQgbGlmdDIgZiBtMSBtMiA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgc3VjYzEgaW5wdXQxIHBvczEgbW9yZTEgbTEgPVxuICAgICAgICBsZXQgc3VjYzIgaW5wdXQyIHBvczIgbW9yZTIgbTIgPSBzdWNjIGlucHV0MiBwb3MyIG1vcmUyIChmIG0xIG0yKSBpblxuICAgICAgICBtMi5ydW4gaW5wdXQxIHBvczEgbW9yZTEgZmFpbCBzdWNjMlxuICAgICAgaW5cbiAgICAgIG0xLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MxIH1cblxuICBsZXQgbGlmdDMgZiBtMSBtMiBtMyA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgc3VjYzEgaW5wdXQxIHBvczEgbW9yZTEgbTEgPVxuICAgICAgICBsZXQgc3VjYzIgaW5wdXQyIHBvczIgbW9yZTIgbTIgPVxuICAgICAgICAgIGxldCBzdWNjMyBpbnB1dDMgcG9zMyBtb3JlMyBtMyA9XG4gICAgICAgICAgICBzdWNjIGlucHV0MyBwb3MzIG1vcmUzIChmIG0xIG0yIG0zKSBpblxuICAgICAgICAgIG0zLnJ1biBpbnB1dDIgcG9zMiBtb3JlMiBmYWlsIHN1Y2MzIGluXG4gICAgICAgIG0yLnJ1biBpbnB1dDEgcG9zMSBtb3JlMSBmYWlsIHN1Y2MyXG4gICAgICBpblxuICAgICAgbTEucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYzEgfVxuXG4gIGxldCBsaWZ0NCBmIG0xIG0yIG0zIG00ID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBzdWNjMSBpbnB1dDEgcG9zMSBtb3JlMSBtMSA9XG4gICAgICAgIGxldCBzdWNjMiBpbnB1dDIgcG9zMiBtb3JlMiBtMiA9XG4gICAgICAgICAgbGV0IHN1Y2MzIGlucHV0MyBwb3MzIG1vcmUzIG0zID1cbiAgICAgICAgICAgIGxldCBzdWNjNCBpbnB1dDQgcG9zNCBtb3JlNCBtNCA9XG4gICAgICAgICAgICAgIHN1Y2MgaW5wdXQ0IHBvczQgbW9yZTQgKGYgbTEgbTIgbTMgbTQpIGluXG4gICAgICAgICAgICBtNC5ydW4gaW5wdXQzIHBvczMgbW9yZTMgZmFpbCBzdWNjNCBpblxuICAgICAgICAgIG0zLnJ1biBpbnB1dDIgcG9zMiBtb3JlMiBmYWlsIHN1Y2MzIGluXG4gICAgICAgIG0yLnJ1biBpbnB1dDEgcG9zMSBtb3JlMSBmYWlsIHN1Y2MyXG4gICAgICBpblxuICAgICAgbTEucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYzEgfVxuXG4gIGxldCAoICo+KSBhIGIgPVxuICAgICgqIGEgPj49IGZ1biBfIC0+IGIgKilcbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyBfID0gYi5ydW4gaW5wdXQnIHBvcycgbW9yZScgZmFpbCBzdWNjIGluXG4gICAgICBhLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MnXG4gICAgfVxuXG4gIGxldCAoPCogKSBhIGIgPVxuICAgICgqIGEgPj49IGZ1biB4IC0+IGIgPj58IGZ1biBfIC0+IHggKilcbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBzdWNjMCBpbnB1dDAgcG9zMCBtb3JlMCB4ID1cbiAgICAgICAgbGV0IHN1Y2MxIGlucHV0MSBwb3MxIG1vcmUxIF8gPSBzdWNjIGlucHV0MSBwb3MxIG1vcmUxIHggaW5cbiAgICAgICAgYi5ydW4gaW5wdXQwIHBvczAgbW9yZTAgZmFpbCBzdWNjMVxuICAgICAgaW5cbiAgICAgIGEucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYzAgfVxuZW5kXG5cbm1vZHVsZSBDaG9pY2UgPSBzdHJ1Y3RcbiAgbGV0ICg8Pz4pIHAgbWFyayA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgZmFpbCcgaW5wdXQnIHBvcycgbW9yZScgbWFya3MgbXNnID1cbiAgICAgICAgZmFpbCBpbnB1dCcgcG9zJyBtb3JlJyAobWFyazo6bWFya3MpIG1zZyBpblxuICAgICAgcC5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCcgc3VjY1xuICAgIH1cblxuICBsZXQgKDx8PikgcCBxID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyBtYXJrcyBtc2cgPVxuICAgICAgICAoKiBUaGUgb25seSB0d28gY29uc3RydWN0b3JzIHRoYXQgaW50cm9kdWNlIG5ldyBmYWlsdXJlIGNvbnRpbnVhdGlvbnMgYXJlXG4gICAgICAgICAqIFs8Pz5dIGFuZCBbPHw+XS4gSWYgdGhlIGluaXRpYWwgaW5wdXQgcG9zaXRpb24gaXMgbGVzcyB0aGFuIHRoZSBsZW5ndGhcbiAgICAgICAgICogb2YgdGhlIGNvbW1pdHRlZCBpbnB1dCwgdGhlbiBjYWxsaW5nIHRoZSBmYWlsdXJlIGNvbnRpbnVhdGlvbiB3aWxsXG4gICAgICAgICAqIGhhdmUgdGhlIGVmZmVjdCBvZiB1bndpbmRpbmcgYWxsIGNob2ljZXMgYW5kIGNvbGxlY3RpbmcgbWFya3MgYWxvbmdcbiAgICAgICAgICogdGhlIHdheS4gKilcbiAgICAgICAgaWYgcG9zIDwgSW5wdXQucGFyc2VyX2NvbW1pdHRlZF9ieXRlcyBpbnB1dCcgdGhlblxuICAgICAgICAgIGZhaWwgaW5wdXQnIHBvcycgbW9yZSBtYXJrcyBtc2dcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHEucnVuIGlucHV0JyBwb3MgbW9yZScgZmFpbCBzdWNjIGluXG4gICAgICBwLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsJyBzdWNjXG4gICAgfVxuZW5kXG5cbm1vZHVsZSBNb25hZF91c2VfZm9yX2RlYnVnZ2luZyA9IHN0cnVjdFxuICBsZXQgcmV0dXJuID0gTW9uYWQucmV0dXJuXG4gIGxldCBmYWlsICAgPSBNb25hZC5mYWlsXG4gIGxldCAoPj49KSAgPSBNb25hZC4oPj49KVxuXG4gIGxldCAoPj58KSBtIGYgPSBtID4+PSBmdW4geCAtPiByZXR1cm4gKGYgeClcblxuICBsZXQgKDwkPikgZiBtID0gbSA+PnwgZlxuICBsZXQgKDwqPikgZiBtID0gZiA+Pj0gZnVuIGYgLT4gbSA+PnwgZlxuXG4gIGxldCBsaWZ0ICA9ICg+PnwpXG4gIGxldCBsaWZ0MiBmIG0xIG0yICAgICAgID0gZiA8JD4gbTEgPCo+IG0yXG4gIGxldCBsaWZ0MyBmIG0xIG0yIG0zICAgID0gZiA8JD4gbTEgPCo+IG0yIDwqPiBtM1xuICBsZXQgbGlmdDQgZiBtMSBtMiBtMyBtNCA9IGYgPCQ+IG0xIDwqPiBtMiA8Kj4gbTMgPCo+IG00XG5cbiAgbGV0ICggKj4pIGEgYiA9IGEgPj49IGZ1biBfIC0+IGJcbiAgbGV0ICg8KiApIGEgYiA9IGEgPj49IGZ1biB4IC0+IGIgPj58IGZ1biBfIC0+IHhcbmVuZFxuIiwidHlwZSB0ID1cbiAgeyBtdXRhYmxlIGJ1ZiA6IEJpZ3N0cmluZ2FmLnRcbiAgOyBtdXRhYmxlIG9mZiA6IGludFxuICA7IG11dGFibGUgbGVuIDogaW50IH1cblxubGV0IG9mX2JpZ3N0cmluZyB+b2ZmIH5sZW4gYnVmID1cbiAgYXNzZXJ0IChvZmYgPj0gMCk7XG4gIGFzc2VydCAoQmlnc3RyaW5nYWYubGVuZ3RoIGJ1ZiA+PSBsZW4gLSBvZmYpO1xuICB7IGJ1Zjsgb2ZmOyBsZW4gfVxuXG5sZXQgY3JlYXRlIGxlbiA9XG4gIG9mX2JpZ3N0cmluZyB+b2ZmOjAgfmxlbjowIChCaWdzdHJpbmdhZi5jcmVhdGUgbGVuKVxuXG5sZXQgd3JpdGFibGVfc3BhY2UgdCA9XG4gIEJpZ3N0cmluZ2FmLmxlbmd0aCB0LmJ1ZiAtIHQubGVuXG5cbmxldCB0cmFpbGluZ19zcGFjZSB0ID1cbiAgQmlnc3RyaW5nYWYubGVuZ3RoIHQuYnVmIC0gKHQub2ZmICsgdC5sZW4pXG5cbmxldCBjb21wcmVzcyB0ID1cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2JsaXQgdC5idWYgfnNyY19vZmY6dC5vZmYgdC5idWYgfmRzdF9vZmY6MCB+bGVuOnQubGVuO1xuICB0Lm9mZiA8LSAwXG5cbmxldCBncm93IHQgdG9fY29weSA9XG4gIGxldCBvbGRfbGVuID0gQmlnc3RyaW5nYWYubGVuZ3RoIHQuYnVmIGluXG4gIGxldCBuZXdfbGVuID0gcmVmIG9sZF9sZW4gaW5cbiAgbGV0IHNwYWNlID0gd3JpdGFibGVfc3BhY2UgdCBpblxuICB3aGlsZSBzcGFjZSArICFuZXdfbGVuIC0gb2xkX2xlbiA8IHRvX2NvcHkgZG9cbiAgICBuZXdfbGVuIDo9ICgzICogIW5ld19sZW4pIC8gMlxuICBkb25lO1xuICBsZXQgbmV3X2J1ZiA9IEJpZ3N0cmluZ2FmLmNyZWF0ZSAhbmV3X2xlbiBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfYmxpdCB0LmJ1ZiB+c3JjX29mZjp0Lm9mZiBuZXdfYnVmIH5kc3Rfb2ZmOjAgfmxlbjp0LmxlbjtcbiAgdC5idWYgPC0gbmV3X2J1ZjtcbiAgdC5vZmYgPC0gMFxuXG5sZXQgZW5zdXJlIHQgdG9fY29weSA9XG4gIGlmIHRyYWlsaW5nX3NwYWNlIHQgPCB0b19jb3B5IHRoZW5cbiAgICBpZiB3cml0YWJsZV9zcGFjZSB0ID49IHRvX2NvcHlcbiAgICB0aGVuIGNvbXByZXNzIHRcbiAgICBlbHNlIGdyb3cgdCB0b19jb3B5XG5cbmxldCB3cml0ZV9wb3MgdCA9XG4gIHQub2ZmICsgdC5sZW5cblxubGV0IGZlZWRfc3RyaW5nIHQgfm9mZiB+bGVuIHN0ciA9XG4gIGFzc2VydCAob2ZmID49IDApO1xuICBhc3NlcnQgKFN0cmluZy5sZW5ndGggc3RyID49IGxlbiAtIG9mZik7XG4gIGVuc3VyZSB0IGxlbjtcbiAgQmlnc3RyaW5nYWYudW5zYWZlX2JsaXRfZnJvbV9zdHJpbmcgc3RyIH5zcmNfb2ZmOm9mZiB0LmJ1ZiB+ZHN0X29mZjood3JpdGVfcG9zIHQpIH5sZW47XG4gIHQubGVuIDwtIHQubGVuICsgbGVuXG5cbmxldCBmZWVkX2JpZ3N0cmluZyB0IH5vZmYgfmxlbiBiID1cbiAgYXNzZXJ0IChvZmYgPj0gMCk7XG4gIGFzc2VydCAoQmlnc3RyaW5nYWYubGVuZ3RoIGIgPj0gbGVuIC0gb2ZmKTtcbiAgZW5zdXJlIHQgbGVuO1xuICBCaWdzdHJpbmdhZi51bnNhZmVfYmxpdCBiIH5zcmNfb2ZmOm9mZiB0LmJ1ZiB+ZHN0X29mZjood3JpdGVfcG9zIHQpIH5sZW47XG4gIHQubGVuIDwtIHQubGVuICsgbGVuXG5cbmxldCBmZWVkX2lucHV0IHQgPSBmdW5jdGlvblxuICB8IGBTdHJpbmcgICAgcyAtPiBmZWVkX3N0cmluZyAgICB0IH5vZmY6MCB+bGVuOihTdHJpbmcgICAgIC5sZW5ndGggcykgc1xuICB8IGBCaWdzdHJpbmcgYiAtPiBmZWVkX2JpZ3N0cmluZyB0IH5vZmY6MCB+bGVuOihCaWdzdHJpbmdhZi5sZW5ndGggYikgYlxuXG5sZXQgc2hpZnQgdCBuID1cbiAgYXNzZXJ0ICh0LmxlbiA+PSBuKTtcbiAgdC5vZmYgPC0gdC5vZmYgKyBuO1xuICB0LmxlbiA8LSB0LmxlbiAtIG5cblxubGV0IGZvcl9yZWFkaW5nIHsgYnVmOyBvZmY7IGxlbiB9ID1cbiAgQmlnc3RyaW5nYWYuc3ViIH5vZmYgfmxlbiBidWZcblxubW9kdWxlIFVuY29uc3VtZWQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGJ1ZiA6IEJpZ3N0cmluZ2FmLnRcbiAgICA7IG9mZiA6IGludFxuICAgIDsgbGVuIDogaW50IH1cbmVuZFxuXG5sZXQgdW5jb25zdW1lZCA/KHNoaWZ0PTApIHsgYnVmOyBvZmY7IGxlbiB9ID1cbiAgYXNzZXJ0IChsZW4gPj0gc2hpZnQpO1xuICB7IFVuY29uc3VtZWQuYnVmOyBvZmYgPSBvZmYgKyBzaGlmdDsgbGVuID0gbGVuIC0gc2hpZnQgfVxuXG5sZXQgb2ZfdW5jb25zdW1lZCB7IFVuY29uc3VtZWQuYnVmOyBvZmY7IGxlbiB9ID1cbiAgeyBidWY7IG9mZjsgbGVuIH1cblxudHlwZSB1bmNvbnN1bWVkID0gVW5jb25zdW1lZC50ID1cbiAgeyBidWYgOiBCaWdzdHJpbmdhZi50XG4gIDsgb2ZmIDogaW50XG4gIDsgbGVuIDogaW50IH1cbiIsIigqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENvcHlyaWdodCAoYykgMjAxNiBJbmhhYml0ZWQgVHlwZSBMTEMuXG5cbiAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gICAgYXJlIG1ldDpcblxuICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXG4gICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvciBub3IgdGhlIG5hbWVzIG9mIGhpcyBjb250cmlidXRvcnNcbiAgICAgICBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiAgICAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gICAgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbiAgICBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gICAgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG4gICAgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICAgIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gICAgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pXG4gICAgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULFxuICAgIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTlxuICAgIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICAgIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKilcblxubW9kdWxlIEJpZ2FycmF5ID0gc3RydWN0XG4gICgqIERvIG5vdCBhY2Nlc3MgQmlnYXJyYXkgb3BlcmF0aW9ucyBkaXJlY3RseS4gSWYgYW55dGhpbmcncyBuZWVkZWQsIHJlZmVyIHRvXG4gICAqIHRoZSBpbnRlcm5hbCBCaWdzdHJpbmcgbW9kdWxlLiAqKVxuZW5kXG5cbnR5cGUgYmlnc3RyaW5nID0gQmlnc3RyaW5nYWYudFxuXG5cbm1vZHVsZSBVbmJ1ZmZlcmVkID0gc3RydWN0XG4gIGluY2x1ZGUgUGFyc2VyXG5cbiAgaW5jbHVkZSBFeHBvcnRlZF9zdGF0ZVxuXG4gIHR5cGUgbW9yZSA9IE1vcmUudCA9XG4gICAgfCBDb21wbGV0ZVxuICAgIHwgSW5jb21wbGV0ZVxuZW5kXG5cbmluY2x1ZGUgVW5idWZmZXJlZFxuaW5jbHVkZSBQYXJzZXIuTW9uYWRcbmluY2x1ZGUgUGFyc2VyLkNob2ljZVxuXG5tb2R1bGUgQnVmZmVyZWQgPSBzdHJ1Y3RcbiAgdHlwZSB1bmNvbnN1bWVkID0gQnVmZmVyaW5nLnVuY29uc3VtZWQgPVxuICAgIHsgYnVmIDogYmlnc3RyaW5nXG4gICAgOyBvZmYgOiBpbnRcbiAgICA7IGxlbiA6IGludCB9XG5cbiAgdHlwZSBpbnB1dCA9XG4gICAgWyBgQmlnc3RyaW5nIG9mIGJpZ3N0cmluZ1xuICAgIHwgYFN0cmluZyAgICBvZiBzdHJpbmcgXVxuXG4gIHR5cGUgJ2Egc3RhdGUgPVxuICAgIHwgUGFydGlhbCBvZiAoWyBpbnB1dCB8IGBFb2YgXSAtPiAnYSBzdGF0ZSlcbiAgICB8IERvbmUgICAgb2YgdW5jb25zdW1lZCAqICdhXG4gICAgfCBGYWlsICAgIG9mIHVuY29uc3VtZWQgKiBzdHJpbmcgbGlzdCAqIHN0cmluZ1xuXG4gIGxldCBmcm9tX3VuYnVmZmVyZWRfc3RhdGUgfmYgYnVmZmVyaW5nID0gZnVuY3Rpb25cbiAgICB8IFVuYnVmZmVyZWQuUGFydGlhbCBwICAgICAgICAgLT4gUGFydGlhbCAoZiBwKVxuICAgIHwgVW5idWZmZXJlZC5Eb25lKGNvbnN1bWVkLCB2KSAtPlxuICAgICAgbGV0IHVuY29uc3VtZWQgPSBCdWZmZXJpbmcudW5jb25zdW1lZCB+c2hpZnQ6Y29uc3VtZWQgYnVmZmVyaW5nIGluXG4gICAgICBEb25lKHVuY29uc3VtZWQsIHYpXG4gICAgfCBVbmJ1ZmZlcmVkLkZhaWwoY29uc3VtZWQsIG1hcmtzLCBtc2cpIC0+XG4gICAgICBsZXQgdW5jb25zdW1lZCA9IEJ1ZmZlcmluZy51bmNvbnN1bWVkIH5zaGlmdDpjb25zdW1lZCBidWZmZXJpbmcgaW5cbiAgICAgIEZhaWwodW5jb25zdW1lZCwgbWFya3MsIG1zZylcblxuICBsZXQgcGFyc2UgPyhpbml0aWFsX2J1ZmZlcl9zaXplPTB4MTAwMCkgcCA9XG4gICAgaWYgaW5pdGlhbF9idWZmZXJfc2l6ZSA8IDEgdGhlblxuICAgICAgZmFpbHdpdGggXCJwYXJzZTogaW52YWxpZCBhcmd1bWVudCwgaW5pdGlhbF9idWZmZXJfc2l6ZSA8IDFcIjtcbiAgICBsZXQgYnVmZmVyaW5nID0gQnVmZmVyaW5nLmNyZWF0ZSBpbml0aWFsX2J1ZmZlcl9zaXplIGluXG4gICAgbGV0IHJlYyBmIHAgaW5wdXQgPVxuICAgICAgQnVmZmVyaW5nLnNoaWZ0IGJ1ZmZlcmluZyBwLmNvbW1pdHRlZDtcbiAgICAgIGxldCBtb3JlIDogTW9yZS50ID1cbiAgICAgICAgbWF0Y2ggaW5wdXQgd2l0aFxuICAgICAgICB8IGBFb2YgICAgICAgICAgICAtPiBDb21wbGV0ZVxuICAgICAgICB8ICNpbnB1dCBhcyBpbnB1dCAtPlxuICAgICAgICAgIEJ1ZmZlcmluZy5mZWVkX2lucHV0IGJ1ZmZlcmluZyBpbnB1dDtcbiAgICAgICAgICBJbmNvbXBsZXRlXG4gICAgICBpblxuICAgICAgbGV0IGZvcl9yZWFkaW5nID0gQnVmZmVyaW5nLmZvcl9yZWFkaW5nIGJ1ZmZlcmluZyBpblxuICAgICAgcC5jb250aW51ZSBmb3JfcmVhZGluZyB+b2ZmOjAgfmxlbjooQmlnc3RyaW5nYWYubGVuZ3RoIGZvcl9yZWFkaW5nKSBtb3JlXG4gICAgICB8PiBmcm9tX3VuYnVmZmVyZWRfc3RhdGUgYnVmZmVyaW5nIH5mXG4gICAgaW5cbiAgICBVbmJ1ZmZlcmVkLnBhcnNlIHBcbiAgICB8PiBmcm9tX3VuYnVmZmVyZWRfc3RhdGUgYnVmZmVyaW5nIH5mXG5cbiAgbGV0IGZlZWQgc3RhdGUgaW5wdXQgPVxuICAgIG1hdGNoIHN0YXRlIHdpdGhcbiAgICB8IFBhcnRpYWwgayAtPiBrIGlucHV0XG4gICAgfCBGYWlsKHVuY29uc3VtZWQsIG1hcmtzLCBtc2cpIC0+XG4gICAgICBiZWdpbiBtYXRjaCBpbnB1dCB3aXRoXG4gICAgICB8IGBFb2YgICAtPiBzdGF0ZVxuICAgICAgfCAjaW5wdXQgYXMgaW5wdXQgLT5cbiAgICAgICAgbGV0IGJ1ZmZlcmluZyA9IEJ1ZmZlcmluZy5vZl91bmNvbnN1bWVkIHVuY29uc3VtZWQgaW5cbiAgICAgICAgQnVmZmVyaW5nLmZlZWRfaW5wdXQgYnVmZmVyaW5nIGlucHV0O1xuICAgICAgICBGYWlsKEJ1ZmZlcmluZy51bmNvbnN1bWVkIGJ1ZmZlcmluZywgbWFya3MsIG1zZylcbiAgICAgIGVuZFxuICAgIHwgRG9uZSh1bmNvbnN1bWVkLCB2KSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggaW5wdXQgd2l0aFxuICAgICAgfCBgRW9mICAgLT4gc3RhdGVcbiAgICAgIHwgI2lucHV0IGFzIGlucHV0IC0+XG4gICAgICAgIGxldCBidWZmZXJpbmcgPSBCdWZmZXJpbmcub2ZfdW5jb25zdW1lZCB1bmNvbnN1bWVkIGluXG4gICAgICAgIEJ1ZmZlcmluZy5mZWVkX2lucHV0IGJ1ZmZlcmluZyBpbnB1dDtcbiAgICAgICAgRG9uZShCdWZmZXJpbmcudW5jb25zdW1lZCBidWZmZXJpbmcsIHYpXG4gICAgICBlbmRcblxuICBsZXQgc3RhdGVfdG9fb3B0aW9uID0gZnVuY3Rpb25cbiAgICB8IERvbmUoXywgdikgLT4gU29tZSB2XG4gICAgfCBQYXJ0aWFsIF8gIC0+IE5vbmVcbiAgICB8IEZhaWwgXyAgICAgLT4gTm9uZVxuXG4gIGxldCBzdGF0ZV90b19yZXN1bHQgPSBmdW5jdGlvblxuICAgIHwgUGFydGlhbCBfICAgICAgICAgICAtPiBFcnJvciBcImluY29tcGxldGUgaW5wdXRcIlxuICAgIHwgRG9uZShfLCB2KSAgICAgICAgICAtPiBPayB2XG4gICAgfCBGYWlsKF8sIG1hcmtzLCBtc2cpIC0+IEVycm9yIChVbmJ1ZmZlcmVkLmZhaWxfdG9fc3RyaW5nIG1hcmtzIG1zZylcblxuICBsZXQgc3RhdGVfdG9fdW5jb25zdW1lZCA9IGZ1bmN0aW9uXG4gICAgfCBEb25lKHVuY29uc3VtZWQsIF8pXG4gICAgfCBGYWlsKHVuY29uc3VtZWQsIF8sIF8pIC0+IFNvbWUgdW5jb25zdW1lZFxuICAgIHwgUGFydGlhbCBfICAgICAgICAgICAgICAtPiBOb25lXG5cbmVuZFxuXG4oKiogQkVHSU46IGdldHRpbmcgaW5wdXQgKilcblxubGV0IHJlYyBwcm9tcHQgaW5wdXQgcG9zIGZhaWwgc3VjYyA9XG4gICgqIFtwcm9tcHRdIHNob3VsZCBvbmx5IGNhbGwgW3N1Y2NdIGlmIGl0IGhhcyByZWNlaXZlZCBtb3JlIGlucHV0LiBJZiB0aGVyZVxuICAgKiBpcyBubyBjaGFuY2UgdGhhdCB0aGUgaW5wdXQgd2lsbCBncm93LCBpLmUuLCBbbW9yZSA9IENvbXBsZXRlXSwgdGhlblxuICAgKiBbcHJvbXB0XSBzaG91bGQgY2FsbCBbZmFpbF0uIE90aGVyd2lzZSAoaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIGlucHV0XG4gICAqIGhhc24ndCBncm93biBidXQgW21vcmUgPSBJbmNvbXBsZXRlXSBqdXN0IHByb21wdCBhZ2Fpbi4gKilcbiAgbGV0IHBhcnNlcl91bmNvbW1pdHRlZF9ieXRlcyA9IElucHV0LnBhcnNlcl91bmNvbW1pdHRlZF9ieXRlcyBpbnB1dCBpblxuICBsZXQgcGFyc2VyX2NvbW1pdHRlZF9ieXRlcyAgID0gSW5wdXQucGFyc2VyX2NvbW1pdHRlZF9ieXRlcyAgIGlucHV0IGluXG4gICgqIFRoZSBjb250aW51YXRpb24gc2hvdWxkIG5vdCBob2xkIGFueSByZWZlcmVuY2VzIHRvIGlucHV0IGFib3ZlLiAqKVxuICBsZXQgY29udGludWUgaW5wdXQgfm9mZiB+bGVuIG1vcmUgPVxuICAgIGlmIGxlbiA8IHBhcnNlcl91bmNvbW1pdHRlZF9ieXRlcyB0aGVuXG4gICAgICBmYWlsd2l0aCBcInByb21wdDogaW5wdXQgc2hydW5rIVwiO1xuICAgIGxldCBpbnB1dCA9IElucHV0LmNyZWF0ZSBpbnB1dCB+b2ZmIH5sZW4gfmNvbW1pdHRlZF9ieXRlczpwYXJzZXJfY29tbWl0dGVkX2J5dGVzIGluXG4gICAgaWYgbGVuID0gcGFyc2VyX3VuY29tbWl0dGVkX2J5dGVzIHRoZW5cbiAgICAgIG1hdGNoIChtb3JlIDogTW9yZS50KSB3aXRoXG4gICAgICB8IENvbXBsZXRlICAgLT4gZmFpbCBpbnB1dCBwb3MgTW9yZS5Db21wbGV0ZVxuICAgICAgfCBJbmNvbXBsZXRlIC0+IHByb21wdCBpbnB1dCBwb3MgZmFpbCBzdWNjXG4gICAgZWxzZVxuICAgICAgc3VjYyBpbnB1dCBwb3MgbW9yZVxuICBpblxuICBTdGF0ZS5QYXJ0aWFsIHsgY29tbWl0dGVkID0gSW5wdXQuYnl0ZXNfZm9yX2NsaWVudF90b19jb21taXQgaW5wdXQ7IGNvbnRpbnVlIH1cblxubGV0IGRlbWFuZF9pbnB1dCA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIG1hdGNoIChtb3JlIDogTW9yZS50KSB3aXRoXG4gICAgfCBDb21wbGV0ZSAgIC0+IGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJub3QgZW5vdWdoIGlucHV0XCJcbiAgICB8IEluY29tcGxldGUgLT5cbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyA9IHN1Y2MgaW5wdXQnIHBvcycgbW9yZScgKClcbiAgICAgIGFuZCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyA9IGZhaWwgaW5wdXQnIHBvcycgbW9yZScgW10gXCJub3QgZW5vdWdoIGlucHV0XCIgaW5cbiAgICAgIHByb21wdCBpbnB1dCBwb3MgZmFpbCcgc3VjYydcbiAgfVxuXG5sZXQgZW5zdXJlX3N1c3BlbmRlZCBuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyA9XG4gIGxldCByZWMgZ28gPVxuICAgIHsgcnVuID0gZnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwnIHN1Y2MnIC0+XG4gICAgICBpZiBwb3MnICsgbiA8PSBJbnB1dC5sZW5ndGggaW5wdXQnIHRoZW5cbiAgICAgICAgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgKClcbiAgICAgIGVsc2VcbiAgICAgICAgKGRlbWFuZF9pbnB1dCAqPiBnbykucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwnIHN1Y2MnXG4gICAgfVxuICBpblxuICAoZGVtYW5kX2lucHV0ICo+IGdvKS5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjXG5cbmxldCB1bnNhZmVfYXBwbHkgbGVuIH5mID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgX2ZhaWwgc3VjYyAtPlxuICAgIHN1Y2MgaW5wdXQgKHBvcyArIGxlbikgbW9yZSAoSW5wdXQuYXBwbHkgaW5wdXQgcG9zIGxlbiB+ZilcbiAgfVxuXG5sZXQgdW5zYWZlX2FwcGx5X29wdCBsZW4gfmYgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBtYXRjaCBJbnB1dC5hcHBseSBpbnB1dCBwb3MgbGVuIH5mIHdpdGhcbiAgICB8IEVycm9yIGUgLT4gZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBlXG4gICAgfCBPayAgICB4IC0+IHN1Y2MgaW5wdXQgKHBvcyArIGxlbikgbW9yZSB4XG4gIH1cblxubGV0IGVuc3VyZSBuIHAgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBpZiBwb3MgKyBuIDw9IElucHV0Lmxlbmd0aCBpbnB1dFxuICAgIHRoZW4gcC5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjXG4gICAgZWxzZVxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnICgpID0gcC5ydW4gaW5wdXQnIHBvcycgbW9yZScgZmFpbCBzdWNjIGluXG4gICAgICBlbnN1cmVfc3VzcGVuZGVkIG4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJyB9XG5cbigqKiBFTkQ6IGdldHRpbmcgaW5wdXQgKilcblxubGV0IGF0X2VuZF9vZl9pbnB1dCA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF8gc3VjYyAtPlxuICAgIGlmIHBvcyA8IElucHV0Lmxlbmd0aCBpbnB1dCB0aGVuXG4gICAgICBzdWNjIGlucHV0IHBvcyBtb3JlIGZhbHNlXG4gICAgZWxzZSBtYXRjaCBtb3JlIHdpdGhcbiAgICB8IENvbXBsZXRlIC0+IHN1Y2MgaW5wdXQgcG9zIG1vcmUgdHJ1ZVxuICAgIHwgSW5jb21wbGV0ZSAtPlxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnID0gc3VjYyBpbnB1dCcgcG9zJyBtb3JlJyBmYWxzZVxuICAgICAgYW5kIGZhaWwnIGlucHV0JyBwb3MnIG1vcmUnID0gc3VjYyBpbnB1dCcgcG9zJyBtb3JlJyB0cnVlIGluXG4gICAgICBwcm9tcHQgaW5wdXQgcG9zIGZhaWwnIHN1Y2MnXG4gIH1cblxubGV0IGVuZF9vZl9pbnB1dCA9XG4gIGF0X2VuZF9vZl9pbnB1dFxuICA+Pj0gZnVuY3Rpb25cbiAgICB8IHRydWUgIC0+IHJldHVybiAoKVxuICAgIHwgZmFsc2UgLT4gZmFpbCBcImVuZF9vZl9pbnB1dFwiXG5cbmxldCBhZHZhbmNlIG4gPVxuICBpZiBuIDwgMFxuICB0aGVuIGZhaWwgXCJhZHZhbmNlXCJcbiAgZWxzZVxuICAgIGxldCBwID1cbiAgICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT4gc3VjYyBpbnB1dCAocG9zICsgbikgbW9yZSAoKSB9XG4gICAgaW5cbiAgICBlbnN1cmUgbiBwXG5cbmxldCBwb3MgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+IHN1Y2MgaW5wdXQgcG9zIG1vcmUgcG9zIH1cblxubGV0IGF2YWlsYWJsZSA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT5cbiAgICBzdWNjIGlucHV0IHBvcyBtb3JlIChJbnB1dC5sZW5ndGggaW5wdXQgLSBwb3MpXG4gIH1cblxubGV0IGNvbW1pdCA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT5cbiAgICBJbnB1dC5jb21taXQgaW5wdXQgcG9zO1xuICAgIHN1Y2MgaW5wdXQgcG9zIG1vcmUgKCkgfVxuXG4oKiBEbyBub3QgdXNlIHRoaXMgaWYgW3BdIGNvbnRhaW5zIGEgW2NvbW1pdF0uICopXG5sZXQgdW5zYWZlX2xvb2thaGVhZCBwID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgbGV0IHN1Y2MnIGlucHV0JyBfIG1vcmUnIHYgPSBzdWNjIGlucHV0JyBwb3MgbW9yZScgdiBpblxuICAgIHAucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYycgfVxuXG5sZXQgcGVla19jaGFyID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgX2ZhaWwgc3VjYyAtPlxuICAgIGlmIHBvcyA8IElucHV0Lmxlbmd0aCBpbnB1dCB0aGVuXG4gICAgICBzdWNjIGlucHV0IHBvcyBtb3JlIChTb21lIChJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zKSlcbiAgICBlbHNlIGlmIG1vcmUgPSBDb21wbGV0ZSB0aGVuXG4gICAgICBzdWNjIGlucHV0IHBvcyBtb3JlIE5vbmVcbiAgICBlbHNlXG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgPVxuICAgICAgICBzdWNjIGlucHV0JyBwb3MnIG1vcmUnIChTb21lIChJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQnIHBvcycpKVxuICAgICAgYW5kIGZhaWwnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgc3VjYyBpbnB1dCcgcG9zJyBtb3JlJyBOb25lIGluXG4gICAgICBwcm9tcHQgaW5wdXQgcG9zIGZhaWwnIHN1Y2MnXG4gIH1cblxuKCogVGhpcyBwYXJzZXIgaXMgdG9vIGltcG9ydGFudCB0byBub3QgYmUgb3B0aW1pemVkLiBEbyBhIGN1c3RvbSBqb2IuICopXG5sZXQgcmVjIHBlZWtfY2hhcl9mYWlsID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgaWYgcG9zIDwgSW5wdXQubGVuZ3RoIGlucHV0XG4gICAgdGhlbiBzdWNjIGlucHV0IHBvcyBtb3JlIChJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zKVxuICAgIGVsc2VcbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyAoKSA9XG4gICAgICAgIHBlZWtfY2hhcl9mYWlsLnJ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsIHN1Y2MgaW5cbiAgICAgIGVuc3VyZV9zdXNwZW5kZWQgMSBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MnIH1cblxubGV0IHNhdGlzZnkgZiA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGlmIHBvcyA8IElucHV0Lmxlbmd0aCBpbnB1dCB0aGVuXG4gICAgICBsZXQgYyA9IElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCBwb3MgaW5cbiAgICAgIGlmIGYgY1xuICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlIGNcbiAgICAgIGVsc2UgUHJpbnRmLmtzcHJpbnRmIChmYWlsIGlucHV0IHBvcyBtb3JlIFtdKSBcInNhdGlzZnk6ICVDXCIgY1xuICAgIGVsc2VcbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyAoKSA9XG4gICAgICAgIGxldCBjID0gSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0JyBwb3MnIGluXG4gICAgICAgIGlmIGYgY1xuICAgICAgICB0aGVuIHN1Y2MgaW5wdXQnIChwb3MnICsgMSkgbW9yZScgY1xuICAgICAgICBlbHNlIFByaW50Zi5rc3ByaW50ZiAoZmFpbCBpbnB1dCcgcG9zJyBtb3JlJyBbXSkgXCJzYXRpc2Z5OiAlQ1wiIGNcbiAgICAgIGluXG4gICAgICBlbnN1cmVfc3VzcGVuZGVkIDEgaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJyB9XG5cbmxldCBjaGFyIGMgPVxuICBsZXQgcCA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBpZiBJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zID0gY1xuICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlIGNcbiAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSAoUHJpbnRmLnNwcmludGYgXCJjaGFyICVDXCIgYykgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCBub3RfY2hhciBjID1cbiAgbGV0IHAgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IGMnID0gSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcyBpblxuICAgICAgaWYgYyA8PiBjJ1xuICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlIGMnXG4gICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gKFByaW50Zi5zcHJpbnRmIFwibm90IGNoYXIgJUNcIiBjKSB9XG4gIGluXG4gIGVuc3VyZSAxIHBcblxubGV0IGFueV9jaGFyID1cbiAgbGV0IHAgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT5cbiAgICAgIHN1Y2MgaW5wdXQgKHBvcyArIDEpIG1vcmUgKElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCBwb3MpICB9XG4gIGluXG4gIGVuc3VyZSAxIHBcblxubGV0IGludDggaSA9XG4gIGxldCBwID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBjID0gQ2hhci5jb2RlIChJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zKSBpblxuICAgICAgaWYgYyA9IGkgbGFuZCAweGZmXG4gICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIDEpIG1vcmUgY1xuICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIChQcmludGYuc3ByaW50ZiBcImludDggJWRcIiBpKSB9XG4gIGluXG4gIGVuc3VyZSAxIHBcblxubGV0IGFueV91aW50OCA9XG4gIGxldCBwID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgYyA9IElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCBwb3MgaW5cbiAgICAgIHN1Y2MgaW5wdXQgKHBvcyArIDEpIG1vcmUgKENoYXIuY29kZSBjKSB9XG4gIGluXG4gIGVuc3VyZSAxIHBcblxubGV0IGFueV9pbnQ4ID1cbiAgKCogaHR0cHM6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvfnNlYW5kZXIvYml0aGFja3MuaHRtbCNWYXJpYWJsZVNpZ25FeHRlbmRSaXNreSAqKVxuICBsZXQgcyA9IFN5cy5pbnRfc2l6ZSAtIDggaW5cbiAgbGV0IHAgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBjID0gSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcyBpblxuICAgICAgc3VjYyBpbnB1dCAocG9zICsgMSkgbW9yZSAoKENoYXIuY29kZSBjIGxzbCBzKSBhc3IgcykgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCBza2lwIGYgPVxuICBsZXQgcCA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBpZiBmIChJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zKVxuICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlICgpXG4gICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJza2lwXCIgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCByZWMgY291bnRfd2hpbGUgfmluaXQgfmYgfndpdGhfYnVmZmVyID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgbGV0IGxlbiAgICAgICAgID0gSW5wdXQuY291bnRfd2hpbGUgaW5wdXQgKHBvcyArIGluaXQpIH5mIGluXG4gICAgbGV0IGlucHV0X2xlbiAgID0gSW5wdXQubGVuZ3RoIGlucHV0IGluXG4gICAgbGV0IGluaXQnICAgICAgID0gaW5pdCArIGxlbiBpblxuICAgICgqIENoZWNrIGlmIHRoZSBsb29wIHRlcm1pbmF0ZWQgYmVjYXVzZSBpdCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGlucHV0XG4gICAgICogYnVmZmVyLiBJZiBzbywgdGhlbiBwcm9tcHQgZm9yIGFkZGl0aW9uYWwgaW5wdXQgYW5kIGNvbnRpbnVlLiAqKVxuICAgIGlmIHBvcyArIGluaXQnIDwgaW5wdXRfbGVuIHx8IG1vcmUgPSBDb21wbGV0ZVxuICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgaW5pdCcpIG1vcmUgKElucHV0LmFwcGx5IGlucHV0IHBvcyBpbml0JyB+Zjp3aXRoX2J1ZmZlcilcbiAgICBlbHNlXG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgPVxuICAgICAgICAoY291bnRfd2hpbGUgfmluaXQ6aW5pdCcgfmYgfndpdGhfYnVmZmVyKS5ydW4gaW5wdXQnIHBvcycgbW9yZScgZmFpbCBzdWNjXG4gICAgICBhbmQgZmFpbCcgaW5wdXQnIHBvcycgbW9yZScgPVxuICAgICAgICBzdWNjIGlucHV0JyAocG9zJyArIGluaXQnKSBtb3JlJyAoSW5wdXQuYXBwbHkgaW5wdXQnIHBvcycgaW5pdCcgfmY6d2l0aF9idWZmZXIpXG4gICAgICBpblxuICAgICAgcHJvbXB0IGlucHV0IHBvcyBmYWlsJyBzdWNjJ1xuICB9XG5cbmxldCByZWMgY291bnRfd2hpbGUxIH5mIH53aXRoX2J1ZmZlciA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGxldCBsZW4gICAgICAgICA9IElucHV0LmNvdW50X3doaWxlIGlucHV0IHBvcyB+ZiBpblxuICAgIGxldCBpbnB1dF9sZW4gICA9IElucHV0Lmxlbmd0aCBpbnB1dCBpblxuICAgICgqIENoZWNrIGlmIHRoZSBsb29wIHRlcm1pbmF0ZWQgYmVjYXVzZSBpdCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGlucHV0XG4gICAgICogYnVmZmVyLiBJZiBzbywgdGhlbiBwcm9tcHQgZm9yIGFkZGl0aW9uYWwgaW5wdXQgYW5kIGNvbnRpbnVlLiAqKVxuICAgIGlmIGxlbiA8IDFcbiAgICB0aGVuXG4gICAgICBpZiBwb3MgPCBpbnB1dF9sZW4gfHwgbW9yZSA9IENvbXBsZXRlXG4gICAgICB0aGVuIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJjb3VudF93aGlsZTFcIlxuICAgICAgZWxzZVxuICAgICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgPVxuICAgICAgICAgIChjb3VudF93aGlsZTEgfmYgfndpdGhfYnVmZmVyKS5ydW4gaW5wdXQnIHBvcycgbW9yZScgZmFpbCBzdWNjXG4gICAgICAgIGFuZCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyA9XG4gICAgICAgICAgZmFpbCBpbnB1dCcgcG9zJyBtb3JlJyBbXSBcImNvdW50X3doaWxlMVwiXG4gICAgICAgIGluXG4gICAgICAgIHByb21wdCBpbnB1dCBwb3MgZmFpbCcgc3VjYydcbiAgICBlbHNlIGlmIHBvcyArIGxlbiA8IGlucHV0X2xlbiB8fCBtb3JlID0gQ29tcGxldGVcbiAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIGxlbikgbW9yZSAoSW5wdXQuYXBwbHkgaW5wdXQgcG9zIGxlbiB+Zjp3aXRoX2J1ZmZlcilcbiAgICBlbHNlXG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgPVxuICAgICAgICAoY291bnRfd2hpbGUgfmluaXQ6bGVuIH5mIH53aXRoX2J1ZmZlcikucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwgc3VjY1xuICAgICAgYW5kIGZhaWwnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgc3VjYyBpbnB1dCcgKHBvcycgKyBsZW4pIG1vcmUnIChJbnB1dC5hcHBseSBpbnB1dCcgcG9zJyBsZW4gfmY6d2l0aF9idWZmZXIpXG4gICAgICBpblxuICAgICAgcHJvbXB0IGlucHV0IHBvcyBmYWlsJyBzdWNjJ1xuICB9XG5cbmxldCBzdHJpbmdfIGYgcyA9XG4gICgqIFhYWChzZWxpb3BvdSk6IEluZWZmaWNpZW50LiBDb3VsZCBjaGVjayBwcmVmaXggZXF1YWxpdHkgdG8gc2hvcnQtY2lyY3VpdFxuICAgKiB0aGUgaW8uICopXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgZW5zdXJlICBsZW4gKHVuc2FmZV9hcHBseV9vcHQgbGVuIH5mOihmdW4gYnVmZmVyIH5vZmYgfmxlbiAtPlxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICB3aGlsZSAhaSA8IGxlbiAmJiBDaGFyLmVxdWFsIChmIChCaWdzdHJpbmdhZi51bnNhZmVfZ2V0IGJ1ZmZlciAob2ZmICsgIWkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmIChTdHJpbmcudW5zYWZlX2dldCBzICFpKSlcbiAgICBkb1xuICAgICAgaW5jciBpXG4gICAgZG9uZTtcbiAgICBpZiBsZW4gPSAhaVxuICAgIHRoZW4gT2sgKEJpZ3N0cmluZ2FmLnN1YnN0cmluZyBidWZmZXIgfm9mZiB+bGVuKVxuICAgIGVsc2UgRXJyb3IgXCJzdHJpbmdcIikpXG5cbmxldCBzdHJpbmcgcyAgICA9IHN0cmluZ18gKGZ1biB4IC0+IHgpIHNcbmxldCBzdHJpbmdfY2kgcyA9IHN0cmluZ18gQ2hhci5sb3dlcmNhc2VfYXNjaWkgc1xuXG5sZXQgc2tpcF93aGlsZSBmID1cbiAgY291bnRfd2hpbGUgfmluaXQ6MCB+ZiB+d2l0aF9idWZmZXI6KGZ1biBfIH5vZmY6XyB+bGVuOl8gLT4gKCkpXG5cbmxldCB0YWtlIG4gPVxuICBpZiBuIDwgMFxuICB0aGVuIGZhaWwgXCJ0YWtlOiBuIDwgMFwiXG4gIGVsc2VcbiAgICBsZXQgbiA9IG1heCBuIDAgaW5cbiAgICBlbnN1cmUgbiAodW5zYWZlX2FwcGx5IG4gfmY6Qmlnc3RyaW5nYWYuc3Vic3RyaW5nKVxuXG5sZXQgdGFrZV9iaWdzdHJpbmcgbiA9XG4gIGlmIG4gPCAwXG4gIHRoZW4gZmFpbCBcInRha2VfYmlnc3RyaW5nOiBuIDwgMFwiXG4gIGVsc2VcbiAgICBsZXQgbiA9IG1heCBuIDAgaW5cbiAgICBlbnN1cmUgbiAodW5zYWZlX2FwcGx5IG4gfmY6Qmlnc3RyaW5nYWYuY29weSlcblxubGV0IHRha2VfYmlnc3RyaW5nX3doaWxlIGYgPVxuICBjb3VudF93aGlsZSB+aW5pdDowIH5mIH53aXRoX2J1ZmZlcjpCaWdzdHJpbmdhZi5jb3B5XG5cbmxldCB0YWtlX2JpZ3N0cmluZ193aGlsZTEgZiA9XG4gIGNvdW50X3doaWxlMSB+ZiB+d2l0aF9idWZmZXI6Qmlnc3RyaW5nYWYuY29weVxuXG5sZXQgdGFrZV9iaWdzdHJpbmdfdGlsbCBmID1cbiAgdGFrZV9iaWdzdHJpbmdfd2hpbGUgKGZ1biBjIC0+IG5vdCAoZiBjKSlcblxubGV0IHBlZWtfc3RyaW5nIG4gPVxuICB1bnNhZmVfbG9va2FoZWFkICh0YWtlIG4pXG5cbmxldCB0YWtlX3doaWxlIGYgPVxuICBjb3VudF93aGlsZSB+aW5pdDowIH5mIH53aXRoX2J1ZmZlcjpCaWdzdHJpbmdhZi5zdWJzdHJpbmdcblxubGV0IHRha2Vfd2hpbGUxIGYgPVxuICBjb3VudF93aGlsZTEgfmYgfndpdGhfYnVmZmVyOkJpZ3N0cmluZ2FmLnN1YnN0cmluZ1xuXG5sZXQgdGFrZV90aWxsIGYgPVxuICB0YWtlX3doaWxlIChmdW4gYyAtPiBub3QgKGYgYykpXG5cbmxldCBjaG9pY2UgPyhmYWlsdXJlX21zZz1cIm5vIG1vcmUgY2hvaWNlc1wiKSBwcyA9XG4gIExpc3QuZm9sZF9yaWdodCAoPHw+KSBwcyAoZmFpbCBmYWlsdXJlX21zZylcblxubGV0IGZpeF9kaXJlY3QgZiA9XG4gIGxldCByZWMgcCA9IGxhenkgKGYgcilcbiAgYW5kIHIgPSB7IHJ1biA9IGZ1biBidWYgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgKExhenkuZm9yY2UgcCkucnVuIGJ1ZiBwb3MgbW9yZSBmYWlsIHN1Y2MgfVxuICBpblxuICByXG5cbmxldCBmaXhfbGF6eSB+bWF4X3N0ZXBzIGYgPVxuICBsZXQgc3RlcHMgPSByZWYgbWF4X3N0ZXBzIGluXG4gIGxldCByZWMgcCA9IGxhenkgKGYgcilcbiAgYW5kIHIgPSB7IHJ1biA9IGZ1biBidWYgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgZGVjciBzdGVwcztcbiAgICBpZiAhc3RlcHMgPCAwXG4gICAgdGhlbiAoXG4gICAgICBzdGVwcyA6PSBtYXhfc3RlcHM7XG4gICAgICBTdGF0ZS5MYXp5IChsYXp5ICgoTGF6eS5mb3JjZSBwKS5ydW4gYnVmIHBvcyBtb3JlIGZhaWwgc3VjYykpKVxuICAgIGVsc2VcbiAgICAgIChMYXp5LmZvcmNlIHApLnJ1biBidWYgcG9zIG1vcmUgZmFpbCBzdWNjXG4gICAgICAgICAgfVxuICBpblxuICByXG5cbmxldCBmaXggPSBtYXRjaCBTeXMuYmFja2VuZF90eXBlIHdpdGhcbiAgfCBOYXRpdmUgLT4gZml4X2RpcmVjdFxuICB8IEJ5dGVjb2RlIC0+IGZpeF9kaXJlY3RcbiAgfCBPdGhlciBfIC0+IGZ1biBmIC0+IGZpeF9sYXp5IH5tYXhfc3RlcHM6MjAgZlxuXG5sZXQgb3B0aW9uIHggcCA9XG4gIHAgPHw+IHJldHVybiB4XG5cbmxldCBjb25zIHggeHMgPSB4IDo6IHhzXG5cbmxldCByZWMgbGlzdCBwcyA9XG4gIG1hdGNoIHBzIHdpdGhcbiAgfCBbXSAgICAtPiByZXR1cm4gW11cbiAgfCBwOjpwcyAtPiBsaWZ0MiBjb25zIHAgKGxpc3QgcHMpXG5cbmxldCBjb3VudCBuIHAgPVxuICBpZiBuIDwgMFxuICB0aGVuIGZhaWwgXCJjb3VudDogbiA8IDBcIlxuICBlbHNlXG4gICAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICAgIHwgMCAtPiByZXR1cm4gW11cbiAgICAgIHwgbiAtPiBsaWZ0MiBjb25zIHAgKGxvb3AgKG4gLSAxKSlcbiAgICBpblxuICAgIGxvb3AgblxuXG5sZXQgbWFueSBwID1cbiAgZml4IChmdW4gbSAtPlxuICAgIChsaWZ0MiBjb25zIHAgbSkgPHw+IHJldHVybiBbXSlcblxubGV0IG1hbnkxIHAgPVxuICBsaWZ0MiBjb25zIHAgKG1hbnkgcClcblxubGV0IG1hbnlfdGlsbCBwIHQgPVxuICBmaXggKGZ1biBtIC0+XG4gICAgKHQgKj4gcmV0dXJuIFtdKSA8fD4gKGxpZnQyIGNvbnMgcCBtKSlcblxubGV0IHNlcF9ieTEgcyBwID1cbiAgZml4IChmdW4gbSAtPlxuICAgIGxpZnQyIGNvbnMgcCAoKHMgKj4gbSkgPHw+IHJldHVybiBbXSkpXG5cbmxldCBzZXBfYnkgcyBwID1cbiAgKGxpZnQyIGNvbnMgcCAoKHMgKj4gc2VwX2J5MSBzIHApIDx8PiByZXR1cm4gW10pKSA8fD4gcmV0dXJuIFtdXG5cbmxldCBza2lwX21hbnkgcCA9XG4gIGZpeCAoZnVuIG0gLT5cbiAgICAgICgocCA+PnwgZnVuIF8gLT4gdHJ1ZSkgPHw+IHJldHVybiBmYWxzZSkgPj49IGZ1bmN0aW9uXG4gICAgICB8IHRydWUgLT4gbVxuICAgICAgfCBmYWxzZSAtPiByZXR1cm4gKClcbiAgICApXG5cbmxldCBza2lwX21hbnkxIHAgPVxuICBwICo+IHNraXBfbWFueSBwXG5cbmxldCBlbmRfb2ZfbGluZSA9XG4gIChjaGFyICdcXG4nICo+IHJldHVybiAoKSkgPHw+IChzdHJpbmcgXCJcXHJcXG5cIiAqPiByZXR1cm4gKCkpIDw/PiBcImVuZF9vZl9saW5lXCJcblxubGV0IHNjYW5fIHN0YXRlIGYgfndpdGhfYnVmZmVyID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgbGV0IHN0YXRlID0gcmVmIHN0YXRlIGluXG4gICAgbGV0IHBhcnNlciA9XG4gICAgICBjb3VudF93aGlsZSB+aW5pdDowIH5mOihmdW4gYyAtPlxuICAgICAgICBtYXRjaCBmICFzdGF0ZSBjIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGZhbHNlXG4gICAgICAgIHwgU29tZSBzdGF0ZScgLT4gc3RhdGUgOj0gc3RhdGUnOyB0cnVlKVxuICAgICAgfndpdGhfYnVmZmVyXG4gICAgICA+PnwgZnVuIHggLT4geCwgIXN0YXRlXG4gICAgaW5cbiAgICBwYXJzZXIucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyB9XG5cbmxldCBzY2FuIHN0YXRlIGYgPVxuICBzY2FuXyBzdGF0ZSBmIH53aXRoX2J1ZmZlcjpCaWdzdHJpbmdhZi5zdWJzdHJpbmdcblxubGV0IHNjYW5fc3RhdGUgc3RhdGUgZiA9XG4gIHNjYW5fIHN0YXRlIGYgfndpdGhfYnVmZmVyOihmdW4gXyB+b2ZmOl8gfmxlbjpfIC0+ICgpKVxuICA+PnwgZnVuICgoKSwgc3RhdGUpIC0+IHN0YXRlXG5cbmxldCBzY2FuX3N0cmluZyBzdGF0ZSBmID1cbiAgc2NhbiBzdGF0ZSBmID4+fCBmc3RcblxubGV0IGNvbnN1bWVfd2l0aCBwIGYgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBsZXQgc3RhcnQgPSBwb3MgaW5cbiAgICBsZXQgcGFyc2VyX2NvbW1pdHRlZF9ieXRlcyA9IElucHV0LnBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgaW5wdXQgIGluXG4gICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnIF8gPVxuICAgICAgaWYgcGFyc2VyX2NvbW1pdHRlZF9ieXRlcyA8PiBJbnB1dC5wYXJzZXJfY29tbWl0dGVkX2J5dGVzIGlucHV0J1xuICAgICAgdGhlbiBmYWlsIGlucHV0JyBwb3MnIG1vcmUnIFtdIFwiY29uc3VtZWQ6IHBhcnNlciBjb21taXR0ZWRcIlxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBsZW4gPSBwb3MnIC0gc3RhcnQgaW5cbiAgICAgICAgbGV0IGNvbnN1bWVkID0gSW5wdXQuYXBwbHkgaW5wdXQnIHN0YXJ0IGxlbiB+ZiBpblxuICAgICAgICBzdWNjIGlucHV0JyBwb3MnIG1vcmUnIGNvbnN1bWVkKVxuICAgIGluXG4gICAgcC5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJ1xuICB9XG5cbmxldCBjb25zdW1lZCAgICAgICAgICAgcCA9IGNvbnN1bWVfd2l0aCBwIEJpZ3N0cmluZ2FmLnN1YnN0cmluZ1xubGV0IGNvbnN1bWVkX2JpZ3N0cmluZyBwID0gY29uc3VtZV93aXRoIHAgQmlnc3RyaW5nYWYuY29weVxuXG5sZXQgYm90aCBhIGIgPSBsaWZ0MiAoZnVuIGEgYiAtPiBhLCBiKSBhIGJcbmxldCBtYXAgdCB+ZiA9IHQgPj58IGZcbmxldCBiaW5kIHQgfmYgPSB0ID4+PSBmXG5sZXQgbWFwMiBhIGIgfmYgPSBsaWZ0MiBmIGEgYlxubGV0IG1hcDMgYSBiIGMgfmYgPSBsaWZ0MyBmIGEgYiBjXG5sZXQgbWFwNCBhIGIgYyBkIH5mID0gbGlmdDQgZiBhIGIgYyBkXG5cbm1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gIGxldCByZXR1cm4gPSByZXR1cm5cbiAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gIGxldCAoID4+PSApID0gKCA+Pj0gKVxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCBtYXAgPSBtYXBcbiAgICBsZXQgYmluZCA9IGJpbmRcbiAgICBsZXQgYm90aCA9IGJvdGhcbiAgICBsZXQgbWFwMiA9IG1hcDJcbiAgICBsZXQgbWFwMyA9IG1hcDNcbiAgICBsZXQgbWFwNCA9IG1hcDRcbiAgZW5kXG5lbmRcblxubGV0ICggbGV0KyApID0gKCA+PnwgKVxubGV0ICggbGV0KiApID0gKCA+Pj0gKVxubGV0ICggYW5kKyApID0gYm90aFxuXG5tb2R1bGUgQkUgPSBzdHJ1Y3RcbiAgKCogWFhYKHNlbGlvcG91KTogVGhlIHBhdHRlcm4gaW4gYm90aCB0aGlzIG1vZHVsZSBhbmQgW0xFXSBhcmUgYSBjb21wcm9taXNlXG4gICAqIGJldHdlZW4gZWZmaWNpZW5jeSBhbmQgY29kZSByZXVzZS4gQnkgaW5saW5pbmcgW2Vuc3VyZV0geW91IGNhbiByZWNvdmVyXG4gICAqIGFib3V0IDIgbmFub3NlY29uZHMgb24gYXZlcmFnZS4gVGhhdCBtYXkgYWRkIHVwIGluIGNlcnRhaW4gYXBwbGljYXRpb25zLlxuICAgKlxuICAgKiBUaGlzIHBhdHRlcm4gZG9lcyBub3QgYWxsb2NhdGUgaW4gdGhlIGZhc3QgKHN1Y2Nlc3MpIHBhdGguXG4gICAqICopXG4gIGxldCBpbnQxNiBuID1cbiAgICBsZXQgYnl0ZXMgPSAyIGluXG4gICAgbGV0IHAgPVxuICAgICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICAgIGlmIElucHV0LnVuc2FmZV9nZXRfaW50MTZfYmUgaW5wdXQgcG9zID0gKG4gbGFuZCAweGZmZmYpXG4gICAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgYnl0ZXMpIG1vcmUgKClcbiAgICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwiQkUuaW50MTZcIiB9XG4gICAgaW5cbiAgICBlbnN1cmUgYnl0ZXMgcFxuXG4gIGxldCBpbnQzMiBuID1cbiAgICBsZXQgYnl0ZXMgPSA0IGluXG4gICAgbGV0IHAgPVxuICAgICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICAgIGlmIEludDMyLmVxdWFsIChJbnB1dC51bnNhZmVfZ2V0X2ludDMyX2JlIGlucHV0IHBvcykgblxuICAgICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIGJ5dGVzKSBtb3JlICgpXG4gICAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBcIkJFLmludDMyXCIgfVxuICAgIGluXG4gICAgZW5zdXJlIGJ5dGVzIHBcblxuICBsZXQgaW50NjQgbiA9XG4gICAgbGV0IGJ5dGVzID0gOCBpblxuICAgIGxldCBwID1cbiAgICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgICBpZiBJbnQ2NC5lcXVhbCAoSW5wdXQudW5zYWZlX2dldF9pbnQ2NF9iZSBpbnB1dCBwb3MpIG5cbiAgICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyBieXRlcykgbW9yZSAoKVxuICAgICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJCRS5pbnQ2NFwiIH1cbiAgICBpblxuICAgIGVuc3VyZSBieXRlcyBwXG5cbiAgbGV0IGFueV91aW50MTYgPVxuICAgIGVuc3VyZSAyICh1bnNhZmVfYXBwbHkgMiB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MTZfYmUgYnMgb2ZmKSlcblxuICBsZXQgYW55X2ludDE2ICA9XG4gICAgZW5zdXJlIDIgKHVuc2FmZV9hcHBseSAyIH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQxNl9zaWduX2V4dGVuZGVkX2JlICBicyBvZmYpKVxuXG4gIGxldCBhbnlfaW50MzIgID1cbiAgICBlbnN1cmUgNCAodW5zYWZlX2FwcGx5IDQgfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDMyX2JlIGJzIG9mZikpXG5cbiAgbGV0IGFueV9pbnQ2NCA9XG4gICAgZW5zdXJlIDggKHVuc2FmZV9hcHBseSA4IH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQ2NF9iZSBicyBvZmYpKVxuXG4gIGxldCBhbnlfZmxvYXQgPVxuICAgIGVuc3VyZSA0ICh1bnNhZmVfYXBwbHkgNCB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEludDMyLmZsb2F0X29mX2JpdHMgKEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MzJfYmUgYnMgb2ZmKSkpXG5cbiAgbGV0IGFueV9kb3VibGUgPVxuICAgIGVuc3VyZSA4ICh1bnNhZmVfYXBwbHkgOCB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEludDY0LmZsb2F0X29mX2JpdHMgKEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50NjRfYmUgYnMgb2ZmKSkpXG5lbmRcblxubW9kdWxlIExFID0gc3RydWN0XG4gIGxldCBpbnQxNiBuID1cbiAgICBsZXQgYnl0ZXMgPSAyIGluXG4gICAgbGV0IHAgPVxuICAgICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICAgIGlmIElucHV0LnVuc2FmZV9nZXRfaW50MTZfbGUgaW5wdXQgcG9zID0gKG4gbGFuZCAweGZmZmYpXG4gICAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgYnl0ZXMpIG1vcmUgKClcbiAgICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwiTEUuaW50MTZcIiB9XG4gICAgaW5cbiAgICBlbnN1cmUgYnl0ZXMgcFxuXG4gIGxldCBpbnQzMiBuID1cbiAgICBsZXQgYnl0ZXMgPSA0IGluXG4gICAgbGV0IHAgPVxuICAgICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICAgIGlmIEludDMyLmVxdWFsIChJbnB1dC51bnNhZmVfZ2V0X2ludDMyX2xlIGlucHV0IHBvcykgblxuICAgICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIGJ5dGVzKSBtb3JlICgpXG4gICAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBcIkxFLmludDMyXCIgfVxuICAgIGluXG4gICAgZW5zdXJlIGJ5dGVzIHBcblxuICBsZXQgaW50NjQgbiA9XG4gICAgbGV0IGJ5dGVzID0gOCBpblxuICAgIGxldCBwID1cbiAgICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgICBpZiBJbnQ2NC5lcXVhbCAoSW5wdXQudW5zYWZlX2dldF9pbnQ2NF9sZSBpbnB1dCBwb3MpIG5cbiAgICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyBieXRlcykgbW9yZSAoKVxuICAgICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJMRS5pbnQ2NFwiIH1cbiAgICBpblxuICAgIGVuc3VyZSBieXRlcyBwXG5cblxuICBsZXQgYW55X3VpbnQxNiA9XG4gICAgZW5zdXJlIDIgKHVuc2FmZV9hcHBseSAyIH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQxNl9sZSBicyBvZmYpKVxuXG4gIGxldCBhbnlfaW50MTYgID1cbiAgICBlbnN1cmUgMiAodW5zYWZlX2FwcGx5IDIgfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDE2X3NpZ25fZXh0ZW5kZWRfbGUgIGJzIG9mZikpXG5cbiAgbGV0IGFueV9pbnQzMiAgPVxuICAgIGVuc3VyZSA0ICh1bnNhZmVfYXBwbHkgNCB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MzJfbGUgYnMgb2ZmKSlcblxuICBsZXQgYW55X2ludDY0ID1cbiAgICBlbnN1cmUgOCAodW5zYWZlX2FwcGx5IDggfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDY0X2xlIGJzIG9mZikpXG5cbiAgbGV0IGFueV9mbG9hdCA9XG4gICAgZW5zdXJlIDQgKHVuc2FmZV9hcHBseSA0IH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gSW50MzIuZmxvYXRfb2ZfYml0cyAoQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQzMl9sZSBicyBvZmYpKSlcblxuICBsZXQgYW55X2RvdWJsZSA9XG4gICAgZW5zdXJlIDggKHVuc2FmZV9hcHBseSA4IH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gSW50NjQuZmxvYXRfb2ZfYml0cyAoQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQ2NF9sZSBicyBvZmYpKSlcbmVuZFxuXG5tb2R1bGUgVW5zYWZlID0gc3RydWN0XG4gIGxldCB0YWtlIG4gZiA9XG4gICAgbGV0IG4gPSBtYXggbiAwIGluXG4gICAgZW5zdXJlIG4gKHVuc2FmZV9hcHBseSBuIH5mKVxuXG4gIGxldCBwZWVrIG4gZiA9XG4gICAgdW5zYWZlX2xvb2thaGVhZCAodGFrZSBuIGYpXG5cbiAgbGV0IHRha2Vfd2hpbGUgY2hlY2sgZiA9XG4gICAgY291bnRfd2hpbGUgfmluaXQ6MCB+ZjpjaGVjayB+d2l0aF9idWZmZXI6ZlxuXG4gIGxldCB0YWtlX3doaWxlMSBjaGVjayBmID1cbiAgICBjb3VudF93aGlsZTEgfmY6Y2hlY2sgfndpdGhfYnVmZmVyOmZcblxuICBsZXQgdGFrZV90aWxsIGNoZWNrIGYgPVxuICAgIHRha2Vfd2hpbGUgKGZ1biBjIC0+IG5vdCAoY2hlY2sgYykpIGZcbmVuZFxuXG5tb2R1bGUgQ29uc3VtZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgUHJlZml4XG4gICAgfCBBbGxcbmVuZFxuXG5sZXQgcGFyc2VfYmlnc3RyaW5nIH5jb25zdW1lIHAgYnMgPVxuICBsZXQgcCA9XG4gICAgbWF0Y2ggKGNvbnN1bWUgOiBDb25zdW1lLnQpIHdpdGhcbiAgICB8IFByZWZpeCAtPiBwXG4gICAgfCBBbGwgLT4gcCA8KiBlbmRfb2ZfaW5wdXRcbiAgaW5cbiAgVW5idWZmZXJlZC5wYXJzZV9iaWdzdHJpbmcgcCBic1xuXG5sZXQgcGFyc2Vfc3RyaW5nIH5jb25zdW1lIHAgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGJzICA9IEJpZ3N0cmluZ2FmLmNyZWF0ZSBsZW4gaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2JsaXRfZnJvbV9zdHJpbmcgcyB+c3JjX29mZjowIGJzIH5kc3Rfb2ZmOjAgfmxlbjtcbiAgcGFyc2VfYmlnc3RyaW5nIH5jb25zdW1lIHAgYnNcbiJdfQ==
