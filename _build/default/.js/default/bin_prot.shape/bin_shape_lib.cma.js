// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1+5.8.1

//# unitInfo: Provides: Bin_shape_lib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Bin_shape_lib = [0];
   runtime.caml_register_global(0, Bin_shape_lib, "Bin_shape_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Bin_shape_lib__Bin_shape
//# unitInfo: Requires: Assert_failure, Base, Base__Comparator, Base__Int, Base__List, Base__Map, Base__Option, Base__Printf, Base__String, Md5_lib, Ppx_compare_lib, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Annotate = "Annotate",
    cst_Application = "Application",
    cst_Base = "Base",
    cst_Exp = "Exp",
    cst_Poly_variant = "Poly_variant",
    cst_Rec_app = "Rec_app",
    cst_Record = "Record",
    cst_Tuple = "Tuple",
    cst_Var = "Var",
    cst_Variant = "Variant",
    cst_annotate$0 = "annotate",
    cst_application$0 = "application",
    cst_base$0 = "base",
    cst_exp = "exp",
    cst_poly_variant$0 = "poly_variant",
    cst_rec_app$0 = "rec_app",
    cst_record$0 = "record",
    cst_sorted$0 = "sorted",
    cst_tuple$0 = "tuple",
    cst_var$0 = "var",
    cst_variant$0 = "variant",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_compare = runtime.caml_string_compare,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    error_source_026 = "shape/src/bin_shape.ml.Sorted_table.t",
    error_source_042 = "shape/src/bin_shape.ml.Canonical_exp_constructor.t",
    error_source_206 = "shape/src/bin_shape.ml.Canonical_full.Exp1.t0",
    Assert_failure = global_data.Assert_failure,
    Base_List = global_data.Base__List,
    Base = global_data.Base,
    Base_Option = global_data.Base__Option,
    Base_Map = global_data.Base__Map,
    Base_Comparator = global_data.Base__Comparator,
    Ppx_compare_lib = global_data.Ppx_compare_lib,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_String = global_data.Base__String,
    Base_Int = global_data.Base__Int,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Printf = global_data.Base__Printf,
    Md5_lib = global_data.Md5_lib,
    sexp_of_t = Base_String[28],
    of_string = Base_String[29],
    to_string = Base_String[30],
    t_of_sexp = Base_String[27],
    sexp_of_t$0 = Base_String[28],
    of_string$0 = Base_String[29],
    to_string$0 = Base_String[30],
    compare = Base_String[37],
    cst_Location_s = "%{Location}: %s",
    _a_ = [11, ": ", [2, 0, 0]],
    _b_ = [0, 0],
    _e_ = [0, 17724, 0],
    _f_ =
      [0,
       [11,
        "Different shapes for duplicated polymorphic constructor: `",
        [2, 0, 0]],
       "Different shapes for duplicated polymorphic constructor: `%s"];
   function eval_fail(loc, fmt){
    return caml_call2
            (Base_Printf[4],
             function(s){
              var
               _dP_ =
                 caml_call3
                  (Base_Printf[2],
                   [0,
                    [24,
                     _b_,
                     function(param, custom_printf_001){
                      return caml_call1(to_string, custom_printf_001);
                     },
                     _a_],
                    cst_Location_s],
                   loc,
                   s);
              return caml_call1(Base[200], _dP_);
             },
             fmt);
   }
   function equal_option(equal, a, b){
    if(a){
     if(b){var y = b[1], x = a[1]; return caml_call2(equal, x, y);}
    }
    else if(! b) return 1;
    return 0;
   }
   function create(loc, eq, xs$1){
    var
     sorted =
       caml_call2
        (Base_List[62],
         xs$1,
         function(param, _dO_){
          var s2 = _dO_[1], s1 = param[1];
          return caml_call2(Base_String[37], s1, s2);
         });
    if(sorted){
     var
      xs$0 = sorted[2],
      match$0 = sorted[1],
      last_value$1 = match$0[2],
      last_key$1 = match$0[1],
      acc$1 = [0, [0, last_key$1, last_value$1], 0],
      acc = acc$1,
      last_key = last_key$1,
      last_value = last_value$1,
      param = xs$0;
     for(;;){
      if(! param){
       var match$1 = [0, 17724, caml_call1(Base_List[38], acc)];
       break;
      }
      var
       xs = param[2],
       match = param[1],
       last_value$0 = match[2],
       last_key$0 = match[1];
      if(caml_call2(Base_String[33], last_key, last_key$0)){
       if(! caml_call2(eq, last_value, last_value$0)){
        var match$1 = [0, -1062743954, last_key$0];
        break;
       }
       param = xs;
      }
      else{
       var acc$0 = [0, [0, last_key$0, last_value$0], acc];
       acc = acc$0;
       last_key = last_key$0;
       last_value = last_value$0;
       param = xs;
      }
     }
    }
    else
     var match$1 = _e_;
    if(17724 <= match$1[1]){var sorted$0 = match$1[2]; return [0, sorted$0];}
    var s = match$1[2];
    return caml_call2(eval_fail(loc, _f_), s, 0);
   }
   function map(t, f){
    return [0,
            caml_call2
             (Base_List[76],
              t[1],
              function(param){
               var v = param[2], k = param[1];
               return [0, k, caml_call1(f, v)];
              })];
   }
   var
    compare$0 = Md5_lib[1],
    to_binary = Md5_lib[3],
    to_hex = Md5_lib[6],
    of_hex_exn = Md5_lib[7],
    string = Md5_lib[8],
    _c_ = [0, "shape/src/bin_shape.ml", 33, 2],
    cst_sorted = cst_sorted$0,
    _d_ = [0, cst_sorted$0],
    _g_ = [0, ""],
    cst_some = "some",
    cst_none = "none",
    _h_ = [0, cst_Annotate],
    _i_ = [0, cst_Base],
    _j_ = [0, cst_Tuple],
    _k_ = [0, cst_Record],
    _l_ = [0, cst_Variant],
    _m_ = [0, cst_Poly_variant],
    _n_ = [0, cst_Application],
    _o_ = [0, cst_Rec_app],
    _p_ = [0, cst_Var],
    _q_ = [0, "..."],
    cst_annotate = cst_annotate$0,
    cst_base = cst_base$0,
    cst_tuple = cst_tuple$0,
    cst_record = cst_record$0,
    cst_variant = cst_variant$0,
    cst_poly_variant = cst_poly_variant$0,
    cst_application = cst_application$0,
    cst_rec_app = cst_rec_app$0,
    cst_var = cst_var$0;
   function to_md5(t){return t;}
   function of_md5(t){return t;}
   function sexp_of_t$1(t){
    var _dN_ = caml_call1(to_hex, t);
    return caml_call1(Base[164], _dN_);
   }
   function t_of_sexp$0(s){
    return caml_call1(of_hex_exn, caml_call1(Base[163], s));
   }
   function uuid(u){return caml_call1(string, caml_call1(to_string$0, u));}
   function int$0(x){return caml_call1(string, caml_call1(Base_Int[11], x));}
   function pair(x, y){
    var _dL_ = caml_call1(to_binary, y), _dM_ = caml_call1(to_binary, x);
    return caml_call1(string, caml_call2(Base[197], _dM_, _dL_));
   }
   function list(l){
    var _dK_ = caml_call2(Base_List[76], l, to_binary);
    return caml_call1(string, caml_call2(Base_String[54], _g_, _dK_));
   }
   function constructor(s, l){
    var _dJ_ = caml_call1(to_binary, list(l));
    return caml_call1(string, caml_call2(Base[197], s, _dJ_));
   }
   function t_of_sexp$1(of_a_039, sexp_044){
    a:
    {
     if(0 === sexp_044[0]){
      var
       _du_ = sexp_044[1],
       _dv_ = caml_string_compare(_du_, cst_annotate$0);
      b:
      {
       c:
       {
        d:
        {
         e:
         {
          f:
          {
           g:
           {
            h:
            {
             i:
             {
              if(0 <= _dv_){
               if(0 < _dv_){
                if(_du_ === cst_application$0) break i;
                if(_du_ === cst_base$0) break h;
                if(_du_ === cst_poly_variant$0) break g;
                if(_du_ === cst_rec_app$0) break f;
                if(_du_ === cst_record$0) break e;
                if(_du_ === cst_tuple$0) break d;
                if(_du_ === cst_var$0) break c;
                if(_du_ !== cst_variant$0) break a;
                break b;
               }
              }
              else if(_du_ !== cst_Annotate){
               if(_du_ === cst_Application) break i;
               if(_du_ === cst_Base) break h;
               if(_du_ === cst_Poly_variant) break g;
               if(_du_ === cst_Rec_app) break f;
               if(_du_ === cst_Record) break e;
               if(_du_ === cst_Tuple) break d;
               if(_du_ === cst_Var) break c;
               if(_du_ !== cst_Variant) break a;
               break b;
              }
              return caml_call2
                      (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
             }
             return caml_call2
                     (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
            }
            return caml_call2
                    (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
           }
           return caml_call2
                   (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
          }
          return caml_call2
                  (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
         }
         return caml_call2
                 (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
        }
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
       }
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
     }
     var _dw_ = sexp_044[1];
     if(! _dw_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_042, sexp_044);
     var _dx_ = _dw_[1];
     if(0 !== _dx_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_042, sexp_044);
     var
      tag_045 = _dx_[1],
      _dy_ = caml_string_compare(tag_045, cst_annotate$0);
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          g:
          {
           h:
           {
            i:
            {
             if(0 <= _dy_){
              if(0 < _dy_){
               if(tag_045 === cst_application$0) break i;
               if(tag_045 === cst_base$0) break h;
               if(tag_045 === cst_poly_variant$0) break g;
               if(tag_045 === cst_rec_app$0) break f;
               if(tag_045 === cst_record$0) break e;
               if(tag_045 === cst_tuple$0) break d;
               if(tag_045 === cst_var$0) break c;
               if(tag_045 !== cst_variant$0) break a;
               break b;
              }
             }
             else if(tag_045 !== cst_Annotate){
              if(tag_045 === cst_Application) break i;
              if(tag_045 === cst_Base) break h;
              if(tag_045 === cst_Poly_variant) break g;
              if(tag_045 === cst_Rec_app) break f;
              if(tag_045 === cst_Record) break e;
              if(tag_045 === cst_Tuple) break d;
              if(tag_045 === cst_Var) break c;
              if(tag_045 !== cst_Variant) break a;
              break b;
             }
             var sexp_args_046 = _dw_[2];
             if(sexp_args_046){
              var _dC_ = sexp_args_046[2];
              if(_dC_ && ! _dC_[2]){
               var
                arg1_048 = _dC_[1],
                arg0_047 = sexp_args_046[1],
                res0_049 = caml_call1(t_of_sexp, arg0_047),
                res1_050 = caml_call1(of_a_039, arg1_048);
               return [0, res0_049, res1_050];
              }
             }
             return caml_call3
                     (Sexplib0_Sexp_conv_error[4],
                      error_source_042,
                      tag_045,
                      sexp_044);
            }
            var sexp_args_090 = _dw_[2];
            if(sexp_args_090){
             var _dB_ = sexp_args_090[2];
             if(_dB_ && ! _dB_[2]){
              var
               arg1_092 = _dB_[1],
               arg0_091 = sexp_args_090[1],
               res0_093 = caml_call1(of_a_039, arg0_091),
               res1_094 = caml_call2(Base[138], of_a_039, arg1_092);
              return [6, res0_093, res1_094];
             }
            }
            return caml_call3
                    (Sexplib0_Sexp_conv_error[4],
                     error_source_042,
                     tag_045,
                     sexp_044);
           }
           var sexp_args_053 = _dw_[2];
           if(sexp_args_053){
            var _dA_ = sexp_args_053[2];
            if(_dA_ && ! _dA_[2]){
             var
              arg1_055 = _dA_[1],
              arg0_054 = sexp_args_053[1],
              res0_056 = caml_call1(t_of_sexp, arg0_054),
              res1_057 = caml_call2(Base[138], of_a_039, arg1_055);
             return [1, res0_056, res1_057];
            }
           }
           return caml_call3
                   (Sexplib0_Sexp_conv_error[4],
                    error_source_042,
                    tag_045,
                    sexp_044);
          }
          var sexp_args_085 = _dw_[2];
          if(sexp_args_085 && ! sexp_args_085[2]){
           var
            arg0_086 = sexp_args_085[1],
            of_a_010 = caml_call1(Base[151], of_a_039);
           if(0 === arg0_086[0])
            var
             res0_087 =
               caml_call2
                (Sexplib0_Sexp_conv_error[16], error_source_026, arg0_086);
           else{
            var
             field_sexps_013 = arg0_086[1],
             sorted_014 = [0, 0],
             duplicates_016 = [0, 0],
             extra_017 = [0, 0];
            g:
            {
             h:
             i:
             j:
             {
              k:
              {
               var param = field_sexps_013;
               for(;;){
                if(! param) break;
                var sexp_012 = param[1];
                if(1 !== sexp_012[0]) break h;
                var _ds_ = sexp_012[1];
                if(! _ds_) break i;
                var _dt_ = _ds_[1];
                if(0 !== _dt_[0]) break k;
                var field_sexps_020 = _ds_[2], field_name_018 = _dt_[1];
                if(field_sexps_020 && field_sexps_020[2]) break j;
                var tail_029 = param[2];
                if(field_name_018 !== cst_sorted$0){
                 if(Sexplib0_Sexp_conv[26][1])
                  extra_017[1] = [0, field_name_018, extra_017[1]];
                }
                else if(sorted_014[1])
                 duplicates_016[1] = [0, field_name_018, duplicates_016[1]];
                else{
                 if(field_sexps_020){
                  if(field_sexps_020[2])
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _c_], 1);
                  var x_030 = field_sexps_020[1], field_sexp_019 = x_030;
                 }
                 else
                  var
                   field_sexp_019 =
                     caml_call2
                      (Sexplib0_Sexp_conv_error[10], error_source_026, arg0_086);
                 var
                  fvalue_027 =
                    caml_call2
                     (Base[138],
                      function(sexp_025){
                       if(1 === sexp_025[0]){
                        var _dH_ = sexp_025[1];
                        if(_dH_){
                         var _dI_ = _dH_[2];
                         if(_dI_ && ! _dI_[2]){
                          var
                           arg1_022 = _dI_[1],
                           arg0_021 = _dH_[1],
                           res0_023 = caml_call1(Base[163], arg0_021),
                           res1_024 = caml_call1(of_a_010, arg1_022);
                          return [0, res0_023, res1_024];
                         }
                        }
                       }
                       return caml_call3
                               (Sexplib0_Sexp_conv_error[2], error_source_026, 2, sexp_025);
                      },
                      field_sexp_019);
                 sorted_014[1] = [0, fvalue_027];
                }
                param = tail_029;
               }
               break g;
              }
              break i;
             }
             caml_call2
              (Sexplib0_Sexp_conv_error[10], error_source_026, sexp_012);
            }
            if(duplicates_016[1])
             var
              res0_087 =
                caml_call3
                 (Sexplib0_Sexp_conv_error[12],
                  error_source_026,
                  duplicates_016[1],
                  arg0_086);
            else if(extra_017[1])
             var
              res0_087 =
                caml_call3
                 (Sexplib0_Sexp_conv_error[13],
                  error_source_026,
                  extra_017[1],
                  arg0_086);
            else{
             var match = sorted_014[1];
             if(match)
              var sorted_015 = match[1], res0_087 = [0, sorted_015];
             else
              var
               res0_087 =
                 caml_call3
                  (Sexplib0_Sexp_conv_error[15],
                   error_source_026,
                   arg0_086,
                   [0, [0, 0 === sorted_014[1] ? 1 : 0, cst_sorted], 0]);
            }
           }
           return [5, res0_087];
          }
          return caml_call3
                  (Sexplib0_Sexp_conv_error[4],
                   error_source_042,
                   tag_045,
                   sexp_044);
         }
         var sexp_args_097 = _dw_[2];
         if(sexp_args_097){
          var _dz_ = sexp_args_097[2];
          if(_dz_ && ! _dz_[2]){
           var
            arg1_099 = _dz_[1],
            arg0_098 = sexp_args_097[1],
            res0_100 = caml_call1(Base[118], arg0_098),
            res1_101 = caml_call2(Base[138], of_a_039, arg1_099);
           return [7, res0_100, res1_101];
          }
         }
         return caml_call3
                 (Sexplib0_Sexp_conv_error[4],
                  error_source_042,
                  tag_045,
                  sexp_044);
        }
        var sexp_args_065 = _dw_[2];
        if(sexp_args_065 && ! sexp_args_065[2]){
         var
          arg0_071 = sexp_args_065[1],
          res0_072 =
            caml_call2
             (Base[138],
              function(sexp_070){
               if(1 === sexp_070[0]){
                var _dF_ = sexp_070[1];
                if(_dF_){
                 var _dG_ = _dF_[2];
                 if(_dG_ && ! _dG_[2]){
                  var
                   arg1_067 = _dG_[1],
                   arg0_066 = _dF_[1],
                   res0_068 = caml_call1(Base[163], arg0_066),
                   res1_069 = caml_call1(of_a_039, arg1_067);
                  return [0, res0_068, res1_069];
                 }
                }
               }
               return caml_call3
                       (Sexplib0_Sexp_conv_error[2], error_source_042, 2, sexp_070);
              },
              arg0_071);
         return [3, res0_072];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[4],
                 error_source_042,
                 tag_045,
                 sexp_044);
       }
       var sexp_args_060 = _dw_[2];
       if(sexp_args_060 && ! sexp_args_060[2]){
        var
         arg0_061 = sexp_args_060[1],
         res0_062 = caml_call2(Base[138], of_a_039, arg0_061);
        return [2, res0_062];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[4],
                error_source_042,
                tag_045,
                sexp_044);
      }
      var sexp_args_104 = _dw_[2];
      if(sexp_args_104 && ! sexp_args_104[2]){
       var
        arg0_105 = sexp_args_104[1],
        res0_106 = caml_call1(Base[118], arg0_105);
       return [8, res0_106];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_042,
               tag_045,
               sexp_044);
     }
     var sexp_args_075 = _dw_[2];
     if(sexp_args_075 && ! sexp_args_075[2]){
      var
       arg0_081 = sexp_args_075[1],
       res0_082 =
         caml_call2
          (Base[138],
           function(sexp_080){
            if(1 === sexp_080[0]){
             var _dD_ = sexp_080[1];
             if(_dD_){
              var _dE_ = _dD_[2];
              if(_dE_ && ! _dE_[2]){
               var
                arg1_077 = _dE_[1],
                arg0_076 = _dD_[1],
                res0_078 = caml_call1(Base[163], arg0_076),
                res1_079 = caml_call2(Base[138], of_a_039, arg1_077);
               return [0, res0_078, res1_079];
              }
             }
            }
            return caml_call3
                    (Sexplib0_Sexp_conv_error[2], error_source_042, 2, sexp_080);
           },
           arg0_081);
      return [4, res0_082];
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[4],
              error_source_042,
              tag_045,
              sexp_044);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_042, sexp_044);
   }
   function sexp_of_t$2(of_a_108, param){
    switch(param[0]){
      case 0:
       var
        arg1_110 = param[2],
        arg0_109 = param[1],
        res0_111 = caml_call1(sexp_of_t$0, arg0_109),
        res1_112 = caml_call1(of_a_108, arg1_110);
       return [1, [0, _h_, [0, res0_111, [0, res1_112, 0]]]];
      case 1:
       var
        arg1_114 = param[2],
        arg0_113 = param[1],
        res0_115 = caml_call1(sexp_of_t$0, arg0_113),
        res1_116 = caml_call2(Base[139], of_a_108, arg1_114);
       return [1, [0, _i_, [0, res0_115, [0, res1_116, 0]]]];
      case 2:
       var
        arg0_117 = param[1],
        res0_118 = caml_call2(Base[139], of_a_108, arg0_117);
       return [1, [0, _j_, [0, res0_118, 0]]];
      case 3:
       var
        arg0_123 = param[1],
        res0_124 =
          caml_call2
           (Base[139],
            function(param){
             var
              arg1_120 = param[2],
              arg0_119 = param[1],
              res0_121 = caml_call1(Base[164], arg0_119),
              res1_122 = caml_call1(of_a_108, arg1_120);
             return [1, [0, res0_121, [0, res1_122, 0]]];
            },
            arg0_123);
       return [1, [0, _k_, [0, res0_124, 0]]];
      case 4:
       var
        arg0_129 = param[1],
        res0_130 =
          caml_call2
           (Base[139],
            function(param){
             var
              arg1_126 = param[2],
              arg0_125 = param[1],
              res0_127 = caml_call1(Base[164], arg0_125),
              res1_128 = caml_call2(Base[139], of_a_108, arg1_126);
             return [1, [0, res0_127, [0, res1_128, 0]]];
            },
            arg0_129);
       return [1, [0, _l_, [0, res0_130, 0]]];
      case 5:
       var
        arg0_131 = param[1],
        of_a_031 = caml_call1(Base[152], of_a_108),
        sorted_033 = arg0_131[1],
        arg_034 =
          caml_call2
           (Base[139],
            function(param){
             var
              arg1_036 = param[2],
              arg0_035 = param[1],
              res0_037 = caml_call1(Base[164], arg0_035),
              res1_038 = caml_call1(of_a_031, arg1_036);
             return [1, [0, res0_037, [0, res1_038, 0]]];
            },
            sorted_033),
        bnds_032 = [0, [1, [0, _d_, [0, arg_034, 0]]], 0],
        res0_132 = [1, bnds_032];
       return [1, [0, _m_, [0, res0_132, 0]]];
      case 6:
       var
        arg1_134 = param[2],
        arg0_133 = param[1],
        res0_135 = caml_call1(of_a_108, arg0_133),
        res1_136 = caml_call2(Base[139], of_a_108, arg1_134);
       return [1, [0, _n_, [0, res0_135, [0, res1_136, 0]]]];
      case 7:
       var
        arg1_138 = param[2],
        arg0_137 = param[1],
        res0_139 = caml_call1(Base[119], arg0_137),
        res1_140 = caml_call2(Base[139], of_a_108, arg1_138);
       return [1, [0, _o_, [0, res0_139, [0, res1_140, 0]]]];
      default:
       var arg0_141 = param[1], res0_142 = caml_call1(Base[119], arg0_141);
       return [1, [0, _p_, [0, res0_142, 0]]];
    }
   }
   function map$0(x, f){
    switch(x[0]){
      case 0:
       var x$0 = x[2], u = x[1]; return [0, u, caml_call1(f, x$0)];
      case 1:
       var xs = x[2], s = x[1];
       return [1, s, caml_call2(Base_List[76], xs, f)];
      case 2:
       var xs$0 = x[1]; return [2, caml_call2(Base_List[76], xs$0, f)];
      case 3:
       var l = x[1];
       return [3,
               caml_call2
                (Base_List[76],
                 l,
                 function(param){
                  var x = param[2], s = param[1];
                  return [0, s, caml_call1(f, x)];
                 })];
      case 4:
       var l$0 = x[1];
       return [4,
               caml_call2
                (Base_List[76],
                 l$0,
                 function(param){
                  var xs = param[2], s = param[1];
                  return [0, s, caml_call2(Base_List[76], xs, f)];
                 })];
      case 5:
       var t = x[1], _dp_ = Base_Option[21];
       return [5, map(t, function(_dr_){return caml_call2(_dp_, _dr_, f);})];
      case 6:
       var l$1 = x[2], x$1 = x[1], _dq_ = caml_call2(Base_List[76], l$1, f);
       return [6, caml_call1(f, x$1), _dq_];
      case 7:
       var l$2 = x[2], t$0 = x[1];
       return [7, t$0, caml_call2(Base_List[76], l$2, f)];
      default: var v = x[1]; return [8, v];
    }
   }
   function to_string$1(t){
    var _do_ = sexp_of_t$2(function(param){return _q_;}, t);
    return caml_call1(Base[84][15], _do_);
   }
   function digest_layer(param){
    switch(param[0]){
      case 0:
       var x = param[2], u = param[1];
       return constructor(cst_annotate, [0, uuid(u), [0, x, 0]]);
      case 1:
       var l = param[2], u$0 = param[1], _dk_ = [0, list(l), 0];
       return constructor(cst_base, [0, uuid(u$0), _dk_]);
      case 2:
       var l$0 = param[1]; return constructor(cst_tuple, [0, list(l$0), 0]);
      case 3:
       var l$1 = param[1];
       return constructor
               (cst_record,
                [0,
                 list
                  (caml_call2
                    (Base_List[76],
                     l$1,
                     function(param){
                      var t = param[2], s = param[1];
                      return pair(caml_call1(string, s), t);
                     })),
                 0]);
      case 4:
       var l$2 = param[1];
       return constructor
               (cst_variant,
                [0,
                 list
                  (caml_call2
                    (Base_List[76],
                     l$2,
                     function(param){
                      var l = param[2], s = param[1], _dn_ = list(l);
                      return pair(caml_call1(string, s), _dn_);
                     })),
                 0]);
      case 5:
       var table = param[1];
       return constructor
               (cst_poly_variant,
                [0,
                 list
                  (caml_call2
                    (Base_List[76],
                     table[1],
                     function(param){
                      var y = param[2], x$0 = param[1];
                      if(y)
                       var x = y[1], _dm_ = constructor(cst_some, [0, x, 0]);
                      else
                       var _dm_ = constructor(cst_none, 0);
                      return pair(caml_call1(string, x$0), _dm_);
                     })),
                 0]);
      case 6:
       var l$3 = param[2], x$0 = param[1];
       return constructor(cst_application, [0, x$0, [0, list(l$3), 0]]);
      case 7:
       var l$4 = param[2], n = param[1], _dl_ = [0, list(l$4), 0];
       return constructor(cst_rec_app, [0, int$0(n), _dl_]);
      default:
       var n$0 = param[1]; return constructor(cst_var, [0, int$0(n$0), 0]);
    }
   }
   function to_digest(param){var x = param[1]; return x;}
   function to_digest$0(x){
    switch(x[0]){
      case 0:
       var x$0 = x[1]; return digest_layer([5, x$0]);
      case 1:
       var x$1 = x[1][2]; return x$1;
      default: var x$2 = x[1]; return x$2;
    }
   }
   function equal(x, y){
    var _dj_ = to_digest$0(y);
    return 0 === caml_call2(compare$0, to_digest$0(x), _dj_) ? 1 : 0;
   }
   function opaque(x){return [2, to_digest$0(x)];}
   function create$0(x){
    var x$0 = map$0(x, to_digest$0), desc = to_string$1(x$0);
    switch(x$0[0]){
      case 0:
       return [1, [0, desc, digest_layer(x$0)]];
      case 1:
       return [1, [0, desc, digest_layer(x$0)]];
      case 5:
       var l = x$0[1]; return [0, l];
      case 6:
       return [1, [0, desc, digest_layer(x$0)]];
      case 7:
       return [1, [0, desc, digest_layer(x$0)]];
      default: return [1, [0, desc, digest_layer(x$0)]];
    }
   }
   function var$0(x){return create$0([8, x]);}
   function apply(def, l){return create$0([6, def, l]);}
   function recurse(tid, l){return create$0([7, tid, l]);}
   function get_poly_variant(x){
    if(1 === x[0]){var desc = x[1][1]; return [1, desc];}
    var l = x[1], _dg_ = Base_Option[21];
    function _dh_(x){return [2, x];}
    return [0, map(l, function(_di_){return caml_call2(_dg_, _di_, _dh_);})];
   }
   var Def = [0];
   function annotate(u, x){return create$0([0, u, x]);}
   function basetype(u, l){return create$0([1, u, l]);}
   function tuple(l){return create$0([2, l]);}
   function poly_variant(loc, l){
    return create$0
            ([5,
              create
               (loc,
                function(_de_, _df_){return equal_option(equal, _de_, _df_);},
                l)]);
   }
   function var$1(x){return create$0([8, x]);}
   function apply$0(x, l){return create$0([6, x, l]);}
   function recurse$0(t, l){return create$0([7, t, l]);}
   function define(x){return x;}
   function record(l){return create$0([3, l]);}
   function variant(l){return create$0([4, l]);}
   function create$1(e){return [0, to_digest$0(e)];}
   var
    Canonical_digest =
      [0,
       to_digest,
       [0, var$0, recurse, apply, opaque, get_poly_variant],
       Def,
       [0,
        annotate,
        basetype,
        tuple,
        poly_variant,
        var$1,
        recurse$0,
        apply$0,
        define,
        record,
        variant,
        create$1]];
   function compare_t0$0(counter, a_198, b_199){
    if(caml_call2(Ppx_compare_lib[1], a_198, b_199)) return 0;
    var b_201 = b_199[1], a_200 = a_198[1];
    if(caml_call2(Ppx_compare_lib[1], a_200, b_201)) return 0;
    a:
    {
     b:
     {
      c:
      {
       d:
       {
        e:
        {
         f:
         {
          switch(a_200[0]){
            case 0:
             var a_146 = a_200[1];
             if(0 !== b_201[0]) return -1;
             var
              b_149 = b_201[2],
              b_147 = b_201[1],
              a_148 = a_200[2],
              n = caml_call2(compare, a_146, b_147);
             if(0 !== n) return n;
             if(counter >= 50)
              return caml_trampoline_return(compare_t0$0, [0, a_148, b_149]);
             var counter$0 = counter + 1 | 0;
             return compare_t0$0(counter$0, a_148, b_149);
            case 1:
             var a_152 = a_200[2], a_150 = a_200[1];
             switch(b_201[0]){
               case 0:
                break a;
               case 1:
                var
                 b_153 = b_201[2],
                 b_151 = b_201[1],
                 n$0 = caml_call2(compare, a_150, b_151);
                return 0 === n$0
                        ? caml_call3
                          (Base[135],
                           function(a_154, b_155){return compare_t0(a_154, b_155);},
                           a_152,
                           b_153)
                        : n$0;
               default: return -1;
             }
            case 2:
             var a_156 = a_200[1];
             switch(b_201[0]){
               case 0:
                break a;
               case 1:
                break b;
               case 2:
                var b_157 = b_201[1];
                return caml_call3
                        (Base[135],
                         function(a_158, b_159){return compare_t0(a_158, b_159);},
                         a_156,
                         b_157);
               default: return -1;
             }
            case 3:
             var a_160 = a_200[1];
             switch(b_201[0]){
               case 0:
                break a;
               case 1:
                break b;
               case 2:
                break c;
               case 3:
                var b_161 = b_201[1];
                return caml_call3
                        (Base[135],
                         function(a_162, b_163){
                          var
                           t_165 = a_162[2],
                           t_164 = a_162[1],
                           t_167 = b_163[2],
                           t_166 = b_163[1],
                           n = caml_call2(Base[159], t_164, t_166);
                          return 0 === n ? compare_t0(t_165, t_167) : n;
                         },
                         a_160,
                         b_161);
               default: return -1;
             }
            case 4:
             var a_168 = a_200[1];
             switch(b_201[0]){
               case 0:
                break a;
               case 1:
                break b;
               case 2:
                break c;
               case 3:
                break d;
               case 4:
                var b_169 = b_201[1];
                return caml_call3
                        (Base[135],
                         function(a_170, b_171){
                          var
                           t_173 = a_170[2],
                           t_172 = a_170[1],
                           t_175 = b_171[2],
                           t_174 = b_171[1],
                           n = caml_call2(Base[159], t_172, t_174);
                          return 0 === n
                                  ? caml_call3
                                    (Base[135],
                                     function(a_176, b_177){return compare_t0(a_176, b_177);},
                                     t_173,
                                     t_175)
                                  : n;
                         },
                         a_168,
                         b_169);
               default: return -1;
             }
            case 5:
             var a_002 = a_200[1];
             switch(b_201[0]){
               case 0:
                break a;
               case 1:
                break b;
               case 2:
                break c;
               case 3:
                break d;
               case 4:
                break e;
               case 5:
                var b_179 = b_201[1];
                return caml_call2(Ppx_compare_lib[1], a_002, b_179)
                        ? 0
                        : caml_call3
                          (Base[135],
                           function(a_004, b_005){
                            var
                             t_007 = a_004[2],
                             t_006 = a_004[1],
                             t_009 = b_005[2],
                             t_008 = b_005[1],
                             n = caml_call2(Base[159], t_006, t_008);
                            return 0 === n
                                    ? caml_call3
                                      (Base[148],
                                       function(a_182, b_183){return compare_t0(a_182, b_183);},
                                       t_007,
                                       t_009)
                                    : n;
                           },
                           a_002[1],
                           b_179[1]);
               default: return -1;
             }
            case 6:
             var a_186 = a_200[2], a_184 = a_200[1];
             switch(b_201[0]){
               case 0:
                break a;
               case 1:
                break b;
               case 2:
                break c;
               case 3:
                break d;
               case 4:
                break e;
               case 5:
                break f;
               case 6:
                var
                 b_187 = b_201[2],
                 b_185 = b_201[1],
                 n$2 = compare_t0(a_184, b_185);
                return 0 === n$2
                        ? caml_call3
                          (Base[135],
                           function(a_188, b_189){return compare_t0(a_188, b_189);},
                           a_186,
                           b_187)
                        : n$2;
               default: return -1;
             }
            case 7:
             var a_192 = a_200[2], a_190 = a_200[1];
             switch(b_201[0]){
               case 0:
                break a;
               case 1:
                break b;
               case 2:
                break c;
               case 3:
                break d;
               case 4:
                break e;
               case 5:
                break f;
               case 6: break;
               case 7:
                var
                 b_193 = b_201[2],
                 b_191 = b_201[1],
                 n$1 = caml_call2(Base[114], a_190, b_191);
                return 0 === n$1
                        ? caml_call3
                          (Base[135],
                           function(a_194, b_195){return compare_t0(a_194, b_195);},
                           a_192,
                           b_193)
                        : n$1;
               default: return -1;
             }
             break;
            default:
             var a_196 = a_200[1];
             switch(b_201[0]){
               case 0:
                break a;
               case 1:
                break b;
               case 2:
                break c;
               case 3:
                break d;
               case 4:
                break e;
               case 5:
                break f;
               case 6: break;
               case 7:
                return 1;
               default:
                var b_197 = b_201[1];
                return caml_call2(Base[114], a_196, b_197);
             }
          }
          return 1;
         }
         return 1;
        }
        return 1;
       }
       return 1;
      }
      return 1;
     }
     return 1;
    }
    return 1;
   }
   function compare_t0(a_198, b_199){
    return caml_trampoline(compare_t0$0(0, a_198, b_199));
   }
   var t0_of_sexp = function _dd_(_dc_){return _dd_.fun(_dc_);};
   runtime.caml_update_dummy
    (t0_of_sexp,
     function(sexp_208){
      a:
      {
       if(0 === sexp_208[0]){
        var _c$_ = sexp_208[1];
        if(_c$_ !== cst_Exp && _c$_ !== cst_exp) break a;
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_206, sexp_208);
       }
       var _da_ = sexp_208[1];
       if(! _da_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[7], error_source_206, sexp_208);
       var _db_ = _da_[1];
       if(0 !== _db_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[6], error_source_206, sexp_208);
       var tag_209 = _db_[1];
       if(tag_209 !== cst_Exp && tag_209 !== cst_exp) break a;
       var sexp_args_210 = _da_[2];
       if(sexp_args_210 && ! sexp_args_210[2]){
        var
         arg0_211 = sexp_args_210[1],
         res0_212 = t_of_sexp$1(t0_of_sexp, arg0_211);
        return [0, res0_212];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[4],
                error_source_206,
                tag_209,
                sexp_208);
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[8], error_source_206, sexp_208);
     });
   var _r_ = [0, cst_Exp];
   function sexp_of_t0(param){
    var arg0_213 = param[1], res0_214 = sexp_of_t$2(sexp_of_t0, arg0_213);
    return [1, [0, _r_, [0, res0_214, 0]]];
   }
   function equal_t0(x, y){return 0 === compare_t0(x, y) ? 1 : 0;}
   function var$2(x){return [0, [8, x]];}
   function apply$1(d, xs){return [0, [6, d, xs]];}
   function recurse$1(r, xs){return [0, [7, r, xs]];}
   function get_poly_variant$0(param){
    var cc = param[1];
    if(5 !== cc[0]) return [1, to_string$1(cc)];
    var tab = cc[1];
    return [0, tab];
   }
   function opaque$0(t){return t;}
   function to_digest$1(param){
    var e = param[1];
    return digest_layer(map$0(e, to_digest$1));
   }
   function to_digest$2(e){return to_digest$1(e);}
   function annotate$0(u, x){return [0, [0, u, x]];}
   function basetype$0(u, xs){return [0, [1, u, xs]];}
   function tuple$0(xs){return [0, [2, xs]];}
   function poly_variant$0(loc, xs){
    return [0,
            [5,
             create
              (loc,
               function(_c9_, _c__){
                return equal_option(equal_t0, _c9_, _c__);
               },
               xs)]];
   }
   function var$3(n){return [0, [8, n]];}
   function recurse$2(r, xs){return recurse$1(r, xs);}
   function apply$2(d, xs){return apply$1(d, xs);}
   function define$0(x){return x;}
   function record$0(xs){return [0, [3, xs]];}
   function variant$0(xs){return [0, [4, xs]];}
   function create$2(exp){return exp;}
   var
    Create =
      [0,
       annotate$0,
       basetype$0,
       tuple$0,
       poly_variant$0,
       var$3,
       recurse$2,
       apply$2,
       define$0,
       record$0,
       variant$0,
       create$2];
   function to_string_hum(t){
    var _c8_ = sexp_of_t0(t);
    return caml_call2(Base[84][13], 0, _c8_);
   }
   var
    Def$0 = [0],
    Exp1 = [0, var$2, recurse$1, apply$1, opaque$0, get_poly_variant$0],
    sexp_of_t$3 = Base_String[28],
    of_string$1 = Base_String[29],
    to_string$2 = Base_String[30],
    symbol = Base_String[33],
    compare$1 = Base_String[37],
    equal$0 = Base_String[121],
    sexp_of_t$4 = Base_String[28],
    of_string$2 = Base_String[29],
    to_string$3 = Base_String[30],
    comparator = Base_String[45],
    compare$2 = Base[114],
    sexp_of_t$5 = Base[119],
    r = [0, 0],
    _s_ = [0, "Constr"],
    _t_ = [0, "Inherit"],
    _u_ = [0, "members"],
    _v_ = [0, "loc"],
    _w_ = [0, "gid"],
    cst_impossible_lookup_group_un =
      "impossible: lookup_group, unbound type-identifier: %{Tid}",
    _x_ = [0, 0],
    cst_impossible_lookup_group_un$0 =
      "impossible: lookup_group, unbound type-identifier: ",
    _y_ = [0, cst_Annotate],
    _z_ = [0, cst_Base],
    _A_ = [0, cst_Record],
    _B_ = [0, cst_Variant],
    _C_ = [0, cst_Tuple],
    _D_ = [0, cst_Poly_variant],
    _E_ = [0, cst_Var],
    _F_ = [0, cst_Rec_app],
    _G_ = [0, "Top_app"];
   function create$3(loc, trips){
    var gid = r[1];
    r[1] = 1 + gid | 0;
    var
     members =
       caml_call2
        (Base_List[76],
         trips,
         function(param){
          var t = param[3], vs = param[2], x = param[1];
          return [0, x, [0, vs, t]];
         });
    return [0, gid, loc, members];
   }
   function lookup(g, tid){
    var match = caml_call3(Base_List[129][5], g[3], symbol, tid);
    if(! match)
     return caml_call2
             (eval_fail
               (g[2],
                [0,
                 [11,
                  cst_impossible_lookup_group_un$0,
                  [24,
                   _x_,
                   function(param, custom_printf_285){
                    return caml_call1(to_string$2, custom_printf_285);
                   },
                   0]],
                 cst_impossible_lookup_group_un]),
              tid,
              0);
    var scheme = match[1];
    return scheme;
   }
   function annotate$1(v0, v1){return [0, v0, v1];}
   function basetype$1(v0, v1){return [1, v0, v1];}
   function record$1(v0){return [2, v0];}
   function variant$1(v0){return [3, v0];}
   function tuple$1(v0){return [4, v0];}
   function rec_app(v0, v1){return [7, v0, v1];}
   function top_app(v0, v1, v2){return [8, v0, v1, v2];}
   function sexp_of_t$6(param){
    switch(param[0]){
      case 0:
       var
        arg1_287 = param[2],
        arg0_286 = param[1],
        res0_288 = caml_call1(sexp_of_t$0, arg0_286),
        res1_289 = sexp_of_t$6(arg1_287);
       return [1, [0, _y_, [0, res0_288, [0, res1_289, 0]]]];
      case 1:
       var
        arg1_291 = param[2],
        arg0_290 = param[1],
        res0_292 = caml_call1(sexp_of_t$0, arg0_290),
        res1_293 = caml_call2(Base[139], sexp_of_t$6, arg1_291);
       return [1, [0, _z_, [0, res0_292, [0, res1_293, 0]]]];
      case 2:
       var
        arg0_298 = param[1],
        res0_299 =
          caml_call2
           (Base[139],
            function(param){
             var
              arg1_295 = param[2],
              arg0_294 = param[1],
              res0_296 = caml_call1(Base[164], arg0_294),
              res1_297 = sexp_of_t$6(arg1_295);
             return [1, [0, res0_296, [0, res1_297, 0]]];
            },
            arg0_298);
       return [1, [0, _A_, [0, res0_299, 0]]];
      case 3:
       var
        arg0_304 = param[1],
        res0_305 =
          caml_call2
           (Base[139],
            function(param){
             var
              arg1_301 = param[2],
              arg0_300 = param[1],
              res0_302 = caml_call1(Base[164], arg0_300),
              res1_303 = caml_call2(Base[139], sexp_of_t$6, arg1_301);
             return [1, [0, res0_302, [0, res1_303, 0]]];
            },
            arg0_304);
       return [1, [0, _B_, [0, res0_305, 0]]];
      case 4:
       var
        arg0_306 = param[1],
        res0_307 = caml_call2(Base[139], sexp_of_t$6, arg0_306);
       return [1, [0, _C_, [0, res0_307, 0]]];
      case 5:
       var
        arg0_312 = param[1],
        arg1_309 = arg0_312[2],
        arg0_308 = arg0_312[1],
        res0_310 = caml_call1(sexp_of_t, arg0_308),
        res1_311 =
          caml_call2
           (Base[139],
            function(param){
             if(-59723313 <= param[1]){
              var
               v_245 = param[2],
               arg1_247 = v_245[2],
               arg0_246 = v_245[1],
               res0_248 = caml_call1(Base[164], arg0_246),
               res1_249 = caml_call2(Base[152], sexp_of_t$6, arg1_247);
              return [1,
                      [0, _s_, [0, [1, [0, res0_248, [0, res1_249, 0]]], 0]]];
             }
             var
              v_250 = param[2],
              arg1_252 = v_250[2],
              arg0_251 = v_250[1],
              res0_253 = caml_call1(sexp_of_t, arg0_251),
              res1_254 = sexp_of_t$6(arg1_252);
             return [1,
                     [0, _t_, [0, [1, [0, res0_253, [0, res1_254, 0]]], 0]]];
            },
            arg1_309),
        res0_313 = [1, [0, res0_310, [0, res1_311, 0]]];
       return [1, [0, _D_, [0, res0_313, 0]]];
      case 6:
       var
        arg0_318 = param[1],
        arg1_315 = arg0_318[2],
        arg0_314 = arg0_318[1],
        res0_316 = caml_call1(sexp_of_t, arg0_314),
        res1_317 = caml_call1(sexp_of_t$4, arg1_315),
        res0_319 = [1, [0, res0_316, [0, res1_317, 0]]];
       return [1, [0, _E_, [0, res0_319, 0]]];
      case 7:
       var
        arg1_321 = param[2],
        arg0_320 = param[1],
        res0_322 = caml_call1(sexp_of_t$3, arg0_320),
        res1_323 = caml_call2(Base[139], sexp_of_t$6, arg1_321);
       return [1, [0, _F_, [0, res0_322, [0, res1_323, 0]]]];
      default:
       var
        arg2_326 = param[3],
        arg1_325 = param[2],
        arg0_324 = param[1],
        members_275 = arg0_324[3],
        loc_273 = arg0_324[2],
        gid_271 = arg0_324[1],
        arg_276 =
          caml_call2
           (Base[139],
            function(param){
             var
              arg1_282 = param[2],
              arg0_281 = param[1],
              res0_283 = caml_call1(sexp_of_t$3, arg0_281),
              arg1_278 = arg1_282[2],
              arg0_277 = arg1_282[1],
              res0_279 = caml_call2(Base[139], sexp_of_t$4, arg0_277),
              res1_280 = sexp_of_t$6(arg1_278),
              res1_284 = [1, [0, res0_279, [0, res1_280, 0]]];
             return [1, [0, res0_283, [0, res1_284, 0]]];
            },
            members_275),
        bnds_270 = [0, [1, [0, _u_, [0, arg_276, 0]]], 0],
        arg_274 = caml_call1(sexp_of_t, loc_273),
        bnds_270$0 = [0, [1, [0, _v_, [0, arg_274, 0]]], bnds_270],
        arg_272 = caml_call1(sexp_of_t$5, gid_271),
        bnds_270$1 = [0, [1, [0, _w_, [0, arg_272, 0]]], bnds_270$0],
        res0_327 = [1, bnds_270$1],
        res1_328 = caml_call1(sexp_of_t$3, arg1_325),
        res2_329 = caml_call2(Base[139], sexp_of_t$6, arg2_326);
       return [1, [0, _G_, [0, res0_327, [0, res1_328, [0, res2_329, 0]]]]];
    }
   }
   function constr(s, t){return [0, -59723313, [0, s, t]];}
   function inherit(loc, t){return [0, -72987685, [0, loc, t]];}
   function var$4(loc, t){return [6, [0, loc, t]];}
   function poly_variant$1(loc, xs){return [5, [0, loc, xs]];}
   function is_cyclic_0(via_VR, group, tid){
    var set = [0, 0];
    function visited(tid){
     return caml_call3(Base_List[6], set[1], tid, equal$0);
    }
    function trav(param){
     var param$0 = param;
     for(;;){
      switch(param$0[0]){
        case 0:
         var t = param$0[2]; param$0 = t; continue;
        case 1:
         var ts = param$0[2]; break;
        case 2:
         var xs = param$0[1];
         return via_VR
                 ? caml_call2
                   (Base_List[9],
                    xs,
                    function(param){var t = param[2]; return trav(t);})
                 : 0;
        case 3:
         var xs$0 = param$0[1];
         return via_VR
                 ? caml_call2
                   (Base_List[9],
                    xs$0,
                    function(param){
                     var ts = param[2];
                     return caml_call2(Base_List[9], ts, trav);
                    })
                 : 0;
        case 4:
         var ts = param$0[1]; break;
        case 5:
         var cs = param$0[1][2];
         return caml_call2
                 (Base_List[9],
                  cs,
                  function(param){
                   if(-59723313 > param[1]){
                    var t$0 = param[2][2];
                    return trav(t$0);
                   }
                   var match = param[2][2];
                   if(! match) return 0;
                   var t = match[1];
                   return trav(t);
                  });
        case 6:
         return 0;
        case 7:
         var ts$0 = param$0[2], tid = param$0[1];
         if(! visited(tid)){set[1] = [0, tid, set[1]]; trav_tid(tid);}
         return caml_call2(Base_List[9], ts$0, trav);
        default: var ts = param$0[3];
      }
      return caml_call2(Base_List[9], ts, trav);
     }
    }
    function trav_tid(tid){
     var body = lookup(group, tid)[2];
     return trav(body);
    }
    trav_tid(tid);
    var res = visited(tid);
    return res;
   }
   var
    _H_ = 1,
    _I_ = 0,
    cst_Free_type_variable_Vid = "Free type variable: '%{Vid}",
    _J_ = [0, 0],
    cst_Free_type_variable = "Free type variable: '",
    _K_ =
      [0,
       [11,
        "The shape for an inherited type is not described as a polymorphic-variant: ",
        [2, 0, 0]],
       "The shape for an inherited type is not described as a polymorphic-variant: %s"],
    cst_apply_incorrect_type_appli = "apply, incorrect type application arity",
    cst_top_level = "top-level";
   function Evaluation(Canonical){
    var func = Base_List[10], _O_ = caml_call1(Base_Map[6], [0, comparator]);
    function _P_(t, param){
     var v = param[2], k = param[1];
     return caml_call3(Base_Map[28], t, k, v);
    }
    function create(_c7_){return caml_call3(func, _c7_, _O_, _P_);}
    function lookup$0(t, k){return caml_call2(Base_Map[36], t, k);}
    var Venv = [0, lookup$0, create];
    function compare(a_330, b_331){
     var
      t_333 = a_330[2],
      t_332 = a_330[1],
      t_335 = b_331[2],
      t_334 = b_331[1],
      n = caml_call2(compare$2, t_332, t_334);
     return 0 === n ? caml_call2(compare$1, t_333, t_335) : n;
    }
    function sexp_of_t(param){
     var
      arg1_337 = param[2],
      arg0_336 = param[1],
      res0_338 = caml_call1(sexp_of_t$5, arg0_336),
      res1_339 = caml_call1(sexp_of_t$3, arg1_337);
     return [1, [0, res0_338, [0, res1_339, 0]]];
    }
    var
     T = [0, compare, sexp_of_t],
     include = caml_call1(Base_Comparator[5], T),
     comparator$0 = include[1];
    function find(t, k){return caml_call2(Base_Map[36], t, k);}
    var empty = caml_call1(Base_Map[6], [0, comparator$0]);
    function extend(t, k, v){return caml_call3(Base_Map[28], t, k, v);}
    var Tenv = [0, find, empty, extend];
    function return$0(x, param, tenv){return x;}
    function bind(t, f, depth, tenv){
     var x = caml_call2(t, depth, tenv);
     return caml_call2(caml_call1(f, x), depth, tenv);
    }
    function look_env(key, param, tenv){
     var result = Tenv[1].call(null, tenv, key);
     return caml_call2
             (Base_Option[21],
              result,
              function(param){var x = param[2]; return [0, x];});
    }
    function extend_new_tid(key, def_t, depth, tenv){
     var
      value = [0, -271630457, depth],
      tenv$0 = Tenv[3].call(null, tenv, key, value);
     return [1, caml_call2(def_t, depth + 1 | 0, tenv$0)];
    }
    function exec(t){return caml_call2(t, 0, Tenv[2]);}
    var
     Defining = [0, return$0, bind, look_env, extend_new_tid, exec],
     symbol_bind = Defining[2],
     return$1 = Defining[1];
    function sequence_defining(xs, f){
     function loop(acc_ys, param){
      if(param){
       var
        xs = param[2],
        x = param[1],
        _cW_ = function(y){return loop([0, y, acc_ys], xs);},
        _cX_ = caml_call1(f, x);
       return function(_c3_, _c4_){
        var _c6_ = _c4_, _c5_ = _c3_;
        return symbol_bind(_cX_, _cW_, _c5_, _c6_);};
      }
      var _cY_ = caml_call1(Base_List[38], acc_ys);
      return function(_cZ_, _c0_){
       var _c2_ = _c0_, _c1_ = _cZ_;
       return return$1(_cY_, _c1_, _c2_);};
     }
     return loop(0, xs);
    }
    function _Q_(group, venv, t){
     switch(t[0]){
       case 0:
        var
         t$0 = t[2],
         s = t[1],
         _bg_ =
           function(v){
            var _cR_ = caml_call2(Canonical[4][1], s, v);
            return function(_cS_, _cT_){
             var _cV_ = _cT_, _cU_ = _cS_;
             return return$1(_cR_, _cU_, _cV_);};
           },
         _bh_ = _Q_(group, venv, t$0);
        return function(_cN_, _cO_){
         var _cQ_ = _cO_, _cP_ = _cN_;
         return symbol_bind(_bh_, _bg_, _cP_, _cQ_);};
       case 1:
        var
         ts = t[2],
         s$0 = t[1],
         _bi_ =
           function(vs){
            var _cI_ = caml_call2(Canonical[4][2], s$0, vs);
            return function(_cJ_, _cK_){
             var _cM_ = _cK_, _cL_ = _cJ_;
             return return$1(_cI_, _cL_, _cM_);};
           },
         _bj_ = eval_list(group, venv, ts);
        return function(_cE_, _cF_){
         var _cH_ = _cF_, _cG_ = _cE_;
         return symbol_bind(_bj_, _bi_, _cG_, _cH_);};
       case 2:
        var
         binds = t[1],
         _bk_ =
           function(binds){
            var _cz_ = caml_call1(Canonical[4][9], binds);
            return function(_cA_, _cB_){
             var _cD_ = _cB_, _cC_ = _cA_;
             return return$1(_cz_, _cC_, _cD_);};
           },
         _bl_ =
           sequence_defining
            (binds,
             function(param){
              var x = param[2], s = param[1];
              function _co_(y){
               var _cu_ = [0, s, y];
               return function(_cv_, _cw_){
                var _cy_ = _cw_, _cx_ = _cv_;
                return return$1(_cu_, _cx_, _cy_);};
              }
              var _cp_ = _Q_(group, venv, x);
              return function(_cq_, _cr_){
               var _ct_ = _cr_, _cs_ = _cq_;
               return symbol_bind(_cp_, _co_, _cs_, _ct_);};
             });
        return function(_ck_, _cl_){
         var _cn_ = _cl_, _cm_ = _ck_;
         return symbol_bind(_bl_, _bk_, _cm_, _cn_);};
       case 3:
        var
         alts = t[1],
         _bm_ =
           function(alts){
            var _cf_ = caml_call1(Canonical[4][10], alts);
            return function(_cg_, _ch_){
             var _cj_ = _ch_, _ci_ = _cg_;
             return return$1(_cf_, _ci_, _cj_);};
           },
         _bn_ =
           sequence_defining
            (alts,
             function(param){
              var xs = param[2], s = param[1];
              function _b6_(ys){
               var _ca_ = [0, s, ys];
               return function(_cb_, _cc_){
                var _ce_ = _cc_, _cd_ = _cb_;
                return return$1(_ca_, _cd_, _ce_);};
              }
              var _b7_ = eval_list(group, venv, xs);
              return function(_b8_, _b9_){
               var _b$_ = _b9_, _b__ = _b8_;
               return symbol_bind(_b7_, _b6_, _b__, _b$_);};
             });
        return function(_b2_, _b3_){
         var _b5_ = _b3_, _b4_ = _b2_;
         return symbol_bind(_bn_, _bm_, _b4_, _b5_);};
       case 4:
        var
         ts$0 = t[1],
         _bo_ =
           function(vs){
            var _bX_ = caml_call1(Canonical[4][3], vs);
            return function(_bY_, _bZ_){
             var _b1_ = _bZ_, _b0_ = _bY_;
             return return$1(_bX_, _b0_, _b1_);};
           },
         _bp_ = eval_list(group, venv, ts$0);
        return function(_bT_, _bU_){
         var _bW_ = _bU_, _bV_ = _bT_;
         return symbol_bind(_bp_, _bo_, _bV_, _bW_);};
       case 5:
        var
         match = t[1],
         cs = match[2],
         loc = match[1],
         _bq_ =
           function(xss){
            var
             _bN_ = caml_call1(Base_List[138], xss),
             _bO_ = caml_call2(Canonical[4][4], loc, _bN_);
            return function(_bP_, _bQ_){
             var _bS_ = _bQ_, _bR_ = _bP_;
             return return$1(_bO_, _bR_, _bS_);};
           },
         _br_ =
           sequence_defining
            (cs, function(_bM_){return eval_poly_constr(group, venv, _bM_);});
        return function(_bI_, _bJ_){
         var _bL_ = _bJ_, _bK_ = _bI_;
         return symbol_bind(_br_, _bq_, _bK_, _bL_);};
       case 6:
        var
         match$0 = t[1],
         vid = match$0[2],
         loc$0 = match$0[1],
         match$1 = Venv[1].call(null, venv, vid);
        if(! match$1)
         return caml_call2
                 (eval_fail
                   (loc$0,
                    [0,
                     [11,
                      cst_Free_type_variable,
                      [24,
                       _J_,
                       function(param, custom_printf_340){
                        return caml_call1(to_string$3, custom_printf_340);
                       },
                       0]],
                     cst_Free_type_variable_Vid]),
                  vid,
                  0);
        var x = match$1[1];
        return function(_bE_, _bF_){
         var _bH_ = _bF_, _bG_ = _bE_;
         return return$1(x, _bG_, _bH_);};
       case 7:
        var
         args = t[2],
         tid = t[1],
         _bs_ = function(args){return eval_app(group, tid, args);},
         _bt_ = eval_list(group, venv, args);
        return function(_bA_, _bB_){
         var _bD_ = _bB_, _bC_ = _bA_;
         return symbol_bind(_bt_, _bs_, _bC_, _bD_);};
       default:
        var
         args$0 = t[3],
         tid$0 = t[2],
         in_group = t[1],
         _bu_ = function(args){return eval_app(in_group, tid$0, args);},
         _bv_ = eval_list(group, venv, args$0);
        return function(_bw_, _bx_){
         var _bz_ = _bx_, _by_ = _bw_;
         return symbol_bind(_bv_, _bu_, _by_, _bz_);};
     }
    }
    function eval_list(group, venv, ts){
     return sequence_defining
             (ts, function(_bf_){return _Q_(group, venv, _bf_);});
    }
    function eval_poly_constr(group, venv, c){
     if(-59723313 > c[1]){
      var
       match$0 = c[2],
       t$0 = match$0[2],
       loc = match$0[1],
       _aT_ =
         function(v){
          var match = caml_call1(Canonical[2][5], v);
          if(0 === match[0]){
           var tab = match[1], _ba_ = tab[1];
           return function(_bb_, _bc_){
            var _be_ = _bc_, _bd_ = _bb_;
            return return$1(_ba_, _bd_, _be_);};
          }
          var desc = match[1];
          return caml_call2(eval_fail(loc, _K_), desc, 0);
         },
       _aU_ = _Q_(group, venv, t$0);
      return function(_a8_, _a9_){
       var _a$_ = _a9_, _a__ = _a8_;
       return symbol_bind(_aU_, _aT_, _a__, _a$_);};
     }
     var _aP_ = c[2], match = _aP_[2], s = _aP_[1];
     if(match){
      var
       t = match[1],
       _aQ_ =
         function(v){
          var _a3_ = [0, [0, s, [0, caml_call1(Canonical[2][4], v)]], 0];
          return function(_a4_, _a5_){
           var _a7_ = _a5_, _a6_ = _a4_;
           return return$1(_a3_, _a6_, _a7_);};
         },
       _aR_ = _Q_(group, venv, t);
      return function(_aZ_, _a0_){
       var _a2_ = _a0_, _a1_ = _aZ_;
       return symbol_bind(_aR_, _aQ_, _a1_, _a2_);};
     }
     var _aS_ = [0, [0, s, 0], 0];
     return function(_aV_, _aW_){
      var _aY_ = _aW_, _aX_ = _aV_;
      return return$1(_aS_, _aX_, _aY_);};
    }
    function eval_definition(group, formals, body){
     var
      _aD_ =
        caml_call2
         (Base_List[96],
          formals,
          function(i, x){return [0, x, caml_call1(Canonical[2][1], i)];}),
      venv = Venv[2].call(null, _aD_);
     function _aE_(v){
      var _aK_ = caml_call1(Canonical[4][8], v);
      return function(_aL_, _aM_){
       var _aO_ = _aM_, _aN_ = _aL_;
       return return$1(_aK_, _aN_, _aO_);};
     }
     var _aF_ = _Q_(group, venv, body);
     return function(_aG_, _aH_){
      var _aJ_ = _aH_, _aI_ = _aG_;
      return symbol_bind(_aF_, _aE_, _aI_, _aJ_);};
    }
    function eval_app(group, tid, args){
     var
      gid = group[1],
      match = lookup(group, tid),
      body = match[2],
      formals = match[1];
     switch(body[0]){
       case 2:
       case 3:
        var record_or_normal_variant = 1; break;
       default: var record_or_normal_variant = 0;
     }
     var
      cyclic = is_cyclic_0(_H_, group, tid),
      cyclic_no_VR = is_cyclic_0(_I_, group, tid);
     a:
     {
      if(record_or_normal_variant && cyclic) break a;
      if(! cyclic_no_VR){
       var match$0 = caml_call2(Base_List[94], formals, args);
       if(match$0)
        var x = match$0[1], venv = Venv[2].call(null, x);
       else
        var venv = caml_call1(Base[200], cst_apply_incorrect_type_appli);
       return _Q_(group, venv, body);
      }
     }
     function _S_(param){
      if(0 === param[0]){
       var r = param[1], _at_ = caml_call2(Canonical[2][2], r, args);
       return function(_az_, _aA_){
        var _aC_ = _aA_, _aB_ = _az_;
        return return$1(_at_, _aB_, _aC_);};
      }
      var def = param[1], _au_ = caml_call2(Canonical[2][3], def, args);
      return function(_av_, _aw_){
       var _ay_ = _aw_, _ax_ = _av_;
       return return$1(_au_, _ax_, _ay_);};
     }
     function _T_(param){
      if(param){
       var recurse = param[1];
       return function(_ap_, _aq_){
        var _as_ = _aq_, _ar_ = _ap_;
        return return$1(recurse, _ar_, _as_);};
      }
      var
       _ai_ = eval_definition(group, formals, body),
       _aj_ = [0, gid, tid],
       _ak_ = Defining[4];
      return function(_al_, _am_){
       var _ao_ = _am_, _an_ = _al_;
       return _ak_(_aj_, _ai_, _an_, _ao_);};
     }
     var _U_ = [0, gid, tid], _V_ = Defining[3];
     function _W_(_ae_, _af_){
      var _ah_ = _af_, _ag_ = _ae_;
      return _V_(_U_, _ag_, _ah_);
     }
     function _X_(_aa_, _ab_){
      var _ad_ = _ab_, _ac_ = _aa_;
      return symbol_bind(_W_, _T_, _ac_, _ad_);
     }
     return function(_Y_, _Z_){
      var _$_ = _Z_, ___ = _Y_;
      return symbol_bind(_X_, _S_, ___, _$_);};
    }
    function eval$0(t){
     var
      group = create$3(caml_call1(of_string, cst_top_level), 0),
      venv = Venv[2].call(null, 0),
      _R_ = _Q_(group, venv, t),
      v = Defining[5].call(null, _R_);
     return caml_call1(Canonical[4][11], v);
    }
    return [0, , , , , , , , , , , , eval$0];
   }
   var
    Exp = [0],
    include = Evaluation([0, to_digest$2, Exp1, Def$0, Create]),
    eval$0 = include[12],
    Evaluation_to_digest = Evaluation(Canonical_digest);
   function eval_to_digest(exp){
    var _N_ = Evaluation_to_digest[12].call(null, exp);
    return caml_call1(Canonical_digest[1], _N_);
   }
   function eval_to_digest_string(exp){
    return caml_call1(to_hex, eval_to_digest(exp));
   }
   var
    Not_a_tuple =
      [248,
       "Bin_shape_lib.Bin_shape.For_typerep.Not_a_tuple",
       runtime.caml_fresh_oo_id(0)],
    _L_ = [0, "shape/src/bin_shape.ml.For_typerep.Not_a_tuple"],
    _M_ = [0, "_none_", 0, -1];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     Not_a_tuple,
     function(param){
      if(param[1] !== Not_a_tuple)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _M_], 1);
      var arg0_341 = param[2], res0_342 = sexp_of_t$6(arg0_341);
      return [1, [0, _L_, [0, res0_342, 0]]];
     });
   function deconstruct_tuple_exn(t){
    if(4 !== t[0]) throw caml_maybe_attach_backtrace([0, Not_a_tuple, t], 1);
    var ts = t[1];
    return ts;
   }
   var
    Bin_shape_lib_Bin_shape =
      [0,
       sexp_of_t$6,
       [0, of_string$1],
       [0, of_string$2],
       [0, of_string],
       [0, of_string$0],
       create$3,
       tuple$1,
       record$1,
       variant$1,
       constr,
       inherit,
       poly_variant$1,
       rec_app,
       top_app,
       var$4,
       basetype$1,
       annotate$1,
       [0, compare$0, t_of_sexp$0, sexp_of_t$1, to_hex, to_md5, of_md5],
       [0,
        compare_t0,
        sexp_of_t0,
        to_string_hum,
        to_digest$2,
        Exp,
        Def$0,
        [0,
         Create[1],
         Create[2],
         Create[3],
         Create[4],
         Create[5],
         Create[7],
         Create[6],
         Create[8],
         Create[9],
         Create[10],
         Create[11]]],
       eval$0,
       eval_to_digest,
       eval_to_digest_string,
       [0, deconstruct_tuple_exn]];
   runtime.caml_register_global
    (133, Bin_shape_lib_Bin_shape, "Bin_shape_lib__Bin_shape");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Bin_shape_lib__Std
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Bin_shape_lib_Std = [0];
   runtime.caml_register_global(0, Bin_shape_lib_Std, "Bin_shape_lib__Std");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiaW5fc2hhcGVfbGliLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJlcnJvcl9zb3VyY2VfMDI2IiwiZXJyb3Jfc291cmNlXzA0MiIsImVycm9yX3NvdXJjZV8yMDYiLCJzZXhwX29mX3QiLCJvZl9zdHJpbmciLCJ0b19zdHJpbmciLCJ0X29mX3NleHAiLCJzZXhwX29mX3QkMCIsIm9mX3N0cmluZyQwIiwidG9fc3RyaW5nJDAiLCJjb21wYXJlIiwiZXZhbF9mYWlsIiwibG9jIiwiZm10IiwicyIsImN1c3RvbV9wcmludGZfMDAxIiwiZXF1YWxfb3B0aW9uIiwiZXF1YWwiLCJhIiwiYiIsInkiLCJ4IiwiY3JlYXRlIiwiZXEiLCJ4cyQxIiwic29ydGVkIiwiczIiLCJzMSIsInhzJDAiLCJsYXN0X3ZhbHVlJDEiLCJsYXN0X2tleSQxIiwiYWNjIiwibGFzdF9rZXkiLCJsYXN0X3ZhbHVlIiwieHMiLCJsYXN0X3ZhbHVlJDAiLCJsYXN0X2tleSQwIiwic29ydGVkJDAiLCJtYXAiLCJ0IiwiZiIsInYiLCJrIiwidG9fbWQ1Iiwib2ZfbWQ1Iiwic2V4cF9vZl90JDEiLCJ0X29mX3NleHAkMCIsInV1aWQiLCJ1IiwiaW50JDAiLCJwYWlyIiwibGlzdCIsImwiLCJjb25zdHJ1Y3RvciIsInRfb2Zfc2V4cCQxIiwib2ZfYV8wMzkiLCJzZXhwXzA0NCIsInRhZ18wNDUiLCJzZXhwX2FyZ3NfMDQ2IiwiYXJnMV8wNDgiLCJhcmcwXzA0NyIsInJlczBfMDQ5IiwicmVzMV8wNTAiLCJzZXhwX2FyZ3NfMDkwIiwiYXJnMV8wOTIiLCJhcmcwXzA5MSIsInJlczBfMDkzIiwicmVzMV8wOTQiLCJzZXhwX2FyZ3NfMDUzIiwiYXJnMV8wNTUiLCJhcmcwXzA1NCIsInJlczBfMDU2IiwicmVzMV8wNTciLCJzZXhwX2FyZ3NfMDg1IiwiYXJnMF8wODYiLCJvZl9hXzAxMCIsInJlczBfMDg3IiwiZmllbGRfc2V4cHNfMDEzIiwic29ydGVkXzAxNCIsImR1cGxpY2F0ZXNfMDE2IiwiZXh0cmFfMDE3Iiwic2V4cF8wMTIiLCJmaWVsZF9zZXhwc18wMjAiLCJmaWVsZF9uYW1lXzAxOCIsInRhaWxfMDI5IiwieF8wMzAiLCJmaWVsZF9zZXhwXzAxOSIsImZ2YWx1ZV8wMjciLCJzZXhwXzAyNSIsImFyZzFfMDIyIiwiYXJnMF8wMjEiLCJyZXMwXzAyMyIsInJlczFfMDI0Iiwic29ydGVkXzAxNSIsInNleHBfYXJnc18wOTciLCJhcmcxXzA5OSIsImFyZzBfMDk4IiwicmVzMF8xMDAiLCJyZXMxXzEwMSIsInNleHBfYXJnc18wNjUiLCJhcmcwXzA3MSIsInJlczBfMDcyIiwic2V4cF8wNzAiLCJhcmcxXzA2NyIsImFyZzBfMDY2IiwicmVzMF8wNjgiLCJyZXMxXzA2OSIsInNleHBfYXJnc18wNjAiLCJhcmcwXzA2MSIsInJlczBfMDYyIiwic2V4cF9hcmdzXzEwNCIsImFyZzBfMTA1IiwicmVzMF8xMDYiLCJzZXhwX2FyZ3NfMDc1IiwiYXJnMF8wODEiLCJyZXMwXzA4MiIsInNleHBfMDgwIiwiYXJnMV8wNzciLCJhcmcwXzA3NiIsInJlczBfMDc4IiwicmVzMV8wNzkiLCJzZXhwX29mX3QkMiIsIm9mX2FfMTA4IiwiYXJnMV8xMTAiLCJhcmcwXzEwOSIsInJlczBfMTExIiwicmVzMV8xMTIiLCJhcmcxXzExNCIsImFyZzBfMTEzIiwicmVzMF8xMTUiLCJyZXMxXzExNiIsImFyZzBfMTE3IiwicmVzMF8xMTgiLCJhcmcwXzEyMyIsInJlczBfMTI0IiwiYXJnMV8xMjAiLCJhcmcwXzExOSIsInJlczBfMTIxIiwicmVzMV8xMjIiLCJhcmcwXzEyOSIsInJlczBfMTMwIiwiYXJnMV8xMjYiLCJhcmcwXzEyNSIsInJlczBfMTI3IiwicmVzMV8xMjgiLCJhcmcwXzEzMSIsIm9mX2FfMDMxIiwic29ydGVkXzAzMyIsImFyZ18wMzQiLCJhcmcxXzAzNiIsImFyZzBfMDM1IiwicmVzMF8wMzciLCJyZXMxXzAzOCIsImJuZHNfMDMyIiwicmVzMF8xMzIiLCJhcmcxXzEzNCIsImFyZzBfMTMzIiwicmVzMF8xMzUiLCJyZXMxXzEzNiIsImFyZzFfMTM4IiwiYXJnMF8xMzciLCJyZXMwXzEzOSIsInJlczFfMTQwIiwiYXJnMF8xNDEiLCJyZXMwXzE0MiIsIm1hcCQwIiwieCQwIiwibCQwIiwibCQxIiwieCQxIiwibCQyIiwidCQwIiwidG9fc3RyaW5nJDEiLCJkaWdlc3RfbGF5ZXIiLCJ1JDAiLCJ0YWJsZSIsImwkMyIsImwkNCIsIm4iLCJuJDAiLCJ0b19kaWdlc3QiLCJ0b19kaWdlc3QkMCIsIngkMiIsIm9wYXF1ZSIsImNyZWF0ZSQwIiwiZGVzYyIsInZhciQwIiwiYXBwbHkiLCJkZWYiLCJyZWN1cnNlIiwidGlkIiwiZ2V0X3BvbHlfdmFyaWFudCIsImFubm90YXRlIiwiYmFzZXR5cGUiLCJ0dXBsZSIsInBvbHlfdmFyaWFudCIsInZhciQxIiwiYXBwbHkkMCIsInJlY3Vyc2UkMCIsImRlZmluZSIsInJlY29yZCIsInZhcmlhbnQiLCJjcmVhdGUkMSIsImUiLCJjb21wYXJlX3QwJDAiLCJhXzE5OCIsImJfMTk5IiwiYl8yMDEiLCJhXzIwMCIsImFfMTQ2IiwiYl8xNDkiLCJiXzE0NyIsImFfMTQ4IiwiYV8xNTIiLCJhXzE1MCIsImJfMTUzIiwiYl8xNTEiLCJhXzE1NCIsImJfMTU1IiwiY29tcGFyZV90MCIsImFfMTU2IiwiYl8xNTciLCJhXzE1OCIsImJfMTU5IiwiYV8xNjAiLCJiXzE2MSIsImFfMTYyIiwiYl8xNjMiLCJ0XzE2NSIsInRfMTY0IiwidF8xNjciLCJ0XzE2NiIsImFfMTY4IiwiYl8xNjkiLCJhXzE3MCIsImJfMTcxIiwidF8xNzMiLCJ0XzE3MiIsInRfMTc1IiwidF8xNzQiLCJhXzE3NiIsImJfMTc3IiwiYV8wMDIiLCJiXzE3OSIsImFfMDA0IiwiYl8wMDUiLCJ0XzAwNyIsInRfMDA2IiwidF8wMDkiLCJ0XzAwOCIsImFfMTgyIiwiYl8xODMiLCJhXzE4NiIsImFfMTg0IiwiYl8xODciLCJiXzE4NSIsIm4kMiIsImFfMTg4IiwiYl8xODkiLCJhXzE5MiIsImFfMTkwIiwiYl8xOTMiLCJiXzE5MSIsIm4kMSIsImFfMTk0IiwiYl8xOTUiLCJhXzE5NiIsImJfMTk3IiwidDBfb2Zfc2V4cCIsInNleHBfMjA4IiwidGFnXzIwOSIsInNleHBfYXJnc18yMTAiLCJhcmcwXzIxMSIsInJlczBfMjEyIiwic2V4cF9vZl90MCIsImFyZzBfMjEzIiwicmVzMF8yMTQiLCJlcXVhbF90MCIsInZhciQyIiwiYXBwbHkkMSIsImQiLCJyZWN1cnNlJDEiLCJyIiwiZ2V0X3BvbHlfdmFyaWFudCQwIiwiY2MiLCJ0YWIiLCJvcGFxdWUkMCIsInRvX2RpZ2VzdCQxIiwidG9fZGlnZXN0JDIiLCJhbm5vdGF0ZSQwIiwiYmFzZXR5cGUkMCIsInR1cGxlJDAiLCJwb2x5X3ZhcmlhbnQkMCIsInZhciQzIiwicmVjdXJzZSQyIiwiYXBwbHkkMiIsImRlZmluZSQwIiwicmVjb3JkJDAiLCJ2YXJpYW50JDAiLCJjcmVhdGUkMiIsImV4cCIsInRvX3N0cmluZ19odW0iLCJzZXhwX29mX3QkMyIsIm9mX3N0cmluZyQxIiwidG9fc3RyaW5nJDIiLCJzeW1ib2wiLCJjb21wYXJlJDEiLCJlcXVhbCQwIiwic2V4cF9vZl90JDQiLCJvZl9zdHJpbmckMiIsInRvX3N0cmluZyQzIiwiY29tcGFyYXRvciIsImNvbXBhcmUkMiIsInNleHBfb2ZfdCQ1IiwiY3JlYXRlJDMiLCJ0cmlwcyIsImdpZCIsIm1lbWJlcnMiLCJ2cyIsImxvb2t1cCIsImciLCJjdXN0b21fcHJpbnRmXzI4NSIsInNjaGVtZSIsImFubm90YXRlJDEiLCJ2MCIsInYxIiwiYmFzZXR5cGUkMSIsInJlY29yZCQxIiwidmFyaWFudCQxIiwidHVwbGUkMSIsInJlY19hcHAiLCJ0b3BfYXBwIiwidjIiLCJzZXhwX29mX3QkNiIsImFyZzFfMjg3IiwiYXJnMF8yODYiLCJyZXMwXzI4OCIsInJlczFfMjg5IiwiYXJnMV8yOTEiLCJhcmcwXzI5MCIsInJlczBfMjkyIiwicmVzMV8yOTMiLCJhcmcwXzI5OCIsInJlczBfMjk5IiwiYXJnMV8yOTUiLCJhcmcwXzI5NCIsInJlczBfMjk2IiwicmVzMV8yOTciLCJhcmcwXzMwNCIsInJlczBfMzA1IiwiYXJnMV8zMDEiLCJhcmcwXzMwMCIsInJlczBfMzAyIiwicmVzMV8zMDMiLCJhcmcwXzMwNiIsInJlczBfMzA3IiwiYXJnMF8zMTIiLCJhcmcxXzMwOSIsImFyZzBfMzA4IiwicmVzMF8zMTAiLCJyZXMxXzMxMSIsInZfMjQ1IiwiYXJnMV8yNDciLCJhcmcwXzI0NiIsInJlczBfMjQ4IiwicmVzMV8yNDkiLCJ2XzI1MCIsImFyZzFfMjUyIiwiYXJnMF8yNTEiLCJyZXMwXzI1MyIsInJlczFfMjU0IiwicmVzMF8zMTMiLCJhcmcwXzMxOCIsImFyZzFfMzE1IiwiYXJnMF8zMTQiLCJyZXMwXzMxNiIsInJlczFfMzE3IiwicmVzMF8zMTkiLCJhcmcxXzMyMSIsImFyZzBfMzIwIiwicmVzMF8zMjIiLCJyZXMxXzMyMyIsImFyZzJfMzI2IiwiYXJnMV8zMjUiLCJhcmcwXzMyNCIsIm1lbWJlcnNfMjc1IiwibG9jXzI3MyIsImdpZF8yNzEiLCJhcmdfMjc2IiwiYXJnMV8yODIiLCJhcmcwXzI4MSIsInJlczBfMjgzIiwiYXJnMV8yNzgiLCJhcmcwXzI3NyIsInJlczBfMjc5IiwicmVzMV8yODAiLCJyZXMxXzI4NCIsImJuZHNfMjcwIiwiYXJnXzI3NCIsImJuZHNfMjcwJDAiLCJhcmdfMjcyIiwiYm5kc18yNzAkMSIsInJlczBfMzI3IiwicmVzMV8zMjgiLCJyZXMyXzMyOSIsImNvbnN0ciIsImluaGVyaXQiLCJ2YXIkNCIsInBvbHlfdmFyaWFudCQxIiwiaXNfY3ljbGljXzAiLCJ2aWFfVlIiLCJncm91cCIsInNldCIsInZpc2l0ZWQiLCJ0cmF2IiwidHMiLCJjcyIsInRzJDAiLCJ0cmF2X3RpZCIsImJvZHkiLCJyZXMiLCJsb29rdXAkMCIsImFfMzMwIiwiYl8zMzEiLCJ0XzMzMyIsInRfMzMyIiwidF8zMzUiLCJ0XzMzNCIsImFyZzFfMzM3IiwiYXJnMF8zMzYiLCJyZXMwXzMzOCIsInJlczFfMzM5IiwiZmluZCIsImVtcHR5IiwiZXh0ZW5kIiwicmV0dXJuJDAiLCJ0ZW52IiwiYmluZCIsImRlcHRoIiwibG9va19lbnYiLCJrZXkiLCJyZXN1bHQiLCJleHRlbmRfbmV3X3RpZCIsImRlZl90IiwidmFsdWUiLCJ0ZW52JDAiLCJleGVjIiwic3ltYm9sX2JpbmQiLCJyZXR1cm4kMSIsInNlcXVlbmNlX2RlZmluaW5nIiwibG9vcCIsImFjY195cyIsInZlbnYiLCJzJDAiLCJldmFsX2xpc3QiLCJiaW5kcyIsImFsdHMiLCJ5cyIsInhzcyIsImV2YWxfcG9seV9jb25zdHIiLCJ2aWQiLCJsb2MkMCIsImN1c3RvbV9wcmludGZfMzQwIiwiYXJncyIsImV2YWxfYXBwIiwiYXJncyQwIiwidGlkJDAiLCJpbl9ncm91cCIsImMiLCJldmFsX2RlZmluaXRpb24iLCJmb3JtYWxzIiwiaSIsInJlY29yZF9vcl9ub3JtYWxfdmFyaWFudCIsImN5Y2xpYyIsImN5Y2xpY19ub19WUiIsImV2YWwkMCIsImV2YWxfdG9fZGlnZXN0IiwiZXZhbF90b19kaWdlc3Rfc3RyaW5nIiwiZGVjb25zdHJ1Y3RfdHVwbGVfZXhuIl0sInNvdXJjZXMiOlsiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iaW5fcHJvdC9zaGFwZS9iaW5fc2hhcGUubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL29jYW1sL3N0cmluZy5tbGkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7SUFnQ0VBO0lBbUVBQztJQW1PRUM7Ozs7Ozs7Ozs7Ozs7O0lDclRJQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQzs7Ozs7Ozs7Ozs7WURISkMsVUFBVUMsS0FBSUM7SUFDaEIsT0FBQTs7c0JBQXFCQztjQUFjOztpQkFBQTs7Ozs7cUNBQWlCQztzQkFBQSxP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O0tBQUE7O2FBeEdGaVE7O0tBNkdNOzthQTdHTkE7SUFzSHVCO2FBSXZCNEIsT0FDRXBiO0tBQ0Y7TUFBSW9YLFFBaFJKakcsU0FnUmtCLFdDaHRCaEJ0VDtNRGl0QkVnYztNQUNrQixVQUZsQnpDLE9BQ0F5QyxNQUZGN1o7TUFHRUU7S0FDSixPQUFBLDZCQURJQTtJQUNxQjtJQXpOYSxpQ0FvTnRDa2I7O0dBWVM7SUFBQTs2QkE1YUwzTDtJQWdhSjJMOztZQXFCRkMsZUFBZWhMO0lBQW1DLDhDQUFuQ0E7SUFBbUMsT0FBQTtHQUErQjtZQUNqRmlMLHNCQUFzQmpMO0lBQU0sT0FBYyxtQkFEMUNnTCxlQUNzQmhMO0dBQXdDO0dBR2hFO0lBQUE7Ozs7Ozs7Ozs7OztNOzswQ0FoVk9pQzs7O1lBa1ZIaUosc0JBQXNCdmI7SUFDeEIsU0FEd0JBLE1BR2pCLE1BQUEsNkNBSGlCQTtRQUVoQndYLEtBRmdCeFg7SUFFVixPQUFOd1g7R0FDb0I7Ozs7T0FyVnZCbEY7V0N2WkQ5QjtXQUFBTTtXQUFBalQ7V0FBQUk7T0RnY0ZrVDtPQWRKZTtPQUFBRjtPQUFBQztPQWtCSTZFO09BQ0FDO09BRUFFO09BckJKOUU7T0FBQUM7T0FvQkk0RTtPQUVBakY7T0F0QkpIO3NCQWhYSXJSLGFBREFELHFCQUZBRixRQUNBQzs7UUE0T0orSztRQUFBdUQ7UUFJQTJCO1FBRlFiOzs7Ozs7Ozs7Ozs7Ozs7T0FnYUoyTDtPQXFCRkM7T0FDQUM7V0FLRUM7Ozs7RTs7Ozs7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuISBCYXNlXG5cbm1vZHVsZSBMb2NhdGlvbiA6IHNpZ1xuICBpbmNsdWRlIElkZW50aWZpYWJsZS5TXG5lbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTdHJpbmdcbmVuZFxuXG5tb2R1bGUgVXVpZCA6IHNpZ1xuICBpbmNsdWRlIElkZW50aWZpYWJsZS5TXG5lbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTdHJpbmdcbmVuZFxuXG5sZXQgZXZhbF9mYWlsIGxvYyBmbXQgPVxuICBQcmludGYua3NwcmludGYgKGZ1biBzIC0+IGZhaWx3aXRoIChQcmludGYuc3ByaW50ZiAhXCIle0xvY2F0aW9ufTogJXNcIiBsb2MgcykpIGZtdFxuOztcblxubGV0IGVxdWFsX29wdGlvbiBlcXVhbCBhIGIgPVxuICBtYXRjaCBhLCBiIHdpdGhcbiAgfCBTb21lIF8sIE5vbmUgfCBOb25lLCBTb21lIF8gLT4gZmFsc2VcbiAgfCBOb25lLCBOb25lIC0+IHRydWVcbiAgfCBTb21lIHgsIFNvbWUgeSAtPiBlcXVhbCB4IHlcbjs7XG5cbm1vZHVsZSBTb3J0ZWRfdGFibGUgOiBzaWdcbiAgdHlwZSAnYSB0IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG5cbiAgdmFsIGNyZWF0ZSA6IExvY2F0aW9uLnQgLT4gZXE6KCdhIC0+ICdhIC0+IGJvb2wpIC0+IChzdHJpbmcgKiAnYSkgbGlzdCAtPiAnYSB0XG4gIHZhbCBleHBvc2UgOiAnYSB0IC0+IChzdHJpbmcgKiAnYSkgbGlzdFxuICB2YWwgbWFwIDogJ2EgdCAtPiBmOignYSAtPiAnYikgLT4gJ2IgdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9IHsgc29ydGVkIDogKHN0cmluZyAqICdhKSBsaXN0IH0gW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cblxuICBsZXQgbWVyZ2VfY2hlY2tfYWRqYWNlbnRfZHVwc1xuICAgIDogIGVxOignYSAtPiAnYSAtPiBib29sKSAtPiAoc3RyaW5nICogJ2EpIGxpc3RcbiAgICAgIC0+IFsgYE9rIG9mIChzdHJpbmcgKiAnYSkgbGlzdCB8IGBNaXNtYXRjaCBvZiBzdHJpbmcgXVxuICAgID1cbiAgICBmdW4gfmVxIC0+XG4gICAgbGV0IHJlYyBsb29wIGFjYyB+bGFzdF9rZXkgfmxhc3RfdmFsdWUgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBgT2sgKExpc3QucmV2IGFjYylcbiAgICAgIHwgKGtleSwgdmFsdWUpIDo6IHhzIC0+XG4gICAgICAgIGlmIFN0cmluZy4obGFzdF9rZXkgPSBrZXkpXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBpZiBlcSBsYXN0X3ZhbHVlIHZhbHVlIHRoZW4gbG9vcCBhY2Mgfmxhc3Rfa2V5IH5sYXN0X3ZhbHVlIHhzIGVsc2UgYE1pc21hdGNoIGtleVxuICAgICAgICBlbHNlIGxvb3AgKChrZXksIHZhbHVlKSA6OiBhY2MpIH5sYXN0X2tleTprZXkgfmxhc3RfdmFsdWU6dmFsdWUgeHNcbiAgICBpblxuICAgIGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBgT2sgW11cbiAgICB8IChrZXksIHZhbHVlKSA6OiB4cyAtPiBsb29wIFsga2V5LCB2YWx1ZSBdIH5sYXN0X2tleTprZXkgfmxhc3RfdmFsdWU6dmFsdWUgeHNcbiAgOztcblxuICBsZXQgY3JlYXRlIGxvYyB+ZXEgeHMgPVxuICAgIGxldCBzb3J0ZWQgPSBMaXN0LnNvcnQgfmNvbXBhcmU6KGZ1biAoczEsIF8pIChzMiwgXykgLT4gU3RyaW5nLmNvbXBhcmUgczEgczIpIHhzIGluXG4gICAgbWF0Y2ggbWVyZ2VfY2hlY2tfYWRqYWNlbnRfZHVwcyB+ZXEgc29ydGVkIHdpdGhcbiAgICB8IGBPayBzb3J0ZWQgLT4geyBzb3J0ZWQgfVxuICAgIHwgYE1pc21hdGNoIHMgLT5cbiAgICAgIGV2YWxfZmFpbCBsb2MgXCJEaWZmZXJlbnQgc2hhcGVzIGZvciBkdXBsaWNhdGVkIHBvbHltb3JwaGljIGNvbnN0cnVjdG9yOiBgJXNcIiBzICgpXG4gIDs7XG5cbiAgbGV0IGV4cG9zZSB0ID0gdC5zb3J0ZWRcbiAgbGV0IG1hcCB0IH5mID0geyBzb3J0ZWQgPSBMaXN0Lm1hcCB0LnNvcnRlZCB+ZjooZnVuIChrLCB2KSAtPiBrLCBmIHYpIH1cbmVuZFxuXG5tb2R1bGUgRGlnZXN0IDogc2lnXG4gIHR5cGUgdCA9IE1kNV9saWIudCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuXG4gIHZhbCB0b19tZDUgOiB0IC0+IE1kNV9saWIudFxuICB2YWwgb2ZfbWQ1IDogTWQ1X2xpYi50IC0+IHRcbiAgdmFsIHRvX2hleCA6IHQgLT4gc3RyaW5nXG4gIHZhbCBjb25zdHJ1Y3RvciA6IHN0cmluZyAtPiB0IGxpc3QgLT4gdFxuICB2YWwgbGlzdCA6IHQgbGlzdCAtPiB0XG4gIHZhbCBwYWlyIDogdCAtPiB0IC0+IHRcbiAgdmFsIHN0cmluZyA6IHN0cmluZyAtPiB0XG4gIHZhbCB1dWlkIDogVXVpZC50IC0+IHRcbiAgdmFsIGludCA6IGludCAtPiB0XG4gIHZhbCBvcHRpb24gOiB0IG9wdGlvbiAtPiB0XG5lbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNZDVfbGliXG5cbiAgbGV0IHRvX21kNSB0ID0gdFxuICBsZXQgb2ZfbWQ1IHQgPSB0XG4gIGxldCBzZXhwX29mX3QgdCA9IHQgfD4gdG9faGV4IHw+IHNleHBfb2Zfc3RyaW5nXG4gIGxldCB0X29mX3NleHAgcyA9IHMgfD4gc3RyaW5nX29mX3NleHAgfD4gb2ZfaGV4X2V4blxuICBsZXQgdXVpZCB1ID0gc3RyaW5nIChVdWlkLnRvX3N0cmluZyB1KVxuICBsZXQgaW50IHggPSBzdHJpbmcgKEludC50b19zdHJpbmcgeClcbiAgbGV0IHBhaXIgeCB5ID0gc3RyaW5nICh0b19iaW5hcnkgeCBeIHRvX2JpbmFyeSB5KVxuICBsZXQgbGlzdCBsID0gc3RyaW5nIChTdHJpbmcuY29uY2F0IH5zZXA6XCJcIiAoTGlzdC5tYXAgfmY6dG9fYmluYXJ5IGwpKVxuICBsZXQgY29uc3RydWN0b3IgcyBsID0gc3RyaW5nIChzIF4gdG9fYmluYXJ5IChsaXN0IGwpKVxuXG4gIGxldCBvcHRpb24gPSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBjb25zdHJ1Y3RvciBcIm5vbmVcIiBbXVxuICAgIHwgU29tZSB4IC0+IGNvbnN0cnVjdG9yIFwic29tZVwiIFsgeCBdXG4gIDs7XG5lbmRcblxubW9kdWxlIENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IgPSBzdHJ1Y3RcbiAgKCogWydhIHRdIGlzIGEgbm9uLXJlY3Vyc2l2ZSB0eXBlLCB1c2VkIHRvIHJlcHJlc2VudCAxLWxheWVyIG9mIGV4cHJlc3Npb24uICBUaGVcbiAgICAgcmVjdXJzaXZlIGtub3QgaXMgdGllZCBiZWxvdyBpbiBbQ2Fub25pY2FsX2Z1bGwuRXhwLnRdLiAqKVxuICB0eXBlICdhIHQgPVxuICAgIHwgQW5ub3RhdGUgb2YgVXVpZC50ICogJ2FcbiAgICB8IEJhc2Ugb2YgVXVpZC50ICogJ2EgbGlzdFxuICAgIHwgVHVwbGUgb2YgJ2EgbGlzdFxuICAgIHwgUmVjb3JkIG9mIChzdHJpbmcgKiAnYSkgbGlzdFxuICAgIHwgVmFyaWFudCBvZiAoc3RyaW5nICogJ2EgbGlzdCkgbGlzdFxuICAgICgqIFBvbHltb3JwaGljIHZhcmlhbnRzIGFyZSBpbnNlbnNpdGl2ZSB0byB0aGUgb3JkZXIgdGhlIGNvbnN0cnVjdG9ycyBhcmUgbGlzdGVkICopXG4gICAgfCBQb2x5X3ZhcmlhbnQgb2YgJ2Egb3B0aW9uIFNvcnRlZF90YWJsZS50XG4gICAgKCogTGVmdC1oYW5kLXNpZGUgb2YgW0FwcGxpY2F0aW9uXSBpcyBhIHBvdGVudGlhbGx5IHJlY3Vyc2l2ZSBkZWZpbml0aW9uOiBpdFxuICAgICAgIGNhbiByZWZlciB0byBpdHNlbGYgdXNpbmcgW1JlY19hcHAgKGksIF8pXSB3aGVyZSBbaV0gaXMgdGhlIGRlcHRoIG9mIHRoaXNcbiAgICAgICBhcHBsaWNhdGlvbiBub2RlIChob3cgbWFueSBhcHBsaWNhdGlvbiBub2RlcyBhcmUgYWJvdmUgaXQpLlxuICAgICAgIEl0IGFsc28gaGFzIGl0cyBvd24gc2NvcGUgb2YgdHlwZSB2YXJpYWJsZXMgc28gaXQgY2FuIG5vdCByZWZlciB0byB0eXBlIHZhcmlhYmxlc1xuICAgICAgIG9mIHRoZSBlbmNsb3Npbmcgc2NvcGUuXG4gICAgKilcbiAgICB8IEFwcGxpY2F0aW9uIG9mICdhICogJ2EgbGlzdFxuICAgIHwgUmVjX2FwcCBvZiBpbnQgKiAnYSBsaXN0XG4gICAgfCBWYXIgb2YgaW50XG4gIFtAQGRlcml2aW5nIHNleHAsIGNvbXBhcmVdXG5cbiAgbGV0IG1hcCB4IH5mID1cbiAgICBtYXRjaCB4IHdpdGhcbiAgICB8IEFubm90YXRlICh1LCB4KSAtPiBBbm5vdGF0ZSAodSwgZiB4KVxuICAgIHwgQmFzZSAocywgeHMpIC0+IEJhc2UgKHMsIExpc3QubWFwIH5mIHhzKVxuICAgIHwgVHVwbGUgeHMgLT4gVHVwbGUgKExpc3QubWFwIH5mIHhzKVxuICAgIHwgUmVjb3JkIGwgLT4gUmVjb3JkIChMaXN0Lm1hcCBsIH5mOihmdW4gKHMsIHgpIC0+IHMsIGYgeCkpXG4gICAgfCBWYXJpYW50IGwgLT4gVmFyaWFudCAoTGlzdC5tYXAgbCB+ZjooZnVuIChzLCB4cykgLT4gcywgTGlzdC5tYXAgfmYgeHMpKVxuICAgIHwgUG9seV92YXJpYW50IHQgLT4gUG9seV92YXJpYW50IChTb3J0ZWRfdGFibGUubWFwIHQgfmY6KE9wdGlvbi5tYXAgfmYpKVxuICAgIHwgQXBwbGljYXRpb24gKHgsIGwpIC0+IEFwcGxpY2F0aW9uIChmIHgsIExpc3QubWFwIH5mIGwpXG4gICAgfCBSZWNfYXBwICh0LCBsKSAtPiBSZWNfYXBwICh0LCBMaXN0Lm1hcCB+ZiBsKVxuICAgIHwgVmFyIHYgLT4gVmFyIHZcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nIHQgPSBTZXhwLnRvX3N0cmluZyAoc2V4cF9vZl90IChmdW4gXyAtPiBBdG9tIFwiLi4uXCIpIHQpXG5lbmRcblxubW9kdWxlIENyZWF0ZV9kaWdlc3QgOiBzaWdcbiAgKCogRGlnZXN0IHZhcmlvdXMgZXhwcmVzc2lvbiBmb3JtcyAqKVxuXG4gIHZhbCBkaWdlc3RfbGF5ZXIgOiBEaWdlc3QudCBDYW5vbmljYWxfZXhwX2NvbnN0cnVjdG9yLnQgLT4gRGlnZXN0LnRcbmVuZCA9IHN0cnVjdFxuICBsZXQgZGlnZXN0X2xheWVyID0gZnVuY3Rpb25cbiAgICB8IENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IuQW5ub3RhdGUgKHUsIHgpIC0+XG4gICAgICBEaWdlc3QuY29uc3RydWN0b3IgXCJhbm5vdGF0ZVwiIFsgRGlnZXN0LnV1aWQgdTsgeCBdXG4gICAgfCBCYXNlICh1LCBsKSAtPiBEaWdlc3QuY29uc3RydWN0b3IgXCJiYXNlXCIgWyBEaWdlc3QudXVpZCB1OyBEaWdlc3QubGlzdCBsIF1cbiAgICB8IFR1cGxlIGwgLT4gRGlnZXN0LmNvbnN0cnVjdG9yIFwidHVwbGVcIiBbIERpZ2VzdC5saXN0IGwgXVxuICAgIHwgUmVjb3JkIGwgLT5cbiAgICAgIERpZ2VzdC5jb25zdHJ1Y3RvclxuICAgICAgICBcInJlY29yZFwiXG4gICAgICAgIFsgRGlnZXN0Lmxpc3QgKExpc3QubWFwIGwgfmY6KGZ1biAocywgdCkgLT4gRGlnZXN0LnBhaXIgKERpZ2VzdC5zdHJpbmcgcykgdCkpIF1cbiAgICB8IFZhcmlhbnQgbCAtPlxuICAgICAgRGlnZXN0LmNvbnN0cnVjdG9yXG4gICAgICAgIFwidmFyaWFudFwiXG4gICAgICAgIFsgRGlnZXN0Lmxpc3RcbiAgICAgICAgICAgIChMaXN0Lm1hcCBsIH5mOihmdW4gKHMsIGwpIC0+IERpZ2VzdC5wYWlyIChEaWdlc3Quc3RyaW5nIHMpIChEaWdlc3QubGlzdCBsKSkpXG4gICAgICAgIF1cbiAgICB8IFBvbHlfdmFyaWFudCB0YWJsZSAtPlxuICAgICAgRGlnZXN0LmNvbnN0cnVjdG9yXG4gICAgICAgIFwicG9seV92YXJpYW50XCJcbiAgICAgICAgWyBEaWdlc3QubGlzdFxuICAgICAgICAgICAgKExpc3QubWFwIChTb3J0ZWRfdGFibGUuZXhwb3NlIHRhYmxlKSB+ZjooZnVuICh4LCB5KSAtPlxuICAgICAgICAgICAgICAgRGlnZXN0LnBhaXIgKERpZ2VzdC5zdHJpbmcgeCkgKERpZ2VzdC5vcHRpb24geSkpKVxuICAgICAgICBdXG4gICAgfCBBcHBsaWNhdGlvbiAoeCwgbCkgLT4gRGlnZXN0LmNvbnN0cnVjdG9yIFwiYXBwbGljYXRpb25cIiBbIHg7IERpZ2VzdC5saXN0IGwgXVxuICAgIHwgUmVjX2FwcCAobiwgbCkgLT4gRGlnZXN0LmNvbnN0cnVjdG9yIFwicmVjX2FwcFwiIFsgRGlnZXN0LmludCBuOyBEaWdlc3QubGlzdCBsIF1cbiAgICB8IFZhciBuIC0+IERpZ2VzdC5jb25zdHJ1Y3RvciBcInZhclwiIFsgRGlnZXN0LmludCBuIF1cbiAgOztcbmVuZFxuXG5tb2R1bGUgVmlzaWJpbGl0eSA9IHN0cnVjdFxuICB0eXBlIHZpc2libGUgPSBWaXNpYmxlXG4gIHR5cGUgb3BhcXVlID0gT3BhcXVlXG5cbiAgbGV0IF8gPSBWaXNpYmxlXG4gIGxldCBfID0gT3BhcXVlXG5lbmRcblxubW9kdWxlIHR5cGUgQ2Fub25pY2FsID0gc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCB0b19kaWdlc3QgOiB0IC0+IERpZ2VzdC50XG5cbiAgbW9kdWxlIEV4cDEgOiBzaWdcbiAgICB0eXBlIF8gdFxuXG4gICAgdmFsIHZhciA6IGludCAtPiBfIHRcbiAgICB2YWwgcmVjdXJzZSA6IGludCAtPiBfIHQgbGlzdCAtPiBfIHRcbiAgICB2YWwgYXBwbHkgOiAnYSB0IC0+ICdhIHQgbGlzdCAtPiBfIHRcbiAgICB2YWwgb3BhcXVlIDogXyB0IC0+IFZpc2liaWxpdHkub3BhcXVlIHRcblxuICAgIHZhbCBnZXRfcG9seV92YXJpYW50XG4gICAgICA6ICBWaXNpYmlsaXR5LnZpc2libGUgdFxuICAgICAgLT4gKFZpc2liaWxpdHkub3BhcXVlIHQgb3B0aW9uIFNvcnRlZF90YWJsZS50LCBzdHJpbmcpIFJlc3VsdC50XG4gIGVuZFxuXG4gIG1vZHVsZSBEZWYgOiBzaWdcbiAgICB0eXBlIHQgPSBWaXNpYmlsaXR5LnZpc2libGUgRXhwMS50XG4gIGVuZFxuXG4gIG1vZHVsZSBDcmVhdGUgOiBzaWdcbiAgICB2YWwgYW5ub3RhdGUgOiBVdWlkLnQgLT4gXyBFeHAxLnQgLT4gXyBFeHAxLnRcbiAgICB2YWwgYmFzZXR5cGUgOiBVdWlkLnQgLT4gXyBFeHAxLnQgbGlzdCAtPiBfIEV4cDEudFxuICAgIHZhbCB0dXBsZSA6IF8gRXhwMS50IGxpc3QgLT4gXyBFeHAxLnRcbiAgICB2YWwgcG9seV92YXJpYW50IDogTG9jYXRpb24udCAtPiAoc3RyaW5nICogXyBFeHAxLnQgb3B0aW9uKSBsaXN0IC0+IF8gRXhwMS50XG4gICAgdmFsIHZhciA6IGludCAtPiBfIEV4cDEudFxuICAgIHZhbCByZWN1cnNlIDogaW50IC0+IF8gRXhwMS50IGxpc3QgLT4gXyBFeHAxLnRcbiAgICB2YWwgYXBwbHkgOiAnYSBFeHAxLnQgLT4gJ2EgRXhwMS50IGxpc3QgLT4gXyBFeHAxLnRcbiAgICB2YWwgZGVmaW5lIDogVmlzaWJpbGl0eS52aXNpYmxlIEV4cDEudCAtPiBEZWYudFxuICAgIHZhbCByZWNvcmQgOiAoc3RyaW5nICogXyBFeHAxLnQpIGxpc3QgLT4gXyBFeHAxLnRcbiAgICB2YWwgdmFyaWFudCA6IChzdHJpbmcgKiBfIEV4cDEudCBsaXN0KSBsaXN0IC0+IF8gRXhwMS50XG4gICAgdmFsIGNyZWF0ZSA6IF8gRXhwMS50IC0+IHRcbiAgZW5kXG5lbmRcblxubW9kdWxlIENhbm9uaWNhbF9kaWdlc3QgOiBDYW5vbmljYWwgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gQ2Fub25pY2FsIG9mIERpZ2VzdC50XG5cbiAgbGV0IHRvX2RpZ2VzdCAoQ2Fub25pY2FsIHgpID0geFxuXG4gIG1vZHVsZSBDRCA9IENyZWF0ZV9kaWdlc3RcblxuICBtb2R1bGUgRXhwMSA9IHN0cnVjdFxuICAgIHR5cGUgb3BhcXVlID0gRGlnZXN0LnRcblxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB8IFBvbHlfdmFyaWFudCBvZiBvcGFxdWUgb3B0aW9uIFNvcnRlZF90YWJsZS50XG4gICAgICB8IE5vbl9wb2x5X3ZhcmlhbnQgb2YgKHN0cmluZyAqIG9wYXF1ZSlcbiAgICAgIHwgT3BhcXVlIDogb3BhcXVlIC0+IFZpc2liaWxpdHkub3BhcXVlIHRcblxuICAgIGxldCB0b19kaWdlc3QgKHR5cGUgYSkgKHggOiBhIHQpID1cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBPcGFxdWUgeCAtPiB4XG4gICAgICB8IE5vbl9wb2x5X3ZhcmlhbnQgKF8sIHgpIC0+IHhcbiAgICAgIHwgUG9seV92YXJpYW50IHggLT4gQ0QuZGlnZXN0X2xheWVyIChQb2x5X3ZhcmlhbnQgeClcbiAgICA7O1xuXG4gICAgbGV0IGVxdWFsICh0eXBlIGEpICh4IDogYSB0KSAoeSA6IGEgdCkgPVxuICAgICAgRGlnZXN0LmNvbXBhcmUgKHRvX2RpZ2VzdCB4KSAodG9fZGlnZXN0IHkpID0gMFxuICAgIDs7XG5cbiAgICBsZXQgb3BhcXVlIHggPSBPcGFxdWUgKHRvX2RpZ2VzdCB4KVxuXG4gICAgbGV0IGNyZWF0ZSB4ID1cbiAgICAgIGxldCB4ID0gQ2Fub25pY2FsX2V4cF9jb25zdHJ1Y3Rvci5tYXAgfmY6dG9fZGlnZXN0IHggaW5cbiAgICAgIGxldCBkZXNjID0gQ2Fub25pY2FsX2V4cF9jb25zdHJ1Y3Rvci50b19zdHJpbmcgeCBpblxuICAgICAgbWF0Y2ggeCB3aXRoXG4gICAgICB8IENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IuUG9seV92YXJpYW50IGwgLT4gUG9seV92YXJpYW50IGxcbiAgICAgIHwgQmFzZSBfIC0+IE5vbl9wb2x5X3ZhcmlhbnQgKGRlc2MsIENELmRpZ2VzdF9sYXllciB4KVxuICAgICAgfCBBbm5vdGF0ZSBfIC0+XG4gICAgICAgICgqIEl0J3MgdW5zYWZlIHRvIHVzZSBkZXJpdmluZyBiaW5faW8gd2hlbiBpbmhlcml0aW5nIGZyb20gYSBwb2x5bW9ycGhpYyB2YXJpYW50XG4gICAgICAgICAgIHRoYXQgaGFzIGEgY3VzdG9tIGJpbl9pby4gIElmIHdlIGZvcmJpZCB0aGF0LCB3ZSBjYW4gaGFwcGlseSByZWplY3QgaGVyZVxuICAgICAgICAgICBhbnl0aGluZyB0aGF0J3MgYW5ub3RhdGVkLiAqKVxuICAgICAgICBOb25fcG9seV92YXJpYW50IChkZXNjLCBDRC5kaWdlc3RfbGF5ZXIgeClcbiAgICAgIHwgQXBwbGljYXRpb24gXyAtPlxuICAgICAgICAoKiBBcHBsaWNhdGlvbiBjYW4gcmVhbGx5IGJlIGEgcG9seS12YXJpYW50IHlvdSBjYW4gaW5oZXJpdCBmcm9tISAgQnV0IGl0J3MgYVxuICAgICAgICAgICByYXJlIHNpdHVhdGlvbiB0aGF0IG1vc3RseSAob25seT8pIGFyaXNlcyB3aXRoIGluaGVyaXRhbmNlIGZyb20gcmVjdXJzaXZlXG4gICAgICAgICAgIHBvbHltb3JwaWMgdmFyaWFudHMsIHdoaWNoIHdlJ3ZlIG5vdCBzZWVuIGFueXdoZXJlIHlldC4gIFNvIHdlIHJlamVjdCBpdC4gKilcbiAgICAgICAgTm9uX3BvbHlfdmFyaWFudCAoZGVzYywgQ0QuZGlnZXN0X2xheWVyIHgpXG4gICAgICB8IFJlY19hcHAgXyAtPlxuICAgICAgICAoKiBZb3UgY2FuIG9ubHkgZ2V0IHRoZSBbUmVjX2FwcF0gY29uc3RydWN0b3IgZm9yIHR5cGUtcmVmZXJlbmNlcyB3aXRoaW4gdGhlXG4gICAgICAgICAgIG11dHVhbCBncm91cCBiZWluZyBkZWZpbmVkLiBSZWZlcmVuY2VzIHdoaWNoXG4gICAgICAgICAgIGZvbGxvdyBhZnRlciB0aGUgY3VycmVudCBncm91cCB3aWxsIGFsd2F5cyBiZSBbQXBwbGljYXRpb25dcy5cblxuICAgICAgICAgICBBbmQgc2luY2Ugb2NhbWwgcmVqZWN0cyByZWZlcmVuY2VzIGluIGBpbmhlcml0YW5jZScgcG9zaXRpb24gdG8gdHlwZXMgd2l0aGluXG4gICAgICAgICAgIHRoZSBjdXJyZW50IGdyb3VwIChzZWUgZXhhbXBsZSkgd2l0aDpcblxuICAgICAgICAgICBFcnJvcjogVGhlIHR5cGUgY29uc3RydWN0b3IgdFxuICAgICAgICAgICBpcyBub3QgeWV0IGNvbXBsZXRlbHkgZGVmaW5lZFxuXG4gICAgICAgICAgIHRoZW4gaXRzIG9rIHRvIHNheSB0aGF0IGEgcmVjLWFwcCBpcyBzb21ldGhpbmcgdGhhdCBjYW4ndCBiZSBpbmhlcml0ZWQgZnJvbSBhbmRcbiAgICAgICAgICAgcmV0dXJuIFtOb25fcG9seV92YXJpYW50XS5cblxuICAgICAgICAgICBBbmQgdW5saWtlIHRoZSBbQXBwbGljYXRpb25dIGNhc2UsIGl0IHNob3VsZCBuZXZlciBiZSBwb3NzaWJsZSB0byBzZWVcbiAgICAgICAgICAgYW4gZXJyb3IgbWVzc2FnZSB3aXRoIHRoZSBbZGVzY10gPSBbUmVjX2FwcF0uXG5cbiAgICAgICAgICAgRXhhbXBsZTogW3R5cGUgdCA9IFtgYSBvZiBbIHwgdF0gXV1cbiAgICAgICAgICAgSGVyZSwgW3wgdF0gd291bGQgYmUgYW4gZXhhbXBsZSBvZiBpbmhlcml0YW5jZSBmcm9tIGEgUmVjX2FwcCwgd2hpY2hcbiAgICAgICAgICAgaXMgcmVqZWN0ZWQgYnkgdGhlIGNvbXBpbGVyLlxuICAgICAgICAqKVxuICAgICAgICBOb25fcG9seV92YXJpYW50IChkZXNjLCBDRC5kaWdlc3RfbGF5ZXIgeClcbiAgICAgIHwgVmFyIF8gfCBUdXBsZSBfIHwgUmVjb3JkIF8gfCBWYXJpYW50IF8gLT5cbiAgICAgICAgTm9uX3BvbHlfdmFyaWFudCAoZGVzYywgQ0QuZGlnZXN0X2xheWVyIHgpXG4gICAgOztcblxuICAgIGxldCB2YXIgeCA9IGNyZWF0ZSAoVmFyIHgpXG4gICAgbGV0IGFwcGx5IGRlZiBsID0gY3JlYXRlIChBcHBsaWNhdGlvbiAoZGVmLCBsKSlcbiAgICBsZXQgcmVjdXJzZSB0aWQgbCA9IGNyZWF0ZSAoUmVjX2FwcCAodGlkLCBsKSlcblxuICAgIGxldCBnZXRfcG9seV92YXJpYW50ICh4IDogVmlzaWJpbGl0eS52aXNpYmxlIHQpID1cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBOb25fcG9seV92YXJpYW50IChkZXNjLCBfKSAtPiBFcnJvciBkZXNjXG4gICAgICB8IFBvbHlfdmFyaWFudCBsIC0+IE9rIChTb3J0ZWRfdGFibGUubWFwIH5mOihPcHRpb24ubWFwIH5mOihmdW4geCAtPiBPcGFxdWUgeCkpIGwpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIERlZiA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IFZpc2liaWxpdHkudmlzaWJsZSBFeHAxLnRcbiAgZW5kXG5cbiAgbW9kdWxlIENyZWF0ZSA9IHN0cnVjdFxuICAgIGxldCBhbm5vdGF0ZSB1IHggPSBFeHAxLmNyZWF0ZSAoQW5ub3RhdGUgKHUsIHgpKVxuICAgIGxldCBiYXNldHlwZSB1IGwgPSBFeHAxLmNyZWF0ZSAoQmFzZSAodSwgbCkpXG4gICAgbGV0IHR1cGxlIGwgPSBFeHAxLmNyZWF0ZSAoVHVwbGUgbClcblxuICAgIGxldCBwb2x5X3ZhcmlhbnQgbG9jIGwgPVxuICAgICAgRXhwMS5jcmVhdGUgKFBvbHlfdmFyaWFudCAoU29ydGVkX3RhYmxlLmNyZWF0ZSBsb2MgfmVxOihlcXVhbF9vcHRpb24gRXhwMS5lcXVhbCkgbCkpXG4gICAgOztcblxuICAgIGxldCB2YXIgeCA9IEV4cDEuY3JlYXRlIChWYXIgeClcbiAgICBsZXQgYXBwbHkgeCBsID0gRXhwMS5jcmVhdGUgKEFwcGxpY2F0aW9uICh4LCBsKSlcbiAgICBsZXQgcmVjdXJzZSB0IGwgPSBFeHAxLmNyZWF0ZSAoUmVjX2FwcCAodCwgbCkpXG4gICAgbGV0IGRlZmluZSB4ID0geFxuICAgIGxldCByZWNvcmQgbCA9IEV4cDEuY3JlYXRlIChSZWNvcmQgbClcbiAgICBsZXQgdmFyaWFudCBsID0gRXhwMS5jcmVhdGUgKFZhcmlhbnQgbClcbiAgICBsZXQgY3JlYXRlIGUgPSBDYW5vbmljYWwgKEV4cDEudG9fZGlnZXN0IGUpXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBDYW5vbmljYWxfZnVsbCA6IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cblxuICBpbmNsdWRlIENhbm9uaWNhbCB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsIHRvX3N0cmluZ19odW0gOiB0IC0+IHN0cmluZ1xuZW5kID0gc3RydWN0XG4gIG1vZHVsZSBDRCA9IENyZWF0ZV9kaWdlc3RcblxuICBtb2R1bGUgRXhwMSA9IHN0cnVjdFxuICAgIHR5cGUgdDAgPSBFeHAgb2YgdDAgQ2Fub25pY2FsX2V4cF9jb25zdHJ1Y3Rvci50IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG5cbiAgICBsZXQgZXF1YWxfdDAgeCB5ID0gY29tcGFyZV90MCB4IHkgPSAwXG5cbiAgICB0eXBlICdhIHQgPSB0MCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuXG4gICAgbGV0IHZhciB4ID0gRXhwIChDYW5vbmljYWxfZXhwX2NvbnN0cnVjdG9yLlZhciB4KVxuICAgIGxldCBhcHBseSBkIHhzID0gRXhwIChDYW5vbmljYWxfZXhwX2NvbnN0cnVjdG9yLkFwcGxpY2F0aW9uIChkLCB4cykpXG4gICAgbGV0IHJlY3Vyc2UgciB4cyA9IEV4cCAoQ2Fub25pY2FsX2V4cF9jb25zdHJ1Y3Rvci5SZWNfYXBwIChyLCB4cykpXG5cbiAgICBsZXQgcG9seV92YXJpYW50IGxvYyB4cyA9XG4gICAgICBFeHBcbiAgICAgICAgKENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IuUG9seV92YXJpYW50XG4gICAgICAgICAgIChTb3J0ZWRfdGFibGUuY3JlYXRlIGxvYyB+ZXE6KGVxdWFsX29wdGlvbiBlcXVhbF90MCkgeHMpKVxuICAgIDs7XG5cbiAgICBsZXQgZ2V0X3BvbHlfdmFyaWFudCA9IGZ1bmN0aW9uXG4gICAgICB8IEV4cCAoUG9seV92YXJpYW50IHRhYikgLT4gT2sgdGFiXG4gICAgICB8IEV4cCBjYyAtPiBFcnJvciAoQ2Fub25pY2FsX2V4cF9jb25zdHJ1Y3Rvci50b19zdHJpbmcgY2MpXG4gICAgOztcblxuICAgIGxldCBvcGFxdWUgdCA9IHRcblxuICAgIGxldCByZWMgdG9fZGlnZXN0ID0gZnVuY3Rpb25cbiAgICAgIHwgRXhwIGUgLT4gQ0QuZGlnZXN0X2xheWVyIChDYW5vbmljYWxfZXhwX2NvbnN0cnVjdG9yLm1hcCB+Zjp0b19kaWdlc3QgZSlcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgRGVmID0gc3RydWN0XG4gICAgKCogQSBbRGVmLnRdIGlzIGFuIGV4cHJlc3Npb24gd2hpY2ggbWF5IGJlIGFwcGxpZWQgKilcbiAgICB0eXBlIHQgPSBFeHAxLnQwIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG4gIGVuZFxuXG4gICgqIEEgY2Fub25pY2FsIHNoYXBlIFt0XSBpcyBhbiBbRXhwMS50XS4gKilcbiAgdHlwZSB0ID0gRXhwMS50MCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuXG4gIGxldCB0b19kaWdlc3QgZSA9IEV4cDEudG9fZGlnZXN0IGVcblxuICBtb2R1bGUgQ3JlYXRlID0gc3RydWN0XG4gICAgbGV0IGFubm90YXRlIHUgeCA9IEV4cDEuRXhwIChBbm5vdGF0ZSAodSwgeCkpXG4gICAgbGV0IGJhc2V0eXBlIHUgeHMgPSBFeHAxLkV4cCAoQmFzZSAodSwgeHMpKVxuICAgIGxldCB0dXBsZSB4cyA9IEV4cDEuRXhwIChUdXBsZSB4cylcbiAgICBsZXQgcG9seV92YXJpYW50IGxvYyB4cyA9IEV4cDEucG9seV92YXJpYW50IGxvYyB4c1xuICAgIGxldCB2YXIgbiA9IEV4cDEuRXhwIChWYXIgbilcbiAgICBsZXQgcmVjdXJzZSByIHhzID0gRXhwMS5yZWN1cnNlIHIgeHNcbiAgICBsZXQgYXBwbHkgZCB4cyA9IEV4cDEuYXBwbHkgZCB4c1xuICAgIGxldCBkZWZpbmUgeCA9IHhcbiAgICBsZXQgcmVjb3JkIHhzID0gRXhwMS5FeHAgKFJlY29yZCB4cylcbiAgICBsZXQgdmFyaWFudCB4cyA9IEV4cDEuRXhwIChWYXJpYW50IHhzKVxuICAgIGxldCBjcmVhdGUgZXhwID0gZXhwXG4gIGVuZFxuXG4gIGxldCB0b19zdHJpbmdfaHVtIHQgPSBTZXhwLnRvX3N0cmluZ19odW0gKHNleHBfb2ZfdCB0KVxuZW5kXG5cbm1vZHVsZSBUaWQgOiBzaWdcbiAgaW5jbHVkZSBJZGVudGlmaWFibGUuU1xuZW5kID0gc3RydWN0XG4gIGluY2x1ZGUgU3RyaW5nXG5lbmRcblxubW9kdWxlIFZpZCA6IHNpZ1xuICBpbmNsdWRlIElkZW50aWZpYWJsZS5TXG5lbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTdHJpbmdcbmVuZFxuXG5tb2R1bGUgR2lkIDogc2lnXG4gICgqIHVuaXF1ZSBncm91cC1pZCwgdXNlZCBhcyBrZXkgZm9yIFRlbnYgYmVsb3cgKilcbiAgdHlwZSB0IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgdmFsIGNyZWF0ZSA6IHVuaXQgLT4gdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9IGludCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuXG4gIGxldCByID0gcmVmIDBcblxuICBsZXQgY3JlYXRlICgpID1cbiAgICBsZXQgdSA9ICFyIGluXG4gICAgciA6PSAxICsgdTtcbiAgICB1XG4gIDs7XG5lbmRcblxubW9kdWxlIEV4cHJlc3Npb24gPSBzdHJ1Y3RcbiAgdHlwZSAndCBwb2x5X2NvbnN0ciA9XG4gICAgWyBgQ29uc3RyIG9mIHN0cmluZyAqICd0IG9wdGlvblxuICAgIHwgYEluaGVyaXQgb2YgTG9jYXRpb24udCAqICd0XG4gICAgXVxuICBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuXG4gIG1vZHVsZSBHcm91cCA6IHNpZ1xuICAgIHR5cGUgJ2EgdCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgdmFsIGNyZWF0ZSA6IExvY2F0aW9uLnQgLT4gKFRpZC50ICogVmlkLnQgbGlzdCAqICdhKSBsaXN0IC0+ICdhIHRcbiAgICB2YWwgaWQgOiAnYSB0IC0+IEdpZC50XG4gICAgdmFsIGxvb2t1cCA6ICdhIHQgLT4gVGlkLnQgLT4gVmlkLnQgbGlzdCAqICdhXG4gIGVuZCA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7IGdpZCA6IEdpZC50XG4gICAgICA7IGxvYyA6IExvY2F0aW9uLnRcbiAgICAgIDsgbWVtYmVycyA6IChUaWQudCAqIChWaWQudCBsaXN0ICogJ2EpKSBsaXN0XG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgIGxldCBjcmVhdGUgbG9jIHRyaXBzID1cbiAgICAgIGxldCBnaWQgPSBHaWQuY3JlYXRlICgpIGluXG4gICAgICBsZXQgbWVtYmVycyA9IExpc3QubWFwIHRyaXBzIH5mOihmdW4gKHgsIHZzLCB0KSAtPiB4LCAodnMsIHQpKSBpblxuICAgICAgeyBnaWQ7IGxvYzsgbWVtYmVycyB9XG4gICAgOztcblxuICAgIGxldCBpZCBnID0gZy5naWRcblxuICAgIGxldCBsb29rdXAgZyB0aWQgPVxuICAgICAgbWF0Y2ggTGlzdC5Bc3NvYy5maW5kIGcubWVtYmVycyB+ZXF1YWw6VGlkLiggPSApIHRpZCB3aXRoXG4gICAgICB8IFNvbWUgc2NoZW1lIC0+IHNjaGVtZVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIGV2YWxfZmFpbFxuICAgICAgICAgIGcubG9jXG4gICAgICAgICAgIVwiaW1wb3NzaWJsZTogbG9va3VwX2dyb3VwLCB1bmJvdW5kIHR5cGUtaWRlbnRpZmllcjogJXtUaWR9XCJcbiAgICAgICAgICB0aWRcbiAgICAgICAgICAoKVxuICAgIDs7XG4gIGVuZFxuXG4gIHR5cGUgdCA9XG4gICAgfCBBbm5vdGF0ZSBvZiBVdWlkLnQgKiB0XG4gICAgfCBCYXNlIG9mIFV1aWQudCAqIHQgbGlzdFxuICAgIHwgUmVjb3JkIG9mIChzdHJpbmcgKiB0KSBsaXN0XG4gICAgfCBWYXJpYW50IG9mIChzdHJpbmcgKiB0IGxpc3QpIGxpc3RcbiAgICB8IFR1cGxlIG9mIHQgbGlzdFxuICAgIHwgUG9seV92YXJpYW50IG9mIChMb2NhdGlvbi50ICogdCBwb2x5X2NvbnN0ciBsaXN0KVxuICAgIHwgVmFyIG9mIChMb2NhdGlvbi50ICogVmlkLnQpXG4gICAgfCBSZWNfYXBwIG9mIFRpZC50ICogdCBsaXN0XG4gICAgfCBUb3BfYXBwIG9mIHQgR3JvdXAudCAqIFRpZC50ICogdCBsaXN0XG4gIFtAQGRlcml2aW5nIHZhcmlhbnRzLCBzZXhwX29mXVxuXG4gIHR5cGUgZ3JvdXAgPSB0IEdyb3VwLnRcblxuICBsZXQgZ3JvdXAgPSBHcm91cC5jcmVhdGVcblxuICB0eXBlIHBvbHlfdmFyaWFudF9yb3cgPSB0IHBvbHlfY29uc3RyXG5cbiAgbGV0IGNvbnN0ciBzIHQgPSBgQ29uc3RyIChzLCB0KVxuICBsZXQgaW5oZXJpdF8gbG9jIHQgPSBgSW5oZXJpdCAobG9jLCB0KVxuICBsZXQgdmFyIGxvYyB0ID0gVmFyIChsb2MsIHQpXG4gIGxldCBwb2x5X3ZhcmlhbnQgbG9jIHhzID0gUG9seV92YXJpYW50IChsb2MsIHhzKVxuICBsZXQgYmFzZXR5cGUgPSBiYXNlXG5cbiAgKCogXCJWUlwiIHN0YW5kcyBmb3IgXCJ2YXJpYW50IG9yIHJlY29yZFwiICopXG5cbiAgbGV0IGlzX2N5Y2xpY18wIH4odmlhX1ZSIDogYm9vbCkgOiBncm91cCAtPiBUaWQudCAtPiBib29sID1cbiAgICBmdW4gZ3JvdXAgdGlkIC0+XG4gICAgbGV0IHNldCA9IHJlZiBbXSBpblxuICAgIGxldCB2aXNpdGVkIHRpZCA9IExpc3QubWVtICFzZXQgdGlkIH5lcXVhbDpUaWQuZXF1YWwgaW5cbiAgICBsZXQgYWRkIHRpZCA9IHNldCA6PSB0aWQgOjogIXNldCBpblxuICAgIGxldCByZWMgdHJhdiA9IGZ1bmN0aW9uXG4gICAgICAoKiBXZSBsb29rIGZvciBjeWNsZXMgYnkgdHJhdmVyc2luZyB0aGUgc3RydWN0dXJlIG9mIHR5cGUtZXhwcmVzc2lvbnMgKilcbiAgICAgIHwgQW5ub3RhdGUgKF8sIHQpIC0+IHRyYXYgdFxuICAgICAgfCBCYXNlIChfLCB0cykgfCBUdXBsZSB0cyB8IFRvcF9hcHAgKF8sIF8sIHRzKSAtPiBMaXN0Lml0ZXIgdHMgfmY6dHJhdlxuICAgICAgKCogLi5pbmNsdWRpbmcgcG9seS12YXJpYW50cyAqKVxuICAgICAgfCBQb2x5X3ZhcmlhbnQgKF8sIGNzKSAtPlxuICAgICAgICBMaXN0Lml0ZXIgY3MgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgfCBgQ29uc3RyIChfLCBOb25lKSAtPiAoKVxuICAgICAgICAgIHwgYENvbnN0ciAoXywgU29tZSB0KSAtPiB0cmF2IHRcbiAgICAgICAgICB8IGBJbmhlcml0IChfbG9jLCB0KSAtPiB0cmF2IHQpXG4gICAgICAoKiAuLiBhbmQgcmVjb3JkcyAmIChub3JtYWwpIHZhcmlhbnRzICopXG4gICAgICB8IFJlY29yZCB4cyAtPiBpZiB2aWFfVlIgdGhlbiBMaXN0Lml0ZXIgeHMgfmY6KGZ1biAoXywgdCkgLT4gdHJhdiB0KSBlbHNlICgpXG4gICAgICB8IFZhcmlhbnQgeHMgLT5cbiAgICAgICAgaWYgdmlhX1ZSIHRoZW4gTGlzdC5pdGVyIHhzIH5mOihmdW4gKF8sIHRzKSAtPiBMaXN0Lml0ZXIgfmY6dHJhdiB0cykgZWxzZSAoKVxuICAgICAgKCogV2UgZG9udCBmb2xsb3cgdHlwZS12YXJzICopXG4gICAgICB8IFZhciBfIC0+ICgpXG4gICAgICAoKiB0cmF2ZXJzZSAocmVjdXJzaXZlKSB0eXBlLWFwcHMgd2hlbiBmaXJzdCBlbmNvdW50ZXJlZCAqKVxuICAgICAgfCBSZWNfYXBwICh0aWQsIHRzKSAtPlxuICAgICAgICBpZiB2aXNpdGVkIHRpZFxuICAgICAgICB0aGVuICgpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGFkZCB0aWQ7XG4gICAgICAgICAgdHJhdl90aWQgdGlkKTtcbiAgICAgICAgTGlzdC5pdGVyIHRzIH5mOnRyYXZcbiAgICBhbmQgdHJhdl90aWQgdGlkID1cbiAgICAgIGxldCBfLCBib2R5ID0gR3JvdXAubG9va3VwIGdyb3VwIHRpZCBpblxuICAgICAgdHJhdiBib2R5XG4gICAgaW5cbiAgICB0cmF2X3RpZCB0aWQ7XG4gICAgbGV0IHJlcyA9IHZpc2l0ZWQgdGlkIGluXG4gICAgKCpsZXQgX3NzID0gU3RyaW5nLmNvbmNhdCB+c2VwOlwiLFwiIChMaXN0Lm1hcCAoIXNldCkgfmY6KHNwcmludGYgIVwiJXtUaWR9XCIpKSBpbiopXG4gICAgKCpQcmludGYucHJpbnRmICFcImlzX2N5bGljOiAle1RpZH0gLS0+ICglcykgJWIgIC0tICVzJSFcIiB0aWQgX3NzIHJlcyAoR3JvdXAubG9jIGdyb3VwKTsqKVxuICAgIHJlc1xuICA7O1xuXG4gIGxldCBpc19jeWNsaWMgPSBpc19jeWNsaWNfMCB+dmlhX1ZSOnRydWVcbiAgbGV0IGlzX2N5Y2xpY193aXRoX25vX2ludGVydmVuaW5nX1ZSID0gaXNfY3ljbGljXzAgfnZpYV9WUjpmYWxzZVxuZW5kXG5cbmluY2x1ZGUgRXhwcmVzc2lvblxuXG5tb2R1bGUgRXZhbHVhdGlvbiAoQ2Fub25pY2FsIDogQ2Fub25pY2FsKSA9IHN0cnVjdFxuICAoKiBbVmVudi50XVxuICAgICBFbnZpcm9ubWVudCBmb3IgcmVzb2x2aW5nIHR5cGUtdmFycyAqKVxuICBtb2R1bGUgVmVudiA6IHNpZ1xuICAgIHR5cGUgdFxuXG4gICAgdmFsIGxvb2t1cCA6IHQgLT4gVmlkLnQgLT4gVmlzaWJpbGl0eS52aXNpYmxlIENhbm9uaWNhbC5FeHAxLnQgb3B0aW9uXG4gICAgdmFsIGNyZWF0ZSA6IChWaWQudCAqIFZpc2liaWxpdHkudmlzaWJsZSBDYW5vbmljYWwuRXhwMS50KSBsaXN0IC0+IHRcbiAgZW5kID0gc3RydWN0XG4gICAgdHlwZSB0ID0gVmlzaWJpbGl0eS52aXNpYmxlIENhbm9uaWNhbC5FeHAxLnQgTWFwLk0oVmlkKS50XG5cbiAgICBsZXQgY3JlYXRlID1cbiAgICAgIExpc3QuZm9sZFxuICAgICAgICB+aW5pdDooTWFwLmVtcHR5IChtb2R1bGUgVmlkKSlcbiAgICAgICAgfmY6KGZ1biB0IChrLCB2KSAtPiBNYXAuc2V0IH5rZXk6ayB+ZGF0YTp2IHQpXG4gICAgOztcblxuICAgIGxldCBsb29rdXAgdCBrID0gTWFwLmZpbmQgdCBrXG4gIGVuZFxuXG4gIG1vZHVsZSBBcHBsaWNhbmQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgfCBSZWN1cnNpb25fbGV2ZWwgb2YgaW50XG4gICAgICB8IERlZmluaXRpb24gb2YgQ2Fub25pY2FsLkRlZi50XG4gIGVuZFxuXG4gICgqIFtUZW52LnRdXG4gICAgIEVudmlyb25tZW50IGZvciByZXNvbHZpbmcgdHlwZS1kZWZpbml0aW9ucyAqKVxuICBtb2R1bGUgVGVudiA6IHNpZ1xuICAgIHR5cGUga2V5ID0gR2lkLnQgKiBUaWQudFxuICAgIHR5cGUgdFxuXG4gICAgdmFsIGZpbmQgOiB0IC0+IGtleSAtPiBbIGBSZWN1cnNpb25fbGV2ZWwgb2YgaW50IF0gb3B0aW9uXG4gICAgdmFsIGVtcHR5IDogdFxuICAgIHZhbCBleHRlbmQgOiB0IC0+IGtleSAtPiBbIGBSZWN1cnNpb25fbGV2ZWwgb2YgaW50IF0gLT4gdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgS2V5ID0gc3RydWN0XG4gICAgICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBHaWQudCAqIFRpZC50IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG4gICAgICBlbmRcblxuICAgICAgaW5jbHVkZSBUXG4gICAgICBpbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcbiAgICBlbmRcblxuICAgIHR5cGUga2V5ID0gS2V5LnRcbiAgICB0eXBlIHQgPSBbIGBSZWN1cnNpb25fbGV2ZWwgb2YgaW50IF0gTWFwLk0oS2V5KS50XG5cbiAgICBsZXQgZmluZCB0IGsgPSBNYXAuZmluZCB0IGtcbiAgICBsZXQgZW1wdHkgPSBNYXAuZW1wdHkgKG1vZHVsZSBLZXkpXG4gICAgbGV0IGV4dGVuZCB0IGsgdiA9IE1hcC5zZXQgfmtleTprIH5kYXRhOnYgdFxuICBlbmRcblxuICAoKiBbRGVmaW5pbmcudF1cbiAgICAgTW9uYWQgZm9yIG1hbmFnaW5nIHVuLXJvbGxpbmcgZGVwdGgsIGFuZCBtYWludGFpbmcgYSBbVGVudi50XSAqKVxuICBtb2R1bGUgRGVmaW5pbmcgOiBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAnYSB0XG4gICAgdmFsIGJpbmQgOiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XG4gICAgdmFsIGxvb2tfZW52IDogVGVudi5rZXkgLT4gQXBwbGljYW5kLnQgb3B0aW9uIHRcbiAgICB2YWwgZXh0ZW5kX25ld190aWQgOiBUZW52LmtleSAtPiBDYW5vbmljYWwuRGVmLnQgdCAtPiBBcHBsaWNhbmQudCB0XG4gICAgdmFsIGV4ZWMgOiAnYSB0IC0+ICdhXG4gIGVuZCA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9IGRlcHRoOmludCAtPiBUZW52LnQgLT4gJ2FcblxuICAgIGxldCByZXR1cm4geCB+ZGVwdGg6XyBfdGVudiA9IHhcblxuICAgIGxldCBiaW5kIHQgZiB+ZGVwdGggdGVudiA9XG4gICAgICBsZXQgeCA9IHQgfmRlcHRoIHRlbnYgaW5cbiAgICAgIChmIHgpIH5kZXB0aCB0ZW52XG4gICAgOztcblxuICAgIGxldCBsb29rX2VudiBrZXkgfmRlcHRoOl8gdGVudiA9XG4gICAgICBsZXQgcmVzdWx0ID0gVGVudi5maW5kIHRlbnYga2V5IGluXG4gICAgICBPcHRpb24ubWFwIH5mOihmdW4gKGBSZWN1cnNpb25fbGV2ZWwgeCkgLT4gQXBwbGljYW5kLlJlY3Vyc2lvbl9sZXZlbCB4KSByZXN1bHRcbiAgICA7O1xuXG4gICAgbGV0IGV4dGVuZF9uZXdfdGlkIGtleSBkZWZfdCB+ZGVwdGggdGVudiA9XG4gICAgICBBcHBsaWNhbmQuRGVmaW5pdGlvblxuICAgICAgICAobGV0IHZhbHVlID0gYFJlY3Vyc2lvbl9sZXZlbCBkZXB0aCBpblxuICAgICAgICAgbGV0IHRlbnYgPSBUZW52LmV4dGVuZCB0ZW52IGtleSB2YWx1ZSBpblxuICAgICAgICAgZGVmX3QgfmRlcHRoOihkZXB0aCArIDEpIHRlbnYpXG4gICAgOztcblxuICAgIGxldCBleGVjIHQgPSB0IH5kZXB0aDowIFRlbnYuZW1wdHlcbiAgZW5kXG5cbiAgdHlwZSAnYSBkZWZpbmluZyA9ICdhIERlZmluaW5nLnRcblxuICBsZXQgKCA+Pj0gKSA9IERlZmluaW5nLmJpbmRcbiAgbGV0IHJldHVybiA9IERlZmluaW5nLnJldHVyblxuXG4gIGxldCBzZXF1ZW5jZV9kZWZpbmluZyA6ICdhIGxpc3QgLT4gZjooJ2EgLT4gJ2IgZGVmaW5pbmcpIC0+ICdiIGxpc3QgZGVmaW5pbmcgPVxuICAgIGZ1biB4cyB+ZiAtPlxuICAgIGxldCByZWMgbG9vcCBhY2NfeXMgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByZXR1cm4gKExpc3QucmV2IGFjY195cylcbiAgICAgIHwgeCA6OiB4cyAtPiBmIHggPj49IGZ1biB5IC0+IGxvb3AgKHkgOjogYWNjX3lzKSB4c1xuICAgIGluXG4gICAgbG9vcCBbXSB4c1xuICA7O1xuXG4gICgqXG4gICAgIFNoYXBlIGV2YWx1YXRpb24uXG5cbiAgICAgU2hhcGVzIGFyZSBldmFsdWF0ZWQgdG8gY2Fub25pY2FsLXNoYXBlIChleHByZXNzaW9ucyksIHdpdGggYWRkaXRpb25hbCBkZWZzIGNvbGxlY3RlZFxuICAgICBpbiB0aGUgW2RlZmluaW5nXSBtb25hZCwgd2hpY2ggYWxzbyBtYW5hZ2VzIGdlbmVyYXRpb24vbWFwcGluZyB0byBbQ2Fub25pY2FsLlRpZC50XVxuXG4gICAgIFRoZXJlIGlzIGRvd253YXJkcyBjb250ZXh0IG9mIFtncm91cF0gYW5kIFtWZW52LnRdXG4gICAgIFRoZSAoY3VycmVudCkgW2dyb3VwXSBjaGFuZ2VzIHdoZW4gdGhlIGNhc2UgZm9yIFtUb3BfYXBwXSBjYWxscyBbZXZhbF9hcHBdLlxuXG4gICAgIFRoZSBjdXJyZW50IFtWZW52LnRdIGlzIGFiYW5kb25lZCB3aGVuIFtldmFsX2FwcF0gaXMgY2FsbGVkLCBhbmQgdGhlbiByZS1jcmVhdGVkIGFmdGVyXG4gICAgIHRoZSBkZWNpc2lvbiBoYXMgYmVlbiBtYWRlIHRvIGVpdGhlciBpbmxpbmUgdGhlIHR5cGUtYXBwbGljYXRpb24sIG9yIG1ha2UgYSByZWZlcmVuY2VcbiAgICAgdG8gYSB0eXBlLWRlZmluaXRpb24sIHdoaWNoIGlzIGNyZWF0ZWQgYXQgbW9zdCBvbmNlIGZvciBlYWNoIChHaWQudCAqIFRpZC50KS5cblxuICAgICBXZSBtYWtlIGEgdHlwZS1kZWZpbml0aW9uIGFsd2F5cyBmb3IgUmVjb3JkcyBhbmQgVmFyaWFudHMsIGFuZCBpbiBhZGRpdGlvbiBmb3IgYW55XG4gICAgIG90aGVyIGN5Y2xpYyB0eXBlLWRlZmluaXRpb24uXG4gICopXG5cbiAgbGV0IHJlYyBldmFsIDogZ3JvdXAgLT4gVmVudi50IC0+IHQgLT4gVmlzaWJpbGl0eS52aXNpYmxlIENhbm9uaWNhbC5FeHAxLnQgZGVmaW5pbmcgPVxuICAgIGZ1biBncm91cCB2ZW52IHQgLT5cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBSZWNvcmQgYmluZHMgLT5cbiAgICAgICAgc2VxdWVuY2VfZGVmaW5pbmcgYmluZHMgfmY6KGZ1biAocywgeCkgLT5cbiAgICAgICAgICBldmFsIGdyb3VwIHZlbnYgeCA+Pj0gZnVuIHkgLT4gcmV0dXJuIChzLCB5KSlcbiAgICAgICAgPj49IGZ1biBiaW5kcyAtPiByZXR1cm4gKENhbm9uaWNhbC5DcmVhdGUucmVjb3JkIGJpbmRzKVxuICAgICAgfCBWYXJpYW50IGFsdHMgLT5cbiAgICAgICAgc2VxdWVuY2VfZGVmaW5pbmcgYWx0cyB+ZjooZnVuIChzLCB4cykgLT5cbiAgICAgICAgICBldmFsX2xpc3QgZ3JvdXAgdmVudiB4cyA+Pj0gZnVuIHlzIC0+IHJldHVybiAocywgeXMpKVxuICAgICAgICA+Pj0gZnVuIGFsdHMgLT4gcmV0dXJuIChDYW5vbmljYWwuQ3JlYXRlLnZhcmlhbnQgYWx0cylcbiAgICAgIHwgVmFyIChsb2MsIHZpZCkgLT5cbiAgICAgICAgKG1hdGNoIFZlbnYubG9va3VwIHZlbnYgdmlkIHdpdGhcbiAgICAgICAgIHwgU29tZSB4IC0+IHJldHVybiB4XG4gICAgICAgICB8IE5vbmUgLT4gZXZhbF9mYWlsIGxvYyAhXCJGcmVlIHR5cGUgdmFyaWFibGU6ICcle1ZpZH1cIiB2aWQgKCkpXG4gICAgICB8IEFubm90YXRlIChzLCB0KSAtPlxuICAgICAgICBldmFsIGdyb3VwIHZlbnYgdCA+Pj0gZnVuIHYgLT4gcmV0dXJuIChDYW5vbmljYWwuQ3JlYXRlLmFubm90YXRlIHMgdilcbiAgICAgIHwgQmFzZSAocywgdHMpIC0+XG4gICAgICAgIGV2YWxfbGlzdCBncm91cCB2ZW52IHRzID4+PSBmdW4gdnMgLT4gcmV0dXJuIChDYW5vbmljYWwuQ3JlYXRlLmJhc2V0eXBlIHMgdnMpXG4gICAgICB8IFR1cGxlIHRzIC0+IGV2YWxfbGlzdCBncm91cCB2ZW52IHRzID4+PSBmdW4gdnMgLT4gcmV0dXJuIChDYW5vbmljYWwuQ3JlYXRlLnR1cGxlIHZzKVxuICAgICAgfCBUb3BfYXBwIChpbl9ncm91cCwgdGlkLCBhcmdzKSAtPlxuICAgICAgICBldmFsX2xpc3QgZ3JvdXAgdmVudiBhcmdzXG4gICAgICAgID4+PSBmdW4gYXJncyAtPlxuICAgICAgICAoKiBhcmdzIGV2YWx1YXRlZCBpbiBjdXJyZW50IGdyb3VwICopXG4gICAgICAgIGV2YWxfYXBwIGluX2dyb3VwIHRpZCBhcmdzXG4gICAgICAoKiBncm91cCBjaGFuZ2VkIGhlcmUgKilcbiAgICAgIHwgUmVjX2FwcCAodGlkLCBhcmdzKSAtPlxuICAgICAgICBldmFsX2xpc3QgZ3JvdXAgdmVudiBhcmdzID4+PSBmdW4gYXJncyAtPiBldmFsX2FwcCBncm91cCB0aWQgYXJnc1xuICAgICAgfCBQb2x5X3ZhcmlhbnQgKGxvYywgY3MpIC0+XG4gICAgICAgIHNlcXVlbmNlX2RlZmluaW5nIH5mOihldmFsX3BvbHlfY29uc3RyIGdyb3VwIHZlbnYpIGNzXG4gICAgICAgID4+PSBmdW4geHNzIC0+IHJldHVybiAoQ2Fub25pY2FsLkNyZWF0ZS5wb2x5X3ZhcmlhbnQgbG9jIChMaXN0LmNvbmNhdCB4c3MpKVxuXG4gIGFuZCBldmFsX2xpc3QgOiBncm91cCAtPiBWZW52LnQgLT4gdCBsaXN0IC0+IF8gQ2Fub25pY2FsLkV4cDEudCBsaXN0IGRlZmluaW5nID1cbiAgICBmdW4gZ3JvdXAgdmVudiB0cyAtPiBzZXF1ZW5jZV9kZWZpbmluZyB0cyB+ZjooZXZhbCBncm91cCB2ZW52KVxuXG4gIGFuZCBldmFsX3BvbHlfY29uc3RyXG4gICAgOiAgZ3JvdXAgLT4gVmVudi50IC0+IHQgcG9seV9jb25zdHJcbiAgICAgIC0+IChzdHJpbmcgKiBWaXNpYmlsaXR5Lm9wYXF1ZSBDYW5vbmljYWwuRXhwMS50IG9wdGlvbikgbGlzdCBkZWZpbmluZ1xuICAgID1cbiAgICBmdW4gZ3JvdXAgdmVudiBjIC0+XG4gICAgICBtYXRjaCBjIHdpdGhcbiAgICAgIHwgYENvbnN0ciAocywgTm9uZSkgLT4gcmV0dXJuIFsgcywgTm9uZSBdXG4gICAgICB8IGBDb25zdHIgKHMsIFNvbWUgdCkgLT5cbiAgICAgICAgZXZhbCBncm91cCB2ZW52IHQgPj49IGZ1biB2IC0+IHJldHVybiBbIHMsIFNvbWUgKENhbm9uaWNhbC5FeHAxLm9wYXF1ZSB2KSBdXG4gICAgICB8IGBJbmhlcml0IChsb2MsIHQpIC0+XG4gICAgICAgIGV2YWwgZ3JvdXAgdmVudiB0XG4gICAgICAgID4+PSBmdW4gdiAtPlxuICAgICAgICAobWF0Y2ggQ2Fub25pY2FsLkV4cDEuZ2V0X3BvbHlfdmFyaWFudCB2IHdpdGhcbiAgICAgICAgIHwgT2sgdGFiIC0+IHJldHVybiAoU29ydGVkX3RhYmxlLmV4cG9zZSB0YWIpXG4gICAgICAgICB8IEVycm9yIGRlc2MgLT5cbiAgICAgICAgICAgZXZhbF9mYWlsXG4gICAgICAgICAgICAgbG9jXG4gICAgICAgICAgICAgXCJUaGUgc2hhcGUgZm9yIGFuIGluaGVyaXRlZCB0eXBlIGlzIG5vdCBkZXNjcmliZWQgYXMgYSBwb2x5bW9ycGhpYy12YXJpYW50OiAlc1wiXG4gICAgICAgICAgICAgZGVzY1xuICAgICAgICAgICAgICgpKVxuXG4gIGFuZCBldmFsX2RlZmluaXRpb24gOiBncm91cCAtPiBWaWQudCBsaXN0IC0+IHQgLT4gQ2Fub25pY2FsLkRlZi50IGRlZmluaW5nID1cbiAgICBmdW4gZ3JvdXAgZm9ybWFscyBib2R5IC0+XG4gICAgICBsZXQgdmVudiA9IFZlbnYuY3JlYXRlIChMaXN0Lm1hcGkgZm9ybWFscyB+ZjooZnVuIGkgeCAtPiB4LCBDYW5vbmljYWwuRXhwMS52YXIgaSkpIGluXG4gICAgICBldmFsIGdyb3VwIHZlbnYgYm9keSA+Pj0gZnVuIHYgLT4gcmV0dXJuIChDYW5vbmljYWwuQ3JlYXRlLmRlZmluZSB2KVxuXG4gIGFuZCBldmFsX2FwcCA6IGdyb3VwIC0+IFRpZC50IC0+IF8gQ2Fub25pY2FsLkV4cDEudCBsaXN0IC0+IF8gQ2Fub25pY2FsLkV4cDEudCBkZWZpbmluZyA9XG4gICAgZnVuIGdyb3VwIHRpZCBhcmdzIC0+XG4gICAgICBsZXQgZ2lkID0gR3JvdXAuaWQgZ3JvdXAgaW5cbiAgICAgIGxldCBmb3JtYWxzLCBib2R5ID0gR3JvdXAubG9va3VwIGdyb3VwIHRpZCBpblxuICAgICAgbGV0IHJlY29yZF9vcl9ub3JtYWxfdmFyaWFudCA9XG4gICAgICAgIG1hdGNoIGJvZHkgd2l0aFxuICAgICAgICB8IFJlY29yZCBfIHwgVmFyaWFudCBfIC0+IHRydWVcbiAgICAgICAgfCBUdXBsZSBfIHwgQW5ub3RhdGUgXyB8IEJhc2UgXyB8IFBvbHlfdmFyaWFudCBfIHwgVmFyIF8gfCBSZWNfYXBwIF8gfCBUb3BfYXBwIF8gLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgaW5cbiAgICAgIGxldCBjeWNsaWMgPSBpc19jeWNsaWMgZ3JvdXAgdGlkIGluXG4gICAgICBsZXQgY3ljbGljX25vX1ZSID0gaXNfY3ljbGljX3dpdGhfbm9faW50ZXJ2ZW5pbmdfVlIgZ3JvdXAgdGlkIGluXG4gICAgICBpZiAocmVjb3JkX29yX25vcm1hbF92YXJpYW50ICYmIGN5Y2xpYykgfHwgY3ljbGljX25vX1ZSXG4gICAgICB0aGVuXG4gICAgICAgIERlZmluaW5nLmxvb2tfZW52IChnaWQsIHRpZClcbiAgICAgICAgPj49IChmdW5jdGlvblxuICAgICAgICAgIHwgU29tZSByZWN1cnNlIC0+IHJldHVybiByZWN1cnNlXG4gICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICBEZWZpbmluZy5leHRlbmRfbmV3X3RpZCAoZ2lkLCB0aWQpIChldmFsX2RlZmluaXRpb24gZ3JvdXAgZm9ybWFscyBib2R5KSlcbiAgICAgICAgPj49IGZ1bmN0aW9uXG4gICAgICAgIHwgUmVjdXJzaW9uX2xldmVsIHIgLT4gcmV0dXJuIChDYW5vbmljYWwuRXhwMS5yZWN1cnNlIHIgYXJncylcbiAgICAgICAgfCBEZWZpbml0aW9uIGRlZiAtPiByZXR1cm4gKENhbm9uaWNhbC5FeHAxLmFwcGx5IGRlZiBhcmdzKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCB2ZW52ID1cbiAgICAgICAgICBtYXRjaCBMaXN0LnppcCBmb3JtYWxzIGFyZ3Mgd2l0aFxuICAgICAgICAgIHwgT2sgeCAtPiBWZW52LmNyZWF0ZSB4XG4gICAgICAgICAgfCBVbmVxdWFsX2xlbmd0aHMgLT4gZmFpbHdpdGggXCJhcHBseSwgaW5jb3JyZWN0IHR5cGUgYXBwbGljYXRpb24gYXJpdHlcIlxuICAgICAgICBpblxuICAgICAgICBldmFsIGdyb3VwIHZlbnYgYm9keSlcbiAgOztcblxuICAoKiB0b3AgbGV2ZWwgZW50cnkgcG9pbnQgZm9yIGV2YWx1YXRpb24gKilcbiAgbGV0IGV2YWwgOiB0IC0+IENhbm9uaWNhbC50ID1cbiAgICBmdW4gdCAtPlxuICAgICAgbGV0IGdyb3VwID0gZ3JvdXAgKExvY2F0aW9uLm9mX3N0cmluZyBcInRvcC1sZXZlbFwiKSBbXSBpblxuICAgICAgbGV0IHZlbnYgPSBWZW52LmNyZWF0ZSBbXSBpblxuICAgICAgbGV0IHYgPSBEZWZpbmluZy5leGVjIChldmFsIGdyb3VwIHZlbnYgdCkgaW5cbiAgICAgIENhbm9uaWNhbC5DcmVhdGUuY3JlYXRlIHZcbiAgOztcbmVuZFxuXG5tb2R1bGUgQ2Fub25pY2FsID0gc3RydWN0XG4gIGluY2x1ZGUgQ2Fub25pY2FsX2Z1bGxcblxuICBtb2R1bGUgRXhwID0gc3RydWN0XG4gICAgdHlwZSB0ID0gVmlzaWJpbGl0eS52aXNpYmxlIEV4cDEudFxuICBlbmRcbmVuZFxuXG5pbmNsdWRlIEV2YWx1YXRpb24gKENhbm9uaWNhbF9mdWxsKVxubW9kdWxlIENhbm9uaWNhbF9zZWxlY3RlZCA9IENhbm9uaWNhbF9kaWdlc3Rcbm1vZHVsZSBFdmFsdWF0aW9uX3RvX2RpZ2VzdCA9IEV2YWx1YXRpb24gKENhbm9uaWNhbF9zZWxlY3RlZClcblxubGV0IGV2YWxfdG9fZGlnZXN0IGV4cCA9IENhbm9uaWNhbF9zZWxlY3RlZC50b19kaWdlc3QgKEV2YWx1YXRpb25fdG9fZGlnZXN0LmV2YWwgZXhwKVxubGV0IGV2YWxfdG9fZGlnZXN0X3N0cmluZyBleHAgPSBEaWdlc3QudG9faGV4IChldmFsX3RvX2RpZ2VzdCBleHApXG5cbm1vZHVsZSBGb3JfdHlwZXJlcCA9IHN0cnVjdFxuICBleGNlcHRpb24gTm90X2FfdHVwbGUgb2YgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBkZWNvbnN0cnVjdF90dXBsZV9leG4gdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBUdXBsZSB0cyAtPiB0c1xuICAgIHwgXyAtPiByYWlzZSAoTm90X2FfdHVwbGUgdClcbiAgOztcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBOT1RFOlxuICAgSWYgdGhpcyBmaWxlIGlzIHN0cmluZ0xhYmVscy5tbGksIHJ1biB0b29scy9zeW5jX3N0ZGxpYl9kb2NzIGFmdGVyIGVkaXRpbmdcbiAgIGl0IHRvIGdlbmVyYXRlIHN0cmluZy5tbGkuXG5cbiAgIElmIHRoaXMgZmlsZSBpcyBzdHJpbmcubWxpLCBkbyBub3QgZWRpdCBpdCBkaXJlY3RseSAtLSBlZGl0XG4gICBzdHJpbmdMYWJlbHMubWxpIGluc3RlYWQuXG4gKilcblxuKCoqIFN0cmluZ3MuXG5cbiAgICBBIHN0cmluZyBbc10gb2YgbGVuZ3RoIFtuXSBpcyBhbiBpbmRleGFibGUgYW5kIGltbXV0YWJsZSBzZXF1ZW5jZVxuICAgIG9mIFtuXSBieXRlcy4gRm9yIGhpc3RvcmljYWwgcmVhc29ucyB0aGVzZSBieXRlcyBhcmUgcmVmZXJyZWQgdG9cbiAgICBhcyBjaGFyYWN0ZXJzLlxuXG4gICAgVGhlIHNlbWFudGljcyBvZiBzdHJpbmcgZnVuY3Rpb25zIGlzIGRlZmluZWQgaW4gdGVybXMgb2ZcbiAgICBpbmRpY2VzIGFuZCBwb3NpdGlvbnMuIFRoZXNlIGFyZSBkZXBpY3RlZCBhbmQgZGVzY3JpYmVkXG4gICAgYXMgZm9sbG93cy5cblxue3ZcbnBvc2l0aW9ucyAgMCAgIDEgICAyICAgMyAgIDQgICAgbi0xICAgIG5cbiAgICAgICAgICAgKy0tLSstLS0rLS0tKy0tLSsgICAgICstLS0tLStcbiAgaW5kaWNlcyAgfCAwIHwgMSB8IDIgfCAzIHwgLi4uIHwgbi0xIHxcbiAgICAgICAgICAgKy0tLSstLS0rLS0tKy0tLSsgICAgICstLS0tLStcbnZ9XG4gICAge3VsXG4gICAgey0gQW4ge2UgaW5kZXh9IFtpXSBvZiBbc10gaXMgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2UgXFxbWzBdO1tuLTFdXFxdLlxuICAgICAgIEl0IHJlcHJlc2VudHMgdGhlIFtpXXRoIGJ5dGUgKGNoYXJhY3Rlcikgb2YgW3NdIHdoaWNoIGNhbiBiZVxuICAgICAgIGFjY2Vzc2VkIHVzaW5nIHRoZSBjb25zdGFudCB0aW1lIHN0cmluZyBpbmRleGluZyBvcGVyYXRvclxuICAgICAgIFtzLltpXV0ufVxuICAgIHstIEEge2UgcG9zaXRpb259IFtpXSBvZiBbc10gaXMgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2VcbiAgICAgICBcXFtbMF07W25dXFxdLiBJdCByZXByZXNlbnRzIGVpdGhlciB0aGUgcG9pbnQgYXQgdGhlIGJlZ2lubmluZyBvZlxuICAgICAgIHRoZSBzdHJpbmcsIG9yIHRoZSBwb2ludCBiZXR3ZWVuIHR3byBpbmRpY2VzLCBvciB0aGUgcG9pbnQgYXRcbiAgICAgICB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuIFRoZSBbaV10aCBieXRlIGluZGV4IGlzIGJldHdlZW4gcG9zaXRpb25cbiAgICAgICBbaV0gYW5kIFtpKzFdLn19XG5cbiAgICBUd28gaW50ZWdlcnMgW3N0YXJ0XSBhbmQgW2xlbl0gYXJlIHNhaWQgdG8gZGVmaW5lIGEge2UgdmFsaWRcbiAgICBzdWJzdHJpbmd9IG9mIFtzXSBpZiBbbGVuID49IDBdIGFuZCBbc3RhcnRdLCBbc3RhcnQrbGVuXSBhcmVcbiAgICBwb3NpdGlvbnMgb2YgW3NdLlxuXG4gICAge2IgVW5pY29kZSB0ZXh0Ln0gU3RyaW5ncyBiZWluZyBhcmJpdHJhcnkgc2VxdWVuY2VzIG9mIGJ5dGVzLCB0aGV5XG4gICAgY2FuIGhvbGQgYW55IGtpbmQgb2YgdGV4dHVhbCBlbmNvZGluZy4gSG93ZXZlciB0aGUgcmVjb21tZW5kZWRcbiAgICBlbmNvZGluZyBmb3Igc3RvcmluZyBVbmljb2RlIHRleHQgaW4gT0NhbWwgc3RyaW5ncyBpcyBVVEYtOC4gVGhpc1xuICAgIGlzIHRoZSBlbmNvZGluZyB1c2VkIGJ5IFVuaWNvZGUgZXNjYXBlcyBpbiBzdHJpbmcgbGl0ZXJhbHMuIEZvclxuICAgIGV4YW1wbGUgdGhlIHN0cmluZyBbXCJcXHV7MUY0MkJ9XCJdIGlzIHRoZSBVVEYtOCBlbmNvZGluZyBvZiB0aGVcbiAgICBVbmljb2RlIGNoYXJhY3RlciBVKzFGNDJCLlxuXG4gICAge2IgUGFzdCBtdXRhYmlsaXR5Ln0gT0NhbWwgc3RyaW5ncyB1c2VkIHRvIGJlIG1vZGlmaWFibGUgaW4gcGxhY2UsXG4gICAgZm9yIGluc3RhbmNlIHZpYSB0aGUgeyFTdHJpbmcuc2V0fSBhbmQgeyFTdHJpbmcuYmxpdH1cbiAgICBmdW5jdGlvbnMuIFRoaXMgdXNlIGlzIG5vd2FkYXlzIG9ubHkgcG9zc2libGUgd2hlbiB0aGUgY29tcGlsZXIgaXNcbiAgICBwdXQgaW4gXCJ1bnNhZmUtc3RyaW5nXCIgbW9kZSBieSBnaXZpbmcgdGhlIFstdW5zYWZlLXN0cmluZ11cbiAgICBjb21tYW5kLWxpbmUgb3B0aW9uLiBUaGlzIGNvbXBhdGliaWxpdHkgbW9kZSBtYWtlcyB0aGUgdHlwZXNcbiAgICBbc3RyaW5nXSBhbmQgW2J5dGVzXSAoc2VlIHshQnl0ZXMudH0pIGludGVyY2hhbmdlYWJsZSBzbyB0aGF0XG4gICAgZnVuY3Rpb25zIGV4cGVjdGluZyBieXRlIHNlcXVlbmNlcyBjYW4gYWxzbyBhY2NlcHQgc3RyaW5ncyBhc1xuICAgIGFyZ3VtZW50cyBhbmQgbW9kaWZ5IHRoZW0uXG5cbiAgICBUaGUgZGlzdGluY3Rpb24gYmV0d2VlbiBbYnl0ZXNdIGFuZCBbc3RyaW5nXSB3YXMgaW50cm9kdWNlZCBpblxuICAgIE9DYW1sIDQuMDIsIGFuZCB0aGUgXCJ1bnNhZmUtc3RyaW5nXCIgY29tcGF0aWJpbGl0eSBtb2RlIHdhcyB0aGVcbiAgICBkZWZhdWx0IHVudGlsIE9DYW1sIDQuMDUuIFN0YXJ0aW5nIHdpdGggNC4wNiwgdGhlIGNvbXBhdGliaWxpdHlcbiAgICBtb2RlIGlzIG9wdC1pbjsgd2UgaW50ZW5kIHRvIHJlbW92ZSB0aGUgb3B0aW9uIGluIHRoZSBmdXR1cmUuXG5cbiAgICBUaGUgbGFiZWxlZCB2ZXJzaW9uIG9mIHRoaXMgbW9kdWxlIGNhbiBiZSB1c2VkIGFzIGRlc2NyaWJlZCBpbiB0aGVcbiAgICB7IVN0ZExhYmVsc30gbW9kdWxlLlxuKilcblxuKCoqIHsxOnN0cmluZ3MgU3RyaW5nc30gKilcblxudHlwZSB0ID0gc3RyaW5nXG4oKiogVGhlIHR5cGUgZm9yIHN0cmluZ3MuICopXG5cbnZhbCBtYWtlIDogaW50IC0+IGNoYXIgLT4gc3RyaW5nXG4oKiogW21ha2UgbiBjXSBpcyBhIHN0cmluZyBvZiBsZW5ndGggW25dIHdpdGggZWFjaCBpbmRleCBob2xkaW5nIHRoZVxuICAgIGNoYXJhY3RlciBbY10uXG5cbiAgICBAcmFpc2UgSW52YWxpZF9hcmd1bWVudCBpZiBbbiA8IDBdIG9yIFtuID4gXXshU3lzLm1heF9zdHJpbmdfbGVuZ3RofS4gKilcblxudmFsIGluaXQgOiBpbnQgLT4gKGludCAtPiBjaGFyKSAtPiBzdHJpbmdcbigqKiBbaW5pdCBuIGZdIGlzIGEgc3RyaW5nIG9mIGxlbmd0aCBbbl0gd2l0aCBpbmRleFxuICAgIFtpXSBob2xkaW5nIHRoZSBjaGFyYWN0ZXIgW2YgaV0gKGNhbGxlZCBpbiBpbmNyZWFzaW5nIGluZGV4IG9yZGVyKS5cblxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtuIDwgMF0gb3IgW24gPiBdeyFTeXMubWF4X3N0cmluZ19sZW5ndGh9LlxuICAgIEBzaW5jZSA0LjAyLjAgKilcblxudmFsIGVtcHR5IDogc3RyaW5nXG4oKiogVGhlIGVtcHR5IHN0cmluZy5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBvZl9ieXRlcyA6IGJ5dGVzIC0+IHN0cmluZ1xuKCoqIFJldHVybiBhIG5ldyBzdHJpbmcgdGhhdCBjb250YWlucyB0aGUgc2FtZSBieXRlcyBhcyB0aGUgZ2l2ZW4gYnl0ZVxuICAgIHNlcXVlbmNlLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIHRvX2J5dGVzIDogc3RyaW5nIC0+IGJ5dGVzXG4oKiogUmV0dXJuIGEgbmV3IGJ5dGUgc2VxdWVuY2UgdGhhdCBjb250YWlucyB0aGUgc2FtZSBieXRlcyBhcyB0aGUgZ2l2ZW5cbiAgICBzdHJpbmcuXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG4oKiogW2xlbmd0aCBzXSBpcyB0aGUgbGVuZ3RoIChudW1iZXIgb2YgYnl0ZXMvY2hhcmFjdGVycykgb2YgW3NdLiAqKVxuXG5leHRlcm5hbCBnZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuKCoqIFtnZXQgcyBpXSBpcyB0aGUgY2hhcmFjdGVyIGF0IGluZGV4IFtpXSBpbiBbc10uIFRoaXMgaXMgdGhlIHNhbWVcbiAgICBhcyB3cml0aW5nIFtzLltpXV0uXG5cbiAgICBAcmFpc2UgSW52YWxpZF9hcmd1bWVudCBpZiBbaV0gbm90IGFuIGluZGV4IG9mIFtzXS4gKilcblxuKCoqIHsxOmNvbmNhdCBDb25jYXRlbmF0aW5nfVxuXG4gICAge2IgTm90ZS59IFRoZSB7IVN0ZGxpYi4oIF4gKX0gYmluYXJ5IG9wZXJhdG9yIGNvbmNhdGVuYXRlcyB0d29cbiAgICBzdHJpbmdzLiAqKVxuXG52YWwgY29uY2F0IDogc3RyaW5nIC0+IHN0cmluZyBsaXN0IC0+IHN0cmluZ1xuKCoqIFtjb25jYXQgc2VwIHNzXSBjb25jYXRlbmF0ZXMgdGhlIGxpc3Qgb2Ygc3RyaW5ncyBbc3NdLCBpbnNlcnRpbmdcbiAgICB0aGUgc2VwYXJhdG9yIHN0cmluZyBbc2VwXSBiZXR3ZWVuIGVhY2guXG5cbiAgICBAcmFpc2UgSW52YWxpZF9hcmd1bWVudCBpZiB0aGUgcmVzdWx0IGlzIGxvbmdlciB0aGFuXG4gICAgeyFTeXMubWF4X3N0cmluZ19sZW5ndGh9IGJ5dGVzLiAqKVxuXG52YWwgY2F0IDogc3RyaW5nIC0+IHN0cmluZyAtPiBzdHJpbmdcbigqKiBbY2F0IHMxIHMyXSBjb25jYXRlbmF0ZXMgczEgYW5kIHMyIChbczEgXiBzMl0pLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgdGhlIHJlc3VsdCBpcyBsb25nZXIgdGhlblxuICAgIHRoYW4geyFTeXMubWF4X3N0cmluZ19sZW5ndGh9IGJ5dGVzLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxuKCoqIHsxOnByZWRpY2F0ZXMgUHJlZGljYXRlcyBhbmQgY29tcGFyaXNvbnN9ICopXG5cbnZhbCBlcXVhbCA6IHQgLT4gdCAtPiBib29sXG4oKiogW2VxdWFsIHMwIHMxXSBpcyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgW3MwXSBhbmQgW3MxXSBhcmUgY2hhcmFjdGVyLXdpc2VcbiAgICBlcXVhbC5cbiAgICBAc2luY2UgNC4wMy4wICg0LjA1LjAgaW4gU3RyaW5nTGFiZWxzKSAqKVxuXG52YWwgY29tcGFyZSA6IHQgLT4gdCAtPiBpbnRcbigqKiBbY29tcGFyZSBzMCBzMV0gc29ydHMgW3MwXSBhbmQgW3MxXSBpbiBsZXhpY29ncmFwaGljYWwgb3JkZXIuIFtjb21wYXJlXVxuICAgIGJlaGF2ZXMgbGlrZSB7IVN0ZGxpYi5jb21wYXJlfSBvbiBzdHJpbmdzIGJ1dCBtYXkgYmUgbW9yZSBlZmZpY2llbnQuICopXG5cbnZhbCBzdGFydHNfd2l0aCA6XG4gIHByZWZpeCAoKiBjb21tZW50IHRod2FydHMgdG9vbHMvc3luY19zdGRsaWJfZG9jcyAqKSA6c3RyaW5nIC0+IHN0cmluZyAtPiBib29sXG4oKiogW3N0YXJ0c193aXRoIF1bfl1bcHJlZml4IHNdIGlzIFt0cnVlXSBpZiBhbmQgb25seSBpZiBbc10gc3RhcnRzIHdpdGhcbiAgICBbcHJlZml4XS5cblxuICAgIEBzaW5jZSA0LjEzLjAgKilcblxudmFsIGVuZHNfd2l0aCA6XG4gIHN1ZmZpeCAoKiBjb21tZW50IHRod2FydHMgdG9vbHMvc3luY19zdGRsaWJfZG9jcyAqKSA6c3RyaW5nIC0+IHN0cmluZyAtPiBib29sXG4oKiogW2VuZHNfd2l0aCBzdWZmaXggc10gaXMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIFtzXSBlbmRzIHdpdGggW3N1ZmZpeF0uXG5cbiAgICBAc2luY2UgNC4xMy4wICopXG5cbnZhbCBjb250YWluc19mcm9tIDogc3RyaW5nIC0+IGludCAtPiBjaGFyIC0+IGJvb2xcbigqKiBbY29udGFpbnNfZnJvbSBzIHN0YXJ0IGNdIGlzIFt0cnVlXSBpZiBhbmQgb25seSBpZiBbY10gYXBwZWFycyBpbiBbc11cbiAgICBhZnRlciBwb3NpdGlvbiBbc3RhcnRdLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW3N0YXJ0XSBpcyBub3QgYSB2YWxpZCBwb3NpdGlvbiBpbiBbc10uICopXG5cbnZhbCByY29udGFpbnNfZnJvbSA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciAtPiBib29sXG4oKiogW3Jjb250YWluc19mcm9tIHMgc3RvcCBjXSBpcyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgW2NdIGFwcGVhcnMgaW4gW3NdXG4gICAgYmVmb3JlIHBvc2l0aW9uIFtzdG9wKzFdLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW3N0b3AgPCAwXSBvciBbc3RvcCsxXSBpcyBub3QgYSB2YWxpZFxuICAgIHBvc2l0aW9uIGluIFtzXS4gKilcblxudmFsIGNvbnRhaW5zIDogc3RyaW5nIC0+IGNoYXIgLT4gYm9vbFxuKCoqIFtjb250YWlucyBzIGNdIGlzIHshU3RyaW5nLmNvbnRhaW5zX2Zyb219WyBzIDAgY10uICopXG5cbigqKiB7MTpleHRyYWN0IEV4dHJhY3Rpbmcgc3Vic3RyaW5nc30gKilcblxudmFsIHN1YiA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHN0cmluZ1xuKCoqIFtzdWIgcyBwb3MgbGVuXSBpcyBhIHN0cmluZyBvZiBsZW5ndGggW2xlbl0sIGNvbnRhaW5pbmcgdGhlXG4gICAgc3Vic3RyaW5nIG9mIFtzXSB0aGF0IHN0YXJ0cyBhdCBwb3NpdGlvbiBbcG9zXSBhbmQgaGFzIGxlbmd0aFxuICAgIFtsZW5dLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW3Bvc10gYW5kIFtsZW5dIGRvIG5vdCBkZXNpZ25hdGUgYSB2YWxpZFxuICAgIHN1YnN0cmluZyBvZiBbc10uICopXG5cbnZhbCBzcGxpdF9vbl9jaGFyIDogY2hhciAtPiBzdHJpbmcgLT4gc3RyaW5nIGxpc3RcbigqKiBbc3BsaXRfb25fY2hhciBzZXAgc10gaXMgdGhlIGxpc3Qgb2YgYWxsIChwb3NzaWJseSBlbXB0eSlcbiAgICBzdWJzdHJpbmdzIG9mIFtzXSB0aGF0IGFyZSBkZWxpbWl0ZWQgYnkgdGhlIGNoYXJhY3RlciBbc2VwXS5cblxuICAgIFRoZSBmdW5jdGlvbidzIHJlc3VsdCBpcyBzcGVjaWZpZWQgYnkgdGhlIGZvbGxvd2luZyBpbnZhcmlhbnRzOlxuICAgIHt1bFxuICAgIHstIFRoZSBsaXN0IGlzIG5vdCBlbXB0eS59XG4gICAgey0gQ29uY2F0ZW5hdGluZyBpdHMgZWxlbWVudHMgdXNpbmcgW3NlcF0gYXMgYSBzZXBhcmF0b3IgcmV0dXJucyBhXG4gICAgICBzdHJpbmcgZXF1YWwgdG8gdGhlIGlucHV0IChbY29uY2F0IChtYWtlIDEgc2VwKVxuICAgICAgKHNwbGl0X29uX2NoYXIgc2VwIHMpID0gc10pLn1cbiAgICB7LSBObyBzdHJpbmcgaW4gdGhlIHJlc3VsdCBjb250YWlucyB0aGUgW3NlcF0gY2hhcmFjdGVyLn19XG5cbiAgICBAc2luY2UgNC4wNC4wICg0LjA1LjAgaW4gU3RyaW5nTGFiZWxzKSAqKVxuXG4oKiogezE6dHJhbnNmb3JtaW5nIFRyYW5zZm9ybWluZ30gKilcblxudmFsIG1hcCA6IChjaGFyIC0+IGNoYXIpIC0+IHN0cmluZyAtPiBzdHJpbmdcbigqKiBbbWFwIGYgc10gaXMgdGhlIHN0cmluZyByZXN1bHRpbmcgZnJvbSBhcHBseWluZyBbZl0gdG8gYWxsIHRoZVxuICAgIGNoYXJhY3RlcnMgb2YgW3NdIGluIGluY3JlYXNpbmcgb3JkZXIuXG5cbiAgICBAc2luY2UgNC4wMC4wICopXG5cbnZhbCBtYXBpIDogKGludCAtPiBjaGFyIC0+IGNoYXIpIC0+IHN0cmluZyAtPiBzdHJpbmdcbigqKiBbbWFwaSBmIHNdIGlzIGxpa2UgeyFtYXB9IGJ1dCB0aGUgaW5kZXggb2YgdGhlIGNoYXJhY3RlciBpcyBhbHNvXG4gICAgcGFzc2VkIHRvIFtmXS5cblxuICAgIEBzaW5jZSA0LjAyLjAgKilcblxudmFsIGZvbGRfbGVmdCA6ICgnYSAtPiBjaGFyIC0+ICdhKSAtPiAnYSAtPiBzdHJpbmcgLT4gJ2FcbigqKiBbZm9sZF9sZWZ0IGYgeCBzXSBjb21wdXRlcyBbZiAoLi4uIChmIChmIHggcy5bMF0pIHMuWzFdKSAuLi4pIHMuW24tMV1dLFxuICAgIHdoZXJlIFtuXSBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgW3NdLlxuICAgIEBzaW5jZSA0LjEzLjAgKilcblxudmFsIGZvbGRfcmlnaHQgOiAoY2hhciAtPiAnYSAtPiAnYSkgLT4gc3RyaW5nIC0+ICdhIC0+ICdhXG4oKiogW2ZvbGRfcmlnaHQgZiBzIHhdIGNvbXB1dGVzIFtmIHMuWzBdIChmIHMuWzFdICggLi4uIChmIHMuW24tMV0geCkgLi4uKSldLFxuICAgIHdoZXJlIFtuXSBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgW3NdLlxuICAgIEBzaW5jZSA0LjEzLjAgKilcblxudmFsIGZvcl9hbGwgOiAoY2hhciAtPiBib29sKSAtPiBzdHJpbmcgLT4gYm9vbFxuKCoqIFtmb3JfYWxsIHAgc10gY2hlY2tzIGlmIGFsbCBjaGFyYWN0ZXJzIGluIFtzXSBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUgW3BdLlxuICAgIEBzaW5jZSA0LjEzLjAgKilcblxudmFsIGV4aXN0cyA6IChjaGFyIC0+IGJvb2wpIC0+IHN0cmluZyAtPiBib29sXG4oKiogW2V4aXN0cyBwIHNdIGNoZWNrcyBpZiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIG9mIFtzXSBzYXRpc2ZpZXMgdGhlIHByZWRpY2F0ZVxuICAgIFtwXS5cbiAgICBAc2luY2UgNC4xMy4wICopXG5cbnZhbCB0cmltIDogc3RyaW5nIC0+IHN0cmluZ1xuKCoqIFt0cmltIHNdIGlzIFtzXSB3aXRob3V0IGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuIFdoaXRlc3BhY2VcbiAgICBjaGFyYWN0ZXJzIGFyZTogWycgJ10sIFsnXFx4MEMnXSAoZm9ybSBmZWVkKSwgWydcXG4nXSwgWydcXHInXSwgYW5kIFsnXFx0J10uXG5cbiAgICBAc2luY2UgNC4wMC4wICopXG5cbnZhbCBlc2NhcGVkIDogc3RyaW5nIC0+IHN0cmluZ1xuKCoqIFtlc2NhcGVkIHNdIGlzIFtzXSB3aXRoIHNwZWNpYWwgY2hhcmFjdGVycyByZXByZXNlbnRlZCBieSBlc2NhcGVcbiAgICBzZXF1ZW5jZXMsIGZvbGxvd2luZyB0aGUgbGV4aWNhbCBjb252ZW50aW9ucyBvZiBPQ2FtbC5cblxuICAgIEFsbCBjaGFyYWN0ZXJzIG91dHNpZGUgdGhlIFVTLUFTQ0lJIHByaW50YWJsZSByYW5nZSBcXFsweDIwOzB4N0VcXF0gYXJlXG4gICAgZXNjYXBlZCwgYXMgd2VsbCBhcyBiYWNrc2xhc2ggKDB4MkYpIGFuZCBkb3VibGUtcXVvdGUgKDB4MjIpLlxuXG4gICAgVGhlIGZ1bmN0aW9uIHshU2NhbmYudW5lc2NhcGVkfSBpcyBhIGxlZnQgaW52ZXJzZSBvZiBbZXNjYXBlZF0sXG4gICAgaS5lLiBbU2NhbmYudW5lc2NhcGVkIChlc2NhcGVkIHMpID0gc10gZm9yIGFueSBzdHJpbmcgW3NdICh1bmxlc3NcbiAgICBbZXNjYXBlZCBzXSBmYWlscykuXG5cbiAgICBAcmFpc2UgSW52YWxpZF9hcmd1bWVudCBpZiB0aGUgcmVzdWx0IGlzIGxvbmdlciB0aGFuXG4gICAgeyFTeXMubWF4X3N0cmluZ19sZW5ndGh9IGJ5dGVzLiAqKVxuXG52YWwgdXBwZXJjYXNlX2FzY2lpIDogc3RyaW5nIC0+IHN0cmluZ1xuKCoqIFt1cHBlcmNhc2VfYXNjaWkgc10gaXMgW3NdIHdpdGggYWxsIGxvd2VyY2FzZSBsZXR0ZXJzXG4gICAgdHJhbnNsYXRlZCB0byB1cHBlcmNhc2UsIHVzaW5nIHRoZSBVUy1BU0NJSSBjaGFyYWN0ZXIgc2V0LlxuXG4gICAgQHNpbmNlIDQuMDMuMCAoNC4wNS4wIGluIFN0cmluZ0xhYmVscykgKilcblxudmFsIGxvd2VyY2FzZV9hc2NpaSA6IHN0cmluZyAtPiBzdHJpbmdcbigqKiBbbG93ZXJjYXNlX2FzY2lpIHNdIGlzIFtzXSB3aXRoIGFsbCB1cHBlcmNhc2UgbGV0dGVycyB0cmFuc2xhdGVkXG4gICAgdG8gbG93ZXJjYXNlLCB1c2luZyB0aGUgVVMtQVNDSUkgY2hhcmFjdGVyIHNldC5cblxuICAgIEBzaW5jZSA0LjAzLjAgKDQuMDUuMCBpbiBTdHJpbmdMYWJlbHMpICopXG5cbnZhbCBjYXBpdGFsaXplX2FzY2lpIDogc3RyaW5nIC0+IHN0cmluZ1xuKCoqIFtjYXBpdGFsaXplX2FzY2lpIHNdIGlzIFtzXSB3aXRoIHRoZSBmaXJzdCBjaGFyYWN0ZXIgc2V0IHRvXG4gICAgdXBwZXJjYXNlLCB1c2luZyB0aGUgVVMtQVNDSUkgY2hhcmFjdGVyIHNldC5cblxuICAgIEBzaW5jZSA0LjAzLjAgKDQuMDUuMCBpbiBTdHJpbmdMYWJlbHMpICopXG5cbnZhbCB1bmNhcGl0YWxpemVfYXNjaWkgOiBzdHJpbmcgLT4gc3RyaW5nXG4oKiogW3VuY2FwaXRhbGl6ZV9hc2NpaSBzXSBpcyBbc10gd2l0aCB0aGUgZmlyc3QgY2hhcmFjdGVyIHNldCB0byBsb3dlcmNhc2UsXG4gICAgdXNpbmcgdGhlIFVTLUFTQ0lJIGNoYXJhY3RlciBzZXQuXG5cbiAgICBAc2luY2UgNC4wMy4wICg0LjA1LjAgaW4gU3RyaW5nTGFiZWxzKSAqKVxuXG4oKiogezE6dHJhdmVyc2luZyBUcmF2ZXJzaW5nfSAqKVxuXG52YWwgaXRlciA6IChjaGFyIC0+IHVuaXQpIC0+IHN0cmluZyAtPiB1bml0XG4oKiogW2l0ZXIgZiBzXSBhcHBsaWVzIGZ1bmN0aW9uIFtmXSBpbiB0dXJuIHRvIGFsbCB0aGUgY2hhcmFjdGVycyBvZiBbc10uXG4gICAgSXQgaXMgZXF1aXZhbGVudCB0byBbZiBzLlswXTsgZiBzLlsxXTsgLi4uOyBmIHMuW2xlbmd0aCBzIC0gMV07ICgpXS4gKilcblxudmFsIGl0ZXJpIDogKGludCAtPiBjaGFyIC0+IHVuaXQpIC0+IHN0cmluZyAtPiB1bml0XG4oKiogW2l0ZXJpXSBpcyBsaWtlIHshaXRlcn0sIGJ1dCB0aGUgZnVuY3Rpb24gaXMgYWxzbyBnaXZlbiB0aGVcbiAgICBjb3JyZXNwb25kaW5nIGNoYXJhY3RlciBpbmRleC5cblxuICAgIEBzaW5jZSA0LjAwLjAgKilcblxuKCoqIHsxOnNlYXJjaGluZyBTZWFyY2hpbmd9ICopXG5cbnZhbCBpbmRleF9mcm9tIDogc3RyaW5nIC0+IGludCAtPiBjaGFyIC0+IGludFxuKCoqIFtpbmRleF9mcm9tIHMgaSBjXSBpcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgW2NdIGluXG4gICAgW3NdIGFmdGVyIHBvc2l0aW9uIFtpXS5cblxuICAgIEByYWlzZSBOb3RfZm91bmQgaWYgW2NdIGRvZXMgbm90IG9jY3VyIGluIFtzXSBhZnRlciBwb3NpdGlvbiBbaV0uXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW2ldIGlzIG5vdCBhIHZhbGlkIHBvc2l0aW9uIGluIFtzXS4gKilcblxuXG52YWwgaW5kZXhfZnJvbV9vcHQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgLT4gaW50IG9wdGlvblxuKCoqIFtpbmRleF9mcm9tX29wdCBzIGkgY10gaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIFtjXVxuICAgIGluIFtzXSBhZnRlciBwb3NpdGlvbiBbaV0gKGlmIGFueSkuXG5cbiAgICBAcmFpc2UgSW52YWxpZF9hcmd1bWVudCBpZiBbaV0gaXMgbm90IGEgdmFsaWQgcG9zaXRpb24gaW4gW3NdLlxuICAgIEBzaW5jZSA0LjA1ICopXG5cbnZhbCByaW5kZXhfZnJvbSA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciAtPiBpbnRcbigqKiBbcmluZGV4X2Zyb20gcyBpIGNdIGlzIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIFtjXSBpblxuICAgIFtzXSBiZWZvcmUgcG9zaXRpb24gW2krMV0uXG5cbiAgICBAcmFpc2UgTm90X2ZvdW5kIGlmIFtjXSBkb2VzIG5vdCBvY2N1ciBpbiBbc10gYmVmb3JlIHBvc2l0aW9uIFtpKzFdLlxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtpKzFdIGlzIG5vdCBhIHZhbGlkIHBvc2l0aW9uIGluIFtzXS4gKilcblxudmFsIHJpbmRleF9mcm9tX29wdCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciAtPiBpbnQgb3B0aW9uXG4oKiogW3JpbmRleF9mcm9tX29wdCBzIGkgY10gaXMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgW2NdXG4gICAgaW4gW3NdIGJlZm9yZSBwb3NpdGlvbiBbaSsxXSAoaWYgYW55KS5cblxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtpKzFdIGlzIG5vdCBhIHZhbGlkIHBvc2l0aW9uIGluIFtzXS5cbiAgICBAc2luY2UgNC4wNSAqKVxuXG52YWwgaW5kZXggOiBzdHJpbmcgLT4gY2hhciAtPiBpbnRcbigqKiBbaW5kZXggcyBjXSBpcyB7IVN0cmluZy5pbmRleF9mcm9tfVsgcyAwIGNdLiAqKVxuXG52YWwgaW5kZXhfb3B0IDogc3RyaW5nIC0+IGNoYXIgLT4gaW50IG9wdGlvblxuKCoqIFtpbmRleF9vcHQgcyBjXSBpcyB7IVN0cmluZy5pbmRleF9mcm9tX29wdH1bIHMgMCBjXS5cblxuICAgIEBzaW5jZSA0LjA1ICopXG5cbnZhbCByaW5kZXggOiBzdHJpbmcgLT4gY2hhciAtPiBpbnRcbigqKiBbcmluZGV4IHMgY10gaXMgeyFTdHJpbmcucmluZGV4X2Zyb219WyBzIChsZW5ndGggcyAtIDEpIGNdLiAqKVxuXG52YWwgcmluZGV4X29wdCA6IHN0cmluZyAtPiBjaGFyIC0+IGludCBvcHRpb25cbigqKiBbcmluZGV4X29wdCBzIGNdIGlzIHshU3RyaW5nLnJpbmRleF9mcm9tX29wdH1bIHMgKGxlbmd0aCBzIC0gMSkgY10uXG5cbiAgICBAc2luY2UgNC4wNSAqKVxuXG4oKiogezEgU3RyaW5ncyBhbmQgU2VxdWVuY2VzfSAqKVxuXG52YWwgdG9fc2VxIDogdCAtPiBjaGFyIFNlcS50XG4oKiogW3RvX3NlcSBzXSBpcyBhIHNlcXVlbmNlIG1hZGUgb2YgdGhlIHN0cmluZydzIGNoYXJhY3RlcnMgaW5cbiAgICBpbmNyZWFzaW5nIG9yZGVyLiBJbiBbXCJ1bnNhZmUtc3RyaW5nXCJdIG1vZGUsIG1vZGlmaWNhdGlvbnMgb2YgdGhlIHN0cmluZ1xuICAgIGR1cmluZyBpdGVyYXRpb24gd2lsbCBiZSByZWZsZWN0ZWQgaW4gdGhlIHNlcXVlbmNlLlxuXG4gICAgQHNpbmNlIDQuMDcgKilcblxudmFsIHRvX3NlcWkgOiB0IC0+IChpbnQgKiBjaGFyKSBTZXEudFxuKCoqIFt0b19zZXFpIHNdIGlzIGxpa2UgeyF0b19zZXF9IGJ1dCBhbHNvIHR1cGxlcyB0aGUgY29ycmVzcG9uZGluZyBpbmRleC5cblxuICAgIEBzaW5jZSA0LjA3ICopXG5cbnZhbCBvZl9zZXEgOiBjaGFyIFNlcS50IC0+IHRcbigqKiBbb2Zfc2VxIHNdIGlzIGEgc3RyaW5nIG1hZGUgb2YgdGhlIHNlcXVlbmNlJ3MgY2hhcmFjdGVycy5cblxuICAgIEBzaW5jZSA0LjA3ICopXG5cbigqKiB7MTpkZXByZWNhdGVkIERlcHJlY2F0ZWQgZnVuY3Rpb25zfSAqKVxuXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX3N0cmluZ1wiXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWQgXCJVc2UgQnl0ZXMuY3JlYXRlL0J5dGVzTGFiZWxzLmNyZWF0ZSBpbnN0ZWFkLlwiXVxuKCoqIFtjcmVhdGUgbl0gcmV0dXJucyBhIGZyZXNoIGJ5dGUgc2VxdWVuY2Ugb2YgbGVuZ3RoIFtuXS5cbiAgICBUaGUgc2VxdWVuY2UgaXMgdW5pbml0aWFsaXplZCBhbmQgY29udGFpbnMgYXJiaXRyYXJ5IGJ5dGVzLlxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtuIDwgMF0gb3IgW24gPiBdeyFTeXMubWF4X3N0cmluZ19sZW5ndGh9LlxuXG4gICAgQGRlcHJlY2F0ZWQgVGhpcyBpcyBhIGRlcHJlY2F0ZWQgYWxpYXMgb2ZcbiAgICB7IUJ5dGVzLmNyZWF0ZX0veyFCeXRlc0xhYmVscy5jcmVhdGV9LiAqKVxuXG5leHRlcm5hbCBzZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlc3RyaW5nX3NhZmVfc2V0XCJcbiAgW0BAb2NhbWwuZGVwcmVjYXRlZCBcIlVzZSBCeXRlcy5zZXQvQnl0ZXNMYWJlbHMuc2V0IGluc3RlYWQuXCJdXG4oKiogW3NldCBzIG4gY10gbW9kaWZpZXMgYnl0ZSBzZXF1ZW5jZSBbc10gaW4gcGxhY2UsXG4gICAgcmVwbGFjaW5nIHRoZSBieXRlIGF0IGluZGV4IFtuXSB3aXRoIFtjXS5cbiAgICBZb3UgY2FuIGFsc28gd3JpdGUgW3MuW25dIDwtIGNdIGluc3RlYWQgb2YgW3NldCBzIG4gY10uXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW25dIGlzIG5vdCBhIHZhbGlkIGluZGV4IGluIFtzXS5cblxuICAgIEBkZXByZWNhdGVkIFRoaXMgaXMgYSBkZXByZWNhdGVkIGFsaWFzIG9mXG4gICAgeyFCeXRlcy5zZXR9L3shQnl0ZXNMYWJlbHMuc2V0fS4gKilcblxudmFsIGJsaXQgOlxuICBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuKCoqIFtibGl0IHNyYyBzcmNfcG9zIGRzdCBkc3RfcG9zIGxlbl0gY29waWVzIFtsZW5dIGJ5dGVzXG4gICAgZnJvbSB0aGUgc3RyaW5nIFtzcmNdLCBzdGFydGluZyBhdCBpbmRleCBbc3JjX3Bvc10sXG4gICAgdG8gYnl0ZSBzZXF1ZW5jZSBbZHN0XSwgc3RhcnRpbmcgYXQgY2hhcmFjdGVyIG51bWJlciBbZHN0X3Bvc10uXG5cbiAgICBAcmFpc2UgSW52YWxpZF9hcmd1bWVudCBpZiBbc3JjX3Bvc10gYW5kIFtsZW5dIGRvIG5vdFxuICAgIGRlc2lnbmF0ZSBhIHZhbGlkIHJhbmdlIG9mIFtzcmNdLCBvciBpZiBbZHN0X3Bvc10gYW5kIFtsZW5dXG4gICAgZG8gbm90IGRlc2lnbmF0ZSBhIHZhbGlkIHJhbmdlIG9mIFtkc3RdLiAqKVxuXG52YWwgY29weSA6IHN0cmluZyAtPiBzdHJpbmdcbiAgW0BAb2NhbWwuZGVwcmVjYXRlZCBcIlN0cmluZ3Mgbm93IGltbXV0YWJsZTogbm8gbmVlZCB0byBjb3B5XCJdXG4oKiogUmV0dXJuIGEgY29weSBvZiB0aGUgZ2l2ZW4gc3RyaW5nLlxuXG4gICAgQGRlcHJlY2F0ZWQgQmVjYXVzZSBzdHJpbmdzIGFyZSBpbW11dGFibGUsIGl0IGRvZXNuJ3QgbWFrZSBtdWNoXG4gICAgc2Vuc2UgdG8gbWFrZSBpZGVudGljYWwgY29waWVzIG9mIHRoZW0uICopXG5cbnZhbCBmaWxsIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiBjaGFyIC0+IHVuaXRcbiAgW0BAb2NhbWwuZGVwcmVjYXRlZCBcIlVzZSBCeXRlcy5maWxsL0J5dGVzTGFiZWxzLmZpbGwgaW5zdGVhZC5cIl1cbigqKiBbZmlsbCBzIHBvcyBsZW4gY10gbW9kaWZpZXMgYnl0ZSBzZXF1ZW5jZSBbc10gaW4gcGxhY2UsXG4gICAgcmVwbGFjaW5nIFtsZW5dIGJ5dGVzIGJ5IFtjXSwgc3RhcnRpbmcgYXQgW3Bvc10uXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW3Bvc10gYW5kIFtsZW5dIGRvIG5vdFxuICAgIGRlc2lnbmF0ZSBhIHZhbGlkIHN1YnN0cmluZyBvZiBbc10uXG5cbiAgICBAZGVwcmVjYXRlZCBUaGlzIGlzIGEgZGVwcmVjYXRlZCBhbGlhcyBvZlxuICAgIHshQnl0ZXMuZmlsbH0veyFCeXRlc0xhYmVscy5maWxsfS4gKilcblxudmFsIHVwcGVyY2FzZSA6IHN0cmluZyAtPiBzdHJpbmdcbiAgW0BAb2NhbWwuZGVwcmVjYXRlZFxuICAgIFwiVXNlIFN0cmluZy51cHBlcmNhc2VfYXNjaWkvU3RyaW5nTGFiZWxzLnVwcGVyY2FzZV9hc2NpaSBpbnN0ZWFkLlwiXVxuKCoqIFJldHVybiBhIGNvcHkgb2YgdGhlIGFyZ3VtZW50LCB3aXRoIGFsbCBsb3dlcmNhc2UgbGV0dGVyc1xuICAgIHRyYW5zbGF0ZWQgdG8gdXBwZXJjYXNlLCBpbmNsdWRpbmcgYWNjZW50ZWQgbGV0dGVycyBvZiB0aGUgSVNPXG4gICAgTGF0aW4tMSAoODg1OS0xKSBjaGFyYWN0ZXIgc2V0LlxuXG4gICAgQGRlcHJlY2F0ZWQgRnVuY3Rpb25zIG9wZXJhdGluZyBvbiBMYXRpbi0xIGNoYXJhY3RlciBzZXQgYXJlIGRlcHJlY2F0ZWQuICopXG5cbnZhbCBsb3dlcmNhc2UgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWRcbiAgICBcIlVzZSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpL1N0cmluZ0xhYmVscy5sb3dlcmNhc2VfYXNjaWkgaW5zdGVhZC5cIl1cbigqKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBhcmd1bWVudCwgd2l0aCBhbGwgdXBwZXJjYXNlIGxldHRlcnNcbiAgICB0cmFuc2xhdGVkIHRvIGxvd2VyY2FzZSwgaW5jbHVkaW5nIGFjY2VudGVkIGxldHRlcnMgb2YgdGhlIElTT1xuICAgIExhdGluLTEgKDg4NTktMSkgY2hhcmFjdGVyIHNldC5cblxuICAgIEBkZXByZWNhdGVkIEZ1bmN0aW9ucyBvcGVyYXRpbmcgb24gTGF0aW4tMSBjaGFyYWN0ZXIgc2V0IGFyZSBkZXByZWNhdGVkLiAqKVxuXG52YWwgY2FwaXRhbGl6ZSA6IHN0cmluZyAtPiBzdHJpbmdcbiAgW0BAb2NhbWwuZGVwcmVjYXRlZFxuICAgIFwiVXNlIFN0cmluZy5jYXBpdGFsaXplX2FzY2lpL1N0cmluZ0xhYmVscy5jYXBpdGFsaXplX2FzY2lpIGluc3RlYWQuXCJdXG4oKiogUmV0dXJuIGEgY29weSBvZiB0aGUgYXJndW1lbnQsIHdpdGggdGhlIGZpcnN0IGNoYXJhY3RlciBzZXQgdG8gdXBwZXJjYXNlLFxuICAgIHVzaW5nIHRoZSBJU08gTGF0aW4tMSAoODg1OS0xKSBjaGFyYWN0ZXIgc2V0Li5cblxuICAgIEBkZXByZWNhdGVkIEZ1bmN0aW9ucyBvcGVyYXRpbmcgb24gTGF0aW4tMSBjaGFyYWN0ZXIgc2V0IGFyZSBkZXByZWNhdGVkLiAqKVxuXG52YWwgdW5jYXBpdGFsaXplIDogc3RyaW5nIC0+IHN0cmluZ1xuICBbQEBvY2FtbC5kZXByZWNhdGVkXG4gICAgXCJVc2UgU3RyaW5nLnVuY2FwaXRhbGl6ZV9hc2NpaS9TdHJpbmdMYWJlbHMudW5jYXBpdGFsaXplX2FzY2lpIGluc3RlYWQuXCJdXG4oKiogUmV0dXJuIGEgY29weSBvZiB0aGUgYXJndW1lbnQsIHdpdGggdGhlIGZpcnN0IGNoYXJhY3RlciBzZXQgdG8gbG93ZXJjYXNlLFxuICAgIHVzaW5nIHRoZSBJU08gTGF0aW4tMSAoODg1OS0xKSBjaGFyYWN0ZXIgc2V0LlxuXG4gICAgQGRlcHJlY2F0ZWQgRnVuY3Rpb25zIG9wZXJhdGluZyBvbiBMYXRpbi0xIGNoYXJhY3RlciBzZXQgYXJlIGRlcHJlY2F0ZWQuICopXG5cbigqKiB7MSBCaW5hcnkgZGVjb2Rpbmcgb2YgaW50ZWdlcnN9ICopXG5cbigqKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgc2VjdGlvbiBiaW5hcnkgZGVjb2RlIGludGVnZXJzIGZyb20gc3RyaW5ncy5cblxuICAgIEFsbCBmb2xsb3dpbmcgZnVuY3Rpb25zIHJhaXNlIFtJbnZhbGlkX2FyZ3VtZW50XSBpZiB0aGUgY2hhcmFjdGVyc1xuICAgIG5lZWRlZCBhdCBpbmRleCBbaV0gdG8gZGVjb2RlIHRoZSBpbnRlZ2VyIGFyZSBub3QgYXZhaWxhYmxlLlxuXG4gICAgTGl0dGxlLWVuZGlhbiAocmVzcC4gYmlnLWVuZGlhbikgZW5jb2RpbmcgbWVhbnMgdGhhdCBsZWFzdFxuICAgIChyZXNwLiBtb3N0KSBzaWduaWZpY2FudCBieXRlcyBhcmUgc3RvcmVkIGZpcnN0LiAgQmlnLWVuZGlhbiBpc1xuICAgIGFsc28ga25vd24gYXMgbmV0d29yayBieXRlIG9yZGVyLiAgTmF0aXZlLWVuZGlhbiBlbmNvZGluZyBpc1xuICAgIGVpdGhlciBsaXR0bGUtZW5kaWFuIG9yIGJpZy1lbmRpYW4gZGVwZW5kaW5nIG9uIHshU3lzLmJpZ19lbmRpYW59LlxuXG4gICAgMzItYml0IGFuZCA2NC1iaXQgaW50ZWdlcnMgYXJlIHJlcHJlc2VudGVkIGJ5IHRoZSBbaW50MzJdIGFuZFxuICAgIFtpbnQ2NF0gdHlwZXMsIHdoaWNoIGNhbiBiZSBpbnRlcnByZXRlZCBlaXRoZXIgYXMgc2lnbmVkIG9yXG4gICAgdW5zaWduZWQgbnVtYmVycy5cblxuICAgIDgtYml0IGFuZCAxNi1iaXQgaW50ZWdlcnMgYXJlIHJlcHJlc2VudGVkIGJ5IHRoZSBbaW50XSB0eXBlLFxuICAgIHdoaWNoIGhhcyBtb3JlIGJpdHMgdGhhbiB0aGUgYmluYXJ5IGVuY29kaW5nLiAgVGhlc2UgZXh0cmEgYml0c1xuICAgIGFyZSBzaWduLWV4dGVuZGVkIChvciB6ZXJvLWV4dGVuZGVkKSBmb3IgZnVuY3Rpb25zIHdoaWNoIGRlY29kZSA4LWJpdFxuICAgIG9yIDE2LWJpdCBpbnRlZ2VycyBhbmQgcmVwcmVzZW50ZWQgdGhlbSB3aXRoIFtpbnRdIHZhbHVlcy5cbiopXG5cbnZhbCBnZXRfdWludDggOiBzdHJpbmcgLT4gaW50IC0+IGludFxuKCoqIFtnZXRfdWludDggYiBpXSBpcyBbYl0ncyB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyIHN0YXJ0aW5nIGF0IGNoYXJhY3RlclxuICAgIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBnZXRfaW50OCA6IHN0cmluZyAtPiBpbnQgLT4gaW50XG4oKiogW2dldF9pbnQ4IGIgaV0gaXMgW2JdJ3Mgc2lnbmVkIDgtYml0IGludGVnZXIgc3RhcnRpbmcgYXQgY2hhcmFjdGVyXG4gICAgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIGdldF91aW50MTZfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludFxuKCoqIFtnZXRfdWludDE2X25lIGIgaV0gaXMgW2JdJ3MgbmF0aXZlLWVuZGlhbiB1bnNpZ25lZCAxNi1iaXQgaW50ZWdlclxuICAgIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X3VpbnQxNl9iZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50XG4oKiogW2dldF91aW50MTZfYmUgYiBpXSBpcyBbYl0ncyBiaWctZW5kaWFuIHVuc2lnbmVkIDE2LWJpdCBpbnRlZ2VyXG4gICAgc3RhcnRpbmcgYXQgY2hhcmFjdGVyIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBnZXRfdWludDE2X2xlIDogc3RyaW5nIC0+IGludCAtPiBpbnRcbigqKiBbZ2V0X3VpbnQxNl9sZSBiIGldIGlzIFtiXSdzIGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgMTYtYml0IGludGVnZXJcbiAgICBzdGFydGluZyBhdCBjaGFyYWN0ZXIgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIGdldF9pbnQxNl9uZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50XG4oKiogW2dldF9pbnQxNl9uZSBiIGldIGlzIFtiXSdzIG5hdGl2ZS1lbmRpYW4gc2lnbmVkIDE2LWJpdCBpbnRlZ2VyXG4gICAgc3RhcnRpbmcgYXQgY2hhcmFjdGVyIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBnZXRfaW50MTZfYmUgOiBzdHJpbmcgLT4gaW50IC0+IGludFxuKCoqIFtnZXRfaW50MTZfYmUgYiBpXSBpcyBbYl0ncyBiaWctZW5kaWFuIHNpZ25lZCAxNi1iaXQgaW50ZWdlclxuICAgIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X2ludDE2X2xlIDogc3RyaW5nIC0+IGludCAtPiBpbnRcbigqKiBbZ2V0X2ludDE2X2xlIGIgaV0gaXMgW2JdJ3MgbGl0dGxlLWVuZGlhbiBzaWduZWQgMTYtYml0IGludGVnZXJcbiAgICBzdGFydGluZyBhdCBjaGFyYWN0ZXIgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIGdldF9pbnQzMl9uZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50MzJcbigqKiBbZ2V0X2ludDMyX25lIGIgaV0gaXMgW2JdJ3MgbmF0aXZlLWVuZGlhbiAzMi1iaXQgaW50ZWdlclxuICAgIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X2ludDMyX2JlIDogc3RyaW5nIC0+IGludCAtPiBpbnQzMlxuKCoqIFtnZXRfaW50MzJfYmUgYiBpXSBpcyBbYl0ncyBiaWctZW5kaWFuIDMyLWJpdCBpbnRlZ2VyXG4gICAgc3RhcnRpbmcgYXQgY2hhcmFjdGVyIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBnZXRfaW50MzJfbGUgOiBzdHJpbmcgLT4gaW50IC0+IGludDMyXG4oKiogW2dldF9pbnQzMl9sZSBiIGldIGlzIFtiXSdzIGxpdHRsZS1lbmRpYW4gMzItYml0IGludGVnZXJcbiAgICBzdGFydGluZyBhdCBjaGFyYWN0ZXIgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIGdldF9pbnQ2NF9uZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50NjRcbigqKiBbZ2V0X2ludDY0X25lIGIgaV0gaXMgW2JdJ3MgbmF0aXZlLWVuZGlhbiA2NC1iaXQgaW50ZWdlclxuICAgIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X2ludDY0X2JlIDogc3RyaW5nIC0+IGludCAtPiBpbnQ2NFxuKCoqIFtnZXRfaW50NjRfYmUgYiBpXSBpcyBbYl0ncyBiaWctZW5kaWFuIDY0LWJpdCBpbnRlZ2VyXG4gICAgc3RhcnRpbmcgYXQgY2hhcmFjdGVyIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBnZXRfaW50NjRfbGUgOiBzdHJpbmcgLT4gaW50IC0+IGludDY0XG4oKiogW2dldF9pbnQ2NF9sZSBiIGldIGlzIFtiXSdzIGxpdHRsZS1lbmRpYW4gNjQtYml0IGludGVnZXJcbiAgICBzdGFydGluZyBhdCBjaGFyYWN0ZXIgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxuKCoqLyoqKVxuXG4oKiBUaGUgZm9sbG93aW5nIGlzIGZvciBzeXN0ZW0gdXNlIG9ubHkuIERvIG5vdCBjYWxsIGRpcmVjdGx5LiAqKVxuXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVzdHJpbmdfdW5zYWZlX3NldFwiXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWRdXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6XG4gIHN0cmluZyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPlxuICAgIHVuaXQgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOlxuICBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiY2FtbF9maWxsX3N0cmluZ1wiIFtAQG5vYWxsb2NdXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWRdXG4iXX0=
