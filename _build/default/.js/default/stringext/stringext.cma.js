// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1+5.8.1

//# unitInfo: Provides: Stringext
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = cst$4,
    cst$2 = cst$4,
    cst$1 = cst$4,
    cst$0 = cst$4,
    cst = cst$4,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer;
   function string_after(s, n){
    return caml_call3
            (Stdlib_String[15], s, n, caml_ml_string_length(s) - n | 0);
   }
   function quote(s){
    var
     len = caml_ml_string_length(s),
     buf = caml_call1(Stdlib_Buffer[1], 2 * len | 0),
     _Z_ = len - 1 | 0,
     _Y_ = 0;
    if(_Z_ >= 0){
     var i = _Y_;
     for(;;){
      var c = caml_string_get(s, i), ___ = c - 63 | 0;
      a:
      {
       b:
       {
        if(31 < ___ >>> 0){
         var _$_ = ___ + 27 | 0;
         if(10 < _$_ >>> 0) break b;
         switch(_$_){case 0:case 6:case 7:case 10: break;default: break b;
         }
        }
        else if(26 >= ___ - 1 >>> 0) break b;
        caml_call2(Stdlib_Buffer[12], buf, 92);
        caml_call2(Stdlib_Buffer[12], buf, c);
        break a;
       }
       caml_call2(Stdlib_Buffer[12], buf, c);
      }
      var _aa_ = i + 1 | 0;
      if(_Z_ === i) break;
      i = _aa_;
     }
    }
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   var of_char = caml_call1(Stdlib_String[1], 1);
   function full_split(str, on){
    if(str == cst$4) return 0;
    var sep = caml_call1(of_char, on);
    function loop(acc, offset){
     try{
      var index = caml_call3(Stdlib_String[33], str, offset, on);
      if(index === offset)
       var _W_ = loop([0, sep, acc], index - 1 | 0);
      else
       var
        token =
          caml_call3
           (Stdlib_String[15], str, index + 1 | 0, offset - index | 0),
        _W_ = loop([0, sep, [0, token, acc]], index - 1 | 0);
      return _W_;
     }
     catch(_X_){
      var _V_ = caml_wrap_exception(_X_);
      if(_V_ === Stdlib[8])
       return 0 <= offset
               ? [0,
                 caml_call3(Stdlib_String[15], str, 0, offset + 1 | 0),
                 acc]
               : acc;
      throw caml_maybe_attach_backtrace(_V_, 0);
     }
    }
    return loop(0, caml_ml_string_length(str) - 1 | 0);
   }
   function split(max, str, on){
    if(max){
     var max$0 = max[1];
     if(str == cst$4) return 0;
     if(1 === max$0) return [0, str, 0];
     var
      loop =
        function(offset, tokens){
         if(tokens === (max$0 - 1 | 0))
          return [0,
                  caml_call3
                   (Stdlib_String[15],
                    str,
                    offset,
                    caml_ml_string_length(str) - offset | 0),
                  0];
         try{
          var index = caml_call3(Stdlib_String[31], str, offset, on);
          if(index === offset)
           var _T_ = [0, cst, loop(offset + 1 | 0, tokens + 1 | 0)];
          else
           var
            token =
              caml_call3(Stdlib_String[15], str, offset, index - offset | 0),
            _T_ = [0, token, loop(index + 1 | 0, tokens + 1 | 0)];
          return _T_;
         }
         catch(_U_){
          var _S_ = caml_wrap_exception(_U_);
          if(_S_ === Stdlib[8])
           return [0,
                   caml_call3
                    (Stdlib_String[15],
                     str,
                     offset,
                     caml_ml_string_length(str) - offset | 0),
                   0];
          throw caml_maybe_attach_backtrace(_S_, 0);
         }
        };
     return loop(0, 0);
    }
    if(str == cst$4) return 0;
    function loop$0(acc, offset){
     try{
      var index = caml_call3(Stdlib_String[33], str, offset, on);
      if(index === offset)
       var _Q_ = loop$0([0, cst$0, acc], index - 1 | 0);
      else
       var
        token =
          caml_call3
           (Stdlib_String[15], str, index + 1 | 0, offset - index | 0),
        _Q_ = loop$0([0, token, acc], index - 1 | 0);
      return _Q_;
     }
     catch(_R_){
      var _P_ = caml_wrap_exception(_R_);
      if(_P_ === Stdlib[8])
       return [0, caml_call3(Stdlib_String[15], str, 0, offset + 1 | 0), acc];
      throw caml_maybe_attach_backtrace(_P_, 0);
     }
    }
    return loop$0(0, caml_ml_string_length(str) - 1 | 0);
   }
   function trim_left_sub(s, last_char, len, chars){
    var final$0 = last_char + len | 0, last_char$0 = last_char, i = last_char;
    for(;;){
     if(i !== final$0){
      var _O_ = caml_string_get(s, i);
      if(caml_call2(Stdlib_String[14], chars, _O_)){
       var i$0 = i + 1 | 0, last_char$1 = i + 1 | 0;
       last_char$0 = last_char$1;
       i = i$0;
       continue;
      }
     }
     var new_len = len - (last_char$0 - last_char | 0) | 0;
     return caml_call3(Stdlib_String[15], s, last_char$0, new_len);
    }
   }
   function split_trim_left(str, on, trim){
    if(str == cst$4) return 0;
    function loop(acc, offset){
     try{
      var index = offset;
      for(;;){
       if(0 > index) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
       var _K_ = caml_string_get(str, index);
       if(caml_call2(Stdlib_String[14], on, _K_)){
        if(index === offset)
         var _M_ = loop([0, cst$1, acc], index - 1 | 0);
        else
         var
          token = trim_left_sub(str, index + 1 | 0, offset - index | 0, trim),
          _M_ = loop([0, token, acc], index - 1 | 0);
        return _M_;
       }
       var i = index - 1 | 0;
       index = i;
      }
     }
     catch(_N_){
      var _L_ = caml_wrap_exception(_N_);
      if(_L_ === Stdlib[8])
       return [0, trim_left_sub(str, 0, offset + 1 | 0, trim), acc];
      throw caml_maybe_attach_backtrace(_L_, 0);
     }
    }
    return loop(0, caml_ml_string_length(str) - 1 | 0);
   }
   var Found_int = [248, "Stringext.Found_int", caml_fresh_oo_id(0)];
   function trim_left(s){
    var
     _F_ = 0 < caml_ml_string_length(s) ? 1 : 0,
     _G_ = _F_ ? caml_string_get(s, 0) !== 32 ? 1 : 0 : _F_;
    if(_G_) return s;
    var len = caml_ml_string_length(s);
    try{
     var _I_ = len - 1 | 0, _H_ = 0;
     if(_I_ >= 0){
      var i = _H_;
      for(;;){
       if(32 !== caml_string_get(s, i))
        throw caml_maybe_attach_backtrace([0, Found_int, i], 1);
       var _J_ = i + 1 | 0;
       if(_I_ === i) break;
       i = _J_;
      }
     }
     return cst$2;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Found_int) throw caml_maybe_attach_backtrace(exn, 0);
     var non_space = exn[2];
     return caml_call3(Stdlib_String[15], s, non_space, len - non_space | 0);
    }
   }
   function find_from(opt, str, pattern){
    if(opt) var sth = opt[1], start = sth; else var start = 0;
    try{
     var
      _A_ = caml_ml_string_length(str) - caml_ml_string_length(pattern) | 0;
     if(_A_ >= start){
      var start$0 = start;
      for(;;){
       try{
        var _w_ = caml_ml_string_length(pattern) - 1 | 0, _v_ = 0;
        if(_w_ >= 0){
         var i = _v_;
         for(;;){
          var _y_ = caml_string_get(pattern, i);
          if(caml_string_get(str, i + start$0 | 0) !== _y_)
           throw caml_maybe_attach_backtrace(Stdlib[3], 1);
          var _z_ = i + 1 | 0;
          if(_w_ === i) break;
          i = _z_;
         }
        }
        var _x_ = 1, _C_ = _x_;
       }
       catch(_E_){var _C_ = 0;}
       if(_C_) throw caml_maybe_attach_backtrace([0, Found_int, start$0], 1);
       var _D_ = start$0 + 1 | 0;
       if(_A_ === start$0) break;
       start$0 = _D_;
      }
     }
     var _B_ = 0;
     return _B_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Found_int) return 0;
     var i$0 = exn[2];
     return [0, i$0];
    }
   }
   function replace_all(str, pattern, with$0){
    var
     plen = caml_ml_string_length(pattern),
     slen = caml_ml_string_length(str),
     buf = caml_call1(Stdlib_Buffer[1], slen),
     i = 0;
    for(;;){
     var match = find_from([0, i], str, pattern);
     if(! match){
      caml_call4(Stdlib_Buffer[18], buf, str, i, slen - i | 0);
      return caml_call1(Stdlib_Buffer[2], buf);
     }
     var j = match[1];
     caml_call4(Stdlib_Buffer[18], buf, str, i, j - i | 0);
     caml_call2(Stdlib_Buffer[16], buf, with$0);
     var i$0 = j + plen | 0;
     i = i$0;
    }
   }
   var
    Found_replace = [248, "Stringext.Found_replace", caml_fresh_oo_id(0)],
    cst_Stringext_cut_empty_separa = "Stringext.cut: empty separator",
    cst_Stringext_rcut_empty_separ = "Stringext.rcut: empty separator";
   function replace_all_assoc(str, tbl){
    var
     slen = caml_ml_string_length(str),
     buf = caml_call1(Stdlib_Buffer[1], slen),
     i = 0;
    for(;;){
     if(slen <= i) return caml_call1(Stdlib_Buffer[2], buf);
     try{
      var found = [0, 0];
      let i$0 = i, found$0 = found;
      var
       f =
         function(param){
          var
           with$0 = param[2],
           pattern = param[1],
           match = find_from([0, i$0], str, pattern);
          if(! match) return Stdlib[19];
          var j = match[1];
          if(j === i$0)
           throw caml_maybe_attach_backtrace
                  ([0, Found_replace, j, pattern, with$0], 1);
          found$0[1] = 1;
          return j;
         };
      if(tbl){
       var
        xs$0 = tbl[2],
        x$1 = tbl[1],
        fx$1 = f(x$1),
        x = x$1,
        fx = fx$1,
        param = xs$0;
       for(;;){
        if(! param) break;
        var xs = param[2], x$0 = param[1], fx$0 = f(x$0);
        if(runtime.caml_lessthan(fx$0, fx)){x = x$0; fx = fx$0; param = xs;}
        else
         param = xs;
       }
       var e = [0, [0, x, fx]];
      }
      else
       var e = 0;
      if(e)
       var
        _s_ = e[1],
        j$1 = _s_[2],
        match$0 = _s_[1],
        with$2 = match$0[2],
        pattern$1 = match$0[1],
        _t_ = found[1] ? [0, [0, j$1, pattern$1, with$2]] : 0,
        _u_ = _t_;
      else
       var _u_ = 0;
      var r = _u_;
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn[1] !== Found_replace) throw caml_maybe_attach_backtrace(exn, 0);
      var
       with$0 = exn[4],
       pattern = exn[3],
       j = exn[2],
       r = [0, [0, j, pattern, with$0]];
     }
     if(! r){
      caml_call4(Stdlib_Buffer[18], buf, str, i, slen - i | 0);
      return caml_call1(Stdlib_Buffer[2], buf);
     }
     var
      match = r[1],
      with$1 = match[3],
      pattern$0 = match[2],
      j$0 = match[1];
     caml_call4(Stdlib_Buffer[18], buf, str, i, j$0 - i | 0);
     caml_call2(Stdlib_Buffer[16], buf, with$1);
     var i$0 = j$0 + caml_ml_string_length(pattern$0) | 0;
     i = i$0;
    }
   }
   function of_list(xs$0){
    var
     l = caml_call1(Stdlib_List[1], xs$0),
     s = caml_create_bytes(l),
     i = 0,
     param = xs$0;
    for(;;){
     if(! param) return caml_call1(Stdlib_Bytes[48], s);
     var xs = param[2], x = param[1];
     caml_bytes_set(s, i, x);
     var i$0 = i + 1 | 0;
     i = i$0;
     param = xs;
    }
   }
   function to_list(s){
    var i$1 = caml_ml_string_length(s) - 1 | 0, acc = 0, i = i$1;
    for(;;){
     if(-1 === i) return acc;
     var i$0 = i - 1 | 0, acc$0 = [0, caml_string_get(s, i), acc];
     acc = acc$0;
     i = i$0;
    }
   }
   function of_array(a){
    var
     len = a.length - 1,
     bytes = caml_create_bytes(len),
     _q_ = len - 1 | 0,
     _p_ = 0;
    if(_q_ >= 0){
     var i = _p_;
     for(;;){
      caml_bytes_set(bytes, i, runtime.caml_check_bound(a, i)[1 + i]);
      var _r_ = i + 1 | 0;
      if(_q_ === i) break;
      i = _r_;
     }
    }
    return caml_call1(Stdlib_Bytes[48], bytes);
   }
   function to_array(s){
    return caml_call2
            (Stdlib_Array[2],
             caml_ml_string_length(s),
             function(_o_){return caml_string_get(s, _o_);});
   }
   function cut(s, on){
    var sep_max = caml_ml_string_length(on) - 1 | 0;
    if(0 > sep_max)
     return caml_call1(Stdlib[1], cst_Stringext_cut_empty_separa);
    var s_max = caml_ml_string_length(s) - 1 | 0;
    if(0 > s_max) return 0;
    var k = [0, 0], i = [0, 0];
    try{
     for(;;){
      if((i[1] + sep_max | 0) > s_max){var _m_ = 0; return _m_;}
      if(caml_string_unsafe_get(s, i[1]) !== caml_string_unsafe_get(on, 0))
       i[1]++;
      else{
       k[1] = 1;
       for(;;){
        if(k[1] > sep_max) break;
        if
         (caml_string_unsafe_get(s, i[1] + k[1] | 0)
          !== caml_string_unsafe_get(on, k[1]))
         break;
        k[1]++;
       }
       if(k[1] > sep_max) throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       i[1]++;
      }
     }
    }
    catch(_n_){
     var _k_ = caml_wrap_exception(_n_);
     if(_k_ !== Stdlib[3]) throw caml_maybe_attach_backtrace(_k_, 0);
     var
      left_end = i[1] - 1 | 0,
      right_start = (i[1] + sep_max | 0) + 1 | 0,
      _l_ =
        caml_call3
         (Stdlib_String[15],
          s,
          right_start,
          (s_max - right_start | 0) + 1 | 0);
     return [0,
             [0, caml_call3(Stdlib_String[15], s, 0, left_end + 1 | 0), _l_]];
    }
   }
   function rcut(s, on){
    var sep_max = caml_ml_string_length(on) - 1 | 0;
    if(0 > sep_max)
     return caml_call1(Stdlib[1], cst_Stringext_rcut_empty_separ);
    var s_max = caml_ml_string_length(s) - 1 | 0;
    if(0 > s_max) return 0;
    var k = [0, 0], i = [0, s_max];
    try{
     for(;;){
      if(sep_max > i[1]){var _i_ = 0; return _i_;}
      if
       (caml_string_unsafe_get(s, i[1])
        !== caml_string_unsafe_get(on, sep_max))
       i[1]--;
      else{
       var sep_start = i[1] - sep_max | 0;
       k[1] = sep_max - 1 | 0;
       for(;;){
        if(0 > k[1]) break;
        if
         (caml_string_unsafe_get(s, sep_start + k[1] | 0)
          !== caml_string_unsafe_get(on, k[1]))
         break;
        k[1]--;
       }
       if(0 > k[1]) throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       i[1]--;
      }
     }
    }
    catch(_j_){
     var _g_ = caml_wrap_exception(_j_);
     if(_g_ !== Stdlib[3]) throw caml_maybe_attach_backtrace(_g_, 0);
     var
      left_end = (i[1] - sep_max | 0) - 1 | 0,
      right_start = i[1] + 1 | 0,
      _h_ =
        caml_call3
         (Stdlib_String[15],
          s,
          right_start,
          (s_max - right_start | 0) + 1 | 0);
     return [0,
             [0, caml_call3(Stdlib_String[15], s, 0, left_end + 1 | 0), _h_]];
    }
   }
   function chop_prefix(s, prefix){
    var
     prefix_l = caml_ml_string_length(prefix),
     string_l = caml_ml_string_length(s);
    if(string_l < prefix_l) return 0;
    try{
     var _b_ = prefix_l - 1 | 0, _a_ = 0;
     if(_b_ >= 0){
      var i = _a_;
      for(;;){
       var _d_ = caml_string_get(prefix, i);
       if(caml_string_get(s, i) !== _d_)
        throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       var _e_ = i + 1 | 0;
       if(_b_ === i) break;
       i = _e_;
      }
     }
     var
      _c_ =
        [0,
         caml_call3(Stdlib_String[15], s, prefix_l, string_l - prefix_l | 0)];
     return _c_;
    }
    catch(_f_){return 0;}
   }
   function drop(s, n){
    var l = caml_ml_string_length(s);
    return l <= n ? cst$3 : caml_call3(Stdlib_String[15], s, n, l - n | 0);
   }
   function take(s, n){
    return caml_ml_string_length(s) <= n
            ? s
            : caml_call3(Stdlib_String[15], s, 0, n);
   }
   var
    Stringext =
      [0,
       string_after,
       quote,
       split,
       full_split,
       trim_left,
       split_trim_left,
       of_char,
       of_list,
       to_list,
       to_array,
       of_array,
       find_from,
       replace_all,
       replace_all_assoc,
       cut,
       rcut,
       chop_prefix,
       drop,
       take,
       trim_left_sub];
   runtime.caml_register_global(19, Stringext, "Stringext");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzdHJpbmdleHQuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInN0cmluZ19hZnRlciIsInMiLCJuIiwicXVvdGUiLCJsZW4iLCJidWYiLCJpIiwiYyIsIm9mX2NoYXIiLCJmdWxsX3NwbGl0Iiwic3RyIiwib24iLCJzZXAiLCJsb29wIiwiYWNjIiwib2Zmc2V0IiwiaW5kZXgiLCJ0b2tlbiIsInNwbGl0IiwibWF4IiwibWF4JDAiLCJ0b2tlbnMiLCJsb29wJDAiLCJ0cmltX2xlZnRfc3ViIiwibGFzdF9jaGFyIiwiY2hhcnMiLCJmaW5hbCQwIiwibGFzdF9jaGFyJDAiLCJpJDAiLCJsYXN0X2NoYXIkMSIsIm5ld19sZW4iLCJzcGxpdF90cmltX2xlZnQiLCJ0cmltIiwidHJpbV9sZWZ0Iiwibm9uX3NwYWNlIiwiZmluZF9mcm9tIiwib3B0IiwicGF0dGVybiIsInN0aCIsInN0YXJ0Iiwic3RhcnQkMCIsInJlcGxhY2VfYWxsIiwid2l0aCQwIiwicGxlbiIsInNsZW4iLCJqIiwicmVwbGFjZV9hbGxfYXNzb2MiLCJ0YmwiLCJmb3VuZCIsImZvdW5kJDAiLCJmIiwieHMkMCIsIngkMSIsIngiLCJmeCIsInhzIiwieCQwIiwiZngkMCIsImUiLCJqJDEiLCJ3aXRoJDIiLCJwYXR0ZXJuJDEiLCJyIiwid2l0aCQxIiwicGF0dGVybiQwIiwiaiQwIiwib2ZfbGlzdCIsImwiLCJ0b19saXN0IiwiaSQxIiwiYWNjJDAiLCJvZl9hcnJheSIsImEiLCJieXRlcyIsInRvX2FycmF5IiwiY3V0Iiwic2VwX21heCIsInNfbWF4IiwiayIsImxlZnRfZW5kIiwicmlnaHRfc3RhcnQiLCJyY3V0Iiwic2VwX3N0YXJ0IiwiY2hvcF9wcmVmaXgiLCJwcmVmaXgiLCJwcmVmaXhfbCIsInN0cmluZ19sIiwiZHJvcCIsInRha2UiXSwic291cmNlcyI6WyIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL3N0cmluZ2V4dC9zdHJpbmdleHQu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TUFBRUM7R0FHWTs7OztPQTlVbkJGO09BRUFHO09Bd0VBZTtPQXJCQVQ7T0FvRUF3QjtPQXRCQUY7T0FoREF2QjtPQXVLQTBEO09BTUFFO09BZUFNO09BUkFIO09BMUZBcEM7T0F1QkFNO09BZ0JBSztPQThEQTZCO09BbUNBTTtPQW9DQUU7T0FZQUk7T0FNQUM7T0FwUEFqRTs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuIFN0cmluZ1xuXG5sZXQgc3RyaW5nX2FmdGVyIHMgbiA9IFN0cmluZy5zdWIgcyBuIChTdHJpbmcubGVuZ3RoIHMgLSBuKVxuXG5sZXQgcXVvdGUgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgKDIgKiBsZW4pIGluXG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgJ1snIHwgJ10nIHwgJyonIHwgJy4nIHwgJ1xcXFwnIHwgJz8nIHwgJysnIHwgJ14nIHwgJyQnIGFzIGMgLT5cbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJ1xcXFwnO1xuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiBjXG4gICAgfCBjIC0+IEJ1ZmZlci5hZGRfY2hhciBidWYgY1xuICBkb25lO1xuICBCdWZmZXIuY29udGVudHMgYnVmXG5cblxuKCogTm90IHRhaWwgcmVjdXJzaXZlIGZvciBcInBlcmZvcm1hbmNlXCIsIHBsZWFzZSBjaG9vc2UgbG93IHZhbHVlcyBmb3JcbiAgIFttYXhdLiBUaGUgaWRlYSBpcyB0aGF0IG1heCBpcyBhbHdheXMgc21hbGwgYmVjYXVzZSBpdCdzIGhhcmRcbiAgIGNvZGUgKilcbmxldCBzcGxpdF9jaGFyX2JvdW5kZWQgc3RyIH5vbiB+bWF4ID1cbiAgaWYgc3RyID0gXCJcIiB0aGVuIFtdXG4gIGVsc2UgaWYgbWF4ID0gMSB0aGVuIFtzdHJdXG4gIGVsc2VcbiAgICBsZXQgcmVjIGxvb3Agb2Zmc2V0IHRva2VucyA9XG4gICAgICBpZiB0b2tlbnMgPSBtYXggLSAxXG4gICAgICB0aGVuIFtzdWIgc3RyIG9mZnNldCAobGVuZ3RoIHN0ciAtIG9mZnNldCldXG4gICAgICBlbHNlXG4gICAgICAgIHRyeVxuICAgICAgICAgIGxldCBpbmRleCA9IGluZGV4X2Zyb20gc3RyIG9mZnNldCBvbiBpblxuICAgICAgICAgIGlmIGluZGV4ID0gb2Zmc2V0IHRoZW5cbiAgICAgICAgICAgIFwiXCI6Oihsb29wIChvZmZzZXQgKyAxKSAodG9rZW5zICsgMSkpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHRva2VuID0gU3RyaW5nLnN1YiBzdHIgb2Zmc2V0IChpbmRleCAtIG9mZnNldCkgaW5cbiAgICAgICAgICAgIHRva2VuOjoobG9vcCAoaW5kZXggKyAxKSAodG9rZW5zICsgMSkpXG4gICAgICAgIHdpdGggTm90X2ZvdW5kIC0+IFtzdWIgc3RyIG9mZnNldCAobGVuZ3RoIHN0ciAtIG9mZnNldCldXG4gICAgaW4gbG9vcCAwIDBcblxubGV0IHNwbGl0X2NoYXJfdW5ib3VuZGVkIHN0ciB+b24gPVxuICBpZiBzdHIgPSBcIlwiIHRoZW4gW11cbiAgZWxzZVxuICAgIGxldCByZWMgbG9vcCBhY2Mgb2Zmc2V0ID1cbiAgICAgIHRyeSBiZWdpblxuICAgICAgICBsZXQgaW5kZXggPSByaW5kZXhfZnJvbSBzdHIgb2Zmc2V0IG9uIGluXG4gICAgICAgIGlmIGluZGV4ID0gb2Zmc2V0IHRoZW5cbiAgICAgICAgICBsb29wIChcIlwiOjphY2MpIChpbmRleCAtIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgdG9rZW4gPSBzdWIgc3RyIChpbmRleCArIDEpIChvZmZzZXQgLSBpbmRleCkgaW5cbiAgICAgICAgICBsb29wICh0b2tlbjo6YWNjKSAoaW5kZXggLSAxKVxuICAgICAgZW5kXG4gICAgICB3aXRoIE5vdF9mb3VuZCAtPiAoc3ViIHN0ciAwIChvZmZzZXQgKyAxKSk6OmFjY1xuICAgIGluIGxvb3AgW10gKGxlbmd0aCBzdHIgLSAxKVxuXG5sZXQgb2ZfY2hhciA9IFN0cmluZy5tYWtlIDFcblxubGV0IGZ1bGxfc3BsaXQgc3RyIH5vbiA9XG4gIGlmIHN0ciA9IFwiXCIgdGhlbiBbXVxuICBlbHNlXG4gICAgbGV0IHNlcCA9IG9mX2NoYXIgb24gaW5cbiAgICBsZXQgcmVjIGxvb3AgYWNjIG9mZnNldCA9XG4gICAgICB0cnkgYmVnaW5cbiAgICAgICAgbGV0IGluZGV4ID0gcmluZGV4X2Zyb20gc3RyIG9mZnNldCBvbiBpblxuICAgICAgICBpZiBpbmRleCA9IG9mZnNldCB0aGVuXG4gICAgICAgICAgbG9vcCAoc2VwOjphY2MpIChpbmRleCAtIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgdG9rZW4gPSBzdWIgc3RyIChpbmRleCArIDEpIChvZmZzZXQgLSBpbmRleCkgaW5cbiAgICAgICAgICBsb29wIChzZXA6OnRva2VuOjphY2MpIChpbmRleCAtIDEpXG4gICAgICBlbmRcbiAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgIGlmIG9mZnNldCA+PSAwXG4gICAgICAgIHRoZW4gKHN1YiBzdHIgMCAob2Zmc2V0ICsgMSkpOjphY2NcbiAgICAgICAgZWxzZSBhY2NcbiAgICBpbiBsb29wIFtdIChsZW5ndGggc3RyIC0gMSlcblxuKCogY29weWluZyBjb3JlJ3MgY29udmVudGlvbiBmb3IgU3RyaW5nLnNwbGl0IGJ1dCB3aXRoIGFuIG9wdGlvbmFsIG1heFxuICAgYXJndW1lbnQgKilcbmxldCBzcGxpdCA/bWF4IHMgfm9uID1cbiAgbWF0Y2ggbWF4IHdpdGhcbiAgfCBOb25lIC0+IHNwbGl0X2NoYXJfdW5ib3VuZGVkIHMgfm9uXG4gIHwgU29tZSBtYXggLT4gICAgICAgICAgICAgICAgICgqIGFzc2VydCAobWF4IDwgMTAwKTsgKilcbiAgICBzcGxpdF9jaGFyX2JvdW5kZWQgcyB+b24gfm1heFxuXG5sZXQgcmluZGV4X2Zyb21fb24gcyB+b2Zmc2V0IH5vbiA9XG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZFxuICAgIGVsc2UgaWYgU3RyaW5nLmNvbnRhaW5zIG9uIHMuW2ldIHRoZW4gaVxuICAgIGVsc2UgbG9vcCAoaSAtIDEpXG4gIGluIGxvb3Agb2Zmc2V0XG5cbmxldCB0cmltX2xlZnRfc3ViIHMgfnBvcyB+bGVuIH5jaGFycyA9XG4gIGxldCBzdGFydF9wb3MgPVxuICAgIGxldCBmaW5hbCA9IHBvcyArIGxlbiBpblxuICAgIGxldCByZWMgbG9vcCBsYXN0X2NoYXIgaSA9XG4gICAgICBpZiBpID0gZmluYWwgdGhlbiBsYXN0X2NoYXJcbiAgICAgIGVsc2UgaWYgU3RyaW5nLmNvbnRhaW5zIGNoYXJzIHMuW2ldIHRoZW4gbG9vcCAoaSArIDEpIChpICsgMSlcbiAgICAgIGVsc2UgbGFzdF9jaGFyXG4gICAgaW4gbG9vcCBwb3MgcG9zXG4gIGluXG4gIGxldCBuZXdfbGVuID0gbGVuIC0gKHN0YXJ0X3BvcyAtIHBvcykgaW5cbiAgU3RyaW5nLnN1YiBzIHN0YXJ0X3BvcyBuZXdfbGVuXG5cbmxldCBzcGxpdF90cmltX2xlZnQgc3RyIH5vbiB+dHJpbSA9XG4gIGlmIHN0ciA9IFwiXCIgdGhlbiBbXVxuICBlbHNlXG4gICAgbGV0IHJlYyBsb29wIGFjYyBvZmZzZXQgPVxuICAgICAgdHJ5IGJlZ2luXG4gICAgICAgIGxldCBpbmRleCA9IHJpbmRleF9mcm9tX29uIHN0ciB+b2Zmc2V0IH5vbiBpblxuICAgICAgICBpZiBpbmRleCA9IG9mZnNldCB0aGVuXG4gICAgICAgICAgbG9vcCAoXCJcIjo6YWNjKSAoaW5kZXggLSAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbGV0IHRva2VuID0gdHJpbV9sZWZ0X3N1YiBzdHIgfnBvczooaW5kZXggKyAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgfmxlbjoob2Zmc2V0IC0gaW5kZXgpIH5jaGFyczp0cmltIGluXG4gICAgICAgICAgbG9vcCAodG9rZW46OmFjYykgKGluZGV4IC0gMSlcbiAgICAgIGVuZFxuICAgICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgKHRyaW1fbGVmdF9zdWIgc3RyIH5wb3M6MCB+bGVuOihvZmZzZXQgKyAxKSB+Y2hhcnM6dHJpbSk6OmFjY1xuICAgIGluIGxvb3AgW10gKGxlbmd0aCBzdHIgLSAxKVxuXG5leGNlcHRpb24gRm91bmRfaW50IG9mIGludFxuXG5sZXQgZmlyc3RfY2hhcl9uZSBzIGMgPVxuICBTdHJpbmcubGVuZ3RoIHMgPiAwICYmIHMuWzBdIDw+IGNcblxubGV0IHRyaW1fbGVmdCBzID1cbiAgaWYgZmlyc3RfY2hhcl9uZSBzICcgJyB0aGVuIHNcbiAgZWxzZVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICB0cnlcbiAgICAgIGZvciBpPTAgdG8gbGVuIC0gMSBkb1xuICAgICAgICBpZiBzLltpXSA8PiAnICcgdGhlbiByYWlzZSAoRm91bmRfaW50IGkpXG4gICAgICBkb25lO1xuICAgICAgXCJcIlxuICAgIHdpdGggRm91bmRfaW50IG5vbl9zcGFjZSAtPlxuICAgICAgc3ViIHMgbm9uX3NwYWNlIChsZW4gLSBub25fc3BhY2UpXG5cbmxldCBzdWJzdHJfZXEgPyhzdGFydD0wKSBzIH5wYXR0ZXJuID1cbiAgdHJ5XG4gICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcGF0dGVybiAtIDEgZG9cbiAgICAgIGlmIHMuW2kgKyBzdGFydF0gPD4gcGF0dGVybi5baV0gdGhlbiByYWlzZSBFeGl0XG4gICAgZG9uZTtcbiAgICB0cnVlXG4gIHdpdGggXyAtPiBmYWxzZVxuXG5sZXQgZmluZF9mcm9tID8oc3RhcnQ9MCkgc3RyIH5wYXR0ZXJuID1cbiAgdHJ5XG4gICAgZm9yIGkgPSBzdGFydCB0byAoU3RyaW5nLmxlbmd0aCBzdHIpIC0gKFN0cmluZy5sZW5ndGggcGF0dGVybikgZG9cbiAgICAgIGlmIHN1YnN0cl9lcSB+c3RhcnQ6aSBzdHIgfnBhdHRlcm4gdGhlblxuICAgICAgICByYWlzZSAoRm91bmRfaW50IGkpXG4gICAgZG9uZTtcbiAgICBOb25lXG4gIHdpdGhcbiAgfCBGb3VuZF9pbnQgaSAtPiBTb21lIGlcbiAgfCAgXyAtPiBOb25lXG5cbmxldCBmaW5kX21pbiBsIH5mID1cbiAgbGV0IHJlYyBsb29wIHggZnggPSBmdW5jdGlvblxuICAgIHwgW10gLT4gU29tZSAoeCwgZngpXG4gICAgfCB4Jzo6eHMgLT5cbiAgICAgIGxldCBmeCcgPSBmIHgnIGluXG4gICAgICBpZiBmeCcgPCBmeCB0aGVuIGxvb3AgeCcgZngnIHhzXG4gICAgICBlbHNlIGxvb3AgeCBmeCB4c1xuICBpblxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgeDo6eHMgLT4gbG9vcCB4IChmIHgpIHhzXG5cbmxldCByZXBsYWNlX2FsbCBzdHIgfnBhdHRlcm4gfndpdGhfID1cbiAgbGV0IChzbGVuLCBwbGVuKSA9IFN0cmluZy4obGVuZ3RoIHN0ciwgbGVuZ3RoIHBhdHRlcm4pIGluXG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIHNsZW4gaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIG1hdGNoIGZpbmRfZnJvbSB+c3RhcnQ6aSBzdHIgfnBhdHRlcm4gd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIHN0ciBpIChzbGVuIC0gaSk7XG4gICAgICBCdWZmZXIuY29udGVudHMgYnVmXG4gICAgfCBTb21lIGogLT5cbiAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBzdHIgaSAoaiAtIGkpO1xuICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIHdpdGhfO1xuICAgICAgbG9vcCAoaiArIHBsZW4pXG4gIGluIGxvb3AgMFxuXG5leGNlcHRpb24gRm91bmRfcmVwbGFjZSBvZiBpbnQgKiBzdHJpbmcgKiBzdHJpbmdcblxubGV0IHJlcGxhY2VfYWxsX2Fzc29jIHN0ciB0YmwgPVxuICBsZXQgc2xlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIHNsZW4gaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPj0gc2xlbiB0aGVuIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgICBlbHNlXG4gICAgICBsZXQgciA9XG4gICAgICAgIHRyeVxuICAgICAgICAgIGxldCBmb3VuZCA9IHJlZiBmYWxzZSBpblxuICAgICAgICAgIGxldCBlID1cbiAgICAgICAgICAgIGZpbmRfbWluIHRibCB+ZjooZnVuIChwYXR0ZXJuLCB3aXRoXykgLT5cbiAgICAgICAgICAgICAgbWF0Y2ggZmluZF9mcm9tIH5zdGFydDppIHN0ciB+cGF0dGVybiB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAgIC0+IG1heF9pbnRcbiAgICAgICAgICAgICAgfCBTb21lIGogd2hlbiBqID0gaSAtPiByYWlzZSAoRm91bmRfcmVwbGFjZSAoaiwgcGF0dGVybiwgd2l0aF8pKVxuICAgICAgICAgICAgICB8IFNvbWUgaiAtPiBmb3VuZCA6PSB0cnVlOyBqKVxuICAgICAgICAgIGluXG4gICAgICAgICAgbWF0Y2ggZSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICB8IFNvbWUgKChwYXR0ZXJuLCB3aXRoXyksIGopIHdoZW4gIWZvdW5kIC0+IFNvbWUgKGosIHBhdHRlcm4sIHdpdGhfKVxuICAgICAgICAgIHwgU29tZSBfIC0+IE5vbmVcbiAgICAgICAgd2l0aCBGb3VuZF9yZXBsYWNlIChqLCBwYXR0ZXJuLCB3aXRoXykgLT4gU29tZSAoaiwgcGF0dGVybiwgd2l0aF8pXG4gICAgICBpblxuICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIHN0ciBpIChzbGVuIC0gaSk7XG4gICAgICAgIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgICAgIHwgU29tZSAoaiwgcGF0dGVybiwgd2l0aF8pIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBzdHIgaSAoaiAtIGkpO1xuICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgd2l0aF87XG4gICAgICAgIGxvb3AgKGogKyBTdHJpbmcubGVuZ3RoIHBhdHRlcm4pXG4gIGluIGxvb3AgMFxuXG5sZXQgaXRlcmkgZiBsID1cbiAgbGV0IHJlYyBsb29wIGkgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gKClcbiAgICB8IHg6OnhzIC0+IChmIGkgeCk7IGxvb3AgKHN1Y2MgaSkgeHNcbiAgaW4gbG9vcCAwIGxcblxubGV0IG9mX2xpc3QgeHMgPVxuICBsZXQgbCA9IExpc3QubGVuZ3RoIHhzIGluXG4gIGxldCBzID0gQnl0ZXMuY3JlYXRlIGwgaW5cbiAgaXRlcmkgKGZ1biBpIGMgLT4gQnl0ZXMuc2V0IHMgaSBjKSB4cztcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzXG5cbmxldCB0b19saXN0IHMgPVxuICBsZXQgcmVjIGxvb3AgYWNjIGkgPVxuICAgIGlmIGkgPSAtMSB0aGVuIGFjY1xuICAgIGVsc2VcbiAgICAgIGxvb3AgKHMuW2ldIDo6IGFjYykgKHByZWQgaSlcbiAgaW4gbG9vcCBbXSAoU3RyaW5nLmxlbmd0aCBzIC0gMSlcblxubGV0IG9mX2FycmF5IGEgPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGEgaW5cbiAgbGV0IGJ5dGVzID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIEJ5dGVzLnNldCBieXRlcyBpIGEuKGkpXG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYnl0ZXNcblxubGV0IHRvX2FycmF5IHMgPSBBcnJheS5pbml0IChTdHJpbmcubGVuZ3RoIHMpIChTdHJpbmcuZ2V0IHMpXG5cbigqIHJpcHBlZCBvZmYgZnJvbSBvbmUgb2YgZGJ1ZW56bGkncyBsaWJzICopXG5sZXQgY3V0IHMgfm9uID1cbiAgbGV0IHNlcF9tYXggPSBsZW5ndGggb24gLSAxIGluXG4gIGlmIHNlcF9tYXggPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmdleHQuY3V0OiBlbXB0eSBzZXBhcmF0b3JcIiBlbHNlXG4gICAgbGV0IHNfbWF4ID0gbGVuZ3RoIHMgLSAxIGluXG4gICAgaWYgc19tYXggPCAwIHRoZW4gTm9uZSBlbHNlXG4gICAgICBsZXQgayA9IHJlZiAwIGluXG4gICAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgICAoKiBXZSBydW4gZnJvbSB0aGUgc3RhcnQgb2YgW3NdIHRvIGVuZCB3aXRoIFtpXSB0cnlpbmcgdG8gbWF0Y2ggdGhlXG4gICAgICAgICBmaXJzdCBjaGFyYWN0ZXIgb2YgW29uXSBpbiBbc10uIElmIHRoaXMgbWF0Y2hlcywgd2UgdmVyaWZ5IHRoYXRcbiAgICAgICAgIHRoZSB3aG9sZSBbb25dIGlzIG1hdGNoZWQgdXNpbmcgW2tdLiBJZiBpdCBkb2Vzbid0IG1hdGNoIHdlXG4gICAgICAgICBjb250aW51ZSB0byBsb29rIGZvciBbb25dIHdpdGggW2ldLiBJZiBpdCBtYXRjaGVzIHdlIGV4aXQgdGhlXG4gICAgICAgICBsb29wIGFuZCBleHRyYWN0IGEgc3Vic3RyaW5nIGZyb20gdGhlIHN0YXJ0IG9mIFtzXSB0byB0aGVcbiAgICAgICAgIHBvc2l0aW9uIGJlZm9yZSB0aGUgW29uXSB3ZSBmb3VuZCBhbmQgYW5vdGhlciBmcm9tIHRoZSBwb3NpdGlvblxuICAgICAgICAgYWZ0ZXIgdGhlIFtvbl0gd2UgZm91bmQgdG8gZW5kIG9mIHN0cmluZy4gSWYgW2ldIGlzIHN1Y2ggdGhhdCBub1xuICAgICAgICAgc2VwYXJhdG9yIGNhbiBiZSBmb3VuZCB3ZSBleGl0IHRoZSBsb29wIGFuZCByZXR1cm4gdGhlIG5vIG1hdGNoXG4gICAgICAgICBjYXNlLiAqKVxuICAgICAgdHJ5XG4gICAgICAgIHdoaWxlICghaSArIHNlcF9tYXggPD0gc19tYXgpIGRvXG4gICAgICAgICAgKCogQ2hlY2sgcmVtYWluaW5nIFtvbl0gY2hhcnMgbWF0Y2gsIGFjY2VzcyB0byB1bnNhZmUgcyAoIWkgKyAhaykgaXNcbiAgICAgICAgICAgICBndWFyYW50ZWVkIGJ5IGxvb3AgaW52YXJpYW50LiAqKVxuICAgICAgICAgIGlmIHVuc2FmZV9nZXQgcyAhaSA8PiB1bnNhZmVfZ2V0IG9uIDAgdGhlbiBpbmNyIGkgZWxzZSBiZWdpblxuICAgICAgICAgICAgayA6PSAxO1xuICAgICAgICAgICAgd2hpbGUgKCFrIDw9IHNlcF9tYXggJiYgdW5zYWZlX2dldCBzICghaSArICFrKSA9IHVuc2FmZV9nZXQgb24gIWspXG4gICAgICAgICAgICBkbyBpbmNyIGsgZG9uZTtcbiAgICAgICAgICAgIGlmICFrIDw9IHNlcF9tYXggdGhlbiAoKiBubyBtYXRjaCAqKSBpbmNyIGkgZWxzZSByYWlzZSBFeGl0XG4gICAgICAgICAgZW5kXG4gICAgICAgIGRvbmU7XG4gICAgICAgIE5vbmUgKCogbm8gbWF0Y2ggaW4gdGhlIHdob2xlIHN0cmluZy4gKilcbiAgICAgIHdpdGhcbiAgICAgIHwgRXhpdCAtPiAoKiBpIGlzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlcGFyYXRvciAqKVxuICAgICAgICBsZXQgbGVmdF9lbmQgPSAhaSAtIDEgaW5cbiAgICAgICAgbGV0IHJpZ2h0X3N0YXJ0ID0gIWkgKyBzZXBfbWF4ICsgMSBpblxuICAgICAgICBTb21lIChzdWIgcyAwIChsZWZ0X2VuZCArIDEpLFxuICAgICAgICAgICAgICBzdWIgcyByaWdodF9zdGFydCAoc19tYXggLSByaWdodF9zdGFydCArIDEpKVxuXG5sZXQgcmN1dCBzIH5vbiA9XG4gIGxldCBzZXBfbWF4ID0gbGVuZ3RoIG9uIC0gMSBpblxuICBpZiBzZXBfbWF4IDwgMCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nZXh0LnJjdXQ6IGVtcHR5IHNlcGFyYXRvclwiIGVsc2VcbiAgICBsZXQgc19tYXggPSBsZW5ndGggcyAtIDEgaW5cbiAgICBpZiBzX21heCA8IDAgdGhlbiBOb25lIGVsc2VcbiAgICAgIGxldCBrID0gcmVmIDAgaW5cbiAgICAgIGxldCBpID0gcmVmIHNfbWF4IGluXG4gICAgICAoKiBXZSBydW4gZnJvbSB0aGUgZW5kIG9mIFtzXSB0byB0aGUgYmVnaW5uaW5nIHdpdGggW2ldIHRyeWluZyB0b1xuICAgICAgICAgbWF0Y2ggdGhlIGxhc3QgY2hhcmFjdGVyIG9mIFtvbl0gaW4gW3NdLiBJZiB0aGlzIG1hdGNoZXMsIHdlXG4gICAgICAgICB2ZXJpZnkgdGhhdCB0aGUgd2hvbGUgW29uXSBpcyBtYXRjaGVkIHVzaW5nIFtrXSAod2UgZG8gdGhhdFxuICAgICAgICAgYmFja3dhcmRzKS4gIElmIGl0IGRvZXNuJ3QgbWF0Y2ggd2UgY29udGludWUgdG8gbG9vayBmb3IgW29uXVxuICAgICAgICAgd2l0aCBbaV0uICBJZiBpdCBtYXRjaGVzIHdlIGV4aXQgdGhlIGxvb3AgYW5kIGV4dHJhY3QgYVxuICAgICAgICAgc3Vic3RyaW5nIGZyb20gdGhlIHN0YXJ0IG9mIFtzXSB0byB0aGUgcG9zaXRpb24gYmVmb3JlIHRoZVxuICAgICAgICAgW29uXSB3ZSBmb3VuZCBhbmQgYW5vdGhlciBmcm9tIHRoZSBwb3NpdGlvbiBhZnRlciB0aGUgW29uXSB3ZVxuICAgICAgICAgZm91bmQgdG8gZW5kIG9mIHN0cmluZy4gIElmIFtpXSBpcyBzdWNoIHRoYXQgbm8gc2VwYXJhdG9yIGNhblxuICAgICAgICAgYmUgZm91bmQgd2UgZXhpdCB0aGUgbG9vcCBhbmQgcmV0dXJuIHRoZSBubyBtYXRjaCBjYXNlLiAqKVxuICAgICAgdHJ5XG4gICAgICAgIHdoaWxlICghaSA+PSBzZXBfbWF4KSBkb1xuICAgICAgICAgIGlmIHVuc2FmZV9nZXQgcyAhaSA8PiB1bnNhZmVfZ2V0IG9uIHNlcF9tYXggdGhlbiBkZWNyIGkgZWxzZSBiZWdpblxuICAgICAgICAgICAgKCogQ2hlY2sgcmVtYWluaW5nIFtvbl0gY2hhcnMgbWF0Y2gsIGFjY2VzcyB0byB1bnNhZmVfZ2V0XG4gICAgICAgICAgICAgICBzIChzZXBfc3RhcnQgKyAhaykgaXMgZ3VhcmFudGVlZCBieSBsb29wIGludmFyaWFudC4gKilcbiAgICAgICAgICAgIGxldCBzZXBfc3RhcnQgPSAhaSAtIHNlcF9tYXggaW5cbiAgICAgICAgICAgIGsgOj0gc2VwX21heCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoIWsgPj0gMCAmJiB1bnNhZmVfZ2V0IHMgKHNlcF9zdGFydCArICFrKSA9IHVuc2FmZV9nZXQgb24gIWspXG4gICAgICAgICAgICBkbyBkZWNyIGsgZG9uZTtcbiAgICAgICAgICAgIGlmICFrID49IDAgdGhlbiAoKiBubyBtYXRjaCAqKSBkZWNyIGkgZWxzZSByYWlzZSBFeGl0XG4gICAgICAgICAgZW5kXG4gICAgICAgIGRvbmU7XG4gICAgICAgIE5vbmUgKCogbm8gbWF0Y2ggaW4gdGhlIHdob2xlIHN0cmluZy4gKilcbiAgICAgIHdpdGhcbiAgICAgIHwgRXhpdCAtPiAoKiBpIGlzIGF0IHRoZSBlbmQgb2YgdGhlIHNlcGFyYXRvciAqKVxuICAgICAgICBsZXQgbGVmdF9lbmQgPSAhaSAtIHNlcF9tYXggLSAxIGluXG4gICAgICAgIGxldCByaWdodF9zdGFydCA9ICFpICsgMSBpblxuICAgICAgICBTb21lIChzdWIgcyAwIChsZWZ0X2VuZCArIDEpLFxuICAgICAgICAgICAgICBzdWIgcyByaWdodF9zdGFydCAoc19tYXggLSByaWdodF9zdGFydCArIDEpKVxuXG5sZXQgY2hvcF9wcmVmaXggcyB+cHJlZml4ID1cbiAgbGV0IHByZWZpeF9sID0gU3RyaW5nLmxlbmd0aCBwcmVmaXggaW5cbiAgbGV0IHN0cmluZ19sID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGlmIHByZWZpeF9sID4gc3RyaW5nX2wgdGhlbiBOb25lXG4gIGVsc2VcbiAgICB0cnlcbiAgICAgIGZvciBpID0gMCB0byBwcmVmaXhfbCAtIDEgZG9cbiAgICAgICAgaWYgcy5baV0gPD4gcHJlZml4LltpXSB0aGVuIHJhaXNlIEV4aXQ7XG4gICAgICBkb25lO1xuICAgICAgU29tZSAoU3RyaW5nLnN1YiBzIHByZWZpeF9sIChzdHJpbmdfbCAtIHByZWZpeF9sKSlcbiAgICB3aXRoIF8gLT4gTm9uZVxuXG5sZXQgZHJvcCBzIG4gPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICBpZiBuID49IGxcbiAgdGhlbiBcIlwiXG4gIGVsc2UgU3RyaW5nLnN1YiBzIG4gKGwgLSBuKVxuXG5sZXQgdGFrZSBzIG4gPVxuICBpZiBuID49IFN0cmluZy5sZW5ndGggc1xuICB0aGVuIHNcbiAgZWxzZSBTdHJpbmcuc3ViIHMgMCBuXG4iXX0=
