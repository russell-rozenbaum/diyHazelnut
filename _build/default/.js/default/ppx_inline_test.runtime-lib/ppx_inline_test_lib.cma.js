// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1+5.8.1

//# unitInfo: Provides: Ppx_inline_test_lib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Ppx_inline_test_lib = [0];
   runtime.caml_register_global(0, Ppx_inline_test_lib, "Ppx_inline_test_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_inline_test_lib__Runtime
//# unitInfo: Requires: Base, Base__Int63, Base__List, Base__Random, Base__String, CamlinternalLazy, Sexplib0__Sexp_conv, Stdlib, Stdlib__Arg, Stdlib__Array, Stdlib__Filename, Stdlib__Hashtbl, Stdlib__List, Stdlib__Printexc, Stdlib__Printf, Stdlib__Random, Stdlib__Result, Stdlib__Scanf, Stdlib__String, Stdlib__Sys, Time_now
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$13 = "",
    cst$14 = "\n",
    cst$15 = " ",
    cst_line = " , line ",
    cst_File = " File ",
    cst_threw = " threw",
    cst_s$0 = "%s",
    cst_s = "%s%!",
    cst$12 = ".\n",
    cst_Ppx_inline_test_lib_Runtim$0 = "Ppx_inline_test_lib__Runtime",
    cst_TES = "TES",
    cst_TESTING_FRAMEWORK = "TESTING_FRAMEWORK",
    cst_T_MODULE_at$0 = "T_MODULE at ",
    cst_T_MODULES = "T_MODULES",
    cst_inline_test_runner$0 = "inline-test-runner",
    cst_inline_tests_log$0 = "inline_tests.log",
    cst_ppx_inline_test_error_the_ =
      "ppx_inline_test error: the following -only-test flags matched nothing:",
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$11 = cst$13,
    cst$9 = cst$14,
    cst$10 = cst$15,
    cst$7 = cst$14,
    cst$8 = cst$15,
    cst$5 = cst$14,
    cst$6 = "  ",
    cst$3 = cst$14,
    cst$4 = cst$13,
    cst$2 = ".",
    cst$0 = cst$13,
    cst$1 = ": ",
    enable_everything = [0, 0, 0],
    cst = cst$13,
    am_running_inline_test_env_var = cst_TESTING_FRAMEWORK,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_String = global_data.Stdlib__String,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Result = global_data.Stdlib__Result,
    Base = global_data.Base,
    Base_String = global_data.Base__String,
    Base_List = global_data.Base__List,
    Stdlib_Random = global_data.Stdlib__Random,
    Base_Random = global_data.Base__Random,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Int63 = global_data.Base__Int63,
    Time_now = global_data.Time_now,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_Arg = global_data.Stdlib__Arg,
    Stdlib_Array = global_data.Stdlib__Array,
    cst_success = "success",
    cst_failure = "failure",
    cst_error = "error";
   function to_string(param){
    switch(param){
      case 0:
       return cst_success;
      case 1:
       return cst_failure;
      default: return cst_error;
    }
   }
   function combine(t1, t2){
    a:
    {
     switch(t1){
       case 0:
        if(! t2) return 0; break;
       case 1: break;
       default: break a;
     }
     if(2 !== t2) return 1;
    }
    return 2;
   }
   function combine_all(ts){
    return caml_call3(Stdlib_List[25], combine, 0, ts);
   }
   var
    test_modules_ran = [0, 0],
    test_modules_failed = [0, 0],
    tests_ran = [0, 0],
    tests_failed = [0, 0],
    dynamic_lib = [0, 0],
    action = [0, -950194894],
    _E_ = [0, [12, 32, [2, 0, [12, 58, [4, 0, 0, 0, 0]]]], " %s:%d"],
    _F_ = [0, [12, 32, [2, 0, 0]], " %s"],
    _z_ =
      [0,
       [11,
        "inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n",
        [10, 0]],
       "inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n%!"],
    _A_ =
      [0,
       [11,
        "You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n",
        [10, 0]],
       "You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n%!"],
    _B_ = [0, [2, 0, [12, 10, 0]], "%s\n"],
    _C_ =
      [0,
       [4,
        0,
        0,
        0,
        [11,
         " tests ran, ",
         [4, 0, 0, 0, [11, " test_modules ran\n", [10, 0]]]]],
       "%d tests ran, %d test_modules ran\n%!"],
    _D_ =
      [0,
       [11, cst_ppx_inline_test_error_the_, 0],
       cst_ppx_inline_test_error_the_],
    _G_ = [0, [11, cst$12, [10, 0]], ".\n%!"],
    _H_ =
      [0,
       [11, "ppx_inline_test error: no tests have been run.\n", [10, 0]],
       "ppx_inline_test error: no tests have been run.\n%!"],
    _J_ = [0, [11, cst_T_MODULES, 0], cst_T_MODULES],
    _K_ = [0, [11, ", ", [4, 0, 0, 0, [11, " TES", 0]]], ", %d TES"],
    _I_ =
      [0,
       [11,
        "FAILED ",
        [4,
         0,
         0,
         0,
         [11, " / ", [4, 0, 0, 0, [11, " tests", [2, 0, [12, 10, [10, 0]]]]]]]],
       "FAILED %d / %d tests%s\n%!"],
    _x_ =
      [0,
       [11,
        cst_T_MODULE_at$0,
        [2,
         0,
         [11,
          cst_threw,
          [2, 0, [2, 0, [11, cst$12, [2, 0, [2, 0, [12, 10, [10, 0]]]]]]]]]],
       "T_MODULE at %s threw%s%s.\n%s%s\n%!"],
    _y_ = [0, [11, cst_TES, 0], cst_TES],
    cst_ppx_inline_test_cannot_use =
      "ppx_inline_test: cannot use -list-partition or -partition without specifying a partition at preprocessing time",
    _r_ = [0, [2, 0, [12, 10, [2, 0, 0]]], "%s\n%s"],
    _s_ = [0, [2, 0, [10, 0]], cst_s],
    _t_ = [0, 1],
    _u_ =
      [0,
       [11, " (", [8, [0, 0, 0], 0, [0, 3], [11, " sec)\n", [10, 0]]]],
       " (%.3f sec)\n%!"],
    _v_ =
      [0,
       [2, 0, [11, " is false.\n", [2, 0, [12, 10, [10, 0]]]]],
       "%s is false.\n%s\n%!"],
    _w_ =
      [0,
       [2,
        0,
        [11,
         cst_threw,
         [2, 0, [2, 0, [11, cst$12, [2, 0, [2, 0, [12, 10, [10, 0]]]]]]]]],
       "%s threw%s%s.\n%s%s\n%!"],
    _q_ = [0, [2, 0, [10, 0]], cst_s],
    _p_ = [0, [2, 0, [10, 0]], cst_s],
    _o_ = [0, [12, 10, [2, 0, [12, 10, [10, 0]]]], "\n%s\n%!"],
    cst_T_MODULE_at = cst_T_MODULE_at$0,
    cst_in_TES = "  in TES",
    cst_time_without_resetting_ran = "time_without_resetting_random_seeds",
    cst_Ppx_inline_test_lib_Runtim = cst_Ppx_inline_test_lib_Runtim$0,
    cst_inline_tests_log = cst_inline_tests_log$0,
    _P_ =
      [0,
       [11,
        "Argument ",
        [2,
         0,
         [11, " doesn't fit the format filename[:line_number]\n", [10, 0]]]],
       "Argument %s doesn't fit the format filename[:line_number]\n%!"],
    _O_ =
      [0,
       [2,
        0,
        [11, ": unexpected anonymous argument ", [2, 0, [12, 10, [10, 0]]]]],
       "%s: unexpected anonymous argument %s\n%!"],
    _h_ =
      [0,
       [11,
        cst_File,
        [3,
         0,
         [11,
          cst_line,
          [4,
           0,
           0,
           0,
           [11,
            " , characters ",
            [4, 0, 0, 0, [11, " - ", [4, 0, 0, 0, [12, 32, [10, 0]]]]]]]]]],
       " File %S , line %d , characters %d - %d %!"],
    _g_ =
      [0,
       [11, cst_File, [3, 0, [11, cst_line, [4, 0, 0, 0, [12, 32, [10, 0]]]]]],
       " File %S , line %d %!"],
    _f_ = [0, [11, cst_File, [3, 0, [12, 32, [10, 0]]]], " File %S %!"],
    _e_ =
      [0,
       [11,
        "File ",
        [3,
         0,
         [11,
          ", line ",
          [4,
           0,
           0,
           0,
           [11,
            ", characters ",
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [2, 0, 0]]]]]]]]],
       "File %S, line %d, characters %d-%d%s"],
    _a_ = [0, [2, 0, 0], cst_s$0],
    _b_ = [0, [2, 0, 0], cst_s$0],
    cst_inline_test_runner = cst_inline_test_runner$0,
    _N_ =
      [0,
       [2, 0, [12, 32, [2, 0, [12, 32, [2, 0, [11, " [args]", 0]]]]]],
       "%s %s %s [args]"],
    cst_Path_to_the_root_of_the_so = " Path to the root of the source tree",
    cst_source_tree_root = "-source-tree-root",
    cst_Allow_output_patterns_in_t =
      " Allow output patterns in tests expectations",
    cst_allow_output_patterns = "-allow-output-patterns",
    cst_Diff_command_for_tests_tha =
      " Diff command for tests that require diffing (use - to disable diffing)",
    cst_diff_cmd = "-diff-cmd",
    cst_Update_expect_tests_in_pla = " Update expect tests in place",
    cst_in_place = "-in-place",
    cst_Summarize_tests_without_us = " Summarize tests without using color",
    cst_no_color = "-no-color",
    cst_location_Run_only_the_test =
      'location Run only the tests specified by all the -only-test options.\n                      Locations can be one of these forms:\n                      - file.ml\n                      - file.ml:line_number\n                      - File "file.ml"\n                      - File "file.ml", line 23\n                      - File "file.ml", line 23, characters 2-3',
    cst_only_test = "-only-test",
    cst_substring_Only_run_tests_w =
      "substring Only run tests whose names contain the given substring",
    cst_matching = "-matching",
    cst_tag_Only_run_tests_tagged_ =
      "tag Only run tests tagged with [tag] (overrides previous -drop-tag)",
    cst_require_tag = "-require-tag",
    cst_tag_Only_run_tests_not_tag =
      "tag Only run tests not tagged with [tag] (overrides previous -require-tag)",
    cst_drop_tag = "-drop-tag",
    cst_Log_the_tests_run_in_inlin = " Log the tests run in inline_tests.log",
    cst_log = "-log",
    cst_Show_the_number_of_tests_r = " Show the number of tests ran",
    cst_show_counts = "-show-counts",
    cst_End_with_an_error_if_no_te = " End with an error if no tests were run",
    cst_strict = "-strict",
    cst_Run_tests_only_up_to_the_f =
      " Run tests only up to the first error (doesn't work for expect tests)",
    cst_stop_on_error = "-stop-on-error",
    cst_Show_the_tests_as_they_run = " Show the tests as they run",
    cst_verbose = "-verbose",
    cst_Only_run_the_tests_in_the_ =
      " Only run the tests in the given partition",
    cst_partition = "-partition",
    cst_Lists_all_the_partitions_t =
      " Lists all the partitions that contain at least one test or test_module",
    cst_list_partitions = "-list-partitions",
    cst_Do_not_run_tests_but_show_ =
      " Do not run tests but show what would have been run",
    cst_list_test_names = "-list-test-names",
    _n_ = [0, 187165616, 545942154],
    _L_ = [0, 187165616, -863538453];
   try{
    caml_sys_getenv("FORCE_DROP_INLINE_TEST");
    var _R_ = 1, force_drop = _R_;
   }
   catch(_br_){
    var _c_ = caml_wrap_exception(_br_);
    if(_c_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_c_, 0);
    var force_drop = 0;
   }
   function get(param){return force_drop ? -950194894 : action[1];}
   var _d_ = caml_call2(Stdlib_Hashtbl[1], 0, 23), current = [0, cst];
   function found_test(param){
    var
     _bp_ = current[1] !== cst$13 ? 1 : 0,
     _bq_ = _bp_ ? 1 - caml_call2(Stdlib_Hashtbl[9], _d_, current[1]) : _bp_;
    return _bq_ ? caml_call3(Stdlib_Hashtbl[5], _d_, current[1], 0) : _bq_;
   }
   function is_current(param){
    if(! param) return 1;
    var p = param[1];
    return p == current[1] ? 1 : 0;
   }
   var current$0 = [0, 0];
   function current_tags(param){
    var
     t = current$0[1],
     _bo_ = caml_call2(Stdlib_List[19], function(m){return m[2];}, t);
    return caml_call1(Stdlib_List[13], _bo_);
   }
   var
    verbose = [0, 0],
    strict = [0, 0],
    show_counts = [0, 0],
    list_test_names = [0, 0],
    delayed_errors = [0, 0],
    stop_on_error = [0, 0],
    log = [0, 0],
    time_sec = [0, 0.],
    use_color = [0, 1],
    in_place = [0, 0],
    diff_command = [0, 0],
    source_tree_root = [0, 0],
    allow_output_patterns = [0, 0];
   function displayed_descr(param){
    var
     _bm_ = caml_obj_tag(param),
     descr =
       250 === _bm_
        ? param[1]
        : 246 === _bm_ ? caml_call1(CamlinternalLazy[2], param) : param;
    return function(filename, line, start_pos, end_pos){
     var
      _bn_ = descr == cst$13 ? cst$0 : caml_call2(Stdlib[28], cst$1, descr);
     return caml_call6
             (Stdlib_Printf[4], _e_, filename, line, start_pos, end_pos, _bn_);};
   }
   var _i_ = caml_sys_argv(0), match = caml_call1(Stdlib_Array[11], _i_);
   a:
   if(match){
    var _j_ = match[2];
    if(_j_){
     var name = match[1];
     if(_j_[1] === cst_inline_test_runner$0){
      var match$0 = _j_[2];
      if(match$0){
       var rest = match$0[2], lib = match$0[1];
       if(Base[85][1]){
        var
         tests = [0, 0],
         list_partitions = [0, 0],
         partition = [0, 0],
         tag_predicate = [0, enable_everything],
         name_filter = [0, 0],
         msg$1 =
           caml_call4
            (Stdlib_Printf[4], _N_, name, cst_inline_test_runner, lib),
         f =
           function(anon){
            caml_call3(Stdlib_Printf[3], _O_, name, anon);
            return caml_call1(Stdlib[99], 1);
           },
         l =
           caml_call2
            (Stdlib_Arg[11],
             0,
             [0,
              [0,
               cst_list_test_names,
               [0,
                function(param){
                 list_test_names[1] = 1;
                 verbose[1] = 1;
                 return 0;
                }],
               cst_Do_not_run_tests_but_show_],
              [0,
               [0,
                cst_list_partitions,
                [0, function(param){list_partitions[1] = 1; return 0;}],
                cst_Lists_all_the_partitions_t],
               [0,
                [0,
                 cst_partition,
                 [4, function(i){partition[1] = [0, i]; return 0;}],
                 cst_Only_run_the_tests_in_the_],
                [0,
                 [0,
                  cst_verbose,
                  [2, verbose],
                  cst_Show_the_tests_as_they_run],
                 [0,
                  [0,
                   cst_stop_on_error,
                   [2, stop_on_error],
                   cst_Run_tests_only_up_to_the_f],
                  [0,
                   [0, cst_strict, [2, strict], cst_End_with_an_error_if_no_te],
                   [0,
                    [0,
                     cst_show_counts,
                     [2, show_counts],
                     cst_Show_the_number_of_tests_r],
                    [0,
                     [0,
                      cst_log,
                      [0,
                       function(param){
                        try{runtime.caml_sys_remove(cst_inline_tests_log$0);}
                        catch(_bl_){}
                        log[1] = [0, caml_call1(Stdlib[60], cst_inline_tests_log)];
                        return 0;
                       }],
                      cst_Log_the_tests_run_in_inlin],
                     [0,
                      [0,
                       cst_drop_tag,
                       [4,
                        function(tag){
                         var t = tag_predicate[1], _bj_ = [0, tag, t[2]];
                         tag_predicate[1] =
                          [0,
                           caml_call2
                            (Stdlib_List[41],
                             function(_bk_){return tag !== _bk_ ? 1 : 0;},
                             t[1]),
                           _bj_];
                         return 0;
                        }],
                       cst_tag_Only_run_tests_not_tag],
                      [0,
                       [0,
                        cst_require_tag,
                        [4,
                         function(tag){
                          var
                           t = tag_predicate[1],
                           _bh_ =
                             caml_call2
                              (Stdlib_List[41],
                               function(_bi_){return tag !== _bi_ ? 1 : 0;},
                               t[2]);
                          tag_predicate[1] = [0, [0, tag, t[1]], _bh_];
                          return 0;
                         }],
                        cst_tag_Only_run_tests_tagged_],
                       [0,
                        [0,
                         cst_matching,
                         [4,
                          function(s){
                           name_filter[1] = [0, s, name_filter[1]];
                           return 0;
                          }],
                         cst_substring_Only_run_tests_w],
                        [0,
                         [0,
                          cst_only_test,
                          [4,
                           function(str){
                            try{
                             var
                              _ba_ =
                                [0,
                                 caml_call3
                                  (Stdlib_Scanf[4],
                                   str,
                                   _h_,
                                   function(file, line, start_pos, end_pos){return [0, file, [0, line]];
                                   })],
                              match = _ba_;
                            }
                            catch(_be_){
                             try{
                              var
                               _a$_ =
                                 [0,
                                  caml_call3
                                   (Stdlib_Scanf[4],
                                    str,
                                    _g_,
                                    function(file, line){return [0, file, [0, line]];})],
                               match = _a$_;
                             }
                             catch(_bf_){
                              try{
                               var
                                _a__ =
                                  [0,
                                   caml_call3
                                    (Stdlib_Scanf[4],
                                     str,
                                     _f_,
                                     function(file){return [0, file, 0];})],
                                match = _a__;
                              }
                              catch(_bg_){var match = 0;}
                             }
                            }
                            if(match)
                             var
                              match$0 = match[1],
                              index = match$0[2],
                              file = match$0[1],
                              index$0 = index,
                              filename = file;
                            else if(caml_call2(Stdlib_String[14], str, 58)){
                             var
                              i = caml_call2(Stdlib_String[35], str, 58),
                              filename$0 = caml_call3(Stdlib_String[15], str, 0, i),
                              index_string =
                                caml_call3
                                 (Stdlib_String[15],
                                  str,
                                  i + 1 | 0,
                                  (caml_ml_string_length(str) - i | 0) - 1 | 0);
                             try{
                              var
                               _bc_ = runtime.caml_int_of_string(index_string),
                               index$1 = _bc_;
                             }
                             catch(_bd_){
                              var _bb_ = caml_wrap_exception(_bd_);
                              if(_bb_[1] !== Stdlib[7])
                               throw caml_maybe_attach_backtrace(_bb_, 0);
                              caml_call2(Stdlib_Printf[3], _P_, str);
                              var index$1 = caml_call1(Stdlib[99], 1);
                             }
                             var index$0 = [0, index$1], filename = filename$0;
                            }
                            else
                             var index$0 = 0, filename = str;
                            tests[1] = [0, [0, filename, index$0, [0, 0]], tests[1]];
                            return 0;
                           }],
                          cst_location_Run_only_the_test],
                         [0,
                          [0,
                           cst_no_color,
                           [3, use_color],
                           cst_Summarize_tests_without_us],
                          [0,
                           [0,
                            cst_in_place,
                            [2, in_place],
                            cst_Update_expect_tests_in_pla],
                           [0,
                            [0,
                             cst_diff_cmd,
                             [4, function(s){diff_command[1] = [0, s]; return 0;}],
                             cst_Diff_command_for_tests_tha],
                            [0,
                             [0,
                              cst_allow_output_patterns,
                              [2, allow_output_patterns],
                              cst_Allow_output_patterns_in_t],
                             [0,
                              [0,
                               cst_source_tree_root,
                               [4, function(s){source_tree_root[1] = [0, s]; return 0;}],
                               cst_Path_to_the_root_of_the_so],
                              0]]]]]]]]]]]]]]]]]),
         argv = caml_call1(Stdlib_Array[12], [0, name, rest]);
        try{caml_call5(Stdlib_Arg[3], 0, argv, l, f, msg$1);}
        catch(exn$0){
         var exn = caml_wrap_exception(exn$0);
         if(exn[1] === Stdlib_Arg[8]){
          var msg = exn[2];
          caml_call2(Stdlib_Printf[3], _a_, msg);
          caml_call1(Stdlib[99], 1);
         }
         else{
          if(exn[1] !== Stdlib_Arg[7])
           throw caml_maybe_attach_backtrace(exn, 0);
          var msg$0 = exn[2];
          caml_call2(Stdlib_Printf[2], _b_, msg$0);
          caml_call1(Stdlib[99], 0);
         }
        }
        var
         _Q_ = list_partitions[1] ? -260537174 : [0, 1025081494, partition[1]],
         v =
           [0,
            -753295984,
            [0, [0, lib, tests[1], name_filter[1], tag_predicate[1]], _Q_]];
        action[1] = v;
        break a;
       }
      }
     }
    }
   }
   var am_test_runner = typeof get(0) === "number" ? 0 : 1;
   a:
   {
    try{caml_sys_getenv("PPX_INLINE_TEST_LIB_AM_RUNNING_INLINE_TEST");}
    catch(_a8_){
     var _k_ = caml_wrap_exception(_a8_);
     if(_k_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_k_, 0);
     b:
     {
      try{var val = caml_sys_getenv(cst_TESTING_FRAMEWORK);}
      catch(_a9_){
       var _l_ = caml_wrap_exception(_a9_);
       if(_l_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_l_, 0);
       var _m_ = 0;
       break b;
      }
      var _M_ = val !== "inline-test" ? 0 : 1, _m_ = _M_;
     }
     var am_running_inline_test = _m_;
     break a;
    }
    var am_running_inline_test = 1;
   }
   var
    testing = am_test_runner ? _n_ : am_running_inline_test ? _L_ : 822171972;
   function wall_time_clock_ns(param){return caml_call1(Time_now[1], 0);}
   var
    where_to_cut_backtrace =
      [246,
       function(param){
        var
         _a6_ = caml_call2(Stdlib[28], cst$2, cst_time_without_resetting_ran),
         _a7_ = caml_call2(Stdlib[28], cst_Ppx_inline_test_lib_Runtim, _a6_);
        return caml_call2(Base_String[70][2], 0, _a7_);
       }];
   function time_without_resetting_random_(f){
    var before_ns = wall_time_clock_ns(0);
    try{var _a5_ = [0, caml_call1(f, 0)], res = _a5_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      res = [1, [0, exn, caml_call1(Stdlib_Printexc[6], 0)]];
    }
    var
     _a3_ = wall_time_clock_ns(0),
     _a4_ = caml_call2(Base_Int63[42], _a3_, before_ns);
    time_sec[1] = caml_call1(Base_Int63[3], _a4_) / 1000000000.;
    return res;
   }
   var
    saved_caml_random_state =
      [246,
       function(_a2_){
        return caml_call1(Stdlib_Random[12][1], [0, 100, 200, 300]);
       }],
    saved_base_random_state =
      [246,
       function(_a1_){
        return caml_call1(Base_Random[18][2], [0, 111, 222, 333]);
       }];
   function string_of_module_descr(param){
    var
     t = current$0[1],
     _aW_ = caml_call2(Stdlib_List[19], function(m){return m[1];}, t),
     _aX_ =
       caml_call2
        (Stdlib_List[19],
         function(s){
          var
           _aY_ = caml_call1(Stdlib_String[28], s),
           _aZ_ = caml_call2(Stdlib[28], _aY_, cst$3),
           _a0_ = caml_call2(Stdlib[28], cst_T_MODULE_at, _aZ_);
          return caml_call2(Stdlib[28], cst_in_TES, _a0_);
         },
         _aW_);
    return caml_call2(Stdlib_String[6], cst$4, _aX_);
   }
   function print_delayed_errors(param){
    var delayed_errors$0 = caml_call1(Stdlib_List[9], delayed_errors[1]);
    if(! delayed_errors$0) return;
    var _aV_ = caml_call2(Stdlib_String[1], 70, 61);
    caml_call2(Stdlib_Printf[3], _o_, _aV_);
    return caml_call2
            (Stdlib_List[17],
             function(message){
              return caml_call2(Stdlib_Printf[3], _p_, message);
             },
             delayed_errors$0);
   }
   function eprintf_or_delay(fmt){
    return caml_call2
            (Stdlib_Printf[10],
             function(s){
              if(verbose[1])
               delayed_errors[1] = [0, s, delayed_errors[1]];
              else
               caml_call2(Stdlib_Printf[3], _q_, s);
              var _aU_ = stop_on_error[1];
              return _aU_
                      ? (print_delayed_errors(0), caml_call1(Stdlib[99], 2))
                      : _aU_;
             },
             fmt);
   }
   function add_hooks(C){
    return function(f, param){caml_call1(C[1], 0); return caml_call1(f, 0);};
   }
   function hum_backtrace(backtrace){
    var
     _aO_ = caml_call1(Base_String[88], backtrace),
     _aP_ =
       caml_call2
        (Base_List[133],
         _aO_,
         function(str){
          var
           _aS_ = caml_obj_tag(where_to_cut_backtrace),
           _aT_ =
             250 === _aS_
              ? where_to_cut_backtrace[1]
              : 246
                === _aS_
                ? caml_call1(CamlinternalLazy[2], where_to_cut_backtrace)
                : where_to_cut_backtrace;
          return 1 - caml_call2(Base_String[70][5], _aT_, str);
         }),
     _aQ_ =
       caml_call2
        (Base_List[76],
         _aP_,
         function(str){
          var _aR_ = caml_call2(Base[197], str, cst$5);
          return caml_call2(Base[197], cst$6, _aR_);
         });
    return caml_call2(Base_String[54], 0, _aQ_);
   }
   function test_inner
   (config,
    descr,
    tags,
    def_filename,
    def_line_number,
    start_pos,
    end_pos,
    f,
    bool_of_f){
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     _ar_ = match[2],
     what_to_do = _ar_[2],
     match$0 = _ar_[1],
     which_tags = match$0[4],
     name_filter = match$0[3],
     only_test_location = match$0[2],
     libname = match$0[1],
     _aF_ = add_hooks(config);
    function f$0(_aM_){var _aN_ = _aM_; return _aF_(f, _aN_);}
    var
     descr$0 =
       [246,
        function(_aL_){
         return displayed_descr(descr)
                 (def_filename, def_line_number, start_pos, end_pos);
        }],
     _as_ = current_tags(0),
     complete_tags = caml_call2(Stdlib[37], tags, _as_),
     _at_ = caml_equal([0, libname], dynamic_lib[1]);
    if(_at_){
     var
      _au_ =
        only_test_location
         ? caml_call2
           (Stdlib_List[33],
            function(param){
             var
              used = param[3],
              line_number_opt = param[2],
              filename = param[1],
              position_start =
                caml_ml_string_length(def_filename)
                - caml_ml_string_length(filename)
                | 0,
              _aG_ = 0 <= position_start ? 1 : 0;
             if(_aG_){
              var
               end_of_def_filename =
                 caml_call3
                  (Stdlib_String[15],
                   def_filename,
                   position_start,
                   caml_ml_string_length(filename)),
               _aH_ = end_of_def_filename == filename ? 1 : 0;
              if(_aH_){
               var
                _aI_ = 0 === position_start ? 1 : 0,
                _aJ_ =
                  _aI_
                  ||
                   (47
                     ===
                      runtime.caml_string_get
                       (def_filename, position_start - 1 | 0)
                     ? 1
                     : 0);
               if(_aJ_)
                if(line_number_opt)
                 var
                  line_number = line_number_opt[1],
                  _aK_ = caml_equal(def_line_number, line_number);
                else
                 var _aK_ = 1;
               else
                var _aK_ = _aJ_;
              }
              else
               var _aK_ = _aH_;
              var found = _aK_;
             }
             else
              var found = _aG_;
             if(found) used[1] = 1;
             return found;
            },
            only_test_location)
         : 1;
     if(_au_){
      var
       _am_ =
         caml_call2
          (Stdlib_List[33],
           function(req){
            return 1 - caml_call2(Stdlib_List[36], req, complete_tags);
           },
           which_tags[1]),
       _av_ =
         _am_
         ||
          caml_call2
           (Stdlib_List[33],
            function(dropped){
             return caml_call2(Stdlib_List[36], dropped, complete_tags);
            },
            which_tags[2]),
       _aw_ = 1 - _av_;
      if(_aw_)
       var
        _ax_ = caml_obj_tag(descr$0),
        descr$1 =
          250 === _ax_
           ? descr$0[1]
           : 246 === _ax_ ? caml_call1(CamlinternalLazy[2], descr$0) : descr$0,
        _ay_ =
          name_filter
           ? caml_call2
             (Stdlib_List[33],
              function(substring){
               return caml_call2(Base_String[76], descr$1, substring);
              },
              name_filter)
           : 1,
        should_run = _ay_;
      else
       var should_run = _aw_;
     }
     else
      var should_run = _au_;
    }
    else
     var should_run = _at_;
    if(should_run){
     if(typeof what_to_do === "number") return found_test(0);
     var partition = what_to_do[2], _az_ = is_current(partition);
     if(_az_){
      var
       _aA_ = caml_obj_tag(descr$0),
       descr$2 =
         250 === _aA_
          ? descr$0[1]
          : 246 === _aA_ ? caml_call1(CamlinternalLazy[2], descr$0) : descr$0;
      tests_ran[1]++;
      var match$1 = log[1];
      if(match$1){
       var ch = match$1[1], _aB_ = string_of_module_descr(0);
       caml_call4(Stdlib_Printf[1], ch, _r_, descr$2, _aB_);
      }
      if(verbose[1]) caml_call2(Stdlib_Printf[2], _s_, descr$2);
      if(list_test_names[1])
       var result$0 = _t_;
      else{
       var
        caml_random_state = caml_call1(Stdlib_Random[13], 0),
        base_random_state = caml_call1(Base_Random[18][4], Base_Random[18][1]),
        _an_ = caml_obj_tag(saved_caml_random_state),
        _ao_ =
          250 === _an_
           ? saved_caml_random_state[1]
           : 246
             === _an_
             ? caml_call1(CamlinternalLazy[2], saved_caml_random_state)
             : saved_caml_random_state;
       caml_call1(Stdlib_Random[14], _ao_);
       var
        _ap_ = caml_obj_tag(saved_base_random_state),
        _aq_ =
          250 === _ap_
           ? saved_base_random_state[1]
           : 246
             === _ap_
             ? caml_call1(CamlinternalLazy[2], saved_base_random_state)
             : saved_base_random_state;
       caml_call1(Base_Random[19], _aq_);
       var result = time_without_resetting_random_(f$0);
       caml_call1(Stdlib_Random[14], caml_random_state);
       caml_call1(Base_Random[19], base_random_state);
       var result$0 = caml_call2(Stdlib_Result[8], bool_of_f, result);
      }
      if(verbose[1]) caml_call2(Stdlib_Printf[2], _u_, time_sec[1]);
      if(0 !== result$0[0]){
       var match$2 = result$0[1], backtrace = match$2[2], exn = match$2[1];
       tests_failed[1]++;
       var
        backtrace$0 = hum_backtrace(backtrace),
        exn_str = caml_call1(Sexplib0_Sexp_conv[68], exn),
        sep = caml_call2(Stdlib_String[14], exn_str, 10) ? cst$7 : cst$8,
        _aD_ = string_of_module_descr(0);
       return caml_call5
               (eprintf_or_delay(_w_),
                descr$2,
                sep,
                exn_str,
                backtrace$0,
                _aD_);
      }
      if(result$0[1]) return 0;
      tests_failed[1]++;
      var _aC_ = string_of_module_descr(0);
      return caml_call2(eprintf_or_delay(_v_), descr$2, _aC_);
     }
     var _aE_ = _az_;
    }
    else
     var _aE_ = should_run;
    return _aE_;
   }
   function set_lib_and_partition(static_lib, partition){
    if(dynamic_lib[1]) return 0;
    dynamic_lib[1] = [0, static_lib];
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     match$0 = match[2],
     what_to_do = match$0[2],
     which_tests = match$0[1],
     _al_ = which_tests[1] == static_lib ? 1 : 0;
    if(! _al_) return _al_;
    a:
    {
     if(typeof what_to_do !== "number" && ! what_to_do[2]){var requires_partition = 0; break a;}
     var requires_partition = 1;
    }
    if(partition == cst$13 && requires_partition)
     return caml_call1(Stdlib[2], cst_ppx_inline_test_cannot_use);
    current[1] = partition;
    return 0;
   }
   function unset_lib(static_lib){
    var match = dynamic_lib[1];
    if(! match) return 0;
    var
     lib = match[1],
     _aj_ = lib == static_lib ? 1 : 0,
     _ak_ = _aj_ ? (dynamic_lib[1] = 0, 0) : _aj_;
    return _ak_;
   }
   function test
   (config, descr, tags, filename, line_number, start_pos, end_pos, f){
    return test_inner
            (config,
             descr,
             tags,
             filename,
             line_number,
             start_pos,
             end_pos,
             f,
             function(b){return b;});
   }
   function test_unit
   (config, descr, tags, filename, line_number, start_pos, end_pos, f){
    return test_inner
            (config,
             descr,
             tags,
             filename,
             line_number,
             start_pos,
             end_pos,
             f,
             function(param){return 1;});
   }
   function test_module
   (config, descr, tags, def_filename, def_line_number, start_pos, end_pos, f){
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     _$_ = match[2],
     what_to_do = _$_[2],
     match$0 = _$_[1],
     which_tags = match$0[4],
     libname = match$0[1],
     _ag_ = add_hooks(config);
    function f$0(_ah_){var _ai_ = _ah_; return _ag_(f, _ai_);}
    var
     _aa_ = current_tags(0),
     partial_tags = caml_call2(Stdlib[37], tags, _aa_),
     _ab_ = caml_equal([0, libname], dynamic_lib[1]),
     should_run =
       _ab_
        ? 1
         -
          caml_call2
           (Stdlib_List[33],
            function(dropped){
             return caml_call2(Stdlib_List[36], dropped, partial_tags);
            },
            which_tags[2])
        : _ab_;
    if(should_run){
     if(typeof what_to_do === "number") return found_test(0);
     var partition = what_to_do[2], _ac_ = is_current(partition);
     if(_ac_){
      test_modules_ran[1]++;
      var
       descr$0 =
         displayed_descr(descr)
          (def_filename, def_line_number, start_pos, end_pos),
       prev = current$0[1];
      current$0[1] = [0, [0, descr$0, tags], prev];
      try{var x = time_without_resetting_random_(f$0); current$0[1] = prev;}
      catch(e$0){
       var e = caml_wrap_exception(e$0);
       current$0[1] = prev;
       throw caml_maybe_attach_backtrace(e, 0);
      }
      if(0 === x[0]) return 0;
      var match$1 = x[1], backtrace = match$1[2], exn = match$1[1];
      test_modules_failed[1]++;
      var
       backtrace$0 = hum_backtrace(backtrace),
       exn_str = caml_call1(Sexplib0_Sexp_conv[68], exn),
       sep = caml_call2(Stdlib_String[14], exn_str, 10) ? cst$9 : cst$10,
       _ad_ = string_of_module_descr(0),
       _ae_ = caml_call1(Stdlib_String[28], descr$0);
      return caml_call5
              (eprintf_or_delay(caml_call2(Stdlib[98], _y_, _x_)),
               _ae_,
               sep,
               exn_str,
               backtrace$0,
               _ad_);
     }
     var _af_ = _ac_;
    }
    else
     var _af_ = should_run;
    return _af_;
   }
   function summarize(param){
    var match = get(0);
    if(typeof match !== "number"){
     var _X_ = match[2], which_tests = _X_[1];
     if(typeof _X_[2] === "number"){
      var
       _U_ =
         caml_call3
          (Stdlib_Hashtbl[14],
           function(k, param, acc){return [0, k, acc];},
           _d_,
           0),
       _V_ = caml_call2(Stdlib_List[56], Stdlib_String[9], _U_),
       _Y_ = caml_call1(Stdlib_Printf[2], _B_);
      caml_call2(Stdlib_List[17], _Y_, _V_);
      return 0;
     }
     var match$0 = log[1];
     if(match$0){var ch = match$0[1]; caml_call1(Stdlib[76], ch);}
     print_delayed_errors(0);
     var count = tests_failed[1], count_test_modules = test_modules_failed[1];
     if(0 === count && 0 === count_test_modules){
      if(show_counts[1])
       caml_call3(Stdlib_Printf[3], _C_, tests_ran[1], test_modules_ran[1]);
      var
       unused_tests =
         caml_call2
          (Stdlib_List[41],
           function(param){var used = param[3]; return 1 - used[1];},
           which_tests[2]),
       errors = unused_tests ? [0, unused_tests] : 0;
      if(errors){
       var tests = errors[1];
       caml_call1(Stdlib_Printf[3], _D_);
       caml_call2
        (Stdlib_List[17],
         function(param){
          var line_number_opt = param[2], filename = param[1];
          if(! line_number_opt)
           return caml_call2(Stdlib_Printf[3], _F_, filename);
          var line_number = line_number_opt[1];
          return caml_call3(Stdlib_Printf[3], _E_, filename, line_number);
         },
         tests);
       caml_call1(Stdlib_Printf[3], _G_);
       return 2;
      }
      if(0 === tests_ran[1] && strict[1]){
       caml_call1(Stdlib_Printf[3], _H_);
       return 2;
      }
      return 0;
     }
     if(0 === count_test_modules)
      var _Z_ = cst$11;
     else
      var
       ___ = caml_call2(Stdlib[98], _K_, _J_),
       _Z_ = caml_call2(Stdlib_Printf[4], ___, count_test_modules);
     caml_call4(Stdlib_Printf[3], _I_, count, tests_ran[1], _Z_);
     return 1;
    }
    a:
    {
     if(runtime.caml_notequal(caml_sys_argv(0), [0])){
      var _W_ = runtime.caml_check_bound(caml_sys_argv(0), 0)[1];
      if(caml_call1(Stdlib_Filename[13], _W_) == "inline_tests_runner.exe"){caml_call1(Stdlib_Printf[3], _z_); break a;}
     }
     caml_call1(Stdlib_Printf[3], _A_);
    }
    return 2;
   }
   var
    use_color$0 = use_color[1],
    in_place$0 = in_place[1],
    diff_command$0 = diff_command[1],
    source_tree_root$0 = source_tree_root[1],
    allow_output_patterns$0 = allow_output_patterns[1],
    evaluators = [0, [0, summarize, 0]];
   function add_evaluator(f){evaluators[1] = [0, f, evaluators[1]]; return 0;}
   function exit(param){
    var _S_ = caml_call1(Stdlib_List[9], evaluators[1]);
    switch
     (combine_all
       (caml_call2
         (Stdlib_List[19], function(f){return caml_call1(f, 0);}, _S_))){
      case 0:
       var _T_ = 0; break;
      case 1:
       var _T_ = 2; break;
      default: var _T_ = 1;
    }
    return caml_call1(Stdlib[99], _T_);
   }
   var
    Ppx_inline_test_lib_Runtime =
      [0,
       [0, combine, combine_all, to_string],
       set_lib_and_partition,
       unset_lib,
       test,
       test_unit,
       test_module,
       testing,
       use_color$0,
       in_place$0,
       diff_command$0,
       source_tree_root$0,
       allow_output_patterns$0,
       am_running_inline_test,
       am_running_inline_test_env_var,
       add_evaluator,
       exit];
   runtime.caml_register_global
    (124, Ppx_inline_test_lib_Runtime, cst_Ppx_inline_test_lib_Runtim$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcHhfaW5saW5lX3Rlc3RfbGliLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJlbmFibGVfZXZlcnl0aGluZyIsImFtX3J1bm5pbmdfaW5saW5lX3Rlc3RfZW52X3ZhciIsInRvX3N0cmluZyIsImNvbWJpbmUiLCJ0MSIsInQyIiwiY29tYmluZV9hbGwiLCJ0cyIsInRlc3RfbW9kdWxlc19yYW4iLCJ0ZXN0X21vZHVsZXNfZmFpbGVkIiwidGVzdHNfcmFuIiwidGVzdHNfZmFpbGVkIiwiZHluYW1pY19saWIiLCJhY3Rpb24iLCJmb3JjZV9kcm9wIiwiZ2V0IiwiY3VycmVudCIsImZvdW5kX3Rlc3QiLCJpc19jdXJyZW50IiwicCIsImN1cnJlbnQkMCIsImN1cnJlbnRfdGFncyIsInQiLCJtIiwidmVyYm9zZSIsInN0cmljdCIsInNob3dfY291bnRzIiwibGlzdF90ZXN0X25hbWVzIiwiZGVsYXllZF9lcnJvcnMiLCJzdG9wX29uX2Vycm9yIiwibG9nIiwidGltZV9zZWMiLCJ1c2VfY29sb3IiLCJpbl9wbGFjZSIsImRpZmZfY29tbWFuZCIsInNvdXJjZV90cmVlX3Jvb3QiLCJhbGxvd19vdXRwdXRfcGF0dGVybnMiLCJkaXNwbGF5ZWRfZGVzY3IiLCJkZXNjciIsImZpbGVuYW1lIiwibGluZSIsInN0YXJ0X3BvcyIsImVuZF9wb3MiLCJuYW1lIiwicmVzdCIsImxpYiIsInRlc3RzIiwibGlzdF9wYXJ0aXRpb25zIiwicGFydGl0aW9uIiwidGFnX3ByZWRpY2F0ZSIsIm5hbWVfZmlsdGVyIiwibXNnJDEiLCJmIiwiYW5vbiIsImwiLCJpIiwidGFnIiwicyIsInN0ciIsImZpbGUiLCJpbmRleCIsImluZGV4JDAiLCJmaWxlbmFtZSQwIiwiaW5kZXhfc3RyaW5nIiwiaW5kZXgkMSIsImFyZ3YiLCJtc2ciLCJtc2ckMCIsInYiLCJhbV90ZXN0X3J1bm5lciIsImFtX3J1bm5pbmdfaW5saW5lX3Rlc3QiLCJ0ZXN0aW5nIiwid2FsbF90aW1lX2Nsb2NrX25zIiwid2hlcmVfdG9fY3V0X2JhY2t0cmFjZSIsInRpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuZG9tXyIsImJlZm9yZV9ucyIsInJlcyIsImV4biQwIiwiZXhuIiwic2F2ZWRfY2FtbF9yYW5kb21fc3RhdGUiLCJzYXZlZF9iYXNlX3JhbmRvbV9zdGF0ZSIsInN0cmluZ19vZl9tb2R1bGVfZGVzY3IiLCJwcmludF9kZWxheWVkX2Vycm9ycyIsImRlbGF5ZWRfZXJyb3JzJDAiLCJtZXNzYWdlIiwiZXByaW50Zl9vcl9kZWxheSIsImZtdCIsImFkZF9ob29rcyIsIkMiLCJodW1fYmFja3RyYWNlIiwiYmFja3RyYWNlIiwidGVzdF9pbm5lciIsImNvbmZpZyIsInRhZ3MiLCJkZWZfZmlsZW5hbWUiLCJkZWZfbGluZV9udW1iZXIiLCJib29sX29mX2YiLCJ3aGF0X3RvX2RvIiwid2hpY2hfdGFncyIsIm9ubHlfdGVzdF9sb2NhdGlvbiIsImxpYm5hbWUiLCJmJDAiLCJkZXNjciQwIiwiY29tcGxldGVfdGFncyIsInVzZWQiLCJsaW5lX251bWJlcl9vcHQiLCJwb3NpdGlvbl9zdGFydCIsImVuZF9vZl9kZWZfZmlsZW5hbWUiLCJsaW5lX251bWJlciIsImZvdW5kIiwicmVxIiwiZHJvcHBlZCIsImRlc2NyJDEiLCJzdWJzdHJpbmciLCJzaG91bGRfcnVuIiwiZGVzY3IkMiIsImNoIiwicmVzdWx0JDAiLCJjYW1sX3JhbmRvbV9zdGF0ZSIsImJhc2VfcmFuZG9tX3N0YXRlIiwicmVzdWx0IiwiYmFja3RyYWNlJDAiLCJleG5fc3RyIiwic2VwIiwic2V0X2xpYl9hbmRfcGFydGl0aW9uIiwic3RhdGljX2xpYiIsIndoaWNoX3Rlc3RzIiwicmVxdWlyZXNfcGFydGl0aW9uIiwidW5zZXRfbGliIiwidGVzdCIsImIiLCJ0ZXN0X3VuaXQiLCJ0ZXN0X21vZHVsZSIsInBhcnRpYWxfdGFncyIsInByZXYiLCJ4IiwiZSQwIiwiZSIsInN1bW1hcml6ZSIsImsiLCJhY2MiLCJjb3VudCIsImNvdW50X3Rlc3RfbW9kdWxlcyIsInVudXNlZF90ZXN0cyIsImVycm9ycyIsInVzZV9jb2xvciQwIiwiaW5fcGxhY2UkMCIsImRpZmZfY29tbWFuZCQwIiwic291cmNlX3RyZWVfcm9vdCQwIiwiYWxsb3dfb3V0cHV0X3BhdHRlcm5zJDAiLCJldmFsdWF0b3JzIiwiYWRkX2V2YWx1YXRvciIsImV4aXQiXSwic291cmNlcyI6WyIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL3BweF9pbmxpbmVfdGVzdC9ydW50aW1lLWxpYi9ydW50aW1lLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBNERNQTs7SUFrUEZDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUFyU0VDO0lBQVk7O09BQ0Q7O09BQ0E7ZUFDQTs7R0FBTztZQUdsQkMsUUFBUUMsSUFBR0M7SUFDYjs7WUFEVUQ7O2FBQUdDLElBRWdCOzs7O2NBRmhCQSxJQUlnQjs7SUFEQTtHQUNPO1lBR2xDQyxZQUFZQztJQUFLLE9BQUEsNEJBUGpCSixZQU9ZSTtHQUFzQztHQVlqQztJQUFuQkM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFxRUVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFVTtJQUErQyxJQUFBLFNBRHpEQzs7Ozs7UUFBQUE7O1lBR0FDLFdBTUYsT0FURUQsMEJBREFELFVBWVU7R0FXSixJQUFBLE1BQUEsc0NBQ05HO1lBQ0FDO0lBQ0Y7S0FBRyxPQUZERDtLQUVD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LFFBVEhrRztPQVVGO09BQ0E7OztVQUFVLElBQWdCdkMsNEJBQVZsRTtVQUNkLEtBRHdCa0U7V0FFZCxPQUFBLGtDQUZJbEU7Y0FHUHFFLGNBSGlCSDtVQUdGLE9BQUEsa0NBSFJsRSxVQUdQcUU7U0FDUjtTQU5JOUQ7T0FPTDtPQUFBOztlQXhrQlJwQyxnQkE2SUFlO09BK2JVO09BQUE7O01BRU87O2NBSU5xSDs7O01BRWtEO09BQUEsTUFBQTthQUFmLGtDQUZuQ0E7S0FDUCxrQ0FEQUQsT0FsbEJKbkk7S0FtbEJJOzs7O0tBakRELEdBQUE7TUFBc0M7TUFBbEIsR0FBQSxtRUFDckI7O0tBR0E7O0lBQUE7R0FnREM7R0FRVTtJQU5idUksY0FqY0FqSDtJQWtjQWtILGFBamNBakg7SUFrY0FrSCxpQkFqY0FqSDtJQWtjQWtILHFCQWpjQWpIO0lBa2NBa0gsMEJBamNBakg7SUFtY0FrSCxxQkEvREFaO1lBZ0VBYSxjQUFlbkcsR0FEZmtHLG9CQUNlbEcsR0FEZmtHLHlCQUNpRDtZQUNqREU7SUFDdUIsVUFBQSwyQkFIdkJGOztNQTVtQkVoSjtRQSttQko7b0NBQWM4QyxHQUFLLE9BQUEsV0FBTEEsTUFBUzs7Ozs7OztJQUF2QixPQUFBO0dBR087Ozs7V0F6bkJIakQsU0FPQUcsYUFiQUo7T0E2ZEYwSDtPQXVCQUk7T0FVQUM7T0FJQUU7T0FJZUM7T0FqTmY3RDtPQThUQTBFO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BM1VBL0U7T0FQQXJFO09BcVZBc0o7T0FDQUM7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBUZXN0X3Jlc3VsdCA9IHN0cnVjdFxuICB0eXBlIHQgPSBTdWNjZXNzIHwgRmFpbHVyZSB8IEVycm9yXG5cbiAgbGV0IHRvX2V4aXRfY29kZSA9IGZ1bmN0aW9uXG4gICAgfCBTdWNjZXNzIC0+IDBcbiAgICB8IEZhaWx1cmUgLT4gMlxuICAgIHwgRXJyb3IgICAtPiAxXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyA9IGZ1bmN0aW9uXG4gICAgfCBTdWNjZXNzIC0+IFwic3VjY2Vzc1wiXG4gICAgfCBGYWlsdXJlIC0+IFwiZmFpbHVyZVwiXG4gICAgfCBFcnJvciAgIC0+IFwiZXJyb3JcIlxuICA7O1xuXG4gIGxldCBjb21iaW5lIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgU3VjY2VzcywgU3VjY2VzcyAgICAgICAgLT4gU3VjY2Vzc1xuICAgIHwgRXJyb3IgICwgXyB8IF8sIEVycm9yICAgLT4gRXJyb3JcbiAgICB8IEZhaWx1cmUsIF8gfCBfLCBGYWlsdXJlIC0+IEZhaWx1cmVcbiAgOztcblxuICBsZXQgY29tYmluZV9hbGwgdHMgPSBMaXN0LmZvbGRfbGVmdCBjb21iaW5lIFN1Y2Nlc3MgdHNcbmVuZFxuXG5sZXQgcGFyc2VfYXJndiBhcmd2IGwgZiBtc2cgPVxuICB0cnlcbiAgICBBcmcucGFyc2VfYXJndiBhcmd2IGwgZiBtc2dcbiAgd2l0aFxuICB8IEFyZy5CYWQgbXNnIC0+IFByaW50Zi5lcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMVxuICB8IEFyZy5IZWxwIG1zZyAtPiBQcmludGYucHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuOztcblxudHlwZSBkZXNjciA9IHN0cmluZ1xubGV0IHRlc3RfbW9kdWxlc19yYW4gPSByZWYgMFxubGV0IHRlc3RfbW9kdWxlc19mYWlsZWQgPSByZWYgMFxubGV0IHRlc3RzX3JhbiA9IHJlZiAwXG5sZXQgdGVzdHNfZmFpbGVkID0gcmVmIDBcbmxldCBkeW5hbWljX2xpYiA6IHN0cmluZyBvcHRpb24gcmVmID0gcmVmIE5vbmVcbnR5cGUgZmlsZW5hbWUgPSBzdHJpbmdcbnR5cGUgbGluZV9udW1iZXIgPSBpbnRcbnR5cGUgc3RhcnRfcG9zID0gaW50XG50eXBlIGVuZF9wb3MgPSBpbnRcbnR5cGUgY29uZmlnID0gKG1vZHVsZSBJbmxpbmVfdGVzdF9jb25maWcuUylcbnR5cGUgJ2EgdGVzdF9mdW5jdGlvbl9hcmdzXG4gID0gY29uZmlnOmNvbmZpZ1xuICAtPiBkZXNjcjpkZXNjciBMYXp5LnRcbiAgLT4gdGFnczpzdHJpbmcgbGlzdFxuICAtPiBmaWxlbmFtZTpmaWxlbmFtZVxuICAtPiBsaW5lX251bWJlcjpsaW5lX251bWJlclxuICAtPiBzdGFydF9wb3M6c3RhcnRfcG9zXG4gIC0+IGVuZF9wb3M6ZW5kX3Bvc1xuICAtPiAnYVxuXG5tb2R1bGUgVGFnX3ByZWRpY2F0ZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgcmVxdWlyZWRfdGFncyAgOiBzdHJpbmcgbGlzdFxuICAgIDsgZHJvcHBlZF90YWdzIDogc3RyaW5nIGxpc3RcbiAgICB9XG5cbiAgbGV0IGVuYWJsZV9ldmVyeXRoaW5nID0geyByZXF1aXJlZF90YWdzID0gW107IGRyb3BwZWRfdGFncyA9IFtdIH1cblxuICBsZXQgZHJvcCB0IHRhZyA9XG4gICAgeyBkcm9wcGVkX3RhZ3MgPSB0YWcgOjogdC5kcm9wcGVkX3RhZ3NcbiAgICA7IHJlcXVpcmVkX3RhZ3MgPSBMaXN0LmZpbHRlciAoKDw+KSB0YWcpIHQucmVxdWlyZWRfdGFnc1xuICAgIH1cblxuICBsZXQgcmVxdWlyZSB0IHRhZyA9XG4gICAgeyBkcm9wcGVkX3RhZ3MgPSBMaXN0LmZpbHRlciAoKDw+KSB0YWcpIHQuZHJvcHBlZF90YWdzXG4gICAgOyByZXF1aXJlZF90YWdzID0gdGFnIDo6IHQucmVxdWlyZWRfdGFnc1xuICAgIH1cblxuICBsZXQgZW50aXJlX21vZHVsZV9kaXNhYmxlZCB0IH5wYXJ0aWFsX3RhZ3M6dGFncyA9XG4gICAgTGlzdC5leGlzdHMgKGZ1biBkcm9wcGVkIC0+IExpc3QubWVtIGRyb3BwZWQgdGFncykgdC5kcm9wcGVkX3RhZ3NcblxuICBsZXQgZGlzYWJsZWQgdCB+Y29tcGxldGVfdGFnczp0YWdzID1cbiAgICBMaXN0LmV4aXN0cyAoZnVuIHJlcSAtPiBub3QgKExpc3QubWVtIHJlcSB0YWdzKSkgdC5yZXF1aXJlZF90YWdzXG4gICAgfHwgTGlzdC5leGlzdHMgKGZ1biBkcm9wcGVkIC0+IExpc3QubWVtIGRyb3BwZWQgdGFncykgdC5kcm9wcGVkX3RhZ3NcbmVuZFxuXG5cbnR5cGUgd2hpY2hfdGVzdHMgPVxuICB7IGxpYm5hbWUgOiBzdHJpbmdcbiAgOyBvbmx5X3Rlc3RfbG9jYXRpb24gOiAoZmlsZW5hbWUgKiBsaW5lX251bWJlciBvcHRpb24gKiBib29sIHJlZikgbGlzdFxuICA7IG5hbWVfZmlsdGVyIDogc3RyaW5nIGxpc3RcbiAgOyB3aGljaF90YWdzIDogVGFnX3ByZWRpY2F0ZS50XG4gIH1cbnR5cGUgdGVzdF9tb2RlID1cbiAgeyB3aGljaF90ZXN0cyA6IHdoaWNoX3Rlc3RzXG4gIDsgd2hhdF90b19kbyA6XG4gICAgICBbIGBSdW5fcGFydGl0aW9uIG9mIHN0cmluZyBvcHRpb25cbiAgICAgIHwgYExpc3RfcGFydGl0aW9uc1xuICAgICAgXVxuICB9XG5cbm1vZHVsZSBBY3Rpb24gOiBzaWdcbiAgdHlwZSB0ID0gW1xuICAgIHwgYElnbm9yZVxuICAgIHwgYFRlc3RfbW9kZSBvZiB0ZXN0X21vZGVcbiAgXVxuICB2YWwgZ2V0IDogdW5pdCAtPiB0XG4gIHZhbCBzZXQgOiB0IC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBbXG4gICAgfCBgSWdub3JlXG4gICAgfCBgVGVzdF9tb2RlIG9mIHRlc3RfbW9kZVxuICBdXG4gIGxldCBhY3Rpb24gOiB0IHJlZiA9IHJlZiBgSWdub3JlXG4gIGxldCBmb3JjZV9kcm9wID1cbiAgICB0cnkgaWdub3JlIChTeXMuZ2V0ZW52IFwiRk9SQ0VfRFJPUF9JTkxJTkVfVEVTVFwiIDogc3RyaW5nKTsgdHJ1ZVxuICAgIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG4gIGxldCBnZXQgKCkgPVxuICAgICgqIFRoaXMgaXMgdXNlZnVsIHdoZW4gY29tcGlsaW5nIHRvIGphdmFzY3JpcHQuXG4gICAgICAgSnNfb2Zfb2NhbWwgY2FuIHN0YXRpY2FsbHkgZXZhbHVhdGUgW1N5cy5nZXRlbnYgXCJGT1JDRV9EUk9QX0lOTElORV9URVNUXCJdXG4gICAgICAgYW5kIGlubGluZSB0aGUgcmVzdWx0IChbYElnbm9yZV0pIHdoZW5ldmVyIFtnZXQgKCldIGlzIGNhbGxlZC5cbiAgICAgICBVbml0IHRlc3RzIGNhbiB0aGVuIGJlIHRyZWF0ZWQgYXMgZGVhZGNvZGUgc2luY2UgdGhlIGFyZ3VtZW50IFtmXSBvZiB0aGUgW3Rlc3RdXG4gICAgICAgZnVuY3Rpb24gYmVsb3cgaXMgbmV2ZXIgdXNlZC4gKilcbiAgICBpZiBmb3JjZV9kcm9wXG4gICAgdGhlbiBgSWdub3JlXG4gICAgZWxzZSAhYWN0aW9uXG5cbiAgbGV0IHNldCB2ID0gYWN0aW9uIDo9IHZcbmVuZFxuXG5tb2R1bGUgUGFydGl0aW9uIDogc2lnXG4gIHZhbCBmb3VuZF90ZXN0IDogdW5pdCAtPiB1bml0XG4gIHZhbCBzZXRfY3VycmVudCA6IHN0cmluZyAtPiB1bml0XG4gIHZhbCBpc19jdXJyZW50IDogc3RyaW5nIG9wdGlvbiAtPiBib29sXG4gIHZhbCBhbGwgOiB1bml0IC0+IHN0cmluZyBsaXN0XG5lbmQgPSBzdHJ1Y3RcbiAgbGV0IGFsbCA9IEhhc2h0YmwuY3JlYXRlIDIzXG4gIGxldCBjdXJyZW50ID0gcmVmIFwiXCIgIGxldCBzZXRfY3VycmVudCB4ID0gY3VycmVudCA6PSB4XG4gIGxldCBmb3VuZF90ZXN0ICgpID1cbiAgICBpZiAhY3VycmVudCA8PiBcIlwiICYmIG5vdCAoSGFzaHRibC5tZW0gYWxsICFjdXJyZW50KSB0aGVuXG4gICAgICBIYXNodGJsLmFkZCBhbGwgIWN1cnJlbnQgKClcbiAgOztcbiAgbGV0IGlzX2N1cnJlbnQgPSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgfCBTb21lIHAgLT4gcCA9ICFjdXJyZW50XG4gIDs7XG4gIGxldCBhbGwgKCkgPVxuICAgIExpc3Quc29ydCBTdHJpbmcuY29tcGFyZVxuICAgICAgKEhhc2h0YmwuZm9sZCAoZnVuIGsgKCkgYWNjIC0+IGsgOjogYWNjKSBhbGwgW10pXG4gIDs7XG5lbmRcblxubW9kdWxlIE1vZHVsZV9jb250ZXh0ID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSBvbmVfbW9kdWxlID1cbiAgICAgIHsgZGVzY3IgOiBzdHJpbmdcbiAgICAgIDsgdGFncyA6IHN0cmluZyBsaXN0XG4gICAgICB9XG5cbiAgICB0eXBlIHQgPSBvbmVfbW9kdWxlIGxpc3RcblxuICAgIGxldCBkZXNjciB0ID0gTGlzdC5tYXAgKGZ1biBtIC0+IG0uZGVzY3IpIHRcbiAgICBsZXQgdGFncyB0ID0gTGlzdC5jb25jYXQgKExpc3QubWFwIChmdW4gbSAtPiBtLnRhZ3MpIHQpXG4gIGVuZFxuXG4gIGxldCBjdXJyZW50IDogVC50IHJlZiA9IHJlZiBbXVxuXG4gIGxldCB3aXRoXyB+ZGVzY3IgfnRhZ3MgZiA9XG4gICAgbGV0IHByZXYgPSAhY3VycmVudCBpblxuICAgIGN1cnJlbnQgOj0geyBULiBkZXNjcjsgdGFncyB9IDo6IHByZXY7XG4gICAgdHJ5XG4gICAgICBsZXQgeCA9IGYgKCkgaW5cbiAgICAgIGN1cnJlbnQgOj0gcHJldjtcbiAgICAgIHhcbiAgICB3aXRoIGUgLT5cbiAgICAgIGN1cnJlbnQgOj0gcHJldjtcbiAgICAgIHJhaXNlIGVcblxuICBsZXQgY3VycmVudF9kZXNjciAoKSA9IFQuZGVzY3IgIWN1cnJlbnRcbiAgbGV0IGN1cnJlbnRfdGFncyAgKCkgPSBULnRhZ3MgICFjdXJyZW50XG5lbmRcblxubGV0IHZlcmJvc2UgPSByZWYgZmFsc2VcbmxldCBzdHJpY3QgPSByZWYgZmFsc2VcbmxldCBzaG93X2NvdW50cyA9IHJlZiBmYWxzZVxubGV0IGxpc3RfdGVzdF9uYW1lcyA9IHJlZiBmYWxzZVxubGV0IGRlbGF5ZWRfZXJyb3JzID0gcmVmIFtdXG5sZXQgc3RvcF9vbl9lcnJvciA9IHJlZiBmYWxzZVxuXG5sZXQgbG9nID0gcmVmIE5vbmVcblxubGV0IHRpbWVfc2VjID0gcmVmIDAuXG5cbmxldCB1c2VfY29sb3IgPSByZWYgdHJ1ZVxubGV0IGluX3BsYWNlICA9IHJlZiBmYWxzZVxubGV0IGRpZmZfY29tbWFuZCA9IHJlZiBOb25lXG5sZXQgc291cmNlX3RyZWVfcm9vdCA9IHJlZiBOb25lXG5sZXQgYWxsb3dfb3V0cHV0X3BhdHRlcm5zID0gcmVmIGZhbHNlXG5cbmxldCBkaXNwbGF5ZWRfZGVzY3IgKGxhenkgZGVzY3IpIGZpbGVuYW1lIGxpbmUgc3RhcnRfcG9zIGVuZF9wb3MgPVxuICBQcmludGYuc3ByaW50ZiBcIkZpbGUgJVMsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWQlc1wiXG4gICAgZmlsZW5hbWUgbGluZSBzdGFydF9wb3MgZW5kX3Bvc1xuICAgIChpZiBkZXNjciA9IFwiXCIgdGhlbiBcIlwiIGVsc2UgXCI6IFwiIF4gZGVzY3IpXG5sZXQgcGFyc2VfZGVzY3Igc3RyID1cbiAgdHJ5IFNvbWUgKFNjYW5mLnNzY2FuZiBzdHIgXCIgRmlsZSAlUyAsIGxpbmUgJWQgLCBjaGFyYWN0ZXJzICVkIC0gJWQgJSFcIlxuICAgICAgICAgICAgICAoZnVuIGZpbGUgbGluZSBfc3RhcnRfcG9zIF9lbmRfcG9zIC0+IGZpbGUsIFNvbWUgbGluZSkpXG4gIHdpdGggXyAtPlxuICB0cnkgU29tZSAoU2NhbmYuc3NjYW5mIHN0ciBcIiBGaWxlICVTICwgbGluZSAlZCAlIVwiIChmdW4gZmlsZSBsaW5lIC0+IGZpbGUsIFNvbWUgbGluZSkpXG4gIHdpdGggXyAtPlxuICB0cnkgU29tZSAoU2NhbmYuc3NjYW5mIHN0ciBcIiBGaWxlICVTICUhXCIgKGZ1biBmaWxlIC0+IGZpbGUsIE5vbmUpKVxuICB3aXRoIF8gLT4gTm9uZVxuXG5sZXQgKCkgPVxuICBtYXRjaCBBcnJheS50b19saXN0IFN5cy5hcmd2IHdpdGhcbiAgfCBuYW1lIDo6IFwiaW5saW5lLXRlc3QtcnVubmVyXCIgOjogbGliIDo6IHJlc3RcbiAgICB3aGVuIEJhc2UuRXhwb3J0ZWRfZm9yX3NwZWNpZmljX3VzZXMuYW1fdGVzdGluZyAtPiBiZWdpblxuICAgICAgKCogd2hlbiB3ZSBzZWUgdGhpcyBhcmd1bWVudCwgd2Ugc3dpdGNoIHRvIHRlc3QgbW9kZSAqKVxuICAgICAgbGV0IHRlc3RzID0gcmVmIFtdIGluXG4gICAgICBsZXQgbGlzdF9wYXJ0aXRpb25zID0gcmVmIGZhbHNlIGluXG4gICAgICBsZXQgcGFydGl0aW9uID0gcmVmIE5vbmUgaW5cbiAgICAgIGxldCB0YWdfcHJlZGljYXRlID0gcmVmIFRhZ19wcmVkaWNhdGUuZW5hYmxlX2V2ZXJ5dGhpbmcgaW5cbiAgICAgIGxldCBuYW1lX2ZpbHRlciA9IHJlZiBbXSBpblxuICAgICAgcGFyc2VfYXJndiAoQXJyYXkub2ZfbGlzdCAobmFtZSA6OiByZXN0KSkgKEFyZy5hbGlnbiBbXG4gICAgICAgIFwiLWxpc3QtdGVzdC1uYW1lc1wiLCBBcmcuVW5pdCAoZnVuICgpIC0+IGxpc3RfdGVzdF9uYW1lcyA6PSB0cnVlOyB2ZXJib3NlIDo9IHRydWUpLFxuICAgICAgICBcIiBEbyBub3QgcnVuIHRlc3RzIGJ1dCBzaG93IHdoYXQgd291bGQgaGF2ZSBiZWVuIHJ1blwiO1xuICAgICAgICBcIi1saXN0LXBhcnRpdGlvbnNcIiwgQXJnLlVuaXQgKGZ1biAoKSAtPiBsaXN0X3BhcnRpdGlvbnMgOj0gdHJ1ZSksXG4gICAgICAgIFwiIExpc3RzIGFsbCB0aGUgcGFydGl0aW9ucyB0aGF0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHRlc3Qgb3IgdGVzdF9tb2R1bGVcIjtcbiAgICAgICAgXCItcGFydGl0aW9uXCIsIEFyZy5TdHJpbmcgKGZ1biBpIC0+IHBhcnRpdGlvbiA6PSBTb21lIGkpLFxuICAgICAgICBcIiBPbmx5IHJ1biB0aGUgdGVzdHMgaW4gdGhlIGdpdmVuIHBhcnRpdGlvblwiO1xuICAgICAgICBcIi12ZXJib3NlXCIsIEFyZy5TZXQgdmVyYm9zZSwgXCIgU2hvdyB0aGUgdGVzdHMgYXMgdGhleSBydW5cIjtcbiAgICAgICAgXCItc3RvcC1vbi1lcnJvclwiLCBBcmcuU2V0IHN0b3Bfb25fZXJyb3IsIFwiIFJ1biB0ZXN0cyBvbmx5IHVwIHRvIHRoZSBmaXJzdCBlcnJvciBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZG9lc24ndCB3b3JrIGZvciBleHBlY3QgdGVzdHMpXCI7XG4gICAgICAgIFwiLXN0cmljdFwiLCBBcmcuU2V0IHN0cmljdCwgXCIgRW5kIHdpdGggYW4gZXJyb3IgaWYgbm8gdGVzdHMgd2VyZSBydW5cIjtcbiAgICAgICAgXCItc2hvdy1jb3VudHNcIiwgQXJnLlNldCBzaG93X2NvdW50cywgXCIgU2hvdyB0aGUgbnVtYmVyIG9mIHRlc3RzIHJhblwiO1xuICAgICAgICBcIi1sb2dcIiwgQXJnLlVuaXQgKGZ1biAoKSAtPlxuICAgICAgICAgICh0cnkgU3lzLnJlbW92ZSBcImlubGluZV90ZXN0cy5sb2dcIiB3aXRoIF8gLT4gKCkpO1xuICAgICAgICAgIGxvZyA6PSBTb21lIChvcGVuX291dCBcImlubGluZV90ZXN0cy5sb2dcIilcbiAgICAgICAgKSwgXCIgTG9nIHRoZSB0ZXN0cyBydW4gaW4gaW5saW5lX3Rlc3RzLmxvZ1wiO1xuICAgICAgICBcIi1kcm9wLXRhZ1wiLCBBcmcuU3RyaW5nIChmdW4gcyAtPlxuICAgICAgICAgIHRhZ19wcmVkaWNhdGUgOj0gVGFnX3ByZWRpY2F0ZS5kcm9wICF0YWdfcHJlZGljYXRlIHNcbiAgICAgICAgKSwgXCJ0YWcgT25seSBydW4gdGVzdHMgbm90IHRhZ2dlZCB3aXRoIFt0YWddIChvdmVycmlkZXMgcHJldmlvdXMgLXJlcXVpcmUtdGFnKVwiO1xuICAgICAgICBcIi1yZXF1aXJlLXRhZ1wiLCBBcmcuU3RyaW5nIChmdW4gcyAtPlxuICAgICAgICAgIHRhZ19wcmVkaWNhdGUgOj0gVGFnX3ByZWRpY2F0ZS5yZXF1aXJlICF0YWdfcHJlZGljYXRlIHNcbiAgICAgICAgKSwgXCJ0YWcgT25seSBydW4gdGVzdHMgdGFnZ2VkIHdpdGggW3RhZ10gKG92ZXJyaWRlcyBwcmV2aW91cyAtZHJvcC10YWcpXCI7XG4gICAgICAgIFwiLW1hdGNoaW5nXCIsIEFyZy5TdHJpbmcgKGZ1biBzIC0+IG5hbWVfZmlsdGVyIDo9IHMgOjogIW5hbWVfZmlsdGVyKSxcbiAgICAgICAgXCJzdWJzdHJpbmcgT25seSBydW4gdGVzdHMgd2hvc2UgbmFtZXMgY29udGFpbiB0aGUgZ2l2ZW4gc3Vic3RyaW5nXCI7XG4gICAgICAgIFwiLW9ubHktdGVzdFwiLCBBcmcuU3RyaW5nIChmdW4gcyAtPlxuICAgICAgICAgIGxldCBmaWxlbmFtZSwgaW5kZXggPVxuICAgICAgICAgICAgbWF0Y2ggcGFyc2VfZGVzY3IgcyB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgKGZpbGUsIGluZGV4KSAtPiBmaWxlLCBpbmRleFxuICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgIGlmIFN0cmluZy5jb250YWlucyBzICc6JyB0aGVuXG4gICAgICAgICAgICAgICAgbGV0IGkgPSBTdHJpbmcuaW5kZXggcyAnOicgaW5cbiAgICAgICAgICAgICAgICBsZXQgZmlsZW5hbWUgPSBTdHJpbmcuc3ViIHMgMCBpIGluXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4X3N0cmluZyA9IFN0cmluZy5zdWIgcyAoaSArIDEpIChTdHJpbmcubGVuZ3RoIHMgLSBpIC0gMSkgaW5cbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPVxuICAgICAgICAgICAgICAgICAgdHJ5IGludF9vZl9zdHJpbmcgaW5kZXhfc3RyaW5nXG4gICAgICAgICAgICAgICAgICB3aXRoIEZhaWx1cmUgXyAtPlxuICAgICAgICAgICAgICAgICAgICBQcmludGYuZXByaW50ZlxuICAgICAgICAgICAgICAgICAgICAgIFwiQXJndW1lbnQgJXMgZG9lc24ndCBmaXQgdGhlIGZvcm1hdCBmaWxlbmFtZVs6bGluZV9udW1iZXJdXFxuJSFcIiBzO1xuICAgICAgICAgICAgICAgICAgICBleGl0IDFcbiAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIGZpbGVuYW1lLCBTb21lIGluZGV4XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzLCBOb25lXG4gICAgICAgICAgaW5cbiAgICAgICAgICB0ZXN0cyA6PSAoZmlsZW5hbWUsIGluZGV4LCByZWYgZmFsc2UpIDo6ICF0ZXN0c1xuICAgICAgICApLCBcImxvY2F0aW9uIFJ1biBvbmx5IHRoZSB0ZXN0cyBzcGVjaWZpZWQgYnkgYWxsIHRoZSAtb25seS10ZXN0IG9wdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgTG9jYXRpb25zIGNhbiBiZSBvbmUgb2YgdGhlc2UgZm9ybXM6XG4gICAgICAgICAgICAgICAgICAgICAgLSBmaWxlLm1sXG4gICAgICAgICAgICAgICAgICAgICAgLSBmaWxlLm1sOmxpbmVfbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgLSBGaWxlIFxcXCJmaWxlLm1sXFxcIlxuICAgICAgICAgICAgICAgICAgICAgIC0gRmlsZSBcXFwiZmlsZS5tbFxcXCIsIGxpbmUgMjNcbiAgICAgICAgICAgICAgICAgICAgICAtIEZpbGUgXFxcImZpbGUubWxcXFwiLCBsaW5lIDIzLCBjaGFyYWN0ZXJzIDItM1wiO1xuICAgICAgICBcIi1uby1jb2xvclwiLCBBcmcuQ2xlYXIgdXNlX2NvbG9yLCBcIiBTdW1tYXJpemUgdGVzdHMgd2l0aG91dCB1c2luZyBjb2xvclwiO1xuICAgICAgICBcIi1pbi1wbGFjZVwiLCBBcmcuU2V0IGluX3BsYWNlLCBcIiBVcGRhdGUgZXhwZWN0IHRlc3RzIGluIHBsYWNlXCI7XG4gICAgICAgIFwiLWRpZmYtY21kXCIsIEFyZy5TdHJpbmcgKGZ1biBzIC0+IGRpZmZfY29tbWFuZCA6PSBTb21lIHMpLFxuICAgICAgICBcIiBEaWZmIGNvbW1hbmQgZm9yIHRlc3RzIHRoYXQgcmVxdWlyZSBkaWZmaW5nICh1c2UgLSB0byBkaXNhYmxlIGRpZmZpbmcpXCI7XG4gICAgICAgIFwiLWFsbG93LW91dHB1dC1wYXR0ZXJuc1wiLCBBcmcuU2V0IGFsbG93X291dHB1dF9wYXR0ZXJucyxcbiAgICAgICAgXCIgQWxsb3cgb3V0cHV0IHBhdHRlcm5zIGluIHRlc3RzIGV4cGVjdGF0aW9uc1wiO1xuICAgICAgICBcIi1zb3VyY2UtdHJlZS1yb290XCIsIEFyZy5TdHJpbmcgKGZ1biBzIC0+IHNvdXJjZV90cmVlX3Jvb3QgOj0gU29tZSBzKSxcbiAgICAgICAgXCIgUGF0aCB0byB0aGUgcm9vdCBvZiB0aGUgc291cmNlIHRyZWVcIlxuICAgICAgXSkgKGZ1biBhbm9uIC0+XG4gICAgICAgIFByaW50Zi5lcHJpbnRmIFwiJXM6IHVuZXhwZWN0ZWQgYW5vbnltb3VzIGFyZ3VtZW50ICVzXFxuJSFcIiBuYW1lIGFub247XG4gICAgICAgIGV4aXQgMVxuICAgICAgKSAoUHJpbnRmLnNwcmludGYgXCIlcyAlcyAlcyBbYXJnc11cIiBuYW1lIFwiaW5saW5lLXRlc3QtcnVubmVyXCIgbGliKTtcbiAgICAgIEFjdGlvbi5zZXQgKFxuICAgICAgICBgVGVzdF9tb2RlXG4gICAgICAgICAgeyB3aGljaF90ZXN0cyA9XG4gICAgICAgICAgICAgIHsgbGlibmFtZSA9IGxpYlxuICAgICAgICAgICAgICA7IG9ubHlfdGVzdF9sb2NhdGlvbiA9ICF0ZXN0cztcbiAgICAgICAgICAgICAgICB3aGljaF90YWdzID0gIXRhZ19wcmVkaWNhdGU7XG4gICAgICAgICAgICAgICAgbmFtZV9maWx0ZXIgPSAhbmFtZV9maWx0ZXJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIDsgd2hhdF90b19kbyA9XG4gICAgICAgICAgICAgIGlmICFsaXN0X3BhcnRpdGlvbnNcbiAgICAgICAgICAgICAgdGhlbiBgTGlzdF9wYXJ0aXRpb25zXG4gICAgICAgICAgICAgIGVsc2UgYFJ1bl9wYXJ0aXRpb24gIXBhcnRpdGlvblxuICAgICAgICAgIH0pXG4gICAgZW5kXG4gIHwgXyAtPlxuICAgICgpXG5cbmxldCBhbV90ZXN0X3J1bm5lciA9XG4gIG1hdGNoIEFjdGlvbi5nZXQgKCkgd2l0aFxuICB8IGBUZXN0X21vZGUgXyAtPiB0cnVlXG4gIHwgYElnbm9yZSAtPiBmYWxzZVxuXG5sZXQgYW1fcnVubmluZ19pbmxpbmVfdGVzdF9lbnZfdmFyID1cbiAgKCogZm9yIGFwcHJveGltYXRlIGNvbXBhdGliaWxpdHksIGdpdmVuIHRoYXQgdGhlIHZhcmlhYmxlIGlzIG5vdCBleGFjdGx5IGVxdWl2YWxlbnRcbiAgICAgdG8gd2hhdCBQUFhfSU5MSU5FX1RFU1RfTElCX0FNX1JVTk5JTkdfSU5MSU5FX1RFU1QgdXNlZCB0byBiZSAqKVxuICBcIlRFU1RJTkdfRlJBTUVXT1JLXCJcblxuKCogVGhpcyB2YWx1ZSBpcyBkZXByZWNhdGVkIGluIHByaW5jaXBsZSwgaW4gZmF2b3Igb2YgQ29yZS5hbV9ydW5uaW5nX3Rlc3QsIHNvXG4gICB3ZSdyZSBnb2luZyB0byBsaXZlIHdpdGggdGhlIHVnbHkgcGF0dGVybiBtYXRjaC4gKilcbmxldCBhbV9ydW5uaW5nX2lubGluZV90ZXN0ID1cbiAgbWF0Y2ggU3lzLmdldGVudiBcIlBQWF9JTkxJTkVfVEVTVF9MSUJfQU1fUlVOTklOR19JTkxJTkVfVEVTVFwiIHdpdGhcbiAgfCAoXyA6IHN0cmluZykgLT4gdHJ1ZSAoKiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHBlb3BsZSBzZXR0aW5nIHRoaXMgdmFyaWFibGUgZGlyZWN0bHkgKilcbiAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+XG4gICAgbWF0Y2ggU3lzLmdldGVudiBhbV9ydW5uaW5nX2lubGluZV90ZXN0X2Vudl92YXIgd2l0aFxuICAgIHwgXCJpbmxpbmUtdGVzdFwiIC0+IHRydWVcbiAgICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT4gZmFsc2VcbiAgICB8IF8gLT4gZmFsc2VcblxubGV0IHRlc3RpbmcgPVxuICBpZiBhbV90ZXN0X3J1bm5lclxuICB0aGVuIGBUZXN0aW5nIGBBbV90ZXN0X3J1bm5lclxuICBlbHNlXG4gICAgKGlmIGFtX3J1bm5pbmdfaW5saW5lX3Rlc3RcbiAgICAgdGhlbiBgVGVzdGluZyBgQW1fY2hpbGRfb2ZfdGVzdF9ydW5uZXJcbiAgICAgZWxzZSBgTm90X3Rlc3RpbmcpXG5cbmxldCB3YWxsX3RpbWVfY2xvY2tfbnMgKCkgPVxuICBUaW1lX25vdy5uYW5vc2Vjb25kc19zaW5jZV91bml4X2Vwb2NoICgpXG5cblxubGV0IHdoZXJlX3RvX2N1dF9iYWNrdHJhY2UgPSBsYXp5IChcbiAgQmFzZS5TdHJpbmcuU2VhcmNoX3BhdHRlcm4uY3JlYXRlIChfX01PRFVMRV9fIF4gXCIuXCIgXiBcInRpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuZG9tX3NlZWRzXCIpKVxuXG5sZXQgdGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHMgZiA9XG4gIGxldCBiZWZvcmVfbnMgPSB3YWxsX3RpbWVfY2xvY2tfbnMgKCkgaW5cbiAgbGV0IHJlcyA9XG4gICAgKCogVG8gYXZvaWQgbm9pc2UgaW4gYmFja3RyYWNlcywgd2UgZG8gdHdvIHRoaW5ncy5cblxuICAgICAgIFdlIHVzZSBbd2hlcmVfdG9fY3V0X2JhY2t0cmFjZV0gYWJvdmUgdG8gcmVtb3ZlIHRoZSBzdGFjayBmcmFtZXMgZm9yIHRoZSBjdXJyZW50XG4gICAgICAgZnVuY3Rpb24gYW5kIGFueSBmdW5jdGlvbiBpdCBnZXRzIGlubGluZWQgaW50bywgYXMgaXQncyBub3Qgb2YgYW55IGludGVyZXN0IHRvIHRoZVxuICAgICAgIHVzZXIsIHNpbmNlIGl0J3Mgbm90IHRhbGtpbmcgYWJvdXQgdGhlaXIgdGVzdCBidXQgaW5zdGVhZCB0YWxraW5nIGFib3V0IHRoZVxuICAgICAgIHBweF9pbmxpbmVfdGVzdCBtYWNoaW5lcnkuXG5cbiAgICAgICBXZSBhbHNvIGF2b2lkIGluc2VydGluZyBhbnkgY29kZSBiZXR3ZWVuIHRoZSBbZl0gdGhhdCBjb21lcyBmcm9tIHRoZSB1c2VyJ3MgZmlsZVxuICAgICAgIGFuZCBncmFiYmluZyB0aGUgYmFja3RyYWNlIGZyb20gaXRzIGV4Y2VwdGlvbnMgKG5vIHdyYXBwaW5nIG9mIFtmXSB3aXRoIGhpZ2ggb3JkZXJcbiAgICAgICBmdW5jdGlvbnMgbGlrZSBFeG4ucHJvdGVjdCwgb3IgKGZ1biAoKSAtPiBmICgpOyB0cnVlKSkuICopXG4gICAgdHJ5IE9rIChmICgpKVxuICAgIHdpdGggZXhuIC0+IEVycm9yIChleG4sIFByaW50ZXhjLmdldF9iYWNrdHJhY2UgKCkpXG4gIGluXG4gIHRpbWVfc2VjIDo9IEJhc2UuSW50NjMuKHdhbGxfdGltZV9jbG9ja19ucyAoKSAtIGJlZm9yZV9ucyB8PiB0b19mbG9hdCkgIC8uIDFlOTtcbiAgcmVzXG5cblxubGV0IHNhdmVkX2NhbWxfcmFuZG9tX3N0YXRlID0gbGF6eSAoU3RkbGliLlJhbmRvbS5TdGF0ZS5tYWtlIFt8IDEwMDsgMjAwOyAzMDAgfF0pXG5sZXQgc2F2ZWRfYmFzZV9yYW5kb21fc3RhdGUgPSBsYXp5IChCYXNlLlJhbmRvbS5TdGF0ZS5tYWtlIFt8IDExMTsgMjIyOyAzMzMgfF0pXG5cbmxldCB0aW1lX2FuZF9yZXNldF9yYW5kb21fc2VlZHMgZiA9XG4gIGxldCBjYW1sX3JhbmRvbV9zdGF0ZSA9IFN0ZGxpYi5SYW5kb20uZ2V0X3N0YXRlICgpIGluXG4gIGxldCBiYXNlX3JhbmRvbV9zdGF0ZSA9IEJhc2UuUmFuZG9tLlN0YXRlLmNvcHkgQmFzZS5SYW5kb20uU3RhdGUuZGVmYXVsdCBpblxuICBTdGRsaWIuUmFuZG9tLnNldF9zdGF0ZSAoTGF6eS5mb3JjZSBzYXZlZF9jYW1sX3JhbmRvbV9zdGF0ZSk7XG4gIEJhc2UuUmFuZG9tLnNldF9zdGF0ZSAoTGF6eS5mb3JjZSBzYXZlZF9iYXNlX3JhbmRvbV9zdGF0ZSk7XG4gIGxldCByZXN1bHQgPSB0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV9zZWVkcyBmIGluXG4gIFN0ZGxpYi5SYW5kb20uc2V0X3N0YXRlIGNhbWxfcmFuZG9tX3N0YXRlO1xuICBCYXNlLlJhbmRvbS5zZXRfc3RhdGUgYmFzZV9yYW5kb21fc3RhdGU7XG4gIHJlc3VsdFxuXG5sZXQgc3RyaW5nX29mX21vZHVsZV9kZXNjciAoKSA9XG4gIFN0cmluZy5jb25jYXQgXCJcIiAoXG4gICAgTGlzdC5tYXAgKGZ1biBzIC0+IFwiICBpbiBURVNcIiBeIFwiVF9NT0RVTEUgYXQgXCIgXiBTdHJpbmcudW5jYXBpdGFsaXplX2FzY2lpIHMgXiBcIlxcblwiKVxuICAgICAgKE1vZHVsZV9jb250ZXh0LmN1cnJlbnRfZGVzY3IgKCkpXG4gIClcblxubGV0IHBvc2l0aW9uX21hdGNoIGRlZl9maWxlbmFtZSBkZWZfbGluZV9udW1iZXIgbCA9XG4gIExpc3QuZXhpc3RzIChmdW4gKGZpbGVuYW1lLCBsaW5lX251bWJlcl9vcHQsIHVzZWQpIC0+XG4gICAgbGV0IHBvc2l0aW9uX3N0YXJ0ID1cbiAgICAgIFN0cmluZy5sZW5ndGggZGVmX2ZpbGVuYW1lIC0gU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSBpblxuICAgIGxldCBmb3VuZCA9XG4gICAgICBwb3NpdGlvbl9zdGFydCA+PSAwICYmXG4gICAgICBsZXQgZW5kX29mX2RlZl9maWxlbmFtZSA9XG4gICAgICAgIFN0cmluZy5zdWIgZGVmX2ZpbGVuYW1lXG4gICAgICAgICAgcG9zaXRpb25fc3RhcnRcbiAgICAgICAgICAoU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSkgaW5cbiAgICAgIGVuZF9vZl9kZWZfZmlsZW5hbWUgPSBmaWxlbmFtZVxuICAgICAgJiYgKHBvc2l0aW9uX3N0YXJ0ID0gMCB8fCBkZWZfZmlsZW5hbWUuW3Bvc2l0aW9uX3N0YXJ0IC0gMV0gPSAnLycpXG4gICAgICAmJiAobWF0Y2ggbGluZV9udW1iZXJfb3B0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgICAgfCBTb21lIGxpbmVfbnVtYmVyIC0+IGRlZl9saW5lX251bWJlciA9IGxpbmVfbnVtYmVyKVxuICAgIGluXG4gICAgaWYgZm91bmQgdGhlbiB1c2VkIDo9IHRydWU7XG4gICAgZm91bmRcbiAgKSBsXG5cbmxldCBuYW1lX2ZpbHRlcl9tYXRjaCB+bmFtZV9maWx0ZXIgZGVzY3IgPVxuICBtYXRjaCBuYW1lX2ZpbHRlciB3aXRoXG4gIHwgW10gLT4gdHJ1ZVxuICB8IF8gOjogXyAtPlxuICAgIExpc3QuZXhpc3RzIChmdW4gc3Vic3RyaW5nIC0+IEJhc2UuU3RyaW5nLmlzX3N1YnN0cmluZyB+c3Vic3RyaW5nIGRlc2NyKSBuYW1lX2ZpbHRlclxuXG5sZXQgcHJpbnRfZGVsYXllZF9lcnJvcnMgKCkgPVxuICBtYXRjaCBMaXN0LnJldiAhZGVsYXllZF9lcnJvcnMgd2l0aFxuICB8IFtdIC0+ICgpXG4gIHwgXyA6OiBfIGFzIGRlbGF5ZWRfZXJyb3JzIC0+XG4gICAgUHJpbnRmLmVwcmludGYgXCJcXG4lc1xcbiUhXCIgKFN0cmluZy5tYWtlIDcwICc9Jyk7XG4gICAgTGlzdC5pdGVyIChmdW4gbWVzc2FnZSAtPlxuICAgICAgUHJpbnRmLmVwcmludGYgXCIlcyUhXCIgbWVzc2FnZVxuICAgICkgZGVsYXllZF9lcnJvcnNcblxubGV0IGVwcmludGZfb3JfZGVsYXkgZm10ID1cbiAgUHJpbnRmLmtzcHJpbnRmIChmdW4gcyAtPlxuICAgIGlmICF2ZXJib3NlIHRoZW4gZGVsYXllZF9lcnJvcnMgOj0gcyA6OiAhZGVsYXllZF9lcnJvcnNcbiAgICBlbHNlIFByaW50Zi5lcHJpbnRmIFwiJXMlIVwiIHM7XG4gICAgaWYgIXN0b3Bfb25fZXJyb3IgdGhlbiBiZWdpblxuICAgICAgcHJpbnRfZGVsYXllZF9lcnJvcnMgKCk7XG4gICAgICBleGl0IDJcbiAgICBlbmRcbiAgKSBmbXRcblxubGV0IGFkZF9ob29rcyAoKG1vZHVsZSBDKSA6IGNvbmZpZykgZiA9XG4gIGZ1biAoKSAtPiBDLnByZV90ZXN0X2hvb2sgKCk7IGYgKClcblxubGV0IGh1bV9iYWNrdHJhY2UgYmFja3RyYWNlID1cbiAgbGV0IG9wZW4gQmFzZSBpblxuICBiYWNrdHJhY2VcbiAgfD4gU3RyaW5nLnNwbGl0X2xpbmVzXG4gIHw+IExpc3QudGFrZV93aGlsZSB+ZjooZnVuIHN0ciAtPlxuICAgIG5vdCAoU3RyaW5nLlNlYXJjaF9wYXR0ZXJuLm1hdGNoZXMgKGZvcmNlIHdoZXJlX3RvX2N1dF9iYWNrdHJhY2UpIHN0cikpXG4gIHw+IExpc3QubWFwIH5mOihmdW4gc3RyIC0+IFwiICBcIiBeIHN0ciBeIFwiXFxuXCIpXG4gIHw+IFN0cmluZy5jb25jYXRcblxubGV0W0BpbmxpbmUgbmV2ZXJdIHRlc3RfaW5uZXIgfmNvbmZpZyB+ZGVzY3IgfnRhZ3MgfmZpbGVuYW1lOmRlZl9maWxlbmFtZSB+bGluZV9udW1iZXI6ZGVmX2xpbmVfbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICB+c3RhcnRfcG9zIH5lbmRfcG9zIGYgYm9vbF9vZl9mID1cbiAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gIHwgYElnbm9yZSAtPiAoKVxuICB8IGBUZXN0X21vZGUgeyB3aGljaF90ZXN0cyA9IHsgbGlibmFtZTsgb25seV90ZXN0X2xvY2F0aW9uOyB3aGljaF90YWdzOyBuYW1lX2ZpbHRlciB9OyB3aGF0X3RvX2RvIH0gLT5cbiAgICBsZXQgZiA9IGFkZF9ob29rcyBjb25maWcgZiBpblxuICAgIGxldCBkZXNjciA9IGxhenkgKGRpc3BsYXllZF9kZXNjciBkZXNjciBkZWZfZmlsZW5hbWUgZGVmX2xpbmVfbnVtYmVyIHN0YXJ0X3BvcyBlbmRfcG9zKSBpblxuICAgIGxldCBjb21wbGV0ZV90YWdzID0gdGFncyBAIE1vZHVsZV9jb250ZXh0LmN1cnJlbnRfdGFncyAoKSBpblxuICAgIGxldCBzaG91bGRfcnVuID1cbiAgICAgIFNvbWUgbGlibmFtZSA9ICFkeW5hbWljX2xpYlxuICAgICAgJiYgYmVnaW4gbWF0Y2ggb25seV90ZXN0X2xvY2F0aW9uIHdpdGhcbiAgICAgICAgfCBbXSAtPiB0cnVlXG4gICAgICAgIHwgXyA6OiBfIC0+IHBvc2l0aW9uX21hdGNoIGRlZl9maWxlbmFtZSBkZWZfbGluZV9udW1iZXIgb25seV90ZXN0X2xvY2F0aW9uXG4gICAgICBlbmRcbiAgICAgICYmIG5vdCAoVGFnX3ByZWRpY2F0ZS5kaXNhYmxlZCB3aGljaF90YWdzIH5jb21wbGV0ZV90YWdzKVxuICAgICAgJiYgbmFtZV9maWx0ZXJfbWF0Y2ggfm5hbWVfZmlsdGVyIChMYXp5LmZvcmNlIGRlc2NyKVxuICAgIGluXG4gICAgaWYgc2hvdWxkX3J1biB0aGVuIGJlZ2luXG4gICAgICBtYXRjaCB3aGF0X3RvX2RvIHdpdGhcbiAgICAgIHwgYExpc3RfcGFydGl0aW9ucyAtPiBQYXJ0aXRpb24uZm91bmRfdGVzdCAoKVxuICAgICAgfCBgUnVuX3BhcnRpdGlvbiBwYXJ0aXRpb24gLT5cbiAgICAgICAgaWYgUGFydGl0aW9uLmlzX2N1cnJlbnQgcGFydGl0aW9uIHRoZW4gYmVnaW5cbiAgICAgICAgICBsZXQgZGVzY3IgPSBMYXp5LmZvcmNlIGRlc2NyIGluXG4gICAgICAgICAgaW5jciB0ZXN0c19yYW47XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggIWxvZyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIGNoIC0+IFByaW50Zi5mcHJpbnRmIGNoIFwiJXNcXG4lc1wiIGRlc2NyIChzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpKVxuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBpZiAhdmVyYm9zZSB0aGVuIGJlZ2luXG4gICAgICAgICAgICBQcmludGYucHJpbnRmIFwiJXMlIVwiIGRlc2NyXG4gICAgICAgICAgZW5kO1xuICAgICAgICAgIGxldCByZXN1bHQgPVxuICAgICAgICAgICAgaWYgIWxpc3RfdGVzdF9uYW1lc1xuICAgICAgICAgICAgdGhlbiBPayB0cnVlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICgqIFNlZSBbdGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHNdIGZvciB3aHkgd2UgdXNlIFtib29sX29mX2ZdXG4gICAgICAgICAgICAgICAgIHJhdGhlciBoYXZlIHRoZSBjYWxsZXIgd3JhcCBbZl0gdG8gYWRqdXN0IGl0cyByZXR1cm4gdmFsdWUuICopXG4gICAgICAgICAgICAgIFJlc3VsdC5tYXAgYm9vbF9vZl9mICh0aW1lX2FuZF9yZXNldF9yYW5kb21fc2VlZHMgZilcbiAgICAgICAgICBpblxuICAgICAgICAgICgqIElmICFsaXN0X3Rlc3RfbmFtZXMsIHRoaXMgaXMgaXMgYSBoYXJtbGVzcyB6ZXJvLiAqKVxuICAgICAgICAgIGlmICF2ZXJib3NlIHRoZW4gUHJpbnRmLnByaW50ZiBcIiAoJS4zZiBzZWMpXFxuJSFcIiAhdGltZV9zZWM7XG4gICAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgICB8IE9rIHRydWUgLT4gKClcbiAgICAgICAgICB8IE9rIGZhbHNlIC0+XG4gICAgICAgICAgICBpbmNyIHRlc3RzX2ZhaWxlZDtcbiAgICAgICAgICAgIGVwcmludGZfb3JfZGVsYXkgXCIlcyBpcyBmYWxzZS5cXG4lc1xcbiUhXCIgZGVzY3JcbiAgICAgICAgICAgICAgKHN0cmluZ19vZl9tb2R1bGVfZGVzY3IgKCkpXG4gICAgICAgICAgfCBFcnJvciAoZXhuLCBiYWNrdHJhY2UpIC0+XG4gICAgICAgICAgICBpbmNyIHRlc3RzX2ZhaWxlZDtcbiAgICAgICAgICAgIGxldCBiYWNrdHJhY2UgPSBodW1fYmFja3RyYWNlIGJhY2t0cmFjZSBpblxuICAgICAgICAgICAgbGV0IGV4bl9zdHIgPSBTZXhwbGliMC5TZXhwX2NvbnYucHJpbnRleGNfcHJlZmVyX3NleHAgZXhuIGluXG4gICAgICAgICAgICBsZXQgc2VwID0gaWYgU3RyaW5nLmNvbnRhaW5zIGV4bl9zdHIgJ1xcbicgdGhlbiBcIlxcblwiIGVsc2UgXCIgXCIgaW5cbiAgICAgICAgICAgIGVwcmludGZfb3JfZGVsYXkgXCIlcyB0aHJldyVzJXMuXFxuJXMlc1xcbiUhXCIgZGVzY3Igc2VwIGV4bl9zdHJcbiAgICAgICAgICAgICAgYmFja3RyYWNlIChzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpKVxuICAgICAgICBlbmRcbiAgICBlbmRcblxubGV0IHNldF9saWJfYW5kX3BhcnRpdGlvbiBzdGF0aWNfbGliIHBhcnRpdGlvbiA9XG4gIG1hdGNoICFkeW5hbWljX2xpYiB3aXRoXG4gIHwgU29tZSBfIC0+XG4gICAgKCogcG9zc2libGUgaWYgdGhlIGludGVyZmFjZSBpcyB1c2VkIGV4cGxpY2l0bHkgb3IgaWYgd2UgaGFwcGVuIHRvIGR5bmxpbmsgc29tZXRoaW5nXG4gICAgICAgdGhhdCBjb250YWluIHRlc3RzICopXG4gICAgKClcbiAgfCBOb25lIC0+XG4gICAgZHluYW1pY19saWIgOj0gU29tZSBzdGF0aWNfbGliO1xuICAgIG1hdGNoIEFjdGlvbi5nZXQgKCkgd2l0aFxuICAgIHwgYElnbm9yZSAtPiAoKVxuICAgIHwgYFRlc3RfbW9kZSB7IHdoaWNoX3Rlc3RzOyB3aGF0X3RvX2RvIH0gLT5cbiAgICAgIGlmIHdoaWNoX3Rlc3RzLmxpYm5hbWUgPSBzdGF0aWNfbGliIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IHJlcXVpcmVzX3BhcnRpdGlvbiA9XG4gICAgICAgICAgbWF0Y2ggd2hhdF90b19kbyB3aXRoXG4gICAgICAgICAgfCBgTGlzdF9wYXJ0aXRpb25zIHwgYFJ1bl9wYXJ0aXRpb24gKFNvbWUgXykgLT4gdHJ1ZVxuICAgICAgICAgIHwgYFJ1bl9wYXJ0aXRpb24gTm9uZSAtPiBmYWxzZVxuICAgICAgICBpblxuICAgICAgICBpZiBwYXJ0aXRpb24gPSBcIlwiICYmIHJlcXVpcmVzX3BhcnRpdGlvblxuICAgICAgICB0aGVuIGZhaWx3aXRoIFwicHB4X2lubGluZV90ZXN0OiBjYW5ub3QgdXNlIC1saXN0LXBhcnRpdGlvbiBvciAtcGFydGl0aW9uIFxcXG4gICAgICAgICAgICAgICAgICAgICAgIHdpdGhvdXQgc3BlY2lmeWluZyBhIHBhcnRpdGlvbiBhdCBwcmVwcm9jZXNzaW5nIHRpbWVcIlxuICAgICAgICBlbHNlIFBhcnRpdGlvbi5zZXRfY3VycmVudCBwYXJ0aXRpb25cbiAgICAgIGVuZFxuXG5sZXQgdW5zZXRfbGliIHN0YXRpY19saWIgPVxuICBtYXRjaCAhZHluYW1pY19saWIgd2l0aFxuICB8IE5vbmUgLT5cbiAgICAoKiBub3QgZ2l2aW5nIGFuIGVycm9yLCBiZWNhdXNlIHdoZW4gc29tZSBhbm5veWluZyBwZW9wbGUgcHV0IHBhX291bml0IGluIHRoZWlyIGxpc3RcbiAgICAgICBvZiBwcmVwcm9jZXNzb3JzLCBwYV9vdW5pdCBpcyBzZXQgdXAgdHdpY2UgYW5kIHdlIGhhdmUgdHdvIGNhbGxzIHRvIHVuc2V0X2xpYiBhdFxuICAgICAgIHRoZSBlbmQgb2YgdGhlIGZpbGUsIGFuZCB0aGUgc2Vjb25kIG9uZSBjb21lcyBpbiB0aGlzIGJyYW5jaCAqKVxuICAgICgpXG4gIHwgU29tZSBsaWIgLT5cbiAgICBpZiBsaWIgPSBzdGF0aWNfbGliIHRoZW4gZHluYW1pY19saWIgOj0gTm9uZVxuXG5sZXQgdGVzdCB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWUgfmxpbmVfbnVtYmVyIH5zdGFydF9wb3MgfmVuZF9wb3MgZiA9XG4gIHRlc3RfaW5uZXIgfmNvbmZpZyB+ZGVzY3IgfnRhZ3MgfmZpbGVuYW1lIH5saW5lX251bWJlciB+c3RhcnRfcG9zIH5lbmRfcG9zXG4gICAgZiAoZnVuIGIgLT4gYilcblxubGV0IHRlc3RfdW5pdCB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWUgfmxpbmVfbnVtYmVyIH5zdGFydF9wb3MgfmVuZF9wb3MgZiA9XG4gIHRlc3RfaW5uZXIgfmNvbmZpZyB+ZGVzY3IgfnRhZ3MgfmZpbGVuYW1lIH5saW5lX251bWJlciB+c3RhcnRfcG9zIH5lbmRfcG9zXG4gICAgZiAoZnVuICgpIC0+IHRydWUpXG5cbmxldFtAaW5saW5lIG5ldmVyXSB0ZXN0X21vZHVsZSB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWU6ZGVmX2ZpbGVuYW1lIH5saW5lX251bWJlcjpkZWZfbGluZV9udW1iZXJcbiAgICAgICAgICAgICAgICAgICAgIH5zdGFydF9wb3MgfmVuZF9wb3MgZiA9XG4gIG1hdGNoIEFjdGlvbi5nZXQgKCkgd2l0aFxuICB8IGBJZ25vcmUgLT4gKClcbiAgfCBgVGVzdF9tb2RlIHsgd2hpY2hfdGVzdHMgPSB7IGxpYm5hbWU7IG9ubHlfdGVzdF9sb2NhdGlvbiA9IF87IG5hbWVfZmlsdGVyID0gXzsgd2hpY2hfdGFncyB9OyB3aGF0X3RvX2RvIH0gLT5cbiAgICBsZXQgZiA9IGFkZF9ob29rcyBjb25maWcgZiBpblxuICAgIGxldCBkZXNjciAoKSA9IGRpc3BsYXllZF9kZXNjciBkZXNjciBkZWZfZmlsZW5hbWUgZGVmX2xpbmVfbnVtYmVyIHN0YXJ0X3BvcyBlbmRfcG9zIGluXG4gICAgbGV0IHBhcnRpYWxfdGFncyA9IHRhZ3MgQCBNb2R1bGVfY29udGV4dC5jdXJyZW50X3RhZ3MgKCkgaW5cbiAgICBsZXQgc2hvdWxkX3J1biA9XG4gICAgICBTb21lIGxpYm5hbWUgPSAhZHluYW1pY19saWJcbiAgICAgICgqIElmLCBubyBtYXR0ZXIgd2hhdCB0YWdzIGEgdGVzdCBkZWZpbmVzLCB3ZSBjZXJ0YWlubHkgd2lsbCBkcm9wIGFsbCB0ZXN0cyB3aXRoaW5cbiAgICAgICAgIHRoaXMgbW9kdWxlLCB0aGVuIGRvbid0IHJ1biB0aGUgbW9kdWxlIGF0IGFsbC4gVGhpcyBtZWFucyBwZW9wbGUgY2FuIHdyaXRlXG4gICAgICAgICB0aGluZ3MgbGlrZSB0aGUgZm9sbG93aW5nIHdpdGhvdXQgYnJlYWtpbmcgdGhlIDMyLWJpdCBidWlsZDpcbiAgICAgICAgIGxldCV0ZXN0X21vZHVsZSBbQHRhZ3MgXCI2NC1iaXRzLW9ubHlcIl0gPSAobW9kdWxlIHN0cnVjdFxuICAgICAgICAgbGV0IGkgPSBJbnQ2NC50b19pbnRfZXhuIC4uLi5cbiAgICAgICAgIGVuZClcbiAgICAgICAgIFdlIGRvbid0IHNob3J0Y3V0IGJhc2VkIG9uIHBvc2l0aW9uLCBhcyB3ZSBjYW4ndCB0ZWxsIHdoYXQgcG9zaXRpb25zIHRoZVxuICAgICAgICAgaW5uZXIgdGVzdHMgd2lsbCBoYXZlLiAqKVxuICAgICAgJiYgbm90IChUYWdfcHJlZGljYXRlLmVudGlyZV9tb2R1bGVfZGlzYWJsZWQgd2hpY2hfdGFncyB+cGFydGlhbF90YWdzKVxuICAgIGluXG4gICAgaWYgc2hvdWxkX3J1biB0aGVuIGJlZ2luXG4gICAgICBtYXRjaCB3aGF0X3RvX2RvIHdpdGhcbiAgICAgIHwgYExpc3RfcGFydGl0aW9ucyAtPiBQYXJ0aXRpb24uZm91bmRfdGVzdCAoKVxuICAgICAgfCBgUnVuX3BhcnRpdGlvbiBwYXJ0aXRpb24gLT5cbiAgICAgICAgaWYgUGFydGl0aW9uLmlzX2N1cnJlbnQgcGFydGl0aW9uIHRoZW4gYmVnaW5cbiAgICAgICAgICBpbmNyIHRlc3RfbW9kdWxlc19yYW47XG4gICAgICAgICAgbGV0IGRlc2NyID0gZGVzY3IgKCkgaW5cbiAgICAgICAgICBtYXRjaFxuICAgICAgICAgICAgTW9kdWxlX2NvbnRleHQud2l0aF8gfmRlc2NyIH50YWdzIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgKCogV2UgZG8gbm90IHJlc2V0IHJhbmRvbSBzdGF0ZXMgdXBvbiBlbnRlcmluZyBbbGV0JXRlc3RfbW9kdWxlXS5cblxuICAgICAgICAgICAgICAgICBDb246IENvZGUgaW4gdGVzdCBtb2R1bGVzIGNhbiBhY2NpZGVudGFsbHkgZGVwZW5kIG9uIHRvcC1sZXZlbCByYW5kb21cbiAgICAgICAgICAgICAgICAgc3RhdGUgZWZmZWN0cy5cblxuICAgICAgICAgICAgICAgICBQcm9zOiAoMSkgV2UgZG9uJ3QgcmVzZXQgdG8gdGhlIHNhbWUgc2VlZCBvbiBlbnRlcmluZyBhIFtsZXQldGVzdF9tb2R1bGVdXG4gICAgICAgICAgICAgICAgIGFuZCB0aGVuIGEgW2xldCV0ZXN0XSBpbnNpZGUgdGhhdCBtb2R1bGUsIHdoaWNoIGNvdWxkIGxlYWQgdG9cbiAgICAgICAgICAgICAgICAgYWNjaWRlbnRhbGx5IHJhbmRvbWx5IGdlbmVyYXRpbmcgdGhlIHNhbWUgdmFsdWVzIGluIHNvbWUgdGVzdC4gKDIpIE1vdmluZ1xuICAgICAgICAgICAgICAgICBjb2RlIGludG8gYW5kIG91dCBvZiBbbGV0JXRlc3RfbW9kdWxlXSBkb2VzIG5vdCBjaGFuZ2UgaXRzIHJhbmRvbSBzZWVkLlxuICAgICAgICAgICAgICAqKVxuICAgICAgICAgICAgICB0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV9zZWVkcyBmKVxuICAgICAgICAgIHdpdGhcbiAgICAgICAgICB8IE9rICgpIC0+ICgpXG4gICAgICAgICAgfCBFcnJvciAoZXhuLCBiYWNrdHJhY2UpIC0+XG4gICAgICAgICAgICBpbmNyIHRlc3RfbW9kdWxlc19mYWlsZWQ7XG4gICAgICAgICAgICBsZXQgYmFja3RyYWNlID0gaHVtX2JhY2t0cmFjZSBiYWNrdHJhY2UgaW5cbiAgICAgICAgICAgIGxldCBleG5fc3RyID0gU2V4cGxpYjAuU2V4cF9jb252LnByaW50ZXhjX3ByZWZlcl9zZXhwIGV4biBpblxuICAgICAgICAgICAgbGV0IHNlcCA9IGlmIFN0cmluZy5jb250YWlucyBleG5fc3RyICdcXG4nIHRoZW4gXCJcXG5cIiBlbHNlIFwiIFwiIGluXG4gICAgICAgICAgICBlcHJpbnRmX29yX2RlbGF5IChcIlRFU1wiIF5eIFwiVF9NT0RVTEUgYXQgJXMgdGhyZXclcyVzLlxcbiVzJXNcXG4lIVwiKVxuICAgICAgICAgICAgICAoU3RyaW5nLnVuY2FwaXRhbGl6ZV9hc2NpaSBkZXNjcikgc2VwIGV4bl9zdHIgYmFja3RyYWNlIChzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpKVxuICAgICAgICBlbmRcbiAgICBlbmRcblxubGV0IHN1bW1hcml6ZSAoKSA9XG4gIG1hdGNoIEFjdGlvbi5nZXQgKCkgd2l0aFxuICB8IGBJZ25vcmUgLT5cbiAgICBpZiBTeXMuYXJndiA8PiBbfHxdICYmIEZpbGVuYW1lLmJhc2VuYW1lIFN5cy5hcmd2LigwKSA9IFwiaW5saW5lX3Rlc3RzX3J1bm5lci5leGVcIiB0aGVuXG4gICAgICBQcmludGYuZXByaW50ZiBcImlubGluZV90ZXN0c19ydW5uZXIuZXhlIGlzIG5vdCBzdXBwb3NlZCB0byBiZSBydW4gYnkgaGFuZCwgeW91IFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIHJ1biB0aGUgaW5saW5lX3Rlc3RzX3J1bm5lciBzY3JpcHQgaW5zdGVhZC5cXG4lIVwiXG4gICAgZWxzZVxuICAgICAgUHJpbnRmLmVwcmludGYgXCJZb3UgYXJlIGRvaW5nIHNvbWV0aGluZyB1bmV4cGVjdGVkIHdpdGggdGhlIHRlc3RzLiBObyB0ZXN0cyBoYXZlIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgYmVlbiBydW4uIFlvdSBzaG91bGQgdXNlIHRoZSBpbmxpbmVfdGVzdHNfcnVubmVyIHNjcmlwdCB0byBydW4gXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0cy5cXG4lIVwiO1xuICAgIFRlc3RfcmVzdWx0LkVycm9yXG4gIHwgYFRlc3RfbW9kZSB7IHdoaWNoX3Rlc3RzID0gXzsgd2hhdF90b19kbyA9IGBMaXN0X3BhcnRpdGlvbnMgfSAtPlxuICAgIExpc3QuaXRlciAoUHJpbnRmLnByaW50ZiBcIiVzXFxuXCIpIChQYXJ0aXRpb24uYWxsICgpKTtcbiAgICBUZXN0X3Jlc3VsdC5TdWNjZXNzXG4gIHwgYFRlc3RfbW9kZSB7IHdoYXRfdG9fZG8gPSBgUnVuX3BhcnRpdGlvbiBfOyB3aGljaF90ZXN0cyB9IC0+IGJlZ2luXG4gICAgICBiZWdpbiBtYXRjaCAhbG9nIHdpdGhcbiAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgfCBTb21lIGNoIC0+IGNsb3NlX291dCBjaFxuICAgICAgZW5kO1xuICAgICAgcHJpbnRfZGVsYXllZF9lcnJvcnMgKCk7XG4gICAgICBtYXRjaCAhdGVzdHNfZmFpbGVkLCAhdGVzdF9tb2R1bGVzX2ZhaWxlZCB3aXRoXG4gICAgICB8IDAsIDAgLT4gYmVnaW5cbiAgICAgICAgICBpZiAhc2hvd19jb3VudHMgdGhlbiBiZWdpblxuICAgICAgICAgICAgUHJpbnRmLmVwcmludGYgXCIlZCB0ZXN0cyByYW4sICVkIHRlc3RfbW9kdWxlcyByYW5cXG4lIVwiICF0ZXN0c19yYW4gIXRlc3RfbW9kdWxlc19yYW5cbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgbGV0IGVycm9ycyA9XG4gICAgICAgICAgICBsZXQgdW51c2VkX3Rlc3RzID1cbiAgICAgICAgICAgICAgTGlzdC5maWx0ZXIgKGZ1biAoXywgXywgdXNlZCkgLT4gbm90ICF1c2VkKSB3aGljaF90ZXN0cy5vbmx5X3Rlc3RfbG9jYXRpb25cbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBtYXRjaCB1bnVzZWRfdGVzdHMgd2l0aFxuICAgICAgICAgICAgfCBbXSAtPiBOb25lXG4gICAgICAgICAgICB8IF8gOjogXyAtPiBTb21lIHVudXNlZF90ZXN0c1xuICAgICAgICAgIGluXG4gICAgICAgICAgbWF0Y2ggZXJyb3JzIHdpdGhcbiAgICAgICAgICB8IFNvbWUgdGVzdHMgLT5cbiAgICAgICAgICAgIFByaW50Zi5lcHJpbnRmIFwicHB4X2lubGluZV90ZXN0IGVycm9yOiB0aGUgZm9sbG93aW5nIC1vbmx5LXRlc3QgZmxhZ3MgbWF0Y2hlZCBub3RoaW5nOlwiO1xuICAgICAgICAgICAgTGlzdC5pdGVyIChmdW4gKGZpbGVuYW1lLCBsaW5lX251bWJlcl9vcHQsIF8pIC0+XG4gICAgICAgICAgICAgIG1hdGNoIGxpbmVfbnVtYmVyX29wdCB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBQcmludGYuZXByaW50ZiBcIiAlc1wiIGZpbGVuYW1lXG4gICAgICAgICAgICAgIHwgU29tZSBsaW5lX251bWJlciAtPiBQcmludGYuZXByaW50ZiBcIiAlczolZFwiIGZpbGVuYW1lIGxpbmVfbnVtYmVyXG4gICAgICAgICAgICApIHRlc3RzO1xuICAgICAgICAgICAgUHJpbnRmLmVwcmludGYgXCIuXFxuJSFcIjtcbiAgICAgICAgICAgIFRlc3RfcmVzdWx0LkVycm9yXG4gICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICBpZiAhdGVzdHNfcmFuID0gMCAmJiAhc3RyaWN0IHRoZW4gYmVnaW5cbiAgICAgICAgICAgICAgUHJpbnRmLmVwcmludGYgXCJwcHhfaW5saW5lX3Rlc3QgZXJyb3I6IG5vIHRlc3RzIGhhdmUgYmVlbiBydW4uXFxuJSFcIjtcbiAgICAgICAgICAgICAgVGVzdF9yZXN1bHQuRXJyb3JcbiAgICAgICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIFRlc3RfcmVzdWx0LlN1Y2Nlc3NcbiAgICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIHwgY291bnQsIGNvdW50X3Rlc3RfbW9kdWxlcyAtPlxuICAgICAgICBQcmludGYuZXByaW50ZiBcIkZBSUxFRCAlZCAvICVkIHRlc3RzJXNcXG4lIVwiIGNvdW50ICF0ZXN0c19yYW5cbiAgICAgICAgICAoaWYgY291bnRfdGVzdF9tb2R1bGVzID0gMCB0aGVuIFwiXCIgZWxzZSBQcmludGYuc3ByaW50ZiAoXCIsICVkIFRFU1wiIF5eIFwiVF9NT0RVTEVTXCIpIGNvdW50X3Rlc3RfbW9kdWxlcyk7XG4gICAgICAgIFRlc3RfcmVzdWx0LkZhaWx1cmVcbiAgICBlbmRcblxubGV0IHVzZV9jb2xvciA9ICF1c2VfY29sb3JcbmxldCBpbl9wbGFjZSAgPSAhaW5fcGxhY2VcbmxldCBkaWZmX2NvbW1hbmQgPSAhZGlmZl9jb21tYW5kXG5sZXQgc291cmNlX3RyZWVfcm9vdCA9ICFzb3VyY2VfdHJlZV9yb290XG5sZXQgYWxsb3dfb3V0cHV0X3BhdHRlcm5zID0gIWFsbG93X291dHB1dF9wYXR0ZXJuc1xuXG5sZXQgZXZhbHVhdG9ycyA9IHJlZiBbc3VtbWFyaXplXVxubGV0IGFkZF9ldmFsdWF0b3IgfmYgPSBldmFsdWF0b3JzIDo9IGYgOjogIWV2YWx1YXRvcnNcbmxldCBleGl0ICgpID1cbiAgTGlzdC5tYXAgKGZ1biBmIC0+IGYgKCkpIChMaXN0LnJldiAhZXZhbHVhdG9ycylcbiAgfD4gVGVzdF9yZXN1bHQuY29tYmluZV9hbGxcbiAgfD4gVGVzdF9yZXN1bHQudG9fZXhpdF9jb2RlXG4gIHw+IGV4aXRcbiJdfQ==
