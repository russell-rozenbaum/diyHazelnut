// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1+5.8.1

//# unitInfo: Provides: Persistent_connection_kernel__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Persistent_connection_kernel = [0];
   runtime.caml_register_global
    (0, Persistent_connection_kernel, "Persistent_connection_kernel__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Persistent_connection_kernel__Persistent_connection_kernel_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Persistent_connection_kern =
      "Persistent_connection_kernel__Persistent_connection_kernel_intf",
    cst_persistent_connection_kern = "persistent_connection_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Persistent_connection_kern);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_persistent_connection_kern);
   caml_call1
    (Expect_test_collector[5][1],
     "persistent_connection_kernel/src/persistent_connection_kernel_intf.ml");
   caml_call2
    (Ppx_inline_test_lib_Runtime[2], cst_persistent_connection_kern, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_persistent_connection_kern);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Persistent_connection_kern);
   var Persistent_connection_kernel_P = [0];
   runtime.caml_register_global
    (11, Persistent_connection_kernel_P, cst_Persistent_connection_kern);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Persistent_connection_kernel
//# unitInfo: Requires: Async_kernel, Async_kernel__Deferred, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Time_source, Base__Exn, Base__Field, Base__Random, Core, Core__Error, Core__Fn, Core__Option, Core__Or_error, Core__Sexp, Core__Time_ns, Expect_test_collector, Persistent_connection_kernel__Persistent_connection_kernel_intf, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Persistent_connection_kern = "Persistent_connection_kernel",
    cst_persistent_connection_kern = "persistent_connection_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    _a_ = [0, "<Conn.t>"],
    cst = "",
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel = global_data.Async_kernel,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_kernel_Time_source = global_data.Async_kernel__Time_source,
    Core_Time_ns = global_data.Core__Time_ns,
    Base_Random = global_data.Base__Random,
    Core = global_data.Core,
    Core_Fn = global_data.Core__Fn,
    Core_Option = global_data.Core__Option,
    Core_Error = global_data.Core__Error,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Base_Exn = global_data.Base__Exn,
    Core_Sexp = global_data.Core__Sexp,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Or_error = global_data.Core__Or_error;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Persistent_connection_kern);
   caml_call1
    (Ppx_bench_lib_Benchmark_accumu[1][1], cst_persistent_connection_kern);
   caml_call1
    (Expect_test_collector[5][1],
     "persistent_connection_kernel/src/persistent_connection_kernel.ml");
   caml_call2
    (Ppx_inline_test_lib_Runtime[2], cst_persistent_connection_kern, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_persistent_connection_kern);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Persistent_connection_kern);
   var
    _b_ = [0, "Attempting_to_connect"],
    _c_ = [0, "Disconnected"],
    _d_ = [0, "Obtained_address"],
    _e_ = [0, "Failed_to_connect"],
    _f_ = [0, "Connected"],
    _g_ = [0, "on_event"],
    _h_ = [0, "server_name"],
    _i_ = [0, "sexp_of_address"],
    _j_ = [0, "address_equal"],
    _k_ = [0, "don't_reconnect"],
    _l_ = [0, "close_finished"],
    _m_ = [0, "close_started"],
    _n_ = [0, "event_handler"],
    _o_ = [0, "next_connect_result"],
    _p_ = [0, "Close_started"],
    _q_ = [0, "Ok"],
    _r_ = [0, "conn"],
    _s_ = [0, "retry_delay"],
    _t_ = [0, "connect"],
    _u_ = [0, "get_address"],
    _v_ = [0, -289386606, 0],
    _w_ = [0, -289386606, 0],
    _x_ = [0, -289386606, 0],
    _y_ = [0, -289386606, 0],
    _z_ = [0, 990972795, 0],
    cst_Persistent_connection_clos = "Persistent connection closed",
    Persistent_connection_kernel =
      [0,
       function(Conn){
        var close = Conn[1], is_closed = Conn[2], close_finished = Conn[3];
        function sexp_of_t(param){return _a_;}
        function sexp_of_t$0(of_address_001, param){
         if(typeof param === "number") return 0 === param ? _b_ : _c_;
         switch(param[0]){
           case 0:
            var
             arg0_002 = param[1],
             res0_003 = caml_call1(of_address_001, arg0_002);
            return [1, [0, _d_, [0, res0_003, 0]]];
           case 1:
            var
             arg0_004 = param[1],
             res0_005 = caml_call1(Core_Error[6], arg0_004);
            return [1, [0, _e_, [0, res0_005, 0]]];
           default:
            var
             arg0_006 = param[1],
             res0_007 = caml_call1(Sexplib0_Sexp_conv[23], arg0_006);
            return [1, [0, _f_, [0, res0_007, 0]]];
         }
        }
        function log_level(param){
         if(typeof param !== "number" && 1 === param[0]) return 106380200;
         return 815031438;
        }
        function handle_event(t, event){
         var on_event = t[6][2];
         return caml_call1(on_event, event);
        }
        function abort_reconnecting_with_no_act(t){
         caml_call2(Async_kernel_Ivar[14], t[7], 0);
         caml_call2(Async_kernel_Ivar[14], t[8], 0);
         return caml_call2(Async_kernel_Ivar[14], t[4], -400989606);
        }
        function current_connection(t){
         var
          _au_ = caml_call1(Async_kernel_Ivar[18], t[4]),
          match = caml_call1(Async_kernel_Deferred[5], _au_);
         if(match){
          var match$0 = match[1];
          if(typeof match$0 !== "number"){
           var conn = match$0[2];
           return [0, conn];
          }
         }
         return 0;
        }
        function close_finished$0(t){
         return caml_call1(Async_kernel_Ivar[18], t[8]);
        }
        function is_closed$0(t){
         return caml_call1(Async_kernel_Ivar[17], t[7]);
        }
        var
         _A_ =
           caml_call1(Sexplib0_Sexp_conv[7], cst_Persistent_connection_clos),
         connected_or_failed_to_connect = caml_call1(Core_Or_error[40], _A_);
        function sexp_of_t$1(param){
         var
          conn_023 = param[4],
          next_connect_result_026 = param[5],
          don_t_reconnect_034 = param[9],
          close_finished_032 = param[8],
          close_started_030 = param[7],
          event_handler_028 = param[6],
          arg_039 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_at_){return 0;}),
          bnds_016 = [0, [1, [0, _i_, [0, arg_039, 0]]], 0],
          arg_037 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_as_){return 0;}),
          bnds_016$0 = [0, [1, [0, _j_, [0, arg_037, 0]]], bnds_016],
          arg_035 =
            caml_call2(Async_kernel_Ivar[9], Core[518], don_t_reconnect_034),
          bnds_016$1 = [0, [1, [0, _k_, [0, arg_035, 0]]], bnds_016$0],
          arg_033 =
            caml_call2(Async_kernel_Ivar[9], Core[518], close_finished_032),
          bnds_016$2 = [0, [1, [0, _l_, [0, arg_033, 0]]], bnds_016$1],
          arg_031 =
            caml_call2(Async_kernel_Ivar[9], Core[518], close_started_030),
          bnds_016$3 = [0, [1, [0, _m_, [0, arg_031, 0]]], bnds_016$2],
          server_name_011 = event_handler_028[1],
          arg_014 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_ar_){return 0;}),
          bnds_010 = [0, [1, [0, _g_, [0, arg_014, 0]]], 0],
          arg_012 = caml_call1(Core[471], server_name_011),
          bnds_010$0 = [0, [1, [0, _h_, [0, arg_012, 0]]], bnds_010],
          arg_029 = [1, bnds_010$0],
          bnds_016$4 = [0, [1, [0, _n_, [0, arg_029, 0]]], bnds_016$3],
          _an_ = caml_call1(Core_Or_error[13], sexp_of_t),
          arg_027 =
            caml_call2(Async_kernel_Ivar[9], _an_, next_connect_result_026),
          bnds_016$5 = [0, [1, [0, _o_, [0, arg_027, 0]]], bnds_016$4],
          arg_024 =
            caml_call2
             (Async_kernel_Ivar[9],
              function(param){
               return typeof param === "number"
                       ? _p_
                       : [1, [0, _q_, [0, _a_, 0]]];
              },
              conn_023),
          bnds_016$6 = [0, [1, [0, _r_, [0, arg_024, 0]]], bnds_016$5],
          arg_022 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_aq_){return 0;}),
          bnds_016$7 = [0, [1, [0, _s_, [0, arg_022, 0]]], bnds_016$6],
          arg_020 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_ap_){return 0;}),
          bnds_016$8 = [0, [1, [0, _t_, [0, arg_020, 0]]], bnds_016$7],
          arg_018 =
            caml_call1(Sexplib0_Sexp_conv[24], function(_ao_){return 0;}),
          bnds_016$9 = [0, [1, [0, _u_, [0, arg_018, 0]]], bnds_016$8];
         return [1, bnds_016$9];
        }
        function close_when_current_connection_(t){
         return caml_call2(Async_kernel_Ivar[15], t[9], 0);
        }
        function close_finished$1(param){return close_finished$0(param);}
        function is_closed$1(param){return is_closed$0(param);}
        function close$0(t){
         if(caml_call1(Async_kernel_Ivar[17], t[7]))
          return close_finished$0(t);
         caml_call2(Async_kernel_Ivar[14], t[7], 0);
         var _ak_ = caml_call1(Async_kernel_Ivar[18], t[4]);
         return caml_call2
                 (Async_kernel[20],
                  _ak_,
                  function(conn_opt){
                   function _al_(param){
                    return caml_call2(Async_kernel_Ivar[14], t[8], 0);
                   }
                   if(typeof conn_opt === "number")
                    var _am_ = Async_kernel_Deferred[18];
                   else
                    var conn = conn_opt[2], _am_ = caml_call1(close, conn);
                   return caml_call2(Async_kernel[21], _am_, _al_);
                  });
        }
        function server_name(t){return t[6][1];}
        function current_connection$0(param){return current_connection(param);
        }
        function connected_or_failed_to_connect$0(t){
         if(is_closed$0(t))
          return caml_call1(Async_kernel[19], connected_or_failed_to_connect);
         var match = current_connection(t);
         if(match){
          var x = match[1];
          if(! caml_call1(is_closed, x))
           return caml_call1(Async_kernel[19], [0, x]);
         }
         var
          _af_ = caml_call1(Async_kernel_Ivar[18], t[5]),
          _ag_ =
            [0,
             caml_call2(Async_kernel[4], _af_, function(_aj_){return _aj_;}),
             0],
          _ah_ = caml_call1(Async_kernel_Ivar[18], t[7]),
          _ai_ =
            [0,
             caml_call2
              (Async_kernel[4],
               _ah_,
               function(param){return connected_or_failed_to_connect;}),
             _ag_];
         return caml_call1(Async_kernel_Deferred[29], _ai_);
        }
        function connected(t){
         function loop(param){
          var
           d = caml_call1(Async_kernel_Ivar[18], t[4]),
           match = caml_call1(Async_kernel_Deferred[5], d);
          if(! match)
           return caml_call2
                   (Async_kernel[20],
                    d,
                    function(param){
                     if(typeof param === "number")
                      return caml_call1(Async_kernel_Deferred[19], 0);
                     var conn = param[2];
                     return caml_call1(Async_kernel[19], conn);
                    });
          var match$0 = match[1];
          if(typeof match$0 === "number")
           return caml_call1(Async_kernel_Deferred[19], 0);
          var conn = match$0[2];
          if(! caml_call1(is_closed, conn))
           return caml_call1(Async_kernel[19], conn);
          var _ae_ = caml_call1(close_finished, conn);
          return caml_call2(Async_kernel[20], _ae_, loop);
         }
         return loop(0);
        }
        function create
        (server_name,
         on_event$0,
         retry_delay$0,
         random_state$1,
         time_source$0,
         connect,
         address,
         get_address){
         if(on_event$0)
          var sth = on_event$0[1], on_event = sth;
         else
          var on_event = function(param){return Async_kernel_Deferred[18];};
         if(random_state$1)
          var sth$0 = random_state$1[1], random_state = sth$0;
         else
          var random_state = [0, 389604849, Base_Random[18][1]];
         if(time_source$0)
          var sth$1 = time_source$0[1], time_source = sth$1;
         else
          var time_source = caml_call1(Async_kernel_Time_source[10], 0);
         var
          event_handler = [0, server_name, on_event],
          _B_ = Core[541] ? 0.1 : 10.,
          _C_ = caml_call1(Core_Time_ns[1][81], _B_),
          default_retry_delay = caml_call1(Core_Fn[1], _C_),
          non_randomized_delay =
            caml_call2(Core_Option[34], retry_delay$0, default_retry_delay);
         if(typeof random_state === "number")
          var retry_delay_span = non_randomized_delay;
         else
          var
           random_state$0 = random_state[2],
           retry_delay_span =
             function(param){
              var
               span = caml_call1(non_randomized_delay, 0),
               span$0 = caml_call1(Core_Time_ns[1][91], span),
               distance =
                 caml_call2(Base_Random[18][10], random_state$0, span$0 * 0.3),
               wait =
                 caml_call1(Base_Random[18][16], random_state$0)
                  ? span$0 + distance
                  : span$0 - distance;
              return caml_call1(Core_Time_ns[1][81], wait);
             };
         function retry_delay(param){
          var _ad_ = caml_call1(retry_delay_span, 0);
          return caml_call2(Async_kernel_Time_source[29], time_source, _ad_);
         }
         var
          _D_ = address[2],
          _E_ = address[1],
          _F_ = caml_call1(Async_kernel_Ivar[12], 0),
          _G_ = caml_call1(Async_kernel_Ivar[12], 0),
          _H_ = caml_call1(Async_kernel_Ivar[12], 0),
          _I_ = caml_call1(Async_kernel_Ivar[12], 0),
          t =
            [0,
             get_address,
             connect,
             retry_delay,
             caml_call1(Async_kernel_Ivar[12], 0),
             _I_,
             event_handler,
             _H_,
             _G_,
             _F_,
             _E_,
             _D_],
          _J_ =
            caml_call2
             (Async_kernel_Deferred[31],
              0,
              function(param){
               var _K_ = handle_event(t, 0);
               return caml_call2
                       (Async_kernel[20],
                        _K_,
                        function(param){
                         var previous_address = [0, 0], previous_error = [0, 0];
                         function loop(param){
                          if(caml_call1(Async_kernel_Ivar[17], t[7]))
                           return caml_call1(Async_kernel[19], -400989606);
                          if(caml_call1(Async_kernel_Ivar[17], t[9]))
                           return caml_call1(Async_kernel[19], -818917400);
                          var
                           ready_to_retry_connecting = caml_call1(t[3], 0),
                           _S_ = caml_call1(t[1], 0),
                           _T_ =
                             caml_call2
                              (Async_kernel[20],
                               _S_,
                               function(param){
                                if(0 !== param[0]){
                                 var e = param[1];
                                 return caml_call1(Async_kernel[19], [1, e]);
                                }
                                var addr = param[1], match = previous_address[1];
                                if(match)
                                 var
                                  previous_address$0 = match[1],
                                  same_as_previous_address =
                                    caml_call2(t[10], addr, previous_address$0);
                                else
                                 var same_as_previous_address = 0;
                                previous_address[1] = [0, addr];
                                function _ab_(param){return caml_call1(t[2], addr);}
                                var
                                 _ac_ =
                                   same_as_previous_address
                                    ? Async_kernel_Deferred[18]
                                    : handle_event(t, [0, addr]);
                                return caml_call2(Async_kernel[20], _ac_, _ab_);
                               });
                          return caml_call2
                                  (Async_kernel[22][2],
                                   _T_,
                                   function(connect_result){
                                    caml_call2(Async_kernel_Ivar[14], t[5], connect_result);
                                    t[5] = caml_call1(Async_kernel_Ivar[12], 0);
                                    if(0 === connect_result[0]){
                                     var conn = connect_result[1];
                                     return caml_call1
                                             (Async_kernel[19],
                                              [0, 17724, [0, conn, ready_to_retry_connecting]]);
                                    }
                                    var err = connect_result[1], match = previous_error[1];
                                    if(match)
                                     var
                                      previous_err = match[1],
                                      to_sexp =
                                        function(e){
                                         var
                                          _$_ = caml_call1(Core_Error[26], e),
                                          _aa_ = caml_call1(Async_kernel_Monitor[13], _$_);
                                         return caml_call1(Base_Exn[1], _aa_);
                                        },
                                      _U_ = to_sexp(previous_err),
                                      _V_ = to_sexp(err),
                                      same_as_previous_error = caml_call2(Core_Sexp[36], _V_, _U_);
                                    else
                                     var same_as_previous_error = 0;
                                    previous_error[1] = [0, err];
                                    function _W_(param){
                                     var
                                      _Y_ = [0, caml_call1(Async_kernel_Ivar[18], t[9]), 0],
                                      _Z_ =
                                        [0,
                                         ready_to_retry_connecting,
                                         [0, caml_call1(Async_kernel_Ivar[18], t[7]), _Y_]],
                                      ___ = caml_call1(Async_kernel_Deferred[23], _Z_);
                                     return caml_call2
                                             (Async_kernel[20], ___, function(param){return loop(0);});
                                    }
                                    var
                                     _X_ =
                                       same_as_previous_error
                                        ? Async_kernel_Deferred[18]
                                        : handle_event(t, [1, err]);
                                    return caml_call2(Async_kernel[20], _X_, _W_);
                                   });
                         }
                         var _L_ = loop(0);
                         return caml_call2
                                 (Async_kernel[20],
                                  _L_,
                                  function(param){
                                   if(typeof param === "number")
                                    return -400989606 <= param
                                            ? (caml_call2
                                               (Async_kernel_Ivar[14], t[4], -400989606),
                                              caml_call1(Async_kernel[19], _v_))
                                            : (abort_reconnecting_with_no_act
                                               (t),
                                              caml_call1(Async_kernel[19], _w_));
                                   var
                                    match = param[2],
                                    ready_to_retry_connecting = match[2],
                                    conn = match[1];
                                   caml_call2(Async_kernel_Ivar[14], t[4], [0, 17724, conn]);
                                   var _M_ = handle_event(t, [2, conn]);
                                   return caml_call2
                                           (Async_kernel[20],
                                            _M_,
                                            function(param){
                                             var _N_ = caml_call1(close_finished, conn);
                                             return caml_call2
                                                     (Async_kernel[20],
                                                      _N_,
                                                      function(param){
                                                       t[4] = caml_call1(Async_kernel_Ivar[12], 0);
                                                       var _O_ = handle_event(t, 1);
                                                       return caml_call2
                                                               (Async_kernel[20],
                                                                _O_,
                                                                function(param){
                                                                 var
                                                                  _P_ = [0, caml_call1(Async_kernel_Ivar[18], t[9]), 0],
                                                                  _Q_ =
                                                                    [0,
                                                                     ready_to_retry_connecting,
                                                                     [0, caml_call1(Async_kernel_Ivar[18], t[7]), _P_]],
                                                                  _R_ = caml_call1(Async_kernel_Deferred[23], _Q_);
                                                                 return caml_call2
                                                                         (Async_kernel[22][3],
                                                                          _R_,
                                                                          function(param){
                                                                           return caml_call1(Async_kernel_Ivar[17], t[7])
                                                                                   ? (caml_call2(Async_kernel_Ivar[14], t[4], -400989606), _x_)
                                                                                   : caml_call1
                                                                                      (Async_kernel_Ivar[17], t[9])
                                                                                     ? (abort_reconnecting_with_no_act(t), _y_)
                                                                                     : _z_;
                                                                          });
                                                                });
                                                      });
                                            });
                                  });
                        });
              });
         caml_call1(Async_kernel[6], _J_);
         return t;
        }
        return [0,
                sexp_of_t$1,
                [0, sexp_of_t$0, log_level],
                create,
                connected,
                connected_or_failed_to_connect$0,
                current_connection$0,
                server_name,
                close$0,
                is_closed$1,
                close_finished$1,
                close_when_current_connection_];
       }];
   runtime.caml_register_global
    (69, Persistent_connection_kernel, cst_Persistent_connection_kern);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwZXJzaXN0ZW50X2Nvbm5lY3Rpb25fa2VybmVsLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJzZXhwX29mX3QiLCJzZXhwX29mX3QkMCIsIm9mX2FkZHJlc3NfMDAxIiwiYXJnMF8wMDIiLCJyZXMwXzAwMyIsImFyZzBfMDA0IiwicmVzMF8wMDUiLCJhcmcwXzAwNiIsInJlczBfMDA3IiwibG9nX2xldmVsIiwiaGFuZGxlX2V2ZW50IiwidCIsImV2ZW50Iiwib25fZXZlbnQiLCJhYm9ydF9yZWNvbm5lY3Rpbmdfd2l0aF9ub19hY3QiLCJjdXJyZW50X2Nvbm5lY3Rpb24iLCJjb25uIiwiY2xvc2VfZmluaXNoZWQkMCIsImlzX2Nsb3NlZCQwIiwiY29ubmVjdGVkX29yX2ZhaWxlZF90b19jb25uZWN0Iiwic2V4cF9vZl90JDEiLCJwYXJhbSIsImNvbm5fMDIzIiwibmV4dF9jb25uZWN0X3Jlc3VsdF8wMjYiLCJkb25fdF9yZWNvbm5lY3RfMDM0IiwiY2xvc2VfZmluaXNoZWRfMDMyIiwiY2xvc2Vfc3RhcnRlZF8wMzAiLCJldmVudF9oYW5kbGVyXzAyOCIsImFyZ18wMzkiLCJibmRzXzAxNiIsImFyZ18wMzciLCJibmRzXzAxNiQwIiwiYXJnXzAzNSIsImJuZHNfMDE2JDEiLCJhcmdfMDMzIiwiYm5kc18wMTYkMiIsImFyZ18wMzEiLCJibmRzXzAxNiQzIiwic2VydmVyX25hbWVfMDExIiwiYXJnXzAxNCIsImJuZHNfMDEwIiwiYXJnXzAxMiIsImJuZHNfMDEwJDAiLCJhcmdfMDI5IiwiYm5kc18wMTYkNCIsImFyZ18wMjciLCJibmRzXzAxNiQ1IiwiYXJnXzAyNCIsImJuZHNfMDE2JDYiLCJhcmdfMDIyIiwiYm5kc18wMTYkNyIsImFyZ18wMjAiLCJibmRzXzAxNiQ4IiwiYXJnXzAxOCIsImJuZHNfMDE2JDkiLCJjbG9zZV93aGVuX2N1cnJlbnRfY29ubmVjdGlvbl8iLCJjbG9zZV9maW5pc2hlZCQxIiwiaXNfY2xvc2VkJDEiLCJjbG9zZSQwIiwiY29ubl9vcHQiLCJzZXJ2ZXJfbmFtZSIsImN1cnJlbnRfY29ubmVjdGlvbiQwIiwiY29ubmVjdGVkX29yX2ZhaWxlZF90b19jb25uZWN0JDAiLCJ4IiwiY29ubmVjdGVkIiwibG9vcCIsImQiLCJjcmVhdGUiLCJvbl9ldmVudCQwIiwicmV0cnlfZGVsYXkkMCIsInJhbmRvbV9zdGF0ZSQxIiwidGltZV9zb3VyY2UkMCIsImNvbm5lY3QiLCJhZGRyZXNzIiwiZ2V0X2FkZHJlc3MiLCJzdGgiLCJzdGgkMCIsInJhbmRvbV9zdGF0ZSIsInN0aCQxIiwidGltZV9zb3VyY2UiLCJldmVudF9oYW5kbGVyIiwiZGVmYXVsdF9yZXRyeV9kZWxheSIsIm5vbl9yYW5kb21pemVkX2RlbGF5IiwicmV0cnlfZGVsYXlfc3BhbiIsInJhbmRvbV9zdGF0ZSQwIiwic3BhbiIsInNwYW4kMCIsImRpc3RhbmNlIiwid2FpdCIsInJldHJ5X2RlbGF5IiwicHJldmlvdXNfYWRkcmVzcyIsInByZXZpb3VzX2Vycm9yIiwicmVhZHlfdG9fcmV0cnlfY29ubmVjdGluZyIsImUiLCJhZGRyIiwicHJldmlvdXNfYWRkcmVzcyQwIiwic2FtZV9hc19wcmV2aW91c19hZGRyZXNzIiwiY29ubmVjdF9yZXN1bHQiLCJlcnIiLCJwcmV2aW91c19lcnIiLCJ0b19zZXhwIiwic2FtZV9hc19wcmV2aW91c19lcnJvciJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL3BlcnNpc3RlbnRfY29ubmVjdGlvbl9rZXJuZWwvcGVyc2lzdGVudF9jb25uZWN0aW9uX2tlcm5lbC5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QkwsaUJBd0h6Qks7bUNBRUwsVUF6SUZOLGFBZWdDQyxPQXdIekJLO21DQUdELE9BQUE7Ozs7NkNBQ0osVUFBQSwyQkFKS0E7NkNBS0QsT0FBQTs7Ozt1REE3SDBCTCxPQThIcEI7dURBQ1YsVUE5SUZELGFBZWdDQzt1REFnSTFCLE9BQUE7Ozs7aUVBTUE7NEVBRUUsa0NBeEl3QkE7a0VBc0kxQjs7cUVBZE9pRjt5RUFlTCxrQ0F2SXdCakY7a0VBcUk1QixNQUFBOzs7OzsyRUFNRixPQUFHLGtDQTNJMkJBO3NGQTZJNUIsa0NBN0k0QkE7cUZBK0l0Qjs4R0EvSXNCQTt3RkFzRGhDRywrQkF0RGdDSDs7MEVBbUpmOztzREFBQTs0Q0FBQTtrQ0FBQTt3QkFBQTtjQUFBO1NBdkNuQjtTQUFBLE9BNUdrQ0E7UUErUW5COztnQkFqQ2ZTO29CQTFTRm5CLGFBa0JJUTtnQkFzU0YwRDtnQkFGQUg7Z0JBREFGO2dCQURBRDtnQkFEQUQ7Z0JBREFGO2dCQURBRDtnQkFEQUQ7Z0JBSkFEOzs7OztFIiwic291cmNlc0NvbnRlbnQiOlsib3BlbiEgQ29yZVxub3BlbiEgQXN5bmNfa2VybmVsXG5vcGVuISBBc3luY19rZXJuZWxfcmVxdWlyZV9leHBsaWNpdF90aW1lX3NvdXJjZVxuaW5jbHVkZSBQZXJzaXN0ZW50X2Nvbm5lY3Rpb25fa2VybmVsX2ludGZcblxubW9kdWxlIE1ha2UgKENvbm4gOiBDbG9zYWJsZSkgPSBzdHJ1Y3RcbiAgbW9kdWxlIENvbm4gPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIENvbm5cblxuICAgIGxldCBzZXhwX29mX3QgKF8gOiB0KSA6IFNleHAudCA9IEF0b20gXCI8Q29ubi50PlwiXG4gIGVuZFxuXG4gIHR5cGUgY29ubiA9IENvbm4udFxuXG4gIG1vZHVsZSBFdmVudCA9IHN0cnVjdFxuICAgIHR5cGUgJ2FkZHJlc3MgdCA9XG4gICAgICB8IEF0dGVtcHRpbmdfdG9fY29ubmVjdFxuICAgICAgfCBPYnRhaW5lZF9hZGRyZXNzIG9mICdhZGRyZXNzXG4gICAgICB8IEZhaWxlZF90b19jb25uZWN0IG9mIEVycm9yLnRcbiAgICAgIHwgQ29ubmVjdGVkIG9mIChjb25uW0BzZXhwLm9wYXF1ZV0pXG4gICAgICB8IERpc2Nvbm5lY3RlZFxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgICB0eXBlICdhZGRyZXNzIGV2ZW50ID0gJ2FkZHJlc3MgdFxuXG4gICAgbW9kdWxlIEhhbmRsZXIgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgJ2FkZHJlc3MgdCA9XG4gICAgICAgIHsgc2VydmVyX25hbWUgOiBzdHJpbmdcbiAgICAgICAgOyBvbl9ldmVudCA6ICdhZGRyZXNzIGV2ZW50IC0+IHVuaXQgRGVmZXJyZWQudFxuICAgICAgICB9XG4gICAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIGVuZFxuXG4gICAgbGV0IGxvZ19sZXZlbCA9IGZ1bmN0aW9uXG4gICAgICB8IEF0dGVtcHRpbmdfdG9fY29ubmVjdCB8IENvbm5lY3RlZCBfIHwgRGlzY29ubmVjdGVkIHwgT2J0YWluZWRfYWRkcmVzcyBfIC0+IGBJbmZvXG4gICAgICB8IEZhaWxlZF90b19jb25uZWN0IF8gLT4gYEVycm9yXG4gICAgOztcblxuICAgIGxldCBoYW5kbGUgdCB7IEhhbmRsZXIuc2VydmVyX25hbWUgPSBfOyBvbl9ldmVudCB9ID0gb25fZXZlbnQgdFxuICBlbmRcblxuICAoKiBBIHBlcnNpc3RlbnQgY29ubmVjdGlvbiB0aGF0IGlzIHBvbHltb3JwaGljIGluIHRoZSBhZGRyZXNzIHR5cGUuICBXZSBoaWRlIGF3YXkgdGhpc1xuICAgICB0eXBlIGxhdGVyIHNpbmNlIGl0IG9ubHkgYXBwZWFycyBpbiB0aGUgdHlwZSBvZiBbY3JlYXRlXS4gKilcbiAgbW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgICB0eXBlICdhZGRyZXNzIHQgPVxuICAgICAgeyBnZXRfYWRkcmVzcyA6IHVuaXQgLT4gJ2FkZHJlc3MgT3JfZXJyb3IudCBEZWZlcnJlZC50XG4gICAgICA7IGNvbm5lY3QgOiAnYWRkcmVzcyAtPiBDb25uLnQgT3JfZXJyb3IudCBEZWZlcnJlZC50XG4gICAgICA7IHJldHJ5X2RlbGF5IDogdW5pdCAtPiB1bml0IERlZmVycmVkLnRcbiAgICAgIDsgbXV0YWJsZSBjb25uIDogWyBgT2sgb2YgQ29ubi50IHwgYENsb3NlX3N0YXJ0ZWQgXSBJdmFyLnRcbiAgICAgIDsgbXV0YWJsZSBuZXh0X2Nvbm5lY3RfcmVzdWx0IDogQ29ubi50IE9yX2Vycm9yLnQgSXZhci50XG4gICAgICA7IGV2ZW50X2hhbmRsZXIgOiAnYWRkcmVzcyBFdmVudC5IYW5kbGVyLnRcbiAgICAgIDsgY2xvc2Vfc3RhcnRlZCA6IHVuaXQgSXZhci50XG4gICAgICA7IGNsb3NlX2ZpbmlzaGVkIDogdW5pdCBJdmFyLnRcbiAgICAgIDsgZG9uJ3RfcmVjb25uZWN0IDogdW5pdCBJdmFyLnRcbiAgICAgIDsgYWRkcmVzc19lcXVhbCA6ICdhZGRyZXNzIC0+ICdhZGRyZXNzIC0+IGJvb2xcbiAgICAgIDsgc2V4cF9vZl9hZGRyZXNzIDogJ2FkZHJlc3MgLT4gU2V4cC50XG4gICAgICB9XG4gICAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG4gICAgbGV0IHNlcnZlcl9uYW1lIHQgPSB0LmV2ZW50X2hhbmRsZXIuc2VydmVyX25hbWVcbiAgICBsZXQgaGFuZGxlX2V2ZW50IHQgZXZlbnQgPSBFdmVudC5oYW5kbGUgZXZlbnQgdC5ldmVudF9oYW5kbGVyXG5cbiAgICAoKiBUaGlzIGZ1bmN0aW9uIGZvY3VzZXMgaW4gb24gdGhlIHRoZSBlcnJvciBpdHNlbGYsIGRpc2NhcmRpbmcgaW5mb3JtYXRpb24gYWJvdXQgd2hpY2hcbiAgICAgICBtb25pdG9yIGNhdWdodCB0aGUgZXJyb3IsIGlmIGFueS5cblxuICAgICAgIElmIHdlIGRvbid0IGRvIHRoaXMsIHdlIHNvbWV0aW1lcyBlbmQgdXAgd2l0aCBub2lzeSBsb2dzIHdoaWNoIHJlcG9ydCB0aGUgc2FtZSBlcnJvclxuICAgICAgIGFnYWluIGFuZCBhZ2FpbiwgZGlmZmVyaW5nIG9ubHkgYXMgdG8gd2hhdCBtb25pdG9yIGNhdWdodCB0aGVtLiAqKVxuICAgIGxldCBzYW1lX2Vycm9yIGUxIGUyID1cbiAgICAgIGxldCB0b19zZXhwIGUgPSBFeG4uc2V4cF9vZl90IChNb25pdG9yLmV4dHJhY3RfZXhuIChFcnJvci50b19leG4gZSkpIGluXG4gICAgICBTZXhwLmVxdWFsICh0b19zZXhwIGUxKSAodG9fc2V4cCBlMilcbiAgICA7O1xuXG4gICAgKCogQ29udGludWUgdHJ5aW5nIHRvIGNvbm5lY3QgdW50aWwgd2UgYXJlIGFibGUgdG8gZG8gc28sIGluIHdoaWNoIGNhc2Ugd2UgcmV0dXJuIGJvdGhcbiAgICAgICB0aGUgbmV3IGNvbm5lY3Rpb24gYW5kIGEgZGVmZXJyZWQgdGhhdCB3aWxsIGJlY29tZSBkZXRlcm1pbmVkIG9uY2Ugd2UgYXJlIHJlYWR5IGZvclxuICAgICAgIHRoZSBuZXh0IHJlY29ubmVjdGlvbiBhdHRlbXB0LiAqKVxuICAgIGxldCB0cnlfY29ubmVjdGluZ191bnRpbF9zdWNjZXNzZnVsIHQgPVxuICAgICAgKCogV2UgdGFrZSBjYXJlIG5vdCB0byBzcGFtIGxvZ3Mgd2l0aCB0aGUgc2FtZSBtZXNzYWdlIG92ZXIgYW5kIG92ZXIgYnkgY29tcGFyaW5nXG4gICAgICAgICBlYWNoIGxvZyBtZXNzYWdlIHRoZSB0aGUgcHJldmlvdXMgb25lIG9mIHRoZSBzYW1lIHR5cGUuICopXG4gICAgICBsZXQgcHJldmlvdXNfYWRkcmVzcyA9IHJlZiBOb25lIGluXG4gICAgICBsZXQgcHJldmlvdXNfZXJyb3IgPSByZWYgTm9uZSBpblxuICAgICAgbGV0IGNvbm5lY3QgKCkgPVxuICAgICAgICB0LmdldF9hZGRyZXNzICgpXG4gICAgICAgID4+PSBmdW5jdGlvblxuICAgICAgICB8IEVycm9yIGUgLT4gcmV0dXJuIChFcnJvciBlKVxuICAgICAgICB8IE9rIGFkZHIgLT5cbiAgICAgICAgICBsZXQgc2FtZV9hc19wcmV2aW91c19hZGRyZXNzID1cbiAgICAgICAgICAgIG1hdGNoICFwcmV2aW91c19hZGRyZXNzIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgICAgICAgICAgfCBTb21lIHByZXZpb3VzX2FkZHJlc3MgLT4gdC5hZGRyZXNzX2VxdWFsIGFkZHIgcHJldmlvdXNfYWRkcmVzc1xuICAgICAgICAgIGluXG4gICAgICAgICAgcHJldmlvdXNfYWRkcmVzcyA6PSBTb21lIGFkZHI7XG4gICAgICAgICAgKGlmIHNhbWVfYXNfcHJldmlvdXNfYWRkcmVzc1xuICAgICAgICAgICB0aGVuIERlZmVycmVkLnVuaXRcbiAgICAgICAgICAgZWxzZSBoYW5kbGVfZXZlbnQgdCAoT2J0YWluZWRfYWRkcmVzcyBhZGRyKSlcbiAgICAgICAgICA+Pj0gZnVuICgpIC0+IHQuY29ubmVjdCBhZGRyXG4gICAgICBpblxuICAgICAgbGV0IHJlYyBsb29wICgpID1cbiAgICAgICAgaWYgSXZhci5pc19mdWxsIHQuY2xvc2Vfc3RhcnRlZFxuICAgICAgICB0aGVuIHJldHVybiBgQ2xvc2Vfc3RhcnRlZFxuICAgICAgICBlbHNlIGlmIEl2YXIuaXNfZnVsbCB0LmRvbid0X3JlY29ubmVjdFxuICAgICAgICB0aGVuIHJldHVybiBgRG9uJ3RfcmVjb25uZWN0XG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCByZWFkeV90b19yZXRyeV9jb25uZWN0aW5nID0gdC5yZXRyeV9kZWxheSAoKSBpblxuICAgICAgICAgIGxldCViaW5kIGNvbm5lY3RfcmVzdWx0ID0gY29ubmVjdCAoKSBpblxuICAgICAgICAgIEl2YXIuZmlsbCB0Lm5leHRfY29ubmVjdF9yZXN1bHQgY29ubmVjdF9yZXN1bHQ7XG4gICAgICAgICAgdC5uZXh0X2Nvbm5lY3RfcmVzdWx0IDwtIEl2YXIuY3JlYXRlICgpO1xuICAgICAgICAgIG1hdGNoIGNvbm5lY3RfcmVzdWx0IHdpdGhcbiAgICAgICAgICB8IE9rIGNvbm4gLT4gcmV0dXJuIChgT2sgKGNvbm4sIHJlYWR5X3RvX3JldHJ5X2Nvbm5lY3RpbmcpKVxuICAgICAgICAgIHwgRXJyb3IgZXJyIC0+XG4gICAgICAgICAgICBsZXQgc2FtZV9hc19wcmV2aW91c19lcnJvciA9XG4gICAgICAgICAgICAgIG1hdGNoICFwcmV2aW91c19lcnJvciB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgICAgICAgICAgICB8IFNvbWUgcHJldmlvdXNfZXJyIC0+IHNhbWVfZXJyb3IgZXJyIHByZXZpb3VzX2VyclxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIHByZXZpb3VzX2Vycm9yIDo9IFNvbWUgZXJyO1xuICAgICAgICAgICAgKGlmIHNhbWVfYXNfcHJldmlvdXNfZXJyb3JcbiAgICAgICAgICAgICB0aGVuIERlZmVycmVkLnVuaXRcbiAgICAgICAgICAgICBlbHNlIGhhbmRsZV9ldmVudCB0IChGYWlsZWRfdG9fY29ubmVjdCBlcnIpKVxuICAgICAgICAgICAgPj49IGZ1biAoKSAtPlxuICAgICAgICAgICAgRGVmZXJyZWQuYW55XG4gICAgICAgICAgICAgIFsgcmVhZHlfdG9fcmV0cnlfY29ubmVjdGluZ1xuICAgICAgICAgICAgICA7IEl2YXIucmVhZCB0LmNsb3NlX3N0YXJ0ZWRcbiAgICAgICAgICAgICAgOyBJdmFyLnJlYWQgdC5kb24ndF9yZWNvbm5lY3RcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgPj49IGZ1biAoKSAtPiBsb29wICgpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgKClcbiAgICA7O1xuXG4gICAgbGV0IGFib3J0X3JlY29ubmVjdGluZ193aXRoX25vX2FjdGl2ZV9jb25uZWN0aW9uIHQgPVxuICAgICAgSXZhci5maWxsIHQuY2xvc2Vfc3RhcnRlZCAoKTtcbiAgICAgIEl2YXIuZmlsbCB0LmNsb3NlX2ZpbmlzaGVkICgpO1xuICAgICAgSXZhci5maWxsIHQuY29ubiBgQ2xvc2Vfc3RhcnRlZFxuICAgIDs7XG5cbiAgICBsZXQgY3JlYXRlXG4gICAgICAgICAgKHR5cGUgYWRkcmVzcylcbiAgICAgICAgICB+c2VydmVyX25hbWVcbiAgICAgICAgICA/KG9uX2V2ZW50ID0gZnVuIF8gLT4gRGVmZXJyZWQudW5pdClcbiAgICAgICAgICA/cmV0cnlfZGVsYXlcbiAgICAgICAgICA/KHJhbmRvbV9zdGF0ZSA9IGBTdGF0ZSBSYW5kb20uU3RhdGUuZGVmYXVsdClcbiAgICAgICAgICA/KHRpbWVfc291cmNlID0gVGltZV9zb3VyY2Uud2FsbF9jbG9jayAoKSlcbiAgICAgICAgICB+Y29ubmVjdFxuICAgICAgICAgIH5hZGRyZXNzOihtb2R1bGUgQWRkcmVzcyA6IEFkZHJlc3Mgd2l0aCB0eXBlIHQgPSBhZGRyZXNzKVxuICAgICAgICAgIGdldF9hZGRyZXNzXG4gICAgICA9XG4gICAgICBsZXQgZXZlbnRfaGFuZGxlciA9IHsgRXZlbnQuSGFuZGxlci5zZXJ2ZXJfbmFtZTsgb25fZXZlbnQgfSBpblxuICAgICAgbGV0IGRlZmF1bHRfcmV0cnlfZGVsYXkgPVxuICAgICAgICBGbi5jb25zdCAoVGltZV9ucy5TcGFuLm9mX3NlYyAoaWYgYW1fcnVubmluZ190ZXN0IHRoZW4gMC4xIGVsc2UgMTAuKSlcbiAgICAgIGluXG4gICAgICBsZXQgbm9uX3JhbmRvbWl6ZWRfZGVsYXkgPSBPcHRpb24udmFsdWUgcmV0cnlfZGVsYXkgfmRlZmF1bHQ6ZGVmYXVsdF9yZXRyeV9kZWxheSBpblxuICAgICAgbGV0IHJldHJ5X2RlbGF5X3NwYW4gPVxuICAgICAgICBtYXRjaCByYW5kb21fc3RhdGUgd2l0aFxuICAgICAgICB8IGBOb25fcmFuZG9tIC0+IG5vbl9yYW5kb21pemVkX2RlbGF5XG4gICAgICAgIHwgYFN0YXRlIHJhbmRvbV9zdGF0ZSAtPlxuICAgICAgICAgIGZ1biAoKSAtPlxuICAgICAgICAgICAgbGV0IHNwYW4gPSBub25fcmFuZG9taXplZF9kZWxheSAoKSBpblxuICAgICAgICAgICAgbGV0IHNwYW4gPSBUaW1lX25zLlNwYW4udG9fc2VjIHNwYW4gaW5cbiAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IFJhbmRvbS5TdGF0ZS5mbG9hdCByYW5kb21fc3RhdGUgKHNwYW4gKi4gMC4zKSBpblxuICAgICAgICAgICAgbGV0IHdhaXQgPVxuICAgICAgICAgICAgICBpZiBSYW5kb20uU3RhdGUuYm9vbCByYW5kb21fc3RhdGVcbiAgICAgICAgICAgICAgdGhlbiBzcGFuICsuIGRpc3RhbmNlXG4gICAgICAgICAgICAgIGVsc2Ugc3BhbiAtLiBkaXN0YW5jZVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIFRpbWVfbnMuU3Bhbi5vZl9zZWMgd2FpdFxuICAgICAgaW5cbiAgICAgIGxldCByZXRyeV9kZWxheSAoKSA9IFRpbWVfc291cmNlLmFmdGVyIHRpbWVfc291cmNlIChyZXRyeV9kZWxheV9zcGFuICgpKSBpblxuICAgICAgbGV0IHQgPVxuICAgICAgICB7IGV2ZW50X2hhbmRsZXJcbiAgICAgICAgOyBnZXRfYWRkcmVzc1xuICAgICAgICA7IGNvbm5lY3RcbiAgICAgICAgOyBuZXh0X2Nvbm5lY3RfcmVzdWx0ID0gSXZhci5jcmVhdGUgKClcbiAgICAgICAgOyByZXRyeV9kZWxheVxuICAgICAgICA7IGNvbm4gPSBJdmFyLmNyZWF0ZSAoKVxuICAgICAgICA7IGNsb3NlX3N0YXJ0ZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgICAgICA7IGNsb3NlX2ZpbmlzaGVkID0gSXZhci5jcmVhdGUgKClcbiAgICAgICAgOyBkb24ndF9yZWNvbm5lY3QgPSBJdmFyLmNyZWF0ZSAoKVxuICAgICAgICA7IGFkZHJlc3NfZXF1YWwgPSBBZGRyZXNzLmVxdWFsXG4gICAgICAgIDsgc2V4cF9vZl9hZGRyZXNzID0gQWRkcmVzcy5zZXhwX29mX3RcbiAgICAgICAgfVxuICAgICAgaW5cbiAgICAgICgqIHRoaXMgbG9vcCBmaW5pc2hlcyBvbmNlIFtjbG9zZSB0XSBoYXMgYmVlbiBjYWxsZWQsIGluIHdoaWNoIGNhc2UgaXQgbWFrZXMgc3VyZSB0b1xuICAgICAgICAgbGVhdmUgW3QuY29ubl0gZmlsbGVkIHdpdGggW2BDbG9zZV9zdGFydGVkXS4gKilcbiAgICAgIGRvbid0X3dhaXRfZm9yXG4gICAgICBAQCBEZWZlcnJlZC5yZXBlYXRfdW50aWxfZmluaXNoZWQgKCkgKGZ1biAoKSAtPlxuICAgICAgICBoYW5kbGVfZXZlbnQgdCBBdHRlbXB0aW5nX3RvX2Nvbm5lY3RcbiAgICAgICAgPj49IGZ1biAoKSAtPlxuICAgICAgICB0cnlfY29ubmVjdGluZ191bnRpbF9zdWNjZXNzZnVsIHRcbiAgICAgICAgPj49IGZ1bmN0aW9uXG4gICAgICAgIHwgYENsb3NlX3N0YXJ0ZWQgLT5cbiAgICAgICAgICBJdmFyLmZpbGwgdC5jb25uIGBDbG9zZV9zdGFydGVkO1xuICAgICAgICAgIHJldHVybiAoYEZpbmlzaGVkICgpKVxuICAgICAgICB8IGBEb24ndF9yZWNvbm5lY3QgLT5cbiAgICAgICAgICBhYm9ydF9yZWNvbm5lY3Rpbmdfd2l0aF9ub19hY3RpdmVfY29ubmVjdGlvbiB0O1xuICAgICAgICAgIHJldHVybiAoYEZpbmlzaGVkICgpKVxuICAgICAgICB8IGBPayAoY29ubiwgcmVhZHlfdG9fcmV0cnlfY29ubmVjdGluZykgLT5cbiAgICAgICAgICBJdmFyLmZpbGwgdC5jb25uIChgT2sgY29ubik7XG4gICAgICAgICAgaGFuZGxlX2V2ZW50IHQgKENvbm5lY3RlZCBjb25uKVxuICAgICAgICAgID4+PSBmdW4gKCkgLT5cbiAgICAgICAgICBDb25uLmNsb3NlX2ZpbmlzaGVkIGNvbm5cbiAgICAgICAgICA+Pj0gZnVuICgpIC0+XG4gICAgICAgICAgdC5jb25uIDwtIEl2YXIuY3JlYXRlICgpO1xuICAgICAgICAgIGhhbmRsZV9ldmVudCB0IERpc2Nvbm5lY3RlZFxuICAgICAgICAgID4+PSBmdW4gKCkgLT5cbiAgICAgICAgICAoKiB3YWl0cyB1bnRpbCBbcmV0cnlfZGVsYXkgKCldIHRpbWUgaGFzIHBhc3NlZCBzaW5jZSB0aGUgdGltZSBqdXN0IGJlZm9yZSB3ZSBsYXN0XG4gICAgICAgICAgICAgdHJpZWQgdG8gY29ubmVjdCByYXRoZXIgdGhhbiB0aGUgdGltZSB3ZSBub3RpY2VkIGJlaW5nIGRpc2Nvbm5lY3RlZCwgc28gdGhhdCBpZlxuICAgICAgICAgICAgIGEgbG9uZy1saXZlZCBjb25uZWN0aW9uIGRpZXMsIHdlIHdpbGwgYXR0ZW1wdCB0byByZWNvbm5lY3QgaW1tZWRpYXRlbHkuICopXG4gICAgICAgICAgbGV0JW1hcCAoKSA9XG4gICAgICAgICAgICBEZWZlcnJlZC5hbnlcbiAgICAgICAgICAgICAgWyByZWFkeV90b19yZXRyeV9jb25uZWN0aW5nXG4gICAgICAgICAgICAgIDsgSXZhci5yZWFkIHQuY2xvc2Vfc3RhcnRlZFxuICAgICAgICAgICAgICA7IEl2YXIucmVhZCB0LmRvbid0X3JlY29ubmVjdFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgaW5cbiAgICAgICAgICBpZiBJdmFyLmlzX2Z1bGwgdC5jbG9zZV9zdGFydGVkXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBJdmFyLmZpbGwgdC5jb25uIGBDbG9zZV9zdGFydGVkO1xuICAgICAgICAgICAgYEZpbmlzaGVkICgpKVxuICAgICAgICAgIGVsc2UgaWYgSXZhci5pc19mdWxsIHQuZG9uJ3RfcmVjb25uZWN0XG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBhYm9ydF9yZWNvbm5lY3Rpbmdfd2l0aF9ub19hY3RpdmVfY29ubmVjdGlvbiB0O1xuICAgICAgICAgICAgYEZpbmlzaGVkICgpKVxuICAgICAgICAgIGVsc2UgYFJlcGVhdCAoKSk7XG4gICAgICB0XG4gICAgOztcblxuICAgIGxldCBjb25uZWN0ZWQgdCA9XG4gICAgICAoKiBUYWtlIGNhcmUgbm90IHRvIHJldHVybiBhIGNvbm5lY3Rpb24gdGhhdCBpcyBrbm93biB0byBiZSBjbG9zZWQgYXQgdGhlIHRpbWVcbiAgICAgICAgIFtjb25uZWN0ZWRdIHdhcyBjYWxsZWQuICBUaGlzIGNvdWxkIGhhcHBlbiBpbiBjbGllbnQgY29kZSB0aGF0IGJlaGF2ZXMgbGlrZVxuICAgICAgICAge1tcbiAgICAgICAgICAgUGVyc2lzdGVudF9jb25uZWN0aW9uLlJwYy5jb25uZWN0ZWQgdFxuICAgICAgICAgICA+Pj0gZnVuIGMxIC0+XG4gICAgICAgICAgIC4uLlxuICAgICAgICAgICAgIFJwYy5Db25uZWN0aW9uLmNsb3NlX2ZpbmlzaGVkIGMxXG4gICAgICAgICAgICgqIGF0IHRoaXMgcG9pbnQgd2UgYXJlIGluIGEgcmFjZSB3aXRoIHRoZSBzYW1lIGNhbGwgaW5zaWRlXG4gICAgICAgICAgICAgIHBlcnNpc3RlbnRfY2xpZW50Lm1sICopXG4gICAgICAgICAgID4+PSBmdW4gKCkgLT5cbiAgICAgICAgICAgUGVyc2lzdGVudF9jb25uZWN0aW9uLlJwYy5jb25uZWN0ZWQgdFxuICAgICAgICAgICAoKiBkZXBlbmRpbmcgb24gaG93IHRoZSByYWNlIHR1cm5zIG91dCwgd2UgZG9uJ3Qgd2FudCB0byBnZXQgYSBjbG9zZWQgY29ubmVjdGlvblxuICAgICAgICAgICAgICBoZXJlICopXG4gICAgICAgICAgID4+PSBmdW4gYzIgLT5cbiAgICAgICAgICAgLi4uXG4gICAgICAgICBdfVxuICAgICAgICAgVGhpcyBkb2Vzbid0IHJlbW92ZSB0aGUgcmFjZSBjb25kaXRpb24sIGJ1dCBpdCBtYWtlcyBpdCBsZXNzIGxpa2VseSB0byBoYXBwZW4uXG4gICAgICAqKVxuICAgICAgbGV0IHJlYyBsb29wICgpID1cbiAgICAgICAgbGV0IGQgPSBJdmFyLnJlYWQgdC5jb25uIGluXG4gICAgICAgIG1hdGNoIERlZmVycmVkLnBlZWsgZCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGRcbiAgICAgICAgICA+Pj0gKGZ1bmN0aW9uXG4gICAgICAgICAgICB8IGBDbG9zZV9zdGFydGVkIC0+IERlZmVycmVkLm5ldmVyICgpXG4gICAgICAgICAgICB8IGBPayBjb25uIC0+IHJldHVybiBjb25uKVxuICAgICAgICB8IFNvbWUgYENsb3NlX3N0YXJ0ZWQgLT4gRGVmZXJyZWQubmV2ZXIgKClcbiAgICAgICAgfCBTb21lIChgT2sgY29ubikgLT5cbiAgICAgICAgICBpZiBDb25uLmlzX2Nsb3NlZCBjb25uXG4gICAgICAgICAgdGhlblxuICAgICAgICAgICAgKCogZ2l2ZSB0aGUgcmVjb25uZWN0aW9uIGxvb3AgYSBjaGFuY2UgdG8gb3ZlcndyaXRlIHRoZSBpdmFyICopXG4gICAgICAgICAgICBDb25uLmNsb3NlX2ZpbmlzaGVkIGNvbm4gPj49IGxvb3BcbiAgICAgICAgICBlbHNlIHJldHVybiBjb25uXG4gICAgICBpblxuICAgICAgbG9vcCAoKVxuICAgIDs7XG5cbiAgICBsZXQgY3VycmVudF9jb25uZWN0aW9uIHQgPVxuICAgICAgbWF0Y2ggRGVmZXJyZWQucGVlayAoSXZhci5yZWFkIHQuY29ubikgd2l0aFxuICAgICAgfCBOb25lIHwgU29tZSBgQ2xvc2Vfc3RhcnRlZCAtPiBOb25lXG4gICAgICB8IFNvbWUgKGBPayBjb25uKSAtPiBTb21lIGNvbm5cbiAgICA7O1xuXG4gICAgbGV0IGNsb3NlX2ZpbmlzaGVkIHQgPSBJdmFyLnJlYWQgdC5jbG9zZV9maW5pc2hlZFxuICAgIGxldCBpc19jbG9zZWQgdCA9IEl2YXIuaXNfZnVsbCB0LmNsb3NlX3N0YXJ0ZWRcblxuICAgIGxldCBjbG9zZSB0ID1cbiAgICAgIGlmIEl2YXIuaXNfZnVsbCB0LmNsb3NlX3N0YXJ0ZWRcbiAgICAgIHRoZW5cbiAgICAgICAgKCogQW5vdGhlciBjYWxsIHRvIGNsb3NlIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MuICBXYWl0IGZvciBpdCB0byBmaW5pc2guICopXG4gICAgICAgIGNsb3NlX2ZpbmlzaGVkIHRcbiAgICAgIGVsc2UgKFxuICAgICAgICBJdmFyLmZpbGwgdC5jbG9zZV9zdGFydGVkICgpO1xuICAgICAgICBJdmFyLnJlYWQgdC5jb25uXG4gICAgICAgID4+PSBmdW4gY29ubl9vcHQgLT5cbiAgICAgICAgKG1hdGNoIGNvbm5fb3B0IHdpdGhcbiAgICAgICAgIHwgYENsb3NlX3N0YXJ0ZWQgLT4gRGVmZXJyZWQudW5pdFxuICAgICAgICAgfCBgT2sgY29ubiAtPiBDb25uLmNsb3NlIGNvbm4pXG4gICAgICAgID4+fCBmdW4gKCkgLT4gSXZhci5maWxsIHQuY2xvc2VfZmluaXNoZWQgKCkpXG4gICAgOztcblxuICAgIGxldCBjb25uZWN0ZWRfb3JfZmFpbGVkX3RvX2Nvbm5lY3RfY29ubmVjdGlvbl9jbG9zZWQgPVxuICAgICAgT3JfZXJyb3IuZXJyb3JfcyBbJW1lc3NhZ2UgXCJQZXJzaXN0ZW50IGNvbm5lY3Rpb24gY2xvc2VkXCJdXG4gICAgOztcblxuICAgIGxldCBjb25uZWN0ZWRfb3JfZmFpbGVkX3RvX2Nvbm5lY3QgdCA9XG4gICAgICBpZiBpc19jbG9zZWQgdFxuICAgICAgdGhlbiByZXR1cm4gY29ubmVjdGVkX29yX2ZhaWxlZF90b19jb25uZWN0X2Nvbm5lY3Rpb25fY2xvc2VkXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggY3VycmVudF9jb25uZWN0aW9uIHQgd2l0aFxuICAgICAgICB8IFNvbWUgeCB3aGVuIG5vdCAoQ29ubi5pc19jbG9zZWQgeCkgLT4gcmV0dXJuIChPayB4KVxuICAgICAgICB8IFNvbWUgKF8gOiBDb25uLnQpIHwgTm9uZSAtPlxuICAgICAgICAgIERlZmVycmVkLmNob29zZVxuICAgICAgICAgICAgWyBjaG9pY2UgKEl2YXIucmVhZCB0LmNsb3NlX3N0YXJ0ZWQpIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgICBjb25uZWN0ZWRfb3JfZmFpbGVkX3RvX2Nvbm5lY3RfY29ubmVjdGlvbl9jbG9zZWQpXG4gICAgICAgICAgICA7IGNob2ljZSAoSXZhci5yZWFkIHQubmV4dF9jb25uZWN0X3Jlc3VsdCkgRm4uaWRcbiAgICAgICAgICAgIF0pXG4gICAgOztcblxuICAgIGxldCBjbG9zZV93aGVuX2N1cnJlbnRfY29ubmVjdGlvbl9pc19jbG9zZWQgdCA9XG4gICAgICBJdmFyLmZpbGxfaWZfZW1wdHkgdC5kb24ndF9yZWNvbm5lY3QgKClcbiAgICA7O1xuICBlbmRcblxuICB0eXBlIHQgPSBUIDogJ2FkZHJlc3MgUG9seS50IC0+IHQgW0BAdW5ib3hlZF1cblxuICBsZXQgc2V4cF9vZl90IChUIHQpID0gUG9seS5zZXhwX29mX3QgdC5zZXhwX29mX2FkZHJlc3MgdFxuXG4gIGxldCBjbG9zZV93aGVuX2N1cnJlbnRfY29ubmVjdGlvbl9pc19jbG9zZWQgKFQgdCkgPVxuICAgIFBvbHkuY2xvc2Vfd2hlbl9jdXJyZW50X2Nvbm5lY3Rpb25faXNfY2xvc2VkIHRcbiAgOztcblxuICBsZXQgY2xvc2VfZmluaXNoZWQgKFQgdCkgPSBQb2x5LmNsb3NlX2ZpbmlzaGVkIHRcbiAgbGV0IGlzX2Nsb3NlZCAoVCB0KSA9IFBvbHkuaXNfY2xvc2VkIHRcbiAgbGV0IGNsb3NlIChUIHQpID0gUG9seS5jbG9zZSB0XG4gIGxldCBzZXJ2ZXJfbmFtZSAoVCB0KSA9IFBvbHkuc2VydmVyX25hbWUgdFxuICBsZXQgY3VycmVudF9jb25uZWN0aW9uIChUIHQpID0gUG9seS5jdXJyZW50X2Nvbm5lY3Rpb24gdFxuICBsZXQgY29ubmVjdGVkX29yX2ZhaWxlZF90b19jb25uZWN0IChUIHQpID0gUG9seS5jb25uZWN0ZWRfb3JfZmFpbGVkX3RvX2Nvbm5lY3QgdFxuICBsZXQgY29ubmVjdGVkIChUIHQpID0gUG9seS5jb25uZWN0ZWQgdFxuXG4gIGxldCBjcmVhdGVcbiAgICAgICAgfnNlcnZlcl9uYW1lXG4gICAgICAgID9vbl9ldmVudFxuICAgICAgICA/cmV0cnlfZGVsYXlcbiAgICAgICAgP3JhbmRvbV9zdGF0ZVxuICAgICAgICA/dGltZV9zb3VyY2VcbiAgICAgICAgfmNvbm5lY3RcbiAgICAgICAgfmFkZHJlc3NcbiAgICAgICAgZ2V0X2FkZHJlc3NcbiAgICA9XG4gICAgVFxuICAgICAgKFBvbHkuY3JlYXRlXG4gICAgICAgICB+c2VydmVyX25hbWVcbiAgICAgICAgID9vbl9ldmVudFxuICAgICAgICAgP3JldHJ5X2RlbGF5XG4gICAgICAgICA/cmFuZG9tX3N0YXRlXG4gICAgICAgICA/dGltZV9zb3VyY2VcbiAgICAgICAgIH5jb25uZWN0XG4gICAgICAgICB+YWRkcmVzc1xuICAgICAgICAgZ2V0X2FkZHJlc3MpXG4gIDs7XG5lbmRcbiJdfQ==
