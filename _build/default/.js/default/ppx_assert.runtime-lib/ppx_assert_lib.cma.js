// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1+5.8.1

//# unitInfo: Provides: Ppx_assert_lib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Ppx_assert_lib = [0];
   runtime.caml_register_global(0, Ppx_assert_lib, "Ppx_assert_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_assert_lib__Runtime
//# unitInfo: Requires: Assert_failure, Base, Base__Source_code_position, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = ": ",
    Base = global_data.Base,
    Base_Source_code_position = global_data.Base__Source_code_position,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    E = [248, "Ppx_assert_lib.Runtime.E", runtime.caml_fresh_oo_id(0)],
    _a_ = [0, "runtime-lib/runtime.ml.E"],
    _b_ = [0, "_none_", 0, -1];
   caml_call4
    (Sexplib0_Sexp_conv[70][1],
     0,
     0,
     E,
     function(param){
      if(param[1] !== E)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
      var
       arg1_002 = param[3],
       arg0_001 = param[2],
       res0_003 = caml_call1(Base[164], arg0_001),
       res1_004 = caml_call1(Base[84][4], arg1_002);
      return [1, [0, _a_, [0, res0_003, [0, res1_004, 0]]]];
     });
   var
    _c_ = [0, "Stack"],
    _d_ = [0, "Loc"],
    _e_ = [0, "Value"],
    cst_predicate_failed = "predicate failed";
   function exn_sexp_style(message, pos, x_005, tag, body){
    if(message)
     var
      s = message[1],
      _j_ = caml_call2(Base[197], cst, tag),
      message$0 = caml_call2(Base[197], s, _j_);
    else
     var message$0 = tag;
    var
     _k_ =
       x_005
        ? [0,
          [1,
           [0,
            _c_,
            [0, caml_call2(Base[139], Base_Source_code_position[3], x_005), 0]]],
          0]
        : 0,
     _l_ = caml_call2(Base[178], [0, [1, [0, _d_, [0, [0, pos], 0]]], 0], _k_),
     sexp = [1, caml_call2(Base[178], body, _l_)];
    return [0, E, message$0, sexp];
   }
   function test_pred(pos, sexpifier, here, message, predicate, t){
    var _i_ = 1 - caml_call1(predicate, t);
    if(_i_)
     throw caml_maybe_attach_backtrace
            (exn_sexp_style
              (message,
               pos,
               here,
               cst_predicate_failed,
               [0, [1, [0, _e_, [0, caml_call1(sexpifier, t), 0]]], 0]),
             1);
    return _i_;
   }
   var
    r_diff = [0, 0],
    _f_ = [0, "vs"],
    cst_comparison_failed = "comparison failed",
    _g_ = [0, "got"],
    _h_ = [0, "expected"],
    cst_got_unexpected_result = "got unexpected result";
   function set_diff_function(f){r_diff[1] = f; return 0;}
   function test_result_or_eq(sexpifier, comparator, equal, expect$0, got$0){
    if(equal)
     var f = equal[1], pass = caml_call2(f, got$0, expect$0);
    else
     var pass = 0 === caml_call2(comparator, got$0, expect$0) ? 1 : 0;
    if(pass) return 892014833;
    var
     got = caml_call1(sexpifier, got$0),
     expect = caml_call1(sexpifier, expect$0),
     match = r_diff[1];
    if(match){
     var
      diff = match[1],
      from = caml_call2(Base[84][13], 0, expect),
      to = caml_call2(Base[84][13], 0, got);
     caml_call2(diff, from, to);
    }
    return [0, 781116926, [0, expect, got]];
   }
   function test_eq(pos, sexpifier, comparator, here, message, equal, t1, t2){
    var match = test_result_or_eq(sexpifier, comparator, equal, t1, t2);
    if(typeof match === "number") return 0;
    var match$0 = match[2], t2$0 = match$0[2], t1$0 = match$0[1];
    throw caml_maybe_attach_backtrace
           (exn_sexp_style
             (message,
              pos,
              here,
              cst_comparison_failed,
              [0, t1$0, [0, _f_, [0, t2$0, 0]]]),
            1);
   }
   function test_result
   (pos, sexpifier, comparator, here, message, equal, expect, got){
    var match = test_result_or_eq(sexpifier, comparator, equal, expect, got);
    if(typeof match === "number") return 0;
    var match$0 = match[2], got$0 = match$0[2], expect$0 = match$0[1];
    throw caml_maybe_attach_backtrace
           (exn_sexp_style
             (message,
              pos,
              here,
              cst_got_unexpected_result,
              [0,
               [1, [0, _h_, [0, expect$0, 0]]],
               [0, [1, [0, _g_, [0, got$0, 0]]], 0]]),
            1);
   }
   var
    Ppx_assert_lib_Runtime =
      [0, test_pred, test_eq, test_result, set_diff_function];
   runtime.caml_register_global
    (17, Ppx_assert_lib_Runtime, "Ppx_assert_lib__Runtime");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcHhfYXNzZXJ0X2xpYi5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiZXhuX3NleHBfc3R5bGUiLCJtZXNzYWdlIiwicG9zIiwieF8wMDUiLCJ0YWciLCJib2R5IiwicyIsIm1lc3NhZ2UkMCIsInNleHAiLCJ0ZXN0X3ByZWQiLCJzZXhwaWZpZXIiLCJoZXJlIiwicHJlZGljYXRlIiwidCIsInJfZGlmZiIsInNldF9kaWZmX2Z1bmN0aW9uIiwiZiIsInRlc3RfcmVzdWx0X29yX2VxIiwiY29tcGFyYXRvciIsImVxdWFsIiwiZXhwZWN0JDAiLCJnb3QkMCIsInBhc3MiLCJnb3QiLCJleHBlY3QiLCJkaWZmIiwiZnJvbSIsInRvIiwidGVzdF9lcSIsInQxIiwidDIiLCJ0MiQwIiwidDEkMCIsInRlc3RfcmVzdWx0Il0sInNvdXJjZXMiOlsiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9wcHhfYXNzZXJ0L3J1bnRpbWUtbGliL3J1bnRpbWUubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7R0F5QkE7Ozs7Ozs7SUFBQTs7Ozs7Ozs7O007Ozs7Ozs7Ozs7Ozs7O1lBRUlBLGVBQWdCQyxTQUFTQyxLQUFLQyxPQUFNQyxLQUFJQztJQUMxQyxHQURrQko7S0FJQTtNQUFUSyxJQUpTTDtNQUlBLE1BQUEsMkJBSm9CRztNQUNsQ0csWUFHVSxzQkFBTEQ7O1NBSExDLFlBRGtDSDtJQU10QztLQUFBO09BTmdDRDs7Ozs7b0VBQUFBOzs7S0FTMUIsTUFBQSwrQ0FUcUJEO0tBTXZCTSxXQUNRLHNCQVA4Qkg7SUFxQjFDLGNBcEJJRSxXQUtBQztHQWVhO1lBT2ZDLFVBQVdQLEtBQUtRLFdBQVdDLE1BQU1WLFNBQVFXLFdBQVVDO0lBQzlDLGNBQUEsV0FEb0NELFdBQVVDOztLQUU3QyxNQUFBO2FBOUJOYjtlQTRCaUNDO2VBQXRCQztlQUFnQlM7O29DQUhHLFdBR2RELFdBQW1DRzs7SUFDOUM7R0FDaUQ7R0FFSztJQUEzREM7Ozs7OztZQUNBQyxrQkFBa0JDLEdBRGxCRixZQUNrQkUsWUFBZTtZQWNqQ0Msa0JBQW1CUCxXQUFXUSxZQUFZQyxPQUFPQyxVQUFRQztJQUMzRCxHQUQ0Q0Y7U0FJbkNILElBSm1DRyxVQUN4Q0csT0FHVSxXQUFMTixHQUprREssT0FBUkQ7O1NBQy9DRSxhQUVRLFdBSG9CSixZQUEyQkcsT0FBUkQ7SUFNbkQsR0FMSUUsTUFNQztJQWxCSztLQUFOQyxNQUFNLFdBV1diLFdBQXNDVztLQVZ2REcsU0FBUyxXQVVRZCxXQUE4QlU7S0FUbkQsUUFORU47O0tBU1k7TUFEUFc7TUFDREMsT0FBUSw0QkFKVkY7TUFLRUcsS0FBUSw0QkFOVko7S0FPRixXQUhLRSxNQUNEQyxNQUNBQzs7SUFHTiwwQkFSSUgsUUFEQUQ7R0FtQmlEO1lBU25ESyxRQUFTMUIsS0FBS1EsV0FBV1EsWUFBWVAsTUFBTVYsU0FBU2tCLE9BQU1VLElBQUdDO0lBQ3pELFlBbEJKYixrQkFpQmNQLFdBQVdRLFlBQTJCQyxPQUFNVSxJQUFHQztrQ0FFcEQ7NEJBVG9DQyxtQkFBSkM7SUFVakIsTUFBQTtZQW5FeEJoQztjQWdFMkNDO2NBQWxDQztjQUE0QlM7O2tCQVBJcUIsbUJBQUlEOztHQVVvQjtZQVFqREU7SUFBYS9CLEtBQUtRLFdBQVdRLFlBQVlQLE1BQU1WLFNBQVNrQixPQUFPSyxRQUFRRDtJQUNuRixZQTdCSk4sa0JBNEJrQ1AsV0FBV1EsWUFBMkJDLE9BQU9LLFFBQVFEO2tDQUU5RTs0QkFSNENGLG9CQUFSRDtJQVNoQixNQUFBO1lBOUU3QnBCO2NBMkUrREM7Y0FBbENDO2NBQTRCUzs7O2dDQU5aUztvQ0FBUUM7O0dBUzBCOzs7VUFsRC9FWixXQW9DQW1CLFNBV2dCSyxhQTFDaEJsQjs7OztFIiwic291cmNlc0NvbnRlbnQiOlsib3BlbiBCYXNlXG5cbnR5cGUgJ2EgdGVzdF9wcmVkXG4gID0gP2hlcmU6TGV4aW5nLnBvc2l0aW9uIGxpc3RcbiAgLT4gP21lc3NhZ2U6c3RyaW5nXG4gIC0+ICgnYSAtPiBib29sKVxuICAtPiAnYVxuICAtPiB1bml0XG5cbnR5cGUgJ2EgdGVzdF9lcVxuICA9ID9oZXJlOkxleGluZy5wb3NpdGlvbiBsaXN0XG4gIC0+ID9tZXNzYWdlOnN0cmluZ1xuICAtPiA/ZXF1YWw6KCdhIC0+ICdhIC0+IGJvb2wpXG4gIC0+ICdhXG4gIC0+ICdhXG4gIC0+IHVuaXRcblxudHlwZSAnYSB0ZXN0X3Jlc3VsdFxuICA9ID9oZXJlOkxleGluZy5wb3NpdGlvbiBsaXN0XG4gIC0+ID9tZXNzYWdlOnN0cmluZ1xuICAtPiA/ZXF1YWw6KCdhIC0+ICdhIC0+IGJvb2wpXG4gIC0+IGV4cGVjdDonYVxuICAtPiAnYVxuICAtPiB1bml0XG5cbmV4Y2VwdGlvbiBFIG9mIHN0cmluZyAqIFNleHAudCBbQEBkZXJpdmluZyBzZXhwXVxuXG5sZXQgZXhuX3NleHBfc3R5bGUgfm1lc3NhZ2UgfnBvcyB+aGVyZSB+dGFnIGJvZHkgPVxuICBsZXQgbWVzc2FnZSA9XG4gICAgbWF0Y2ggbWVzc2FnZSB3aXRoXG4gICAgfCBOb25lIC0+IHRhZ1xuICAgIHwgU29tZSBzIC0+IHMgXiBcIjogXCIgXiB0YWdcbiAgaW5cbiAgbGV0IHNleHAgPVxuICAgIFNleHAuTGlzdCAoXG4gICAgICBib2R5XG4gICAgICBAIFsgU2V4cC5MaXN0IFsgU2V4cC5BdG9tIFwiTG9jXCI7IFNleHAuQXRvbSBwb3MgXSBdXG4gICAgICBAIGJlZ2luIG1hdGNoIGhlcmUgd2l0aFxuICAgICAgICB8IFtdIC0+IFtdXG4gICAgICAgIHwgXyAtPiBbIFNleHAuTGlzdCBbIFNleHAuQXRvbSBcIlN0YWNrXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgWyVzZXhwX29mOiBTb3VyY2VfY29kZV9wb3NpdGlvbi50IGxpc3RdIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIF0gXVxuICAgICAgZW5kXG4gICAgKVxuICBpblxuICAoKiBIZXJlIGFuZCBpbiBvdGhlciBwbGFjZXMgd2UgcmV0dXJuIGV4Y2VwdGlvbnMsIHJhdGhlciB0aGFuIGRpcmVjdGx5IHJhaXNpbmcsIGFuZFxuICAgICBpbnN0ZWFkIHJhaXNlIGF0IHRoZSBsYXRlc3QgbW9tZW50IHBvc3NpYmxlLCBzbyBiYWNrdHJhY2UgZG9uJ3QgaW5jbHVkZSBub2lzZSBmcm9tXG4gICAgIHRoZXNlIGZ1bmN0aW9ucyB0aGF0IGNvbnN0cnVjdCBleGNlcHRpb25zLiAqKVxuICBFIChtZXNzYWdlLCBzZXhwKVxuXG5sZXQgW0Bjb2xkXSBleG5fdGVzdF9wcmVkIH5tZXNzYWdlIH5wb3MgfmhlcmUgfnNleHBpZmllciB0ID1cbiAgZXhuX3NleHBfc3R5bGUgfm1lc3NhZ2UgfnBvcyB+aGVyZSB+dGFnOlwicHJlZGljYXRlIGZhaWxlZFwiIFtcbiAgICBTZXhwLkxpc3QgW1NleHAuQXRvbSBcIlZhbHVlXCI7IHNleHBpZmllciB0XVxuICBdXG5cbmxldCB0ZXN0X3ByZWQgfnBvcyB+c2V4cGlmaWVyIH5oZXJlID9tZXNzYWdlIHByZWRpY2F0ZSB0ID1cbiAgaWYgbm90IChwcmVkaWNhdGUgdCkgdGhlblxuICAgIHJhaXNlIChleG5fdGVzdF9wcmVkIH5tZXNzYWdlIH5wb3MgfmhlcmUgfnNleHBpZmllciB0KVxuXG5sZXQgcl9kaWZmIDogKGZyb21fOnN0cmluZyAtPiB0b186c3RyaW5nIC0+IHVuaXQpIG9wdGlvbiByZWYgPSByZWYgICBOb25lXG5sZXQgc2V0X2RpZmZfZnVuY3Rpb24gZiA9IHJfZGlmZiA6PSBmXG5cbmxldCBbQGNvbGRdIHRlc3RfcmVzdWx0X29yX2VxX2ZhaWxlZCB+c2V4cGlmaWVyIH5leHBlY3QgfmdvdCA9XG4gIGxldCBnb3QgPSBzZXhwaWZpZXIgZ290IGluXG4gIGxldCBleHBlY3QgPSBzZXhwaWZpZXIgZXhwZWN0IGluXG4gIGJlZ2luIG1hdGNoICFyX2RpZmYgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGRpZmYgLT5cbiAgICBsZXQgZnJvbV8gPSBTZXhwLnRvX3N0cmluZ19odW0gZXhwZWN0IGluXG4gICAgbGV0IHRvXyAgID0gU2V4cC50b19zdHJpbmdfaHVtIGdvdCBpblxuICAgIGRpZmYgfmZyb21fIH50b19cbiAgZW5kO1xuICBgRmFpbCAoZXhwZWN0LCBnb3QpXG5cbmxldCB0ZXN0X3Jlc3VsdF9vcl9lcSB+c2V4cGlmaWVyIH5jb21wYXJhdG9yIH5lcXVhbCB+ZXhwZWN0IH5nb3QgPVxuICBsZXQgcGFzcyA9XG4gICAgbWF0Y2ggZXF1YWwgd2l0aFxuICAgIHwgTm9uZSAtPiBjb21wYXJhdG9yIGdvdCBleHBlY3QgPSAwXG4gICAgfCBTb21lIGYgLT4gZiBnb3QgZXhwZWN0XG4gIGluXG4gIGlmIHBhc3NcbiAgdGhlbiBgUGFzc1xuICBlbHNlIHRlc3RfcmVzdWx0X29yX2VxX2ZhaWxlZCB+c2V4cGlmaWVyIH5leHBlY3QgfmdvdFxuXG5sZXQgW0Bjb2xkXSBleG5fdGVzdF9lcSB+bWVzc2FnZSB+cG9zIH5oZXJlIH50MSB+dDIgPVxuICBleG5fc2V4cF9zdHlsZSB+bWVzc2FnZSB+cG9zIH5oZXJlIH50YWc6XCJjb21wYXJpc29uIGZhaWxlZFwiIFtcbiAgICB0MTtcbiAgICBTZXhwLkF0b20gXCJ2c1wiO1xuICAgIHQyO1xuICBdXG5cbmxldCB0ZXN0X2VxIH5wb3MgfnNleHBpZmllciB+Y29tcGFyYXRvciB+aGVyZSA/bWVzc2FnZSA/ZXF1YWwgdDEgdDIgPVxuICBtYXRjaCB0ZXN0X3Jlc3VsdF9vcl9lcSB+c2V4cGlmaWVyIH5jb21wYXJhdG9yIH5lcXVhbCB+ZXhwZWN0OnQxIH5nb3Q6dDIgd2l0aFxuICB8IGBQYXNzIC0+ICgpXG4gIHwgYEZhaWwgKHQxLCB0MikgLT4gcmFpc2UgKGV4bl90ZXN0X2VxIH5tZXNzYWdlIH5wb3MgfmhlcmUgfnQxIH50MilcblxubGV0IFtAY29sZF0gZXhuX3Rlc3RfcmVzdWx0IH5tZXNzYWdlIH5wb3MgfmhlcmUgfmV4cGVjdCB+Z290ID1cbiAgZXhuX3NleHBfc3R5bGUgfm1lc3NhZ2UgfnBvcyB+aGVyZSB+dGFnOlwiZ290IHVuZXhwZWN0ZWQgcmVzdWx0XCIgW1xuICAgIFNleHAuTGlzdCBbU2V4cC5BdG9tIFwiZXhwZWN0ZWRcIjsgZXhwZWN0XTtcbiAgICBTZXhwLkxpc3QgW1NleHAuQXRvbSBcImdvdFwiOyBnb3RdO1xuICBdXG5cbmxldFtAd2FybmluZyBcIi0xNlwiXSB0ZXN0X3Jlc3VsdCB+cG9zIH5zZXhwaWZpZXIgfmNvbXBhcmF0b3IgfmhlcmUgP21lc3NhZ2UgP2VxdWFsIH5leHBlY3QgfmdvdCA9XG4gIG1hdGNoIHRlc3RfcmVzdWx0X29yX2VxIH5zZXhwaWZpZXIgfmNvbXBhcmF0b3IgfmVxdWFsIH5leHBlY3QgfmdvdCB3aXRoXG4gIHwgYFBhc3MgLT4gKClcbiAgfCBgRmFpbCAoZXhwZWN0LCBnb3QpIC0+IHJhaXNlIChleG5fdGVzdF9yZXN1bHQgfm1lc3NhZ2UgfnBvcyB+aGVyZSB+ZXhwZWN0IH5nb3QpXG4iXX0=
