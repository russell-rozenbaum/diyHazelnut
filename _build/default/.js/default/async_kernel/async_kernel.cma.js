// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1+5.8.1

//# unitInfo: Provides: Async_kernel__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Async_kernel = [0];
   runtime.caml_register_global(0, Async_kernel, "Async_kernel__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Time_ns
//# unitInfo: Requires: Core__Time_ns, Core__Time_ns_alternate_sexp, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Time_ns = "Async_kernel__Time_ns",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Time_ns = global_data.Core__Time_ns,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Time_ns_alternate_sexp = global_data.Core__Time_ns_alternate_sexp;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Time_ns);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/time_ns.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    typerep_of_t = Core_Time_ns_alternate_sexp[1],
    typename_of_t = Core_Time_ns_alternate_sexp[2],
    bin_size_t = Core_Time_ns_alternate_sexp[3],
    bin_write_t = Core_Time_ns_alternate_sexp[4],
    bin_read_t = Core_Time_ns_alternate_sexp[5],
    bin_read_t$0 = Core_Time_ns_alternate_sexp[6],
    bin_shape_t = Core_Time_ns_alternate_sexp[7],
    bin_writer_t = Core_Time_ns_alternate_sexp[8],
    bin_reader_t = Core_Time_ns_alternate_sexp[9],
    bin_t = Core_Time_ns_alternate_sexp[10],
    quickcheck_generator = Core_Time_ns_alternate_sexp[11],
    quickcheck_observer = Core_Time_ns_alternate_sexp[12],
    quickcheck_shrinker = Core_Time_ns_alternate_sexp[13],
    gen_incl = Core_Time_ns_alternate_sexp[14],
    gen_uniform_incl = Core_Time_ns_alternate_sexp[15],
    is_earlier = Core_Time_ns_alternate_sexp[16],
    is_later = Core_Time_ns_alternate_sexp[17],
    of_date_ofday = Core_Time_ns_alternate_sexp[18],
    of_date_ofday_precise = Core_Time_ns_alternate_sexp[19],
    to_date_ofday = Core_Time_ns_alternate_sexp[20],
    to_date_ofday_precise = Core_Time_ns_alternate_sexp[21],
    to_date = Core_Time_ns_alternate_sexp[22],
    to_ofday = Core_Time_ns_alternate_sexp[23],
    reset_date_cache = Core_Time_ns_alternate_sexp[24],
    convert = Core_Time_ns_alternate_sexp[25],
    utc_offset = Core_Time_ns_alternate_sexp[26],
    to_filename_string = Core_Time_ns_alternate_sexp[27],
    of_filename_string = Core_Time_ns_alternate_sexp[28],
    to_string_abs = Core_Time_ns_alternate_sexp[29],
    to_string_abs_trimmed = Core_Time_ns_alternate_sexp[30],
    to_string_abs_parts = Core_Time_ns_alternate_sexp[31],
    to_string_trimmed = Core_Time_ns_alternate_sexp[32],
    to_sec_string = Core_Time_ns_alternate_sexp[33],
    to_sec_string_with_zone = Core_Time_ns_alternate_sexp[34],
    of_localized_string = Core_Time_ns_alternate_sexp[35],
    of_string_gen = Core_Time_ns_alternate_sexp[36],
    to_string_iso8601_basic = Core_Time_ns_alternate_sexp[37],
    occurrence = Core_Time_ns_alternate_sexp[38],
    of_string = Core_Time_ns_alternate_sexp[39],
    of_string_with_utc_offset = Core_Time_ns_alternate_sexp[40],
    to_string = Core_Time_ns_alternate_sexp[41],
    to_string_utc = Core_Time_ns_alternate_sexp[42],
    epoch = Core_Time_ns_alternate_sexp[43],
    min_value_representable = Core_Time_ns_alternate_sexp[44],
    max_value_representable = Core_Time_ns_alternate_sexp[45],
    min_value_for_1us_rounding = Core_Time_ns_alternate_sexp[46],
    max_value_for_1us_rounding = Core_Time_ns_alternate_sexp[47],
    min_value = Core_Time_ns_alternate_sexp[48],
    max_value = Core_Time_ns_alternate_sexp[49],
    now = Core_Time_ns_alternate_sexp[50],
    add = Core_Time_ns_alternate_sexp[51],
    add_saturating = Core_Time_ns_alternate_sexp[52],
    sub_saturating = Core_Time_ns_alternate_sexp[53],
    sub = Core_Time_ns_alternate_sexp[54],
    next = Core_Time_ns_alternate_sexp[55],
    prev = Core_Time_ns_alternate_sexp[56],
    diff = Core_Time_ns_alternate_sexp[57],
    abs_diff = Core_Time_ns_alternate_sexp[58],
    to_span_since_epoch = Core_Time_ns_alternate_sexp[59],
    of_span_since_epoch = Core_Time_ns_alternate_sexp[60],
    to_int63_ns_since_epoch = Core_Time_ns_alternate_sexp[61],
    of_int63_ns_since_epoch = Core_Time_ns_alternate_sexp[62],
    to_int_ns_since_epoch = Core_Time_ns_alternate_sexp[63],
    of_int_ns_since_epoch = Core_Time_ns_alternate_sexp[64],
    next_multiple = Core_Time_ns_alternate_sexp[65],
    prev_multiple = Core_Time_ns_alternate_sexp[66],
    random = Core_Time_ns_alternate_sexp[67],
    of_time = Core_Time_ns_alternate_sexp[68],
    to_time = Core_Time_ns_alternate_sexp[69],
    to_time_float_round_nearest = Core_Time_ns_alternate_sexp[70],
    to_time_float_round_nearest_mi = Core_Time_ns_alternate_sexp[71],
    of_time_float_round_nearest = Core_Time_ns_alternate_sexp[72],
    of_time_float_round_nearest_mi = Core_Time_ns_alternate_sexp[73],
    arg_type = Core_Time_ns_alternate_sexp[74],
    get_sexp_zone = Core_Time_ns_alternate_sexp[75],
    interruptible_pause = Core_Time_ns_alternate_sexp[76],
    of_date_ofday_zoned = Core_Time_ns_alternate_sexp[77],
    of_string_abs = Core_Time_ns_alternate_sexp[78],
    of_string_fix_proto = Core_Time_ns_alternate_sexp[79],
    pause = Core_Time_ns_alternate_sexp[80],
    pause_forever = Core_Time_ns_alternate_sexp[81],
    pp = Core_Time_ns_alternate_sexp[82],
    set_sexp_zone = Core_Time_ns_alternate_sexp[83],
    sexp_of_t_abs = Core_Time_ns_alternate_sexp[84],
    t_of_sexp_abs = Core_Time_ns_alternate_sexp[85],
    to_date_ofday_zoned = Core_Time_ns_alternate_sexp[86],
    to_ofday_zoned = Core_Time_ns_alternate_sexp[87],
    to_string_fix_proto = Core_Time_ns_alternate_sexp[88],
    hash_fold_t = Core_Time_ns_alternate_sexp[89],
    hash = Core_Time_ns_alternate_sexp[90],
    t_of_sexp = Core_Time_ns_alternate_sexp[91],
    sexp_of_t = Core_Time_ns_alternate_sexp[92],
    t_sexp_grammar = Core_Time_ns_alternate_sexp[93],
    symbol = Core_Time_ns_alternate_sexp[94],
    symbol$0 = Core_Time_ns_alternate_sexp[95],
    symbol$1 = Core_Time_ns_alternate_sexp[96],
    symbol$2 = Core_Time_ns_alternate_sexp[97],
    symbol$3 = Core_Time_ns_alternate_sexp[98],
    symbol$4 = Core_Time_ns_alternate_sexp[99],
    equal = Core_Time_ns_alternate_sexp[100],
    compare = Core_Time_ns_alternate_sexp[101],
    min = Core_Time_ns_alternate_sexp[102],
    max = Core_Time_ns_alternate_sexp[103],
    ascending = Core_Time_ns_alternate_sexp[104],
    descending = Core_Time_ns_alternate_sexp[105],
    between = Core_Time_ns_alternate_sexp[106],
    clamp_exn = Core_Time_ns_alternate_sexp[107],
    clamp = Core_Time_ns_alternate_sexp[108],
    comparator = Core_Time_ns_alternate_sexp[109],
    validate_lbound = Core_Time_ns_alternate_sexp[110],
    validate_ubound = Core_Time_ns_alternate_sexp[111],
    validate_bound = Core_Time_ns_alternate_sexp[112];
   function after(t, span){
    var result = caml_call2(add, t, span);
    if
     (caml_call2(Core_Time_ns[1][18], span, Core_Time_ns[1][75])
      && caml_call2(symbol$3, result, t))
     return max_value_for_1us_rounding;
    return result;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Time_ns);
   var
    Async_kernel_Time_ns =
      [0,
       typerep_of_t,
       typename_of_t,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       quickcheck_generator,
       quickcheck_observer,
       quickcheck_shrinker,
       gen_incl,
       gen_uniform_incl,
       is_earlier,
       is_later,
       of_date_ofday,
       of_date_ofday_precise,
       to_date_ofday,
       to_date_ofday_precise,
       to_date,
       to_ofday,
       reset_date_cache,
       convert,
       utc_offset,
       to_filename_string,
       of_filename_string,
       to_string_abs,
       to_string_abs_trimmed,
       to_string_abs_parts,
       to_string_trimmed,
       to_sec_string,
       to_sec_string_with_zone,
       of_localized_string,
       of_string_gen,
       to_string_iso8601_basic,
       occurrence,
       of_string,
       of_string_with_utc_offset,
       to_string,
       to_string_utc,
       epoch,
       min_value_representable,
       max_value_representable,
       min_value_for_1us_rounding,
       max_value_for_1us_rounding,
       min_value,
       max_value,
       now,
       add,
       add_saturating,
       sub_saturating,
       sub,
       next,
       prev,
       diff,
       abs_diff,
       to_span_since_epoch,
       of_span_since_epoch,
       to_int63_ns_since_epoch,
       of_int63_ns_since_epoch,
       to_int_ns_since_epoch,
       of_int_ns_since_epoch,
       next_multiple,
       prev_multiple,
       random,
       of_time,
       to_time,
       to_time_float_round_nearest,
       to_time_float_round_nearest_mi,
       of_time_float_round_nearest,
       of_time_float_round_nearest_mi,
       arg_type,
       get_sexp_zone,
       interruptible_pause,
       of_date_ofday_zoned,
       of_string_abs,
       of_string_fix_proto,
       pause,
       pause_forever,
       pp,
       set_sexp_zone,
       sexp_of_t_abs,
       t_of_sexp_abs,
       to_date_ofday_zoned,
       to_ofday_zoned,
       to_string_fix_proto,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       after];
   runtime.caml_register_global
    (13, Async_kernel_Time_ns, cst_Async_kernel_Time_ns);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Debug
//# unitInfo: Requires: Async_kernel__Time_ns, Async_kernel_config, Core, Core__Sexp, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Debug = "Async_kernel__Debug",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Core_Sexp = global_data.Core__Sexp,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Async_kernel_config = global_data.Async_kernel_config,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Debug);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/debug.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    include = Async_kernel_config[14],
    clock = include[1],
    fd = include[2],
    file_descr_watcher = include[3],
    finalizers = include[4],
    interruptor = include[5],
    monitor = include[6],
    monitor_send_exn = include[7],
    parallel = include[8],
    reader = include[9],
    scheduler = include[10],
    shutdown = include[11],
    thread_pool = include[12],
    thread_safe = include[13],
    writer = include[14],
    _a_ = [0, [2, 0, [12, 10, [10, 0]]], "%s\n%!"];
   function log(arg2_003, arg3_004, sexp_of_a){
    var
     arg1_002 = caml_call1(Async_kernel_Time_ns[50], 0),
     arg0_001 = caml_call1(Async_kernel_config[31][1], 0),
     res0_005 = caml_call1(Core_Sexp[90], arg0_001),
     res1_006 = caml_call1(Async_kernel_Time_ns[92], arg1_002),
     res2_007 = caml_call1(Core[471], arg2_003),
     res3_008 = caml_call1(sexp_of_a, arg3_004),
     _b_ =
       caml_call2
        (Core_Sexp[81],
         0,
         [1, [0, res0_005, [0, res1_006, [0, res2_007, [0, res3_008, 0]]]]]);
    return caml_call2(Core[231], _a_, _b_);
   }
   function log_string(message){return log(message, 0, Core[518]);}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Debug);
   var
    Async_kernel_Debug =
      [0,
       clock,
       fd,
       file_descr_watcher,
       finalizers,
       interruptor,
       monitor,
       monitor_send_exn,
       parallel,
       reader,
       scheduler,
       shutdown,
       thread_pool,
       thread_safe,
       writer,
       log,
       log_string];
   runtime.caml_register_global
    (16, Async_kernel_Debug, cst_Async_kernel_Debug);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Import
//# unitInfo: Requires: Core, Core__Debug, Core__Int, Core__Sexp, Core__String, Core__Time_ns, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Import = "Async_kernel__Import",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Sexp = global_data.Core__Sexp,
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Int = global_data.Core__Int,
    Core_String = global_data.Core__String,
    Core_Debug = global_data.Core__Debug,
    Core_Time_ns = global_data.Core__Time_ns;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Import);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/import.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    include = Core_Int[99],
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    concat = Core_String[32],
    eprint = Core_Debug[1],
    eprint_s = Core_Debug[3],
    eprints = Core_Debug[2],
    _a_ = [0, [2, 0, [12, 10, [10, 0]]], "%s\n%!"];
   function print_s(sexp){
    var _b_ = caml_call2(Core_Sexp[81], 0, sexp);
    return caml_call2(Core[250], _a_, _b_);
   }
   var sec = Core_Time_ns[1][81], Thread = [0], Unix = [0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Import);
   var
    Async_kernel_Import =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       concat,
       eprint,
       eprint_s,
       eprints,
       print_s,
       sec,
       Thread,
       Unix];
   runtime.caml_register_global
    (18, Async_kernel_Import, cst_Async_kernel_Import);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Priority
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Priority = "Async_kernel__Priority",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Priority);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/priority.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, "Low"], _b_ = [0, "Normal"];
   function sexp_of_t(param){return param ? _a_ : _b_;}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Priority);
   var Async_kernel_Priority = [0, sexp_of_t, 0, 1];
   runtime.caml_register_global
    (13, Async_kernel_Priority, cst_Async_kernel_Priority);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Types
//# unitInfo: Requires: CamlinternalMod, Core__Unique_id, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Types = "Async_kernel__Types",
    cst_async_kernel = "async_kernel",
    cst_src_types_ml = "src/types.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    CamlinternalMod = global_data.CamlinternalMod,
    Core_Unique_id = global_data.Core__Unique_id;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Types);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_types_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    Cell =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 37, 2], [0, [0]]),
    Handler =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 42, 2], [0, [0]]),
    Ivar =
      caml_call2
       (CamlinternalMod[1], [0, cst_src_types_ml, 51, 2], [0, [0, [0, [0]]]]),
    Deferred =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 56, 2], [0, [0]]),
    Execution_context =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 66, 2], [0, [0]]),
    Forwarding =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 74, 2], [0, [0]]),
    Monitor =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 88, 2], [0, [0]]),
    Tail =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 93, 2], [0, [0]]),
    Stream =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 102, 2], [0, [0]]);
   caml_call3(CamlinternalMod[2], [0, [0]], Cell, Cell);
   caml_call3(CamlinternalMod[2], [0, [0]], Handler, Handler);
   caml_call3(CamlinternalMod[2], [0, [0, [0, [0]]]], Ivar, Ivar);
   caml_call3(CamlinternalMod[2], [0, [0]], Deferred, Deferred);
   caml_call3
    (CamlinternalMod[2], [0, [0]], Execution_context, Execution_context);
   caml_call3(CamlinternalMod[2], [0, [0]], Forwarding, Forwarding);
   caml_call3(CamlinternalMod[2], [0, [0]], Monitor, Monitor);
   caml_call3(CamlinternalMod[2], [0, [0]], Tail, Tail);
   caml_call3(CamlinternalMod[2], [0, [0]], Stream, Stream);
   function to_repr(t){return t;}
   function of_repr(t){return t;}
   var
    Bvar = [0, of_repr, to_repr],
    Event =
      caml_call2
       (CamlinternalMod[1],
        [0, cst_src_types_ml, 155, 2],
        [0, [0, [0, [0]], [0, [0]]]]),
    External_job =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 160, 2], [0, [0]]),
    Job =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 166, 2], [0, [0]]),
    Job_or_event =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 171, 2], [0, [0]]),
    Job_pool =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 176, 2], [0, [0]]),
    Job_queue =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 188, 2], [0, [0]]),
    Jobs =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 198, 2], [0, [0]]),
    Scheduler =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 233, 2], [0, [0]]),
    Cycle_hook =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 238, 2], [0, [0]]),
    Time_source =
      caml_call2(CamlinternalMod[1], [0, cst_src_types_ml, 256, 2], [0, [0]]),
    Very_low_priority_worker =
      caml_call2
       (CamlinternalMod[1], [0, cst_src_types_ml, 270, 2], [0, [0, [0, [0]]]]),
    Cycle_hook_handle = caml_call1(Core_Unique_id[2], [0]),
    Time_source_id = caml_call1(Core_Unique_id[2], [0]);
   caml_call3(CamlinternalMod[2], [0, [0, [0, [0]], [0, [0]]]], Event, Event);
   caml_call3(CamlinternalMod[2], [0, [0]], External_job, External_job);
   caml_call3(CamlinternalMod[2], [0, [0]], Job, Job);
   caml_call3(CamlinternalMod[2], [0, [0]], Job_or_event, Job_or_event);
   caml_call3(CamlinternalMod[2], [0, [0]], Job_pool, Job_pool);
   caml_call3(CamlinternalMod[2], [0, [0]], Job_queue, Job_queue);
   caml_call3(CamlinternalMod[2], [0, [0]], Jobs, Jobs);
   caml_call3(CamlinternalMod[2], [0, [0]], Scheduler, Scheduler);
   caml_call3(CamlinternalMod[2], [0, [0]], Cycle_hook, Cycle_hook);
   caml_call3(CamlinternalMod[2], [0, [0]], Time_source, Time_source);
   caml_call3
    (CamlinternalMod[2],
     [0, [0, [0, [0]]]],
     Very_low_priority_worker,
     Very_low_priority_worker);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Types);
   var
    Async_kernel_Types =
      [0,
       Cell,
       Handler,
       Ivar,
       Deferred,
       Execution_context,
       Forwarding,
       Monitor,
       Tail,
       Stream,
       Bvar,
       Event,
       External_job,
       Job,
       Job_or_event,
       Job_pool,
       Job_queue,
       Jobs,
       Scheduler,
       Cycle_hook,
       Cycle_hook_handle,
       Time_source_id,
       Time_source,
       Very_low_priority_worker];
   runtime.caml_register_global
    (73, Async_kernel_Types, cst_Async_kernel_Types);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Monitor0
//# unitInfo: Requires: Async_kernel__Debug, Base__Field, Core, Core__Bag, Core__Info, Core__List, Core__Sexp, Core__Source_code_position, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexp_hidden_in_test
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Monitor0 = "Async_kernel__Monitor0",
    cst_async_kernel = "async_kernel",
    cst_forwarding = "forwarding",
    cst_handlers_for_all_errors = "handlers_for_all_errors",
    cst_has_seen_error = "has_seen_error",
    cst_here = "here",
    cst_id$0 = "id",
    cst_name = "name",
    cst_next_error = "next_error",
    cst_tails_for_all_errors = "tails_for_all_errors";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    names =
      [0,
       cst_name,
       [0,
        cst_here,
        [0,
         cst_id$0,
         [0,
          cst_next_error,
          [0,
           cst_handlers_for_all_errors,
           [0,
            cst_tails_for_all_errors,
            [0, cst_has_seen_error, [0, cst_forwarding, 0]]]]]]]],
    Core = global_data.Core,
    Sexp_hidden_in_test = global_data.Sexp_hidden_in_test,
    Core_Info = global_data.Core__Info,
    Core_Bag = global_data.Core__Bag,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Core_Sexp = global_data.Core__Sexp,
    Core_List = global_data.Core__List,
    Core_Source_code_position = global_data.Core__Source_code_position,
    Base_Field = global_data.Base__Field,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Monitor0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/monitor0.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var debug = Async_kernel_Debug[6];
   function forwarding(r){return r[8];}
   function set_forwarding(r, v){r[8] = v; return 0;}
   function has_seen_error(r){return r[7];}
   function set_has_seen_error(r, v){r[7] = v; return 0;}
   function tails_for_all_errors(r){return r[6];}
   function set_tails_for_all_errors(r, v){r[6] = v; return 0;}
   function handlers_for_all_errors(r){return r[5];}
   function set_handlers_for_all_errors(r, v){r[5] = v; return 0;}
   function next_error(r){return r[4];}
   function set_next_error(r, v){r[4] = v; return 0;}
   function id(r){return r[3];}
   function here(r){return r[2];}
   function name(r){return r[1];}
   var
    forwarding$0 =
      [0,
       function(param){return 0;},
       cst_forwarding,
       [0, set_forwarding],
       forwarding,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v];
       }],
    has_seen_error$0 =
      [0,
       function(param){return 0;},
       cst_has_seen_error,
       [0, set_has_seen_error],
       has_seen_error,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8]];
       }],
    tails_for_all_errors$0 =
      [0,
       function(param){return 0;},
       cst_tails_for_all_errors,
       [0, set_tails_for_all_errors],
       tails_for_all_errors,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8]];
       }],
    handlers_for_all_errors$0 =
      [0,
       function(param){return 0;},
       cst_handlers_for_all_errors,
       [0, set_handlers_for_all_errors],
       handlers_for_all_errors,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8]];
       }],
    next_error$0 =
      [0,
       function(param){return 0;},
       cst_next_error,
       [0, set_next_error],
       next_error,
       function(r, v){
        return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8]];
       }],
    id$0 =
      [0,
       function(param){return 0;},
       cst_id$0,
       0,
       id,
       function(r, v){
        return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8]];
       }],
    here$0 =
      [0,
       function(param){return 0;},
       cst_here,
       0,
       here,
       function(r, v){
        return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8]];
       }],
    name$0 =
      [0,
       function(param){return 0;},
       cst_name,
       0,
       name,
       function(r, v){
        return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8]];
       }];
   function make_creator
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun,
    compile_acc){
    var
     match = caml_call2(name_fun, name$0, compile_acc),
     compile_acc$0 = match[2],
     name_gen = match[1],
     match$0 = caml_call2(here_fun, here$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     here_gen = match$0[1],
     match$1 = caml_call2(id_fun, id$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     id_gen = match$1[1],
     match$2 = caml_call2(next_error_fun, next_error$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     next_error_gen = match$2[1],
     match$3 =
       caml_call2
        (handlers_for_all_errors_fun,
         handlers_for_all_errors$0,
         compile_acc$3),
     compile_acc$4 = match$3[2],
     handlers_for_all_errors_gen = match$3[1],
     match$4 =
       caml_call2
        (tails_for_all_errors_fun, tails_for_all_errors$0, compile_acc$4),
     compile_acc$5 = match$4[2],
     tails_for_all_errors_gen = match$4[1],
     match$5 = caml_call2(has_seen_error_fun, has_seen_error$0, compile_acc$5),
     compile_acc$6 = match$5[2],
     has_seen_error_gen = match$5[1],
     match$6 = caml_call2(forwarding_fun, forwarding$0, compile_acc$6),
     compile_acc$7 = match$6[2],
     forwarding_gen = match$6[1];
    return [0,
            function(acc){
             var
              name = caml_call1(name_gen, acc),
              here = caml_call1(here_gen, acc),
              id = caml_call1(id_gen, acc),
              next_error = caml_call1(next_error_gen, acc),
              handlers_for_all_errors =
                caml_call1(handlers_for_all_errors_gen, acc),
              tails_for_all_errors = caml_call1(tails_for_all_errors_gen, acc),
              has_seen_error = caml_call1(has_seen_error_gen, acc),
              forwarding = caml_call1(forwarding_gen, acc);
             return [0,
                     name,
                     here,
                     id,
                     next_error,
                     handlers_for_all_errors,
                     tails_for_all_errors,
                     has_seen_error,
                     forwarding];
            },
            compile_acc$7];
   }
   function create
   (name,
    here,
    id,
    next_error,
    handlers_for_all_errors,
    tails_for_all_errors,
    has_seen_error,
    forwarding){
    return [0,
            name,
            here,
            id,
            next_error,
            handlers_for_all_errors,
            tails_for_all_errors,
            has_seen_error,
            forwarding];
   }
   function map
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _am_ = caml_call1(forwarding_fun, forwarding$0),
     _an_ = caml_call1(has_seen_error_fun, has_seen_error$0),
     _ao_ = caml_call1(tails_for_all_errors_fun, tails_for_all_errors$0),
     _ap_ = caml_call1(handlers_for_all_errors_fun, handlers_for_all_errors$0),
     _aq_ = caml_call1(next_error_fun, next_error$0),
     _ar_ = caml_call1(id_fun, id$0),
     _as_ = caml_call1(here_fun, here$0);
    return [0,
            caml_call1(name_fun, name$0),
            _as_,
            _ar_,
            _aq_,
            _ap_,
            _ao_,
            _an_,
            _am_];
   }
   function iter
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    caml_call1(name_fun, name$0);
    caml_call1(here_fun, here$0);
    caml_call1(id_fun, id$0);
    caml_call1(next_error_fun, next_error$0);
    caml_call1(handlers_for_all_errors_fun, handlers_for_all_errors$0);
    caml_call1(tails_for_all_errors_fun, tails_for_all_errors$0);
    caml_call1(has_seen_error_fun, has_seen_error$0);
    return caml_call1(forwarding_fun, forwarding$0);
   }
   function fold
   (init,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    return caml_call2
            (forwarding_fun,
             caml_call2
              (has_seen_error_fun,
               caml_call2
                (tails_for_all_errors_fun,
                 caml_call2
                  (handlers_for_all_errors_fun,
                   caml_call2
                    (next_error_fun,
                     caml_call2
                      (id_fun,
                       caml_call2
                        (here_fun, caml_call2(name_fun, init, name$0), here$0),
                       id$0),
                     next_error$0),
                   handlers_for_all_errors$0),
                 tails_for_all_errors$0),
               has_seen_error$0),
             forwarding$0);
   }
   function map_poly(record){
    var
     _af_ = [0, caml_call1(record[1], forwarding$0), 0],
     _ag_ = [0, caml_call1(record[1], has_seen_error$0), _af_],
     _ah_ = [0, caml_call1(record[1], tails_for_all_errors$0), _ag_],
     _ai_ = [0, caml_call1(record[1], handlers_for_all_errors$0), _ah_],
     _aj_ = [0, caml_call1(record[1], next_error$0), _ai_],
     _ak_ = [0, caml_call1(record[1], id$0), _aj_],
     _al_ = [0, caml_call1(record[1], here$0), _ak_];
    return [0, caml_call1(record[1], name$0), _al_];
   }
   function for_all
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     ___ = caml_call1(name_fun, name$0),
     _$_ = ___ ? caml_call1(here_fun, here$0) : ___,
     _aa_ = _$_ ? caml_call1(id_fun, id$0) : _$_,
     _ab_ = _aa_ ? caml_call1(next_error_fun, next_error$0) : _aa_,
     _ac_ =
       _ab_
        ? caml_call1(handlers_for_all_errors_fun, handlers_for_all_errors$0)
        : _ab_,
     _ad_ =
       _ac_
        ? caml_call1(tails_for_all_errors_fun, tails_for_all_errors$0)
        : _ac_,
     _ae_ = _ad_ ? caml_call1(has_seen_error_fun, has_seen_error$0) : _ad_;
    return _ae_ ? caml_call1(forwarding_fun, forwarding$0) : _ae_;
   }
   function exists
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _Z_ = caml_call1(name_fun, name$0),
     _T_ = _Z_ || caml_call1(here_fun, here$0),
     _U_ = _T_ || caml_call1(id_fun, id$0),
     _V_ = _U_ || caml_call1(next_error_fun, next_error$0),
     _W_ =
       _V_
       || caml_call1(handlers_for_all_errors_fun, handlers_for_all_errors$0),
     _X_ = _W_ || caml_call1(tails_for_all_errors_fun, tails_for_all_errors$0),
     _Y_ = _X_ || caml_call1(has_seen_error_fun, has_seen_error$0);
    return _Y_ ? _Y_ : caml_call1(forwarding_fun, forwarding$0);
   }
   function to_list
   (name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _M_ = [0, caml_call1(forwarding_fun, forwarding$0), 0],
     _N_ = [0, caml_call1(has_seen_error_fun, has_seen_error$0), _M_],
     _O_ =
       [0, caml_call1(tails_for_all_errors_fun, tails_for_all_errors$0), _N_],
     _P_ =
       [0,
        caml_call1(handlers_for_all_errors_fun, handlers_for_all_errors$0),
        _O_],
     _Q_ = [0, caml_call1(next_error_fun, next_error$0), _P_],
     _R_ = [0, caml_call1(id_fun, id$0), _Q_],
     _S_ = [0, caml_call1(here_fun, here$0), _R_];
    return [0, caml_call1(name_fun, name$0), _S_];
   }
   function iter$0
   (record,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    caml_call3(name_fun, name$0, record, record[1]);
    caml_call3(here_fun, here$0, record, record[2]);
    caml_call3(id_fun, id$0, record, record[3]);
    caml_call3(next_error_fun, next_error$0, record, record[4]);
    caml_call3
     (handlers_for_all_errors_fun,
      handlers_for_all_errors$0,
      record,
      record[5]);
    caml_call3
     (tails_for_all_errors_fun, tails_for_all_errors$0, record, record[6]);
    caml_call3(has_seen_error_fun, has_seen_error$0, record, record[7]);
    return caml_call3(forwarding_fun, forwarding$0, record, record[8]);
   }
   function fold$0
   (record,
    init,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _F_ = record[8],
     _G_ = record[7],
     _H_ = record[6],
     _I_ = record[5],
     _J_ = record[4],
     _K_ = record[3],
     _L_ = record[2];
    return caml_call4
            (forwarding_fun,
             caml_call4
              (has_seen_error_fun,
               caml_call4
                (tails_for_all_errors_fun,
                 caml_call4
                  (handlers_for_all_errors_fun,
                   caml_call4
                    (next_error_fun,
                     caml_call4
                      (id_fun,
                       caml_call4
                        (here_fun,
                         caml_call4(name_fun, init, name$0, record, record[1]),
                         here$0,
                         record,
                         _L_),
                       id$0,
                       record,
                       _K_),
                     next_error$0,
                     record,
                     _J_),
                   handlers_for_all_errors$0,
                   record,
                   _I_),
                 tails_for_all_errors$0,
                 record,
                 _H_),
               has_seen_error$0,
               record,
               _G_),
             forwarding$0,
             record,
             _F_);
   }
   function for_all$0
   (record,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _y_ = caml_call3(name_fun, name$0, record, record[1]),
     _z_ = _y_ ? caml_call3(here_fun, here$0, record, record[2]) : _y_,
     _A_ = _z_ ? caml_call3(id_fun, id$0, record, record[3]) : _z_,
     _B_ =
       _A_ ? caml_call3(next_error_fun, next_error$0, record, record[4]) : _A_,
     _C_ =
       _B_
        ? caml_call3
          (handlers_for_all_errors_fun,
           handlers_for_all_errors$0,
           record,
           record[5])
        : _B_,
     _D_ =
       _C_
        ? caml_call3
          (tails_for_all_errors_fun,
           tails_for_all_errors$0,
           record,
           record[6])
        : _C_,
     _E_ =
       _D_
        ? caml_call3(has_seen_error_fun, has_seen_error$0, record, record[7])
        : _D_;
    return _E_
            ? caml_call3(forwarding_fun, forwarding$0, record, record[8])
            : _E_;
   }
   function exists$0
   (record,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _x_ = caml_call3(name_fun, name$0, record, record[1]),
     _r_ = _x_ || caml_call3(here_fun, here$0, record, record[2]),
     _s_ = _r_ || caml_call3(id_fun, id$0, record, record[3]),
     _t_ = _s_ || caml_call3(next_error_fun, next_error$0, record, record[4]),
     _u_ =
       _t_
       ||
        caml_call3
         (handlers_for_all_errors_fun,
          handlers_for_all_errors$0,
          record,
          record[5]),
     _v_ =
       _u_
       ||
        caml_call3
         (tails_for_all_errors_fun, tails_for_all_errors$0, record, record[6]),
     _w_ =
       _v_
       || caml_call3(has_seen_error_fun, has_seen_error$0, record, record[7]);
    return _w_
            ? _w_
            : caml_call3(forwarding_fun, forwarding$0, record, record[8]);
   }
   function to_list$0
   (record,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _k_ = [0, caml_call3(forwarding_fun, forwarding$0, record, record[8]), 0],
     _l_ =
       [0,
        caml_call3(has_seen_error_fun, has_seen_error$0, record, record[7]),
        _k_],
     _m_ =
       [0,
        caml_call3
         (tails_for_all_errors_fun, tails_for_all_errors$0, record, record[6]),
        _l_],
     _n_ =
       [0,
        caml_call3
         (handlers_for_all_errors_fun,
          handlers_for_all_errors$0,
          record,
          record[5]),
        _m_],
     _o_ =
       [0, caml_call3(next_error_fun, next_error$0, record, record[4]), _n_],
     _p_ = [0, caml_call3(id_fun, id$0, record, record[3]), _o_],
     _q_ = [0, caml_call3(here_fun, here$0, record, record[2]), _p_];
    return [0, caml_call3(name_fun, name$0, record, record[1]), _q_];
   }
   function map$0
   (record,
    name_fun,
    here_fun,
    id_fun,
    next_error_fun,
    handlers_for_all_errors_fun,
    tails_for_all_errors_fun,
    has_seen_error_fun,
    forwarding_fun){
    var
     _d_ = caml_call3(forwarding_fun, forwarding$0, record, record[8]),
     _e_ = caml_call3(has_seen_error_fun, has_seen_error$0, record, record[7]),
     _f_ =
       caml_call3
        (tails_for_all_errors_fun, tails_for_all_errors$0, record, record[6]),
     _g_ =
       caml_call3
        (handlers_for_all_errors_fun,
         handlers_for_all_errors$0,
         record,
         record[5]),
     _h_ = caml_call3(next_error_fun, next_error$0, record, record[4]),
     _i_ = caml_call3(id_fun, id$0, record, record[3]),
     _j_ = caml_call3(here_fun, here$0, record, record[2]);
    return [0,
            caml_call3(name_fun, name$0, record, record[1]),
            _j_,
            _i_,
            _h_,
            _g_,
            _f_,
            _e_,
            _d_];
   }
   function set_all_mutable_fields
   (record,
    next_error,
    handlers_for_all_errors,
    tails_for_all_errors,
    has_seen_error,
    forwarding){
    var record$0 = caml_call1(Base_Field[1][1], record);
    record$0[4] = next_error;
    record$0[5] = handlers_for_all_errors;
    record$0[6] = tails_for_all_errors;
    record$0[7] = has_seen_error;
    record$0[8] = forwarding;
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields],
    Fields =
      [0,
       names,
       forwarding$0,
       has_seen_error$0,
       tails_for_all_errors$0,
       handlers_for_all_errors$0,
       next_error$0,
       id$0,
       here$0,
       name$0,
       make_creator,
       create,
       map,
       iter,
       fold,
       map_poly,
       for_all,
       exists,
       to_list,
       Direct];
   function description(t){
    var match = t[2];
    if(! match) return caml_call1(Core_Info[6], t[1]);
    var
     here = match[1],
     _c_ = [0, caml_call1(Core_Source_code_position[1], here), 0];
    return [1, [0, caml_call1(Core_Info[6], t[1]), _c_]];
   }
   function descriptions(t$1){
    var t = t$1, ac = 0;
    for(;;){
     var ac$0 = [0, description(t), ac], match = t[8];
     if(typeof match === "number") return caml_call1(Core_List[34], ac$0);
     var t$0 = match[1];
     t = t$0;
     ac = ac$0;
    }
   }
   function sexp_of_t(t){
    var x_001 = descriptions(t);
    return caml_call2(Core[421], Core_Sexp[90], x_001);
   }
   var r = [0, 0], cst_created_monitor = "created monitor", cst_id = cst_id$0;
   function next_id(param){r[1]++; return r[1];}
   function create_with_parent(here, info, name, parent){
    var id = next_id(0);
    if(info){
     var i = info[1];
     if(name)
      var s = name[1], _a_ = caml_call2(Core_Info[20], i, s);
     else
      var _a_ = i;
     var name$0 = _a_;
    }
    else if(name)
     var s$0 = name[1], name$0 = caml_call1(Core_Info[12], s$0);
    else
     var
      name$0 =
        caml_call5
         (Core_Info[17],
          0,
          0,
          cst_id,
          id,
          function(x_002){
           return caml_call2(Sexp_hidden_in_test[10], Core[356], x_002);
          });
    if(parent)
     var parent$0 = parent[1], _b_ = [0, parent$0];
    else
     var _b_ = 1;
    var
     t = [0, name$0, here, id, [0, 0], caml_call1(Core_Bag[22], 0), 0, 0, _b_];
    if(debug)
     caml_call3(Async_kernel_Debug[15], cst_created_monitor, t, sexp_of_t);
    return t;
   }
   var main = create_with_parent(0, 0, [0, "main"], 0);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Monitor0);
   var
    Async_kernel_Monitor0 =
      [0,
       debug,
       forwarding,
       set_forwarding,
       has_seen_error,
       set_has_seen_error,
       tails_for_all_errors,
       set_tails_for_all_errors,
       handlers_for_all_errors,
       set_handlers_for_all_errors,
       next_error,
       set_next_error,
       id,
       here,
       name,
       Fields,
       description,
       descriptions,
       sexp_of_t,
       next_id,
       create_with_parent,
       main];
   runtime.caml_register_global
    (32, Async_kernel_Monitor0, cst_Async_kernel_Monitor0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Execution_context
//# unitInfo: Requires: Async_kernel__Monitor0, Async_kernel__Priority, Base__Backtrace, Base__Field, Core, Core__Option, Core__Univ_map, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Execution_con = "Async_kernel__Execution_context",
    cst_async_kernel = "async_kernel",
    cst_backtrace_history = "backtrace_history",
    cst_local_storage = "local_storage",
    cst_monitor = "monitor",
    cst_priority = "priority";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    names =
      [0,
       cst_monitor,
       [0,
        cst_priority,
        [0, cst_local_storage, [0, cst_backtrace_history, 0]]]],
    Base_Backtrace = global_data.Base__Backtrace,
    Core_Univ_map = global_data.Core__Univ_map,
    Core_Option = global_data.Core__Option,
    Core = global_data.Core,
    Async_kernel_Priority = global_data.Async_kernel__Priority,
    Async_kernel_Monitor0 = global_data.Async_kernel__Monitor0,
    Base_Field = global_data.Base__Field,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Execution_con);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/execution_context.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function backtrace_history(r){return r[4];}
   function local_storage(r){return r[3];}
   function priority(r){return r[2];}
   function monitor(r){return r[1];}
   var
    backtrace_history$0 =
      [0,
       function(param){return 0;},
       cst_backtrace_history,
       0,
       backtrace_history,
       function(r, v){return [0, r[1], r[2], r[3], v];}],
    local_storage$0 =
      [0,
       function(param){return 0;},
       cst_local_storage,
       0,
       local_storage,
       function(r, v){return [0, r[1], r[2], v, r[4]];}],
    priority$0 =
      [0,
       function(param){return 0;},
       cst_priority,
       0,
       priority,
       function(r, v){return [0, r[1], v, r[3], r[4]];}],
    monitor$0 =
      [0,
       function(param){return 0;},
       cst_monitor,
       0,
       monitor,
       function(r, v){return [0, v, r[2], r[3], r[4]];}];
   function make_creator
   (monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun,
    compile_acc){
    var
     match = caml_call2(monitor_fun, monitor$0, compile_acc),
     compile_acc$0 = match[2],
     monitor_gen = match[1],
     match$0 = caml_call2(priority_fun, priority$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     priority_gen = match$0[1],
     match$1 = caml_call2(local_storage_fun, local_storage$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     local_storage_gen = match$1[1],
     match$2 =
       caml_call2(backtrace_history_fun, backtrace_history$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     backtrace_history_gen = match$2[1];
    return [0,
            function(acc){
             var
              monitor = caml_call1(monitor_gen, acc),
              priority = caml_call1(priority_gen, acc),
              local_storage = caml_call1(local_storage_gen, acc),
              backtrace_history = caml_call1(backtrace_history_gen, acc);
             return [0, monitor, priority, local_storage, backtrace_history];
            },
            compile_acc$3];
   }
   function create(monitor, priority, local_storage, backtrace_history){return [0, monitor, priority, local_storage, backtrace_history];
   }
   function map
   (monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    var
     _L_ = caml_call1(backtrace_history_fun, backtrace_history$0),
     _M_ = caml_call1(local_storage_fun, local_storage$0),
     _N_ = caml_call1(priority_fun, priority$0);
    return [0, caml_call1(monitor_fun, monitor$0), _N_, _M_, _L_];
   }
   function iter
   (monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    caml_call1(monitor_fun, monitor$0);
    caml_call1(priority_fun, priority$0);
    caml_call1(local_storage_fun, local_storage$0);
    return caml_call1(backtrace_history_fun, backtrace_history$0);
   }
   function fold
   (init, monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    return caml_call2
            (backtrace_history_fun,
             caml_call2
              (local_storage_fun,
               caml_call2
                (priority_fun,
                 caml_call2(monitor_fun, init, monitor$0),
                 priority$0),
               local_storage$0),
             backtrace_history$0);
   }
   function map_poly(record){
    var
     _I_ = [0, caml_call1(record[1], backtrace_history$0), 0],
     _J_ = [0, caml_call1(record[1], local_storage$0), _I_],
     _K_ = [0, caml_call1(record[1], priority$0), _J_];
    return [0, caml_call1(record[1], monitor$0), _K_];
   }
   function for_all
   (monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    var
     _F_ = caml_call1(monitor_fun, monitor$0),
     _G_ = _F_ ? caml_call1(priority_fun, priority$0) : _F_,
     _H_ = _G_ ? caml_call1(local_storage_fun, local_storage$0) : _G_;
    return _H_ ? caml_call1(backtrace_history_fun, backtrace_history$0) : _H_;
   }
   function exists
   (monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    var
     _E_ = caml_call1(monitor_fun, monitor$0),
     _C_ = _E_ || caml_call1(priority_fun, priority$0),
     _D_ = _C_ || caml_call1(local_storage_fun, local_storage$0);
    return _D_ ? _D_ : caml_call1(backtrace_history_fun, backtrace_history$0);
   }
   function to_list
   (monitor_fun, priority_fun, local_storage_fun, backtrace_history_fun){
    var
     _z_ = [0, caml_call1(backtrace_history_fun, backtrace_history$0), 0],
     _A_ = [0, caml_call1(local_storage_fun, local_storage$0), _z_],
     _B_ = [0, caml_call1(priority_fun, priority$0), _A_];
    return [0, caml_call1(monitor_fun, monitor$0), _B_];
   }
   function iter$0
   (record,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    caml_call3(monitor_fun, monitor$0, record, record[1]);
    caml_call3(priority_fun, priority$0, record, record[2]);
    caml_call3(local_storage_fun, local_storage$0, record, record[3]);
    return caml_call3
            (backtrace_history_fun, backtrace_history$0, record, record[4]);
   }
   function fold$0
   (record,
    init,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    var _w_ = record[4], _x_ = record[3], _y_ = record[2];
    return caml_call4
            (backtrace_history_fun,
             caml_call4
              (local_storage_fun,
               caml_call4
                (priority_fun,
                 caml_call4(monitor_fun, init, monitor$0, record, record[1]),
                 priority$0,
                 record,
                 _y_),
               local_storage$0,
               record,
               _x_),
             backtrace_history$0,
             record,
             _w_);
   }
   function for_all$0
   (record,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    var
     _t_ = caml_call3(monitor_fun, monitor$0, record, record[1]),
     _u_ = _t_ ? caml_call3(priority_fun, priority$0, record, record[2]) : _t_,
     _v_ =
       _u_
        ? caml_call3(local_storage_fun, local_storage$0, record, record[3])
        : _u_;
    return _v_
            ? caml_call3
              (backtrace_history_fun, backtrace_history$0, record, record[4])
            : _v_;
   }
   function exists$0
   (record,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    var
     _s_ = caml_call3(monitor_fun, monitor$0, record, record[1]),
     _q_ = _s_ || caml_call3(priority_fun, priority$0, record, record[2]),
     _r_ =
       _q_
       || caml_call3(local_storage_fun, local_storage$0, record, record[3]);
    return _r_
            ? _r_
            : caml_call3
              (backtrace_history_fun, backtrace_history$0, record, record[4]);
   }
   function to_list$0
   (record,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    var
     _n_ =
       [0,
        caml_call3
         (backtrace_history_fun, backtrace_history$0, record, record[4]),
        0],
     _o_ =
       [0,
        caml_call3(local_storage_fun, local_storage$0, record, record[3]),
        _n_],
     _p_ = [0, caml_call3(priority_fun, priority$0, record, record[2]), _o_];
    return [0, caml_call3(monitor_fun, monitor$0, record, record[1]), _p_];
   }
   function map$0
   (record,
    monitor_fun,
    priority_fun,
    local_storage_fun,
    backtrace_history_fun){
    var
     _k_ =
       caml_call3
        (backtrace_history_fun, backtrace_history$0, record, record[4]),
     _l_ = caml_call3(local_storage_fun, local_storage$0, record, record[3]),
     _m_ = caml_call3(priority_fun, priority$0, record, record[2]);
    return [0,
            caml_call3(monitor_fun, monitor$0, record, record[1]),
            _m_,
            _l_,
            _k_];
   }
   function set_all_mutable_fields(record){
    caml_call1(Base_Field[1][1], record);
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields],
    _a_ = [0, cst_backtrace_history],
    _b_ = [0, cst_local_storage],
    _c_ = [0, cst_priority],
    _d_ = [0, cst_monitor];
   function sexp_of_t(param){
    var
     backtrace_history_008 = param[4],
     local_storage_006 = param[3],
     priority_004 = param[2],
     monitor_002 = param[1],
     arg_009 = caml_call2(Core[421], Base_Backtrace[1], backtrace_history_008),
     bnds_001 = [0, [1, [0, _a_, [0, arg_009, 0]]], 0],
     arg_007 = caml_call1(Core_Univ_map[2], local_storage_006),
     bnds_001$0 = [0, [1, [0, _b_, [0, arg_007, 0]]], bnds_001],
     arg_005 = caml_call1(Async_kernel_Priority[1], priority_004),
     bnds_001$1 = [0, [1, [0, _c_, [0, arg_005, 0]]], bnds_001$0],
     arg_003 = caml_call1(Async_kernel_Monitor0[18], monitor_002),
     bnds_001$2 = [0, [1, [0, _d_, [0, arg_003, 0]]], bnds_001$1];
    return [1, bnds_001$2];
   }
   function invariant(param){return 0;}
   var
    main =
      [0,
       Async_kernel_Monitor0[21],
       Async_kernel_Priority[2],
       Core_Univ_map[4],
       0];
   function create_like(monitor, priority, local_storage, t){
    var
     monitor$0 = caml_call2(Core_Option[34], monitor, t[1]),
     _i_ = t[4],
     _j_ = caml_call2(Core_Option[34], local_storage, t[3]);
    return [0,
            monitor$0,
            caml_call2(Core_Option[34], priority, t[2]),
            _j_,
            _i_];
   }
   function find_local(t, key){
    return caml_call2(Core_Univ_map[10], t[3], key);
   }
   function with_local(t, key, data){
    var
     _g_ = t[4],
     _h_ =
       caml_call3(Core_Univ_map[14], t[3], key, function(param){return data;});
    return [0, t[1], t[2], _h_, _g_];
   }
   function record_backtrace(t){
    var _e_ = t[4], _f_ = [0, caml_call2(Base_Backtrace[2], 0, 0), _e_];
    return [0, t[1], t[2], t[3], _f_];
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Execution_con);
   var
    Async_kernel_Execution_context =
      [0,
       backtrace_history,
       local_storage,
       priority,
       monitor,
       [0,
        names,
        backtrace_history$0,
        local_storage$0,
        priority$0,
        monitor$0,
        fold,
        make_creator,
        create,
        map,
        iter,
        for_all,
        exists,
        to_list,
        map_poly,
        Direct],
       sexp_of_t,
       invariant,
       main,
       create_like,
       find_local,
       with_local,
       record_backtrace];
   runtime.caml_register_global
    (27, Async_kernel_Execution_context, cst_Async_kernel_Execution_con);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__External_job
//# unitInfo: Requires: Async_kernel__Types, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_External_job = "Async_kernel__External_job",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_External_job);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/external_job.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, "<job>"];
   function sexp_of_t(param){return _a_;}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_External_job);
   var Async_kernel_External_job = [0, sexp_of_t];
   runtime.caml_register_global
    (12, Async_kernel_External_job, cst_Async_kernel_External_job);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_pool
//# unitInfo: Requires: Async_kernel__Execution_context, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_pool = "Async_kernel__Job_pool",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Tuple_pool = global_data.Tuple_pool,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_pool);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/job_pool.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var dummy_e = Async_kernel_Execution_context[8];
   function dummy_f(_c_){return 0;}
   var dummy_a = 0;
   function sexp_of_slots(x_001){
    return caml_call4
            (Tuple_pool[1][5],
             Async_kernel_Execution_context[6],
             function(param){
              return caml_call1
                      (Sexplib0_Sexp_conv[24], function(_b_){return 0;});
             },
             Sexplib0_Sexp_conv[23],
             x_001);
   }
   function sexp_of_t(x_002){
    return caml_call2(Tuple_pool[4], sexp_of_slots, x_002);
   }
   function invariant(t){
    return caml_call2(Tuple_pool[5], function(_a_){return 0;}, t);
   }
   function create(param){
    return caml_call3
            (Tuple_pool[9],
             Tuple_pool[1][19],
             1,
             [0, dummy_e, dummy_f, dummy_a]);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_pool);
   var
    Async_kernel_Job_pool = [0, sexp_of_slots, sexp_of_t, invariant, create];
   runtime.caml_register_global
    (14, Async_kernel_Job_pool, cst_Async_kernel_Job_pool);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job
//# unitInfo: Requires: Async_kernel__Job_pool, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job = "Async_kernel__Job",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Job_pool = global_data.Async_kernel__Job_pool,
    Tuple_pool = global_data.Tuple_pool,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/job.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function sexp_of_t(x_001){
    return caml_call2(Tuple_pool[3][1], Async_kernel_Job_pool[1], x_001);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job);
   var Async_kernel_Job = [0, sexp_of_t];
   runtime.caml_register_global(13, Async_kernel_Job, cst_Async_kernel_Job);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_or_event
//# unitInfo: Requires: Async_kernel__Types, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_or_event = "Async_kernel__Job_or_event",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Stdlib_Obj = global_data.Stdlib__Obj,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   global_data.Async_kernel__Types;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_or_event);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/job_or_event.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function of_event(event){return event;}
   function of_job(job){return job;}
   function is_event(t){return caml_call1(Stdlib_Obj[1], t);}
   function is_job(t){return typeof t === "number" ? 1 : 0;}
   function kind(t){return is_event(t) ? 0 : 1;}
   function project(param, job_or_event){return job_or_event;}
   var Match = [0, kind, project];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_or_event);
   var
    Async_kernel_Job_or_event = [0, of_event, of_job, is_event, is_job, Match];
   runtime.caml_register_global
    (13, Async_kernel_Job_or_event, cst_Async_kernel_Job_or_event);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_or_event_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_or_event_ = "Async_kernel__Job_or_event_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_or_event_);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/job_or_event_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_or_event_);
   var Async_kernel_Job_or_event_intf = [0];
   runtime.caml_register_global
    (11, Async_kernel_Job_or_event_intf, cst_Async_kernel_Job_or_event_);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Scheduler0
//# unitInfo: Requires: Async_kernel__Types, Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Scheduler0 = "Async_kernel__Scheduler0",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Scheduler0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/scheduler0.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function events(t){return t[19][4];}
   function set_execution_context(t, execution_context){
    var
     _a_ = 1 - caml_call2(Core[246], t[7], execution_context),
     _b_ = _a_ ? (t[7] = execution_context, 0) : _a_;
    return _b_;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Scheduler0);
   var Async_kernel_Scheduler0 = [0, events, set_execution_context];
   runtime.caml_register_global
    (12, Async_kernel_Scheduler0, cst_Async_kernel_Scheduler0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Job_queue
//# unitInfo: Requires: Assert_failure, Async_kernel__Execution_context, Async_kernel__Import, Async_kernel__Scheduler0, Base__Backtrace, Base__Field, Base__Invariant, Core, Core__Int, Core__Uniform_array, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Thread_safe_queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Job_queue = "Async_kernel__Job_queue",
    cst_async_kernel = "async_kernel",
    cst_front = "front",
    cst_jobs = "jobs",
    cst_jobs_left_this_cycle = "jobs_left_this_cycle",
    cst_length = "length",
    cst_mask = "mask",
    cst_num_jobs_run = "num_jobs_run",
    cst_src_job_queue_ml = "src/job_queue.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Uniform_array = global_data.Core__Uniform_array,
    Base_Backtrace = global_data.Base__Backtrace,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Async_kernel_Scheduler0 = global_data.Async_kernel__Scheduler0,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Int = global_data.Core__Int,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Base_Invariant = global_data.Base__Invariant;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Job_queue);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_job_queue_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var dummy_e = Async_kernel_Execution_context[8];
   function dummy_f(_G_){return 0;}
   function length(r){return r[6];}
   function set_length(r, v){r[6] = v; return 0;}
   function front(r){return r[5];}
   function set_front(r, v){r[5] = v; return 0;}
   function mask(r){return r[4];}
   function set_mask(r, v){r[4] = v; return 0;}
   function jobs(r){return r[3];}
   function set_jobs(r, v){r[3] = v; return 0;}
   function jobs_left_this_cycle(r){return r[2];}
   function set_jobs_left_this_cycle(r, v){r[2] = v; return 0;}
   function num_jobs_run(r){return r[1];}
   function set_num_jobs_run(r, v){r[1] = v; return 0;}
   var
    length$0 =
      [0,
       function(param){return 0;},
       cst_length,
       [0, set_length],
       length,
       function(r, v){return [0, r[1], r[2], r[3], r[4], r[5], v];}],
    front$0 =
      [0,
       function(param){return 0;},
       cst_front,
       [0, set_front],
       front,
       function(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6]];}],
    mask$0 =
      [0,
       function(param){return 0;},
       cst_mask,
       [0, set_mask],
       mask,
       function(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6]];}],
    jobs$0 =
      [0,
       function(param){return 0;},
       cst_jobs,
       [0, set_jobs],
       jobs,
       function(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6]];}],
    jobs_left_this_cycle$0 =
      [0,
       function(param){return 0;},
       cst_jobs_left_this_cycle,
       [0, set_jobs_left_this_cycle],
       jobs_left_this_cycle,
       function(r, v){return [0, r[1], v, r[3], r[4], r[5], r[6]];}],
    num_jobs_run$0 =
      [0,
       function(param){return 0;},
       cst_num_jobs_run,
       [0, set_num_jobs_run],
       num_jobs_run,
       function(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6]];}],
    dummy_a = 0,
    _a_ = [0, cst_length],
    _b_ = [0, cst_front],
    _c_ = [0, cst_mask],
    _d_ = [0, cst_jobs],
    _e_ = [0, cst_jobs_left_this_cycle],
    _f_ = [0, cst_num_jobs_run],
    _g_ = [0, cst_src_job_queue_ml, 60, 11],
    _h_ = [0, cst_src_job_queue_ml, 59, 11],
    _i_ = [0, cst_src_job_queue_ml, 56, 11],
    _j_ = [0, cst_src_job_queue_ml, 55, 11],
    _k_ = [0, cst_src_job_queue_ml, 52, 11],
    _l_ = [0, cst_src_job_queue_ml, 51, 11],
    _m_ = [0, cst_src_job_queue_ml, 41, 44],
    _n_ = [0, cst_src_job_queue_ml, 39, 48],
    _o_ = [0, cst_src_job_queue_ml, 36, 1334, 1356],
    _p_ = [0, "t"],
    _q_ = [0, "n"],
    cst_Jobs_set_jobs_left_this_cy =
      "Jobs.set_jobs_left_this_cycle got negative number",
    _r_ = [0, 0];
   function sexp_of_t(param){
    var
     num_jobs_run_002 = param[1],
     jobs_left_this_cycle_004 = param[2],
     jobs_006 = param[3],
     mask_008 = param[4],
     front_010 = param[5],
     length_012 = param[6],
     arg_013 = caml_call1(Core[356], length_012),
     bnds_001 = [0, [1, [0, _a_, [0, arg_013, 0]]], 0],
     arg_011 = caml_call1(Core[356], front_010),
     bnds_001$0 = [0, [1, [0, _b_, [0, arg_011, 0]]], bnds_001],
     arg_009 = caml_call1(Core[356], mask_008),
     bnds_001$1 = [0, [1, [0, _c_, [0, arg_009, 0]]], bnds_001$0],
     arg_007 = caml_call1(Sexplib0_Sexp_conv[23], jobs_006),
     bnds_001$2 = [0, [1, [0, _d_, [0, arg_007, 0]]], bnds_001$1],
     arg_005 = caml_call1(Core[356], jobs_left_this_cycle_004),
     bnds_001$3 = [0, [1, [0, _e_, [0, arg_005, 0]]], bnds_001$2],
     arg_003 = caml_call1(Core[356], num_jobs_run_002),
     bnds_001$4 = [0, [1, [0, _f_, [0, arg_003, 0]]], bnds_001$3];
    return [1, bnds_001$4];
   }
   function offset(t, i){return ((t[5] + i | 0) & t[4]) * 3 | 0;}
   function capacity(t){return t[4] + 1 | 0;}
   function invariant(t){
    return caml_call4
            (Base_Invariant[1],
             _o_,
             t,
             sexp_of_t,
             function(param){
              function check(f){return caml_call2(Base_Invariant[2], t, f);}
              var
               length_fun =
                 check
                  (function(length){
                    if(! caml_call2(Async_kernel_Import[1], length, 0))
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _h_], 1);
                    var _F_ = capacity(t);
                    if(caml_call2(Async_kernel_Import[2], length, _F_))
                     return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _g_], 1);
                   }),
               front_fun =
                 check
                  (function(front){
                    if(! caml_call2(Async_kernel_Import[1], front, 0))
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _j_], 1);
                    var _E_ = capacity(t);
                    if(caml_call2(Async_kernel_Import[5], front, _E_)) return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _i_], 1);
                   }),
               mask_fun =
                 check
                  (function(mask){
                    var capacity = mask + 1 | 0;
                    if(! caml_call1(Core_Int[48], capacity))
                     throw caml_maybe_attach_backtrace
                            ([0, Assert_failure, _l_], 1);
                    var _D_ = caml_call1(Core_Uniform_array[18], t[3]);
                    if
                     (caml_call2(Async_kernel_Import[3], capacity * 3 | 0, _D_))
                     return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _k_], 1);
                   }),
               jobs_fun =
                 check
                  (function(jobs){
                    var _z_ = t[6] - 1 | 0, _y_ = 0;
                    if(_z_ >= 0){
                     var i = _y_;
                     for(;;){
                      var
                       _A_ = offset(t, i),
                       _B_ = caml_call2(Core_Uniform_array[19], jobs, _A_);
                      caml_call1(Async_kernel_Execution_context[7], _B_);
                      var _C_ = i + 1 | 0;
                      if(_z_ === i) break;
                      i = _C_;
                     }
                    }
                    return 0;
                   }),
               jobs_left_this_cycle_fun =
                 check
                  (function(jobs_left_this_cycle){
                    if
                     (caml_call2(Async_kernel_Import[1], jobs_left_this_cycle, 0))
                     return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _m_], 1);
                   }),
               num_jobs_run_fun =
                 check
                  (function(num_jobs_run){
                    if(caml_call2(Async_kernel_Import[1], num_jobs_run, 0))
                     return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _n_], 1);
                   });
              caml_call1(num_jobs_run_fun, num_jobs_run$0);
              caml_call1(jobs_left_this_cycle_fun, jobs_left_this_cycle$0);
              caml_call1(jobs_fun, jobs$0);
              caml_call1(mask_fun, mask$0);
              caml_call1(front_fun, front$0);
              return caml_call1(length_fun, length$0);
             });
   }
   function create_array(capacity){
    return caml_call1(Core_Uniform_array[43], capacity * 3 | 0);
   }
   function create(param){return [0, 0, 0, create_array(1), 0, 0, 0];}
   function clear(t){t[5] = 0; t[6] = 0; t[2] = 0; return 0;}
   function set(t, i, execution_context, f, a){
    var offset$0 = offset(t, i);
    caml_call3(Core_Uniform_array[22], t[3], offset$0, execution_context);
    caml_call3(Core_Uniform_array[22], t[3], offset$0 + 1 | 0, f);
    return caml_call3(Core_Uniform_array[22], t[3], offset$0 + 2 | 0, a);
   }
   function enqueue(t, execution_context, f, a){
    var _x_ = capacity(t);
    if(caml_call2(Async_kernel_Import[3], t[6], _x_)){
     var
      old_capacity = capacity(t),
      new_capacity = old_capacity * 2 | 0,
      old_jobs = t[3],
      old_front = t[5],
      len1 =
        caml_call2(Core_Int[92], t[6], old_capacity - old_front | 0) * 3 | 0,
      len2 = (t[6] * 3 | 0) - len1 | 0,
      new_jobs = create_array(new_capacity);
     caml_call5
      (Core_Uniform_array[36], old_jobs, old_front * 3 | 0, new_jobs, 0, len1);
     caml_call5(Core_Uniform_array[36], old_jobs, 0, new_jobs, len1, len2);
     t[4] = new_capacity - 1 | 0;
     t[3] = new_jobs;
     t[5] = 0;
    }
    set(t, t[6], execution_context, f, a);
    t[6] = t[6] + 1 | 0;
    return 0;
   }
   function set_jobs_left_this_cycle$0(t, n){
    if(caml_call2(Async_kernel_Import[5], n, 0)){
     var
      _u_ = [0, [1, [0, _p_, [0, sexp_of_t(t), 0]]], 0],
      _v_ = [0, [1, [0, _q_, [0, caml_call1(Core[356], n), 0]]], _u_],
      _w_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Jobs_set_jobs_left_this_cy),
          _v_]];
     caml_call1(Core[253], _w_);
    }
    t[2] = n;
    return 0;
   }
   function can_run_a_job(t){
    var _t_ = caml_call2(Async_kernel_Import[4], t[6], 0);
    return _t_ ? caml_call2(Async_kernel_Import[4], t[2], 0) : _t_;
   }
   function run_job(t, scheduler, execution_context, f, a){
    t[1] = t[1] + 1 | 0;
    caml_call2(Async_kernel_Scheduler0[2], scheduler, execution_context);
    return caml_call1(f, a);
   }
   function run_external_jobs(t, scheduler){
    var external_jobs = scheduler[20];
    for(;;){
     var _s_ = caml_call1(Thread_safe_queue[4], external_jobs);
     if(! caml_call2(Async_kernel_Import[4], _s_, 0)) return;
     var
      match = caml_call1(Thread_safe_queue[6], external_jobs),
      a = match[3],
      f = match[2],
      execution_context = match[1];
     run_job(t, scheduler, execution_context, f, a);
    }
   }
   function run_jobs(t, scheduler){
    try{
     run_external_jobs(t, scheduler);
     for(;;){
      if(! can_run_a_job(t)) return _r_;
      var
       this_job = offset(t, 0),
       execution_context = caml_call2(Core_Uniform_array[20], t[3], this_job),
       f = caml_call2(Core_Uniform_array[20], t[3], this_job + 1 | 0),
       a = caml_call2(Core_Uniform_array[20], t[3], this_job + 2 | 0);
      set(t, 0, dummy_e, dummy_f, dummy_a);
      t[5] = (t[5] + 1 | 0) & t[4];
      t[6] = t[6] - 1 | 0;
      t[2] = t[2] - 1 | 0;
      run_job(t, scheduler, execution_context, f, a);
      run_external_jobs(t, scheduler);
     }
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      backtrace = caml_call1(Base_Backtrace[6][4], 0);
     return [1, [0, exn, backtrace]];
    }
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Job_queue);
   var
    Async_kernel_Job_queue =
      [0,
       sexp_of_t,
       invariant,
       create,
       enqueue,
       clear,
       set_jobs_left_this_cycle$0,
       can_run_a_job,
       length,
       run_jobs,
       num_jobs_run];
   runtime.caml_register_global
    (49, Async_kernel_Job_queue, cst_Async_kernel_Job_queue);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Synchronous_time_source0
//# unitInfo: Requires: Assert_failure, Async_kernel__Job_or_event, Async_kernel__Scheduler0, Async_kernel__Time_ns, Base__Backtrace, Base__Field, Base__Invariant, Core, Core__Error, Core__List, Core__Or_error, Core__Time_ns, Expect_test_collector, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Synchronous_t = "Async_kernel__Synchronous_time_source0",
    cst_advance_errors = "advance_errors",
    cst_alarm = "alarm",
    cst_am_advancing = "am_advancing",
    cst_async_kernel = "async_kernel",
    cst_at = "at",
    cst_callback = "callback",
    cst_events = "events",
    cst_execution_context = "execution_context",
    cst_fired_events = "fired_events",
    cst_handle_fired = "handle_fired",
    cst_id = "id",
    cst_interval = "interval",
    cst_is_wall_clock = "is_wall_clock",
    cst_most_recently_fired = "most_recently_fired",
    cst_next_fired = "next_fired",
    cst_now = "now",
    cst_prev_fired = "prev_fired",
    cst_scheduler = "scheduler",
    cst_src_synchronous_time_sourc$0 = "src/synchronous_time_source0.ml",
    cst_status = "status",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   function caml_call9(f, a0, a1, a2, a3, a4, a5, a6, a7, a8){
    return (f.l >= 0 ? f.l : f.l = f.length) == 9
            ? f(a0, a1, a2, a3, a4, a5, a6, a7, a8)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7, a8]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos$3 = "src/synchronous_time_source0.ml:341:32",
    pos$2 = "src/synchronous_time_source0.ml:340:32",
    pos$1 = "src/synchronous_time_source0.ml:187:30",
    pos$0 = "src/synchronous_time_source0.ml:205:32",
    pos = "src/synchronous_time_source0.ml:215:32",
    cst = "",
    names =
      [0,
       cst_alarm,
       [0,
        cst_at,
        [0,
         cst_callback,
         [0,
          cst_execution_context,
          [0,
           cst_interval,
           [0, cst_next_fired, [0, cst_prev_fired, [0, cst_status, 0]]]]]]]],
    names$0 =
      [0,
       cst_id,
       [0,
        cst_advance_errors,
        [0,
         cst_am_advancing,
         [0,
          cst_events,
          [0,
           cst_fired_events,
           [0,
            cst_most_recently_fired,
            [0,
             cst_handle_fired,
             [0, cst_is_wall_clock, [0, cst_scheduler, 0]]]]]]]]],
    Timing_wheel = global_data.Timing_wheel,
    Core_Error = global_data.Core__Error,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Scheduler0 = global_data.Async_kernel__Scheduler0,
    Base_Backtrace = global_data.Base__Backtrace,
    Core_Or_error = global_data.Core__Or_error,
    Core_Time_ns = global_data.Core__Time_ns,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Core_List = global_data.Core__List,
    Base_Field = global_data.Base__Field,
    Async_kernel_Job_or_event = global_data.Async_kernel__Job_or_event,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Synchronous_t);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_synchronous_time_sourc$0);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    typerep_of_t = Async_kernel_Time_ns[1],
    typename_of_t = Async_kernel_Time_ns[2],
    bin_size_t = Async_kernel_Time_ns[3],
    bin_write_t = Async_kernel_Time_ns[4],
    bin_read_t = Async_kernel_Time_ns[5],
    bin_read_t$0 = Async_kernel_Time_ns[6],
    bin_shape_t = Async_kernel_Time_ns[7],
    bin_writer_t = Async_kernel_Time_ns[8],
    bin_reader_t = Async_kernel_Time_ns[9],
    bin_t = Async_kernel_Time_ns[10],
    quickcheck_generator = Async_kernel_Time_ns[11],
    quickcheck_observer = Async_kernel_Time_ns[12],
    quickcheck_shrinker = Async_kernel_Time_ns[13],
    gen_incl = Async_kernel_Time_ns[14],
    gen_uniform_incl = Async_kernel_Time_ns[15],
    is_earlier = Async_kernel_Time_ns[16],
    is_later = Async_kernel_Time_ns[17],
    of_date_ofday = Async_kernel_Time_ns[18],
    of_date_ofday_precise = Async_kernel_Time_ns[19],
    to_date_ofday = Async_kernel_Time_ns[20],
    to_date_ofday_precise = Async_kernel_Time_ns[21],
    to_date = Async_kernel_Time_ns[22],
    to_ofday = Async_kernel_Time_ns[23],
    reset_date_cache = Async_kernel_Time_ns[24],
    convert = Async_kernel_Time_ns[25],
    utc_offset = Async_kernel_Time_ns[26],
    to_filename_string = Async_kernel_Time_ns[27],
    of_filename_string = Async_kernel_Time_ns[28],
    to_string_abs = Async_kernel_Time_ns[29],
    to_string_abs_trimmed = Async_kernel_Time_ns[30],
    to_string_abs_parts = Async_kernel_Time_ns[31],
    to_string_trimmed = Async_kernel_Time_ns[32],
    to_sec_string = Async_kernel_Time_ns[33],
    to_sec_string_with_zone = Async_kernel_Time_ns[34],
    of_localized_string = Async_kernel_Time_ns[35],
    of_string_gen = Async_kernel_Time_ns[36],
    to_string_iso8601_basic = Async_kernel_Time_ns[37],
    occurrence = Async_kernel_Time_ns[38],
    of_string = Async_kernel_Time_ns[39],
    of_string_with_utc_offset = Async_kernel_Time_ns[40],
    to_string = Async_kernel_Time_ns[41],
    to_string_utc = Async_kernel_Time_ns[42],
    epoch = Async_kernel_Time_ns[43],
    min_value_representable = Async_kernel_Time_ns[44],
    max_value_representable = Async_kernel_Time_ns[45],
    min_value_for_1us_rounding = Async_kernel_Time_ns[46],
    max_value_for_1us_rounding = Async_kernel_Time_ns[47],
    min_value = Async_kernel_Time_ns[48],
    max_value = Async_kernel_Time_ns[49],
    now = Async_kernel_Time_ns[50],
    add = Async_kernel_Time_ns[51],
    add_saturating = Async_kernel_Time_ns[52],
    sub_saturating = Async_kernel_Time_ns[53],
    sub = Async_kernel_Time_ns[54],
    next = Async_kernel_Time_ns[55],
    prev = Async_kernel_Time_ns[56],
    diff = Async_kernel_Time_ns[57],
    abs_diff = Async_kernel_Time_ns[58],
    to_span_since_epoch = Async_kernel_Time_ns[59],
    of_span_since_epoch = Async_kernel_Time_ns[60],
    to_int63_ns_since_epoch = Async_kernel_Time_ns[61],
    of_int63_ns_since_epoch = Async_kernel_Time_ns[62],
    to_int_ns_since_epoch = Async_kernel_Time_ns[63],
    of_int_ns_since_epoch = Async_kernel_Time_ns[64],
    next_multiple = Async_kernel_Time_ns[65],
    prev_multiple = Async_kernel_Time_ns[66],
    random = Async_kernel_Time_ns[67],
    of_time = Async_kernel_Time_ns[68],
    to_time = Async_kernel_Time_ns[69],
    to_time_float_round_nearest = Async_kernel_Time_ns[70],
    to_time_float_round_nearest_mi = Async_kernel_Time_ns[71],
    of_time_float_round_nearest = Async_kernel_Time_ns[72],
    of_time_float_round_nearest_mi = Async_kernel_Time_ns[73],
    arg_type = Async_kernel_Time_ns[74],
    get_sexp_zone = Async_kernel_Time_ns[75],
    interruptible_pause = Async_kernel_Time_ns[76],
    of_date_ofday_zoned = Async_kernel_Time_ns[77],
    of_string_abs = Async_kernel_Time_ns[78],
    of_string_fix_proto = Async_kernel_Time_ns[79],
    pause = Async_kernel_Time_ns[80],
    pause_forever = Async_kernel_Time_ns[81],
    pp = Async_kernel_Time_ns[82],
    set_sexp_zone = Async_kernel_Time_ns[83],
    sexp_of_t_abs = Async_kernel_Time_ns[84],
    t_of_sexp_abs = Async_kernel_Time_ns[85],
    to_date_ofday_zoned = Async_kernel_Time_ns[86],
    to_ofday_zoned = Async_kernel_Time_ns[87],
    to_string_fix_proto = Async_kernel_Time_ns[88],
    hash_fold_t = Async_kernel_Time_ns[89],
    hash = Async_kernel_Time_ns[90],
    t_of_sexp = Async_kernel_Time_ns[91],
    t_sexp_grammar = Async_kernel_Time_ns[93],
    symbol = Async_kernel_Time_ns[94],
    symbol$0 = Async_kernel_Time_ns[95],
    symbol$1 = Async_kernel_Time_ns[96],
    symbol$2 = Async_kernel_Time_ns[97],
    symbol$3 = Async_kernel_Time_ns[98],
    symbol$4 = Async_kernel_Time_ns[99],
    equal = Async_kernel_Time_ns[100],
    compare = Async_kernel_Time_ns[101],
    min = Async_kernel_Time_ns[102],
    max = Async_kernel_Time_ns[103],
    ascending = Async_kernel_Time_ns[104],
    descending = Async_kernel_Time_ns[105],
    between = Async_kernel_Time_ns[106],
    clamp_exn = Async_kernel_Time_ns[107],
    clamp = Async_kernel_Time_ns[108],
    comparator = Async_kernel_Time_ns[109],
    validate_lbound = Async_kernel_Time_ns[110],
    validate_ubound = Async_kernel_Time_ns[111],
    validate_bound = Async_kernel_Time_ns[112],
    after = Async_kernel_Time_ns[113];
   function sexp_of_t(t){
    var
     _dg_ = caml_call1(to_span_since_epoch, t),
     _dh_ =
       runtime.core_time_ns_format
        (caml_call1(Core_Time_ns[1][91], _dg_), "%Y-%m-%dT%H:%M:%S%z");
    return caml_call1(Core[471], _dh_);
   }
   var
    Time_ns =
      [0,
       typerep_of_t,
       typename_of_t,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_shape_t,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       quickcheck_generator,
       quickcheck_observer,
       quickcheck_shrinker,
       gen_incl,
       gen_uniform_incl,
       is_earlier,
       is_later,
       of_date_ofday,
       of_date_ofday_precise,
       to_date_ofday,
       to_date_ofday_precise,
       to_date,
       to_ofday,
       reset_date_cache,
       convert,
       utc_offset,
       to_filename_string,
       of_filename_string,
       to_string_abs,
       to_string_abs_trimmed,
       to_string_abs_parts,
       to_string_trimmed,
       to_sec_string,
       to_sec_string_with_zone,
       of_localized_string,
       of_string_gen,
       to_string_iso8601_basic,
       occurrence,
       of_string,
       of_string_with_utc_offset,
       to_string,
       to_string_utc,
       epoch,
       min_value_representable,
       max_value_representable,
       min_value_for_1us_rounding,
       max_value_for_1us_rounding,
       min_value,
       max_value,
       now,
       add,
       add_saturating,
       sub_saturating,
       sub,
       next,
       prev,
       diff,
       abs_diff,
       to_span_since_epoch,
       of_span_since_epoch,
       to_int63_ns_since_epoch,
       of_int63_ns_since_epoch,
       to_int_ns_since_epoch,
       of_int_ns_since_epoch,
       next_multiple,
       prev_multiple,
       random,
       of_time,
       to_time,
       to_time_float_round_nearest,
       to_time_float_round_nearest_mi,
       of_time_float_round_nearest,
       of_time_float_round_nearest_mi,
       arg_type,
       get_sexp_zone,
       interruptible_pause,
       of_date_ofday_zoned,
       of_string_abs,
       of_string_fix_proto,
       pause,
       pause_forever,
       pp,
       set_sexp_zone,
       sexp_of_t_abs,
       t_of_sexp_abs,
       to_date_ofday_zoned,
       to_ofday_zoned,
       to_string_fix_proto,
       hash_fold_t,
       hash,
       t_of_sexp,
       t_sexp_grammar,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       validate_lbound,
       validate_ubound,
       validate_bound,
       after,
       sexp_of_t],
    include = Timing_wheel[5],
    sexp_of_t$0 = include[1],
    null$0 = include[2],
    at = include[3],
    interval_num = include[4],
    value = include[5];
   function is_null(t){
    var _df_ = caml_call1(null$0, 0);
    return caml_call2(Core[246], t, _df_);
   }
   var
    Alarm = [0, sexp_of_t$0, null$0, at, interval_num, value, is_null],
    _a_ = caml_call2(Timing_wheel[1][13], Timing_wheel[1][10], 3),
    _b_ =
      [0,
       caml_call2(Timing_wheel[7][5], 0, [0, 13, [0, 6, [0, 6, [0, 5, 0]]]])],
    default_timing_wheel_config =
      caml_call4(Timing_wheel[8][4], 0, _b_, _a_, 0),
    compare$0 = runtime.caml_int_compare,
    _c_ = [0, "Fired"],
    _d_ = [0, "Happening"],
    _e_ = [0, "Scheduled"],
    _f_ = [0, "Unscheduled"];
   function equal$0(_de_, _dd_){return _de_ === _dd_ ? 1 : 0;}
   function sexp_of_t$1(param){
    switch(param){
      case 0:
       return _c_;
      case 1:
       return _d_;
      case 2:
       return _e_;
      default: return _f_;
    }
   }
   function transition_is_allowed(from, to){
    a:
    {
     switch(from){
       case 0:
        if(1 !== to && 3 > to) break a; break;
       case 1:
        if(2 > to) break a; break;
       case 2:
        if(1 >= to - 1 >>> 0) break a; break;
       default: if(1 === to || 3 <= to) break a;
     }
     return 1;
    }
    return 0;
   }
   var
    Status = [0, compare$0, equal$0, sexp_of_t$1, transition_is_allowed],
    _g_ = [0, cst_interval],
    _h_ = [0, cst_at],
    _i_ = [0, cst_status];
   function sexp_of_event(param){
    var at = param[2], interval = param[5], status = param[8], match = 0;
    if(interval)
     var
      v = interval[1],
      _db_ =
        [0, [1, [0, _g_, [0, caml_call1(Core_Time_ns[1][10], v), 0]]], match];
    else
     var _db_ = match;
    var _dc_ = [0, [1, [0, _h_, [0, caml_call1(Time_ns[113], at), 0]]], _db_];
    return [1,
            [0, [1, [0, _i_, [0, caml_call1(Status[3], status), 0]]], _dc_]];
   }
   var Event_is_block = [0], none = 0;
   function some(_da_){return _da_;}
   function is_none(t){return caml_call2(Core[246], t, none);}
   function is_some(t){return 1 - is_none(t);}
   function first_some(t1, t2){return is_some(t1) ? t1 : t2;}
   function unsafe_value(_c$_){return _c$_;}
   var
    Optional_syntax = [0, is_none, unsafe_value],
    Optional_syntax$0 = [0, Optional_syntax],
    _j_ = [1, 0],
    cst_Synchronous_time_source_Ev =
      "[Synchronous_time_source.Event.Option.value_exn None]";
   function sexp_of_t$2(ppx_optional_e_0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0)) return _j_;
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return sexp_of_event(event);
   }
   function value$0(ppx_optional_e_0, default$0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0))
     return default$0;
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return event;
   }
   function value_exn(ppx_optional_e_0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0)){
     var
      _c__ = caml_call1(Sexplib0_Sexp_conv[7], cst_Synchronous_time_source_Ev);
     return caml_call1(Core[253], _c__);
    }
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return event;
   }
   function to_option(ppx_optional_e_0){
    if(caml_call1(Optional_syntax$0[1][1], ppx_optional_e_0)) return 0;
    var event = caml_call1(Optional_syntax$0[1][2], ppx_optional_e_0);
    return [0, event];
   }
   function of_option(param){
    if(! param) return none;
    var event = param[1];
    return event;
   }
   var
    Option =
      [0,
       Event_is_block,
       none,
       some,
       is_none,
       is_some,
       first_some,
       Optional_syntax$0,
       sexp_of_t$2,
       value$0,
       value_exn,
       to_option,
       of_option];
   function status(r){return r[8];}
   function set_status(r, v){r[8] = v; return 0;}
   function prev_fired(r){return r[7];}
   function set_prev_fired(r, v){r[7] = v; return 0;}
   function next_fired(r){return r[6];}
   function set_next_fired(r, v){r[6] = v; return 0;}
   function interval(r){return r[5];}
   function set_interval(r, v){r[5] = v; return 0;}
   function execution_context(r){return r[4];}
   function callback(r){return r[3];}
   function at$0(r){return r[2];}
   function set_at(r, v){r[2] = v; return 0;}
   function alarm(r){return r[1];}
   function set_alarm(r, v){r[1] = v; return 0;}
   var
    status$0 =
      [0,
       function(param){return 0;},
       cst_status,
       [0, set_status],
       status,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v];
       }],
    prev_fired$0 =
      [0,
       function(param){return 0;},
       cst_prev_fired,
       [0, set_prev_fired],
       prev_fired,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8]];
       }],
    next_fired$0 =
      [0,
       function(param){return 0;},
       cst_next_fired,
       [0, set_next_fired],
       next_fired,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8]];
       }],
    interval$0 =
      [0,
       function(param){return 0;},
       cst_interval,
       [0, set_interval],
       interval,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8]];
       }],
    execution_context$0 =
      [0,
       function(param){return 0;},
       cst_execution_context,
       0,
       execution_context,
       function(r, v){
        return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8]];
       }],
    callback$0 =
      [0,
       function(param){return 0;},
       cst_callback,
       0,
       callback,
       function(r, v){
        return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8]];
       }],
    at$1 =
      [0,
       function(param){return 0;},
       cst_at,
       [0, set_at],
       at$0,
       function(r, v){
        return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8]];
       }],
    alarm$0 =
      [0,
       function(param){return 0;},
       cst_alarm,
       [0, set_alarm],
       alarm,
       function(r, v){
        return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8]];
       }];
   function make_creator
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun,
    compile_acc){
    var
     match = caml_call2(alarm_fun, alarm$0, compile_acc),
     compile_acc$0 = match[2],
     alarm_gen = match[1],
     match$0 = caml_call2(at_fun, at$1, compile_acc$0),
     compile_acc$1 = match$0[2],
     at_gen = match$0[1],
     match$1 = caml_call2(callback_fun, callback$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     callback_gen = match$1[1],
     match$2 =
       caml_call2(execution_context_fun, execution_context$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     execution_context_gen = match$2[1],
     match$3 = caml_call2(interval_fun, interval$0, compile_acc$3),
     compile_acc$4 = match$3[2],
     interval_gen = match$3[1],
     match$4 = caml_call2(next_fired_fun, next_fired$0, compile_acc$4),
     compile_acc$5 = match$4[2],
     next_fired_gen = match$4[1],
     match$5 = caml_call2(prev_fired_fun, prev_fired$0, compile_acc$5),
     compile_acc$6 = match$5[2],
     prev_fired_gen = match$5[1],
     match$6 = caml_call2(status_fun, status$0, compile_acc$6),
     compile_acc$7 = match$6[2],
     status_gen = match$6[1];
    return [0,
            function(acc){
             var
              alarm = caml_call1(alarm_gen, acc),
              at = caml_call1(at_gen, acc),
              callback = caml_call1(callback_gen, acc),
              execution_context = caml_call1(execution_context_gen, acc),
              interval = caml_call1(interval_gen, acc),
              next_fired = caml_call1(next_fired_gen, acc),
              prev_fired = caml_call1(prev_fired_gen, acc),
              status = caml_call1(status_gen, acc);
             return [0,
                     alarm,
                     at,
                     callback,
                     execution_context,
                     interval,
                     next_fired,
                     prev_fired,
                     status];
            },
            compile_acc$7];
   }
   function create
   (alarm,
    at,
    callback,
    execution_context,
    interval,
    next_fired,
    prev_fired,
    status){
    return [0,
            alarm,
            at,
            callback,
            execution_context,
            interval,
            next_fired,
            prev_fired,
            status];
   }
   function map
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _c3_ = caml_call1(status_fun, status$0),
     _c4_ = caml_call1(prev_fired_fun, prev_fired$0),
     _c5_ = caml_call1(next_fired_fun, next_fired$0),
     _c6_ = caml_call1(interval_fun, interval$0),
     _c7_ = caml_call1(execution_context_fun, execution_context$0),
     _c8_ = caml_call1(callback_fun, callback$0),
     _c9_ = caml_call1(at_fun, at$1);
    return [0,
            caml_call1(alarm_fun, alarm$0),
            _c9_,
            _c8_,
            _c7_,
            _c6_,
            _c5_,
            _c4_,
            _c3_];
   }
   function iter
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    caml_call1(alarm_fun, alarm$0);
    caml_call1(at_fun, at$1);
    caml_call1(callback_fun, callback$0);
    caml_call1(execution_context_fun, execution_context$0);
    caml_call1(interval_fun, interval$0);
    caml_call1(next_fired_fun, next_fired$0);
    caml_call1(prev_fired_fun, prev_fired$0);
    return caml_call1(status_fun, status$0);
   }
   function fold
   (init,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    return caml_call2
            (status_fun,
             caml_call2
              (prev_fired_fun,
               caml_call2
                (next_fired_fun,
                 caml_call2
                  (interval_fun,
                   caml_call2
                    (execution_context_fun,
                     caml_call2
                      (callback_fun,
                       caml_call2
                        (at_fun, caml_call2(alarm_fun, init, alarm$0), at$1),
                       callback$0),
                     execution_context$0),
                   interval$0),
                 next_fired$0),
               prev_fired$0),
             status$0);
   }
   function map_poly(record){
    var
     _cW_ = [0, caml_call1(record[1], status$0), 0],
     _cX_ = [0, caml_call1(record[1], prev_fired$0), _cW_],
     _cY_ = [0, caml_call1(record[1], next_fired$0), _cX_],
     _cZ_ = [0, caml_call1(record[1], interval$0), _cY_],
     _c0_ = [0, caml_call1(record[1], execution_context$0), _cZ_],
     _c1_ = [0, caml_call1(record[1], callback$0), _c0_],
     _c2_ = [0, caml_call1(record[1], at$1), _c1_];
    return [0, caml_call1(record[1], alarm$0), _c2_];
   }
   function for_all
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _cP_ = caml_call1(alarm_fun, alarm$0),
     _cQ_ = _cP_ ? caml_call1(at_fun, at$1) : _cP_,
     _cR_ = _cQ_ ? caml_call1(callback_fun, callback$0) : _cQ_,
     _cS_ =
       _cR_ ? caml_call1(execution_context_fun, execution_context$0) : _cR_,
     _cT_ = _cS_ ? caml_call1(interval_fun, interval$0) : _cS_,
     _cU_ = _cT_ ? caml_call1(next_fired_fun, next_fired$0) : _cT_,
     _cV_ = _cU_ ? caml_call1(prev_fired_fun, prev_fired$0) : _cU_;
    return _cV_ ? caml_call1(status_fun, status$0) : _cV_;
   }
   function exists
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _cO_ = caml_call1(alarm_fun, alarm$0),
     _cI_ = _cO_ || caml_call1(at_fun, at$1),
     _cJ_ = _cI_ || caml_call1(callback_fun, callback$0),
     _cK_ = _cJ_ || caml_call1(execution_context_fun, execution_context$0),
     _cL_ = _cK_ || caml_call1(interval_fun, interval$0),
     _cM_ = _cL_ || caml_call1(next_fired_fun, next_fired$0),
     _cN_ = _cM_ || caml_call1(prev_fired_fun, prev_fired$0);
    return _cN_ ? _cN_ : caml_call1(status_fun, status$0);
   }
   function to_list
   (alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _cB_ = [0, caml_call1(status_fun, status$0), 0],
     _cC_ = [0, caml_call1(prev_fired_fun, prev_fired$0), _cB_],
     _cD_ = [0, caml_call1(next_fired_fun, next_fired$0), _cC_],
     _cE_ = [0, caml_call1(interval_fun, interval$0), _cD_],
     _cF_ = [0, caml_call1(execution_context_fun, execution_context$0), _cE_],
     _cG_ = [0, caml_call1(callback_fun, callback$0), _cF_],
     _cH_ = [0, caml_call1(at_fun, at$1), _cG_];
    return [0, caml_call1(alarm_fun, alarm$0), _cH_];
   }
   function iter$0
   (record,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    caml_call3(alarm_fun, alarm$0, record, record[1]);
    caml_call3(at_fun, at$1, record, record[2]);
    caml_call3(callback_fun, callback$0, record, record[3]);
    caml_call3(execution_context_fun, execution_context$0, record, record[4]);
    caml_call3(interval_fun, interval$0, record, record[5]);
    caml_call3(next_fired_fun, next_fired$0, record, record[6]);
    caml_call3(prev_fired_fun, prev_fired$0, record, record[7]);
    return caml_call3(status_fun, status$0, record, record[8]);
   }
   function fold$0
   (record,
    init,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _cu_ = record[8],
     _cv_ = record[7],
     _cw_ = record[6],
     _cx_ = record[5],
     _cy_ = record[4],
     _cz_ = record[3],
     _cA_ = record[2];
    return caml_call4
            (status_fun,
             caml_call4
              (prev_fired_fun,
               caml_call4
                (next_fired_fun,
                 caml_call4
                  (interval_fun,
                   caml_call4
                    (execution_context_fun,
                     caml_call4
                      (callback_fun,
                       caml_call4
                        (at_fun,
                         caml_call4(alarm_fun, init, alarm$0, record, record[1]),
                         at$1,
                         record,
                         _cA_),
                       callback$0,
                       record,
                       _cz_),
                     execution_context$0,
                     record,
                     _cy_),
                   interval$0,
                   record,
                   _cx_),
                 next_fired$0,
                 record,
                 _cw_),
               prev_fired$0,
               record,
               _cv_),
             status$0,
             record,
             _cu_);
   }
   function for_all$0
   (record,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _cn_ = caml_call3(alarm_fun, alarm$0, record, record[1]),
     _co_ = _cn_ ? caml_call3(at_fun, at$1, record, record[2]) : _cn_,
     _cp_ =
       _co_ ? caml_call3(callback_fun, callback$0, record, record[3]) : _co_,
     _cq_ =
       _cp_
        ? caml_call3
          (execution_context_fun, execution_context$0, record, record[4])
        : _cp_,
     _cr_ =
       _cq_ ? caml_call3(interval_fun, interval$0, record, record[5]) : _cq_,
     _cs_ =
       _cr_
        ? caml_call3(next_fired_fun, next_fired$0, record, record[6])
        : _cr_,
     _ct_ =
       _cs_
        ? caml_call3(prev_fired_fun, prev_fired$0, record, record[7])
        : _cs_;
    return _ct_ ? caml_call3(status_fun, status$0, record, record[8]) : _ct_;
   }
   function exists$0
   (record,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _cm_ = caml_call3(alarm_fun, alarm$0, record, record[1]),
     _cg_ = _cm_ || caml_call3(at_fun, at$1, record, record[2]),
     _ch_ = _cg_ || caml_call3(callback_fun, callback$0, record, record[3]),
     _ci_ =
       _ch_
       ||
        caml_call3
         (execution_context_fun, execution_context$0, record, record[4]),
     _cj_ = _ci_ || caml_call3(interval_fun, interval$0, record, record[5]),
     _ck_ =
       _cj_ || caml_call3(next_fired_fun, next_fired$0, record, record[6]),
     _cl_ =
       _ck_ || caml_call3(prev_fired_fun, prev_fired$0, record, record[7]);
    return _cl_ ? _cl_ : caml_call3(status_fun, status$0, record, record[8]);
   }
   function to_list$0
   (record,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _b$_ = [0, caml_call3(status_fun, status$0, record, record[8]), 0],
     _ca_ =
       [0, caml_call3(prev_fired_fun, prev_fired$0, record, record[7]), _b$_],
     _cb_ =
       [0, caml_call3(next_fired_fun, next_fired$0, record, record[6]), _ca_],
     _cc_ = [0, caml_call3(interval_fun, interval$0, record, record[5]), _cb_],
     _cd_ =
       [0,
        caml_call3
         (execution_context_fun, execution_context$0, record, record[4]),
        _cc_],
     _ce_ = [0, caml_call3(callback_fun, callback$0, record, record[3]), _cd_],
     _cf_ = [0, caml_call3(at_fun, at$1, record, record[2]), _ce_];
    return [0, caml_call3(alarm_fun, alarm$0, record, record[1]), _cf_];
   }
   function map$0
   (record,
    alarm_fun,
    at_fun,
    callback_fun,
    execution_context_fun,
    interval_fun,
    next_fired_fun,
    prev_fired_fun,
    status_fun){
    var
     _b4_ = caml_call3(status_fun, status$0, record, record[8]),
     _b5_ = caml_call3(prev_fired_fun, prev_fired$0, record, record[7]),
     _b6_ = caml_call3(next_fired_fun, next_fired$0, record, record[6]),
     _b7_ = caml_call3(interval_fun, interval$0, record, record[5]),
     _b8_ =
       caml_call3
        (execution_context_fun, execution_context$0, record, record[4]),
     _b9_ = caml_call3(callback_fun, callback$0, record, record[3]),
     _b__ = caml_call3(at_fun, at$1, record, record[2]);
    return [0,
            caml_call3(alarm_fun, alarm$0, record, record[1]),
            _b__,
            _b9_,
            _b8_,
            _b7_,
            _b6_,
            _b5_,
            _b4_];
   }
   function set_all_mutable_fields
   (record, alarm, at, interval, next_fired, prev_fired, status){
    var record$0 = caml_call1(Base_Field[1][1], record);
    record$0[1] = alarm;
    record$0[2] = at;
    record$0[5] = interval;
    record$0[6] = next_fired;
    record$0[7] = prev_fired;
    record$0[8] = status;
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields],
    Fields =
      [0,
       names,
       status$0,
       prev_fired$0,
       next_fired$0,
       interval$0,
       execution_context$0,
       callback$0,
       at$1,
       alarm$0,
       make_creator,
       create,
       map,
       iter,
       fold,
       map_poly,
       for_all,
       exists,
       to_list,
       Direct],
    _k_ = [0, cst_src_synchronous_time_sourc$0, 216, 17],
    _l_ = [0, cst_src_synchronous_time_sourc$0, 206, 17],
    _m_ = [0, cst_src_synchronous_time_sourc$0, 182, 5945, 5971],
    _n_ = [0, "event"],
    _o_ = [0, "to_"],
    _p_ = [0, "from"],
    cst_bug_set_status_transition_ =
      "bug -- set_status transition not allowed",
    cst_src_synchronous_time_sourc = "src/synchronous_time_source0.ml:226:12";
   function invariant(t){
    return caml_call4
            (Base_Invariant[1],
             _m_,
             t,
             sexp_of_event,
             function(param){
              function check(f){return caml_call2(Base_Invariant[2], t, f);}
              var
               _bS_ =
                 check
                  (function(ppx_optional_e_0){
                    if(caml_call1(Option[7][1][1], ppx_optional_e_0)) return 0;
                    var
                     prev_fired = caml_call1(Option[7][1][2], ppx_optional_e_0),
                     got = t[8],
                     sexpifier = Status[3];
                    function comparator(a_013, b_014){
                     return caml_call2(Status[1], a_013, b_014);
                    }
                    caml_call8
                     (Ppx_assert_lib_Runtime[3],
                      pos,
                      sexpifier,
                      comparator,
                      0,
                      0,
                      0,
                      0,
                      got);
                    var _b2_ = prev_fired[6], _b3_ = caml_call1(Option[3], t);
                    if(caml_call2(Core[246], _b3_, _b2_)) return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _k_], 1);
                   }),
               _bT_ =
                 check
                  (function(ppx_optional_e_0){
                    if(caml_call1(Option[7][1][1], ppx_optional_e_0)) return 0;
                    var
                     next_fired = caml_call1(Option[7][1][2], ppx_optional_e_0),
                     got = t[8],
                     sexpifier = Status[3];
                    function comparator(a_009, b_010){
                     return caml_call2(Status[1], a_009, b_010);
                    }
                    caml_call8
                     (Ppx_assert_lib_Runtime[3],
                      pos$0,
                      sexpifier,
                      comparator,
                      0,
                      0,
                      0,
                      0,
                      got);
                    var _b0_ = next_fired[7], _b1_ = caml_call1(Option[3], t);
                    if(caml_call2(Core[246], _b1_, _b0_)) return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _l_], 1);
                   }),
               _bU_ =
                 check
                  (function(alarm){
                    var
                     got = caml_call1(Alarm[6], alarm),
                     expect = 2 === t[8] ? 0 : 1,
                     sexpifier = Core[305];
                    function comparator(a_005, b_006){
                     return caml_call2(Core[301], a_005, b_006);
                    }
                    return caml_call8
                            (Ppx_assert_lib_Runtime[3],
                             pos$1,
                             sexpifier,
                             comparator,
                             0,
                             0,
                             0,
                             expect,
                             got);
                   });
              return caml_call8
                      (Fields[13],
                       _bU_,
                       function(_bZ_){return 0;},
                       function(_bY_){return 0;},
                       function(_bX_){return 0;},
                       function(_bW_){return 0;},
                       _bT_,
                       _bS_,
                       function(_bV_){return 0;});
             });
   }
   function set_status$0(t, to){
    var from = t[8];
    if(1 - caml_call2(Status[4], from, to)){
     var
      _bN_ = [0, [1, [0, _n_, [0, sexp_of_event(t), 0]]], 0],
      _bO_ = [0, [1, [0, _o_, [0, caml_call1(Status[3], to), 0]]], _bN_],
      _bP_ = [0, [1, [0, _p_, [0, caml_call1(Status[3], from), 0]]], _bO_],
      _bQ_ =
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_bug_set_status_transition_),
         _bP_],
      _bR_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_src_synchronous_time_sourc),
          _bQ_]];
     caml_call1(Core[253], _bR_);
    }
    t[8] = to;
    return 0;
   }
   function set_status_if(is, t, to){
    var _bM_ = caml_call2(Status[2], is, t[8]);
    return _bM_ ? set_status$0(t, to) : _bM_;
   }
   var
    Event =
      [0,
       Status,
       sexp_of_event,
       Option,
       status,
       prev_fired,
       set_prev_fired,
       next_fired,
       set_next_fired,
       interval,
       set_interval,
       execution_context,
       callback,
       at$0,
       set_at,
       alarm,
       set_alarm,
       Fields,
       sexp_of_event,
       invariant,
       set_status$0,
       set_status_if,
       at$0],
    of_event = Async_kernel_Job_or_event[1],
    of_job = Async_kernel_Job_or_event[2],
    is_event = Async_kernel_Job_or_event[3],
    is_job = Async_kernel_Job_or_event[4],
    Match = Async_kernel_Job_or_event[5],
    cst_Job_t = "<Job.t>";
   function sexp_of_t$3(t){
    var
     k = caml_call1(Async_kernel_Job_or_event[5][1], t),
     match = caml_call2(Async_kernel_Job_or_event[5][2], k, t);
    return k
            ? caml_call1(Sexplib0_Sexp_conv[7], cst_Job_t)
            : caml_call1(Event[18], match);
   }
   var
    Job_or_event = [0, of_event, of_job, is_event, is_job, Match, sexp_of_t$3];
   function scheduler(r){return r[9];}
   function is_wall_clock(r){return r[8];}
   function handle_fired(r){return r[7];}
   function most_recently_fired(r){return r[6];}
   function set_most_recently_fired(r, v){r[6] = v; return 0;}
   function fired_events(r){return r[5];}
   function set_fired_events(r, v){r[5] = v; return 0;}
   function events(r){return r[4];}
   function am_advancing(r){return r[3];}
   function set_am_advancing(r, v){r[3] = v; return 0;}
   function advance_errors(r){return r[2];}
   function set_advance_errors(r, v){r[2] = v; return 0;}
   function id(r){return r[1];}
   var
    scheduler$0 =
      [0,
       function(param){return 0;},
       cst_scheduler,
       0,
       scheduler,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], v];
       }],
    is_wall_clock$0 =
      [0,
       function(param){return 0;},
       cst_is_wall_clock,
       0,
       is_wall_clock,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], v, r[9]];
       }],
    handle_fired$0 =
      [0,
       function(param){return 0;},
       cst_handle_fired,
       0,
       handle_fired,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], v, r[8], r[9]];
       }],
    most_recently_fired$0 =
      [0,
       function(param){return 0;},
       cst_most_recently_fired,
       [0, set_most_recently_fired],
       most_recently_fired,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8], r[9]];
       }],
    fired_events$0 =
      [0,
       function(param){return 0;},
       cst_fired_events,
       [0, set_fired_events],
       fired_events,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8], r[9]];
       }],
    events$0 =
      [0,
       function(param){return 0;},
       cst_events,
       0,
       events,
       function(r, v){
        return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8], r[9]];
       }],
    am_advancing$0 =
      [0,
       function(param){return 0;},
       cst_am_advancing,
       [0, set_am_advancing],
       am_advancing,
       function(r, v){
        return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8], r[9]];
       }],
    advance_errors$0 =
      [0,
       function(param){return 0;},
       cst_advance_errors,
       [0, set_advance_errors],
       advance_errors,
       function(r, v){
        return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8], r[9]];
       }],
    id$0 =
      [0,
       function(param){return 0;},
       cst_id,
       0,
       id,
       function(r, v){
        return [0, v, r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9]];
       }];
   function make_creator$0
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun,
    compile_acc){
    var
     match = caml_call2(id_fun, id$0, compile_acc),
     compile_acc$0 = match[2],
     id_gen = match[1],
     match$0 = caml_call2(advance_errors_fun, advance_errors$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     advance_errors_gen = match$0[1],
     match$1 = caml_call2(am_advancing_fun, am_advancing$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     am_advancing_gen = match$1[1],
     match$2 = caml_call2(events_fun, events$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     events_gen = match$2[1],
     match$3 = caml_call2(fired_events_fun, fired_events$0, compile_acc$3),
     compile_acc$4 = match$3[2],
     fired_events_gen = match$3[1],
     match$4 =
       caml_call2
        (most_recently_fired_fun, most_recently_fired$0, compile_acc$4),
     compile_acc$5 = match$4[2],
     most_recently_fired_gen = match$4[1],
     match$5 = caml_call2(handle_fired_fun, handle_fired$0, compile_acc$5),
     compile_acc$6 = match$5[2],
     handle_fired_gen = match$5[1],
     match$6 = caml_call2(is_wall_clock_fun, is_wall_clock$0, compile_acc$6),
     compile_acc$7 = match$6[2],
     is_wall_clock_gen = match$6[1],
     match$7 = caml_call2(scheduler_fun, scheduler$0, compile_acc$7),
     compile_acc$8 = match$7[2],
     scheduler_gen = match$7[1];
    return [0,
            function(acc){
             var
              id = caml_call1(id_gen, acc),
              advance_errors = caml_call1(advance_errors_gen, acc),
              am_advancing = caml_call1(am_advancing_gen, acc),
              events = caml_call1(events_gen, acc),
              fired_events = caml_call1(fired_events_gen, acc),
              most_recently_fired = caml_call1(most_recently_fired_gen, acc),
              handle_fired = caml_call1(handle_fired_gen, acc),
              is_wall_clock = caml_call1(is_wall_clock_gen, acc),
              scheduler = caml_call1(scheduler_gen, acc);
             return [0,
                     id,
                     advance_errors,
                     am_advancing,
                     events,
                     fired_events,
                     most_recently_fired,
                     handle_fired,
                     is_wall_clock,
                     scheduler];
            },
            compile_acc$8];
   }
   function create$0
   (id,
    advance_errors,
    am_advancing,
    events,
    fired_events,
    most_recently_fired,
    handle_fired,
    is_wall_clock,
    scheduler){
    return [0,
            id,
            advance_errors,
            am_advancing,
            events,
            fired_events,
            most_recently_fired,
            handle_fired,
            is_wall_clock,
            scheduler];
   }
   function map$1
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _bE_ = caml_call1(scheduler_fun, scheduler$0),
     _bF_ = caml_call1(is_wall_clock_fun, is_wall_clock$0),
     _bG_ = caml_call1(handle_fired_fun, handle_fired$0),
     _bH_ = caml_call1(most_recently_fired_fun, most_recently_fired$0),
     _bI_ = caml_call1(fired_events_fun, fired_events$0),
     _bJ_ = caml_call1(events_fun, events$0),
     _bK_ = caml_call1(am_advancing_fun, am_advancing$0),
     _bL_ = caml_call1(advance_errors_fun, advance_errors$0);
    return [0,
            caml_call1(id_fun, id$0),
            _bL_,
            _bK_,
            _bJ_,
            _bI_,
            _bH_,
            _bG_,
            _bF_,
            _bE_];
   }
   function iter$1
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    caml_call1(id_fun, id$0);
    caml_call1(advance_errors_fun, advance_errors$0);
    caml_call1(am_advancing_fun, am_advancing$0);
    caml_call1(events_fun, events$0);
    caml_call1(fired_events_fun, fired_events$0);
    caml_call1(most_recently_fired_fun, most_recently_fired$0);
    caml_call1(handle_fired_fun, handle_fired$0);
    caml_call1(is_wall_clock_fun, is_wall_clock$0);
    return caml_call1(scheduler_fun, scheduler$0);
   }
   function fold$1
   (init,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    return caml_call2
            (scheduler_fun,
             caml_call2
              (is_wall_clock_fun,
               caml_call2
                (handle_fired_fun,
                 caml_call2
                  (most_recently_fired_fun,
                   caml_call2
                    (fired_events_fun,
                     caml_call2
                      (events_fun,
                       caml_call2
                        (am_advancing_fun,
                         caml_call2
                          (advance_errors_fun,
                           caml_call2(id_fun, init, id$0),
                           advance_errors$0),
                         am_advancing$0),
                       events$0),
                     fired_events$0),
                   most_recently_fired$0),
                 handle_fired$0),
               is_wall_clock$0),
             scheduler$0);
   }
   function map_poly$0(record){
    var
     _bw_ = [0, caml_call1(record[1], scheduler$0), 0],
     _bx_ = [0, caml_call1(record[1], is_wall_clock$0), _bw_],
     _by_ = [0, caml_call1(record[1], handle_fired$0), _bx_],
     _bz_ = [0, caml_call1(record[1], most_recently_fired$0), _by_],
     _bA_ = [0, caml_call1(record[1], fired_events$0), _bz_],
     _bB_ = [0, caml_call1(record[1], events$0), _bA_],
     _bC_ = [0, caml_call1(record[1], am_advancing$0), _bB_],
     _bD_ = [0, caml_call1(record[1], advance_errors$0), _bC_];
    return [0, caml_call1(record[1], id$0), _bD_];
   }
   function for_all$1
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _bo_ = caml_call1(id_fun, id$0),
     _bp_ = _bo_ ? caml_call1(advance_errors_fun, advance_errors$0) : _bo_,
     _bq_ = _bp_ ? caml_call1(am_advancing_fun, am_advancing$0) : _bp_,
     _br_ = _bq_ ? caml_call1(events_fun, events$0) : _bq_,
     _bs_ = _br_ ? caml_call1(fired_events_fun, fired_events$0) : _br_,
     _bt_ =
       _bs_
        ? caml_call1(most_recently_fired_fun, most_recently_fired$0)
        : _bs_,
     _bu_ = _bt_ ? caml_call1(handle_fired_fun, handle_fired$0) : _bt_,
     _bv_ = _bu_ ? caml_call1(is_wall_clock_fun, is_wall_clock$0) : _bu_;
    return _bv_ ? caml_call1(scheduler_fun, scheduler$0) : _bv_;
   }
   function exists$1
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _bn_ = caml_call1(id_fun, id$0),
     _bg_ = _bn_ || caml_call1(advance_errors_fun, advance_errors$0),
     _bh_ = _bg_ || caml_call1(am_advancing_fun, am_advancing$0),
     _bi_ = _bh_ || caml_call1(events_fun, events$0),
     _bj_ = _bi_ || caml_call1(fired_events_fun, fired_events$0),
     _bk_ = _bj_ || caml_call1(most_recently_fired_fun, most_recently_fired$0),
     _bl_ = _bk_ || caml_call1(handle_fired_fun, handle_fired$0),
     _bm_ = _bl_ || caml_call1(is_wall_clock_fun, is_wall_clock$0);
    return _bm_ ? _bm_ : caml_call1(scheduler_fun, scheduler$0);
   }
   function to_list$1
   (id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _a__ = [0, caml_call1(scheduler_fun, scheduler$0), 0],
     _a$_ = [0, caml_call1(is_wall_clock_fun, is_wall_clock$0), _a__],
     _ba_ = [0, caml_call1(handle_fired_fun, handle_fired$0), _a$_],
     _bb_ =
       [0, caml_call1(most_recently_fired_fun, most_recently_fired$0), _ba_],
     _bc_ = [0, caml_call1(fired_events_fun, fired_events$0), _bb_],
     _bd_ = [0, caml_call1(events_fun, events$0), _bc_],
     _be_ = [0, caml_call1(am_advancing_fun, am_advancing$0), _bd_],
     _bf_ = [0, caml_call1(advance_errors_fun, advance_errors$0), _be_];
    return [0, caml_call1(id_fun, id$0), _bf_];
   }
   function iter$2
   (record,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    caml_call3(id_fun, id$0, record, record[1]);
    caml_call3(advance_errors_fun, advance_errors$0, record, record[2]);
    caml_call3(am_advancing_fun, am_advancing$0, record, record[3]);
    caml_call3(events_fun, events$0, record, record[4]);
    caml_call3(fired_events_fun, fired_events$0, record, record[5]);
    caml_call3
     (most_recently_fired_fun, most_recently_fired$0, record, record[6]);
    caml_call3(handle_fired_fun, handle_fired$0, record, record[7]);
    caml_call3(is_wall_clock_fun, is_wall_clock$0, record, record[8]);
    return caml_call3(scheduler_fun, scheduler$0, record, record[9]);
   }
   function fold$2
   (record,
    init,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _a2_ = record[9],
     _a3_ = record[8],
     _a4_ = record[7],
     _a5_ = record[6],
     _a6_ = record[5],
     _a7_ = record[4],
     _a8_ = record[3],
     _a9_ = record[2];
    return caml_call4
            (scheduler_fun,
             caml_call4
              (is_wall_clock_fun,
               caml_call4
                (handle_fired_fun,
                 caml_call4
                  (most_recently_fired_fun,
                   caml_call4
                    (fired_events_fun,
                     caml_call4
                      (events_fun,
                       caml_call4
                        (am_advancing_fun,
                         caml_call4
                          (advance_errors_fun,
                           caml_call4(id_fun, init, id$0, record, record[1]),
                           advance_errors$0,
                           record,
                           _a9_),
                         am_advancing$0,
                         record,
                         _a8_),
                       events$0,
                       record,
                       _a7_),
                     fired_events$0,
                     record,
                     _a6_),
                   most_recently_fired$0,
                   record,
                   _a5_),
                 handle_fired$0,
                 record,
                 _a4_),
               is_wall_clock$0,
               record,
               _a3_),
             scheduler$0,
             record,
             _a2_);
   }
   function for_all$2
   (record,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _aU_ = caml_call3(id_fun, id$0, record, record[1]),
     _aV_ =
       _aU_
        ? caml_call3(advance_errors_fun, advance_errors$0, record, record[2])
        : _aU_,
     _aW_ =
       _aV_
        ? caml_call3(am_advancing_fun, am_advancing$0, record, record[3])
        : _aV_,
     _aX_ = _aW_ ? caml_call3(events_fun, events$0, record, record[4]) : _aW_,
     _aY_ =
       _aX_
        ? caml_call3(fired_events_fun, fired_events$0, record, record[5])
        : _aX_,
     _aZ_ =
       _aY_
        ? caml_call3
          (most_recently_fired_fun, most_recently_fired$0, record, record[6])
        : _aY_,
     _a0_ =
       _aZ_
        ? caml_call3(handle_fired_fun, handle_fired$0, record, record[7])
        : _aZ_,
     _a1_ =
       _a0_
        ? caml_call3(is_wall_clock_fun, is_wall_clock$0, record, record[8])
        : _a0_;
    return _a1_
            ? caml_call3(scheduler_fun, scheduler$0, record, record[9])
            : _a1_;
   }
   function exists$2
   (record,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _aT_ = caml_call3(id_fun, id$0, record, record[1]),
     _aM_ =
       _aT_
       || caml_call3(advance_errors_fun, advance_errors$0, record, record[2]),
     _aN_ =
       _aM_ || caml_call3(am_advancing_fun, am_advancing$0, record, record[3]),
     _aO_ = _aN_ || caml_call3(events_fun, events$0, record, record[4]),
     _aP_ =
       _aO_ || caml_call3(fired_events_fun, fired_events$0, record, record[5]),
     _aQ_ =
       _aP_
       ||
        caml_call3
         (most_recently_fired_fun, most_recently_fired$0, record, record[6]),
     _aR_ =
       _aQ_ || caml_call3(handle_fired_fun, handle_fired$0, record, record[7]),
     _aS_ =
       _aR_
       || caml_call3(is_wall_clock_fun, is_wall_clock$0, record, record[8]);
    return _aS_
            ? _aS_
            : caml_call3(scheduler_fun, scheduler$0, record, record[9]);
   }
   function to_list$2
   (record,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _aE_ = [0, caml_call3(scheduler_fun, scheduler$0, record, record[9]), 0],
     _aF_ =
       [0,
        caml_call3(is_wall_clock_fun, is_wall_clock$0, record, record[8]),
        _aE_],
     _aG_ =
       [0,
        caml_call3(handle_fired_fun, handle_fired$0, record, record[7]),
        _aF_],
     _aH_ =
       [0,
        caml_call3
         (most_recently_fired_fun, most_recently_fired$0, record, record[6]),
        _aG_],
     _aI_ =
       [0,
        caml_call3(fired_events_fun, fired_events$0, record, record[5]),
        _aH_],
     _aJ_ = [0, caml_call3(events_fun, events$0, record, record[4]), _aI_],
     _aK_ =
       [0,
        caml_call3(am_advancing_fun, am_advancing$0, record, record[3]),
        _aJ_],
     _aL_ =
       [0,
        caml_call3(advance_errors_fun, advance_errors$0, record, record[2]),
        _aK_];
    return [0, caml_call3(id_fun, id$0, record, record[1]), _aL_];
   }
   function map$2
   (record,
    id_fun,
    advance_errors_fun,
    am_advancing_fun,
    events_fun,
    fired_events_fun,
    most_recently_fired_fun,
    handle_fired_fun,
    is_wall_clock_fun,
    scheduler_fun){
    var
     _aw_ = caml_call3(scheduler_fun, scheduler$0, record, record[9]),
     _ax_ = caml_call3(is_wall_clock_fun, is_wall_clock$0, record, record[8]),
     _ay_ = caml_call3(handle_fired_fun, handle_fired$0, record, record[7]),
     _az_ =
       caml_call3
        (most_recently_fired_fun, most_recently_fired$0, record, record[6]),
     _aA_ = caml_call3(fired_events_fun, fired_events$0, record, record[5]),
     _aB_ = caml_call3(events_fun, events$0, record, record[4]),
     _aC_ = caml_call3(am_advancing_fun, am_advancing$0, record, record[3]),
     _aD_ =
       caml_call3(advance_errors_fun, advance_errors$0, record, record[2]);
    return [0,
            caml_call3(id_fun, id$0, record, record[1]),
            _aD_,
            _aC_,
            _aB_,
            _aA_,
            _az_,
            _ay_,
            _ax_,
            _aw_];
   }
   function set_all_mutable_fields$0
   (record, advance_errors, am_advancing, fired_events, most_recently_fired){
    var record$0 = caml_call1(Base_Field[1][1], record);
    record$0[2] = advance_errors;
    record$0[3] = am_advancing;
    record$0[5] = fired_events;
    record$0[6] = most_recently_fired;
    return 0;
   }
   var
    Direct$0 =
      [0,
       iter$2,
       fold$2,
       for_all$2,
       exists$2,
       to_list$2,
       map$2,
       set_all_mutable_fields$0],
    Fields$0 =
      [0,
       names$0,
       scheduler$0,
       is_wall_clock$0,
       handle_fired$0,
       most_recently_fired$0,
       fired_events$0,
       events$0,
       am_advancing$0,
       advance_errors$0,
       id$0,
       make_creator$0,
       create$0,
       map$1,
       iter$1,
       fold$1,
       map_poly$0,
       for_all$1,
       exists$1,
       to_list$1,
       Direct$0],
    _q_ = [0, cst_now],
    cst_wall_clock = "wall_clock",
    _r_ = [0, cst_events],
    _s_ = [0, cst_now],
    _t_ = [0, cst_src_synchronous_time_sourc$0, 362, 29],
    _u_ = [0, cst_src_synchronous_time_sourc$0, 350, 17],
    _v_ = [0, cst_src_synchronous_time_sourc$0, 346, 15],
    _w_ = [0, cst_src_synchronous_time_sourc$0, 339, 17],
    _x_ = [0, "_"],
    _y_ = [0, cst_src_synchronous_time_sourc$0, 323, 11243, 11267];
   function sexp_of_t$4(param, _ao_){
    var
     events = _ao_[4],
     is_wall_clock = _ao_[8],
     now = caml_call1(Timing_wheel[11], events);
    if(is_wall_clock){
     var _ap_ = [0, [1, [0, _q_, [0, caml_call1(Time_ns[113], now), 0]]], 0];
     return [1, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_wall_clock), _ap_]];
    }
    var all_events = [0, 0];
    caml_call2
     (Timing_wheel[15],
      events,
      function(alarm){
       var _au_ = all_events[1], _av_ = caml_call2(Alarm[5], events, alarm);
       all_events[1] =
        [0, [0, caml_call2(Alarm[3], events, alarm), _av_], _au_];
       return 0;
      });
    var
     _aq_ =
       caml_call2
        (Core_List[58],
         all_events[1],
         function(param, _at_){
          var at2 = _at_[1], at1 = param[1];
          return caml_call2(Time_ns[100], at1, at2);
         }),
     events$0 =
       caml_call2(Core_List[72], _aq_, function(_as_){return _as_[2];}),
     _ar_ =
       [0,
        [1,
         [0, _r_, [0, caml_call2(Core[421], Job_or_event[6], events$0), 0]]],
        0];
    return [1,
            [0, [1, [0, _s_, [0, caml_call1(Time_ns[113], now), 0]]], _ar_]];
   }
   function timing_wheel_now(t){return caml_call1(Timing_wheel[11], t[4]);}
   function is_in_fired_events(t, target_event){
    var current$1 = t[5], ppx_optional_e_0 = current$1;
    for(;;){
     if(caml_call1(Event[3][7][1][1], ppx_optional_e_0)) return 0;
     var
      current = caml_call1(Event[3][7][1][2], ppx_optional_e_0),
      _an_ = caml_call2(Core[246], current, target_event);
     if(_an_) return _an_;
     var current$0 = current[6];
     ppx_optional_e_0 = current$0;
    }
   }
   function invariant_with_jobs(job_invariant, t){
    return caml_call4
            (Base_Invariant[1],
             _y_,
             t,
             function(x_016){
              return sexp_of_t$4(function(param){return _x_;}, x_016);
             },
             function(param){
              function check(f){return caml_call2(Base_Invariant[2], t, f);}
              var
               _ac_ =
                 check
                  (function(most_recently_fired){
                    if(caml_call1(Event[3][7][1][1], most_recently_fired))
                     return 0;
                    var
                     event = caml_call1(Event[3][7][1][2], most_recently_fired);
                    if(is_in_fired_events(t, event)) return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _t_], 1);
                   }),
               _ad_ =
                 check
                  (function(ppx_optional_e_0){
                    if(caml_call1(Event[3][7][1][1], ppx_optional_e_0))
                     return 0;
                    var
                     current$1 = caml_call1(Event[3][7][1][2], ppx_optional_e_0),
                     current = current$1;
                    for(;;){
                     var _am_ = timing_wheel_now(t);
                     if(! caml_call2(Time_ns[94], current[2], _am_))
                      throw caml_maybe_attach_backtrace
                             ([0, Assert_failure, _v_], 1);
                     var ppx_optional_e_0$0 = current[6];
                     if(caml_call1(Event[3][7][1][1], ppx_optional_e_0$0))
                      return 0;
                     var
                      current$0 =
                        caml_call1(Event[3][7][1][2], ppx_optional_e_0$0);
                     if(! caml_call2(Time_ns[94], current[2], current$0[2]))
                      throw caml_maybe_attach_backtrace
                             ([0, Assert_failure, _u_], 1);
                     current = current$0;
                    }
                   }),
               _ae_ =
                 check
                  (function(events){
                    caml_call2
                     (Timing_wheel[6], function(_al_){return 0;}, events);
                    return caml_call2
                            (Timing_wheel[15],
                             events,
                             function(alarm){
                              var
                               job_or_event = caml_call2(Alarm[5], events, alarm),
                               k = caml_call1(Job_or_event[5][1], job_or_event),
                               event = caml_call2(Job_or_event[5][2], k, job_or_event);
                              if(k) return caml_call1(job_invariant, event);
                              if(! caml_call2(Core[246], alarm, event[1]))
                               throw caml_maybe_attach_backtrace
                                      ([0, Assert_failure, _w_], 1);
                              var
                               got = event[2],
                               expect = caml_call2(Alarm[3], events, alarm),
                               sexpifier = Time_ns[113];
                              function comparator(a_017, b_018){
                               return caml_call2(Time_ns[100], a_017, b_018);
                              }
                              caml_call8
                               (Ppx_assert_lib_Runtime[3],
                                pos$2,
                                sexpifier,
                                comparator,
                                0,
                                0,
                                0,
                                expect,
                                got);
                              var got$0 = event[8], sexpifier$0 = Event[1][3];
                              function comparator$0(a_019, b_020){
                               return caml_call2(Event[1][1], a_019, b_020);
                              }
                              caml_call8
                               (Ppx_assert_lib_Runtime[3],
                                pos$3,
                                sexpifier$0,
                                comparator$0,
                                0,
                                0,
                                0,
                                2,
                                got$0);
                              return caml_call1(Event[19], event);
                             });
                   });
              return caml_call9
                      (Fields$0[14],
                       function(_ak_){return 0;},
                       function(_aj_){return 0;},
                       function(_ai_){return 0;},
                       _ae_,
                       _ad_,
                       _ac_,
                       function(_ah_){return 0;},
                       function(_ag_){return 0;},
                       function(_af_){return 0;});
             });
   }
   function invariant$0(t){
    return invariant_with_jobs(function(param){return 0;}, t);
   }
   var
    T1 =
      [0,
       Event,
       Job_or_event,
       scheduler,
       is_wall_clock,
       handle_fired,
       most_recently_fired,
       set_most_recently_fired,
       fired_events,
       set_fired_events,
       events,
       am_advancing,
       set_am_advancing,
       advance_errors,
       set_advance_errors,
       id,
       Fields$0,
       sexp_of_t$4,
       timing_wheel_now,
       is_in_fired_events,
       invariant_with_jobs,
       invariant$0];
   function sexp_of_t$5(x_021){return caml_call2(T1[17], Core[171], x_021);}
   var invariant$1 = T1[21], invariant_with_jobs$0 = T1[20];
   function sexp_of_t$6(x_022){return caml_call2(T1[17], Core[202], x_022);}
   var Read_write = [0, sexp_of_t$6, invariant$1, invariant_with_jobs$0];
   function id$1(t){return t[1];}
   function is_wall_clock$1(t){return t[8];}
   function length(t){return caml_call1(Timing_wheel[14], t[4]);}
   function max_allowed_alarm_time(t){
    return caml_call1(Timing_wheel[22], t[4]);
   }
   function read_only(t){return t;}
   function fire(t, event){
    caml_call2(T1[1][20], event, 0);
    event[1] = caml_call1(Alarm[2], 0);
    var ppx_optional_e_0 = t[6];
    a:
    {
     if(! caml_call1(T1[1][3][7][1][1], ppx_optional_e_0)){
      var
       most_recently_fired = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0);
      if(caml_call2(Time_ns[94], most_recently_fired[2], event[2])){
       var
        most_recently_fired$0 =
          caml_call1(T1[1][3][7][1][2], ppx_optional_e_0);
       event[7] = caml_call1(T1[1][3][3], most_recently_fired$0);
       event[6] = most_recently_fired$0[6];
       break a;
      }
     }
     event[7] = T1[1][3][2];
     event[6] = t[5];
    }
    t[6] = caml_call1(T1[1][3][3], event);
    for(;;){
     var ppx_optional_e_0$0 = event[6];
     if(caml_call1(T1[1][3][7][1][1], ppx_optional_e_0$0))
      var continue$0 = 0;
     else{
      var
       next$0 = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0$0),
       continue$1 = caml_call2(Time_ns[94], next$0[2], event[2]);
      if(continue$1){event[7] = event[6]; event[6] = next$0[6];}
      var continue$0 = continue$1;
     }
     if(! continue$0) break;
    }
    var ppx_optional_e_0$1 = event[6];
    if(! caml_call1(T1[1][3][7][1][1], ppx_optional_e_0$1)){
     var next = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0$1);
     next[7] = caml_call1(T1[1][3][3], event);
    }
    var ppx_optional_e_0$2 = event[7];
    if(caml_call1(T1[1][3][7][1][1], ppx_optional_e_0$2)){t[5] = caml_call1(T1[1][3][3], event); return 0;}
    var prev = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0$2);
    prev[6] = caml_call1(T1[1][3][3], event);
    return 0;
   }
   function alarm_precision(t){return caml_call1(Timing_wheel[10], t[4]);}
   function next_alarm_fires_at(t){return caml_call1(Timing_wheel[38], t[4]);}
   function next_alarm_runs_at(t){
    return caml_call1(T1[1][3][5], t[5])
            ? [0, caml_call1(T1[18], t)]
            : caml_call1(Timing_wheel[38], t[4]);
   }
   function now$0(t){
    return t[8] ? caml_call1(Time_ns[50], 0) : caml_call1(T1[18], t);
   }
   var timing_wheel_now$0 = T1[18];
   function schedule(t, event){
    caml_call2(T1[1][20], event, 2);
    var _ab_ = caml_call1(T1[2][1], event);
    event[1] = caml_call3(Timing_wheel[25], t[4], event[2], _ab_);
    return 0;
   }
   function remove_from_fired(t, event, new_status){
    var ppx_optional_e_0 = t[6];
    if(! caml_call1(T1[1][3][7][1][1], ppx_optional_e_0)){
     var
      most_recently_fired = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0);
     if(caml_call2(Core[246], event, most_recently_fired))
      t[6] = caml_call2(T1[1][3][6], event[6], event[7]);
    }
    var ppx_optional_e_0$0 = event[7];
    if(caml_call1(T1[1][3][7][1][1], ppx_optional_e_0$0))
     t[5] = event[6];
    else{
     var prev = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0$0);
     prev[6] = event[6];
    }
    var ppx_optional_e_0$1 = event[6];
    if(! caml_call1(T1[1][3][7][1][1], ppx_optional_e_0$1)){
     var next = caml_call1(T1[1][3][7][1][2], ppx_optional_e_0$1);
     next[7] = event[7];
    }
    event[6] = T1[1][3][2];
    event[7] = T1[1][3][2];
    return caml_call2(T1[1][20], event, new_status);
   }
   var
    include$0 = T1[1],
    Status$0 = include$0[1],
    sexp_of_event$0 = include$0[2],
    Option$0 = include$0[3],
    status$1 = include$0[4],
    prev_fired$1 = include$0[5],
    set_prev_fired$0 = include$0[6],
    next_fired$1 = include$0[7],
    set_next_fired$0 = include$0[8],
    interval$1 = include$0[9],
    set_interval$0 = include$0[10],
    execution_context$1 = include$0[11],
    callback$1 = include$0[12],
    set_at$0 = include$0[14],
    alarm$1 = include$0[15],
    set_alarm$0 = include$0[16],
    Fields$1 = include$0[17],
    sexp_of_t$7 = include$0[18],
    invariant$2 = include$0[19],
    set_status$1 = include$0[20],
    set_status_if$0 = include$0[21],
    scheduled_at = include$0[22],
    _z_ = [0, "alarm_precision"],
    _A_ = [0, "span"],
    cst_interval_span_smaller_than =
      "interval span smaller than alarm precision",
    _B_ = [0, "Ok"],
    _C_ = [0, "Currently_happening"],
    _D_ = [0, "Previously_unscheduled"];
   function create_internal(t, at, interval, callback){
    var ___ = T1[1][3][2], _$_ = T1[1][3][2], _aa_ = t[9][7];
    return [0,
            caml_call1(Alarm[2], 0),
            at,
            callback,
            _aa_,
            interval,
            _$_,
            ___,
            3];
   }
   function add$0(t, event){
    var _Z_ = caml_call1(timing_wheel_now$0, t);
    return caml_call2(Time_ns[94], event[2], _Z_)
            ? fire(t, event)
            : schedule(t, event);
   }
   function create_and_add(t, at, interval, callback){
    var event = create_internal(t, at, interval, callback);
    add$0(t, event);
    return event;
   }
   function at$2(t, at, callback){return create_and_add(t, at, 0, callback);}
   function after$0(t, span, callback){
    var _Y_ = now$0(t);
    return create_and_add(t, caml_call2(Time_ns[112], _Y_, span), 0, callback);
   }
   function require_span_at_least_alarm_pr(t, span){
    var
     alarm_precision$0 = alarm_precision(t),
     _U_ = caml_call2(Core_Time_ns[1][19], span, alarm_precision$0);
    if(! _U_) return _U_;
    var
     _V_ =
       [0,
        [1,
         [0, _z_, [0, caml_call1(Core_Time_ns[1][10], alarm_precision$0), 0]]],
        0],
     _W_ =
       [0, [1, [0, _A_, [0, caml_call1(Core_Time_ns[1][10], span), 0]]], _V_],
     _X_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_interval_span_smaller_than),
         _W_]];
    return caml_call1(Core[253], _X_);
   }
   function at_intervals(t, span, callback){
    require_span_at_least_alarm_pr(t, span);
    return create_and_add(t, now$0(t), [0, span], callback);
   }
   function sexp_of_t$8(param){
    switch(param){case 0: return _B_;case 1: return _C_;default: return _D_;
    }
   }
   var
    Abort_result = [0, sexp_of_t$8],
    _E_ = [0, "reason"],
    cst_Synchronous_time_source_ab =
      "[Synchronous_time_source.abort_exn] cannot abort event",
    _F_ = [0, 0],
    cst_cannot_schedule_an_event_w = "cannot schedule an event with status";
   function abort(t, event){
    switch(event[8]){
      case 0:
       remove_from_fired(t, event, 3); return 0;
      case 1:
       return event[5] ? (event[5] = 0, 0) : 1;
      case 2:
       caml_call2(T1[1][20], event, 3);
       caml_call2(Timing_wheel[28], t[4], event[1]);
       event[1] = caml_call1(Alarm[2], 0);
       return 0;
      default: return 2;
    }
   }
   function abort_if_possible(t, event){abort(t, event); return 0;}
   function abort_exn(t, event){
    var reason = abort(t, event);
    if(! reason) return 0;
    var
     _S_ = [0, [1, [0, _E_, [0, caml_call1(Abort_result[1], reason), 0]]], 0],
     _T_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Synchronous_time_source_ab),
         _S_]];
    return caml_call1(Core[253], _T_);
   }
   function create$1(t, callback){
    return create_internal(t, Time_ns[43], 0, callback);
   }
   function schedule_at_internal(t, event, at, interval){
    var status = event[8];
    if(3 <= status){
     event[2] = at;
     event[5] = interval;
     add$0(t, event);
     return _F_;
    }
    var
     _Q_ = [0, caml_call1(T1[1][1][3], status), 0],
     _R_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_cannot_schedule_an_event_w),
         _Q_]];
    return caml_call1(Core_Or_error[40], _R_);
   }
   function schedule_at(t, event, at){
    return schedule_at_internal(t, event, at, 0);
   }
   function schedule_after(t, event, span){
    var _P_ = now$0(t);
    return schedule_at(t, event, caml_call2(Time_ns[112], _P_, span));
   }
   function schedule_at_intervals(t, event, span){
    require_span_at_least_alarm_pr(t, span);
    return schedule_at_internal(t, event, now$0(t), [0, span]);
   }
   function reschedule_at(t, event, at){
    switch(event[8]){
      case 0:
       remove_from_fired(t, event, 3); event[2] = at; return add$0(t, event);
      case 1:
       event[2] = at; return add$0(t, event);
      case 2:
       event[2] = at;
       var _O_ = caml_call1(timing_wheel_now$0, t);
       return caml_call2(Time_ns[96], at, _O_)
               ? caml_call3(Timing_wheel[29], t[4], event[1], at)
               : (caml_call2
                  (Timing_wheel[28], t[4], event[1]),
                 fire(t, event));
      default: event[2] = at; event[5] = 0; return add$0(t, event);
    }
   }
   function reschedule_after(t, event, span){
    var _N_ = now$0(t);
    return reschedule_at(t, event, caml_call2(Time_ns[112], _N_, span));
   }
   var
    Event$0 =
      [0,
       Status$0,
       sexp_of_event$0,
       Option$0,
       status$1,
       prev_fired$1,
       set_prev_fired$0,
       next_fired$1,
       set_next_fired$0,
       interval$1,
       set_interval$0,
       execution_context$1,
       callback$1,
       set_at$0,
       alarm$1,
       set_alarm$0,
       Fields$1,
       sexp_of_t$7,
       invariant$2,
       set_status$1,
       set_status_if$0,
       scheduled_at,
       create_internal,
       add$0,
       create_and_add,
       at$2,
       after$0,
       require_span_at_least_alarm_pr,
       at_intervals,
       Abort_result,
       abort,
       abort_if_possible,
       abort_exn,
       create$1,
       schedule_at_internal,
       schedule_at,
       schedule_after,
       schedule_at_intervals,
       reschedule_at,
       reschedule_after],
    _G_ = [0, cst_src_synchronous_time_sourc$0, 633, 48],
    cst_cannot_call_advance_by_ala =
      "cannot call [advance_by_alarms] or [advance_directly] from callback",
    _H_ = [0, 0];
   function run_after(t, span, callback){
    caml_call3(Event$0[26], t, span, callback);
    return 0;
   }
   function run_at(t, at, callback){
    caml_call3(Event$0[25], t, at, callback);
    return 0;
   }
   function run_at_intervals(t, span, callback){
    caml_call3(Event$0[28], t, span, callback);
    return 0;
   }
   function run_fired_events(t, send_exn){
    var current_execution_context = t[9][7];
    for(;;){
     var ppx_optional_e_0 = t[5];
     if(caml_call1(Event$0[3][7][1][1], ppx_optional_e_0))
      var _K_ = 0;
     else{
      var event = caml_call1(Event$0[3][7][1][2], ppx_optional_e_0);
      if(event[8])
       throw caml_maybe_attach_backtrace([0, Assert_failure, _G_], 1);
      remove_from_fired(t, event, 1);
      caml_call2(Async_kernel_Scheduler0[2], t[9], event[4]);
      a:
      {
       try{caml_call1(event[3], 0);}
       catch(exn$0){
        var exn = caml_wrap_exception(exn$0);
        if(send_exn){
         var
          send_exn$0 = send_exn[1],
          backtrace = caml_call1(Base_Backtrace[6][4], 0);
         caml_call3
          (send_exn$0, event[4][1], [0, [0, 936718974, backtrace]], exn);
        }
        else{
         var _L_ = t[2];
         t[2] = [0, caml_call2(Core_Error[25], 0, exn), _L_];
        }
        caml_call3(Event$0[20], 1, event, 3);
        break a;
       }
       var match = event[5];
       if(match){
        var interval = match[1];
        if(caml_call2(Event$0[1][2], 1, event[8])){
         var _M_ = caml_call1(timing_wheel_now$0, t);
         event[2] = caml_call5(Time_ns[65], 0, event[2], _M_, interval, 0);
         schedule(t, event);
        }
       }
       else
        caml_call3(Event$0[20], 1, event, 3);
      }
      var _K_ = 1;
     }
     if(! _K_)
      return caml_call2
              (Async_kernel_Scheduler0[2], t[9], current_execution_context);
    }
   }
   function advance_clock(t, to, send_exn){
    caml_call3(Timing_wheel[20], t[4], to, t[7]);
    return run_fired_events(t, send_exn);
   }
   function fire_past_alarms(t, send_exn){
    caml_call2(Timing_wheel[21], t[4], t[7]);
    return run_fired_events(t, send_exn);
   }
   function advance_internal(t, to, send_exn){
    advance_clock(t, to, send_exn);
    return fire_past_alarms(t, send_exn);
   }
   function prepare_to_advance(t, send_exn){
    if(t[3]){
     var
      _J_ = caml_call1(Sexplib0_Sexp_conv[7], cst_cannot_call_advance_by_ala);
     caml_call1(Core[253], _J_);
    }
    t[3] = 1;
    if(t[2]) t[2] = 0;
    return run_fired_events(t, send_exn);
   }
   function finish_advancing(t){
    t[3] = 0;
    var errors = t[2];
    return errors
            ? (t[2] = 0, [1, caml_call2(Core_Error[24], 0, errors)])
            : _H_;
   }
   function advance_by_alarms(t, to){
    var send_exn = 0;
    prepare_to_advance(t, send_exn);
    var continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]){
      advance_internal(t, to, send_exn);
      return finish_advancing(t);
     }
     if(caml_call1(Timing_wheel[13], t[4]))
      continue$0[1] = 0;
     else{
      var min_alarm_time = caml_call1(Timing_wheel[37], t[4]);
      if(caml_call2(Time_ns[93], min_alarm_time, to))
       continue$0[1] = 0;
      else
       advance_internal(t, min_alarm_time, send_exn);
     }
    }
   }
   function advance_by_max_alarms_in_each_(t, to){
    var send_exn = 0;
    prepare_to_advance(t, send_exn);
    var continue$0 = [0, 1];
    for(;;){
     if(! continue$0[1]){
      advance_internal(t, to, send_exn);
      return finish_advancing(t);
     }
     if(caml_call1(Timing_wheel[13], t[4]))
      continue$0[1] = 0;
     else{
      var next_alarm_fires_at = caml_call1(Timing_wheel[39], t[4]);
      if(caml_call2(Time_ns[93], next_alarm_fires_at, to))
       continue$0[1] = 0;
      else
       advance_internal(t, caml_call1(Timing_wheel[36], t[4]), send_exn);
     }
    }
   }
   function advance_directly(t, to){
    var send_exn = 0;
    prepare_to_advance(t, send_exn);
    advance_internal(t, to, send_exn);
    return finish_advancing(t);
   }
   function duration_of(t, f){
    var
     start = now$0(t),
     result = caml_call1(f, 0),
     _I_ = now$0(t),
     duration = caml_call2(Time_ns[57], _I_, start);
    return [0, result, duration];
   }
   function max_alarm_time_in_min_timing_w(t){
    return caml_call1(Timing_wheel[34], t[4]);
   }
   function has_events_to_run(t){return caml_call1(Event$0[3][5], t[5]);}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Synchronous_t);
   var
    Async_kernel_Synchronous_time_ =
      [0,
       Time_ns,
       Alarm,
       default_timing_wheel_config,
       T1,
       sexp_of_t$5,
       invariant$1,
       invariant_with_jobs$0,
       Read_write,
       id$1,
       is_wall_clock$1,
       length,
       max_allowed_alarm_time,
       read_only,
       fire,
       alarm_precision,
       next_alarm_fires_at,
       next_alarm_runs_at,
       now$0,
       timing_wheel_now$0,
       schedule,
       remove_from_fired,
       Event$0,
       run_after,
       run_at,
       run_at_intervals,
       run_fired_events,
       advance_clock,
       fire_past_alarms,
       advance_internal,
       prepare_to_advance,
       finish_advancing,
       advance_by_alarms,
       advance_by_max_alarms_in_each_,
       advance_directly,
       duration_of,
       max_alarm_time_in_min_timing_w,
       has_events_to_run];
   runtime.caml_register_global
    (102, Async_kernel_Synchronous_time_, cst_Async_kernel_Synchronous_t);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Scheduler1
//# unitInfo: Requires: Assert_failure, Async_kernel__Debug, Async_kernel__Execution_context, Async_kernel__External_job, Async_kernel__Import, Async_kernel__Job_pool, Async_kernel__Job_queue, Async_kernel__Scheduler0, Async_kernel__Synchronous_time_source0, Async_kernel__Time_ns, Async_kernel__Types, Async_kernel_config, Base__Exn, Base__Field, Base__Invariant, Core, Core__Deque, Core__Error, Core__Hashtbl, Core__Int, Core__List, Core__Option, Core__Result, Core__Sexp, Core__Time_ns, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Thread_safe_queue, Timing_wheel, Tuple_pool
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Scheduler1$0 = "Async_kernel__Scheduler1",
    cst_async_kernel$0 = "async_kernel",
    cst_check_access = "check_access",
    cst_check_invariants = "check_invariants",
    cst_current_execution_context = "current_execution_context",
    cst_cycle_count = "cycle_count",
    cst_cycle_start = "cycle_start",
    cst_event_added_hook = "event_added_hook",
    cst_exec = "exec",
    cst_execution_context = "execution_context",
    cst_external_jobs = "external_jobs",
    cst_in_cycle = "in_cycle",
    cst_job_pool = "job_pool",
    cst_job_queued_hook = "job_queued_hook",
    cst_last_cycle_num_jobs = "last_cycle_num_jobs",
    cst_last_cycle_time = "last_cycle_time",
    cst_low_priority_jobs = "low_priority_jobs",
    cst_main_execution_context = "main_execution_context",
    cst_max_num_jobs_per_priority_ = "max_num_jobs_per_priority_per_cycle",
    cst_normal_priority_jobs = "normal_priority_jobs",
    cst_record_backtraces = "record_backtraces",
    cst_run_every_cycle_end = "run_every_cycle_end",
    cst_run_every_cycle_end_state = "run_every_cycle_end_state",
    cst_run_every_cycle_start = "run_every_cycle_start",
    cst_run_every_cycle_start_stat = "run_every_cycle_start_state",
    cst_src_scheduler1_ml = "src/scheduler1.ml",
    cst_thread_safe_external_job_h = "thread_safe_external_job_hook",
    cst_time_source = "time_source",
    cst_total_cycle_time = "total_cycle_time",
    cst_uncaught_exn = "uncaught_exn",
    cst_very_low_priority_workers = "very_low_priority_workers",
    cst_yield = "yield",
    cst_yield_until_no_jobs_remain = "yield_until_no_jobs_remain",
    caml_list_of_js_array = runtime.caml_list_of_js_array,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call28
   (f,
    a0,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    a11,
    a12,
    a13,
    a14,
    a15,
    a16,
    a17,
    a18,
    a19,
    a20,
    a21,
    a22,
    a23,
    a24,
    a25,
    a26,
    a27){
    return (f.l >= 0 ? f.l : f.l = f.length) == 28
            ? f
              (a0,
               a1,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14,
               a15,
               a16,
               a17,
               a18,
               a19,
               a20,
               a21,
               a22,
               a23,
               a24,
               a25,
               a26,
               a27)
            : runtime.caml_call_gen
              (f,
               [a0,
                a1,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14,
                a15,
                a16,
                a17,
                a18,
                a19,
                a20,
                a21,
                a22,
                a23,
                a24,
                a25,
                a26,
                a27]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    names = [0, cst_execution_context, [0, cst_exec, 0]],
    names$0 =
      caml_list_of_js_array
       ([cst_check_access,
         cst_job_pool,
         cst_normal_priority_jobs,
         cst_low_priority_jobs,
         cst_very_low_priority_workers,
         cst_main_execution_context,
         cst_current_execution_context,
         cst_uncaught_exn,
         cst_cycle_count,
         cst_cycle_start,
         cst_in_cycle,
         cst_run_every_cycle_start,
         cst_run_every_cycle_start_stat,
         cst_run_every_cycle_end,
         cst_run_every_cycle_end_state,
         cst_last_cycle_time,
         cst_last_cycle_num_jobs,
         cst_total_cycle_time,
         cst_time_source,
         cst_external_jobs,
         cst_thread_safe_external_job_h,
         cst_job_queued_hook,
         cst_event_added_hook,
         cst_yield,
         cst_yield_until_no_jobs_remain,
         cst_check_invariants,
         cst_max_num_jobs_per_priority_,
         cst_record_backtraces]),
    Async_kernel_Job_queue = global_data.Async_kernel__Job_queue,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0,
    Timing_wheel = global_data.Timing_wheel,
    Async_kernel_config = global_data.Async_kernel_config,
    Async_kernel_Types = global_data.Async_kernel__Types,
    Core_Int = global_data.Core__Int,
    Base_Exn = global_data.Base__Exn,
    Core_Sexp = global_data.Core__Sexp,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Core_List = global_data.Core__List,
    Tuple_pool = global_data.Tuple_pool,
    Core = global_data.Core,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Core_Deque = global_data.Core__Deque,
    Async_kernel_Job_pool = global_data.Async_kernel__Job_pool,
    Assert_failure = global_data.Assert_failure,
    Base_Field = global_data.Base__Field,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Option = global_data.Core__Option,
    Core_Error = global_data.Core__Error,
    Async_kernel_External_job = global_data.Async_kernel__External_job,
    Core_Time_ns = global_data.Core__Time_ns,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Scheduler0 = global_data.Async_kernel__Scheduler0,
    Core_Result = global_data.Core__Result;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Scheduler1$0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel$0);
   caml_call1(Expect_test_collector[5][1], cst_src_scheduler1_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel$0, cst);
   var
    events = Async_kernel_Scheduler0[1],
    set_execution_context = Async_kernel_Scheduler0[2],
    debug = Async_kernel_Debug[10];
   function create_with_cell(cell){return [0, cell];}
   function create(param){return [0, 0];}
   function create_full(a){return [0, [2, a]];}
   var Ivar = [0, create_with_cell, create, create_full];
   function create$0(param){
    var _fw_ = [0, 0, caml_call1(Ivar[2], 0)];
    return caml_call1(Async_kernel_Types[10][1], _fw_);
   }
   var Bvar = [0, create$0], _a_ = [0, "Not_finished"], _b_ = [0, "Finished"];
   function sexp_of_t(param){return param ? _a_ : _b_;}
   var Exec_result = [0, sexp_of_t];
   function exec(r){return r[2];}
   function execution_context(r){return r[1];}
   var
    exec$0 =
      [0,
       function(param){return 0;},
       cst_exec,
       0,
       exec,
       function(r, v){return [0, r[1], v];}],
    execution_context$0 =
      [0,
       function(param){return 0;},
       cst_execution_context,
       0,
       execution_context,
       function(r, v){return [0, v, r[2]];}];
   function make_creator(execution_context_fun, exec_fun, compile_acc){
    var
     match =
       caml_call2(execution_context_fun, execution_context$0, compile_acc),
     compile_acc$0 = match[2],
     execution_context_gen = match[1],
     match$0 = caml_call2(exec_fun, exec$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     exec_gen = match$0[1];
    return [0,
            function(acc){
             var
              execution_context = caml_call1(execution_context_gen, acc),
              exec = caml_call1(exec_gen, acc);
             return [0, execution_context, exec];
            },
            compile_acc$1];
   }
   function create$1(execution_context, exec){return [0, execution_context, exec];
   }
   function map(execution_context_fun, exec_fun){
    var _fv_ = caml_call1(exec_fun, exec$0);
    return [0, caml_call1(execution_context_fun, execution_context$0), _fv_];
   }
   function iter(execution_context_fun, exec_fun){
    caml_call1(execution_context_fun, execution_context$0);
    return caml_call1(exec_fun, exec$0);
   }
   function fold(init, execution_context_fun, exec_fun){
    return caml_call2
            (exec_fun,
             caml_call2(execution_context_fun, init, execution_context$0),
             exec$0);
   }
   function map_poly(record){
    var _fu_ = [0, caml_call1(record[1], exec$0), 0];
    return [0, caml_call1(record[1], execution_context$0), _fu_];
   }
   function for_all(execution_context_fun, exec_fun){
    var _ft_ = caml_call1(execution_context_fun, execution_context$0);
    return _ft_ ? caml_call1(exec_fun, exec$0) : _ft_;
   }
   function exists(execution_context_fun, exec_fun){
    var _fs_ = caml_call1(execution_context_fun, execution_context$0);
    return _fs_ ? _fs_ : caml_call1(exec_fun, exec$0);
   }
   function to_list(execution_context_fun, exec_fun){
    var _fr_ = [0, caml_call1(exec_fun, exec$0), 0];
    return [0, caml_call1(execution_context_fun, execution_context$0), _fr_];
   }
   function iter$0(record, execution_context_fun, exec_fun){
    caml_call3(execution_context_fun, execution_context$0, record, record[1]);
    return caml_call3(exec_fun, exec$0, record, record[2]);
   }
   function fold$0(record, init, execution_context_fun, exec_fun){
    var _fq_ = record[2];
    return caml_call4
            (exec_fun,
             caml_call4
              (execution_context_fun,
               init,
               execution_context$0,
               record,
               record[1]),
             exec$0,
             record,
             _fq_);
   }
   function for_all$0(record, execution_context_fun, exec_fun){
    var
     _fp_ =
       caml_call3
        (execution_context_fun, execution_context$0, record, record[1]);
    return _fp_ ? caml_call3(exec_fun, exec$0, record, record[2]) : _fp_;
   }
   function exists$0(record, execution_context_fun, exec_fun){
    var
     _fo_ =
       caml_call3
        (execution_context_fun, execution_context$0, record, record[1]);
    return _fo_ ? _fo_ : caml_call3(exec_fun, exec$0, record, record[2]);
   }
   function to_list$0(record, execution_context_fun, exec_fun){
    var _fn_ = [0, caml_call3(exec_fun, exec$0, record, record[2]), 0];
    return [0,
            caml_call3
             (execution_context_fun, execution_context$0, record, record[1]),
            _fn_];
   }
   function map$0(record, execution_context_fun, exec_fun){
    var _fm_ = caml_call3(exec_fun, exec$0, record, record[2]);
    return [0,
            caml_call3
             (execution_context_fun, execution_context$0, record, record[1]),
            _fm_];
   }
   function set_all_mutable_fields(record){
    caml_call1(Base_Field[1][1], record);
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields],
    Fields =
      [0,
       names,
       exec$0,
       execution_context$0,
       make_creator,
       create$1,
       map,
       iter,
       fold,
       map_poly,
       for_all,
       exists,
       to_list,
       Direct],
    _c_ = [0, cst_exec],
    _d_ = [0, cst_execution_context],
    _e_ = [0, cst_src_scheduler1_ml, 51, 1645, 1669];
   function sexp_of_t$0(param){
    var
     execution_context_002 = param[1],
     arg_005 = caml_call1(Sexplib0_Sexp_conv[24], function(_fl_){return 0;}),
     bnds_001 = [0, [1, [0, _c_, [0, arg_005, 0]]], 0],
     arg_003 =
       caml_call1(Async_kernel_Execution_context[6], execution_context_002),
     bnds_001$0 = [0, [1, [0, _d_, [0, arg_003, 0]]], bnds_001];
    return [1, bnds_001$0];
   }
   function invariant(t){
    return caml_call4
            (Base_Invariant[1],
             _e_,
             t,
             sexp_of_t$0,
             function(param){
              var
               f = Async_kernel_Execution_context[7],
               _fj_ = caml_call2(Base_Invariant[2], t, f);
              return caml_call2(Fields[7], _fj_, function(_fk_){return 0;});
             });
   }
   var
    Very_low_priority_worker =
      [0,
       Exec_result,
       exec,
       execution_context,
       Fields,
       sexp_of_t$0,
       invariant];
   function record_backtraces(r){return r[28];}
   function set_record_backtraces(r, v){r[28] = v; return 0;}
   function max_num_jobs_per_priority_per_(r){return r[27];}
   function set_max_num_jobs_per_priority_(r, v){r[27] = v; return 0;}
   function check_invariants(r){return r[26];}
   function set_check_invariants(r, v){r[26] = v; return 0;}
   function yield_until_no_jobs_remain(r){return r[25];}
   function set_yield_until_no_jobs_remain(r, v){r[25] = v; return 0;}
   function yield$0(r){return r[24];}
   function set_yield(r, v){r[24] = v; return 0;}
   function event_added_hook(r){return r[23];}
   function set_event_added_hook(r, v){r[23] = v; return 0;}
   function job_queued_hook(r){return r[22];}
   function set_job_queued_hook(r, v){r[22] = v; return 0;}
   function thread_safe_external_job_hook(r){return r[21];}
   function set_thread_safe_external_job_h(r, v){r[21] = v; return 0;}
   function external_jobs(r){return r[20];}
   function time_source(r){return r[19];}
   function set_time_source(r, v){r[19] = v; return 0;}
   function total_cycle_time(r){return r[18];}
   function set_total_cycle_time(r, v){r[18] = v; return 0;}
   function last_cycle_num_jobs(r){return r[17];}
   function set_last_cycle_num_jobs(r, v){r[17] = v; return 0;}
   function last_cycle_time(r){return r[16];}
   function set_last_cycle_time(r, v){r[16] = v; return 0;}
   function run_every_cycle_end_state(r){return r[15];}
   function run_every_cycle_end(r){return r[14];}
   function set_run_every_cycle_end(r, v){r[14] = v; return 0;}
   function run_every_cycle_start_state(r){return r[13];}
   function run_every_cycle_start(r){return r[12];}
   function set_run_every_cycle_start(r, v){r[12] = v; return 0;}
   function in_cycle(r){return r[11];}
   function set_in_cycle(r, v){r[11] = v; return 0;}
   function cycle_start(r){return r[10];}
   function set_cycle_start(r, v){r[10] = v; return 0;}
   function cycle_count(r){return r[9];}
   function set_cycle_count(r, v){r[9] = v; return 0;}
   function uncaught_exn_unwrapped(r){return r[8];}
   function set_uncaught_exn(r, v){r[8] = v; return 0;}
   function current_execution_context(r){return r[7];}
   function set_current_execution_context(r, v){r[7] = v; return 0;}
   function main_execution_context(r){return r[6];}
   function set_main_execution_context(r, v){r[6] = v; return 0;}
   function very_low_priority_workers(r){return r[5];}
   function low_priority_jobs(r){return r[4];}
   function normal_priority_jobs(r){return r[3];}
   function job_pool(r){return r[2];}
   function set_job_pool(r, v){r[2] = v; return 0;}
   function check_access(r){return r[1];}
   function set_check_access(r, v){r[1] = v; return 0;}
   var
    record_backtraces$0 =
      [0,
       function(param){return 0;},
       cst_record_backtraces,
       [0, set_record_backtraces],
       record_backtraces,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                v];
       }],
    max_num_jobs_per_priority_per_$0 =
      [0,
       function(param){return 0;},
       cst_max_num_jobs_per_priority_,
       [0, set_max_num_jobs_per_priority_],
       max_num_jobs_per_priority_per_,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                v,
                r[28]];
       }],
    check_invariants$0 =
      [0,
       function(param){return 0;},
       cst_check_invariants,
       [0, set_check_invariants],
       check_invariants,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                v,
                r[27],
                r[28]];
       }],
    yield_until_no_jobs_remain$0 =
      [0,
       function(param){return 0;},
       cst_yield_until_no_jobs_remain,
       [0, set_yield_until_no_jobs_remain],
       yield_until_no_jobs_remain,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                v,
                r[26],
                r[27],
                r[28]];
       }],
    yield$1 =
      [0,
       function(param){return 0;},
       cst_yield,
       [0, set_yield],
       yield$0,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                v,
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    event_added_hook$0 =
      [0,
       function(param){return 0;},
       cst_event_added_hook,
       [0, set_event_added_hook],
       event_added_hook,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                v,
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    job_queued_hook$0 =
      [0,
       function(param){return 0;},
       cst_job_queued_hook,
       [0, set_job_queued_hook],
       job_queued_hook,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                v,
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    thread_safe_external_job_hook$0 =
      [0,
       function(param){return 0;},
       cst_thread_safe_external_job_h,
       [0, set_thread_safe_external_job_h],
       thread_safe_external_job_hook,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                v,
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    external_jobs$0 =
      [0,
       function(param){return 0;},
       cst_external_jobs,
       0,
       external_jobs,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                v,
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    time_source$0 =
      [0,
       function(param){return 0;},
       cst_time_source,
       [0, set_time_source],
       time_source,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                v,
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    total_cycle_time$0 =
      [0,
       function(param){return 0;},
       cst_total_cycle_time,
       [0, set_total_cycle_time],
       total_cycle_time,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                v,
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    last_cycle_num_jobs$0 =
      [0,
       function(param){return 0;},
       cst_last_cycle_num_jobs,
       [0, set_last_cycle_num_jobs],
       last_cycle_num_jobs,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                v,
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    last_cycle_time$0 =
      [0,
       function(param){return 0;},
       cst_last_cycle_time,
       [0, set_last_cycle_time],
       last_cycle_time,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                v,
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    run_every_cycle_end_state$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_end_state,
       0,
       run_every_cycle_end_state,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                v,
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    run_every_cycle_end$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_end,
       [0, set_run_every_cycle_end],
       run_every_cycle_end,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                v,
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    run_every_cycle_start_state$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_start_stat,
       0,
       run_every_cycle_start_state,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                v,
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    run_every_cycle_start$0 =
      [0,
       function(param){return 0;},
       cst_run_every_cycle_start,
       [0, set_run_every_cycle_start],
       run_every_cycle_start,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                v,
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    in_cycle$0 =
      [0,
       function(param){return 0;},
       cst_in_cycle,
       [0, set_in_cycle],
       in_cycle,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                v,
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    cycle_start$0 =
      [0,
       function(param){return 0;},
       cst_cycle_start,
       [0, set_cycle_start],
       cycle_start,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                v,
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    cycle_count$0 =
      [0,
       function(param){return 0;},
       cst_cycle_count,
       [0, set_cycle_count],
       cycle_count,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                v,
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    uncaught_exn =
      [0,
       function(param){return 0;},
       cst_uncaught_exn,
       [0, set_uncaught_exn],
       uncaught_exn_unwrapped,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                v,
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    current_execution_context$0 =
      [0,
       function(param){return 0;},
       cst_current_execution_context,
       [0, set_current_execution_context],
       current_execution_context,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                v,
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    main_execution_context$0 =
      [0,
       function(param){return 0;},
       cst_main_execution_context,
       [0, set_main_execution_context],
       main_execution_context,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                v,
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    very_low_priority_workers$0 =
      [0,
       function(param){return 0;},
       cst_very_low_priority_workers,
       0,
       very_low_priority_workers,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                v,
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    low_priority_jobs$0 =
      [0,
       function(param){return 0;},
       cst_low_priority_jobs,
       0,
       low_priority_jobs,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                v,
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    normal_priority_jobs$0 =
      [0,
       function(param){return 0;},
       cst_normal_priority_jobs,
       0,
       normal_priority_jobs,
       function(r, v){
        return [0,
                r[1],
                r[2],
                v,
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    job_pool$0 =
      [0,
       function(param){return 0;},
       cst_job_pool,
       [0, set_job_pool],
       job_pool,
       function(r, v){
        return [0,
                r[1],
                v,
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }],
    check_access$0 =
      [0,
       function(param){return 0;},
       cst_check_access,
       [0, set_check_access],
       check_access,
       function(r, v){
        return [0,
                v,
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12],
                r[13],
                r[14],
                r[15],
                r[16],
                r[17],
                r[18],
                r[19],
                r[20],
                r[21],
                r[22],
                r[23],
                r[24],
                r[25],
                r[26],
                r[27],
                r[28]];
       }];
   function make_creator$0
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun,
    compile_acc){
    var
     match = caml_call2(check_access_fun, check_access$0, compile_acc),
     compile_acc$0 = match[2],
     check_access_gen = match[1],
     match$0 = caml_call2(job_pool_fun, job_pool$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     job_pool_gen = match$0[1],
     match$1 =
       caml_call2
        (normal_priority_jobs_fun, normal_priority_jobs$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     normal_priority_jobs_gen = match$1[1],
     match$2 =
       caml_call2(low_priority_jobs_fun, low_priority_jobs$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     low_priority_jobs_gen = match$2[1],
     match$3 =
       caml_call2
        (very_low_priority_workers_fun,
         very_low_priority_workers$0,
         compile_acc$3),
     compile_acc$4 = match$3[2],
     very_low_priority_workers_gen = match$3[1],
     match$4 =
       caml_call2
        (main_execution_context_fun, main_execution_context$0, compile_acc$4),
     compile_acc$5 = match$4[2],
     main_execution_context_gen = match$4[1],
     match$5 =
       caml_call2
        (current_execution_context_fun,
         current_execution_context$0,
         compile_acc$5),
     compile_acc$6 = match$5[2],
     current_execution_context_gen = match$5[1],
     match$6 = caml_call2(uncaught_exn_fun, uncaught_exn, compile_acc$6),
     compile_acc$7 = match$6[2],
     uncaught_exn_gen = match$6[1],
     match$7 = caml_call2(cycle_count_fun, cycle_count$0, compile_acc$7),
     compile_acc$8 = match$7[2],
     cycle_count_gen = match$7[1],
     match$8 = caml_call2(cycle_start_fun, cycle_start$0, compile_acc$8),
     compile_acc$9 = match$8[2],
     cycle_start_gen = match$8[1],
     match$9 = caml_call2(in_cycle_fun, in_cycle$0, compile_acc$9),
     compile_acc$10 = match$9[2],
     in_cycle_gen = match$9[1],
     match$10 =
       caml_call2
        (run_every_cycle_start_fun, run_every_cycle_start$0, compile_acc$10),
     compile_acc$11 = match$10[2],
     run_every_cycle_start_gen = match$10[1],
     match$11 =
       caml_call2
        (run_every_cycle_start_state_fu,
         run_every_cycle_start_state$0,
         compile_acc$11),
     compile_acc$12 = match$11[2],
     run_every_cycle_start_state_ge = match$11[1],
     match$12 =
       caml_call2
        (run_every_cycle_end_fun, run_every_cycle_end$0, compile_acc$12),
     compile_acc$13 = match$12[2],
     run_every_cycle_end_gen = match$12[1],
     match$13 =
       caml_call2
        (run_every_cycle_end_state_fun,
         run_every_cycle_end_state$0,
         compile_acc$13),
     compile_acc$14 = match$13[2],
     run_every_cycle_end_state_gen = match$13[1],
     match$14 =
       caml_call2(last_cycle_time_fun, last_cycle_time$0, compile_acc$14),
     compile_acc$15 = match$14[2],
     last_cycle_time_gen = match$14[1],
     match$15 =
       caml_call2
        (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, compile_acc$15),
     compile_acc$16 = match$15[2],
     last_cycle_num_jobs_gen = match$15[1],
     match$16 =
       caml_call2(total_cycle_time_fun, total_cycle_time$0, compile_acc$16),
     compile_acc$17 = match$16[2],
     total_cycle_time_gen = match$16[1],
     match$17 = caml_call2(time_source_fun, time_source$0, compile_acc$17),
     compile_acc$18 = match$17[2],
     time_source_gen = match$17[1],
     match$18 = caml_call2(external_jobs_fun, external_jobs$0, compile_acc$18),
     compile_acc$19 = match$18[2],
     external_jobs_gen = match$18[1],
     match$19 =
       caml_call2
        (thread_safe_external_job_hook_,
         thread_safe_external_job_hook$0,
         compile_acc$19),
     compile_acc$20 = match$19[2],
     thread_safe_external_job_hook_$0 = match$19[1],
     match$20 =
       caml_call2(job_queued_hook_fun, job_queued_hook$0, compile_acc$20),
     compile_acc$21 = match$20[2],
     job_queued_hook_gen = match$20[1],
     match$21 =
       caml_call2(event_added_hook_fun, event_added_hook$0, compile_acc$21),
     compile_acc$22 = match$21[2],
     event_added_hook_gen = match$21[1],
     match$22 = caml_call2(yield_fun, yield$1, compile_acc$22),
     compile_acc$23 = match$22[2],
     yield_gen = match$22[1],
     match$23 =
       caml_call2
        (yield_until_no_jobs_remain_fun,
         yield_until_no_jobs_remain$0,
         compile_acc$23),
     compile_acc$24 = match$23[2],
     yield_until_no_jobs_remain_gen = match$23[1],
     match$24 =
       caml_call2(check_invariants_fun, check_invariants$0, compile_acc$24),
     compile_acc$25 = match$24[2],
     check_invariants_gen = match$24[1],
     match$25 =
       caml_call2
        (max_num_jobs_per_priority_per_,
         max_num_jobs_per_priority_per_$0,
         compile_acc$25),
     compile_acc$26 = match$25[2],
     max_num_jobs_per_priority_per_$1 = match$25[1],
     match$26 =
       caml_call2(record_backtraces_fun, record_backtraces$0, compile_acc$26),
     compile_acc$27 = match$26[2],
     record_backtraces_gen = match$26[1];
    return [0,
            function(acc){
             var
              check_access = caml_call1(check_access_gen, acc),
              job_pool = caml_call1(job_pool_gen, acc),
              normal_priority_jobs = caml_call1(normal_priority_jobs_gen, acc),
              low_priority_jobs = caml_call1(low_priority_jobs_gen, acc),
              very_low_priority_workers =
                caml_call1(very_low_priority_workers_gen, acc),
              main_execution_context =
                caml_call1(main_execution_context_gen, acc),
              current_execution_context =
                caml_call1(current_execution_context_gen, acc),
              uncaught_exn = caml_call1(uncaught_exn_gen, acc),
              cycle_count = caml_call1(cycle_count_gen, acc),
              cycle_start = caml_call1(cycle_start_gen, acc),
              in_cycle = caml_call1(in_cycle_gen, acc),
              run_every_cycle_start =
                caml_call1(run_every_cycle_start_gen, acc),
              run_every_cycle_start_state =
                caml_call1(run_every_cycle_start_state_ge, acc),
              run_every_cycle_end = caml_call1(run_every_cycle_end_gen, acc),
              run_every_cycle_end_state =
                caml_call1(run_every_cycle_end_state_gen, acc),
              last_cycle_time = caml_call1(last_cycle_time_gen, acc),
              last_cycle_num_jobs = caml_call1(last_cycle_num_jobs_gen, acc),
              total_cycle_time = caml_call1(total_cycle_time_gen, acc),
              time_source = caml_call1(time_source_gen, acc),
              external_jobs = caml_call1(external_jobs_gen, acc),
              thread_safe_external_job_hook =
                caml_call1(thread_safe_external_job_hook_$0, acc),
              job_queued_hook = caml_call1(job_queued_hook_gen, acc),
              event_added_hook = caml_call1(event_added_hook_gen, acc),
              yield$0 = caml_call1(yield_gen, acc),
              yield_until_no_jobs_remain =
                caml_call1(yield_until_no_jobs_remain_gen, acc),
              check_invariants = caml_call1(check_invariants_gen, acc),
              max_num_jobs_per_priority_per_ =
                caml_call1(max_num_jobs_per_priority_per_$1, acc),
              record_backtraces = caml_call1(record_backtraces_gen, acc);
             return [0,
                     check_access,
                     job_pool,
                     normal_priority_jobs,
                     low_priority_jobs,
                     very_low_priority_workers,
                     main_execution_context,
                     current_execution_context,
                     uncaught_exn,
                     cycle_count,
                     cycle_start,
                     in_cycle,
                     run_every_cycle_start,
                     run_every_cycle_start_state,
                     run_every_cycle_end,
                     run_every_cycle_end_state,
                     last_cycle_time,
                     last_cycle_num_jobs,
                     total_cycle_time,
                     time_source,
                     external_jobs,
                     thread_safe_external_job_hook,
                     job_queued_hook,
                     event_added_hook,
                     yield$0,
                     yield_until_no_jobs_remain,
                     check_invariants,
                     max_num_jobs_per_priority_per_,
                     record_backtraces];
            },
            compile_acc$27];
   }
   function create$2
   (check_access,
    job_pool,
    normal_priority_jobs,
    low_priority_jobs,
    very_low_priority_workers,
    main_execution_context,
    current_execution_context,
    uncaught_exn,
    cycle_count,
    cycle_start,
    in_cycle,
    run_every_cycle_start,
    run_every_cycle_start_state,
    run_every_cycle_end,
    run_every_cycle_end_state,
    last_cycle_time,
    last_cycle_num_jobs,
    total_cycle_time,
    time_source,
    external_jobs,
    thread_safe_external_job_hook,
    job_queued_hook,
    event_added_hook,
    yield$0,
    yield_until_no_jobs_remain,
    check_invariants,
    max_num_jobs_per_priority_per_,
    record_backtraces){
    return [0,
            check_access,
            job_pool,
            normal_priority_jobs,
            low_priority_jobs,
            very_low_priority_workers,
            main_execution_context,
            current_execution_context,
            uncaught_exn,
            cycle_count,
            cycle_start,
            in_cycle,
            run_every_cycle_start,
            run_every_cycle_start_state,
            run_every_cycle_end,
            run_every_cycle_end_state,
            last_cycle_time,
            last_cycle_num_jobs,
            total_cycle_time,
            time_source,
            external_jobs,
            thread_safe_external_job_hook,
            job_queued_hook,
            event_added_hook,
            yield$0,
            yield_until_no_jobs_remain,
            check_invariants,
            max_num_jobs_per_priority_per_,
            record_backtraces];
   }
   function map$1
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _eU_ = caml_call1(record_backtraces_fun, record_backtraces$0),
     _eV_ =
       caml_call1
        (max_num_jobs_per_priority_per_, max_num_jobs_per_priority_per_$0),
     _eW_ = caml_call1(check_invariants_fun, check_invariants$0),
     _eX_ =
       caml_call1
        (yield_until_no_jobs_remain_fun, yield_until_no_jobs_remain$0),
     _eY_ = caml_call1(yield_fun, yield$1),
     _eZ_ = caml_call1(event_added_hook_fun, event_added_hook$0),
     _e0_ = caml_call1(job_queued_hook_fun, job_queued_hook$0),
     _e1_ =
       caml_call1
        (thread_safe_external_job_hook_, thread_safe_external_job_hook$0),
     _e2_ = caml_call1(external_jobs_fun, external_jobs$0),
     _e3_ = caml_call1(time_source_fun, time_source$0),
     _e4_ = caml_call1(total_cycle_time_fun, total_cycle_time$0),
     _e5_ = caml_call1(last_cycle_num_jobs_fun, last_cycle_num_jobs$0),
     _e6_ = caml_call1(last_cycle_time_fun, last_cycle_time$0),
     _e7_ =
       caml_call1(run_every_cycle_end_state_fun, run_every_cycle_end_state$0),
     _e8_ = caml_call1(run_every_cycle_end_fun, run_every_cycle_end$0),
     _e9_ =
       caml_call1
        (run_every_cycle_start_state_fu, run_every_cycle_start_state$0),
     _e__ = caml_call1(run_every_cycle_start_fun, run_every_cycle_start$0),
     _e$_ = caml_call1(in_cycle_fun, in_cycle$0),
     _fa_ = caml_call1(cycle_start_fun, cycle_start$0),
     _fb_ = caml_call1(cycle_count_fun, cycle_count$0),
     _fc_ = caml_call1(uncaught_exn_fun, uncaught_exn),
     _fd_ =
       caml_call1(current_execution_context_fun, current_execution_context$0),
     _fe_ = caml_call1(main_execution_context_fun, main_execution_context$0),
     _ff_ =
       caml_call1(very_low_priority_workers_fun, very_low_priority_workers$0),
     _fg_ = caml_call1(low_priority_jobs_fun, low_priority_jobs$0),
     _fh_ = caml_call1(normal_priority_jobs_fun, normal_priority_jobs$0),
     _fi_ = caml_call1(job_pool_fun, job_pool$0);
    return [0,
            caml_call1(check_access_fun, check_access$0),
            _fi_,
            _fh_,
            _fg_,
            _ff_,
            _fe_,
            _fd_,
            _fc_,
            _fb_,
            _fa_,
            _e$_,
            _e__,
            _e9_,
            _e8_,
            _e7_,
            _e6_,
            _e5_,
            _e4_,
            _e3_,
            _e2_,
            _e1_,
            _e0_,
            _eZ_,
            _eY_,
            _eX_,
            _eW_,
            _eV_,
            _eU_];
   }
   function iter$1
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    caml_call1(check_access_fun, check_access$0);
    caml_call1(job_pool_fun, job_pool$0);
    caml_call1(normal_priority_jobs_fun, normal_priority_jobs$0);
    caml_call1(low_priority_jobs_fun, low_priority_jobs$0);
    caml_call1(very_low_priority_workers_fun, very_low_priority_workers$0);
    caml_call1(main_execution_context_fun, main_execution_context$0);
    caml_call1(current_execution_context_fun, current_execution_context$0);
    caml_call1(uncaught_exn_fun, uncaught_exn);
    caml_call1(cycle_count_fun, cycle_count$0);
    caml_call1(cycle_start_fun, cycle_start$0);
    caml_call1(in_cycle_fun, in_cycle$0);
    caml_call1(run_every_cycle_start_fun, run_every_cycle_start$0);
    caml_call1(run_every_cycle_start_state_fu, run_every_cycle_start_state$0);
    caml_call1(run_every_cycle_end_fun, run_every_cycle_end$0);
    caml_call1(run_every_cycle_end_state_fun, run_every_cycle_end_state$0);
    caml_call1(last_cycle_time_fun, last_cycle_time$0);
    caml_call1(last_cycle_num_jobs_fun, last_cycle_num_jobs$0);
    caml_call1(total_cycle_time_fun, total_cycle_time$0);
    caml_call1(time_source_fun, time_source$0);
    caml_call1(external_jobs_fun, external_jobs$0);
    caml_call1
     (thread_safe_external_job_hook_, thread_safe_external_job_hook$0);
    caml_call1(job_queued_hook_fun, job_queued_hook$0);
    caml_call1(event_added_hook_fun, event_added_hook$0);
    caml_call1(yield_fun, yield$1);
    caml_call1(yield_until_no_jobs_remain_fun, yield_until_no_jobs_remain$0);
    caml_call1(check_invariants_fun, check_invariants$0);
    caml_call1
     (max_num_jobs_per_priority_per_, max_num_jobs_per_priority_per_$0);
    return caml_call1(record_backtraces_fun, record_backtraces$0);
   }
   function fold$1
   (init,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    return caml_call2
            (record_backtraces_fun,
             caml_call2
              (max_num_jobs_per_priority_per_,
               caml_call2
                (check_invariants_fun,
                 caml_call2
                  (yield_until_no_jobs_remain_fun,
                   caml_call2
                    (yield_fun,
                     caml_call2
                      (event_added_hook_fun,
                       caml_call2
                        (job_queued_hook_fun,
                         caml_call2
                          (thread_safe_external_job_hook_,
                           caml_call2
                            (external_jobs_fun,
                             caml_call2
                              (time_source_fun,
                               caml_call2
                                (total_cycle_time_fun,
                                 caml_call2
                                  (last_cycle_num_jobs_fun,
                                   caml_call2
                                    (last_cycle_time_fun,
                                     caml_call2
                                      (run_every_cycle_end_state_fun,
                                       caml_call2
                                        (run_every_cycle_end_fun,
                                         caml_call2
                                          (run_every_cycle_start_state_fu,
                                           caml_call2
                                            (run_every_cycle_start_fun,
                                             caml_call2
                                              (in_cycle_fun,
                                               caml_call2
                                                (cycle_start_fun,
                                                 caml_call2
                                                  (cycle_count_fun,
                                                   caml_call2
                                                    (uncaught_exn_fun,
                                                     caml_call2
                                                      (current_execution_context_fun,
                                                       caml_call2
                                                        (main_execution_context_fun,
                                                         caml_call2
                                                          (very_low_priority_workers_fun,
                                                           caml_call2
                                                            (low_priority_jobs_fun,
                                                             caml_call2
                                                              (normal_priority_jobs_fun,
                                                               caml_call2
                                                                (job_pool_fun,
                                                                 caml_call2(check_access_fun, init, check_access$0),
                                                                 job_pool$0),
                                                               normal_priority_jobs$0),
                                                             low_priority_jobs$0),
                                                           very_low_priority_workers$0),
                                                         main_execution_context$0),
                                                       current_execution_context$0),
                                                     uncaught_exn),
                                                   cycle_count$0),
                                                 cycle_start$0),
                                               in_cycle$0),
                                             run_every_cycle_start$0),
                                           run_every_cycle_start_state$0),
                                         run_every_cycle_end$0),
                                       run_every_cycle_end_state$0),
                                     last_cycle_time$0),
                                   last_cycle_num_jobs$0),
                                 total_cycle_time$0),
                               time_source$0),
                             external_jobs$0),
                           thread_safe_external_job_hook$0),
                         job_queued_hook$0),
                       event_added_hook$0),
                     yield$1),
                   yield_until_no_jobs_remain$0),
                 check_invariants$0),
               max_num_jobs_per_priority_per_$0),
             record_backtraces$0);
   }
   function map_poly$0(record){
    var
     _et_ = [0, caml_call1(record[1], record_backtraces$0), 0],
     _eu_ = [0, caml_call1(record[1], max_num_jobs_per_priority_per_$0), _et_],
     _ev_ = [0, caml_call1(record[1], check_invariants$0), _eu_],
     _ew_ = [0, caml_call1(record[1], yield_until_no_jobs_remain$0), _ev_],
     _ex_ = [0, caml_call1(record[1], yield$1), _ew_],
     _ey_ = [0, caml_call1(record[1], event_added_hook$0), _ex_],
     _ez_ = [0, caml_call1(record[1], job_queued_hook$0), _ey_],
     _eA_ = [0, caml_call1(record[1], thread_safe_external_job_hook$0), _ez_],
     _eB_ = [0, caml_call1(record[1], external_jobs$0), _eA_],
     _eC_ = [0, caml_call1(record[1], time_source$0), _eB_],
     _eD_ = [0, caml_call1(record[1], total_cycle_time$0), _eC_],
     _eE_ = [0, caml_call1(record[1], last_cycle_num_jobs$0), _eD_],
     _eF_ = [0, caml_call1(record[1], last_cycle_time$0), _eE_],
     _eG_ = [0, caml_call1(record[1], run_every_cycle_end_state$0), _eF_],
     _eH_ = [0, caml_call1(record[1], run_every_cycle_end$0), _eG_],
     _eI_ = [0, caml_call1(record[1], run_every_cycle_start_state$0), _eH_],
     _eJ_ = [0, caml_call1(record[1], run_every_cycle_start$0), _eI_],
     _eK_ = [0, caml_call1(record[1], in_cycle$0), _eJ_],
     _eL_ = [0, caml_call1(record[1], cycle_start$0), _eK_],
     _eM_ = [0, caml_call1(record[1], cycle_count$0), _eL_],
     _eN_ = [0, caml_call1(record[1], uncaught_exn), _eM_],
     _eO_ = [0, caml_call1(record[1], current_execution_context$0), _eN_],
     _eP_ = [0, caml_call1(record[1], main_execution_context$0), _eO_],
     _eQ_ = [0, caml_call1(record[1], very_low_priority_workers$0), _eP_],
     _eR_ = [0, caml_call1(record[1], low_priority_jobs$0), _eQ_],
     _eS_ = [0, caml_call1(record[1], normal_priority_jobs$0), _eR_],
     _eT_ = [0, caml_call1(record[1], job_pool$0), _eS_];
    return [0, caml_call1(record[1], check_access$0), _eT_];
   }
   function for_all$1
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _d4_ = caml_call1(check_access_fun, check_access$0),
     _d5_ = _d4_ ? caml_call1(job_pool_fun, job_pool$0) : _d4_,
     _d6_ =
       _d5_
        ? caml_call1(normal_priority_jobs_fun, normal_priority_jobs$0)
        : _d5_,
     _d7_ =
       _d6_ ? caml_call1(low_priority_jobs_fun, low_priority_jobs$0) : _d6_,
     _d8_ =
       _d7_
        ? caml_call1
          (very_low_priority_workers_fun, very_low_priority_workers$0)
        : _d7_,
     _d9_ =
       _d8_
        ? caml_call1(main_execution_context_fun, main_execution_context$0)
        : _d8_,
     _d__ =
       _d9_
        ? caml_call1
          (current_execution_context_fun, current_execution_context$0)
        : _d9_,
     _d$_ = _d__ ? caml_call1(uncaught_exn_fun, uncaught_exn) : _d__,
     _ea_ = _d$_ ? caml_call1(cycle_count_fun, cycle_count$0) : _d$_,
     _eb_ = _ea_ ? caml_call1(cycle_start_fun, cycle_start$0) : _ea_,
     _ec_ = _eb_ ? caml_call1(in_cycle_fun, in_cycle$0) : _eb_,
     _ed_ =
       _ec_
        ? caml_call1(run_every_cycle_start_fun, run_every_cycle_start$0)
        : _ec_,
     _ee_ =
       _ed_
        ? caml_call1
          (run_every_cycle_start_state_fu, run_every_cycle_start_state$0)
        : _ed_,
     _ef_ =
       _ee_
        ? caml_call1(run_every_cycle_end_fun, run_every_cycle_end$0)
        : _ee_,
     _eg_ =
       _ef_
        ? caml_call1
          (run_every_cycle_end_state_fun, run_every_cycle_end_state$0)
        : _ef_,
     _eh_ = _eg_ ? caml_call1(last_cycle_time_fun, last_cycle_time$0) : _eg_,
     _ei_ =
       _eh_
        ? caml_call1(last_cycle_num_jobs_fun, last_cycle_num_jobs$0)
        : _eh_,
     _ej_ = _ei_ ? caml_call1(total_cycle_time_fun, total_cycle_time$0) : _ei_,
     _ek_ = _ej_ ? caml_call1(time_source_fun, time_source$0) : _ej_,
     _el_ = _ek_ ? caml_call1(external_jobs_fun, external_jobs$0) : _ek_,
     _em_ =
       _el_
        ? caml_call1
          (thread_safe_external_job_hook_, thread_safe_external_job_hook$0)
        : _el_,
     _en_ = _em_ ? caml_call1(job_queued_hook_fun, job_queued_hook$0) : _em_,
     _eo_ = _en_ ? caml_call1(event_added_hook_fun, event_added_hook$0) : _en_,
     _ep_ = _eo_ ? caml_call1(yield_fun, yield$1) : _eo_,
     _eq_ =
       _ep_
        ? caml_call1
          (yield_until_no_jobs_remain_fun, yield_until_no_jobs_remain$0)
        : _ep_,
     _er_ = _eq_ ? caml_call1(check_invariants_fun, check_invariants$0) : _eq_,
     _es_ =
       _er_
        ? caml_call1
          (max_num_jobs_per_priority_per_, max_num_jobs_per_priority_per_$0)
        : _er_;
    return _es_
            ? caml_call1(record_backtraces_fun, record_backtraces$0)
            : _es_;
   }
   function exists$1
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _d3_ = caml_call1(check_access_fun, check_access$0),
     _dD_ = _d3_ || caml_call1(job_pool_fun, job_pool$0),
     _dE_ =
       _dD_ || caml_call1(normal_priority_jobs_fun, normal_priority_jobs$0),
     _dF_ = _dE_ || caml_call1(low_priority_jobs_fun, low_priority_jobs$0),
     _dG_ =
       _dF_
       ||
        caml_call1(very_low_priority_workers_fun, very_low_priority_workers$0),
     _dH_ =
       _dG_
       || caml_call1(main_execution_context_fun, main_execution_context$0),
     _dI_ =
       _dH_
       ||
        caml_call1(current_execution_context_fun, current_execution_context$0),
     _dJ_ = _dI_ || caml_call1(uncaught_exn_fun, uncaught_exn),
     _dK_ = _dJ_ || caml_call1(cycle_count_fun, cycle_count$0),
     _dL_ = _dK_ || caml_call1(cycle_start_fun, cycle_start$0),
     _dM_ = _dL_ || caml_call1(in_cycle_fun, in_cycle$0),
     _dN_ =
       _dM_ || caml_call1(run_every_cycle_start_fun, run_every_cycle_start$0),
     _dO_ =
       _dN_
       ||
        caml_call1
         (run_every_cycle_start_state_fu, run_every_cycle_start_state$0),
     _dP_ = _dO_ || caml_call1(run_every_cycle_end_fun, run_every_cycle_end$0),
     _dQ_ =
       _dP_
       ||
        caml_call1(run_every_cycle_end_state_fun, run_every_cycle_end_state$0),
     _dR_ = _dQ_ || caml_call1(last_cycle_time_fun, last_cycle_time$0),
     _dS_ = _dR_ || caml_call1(last_cycle_num_jobs_fun, last_cycle_num_jobs$0),
     _dT_ = _dS_ || caml_call1(total_cycle_time_fun, total_cycle_time$0),
     _dU_ = _dT_ || caml_call1(time_source_fun, time_source$0),
     _dV_ = _dU_ || caml_call1(external_jobs_fun, external_jobs$0),
     _dW_ =
       _dV_
       ||
        caml_call1
         (thread_safe_external_job_hook_, thread_safe_external_job_hook$0),
     _dX_ = _dW_ || caml_call1(job_queued_hook_fun, job_queued_hook$0),
     _dY_ = _dX_ || caml_call1(event_added_hook_fun, event_added_hook$0),
     _dZ_ = _dY_ || caml_call1(yield_fun, yield$1),
     _d0_ =
       _dZ_
       ||
        caml_call1
         (yield_until_no_jobs_remain_fun, yield_until_no_jobs_remain$0),
     _d1_ = _d0_ || caml_call1(check_invariants_fun, check_invariants$0),
     _d2_ =
       _d1_
       ||
        caml_call1
         (max_num_jobs_per_priority_per_, max_num_jobs_per_priority_per_$0);
    return _d2_
            ? _d2_
            : caml_call1(record_backtraces_fun, record_backtraces$0);
   }
   function to_list$1
   (check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _dc_ = [0, caml_call1(record_backtraces_fun, record_backtraces$0), 0],
     _dd_ =
       [0,
        caml_call1
         (max_num_jobs_per_priority_per_, max_num_jobs_per_priority_per_$0),
        _dc_],
     _de_ = [0, caml_call1(check_invariants_fun, check_invariants$0), _dd_],
     _df_ =
       [0,
        caml_call1
         (yield_until_no_jobs_remain_fun, yield_until_no_jobs_remain$0),
        _de_],
     _dg_ = [0, caml_call1(yield_fun, yield$1), _df_],
     _dh_ = [0, caml_call1(event_added_hook_fun, event_added_hook$0), _dg_],
     _di_ = [0, caml_call1(job_queued_hook_fun, job_queued_hook$0), _dh_],
     _dj_ =
       [0,
        caml_call1
         (thread_safe_external_job_hook_, thread_safe_external_job_hook$0),
        _di_],
     _dk_ = [0, caml_call1(external_jobs_fun, external_jobs$0), _dj_],
     _dl_ = [0, caml_call1(time_source_fun, time_source$0), _dk_],
     _dm_ = [0, caml_call1(total_cycle_time_fun, total_cycle_time$0), _dl_],
     _dn_ =
       [0, caml_call1(last_cycle_num_jobs_fun, last_cycle_num_jobs$0), _dm_],
     _do_ = [0, caml_call1(last_cycle_time_fun, last_cycle_time$0), _dn_],
     _dp_ =
       [0,
        caml_call1(run_every_cycle_end_state_fun, run_every_cycle_end_state$0),
        _do_],
     _dq_ =
       [0, caml_call1(run_every_cycle_end_fun, run_every_cycle_end$0), _dp_],
     _dr_ =
       [0,
        caml_call1
         (run_every_cycle_start_state_fu, run_every_cycle_start_state$0),
        _dq_],
     _ds_ =
       [0,
        caml_call1(run_every_cycle_start_fun, run_every_cycle_start$0),
        _dr_],
     _dt_ = [0, caml_call1(in_cycle_fun, in_cycle$0), _ds_],
     _du_ = [0, caml_call1(cycle_start_fun, cycle_start$0), _dt_],
     _dv_ = [0, caml_call1(cycle_count_fun, cycle_count$0), _du_],
     _dw_ = [0, caml_call1(uncaught_exn_fun, uncaught_exn), _dv_],
     _dx_ =
       [0,
        caml_call1(current_execution_context_fun, current_execution_context$0),
        _dw_],
     _dy_ =
       [0,
        caml_call1(main_execution_context_fun, main_execution_context$0),
        _dx_],
     _dz_ =
       [0,
        caml_call1(very_low_priority_workers_fun, very_low_priority_workers$0),
        _dy_],
     _dA_ = [0, caml_call1(low_priority_jobs_fun, low_priority_jobs$0), _dz_],
     _dB_ =
       [0, caml_call1(normal_priority_jobs_fun, normal_priority_jobs$0), _dA_],
     _dC_ = [0, caml_call1(job_pool_fun, job_pool$0), _dB_];
    return [0, caml_call1(check_access_fun, check_access$0), _dC_];
   }
   function iter$2
   (record,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    caml_call3(check_access_fun, check_access$0, record, record[1]);
    caml_call3(job_pool_fun, job_pool$0, record, record[2]);
    caml_call3
     (normal_priority_jobs_fun, normal_priority_jobs$0, record, record[3]);
    caml_call3(low_priority_jobs_fun, low_priority_jobs$0, record, record[4]);
    caml_call3
     (very_low_priority_workers_fun,
      very_low_priority_workers$0,
      record,
      record[5]);
    caml_call3
     (main_execution_context_fun, main_execution_context$0, record, record[6]);
    caml_call3
     (current_execution_context_fun,
      current_execution_context$0,
      record,
      record[7]);
    caml_call3(uncaught_exn_fun, uncaught_exn, record, record[8]);
    caml_call3(cycle_count_fun, cycle_count$0, record, record[9]);
    caml_call3(cycle_start_fun, cycle_start$0, record, record[10]);
    caml_call3(in_cycle_fun, in_cycle$0, record, record[11]);
    caml_call3
     (run_every_cycle_start_fun, run_every_cycle_start$0, record, record[12]);
    caml_call3
     (run_every_cycle_start_state_fu,
      run_every_cycle_start_state$0,
      record,
      record[13]);
    caml_call3
     (run_every_cycle_end_fun, run_every_cycle_end$0, record, record[14]);
    caml_call3
     (run_every_cycle_end_state_fun,
      run_every_cycle_end_state$0,
      record,
      record[15]);
    caml_call3(last_cycle_time_fun, last_cycle_time$0, record, record[16]);
    caml_call3
     (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, record, record[17]);
    caml_call3(total_cycle_time_fun, total_cycle_time$0, record, record[18]);
    caml_call3(time_source_fun, time_source$0, record, record[19]);
    caml_call3(external_jobs_fun, external_jobs$0, record, record[20]);
    caml_call3
     (thread_safe_external_job_hook_,
      thread_safe_external_job_hook$0,
      record,
      record[21]);
    caml_call3(job_queued_hook_fun, job_queued_hook$0, record, record[22]);
    caml_call3(event_added_hook_fun, event_added_hook$0, record, record[23]);
    caml_call3(yield_fun, yield$1, record, record[24]);
    caml_call3
     (yield_until_no_jobs_remain_fun,
      yield_until_no_jobs_remain$0,
      record,
      record[25]);
    caml_call3(check_invariants_fun, check_invariants$0, record, record[26]);
    caml_call3
     (max_num_jobs_per_priority_per_,
      max_num_jobs_per_priority_per_$0,
      record,
      record[27]);
    return caml_call3
            (record_backtraces_fun, record_backtraces$0, record, record[28]);
   }
   function fold$2
   (record,
    init,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _cN_ = record[28],
     _cO_ = record[27],
     _cP_ = record[26],
     _cQ_ = record[25],
     _cR_ = record[24],
     _cS_ = record[23],
     _cT_ = record[22],
     _cU_ = record[21],
     _cV_ = record[20],
     _cW_ = record[19],
     _cX_ = record[18],
     _cY_ = record[17],
     _cZ_ = record[16],
     _c0_ = record[15],
     _c1_ = record[14],
     _c2_ = record[13],
     _c3_ = record[12],
     _c4_ = record[11],
     _c5_ = record[10],
     _c6_ = record[9],
     _c7_ = record[8],
     _c8_ = record[7],
     _c9_ = record[6],
     _c__ = record[5],
     _c$_ = record[4],
     _da_ = record[3],
     _db_ = record[2];
    return caml_call4
            (record_backtraces_fun,
             caml_call4
              (max_num_jobs_per_priority_per_,
               caml_call4
                (check_invariants_fun,
                 caml_call4
                  (yield_until_no_jobs_remain_fun,
                   caml_call4
                    (yield_fun,
                     caml_call4
                      (event_added_hook_fun,
                       caml_call4
                        (job_queued_hook_fun,
                         caml_call4
                          (thread_safe_external_job_hook_,
                           caml_call4
                            (external_jobs_fun,
                             caml_call4
                              (time_source_fun,
                               caml_call4
                                (total_cycle_time_fun,
                                 caml_call4
                                  (last_cycle_num_jobs_fun,
                                   caml_call4
                                    (last_cycle_time_fun,
                                     caml_call4
                                      (run_every_cycle_end_state_fun,
                                       caml_call4
                                        (run_every_cycle_end_fun,
                                         caml_call4
                                          (run_every_cycle_start_state_fu,
                                           caml_call4
                                            (run_every_cycle_start_fun,
                                             caml_call4
                                              (in_cycle_fun,
                                               caml_call4
                                                (cycle_start_fun,
                                                 caml_call4
                                                  (cycle_count_fun,
                                                   caml_call4
                                                    (uncaught_exn_fun,
                                                     caml_call4
                                                      (current_execution_context_fun,
                                                       caml_call4
                                                        (main_execution_context_fun,
                                                         caml_call4
                                                          (very_low_priority_workers_fun,
                                                           caml_call4
                                                            (low_priority_jobs_fun,
                                                             caml_call4
                                                              (normal_priority_jobs_fun,
                                                               caml_call4
                                                                (job_pool_fun,
                                                                 caml_call4
                                                                  (check_access_fun, init, check_access$0, record, record[1]),
                                                                 job_pool$0,
                                                                 record,
                                                                 _db_),
                                                               normal_priority_jobs$0,
                                                               record,
                                                               _da_),
                                                             low_priority_jobs$0,
                                                             record,
                                                             _c$_),
                                                           very_low_priority_workers$0,
                                                           record,
                                                           _c__),
                                                         main_execution_context$0,
                                                         record,
                                                         _c9_),
                                                       current_execution_context$0,
                                                       record,
                                                       _c8_),
                                                     uncaught_exn,
                                                     record,
                                                     _c7_),
                                                   cycle_count$0,
                                                   record,
                                                   _c6_),
                                                 cycle_start$0,
                                                 record,
                                                 _c5_),
                                               in_cycle$0,
                                               record,
                                               _c4_),
                                             run_every_cycle_start$0,
                                             record,
                                             _c3_),
                                           run_every_cycle_start_state$0,
                                           record,
                                           _c2_),
                                         run_every_cycle_end$0,
                                         record,
                                         _c1_),
                                       run_every_cycle_end_state$0,
                                       record,
                                       _c0_),
                                     last_cycle_time$0,
                                     record,
                                     _cZ_),
                                   last_cycle_num_jobs$0,
                                   record,
                                   _cY_),
                                 total_cycle_time$0,
                                 record,
                                 _cX_),
                               time_source$0,
                               record,
                               _cW_),
                             external_jobs$0,
                             record,
                             _cV_),
                           thread_safe_external_job_hook$0,
                           record,
                           _cU_),
                         job_queued_hook$0,
                         record,
                         _cT_),
                       event_added_hook$0,
                       record,
                       _cS_),
                     yield$1,
                     record,
                     _cR_),
                   yield_until_no_jobs_remain$0,
                   record,
                   _cQ_),
                 check_invariants$0,
                 record,
                 _cP_),
               max_num_jobs_per_priority_per_$0,
               record,
               _cO_),
             record_backtraces$0,
             record,
             _cN_);
   }
   function for_all$2
   (record,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _cm_ = caml_call3(check_access_fun, check_access$0, record, record[1]),
     _cn_ =
       _cm_ ? caml_call3(job_pool_fun, job_pool$0, record, record[2]) : _cm_,
     _co_ =
       _cn_
        ? caml_call3
          (normal_priority_jobs_fun,
           normal_priority_jobs$0,
           record,
           record[3])
        : _cn_,
     _cp_ =
       _co_
        ? caml_call3
          (low_priority_jobs_fun, low_priority_jobs$0, record, record[4])
        : _co_,
     _cq_ =
       _cp_
        ? caml_call3
          (very_low_priority_workers_fun,
           very_low_priority_workers$0,
           record,
           record[5])
        : _cp_,
     _cr_ =
       _cq_
        ? caml_call3
          (main_execution_context_fun,
           main_execution_context$0,
           record,
           record[6])
        : _cq_,
     _cs_ =
       _cr_
        ? caml_call3
          (current_execution_context_fun,
           current_execution_context$0,
           record,
           record[7])
        : _cr_,
     _ct_ =
       _cs_
        ? caml_call3(uncaught_exn_fun, uncaught_exn, record, record[8])
        : _cs_,
     _cu_ =
       _ct_
        ? caml_call3(cycle_count_fun, cycle_count$0, record, record[9])
        : _ct_,
     _cv_ =
       _cu_
        ? caml_call3(cycle_start_fun, cycle_start$0, record, record[10])
        : _cu_,
     _cw_ =
       _cv_ ? caml_call3(in_cycle_fun, in_cycle$0, record, record[11]) : _cv_,
     _cx_ =
       _cw_
        ? caml_call3
          (run_every_cycle_start_fun,
           run_every_cycle_start$0,
           record,
           record[12])
        : _cw_,
     _cy_ =
       _cx_
        ? caml_call3
          (run_every_cycle_start_state_fu,
           run_every_cycle_start_state$0,
           record,
           record[13])
        : _cx_,
     _cz_ =
       _cy_
        ? caml_call3
          (run_every_cycle_end_fun, run_every_cycle_end$0, record, record[14])
        : _cy_,
     _cA_ =
       _cz_
        ? caml_call3
          (run_every_cycle_end_state_fun,
           run_every_cycle_end_state$0,
           record,
           record[15])
        : _cz_,
     _cB_ =
       _cA_
        ? caml_call3
          (last_cycle_time_fun, last_cycle_time$0, record, record[16])
        : _cA_,
     _cC_ =
       _cB_
        ? caml_call3
          (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, record, record[17])
        : _cB_,
     _cD_ =
       _cC_
        ? caml_call3
          (total_cycle_time_fun, total_cycle_time$0, record, record[18])
        : _cC_,
     _cE_ =
       _cD_
        ? caml_call3(time_source_fun, time_source$0, record, record[19])
        : _cD_,
     _cF_ =
       _cE_
        ? caml_call3(external_jobs_fun, external_jobs$0, record, record[20])
        : _cE_,
     _cG_ =
       _cF_
        ? caml_call3
          (thread_safe_external_job_hook_,
           thread_safe_external_job_hook$0,
           record,
           record[21])
        : _cF_,
     _cH_ =
       _cG_
        ? caml_call3
          (job_queued_hook_fun, job_queued_hook$0, record, record[22])
        : _cG_,
     _cI_ =
       _cH_
        ? caml_call3
          (event_added_hook_fun, event_added_hook$0, record, record[23])
        : _cH_,
     _cJ_ = _cI_ ? caml_call3(yield_fun, yield$1, record, record[24]) : _cI_,
     _cK_ =
       _cJ_
        ? caml_call3
          (yield_until_no_jobs_remain_fun,
           yield_until_no_jobs_remain$0,
           record,
           record[25])
        : _cJ_,
     _cL_ =
       _cK_
        ? caml_call3
          (check_invariants_fun, check_invariants$0, record, record[26])
        : _cK_,
     _cM_ =
       _cL_
        ? caml_call3
          (max_num_jobs_per_priority_per_,
           max_num_jobs_per_priority_per_$0,
           record,
           record[27])
        : _cL_;
    return _cM_
            ? caml_call3
              (record_backtraces_fun, record_backtraces$0, record, record[28])
            : _cM_;
   }
   function exists$2
   (record,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _cl_ = caml_call3(check_access_fun, check_access$0, record, record[1]),
     _bX_ = _cl_ || caml_call3(job_pool_fun, job_pool$0, record, record[2]),
     _bY_ =
       _bX_
       ||
        caml_call3
         (normal_priority_jobs_fun, normal_priority_jobs$0, record, record[3]),
     _bZ_ =
       _bY_
       ||
        caml_call3
         (low_priority_jobs_fun, low_priority_jobs$0, record, record[4]),
     _b0_ =
       _bZ_
       ||
        caml_call3
         (very_low_priority_workers_fun,
          very_low_priority_workers$0,
          record,
          record[5]),
     _b1_ =
       _b0_
       ||
        caml_call3
         (main_execution_context_fun,
          main_execution_context$0,
          record,
          record[6]),
     _b2_ =
       _b1_
       ||
        caml_call3
         (current_execution_context_fun,
          current_execution_context$0,
          record,
          record[7]),
     _b3_ =
       _b2_ || caml_call3(uncaught_exn_fun, uncaught_exn, record, record[8]),
     _b4_ =
       _b3_ || caml_call3(cycle_count_fun, cycle_count$0, record, record[9]),
     _b5_ =
       _b4_ || caml_call3(cycle_start_fun, cycle_start$0, record, record[10]),
     _b6_ = _b5_ || caml_call3(in_cycle_fun, in_cycle$0, record, record[11]),
     _b7_ =
       _b6_
       ||
        caml_call3
         (run_every_cycle_start_fun,
          run_every_cycle_start$0,
          record,
          record[12]),
     _b8_ =
       _b7_
       ||
        caml_call3
         (run_every_cycle_start_state_fu,
          run_every_cycle_start_state$0,
          record,
          record[13]),
     _b9_ =
       _b8_
       ||
        caml_call3
         (run_every_cycle_end_fun, run_every_cycle_end$0, record, record[14]),
     _b__ =
       _b9_
       ||
        caml_call3
         (run_every_cycle_end_state_fun,
          run_every_cycle_end_state$0,
          record,
          record[15]),
     _b$_ =
       _b__
       ||
        caml_call3(last_cycle_time_fun, last_cycle_time$0, record, record[16]),
     _ca_ =
       _b$_
       ||
        caml_call3
         (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, record, record[17]),
     _cb_ =
       _ca_
       ||
        caml_call3
         (total_cycle_time_fun, total_cycle_time$0, record, record[18]),
     _cc_ =
       _cb_ || caml_call3(time_source_fun, time_source$0, record, record[19]),
     _cd_ =
       _cc_
       || caml_call3(external_jobs_fun, external_jobs$0, record, record[20]),
     _ce_ =
       _cd_
       ||
        caml_call3
         (thread_safe_external_job_hook_,
          thread_safe_external_job_hook$0,
          record,
          record[21]),
     _cf_ =
       _ce_
       ||
        caml_call3(job_queued_hook_fun, job_queued_hook$0, record, record[22]),
     _cg_ =
       _cf_
       ||
        caml_call3
         (event_added_hook_fun, event_added_hook$0, record, record[23]),
     _ch_ = _cg_ || caml_call3(yield_fun, yield$1, record, record[24]),
     _ci_ =
       _ch_
       ||
        caml_call3
         (yield_until_no_jobs_remain_fun,
          yield_until_no_jobs_remain$0,
          record,
          record[25]),
     _cj_ =
       _ci_
       ||
        caml_call3
         (check_invariants_fun, check_invariants$0, record, record[26]),
     _ck_ =
       _cj_
       ||
        caml_call3
         (max_num_jobs_per_priority_per_,
          max_num_jobs_per_priority_per_$0,
          record,
          record[27]);
    return _ck_
            ? _ck_
            : caml_call3
              (record_backtraces_fun, record_backtraces$0, record, record[28]);
   }
   function to_list$2
   (record,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _bw_ =
       [0,
        caml_call3
         (record_backtraces_fun, record_backtraces$0, record, record[28]),
        0],
     _bx_ =
       [0,
        caml_call3
         (max_num_jobs_per_priority_per_,
          max_num_jobs_per_priority_per_$0,
          record,
          record[27]),
        _bw_],
     _by_ =
       [0,
        caml_call3
         (check_invariants_fun, check_invariants$0, record, record[26]),
        _bx_],
     _bz_ =
       [0,
        caml_call3
         (yield_until_no_jobs_remain_fun,
          yield_until_no_jobs_remain$0,
          record,
          record[25]),
        _by_],
     _bA_ = [0, caml_call3(yield_fun, yield$1, record, record[24]), _bz_],
     _bB_ =
       [0,
        caml_call3
         (event_added_hook_fun, event_added_hook$0, record, record[23]),
        _bA_],
     _bC_ =
       [0,
        caml_call3(job_queued_hook_fun, job_queued_hook$0, record, record[22]),
        _bB_],
     _bD_ =
       [0,
        caml_call3
         (thread_safe_external_job_hook_,
          thread_safe_external_job_hook$0,
          record,
          record[21]),
        _bC_],
     _bE_ =
       [0,
        caml_call3(external_jobs_fun, external_jobs$0, record, record[20]),
        _bD_],
     _bF_ =
       [0,
        caml_call3(time_source_fun, time_source$0, record, record[19]),
        _bE_],
     _bG_ =
       [0,
        caml_call3
         (total_cycle_time_fun, total_cycle_time$0, record, record[18]),
        _bF_],
     _bH_ =
       [0,
        caml_call3
         (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, record, record[17]),
        _bG_],
     _bI_ =
       [0,
        caml_call3(last_cycle_time_fun, last_cycle_time$0, record, record[16]),
        _bH_],
     _bJ_ =
       [0,
        caml_call3
         (run_every_cycle_end_state_fun,
          run_every_cycle_end_state$0,
          record,
          record[15]),
        _bI_],
     _bK_ =
       [0,
        caml_call3
         (run_every_cycle_end_fun, run_every_cycle_end$0, record, record[14]),
        _bJ_],
     _bL_ =
       [0,
        caml_call3
         (run_every_cycle_start_state_fu,
          run_every_cycle_start_state$0,
          record,
          record[13]),
        _bK_],
     _bM_ =
       [0,
        caml_call3
         (run_every_cycle_start_fun,
          run_every_cycle_start$0,
          record,
          record[12]),
        _bL_],
     _bN_ =
       [0, caml_call3(in_cycle_fun, in_cycle$0, record, record[11]), _bM_],
     _bO_ =
       [0,
        caml_call3(cycle_start_fun, cycle_start$0, record, record[10]),
        _bN_],
     _bP_ =
       [0,
        caml_call3(cycle_count_fun, cycle_count$0, record, record[9]),
        _bO_],
     _bQ_ =
       [0,
        caml_call3(uncaught_exn_fun, uncaught_exn, record, record[8]),
        _bP_],
     _bR_ =
       [0,
        caml_call3
         (current_execution_context_fun,
          current_execution_context$0,
          record,
          record[7]),
        _bQ_],
     _bS_ =
       [0,
        caml_call3
         (main_execution_context_fun,
          main_execution_context$0,
          record,
          record[6]),
        _bR_],
     _bT_ =
       [0,
        caml_call3
         (very_low_priority_workers_fun,
          very_low_priority_workers$0,
          record,
          record[5]),
        _bS_],
     _bU_ =
       [0,
        caml_call3
         (low_priority_jobs_fun, low_priority_jobs$0, record, record[4]),
        _bT_],
     _bV_ =
       [0,
        caml_call3
         (normal_priority_jobs_fun, normal_priority_jobs$0, record, record[3]),
        _bU_],
     _bW_ = [0, caml_call3(job_pool_fun, job_pool$0, record, record[2]), _bV_];
    return [0,
            caml_call3(check_access_fun, check_access$0, record, record[1]),
            _bW_];
   }
   function map$2
   (record,
    check_access_fun,
    job_pool_fun,
    normal_priority_jobs_fun,
    low_priority_jobs_fun,
    very_low_priority_workers_fun,
    main_execution_context_fun,
    current_execution_context_fun,
    uncaught_exn_fun,
    cycle_count_fun,
    cycle_start_fun,
    in_cycle_fun,
    run_every_cycle_start_fun,
    run_every_cycle_start_state_fu,
    run_every_cycle_end_fun,
    run_every_cycle_end_state_fun,
    last_cycle_time_fun,
    last_cycle_num_jobs_fun,
    total_cycle_time_fun,
    time_source_fun,
    external_jobs_fun,
    thread_safe_external_job_hook_,
    job_queued_hook_fun,
    event_added_hook_fun,
    yield_fun,
    yield_until_no_jobs_remain_fun,
    check_invariants_fun,
    max_num_jobs_per_priority_per_,
    record_backtraces_fun){
    var
     _a7_ =
       caml_call3
        (record_backtraces_fun, record_backtraces$0, record, record[28]),
     _a8_ =
       caml_call3
        (max_num_jobs_per_priority_per_,
         max_num_jobs_per_priority_per_$0,
         record,
         record[27]),
     _a9_ =
       caml_call3
        (check_invariants_fun, check_invariants$0, record, record[26]),
     _a__ =
       caml_call3
        (yield_until_no_jobs_remain_fun,
         yield_until_no_jobs_remain$0,
         record,
         record[25]),
     _a$_ = caml_call3(yield_fun, yield$1, record, record[24]),
     _ba_ =
       caml_call3
        (event_added_hook_fun, event_added_hook$0, record, record[23]),
     _bb_ =
       caml_call3(job_queued_hook_fun, job_queued_hook$0, record, record[22]),
     _bc_ =
       caml_call3
        (thread_safe_external_job_hook_,
         thread_safe_external_job_hook$0,
         record,
         record[21]),
     _bd_ = caml_call3(external_jobs_fun, external_jobs$0, record, record[20]),
     _be_ = caml_call3(time_source_fun, time_source$0, record, record[19]),
     _bf_ =
       caml_call3
        (total_cycle_time_fun, total_cycle_time$0, record, record[18]),
     _bg_ =
       caml_call3
        (last_cycle_num_jobs_fun, last_cycle_num_jobs$0, record, record[17]),
     _bh_ =
       caml_call3(last_cycle_time_fun, last_cycle_time$0, record, record[16]),
     _bi_ =
       caml_call3
        (run_every_cycle_end_state_fun,
         run_every_cycle_end_state$0,
         record,
         record[15]),
     _bj_ =
       caml_call3
        (run_every_cycle_end_fun, run_every_cycle_end$0, record, record[14]),
     _bk_ =
       caml_call3
        (run_every_cycle_start_state_fu,
         run_every_cycle_start_state$0,
         record,
         record[13]),
     _bl_ =
       caml_call3
        (run_every_cycle_start_fun,
         run_every_cycle_start$0,
         record,
         record[12]),
     _bm_ = caml_call3(in_cycle_fun, in_cycle$0, record, record[11]),
     _bn_ = caml_call3(cycle_start_fun, cycle_start$0, record, record[10]),
     _bo_ = caml_call3(cycle_count_fun, cycle_count$0, record, record[9]),
     _bp_ = caml_call3(uncaught_exn_fun, uncaught_exn, record, record[8]),
     _bq_ =
       caml_call3
        (current_execution_context_fun,
         current_execution_context$0,
         record,
         record[7]),
     _br_ =
       caml_call3
        (main_execution_context_fun,
         main_execution_context$0,
         record,
         record[6]),
     _bs_ =
       caml_call3
        (very_low_priority_workers_fun,
         very_low_priority_workers$0,
         record,
         record[5]),
     _bt_ =
       caml_call3
        (low_priority_jobs_fun, low_priority_jobs$0, record, record[4]),
     _bu_ =
       caml_call3
        (normal_priority_jobs_fun, normal_priority_jobs$0, record, record[3]),
     _bv_ = caml_call3(job_pool_fun, job_pool$0, record, record[2]);
    return [0,
            caml_call3(check_access_fun, check_access$0, record, record[1]),
            _bv_,
            _bu_,
            _bt_,
            _bs_,
            _br_,
            _bq_,
            _bp_,
            _bo_,
            _bn_,
            _bm_,
            _bl_,
            _bk_,
            _bj_,
            _bi_,
            _bh_,
            _bg_,
            _bf_,
            _be_,
            _bd_,
            _bc_,
            _bb_,
            _ba_,
            _a$_,
            _a__,
            _a9_,
            _a8_,
            _a7_];
   }
   function set_all_mutable_fields$0
   (record,
    check_access,
    job_pool,
    main_execution_context,
    current_execution_context,
    uncaught_exn,
    cycle_count,
    cycle_start,
    in_cycle,
    run_every_cycle_start,
    run_every_cycle_end,
    last_cycle_time,
    last_cycle_num_jobs,
    total_cycle_time,
    time_source,
    thread_safe_external_job_hook,
    job_queued_hook,
    event_added_hook,
    yield$0,
    yield_until_no_jobs_remain,
    check_invariants,
    max_num_jobs_per_priority_per_,
    record_backtraces){
    var record$0 = caml_call1(Base_Field[1][1], record);
    record$0[1] = check_access;
    record$0[2] = job_pool;
    record$0[6] = main_execution_context;
    record$0[7] = current_execution_context;
    record$0[8] = uncaught_exn;
    record$0[9] = cycle_count;
    record$0[10] = cycle_start;
    record$0[11] = in_cycle;
    record$0[12] = run_every_cycle_start;
    record$0[14] = run_every_cycle_end;
    record$0[16] = last_cycle_time;
    record$0[17] = last_cycle_num_jobs;
    record$0[18] = total_cycle_time;
    record$0[19] = time_source;
    record$0[21] = thread_safe_external_job_hook;
    record$0[22] = job_queued_hook;
    record$0[23] = event_added_hook;
    record$0[24] = yield$0;
    record$0[25] = yield_until_no_jobs_remain;
    record$0[26] = check_invariants;
    record$0[27] = max_num_jobs_per_priority_per_;
    record$0[28] = record_backtraces;
    return 0;
   }
   var
    Direct$0 =
      [0,
       iter$2,
       fold$2,
       for_all$2,
       exists$2,
       to_list$2,
       map$2,
       set_all_mutable_fields$0],
    Fields$0 =
      [0,
       names$0,
       record_backtraces$0,
       max_num_jobs_per_priority_per_$0,
       check_invariants$0,
       yield_until_no_jobs_remain$0,
       yield$1,
       event_added_hook$0,
       job_queued_hook$0,
       thread_safe_external_job_hook$0,
       external_jobs$0,
       time_source$0,
       total_cycle_time$0,
       last_cycle_num_jobs$0,
       last_cycle_time$0,
       run_every_cycle_end_state$0,
       run_every_cycle_end$0,
       run_every_cycle_start_state$0,
       run_every_cycle_start$0,
       in_cycle$0,
       cycle_start$0,
       cycle_count$0,
       uncaught_exn,
       current_execution_context$0,
       main_execution_context$0,
       very_low_priority_workers$0,
       low_priority_jobs$0,
       normal_priority_jobs$0,
       job_pool$0,
       check_access$0,
       make_creator$0,
       create$2,
       map$1,
       iter$1,
       fold$1,
       map_poly$0,
       for_all$1,
       exists$1,
       to_list$1,
       Direct$0],
    _f_ = [0, cst_record_backtraces],
    _g_ = [0, cst_max_num_jobs_per_priority_],
    _h_ = [0, cst_check_invariants],
    _i_ = [0, cst_yield_until_no_jobs_remain],
    _j_ = [0, cst_yield],
    _k_ = [0, cst_event_added_hook],
    _l_ = [0, cst_job_queued_hook],
    _m_ = [0, cst_thread_safe_external_job_h],
    _n_ = [0, cst_external_jobs],
    _o_ = [0, cst_time_source],
    _p_ = [0, cst_total_cycle_time],
    _q_ = [0, cst_last_cycle_num_jobs],
    _r_ = [0, cst_last_cycle_time],
    _s_ = [0, cst_run_every_cycle_end_state],
    _t_ = [0, cst_run_every_cycle_end],
    _u_ = [0, cst_run_every_cycle_start_stat],
    _v_ = [0, cst_run_every_cycle_start],
    _w_ = [0, cst_in_cycle],
    _x_ = [0, cst_cycle_start],
    _y_ = [0, cst_cycle_count],
    _z_ = [0, cst_uncaught_exn],
    _A_ = [0, cst_current_execution_context],
    _B_ = [0, cst_main_execution_context],
    _C_ = [0, cst_very_low_priority_workers],
    _D_ = [0, cst_low_priority_jobs],
    _E_ = [0, cst_normal_priority_jobs],
    _F_ = [0, cst_job_pool],
    _G_ = [0, cst_check_access],
    cst_unhandled_exception = "unhandled exception",
    _H_ = [0, cst_src_scheduler1_ml, 153, 2],
    _I_ = [0, "t"],
    _J_ = [0, "exn"],
    cst_Scheduler_invariant_failed = "Scheduler.invariant failed",
    _K_ = [0, cst_src_scheduler1_ml, 191, 14],
    _L_ = [0, cst_src_scheduler1_ml, 187, 43],
    _M_ = [0, cst_src_scheduler1_ml, 171, 46],
    _N_ = [0, cst_src_scheduler1_ml, 170, 40];
   function sexp_of_t$1(param){
    var
     check_access_007 = param[1],
     job_pool_009 = param[2],
     very_low_priority_workers_015 = param[5],
     low_priority_jobs_013 = param[4],
     normal_priority_jobs_011 = param[3],
     main_execution_context_017 = param[6],
     current_execution_context_019 = param[7],
     uncaught_exn_021 = param[8],
     cycle_count_027 = param[9],
     cycle_start_029 = param[10],
     in_cycle_031 = param[11],
     run_every_cycle_start_033 = param[12],
     run_every_cycle_start_state_03 = param[13],
     run_every_cycle_end_037 = param[14],
     run_every_cycle_end_state_039 = param[15],
     last_cycle_time_041 = param[16],
     last_cycle_num_jobs_043 = param[17],
     total_cycle_time_045 = param[18],
     time_source_047 = param[19],
     external_jobs_049 = param[20],
     job_queued_hook_053 = param[22],
     event_added_hook_055 = param[23],
     yield_057 = param[24],
     yield_until_no_jobs_remain_059 = param[25],
     check_invariants_061 = param[26],
     max_num_jobs_per_priority_per_ = param[27],
     record_backtraces_065 = param[28],
     arg_066 = caml_call1(Core[305], record_backtraces_065),
     bnds_006 = [0, [1, [0, _f_, [0, arg_066, 0]]], 0],
     arg_064 =
       caml_call1(Async_kernel_config[5][2], max_num_jobs_per_priority_per_),
     bnds_006$0 = [0, [1, [0, _g_, [0, arg_064, 0]]], bnds_006],
     arg_062 = caml_call1(Core[305], check_invariants_061),
     bnds_006$1 = [0, [1, [0, _h_, [0, arg_062, 0]]], bnds_006$0],
     arg_060 =
       caml_call1(Sexplib0_Sexp_conv[23], yield_until_no_jobs_remain_059),
     bnds_006$2 = [0, [1, [0, _i_, [0, arg_060, 0]]], bnds_006$1],
     arg_058 = caml_call1(Sexplib0_Sexp_conv[23], yield_057),
     bnds_006$3 = [0, [1, [0, _j_, [0, arg_058, 0]]], bnds_006$2],
     arg_056 =
       caml_call2
        (Core[454],
         function(param){
          return caml_call1(Sexplib0_Sexp_conv[24], function(_a6_){return 0;});
         },
         event_added_hook_055),
     bnds_006$4 = [0, [1, [0, _k_, [0, arg_056, 0]]], bnds_006$3],
     arg_054 =
       caml_call2
        (Core[454],
         function(param){
          return caml_call1(Sexplib0_Sexp_conv[24], function(_a5_){return 0;});
         },
         job_queued_hook_053),
     bnds_006$5 = [0, [1, [0, _l_, [0, arg_054, 0]]], bnds_006$4],
     arg_052 = caml_call1(Sexplib0_Sexp_conv[24], function(_a4_){return 0;}),
     bnds_006$6 = [0, [1, [0, _m_, [0, arg_052, 0]]], bnds_006$5],
     arg_050 =
       caml_call2
        (Thread_safe_queue[1],
         Async_kernel_External_job[1],
         external_jobs_049),
     bnds_006$7 = [0, [1, [0, _n_, [0, arg_050, 0]]], bnds_006$6],
     arg_048 =
       caml_call2
        (Async_kernel_Synchronous_time_[4][17], Core[202], time_source_047),
     bnds_006$8 = [0, [1, [0, _o_, [0, arg_048, 0]]], bnds_006$7],
     arg_046 = caml_call1(Core_Time_ns[1][10], total_cycle_time_045),
     bnds_006$9 = [0, [1, [0, _p_, [0, arg_046, 0]]], bnds_006$8],
     arg_044 = caml_call1(Core[356], last_cycle_num_jobs_043),
     bnds_006$10 = [0, [1, [0, _q_, [0, arg_044, 0]]], bnds_006$9],
     arg_042 = caml_call1(Core_Time_ns[1][10], last_cycle_time_041),
     bnds_006$11 = [0, [1, [0, _r_, [0, arg_042, 0]]], bnds_006$10],
     arg_040 =
       caml_call3
        (Core_Hashtbl[3],
         Async_kernel_Types[20][10],
         Sexplib0_Sexp_conv[23],
         run_every_cycle_end_state_039),
     bnds_006$12 = [0, [1, [0, _s_, [0, arg_040, 0]]], bnds_006$11],
     arg_038 =
       caml_call2(Core[421], Sexplib0_Sexp_conv[23], run_every_cycle_end_037),
     bnds_006$13 = [0, [1, [0, _t_, [0, arg_038, 0]]], bnds_006$12],
     arg_036 =
       caml_call3
        (Core_Hashtbl[3],
         Async_kernel_Types[20][10],
         Sexplib0_Sexp_conv[23],
         run_every_cycle_start_state_03),
     bnds_006$14 = [0, [1, [0, _u_, [0, arg_036, 0]]], bnds_006$13],
     arg_034 =
       caml_call2
        (Core[421], Sexplib0_Sexp_conv[23], run_every_cycle_start_033),
     bnds_006$15 = [0, [1, [0, _v_, [0, arg_034, 0]]], bnds_006$14],
     arg_032 = caml_call1(Core[305], in_cycle_031),
     bnds_006$16 = [0, [1, [0, _w_, [0, arg_032, 0]]], bnds_006$15],
     arg_030 = caml_call1(Async_kernel_Time_ns[92], cycle_start_029),
     bnds_006$17 = [0, [1, [0, _x_, [0, arg_030, 0]]], bnds_006$16],
     arg_028 = caml_call1(Core[356], cycle_count_027),
     bnds_006$18 = [0, [1, [0, _y_, [0, arg_028, 0]]], bnds_006$17],
     arg_022 =
       caml_call2
        (Core[454],
         function(param){
          var
           arg1_024 = param[2],
           arg0_023 = param[1],
           res0_025 = caml_call1(Base_Exn[1], arg0_023),
           res1_026 = caml_call1(Core_Sexp[90], arg1_024);
          return [1, [0, res0_025, [0, res1_026, 0]]];
         },
         uncaught_exn_021),
     bnds_006$19 = [0, [1, [0, _z_, [0, arg_022, 0]]], bnds_006$18],
     arg_020 =
       caml_call1
        (Async_kernel_Execution_context[6], current_execution_context_019),
     bnds_006$20 = [0, [1, [0, _A_, [0, arg_020, 0]]], bnds_006$19],
     arg_018 =
       caml_call1
        (Async_kernel_Execution_context[6], main_execution_context_017),
     bnds_006$21 = [0, [1, [0, _B_, [0, arg_018, 0]]], bnds_006$20],
     arg_016 =
       caml_call2
        (Core_Deque[10],
         Very_low_priority_worker[5],
         very_low_priority_workers_015),
     bnds_006$22 = [0, [1, [0, _C_, [0, arg_016, 0]]], bnds_006$21],
     arg_014 = caml_call1(Async_kernel_Job_queue[1], low_priority_jobs_013),
     bnds_006$23 = [0, [1, [0, _D_, [0, arg_014, 0]]], bnds_006$22],
     arg_012 = caml_call1(Async_kernel_Job_queue[1], normal_priority_jobs_011),
     bnds_006$24 = [0, [1, [0, _E_, [0, arg_012, 0]]], bnds_006$23],
     arg_010 = caml_call1(Async_kernel_Job_pool[2], job_pool_009),
     bnds_006$25 = [0, [1, [0, _F_, [0, arg_010, 0]]], bnds_006$24],
     arg_008 =
       caml_call2
        (Core[454],
         function(param){
          return caml_call1(Sexplib0_Sexp_conv[24], function(_a3_){return 0;});
         },
         check_access_007),
     bnds_006$26 = [0, [1, [0, _G_, [0, arg_008, 0]]], bnds_006$25];
    return [1, bnds_006$26];
   }
   function uncaught_exn$0(t){
    var _a2_ = t[8];
    if(! _a2_) return 0;
    var match = _a2_[1], sexp = match[2], exn = match[1];
    return [0,
            caml_call5
             (Core_Error[17],
              0,
              0,
              cst_unhandled_exception,
              [0, exn, sexp],
              function(param){
               var
                arg1_068 = param[2],
                arg0_067 = param[1],
                res0_069 = caml_call1(Base_Exn[1], arg0_067),
                res1_070 = caml_call1(Core_Sexp[90], arg1_068);
               return [1, [0, res0_069, [0, res1_070, 0]]];
              })];
   }
   function num_pending_jobs(t){
    var _a1_ = caml_call1(Async_kernel_Job_queue[8], t[4]);
    return caml_call1(Async_kernel_Job_queue[8], t[3]) + _a1_ | 0;
   }
   function num_jobs_run(t){
    var _a0_ = caml_call1(Async_kernel_Job_queue[10], t[4]);
    return caml_call1(Async_kernel_Job_queue[10], t[3]) + _a0_ | 0;
   }
   function last_cycle_num_jobs$1(t){return t[17];}
   function unordered_is_sublist(equal, small, large){
    var
     _aY_ =
       caml_call3
        (Core_List[10],
         small,
         [0, large],
         function(acc, x){
          return caml_call2
                  (Core_Option[27],
                   acc,
                   function(l$0){
                    var
                     _aZ_ =
                       caml_call2
                        (Core_List[130],
                         l$0,
                         function(y){return 1 - caml_call2(equal, y, x);}),
                     match = _aZ_[2],
                     l = _aZ_[1];
                    if(! match) return 0;
                    var r = match[2];
                    return [0, caml_call2(Core[157], l, r)];
                   });
         });
    return caml_call1(Core_Option[57], _aY_);
   }
   function check_hook_table_invariant(table, list){
    var _aX_ = caml_call1(Core_Hashtbl[65], table);
    if(unordered_is_sublist(Core[246], _aX_, list)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
   }
   function invariant$0(t){
    try{
     var
      check =
        function(f, field){
         return caml_call1(f, caml_call2(Base_Field[3], field, t));
        },
      _as_ =
        caml_call1
         (Async_kernel_Synchronous_time_[8][3],
          function(job){
           if(caml_call2(Tuple_pool[6], t[2], job)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _K_], 1);
          }),
      _at_ = Async_kernel_Execution_context[7],
      _au_ = Async_kernel_Execution_context[7],
      _av_ = Async_kernel_Job_queue[2],
      _aw_ = Async_kernel_Job_queue[2],
      _ax_ = Async_kernel_Job_pool[3],
      _ay_ =
        caml_call28
         (Fields$0[33],
          function(_aW_){return 0;},
          function(_aV_){return check(_ax_, _aV_);},
          function(_aU_){return check(_aw_, _aU_);},
          function(_aT_){return check(_av_, _aT_);},
          function(field){
           var q = caml_call2(Base_Field[3], field, t);
           return caml_call2(Core_Deque[17], q, Very_low_priority_worker[6]);
          },
          function(_aS_){return check(_au_, _aS_);},
          function(_aR_){return check(_at_, _aR_);},
          function(field){
           var
            uncaught_exn = caml_call2(Base_Field[3], field, t),
            _aP_ = caml_call1(Core[243], uncaught_exn);
           if(! _aP_) return _aP_;
           var _aQ_ = num_pending_jobs(t);
           if(caml_call2(Async_kernel_Import[3], _aQ_, 0)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _N_], 1);
          },
          function(field){
           var cycle_count = caml_call2(Base_Field[3], field, t);
           if(caml_call2(Async_kernel_Import[1], cycle_count, 0)) return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _M_], 1);
          },
          function(_aO_){return 0;},
          function(_aN_){return 0;},
          function(_aM_){return 0;},
          function(field){
           var
            run_every_cycle_start_state = caml_call2(Base_Field[3], field, t);
           return check_hook_table_invariant
                   (run_every_cycle_start_state, t[12]);
          },
          function(_aL_){return 0;},
          function(field){
           var
            run_every_cycle_end_state = caml_call2(Base_Field[3], field, t);
           return check_hook_table_invariant(run_every_cycle_end_state, t[14]);
          },
          function(_aK_){return 0;},
          function(field){
           var last_cycle_num_jobs = caml_call2(Base_Field[3], field, t);
           if(caml_call2(Async_kernel_Import[1], last_cycle_num_jobs, 0))
            return 0;
           throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
          },
          function(_aJ_){return 0;},
          function(_aI_){return check(_as_, _aI_);},
          function(_aH_){return 0;},
          function(_aG_){return 0;},
          function(_aF_){return 0;},
          function(_aE_){return 0;},
          function(_aD_){return 0;},
          function(_aC_){return 0;},
          function(_aB_){return 0;},
          function(_aA_){return 0;},
          function(_az_){return 0;});
     return _ay_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _ap_ = [0, [1, [0, _I_, [0, sexp_of_t$1(t), 0]]], 0],
      _aq_ = [0, [1, [0, _J_, [0, caml_call1(Core[537], exn), 0]]], _ap_],
      _ar_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_invariant_failed),
          _aq_]];
     return caml_call1(Core[253], _ar_);
    }
   }
   function free_job(t, job){return caml_call2(Tuple_pool[15], t[2], job);}
   function enqueue(t, execution_context, f, a){
    var _an_ = caml_call1(Core[242], t[8]);
    if(_an_){
     var priority = execution_context[2], job_queue = priority ? t[4] : t[3];
     caml_call4(Async_kernel_Job_queue[4], job_queue, execution_context, f, a);
     var match = t[22];
     if(match){var f$0 = match[1]; return caml_call1(f$0, priority);}
     var _ao_ = 0;
    }
    else
     var _ao_ = _an_;
    return _ao_;
   }
   function enqueue_job(t, job, free_job){
    var
     job_pool = t[2],
     _al_ = caml_call3(Tuple_pool[32], job_pool, job, Tuple_pool[2][5]),
     _am_ = caml_call3(Tuple_pool[32], job_pool, job, Tuple_pool[2][4]);
    enqueue
     (t,
      caml_call3(Tuple_pool[32], job_pool, job, Tuple_pool[2][3]),
      _am_,
      _al_);
    return free_job ? caml_call2(Tuple_pool[15], t[2], job) : free_job;
   }
   function handle_fired(time_source, job_or_event){
    var
     k = caml_call1(Async_kernel_Synchronous_time_[4][2][5][1], job_or_event),
     match =
       caml_call2(Async_kernel_Synchronous_time_[4][2][5][2], k, job_or_event);
    return k
            ? enqueue_job(time_source[9], match, 1)
            : caml_call2
              (Async_kernel_Synchronous_time_[14], time_source, match);
   }
   function create$3(param){
    var
     now = caml_call1(Async_kernel_Time_ns[50], 0),
     t = [],
     time_source = [],
     events = caml_call2(Timing_wheel[9], Async_kernel_config[29], now),
     _T_ = Async_kernel_config[27],
     _U_ = Async_kernel_config[23],
     _V_ = Async_kernel_config[16],
     _W_ = caml_call1(Bvar[1], 0),
     _X_ = caml_call1(Bvar[1], 0),
     _Y_ = caml_call1(Thread_safe_queue[3], 0),
     _Z_ = caml_call1(Async_kernel_Import[16], 0.),
     ___ = caml_call1(Async_kernel_Import[16], 0.),
     _$_ = Async_kernel_Types[20],
     _aa_ = caml_call3(Core_Hashtbl[4], 0, 0, [0, _$_[20], _$_[10], _$_[36]]),
     _ab_ = Async_kernel_Types[20],
     _ac_ =
       caml_call3(Core_Hashtbl[4], 0, 0, [0, _ab_[20], _ab_[10], _ab_[36]]),
     _ad_ = Async_kernel_Execution_context[8],
     _ae_ = Async_kernel_Execution_context[8],
     _af_ = caml_call3(Core_Deque[31], 0, 0, 0),
     _ag_ = caml_call1(Async_kernel_Job_queue[3], 0),
     _ah_ = caml_call1(Async_kernel_Job_queue[3], 0);
    caml_update_dummy
     (t,
      [0,
       0,
       caml_call1(Async_kernel_Job_pool[4], 0),
       _ah_,
       _ag_,
       _af_,
       _ae_,
       _ad_,
       0,
       0,
       now,
       0,
       0,
       _ac_,
       0,
       _aa_,
       ___,
       0,
       _Z_,
       time_source,
       _Y_,
       function(_ak_){return 0;},
       0,
       0,
       _X_,
       _W_,
       _V_,
       _U_,
       _T_]);
    var
     _ai_ = Async_kernel_Synchronous_time_[22][3][2],
     _aj_ = Async_kernel_Synchronous_time_[22][3][2];
    caml_update_dummy
     (time_source,
      [0,
       caml_call1(Async_kernel_Types[21][45], 0),
       0,
       0,
       events,
       _aj_,
       _ai_,
       function(alarm){
        return handle_fired
                (time_source, caml_call2(Timing_wheel[5][5], events, alarm));
       },
       1,
       t]);
    return t;
   }
   function is_dead(t){return caml_call1(Core[243], t[8]);}
   function set_check_access$0(t, f){t[1] = f; return 0;}
   var
    match = caml_call1(Core_Result[47], create$3),
    _O_ = [0, 0],
    _P_ = [0, 0],
    cst_got_uncaught_exn = "got_uncaught_exn",
    cst_Async_cannot_create_its_ra = "Async cannot create its raw scheduler",
    cst_async_kernel = cst_async_kernel$0,
    cst_Async_kernel_Scheduler1 = cst_Async_kernel_Scheduler1$0;
   if(0 === match[0])
    var t = match[1], t_ref = [0, t];
   else{
    var exn = match[1];
    caml_call3
     (Async_kernel_Debug[15], cst_Async_cannot_create_its_ra, exn, Core[537]);
    var t_ref = caml_call1(Core[83], 1);
   }
   function check_access$1(t){
    var match = t[1];
    if(! match) return 0;
    var f = match[1];
    return caml_call1(f, 0);
   }
   function t$0(param){var t = t_ref[1]; check_access$1(t); return t;}
   function current_execution_context$1(t){
    return t[28] ? caml_call1(Async_kernel_Execution_context[12], t[7]) : t[7];
   }
   function with_execution_context1(t, tmp_context, f, x){
    var old_context = current_execution_context$1(t);
    caml_call2(set_execution_context, t, tmp_context);
    return caml_call3
            (Core[252],
             f,
             x,
             function(param){
              return caml_call2(set_execution_context, t, old_context);
             });
   }
   function with_execution_context(t, tmp_context, f){
    return with_execution_context1(t, tmp_context, f, 0);
   }
   function create_job(t, execution_context, f, a){
    if(caml_call1(Tuple_pool[14], t[2]))
     t[2] = caml_call2(Tuple_pool[13], 0, t[2]);
    return caml_call4(Tuple_pool[19], t[2], execution_context, f, a);
   }
   function got_uncaught_exn(t, exn, sexp){
    if(debug)
     caml_call3
      (Async_kernel_Debug[15],
       cst_got_uncaught_exn,
       [0, exn, sexp],
       function(param){
        var
         arg1_072 = param[2],
         arg0_071 = param[1],
         res0_073 = caml_call1(Base_Exn[1], arg0_071),
         res1_074 = caml_call1(Core_Sexp[90], arg1_072);
        return [1, [0, res0_073, [0, res1_074, 0]]];
       });
    caml_call2
     (Core_List[9], [0, t[3], [0, t[4], 0]], Async_kernel_Job_queue[5]);
    t[8] = [0, [0, exn, sexp]];
    return 0;
   }
   function start_cycle(t, max_num_jobs_per_priority){
    var n = caml_call1(Async_kernel_config[5][5], max_num_jobs_per_priority);
    caml_call2(Async_kernel_Job_queue[6], t[3], n);
    return caml_call2(Async_kernel_Job_queue[6], t[4], n);
   }
   function run_jobs(t){
    for(;;){
     var e = caml_call2(Async_kernel_Job_queue[9], t[3], t);
     if(0 !== e[0]) return e;
     var e$0 = caml_call2(Async_kernel_Job_queue[9], t[4], t);
     if(0 !== e$0[0]) return e$0;
     if
      (!
       caml_call1(Async_kernel_Job_queue[7], t[3])
       && ! caml_call1(Async_kernel_Job_queue[7], t[4]))
      return _O_;
    }
   }
   function stabilize(t){
    start_cycle(t, caml_call1(Async_kernel_config[5][4], Core_Int[41]));
    var match = run_jobs(t);
    if(0 === match[0]) return _P_;
    var exn = match[1][1];
    return [1, exn];
   }
   function create_time_source(opt, now, param){
    if(opt)
     var sth = opt[1], timing_wheel_config = sth;
    else
     var timing_wheel_config = Async_kernel_config[29];
    var
     t = t$0(0),
     events = caml_call2(Timing_wheel[9], timing_wheel_config, now),
     time_source = [],
     _R_ = Async_kernel_Synchronous_time_[22][3][2],
     _S_ = Async_kernel_Synchronous_time_[22][3][2];
    caml_update_dummy
     (time_source,
      [0,
       caml_call1(Async_kernel_Types[21][45], 0),
       0,
       0,
       events,
       _S_,
       _R_,
       function(alarm){
        return handle_fired
                (time_source, caml_call2(Timing_wheel[5][5], events, alarm));
       },
       0,
       t]);
    return time_source;
   }
   function wall_clock(param){
    var _Q_ = t$0(0)[19];
    return caml_call1(Async_kernel_Synchronous_time_[13], _Q_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Scheduler1);
   var
    Async_kernel_Scheduler1 =
      [0,
       events,
       set_execution_context,
       debug,
       Ivar,
       Bvar,
       Very_low_priority_worker,
       record_backtraces,
       set_record_backtraces,
       max_num_jobs_per_priority_per_,
       set_max_num_jobs_per_priority_,
       check_invariants,
       set_check_invariants,
       yield_until_no_jobs_remain,
       set_yield_until_no_jobs_remain,
       yield$0,
       set_yield,
       event_added_hook,
       set_event_added_hook,
       job_queued_hook,
       set_job_queued_hook,
       thread_safe_external_job_hook,
       set_thread_safe_external_job_h,
       external_jobs,
       time_source,
       set_time_source,
       total_cycle_time,
       set_total_cycle_time,
       set_last_cycle_num_jobs,
       last_cycle_time,
       set_last_cycle_time,
       run_every_cycle_end_state,
       run_every_cycle_end,
       set_run_every_cycle_end,
       run_every_cycle_start_state,
       run_every_cycle_start,
       set_run_every_cycle_start,
       in_cycle,
       set_in_cycle,
       cycle_start,
       set_cycle_start,
       cycle_count,
       set_cycle_count,
       set_uncaught_exn,
       set_current_execution_context,
       main_execution_context,
       set_main_execution_context,
       very_low_priority_workers,
       low_priority_jobs,
       normal_priority_jobs,
       job_pool,
       set_job_pool,
       Fields$0,
       sexp_of_t$1,
       uncaught_exn_unwrapped,
       uncaught_exn$0,
       num_pending_jobs,
       num_jobs_run,
       last_cycle_num_jobs$1,
       unordered_is_sublist,
       check_hook_table_invariant,
       invariant$0,
       free_job,
       enqueue,
       enqueue_job,
       handle_fired,
       create$3,
       is_dead,
       set_check_access$0,
       t_ref,
       check_access$1,
       t$0,
       current_execution_context$1,
       with_execution_context1,
       with_execution_context,
       create_job,
       got_uncaught_exn,
       start_cycle,
       run_jobs,
       stabilize,
       create_time_source,
       wall_clock];
   runtime.caml_register_global
    (120, Async_kernel_Scheduler1, cst_Async_kernel_Scheduler1$0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Ivar0
//# unitInfo: Requires: Assert_failure, Async_kernel__Execution_context, Async_kernel__Scheduler1, Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Ivar0 = "Async_kernel__Ivar0",
    cst_async_kernel = "async_kernel",
    cst_src_ivar0_ml = "src/ivar0.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Ivar0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_ivar0_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _b_ = [0, "execution_context"];
   function set_prev(param, x){param[3] = x; return 0;}
   function set_next(param, x){param[4] = x; return 0;}
   function create(run, execution_context){
    var t = [0, run, execution_context, 0, 0];
    set_prev(t, t);
    set_next(t, t);
    return t;
   }
   function create2(run1, execution_context1, run2, execution_context2){
    var
     t1 = [0, run1, execution_context1, 0, 0],
     t2 = [0, run2, execution_context2, t1, t1];
    set_prev(t1, t2);
    set_next(t1, t2);
    return t1;
   }
   function length(t){
    var n = [0, 1], r = [0, t[4]];
    for(;;){
     if(caml_call2(Core[246], r[1], t)) return n[1];
     n[1]++;
     r[1] = r[1][4];
    }
   }
   function enqueue(t, scheduler, v){
    return caml_call4(Async_kernel_Scheduler1[63], scheduler, t[2], t[1], v);
   }
   function schedule_jobs(t, v){
    var scheduler = caml_call1(Async_kernel_Scheduler1[71], 0);
    enqueue(t, scheduler, v);
    var r = [0, t[4]];
    for(;;){
     if(caml_call2(Core[246], r[1], t)) return 0;
     enqueue(r[1], scheduler, v);
     r[1] = r[1][4];
    }
   }
   function add(t, run, execution_context){
    var result = [0, run, execution_context, t[3], t];
    set_next(t[3], result);
    set_prev(t, result);
    return result;
   }
   function of_list(l){
    if(! l) return 0;
    var
     l$0 = l[2],
     match = l[1],
     execution_context = match[2],
     run = match[1],
     first = create(run, execution_context),
     prev = first,
     l$1 = l$0;
    for(;;){
     if(! l$1){set_prev(first, prev); return [0, first];}
     var
      l$2 = l$1[2],
      match$0 = l$1[1],
      execution_context$0 = match$0[2],
      run$0 = match$0[1],
      prev$0 = [0, run$0, execution_context$0, prev, first];
     set_next(prev, prev$0);
     prev = prev$0;
     l$1 = l$2;
    }
   }
   function to_list(first){
    var t = first[3], t$0 = t, acc = 0;
    for(;;){
     var acc$0 = [0, [0, t$0[1], t$0[2]], acc];
     if(caml_call2(Core[246], t$0, first)) return acc$0;
     var t$1 = t$0[3];
     t$0 = t$1;
     acc = acc$0;
    }
   }
   function sexp_of_t(param, t){
    var execution_context = t[2];
    return [1,
            [0,
             _b_,
             [0,
              caml_call1(Async_kernel_Execution_context[6], execution_context),
              0]]];
   }
   function cell_of_handler(x){return x;}
   function equal(t$0, t){return caml_call2(Core[246], t$0, t);}
   function indir(t){return [0, [3, t]];}
   var
    include = Async_kernel_Scheduler1[4],
    create_with_cell = include[1],
    create$0 = include[2],
    create_full = include[3],
    _a_ = [0, cst_src_ivar0_ml, 118, 6],
    _c_ = [0, cst_src_ivar0_ml, 258, 15],
    _d_ = [0, "Empty"],
    _e_ = [0, "Full"],
    _f_ = [0, cst_src_ivar0_ml, 269, 15],
    _g_ = [0, cst_src_ivar0_ml, 277, 15],
    _h_ = [0, cst_src_ivar0_ml, 285, 15],
    cst_Ivar_value_exn_called_on_e = "Ivar.value_exn called on empty ivar",
    _i_ = [0, cst_src_ivar0_ml, 296, 15],
    _j_ = [0, "_"],
    _k_ = [0, "t"],
    cst_Ivar_fill_of_full_ivar = "Ivar.fill of full ivar",
    _l_ = [0, cst_src_ivar0_ml, 306, 15],
    _m_ = [0, cst_src_ivar0_ml, 321, 15],
    _n_ = [0, cst_src_ivar0_ml, 340, 15],
    _o_ = [0, cst_src_ivar0_ml, 362, 15],
    _p_ = [0, cst_src_ivar0_ml, 383, 15],
    _q_ = [0, cst_src_ivar0_ml, 450, 21],
    _r_ = [0, cst_src_ivar0_ml, 446, 35];
   function squash(t$3){
    var match$0 = t$3[1];
    if(typeof match$0 !== "number" && 3 === match$0[0]){
     var t$4 = match$0[1], indir$1 = t$4[1];
     if(typeof indir$1 !== "number" && 3 === indir$1[0]){
      var t$5 = indir$1[1];
      a:
      {
       var indir = indir$1, t = t$5;
       for(;;){
        var indir$0 = t[1];
        if(typeof indir$0 === "number") break;
        if(3 !== indir$0[0]) break a;
        var t$0 = indir$0[1];
        indir = indir$0;
        t = t$0;
       }
      }
      var t$1 = t$3;
      for(;;){
       var match = t$1[1];
       if(typeof match !== "number" && 3 === match[0]){
        var t$2 = match[1];
        t$1[1] = indir;
        t$1 = t$2;
        continue;
       }
       return t$1;
      }
     }
     return t$4;
    }
    return t$3;
   }
   function invariant(a_invariant, t){
    var t$0 = squash(t), handler = t$0[1];
    if(typeof handler === "number") return 0;
    switch(handler[0]){
      case 0:
       caml_call1(Async_kernel_Execution_context[7], handler[2]);
       var r = [0, handler[4]];
       for(;;){
        if(caml_call2(Core[246], r[1], handler)) return 0;
        var t1 = r[1];
        if(! caml_call2(Core[246], t1[4][3], t1))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
        caml_call1(Async_kernel_Execution_context[7], t1[2]);
        r[1] = r[1][4];
       }
       break;
      case 1:
       var execution_context = handler[2];
       return caml_call1(Async_kernel_Execution_context[7], execution_context);
      case 2:
       var a = handler[1]; return caml_call1(a_invariant, a);
      default: throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    }
   }
   function sexp_of_t$0(sexp_of_a, t){
    var t$0 = squash(t), match = t$0[1];
    if(typeof match !== "number")
     switch(match[0]){
       case 2:
        var a = match[1];
        return [1, [0, _e_, [0, caml_call1(sexp_of_a, a), 0]]];
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     }
    return _d_;
   }
   function peek(t){
    var t$0 = squash(t), match = t$0[1];
    if(typeof match !== "number")
     switch(match[0]){
       case 2:
        var a = match[1]; return [0, a];
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     }
    return 0;
   }
   function value(t, if_empty_then_failwith){
    var t$0 = squash(t), match = t$0[1];
    if(typeof match !== "number")
     switch(match[0]){
       case 2:
        var a = match[1]; return a;
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
     }
    return caml_call1(Core[6], if_empty_then_failwith);
   }
   function value_exn(t){return value(t, cst_Ivar_value_exn_called_on_e);}
   function is_empty(t){
    var t$0 = squash(t), _B_ = t$0[1];
    if(typeof _B_ !== "number")
     switch(_B_[0]){
       case 2:
        return 0;
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     }
    return 1;
   }
   function is_full(t){return 1 - is_empty(t);}
   function fill(t, v){
    var x_001 = squash(t), handler = x_001[1];
    if(typeof handler !== "number")
     switch(handler[0]){
       case 0:
        x_001[1] = [2, v]; return schedule_jobs(handler, v);
       case 1:
        var execution_context = handler[2], run = handler[1];
        x_001[1] = [2, v];
        var _y_ = caml_call1(Async_kernel_Scheduler1[71], 0);
        return caml_call3
                (caml_call1(Async_kernel_Scheduler1[63], _y_),
                 execution_context,
                 run,
                 v);
       case 2:
        var
         _z_ =
           [0,
            [1,
             [0,
              _k_,
              [0, sexp_of_t$0(function(param){return _j_;}, x_001), 0]]],
            0],
         _A_ =
           [1,
            [0,
             caml_call1(Sexplib0_Sexp_conv[7], cst_Ivar_fill_of_full_ivar),
             _z_]];
        return caml_call1(Core[253], _A_);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
     }
    x_001[1] = [2, v];
    return 0;
   }
   function remove_handler(t, handler){
    function x$0(_x_){return 0;}
    handler[1] = x$0;
    var t$0 = squash(t), cell = t$0[1];
    if(typeof cell !== "number")
     switch(cell[0]){
       case 0:
        if(caml_call2(Core[246], handler, handler[4])){t$0[1] = 0; return 0;}
        if(caml_call2(Core[246], handler, cell)){var x = handler[4]; t$0[1] = x;}
        set_prev(handler[4], handler[3]);
        set_next(handler[3], handler[4]);
        set_prev(handler, handler);
        return set_next(handler, handler);
       case 2:
        return 0;
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
     }
    return 0;
   }
   function add_handler(t, run, execution_context){
    var t$0 = squash(t), handler = t$0[1];
    if(typeof handler !== "number")
     switch(handler[0]){
       case 0:
        return add(handler, run, execution_context);
       case 1:
        var
         execution_context$0 = handler[2],
         run$0 = handler[1],
         handler$1 =
           create2(run, execution_context, run$0, execution_context$0);
        t$0[1] = handler$1;
        return handler$1;
       case 2:
        var
         v = handler[1],
         handler$2 = create(run, execution_context),
         run$1 = function(v){return caml_call1(handler$2[1], v);},
         _w_ = caml_call1(Async_kernel_Scheduler1[71], 0);
        caml_call3
         (caml_call1(Async_kernel_Scheduler1[63], _w_),
          execution_context,
          run$1,
          v);
        return handler$2;
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
     }
    var handler$0 = create(run, execution_context);
    t$0[1] = handler$0;
    return handler$0;
   }
   function has_handlers(t){
    var t$0 = squash(t), _v_ = t$0[1];
    if(typeof _v_ !== "number")
     switch(_v_[0]){
       case 3:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
       case 2: break;
       default: return 1;
     }
    return 0;
   }
   function upon(t, run){
    var _u_ = caml_call1(Async_kernel_Scheduler1[71], 0);
    return add_handler(t, run, caml_call1(Async_kernel_Scheduler1[72], _u_));
   }
   function upon$0(t, run){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], scheduler),
     t$0 = squash(t),
     handler = t$0[1];
    if(typeof handler !== "number")
     switch(handler[0]){
       case 0:
        add(handler, run, execution_context); return 0;
       case 1:
        var
         execution_context$0 = handler[2],
         run$0 = handler[1],
         x = create2(run, execution_context, run$0, execution_context$0);
        t$0[1] = x;
        return 0;
       case 2:
        var v = handler[1];
        return caml_call4
                (Async_kernel_Scheduler1[63],
                 scheduler,
                 execution_context,
                 run,
                 v);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
     }
    t$0[1] = [1, run, execution_context];
    return 0;
   }
   function connect(bind_result, bind_rhs){
    var _s_ = 1 - caml_call2(Core[246], bind_result, bind_rhs);
    if(! _s_) return _s_;
    var bind_result$0 = squash(bind_result), indir = [3, bind_result$0];
    a:
    {
     b:
     c:
     {
      var ivar = bind_rhs;
      d:
      for(;;){
       var bind_rhs_contents = ivar[1];
       if(typeof bind_rhs_contents === "number") break c;
       switch(bind_rhs_contents[0]){
         case 2:
          break d;
         case 3:
          var ivar$0 = bind_rhs_contents[1];
          ivar[1] = indir;
          ivar = ivar$0;
          break;
         default: break b;
       }
      }
      break a;
     }
     if(1 - caml_call2(Core[246], ivar, bind_result$0)) ivar[1] = indir;
    }
    var t1 = bind_result$0[1];
    a:
    {
     b:
     {
      if(typeof t1 !== "number")
       switch(t1[0]){
         case 0:
          if(typeof bind_rhs_contents === "number") break a;
          switch(bind_rhs_contents[0]){
            case 0:
             var last1 = t1[3], last2 = bind_rhs_contents[3];
             set_next(last1, bind_rhs_contents);
             set_next(last2, t1);
             set_prev(t1, last2);
             return set_prev(bind_rhs_contents, last1);
            case 1:
             var
              execution_context2 = bind_rhs_contents[2],
              run2 = bind_rhs_contents[1];
             add(t1, run2, execution_context2);
             return 0;
            case 2:
             var v = bind_rhs_contents[1];
             bind_result$0[1] = bind_rhs_contents;
             return schedule_jobs(t1, v);
          }
          break;
         case 1:
          var execution_context = t1[2], run = t1[1];
          if(typeof bind_rhs_contents === "number") break a;
          switch(bind_rhs_contents[0]){
            case 0:
             var handler1 = add(bind_rhs_contents, run, execution_context);
             bind_result$0[1] = handler1;
             return 0;
            case 1:
             var
              execution_context2$0 = bind_rhs_contents[2],
              run2$0 = bind_rhs_contents[1],
              handler1$0 =
                create2(run, execution_context, run2$0, execution_context2$0);
             bind_result$0[1] = handler1$0;
             return 0;
            case 2:
             var v$0 = bind_rhs_contents[1];
             bind_result$0[1] = bind_rhs_contents;
             var _t_ = caml_call1(Async_kernel_Scheduler1[71], 0);
             return caml_call3
                     (caml_call1(Async_kernel_Scheduler1[63], _t_),
                      execution_context,
                      run,
                      v$0);
          }
          break;
         case 2: break;
         default: break b;
       }
      if(typeof bind_rhs_contents !== "number" && 3 === bind_rhs_contents[0])
       break b;
      if(typeof t1 === "number") break a;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _q_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
    }
    return typeof bind_rhs_contents === "number"
            ? 0
            : (bind_result$0[1] = bind_rhs_contents, 0);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Ivar0);
   var
    Async_kernel_Ivar0 =
      [0,
       sexp_of_t$0,
       invariant,
       create$0,
       create_full,
       create_with_cell,
       peek,
       value_exn,
       value,
       is_empty,
       is_full,
       equal,
       connect,
       fill,
       [0, sexp_of_t, length, of_list, to_list],
       cell_of_handler,
       add_handler,
       remove_handler,
       has_handlers,
       upon$0,
       upon,
       indir,
       squash];
   runtime.caml_register_global
    (36, Async_kernel_Ivar0, cst_Async_kernel_Ivar0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred0
//# unitInfo: Requires: Async_kernel__Ivar0, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred0 = "Async_kernel__Deferred0",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Ivar0 = global_data.Async_kernel__Ivar0,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred0.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    cst_Deferred_value_exn_called_ =
      "Deferred.value_exn called on undetermined deferred";
   function of_ivar(ivar){return ivar;}
   function invariant(invariant_a, t){
    return caml_call2(Async_kernel_Ivar0[2], invariant_a, t);
   }
   function sexp_of_t(sexp_of_a, t){
    return caml_call2(Async_kernel_Ivar0[1], sexp_of_a, t);
   }
   function peek(t){return caml_call1(Async_kernel_Ivar0[6], t);}
   function return$0(a){
    var ivar = caml_call1(Async_kernel_Ivar0[4], a);
    return ivar;
   }
   function is_determined(t){return caml_call1(Async_kernel_Ivar0[10], t);}
   function value_exn(t){
    return caml_call2
            (Async_kernel_Ivar0[8], t, cst_Deferred_value_exn_called_);
   }
   function upon(t, f){return caml_call2(Async_kernel_Ivar0[19], t, f);}
   function create(f){
    var result = caml_call1(Async_kernel_Ivar0[3], 0);
    caml_call1(f, result);
    return result;
   }
   function bind(t, f){
    var bind_result = caml_call1(Async_kernel_Ivar0[3], 0);
    upon
     (t,
      function(a){
       var t = caml_call1(f, a);
       return caml_call2(Async_kernel_Ivar0[12], bind_result, t);
      });
    return bind_result;
   }
   function add_handler(t, f, execution_context){
    return caml_call3(Async_kernel_Ivar0[16], t, f, execution_context);
   }
   function remove_handler(t, h){
    return caml_call2(Async_kernel_Ivar0[17], t, h);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred0);
   var
    Async_kernel_Deferred0 =
      [0,
       sexp_of_t,
       invariant,
       of_ivar,
       create,
       peek,
       value_exn,
       is_determined,
       return$0,
       upon,
       bind,
       [0, Async_kernel_Ivar0[14][1]],
       add_handler,
       remove_handler];
   runtime.caml_register_global
    (13, Async_kernel_Deferred0, cst_Async_kernel_Deferred0);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Ivar
//# unitInfo: Requires: Async_kernel__Deferred0, Async_kernel__Ivar0, Core__Binable, Core__Option, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Ivar = "Async_kernel__Ivar",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Ivar0 = global_data.Async_kernel__Ivar0,
    Async_kernel_Deferred0 = global_data.Async_kernel__Deferred0,
    Core_Option = global_data.Core__Option,
    Core_Binable = global_data.Core__Binable;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Ivar);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/ivar.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    sexp_of_t = Async_kernel_Ivar0[1],
    invariant = Async_kernel_Ivar0[2],
    create = Async_kernel_Ivar0[3],
    create_full = Async_kernel_Ivar0[4],
    peek = Async_kernel_Ivar0[6],
    value_exn = Async_kernel_Ivar0[7],
    is_empty = Async_kernel_Ivar0[9],
    is_full = Async_kernel_Ivar0[10],
    equal = Async_kernel_Ivar0[11],
    fill = Async_kernel_Ivar0[13],
    has_handlers = Async_kernel_Ivar0[18],
    read = Async_kernel_Deferred0[3];
   function fill_if_empty(t, v){
    var _a_ = caml_call1(is_empty, t);
    return _a_ ? caml_call2(fill, t, v) : _a_;
   }
   function to_binable(t){return caml_call1(peek, t);}
   function of_binable(param){
    if(! param) return caml_call1(create, 0);
    var a = param[1];
    return caml_call1(create_full, a);
   }
   var
    include =
      caml_call1
       (caml_call1
         (Core_Binable[7],
          [0,
           Core_Option[1],
           Core_Option[2],
           Core_Option[3],
           Core_Option[4],
           Core_Option[5]]),
        [0, to_binable, of_binable]),
    bin_shape_t = include[1],
    bin_size_t = include[2],
    bin_write_t = include[3],
    bin_read_t = include[4],
    bin_read_t$0 = include[5],
    bin_writer_t = include[6],
    bin_reader_t = include[7],
    bin_t = include[8];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Ivar);
   var
    Async_kernel_Ivar =
      [0,
       bin_shape_t,
       bin_size_t,
       bin_write_t,
       bin_read_t,
       bin_read_t$0,
       bin_writer_t,
       bin_reader_t,
       bin_t,
       sexp_of_t,
       invariant,
       equal,
       create,
       create_full,
       fill,
       fill_if_empty,
       is_empty,
       is_full,
       read,
       peek,
       value_exn,
       has_handlers];
   runtime.caml_register_global(15, Async_kernel_Ivar, cst_Async_kernel_Ivar);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Monad_sequence
//# unitInfo: Requires: Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Monad_sequenc = "Async_kernel__Monad_sequence",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Monad_sequenc);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/monad_sequence.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    _a_ = [0, "Parallel"],
    _b_ = [0, "Sequential"],
    _c_ = [0, "Max_concurrent_jobs"];
   function sexp_of_how(param){
    if(typeof param === "number") return -676829465 <= param ? _a_ : _b_;
    var v_001 = param[2];
    return [1, [0, _c_, [0, caml_call1(Core[356], v_001), 0]]];
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Monad_sequenc);
   var Async_kernel_Monad_sequence = [0, sexp_of_how];
   runtime.caml_register_global
    (15, Async_kernel_Monad_sequence, cst_Async_kernel_Monad_sequenc);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred1
//# unitInfo: Requires: Assert_failure, Async_kernel__Deferred0, Async_kernel__Ivar, Async_kernel__Monad_sequence, Async_kernel__Scheduler1, Base__Monad, Core, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred1 = "Async_kernel__Deferred1",
    cst_async_kernel = "async_kernel",
    cst_src_deferred1_ml = "src/deferred1.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Assert_failure = global_data.Assert_failure,
    Core_List = global_data.Core__List,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core = global_data.Core,
    Async_kernel_Deferred0 = global_data.Async_kernel__Deferred0,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Base_Monad = global_data.Base__Monad,
    Async_kernel_Monad_sequence = global_data.Async_kernel__Monad_sequence;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred1);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_deferred1_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    sexp_of_t = Async_kernel_Deferred0[1],
    invariant = Async_kernel_Deferred0[2],
    of_ivar = Async_kernel_Deferred0[3],
    create = Async_kernel_Deferred0[4],
    peek = Async_kernel_Deferred0[5],
    value_exn = Async_kernel_Deferred0[6],
    is_determined = Async_kernel_Deferred0[7],
    upon = Async_kernel_Deferred0[9],
    Handler = Async_kernel_Deferred0[11],
    add_handler = Async_kernel_Deferred0[12],
    remove_handler = Async_kernel_Deferred0[13];
   function never(param){
    var _u_ = caml_call1(Async_kernel_Ivar[12], 0);
    return caml_call1(Async_kernel_Ivar[18], _u_);
   }
   var
    of_ivar$0 = Async_kernel_Deferred0[3],
    return$0 = Async_kernel_Deferred0[8],
    upon$0 = Async_kernel_Deferred0[9],
    bind = Async_kernel_Deferred0[10],
    map =
      [0,
       -198771759,
       function(t, f){
        var result = caml_call1(Async_kernel_Ivar[12], 0);
        caml_call2
         (upon$0,
          t,
          function(a){
           var _t_ = caml_call1(f, a);
           return caml_call2(Async_kernel_Ivar[14], result, _t_);
          });
        return caml_call1(of_ivar$0, result);
       }],
    M = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = M[1],
    symbol_map = M[2],
    Monad_infix = M[3],
    bind$0 = M[4],
    map$0 = M[6],
    join = M[7],
    ignore_m = M[8],
    return$1 = Async_kernel_Deferred0[8],
    include = M[11],
    symbol_bind$0 = include[2],
    symbol_map$0 = include[3],
    return$2 = Async_kernel_Deferred0[8],
    include$0 = M[11][4],
    bind$1 = include$0[2],
    map$1 = include$0[3],
    both = include$0[4],
    Open_on_rhs = include$0[5],
    return$3 = Async_kernel_Deferred0[8],
    Let_syntax = [0, bind$1, map$1, both, Open_on_rhs, return$3],
    Let_syntax$0 = [0, symbol_bind$0, symbol_map$0, return$2, Let_syntax],
    unit = caml_call1(Let_syntax$0[3], 0);
   function both$0(t1, t2){
    return caml_call1
            (create,
             function(result){
              return caml_call2
                      (upon,
                       t1,
                       function(a1){
                        return caml_call2
                                (upon,
                                 t2,
                                 function(a2){
                                  return caml_call2
                                          (Async_kernel_Ivar[14], result, [0, a1, a2]);
                                 });
                       });
             });
   }
   var
    symbol_bind$1 = Monad_infix[1],
    symbol_map$1 = Monad_infix[2],
    Infix = [0, symbol_bind$1, symbol_map$1, upon, both$0];
   function don_t_wait_for(param){return 0;}
   function map$2(param, f2){
    var f1 = param[2], t = param[1];
    return [0, t, function(x){return caml_call1(f2, caml_call1(f1, x));}];
   }
   var Choice = [0, map$2];
   function process(param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var rest = param$0[3], handler = param$0[2], t = param$0[1];
     caml_call2(remove_handler, t, handler);
     param$0 = rest;
    }
   }
   var Unregister = [0, process], _a_ = [0, cst_src_deferred1_ml, 120, 10];
   function choice(t, f){return [0, t, f];}
   function enabled(choices){
    var result = caml_call1(Async_kernel_Ivar[12], 0), unregisters = [0, 0];
    function ready(param){
     var _r_ = caml_call1(Async_kernel_Ivar[16], result);
     return _r_
             ? (caml_call1
                (Unregister[1], unregisters[1]),
               caml_call2
                (Async_kernel_Ivar[14],
                 result,
                 function(param){
                  var
                   _s_ =
                     caml_call3
                      (Core_List[10],
                       choices,
                       0,
                       function(ac, param){
                        var f = param[2], t = param[1], match = caml_call1(peek, t);
                        if(! match) return ac;
                        var v = match[1];
                        return [0, caml_call1(f, v), ac];
                       });
                  return caml_call1(Core_List[34], _s_);
                 }))
             : _r_;
    }
    var
     _q_ = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], _q_);
    unregisters[1] =
     caml_call3
      (Core_List[10],
       choices,
       0,
       function(acc, param){
        var t = param[1];
        return [0,
                t,
                caml_call3
                 (Async_kernel_Deferred0[12], t, ready, execution_context),
                acc];
       });
    return caml_call1(Async_kernel_Ivar[18], result);
   }
   function choose_result(choices){
    var choices$0 = choices;
    for(;;){
     if(! choices$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var
      choices$1 = choices$0[2],
      match = choices$0[1],
      f = match[2],
      t = match[1],
      match$0 = caml_call1(peek, t);
     if(match$0){var v = match$0[1]; return caml_call1(f, v);}
     choices$0 = choices$1;
    }
   }
   function choose(choices){
    var result = caml_call1(Async_kernel_Ivar[12], 0), unregisters = [0, 0];
    function ready(param){
     var _o_ = caml_call1(Async_kernel_Ivar[16], result);
     if(! _o_) return _o_;
     caml_call1(Unregister[1], unregisters[1]);
     var _p_ = choose_result(choices);
     return caml_call2(Async_kernel_Ivar[14], result, _p_);
    }
    var
     _n_ = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], _n_);
    unregisters[1] =
     caml_call3
      (Core_List[10],
       choices,
       0,
       function(acc, param){
        var t = param[1];
        return [0,
                t,
                caml_call3
                 (Async_kernel_Deferred0[12], t, ready, execution_context),
                acc];
       });
    return caml_call1(Async_kernel_Ivar[18], result);
   }
   function any_f(ts, f){
    return choose
            (caml_call2(Core_List[72], ts, function(t){return [0, t, f];}));
   }
   function any(ts){return any_f(ts, function(_m_){return _m_;});}
   function any_unit(ts){return any_f(ts, function(_l_){return 0;});}
   function for$0(start, to, do$0){
    function loop(i){
     if(caml_call2(Core[91], i, to)) return caml_call1(Let_syntax$0[3], 0);
     var _k_ = caml_call1(do$0, i);
     return caml_call2
             (Let_syntax$0[4][1],
              _k_,
              function(param){return loop(i + 1 | 0);});
    }
    return loop(start);
   }
   function repeat_until_finished(state, f){
    return caml_call1
            (create,
             function(finished){
              function loop(state){
               var _j_ = caml_call1(f, state);
               return caml_call2
                       (Infix[3],
                        _j_,
                        function(param){
                         if(990972795 <= param[1]){
                          var state = param[2];
                          return loop(state);
                         }
                         var result = param[2];
                         return caml_call2(Async_kernel_Ivar[14], finished, result);
                        });
              }
              return loop(state);
             });
   }
   function forever(state, f){
    var
     _g_ = Core[159],
     _h_ =
       repeat_until_finished
        (state,
         function(state){
          var _i_ = caml_call1(f, state);
          return caml_call2
                  (Let_syntax$0[4][2],
                   _i_,
                   function(state){return [0, 990972795, state];});
         });
    return caml_call2(Infix[3], _h_, _g_);
   }
   var sexp_of_how = Async_kernel_Monad_sequence[1];
   function fold(t, init, f){
    return caml_call1
            (create,
             function(result){
              function loop(t, b){
               if(! t) return caml_call2(Async_kernel_Ivar[14], result, b);
               var xs = t[2], x = t[1], _f_ = caml_call2(f, b, x);
               return caml_call2
                       (Infix[3], _f_, function(b){return loop(xs, b);});
              }
              return loop(t, init);
             });
   }
   function seqmap(t, f){
    var
     _c_ = Core_List[34],
     _d_ =
       fold
        (t,
         0,
         function(bs, a){
          var _e_ = caml_call1(f, a);
          return caml_call2(Infix[2], _e_, function(b){return [0, b, bs];});
         });
    return caml_call2(Infix[2], _d_, _c_);
   }
   function all(ds){return seqmap(ds, function(_b_){return _b_;});}
   function all_unit(ds){return fold(ds, 0, function(param, d){return d;});}
   function ok(x){
    return caml_call2(Infix[2], x, function(x){return [0, x];});
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred1);
   var
    Async_kernel_Deferred1 =
      [0,
       sexp_of_t,
       invariant,
       of_ivar,
       create,
       peek,
       value_exn,
       is_determined,
       upon,
       Handler,
       add_handler,
       remove_handler,
       never,
       M,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       map$0,
       join,
       ignore_m,
       return$1,
       Let_syntax$0,
       unit,
       both$0,
       Infix,
       don_t_wait_for,
       Choice,
       Unregister,
       choice,
       enabled,
       choose_result,
       choose,
       any_f,
       any,
       any_unit,
       for$0,
       repeat_until_finished,
       forever,
       sexp_of_how,
       fold,
       seqmap,
       all,
       all_unit,
       ok];
   runtime.caml_register_global
    (20, Async_kernel_Deferred1, cst_Async_kernel_Deferred1);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_std
//# unitInfo: Requires: Async_kernel__Deferred1, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_std = "Async_kernel__Deferred_std",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_std);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_std.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    _a_ = Async_kernel_Deferred1[25],
    symbol = _a_[3],
    ppx_both = _a_[4],
    include = Async_kernel_Deferred1[22],
    symbol_bind = include[1],
    symbol_map = include[2],
    return$0 = include[3],
    Let_syntax = include[4],
    choice = Async_kernel_Deferred1[29],
    choose = Async_kernel_Deferred1[32],
    don_t_wait_for = Async_kernel_Deferred1[26],
    never = Async_kernel_Deferred1[12],
    upon = Async_kernel_Deferred1[8];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_std);
   var
    Async_kernel_Deferred_std =
      [0,
       symbol,
       ppx_both,
       symbol_bind,
       symbol_map,
       Let_syntax,
       choice,
       choose,
       don_t_wait_for,
       never,
       return$0,
       upon];
   runtime.caml_register_global
    (12, Async_kernel_Deferred_std, cst_Async_kernel_Deferred_std);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Ivar_filler
//# unitInfo: Requires: Assert_failure, Async_kernel__Ivar, Base__Invariant, Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Ivar_filler = "Async_kernel__Ivar_filler",
    cst_async_kernel = "async_kernel",
    cst_src_ivar_filler_ml = "src/ivar_filler.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Ivar_filler);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_ivar_filler_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    _a_ = [0, "Empty"],
    _b_ = [0, "Full"],
    _c_ = [0, cst_src_ivar_filler_ml, 15, 20],
    _d_ = [0, "_"],
    _e_ = [0, cst_src_ivar_filler_ml, 12, 154, 176],
    cst_attempt_to_fill_full_ivar = "attempt to fill full ivar";
   function sexp_of_t(of_a_005, x_006){
    return caml_call2
            (Core[501],
             function(param){
              if(! param) return _b_;
              var
               arg0_002 = param[1],
               res0_003 = caml_call2(Async_kernel_Ivar[9], of_a_005, arg0_002);
              return [1, [0, _a_, [0, res0_003, 0]]];
             },
             x_006);
   }
   function invariant(param, t){
    return caml_call4
            (Base_Invariant[1],
             _e_,
             t,
             function(x_007){
              return sexp_of_t(function(param){return _d_;}, x_007);
             },
             function(param){
              var match = t[1];
              if(! match) return 0;
              var ivar = match[1];
              if(caml_call1(Async_kernel_Ivar[16], ivar)) return 0;
              throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
             });
   }
   function create(param){
    var ivar = caml_call1(Async_kernel_Ivar[12], 0), t = [0, [0, ivar]];
    return [0, t, caml_call1(Async_kernel_Ivar[18], ivar)];
   }
   function is_empty(t){return t[1] ? 1 : 0;}
   function fill(t, a){
    var match = t[1];
    if(match){
     var i = match[1];
     t[1] = 0;
     return caml_call2(Async_kernel_Ivar[14], i, a);
    }
    var
     _f_ = caml_call1(Sexplib0_Sexp_conv[7], cst_attempt_to_fill_full_ivar);
    return caml_call1(Core[253], _f_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Ivar_filler);
   var
    Async_kernel_Ivar_filler =
      [0, sexp_of_t, invariant, create, is_empty, fill];
   runtime.caml_register_global
    (22, Async_kernel_Ivar_filler, cst_Async_kernel_Ivar_filler);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Tail
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Ivar, Base__Field, Core, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Tail = "Async_kernel__Tail",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core;
   global_data.Base__Field;
   var
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_List = global_data.Core__List,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Tail);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/tail.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, "..."];
   function sexp_of_t(sexp_of_a, t){
    var d = t, ac = 0;
    for(;;){
     var match = caml_call1(Async_kernel_Deferred1[5], d);
     if(! match) return [1, caml_call1(Core_List[34], [0, _a_, ac])];
     var match$0 = match[1];
     if(! match$0) return [1, caml_call1(Core_List[34], ac)];
     var
      t$0 = match$0[2],
      a = match$0[1],
      ac$0 = [0, caml_call1(sexp_of_a, a), ac];
     d = t$0;
     ac = ac$0;
    }
   }
   function next(t){return t;}
   var
    Stream = [0, sexp_of_t, next],
    cst_open_tail = "<open tail>",
    cst_closed_tail = "<closed tail>",
    cst_stream_is_closed = "stream is closed";
   function sexp_of_t$0(param, t){
    var
     _d_ =
       caml_call1(Async_kernel_Ivar[16], t[1])
        ? cst_open_tail
        : cst_closed_tail;
    return [0, _d_];
   }
   function create(param){return [0, caml_call1(Async_kernel_Ivar[12], 0)];}
   function collect(t){return caml_call1(Async_kernel_Ivar[18], t[1]);}
   function is_closed(t){return caml_call1(Async_kernel_Ivar[17], t[1]);}
   function fill_exn(t, v){
    if(! is_closed(t)) return caml_call2(Async_kernel_Ivar[14], t[1], v);
    var _c_ = caml_call1(Sexplib0_Sexp_conv[7], cst_stream_is_closed);
    return caml_call1(Core[253], _c_);
   }
   function close_exn(t){return fill_exn(t, 0);}
   function close_if_open(t){
    var _b_ = 1 - is_closed(t);
    return _b_ ? caml_call2(Async_kernel_Ivar[14], t[1], 0) : _b_;
   }
   function extend(t, v){
    var next = caml_call1(Async_kernel_Ivar[12], 0);
    fill_exn(t, [0, v, caml_call1(Async_kernel_Ivar[18], next)]);
    t[1] = next;
    return 0;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Tail);
   var
    Async_kernel_Tail =
      [0,
       sexp_of_t$0,
       create,
       extend,
       close_exn,
       close_if_open,
       is_closed,
       Stream,
       collect];
   runtime.caml_register_global(23, Async_kernel_Tail, cst_Async_kernel_Tail);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Monitor
//# unitInfo: Requires: Assert_failure, Async_kernel__Debug, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Execution_context, Async_kernel__Ivar, Async_kernel__Ivar_filler, Async_kernel__Monitor0, Async_kernel__Scheduler1, Async_kernel__Tail, Async_kernel_config, Base__Backtrace, Base__Exn, Base__Field, Base__Invariant, Core, Core__Bag, Core__Error, Core__Info, Core__List, Core__Or_error, Core__Result, Core__String, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Sexplib__Conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Async_kernel_Monitor = "Async_kernel__Monitor",
    cst_Caught_by_monitor = "Caught by monitor ",
    cst_async_kernel = "async_kernel",
    cst_exn = "exn",
    cst_file = "file ",
    cst_src_monitor_ml = "src/monitor.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    job_queue = 'Called from file "job_queue.ml"',
    deferred0 = 'Called from file "deferred0.ml"',
    deferred1 = 'Called from file "deferred1.ml"',
    monitor = 'Called from file "monitor.ml"',
    import0 = 'Raised at file "import0.ml"',
    error = 'Called from file "error.ml"',
    Core_Error = global_data.Core__Error,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Core_Or_error = global_data.Core__Or_error,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Ivar_filler = global_data.Async_kernel__Ivar_filler,
    Base_Exn = global_data.Base__Exn;
   global_data.Base__Field;
   var
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Core_Result = global_data.Core__Result,
    Async_kernel_config = global_data.Async_kernel_config,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Core_Bag = global_data.Core__Bag,
    Core_List = global_data.Core__List,
    Base_Backtrace = global_data.Base__Backtrace,
    Core_Info = global_data.Core__Info,
    Core_String = global_data.Core__String,
    Base_Invariant = global_data.Base__Invariant,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Monitor0 = global_data.Async_kernel__Monitor0,
    Sexplib_Conv = global_data.Sexplib__Conv;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Monitor);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_monitor_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    has_seen_error = Async_kernel_Monitor0[4],
    name = Async_kernel_Monitor0[14],
    Fields = Async_kernel_Monitor0[15],
    sexp_of_t = Async_kernel_Monitor0[18],
    create_with_parent = Async_kernel_Monitor0[20],
    main = Async_kernel_Monitor0[21],
    _a_ = [0, cst_src_monitor_ml, 20, 44],
    _b_ = [0, cst_src_monitor_ml, 13, 226, 248],
    _c_ = [0, cst_src_monitor_ml, 46, 23];
   function invariant(t){
    return caml_call4
            (Base_Invariant[1],
             _b_,
             t,
             sexp_of_t,
             function(param){
              function f(next_error){
               if(caml_call1(Async_kernel_Ivar[16], next_error)) return 0;
               throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
              }
              var _ae_ = caml_call2(Base_Invariant[2], t, f);
              return caml_call8
                      (Fields[13],
                       function(_al_){return 0;},
                       function(_ak_){return 0;},
                       function(_aj_){return 0;},
                       _ae_,
                       function(_ai_){return 0;},
                       function(_ah_){return 0;},
                       function(_ag_){return 0;},
                       function(_af_){return 0;});
             });
   }
   function current_execution_context(param){
    var _ad_ = caml_call1(Async_kernel_Scheduler1[71], 0);
    return caml_call1(Async_kernel_Scheduler1[72], _ad_);
   }
   function current(param){
    var _ac_ = current_execution_context(0);
    return caml_call1(Async_kernel_Execution_context[4], _ac_);
   }
   function detach(t){t[8] = 0; return 0;}
   function detach_and_iter_errors(t, f){
    detach(t);
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], scheduler),
     handler_state_ref = [0, 0];
    function run_f(exn){
     var match = handler_state_ref[1];
     if(typeof match === "number"){
      if(match) return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     }
     var bag_elt = match[1];
     try{var _ab_ = caml_call1(f, exn); return _ab_;}
     catch(inner_exn$0){
      var inner_exn = caml_wrap_exception(inner_exn$0);
      handler_state_ref[1] = 1;
      caml_call2(Core_Bag[26], t[5], bag_elt);
      throw caml_maybe_attach_backtrace(inner_exn, 0);
     }
    }
    handler_state_ref[1] =
     [0, caml_call2(Core_Bag[23], t[5], [0, execution_context, run_f])];
    return 0;
   }
   function detach_and_get_error_stream(t){
    detach(t);
    var tail = caml_call1(Async_kernel_Tail[2], 0);
    t[6] = [0, tail, t[6]];
    return caml_call1(Async_kernel_Tail[8], tail);
   }
   function get_next_error(t){return caml_call1(Async_kernel_Ivar[18], t[4]);}
   function detach_and_get_next_error(t){detach(t); return get_next_error(t);}
   function create(here, info, name, param){
    var parent = current(0);
    return caml_call4(create_with_parent, here, info, name, [0, parent]);
   }
   function backtrace(t){return t[2];}
   function extract_exn(t){return t[1];}
   var
    Monitor_exn =
      [248, "Async_kernel__Monitor.Monitor_exn", runtime.caml_fresh_oo_id(0)],
    _d_ =
      [0,
       [11, cst_file, [3, 0, [11, ", line LINE, characters C1-C2", 0]]],
       "file %S, line LINE, characters C1-C2"],
    _e_ =
      [0,
       [11, cst_Caught_by_monitor, [2, 0, [11, " at ", [2, 0, 0]]]],
       "Caught by monitor %s at %s"],
    _f_ = [0, "backtrace_history"],
    _g_ =
      [0, [11, "Caught by monitor at ", [2, 0, 0]], "Caught by monitor at %s"],
    _h_ = [0, [11, cst_Caught_by_monitor, [2, 0, 0]], "Caught by monitor %s"],
    _i_ =
      [0,
       [11,
        cst_file,
        [3,
         0,
         [11,
          ", line ",
          [4,
           0,
           0,
           0,
           [11, ", characters ", [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]]]]]]],
       "file %S, line %d, characters %d-%d"],
    cst_monitor_ml_Error = "monitor.ml.Error",
    _j_ = [0, cst_src_monitor_ml, 199, 6];
   caml_call4
    (Sexplib_Conv[70][1],
     0,
     0,
     Monitor_exn,
     function(param){
      if(param[1] !== Monitor_exn)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
      var
       t = param[2],
       monitor$0 = t[4],
       backtrace_history = t[3],
       backtrace = t[2],
       exn = t[1],
       s = caml_call1(Core_Info[9], monitor$0[1]),
       name = s !== cst$1 ? [0, s] : 0,
       match$0 = monitor$0[2];
      if(match$0)
       var
        here = match$0[1],
        column = here[4] - here[3] | 0,
        _X_ =
          Core[541]
           ? caml_call2(Core[257], _d_, here[1])
           : caml_call5(Core[257], _i_, here[1], here[2], column, column),
        pos = [0, _X_];
      else
       var pos = 0;
      if(pos){
       var pos$0 = pos[1];
       if(name)
        var
         name$0 = name[1],
         _Y_ = [0, caml_call3(Core[257], _e_, name$0, pos$0), 0];
       else
        var _Y_ = [0, caml_call2(Core[257], _g_, pos$0), 0];
       var monitor$1 = _Y_;
      }
      else if(name)
       var
        name$1 = name[1],
        monitor$1 = [0, caml_call2(Core[257], _h_, name$1), 0];
      else
       var monitor$1 = 0;
      if(backtrace)
       var
        backtrace$0 = backtrace[1],
        backtrace$1 = caml_call1(Base_Backtrace[4], backtrace$0);
      else
       var backtrace$1 = 0;
      a:
      {
       if(backtrace$1){
        var rest = backtrace$1[2], t1 = backtrace$1[1];
        if(caml_call2(Core_String[57], t1, import0)){
         b:
         {
          if(rest){
           var rest$0 = rest[2], t2 = rest[1];
           if(caml_call2(Core_String[57], t2, error)){
            c:
            {
             if(rest$0){
              var rest$1 = rest$0[2], t3 = rest$0[1];
              if(caml_call2(Core_String[57], t3, error)){var rest$2 = rest$1; break c;}
             }
             var rest$2 = rest$0;
            }
            var rest$3 = rest$2;
            break b;
           }
          }
          var rest$3 = rest;
         }
         var traces = rest$3;
         break a;
        }
       }
       var traces = backtrace$1;
      }
      var match = caml_call1(Core_List[34], traces);
      a:
      {
       if(match){
        var rest$4 = match[2], t1$0 = match[1];
        if(caml_call2(Core_String[57], t1$0, job_queue)){
         if(rest$4){
          var rest$5 = rest$4[2], t2$0 = rest$4[1];
          if(caml_call2(Core_String[57], t2$0, job_queue)){
           b:
           if(rest$5){
            var rest$6 = rest$5[2], t2$1 = rest$5[1];
            if
             (!
              caml_call2(Core_String[57], t2$1, deferred0)
              &&
               !
               caml_call2(Core_String[57], t2$1, deferred1)
               && ! caml_call2(Core_String[57], t2$1, monitor))
             break b;
            var _Z_ = caml_call1(Core_List[34], rest$6);
            break a;
           }
           var _Z_ = caml_call1(Core_List[34], rest$5);
           break a;
          }
         }
         var _Z_ = caml_call1(Core_List[34], rest$4);
         break a;
        }
       }
       var _Z_ = traces;
      }
      var backtrace$2 = caml_call2(Core[157], _Z_, monitor$1);
      function list_if_not_empty(l){return l ? [0, l] : 0;}
      var
       match$1 = list_if_not_empty(backtrace$2),
       ___ = list_if_not_empty(backtrace_history),
       match$2 = 0;
      if(___)
       var
        x_002 = ___[1],
        match$3 =
          [0,
           [1,
            [0, _f_, [0, caml_call2(Core[421], Base_Backtrace[1], x_002), 0]]],
           match$2];
      else
       var match$3 = match$2;
      if(match$1)
       var
        x_001 = match$1[1],
        _$_ = [0, caml_call2(Core[421], Core[471], x_001), match$3];
      else
       var _$_ = match$3;
      var sexp = [1, [0, caml_call1(Core[537], exn), _$_]];
      if(0 === sexp[0])
       var _aa_ = [0, sexp, 0];
      else
       var l = sexp[1], _aa_ = l;
      return [1,
              [0,
               caml_call1(Sexplib0_Sexp_conv[7], cst_monitor_ml_Error),
               _aa_]];
     });
   var
    cst_Monitor_send_exn = "Monitor.send_exn",
    cst_Monitor_send_exn_found_lis =
      "Monitor.send_exn found listening monitor",
    _k_ = [0, 3553398],
    _l_ = [1, 0],
    _m_ = [0, cst_exn],
    cst_failed_to_set_Monitor_Expe =
      "failed to set [Monitor.Expert.try_with_log_exn]";
   function extract_exn$0(exn){
    if(exn[1] !== Monitor_exn) return exn;
    var error = exn[2];
    return error[1];
   }
   function send_exn(t, opt, exn){
    if(opt) var sth = opt[1], backtrace = sth; else var backtrace = 3553398;
    if(exn[1] === Monitor_exn)
     var exn$0 = exn;
    else{
     if(typeof backtrace === "number")
      var backtrace$0 = caml_call1(Base_Backtrace[6][5], exn);
     else
      var b = backtrace[2], backtrace$0 = [0, b];
     var
      backtrace_history = current_execution_context(0)[4],
      exn$0 = [0, Monitor_exn, [0, exn, backtrace$0, backtrace_history, t]];
    }
    if(Async_kernel_Debug[7])
     caml_call3
      (Async_kernel_Debug[15],
       cst_Monitor_send_exn,
       [0, t, exn$0],
       function(param){
        var
         arg1_004 = param[2],
         arg0_003 = param[1],
         res0_005 = caml_call1(sexp_of_t, arg0_003),
         res1_006 = caml_call1(Core[537], arg1_004);
        return [1, [0, res0_005, [0, res1_006, 0]]];
       });
    t[7] = 1;
    var scheduler = caml_call1(Async_kernel_Scheduler1[71], 0), t$0 = t;
    for(;;){
     caml_call2(Async_kernel_Ivar[14], t$0[4], exn$0);
     t$0[4] = caml_call1(Async_kernel_Ivar[12], 0);
     var match = t$0[8];
     if(typeof match === "number") break;
     var parent = match[1];
     t$0 = parent;
    }
    if(match){
     var
      _V_ = caml_call1(Async_kernel_config[31][1], 0),
      _W_ = caml_call1(Async_kernel_Scheduler1[71], 0);
     return caml_call2
             (caml_call1(Async_kernel_Scheduler1[76], _W_), exn$0, _V_);
    }
    if(Async_kernel_Debug[7])
     caml_call3
      (Async_kernel_Debug[15],
       cst_Monitor_send_exn_found_lis,
       [0, t$0, exn$0],
       function(param){
        var
         arg1_008 = param[2],
         arg0_007 = param[1],
         res0_009 = caml_call1(sexp_of_t, arg0_007),
         res1_010 = caml_call1(Core[537], arg1_008);
        return [1, [0, res0_009, [0, res1_010, 0]]];
       });
    caml_call2
     (Core_Bag[7],
      t$0[5],
      function(param){
       var f = param[2], execution_context = param[1];
       return caml_call4
               (Async_kernel_Scheduler1[63],
                scheduler,
                execution_context,
                f,
                exn$0);
      });
    return caml_call2
            (Core_List[9],
             t$0[6],
             function(tail){
              return caml_call2(Async_kernel_Tail[3], tail, exn$0);
             });
   }
   function within_context(context, f){
    var _U_ = caml_call1(Async_kernel_Scheduler1[71], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler1[74], _U_),
             context,
             function(param){
              var match = caml_call1(Core_Result[47], f);
              if(0 === match[0]){var x = match[1]; return [0, x];}
              var exn = match[1];
              send_exn
               (caml_call1(Async_kernel_Execution_context[4], context),
                _k_,
                exn);
              return _l_;
             });
   }
   function within_gen(monitor, priority, f){
    var
     _T_ = current_execution_context(0),
     tmp_context =
       caml_call4
        (Async_kernel_Execution_context[9], monitor, priority, 0, _T_);
    return within_context(tmp_context, f);
   }
   function within(monitor, priority, f){
    var match = within_gen(monitor, priority, f);
    if(0 !== match[0]) return caml_call1(Async_kernel_Deferred1[12], 0);
    var d = match[1];
    return d;
   }
   function within_v(monitor, priority, f){
    var match = within_gen(monitor, priority, f);
    if(0 !== match[0]) return 0;
    var x = match[1];
    return [0, x];
   }
   function within$0(monitor, priority, f){
    return 0 === within_gen(monitor, priority, f)[0] ? 0 : 0;
   }
   function schedule_with_data(monitor, priority, work, x){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[71], 0),
     _R_ = caml_call1(Async_kernel_Scheduler1[72], scheduler),
     _S_ =
       caml_call4
        (Async_kernel_Execution_context[9], monitor, priority, 0, _R_);
    return caml_call4(Async_kernel_Scheduler1[63], scheduler, _S_, work, x);
   }
   function schedule(monitor, priority, work){
    return schedule_with_data(monitor, priority, work, 0);
   }
   function upon_work_fill_i(param){
    var i = param[2], work = param[1], _Q_ = caml_call1(work, 0);
    return caml_call2
            (Async_kernel_Deferred_std[11],
             _Q_,
             function(a){return caml_call2(Async_kernel_Ivar[14], i, a);});
   }
   function schedule$0(monitor, priority, work){
    var i = caml_call1(Async_kernel_Ivar[12], 0);
    schedule_with_data(monitor, priority, upon_work_fill_i, [0, work, i]);
    return caml_call1(Async_kernel_Ivar[18], i);
   }
   function preserve_execution_context(f){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], scheduler);
    return caml_call1
            (Core[258],
             function(a){
              return caml_call4
                      (Async_kernel_Scheduler1[63],
                       scheduler,
                       execution_context,
                       f,
                       a);
             });
   }
   function preserve_execution_context$0(f){
    var
     scheduler = caml_call1(Async_kernel_Scheduler1[71], 0),
     execution_context = caml_call1(Async_kernel_Scheduler1[72], scheduler);
    function call_and_fill(param){
     var i = param[3], a = param[2], f = param[1], _P_ = caml_call1(f, a);
     return caml_call2
             (Async_kernel_Deferred_std[11],
              _P_,
              function(r){return caml_call2(Async_kernel_Ivar[14], i, r);});
    }
    return caml_call1
            (Core[258],
             function(a){
              return caml_call1
                      (Async_kernel_Deferred1[4],
                       function(i){
                        return caml_call4
                                (Async_kernel_Scheduler1[63],
                                 scheduler,
                                 execution_context,
                                 call_and_fill,
                                 [0, f, a, i]);
                       });
             });
   }
   function stream_iter(stream, f){
    function loop(stream){
     var _O_ = caml_call1(Async_kernel_Tail[7][2], stream);
     return caml_call2
             (Async_kernel_Deferred_std[1],
              _O_,
              function(param){
               if(! param) return 0;
               var stream = param[2], v = param[1];
               loop(stream);
               return caml_call1(f, v);
              });
    }
    return loop(stream);
   }
   function create$0(here, info, name, run, f){
    var
     monitor = caml_call4(create_with_parent, here, info, name, 0),
     exns = detach_and_get_error_stream(monitor),
     ok =
       523273847 <= run
        ? schedule$0([0, monitor], 0, f)
        : within([0, monitor], 0, f);
    return [0, ok, exns];
   }
   function fill_result_and_handle_backgro
   (result_filler, result, exns, handle_exns_after_result){
    var _N_ = caml_call1(Async_kernel_Ivar_filler[4], result_filler);
    return _N_
            ? (caml_call2
               (Async_kernel_Ivar_filler[5], result_filler, result),
              caml_call1(handle_exns_after_result, exns))
            : _N_;
   }
   var
    try_with_log_exn =
      [0,
       function(exn){
        var
         _L_ = [0, [1, [0, _m_, [0, caml_call1(Base_Exn[1], exn), 0]]], 0],
         _M_ =
           [1,
            [0,
             caml_call1(Sexplib0_Sexp_conv[7], cst_failed_to_set_Monitor_Expe),
             _L_]];
        return caml_call1(Core[253], _M_);
       }],
    Expert = [0, try_with_log_exn],
    _n_ = [0, cst_src_monitor_ml, 422, 17],
    _o_ = [0, 3903734],
    cst_try_with_or_error = "try_with_or_error",
    cst_try_with_join_or_error = "try_with_join_or_error",
    _p_ = [0, "finally_exn"],
    _q_ = [0, cst_exn],
    cst_Async_finally = "Async finally",
    _r_ = [0, 523273847],
    _s_ = [0, 0],
    _t_ = [0, "finally"],
    cst_Monitor_protect = "Monitor.protect",
    cst_Monitor_catch_got_unexpect =
      "Monitor.catch got unexpected empty stream";
   function try_with(here, info, opt, _I_, _H_, _G_, f$0){
    if(opt) var sth = opt[1], name = sth; else var name = cst$0;
    if(_I_)
     var sth$0 = _I_[1], do_extract_exn = sth$0;
    else
     var do_extract_exn = 0;
    if(_H_) var sth$1 = _H_[1], run = sth$1; else var run = 3903734;
    if(_G_) var sth$2 = _G_[1], rest = sth$2; else var rest = -146189108;
    var
     match = create$0(here, info, [0, name], run, f$0),
     exns = match[2],
     ok = match[1];
    if(typeof rest === "number")
     if(3804260 <= rest)
      var handle_exn = Expert[1][1];
     else
      var
       parent = current(0),
       handle_exn = function(exn){return send_exn(parent, 0, exn);};
    else
     var
      f = rest[2],
      parent$0 = current(0),
      handle_exn =
        function(exn){
         return within$0
                 ([0, parent$0],
                  0,
                  function(param){return caml_call1(f, exn);});
        };
    function handle_exns_after_result(exns){return stream_iter(exns, handle_exn);
    }
    return within
            ([0, main],
             0,
             function(param){
              if(caml_call1(Async_kernel_Deferred1[7], ok)){
               stream_iter(exns, handle_exn);
               var _J_ = [0, caml_call1(Async_kernel_Deferred1[6], ok)];
               return caml_call1(Async_kernel_Deferred_std[10], _J_);
              }
              var
               match = caml_call1(Async_kernel_Ivar_filler[3], 0),
               result = match[2],
               result_filler = match[1];
              caml_call2
               (Async_kernel_Deferred_std[11],
                ok,
                function(res){
                 return fill_result_and_handle_backgro
                         (result_filler, [0, res], exns, handle_exns_after_result);
                });
              var _K_ = caml_call1(Async_kernel_Tail[7][2], exns);
              caml_call2
               (Async_kernel_Deferred_std[11],
                _K_,
                function(param){
                 if(! param)
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _n_], 1);
                 var
                  exns = param[2],
                  exn = param[1],
                  exn$0 = do_extract_exn ? extract_exn$0(exn) : exn;
                 return fill_result_and_handle_backgro
                         (result_filler, [1, exn$0], exns, handle_exns_after_result);
                });
              return result;
             });
   }
   function try_with_or_error(here, info, opt, extract_exn, rest, f){
    if(opt)
     var sth = opt[1], name = sth;
    else
     var name = cst_try_with_or_error;
    var
     arg = Core_Or_error[38],
     _F_ = try_with(here, info, [0, name], extract_exn, _o_, rest, f);
    return caml_call2
            (Async_kernel_Deferred_std[4],
             _F_,
             function(eta){return caml_call2(arg, 0, eta);});
   }
   function try_with_join_or_error(here, info, opt, extract_exn, rest, f){
    if(opt)
     var sth = opt[1], name = sth;
    else
     var name = cst_try_with_join_or_error;
    var
     _D_ = Core_Or_error[27],
     _E_ = try_with_or_error(here, info, [0, name], extract_exn, rest, f);
    return caml_call2(Async_kernel_Deferred_std[4], _E_, _D_);
   }
   function protect(here, info, opt, extract_exn, run, rest, f, finally$0){
    if(opt) var sth = opt[1], name = sth; else var name = cst_Monitor_protect;
    var _y_ = try_with(here, info, [0, name], extract_exn, run, rest, f);
    return caml_call2
            (Async_kernel_Deferred_std[5][1],
             _y_,
             function(r){
              var _z_ = try_with(here, info, _t_, _s_, _r_, rest, finally$0);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _z_,
                       function(fr){
                        if(0 === r[0]){
                         var r$0 = r[1];
                         if(0 === fr[0]) return r$0;
                         var e = fr[1];
                        }
                        else{
                         var exn = r[1];
                         if(0 !== fr[0]){
                          var
                           finally_exn = fr[1],
                           _A_ =
                             [0,
                              [1, [0, _p_, [0, caml_call1(Core[537], finally_exn), 0]]],
                              0],
                           _B_ =
                             [0, [1, [0, _q_, [0, caml_call1(Core[537], exn), 0]]], _A_],
                           _C_ =
                             [1,
                              [0,
                               caml_call1(Sexplib0_Sexp_conv[7], cst_Async_finally),
                               _B_]];
                          return caml_call1(Core[253], _C_);
                         }
                         var e = exn;
                        }
                        throw caml_maybe_attach_backtrace(e, 0);
                       });
             });
   }
   function handle_errors(here, info, name, f, handler){
    var
     match = create$0(here, info, name, 3903734, f),
     exns = match[2],
     ok = match[1];
    stream_iter(exns, handler);
    return ok;
   }
   function catch_stream(here, info, name, f){
    var
     exns =
       create$0
         (here,
          info,
          name,
          3903734,
          function(param){
           caml_call1(f, 0);
           return caml_call1(Async_kernel_Deferred_std[10], 0);
          })
        [2];
    return exns;
   }
   function catch$0(here, info, name, f){
    var
     _v_ = catch_stream(here, info, name, f),
     _w_ = caml_call1(Async_kernel_Tail[7][2], _v_);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _w_,
             function(param){
              if(param){var x = param[1]; return x;}
              var
               _x_ =
                 caml_call1
                  (Sexplib0_Sexp_conv[7], cst_Monitor_catch_got_unexpect);
              return caml_call1(Core[253], _x_);
             });
   }
   function catch_error(here, info, name, f){
    var arg = Core_Error[25], _u_ = catch$0(here, info, name, f);
    return caml_call2
            (Async_kernel_Deferred_std[4],
             _u_,
             function(eta){return caml_call2(arg, 0, eta);});
   }
   function parent(t){
    var match = t[8];
    if(typeof match === "number") return match ? 0 : 0;
    var parent = match[1];
    return [0, parent];
   }
   function depth(t){
    var t$0 = t, n = 0;
    for(;;){
     var match = parent(t$0);
     if(! match) return n;
     var t$1 = match[1], n$0 = n + 1 | 0;
     t$0 = t$1;
     n = n$0;
    }
   }
   var For_tests = [0, parent, depth];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Monitor);
   var
    Async_kernel_Monitor =
      [0,
       sexp_of_t,
       invariant,
       create,
       name,
       current,
       detach,
       detach_and_iter_errors,
       detach_and_get_next_error,
       detach_and_get_error_stream,
       get_next_error,
       [0, extract_exn, backtrace],
       Monitor_exn,
       extract_exn$0,
       has_seen_error,
       send_exn,
       try_with,
       try_with_or_error,
       try_with_join_or_error,
       handle_errors,
       catch_stream,
       catch$0,
       catch_error,
       protect,
       main,
       Expert,
       [0,
        within,
        within$0,
        within_v,
        schedule$0,
        schedule,
        within_context,
        preserve_execution_context,
        preserve_execution_context$0],
       For_tests];
   runtime.caml_register_global
    (79, Async_kernel_Monitor, cst_Async_kernel_Monitor);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_stream
//# unitInfo: Requires: Assert_failure, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Tail, Core, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_stream = "Async_kernel__Async_stream",
    cst_async_kernel = "async_kernel",
    cst_src_async_stream_ml = "src/async_stream.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Core = global_data.Core,
    Core_List = global_data.Core__List,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_stream);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_async_stream_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    include = Async_kernel_Tail[7],
    sexp_of_t = include[1],
    next = include[2],
    cst_Stream_first_of_empty_stre = "Stream.first of empty stream",
    _a_ = [0, cst_src_async_stream_ml, 179, 18],
    _b_ = [0, -146189108],
    _c_ = [0, 523273847];
   function first_exn(t){
    var _X_ = caml_call1(next, t);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _X_,
             function(param){
              if(param){var x = param[1]; return x;}
              var
               _Y_ =
                 caml_call1
                  (Sexplib0_Sexp_conv[7], cst_Stream_first_of_empty_stre);
              return caml_call1(Core[253], _Y_);
             });
   }
   function fold(t, init, f){
    return caml_call1
            (Async_kernel_Deferred1[4],
             function(result){
              function loop(t, b){
               var _U_ = caml_call1(next, t);
               return caml_call2
                       (Async_kernel_Deferred_std[11],
                        _U_,
                        function(param){
                         if(! param)
                          return caml_call2(Async_kernel_Ivar[14], result, b);
                         var t = param[2], v = param[1], _V_ = caml_call2(f, b, v);
                         return caml_call2
                                 (Async_kernel_Deferred_std[11],
                                  _V_,
                                  function(_W_){return loop(t, _W_);});
                        });
              }
              return loop(t, init);
             });
   }
   function fold$0(t, init, f){
    return caml_call1
            (Async_kernel_Deferred1[4],
             function(result){
              function loop$0(counter, t, b){
               var
                _S_ = caml_call1(next, t),
                match = caml_call1(Async_kernel_Deferred1[5], _S_);
               if(! match){
                var _T_ = caml_call1(next, t);
                return caml_call2
                        (Async_kernel_Deferred_std[11],
                         _T_,
                         function(next){return loop_next(next, b);});
               }
               var next$0 = match[1];
               if(counter >= 50)
                return caml_trampoline_return(loop_next$0, [0, next$0, b]);
               var counter$0 = counter + 1 | 0;
               return loop_next$0(counter$0, next$0, b);
              }
              function loop(t, b){return caml_trampoline(loop$0(0, t, b));}
              function loop_next$0(counter, next, b){
               if(! next) return caml_call2(Async_kernel_Ivar[14], result, b);
               var t = next[2], v = next[1], _R_ = caml_call2(f, b, v);
               if(counter >= 50)
                return caml_trampoline_return(loop$0, [0, t, _R_]);
               var counter$0 = counter + 1 | 0;
               return loop$0(counter$0, t, _R_);
              }
              function loop_next(next, b){
               return caml_trampoline(loop_next$0(0, next, b));
              }
              return loop(t, init);
             });
   }
   function length(t){
    return fold$0(t, 0, function(n, param){return n + 1 | 0;});
   }
   function iter(t, f){
    return fold(t, 0, function(param, v){return caml_call1(f, v);});
   }
   function closed(t){
    var
     _Q_ = caml_call1(next, t),
     match = caml_call1(Async_kernel_Deferred1[5], _Q_);
    if(match && ! match[1])
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    return iter
            (t,
             function(param){
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function iter$0(t, f){
    var
     _P_ =
       iter
        (t,
         function(a){
          caml_call1(f, a);
          return caml_call1(Async_kernel_Deferred_std[10], 0);
         });
    return caml_call1(Async_kernel_Deferred_std[8], _P_);
   }
   function create(f){
    var
     tail = caml_call1(Async_kernel_Tail[2], 0),
     t = caml_call1(Async_kernel_Tail[8], tail);
    caml_call1(f, tail);
    return t;
   }
   function unfold(b, f){
    return create
            (function(tail){
              function loop(b){
               var _O_ = caml_call1(f, b);
               return caml_call2
                       (Async_kernel_Deferred_std[11],
                        _O_,
                        function(param){
                         if(! param) return caml_call1(Async_kernel_Tail[4], tail);
                         var match = param[1], b = match[2], a = match[1];
                         caml_call2(Async_kernel_Tail[3], tail, a);
                         return loop(b);
                        });
              }
              return loop(b);
             });
   }
   function of_list(l){
    return create
            (function(tail){
              caml_call2
               (Core_List[9],
                l,
                function(x){return caml_call2(Async_kernel_Tail[3], tail, x);});
              return caml_call1(Async_kernel_Tail[4], tail);
             });
   }
   function to_list(s){
    var
     _M_ = Core_List[34],
     _N_ =
       fold
        (s,
         0,
         function(b, a){
          return caml_call1(Async_kernel_Deferred_std[10], [0, a, b]);
         });
    return caml_call2(Async_kernel_Deferred_std[4], _N_, _M_);
   }
   function copy_to_tail(t, tail){
    return iter
            (t,
             function(a){
              var _L_ = caml_call2(Async_kernel_Tail[3], tail, a);
              return caml_call1(Async_kernel_Deferred_std[10], _L_);
             });
   }
   function append(t1, t2){
    return create
            (function(tail){
              var _J_ = copy_to_tail(t1, tail);
              return caml_call2
                      (Async_kernel_Deferred_std[11],
                       _J_,
                       function(param){
                        var _K_ = copy_to_tail(t2, tail);
                        return caml_call2
                                (Async_kernel_Deferred_std[11],
                                 _K_,
                                 function(param){
                                  return caml_call1(Async_kernel_Tail[4], tail);
                                 });
                       });
             });
   }
   function concat(t){
    return create
            (function(tail){
              var _I_ = iter(t, function(t){return copy_to_tail(t, tail);});
              return caml_call2
                      (Async_kernel_Deferred_std[11],
                       _I_,
                       function(param){
                        return caml_call1(Async_kernel_Tail[4], tail);
                       });
             });
   }
   function filter_deprecated(t, f){
    return create
            (function(tail){
              var
               _F_ =
                 iter
                  (t,
                   function(v){
                    var
                     _G_ = caml_call1(f, v),
                     _H_ = caml_call1(Async_kernel_Deferred_std[10], _G_);
                    return caml_call2
                            (Async_kernel_Deferred_std[5][2],
                             _H_,
                             function(param){
                              return param ? caml_call2(Async_kernel_Tail[3], tail, v) : 0;
                             });
                   });
              return caml_call2
                      (Async_kernel_Deferred_std[11],
                       _F_,
                       function(param){
                        return caml_call1(Async_kernel_Tail[4], tail);
                       });
             });
   }
   function filter_map_deprecated(t, f){
    return create
            (function(tail){
              var
               _C_ =
                 iter
                  (t,
                   function(v){
                    var
                     _D_ = caml_call1(f, v),
                     _E_ = caml_call1(Async_kernel_Deferred_std[10], _D_);
                    return caml_call2
                            (Async_kernel_Deferred_std[5][2],
                             _E_,
                             function(param){
                              if(! param) return 0;
                              var v = param[1];
                              return caml_call2(Async_kernel_Tail[3], tail, v);
                             });
                   });
              return caml_call2
                      (Async_kernel_Deferred_std[11],
                       _C_,
                       function(param){
                        return caml_call1(Async_kernel_Tail[4], tail);
                       });
             });
   }
   function map(t, f){
    return create
            (function(tail){
              var
               _z_ =
                 iter
                  (t,
                   function(v){
                    var
                     _A_ = caml_call1(Async_kernel_Tail[3], tail),
                     _B_ = caml_call1(f, v);
                    return caml_call2(Async_kernel_Deferred_std[4], _B_, _A_);
                   });
              return caml_call2
                      (Async_kernel_Deferred_std[11],
                       _z_,
                       function(param){
                        return caml_call1(Async_kernel_Tail[4], tail);
                       });
             });
   }
   function map$0(t, f){
    return map
            (t,
             function(a){
              var _y_ = caml_call1(f, a);
              return caml_call1(Async_kernel_Deferred_std[10], _y_);
             });
   }
   function first_n(s, n){
    return create
            (function(tail){
              function loop(s, n){
               if(caml_call2(Core[90], n, 0))
                return caml_call1(Async_kernel_Tail[4], tail);
               var _x_ = caml_call1(next, s);
               return caml_call2
                       (Async_kernel_Deferred_std[11],
                        _x_,
                        function(param){
                         if(! param) return caml_call1(Async_kernel_Tail[4], tail);
                         var t = param[2], x = param[1];
                         caml_call2(Async_kernel_Tail[3], tail, x);
                         return loop(t, n - 1 | 0);
                        });
              }
              return loop(s, n);
             });
   }
   function available_now(t){
    var t$0 = t, ac = 0;
    for(;;){
     var
      _w_ = caml_call1(next, t$0),
      match = caml_call1(Async_kernel_Deferred1[5], _w_);
     if(match){
      var match$0 = match[1];
      if(match$0){
       var t$1 = match$0[2], x = match$0[1], ac$0 = [0, x, ac];
       t$0 = t$1;
       ac = ac$0;
       continue;
      }
     }
     return [0, caml_call1(Core_List[34], ac), t$0];
    }
   }
   function split(opt, _q_, t){
    if(opt)
     var sth = opt[1], stop = sth;
    else
     var stop = caml_call1(Async_kernel_Deferred1[12], 0);
    if(_q_)
     var sth$0 = _q_[1], f = sth$0;
    else
     var f = function(param){return 192584839;};
    var
     reason_for_stopping = caml_call1(Async_kernel_Ivar[12], 0),
     prefix = caml_call1(Async_kernel_Tail[2], 0);
    function finish(v){
     caml_call1(Async_kernel_Tail[4], prefix);
     return caml_call2(Async_kernel_Ivar[14], reason_for_stopping, v);
    }
    function loop(t){
     var
      _s_ = caml_call1(next, t),
      _t_ =
        [0,
         caml_call2
          (Async_kernel_Deferred_std[6],
           _s_,
           function(o){return [0, 870035731, o];}),
         0],
      _u_ =
        [0,
         caml_call2
          (Async_kernel_Deferred_std[6],
           stop,
           function(param){return 280164845;}),
         _t_],
      _v_ = caml_call1(Async_kernel_Deferred_std[7], _u_);
     return caml_call2
             (Async_kernel_Deferred_std[1],
              _v_,
              function(param){
               if(typeof param === "number") return finish([0, 280164845, t]);
               var o = param[2];
               if(! o) return finish(1144100);
               var t$0 = o[2], a = o[1], match = caml_call1(f, a);
               if(typeof match === "number"){
                caml_call2(Async_kernel_Tail[3], prefix, a);
                return loop(t$0);
               }
               var b = match[2];
               return finish([0, 398750242, [0, b, t$0]]);
              });
    }
    loop(t);
    var _r_ = caml_call1(Async_kernel_Ivar[18], reason_for_stopping);
    return [0, caml_call1(Async_kernel_Tail[8], prefix), _r_];
   }
   function find(t, f){
    var
     found =
       split
         (0,
          [0,
           function(a){
            return caml_call1(f, a) ? [0, 398750242, a] : 192584839;
           }],
          t)
        [2];
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             found,
             function(x){
              if(typeof x !== "number" && 398750242 > x[1])
               throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
              return x;
             });
   }
   function ungroup(t){
    return create
            (function(tail){
              var
               _p_ =
                 iter
                  (t,
                   function(l){
                    caml_call2
                     (Core_List[9],
                      l,
                      function(x){
                       return caml_call2(Async_kernel_Tail[3], tail, x);
                      });
                    return caml_call1(Async_kernel_Deferred_std[10], 0);
                   });
              return caml_call2
                      (Async_kernel_Deferred_std[11],
                       _p_,
                       function(param){
                        return caml_call1(Async_kernel_Tail[4], tail);
                       });
             });
   }
   function interleave(ts){
    return create
            (function(tail){
              var num_open = [0, 1];
              function close(param){
               num_open[1] = num_open[1] - 1 | 0;
               var _o_ = caml_call2(Core[90], num_open[1], 0);
               return _o_ ? caml_call1(Async_kernel_Tail[4], tail) : _o_;
              }
              var
               outer_closed =
                 iter
                  (ts,
                   function(t){
                    num_open[1] = num_open[1] + 1 | 0;
                    var _n_ = copy_to_tail(t, tail);
                    caml_call2(Async_kernel_Deferred_std[11], _n_, close);
                    return caml_call1(Async_kernel_Deferred_std[10], 0);
                   });
              return caml_call2
                      (Async_kernel_Deferred_std[11], outer_closed, close);
             });
   }
   function take_until(t, d){
    return create
            (function(tail){
              function loop(t){
               var
                _j_ = caml_call1(next, t),
                _k_ =
                  [0,
                   caml_call2
                    (Async_kernel_Deferred_std[6],
                     _j_,
                     function(z){return [0, 870035731, z];}),
                   0],
                _l_ =
                  [0,
                   caml_call2
                    (Async_kernel_Deferred_std[6],
                     d,
                     function(param){return 926227490;}),
                   _k_],
                _m_ = caml_call1(Async_kernel_Deferred_std[7], _l_);
               return caml_call2
                       (Async_kernel_Deferred_std[11],
                        _m_,
                        function(param){
                         if(typeof param !== "number"){
                          var match = param[2];
                          if(match){
                           var t = match[2], x = match[1];
                           caml_call2(Async_kernel_Tail[3], tail, x);
                           return loop(t);
                          }
                         }
                         return caml_call1(Async_kernel_Tail[4], tail);
                        });
              }
              return loop(t);
             });
   }
   function iter_durably(t, f){
    return caml_call1
            (Async_kernel_Deferred1[4],
             function(result){
              function loop(t){
               var _g_ = caml_call1(next, t);
               return caml_call2
                       (Async_kernel_Deferred_std[1],
                        _g_,
                        function(param){
                         if(! param)
                          return caml_call2(Async_kernel_Ivar[14], result, 0);
                         var
                          t = param[2],
                          x = param[1],
                          _h_ =
                            caml_call7
                             (Async_kernel_Monitor[16],
                              0,
                              0,
                              0,
                              0,
                              _c_,
                              _b_,
                              function(param){return caml_call1(f, x);});
                         return caml_call2
                                 (Async_kernel_Deferred_std[1],
                                  _h_,
                                  function(z){
                                   loop(t);
                                   if(0 === z[0]) return 0;
                                   var e = z[1], _i_ = caml_call1(Async_kernel_Monitor[5], 0);
                                   return caml_call3(Async_kernel_Monitor[15], _i_, 0, e);
                                  });
                        });
              }
              return loop(t);
             });
   }
   function iter_durably_report_end(t, f){
    return caml_call1
            (Async_kernel_Deferred1[4],
             function(result){
              function loop(t){
               var _f_ = caml_call1(next, t);
               return caml_call2
                       (Async_kernel_Deferred_std[1],
                        _f_,
                        function(param){
                         if(! param)
                          return caml_call2(Async_kernel_Ivar[14], result, 0);
                         var t = param[2], x = param[1];
                         loop(t);
                         return caml_call1(f, x);
                        });
              }
              return loop(t);
             });
   }
   function iter_durably$0(t, f){
    var _e_ = iter_durably_report_end(t, f);
    return caml_call1(Async_kernel_Deferred_std[8], _e_);
   }
   function of_fun(f){
    return unfold
            (0,
             function(param){
              var _d_ = caml_call1(f, 0);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _d_,
                       function(a){return [0, [0, a, 0]];});
             });
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_stream);
   var
    Async_kernel_Async_stream =
      [0,
       sexp_of_t,
       create,
       next,
       first_exn,
       of_list,
       to_list,
       of_fun,
       copy_to_tail,
       append,
       concat,
       available_now,
       filter_deprecated,
       filter_map_deprecated,
       fold,
       fold$0,
       iter,
       closed,
       iter$0,
       take_until,
       iter_durably,
       iter_durably$0,
       iter_durably_report_end,
       length,
       map,
       map$0,
       first_n,
       unfold,
       split,
       find,
       ungroup,
       interleave];
   runtime.caml_register_global
    (24, Async_kernel_Async_stream, cst_Async_kernel_Async_stream);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Time_source_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Time_source_i = "Async_kernel__Time_source_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Time_source_i);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/time_source_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Time_source_i);
   var Async_kernel_Time_source_intf = [0];
   runtime.caml_register_global
    (11, Async_kernel_Time_source_intf, cst_Async_kernel_Time_source_i);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Bvar
//# unitInfo: Requires: Assert_failure, Async_kernel__Ivar, Async_kernel__Scheduler1, Async_kernel__Types, Base__Field, Base__Invariant, Core, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Bvar = "Async_kernel__Bvar",
    cst_async_kernel = "async_kernel",
    cst_has_any_waiters = "has_any_waiters",
    cst_ivar = "ivar",
    cst_src_bvar_ml = "src/bvar.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Types = global_data.Async_kernel__Types,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Invariant = global_data.Base__Invariant;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Bvar);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_bvar_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function ivar(r){return r[2];}
   function set_ivar(r, v){r[2] = v; return 0;}
   function has_any_waiters(r){return r[1];}
   function set_has_any_waiters(r, v){r[1] = v; return 0;}
   var
    ivar$0 =
      [0,
       function(param){return 0;},
       cst_ivar,
       [0, set_ivar],
       ivar,
       function(r, v){return [0, r[1], v];}],
    has_any_waiters$0 =
      [0,
       function(param){return 0;},
       cst_has_any_waiters,
       [0, set_has_any_waiters],
       has_any_waiters,
       function(r, v){return [0, v, r[2]];}],
    _a_ = [0, cst_ivar],
    _b_ = [0, cst_has_any_waiters],
    _c_ = [0, cst_src_bvar_ml, 23, 11],
    _d_ = [0, cst_src_bvar_ml, 19, 47],
    _e_ = [0, "_"],
    _f_ = [0, cst_src_bvar_ml, 14, 287, 309],
    _g_ = [0, cst_has_any_waiters];
   function invariant(invariant_a, param, t){
    var repr = caml_call1(Async_kernel_Types[10][2], t);
    return caml_call4
            (Base_Invariant[1],
             _f_,
             repr,
             function(x_007){
              function of_a_001(param){return _e_;}
              var
               has_any_waiters_003 = x_007[1],
               ivar_005 = x_007[2],
               arg_006 = caml_call2(Async_kernel_Ivar[9], of_a_001, ivar_005),
               bnds_002 = [0, [1, [0, _a_, [0, arg_006, 0]]], 0],
               arg_004 = caml_call1(Core[305], has_any_waiters_003),
               bnds_002$0 = [0, [1, [0, _b_, [0, arg_004, 0]]], bnds_002];
              return [1, bnds_002$0];
             },
             function(param){
              function check(f){
               return caml_call2(Base_Invariant[2], repr, f);
              }
              var
               ivar_fun =
                 check
                  (function(ivar){
                    caml_call2(Async_kernel_Ivar[10], invariant_a, ivar);
                    if(caml_call1(Async_kernel_Ivar[16], ivar)) return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _c_], 1);
                   }),
               has_any_waiters_fun =
                 check
                  (function(has_any_waiters){
                    var _k_ = caml_call1(Async_kernel_Ivar[21], repr[2]);
                    if(! _k_) return _k_;
                    if(has_any_waiters) return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _d_], 1);
                   });
              caml_call1(has_any_waiters_fun, has_any_waiters$0);
              return caml_call1(ivar_fun, ivar$0);
             });
   }
   function sexp_of_t(param, _j_, t){
    var has_any_waiters = caml_call1(Async_kernel_Types[10][2], t)[1];
    return [1, [0, _g_, [0, caml_call1(Core[305], has_any_waiters), 0]]];
   }
   var include = Async_kernel_Scheduler1[5], create = include[1];
   function broadcast(t, a){
    var
     repr = caml_call1(Async_kernel_Types[10][2], t),
     _h_ = repr[1],
     _i_ =
       _h_
        ? (repr
           [1]
          = 0,
          caml_call2(Async_kernel_Ivar[14], repr[2], a),
          repr[2] = caml_call1(Async_kernel_Ivar[12], 0),
          0)
        : _h_;
    return _i_;
   }
   function wait(t){
    var repr = caml_call1(Async_kernel_Types[10][2], t);
    repr[1] = 1;
    return caml_call1(Async_kernel_Ivar[18], repr[2]);
   }
   function has_any_waiters$1(t){
    var repr = caml_call1(Async_kernel_Types[10][2], t);
    return repr[1];
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Bvar);
   var
    Async_kernel_Bvar =
      [0, sexp_of_t, invariant, create, wait, broadcast, has_any_waiters$1];
   runtime.caml_register_global(28, Async_kernel_Bvar, cst_Async_kernel_Bvar);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Time_source
//# unitInfo: Requires: Assert_failure, Async_kernel__Bvar, Async_kernel__Debug, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Import, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Scheduler1, Async_kernel__Synchronous_time_source0, Async_kernel__Tail, Async_kernel__Time_ns, Async_kernel__Types, Base__Field, Base__Invariant, Core, Core__Time_ns, Expect_test_collector, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Aborted = "Aborted",
    cst_Async_kernel_Time_source = "Async_kernel__Time_source",
    cst_Happened = "Happened",
    cst_Ok = "Ok",
    cst_Previously_aborted = "Previously_aborted",
    cst_Previously_happened = "Previously_happened",
    cst$0 = "_",
    cst_alarm = "alarm",
    cst_async_kernel = "async_kernel",
    cst_fired = "fired",
    cst_num_fires_to_skip = "num_fires_to_skip",
    cst_scheduled_at = "scheduled_at",
    cst_src_time_source_ml = "src/time_source.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    pos = "src/time_source.ml:294:30",
    cst = "",
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Core_Time_ns = global_data.Core__Time_ns,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Timing_wheel = global_data.Timing_wheel,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0;
   global_data.Base__Field;
   var
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Async_kernel_Bvar = global_data.Async_kernel__Bvar,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Types = global_data.Async_kernel__Types;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Time_source);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_time_source_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    debug = Async_kernel_Debug[1],
    upon = Async_kernel_Deferred1[8],
    choose = Async_kernel_Deferred1[32],
    choice = Async_kernel_Deferred1[29],
    include = Async_kernel_Synchronous_time_[4],
    Job_or_event = include[2],
    invariant_with_jobs = include[20],
    invariant = include[21],
    cst_wall_clock = "<wall_clock>",
    _a_ = [0, cst$0],
    _b_ = [0, "events"],
    _c_ = [0, "is_wall_clock"];
   function sexp_of_t(param, _aB_){
    var events = _aB_[4], is_wall_clock = _aB_[8];
    if(is_wall_clock)
     return caml_call1(Sexplib0_Sexp_conv[7], cst_wall_clock);
    var
     _aC_ =
       [0,
        [1,
         [0,
          _b_,
          [0,
           caml_call2(Timing_wheel[2], function(param){return _a_;}, events),
           0]]],
        0];
    return [1,
            [0,
             [1, [0, _c_, [0, caml_call1(Core[305], is_wall_clock), 0]]],
             _aC_]];
   }
   function sexp_of_t$0(x_002){return sexp_of_t(Core[202], x_002);}
   var Read_write = [0, sexp_of_t$0, invariant, invariant_with_jobs];
   function sexp_of_t$1(x_003){return sexp_of_t(Core[171], x_003);}
   function read_only(t){return t;}
   var
    create = Async_kernel_Scheduler1[80],
    wall_clock = Async_kernel_Scheduler1[81];
   function alarm_precision(t){return caml_call1(Timing_wheel[10], t[4]);}
   function is_wall_clock(t){return t[8];}
   function next_alarm_fires_at(t){return caml_call1(Timing_wheel[38], t[4]);}
   function timing_wheel_now(t){return caml_call1(Timing_wheel[11], t[4]);}
   function id(t){return t[1];}
   function now(t){
    return t[8]
            ? caml_call1(Async_kernel_Time_ns[50], 0)
            : timing_wheel_now(t);
   }
   var
    send_exn = [0, Async_kernel_Monitor[15]],
    _d_ = [0, cst_src_time_source_ml, 228, 5],
    _e_ = [0, cst_Aborted],
    _f_ = [0, cst_Happened];
   function advance_directly(t, to){
    return caml_call3(Async_kernel_Synchronous_time_[27], t, to, send_exn);
   }
   function advance_directly_by(t, by){
    var _aA_ = now(t);
    return advance_directly
            (t, caml_call2(Async_kernel_Time_ns[113], _aA_, by));
   }
   function fire_past_alarms(t){
    return caml_call2(Async_kernel_Synchronous_time_[28], t, send_exn);
   }
   function yield$0(t){
    var _az_ = caml_call1(Async_kernel_Scheduler1[15], t[9]);
    return caml_call1(Async_kernel_Bvar[4], _az_);
   }
   function advance_by_alarms(wait_for, t, to){
    function run_queued_alarms(param){
     if(! wait_for) return yield$0(t);
     var f = wait_for[1];
     return caml_call1(f, 0);
    }
    function finish(param){
     advance_directly(t, to);
     fire_past_alarms(t);
     return run_queued_alarms(0);
    }
    function walk_alarms(param){
     for(;;){
      var match = caml_call1(Timing_wheel[35], t[4]);
      if(! match) return finish(0);
      var min_alarm_time_in_min_interval = match[1];
      if
       (caml_call2
         (Async_kernel_Time_ns[94], min_alarm_time_in_min_interval, to))
       return finish(0);
      advance_directly(t, min_alarm_time_in_min_interval);
      fire_past_alarms(t);
      var queued_alarms_ran = run_queued_alarms(0);
      if(! caml_call1(Async_kernel_Deferred1[7], queued_alarms_ran))
       return caml_call2
               (Async_kernel_Deferred_std[5][1],
                queued_alarms_ran,
                function(param){return walk_alarms(0);});
     }
    }
    fire_past_alarms(t);
    var _ay_ = run_queued_alarms(0);
    return caml_call2
            (Async_kernel_Deferred_std[5][1],
             _ay_,
             function(param){return walk_alarms(0);});
   }
   function advance_by_max_alarms_in_each_(wait_for, t, to){
    function run_queued_alarms(param){
     if(! wait_for) return yield$0(t);
     var f = wait_for[1];
     return caml_call1(f, 0);
    }
    function finish(param){
     advance_directly(t, to);
     fire_past_alarms(t);
     return run_queued_alarms(0);
    }
    function walk_alarms(param){
     for(;;){
      var match = next_alarm_fires_at(t);
      if(! match) return finish(0);
      var next_alarm_fires_at$0 = match[1];
      if(caml_call2(Async_kernel_Time_ns[94], next_alarm_fires_at$0, to))
       return finish(0);
      advance_directly(t, caml_call1(Timing_wheel[36], t[4]));
      fire_past_alarms(t);
      var queued_alarms_ran = run_queued_alarms(0);
      if(! caml_call1(Async_kernel_Deferred1[7], queued_alarms_ran))
       return caml_call2
               (Async_kernel_Deferred_std[5][1],
                queued_alarms_ran,
                function(param){return walk_alarms(0);});
     }
    }
    fire_past_alarms(t);
    var _ax_ = run_queued_alarms(0);
    return caml_call2
            (Async_kernel_Deferred_std[5][1],
             _ax_,
             function(param){return walk_alarms(0);});
   }
   function advance_by_alarms_by(wait_for, t, by){
    var _aw_ = now(t);
    return advance_by_alarms
            (wait_for, t, caml_call2(Async_kernel_Time_ns[113], _aw_, by));
   }
   function span_to_time(t, span){
    var _av_ = now(t);
    return caml_call2(Async_kernel_Time_ns[113], _av_, span);
   }
   function run_at_internal(t, time, f$0, a){
    var
     execution_context = caml_call1(Async_kernel_Scheduler1[72], t[9]),
     _au_ = caml_call1(Timing_wheel[11], t[4]);
    if(! caml_call2(Async_kernel_Time_ns[97], time, _au_)){
     caml_call4(Async_kernel_Scheduler1[63], t[9], execution_context, f$0, a);
     return caml_call1(Timing_wheel[5][2], 0);
    }
    var
     _as_ =
       caml_call4
        (Async_kernel_Scheduler1[75], t[9], execution_context, f$0, a),
     _at_ = caml_call1(Job_or_event[2], _as_),
     alarm = caml_call3(Timing_wheel[25], t[4], time, _at_),
     match = t[9][23];
    if(match){var f = match[1]; caml_call1(f, time);}
    return alarm;
   }
   function run_at(t, time, f, a){run_at_internal(t, time, f, a); return 0;}
   function run_after(t, span, f, a){
    return run_at(t, span_to_time(t, span), f, a);
   }
   function fill(result){return caml_call2(Async_kernel_Ivar[14], result, 0);}
   function at(t, time){
    var _ar_ = caml_call1(Timing_wheel[11], t[4]);
    if(caml_call2(Async_kernel_Time_ns[95], time, _ar_))
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    var result = caml_call1(Async_kernel_Ivar[12], 0);
    run_at_internal(t, time, fill, result);
    return caml_call1(Async_kernel_Ivar[18], result);
   }
   function after(t, span){return at(t, span_to_time(t, span));}
   function remove_alarm(t, alarm){
    var
     job_or_event = caml_call2(Timing_wheel[5][5], t[4], alarm),
     k = caml_call1(Job_or_event[5][1], job_or_event),
     match = caml_call2(Job_or_event[5][2], k, job_or_event);
    if(! k) throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    caml_call2(Async_kernel_Scheduler1[62], t[9], match);
    return caml_call2(Timing_wheel[28], t[4], alarm);
   }
   function sexp_of_t$2(of_a_008, of_h_009, param){
    if(0 === param[0]){
     var arg0_010 = param[1], res0_011 = caml_call1(of_a_008, arg0_010);
     return [1, [0, _e_, [0, res0_011, 0]]];
    }
    var arg0_012 = param[1], res0_013 = caml_call1(of_h_009, arg0_012);
    return [1, [0, _f_, [0, res0_013, 0]]];
   }
   var Fired = [0, sexp_of_t$2];
   function scheduled_at(r){return r[5];}
   function set_scheduled_at(r, v){r[5] = v; return 0;}
   function num_fires_to_skip(r){return r[4];}
   function set_num_fires_to_skip(r, v){r[4] = v; return 0;}
   function fired(r){return r[3];}
   function alarm(r){return r[1];}
   function set_alarm(r, v){r[1] = v; return 0;}
   var
    scheduled_at$0 =
      [0,
       function(param){return 0;},
       cst_scheduled_at,
       [0, set_scheduled_at],
       scheduled_at,
       function(r, v){return [0, r[1], r[2], r[3], r[4], v, r[6]];}],
    num_fires_to_skip$0 =
      [0,
       function(param){return 0;},
       cst_num_fires_to_skip,
       [0, set_num_fires_to_skip],
       num_fires_to_skip,
       function(r, v){return [0, r[1], r[2], r[3], v, r[5], r[6]];}],
    fired$0 =
      [0,
       function(param){return 0;},
       cst_fired,
       0,
       fired,
       function(r, v){return [0, r[1], r[2], v, r[4], r[5], r[6]];}],
    alarm$0 =
      [0,
       function(param){return 0;},
       cst_alarm,
       [0, set_alarm],
       alarm,
       function(r, v){return [0, v, r[2], r[3], r[4], r[5], r[6]];}],
    _g_ = [0, "time_source"],
    _h_ = [0, cst_scheduled_at],
    _i_ = [0, cst_num_fires_to_skip],
    _j_ = [0, cst_fired],
    _k_ = [0, "fire"],
    _l_ = [0, cst_alarm],
    _m_ = [0, cst_src_time_source_ml, 289, 43],
    _n_ = [0, cst_src_time_source_ml, 278, 18],
    _o_ = [0, cst_src_time_source_ml, 280, 18],
    _p_ = [0, cst$0],
    _q_ = [0, cst$0],
    _r_ = [0, cst_src_time_source_ml, 271, 9504, 9528],
    _s_ = [0, cst_Aborted],
    _t_ = [0, cst_Happened],
    _u_ = [0, "Scheduled_at"];
   function sexp_of_t$3(of_a_016, of_h_017, param){
    var
     alarm_019 = param[1],
     fired_023 = param[3],
     num_fires_to_skip_025 = param[4],
     scheduled_at_027 = param[5],
     time_source_029 = param[6],
     arg_030 = caml_call1(Async_kernel_Synchronous_time_[5], time_source_029),
     bnds_018 = [0, [1, [0, _g_, [0, arg_030, 0]]], 0],
     arg_028 = caml_call1(Async_kernel_Time_ns[92], scheduled_at_027),
     bnds_018$0 = [0, [1, [0, _h_, [0, arg_028, 0]]], bnds_018],
     arg_026 = caml_call1(Core[356], num_fires_to_skip_025),
     bnds_018$1 = [0, [1, [0, _i_, [0, arg_026, 0]]], bnds_018$0],
     _ap_ = caml_call2(Fired[1], of_a_016, of_h_017),
     arg_024 = caml_call2(Async_kernel_Ivar[9], _ap_, fired_023),
     bnds_018$2 = [0, [1, [0, _j_, [0, arg_024, 0]]], bnds_018$1],
     arg_022 = caml_call1(Sexplib0_Sexp_conv[24], function(_aq_){return 0;}),
     bnds_018$3 = [0, [1, [0, _k_, [0, arg_022, 0]]], bnds_018$2],
     arg_020 = caml_call2(Timing_wheel[5][1], Job_or_event[6], alarm_019),
     bnds_018$4 = [0, [1, [0, _l_, [0, arg_020, 0]]], bnds_018$3];
    return [1, bnds_018$4];
   }
   function sexp_of_t_unit(x_031){
    return sexp_of_t$3(Core[518], Core[518], x_031);
   }
   function fired$1(t){return caml_call1(Async_kernel_Ivar[18], t[3]);}
   function invariant$0(invariant_a, invariant_h, t){
    return caml_call4
            (Base_Invariant[1],
             _r_,
             t,
             function(x_032){
              return sexp_of_t$3
                      (function(param){return _q_;},
                       function(param){return _p_;},
                       x_032);
             },
             function(param){
              var events = t[6][4];
              function check(f){return caml_call2(Base_Invariant[2], t, f);}
              var
               scheduled_at_fun =
                 check
                  (function(scheduled_at){
                    var _ao_ = caml_call2(Timing_wheel[27], events, t[1]);
                    if(! _ao_) return _ao_;
                    var
                     expect = caml_call2(Timing_wheel[5][3], events, t[1]),
                     sexpifier = Async_kernel_Time_ns[92];
                    function comparator(a_033, b_034){
                     return caml_call2(Async_kernel_Time_ns[101], a_033, b_034);
                    }
                    return caml_call8
                            (Ppx_assert_lib_Runtime[3],
                             pos,
                             sexpifier,
                             comparator,
                             0,
                             0,
                             0,
                             expect,
                             scheduled_at);
                   }),
               num_fires_to_skip_fun =
                 check
                  (function(num_fires_to_skip){
                    if(caml_call2(Async_kernel_Import[1], num_fires_to_skip, 0))
                     return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _m_], 1);
                   }),
               fired_fun =
                 check
                  (function(fired){
                    var
                     _an_ = caml_call1(Async_kernel_Ivar[18], fired),
                     match = caml_call1(Async_kernel_Deferred1[5], _an_);
                    if(! match) return 0;
                    var match$0 = match[1];
                    if(0 === match$0[0]){
                     var a = match$0[1];
                     return caml_call1(invariant_a, a);
                    }
                    var h = match$0[1];
                    return caml_call1(invariant_h, h);
                   }),
               alarm_fun =
                 check
                  (function(alarm){
                    if(caml_call1(Async_kernel_Ivar[17], t[3])){
                     if(caml_call2(Timing_wheel[27], events, alarm))
                      throw caml_maybe_attach_backtrace
                             ([0, Assert_failure, _n_], 1);
                     return 0;
                    }
                    var _al_ = caml_call2(Timing_wheel[27], events, alarm);
                    if(! _al_) return _al_;
                    var _am_ = caml_call2(Timing_wheel[5][5], events, alarm);
                    if(caml_call1(Job_or_event[4], _am_)) return 0;
                    throw caml_maybe_attach_backtrace
                           ([0, Assert_failure, _o_], 1);
                   });
              caml_call1(alarm_fun, alarm$0);
              caml_call1(fired_fun, fired$0);
              caml_call1(num_fires_to_skip_fun, num_fires_to_skip$0);
              caml_call1(scheduled_at_fun, scheduled_at$0);
              return 0;
             });
   }
   function sexp_of_t$4(of_a_035, of_h_036, param){
    switch(param[0]){
      case 0:
       var arg0_037 = param[1], res0_038 = caml_call1(of_a_035, arg0_037);
       return [1, [0, _s_, [0, res0_038, 0]]];
      case 1:
       var arg0_039 = param[1], res0_040 = caml_call1(of_h_036, arg0_039);
       return [1, [0, _t_, [0, res0_040, 0]]];
      default:
       var
        arg0_041 = param[1],
        res0_042 = caml_call1(Async_kernel_Time_ns[92], arg0_041);
       return [1, [0, _u_, [0, res0_042, 0]]];
    }
   }
   var
    Status = [0, sexp_of_t$4],
    _v_ = [0, cst_Ok],
    _w_ = [0, cst_Previously_aborted],
    _x_ = [0, cst_Previously_happened];
   function status(t){
    var
     _ak_ = caml_call1(Async_kernel_Ivar[18], t[3]),
     match = caml_call1(Async_kernel_Deferred1[5], _ak_);
    if(! match) return [2, t[5]];
    var match$0 = match[1];
    if(0 === match$0[0]){var a = match$0[1]; return [0, a];}
    var h = match$0[1];
    return [1, h];
   }
   function sexp_of_t$5(of_a_045, of_h_046, param){
    if(typeof param === "number") return _v_;
    if(0 === param[0]){
     var arg0_047 = param[1], res0_048 = caml_call1(of_a_045, arg0_047);
     return [1, [0, _w_, [0, res0_048, 0]]];
    }
    var arg0_049 = param[1], res0_050 = caml_call1(of_h_046, arg0_049);
    return [1, [0, _x_, [0, res0_050, 0]]];
   }
   var
    Abort_result = [0, sexp_of_t$5],
    _y_ = [0, cst$0],
    _z_ = [0, cst$0],
    cst_Time_source_Event_abort = "Time_source.Event.abort",
    cst_Clock_Event_abort_exn_fail =
      "Clock.Event.abort_exn failed to abort event that previously aborted",
    cst_Clock_Event_abort_exn_fail$0 =
      "Clock.Event.abort_exn failed to abort event that previously happened",
    _A_ = [0, cst_Ok],
    _B_ = [0, cst_Previously_aborted],
    _C_ = [0, cst_Previously_happened];
   function abort(t, a){
    if(debug)
     caml_call3
      (Async_kernel_Debug[15],
       cst_Time_source_Event_abort,
       t,
       function(x_053){
        return sexp_of_t$3
                (function(param){return _z_;},
                 function(param){return _y_;},
                 x_053);
       });
    var
     _aj_ = fired$1(t),
     match = caml_call1(Async_kernel_Deferred1[5], _aj_);
    if(! match){
     caml_call2(Async_kernel_Ivar[14], t[3], [0, a]);
     var alarm = t[1], t$0 = t[6];
     if(caml_call2(Timing_wheel[27], t$0[4], alarm)) remove_alarm(t$0, alarm);
     return 0;
    }
    var match$0 = match[1];
    if(0 === match$0[0]){var a$0 = match$0[1]; return [0, a$0];}
    var h = match$0[1];
    return [1, h];
   }
   function abort_exn(t, a){
    var match = abort(t, a);
    if(typeof match === "number") return 0;
    if(0 === match[0]){
     var
      _ah_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Clock_Event_abort_exn_fail);
     return caml_call1(Core[253], _ah_);
    }
    var
     _ai_ =
       caml_call1(Sexplib0_Sexp_conv[7], cst_Clock_Event_abort_exn_fail$0);
    return caml_call1(Core[253], _ai_);
   }
   function abort_if_possible(t, a){abort(t, a); return 0;}
   function schedule(t){t[1] = run_at_internal(t[6], t[5], t[2], 0); return;}
   function sexp_of_t$6(of_a_054, of_h_055, param){
    if(typeof param === "number") return _A_;
    if(0 === param[0]){
     var arg0_056 = param[1], res0_057 = caml_call1(of_a_054, arg0_056);
     return [1, [0, _B_, [0, res0_057, 0]]];
    }
    var arg0_058 = param[1], res0_059 = caml_call1(of_h_055, arg0_058);
    return [1, [0, _C_, [0, res0_059, 0]]];
   }
   var
    Reschedule_result = [0, sexp_of_t$6],
    _D_ = [0, cst$0],
    _E_ = [0, cst$0],
    cst_Time_source_Event_reschedu = "Time_source.Event.reschedule_at",
    cst_Time_source_Event_run_at = "Time_source.Event.run_at";
   function reschedule_at(t, at){
    if(debug)
     caml_call3
      (Async_kernel_Debug[15],
       cst_Time_source_Event_reschedu,
       [0, t, at],
       function(param){
        var
         arg1_063 = param[2],
         arg0_062 = param[1],
         res0_064 =
           sexp_of_t$3
            (function(param){return _E_;},
             function(param){return _D_;},
             arg0_062),
         res1_065 = caml_call1(Async_kernel_Time_ns[92], arg1_063);
        return [1, [0, res0_064, [0, res1_065, 0]]];
       });
    var
     _af_ = fired$1(t),
     match = caml_call1(Async_kernel_Deferred1[5], _af_);
    if(match){
     var match$0 = match[1];
     if(0 === match$0[0]){var a = match$0[1]; return [0, a];}
     var h = match$0[1];
     return [1, h];
    }
    var
     events = t[6][4],
     is_in_timing_wheel = caml_call2(Timing_wheel[27], events, t[1]),
     _ag_ = caml_call1(Timing_wheel[11], events),
     am_trying_to_reschedule_in_the =
       caml_call2(Async_kernel_Time_ns[97], at, _ag_);
    t[5] = at;
    if(am_trying_to_reschedule_in_the)
     if(is_in_timing_wheel)
      caml_call3(Timing_wheel[29], events, t[1], at);
     else{t[4] = t[4] + 1 | 0; schedule(t);}
    else if(is_in_timing_wheel){
     caml_call1(t[6][7], t[1]);
     caml_call2(Timing_wheel[28], events, t[1]);
    }
    return 0;
   }
   function reschedule_after(t, span){
    return reschedule_at(t, span_to_time(t[6], span));
   }
   function run_at$0(time_source, scheduled_at, f, z){
    if(debug)
     caml_call3
      (Async_kernel_Debug[15],
       cst_Time_source_Event_run_at,
       scheduled_at,
       Async_kernel_Time_ns[92]);
    var
     _aa_ = caml_call1(Async_kernel_Ivar[12], 0),
     t =
       [0,
        caml_call1(Timing_wheel[5][2], 0),
        function(_ae_){return 0;},
        _aa_,
        0,
        scheduled_at,
        time_source];
    function fire(param){
     var _ab_ = caml_call1(Async_kernel_Ivar[16], t[3]);
     if(_ab_){
      if(caml_call2(Async_kernel_Import[4], t[4], 0)){t[4] = t[4] - 1 | 0; return 0;}
      var
       result = caml_call1(f, z),
       _ac_ = caml_call1(Async_kernel_Ivar[16], t[3]);
      if(_ac_) return caml_call2(Async_kernel_Ivar[14], t[3], [1, result]);
      var _ad_ = _ac_;
     }
     else
      var _ad_ = _ab_;
     return _ad_;
    }
    t[2] = fire;
    schedule(t);
    return t;
   }
   function at$0(time_source, time){
    return run_at$0(time_source, time, function(_$_){return 0;}, 0);
   }
   function run_after$0(time_source, span, f, a){
    return run_at$0(time_source, span_to_time(time_source, span), f, a);
   }
   function after$0(time_source, span){
    return at$0(time_source, span_to_time(time_source, span));
   }
   function at_times(opt, t, next_time){
    if(opt)
     var sth = opt[1], stop = sth;
    else
     var stop = caml_call1(Async_kernel_Deferred1[12], 0);
    var tail = caml_call1(Async_kernel_Tail[2], 0);
    function loop(param){
     var
      ___ =
        [0,
         caml_call2
          (choice,
           at(t, caml_call1(next_time, 0)),
           function(param){return 936767357;}),
         0];
     return caml_call2
             (upon,
              caml_call1
               (choose,
                [0,
                 caml_call2(choice, stop, function(param){return 926227490;}),
                 ___]),
              function(param){
               return 936767357 <= param
                       ? (caml_call2(Async_kernel_Tail[3], tail, 0), loop(0))
                       : caml_call1(Async_kernel_Tail[4], tail);
              });
    }
    loop(0);
    return caml_call1(Async_kernel_Tail[8], tail);
   }
   function at_varying_intervals(stop, t, compute_span){
    return at_times
            (stop,
             t,
             function(param){
              var _Y_ = caml_call1(compute_span, 0), _Z_ = now(t);
              return caml_call2(Async_kernel_Time_ns[113], _Z_, _Y_);
             });
   }
   function at_intervals(start, stop, t, interval){
    if(start) var x = start[1], start$0 = x; else var start$0 = now(t);
    return at_times
            (stop,
             t,
             function(param){
              var _X_ = now(t);
              return caml_call5
                      (Async_kernel_Time_ns[65], 0, start$0, _X_, interval, 0);
             });
   }
   var
    _F_ = [0, -146189108],
    _G_ = [0, 3903734],
    _H_ = [0, "span"],
    cst_Time_source_every_got_nonp = "Time_source.every got nonpositive span",
    _I_ = [0, 1],
    cst_Time_source_with_timeout_b =
      "Time_source.with_timeout bug: both completed and timed out",
    cst_Time_source_with_timeout_b$0 =
      "Time_source.with_timeout bug: should only abort once";
   function run_repeatedly(opt, stop, _R_, _Q_, time_source, f, continue$0){
    if(opt)
     var sth = opt[1], start = sth;
    else
     var start = caml_call1(Async_kernel_Deferred_std[10], 0);
    if(_R_)
     var sth$0 = _R_[1], continue_on_error = sth$0;
    else
     var continue_on_error = 1;
    if(_Q_)
     var sth$1 = _Q_[1], finished = sth$1;
    else
     var finished = caml_call1(Async_kernel_Ivar[12], 0);
    return caml_call2
            (upon,
             start,
             function(param){
              var alarm = [0, caml_call1(Timing_wheel[5][2], 0)];
              if(stop){
               var stop$0 = stop[1];
               caml_call2
                (upon,
                 stop$0,
                 function(param){
                  var
                   _W_ = caml_call2(Timing_wheel[27], time_source[4], alarm[1]);
                  return _W_
                          ? (remove_alarm
                             (time_source, alarm[1]),
                            caml_call2(Async_kernel_Ivar[15], finished, 0))
                          : _W_;
                 });
               var stop$1 = stop$0;
              }
              else
               var stop$1 = caml_call1(Async_kernel_Deferred1[12], 0);
              function run_f(param){
               if(caml_call1(Async_kernel_Deferred1[7], stop$1))
                return caml_call2(Async_kernel_Ivar[15], finished, 0);
               if(continue_on_error)
                return caml_call2
                        (upon,
                         caml_call7
                          (Async_kernel_Monitor[16], 0, 0, 0, 0, _G_, _F_, f),
                         continue_try_with);
               var d = caml_call1(f, 0);
               return caml_call1(Async_kernel_Deferred1[7], d)
                       ? continue_f(0)
                       : caml_call2(upon, d, continue_f);
              }
              function continue_f(param){
               if(caml_call1(Async_kernel_Deferred1[7], stop$1))
                return caml_call2(Async_kernel_Ivar[15], finished, 0);
               var _U_ = 0;
               if(typeof continue$0 === "number")
                var _V_ = caml_call1(Timing_wheel[11], time_source[4]);
               else if(0 === continue$0[0])
                var
                 span = continue$0[1],
                 _V_ = span_to_time(time_source, span);
               else
                var
                 interval = continue$0[2],
                 base = continue$0[1],
                 _T_ = now(time_source),
                 _V_ =
                   caml_call5
                    (Async_kernel_Time_ns[65], 0, base, _T_, interval, 0);
               alarm[1] = run_at_internal(time_source, _V_, run_f, _U_);
               return 0;
              }
              function continue_try_with(or_error){
               if(0 !== or_error[0]){
                var
                 error = or_error[1],
                 _S_ = caml_call1(Async_kernel_Monitor[5], 0);
                caml_call3(Async_kernel_Monitor[15], _S_, 0, error);
               }
               return continue_f(0);
              }
              return run_f(0);
             });
   }
   function every(start, stop, continue_on_error, finished, t, span, f){
    if(caml_call2(Core_Time_ns[1][16], span, Core_Time_ns[1][75])){
     var
      _O_ =
        [0, [1, [0, _H_, [0, caml_call1(Core_Time_ns[1][10], span), 0]]], 0],
      _P_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Time_source_every_got_nonp),
          _O_]];
     caml_call1(Core[253], _P_);
    }
    return run_repeatedly
            (start, stop, continue_on_error, finished, t, f, [0, span]);
   }
   function every$0(start, stop, continue_on_error, t, span, f){
    return every
            (start,
             stop,
             continue_on_error,
             0,
             t,
             span,
             function(param){
              caml_call1(f, 0);
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function run_at_intervals(start, stop, continue_on_error, t, interval, f){
    var now$0 = now(t);
    if(start)
     var
      start$0 = start[1],
      start$1 =
        [0,
         at
          (t,
           caml_call5
            (Async_kernel_Time_ns[65], _I_, start$0, now$0, interval, 0))],
      base = start$0;
    else
     var start$1 = 0, base = now$0;
    return run_repeatedly
            (start$1, stop, continue_on_error, 0, t, f, [1, base, interval]);
   }
   function run_at_intervals$0(start, stop, continue_on_error, t, interval, f){
    return run_at_intervals
            (start,
             stop,
             continue_on_error,
             t,
             interval,
             function(param){
              caml_call1(f, 0);
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function with_timeout(t, span, d){
    var
     timeout = after$0(t, span),
     _L_ =
       [0,
        caml_call2
         (choice,
          fired$1(timeout),
          function(param){
           if(0 !== param[0]) return 642269825;
           var
            _N_ =
              caml_call1
               (Sexplib0_Sexp_conv[7], cst_Time_source_with_timeout_b);
           return caml_call1(Core[253], _N_);
          }),
        0];
    return caml_call1
            (choose,
             [0,
              caml_call2
               (choice,
                d,
                function(v){
                 var match = abort(timeout, 0);
                 a:
                 if(typeof match !== "number" && 0 === match[0]){
                  var
                   _M_ =
                     caml_call1
                      (Sexplib0_Sexp_conv[7], cst_Time_source_with_timeout_b$0);
                  caml_call1(Core[253], _M_);
                  break a;
                 }
                 return [0, 1025039613, v];
                }),
              _L_]);
   }
   function duration_of(t, f){
    var start = now(t), _J_ = caml_call1(f, 0);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _J_,
             function(result){
              var
               _K_ = now(t),
               duration = caml_call2(Async_kernel_Time_ns[57], _K_, start);
              return [0, result, duration];
             });
   }
   function of_synchronous(t){return t;}
   function to_synchronous(t){return t;}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Time_source);
   var
    Async_kernel_Time_source =
      [0,
       [0, sexp_of_t],
       Read_write,
       Async_kernel_Types[21],
       sexp_of_t$1,
       id,
       invariant,
       invariant_with_jobs,
       read_only,
       create,
       wall_clock,
       alarm_precision,
       is_wall_clock,
       next_alarm_fires_at,
       now,
       timing_wheel_now,
       advance_directly,
       advance_directly,
       advance_directly_by,
       advance_directly_by,
       fire_past_alarms,
       advance_by_alarms,
       advance_by_max_alarms_in_each_,
       advance_by_alarms_by,
       [0, 0],
       run_repeatedly,
       run_at,
       run_after,
       at,
       after,
       with_timeout,
       duration_of,
       [0,
        sexp_of_t$3,
        sexp_of_t_unit,
        invariant$0,
        scheduled_at,
        Status,
        status,
        run_at$0,
        run_after$0,
        Abort_result,
        abort,
        abort_exn,
        abort_if_possible,
        Fired,
        fired$1,
        Reschedule_result,
        reschedule_at,
        reschedule_after,
        at$0,
        after$0],
       at_varying_intervals,
       at_intervals,
       every,
       every$0,
       run_at_intervals,
       run_at_intervals$0,
       of_synchronous,
       to_synchronous];
   runtime.caml_register_global
    (83, Async_kernel_Time_source, cst_Async_kernel_Time_source);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Stack_or_counter
//# unitInfo: Requires: Base, Base__Stack, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Stack_or_coun = "Async_kernel__Stack_or_counter",
    cst_async_kernel = "async_kernel",
    cst_length = "length";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Stack = global_data.Base__Stack,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base = global_data.Base,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Stack_or_coun);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/stack_or_counter.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    _a_ = [0, "Stack"],
    _b_ = [0, cst_length],
    _c_ = [0, "Counter"],
    _d_ = [0, cst_length],
    cst_Stack_or_counter_create_co =
      "[Stack_or_counter.create_counter] got negative length",
    cst_Stack_or_counter_pop_exn_o =
      "[Stack_or_counter.pop_exn] of empty stack";
   function sexp_of_t(of_a_002, param){
    if(0 === param[0]){
     var
      arg0_003 = param[1],
      res0_004 = caml_call2(Base_Stack[2], of_a_002, arg0_003);
     return [1, [0, _a_, [0, res0_004, 0]]];
    }
    var
     length_006 = param[1],
     arg_007 = caml_call1(Base[119], length_006),
     bnds_005 = [0, [1, [0, _b_, [0, arg_007, 0]]], 0];
    return [1, [0, _c_, bnds_005]];
   }
   function of_list(list){return [0, caml_call1(Base_Stack[22], list)];}
   function create_counter(length){
    if(length < 0){
     var
      _i_ = [0, [1, [0, _d_, [0, caml_call1(Base[119], length), 0]]], 0],
      _j_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Stack_or_counter_create_co),
          _i_]];
     caml_call1(Base[202], _j_);
    }
    return [1, length];
   }
   function length(t){
    if(0 !== t[0]) return t[1];
    var s = t[1];
    return caml_call1(Base_Stack[6], s);
   }
   function clear(t){
    if(0 === t[0]){var s = t[1]; return caml_call1(Base_Stack[30], s);}
    t[1] = 0;
    return 0;
   }
   function push(t, a){
    if(0 === t[0]){var s = t[1]; return caml_call2(Base_Stack[25], s, a);}
    t[1] = t[1] + 1 | 0;
    return 0;
   }
   function pop_exn(t){
    if(0 === t[0]){var s = t[1]; return caml_call1(Base_Stack[27], s);}
    if(0 === t[1]){
     var
      _h_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Stack_or_counter_pop_exn_o);
     caml_call1(Base[202], _h_);
    }
    t[1] = t[1] - 1 | 0;
    return 0;
   }
   function iter(t, f){
    if(0 === t[0]){var s = t[1]; return caml_call2(Base_Stack[8], s, f);}
    var _f_ = t[1], _e_ = 1;
    if(_f_ >= 1){
     var for$0 = _e_;
     for(;;){
      caml_call1(f, 0);
      var _g_ = for$0 + 1 | 0;
      if(_f_ === for$0) break;
      for$0 = _g_;
     }
    }
    return 0;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Stack_or_coun);
   var
    Async_kernel_Stack_or_counter =
      [0,
       sexp_of_t,
       clear,
       create_counter,
       iter,
       length,
       of_list,
       pop_exn,
       push];
   runtime.caml_register_global
    (20, Async_kernel_Stack_or_counter, cst_Async_kernel_Stack_or_coun);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Throttle
//# unitInfo: Requires: Assert_failure, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Import, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Stack_or_counter, Base__Field, Core, Core__Int, Core__List, Core__Queue, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Aborted = "Aborted",
    cst_Async_kernel_Throttle = "Async_kernel__Throttle",
    cst_Ok = "Ok",
    cst_Raised = "Raised",
    cst_async_kernel = "async_kernel",
    cst_capacity_available = "capacity_available",
    cst_cleaned = "cleaned",
    cst_job_resources_not_in_use = "job_resources_not_in_use",
    cst_jobs_waiting_to_start = "jobs_waiting_to_start",
    cst_max_concurrent_jobs = "max_concurrent_jobs",
    cst_num_jobs_running = "num_jobs_running",
    cst_num_resources_not_cleaned = "num_resources_not_cleaned",
    cst_src_throttle_ml = "src/throttle.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Stack_or_counter = global_data.Async_kernel__Stack_or_counter,
    Core_Queue = global_data.Core__Queue,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core = global_data.Core,
    Core_Int = global_data.Core__Int,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core_List = global_data.Core__List,
    Base_Field = global_data.Base__Field,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Throttle);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_throttle_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, cst_Aborted], _b_ = [0, cst_Ok], _c_ = [0, cst_Raised];
   function sexp_of_outcome(of_a_001, param){
    if(typeof param === "number") return _a_;
    if(17724 <= param[1]){
     var v_002 = param[2];
     return [1, [0, _b_, [0, caml_call1(of_a_001, v_002), 0]]];
    }
    var v_003 = param[2];
    return [1, [0, _c_, [0, caml_call1(Core[537], v_003), 0]]];
   }
   function abort(t){
    return caml_call2(Async_kernel_Ivar[14], t[1], 774323088);
   }
   function cleaned(r){return r[10];}
   function num_resources_not_cleaned(r){return r[9];}
   function set_num_resources_not_cleaned(r, v){r[9] = v; return 0;}
   function is_dead(r){return r[7];}
   function capacity_available(r){return r[6];}
   function set_capacity_available(r, v){r[6] = v; return 0;}
   function num_jobs_running(r){return r[5];}
   function set_num_jobs_running(r, v){r[5] = v; return 0;}
   function jobs_waiting_to_start(r){return r[4];}
   function job_resources_not_in_use(r){return r[3];}
   function max_concurrent_jobs(r){return r[2];}
   var
    cleaned$0 =
      [0,
       function(param){return 0;},
       cst_cleaned,
       0,
       cleaned,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], v];
       }],
    num_resources_not_cleaned$0 =
      [0,
       function(param){return 0;},
       cst_num_resources_not_cleaned,
       [0, set_num_resources_not_cleaned],
       num_resources_not_cleaned,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], v, r[10]];
       }],
    capacity_available$0 =
      [0,
       function(param){return 0;},
       cst_capacity_available,
       [0, set_capacity_available],
       capacity_available,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], r[5], v, r[7], r[8], r[9], r[10]];
       }],
    num_jobs_running$0 =
      [0,
       function(param){return 0;},
       cst_num_jobs_running,
       [0, set_num_jobs_running],
       num_jobs_running,
       function(r, v){
        return [0, r[1], r[2], r[3], r[4], v, r[6], r[7], r[8], r[9], r[10]];
       }],
    jobs_waiting_to_start$0 =
      [0,
       function(param){return 0;},
       cst_jobs_waiting_to_start,
       0,
       jobs_waiting_to_start,
       function(r, v){
        return [0, r[1], r[2], r[3], v, r[5], r[6], r[7], r[8], r[9], r[10]];
       }],
    job_resources_not_in_use$0 =
      [0,
       function(param){return 0;},
       cst_job_resources_not_in_use,
       0,
       job_resources_not_in_use,
       function(r, v){
        return [0, r[1], r[2], v, r[4], r[5], r[6], r[7], r[8], r[9], r[10]];
       }],
    max_concurrent_jobs$0 =
      [0,
       function(param){return 0;},
       cst_max_concurrent_jobs,
       0,
       max_concurrent_jobs,
       function(r, v){
        return [0, r[1], v, r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10]];
       }],
    _d_ = [0, cst_Aborted],
    _e_ = [0, cst_Ok],
    _f_ = [0, cst_Raised],
    _g_ = [0, "outcome"],
    _h_ = [0, "Abort"],
    _i_ = [0, "Start"],
    _j_ = [0, "start"],
    _n_ = [0, cst_cleaned],
    _o_ = [0, cst_num_resources_not_cleaned],
    _p_ = [0, "cleans"],
    _q_ = [0, "is_dead"],
    _r_ = [0, cst_capacity_available],
    _s_ = [0, cst_num_jobs_running],
    _t_ = [0, cst_jobs_waiting_to_start],
    _u_ = [0, cst_job_resources_not_in_use],
    _v_ = [0, cst_max_concurrent_jobs],
    _w_ = [0, "continue_on_error"],
    _x_ = [0, "_"],
    _y_ = [0, "t"],
    _z_ = [0, "exn"],
    cst_Throttle_invariant_failed = "Throttle.invariant failed",
    _A_ = [0, cst_src_throttle_ml, 133, 40],
    _B_ = [0, cst_src_throttle_ml, 130, 69],
    _C_ = [0, cst_src_throttle_ml, 129, 11],
    _D_ = [0, cst_src_throttle_ml, 128, 11],
    _E_ = [0, cst_src_throttle_ml, 123, 26],
    _F_ = [0, cst_src_throttle_ml, 119, 16],
    _G_ = [0, cst_src_throttle_ml, 117, 11],
    _H_ = [0, cst_src_throttle_ml, 116, 11],
    _I_ = [0, cst_src_throttle_ml, 113, 29],
    _J_ = [0, cst_src_throttle_ml, 108, 11],
    _K_ = [0, cst_src_throttle_ml, 104, 43];
   function sexp_of_t(of_a_011, param){
    var
     jobs_waiting_to_start_019 = param[4],
     job_resources_not_in_use_017 = param[3],
     max_concurrent_jobs_015 = param[2],
     continue_on_error_013 = param[1],
     num_jobs_running_021 = param[5],
     capacity_available_023 = param[6],
     is_dead_025 = param[7],
     cleans_027 = param[8],
     num_resources_not_cleaned_029 = param[9],
     cleaned_031 = param[10],
     arg_032 = caml_call2(Async_kernel_Ivar[9], Core[518], cleaned_031),
     bnds_012 = [0, [1, [0, _n_, [0, arg_032, 0]]], 0],
     arg_030 = caml_call1(Core[356], num_resources_not_cleaned_029),
     bnds_012$0 = [0, [1, [0, _o_, [0, arg_030, 0]]], bnds_012],
     arg_028 =
       caml_call2
        (Core[421],
         function(param){
          return caml_call1(Sexplib0_Sexp_conv[24], function(_at_){return 0;});
         },
         cleans_027),
     bnds_012$1 = [0, [1, [0, _p_, [0, arg_028, 0]]], bnds_012$0],
     arg_026 = caml_call1(Core[305], is_dead_025),
     bnds_012$2 = [0, [1, [0, _q_, [0, arg_026, 0]]], bnds_012$1],
     _as_ = caml_call1(Async_kernel_Ivar[9], Core[518]),
     arg_024 = caml_call2(Core[454], _as_, capacity_available_023),
     bnds_012$3 = [0, [1, [0, _r_, [0, arg_024, 0]]], bnds_012$2],
     arg_022 = caml_call1(Core[356], num_jobs_running_021),
     bnds_012$4 = [0, [1, [0, _s_, [0, arg_022, 0]]], bnds_012$3],
     arg_020 =
       caml_call2
        (Core_Queue[11],
         function(param){
          var
           outcome_009 = param[2],
           start_006 = param[1],
           arg_010 =
             caml_call2
              (Async_kernel_Deferred1[1],
               function(param){
                return -216426513 === param ? _d_ : 17724 <= param ? _e_ : _f_;
               },
               outcome_009),
           bnds_005 = [0, [1, [0, _g_, [0, arg_010, 0]]], 0],
           arg_007 =
             caml_call2
              (Async_kernel_Ivar[9],
               function(param){
                if(typeof param === "number") return _h_;
                var v_008 = param[2];
                return [1, [0, _i_, [0, caml_call1(of_a_011, v_008), 0]]];
               },
               start_006),
           bnds_005$0 = [0, [1, [0, _j_, [0, arg_007, 0]]], bnds_005];
          return [1, bnds_005$0];
         },
         jobs_waiting_to_start_019),
     bnds_012$5 = [0, [1, [0, _t_, [0, arg_020, 0]]], bnds_012$4],
     arg_018 =
       caml_call2
        (Async_kernel_Stack_or_counter[1],
         of_a_011,
         job_resources_not_in_use_017),
     bnds_012$6 = [0, [1, [0, _u_, [0, arg_018, 0]]], bnds_012$5],
     arg_016 = caml_call1(Core[356], max_concurrent_jobs_015),
     bnds_012$7 = [0, [1, [0, _v_, [0, arg_016, 0]]], bnds_012$6],
     arg_014 = caml_call1(Core[305], continue_on_error_013),
     bnds_012$8 = [0, [1, [0, _w_, [0, arg_014, 0]]], bnds_012$7];
    return [1, bnds_012$8];
   }
   function invariant(invariant_a, x_033){
    try{
     var
      max_concurrent_jobs =
        caml_call2(Base_Field[3], max_concurrent_jobs$0, x_033);
     if(! caml_call2(Async_kernel_Import[4], max_concurrent_jobs, 0))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _K_], 1);
     var
      job_resources_not_in_use =
        caml_call2(Base_Field[3], job_resources_not_in_use$0, x_033);
     caml_call2
      (Async_kernel_Stack_or_counter[4],
       job_resources_not_in_use,
       invariant_a);
     var
      _ap_ = x_033[7] ? 0 : x_033[2] - x_033[5] | 0,
      _aq_ =
        caml_call1(Async_kernel_Stack_or_counter[5], job_resources_not_in_use);
     if(! caml_call2(Async_kernel_Import[3], _aq_, _ap_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _J_], 1);
     var
      jobs_waiting_to_start =
        caml_call2(Base_Field[3], jobs_waiting_to_start$0, x_033);
     if(x_033[7] && ! caml_call1(Core_Queue[15], jobs_waiting_to_start))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _I_], 1);
     var
      num_jobs_running = caml_call2(Base_Field[3], num_jobs_running$0, x_033);
     if(! caml_call2(Async_kernel_Import[1], num_jobs_running, 0))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
     if(! caml_call2(Async_kernel_Import[2], num_jobs_running, x_033[2]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _G_], 1);
     if
      (caml_call2(Async_kernel_Import[5], num_jobs_running, x_033[2])
       && ! caml_call1(Core_Queue[15], x_033[4]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
     var param = caml_call2(Base_Field[3], capacity_available$0, x_033);
     if(param){
      var ivar = param[1];
      if(! caml_call1(Async_kernel_Ivar[16], ivar))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
     }
     var
      num_resources_not_cleaned =
        caml_call2(Base_Field[3], num_resources_not_cleaned$0, x_033);
     if(! caml_call2(Async_kernel_Import[1], num_resources_not_cleaned, 0))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
     if
      (!
       caml_call2(Async_kernel_Import[2], num_resources_not_cleaned, x_033[2]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _C_], 1);
     if
      (caml_call2(Async_kernel_Import[5], num_resources_not_cleaned, x_033[2])
       && ! x_033[7])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
     var
      cleaned = caml_call2(Base_Field[3], cleaned$0, x_033),
      _ao_ = caml_call1(Async_kernel_Ivar[17], cleaned);
     if(_ao_){
      if(! caml_call2(Async_kernel_Import[3], x_033[9], 0))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
      var _ar_ = 0;
     }
     else
      var _ar_ = _ao_;
     return _ar_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _al_ =
        [0,
         [1, [0, _y_, [0, sexp_of_t(function(param){return _x_;}, x_033), 0]]],
         0],
      _am_ = [0, [1, [0, _z_, [0, caml_call1(Core[537], exn), 0]]], _al_],
      _an_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Throttle_invariant_failed),
          _am_]];
     return caml_call1(Core[253], _an_);
    }
   }
   function sexp_of_t$0(of_a_034, of_kind_035, x_036){return sexp_of_t(of_a_034, x_036);
   }
   function invariant$0(invariant_a, param, t){return invariant(invariant_a, t);
   }
   var
    T2 = [0, sexp_of_t$0, invariant$0],
    _m_ = [0, cst_src_throttle_ml, 58, 18],
    _L_ = [0, cst_src_throttle_ml, 173, 2],
    _M_ = [0, cst_src_throttle_ml, 175, 2],
    _N_ = [0, cst_src_throttle_ml, 174, 2];
   function num_jobs_waiting_to_start(t){
    return caml_call1(Core_Queue[14], t[4]);
   }
   function clean_resource(t, a){
    var
     _ai_ =
       caml_call2(Core_List[72], t[8], function(f){return caml_call1(f, a);}),
     _aj_ = caml_call1(Async_kernel_Deferred1[43], _ai_);
    return caml_call2
            (Async_kernel_Deferred_std[1],
             _aj_,
             function(param){
              t[9] = t[9] - 1 | 0;
              var _ak_ = caml_call2(Async_kernel_Import[3], t[9], 0);
              return _ak_ ? caml_call2(Async_kernel_Ivar[14], t[10], 0) : _ak_;
             });
   }
   function kill(t){
    var _ah_ = 1 - t[7];
    return _ah_
            ? (t
               [7]
              = 1,
              caml_call2(Core_Queue[16], t[4], abort),
              caml_call1(Core_Queue[47], t[4]),
              caml_call2
               (Async_kernel_Stack_or_counter[4],
                t[3],
                function(a){return clean_resource(t, a);}),
              caml_call1(Async_kernel_Stack_or_counter[2], t[3]))
            : _ah_;
   }
   function at_kill(t, f){
    var
     _ag_ = caml_call1(Async_kernel_Monitor[26][8], f),
     f$0 = caml_call1(Core[259], _ag_);
    t[8] = [0, f$0, t[8]];
    return 0;
   }
   function cleaned$1(t){return caml_call1(Async_kernel_Ivar[18], t[10]);}
   function start_job(t){
    if(t[7]) throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
    if(! caml_call2(Async_kernel_Import[5], t[5], t[2]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _N_], 1);
    if(caml_call1(Core_Queue[15], t[4]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _M_], 1);
    var job = caml_call1(Core_Queue[44], t[4]);
    t[5] = t[5] + 1 | 0;
    var job_resource = caml_call1(Async_kernel_Stack_or_counter[7], t[3]);
    caml_call2(Async_kernel_Ivar[14], job[1], [0, 389604418, job_resource]);
    var
     _af_ =
       caml_call2
        (Async_kernel_Deferred_std[5][2],
         job[2],
         function(x){
          if(-216426513 === x)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
          return x;
         });
    return caml_call2
            (Async_kernel_Deferred_std[1],
             _af_,
             function(res){
              t[5] = t[5] - 1 | 0;
              if(17724 > res && 1 - t[1]) kill(t);
              if(t[7]) return clean_resource(t, job_resource);
              caml_call2(Async_kernel_Stack_or_counter[8], t[3], job_resource);
              if(! caml_call1(Core_Queue[15], t[4])) return start_job(t);
              var match = t[6];
              if(! match) return 0;
              var ivar = match[1];
              caml_call2(Async_kernel_Ivar[14], ivar, 0);
              t[6] = 0;
              return 0;
             });
   }
   function create_internal(continue_on_error, job_resources){
    var
     max_concurrent_jobs =
       caml_call1(Async_kernel_Stack_or_counter[5], job_resources),
     _ae_ = caml_call1(Async_kernel_Ivar[12], 0);
    return [0,
            continue_on_error,
            max_concurrent_jobs,
            job_resources,
            caml_call2(Core_Queue[61], 0, 0),
            0,
            0,
            0,
            0,
            max_concurrent_jobs,
            _ae_];
   }
   function create_with(continue_on_error, job_resources){
    return create_internal
            (continue_on_error,
             caml_call1(Async_kernel_Stack_or_counter[6], job_resources));
   }
   function create(opt, a){
    if(opt)
     var sth = opt[1], continue_on_error = sth;
    else
     var continue_on_error = 0;
    return create_with(continue_on_error, [0, a, 0]);
   }
   var
    Sequencer = [0, sexp_of_t, create],
    _k_ = [0, 3804260],
    _l_ = [0, 523273847],
    _O_ = [0, cst_max_concurrent_jobs],
    cst_Throttle_create_requires_p =
      "Throttle.create requires positive max_concurrent_jobs, but got",
    cst_throttle_aborted_job = "throttle aborted job",
    cst_enqueue_exclusive_was_call =
      "[enqueue_exclusive] was called with a very large value of [max_concurrent_jobs]. This doesn't work.",
    _P_ = [0, cst_src_throttle_ml, 279, 2];
   function create$0(continue_on_error, max_concurrent_jobs){
    if(caml_call2(Async_kernel_Import[2], max_concurrent_jobs, 0)){
     var
      _ac_ =
        [0,
         [1, [0, _O_, [0, caml_call1(Core[356], max_concurrent_jobs), 0]]],
         0],
      _ad_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Throttle_create_requires_p),
          _ac_]];
     caml_call1(Core[253], _ad_);
    }
    return create_internal
            (continue_on_error,
             caml_call1(Async_kernel_Stack_or_counter[3], max_concurrent_jobs));
   }
   function enqueue(t, work){
    var
     start = caml_call1(Async_kernel_Ivar[12], 0),
     _aa_ = caml_call1(Async_kernel_Ivar[18], start),
     result =
       caml_call2
        (Async_kernel_Deferred_std[5][1],
         _aa_,
         function(param){
          if(typeof param === "number")
           return caml_call1(Async_kernel_Deferred_std[10], -216426513);
          var
           a = param[2],
           _ab_ =
             caml_call7
              (Async_kernel_Monitor[16],
               0,
               0,
               0,
               0,
               _l_,
               _k_,
               function(param){return caml_call1(work, a);});
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _ab_,
                   function(param){
                    if(0 === param[0]){var a = param[1]; return [0, 17724, a];}
                    var exn = param[1];
                    return [0, -387916264, exn];
                   });
         }),
     outcome =
       caml_call2
        (Async_kernel_Deferred_std[5][2],
         result,
         function(param){
          return typeof param === "number"
                  ? -216426513
                  : 17724 <= param[1] ? 17724 : -387916264;
         }),
     internal_job = [0, start, outcome];
    if(t[7])
     abort(internal_job);
    else{
     caml_call2(Core_Queue[41], t[4], internal_job);
     if(caml_call2(Async_kernel_Import[5], t[5], t[2])) start_job(t);
    }
    return result;
   }
   function handle_enqueue_result(result){
    if(typeof result === "number"){
     var _$_ = caml_call1(Sexplib0_Sexp_conv[7], cst_throttle_aborted_job);
     return caml_call1(Core[253], _$_);
    }
    if(17724 <= result[1]){var a = result[2]; return a;}
    var exn = result[2];
    throw caml_maybe_attach_backtrace(exn, 0);
   }
   function enqueue$0(t, f){
    var ___ = enqueue(t, f);
    return caml_call2
            (Async_kernel_Deferred_std[4], ___, handle_enqueue_result);
   }
   function enqueue_exclusive(t, f){
    var n = t[2];
    if(caml_call2(Core_Int[84], n, 1000000)){
     var
      _U_ = caml_call1(Sexplib0_Sexp_conv[7], cst_enqueue_exclusive_was_call);
     caml_call1(Core[253], _U_);
    }
    var done = caml_call1(Async_kernel_Ivar[12], 0);
    if(! caml_call2(Async_kernel_Import[4], n, 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _P_], 1);
    function f_placeholder(slot){
     return caml_call1(Async_kernel_Ivar[18], done);
    }
    var _W_ = n - 1 | 0, _V_ = 1;
    if(_W_ >= 1){
     var for$0 = _V_;
     for(;;){
      var _Y_ = enqueue$0(t, f_placeholder);
      caml_call1(Async_kernel_Deferred_std[8], _Y_);
      var _Z_ = for$0 + 1 | 0;
      if(_W_ === for$0) break;
      for$0 = _Z_;
     }
    }
    var _X_ = enqueue(t, function(slot){return caml_call1(f, 0);});
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _X_,
             function(result){
              caml_call2(Async_kernel_Ivar[14], done, 0);
              return handle_enqueue_result(result);
             });
   }
   function monad_sequence_how(how, f){
    a:
    {
     if(typeof how === "number" && -676829465 <= how){var f$0 = f; break a;}
     if(typeof how === "number")
      var max_concurrent_jobs = 1;
     else
      var
       max_concurrent_jobs$0 = how[2],
       max_concurrent_jobs = max_concurrent_jobs$0;
     var
      t = create$0(0, max_concurrent_jobs),
      f$0 =
        function(a){
         return enqueue$0(t, function(param){return caml_call1(f, a);});
        };
    }
    return caml_call1(Core[258], f$0);
   }
   function monad_sequence_how2(how, f){
    a:
    {
     if(typeof how === "number" && -676829465 <= how){var f$0 = f; break a;}
     if(typeof how === "number")
      var max_concurrent_jobs = 1;
     else
      var
       max_concurrent_jobs$0 = how[2],
       max_concurrent_jobs = max_concurrent_jobs$0;
     var
      t = create$0(0, max_concurrent_jobs),
      f$0 =
        function(a1, a2){
         return enqueue$0(t, function(param){return caml_call2(f, a1, a2);});
        };
    }
    return caml_call1(Core[258], f$0);
   }
   function prior_jobs_done(t){
    return caml_call1
            (Async_kernel_Deferred1[4],
             function(all_dummy_jobs_running){
              var dummy_jobs_running = [0, 0], _R_ = t[2], _Q_ = 1;
              if(_R_ >= 1){
               var for$0 = _Q_;
               for(;;){
                var
                 _S_ =
                   enqueue$0
                    (t,
                     function(param){
                      dummy_jobs_running[1]++;
                      if
                       (caml_call2
                         (Async_kernel_Import[3], dummy_jobs_running[1], t[2]))
                       caml_call2(Async_kernel_Ivar[14], all_dummy_jobs_running, 0);
                      return caml_call1
                              (Async_kernel_Ivar[18], all_dummy_jobs_running);
                     });
                caml_call1(Async_kernel_Deferred_std[8], _S_);
                var _T_ = for$0 + 1 | 0;
                if(_R_ === for$0) break;
                for$0 = _T_;
               }
              }
              return 0;
             });
   }
   function capacity_available$1(t){
    if(caml_call2(Async_kernel_Import[5], t[5], t[2]))
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    var match = t[6];
    if(! match)
     return caml_call1
             (Async_kernel_Deferred1[4],
              function(ivar){t[6] = [0, ivar]; return 0;});
    var ivar = match[1];
    return caml_call1(Async_kernel_Ivar[18], ivar);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Throttle);
   var
    Async_kernel_Throttle =
      [0,
       T2,
       sexp_of_t,
       invariant,
       create$0,
       create_with,
       sexp_of_outcome,
       enqueue,
       enqueue$0,
       enqueue_exclusive,
       monad_sequence_how,
       monad_sequence_how2,
       prior_jobs_done,
       max_concurrent_jobs,
       num_jobs_running,
       num_jobs_waiting_to_start,
       capacity_available$1,
       kill,
       is_dead,
       at_kill,
       cleaned$1,
       Sequencer];
   runtime.caml_register_global
    (81, Async_kernel_Throttle, cst_Async_kernel_Throttle);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Synchronous_time_source
//# unitInfo: Requires: Async_kernel__Scheduler1, Async_kernel__Synchronous_time_source0, Async_kernel__Types, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Synchronous_t = "Async_kernel__Synchronous_time_source",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Async_kernel_Types = global_data.Async_kernel__Types;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Synchronous_t);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/synchronous_time_source.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    default_timing_wheel_config = Async_kernel_Synchronous_time_[3],
    T1 = Async_kernel_Synchronous_time_[4],
    sexp_of_t = Async_kernel_Synchronous_time_[5],
    invariant = Async_kernel_Synchronous_time_[6],
    invariant_with_jobs = Async_kernel_Synchronous_time_[7],
    Read_write = Async_kernel_Synchronous_time_[8],
    id = Async_kernel_Synchronous_time_[9],
    is_wall_clock = Async_kernel_Synchronous_time_[10],
    length = Async_kernel_Synchronous_time_[11],
    max_allowed_alarm_time = Async_kernel_Synchronous_time_[12],
    read_only = Async_kernel_Synchronous_time_[13],
    alarm_precision = Async_kernel_Synchronous_time_[15],
    next_alarm_fires_at = Async_kernel_Synchronous_time_[16],
    next_alarm_runs_at = Async_kernel_Synchronous_time_[17],
    now = Async_kernel_Synchronous_time_[18],
    timing_wheel_now = Async_kernel_Synchronous_time_[19],
    Event = Async_kernel_Synchronous_time_[22],
    run_after = Async_kernel_Synchronous_time_[23],
    run_at = Async_kernel_Synchronous_time_[24],
    run_at_intervals = Async_kernel_Synchronous_time_[25],
    advance_by_alarms = Async_kernel_Synchronous_time_[32],
    advance_by_max_alarms_in_each_ = Async_kernel_Synchronous_time_[33],
    advance_directly = Async_kernel_Synchronous_time_[34],
    duration_of = Async_kernel_Synchronous_time_[35],
    max_alarm_time_in_min_timing_w = Async_kernel_Synchronous_time_[36],
    has_events_to_run = Async_kernel_Synchronous_time_[37],
    create = Async_kernel_Scheduler1[80],
    wall_clock = Async_kernel_Scheduler1[81];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Synchronous_t);
   var
    _a_ = Event[3],
    Async_kernel_Synchronous_time_$0 =
      [0,
       [0, T1[17]],
       Read_write,
       Async_kernel_Types[21],
       sexp_of_t,
       invariant_with_jobs,
       invariant,
       id,
       read_only,
       create,
       alarm_precision,
       is_wall_clock,
       now,
       timing_wheel_now,
       run_at,
       run_after,
       run_at_intervals,
       max_allowed_alarm_time,
       duration_of,
       [0,
        Event[17],
        Event[18],
        [0,
         _a_[8],
         _a_[2],
         _a_[3],
         _a_[4],
         _a_[5],
         _a_[9],
         _a_[10],
         _a_[11],
         _a_[12],
         _a_[7]],
        Event[25],
        Event[26],
        Event[28],
        Event[29],
        Event[30],
        Event[32],
        Event[31],
        Event[33],
        Event[35],
        Event[36],
        Event[37],
        Event[38],
        Event[39],
        Event[21]],
       default_timing_wheel_config,
       wall_clock,
       length,
       next_alarm_runs_at,
       next_alarm_fires_at,
       advance_by_alarms,
       advance_by_max_alarms_in_each_,
       advance_directly,
       max_alarm_time_in_min_timing_w,
       has_events_to_run];
   runtime.caml_register_global
    (14, Async_kernel_Synchronous_time_$0, cst_Async_kernel_Synchronous_t);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Scheduler
//# unitInfo: Requires: Assert_failure, Async_kernel__Async_stream, Async_kernel__Bvar, Async_kernel__Debug, Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Execution_context, Async_kernel__Import, Async_kernel__Job_queue, Async_kernel__Monitor, Async_kernel__Scheduler1, Async_kernel__Synchronous_time_source0, Async_kernel__Tail, Async_kernel__Time_ns, Async_kernel__Types, Async_kernel_config, Base__Backtrace, Core, Core__Deque, Core__Error, Core__Gc, Core__Hashtbl, Core__Heap_block, Core__List, Core__Option, Core__Time_ns, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv, Stdlib, Stdlib__Gc, Thread_safe_queue, Timing_wheel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Scheduler = "Async_kernel__Scheduler",
    cst_async_kernel = "async_kernel",
    cst_src_scheduler_ml = "src/scheduler.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Import = global_data.Async_kernel__Import,
    Core_Deque = global_data.Core__Deque,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Base_Backtrace = global_data.Base__Backtrace,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Execution_context =
      global_data.Async_kernel__Execution_context,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Core_Time_ns = global_data.Core__Time_ns,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Bvar = global_data.Async_kernel__Bvar,
    Async_kernel_Debug = global_data.Async_kernel__Debug,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Core_Error = global_data.Core__Error,
    Core_Option = global_data.Core__Option,
    Core_List = global_data.Core__List,
    Async_kernel_Synchronous_time_ =
      global_data.Async_kernel__Synchronous_time_source0,
    Async_kernel_Job_queue = global_data.Async_kernel__Job_queue,
    Core_Heap_block = global_data.Core__Heap_block,
    Stdlib_Gc = global_data.Stdlib__Gc,
    Stdlib = global_data.Stdlib,
    Core_Gc = global_data.Core__Gc,
    Thread_safe_queue = global_data.Thread_safe_queue,
    Async_kernel_config = global_data.Async_kernel_config,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Async_kernel_Async_stream = global_data.Async_kernel__Async_stream,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Async_kernel_Types = global_data.Async_kernel__Types,
    Timing_wheel = global_data.Timing_wheel,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Scheduler);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_scheduler_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    start_cycle = Async_kernel_Scheduler1[77],
    create_job = Async_kernel_Scheduler1[75],
    with_execution_context = Async_kernel_Scheduler1[74],
    with_execution_context1 = Async_kernel_Scheduler1[73],
    current_execution_context = Async_kernel_Scheduler1[72],
    check_access = Async_kernel_Scheduler1[70],
    t_ref = Async_kernel_Scheduler1[69],
    set_check_access = Async_kernel_Scheduler1[68],
    is_dead = Async_kernel_Scheduler1[67],
    enqueue_job = Async_kernel_Scheduler1[64],
    enqueue = Async_kernel_Scheduler1[63],
    free_job = Async_kernel_Scheduler1[62],
    invariant = Async_kernel_Scheduler1[61],
    last_cycle_num_jobs = Async_kernel_Scheduler1[58],
    num_jobs_run = Async_kernel_Scheduler1[57],
    num_pending_jobs = Async_kernel_Scheduler1[56],
    uncaught_exn = Async_kernel_Scheduler1[55],
    uncaught_exn_unwrapped = Async_kernel_Scheduler1[54],
    sexp_of_t = Async_kernel_Scheduler1[53],
    last_cycle_time = Async_kernel_Scheduler1[29],
    Very_low_priority_worker = Async_kernel_Scheduler1[6],
    debug = Async_kernel_Scheduler1[3],
    set_execution_context = Async_kernel_Scheduler1[2],
    events = Async_kernel_Scheduler1[1],
    t = Async_kernel_Scheduler1[71],
    include = Async_kernel_Monitor[26],
    within = include[1],
    within$0 = include[2],
    within_v = include[3],
    schedule = include[4],
    schedule$0 = include[5],
    within_context = include[6],
    preserve_execution_context = include[7],
    preserve_execution_context$0 = include[8];
   function find_local(key){
    var _V_ = caml_call1(current_execution_context, caml_call1(t, 0));
    return caml_call2(Async_kernel_Execution_context[10], _V_, key);
   }
   function with_local(key, value, f){
    var
     t$0 = caml_call1(t, 0),
     _U_ = caml_call1(current_execution_context, t$0),
     execution_context =
       caml_call3(Async_kernel_Execution_context[11], _U_, key, value);
    return caml_call3(with_execution_context, t$0, execution_context, f);
   }
   var
    main_execution_context = caml_call1(t, 0)[6],
    cst_Scheduler_remove_single_cy =
      "Scheduler.remove_single_cycle_hook called with a hook that isn't registered",
    cst_Attempted_to_remove_a_cycl =
      "Attempted to remove a cycle start hook which has already been removed.",
    cst_Attempted_to_remove_a_cycl$0 =
      "Attempted to remove a cycle end hook which has already been removed.",
    cst_enqueueing_finalizer = "enqueueing finalizer",
    cst_adding_finalizer = "adding finalizer",
    cst_enqueueing_finalizer_using =
      "enqueueing finalizer (using 'last' semantic)",
    cst_adding_finalizer_using_las =
      "adding finalizer (using 'last' semantic)";
   function can_run_a_job(t){
    var
     _S_ = caml_call1(num_pending_jobs, t),
     _T_ = caml_call2(Async_kernel_Import[4], _S_, 0);
    return _T_ ? _T_ : caml_call1(Async_kernel_Bvar[6], t[24]);
   }
   function has_upcoming_event(t){
    var _R_ = caml_call1(events, t);
    return 1 - caml_call1(Timing_wheel[13], _R_);
   }
   function next_upcoming_event(t){
    var _Q_ = caml_call1(events, t);
    return caml_call1(Timing_wheel[38], _Q_);
   }
   function next_upcoming_event_exn(t){
    var _P_ = caml_call1(events, t);
    return caml_call1(Timing_wheel[39], _P_);
   }
   function event_precision(t){
    var _O_ = caml_call1(events, t);
    return caml_call1(Timing_wheel[10], _O_);
   }
   function cycle_start(t){return t[10];}
   function run_every_cycle_start(t, f){t[12] = [0, f, t[12]]; return 0;}
   function run_every_cycle_end(t, f){t[14] = [0, f, t[14]]; return 0;}
   function add_every_cycle_start_hook(t, f){
    var handle = caml_call1(Async_kernel_Types[20][45], 0);
    caml_call3(Core_Hashtbl[36], t[13], handle, f);
    run_every_cycle_start(t, f);
    return handle;
   }
   function add_every_cycle_end_hook(t, f){
    var handle = caml_call1(Async_kernel_Types[20][45], 0);
    caml_call3(Core_Hashtbl[36], t[15], handle, f);
    run_every_cycle_end(t, f);
    return handle;
   }
   function remove_single_cycle_hook(lst, f){
    var
     f$0 = caml_call1(Core[246], f),
     _M_ =
       caml_call2
        (Core_List[130], lst, function(x){return 1 - caml_call1(f$0, x);}),
     match = _M_[2],
     l = _M_[1];
    if(match)
     var r = match[2], match$0 = [0, caml_call2(Core[157], l, r)];
    else
     var match$0 = 0;
    if(match$0){var lst$0 = match$0[1]; return lst$0;}
    var
     _N_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_remove_single_cy);
    return caml_call1(Core[253], _N_);
   }
   function remove_every_cycle_start_hook_(t, handle){
    var match = caml_call2(Core_Hashtbl[61], t[13], handle);
    if(! match) return caml_call1(Core[6], cst_Attempted_to_remove_a_cycl);
    var f = match[1];
    t[12] = remove_single_cycle_hook(t[12], f);
    return 0;
   }
   function remove_every_cycle_end_hook_ex(t, handle){
    var match = caml_call2(Core_Hashtbl[61], t[15], handle);
    if(! match) return caml_call1(Core[6], cst_Attempted_to_remove_a_cycl$0);
    var f = match[1];
    t[14] = remove_single_cycle_hook(t[14], f);
    return 0;
   }
   function map_cycle_times(t, f){
    return caml_call1
            (Async_kernel_Async_stream[2],
             function(tail){
              return run_every_cycle_start
                      (t,
                       function(param){
                        var _L_ = caml_call1(f, t[16]);
                        return caml_call2(Async_kernel_Tail[3], tail, _L_);
                       });
             });
   }
   function long_cycles(t, at_least){
    return caml_call1
            (Async_kernel_Async_stream[2],
             function(tail){
              return run_every_cycle_start
                      (t,
                       function(param){
                        var _K_ = caml_call2(Core_Time_ns[1][15], t[16], at_least);
                        return _K_
                                ? caml_call2(Async_kernel_Tail[3], tail, t[16])
                                : _K_;
                       });
             });
   }
   function cycle_num_jobs(t){
    return caml_call1
            (Async_kernel_Async_stream[2],
             function(tail){
              return run_every_cycle_start
                      (t,
                       function(param){
                        return caml_call2(Async_kernel_Tail[3], tail, t[17]);
                       });
             });
   }
   function cycle_count(t){return t[9];}
   function set_max_num_jobs_per_priority_(t, int$0){
    t[27] = caml_call1(Async_kernel_config[5][4], int$0);
    return 0;
   }
   function max_num_jobs_per_priority_per_(t){
    return caml_call1(Async_kernel_config[5][5], t[27]);
   }
   function set_thread_safe_external_job_h(t, f){t[21] = f; return 0;}
   function thread_safe_enqueue_external_j(t, execution_context, f, a){
    caml_call2(Thread_safe_queue[5], t[20], [0, execution_context, f, a]);
    return caml_call1(t[21], 0);
   }
   function set_event_added_hook(t, f){t[23] = [0, f]; return 0;}
   function set_job_queued_hook(t, f){t[22] = [0, f]; return 0;}
   function create_alarm(t, f){
    var execution_context = caml_call1(current_execution_context, t);
    return caml_call1
            (Core_Gc[10][6][2],
             function(param){
              return thread_safe_enqueue_external_j
                      (t, execution_context, f, 0);
             });
   }
   function add_finalizer(t, heap_block, f){
    var execution_context = caml_call1(current_execution_context, t);
    function finalizer(heap_block){
     if(Async_kernel_Debug[4])
      caml_call1(Async_kernel_Debug[16], cst_enqueueing_finalizer);
     return thread_safe_enqueue_external_j
             (t, execution_context, f, heap_block);
    }
    if(Async_kernel_Debug[4])
     caml_call1(Async_kernel_Debug[16], cst_adding_finalizer);
    try{var _I_ = caml_call2(Stdlib_Gc[3], finalizer, heap_block); return _I_;
    }
    catch(_J_){
     var _H_ = caml_wrap_exception(_J_);
     if(_H_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_H_, 0);
    }
   }
   function add_finalizer_exn(t, x, f){
    return add_finalizer
            (t,
             caml_call1(Core_Heap_block[3], x),
             function(heap_block){
              return caml_call1(f, caml_call1(Core_Heap_block[4], heap_block));
             });
   }
   function add_finalizer_last(t, heap_block, f){
    var execution_context = caml_call1(current_execution_context, t);
    function finalizer(param){
     if(Async_kernel_Debug[4])
      caml_call1(Async_kernel_Debug[16], cst_enqueueing_finalizer_using);
     return thread_safe_enqueue_external_j(t, execution_context, f, 0);
    }
    if(Async_kernel_Debug[4])
     caml_call1(Async_kernel_Debug[16], cst_adding_finalizer_using_las);
    try{var _F_ = caml_call2(Stdlib_Gc[4], finalizer, heap_block); return _F_;
    }
    catch(_G_){
     var _E_ = caml_wrap_exception(_G_);
     if(_E_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_E_, 0);
    }
   }
   function add_finalizer_last_exn(t, x, f){
    return add_finalizer_last(t, caml_call1(Core_Heap_block[3], x), f);
   }
   function force_current_cycle_to_end(t){
    return caml_call2(Async_kernel_Job_queue[6], t[3], 0);
   }
   var
    send_exn = [0, Async_kernel_Monitor[15]],
    cst_run_cycle_starting = "run_cycle starting",
    cst_run_cycle_finished = "run_cycle finished",
    cst_run_cycles_until_no_jobs_r =
      "run_cycles_until_no_jobs_remain starting",
    _a_ = [0, "scheduler"],
    cst_run_cycles_until_no_jobs_r$0 =
      "run_cycles_until_no_jobs_remain cannot proceed -- scheduler is dead",
    cst_run_cycles_until_no_jobs_r$1 =
      "run_cycles_until_no_jobs_remain finished",
    cst_Async_scheduler_is_unusabl =
      "Async scheduler is unusable due to [make_async_unusable]",
    cst_reset_in_forked_process = "reset_in_forked_process",
    _b_ = [0, "n"],
    cst_Scheduler_yield_every_got_ =
      "Scheduler.yield_every got nonpositive count",
    _c_ = [0, cst_src_scheduler_ml, 324, 4],
    _d_ = [0, 1];
   function advance_clock(t, now){
    return caml_call3
            (Async_kernel_Synchronous_time_[29], t[19], now, send_exn);
   }
   function run_cycle(t){
    if(debug)
     caml_call3(Async_kernel_Debug[15], cst_run_cycle_starting, t, sexp_of_t);
    var now = caml_call1(Async_kernel_Time_ns[50], 0);
    t[9] = t[9] + 1 | 0;
    t[10] = now;
    t[11] = 1;
    caml_call2(Async_kernel_Bvar[5], t[24], 0);
    var num_jobs_run_at_start_of_cycle = caml_call1(num_jobs_run, t);
    caml_call2(Core_List[9], t[12], function(f){return caml_call1(f, 0);});
    advance_clock(t, now);
    caml_call2(start_cycle, t, t[27]);
    for(;;){
     var match = caml_call1(Async_kernel_Scheduler1[78], t);
     if(0 === match[0]) break;
     var
      match$0 = match[1],
      backtrace = match$0[2],
      exn = match$0[1],
      _v_ = caml_call1(Async_kernel_Monitor[5], 0);
     caml_call3
      (Async_kernel_Monitor[15], _v_, [0, [0, 936718974, backtrace]], exn);
    }
    var
     _w_ = t[10],
     _x_ = caml_call1(Async_kernel_Time_ns[50], 0),
     cycle_time = caml_call2(Async_kernel_Time_ns[57], _x_, _w_);
    t[16] = cycle_time;
    t[17] = caml_call1(num_jobs_run, t) - num_jobs_run_at_start_of_cycle | 0;
    t[18] = caml_call2(Core_Time_ns[1][97], t[18], cycle_time);
    var _y_ = caml_call1(Async_kernel_Bvar[6], t[25]);
    if(_y_)
     var
      _z_ = caml_call1(num_pending_jobs, t),
      _A_ = caml_call2(Async_kernel_Import[3], _z_, 0);
    else
     var _A_ = _y_;
    if(_A_) caml_call2(Async_kernel_Bvar[5], t[25], 0);
    caml_call2(Core_List[9], t[14], function(f){return caml_call1(f, 0);});
    t[11] = 0;
    if(! debug) return debug;
    var
     _B_ = next_upcoming_event(t),
     _C_ = caml_call1(Core[243], _B_),
     _D_ = [0, caml_call1(uncaught_exn, t), _C_];
    return caml_call3
            (Async_kernel_Debug[15],
             cst_run_cycle_finished,
             _D_,
             function(param){
              var
               arg1_002 = param[2],
               arg0_001 = param[1],
               res0_003 = caml_call2(Core[454], Core_Error[6], arg0_001),
               res1_004 = caml_call1(Core[305], arg1_002);
              return [1, [0, res0_003, [0, res1_004, 0]]];
             });
   }
   function run_cycles_until_no_jobs_remai(param){
    if(debug)
     caml_call1(Async_kernel_Debug[16], cst_run_cycles_until_no_jobs_r);
    var t$0 = caml_call1(t, 0);
    if(caml_call1(is_dead, t$0)){
     var
      _r_ = [0, [1, [0, _a_, [0, caml_call1(sexp_of_t, t$0), 0]]], 0],
      _s_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_run_cycles_until_no_jobs_r$0),
          _r_]];
     caml_call1(Core[253], _s_);
    }
    for(;;){
     run_cycle(t$0);
     advance_clock(t$0, caml_call1(Async_kernel_Time_ns[50], 0));
     if(! can_run_a_job(t$0)){
      caml_call2(set_execution_context, t$0, t$0[6]);
      if(debug)
       caml_call1(Async_kernel_Debug[16], cst_run_cycles_until_no_jobs_r$1);
      var _t_ = Core_Error[28], _u_ = caml_call1(uncaught_exn, t$0);
      return caml_call2(Core_Option[41], _u_, _t_);
     }
    }
   }
   function make_async_unusable(param){
    var t = t_ref[1];
    t[1] =
     [0,
      function(param){
       var
        _q_ =
          caml_call1(Sexplib0_Sexp_conv[7], cst_Async_scheduler_is_unusabl);
       return caml_call1(Core[253], _q_);
      }];
    return 0;
   }
   function reset_in_forked_process(param){
    if(debug) caml_call1(Async_kernel_Debug[16], cst_reset_in_forked_process);
    var _p_ = caml_call1(Async_kernel_Scheduler1[66], 0);
    Async_kernel_Scheduler1[69][1] = _p_;
    return 0;
   }
   function check_invariants(t){return t[26];}
   function set_check_invariants(t, b){t[26] = b; return 0;}
   function set_record_backtraces(t, b){t[28] = b; return 0;}
   function yield$0(t){return caml_call1(Async_kernel_Bvar[4], t[24]);}
   function yield_until_no_jobs_remain(opt, t){
    if(opt)
     var sth = opt[1], may_return_immediately = sth;
    else
     var may_return_immediately = 0;
    if(may_return_immediately){
     var _o_ = caml_call1(num_pending_jobs, t);
     if(caml_call2(Async_kernel_Import[3], _o_, 0))
      return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    return caml_call1(Async_kernel_Bvar[4], t[25]);
   }
   function yield_every(n){
    if(caml_call2(Async_kernel_Import[2], n, 0)){
     var
      _m_ = [0, [1, [0, _b_, [0, caml_call1(Core[356], n), 0]]], 0],
      _n_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Scheduler_yield_every_got_),
          _m_]];
     return caml_call1(Core[253], _n_);
    }
    if(caml_call2(Async_kernel_Import[3], n, 1))
     return caml_call1(Core[258], function(t){return yield$0(t);});
    var count_until_yield = [0, n];
    return caml_call1
            (Core[258],
             function(t){
              count_until_yield[1]--;
              return caml_call2
                       (Async_kernel_Import[4], count_until_yield[1], 0)
                      ? caml_call1(Async_kernel_Deferred_std[10], 0)
                      : (count_until_yield[1] = n, yield$0(t));
             });
   }
   function total_cycle_time(t){
    if(! t[11]) return t[18];
    var
     _k_ = t[10],
     _l_ = caml_call1(Async_kernel_Time_ns[50], 0),
     this_cycle_time = caml_call2(Async_kernel_Time_ns[57], _l_, _k_);
    return caml_call2(Core_Time_ns[1][97], t[18], this_cycle_time);
   }
   function run(t){
    var num_execs_before_yielding = 1000;
    for(;;){
     if(caml_call2(Async_kernel_Import[3], num_execs_before_yielding, 0))
      return yield_then_run(t);
     var _i_ = 1 - caml_call1(Core_Deque[16], t[5]);
     if(! _i_) return _i_;
     var worker = caml_call1(Core_Deque[61], t[5]);
     caml_call2(set_execution_context, t, worker[1]);
     a:
     {
      var num_execs_before_yielding$0 = num_execs_before_yielding;
      for(;;){
       if(! caml_call2(Core[246], t[7], worker[1]))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
       if(caml_call2(Async_kernel_Import[3], num_execs_before_yielding$0, 0)){caml_call2(Core_Deque[52], t[5], worker); return yield_then_run(t);}
       var num_execs_before_yielding$1 = num_execs_before_yielding$0 - 1 | 0;
       try{var val = caml_call1(worker[2], 0);}
       catch(exn$0){var exn = caml_wrap_exception(exn$0); break;}
       if(! val) break a;
       num_execs_before_yielding$0 = num_execs_before_yielding$1;
      }
      var
       bt = caml_call1(Base_Backtrace[6][4], 0),
       _j_ = caml_call1(Async_kernel_Monitor[5], 0);
      caml_call3(Async_kernel_Monitor[15], _j_, [0, [0, 936718974, bt]], exn);
      num_execs_before_yielding = num_execs_before_yielding$1;
      continue;
     }
     num_execs_before_yielding = num_execs_before_yielding$1;
    }
   }
   function yield_then_run(t){
    var _g_ = 1 - caml_call1(Core_Deque[16], t[5]);
    if(! _g_) return _g_;
    var _h_ = yield$0(t);
    return caml_call2
            (Async_kernel_Deferred1[8], _h_, function(param){return run(t);});
   }
   function enqueue$0(f){
    var
     t$0 = caml_call1(t, 0),
     queue = t$0[5],
     running = 1 - caml_call1(Core_Deque[16], queue),
     _e_ = caml_call1(current_execution_context, t$0),
     execution_context =
       caml_call4(Async_kernel_Execution_context[9], 0, _d_, 0, _e_);
    caml_call2(Core_Deque[53], queue, [0, execution_context, f]);
    var _f_ = 1 - running;
    return _f_ ? caml_call4(enqueue, t$0, execution_context, run, t$0) : _f_;
   }
   var For_bench = [0, advance_clock];
   function in_cycle(t){return t[11];}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Scheduler);
   var
    Async_kernel_Scheduler =
      [0,
       sexp_of_t,
       t,
       invariant,
       current_execution_context,
       with_execution_context,
       with_execution_context1,
       set_execution_context,
       enqueue,
       create_job,
       enqueue_job,
       free_job,
       main_execution_context,
       cycle_start,
       run_cycle,
       run_cycles_until_no_jobs_remai,
       has_upcoming_event,
       next_upcoming_event,
       next_upcoming_event_exn,
       event_precision,
       uncaught_exn,
       uncaught_exn_unwrapped,
       num_pending_jobs,
       num_jobs_run,
       last_cycle_num_jobs,
       map_cycle_times,
       cycle_num_jobs,
       cycle_count,
       total_cycle_time,
       max_num_jobs_per_priority_per_,
       set_max_num_jobs_per_priority_,
       set_check_access,
       check_access,
       check_invariants,
       set_check_invariants,
       set_record_backtraces,
       run_every_cycle_start,
       run_every_cycle_end,
       add_every_cycle_start_hook,
       add_every_cycle_end_hook,
       remove_every_cycle_start_hook_,
       remove_every_cycle_end_hook_ex,
       last_cycle_time,
       long_cycles,
       can_run_a_job,
       create_alarm,
       add_finalizer,
       add_finalizer_exn,
       add_finalizer_last,
       add_finalizer_last_exn,
       set_thread_safe_external_job_h,
       set_job_queued_hook,
       set_event_added_hook,
       thread_safe_enqueue_external_j,
       force_current_cycle_to_end,
       within,
       within$0,
       within_v,
       schedule,
       schedule$0,
       preserve_execution_context,
       preserve_execution_context$0,
       within_context,
       find_local,
       with_local,
       make_async_unusable,
       reset_in_forked_process,
       yield$0,
       yield_every,
       yield_until_no_jobs_remain,
       [0, Very_low_priority_worker[1], enqueue$0],
       For_bench,
       in_cycle];
   runtime.caml_register_global
    (61, Async_kernel_Scheduler, cst_Async_kernel_Scheduler);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Cycle_hook
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Cycle_hook = "Async_kernel__Cycle_hook",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Cycle_hook);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/cycle_hook.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var Handle = [0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Cycle_hook);
   var Async_kernel_Cycle_hook = [0, Handle];
   runtime.caml_register_global
    (11, Async_kernel_Cycle_hook, cst_Async_kernel_Cycle_hook);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_kernel_scheduler
//# unitInfo: Requires: Async_kernel__Scheduler, Async_kernel__Time_ns, Base__Staged, Core, Core__Time_ns, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_kernel_ = "Async_kernel__Async_kernel_scheduler",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Staged = global_data.Base__Staged,
    Core = global_data.Core,
    Core_Time_ns = global_data.Core__Time_ns,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_kernel_);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/async_kernel_scheduler.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    t = Async_kernel_Scheduler[2],
    with_execution_context = Async_kernel_Scheduler[5],
    with_execution_context1 = Async_kernel_Scheduler[6],
    enqueue = Async_kernel_Scheduler[8],
    run_cycles_until_no_jobs_remai = Async_kernel_Scheduler[15],
    last_cycle_num_jobs = Async_kernel_Scheduler[24],
    map_cycle_times = Async_kernel_Scheduler[25],
    run_every_cycle_start = Async_kernel_Scheduler[36],
    run_every_cycle_end = Async_kernel_Scheduler[37],
    add_every_cycle_start_hook = Async_kernel_Scheduler[38],
    add_every_cycle_end_hook = Async_kernel_Scheduler[39],
    remove_every_cycle_start_hook_ = Async_kernel_Scheduler[40],
    remove_every_cycle_end_hook_ex = Async_kernel_Scheduler[41],
    thread_safe_enqueue_external_j = Async_kernel_Scheduler[53],
    within = Async_kernel_Scheduler[55],
    within$0 = Async_kernel_Scheduler[56],
    within_v = Async_kernel_Scheduler[57],
    schedule = Async_kernel_Scheduler[58],
    schedule$0 = Async_kernel_Scheduler[59],
    preserve_execution_context = Async_kernel_Scheduler[60],
    preserve_execution_context$0 = Async_kernel_Scheduler[61],
    within_context = Async_kernel_Scheduler[62],
    find_local = Async_kernel_Scheduler[63],
    with_local = Async_kernel_Scheduler[64],
    _a_ = Async_kernel_Scheduler[4],
    _b_ = Async_kernel_Scheduler[13],
    _c_ = Async_kernel_Scheduler[19],
    _d_ = Async_kernel_Scheduler[22],
    _e_ = Async_kernel_Scheduler[23],
    _f_ = Async_kernel_Scheduler[27],
    _g_ = Async_kernel_Scheduler[28],
    _h_ = Async_kernel_Scheduler[29],
    _i_ = Async_kernel_Scheduler[30],
    _j_ = Async_kernel_Scheduler[35],
    _k_ = Async_kernel_Scheduler[42],
    _l_ = Async_kernel_Scheduler[43],
    _m_ = Async_kernel_Scheduler[54],
    _n_ = Async_kernel_Scheduler[67],
    _o_ = Async_kernel_Scheduler[68],
    _p_ = Async_kernel_Scheduler[69];
   function enqueue_job(execution_context, f, a){
    return caml_call4(enqueue, caml_call1(t, 0), execution_context, f, a);
   }
   function thread_safe_enqueue_job(execution_context, f, a){
    return caml_call4
            (thread_safe_enqueue_external_j,
             caml_call1(t, 0),
             execution_context,
             f,
             a);
   }
   function current_execution_context(param){
    return caml_call1(_a_, caml_call1(t, 0));
   }
   function cycle_count(param){return caml_call1(_f_, caml_call1(t, 0));}
   function cycle_start_ns(param){return caml_call1(_b_, caml_call1(t, 0));}
   function cycle_start(param){
    var _u_ = cycle_start_ns(0);
    return caml_call1(Async_kernel_Time_ns[70], _u_);
   }
   function cycle_times_ns(param){
    return caml_call2
            (map_cycle_times, caml_call1(t, 0), function(_t_){return _t_;});
   }
   function cycle_times(param){
    var _s_ = Core_Time_ns[1][134];
    return caml_call2(map_cycle_times, caml_call1(t, 0), _s_);
   }
   function total_cycle_time(param){return caml_call1(_g_, caml_call1(t, 0));}
   function last_cycle_time(param){return caml_call1(_k_, caml_call1(t, 0));}
   function long_cycles(at_least){
    return caml_call2(_l_, caml_call1(t, 0), at_least);
   }
   function event_precision_ns(param){
    return caml_call1(_c_, caml_call1(t, 0));
   }
   function event_precision(param){
    var _r_ = event_precision_ns(0);
    return caml_call1(Core_Time_ns[1][134], _r_);
   }
   function set_max_num_jobs_per_priority_(i){
    return caml_call2(_i_, caml_call1(t, 0), i);
   }
   function max_num_jobs_per_priority_per_(param){return caml_call1(_h_, caml_call1(t, 0));
   }
   function set_record_backtraces(bool){
    return caml_call2(_j_, caml_call1(t, 0), bool);
   }
   function force_current_cycle_to_end(param){return caml_call1(_m_, caml_call1(t, 0));
   }
   function yield$0(param){return caml_call1(_n_, caml_call1(t, 0));}
   function yield_until_no_jobs_remain(may_return_immediately, param){return caml_call2(_p_, may_return_immediately, caml_call1(t, 0));
   }
   function yield_every(n){
    var
     _q_ = caml_call1(_o_, n),
     yield_every = caml_call1(Base_Staged[2], _q_),
     t$0 = caml_call1(t, 0);
    return caml_call1
            (Core[258], function(param){return caml_call1(yield_every, t$0);});
   }
   function num_jobs_run(param){return caml_call1(_e_, caml_call1(t, 0));}
   function num_pending_jobs(param){return caml_call1(_d_, caml_call1(t, 0));}
   function last_cycle_num_jobs$0(param){
    return caml_call1(last_cycle_num_jobs, caml_call1(t, 0));
   }
   function run_every_cycle_start$0(f){
    return caml_call2(run_every_cycle_start, caml_call1(t, 0), f);
   }
   function run_every_cycle_end$0(f){
    return caml_call2(run_every_cycle_end, caml_call1(t, 0), f);
   }
   function add_every_cycle_start_hook$0(f){
    return caml_call2(add_every_cycle_start_hook, caml_call1(t, 0), f);
   }
   function add_every_cycle_end_hook$0(f){
    return caml_call2(add_every_cycle_end_hook, caml_call1(t, 0), f);
   }
   function remove_every_cycle_start_hook_$0(handle){
    return caml_call2
            (remove_every_cycle_start_hook_, caml_call1(t, 0), handle);
   }
   function remove_every_cycle_end_hook_ex$0(handle){
    return caml_call2
            (remove_every_cycle_end_hook_ex, caml_call1(t, 0), handle);
   }
   function with_execution_context$0(execution_context, f){
    return caml_call3
            (with_execution_context, caml_call1(t, 0), execution_context, f);
   }
   function with_execution_context1$0(execution_context, f, x){
    return caml_call4
            (with_execution_context1,
             caml_call1(t, 0),
             execution_context,
             f,
             x);
   }
   var
    Expert =
      [0,
       run_cycles_until_no_jobs_remai,
       last_cycle_num_jobs$0,
       run_every_cycle_start$0,
       run_every_cycle_end$0,
       add_every_cycle_start_hook$0,
       add_every_cycle_end_hook$0,
       remove_every_cycle_start_hook_$0,
       remove_every_cycle_end_hook_ex$0,
       with_execution_context$0,
       with_execution_context1$0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_kernel_);
   var
    Async_kernel_Async_kernel_sche =
      [0,
       current_execution_context,
       within_context,
       within,
       within$0,
       within_v,
       with_local,
       find_local,
       schedule,
       schedule$0,
       enqueue_job,
       thread_safe_enqueue_job,
       preserve_execution_context,
       preserve_execution_context$0,
       cycle_start,
       cycle_start_ns,
       cycle_times,
       cycle_times_ns,
       last_cycle_time,
       long_cycles,
       cycle_count,
       total_cycle_time,
       event_precision,
       event_precision_ns,
       force_current_cycle_to_end,
       set_max_num_jobs_per_priority_,
       max_num_jobs_per_priority_per_,
       set_record_backtraces,
       yield$0,
       yield_until_no_jobs_remain,
       yield_every,
       num_jobs_run,
       num_pending_jobs,
       Expert];
   runtime.caml_register_global
    (16, Async_kernel_Async_kernel_sche, cst_Async_kernel_Async_kernel_);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Clock_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_compare_lib, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Clock_intf = "Async_kernel__Clock_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_compare_lib = global_data.Ppx_compare_lib,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Clock_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/clock_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, "Timeout"], _b_ = [0, "Result"];
   function compare(cmp_a, a_001, b_002){
    if(caml_call2(Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(typeof a_001 === "number"){
     if(642269825 === b_002) return 0;
    }
    else if(typeof b_002 !== "number" && 1025039613 === b_002[1]){
     var right_004 = b_002[2], left_003 = a_001[2];
     return caml_call2(cmp_a, left_003, right_004);
    }
    return runtime.caml_compare(a_001, b_002);
   }
   function sexp_of_t(of_a_005, param){
    if(typeof param === "number") return _a_;
    var v_006 = param[2];
    return [1, [0, _b_, [0, caml_call1(of_a_005, v_006), 0]]];
   }
   var Or_timeout = [0, compare, sexp_of_t];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Clock_intf);
   var Async_kernel_Clock_intf = [0, Or_timeout];
   runtime.caml_register_global
    (14, Async_kernel_Clock_intf, cst_Async_kernel_Clock_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Clock_ns
//# unitInfo: Requires: Async_kernel__Scheduler1, Async_kernel__Time_source, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Clock_ns = "Async_kernel__Clock_ns",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Time_source = global_data.Async_kernel__Time_source,
    Async_kernel_Scheduler1 = global_data.Async_kernel__Scheduler1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Clock_ns);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/clock_ns.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function time_source(param){
    var _q_ = caml_call1(Async_kernel_Scheduler1[71], 0)[19];
    return caml_call1(Async_kernel_Time_source[39], _q_);
   }
   function after(span){
    var _p_ = time_source(0);
    return caml_call2(Async_kernel_Time_source[29], _p_, span);
   }
   function at(time){
    var _o_ = time_source(0);
    return caml_call2(Async_kernel_Time_source[28], _o_, time);
   }
   function at_varying_intervals(stop, compute_span){
    var _n_ = time_source(0);
    return caml_call3(Async_kernel_Time_source[33], stop, _n_, compute_span);
   }
   function at_intervals(start, stop, interval){
    var _m_ = time_source(0);
    return caml_call4
            (Async_kernel_Time_source[34], start, stop, _m_, interval);
   }
   function every(start, stop, continue_on_error, finished, span, f){
    var _l_ = time_source(0);
    return caml_call7
            (Async_kernel_Time_source[35],
             start,
             stop,
             continue_on_error,
             finished,
             _l_,
             span,
             f);
   }
   function every$0(start, stop, continue_on_error, span, f){
    var _k_ = time_source(0);
    return caml_call6
            (Async_kernel_Time_source[36],
             start,
             stop,
             continue_on_error,
             _k_,
             span,
             f);
   }
   function run_after(span, f, a){
    var _j_ = time_source(0);
    return caml_call4(Async_kernel_Time_source[27], _j_, span, f, a);
   }
   function run_at(time, f, a){
    var _i_ = time_source(0);
    return caml_call4(Async_kernel_Time_source[26], _i_, time, f, a);
   }
   function run_at_intervals(start, stop, continue_on_error, interval, f){
    var _h_ = time_source(0);
    return caml_call6
            (Async_kernel_Time_source[38],
             start,
             stop,
             continue_on_error,
             _h_,
             interval,
             f);
   }
   function run_at_intervals$0(start, stop, continue_on_error, interval, f){
    var _g_ = time_source(0);
    return caml_call6
            (Async_kernel_Time_source[37],
             start,
             stop,
             continue_on_error,
             _g_,
             interval,
             f);
   }
   function with_timeout(span, d){
    var _f_ = time_source(0);
    return caml_call3(Async_kernel_Time_source[30], _f_, span, d);
   }
   function duration_of(f){
    var _e_ = time_source(0);
    return caml_call2(Async_kernel_Time_source[31], _e_, f);
   }
   var
    include = Async_kernel_Time_source[32],
    sexp_of_t = include[1],
    sexp_of_t_unit = include[2],
    invariant = include[3],
    scheduled_at = include[4],
    Status = include[5],
    status = include[6],
    abort = include[10],
    abort_exn = include[11],
    abort_if_possible = include[12],
    fired = include[14],
    reschedule_at = include[16],
    reschedule_after = include[17],
    _a_ = include[7],
    _b_ = include[8],
    _c_ = include[18],
    _d_ = include[19];
   function after$0(span){return caml_call2(_d_, time_source(0), span);}
   function run_after$0(span, f, a){
    return caml_call4(_b_, time_source(0), span, f, a);
   }
   function at$0(time){return caml_call2(_c_, time_source(0), time);}
   function run_at$0(time, f, z){
    return caml_call4(_a_, time_source(0), time, f, z);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Clock_ns);
   var
    Async_kernel_Clock_ns =
      [0,
       run_at,
       run_after,
       at,
       after,
       with_timeout,
       [0,
        sexp_of_t,
        sexp_of_t_unit,
        invariant,
        scheduled_at,
        Status,
        status,
        run_at$0,
        run_after$0,
        abort,
        abort_exn,
        abort_if_possible,
        fired,
        reschedule_at,
        reschedule_after,
        at$0,
        after$0],
       at_varying_intervals,
       at_intervals,
       every,
       every$0,
       run_at_intervals$0,
       run_at_intervals,
       duration_of];
   runtime.caml_register_global
    (13, Async_kernel_Clock_ns, cst_Async_kernel_Clock_ns);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_array
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Throttle, Core, Core__Array, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_arra = "Async_kernel__Deferred_array",
    cst_async_kernel = "async_kernel",
    caml_check_bound = runtime.caml_check_bound;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Array = global_data.Core__Array,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Core = global_data.Core,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_List = global_data.Core__List,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_arra);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_array.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, 0], _b_ = [0, 0];
   function foldi(t, init, f){
    return caml_call1
            (Async_kernel_Deferred1[4],
             function(result){
              function loop(i, b){
               if(caml_call2(Core[90], i, t.length - 1))
                return caml_call2(Async_kernel_Ivar[14], result, b);
               var _y_ = caml_call3(f, i, b, caml_check_bound(t, i)[1 + i]);
               return caml_call2
                       (Async_kernel_Deferred_std[1],
                        _y_,
                        function(b){return loop(i + 1 | 0, b);});
              }
              return loop(0, init);
             });
   }
   function fold(t, init, f){
    return foldi(t, init, function(param, a, x){return caml_call2(f, a, x);});
   }
   function seqmapi(t, f){
    var
     _v_ =
       foldi
        (t,
         0,
         function(i, bs, a){
          var _x_ = caml_call2(f, i, a);
          return caml_call2
                  (Async_kernel_Deferred_std[4],
                   _x_,
                   function(b){return [0, b, bs];});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _v_,
             function(bs){
              var _w_ = caml_call1(Core_List[34], bs);
              return caml_call1(Core_Array[52], _w_);
             });
   }
   function all(ds){return seqmapi(ds, function(param, x){return x;});}
   function all_unit(ds){
    var _u_ = fold(ds, 0, function(param, d){return d;});
    return caml_call1(Async_kernel_Deferred1[20], _u_);
   }
   function iteri(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how)
     return foldi(t, 0, function(i, param, x){return caml_call2(f, i, x);});
    var
     _s_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _t_ = caml_call1(Core[259], _s_);
    return all_unit(caml_call2(Core_Array[59], t, _t_));
   }
   function mapi(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how) return seqmapi(t, f);
    var
     _q_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _r_ = caml_call1(Core[259], _q_);
    return all(caml_call2(Core_Array[59], t, _r_));
   }
   function filteri(how, t, f){
    var _o_ = mapi(how, t, f);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _o_,
             function(bools){
              var
               _p_ =
                 caml_call4
                  (Core_Array[82],
                   t,
                   bools,
                   0,
                   function(ac, x, b){return b ? [0, x, ac] : ac;});
              return caml_call1(Core_Array[90], _p_);
             });
   }
   function filter_mapi(how, t, f){
    var _m_ = Core_Array[74], _n_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _n_, _m_);
   }
   function concat_mapi(how, t, f){
    var _k_ = mapi(how, t, f);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _k_,
             function(t){
              var _l_ = caml_call1(Core_Array[32], t);
              return caml_call1(Core_Array[44], _l_);
             });
   }
   function find_mapi(t, f){
    function aux(i){
     if(caml_call2(Core[90], i, t.length - 1))
      return caml_call1(Async_kernel_Deferred_std[10], 0);
     var _j_ = caml_call2(f, i, caml_check_bound(t, i)[1 + i]);
     return caml_call2
             (Async_kernel_Deferred_std[5][1],
              _j_,
              function(some){
               return some
                       ? caml_call1(Async_kernel_Deferred_std[10], some)
                       : aux(i + 1 | 0);
              });
    }
    return aux(0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              var _i_ = caml_call2(f, i, elt);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _i_,
                       function(b){return b ? [0, [0, i, elt]] : 0;});
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              var _h_ = caml_call1(f, elt);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _h_,
                       function(b){return b ? [0, elt] : 0;});
             });
   }
   function existsi(t, f){
    var
     _f_ =
       find_mapi
        (t,
         function(i, elt){
          var _g_ = caml_call2(f, i, elt);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _g_,
                   function(b){return b ? _a_ : 0;});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _f_,
             function(param){return param ? 1 : 0;});
   }
   function for_alli(t, f){
    var
     _d_ =
       find_mapi
        (t,
         function(i, elt){
          var _e_ = caml_call2(f, i, elt);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _e_,
                   function(b){return b ? 0 : _b_;});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _d_,
             function(param){return param ? 0 : 1;});
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    return map
            (how,
             caml_call2(Core_Array[40], n, function(_c_){return _c_;}),
             f);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_arra);
   var
    Async_kernel_Deferred_array =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (20, Async_kernel_Deferred_array, cst_Async_kernel_Deferred_arra);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_list
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Throttle, Core, Core__List, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_list = "Async_kernel__Deferred_list",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_List = global_data.Core__List,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Core = global_data.Core,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_list);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_list.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, 0], _b_ = [0, 0];
   function foldi(t, init, f){
    return caml_call1
            (Async_kernel_Deferred1[4],
             function(result){
              function loop(t, i, b){
               if(! t) return caml_call2(Async_kernel_Ivar[14], result, b);
               var xs = t[2], x = t[1], _y_ = caml_call3(f, i, b, x);
               return caml_call2
                       (Async_kernel_Deferred_std[1],
                        _y_,
                        function(b){return loop(xs, i + 1 | 0, b);});
              }
              return loop(t, 0, init);
             });
   }
   function fold(t, init, f){
    return foldi(t, init, function(param, a, x){return caml_call2(f, a, x);});
   }
   function seqmapi(t, f){
    var
     _v_ = Core_List[34],
     _w_ =
       foldi
        (t,
         0,
         function(i, bs, a){
          var _x_ = caml_call2(f, i, a);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _x_,
                   function(b){return [0, b, bs];});
         });
    return caml_call2(Async_kernel_Deferred_std[4], _w_, _v_);
   }
   function all(ds){return seqmapi(ds, function(param, x){return x;});}
   function all_unit(ds){
    var _u_ = fold(ds, 0, function(param, d){return d;});
    return caml_call1(Async_kernel_Deferred1[20], _u_);
   }
   function iteri(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how)
     return foldi(t, 0, function(i, param, x){return caml_call2(f, i, x);});
    var
     _s_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _t_ = caml_call1(Core[259], _s_);
    return all_unit(caml_call2(Core_List[92], t, _t_));
   }
   function mapi(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how) return seqmapi(t, f);
    var
     _q_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _r_ = caml_call1(Core[259], _q_);
    return all(caml_call2(Core_List[92], t, _r_));
   }
   function filteri(how, t, f){
    var _o_ = mapi(how, t, f);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _o_,
             function(bools){
              var
               _p_ =
                 caml_call4
                  (Core_List[42],
                   t,
                   bools,
                   0,
                   function(ac, x, b){return b ? [0, x, ac] : ac;});
              return caml_call1(Core_List[34], _p_);
             });
   }
   function filter_mapi(how, t, f){
    var _m_ = Core_List[124], _n_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _n_, _m_);
   }
   function concat_mapi(how, t, f){
    var _k_ = Core_List[133], _l_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _l_, _k_);
   }
   function find_mapi(t, f){
    function find_mapi(t, f, i){
     if(! t) return caml_call1(Async_kernel_Deferred_std[10], 0);
     var tl = t[2], hd = t[1], _j_ = caml_call2(f, i, hd);
     return caml_call2
             (Async_kernel_Deferred_std[5][1],
              _j_,
              function(some){
               return some
                       ? caml_call1(Async_kernel_Deferred_std[10], some)
                       : find_mapi(tl, f, i + 1 | 0);
              });
    }
    return find_mapi(t, f, 0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              var _i_ = caml_call2(f, i, elt);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _i_,
                       function(b){return b ? [0, [0, i, elt]] : 0;});
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              var _h_ = caml_call1(f, elt);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _h_,
                       function(b){return b ? [0, elt] : 0;});
             });
   }
   function existsi(t, f){
    var
     _f_ =
       find_mapi
        (t,
         function(i, elt){
          var _g_ = caml_call2(f, i, elt);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _g_,
                   function(b){return b ? _a_ : 0;});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _f_,
             function(param){return param ? 1 : 0;});
   }
   function for_alli(t, f){
    var
     _d_ =
       find_mapi
        (t,
         function(i, elt){
          var _e_ = caml_call2(f, i, elt);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _e_,
                   function(b){return b ? 0 : _b_;});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _d_,
             function(param){return param ? 0 : 1;});
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    return map
            (how,
             caml_call2(Core_List[119], n, function(_c_){return _c_;}),
             f);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_list);
   var
    Async_kernel_Deferred_list =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (19, Async_kernel_Deferred_list, cst_Async_kernel_Deferred_list);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_map
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_list, Async_kernel__Deferred_std, Async_kernel__Ivar, Base__Field, Base__List, Base__Map, Core__Map, Core__Sequence, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_map = "Async_kernel__Deferred_map",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Map = global_data.Core__Map,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Base_List = global_data.Base__List,
    Async_kernel_Deferred_list = global_data.Async_kernel__Deferred_list,
    Base_Map = global_data.Base__Map,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core_Sequence = global_data.Core__Sequence,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_map);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_map.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, -542431297];
   function change(t, k, f){
    var _q_ = caml_call1(f, caml_call2(Core_Map[38], t, k));
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _q_,
             function(opt){
              return caml_call3
                      (Core_Map[36], t, k, function(param){return opt;});
             });
   }
   function update(t, k, f){
    var _p_ = caml_call1(f, caml_call2(Core_Map[38], t, k));
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _p_,
             function(data){return caml_call3(Core_Map[32], t, k, data);});
   }
   function iter_keys(how, t, f){
    var _o_ = caml_call1(Core_Map[72], t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _o_, f);
   }
   function iter(how, t, f){
    var _n_ = caml_call1(Core_Map[73], t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _n_, f);
   }
   function iteri(how, t, f){
    var _m_ = caml_call2(Core_Map[74], 0, t);
    return caml_call3
            (Async_kernel_Deferred_list[14],
             how,
             _m_,
             function(param){
              var data = param[2], key = param[1];
              return caml_call2(f, key, data);
             });
   }
   function fold(t, init, f){
    var
     alist_in_increasing_key_order =
       caml_call3
        (Core_Map[57],
         t,
         0,
         function(key, data, alist){return [0, [0, key, data], alist];});
    return caml_call3
            (Async_kernel_Deferred_list[2],
             alist_in_increasing_key_order,
             init,
             function(ac, param){
              var data = param[2], key = param[1];
              return caml_call3(f, key, data, ac);
             });
   }
   function fold_right(t, init, f){
    var
     alist_in_decreasing_key_order =
       caml_call3
        (Core_Map[55],
         t,
         0,
         function(key, data, alist){return [0, [0, key, data], alist];});
    return caml_call3
            (Async_kernel_Deferred_list[2],
             alist_in_decreasing_key_order,
             init,
             function(ac, param){
              var data = param[2], key = param[1];
              return caml_call3(f, key, data, ac);
             });
   }
   function result(r){return r[3];}
   function filter_mapi(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how){
     var
      comparator = caml_call1(Core_Map[2], t),
      sequence = caml_call4(Core_Map[101], _a_, 0, 0, t);
     return caml_call1
             (Async_kernel_Deferred1[4],
              function(ivar){
               return caml_call4
                       (Core_Sequence[105],
                        sequence,
                        Base_Map[104][3][96][1],
                        function(s, param, k){
                         var
                          data = param[2],
                          key = param[1],
                          _l_ = caml_call2(f, key, data);
                         return caml_call2
                                 (Async_kernel_Deferred_std[11],
                                  _l_,
                                  function(param){
                                   if(! param) return caml_call1(k, s);
                                   var
                                    data = param[1],
                                    s$0 =
                                      caml_call4
                                       (Base_Map[104][3][96][2], s, comparator, key, data);
                                   return caml_call1(k, s$0);
                                  });
                        },
                        function(x){
                         var
                          _j_ = caml_call1(Base_Map[104][3][96][3], x),
                          _k_ = caml_call2(Core_Map[110][23], comparator, _j_);
                         return caml_call2(Async_kernel_Ivar[14], ivar, _k_);
                        });
              });
    }
    var
     jobs = [0, 0],
     job_map =
       caml_call2
        (Core_Map[52],
         t,
         function(key, data){
          var job = [0, key, data, 0];
          jobs[1] = [0, job, jobs[1]];
          return job;
         }),
     _g_ = caml_call1(Base_List[38], jobs[1]),
     _h_ =
       caml_call3
        (Async_kernel_Deferred_list[14],
         [0, how],
         _g_,
         function(job){
          var data = job[2], key = job[1], _i_ = caml_call2(f, key, data);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _i_,
                   function(x){job[3] = x; return 0;});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _h_,
             function(param){
              return caml_call2(Core_Map[62], job_map, result);
             });
   }
   function filter_map(how, t, f){
    return filter_mapi
            (how, t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys(how, t, f){
    return filter_mapi
            (how,
             t,
             function(key, data){
              var _f_ = caml_call1(f, key);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _f_,
                       function(b){return b ? [0, data] : 0;});
             });
   }
   function filter(how, t, f){
    return filter_mapi
            (how,
             t,
             function(param, data){
              var _e_ = caml_call1(f, data);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _e_,
                       function(b){return b ? [0, data] : 0;});
             });
   }
   function filteri(how, t, f){
    return filter_mapi
            (how,
             t,
             function(key, data){
              var _d_ = caml_call2(f, key, data);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _d_,
                       function(b){return b ? [0, data] : 0;});
             });
   }
   function mapi(how, t, f){
    return filter_mapi
            (how,
             t,
             function(key, data){
              var _c_ = caml_call2(f, key, data);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _c_,
                       function(z){return [0, z];});
             });
   }
   function map(how, t, f){
    return mapi(how, t, function(param, data){return caml_call1(f, data);});
   }
   function merge(how, t1, t2, f){
    return filter_map
            (how,
             caml_call3
              (Core_Map[77],
               t1,
               t2,
               function(key, z){
                return [0, function(param){return caml_call2(f, key, z);}];
               }),
             function(thunk){return caml_call1(thunk, 0);});
   }
   function all(t){return map(0, t, function(_b_){return _b_;});}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_map);
   var
    Async_kernel_Deferred_map =
      [0,
       change,
       update,
       iter_keys,
       iter,
       iteri,
       map,
       mapi,
       fold,
       fold_right,
       filter_keys,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       merge,
       all];
   runtime.caml_register_global
    (25, Async_kernel_Deferred_map, cst_Async_kernel_Deferred_map);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_memo
//# unitInfo: Requires: Async_kernel__Deferred_std, Async_kernel__Monitor, Base__Exn, Base__Staged, Core__Memo, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_memo = "Async_kernel__Deferred_memo",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core_Memo = global_data.Core__Memo,
    Base_Staged = global_data.Base__Staged,
    Base_Exn = global_data.Base__Exn,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_memo);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_memo.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    cst_caught_exception_in_memoiz = "caught exception in memoized function",
    _a_ = [0, 3804260],
    _b_ = [0, 3903734],
    _c_ = [0, 3804260],
    _d_ = [0, 3903734];
   function reraise(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var exn = param[1];
    return caml_call2(Base_Exn[8], exn, cst_caught_exception_in_memoiz);
   }
   function general(hashable, f){
    var
     f$0 =
       caml_call3
        (Core_Memo[1],
         [0, hashable[4]],
         0,
         function(a){
          return caml_call7
                  (Async_kernel_Monitor[16],
                   0,
                   0,
                   0,
                   0,
                   _b_,
                   _a_,
                   function(param){return caml_call1(f, a);});
         });
    return caml_call1
            (Base_Staged[1],
             function(a){
              var _f_ = caml_call1(f$0, a);
              return caml_call2(Async_kernel_Deferred_std[4], _f_, reraise);
             });
   }
   function unit(f){
    var
     f$0 =
       caml_call1
        (Core_Memo[3],
         function(param){
          return caml_call7(Async_kernel_Monitor[16], 0, 0, 0, 0, _d_, _c_, f);
         });
    return caml_call1
            (Base_Staged[1],
             function(param){
              var _e_ = caml_call1(f$0, 0);
              return caml_call2(Async_kernel_Deferred_std[4], _e_, reraise);
             });
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_memo);
   var Async_kernel_Deferred_memo = [0, general, unit];
   runtime.caml_register_global
    (21, Async_kernel_Deferred_memo, cst_Async_kernel_Deferred_memo);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_option
//# unitInfo: Requires: Async_kernel__Deferred1, Base__Monad, Core__Option, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_opti = "Async_kernel__Deferred_option",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Option = global_data.Core__Option,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_opti);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_option.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function return$0(a){
    return caml_call1(Async_kernel_Deferred1[21], [0, a]);
   }
   function bind(t, f){
    return caml_call2
            (Async_kernel_Deferred1[17],
             t,
             function(param){
              if(! param) return caml_call1(Async_kernel_Deferred1[21], 0);
              var a = param[1];
              return caml_call1(f, a);
             });
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        return caml_call2
                (Async_kernel_Deferred1[18],
                 t,
                 function(r){return caml_call2(Core_Option[29], r, f);});
       }],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_opti);
   var
    Async_kernel_Deferred_option =
      [0,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax];
   runtime.caml_register_global
    (14, Async_kernel_Deferred_option, cst_Async_kernel_Deferred_opti);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_result
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_std, Base__Monad, Core__Printf, Core__Result, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_resu = "Async_kernel__Deferred_result",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Result = global_data.Core__Result,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_Printf = global_data.Core__Printf,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_resu);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_result.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function combine(t1, t2, ok, err){
    var _a_ = caml_call2(Async_kernel_Deferred_std[5][3], t1, t2);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _a_,
             function(param){
              var t2 = param[2], t1 = param[1];
              return caml_call4(Core_Result[40], t1, t2, ok, err);
             });
   }
   function return$0(a){
    return caml_call1(Async_kernel_Deferred1[21], [0, a]);
   }
   function bind(t, f){
    return caml_call2
            (Async_kernel_Deferred1[17],
             t,
             function(error){
              if(0 !== error[0])
               return caml_call1(Async_kernel_Deferred1[21], error);
              var a = error[1];
              return caml_call1(f, a);
             });
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        return caml_call2
                (Async_kernel_Deferred1[18],
                 t,
                 function(r){return caml_call2(Core_Result[38], r, f);});
       }],
    include = caml_call1(Base_Monad[2], [0, bind, map, return$0]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Let_syntax = include[3],
    Monad_infix = include[4],
    bind$0 = include[5],
    return$1 = include[6],
    map$0 = include[7],
    join = include[8],
    ignore_m = include[9],
    all = include[10],
    all_unit = include[11];
   function fail(x){return caml_call1(Async_kernel_Deferred1[21], [1, x]);}
   function failf(format){return caml_call2(Core_Printf[4], fail, format);}
   function map_error(t, f){
    return caml_call2
            (Async_kernel_Deferred1[18],
             t,
             function(r){return caml_call2(Core_Result[39], r, f);});
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_resu);
   var
    Async_kernel_Deferred_result =
      [0,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       fail,
       failf,
       map_error,
       combine];
   runtime.caml_register_global
    (16, Async_kernel_Deferred_result, cst_Async_kernel_Deferred_resu);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_or_error
//# unitInfo: Requires: Async_kernel__Deferred1, Async_kernel__Deferred_result, Async_kernel__Monitor, Async_kernel__Throttle, Base__Applicative, Core, Core__Error, Core__List, Core__Or_error, Core__Result, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_or_e = "Async_kernel__Deferred_or_error",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_List = global_data.Core__List,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Core = global_data.Core,
    Core_Or_error = global_data.Core__Or_error,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1,
    Core_Error = global_data.Core__Error,
    Core_Result = global_data.Core__Result,
    Async_kernel_Deferred_result = global_data.Async_kernel__Deferred_result,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Base_Applicative = global_data.Base__Applicative;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_or_e);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_or_error.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    try_with = Async_kernel_Monitor[16],
    ignore_m = Async_kernel_Deferred_result[9],
    join = Async_kernel_Deferred_result[8],
    return$0 = Async_kernel_Deferred_result[6],
    bind = Async_kernel_Deferred_result[5],
    Monad_infix = Async_kernel_Deferred_result[4],
    symbol_bind = Async_kernel_Deferred_result[1];
   function apply(f, x){
    return caml_call4
            (Async_kernel_Deferred_result[15],
             f,
             x,
             function(f, x){return caml_call1(f, x);},
             function(e1, e2){
              return caml_call2(Core_Error[24], 0, [0, e1, [0, e2, 0]]);
             });
   }
   var
    map = [0, -198771759, Async_kernel_Deferred_result[7]],
    include = caml_call1(Base_Applicative[5], [0, return$0, apply, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol$1 = include[6],
    symbol_map = include[7],
    apply$0 = include[8],
    map2 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13],
    symbol_bind$0 = Monad_infix[1],
    symbol_map$0 = Monad_infix[2],
    Open_on_rhs = [0];
   function fail(error){
    var _G_ = caml_call1(Core_Result[27], error);
    return caml_call1(Async_kernel_Deferred1[21], _G_);
   }
   function ok_exn(t){
    return caml_call2(Async_kernel_Deferred1[18], t, Core_Or_error[36]);
   }
   function of_exn(exn){
    var _F_ = caml_call2(Core_Or_error[37], 0, exn);
    return caml_call1(Async_kernel_Deferred1[21], _F_);
   }
   function of_exn_result(t){
    var arg = Core_Or_error[38];
    return caml_call2
            (Async_kernel_Deferred1[18],
             t,
             function(eta){return caml_call2(arg, 0, eta);});
   }
   function error(msg, v, sexp_of){
    var _E_ = caml_call5(Core_Or_error[39], 0, 0, msg, v, sexp_of);
    return caml_call1(Async_kernel_Deferred1[21], _E_);
   }
   function error_s(sexp){
    var _D_ = caml_call1(Core_Or_error[40], sexp);
    return caml_call1(Async_kernel_Deferred1[21], _D_);
   }
   function error_string(msg){
    var _C_ = caml_call1(Core_Or_error[41], msg);
    return caml_call1(Async_kernel_Deferred1[21], _C_);
   }
   function errorf(format){
    return caml_call2(Core[244], error_string, format);
   }
   function tag(t, tag){
    var _A_ = Core_Or_error[43];
    return caml_call2
            (Async_kernel_Deferred1[18],
             t,
             function(_B_){return caml_call2(_A_, _B_, tag);});
   }
   function tag_s(t, tag){
    var _y_ = Core_Or_error[44];
    return caml_call2
            (Async_kernel_Deferred1[18],
             t,
             function(_z_){return caml_call2(_y_, _z_, tag);});
   }
   function tag_s_lazy(t, tag){
    var _w_ = Core_Or_error[45];
    return caml_call2
            (Async_kernel_Deferred1[18],
             t,
             function(_x_){return caml_call2(_w_, _x_, tag);});
   }
   function tag_arg(t, message, a, sexp_of_a){
    return caml_call2
            (Async_kernel_Deferred1[18],
             t,
             function(t){
              return caml_call4(Core_Or_error[46], t, message, a, sexp_of_a);
             });
   }
   function unimplemented(msg){
    var _v_ = caml_call1(Core_Or_error[47], msg);
    return caml_call1(Async_kernel_Deferred1[21], _v_);
   }
   function combine_errors(l){
    var
     _t_ = Core_Or_error[51],
     _u_ = caml_call1(Async_kernel_Deferred1[42], l);
    return caml_call2(Async_kernel_Deferred1[18], _u_, _t_);
   }
   function combine_errors_unit(l){
    var
     _r_ = Core_Or_error[52],
     _s_ = caml_call1(Async_kernel_Deferred1[42], l);
    return caml_call2(Async_kernel_Deferred1[18], _s_, _r_);
   }
   function filter_ok_at_least_one(l){
    var
     _p_ = Core_Or_error[53],
     _q_ = caml_call1(Async_kernel_Deferred1[42], l);
    return caml_call2(Async_kernel_Deferred1[18], _q_, _p_);
   }
   function find_map_ok(l, f){
    return caml_call2
            (Async_kernel_Deferred1[37],
             [0, l, 0],
             function(param){
              var errors = param[2], l = param[1];
              if(l){
               var tl = l[2], hd = l[1], _n_ = caml_call1(f, hd);
               return caml_call2
                       (Async_kernel_Deferred1[18],
                        _n_,
                        function(param){
                         if(0 === param[0]){
                          var result = param[1];
                          return [0, -289386606, [0, result]];
                         }
                         var current_error = param[1];
                         return [0, 990972795, [0, tl, [0, current_error, errors]]];
                        });
              }
              var
               _o_ = caml_call1(Core_List[34], errors),
               errors$0 = caml_call2(Core_Error[24], 0, _o_);
              return caml_call1
                      (Async_kernel_Deferred1[21], [0, -289386606, [1, errors$0]]);
             });
   }
   var ok_unit = caml_call1(return$1, 0), _a_ = [0, 0], _b_ = [0, 0];
   function try_with$0(extract_exn, run, rest, here, name, f){
    var _m_ = caml_call7(try_with, here, 0, name, extract_exn, run, rest, f);
    return caml_call2
            (Async_kernel_Deferred1[18],
             _m_,
             function(ok){
              if(0 === ok[0]) return ok;
              var exn = ok[1];
              return [1, caml_call2(Core_Error[25], 0, exn)];
             });
   }
   function try_with_join(extract_exn, run, rest, here, name, f){
    var
     _k_ = Core_Or_error[27],
     _l_ = try_with$0(extract_exn, run, rest, here, name, f);
    return caml_call2(Async_kernel_Deferred1[18], _l_, _k_);
   }
   function foldi(list, acc, f){
    function loop(i, acc, param){
     if(! param) return caml_call1(return$1, acc);
     var tl = param[2], hd = param[1];
     return caml_call2
             (bind,
              caml_call3(f, i, acc, hd),
              function(acc){return loop(i + 1 | 0, acc, tl);});
    }
    return loop(0, acc, list);
   }
   function fold(t, init, f){
    return foldi(t, init, function(param, a, x){return caml_call2(f, a, x);});
   }
   function iteri(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how)
     return foldi(t, 0, function(i, param, x){return caml_call2(f, i, x);});
    var
     _i_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _j_ = caml_call1(Core[259], _i_);
    return caml_call1(all_unit, caml_call2(Core_List[92], t, _j_));
   }
   function mapi(opt, t, f){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    if(typeof how === "number" && -676829465 > how){
     var _f_ = Core_List[34];
     return caml_call2
             (symbol_map$0,
              foldi
               (t,
                0,
                function(i, bs, a){
                 return caml_call2
                         (map$0,
                          caml_call2(f, i, a),
                          function(b){return [0, b, bs];});
                }),
              _f_);
    }
    var
     _g_ = caml_call2(Async_kernel_Throttle[11], how, f),
     _h_ = caml_call1(Core[259], _g_);
    return caml_call1(all, caml_call2(Core_List[92], t, _h_));
   }
   function filter_mapi(how, t, f){
    var _e_ = Core_List[124];
    return caml_call2(symbol_map$0, mapi(how, t, f), _e_);
   }
   function concat_mapi(how, t, f){
    var _d_ = Core_List[133];
    return caml_call2(symbol_map$0, mapi(how, t, f), _d_);
   }
   function filteri(how, t, f){
    return filter_mapi
            (how,
             t,
             function(i, x){
              return caml_call2
                      (map$0,
                       caml_call2(f, i, x),
                       function(b){return b ? [0, x] : 0;});
             });
   }
   function find_mapi(t, f){
    function find_mapi(t, f, i){
     if(! t) return caml_call1(return$1, 0);
     var tl = t[2], hd = t[1];
     return caml_call2
             (bind,
              caml_call2(f, i, hd),
              function(some){
               return some
                       ? caml_call1(return$1, some)
                       : find_mapi(tl, f, i + 1 | 0);
              });
    }
    return find_mapi(t, f, 0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              return caml_call2
                      (map$0,
                       caml_call2(f, i, elt),
                       function(b){return b ? [0, [0, i, elt]] : 0;});
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              return caml_call2
                      (map$0,
                       caml_call1(f, elt),
                       function(b){return b ? [0, elt] : 0;});
             });
   }
   function existsi(t, f){
    return caml_call2
            (map$0,
             find_mapi
              (t,
               function(i, elt){
                return caml_call2
                        (map$0,
                         caml_call2(f, i, elt),
                         function(b){return b ? _a_ : 0;});
               }),
             function(param){return param ? 1 : 0;});
   }
   function for_alli(t, f){
    return caml_call2
            (map$0,
             find_mapi
              (t,
               function(i, elt){
                return caml_call2
                        (map$0,
                         caml_call2(f, i, elt),
                         function(b){return b ? 0 : _b_;});
               }),
             function(param){return param ? 0 : 1;});
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map$1(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    return map$1
            (how,
             caml_call2(Core_List[119], n, function(_c_){return _c_;}),
             f);
   }
   function repeat_until_finished(state, f){
    return caml_call2
            (bind,
             caml_call1(f, state),
             function(param){
              if(990972795 <= param[1]){
               var state = param[2];
               return repeat_until_finished(state, f);
              }
              var state$0 = param[2];
              return caml_call1(return$1, state$0);
             });
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_or_e);
   var
    Async_kernel_Deferred_or_error =
      [0,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply$0,
       map2,
       map3,
       Applicative_infix,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       [0,
        return$1,
        symbol_bind$0,
        symbol_map$0,
        [0, return$1, bind, map$0, both, Open_on_rhs]],
       fail,
       ok_exn,
       of_exn,
       of_exn_result,
       error,
       error_s,
       error_string,
       errorf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       unimplemented,
       combine_errors,
       combine_errors_unit,
       filter_ok_at_least_one,
       find_map_ok,
       ok_unit,
       try_with$0,
       try_with_join,
       [0,
        foldi,
        fold,
        find,
        findi,
        find_map,
        find_mapi,
        exists,
        existsi,
        for_all,
        for_alli,
        all,
        all_unit,
        init,
        iter,
        iteri,
        map$1,
        mapi,
        filter,
        filteri,
        filter_map,
        filter_mapi,
        concat_map,
        concat_mapi],
       repeat_until_finished];
   runtime.caml_register_global
    (23, Async_kernel_Deferred_or_error, cst_Async_kernel_Deferred_or_e);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_queue
//# unitInfo: Requires: Async_kernel__Deferred_list, Async_kernel__Deferred_std, Core__Queue, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_queu = "Async_kernel__Deferred_queue",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Queue = global_data.Core__Queue,
    Async_kernel_Deferred_list = global_data.Async_kernel__Deferred_list,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_queu);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_queue.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function foldi(t, init, f){
    var _T_ = caml_call1(Core_Queue[26], t);
    return caml_call3(Async_kernel_Deferred_list[1], _T_, init, f);
   }
   function fold(t, init, f){
    var _S_ = caml_call1(Core_Queue[26], t);
    return caml_call3(Async_kernel_Deferred_list[2], _S_, init, f);
   }
   function all(t){
    var
     _P_ = Core_Queue[38],
     _Q_ = caml_call1(Core_Queue[26], t),
     _R_ = caml_call1(Async_kernel_Deferred_list[11], _Q_);
    return caml_call2(Async_kernel_Deferred_std[4], _R_, _P_);
   }
   function all_unit(t){
    var _O_ = caml_call1(Core_Queue[26], t);
    return caml_call1(Async_kernel_Deferred_list[12], _O_);
   }
   function iter(how, t, f){
    var _N_ = caml_call1(Core_Queue[26], t);
    return caml_call3(Async_kernel_Deferred_list[14], how, _N_, f);
   }
   function iteri(how, t, f){
    var _M_ = caml_call1(Core_Queue[26], t);
    return caml_call3(Async_kernel_Deferred_list[15], how, _M_, f);
   }
   function map(how, t, f){
    var
     _J_ = Core_Queue[38],
     _K_ = caml_call1(Core_Queue[26], t),
     _L_ = caml_call3(Async_kernel_Deferred_list[16], how, _K_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _L_, _J_);
   }
   function mapi(how, t, f){
    var
     _G_ = Core_Queue[38],
     _H_ = caml_call1(Core_Queue[26], t),
     _I_ = caml_call3(Async_kernel_Deferred_list[17], how, _H_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _I_, _G_);
   }
   function init(how, n, f){
    var
     _E_ = Core_Queue[38],
     _F_ = caml_call3(Async_kernel_Deferred_list[13], how, n, f);
    return caml_call2(Async_kernel_Deferred_std[4], _F_, _E_);
   }
   function filter(how, t, f){
    var
     _B_ = Core_Queue[38],
     _C_ = caml_call1(Core_Queue[26], t),
     _D_ = caml_call3(Async_kernel_Deferred_list[18], how, _C_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _D_, _B_);
   }
   function filteri(how, t, f){
    var
     _y_ = Core_Queue[38],
     _z_ = caml_call1(Core_Queue[26], t),
     _A_ = caml_call3(Async_kernel_Deferred_list[19], how, _z_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _A_, _y_);
   }
   function filter_map(how, t, f){
    var
     _v_ = Core_Queue[38],
     _w_ = caml_call1(Core_Queue[26], t),
     _x_ = caml_call3(Async_kernel_Deferred_list[20], how, _w_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _x_, _v_);
   }
   function filter_mapi(how, t, f){
    var
     _s_ = Core_Queue[38],
     _t_ = caml_call1(Core_Queue[26], t),
     _u_ = caml_call3(Async_kernel_Deferred_list[21], how, _t_, f);
    return caml_call2(Async_kernel_Deferred_std[4], _u_, _s_);
   }
   function concat_map(how, t, f){
    var
     _n_ = Core_Queue[38],
     _o_ = caml_call1(Core_Queue[26], t),
     _p_ =
       caml_call3
        (Async_kernel_Deferred_list[22],
         how,
         _o_,
         function(x){
          var _q_ = Core_Queue[26], _r_ = caml_call1(f, x);
          return caml_call2(Async_kernel_Deferred_std[4], _r_, _q_);
         });
    return caml_call2(Async_kernel_Deferred_std[4], _p_, _n_);
   }
   function concat_mapi(how, t, f){
    var
     _i_ = Core_Queue[38],
     _j_ = caml_call1(Core_Queue[26], t),
     _k_ =
       caml_call3
        (Async_kernel_Deferred_list[23],
         how,
         _j_,
         function(i, x){
          var _l_ = Core_Queue[26], _m_ = caml_call2(f, i, x);
          return caml_call2(Async_kernel_Deferred_std[4], _m_, _l_);
         });
    return caml_call2(Async_kernel_Deferred_std[4], _k_, _i_);
   }
   function find_map(t, f){
    var _h_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[5], _h_, f);
   }
   function find_mapi(t, f){
    var _g_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[6], _g_, f);
   }
   function find(t, f){
    var _f_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[3], _f_, f);
   }
   function findi(t, f){
    var _e_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[4], _e_, f);
   }
   function for_all(t, f){
    var _d_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[9], _d_, f);
   }
   function for_alli(t, f){
    var _c_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[10], _c_, f);
   }
   function exists(t, f){
    var _b_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[7], _b_, f);
   }
   function existsi(t, f){
    var _a_ = caml_call1(Core_Queue[26], t);
    return caml_call2(Async_kernel_Deferred_list[8], _a_, f);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_queu);
   var
    Async_kernel_Deferred_queue =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (14, Async_kernel_Deferred_queue, cst_Async_kernel_Deferred_queu);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred_sequence
//# unitInfo: Requires: Async_kernel__Deferred_std, Async_kernel__Throttle, Core__List, Core__Sequence, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred_sequ = "Async_kernel__Deferred_sequence",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Sequence = global_data.Core__Sequence,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Core_List = global_data.Core__List,
    Async_kernel_Throttle = global_data.Async_kernel__Throttle,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred_sequ);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred_sequence.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, 0], _b_ = [0, 0];
   function fold_mapi(opt, t){
    if(opt) var sth = opt[1], how = sth; else var how = -686623969;
    return function(init, mapi_f, fold_f){
     if(typeof how !== "number"){
      var
       max_concurrent_jobs = how[2],
       throttle = caml_call2(Async_kernel_Throttle[4], 0, max_concurrent_jobs),
       loop$0 =
         function(i, t, c){
          var _y_ = caml_call1(Async_kernel_Throttle[16], throttle);
          return caml_call2
                  (Async_kernel_Deferred_std[5][1],
                   _y_,
                   function(param){
                    var match = caml_call1(Core_Sequence[47], t);
                    if(! match) return c;
                    var
                     match$0 = match[1],
                     t$0 = match$0[2],
                     a = match$0[1],
                     _z_ =
                       caml_call2
                        (Async_kernel_Throttle[8],
                         throttle,
                         function(param){return caml_call2(mapi_f, i, a);});
                    return loop$0
                            (i + 1 | 0,
                             t$0,
                             caml_call2
                              (Async_kernel_Deferred_std[5][1],
                               _z_,
                               function(b){
                                return caml_call2
                                        (Async_kernel_Deferred_std[5][2],
                                         c,
                                         function(c){return caml_call2(fold_f, c, b);});
                               }));
                   });
         };
      return loop$0(0, t, caml_call1(Async_kernel_Deferred_std[10], init));
     }
     if(-676829465 > how){
      var
       loop =
         function(i, t, c){
          var match = caml_call1(Core_Sequence[47], t);
          if(! match) return caml_call1(Async_kernel_Deferred_std[10], c);
          var
           match$0 = match[1],
           t$0 = match$0[2],
           a = match$0[1],
           _x_ = caml_call2(mapi_f, i, a);
          return caml_call2
                  (Async_kernel_Deferred_std[5][1],
                   _x_,
                   function(b){
                    return loop(i + 1 | 0, t$0, caml_call2(fold_f, c, b));
                   });
         };
      return loop(0, t, init);
     }
     var
      c$1 = caml_call1(Async_kernel_Deferred_std[10], init),
      i = 0,
      t$0 = t,
      c = c$1;
     for(;;){
      var match = caml_call1(Core_Sequence[47], t$0);
      if(! match) return c;
      var match$0 = match[1], t$1 = match$0[2], a = match$0[1];
      let c$1 = c;
      var
       _w_ = caml_call2(mapi_f, i, a),
       c$0 =
         caml_call2
          (Async_kernel_Deferred_std[5][1],
           _w_,
           function(b){
            return caml_call2
                    (Async_kernel_Deferred_std[5][2],
                     c$1,
                     function(c){return caml_call2(fold_f, c, b);});
           }),
       i$0 = i + 1 | 0;
      i = i$0;
      t$0 = t$1;
      c = c$0;
     }};
   }
   function foldi(t, init, f){
    return caml_call4
            (Core_Sequence[105],
             t,
             [0, 0, init],
             function(param, a, k){
              var b = param[2], i = param[1], _v_ = caml_call3(f, i, b, a);
              return caml_call2
                      (Async_kernel_Deferred_std[5][1],
                       _v_,
                       function(b){return caml_call1(k, [0, i + 1 | 0, b]);});
             },
             function(param){
              var b = param[2];
              return caml_call1(Async_kernel_Deferred_std[10], b);
             });
   }
   function fold(t, init, f){
    return caml_call4
            (Core_Sequence[105],
             t,
             init,
             function(b, a, k){
              var _u_ = caml_call2(f, b, a);
              return caml_call2(Async_kernel_Deferred_std[3], _u_, k);
             },
             Async_kernel_Deferred_std[10]);
   }
   function all(t){
    var
     _s_ =
       fold
        (t,
         0,
         function(accum, d){
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   d,
                   function(a){return [0, a, accum];});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _s_,
             function(res){
              var _t_ = caml_call1(Core_List[34], res);
              return caml_call1(Core_Sequence[109], _t_);
             });
   }
   function all_unit(t){return fold(t, 0, function(param, v){return v;});}
   function find_mapi(t, f){
    function find_mapi(t, f, i){
     var match = caml_call1(Core_Sequence[47], t);
     if(! match) return caml_call1(Async_kernel_Deferred_std[10], 0);
     var
      match$0 = match[1],
      rest = match$0[2],
      v = match$0[1],
      _r_ = caml_call2(f, i, v);
     return caml_call2
             (Async_kernel_Deferred_std[5][1],
              _r_,
              function(some){
               return some
                       ? caml_call1(Async_kernel_Deferred_std[10], some)
                       : find_mapi(rest, f, i + 1 | 0);
              });
    }
    return find_mapi(t, f, 0);
   }
   function findi(t, f){
    return find_mapi
            (t,
             function(i, elt){
              var _q_ = caml_call2(f, i, elt);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _q_,
                       function(b){return b ? [0, [0, i, elt]] : 0;});
             });
   }
   function find(t, f){
    return find_mapi
            (t,
             function(param, elt){
              var _p_ = caml_call1(f, elt);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _p_,
                       function(b){return b ? [0, elt] : 0;});
             });
   }
   function existsi(t, f){
    var
     _n_ =
       find_mapi
        (t,
         function(i, elt){
          var _o_ = caml_call2(f, i, elt);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _o_,
                   function(b){return b ? _a_ : 0;});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _n_,
             function(param){return param ? 1 : 0;});
   }
   function for_alli(t, f){
    var
     _l_ =
       find_mapi
        (t,
         function(i, elt){
          var _m_ = caml_call2(f, i, elt);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _m_,
                   function(b){return b ? 0 : _b_;});
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _l_,
             function(param){return param ? 0 : 1;});
   }
   function iteri(how, t, f){
    return fold_mapi(how, t)(0, f, function(param, _k_){return 0;});
   }
   function mapi(how, t, f){
    var
     _i_ =
       fold_mapi(how, t)
        (0,
         function(i, a){return caml_call2(f, i, a);},
         function(bs, b){return [0, b, bs];});
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _i_,
             function(bs){
              var _j_ = caml_call1(Core_List[34], bs);
              return caml_call1(Core_Sequence[109], _j_);
             });
   }
   function filter_mapi(how, t, f){
    var
     _g_ =
       fold_mapi(how, t)
        (0,
         function(i, a){return caml_call2(f, i, a);},
         function(bs, maybe_v){
          if(! maybe_v) return bs;
          var b = maybe_v[1];
          return [0, b, bs];
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _g_,
             function(bs){
              var _h_ = caml_call1(Core_List[34], bs);
              return caml_call1(Core_Sequence[109], _h_);
             });
   }
   function concat_mapi(how, t, f){
    var _e_ = Core_Sequence[70], _f_ = mapi(how, t, f);
    return caml_call2(Async_kernel_Deferred_std[4], _f_, _e_);
   }
   function filteri(how, t, f){
    return filter_mapi
            (how,
             t,
             function(i, a){
              var _d_ = caml_call2(f, i, a);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _d_,
                       function(param){return param ? [0, a] : 0;});
             });
   }
   function iter(how, t, f){
    return iteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function map(how, t, f){
    return mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter(how, t, f){
    return filteri(how, t, function(param, a){return caml_call1(f, a);});
   }
   function filter_map(how, t, f){
    return filter_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function concat_map(how, t, f){
    return concat_mapi(how, t, function(param, a){return caml_call1(f, a);});
   }
   function find_map(t, f){
    return find_mapi(t, function(param, a){return caml_call1(f, a);});
   }
   function exists(t, f){
    return existsi(t, function(param, a){return caml_call1(f, a);});
   }
   function for_all(t, f){
    return for_alli(t, function(param, a){return caml_call1(f, a);});
   }
   function init(how, n, f){
    return map
            (how,
             caml_call2(Core_Sequence[83], n, function(_c_){return _c_;}),
             f);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred_sequ);
   var
    Async_kernel_Deferred_sequence =
      [0,
       foldi,
       fold,
       find,
       findi,
       find_map,
       find_mapi,
       exists,
       existsi,
       for_all,
       for_alli,
       all,
       all_unit,
       init,
       iter,
       iteri,
       map,
       mapi,
       filter,
       filteri,
       filter_map,
       filter_mapi,
       concat_map,
       concat_mapi];
   runtime.caml_register_global
    (17, Async_kernel_Deferred_sequence, cst_Async_kernel_Deferred_sequ);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Deferred
//# unitInfo: Requires: Async_kernel__Deferred1, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Deferred = "Async_kernel__Deferred",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Deferred1 = global_data.Async_kernel__Deferred1;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Deferred);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/deferred.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    sexp_of_t = Async_kernel_Deferred1[1],
    invariant = Async_kernel_Deferred1[2],
    create = Async_kernel_Deferred1[4],
    peek = Async_kernel_Deferred1[5],
    value_exn = Async_kernel_Deferred1[6],
    is_determined = Async_kernel_Deferred1[7],
    upon = Async_kernel_Deferred1[8],
    never = Async_kernel_Deferred1[12],
    symbol_bind = Async_kernel_Deferred1[14],
    symbol_map = Async_kernel_Deferred1[15],
    Monad_infix = Async_kernel_Deferred1[16],
    bind = Async_kernel_Deferred1[17],
    map = Async_kernel_Deferred1[18],
    join = Async_kernel_Deferred1[19],
    ignore_m = Async_kernel_Deferred1[20],
    return$0 = Async_kernel_Deferred1[21],
    Let_syntax = Async_kernel_Deferred1[22],
    unit = Async_kernel_Deferred1[23],
    both = Async_kernel_Deferred1[24],
    Infix = Async_kernel_Deferred1[25],
    don_t_wait_for = Async_kernel_Deferred1[26],
    Choice = Async_kernel_Deferred1[27],
    choice = Async_kernel_Deferred1[29],
    enabled = Async_kernel_Deferred1[30],
    choose = Async_kernel_Deferred1[32],
    any = Async_kernel_Deferred1[34],
    any_unit = Async_kernel_Deferred1[35],
    for$0 = Async_kernel_Deferred1[36],
    repeat_until_finished = Async_kernel_Deferred1[37],
    forever = Async_kernel_Deferred1[38],
    all = Async_kernel_Deferred1[42],
    all_unit = Async_kernel_Deferred1[43],
    ok = Async_kernel_Deferred1[44];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Deferred);
   var
    _a_ = Let_syntax[4],
    Async_kernel_Deferred =
      [0,
       sexp_of_t,
       invariant,
       create,
       upon,
       peek,
       value_exn,
       is_determined,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind,
       return$0,
       map,
       join,
       ignore_m,
       [0,
        Let_syntax[3],
        Let_syntax[1],
        Let_syntax[2],
        [0, _a_[5], _a_[1], _a_[2], _a_[3], _a_[4]]],
       [0, Infix[1], Infix[2], Infix[3]],
       unit,
       never,
       both,
       all,
       all_unit,
       any,
       any_unit,
       don_t_wait_for,
       Choice,
       choice,
       enabled,
       choose,
       for$0,
       repeat_until_finished,
       forever,
       ok];
   runtime.caml_register_global
    (12, Async_kernel_Deferred, cst_Async_kernel_Deferred);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Require_explicit_time_source
//# unitInfo: Requires: Async_kernel__Async_kernel_scheduler, Async_kernel__Clock_ns, Async_kernel__Time_ns, Core__Date, Core__Time_float, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Require_expli =
      "Async_kernel__Require_explicit_time_source",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Clock_ns = global_data.Async_kernel__Clock_ns,
    Core_Date = global_data.Core__Date,
    Async_kernel_Async_kernel_sche =
      global_data.Async_kernel__Async_kernel_scheduler,
    Core_Time_float = global_data.Core__Time_float,
    Async_kernel_Time_ns = global_data.Async_kernel__Time_ns;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Require_expli);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1
    (Expect_test_collector[5][1], "src/require_explicit_time_source.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    after = Async_kernel_Clock_ns[4],
    at = Async_kernel_Clock_ns[3],
    every = Async_kernel_Clock_ns[10],
    with_timeout = Async_kernel_Clock_ns[5];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Require_expli);
   var
    Async_kernel_Require_explicit_ =
      [0,
       Async_kernel_Clock_ns,
       [0,
        Async_kernel_Time_ns[1],
        Async_kernel_Time_ns[2],
        Async_kernel_Time_ns[3],
        Async_kernel_Time_ns[4],
        Async_kernel_Time_ns[5],
        Async_kernel_Time_ns[6],
        Async_kernel_Time_ns[7],
        Async_kernel_Time_ns[8],
        Async_kernel_Time_ns[9],
        Async_kernel_Time_ns[10],
        Async_kernel_Time_ns[11],
        Async_kernel_Time_ns[12],
        Async_kernel_Time_ns[13],
        Async_kernel_Time_ns[14],
        Async_kernel_Time_ns[15],
        Async_kernel_Time_ns[16],
        Async_kernel_Time_ns[17],
        Async_kernel_Time_ns[18],
        Async_kernel_Time_ns[19],
        Async_kernel_Time_ns[20],
        Async_kernel_Time_ns[21],
        Async_kernel_Time_ns[22],
        Async_kernel_Time_ns[23],
        Async_kernel_Time_ns[24],
        Async_kernel_Time_ns[25],
        Async_kernel_Time_ns[26],
        Async_kernel_Time_ns[27],
        Async_kernel_Time_ns[28],
        Async_kernel_Time_ns[29],
        Async_kernel_Time_ns[30],
        Async_kernel_Time_ns[31],
        Async_kernel_Time_ns[32],
        Async_kernel_Time_ns[33],
        Async_kernel_Time_ns[34],
        Async_kernel_Time_ns[35],
        Async_kernel_Time_ns[36],
        Async_kernel_Time_ns[37],
        Async_kernel_Time_ns[38],
        Async_kernel_Time_ns[39],
        Async_kernel_Time_ns[40],
        Async_kernel_Time_ns[41],
        Async_kernel_Time_ns[42],
        Async_kernel_Time_ns[43],
        Async_kernel_Time_ns[44],
        Async_kernel_Time_ns[45],
        Async_kernel_Time_ns[46],
        Async_kernel_Time_ns[47],
        Async_kernel_Time_ns[48],
        Async_kernel_Time_ns[49],
        Async_kernel_Time_ns[51],
        Async_kernel_Time_ns[52],
        Async_kernel_Time_ns[53],
        Async_kernel_Time_ns[54],
        Async_kernel_Time_ns[55],
        Async_kernel_Time_ns[56],
        Async_kernel_Time_ns[57],
        Async_kernel_Time_ns[58],
        Async_kernel_Time_ns[59],
        Async_kernel_Time_ns[60],
        Async_kernel_Time_ns[61],
        Async_kernel_Time_ns[62],
        Async_kernel_Time_ns[63],
        Async_kernel_Time_ns[64],
        Async_kernel_Time_ns[65],
        Async_kernel_Time_ns[66],
        Async_kernel_Time_ns[67],
        Async_kernel_Time_ns[68],
        Async_kernel_Time_ns[69],
        Async_kernel_Time_ns[70],
        Async_kernel_Time_ns[71],
        Async_kernel_Time_ns[72],
        Async_kernel_Time_ns[73],
        Async_kernel_Time_ns[74],
        Async_kernel_Time_ns[75],
        Async_kernel_Time_ns[76],
        Async_kernel_Time_ns[77],
        Async_kernel_Time_ns[78],
        Async_kernel_Time_ns[79],
        Async_kernel_Time_ns[80],
        Async_kernel_Time_ns[81],
        Async_kernel_Time_ns[82],
        Async_kernel_Time_ns[83],
        Async_kernel_Time_ns[84],
        Async_kernel_Time_ns[85],
        Async_kernel_Time_ns[86],
        Async_kernel_Time_ns[87],
        Async_kernel_Time_ns[88],
        Async_kernel_Time_ns[89],
        Async_kernel_Time_ns[90],
        Async_kernel_Time_ns[91],
        Async_kernel_Time_ns[92],
        Async_kernel_Time_ns[93],
        Async_kernel_Time_ns[94],
        Async_kernel_Time_ns[95],
        Async_kernel_Time_ns[96],
        Async_kernel_Time_ns[97],
        Async_kernel_Time_ns[98],
        Async_kernel_Time_ns[99],
        Async_kernel_Time_ns[100],
        Async_kernel_Time_ns[101],
        Async_kernel_Time_ns[102],
        Async_kernel_Time_ns[103],
        Async_kernel_Time_ns[104],
        Async_kernel_Time_ns[105],
        Async_kernel_Time_ns[106],
        Async_kernel_Time_ns[107],
        Async_kernel_Time_ns[108],
        Async_kernel_Time_ns[109],
        Async_kernel_Time_ns[110],
        Async_kernel_Time_ns[111],
        Async_kernel_Time_ns[112],
        Async_kernel_Time_ns[113],
        Async_kernel_Time_ns[50]],
       [0,
        Core_Time_float[1],
        Core_Time_float[2],
        Core_Time_float[3],
        Core_Time_float[4],
        Core_Time_float[5],
        Core_Time_float[6],
        Core_Time_float[7],
        Core_Time_float[8],
        Core_Time_float[9],
        Core_Time_float[10],
        Core_Time_float[11],
        Core_Time_float[12],
        Core_Time_float[14],
        Core_Time_float[15],
        Core_Time_float[16],
        Core_Time_float[17],
        Core_Time_float[18],
        Core_Time_float[19],
        Core_Time_float[20],
        Core_Time_float[21],
        Core_Time_float[22],
        Core_Time_float[23],
        Core_Time_float[24],
        Core_Time_float[25],
        Core_Time_float[26],
        Core_Time_float[27],
        Core_Time_float[28],
        Core_Time_float[29],
        Core_Time_float[30],
        Core_Time_float[31],
        Core_Time_float[32],
        Core_Time_float[33],
        Core_Time_float[34],
        Core_Time_float[35],
        Core_Time_float[36],
        Core_Time_float[37],
        Core_Time_float[38],
        Core_Time_float[39],
        Core_Time_float[40],
        Core_Time_float[41],
        Core_Time_float[42],
        Core_Time_float[43],
        Core_Time_float[45],
        Core_Time_float[46],
        Core_Time_float[48],
        Core_Time_float[49],
        Core_Time_float[50],
        Core_Time_float[51],
        Core_Time_float[52],
        Core_Time_float[53],
        Core_Time_float[54],
        Core_Time_float[55],
        Core_Time_float[56],
        Core_Time_float[57],
        Core_Time_float[58],
        Core_Time_float[59],
        Core_Time_float[60],
        Core_Time_float[61],
        Core_Time_float[62],
        Core_Time_float[63],
        Core_Time_float[64],
        Core_Time_float[65],
        Core_Time_float[66],
        Core_Time_float[67],
        Core_Time_float[68],
        Core_Time_float[69],
        Core_Time_float[70],
        Core_Time_float[71],
        Core_Time_float[72],
        Core_Time_float[73],
        Core_Time_float[74],
        Core_Time_float[75],
        Core_Time_float[76],
        Core_Time_float[77],
        Core_Time_float[78],
        Core_Time_float[79],
        Core_Time_float[80],
        Core_Time_float[81],
        Core_Time_float[82],
        Core_Time_float[93],
        Core_Time_float[94],
        Core_Time_float[95],
        Core_Time_float[96],
        Core_Time_float[97],
        Core_Time_float[98],
        Core_Time_float[99],
        Core_Time_float[100],
        Core_Time_float[101],
        Core_Time_float[102],
        Core_Time_float[103],
        Core_Time_float[104],
        Core_Time_float[105],
        Core_Time_float[106],
        Core_Time_float[107],
        Core_Time_float[108],
        Core_Time_float[109],
        Core_Time_float[110],
        Core_Time_float[111],
        Core_Time_float[112],
        Core_Time_float[113],
        Core_Time_float[114],
        Core_Time_float[115],
        Core_Time_float[47]],
       [0,
        Async_kernel_Async_kernel_sche[1],
        Async_kernel_Async_kernel_sche[2],
        Async_kernel_Async_kernel_sche[3],
        Async_kernel_Async_kernel_sche[4],
        Async_kernel_Async_kernel_sche[5],
        Async_kernel_Async_kernel_sche[6],
        Async_kernel_Async_kernel_sche[7],
        Async_kernel_Async_kernel_sche[8],
        Async_kernel_Async_kernel_sche[9],
        Async_kernel_Async_kernel_sche[10],
        Async_kernel_Async_kernel_sche[11],
        Async_kernel_Async_kernel_sche[12],
        Async_kernel_Async_kernel_sche[13],
        Async_kernel_Async_kernel_sche[16],
        Async_kernel_Async_kernel_sche[17],
        Async_kernel_Async_kernel_sche[18],
        Async_kernel_Async_kernel_sche[19],
        Async_kernel_Async_kernel_sche[20],
        Async_kernel_Async_kernel_sche[21],
        Async_kernel_Async_kernel_sche[22],
        Async_kernel_Async_kernel_sche[23],
        Async_kernel_Async_kernel_sche[24],
        Async_kernel_Async_kernel_sche[25],
        Async_kernel_Async_kernel_sche[26],
        Async_kernel_Async_kernel_sche[27],
        Async_kernel_Async_kernel_sche[28],
        Async_kernel_Async_kernel_sche[29],
        Async_kernel_Async_kernel_sche[30],
        Async_kernel_Async_kernel_sche[31],
        Async_kernel_Async_kernel_sche[32],
        Async_kernel_Async_kernel_sche[14],
        Async_kernel_Async_kernel_sche[15]],
       [0,
        Core_Date[1],
        Core_Date[2],
        Core_Date[3],
        Core_Date[4],
        Core_Date[5],
        Core_Date[6],
        Core_Date[7],
        Core_Date[8],
        Core_Date[9],
        Core_Date[10],
        Core_Date[11],
        Core_Date[12],
        Core_Date[13],
        Core_Date[14],
        Core_Date[15],
        Core_Date[16],
        Core_Date[20],
        Core_Date[21],
        Core_Date[22],
        Core_Date[23],
        Core_Date[24],
        Core_Date[25],
        Core_Date[26],
        Core_Date[27],
        Core_Date[28],
        Core_Date[29],
        Core_Date[30],
        Core_Date[31],
        Core_Date[32],
        Core_Date[33],
        Core_Date[34],
        Core_Date[35],
        Core_Date[36],
        Core_Date[37],
        Core_Date[38],
        Core_Date[39],
        Core_Date[41],
        Core_Date[44],
        Core_Date[45],
        Core_Date[46],
        Core_Date[47],
        Core_Date[48],
        Core_Date[49],
        Core_Date[50],
        Core_Date[51],
        Core_Date[52],
        Core_Date[53],
        Core_Date[54],
        Core_Date[55],
        Core_Date[56],
        Core_Date[57],
        Core_Date[58],
        Core_Date[59],
        Core_Date[60],
        Core_Date[61],
        Core_Date[62],
        Core_Date[63],
        Core_Date[64],
        Core_Date[65],
        Core_Date[66],
        Core_Date[67],
        Core_Date[68],
        Core_Date[69],
        Core_Date[70],
        Core_Date[71],
        Core_Date[72],
        Core_Date[73],
        Core_Date[74],
        Core_Date[75],
        Core_Date[76],
        Core_Date[77],
        Core_Date[78],
        Core_Date[79],
        Core_Date[80],
        Core_Date[81],
        Core_Date[82],
        Core_Date[83],
        Core_Date[84],
        Core_Date[85],
        Core_Date[86],
        Core_Date[92],
        Core_Date[94],
        Core_Date[95],
        Core_Date[96],
        Core_Date[93]],
       at,
       after,
       every,
       with_timeout];
   runtime.caml_register_global
    (16, Async_kernel_Require_explicit_, cst_Async_kernel_Require_expli);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Pipe
//# unitInfo: Requires: Assert_failure, Async_kernel__Async_stream, Async_kernel__Deferred, Async_kernel__Deferred_list, Async_kernel__Deferred_queue, Async_kernel__Deferred_std, Async_kernel__Import, Async_kernel__Ivar, Async_kernel__Monitor, Async_kernel__Tail, Base__Field, Core, Core__Bag, Core__Bool, Core__Hashtbl, Core__Int, Core__List, Core__Option, Core__Queue, Core__Sequence, Core__Sexp, Core__Source_code_position, Expect_test_collector, Pairing_heap, Ppx_bench_lib__Benchmark_accumulator, Ppx_compare_lib, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexp_hidden_in_test, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Pipe = "Async_kernel__Pipe",
    cst_Eof = "Eof",
    cst_Ok = "Ok",
    cst_Reader_closed = "Reader_closed",
    cst$0 = "_",
    cst_async_kernel = "async_kernel",
    cst_blocked_flushes = "blocked_flushes",
    cst_blocked_reads = "blocked_reads",
    cst_consumer = "consumer",
    cst_consumers = "consumers",
    cst_exn = "exn",
    cst_pipe = "pipe",
    cst_pushback = "pushback",
    cst_size_budget = "size_budget",
    cst_src_pipe_ml = "src/pipe.ml",
    cst_values_read = "values_read",
    cst_wants = "wants",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_List = global_data.Core__List,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_kernel_Deferred_list = global_data.Async_kernel__Deferred_list,
    Pairing_heap = global_data.Pairing_heap,
    Async_kernel_Import = global_data.Async_kernel__Import,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core_Sequence = global_data.Core__Sequence,
    Core_Queue = global_data.Core__Queue,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred_queue = global_data.Async_kernel__Deferred_queue,
    Core_Sexp = global_data.Core__Sexp,
    Core_Option = global_data.Core__Option,
    Assert_failure = global_data.Assert_failure,
    Async_kernel_Async_stream = global_data.Async_kernel__Async_stream,
    Async_kernel_Tail = global_data.Async_kernel__Tail,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Core = global_data.Core,
    Core_Int = global_data.Core__Int,
    Core_Bag = global_data.Core__Bag,
    Core_Source_code_position = global_data.Core__Source_code_position,
    Core_Bool = global_data.Core__Bool,
    Base_Field = global_data.Base__Field,
    Core_Hashtbl = global_data.Core__Hashtbl,
    Sexp_hidden_in_test = global_data.Sexp_hidden_in_test,
    Ppx_compare_lib = global_data.Ppx_compare_lib,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Pipe);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_pipe_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    show_debug_messages = [0, 0],
    check_invariant = [0, 0],
    _a_ = [0, cst_Ok],
    _b_ = [0, cst_Reader_closed];
   function compare(a_001, b_002){
    if(caml_call2(Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(17724 <= a_001){
     if(17724 === b_002) return 0;
    }
    else if(-402004920 === b_002) return 0;
    return runtime.caml_int_compare(a_001, b_002);
   }
   function sexp_of_t(param){return 17724 <= param ? _a_ : _b_;}
   function equal(x_003, x_004){return 0 === compare(x_003, x_004) ? 1 : 0;}
   function combine(l){
    var _c4_ = caml_call1(Async_kernel_Deferred[21], l);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _c4_,
             function(l){
              return caml_call3(Core_List[6], l, -402004920, equal)
                      ? -402004920
                      : 17724;
             });
   }
   function values_read(r){return r[2];}
   function set_values_read(r, v){r[2] = v; return 0;}
   var
    values_read$0 =
      [0,
       function(param){return 0;},
       cst_values_read,
       [0, set_values_read],
       values_read,
       function(r, v){return [0, r[1], v, r[3]];}],
    _c_ = [0, "downstream_flushed"],
    _d_ = [0, "Have_been_sent_downstream"],
    _e_ = [0, cst_values_read],
    _f_ = [0, "pipe_id"],
    _g_ = [0, "Have_not_been_sent_downstream"],
    _h_ = [0, cst_pipe],
    _i_ = [0, cst_exn],
    cst_Pipe_Consumer_invariant_fa = "Pipe.Consumer.invariant failed",
    _j_ = [0, cst_src_pipe_ml, 79, 54];
   function sexp_of_t$0(param){
    var
     pipe_id_009 = param[1],
     values_read_011 = param[2],
     arg_015 = caml_call1(Sexplib0_Sexp_conv[24], function(_c3_){return 0;}),
     bnds_008 = [0, [1, [0, _c_, [0, arg_015, 0]]], 0];
    if(typeof values_read_011 === "number")
     var arg_012 = _d_;
    else
     var
      v_013 = values_read_011[2],
      arg_012 =
        [1,
         [0, _g_, [0, caml_call2(Async_kernel_Ivar[9], Core[518], v_013), 0]]];
    var
     bnds_008$0 = [0, [1, [0, _e_, [0, arg_012, 0]]], bnds_008],
     arg_010 = caml_call1(Core[356], pipe_id_009),
     bnds_008$1 = [0, [1, [0, _f_, [0, arg_010, 0]]], bnds_008$0];
    return [1, bnds_008$1];
   }
   function invariant(t){
    try{
     var param = caml_call2(Base_Field[3], values_read$0, t);
     if(typeof param !== "number"){
      var ivar = param[2];
      if(! caml_call1(Async_kernel_Ivar[16], ivar))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
     }
     return;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _c0_ = [0, [1, [0, _h_, [0, sexp_of_t$0(t), 0]]], 0],
      _c1_ = [0, [1, [0, _i_, [0, caml_call1(Core[537], exn), 0]]], _c0_],
      _c2_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_Consumer_invariant_fa),
          _c1_]];
     return caml_call1(Core[253], _c2_);
    }
   }
   function start(t){
    return typeof t[2] === "number"
            ? (t
               [2]
              = [0, -122467239, caml_call1(Async_kernel_Ivar[12], 0)],
              0)
            : 0;
   }
   function values_sent_downstream(t){
    var match = t[2];
    if(typeof match === "number") return 0;
    var ivar = match[2];
    caml_call2(Async_kernel_Ivar[14], ivar, 0);
    t[2] = -758792467;
    return 0;
   }
   function values_sent_downstream_and_flu(t){
    var match = t[2];
    if(typeof match === "number") return caml_call1(t[3], 0);
    var
     when_sent_downstream = match[2],
     _cZ_ = caml_call1(Async_kernel_Ivar[18], when_sent_downstream);
    return caml_call2
            (Async_kernel_Deferred_std[5][1],
             _cZ_,
             function(param){return caml_call1(t[3], 0);});
   }
   function consumer(r){return r[2];}
   function wants(r){return r[1];}
   var
    consumer$0 =
      [0,
       function(param){return 0;},
       cst_consumer,
       0,
       consumer,
       function(r, v){return [0, r[1], v];}],
    wants$0 =
      [0,
       function(param){return 0;},
       cst_wants,
       0,
       wants,
       function(r, v){return [0, v, r[2]];}],
    _k_ = [0, cst_Eof],
    _l_ = [0, cst_Ok],
    _m_ = [0, "Zero"],
    _n_ = [0, cst_Eof],
    _o_ = [0, cst_Ok],
    _p_ = [0, "One"],
    _q_ = [0, cst_Eof],
    _r_ = [0, cst_Ok],
    _s_ = [0, "At_most"],
    _t_ = [0, cst_consumer],
    _u_ = [0, cst_wants],
    _z_ = [0, cst_Ok],
    _A_ = [0, cst_Reader_closed],
    _B_ = [0, "ready"],
    _C_ = [0, "fill_when_num_values_read"];
   function sexp_of_t$1(of_a_029, param){
    var
     consumer_033 = param[2],
     wants_031 = param[1],
     arg_034 = caml_call2(Core[454], sexp_of_t$0, consumer_033),
     bnds_030 = [0, [1, [0, _t_, [0, arg_034, 0]]], 0];
    switch(wants_031[0]){
      case 0:
       var
        arg0_018 = wants_031[1],
        res0_019 =
          caml_call2
           (Async_kernel_Ivar[9],
            function(param){return 3456156 <= param ? _k_ : _l_;},
            arg0_018),
        arg_032 = [1, [0, _m_, [0, res0_019, 0]]];
       break;
      case 1:
       var
        arg0_021 = wants_031[1],
        res0_022 =
          caml_call2
           (Async_kernel_Ivar[9],
            function(param){
             if(typeof param === "number") return _n_;
             var v_020 = param[2];
             return [1, [0, _o_, [0, caml_call1(of_a_029, v_020), 0]]];
            },
            arg0_021),
        arg_032 = [1, [0, _p_, [0, res0_022, 0]]];
       break;
      default:
       var
        arg1_025 = wants_031[2],
        arg0_024 = wants_031[1],
        res0_026 = caml_call1(Core[356], arg0_024),
        res1_027 =
          caml_call2
           (Async_kernel_Ivar[9],
            function(param){
             if(typeof param === "number") return _q_;
             var v_023 = param[2];
             return [1,
                     [0,
                      _r_,
                      [0, caml_call2(Core_Queue[11], of_a_029, v_023), 0]]];
            },
            arg1_025),
        arg_032 = [1, [0, _s_, [0, res0_026, [0, res1_027, 0]]]];
    }
    var bnds_030$0 = [0, [1, [0, _u_, [0, arg_032, 0]]], bnds_030];
    return [1, bnds_030$0];
   }
   function fill_with_eof(t){
    var match = t[1];
    switch(match[0]){
      case 0:
       var i = match[1]; return caml_call2(Async_kernel_Ivar[14], i, 3456156);
      case 1:
       var i$0 = match[1];
       return caml_call2(Async_kernel_Ivar[14], i$0, 3456156);
      default:
       var i$1 = match[2];
       return caml_call2(Async_kernel_Ivar[14], i$1, 3456156);
    }
   }
   function fill_when_num_values_read(r){return r[1];}
   function sexp_of_t$2(param){
    var
     ready_039 = param[2],
     fill_when_num_values_read_037 = param[1],
     arg_040 =
       caml_call2
        (Async_kernel_Ivar[9],
         function(param){return 17724 <= param ? _z_ : _A_;},
         ready_039),
     bnds_036 = [0, [1, [0, _B_, [0, arg_040, 0]]], 0],
     arg_038 = caml_call1(Core[356], fill_when_num_values_read_037),
     bnds_036$0 = [0, [1, [0, _C_, [0, arg_038, 0]]], bnds_036];
    return [1, bnds_036$0];
   }
   function fill(t, v){return caml_call2(Async_kernel_Ivar[14], t[2], v);}
   function consumers(r){return r[11];}
   function set_consumers(r, v){r[11] = v; return 0;}
   function blocked_reads(r){return r[8];}
   function blocked_flushes(r){return r[7];}
   function pushback(r){return r[5];}
   function set_pushback(r, v){r[5] = v; return 0;}
   function size_budget(r){return r[4];}
   function set_size_budget(r, v){r[4] = v; return 0;}
   var
    consumers$0 =
      [0,
       function(param){return 0;},
       cst_consumers,
       [0, set_consumers],
       consumers,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                v,
                r[12]];
       }],
    blocked_reads$0 =
      [0,
       function(param){return 0;},
       cst_blocked_reads,
       0,
       blocked_reads,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                r[7],
                v,
                r[9],
                r[10],
                r[11],
                r[12]];
       }],
    blocked_flushes$0 =
      [0,
       function(param){return 0;},
       cst_blocked_flushes,
       0,
       blocked_flushes,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                r[5],
                r[6],
                v,
                r[8],
                r[9],
                r[10],
                r[11],
                r[12]];
       }],
    pushback$0 =
      [0,
       function(param){return 0;},
       cst_pushback,
       [0, set_pushback],
       pushback,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                r[4],
                v,
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12]];
       }],
    size_budget$0 =
      [0,
       function(param){return 0;},
       cst_size_budget,
       [0, set_size_budget],
       size_budget,
       function(r, v){
        return [0,
                r[1],
                r[2],
                r[3],
                v,
                r[5],
                r[6],
                r[7],
                r[8],
                r[9],
                r[10],
                r[11],
                r[12]];
       }],
    _v_ = [0, cst$0],
    _w_ = [0, cst_pipe],
    _x_ = [0, cst_exn],
    cst_Pipe_Blocked_read_invarian = "Pipe.Blocked_read.invariant failed",
    _y_ = [0, cst_src_pipe_ml, 140, 33],
    _D_ = [0, "upstream_flusheds"],
    _E_ = [0, cst_consumers],
    _F_ = [0, "read_closed"],
    _G_ = [0, "closed"],
    _H_ = [0, cst_blocked_reads],
    _I_ = [0, cst_blocked_flushes],
    _J_ = [0, "num_values_read"],
    _K_ = [0, cst_pushback],
    _L_ = [0, cst_size_budget],
    _M_ = [0, "buffer"],
    _N_ = [0, "info"],
    _O_ = [0, "id"],
    _P_ = [0, cst$0],
    _Q_ = [0, cst$0],
    _R_ = [0, cst_pipe],
    _S_ = [0, cst_exn],
    cst_Pipe_invariant_failed = "Pipe.invariant failed",
    _T_ = [0, cst_src_pipe_ml, 293, 13],
    _U_ = [0, cst_src_pipe_ml, 284, 13],
    _V_ = [0, cst_src_pipe_ml, 286, 31],
    _W_ = [0, cst_src_pipe_ml, 281, 36],
    _X_ = [0, cst_src_pipe_ml, 269, 13],
    _Y_ = [0, cst_src_pipe_ml, 276, 30],
    _Z_ = [0, cst_src_pipe_ml, 270, 11],
    ___ = [0, cst_src_pipe_ml, 261, 11],
    _$_ = [0, cst_src_pipe_ml, 258, 46],
    _aa_ = [0, cst_src_pipe_ml, 300, 2],
    _ab_ = [0, cst_src_pipe_ml, 307, 2];
   function sexp_of_pipe(of_a_041, of_phantom_042, param){
    var
     id_044 = param[1],
     info_046 = param[2],
     buffer_050 = param[3],
     size_budget_052 = param[4],
     pushback_054 = param[5],
     num_values_read_056 = param[6],
     read_closed_064 = param[10],
     closed_062 = param[9],
     blocked_reads_060 = param[8],
     blocked_flushes_058 = param[7],
     consumers_066 = param[11],
     upstream_flusheds_068 = param[12],
     arg_069 =
       caml_call2
        (Core_Bag[3],
         function(param){
          return caml_call1(Sexplib0_Sexp_conv[24], function(_cY_){return 0;});
         },
         upstream_flusheds_068),
     bnds_043 = [0, [1, [0, _D_, [0, arg_069, 0]]], 0],
     arg_067 = caml_call2(Core[421], sexp_of_t$0, consumers_066),
     bnds_043$0 = [0, [1, [0, _E_, [0, arg_067, 0]]], bnds_043],
     arg_065 = caml_call2(Async_kernel_Ivar[9], Core[518], read_closed_064),
     bnds_043$1 = [0, [1, [0, _F_, [0, arg_065, 0]]], bnds_043$0],
     arg_063 = caml_call2(Async_kernel_Ivar[9], Core[518], closed_062),
     bnds_043$2 = [0, [1, [0, _G_, [0, arg_063, 0]]], bnds_043$1],
     arg_061 =
       caml_call2
        (Core_Queue[11],
         function(_cX_){return sexp_of_t$1(of_a_041, _cX_);},
         blocked_reads_060),
     bnds_043$3 = [0, [1, [0, _H_, [0, arg_061, 0]]], bnds_043$2],
     arg_059 = caml_call2(Core_Queue[11], sexp_of_t$2, blocked_flushes_058),
     bnds_043$4 = [0, [1, [0, _I_, [0, arg_059, 0]]], bnds_043$3],
     arg_057 = caml_call1(Core[356], num_values_read_056),
     bnds_043$5 = [0, [1, [0, _J_, [0, arg_057, 0]]], bnds_043$4],
     arg_055 = caml_call2(Async_kernel_Ivar[9], Core[518], pushback_054),
     bnds_043$6 = [0, [1, [0, _K_, [0, arg_055, 0]]], bnds_043$5],
     arg_053 = caml_call1(Core[356], size_budget_052),
     bnds_043$7 = [0, [1, [0, _L_, [0, arg_053, 0]]], bnds_043$6],
     arg_051 = caml_call2(Core_Queue[11], of_a_041, buffer_050),
     bnds_043$8 = [0, [1, [0, _M_, [0, arg_051, 0]]], bnds_043$7];
    if(info_046)
     var
      v_047 = info_046[1],
      arg_049 = caml_call1(Core_Sexp[90], v_047),
      bnd_048 = [1, [0, _N_, [0, arg_049, 0]]],
      bnds_043$9 = [0, bnd_048, bnds_043$8];
    else
     var bnds_043$9 = bnds_043$8;
    var
     arg_045 = caml_call2(Sexp_hidden_in_test[10], Core[356], id_044),
     bnds_043$10 = [0, [1, [0, _O_, [0, arg_045, 0]]], bnds_043$9];
    return [1, bnds_043$10];
   }
   function hash(t){return caml_call1(Core_Hashtbl[1], t[1]);}
   function equal$0(t1, t2){return caml_call2(Core[246], t1, t2);}
   function compare$0(t1, t2){return caml_call2(Core_Int[91], t1[1], t2[1]);}
   function is_closed(t){return caml_call1(Async_kernel_Ivar[17], t[9]);}
   function is_read_closed(t){
    return caml_call1(Async_kernel_Ivar[17], t[10]);
   }
   function closed(t){return caml_call1(Async_kernel_Ivar[18], t[9]);}
   function pushback$1(t){return caml_call1(Async_kernel_Ivar[18], t[5]);}
   function length(t){return caml_call1(Core_Queue[14], t[3]);}
   function is_empty(t){
    var _cW_ = length(t);
    return caml_call2(Async_kernel_Import[3], _cW_, 0);
   }
   function invariant$0(x_073){
    try{
     var size_budget = caml_call2(Base_Field[3], size_budget$0, x_073);
     if(! caml_call2(Async_kernel_Import[1], size_budget, 0))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _$_], 1);
     var
      pushback = caml_call2(Base_Field[3], pushback$0, x_073),
      _cN_ = x_073[4],
      _cO_ = length(x_073),
      _cP_ = caml_call2(Async_kernel_Import[2], _cO_, _cN_),
      _cQ_ = _cP_ || is_closed(x_073),
      _cR_ = caml_call1(Async_kernel_Ivar[17], pushback);
     if(! caml_call2(Core_Bool[27], _cR_, _cQ_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, ___], 1);
     var
      blocked_flushes = caml_call2(Base_Field[3], blocked_flushes$0, x_073);
     caml_call2
      (Core_Queue[16],
       blocked_flushes,
       function(f){
        if(caml_call2(Async_kernel_Import[4], f[1], x_073[6])) return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
       });
     var
      _cK_ = Core_Int[91],
      _cL_ = caml_call1(Core_Queue[26], blocked_flushes),
      _cM_ = caml_call2(Core_List[72], _cL_, fill_when_num_values_read);
     if(! caml_call2(Core_List[140], _cM_, _cK_))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _Z_], 1);
     if(is_empty(x_073) && ! caml_call1(Core_Queue[15], blocked_flushes))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _Y_], 1);
     var blocked_reads = caml_call2(Base_Field[3], blocked_reads$0, x_073);
     if(1 - is_empty(x_073) && ! caml_call1(Core_Queue[15], blocked_reads))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _W_], 1);
     caml_call2
      (Core_Queue[16],
       blocked_reads,
       function(x_035){
        try{
         var param = caml_call2(Base_Field[3], wants$0, x_035);
         if(2 === param[0]){
          var i = param[1];
          if(! caml_call2(Async_kernel_Import[4], i, 0))
           throw caml_maybe_attach_backtrace([0, Assert_failure, _y_], 1);
         }
         var param$0 = caml_call2(Base_Field[3], consumer$0, x_035);
         if(param$0){var consumer = param$0[1]; invariant(consumer);}
        }
        catch(exn$0){
         var
          exn = caml_wrap_exception(exn$0),
          _cS_ =
            [0,
             [1,
              [0,
               _w_,
               [0, sexp_of_t$1(function(param){return _v_;}, x_035), 0]]],
             0],
          _cT_ = [0, [1, [0, _x_, [0, caml_call1(Core[537], exn), 0]]], _cS_],
          _cU_ =
            [1,
             [0,
              caml_call1
               (Sexplib0_Sexp_conv[7], cst_Pipe_Blocked_read_invarian),
              _cT_]];
         caml_call1(Core[253], _cU_);
        }
        var match = x_035[1];
        switch(match[0]){
          case 0:
           var i$0 = match[1], _cV_ = caml_call1(Async_kernel_Ivar[16], i$0);
           break;
          case 1:
           var i$1 = match[1], _cV_ = caml_call1(Async_kernel_Ivar[16], i$1);
           break;
          default:
           var i$2 = match[2], _cV_ = caml_call1(Async_kernel_Ivar[16], i$2);
        }
        if(_cV_) return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _U_], 1);
       });
     if(is_closed(x_073) && ! caml_call1(Core_Queue[15], blocked_reads))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _V_], 1);
     var l = caml_call2(Base_Field[3], consumers$0, x_073);
     caml_call2
      (Core_List[9],
       l,
       function(consumer){
        invariant(consumer);
        if(caml_call2(Async_kernel_Import[3], consumer[1], x_073[1]))
         return 0;
        throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
       });
     var _cJ_ = 0;
     return _cJ_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _cG_ =
        [0,
         [1,
          [0,
           _R_,
           [0,
            sexp_of_pipe
             (function(param){return _Q_;},
              function(param){return _P_;},
              x_073),
            0]]],
         0],
      _cH_ = [0, [1, [0, _S_, [0, caml_call1(Core[537], exn), 0]]], _cG_],
      _cI_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_invariant_failed),
          _cH_]];
     return caml_call1(Core[253], _cI_);
    }
   }
   function sexp_of_phantom(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _aa_], 1);
   }
   function sexp_of_t$3(of_a_074, x_075){
    return sexp_of_pipe(of_a_074, sexp_of_phantom, x_075);
   }
   function sexp_of_phantom$0(param){
    throw caml_maybe_attach_backtrace([0, Assert_failure, _ab_], 1);
   }
   function sexp_of_t$4(of_a_076, x_077){
    return sexp_of_pipe(of_a_076, sexp_of_phantom$0, x_077);
   }
   var
    id_ref = [0, 0],
    _ac_ = [0, cst_size_budget],
    cst_negative_size_budget = "negative size_budget",
    _ad_ = [0, cst$0],
    _ae_ = [0, cst$0],
    cst_close = "close",
    _af_ = [0, cst$0],
    _ag_ = [0, cst$0],
    cst_close_read = "close_read",
    _ah_ = [0, 3804260],
    _ai_ = [0, 523273847],
    _aj_ = [0, 3804260],
    _ak_ = [0, 523273847],
    _al_ = [0, cst_src_pipe_ml, 456, 2],
    _am_ = [0, cst_src_pipe_ml, 465, 2],
    _an_ = [0, cst$0],
    _ao_ = [0, cst$0],
    cst_write = "write",
    _ap_ = [0, cst$0],
    _aq_ = [0, cst$0],
    _ar_ = [0, cst_pipe],
    cst_write_to_closed_pipe = "write to closed pipe",
    _as_ = [0, cst$0],
    _at_ = [0, cst_pipe],
    _au_ = [0, cst_consumer],
    cst_Attempt_to_use_consumer_wi = "Attempt to use consumer with wrong pipe",
    _av_ = [0, cst$0],
    _aw_ = [0, cst$0],
    cst_read_now = "read_now",
    _ax_ = [0, cst_src_pipe_ml, 574, 4],
    _ay_ = [0, "max_queue_length"],
    cst_max_queue_length_0 = "max_queue_length <= 0",
    cst_read = "read'",
    cst_read$0 = "read",
    _az_ = [0, cst_src_pipe_ml, 623, 4],
    cst_Pipe_read_exn_received_EOF = "Pipe.read_exn: received EOF",
    cst_values_available = "values_available",
    _aA_ = [0, "here"],
    cst_Pipe_read_choice_single_co =
      "Pipe.read_choice_single_consumer_exn: choice was enabled but pipe is empty; this is likely due to a race condition with one or more other consumers",
    cst_read_exactly = "read_exactly",
    _aB_ = [0, "num_values"],
    cst_Pipe_read_exactly_got_num_ = "Pipe.read_exactly got num_values <= 0",
    _aC_ = [0, cst_src_pipe_ml, 674, 6],
    _aD_ = [0, "When_value_read"],
    _aE_ = [0, "When_value_processed"],
    _aF_ = [0, "Consumer"];
   function create_internal(size_budget, info, initial_buffer){
    id_ref[1]++;
    var
     _cA_ = caml_call1(Core_Bag[22], 0),
     _cB_ = caml_call1(Async_kernel_Ivar[12], 0),
     _cC_ = caml_call1(Async_kernel_Ivar[12], 0),
     _cD_ = caml_call2(Core_Queue[61], 0, 0),
     _cE_ = caml_call2(Core_Queue[61], 0, 0),
     _cF_ = caml_call1(Async_kernel_Ivar[12], 0),
     t =
       [0,
        id_ref[1],
        info,
        initial_buffer,
        size_budget,
        _cF_,
        0,
        _cE_,
        _cD_,
        _cC_,
        _cB_,
        0,
        _cA_];
    return t;
   }
   function validate_size_budget(size_budget){
    if(! caml_call2(Async_kernel_Import[5], size_budget, 0))
     return size_budget;
    var
     _cy_ = [0, [1, [0, _ac_, [0, caml_call1(Core[356], size_budget), 0]]], 0],
     _cz_ =
       [1,
        [0, caml_call1(Sexplib0_Sexp_conv[7], cst_negative_size_budget), _cy_]];
    return caml_call1(Core[253], _cz_);
   }
   function create(size_budget, info, param){
    if(size_budget)
     var v = size_budget[1], size_budget$0 = validate_size_budget(v);
    else
     var size_budget$0 = 0;
    var
     t =
       create_internal(size_budget$0, info, caml_call2(Core_Queue[61], 0, 0));
    caml_call2(Async_kernel_Ivar[14], t[5], 0);
    if(check_invariant[1]) invariant$0(t);
    return [0, t, t];
   }
   function update_pushback(t){
    var _cu_ = t[4], _cv_ = length(t);
    if(! caml_call2(Async_kernel_Import[2], _cv_, _cu_) && ! is_closed(t)){
     var
      _cw_ = caml_call1(Async_kernel_Ivar[17], t[5]),
      _cx_ = _cw_ ? (t[5] = caml_call1(Async_kernel_Ivar[12], 0), 0) : _cw_;
     return _cx_;
    }
    return caml_call2(Async_kernel_Ivar[15], t[5], 0);
   }
   function close(t){
    if(show_debug_messages[1])
     caml_call3
      (Async_kernel_Import[14],
       cst_close,
       t,
       function(x_078){
        return sexp_of_pipe
                (function(param){return _ae_;},
                 function(param){return _ad_;},
                 x_078);
       });
    if(check_invariant[1]) invariant$0(t);
    var _ct_ = 1 - is_closed(t);
    if(! _ct_) return _ct_;
    caml_call2(Async_kernel_Ivar[14], t[9], 0);
    if(is_empty(t)){
     caml_call2(Core_Queue[16], t[8], fill_with_eof);
     caml_call1(Core_Queue[47], t[8]);
    }
    return update_pushback(t);
   }
   function close_read(t){
    if(show_debug_messages[1])
     caml_call3
      (Async_kernel_Import[14],
       cst_close_read,
       t,
       function(x_079){
        return sexp_of_pipe
                (function(param){return _ag_;},
                 function(param){return _af_;},
                 x_079);
       });
    if(check_invariant[1]) invariant$0(t);
    var _cs_ = 1 - is_read_closed(t);
    return _cs_
            ? (caml_call2
               (Async_kernel_Ivar[14], t[10], 0),
              caml_call2
               (Core_Queue[16],
                t[7],
                function(flush){return fill(flush, -402004920);}),
              caml_call1(Core_Queue[47], t[7]),
              caml_call1(Core_Queue[47], t[3]),
              update_pushback(t),
              close(t))
            : _cs_;
   }
   function create_reader_not_close_on_exc(size_budget, f){
    var
     match = create(size_budget, 0, 0),
     w = match[2],
     r = match[1],
     _cr_ = caml_call1(f, w);
    caml_call2
     (Async_kernel_Deferred_std[11], _cr_, function(param){return close(w);});
    return r;
   }
   function create_reader(size_budget, close_on_exception, f){
    if(! close_on_exception)
     return create_reader_not_close_on_exc(size_budget, f);
    var
     match = create(size_budget, 0, 0),
     w = match[2],
     r = match[1],
     _cq_ =
       caml_call8
        (Async_kernel_Monitor[23],
         0,
         0,
         0,
         0,
         _ai_,
         _ah_,
         function(param){return caml_call1(f, w);},
         function(param){
          close(w);
          return caml_call1(Async_kernel_Deferred_std[10], 0);
         });
    caml_call1(Async_kernel_Deferred_std[8], _cq_);
    return r;
   }
   function create_writer(size_budget, f){
    var
     match = create(size_budget, 0, 0),
     w = match[2],
     r = match[1],
     _cp_ =
       caml_call8
        (Async_kernel_Monitor[23],
         0,
         0,
         0,
         0,
         _ak_,
         _aj_,
         function(param){return caml_call1(f, r);},
         function(param){
          close_read(r);
          return caml_call1(Async_kernel_Deferred_std[10], 0);
         });
    caml_call1(Async_kernel_Deferred_std[8], _cp_);
    return w;
   }
   function values_were_read(t, consumer){
    caml_call2(Core_Option[41], consumer, start);
    for(;;){
     var match = caml_call1(Core_Queue[45], t[7]);
     if(! match) return;
     var
      flush = match[1],
      _cn_ = caml_call2(Async_kernel_Import[1], t[6], flush[1]);
     if(! _cn_) return _cn_;
     caml_call1(Core_Queue[44], t[7]);
     if(consumer){
      var consumer$0 = consumer[1];
      let flush$0 = flush;
      var _co_ = values_sent_downstream_and_flu(consumer$0);
      caml_call2
       (Async_kernel_Deferred_std[11],
        _co_,
        function(flush_result){return fill(flush$0, flush_result);});
     }
     else
      fill(flush, 17724);
    }
   }
   function consume_one(t, consumer){
    var _cm_ = length(t);
    if(! caml_call2(Async_kernel_Import[1], _cm_, 1))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _al_], 1);
    var result = caml_call1(Core_Queue[44], t[3]);
    t[6] = t[6] + 1 | 0;
    values_were_read(t, consumer);
    update_pushback(t);
    return result;
   }
   function consume(t, max_queue_length, consumer){
    if(! caml_call2(Async_kernel_Import[1], max_queue_length, 0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _am_], 1);
    var _cl_ = length(t);
    if(caml_call2(Async_kernel_Import[1], max_queue_length, _cl_)){
     var result = t[3];
     t[3] = caml_call2(Core_Queue[61], 0, 0);
     var _ck_ = caml_call1(Core_Queue[14], result);
     t[6] = t[6] + _ck_ | 0;
     values_were_read(t, consumer);
     update_pushback(t);
     return result;
    }
    t[6] = t[6] + max_queue_length | 0;
    values_were_read(t, consumer);
    var result$0 = caml_call2(Core_Queue[61], [0, max_queue_length], 0);
    caml_call4(Core_Queue[64], t[3], result$0, [0, max_queue_length], 0);
    update_pushback(t);
    return result$0;
   }
   function set_size_budget$0(t, size_budget){
    var size_budget$0 = validate_size_budget(size_budget);
    t[4] = size_budget$0;
    return update_pushback(t);
   }
   function start_write(x_081){
    if(show_debug_messages[1])
     caml_call3
      (Async_kernel_Import[14],
       cst_write,
       x_081,
       function(x_080){
        return sexp_of_pipe
                (function(param){return _ao_;},
                 function(param){return _an_;},
                 x_080);
       });
    if(check_invariant[1]) invariant$0(x_081);
    var _ch_ = is_closed(x_081);
    if(! _ch_) return _ch_;
    var
     _ci_ =
       [0,
        [1,
         [0,
          _ar_,
          [0,
           sexp_of_pipe
            (function(param){return _aq_;},
             function(param){return _ap_;},
             x_081),
           0]]],
        0],
     _cj_ =
       [1,
        [0, caml_call1(Sexplib0_Sexp_conv[7], cst_write_to_closed_pipe), _ci_]];
    return caml_call1(Core[253], _cj_);
   }
   function finish_write(t){
    for(;;){
     if(! caml_call1(Core_Queue[15], t[8]) && ! is_empty(t)){
      var
       blocked_read = caml_call1(Core_Queue[44], t[8]),
       consumer = blocked_read[2],
       match = blocked_read[1];
      switch(match[0]){
        case 0:
         var ivar = match[1];
         caml_call2(Async_kernel_Ivar[14], ivar, 17724);
         break;
        case 1:
         var ivar$0 = match[1], _cf_ = [0, 17724, consume_one(t, consumer)];
         caml_call2(Async_kernel_Ivar[14], ivar$0, _cf_);
         break;
        default:
         var
          ivar$1 = match[2],
          max_queue_length = match[1],
          _cg_ = [0, 17724, consume(t, max_queue_length, consumer)];
         caml_call2(Async_kernel_Ivar[14], ivar$1, _cg_);
      }
      continue;
     }
     return update_pushback(t);
    }
   }
   function transfer_in_without_pushback(t, from){
    start_write(t);
    caml_call4(Core_Queue[64], from, t[3], 0, 0);
    return finish_write(t);
   }
   function transfer_in(t, from){
    transfer_in_without_pushback(t, from);
    return pushback$1(t);
   }
   function write(t, q){return transfer_in(t, q);}
   function write_without_pushback(t, value){
    start_write(t);
    caml_call2(Core_Queue[41], t[3], value);
    return finish_write(t);
   }
   function write$0(t, value){
    write_without_pushback(t, value);
    return pushback$1(t);
   }
   function write_when_ready(t, f){
    var _ce_ = pushback$1(t);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _ce_,
             function(param){
              return is_closed(t)
                      ? -1025106484
                      : [0,
                        17724,
                        caml_call1
                         (f, function(x){return write_without_pushback(t, x);})];
             });
   }
   function write_if_open(t, x){
    return is_closed(t)
            ? caml_call1(Async_kernel_Deferred_std[10], 0)
            : write$0(t, x);
   }
   function write_without_pushback_if_open(t, x){
    var _cd_ = 1 - is_closed(t);
    return _cd_ ? write_without_pushback(t, x) : _cd_;
   }
   function ensure_consumer_matches(consumer, x_083){
    if(! consumer) return;
    var
     consumer$0 = consumer[1],
     _b$_ = caml_call2(Async_kernel_Import[6], x_083[1], consumer$0[1]);
    if(! _b$_) return _b$_;
    function of_a_074(param){return _as_;}
    var
     _ca_ =
       [0,
        [1, [0, _at_, [0, sexp_of_pipe(of_a_074, sexp_of_phantom, x_083), 0]]],
        0],
     _cb_ = [0, [1, [0, _au_, [0, sexp_of_t$0(consumer$0), 0]]], _ca_],
     _cc_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Attempt_to_use_consumer_wi),
         _cb_]];
    return caml_call1(Core[253], _cc_);
   }
   function start_read(consumer, t, label){
    if(show_debug_messages[1])
     caml_call3
      (Async_kernel_Import[14],
       label,
       t,
       function(x_084){
        return sexp_of_pipe
                (function(param){return _aw_;},
                 function(param){return _av_;},
                 x_084);
       });
    if(check_invariant[1]) invariant$0(t);
    return ensure_consumer_matches(consumer, t);
   }
   function gen_read_now(consumer, t, consume){
    start_read(consumer, t, cst_read_now);
    if(is_empty(t)) return is_closed(t) ? 3456156 : -445537353;
    if(caml_call1(Core_Queue[15], t[8]))
     return [0, 17724, caml_call2(consume, t, consumer)];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _ax_], 1);
   }
   function get_max_queue_length(max_queue_length){
    if(! max_queue_length) return Core_Int[41];
    var max_queue_length$0 = max_queue_length[1];
    if(caml_call2(Async_kernel_Import[2], max_queue_length$0, 0)){
     var
      _b9_ =
        [0,
         [1, [0, _ay_, [0, caml_call1(Core[356], max_queue_length$0), 0]]],
         0],
      _b__ =
        [1,
         [0, caml_call1(Sexplib0_Sexp_conv[7], cst_max_queue_length_0), _b9_]];
     caml_call1(Core[253], _b__);
    }
    return max_queue_length$0;
   }
   function read_now(consumer, max_queue_length, t){
    var max_queue_length$0 = get_max_queue_length(max_queue_length);
    return gen_read_now
            (consumer,
             t,
             function(t, consumer){
              return consume(t, max_queue_length$0, consumer);
             });
   }
   function read_now$0(consumer, t){
    return gen_read_now(consumer, t, consume_one);
   }
   function peek(t){return caml_call1(Core_Queue[45], t[3]);}
   function clear(t){read_now(0, 0, t); return 0;}
   function read(consumer, max_queue_length, t){
    var max_queue_length$0 = get_max_queue_length(max_queue_length);
    start_read(consumer, t, cst_read);
    var r = read_now(consumer, [0, max_queue_length$0], t);
    if(typeof r === "number" && 3456156 > r)
     return caml_call1
             (Async_kernel_Deferred[3],
              function(ivar){
               var wants = [2, max_queue_length$0, ivar];
               return caml_call2(Core_Queue[41], t[8], [0, wants, consumer]);
              });
    return caml_call1(Async_kernel_Deferred_std[10], r);
   }
   function read$0(consumer, t){
    start_read(consumer, t, cst_read$0);
    if(is_empty(t))
     return is_closed(t)
             ? caml_call1(Async_kernel_Deferred_std[10], 3456156)
             : caml_call1
               (Async_kernel_Deferred[3],
                function(ivar){
                 var wants = [1, ivar];
                 return caml_call2(Core_Queue[41], t[8], [0, wants, consumer]);
                });
    if(! caml_call1(Core_Queue[15], t[8]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _az_], 1);
    var _b8_ = [0, 17724, consume_one(t, consumer)];
    return caml_call1(Async_kernel_Deferred_std[10], _b8_);
   }
   function read_exn(consumer, t){
    var _b6_ = read$0(consumer, t);
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _b6_,
             function(param){
              if(typeof param === "number"){
               var
                _b7_ =
                  caml_call1
                   (Sexplib0_Sexp_conv[7], cst_Pipe_read_exn_received_EOF);
               return caml_call1(Core[253], _b7_);
              }
              var value = param[2];
              return value;
             });
   }
   function values_available(t){
    start_read(0, t, cst_values_available);
    if(! is_empty(t)) return caml_call1(Async_kernel_Deferred_std[10], 17724);
    if(is_closed(t))
     return caml_call1(Async_kernel_Deferred_std[10], 3456156);
    var match = caml_call1(Core_Queue[62], t[8]);
    if(match){
     var _b4_ = match[1], _b5_ = _b4_[1];
     if(0 === _b5_[0] && ! _b4_[2]){
      var ivar = _b5_[1];
      return caml_call1(Async_kernel_Ivar[18], ivar);
     }
    }
    return caml_call1
            (Async_kernel_Deferred[3],
             function(ivar){
              var wants = [0, ivar];
              return caml_call2(Core_Queue[41], t[8], [0, wants, 0]);
             });
   }
   function read_choice(t){
    var _b3_ = values_available(t);
    return caml_call2
            (Async_kernel_Deferred_std[6],
             _b3_,
             function(param){return gen_read_now(0, t, consume_one);});
   }
   function read_choice_single_consumer_ex(t, here){
    var _b0_ = read_choice(t);
    return caml_call2
            (Async_kernel_Deferred[26][1],
             _b0_,
             function(x){
              if(typeof x === "number" && 3456156 > x){
               var
                _b1_ =
                  [0,
                   [1,
                    [0,
                     _aA_,
                     [0, caml_call1(Core_Source_code_position[1], here), 0]]],
                   0],
                _b2_ =
                  [1,
                   [0,
                    caml_call1
                     (Sexplib0_Sexp_conv[7], cst_Pipe_read_choice_single_co),
                    _b1_]];
               return caml_call1(Core[253], _b2_);
              }
              return x;
             });
   }
   function read_exactly(consumer, t, num_values){
    start_read(consumer, t, cst_read_exactly);
    if(caml_call2(Async_kernel_Import[2], num_values, 0)){
     var
      _bW_ = [0, [1, [0, _aB_, [0, caml_call1(Core[356], num_values), 0]]], 0],
      _bX_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_read_exactly_got_num_),
          _bW_]];
     caml_call1(Core[253], _bX_);
    }
    return caml_call1
            (Async_kernel_Deferred[3],
             function(finish){
              var result = caml_call2(Core_Queue[61], 0, 0);
              function loop(param){
               var already_read = caml_call1(Core_Queue[14], result);
               if
                (!
                 caml_call2(Async_kernel_Import[2], already_read, num_values))
                throw caml_maybe_attach_backtrace
                       ([0, Assert_failure, _aC_], 1);
               if
                (caml_call2(Async_kernel_Import[3], already_read, num_values))
                return caml_call2
                        (Async_kernel_Ivar[14], finish, [0, -876407060, result]);
               var
                _bY_ = read(consumer, [0, num_values - already_read | 0], t);
               return caml_call2
                       (Async_kernel_Deferred_std[1],
                        _bY_,
                        function(param){
                         if(typeof param === "number"){
                          var
                           _bZ_ =
                             caml_call2(Async_kernel_Import[3], already_read, 0)
                              ? 3456156
                              : [0, 287952037, result];
                          return caml_call2(Async_kernel_Ivar[14], finish, _bZ_);
                         }
                         var q = param[2];
                         caml_call4(Core_Queue[64], q, result, 0, 0);
                         return loop(0);
                        });
              }
              return loop(0);
             });
   }
   function downstream_flushed(t){
    return is_empty(t)
            ? caml_call1
               (Core_List[8], t[11])
              ? caml_call1(Async_kernel_Deferred_std[10], 17724)
              : combine
                (caml_call2
                  (Core_List[72], t[11], values_sent_downstream_and_flu))
            : caml_call1
              (Async_kernel_Deferred[3],
               function(ready){
                var _bV_ = length(t);
                return caml_call2
                        (Core_Queue[41], t[7], [0, t[6] + _bV_ | 0, ready]);
               });
   }
   function upstream_flushed(t){
    if(caml_call1(Core_Bag[6], t[12])) return downstream_flushed(t);
    var _bU_ = caml_call1(Core_Bag[17], t[12]);
    return combine
            (caml_call2
              (Core_List[72], _bU_, function(f){return caml_call1(f, 0);}));
   }
   function add_consumer(t, downstream_flushed){
    var
     pipe_id = t[1],
     consumer = [0, pipe_id, -758792467, downstream_flushed];
    t[11] = [0, consumer, t[11]];
    return consumer;
   }
   function consumer$1(param){var t = param[1]; return t[2];}
   function create$0(upstream, downstream){
    function upstream_flushed$0(param){return upstream_flushed(upstream);}
    var _bT_ = caml_call2(Core_Bag[23], downstream[12], upstream_flushed$0);
    return [0,
            [0,
             downstream,
             add_consumer
              (upstream,
               function(param){return downstream_flushed(downstream);}),
             _bT_]];
   }
   function sexp_of_t$5(param){
    if(typeof param === "number") return param ? _aD_ : _aE_;
    var arg0_085 = param[1], res0_086 = sexp_of_t$0(arg0_085);
    return [1, [0, _aF_, [0, res0_086, 0]]];
   }
   var
    Flushed = [0, sexp_of_t$5],
    _aG_ = [0, 3804260],
    _aH_ = [0, 523273847],
    _aI_ = [0, "max_iterations_per_job"],
    cst_iter_without_pushback_got_ =
      "iter_without_pushback got non-positive max_iterations_per_job",
    _aJ_ = [0, cst_src_pipe_ml, 949, 4],
    _aK_ = [0, "Mapped"],
    cst_Pipe_interleave = "Pipe.interleave";
   function fold_gen(read_now, opt, t, init, f){
    if(opt) var sth = opt[1], flushed = sth; else var flushed = 1;
    if(typeof flushed === "number")
     var
      consumer =
        flushed
         ? 0
         : [0,
           add_consumer
            (t,
             function(param){
              return caml_call1(Async_kernel_Deferred_std[10], 17724);
             })];
    else
     var consumer$0 = flushed[1], consumer = [0, consumer$0];
    if(check_invariant[1]) invariant$0(t);
    ensure_consumer_matches(consumer, t);
    return caml_call1
            (Async_kernel_Deferred[3],
             function(finished){
              var _bR_ = caml_call1(Async_kernel_Deferred_std[10], 0);
              return caml_call2
                      (Async_kernel_Deferred_std[1],
                       _bR_,
                       function(param){
                        function loop(b){
                         var match = caml_call2(read_now, consumer, t);
                         if(typeof match !== "number"){
                          var v = match[2];
                          return caml_call3(f, b, v, continue$0);
                         }
                         if(3456156 <= match)
                          return caml_call2(Async_kernel_Ivar[14], finished, b);
                         var _bS_ = values_available(t);
                         return caml_call2
                                 (Async_kernel_Deferred_std[1],
                                  _bS_,
                                  function(param){return loop(b);});
                        }
                        function continue$0(b){
                         caml_call2
                          (Core_Option[41], consumer, values_sent_downstream);
                         return loop(b);
                        }
                        return loop(init);
                       });
             });
   }
   function fold(flushed, max_queue_length, t, init, f){
    return fold_gen
            (function(_bP_){
              return function(_bQ_){
               return read_now(_bP_, max_queue_length, _bQ_);};
             },
             flushed,
             t,
             init,
             function(b, q, loop){
              var _bO_ = caml_call2(f, b, q);
              return caml_call2(Async_kernel_Deferred_std[1], _bO_, loop);
             });
   }
   function fold$0(flushed, t, init, f){
    return fold_gen
            (read_now$0,
             flushed,
             t,
             init,
             function(b, a, loop){
              var _bN_ = caml_call2(f, b, a);
              return caml_call2(Async_kernel_Deferred_std[1], _bN_, loop);
             });
   }
   function fold_without_pushback(consumer, t, init, f){
    function _bL_(b, a, loop){return caml_call1(loop, caml_call2(f, b, a));}
    if(consumer) var c = consumer[1], _bM_ = [0, [0, c]]; else var _bM_ = 0;
    return fold_gen(read_now$0, _bM_, t, init, _bL_);
   }
   function with_error_to_current_monitor(opt, f, a){
    if(opt)
     var sth = opt[1], continue_on_error = sth;
    else
     var continue_on_error = 0;
    if(! continue_on_error) return caml_call1(f, a);
    var
     _bI_ =
       caml_call7
        (Async_kernel_Monitor[16],
         0,
         0,
         0,
         0,
         _aH_,
         _aG_,
         function(param){return caml_call1(f, a);});
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _bI_,
             function(param){
              if(0 === param[0]) return 0;
              var
               exn = param[1],
               _bJ_ = caml_call1(Async_kernel_Monitor[13], exn),
               _bK_ = caml_call1(Async_kernel_Monitor[5], 0);
              return caml_call3(Async_kernel_Monitor[15], _bK_, 0, _bJ_);
             });
   }
   function iter(continue_on_error, flushed, max_queue_length, t, f){
    return fold
            (flushed,
             max_queue_length,
             t,
             0,
             function(param, q){
              return with_error_to_current_monitor(continue_on_error, f, q);
             });
   }
   function iter$0(continue_on_error, flushed, t, f){
    return fold_gen
            (read_now$0,
             flushed,
             t,
             0,
             function(param, a, loop){
              var
               _bH_ = with_error_to_current_monitor(continue_on_error, f, a);
              return caml_call2
                      (Async_kernel_Deferred_std[1],
                       _bH_,
                       function(param){return caml_call1(loop, 0);});
             });
   }
   function iter_without_pushback(consumer, opt, max_iterations_per_job, t, f){
    if(opt)
     var sth = opt[1], continue_on_error = sth;
    else
     var continue_on_error = 0;
    ensure_consumer_matches(consumer, t);
    if(max_iterations_per_job){
     var max_iterations_per_job$0 = max_iterations_per_job[1];
     if(caml_call2(Async_kernel_Import[2], max_iterations_per_job$0, 0)){
      var
       _bB_ =
         [0,
          [1,
           [0, _aI_, [0, caml_call1(Core[356], max_iterations_per_job$0), 0]]],
          0],
       _bC_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_iter_without_pushback_got_),
           _bB_]];
      caml_call1(Core[253], _bC_);
     }
     var max_iterations_per_job$1 = max_iterations_per_job$0;
    }
    else
     var max_iterations_per_job$1 = Core_Int[41];
    var
     f$0 =
       continue_on_error
        ? function
         (a){
          try{caml_call1(f, a); return;}
          catch(exn$0){
           var
            exn = caml_wrap_exception(exn$0),
            _bG_ = caml_call1(Async_kernel_Monitor[5], 0);
           return caml_call3(Async_kernel_Monitor[15], _bG_, 0, exn);
          }
         }
        : f;
    return caml_call1
            (Async_kernel_Deferred[3],
             function(finished){
              var _bD_ = caml_call1(Async_kernel_Deferred_std[10], 0);
              return caml_call2
                      (Async_kernel_Deferred_std[1],
                       _bD_,
                       function(param){
                        function start(param){
                         a:
                         {
                          var remaining = max_iterations_per_job$1;
                          for(;;){
                           if(caml_call2(Async_kernel_Import[3], remaining, 0))
                            break a;
                           var match = gen_read_now(consumer, t, consume_one);
                           if(typeof match === "number") break;
                           var a = match[2];
                           caml_call1(f$0, a);
                           var remaining$0 = remaining - 1 | 0;
                           remaining = remaining$0;
                          }
                          if(3456156 <= match)
                           return caml_call2(Async_kernel_Ivar[14], finished, 0);
                          var _bF_ = values_available(t);
                          return caml_call2
                                  (Async_kernel_Deferred_std[1],
                                   _bF_,
                                   function(param){return start(0);});
                         }
                         var _bE_ = caml_call1(Async_kernel_Deferred_std[10], 0);
                         return caml_call2
                                 (Async_kernel_Deferred_std[1],
                                  _bE_,
                                  function(param){return start(0);});
                        }
                        return start(0);
                       });
             });
   }
   function drain(t){
    return iter
            (0,
             0,
             0,
             t,
             function(param){
              return caml_call1(Async_kernel_Deferred_std[10], 0);
             });
   }
   function drain_and_count(t){
    return fold
            (0,
             0,
             t,
             0,
             function(sum, q){
              var _bA_ = sum + caml_call1(Core_Queue[14], q) | 0;
              return caml_call1(Async_kernel_Deferred_std[10], _bA_);
             });
   }
   function read_all(input){
    var
     result = caml_call2(Core_Queue[61], 0, 0),
     _bz_ =
       iter
        (0,
         0,
         0,
         input,
         function(q){
          caml_call4(Core_Queue[64], q, result, 0, 0);
          return caml_call1(Async_kernel_Deferred_std[10], 0);
         });
    return caml_call2
            (Async_kernel_Deferred_std[5][2],
             _bz_,
             function(param){return result;});
   }
   function to_list(r){
    var _bx_ = Core_Queue[26], _by_ = read_all(r);
    return caml_call2(Async_kernel_Deferred_std[4], _by_, _bx_);
   }
   function to_stream_deprecated(t){
    return caml_call1
            (Async_kernel_Async_stream[2],
             function(tail){
              var
               _bw_ =
                 iter_without_pushback
                  (0,
                   0,
                   0,
                   t,
                   function(x){
                    return caml_call2(Async_kernel_Tail[3], tail, x);
                   });
              return caml_call2
                      (Async_kernel_Deferred_std[1],
                       _bw_,
                       function(param){
                        return caml_call1(Async_kernel_Tail[4], tail);
                       });
             });
   }
   function of_stream_deprecated(s){
    var
     match = create(0, 0, 0),
     w = match[2],
     r = match[1],
     q = caml_call2(Core_Queue[61], 0, 0);
    function transfer(param){
     var _bu_ = 1 - caml_call1(Core_Queue[15], q);
     if(! _bu_) return _bu_;
     var _bv_ = transfer_in(w, q);
     return caml_call1(Async_kernel_Deferred_std[8], _bv_);
    }
    function loop$0(counter, s){
     if(is_closed(w))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _aJ_], 1);
     var
      next_deferred = caml_call1(Async_kernel_Async_stream[3], s),
      match = caml_call1(Async_kernel_Deferred[5], next_deferred);
     if(! match){
      transfer(0);
      return caml_call2
              (Async_kernel_Deferred_std[11],
               next_deferred,
               check_closed_loop_next);
     }
     var next = match[1];
     if(counter >= 50) return caml_trampoline_return(loop_next$0, [0, next]);
     var counter$0 = counter + 1 | 0;
     return loop_next$0(counter$0, next);
    }
    function loop(s){return caml_trampoline(loop$0(0, s));}
    function check_closed_loop_next(next){
     var _bt_ = 1 - is_closed(w);
     return _bt_ ? loop_next(next) : _bt_;
    }
    function loop_next$0(counter, param){
     if(! param){transfer(0); return close(w);}
     var s = param[2], x = param[1];
     caml_call2(Core_Queue[41], q, x);
     if(counter >= 50) return caml_trampoline_return(loop$0, [0, s]);
     var counter$0 = counter + 1 | 0;
     return loop$0(counter$0, s);
    }
    function loop_next(param){return caml_trampoline(loop_next$0(0, param));}
    loop(s);
    return r;
   }
   function transfer_gen(read_now, write, input, output, f){
    if(check_invariant[1]){invariant$0(input); invariant$0(output);}
    var link = create$0(input, output), consumer = consumer$1(link);
    function unlink(param){
     var t = link[1];
     return caml_call2(Core_Bag[26], t[1][12], t[3]);
    }
    return caml_call1
            (Async_kernel_Deferred[3],
             function(result){
              var _bl_ = caml_call1(Async_kernel_Deferred_std[10], 0);
              return caml_call2
                      (Async_kernel_Deferred_std[1],
                       _bl_,
                       function(param){
                        function output_closed(param){
                         close_read(input);
                         unlink(0);
                         return caml_call2(Async_kernel_Ivar[14], result, 0);
                        }
                        function loop(param){
                         if(is_closed(output)) return output_closed(0);
                         var match = caml_call2(read_now, [0, consumer], input);
                         if(typeof match !== "number"){
                          var x = match[2];
                          return caml_call2(f, x, continue$0);
                         }
                         if(3456156 <= match){
                          unlink(0);
                          return caml_call2(Async_kernel_Ivar[14], result, 0);
                         }
                         var
                          _bm_ = closed(output),
                          _bn_ =
                            [0,
                             caml_call2
                              (Async_kernel_Deferred_std[6],
                               _bm_,
                               function(_bs_){return 0;}),
                             0],
                          _bo_ = values_available(input),
                          _bp_ =
                            [0,
                             caml_call2
                              (Async_kernel_Deferred_std[6],
                               _bo_,
                               function(_br_){return 0;}),
                             _bn_],
                          _bq_ = caml_call1(Async_kernel_Deferred_std[7], _bp_);
                         return caml_call2
                                 (Async_kernel_Deferred_std[1],
                                  _bq_,
                                  function(param){return loop(0);});
                        }
                        function continue$0(y){
                         if(is_closed(output)) return output_closed(0);
                         var pushback = caml_call2(write, output, y);
                         values_sent_downstream(consumer);
                         return caml_call2
                                 (Async_kernel_Deferred_std[1],
                                  pushback,
                                  function(param){return loop(0);});
                        }
                        return loop(0);
                       });
             });
   }
   function transfer(max_queue_length, input, output, f){
    return transfer_gen
            (function(_bj_){
              return function(_bk_){
               return read_now(_bj_, max_queue_length, _bk_);};
             },
             write,
             input,
             output,
             function(q, k){
              var _bi_ = caml_call1(f, q);
              return caml_call2(Async_kernel_Deferred_std[1], _bi_, k);
             });
   }
   function transfer$0(input, output, f){
    return transfer_gen
            (read_now$0,
             write$0,
             input,
             output,
             function(a, k){return caml_call1(k, caml_call1(f, a));});
   }
   function transfer_id(max_queue_length, input, output){
    return transfer_gen
            (function(_bg_){
              return function(_bh_){
               return read_now(_bg_, max_queue_length, _bh_);};
             },
             write,
             input,
             output,
             function(q, k){return caml_call1(k, q);});
   }
   function map_gen(read, write, input, f){
    var
     info =
       caml_call2
        (Core_Option[29],
         input[2],
         function(info){
          return [1, [0, _aK_, [0, caml_call1(Core_Sexp[90], info), 0]]];
         }),
     match = create(0, info, 0),
     output = match[2],
     result = match[1],
     _bf_ = transfer_gen(read, write, input, output, f);
    caml_call2
     (Async_kernel_Deferred_std[11],
      _bf_,
      function(param){return close(output);});
    return result;
   }
   function map(max_queue_length, input, f){
    return map_gen
            (function(_bd_){
              return function(_be_){
               return read_now(_bd_, max_queue_length, _be_);};
             },
             write,
             input,
             function(q, k){
              var _bc_ = caml_call1(f, q);
              return caml_call2(Async_kernel_Deferred_std[1], _bc_, k);
             });
   }
   function map$0(input, f){
    return map_gen
            (read_now$0,
             write$0,
             input,
             function(a, k){return caml_call1(k, caml_call1(f, a));});
   }
   function concat_map_list(max_queue_length, input, f){
    return map_gen
            (function(_ba_){
              return function(_bb_){
               return read_now(_ba_, max_queue_length, _bb_);};
             },
             write,
             input,
             function(q, k){
              return caml_call1(k, caml_call2(Core_Queue[51], q, f));
             });
   }
   function filter_map(max_queue_length, input, f){
    return map
            (max_queue_length,
             input,
             function(q){
              return caml_call3(Async_kernel_Deferred_queue[20], 0, q, f);
             });
   }
   function filter_map$0(max_queue_length, input, f){
    return map_gen
            (function(_a__){
              return function(_a$_){
               return read_now(_a__, max_queue_length, _a$_);};
             },
             write,
             input,
             function(q, k){
              return caml_call1
                      (k,
                       caml_call2
                        (Core_Queue[53],
                         q,
                         function(x){
                          return is_read_closed(input) ? 0 : caml_call1(f, x);
                         }));
             });
   }
   function folding_filter_map(max_queue_length, input, init, f){
    var accum = [0, init];
    return filter_map
            (max_queue_length,
             input,
             function(x){
              var _a9_ = caml_call2(f, accum[1], x);
              return caml_call2
                      (Async_kernel_Deferred_std[5][2],
                       _a9_,
                       function(param){
                        var x = param[2], a = param[1];
                        accum[1] = a;
                        return x;
                       });
             });
   }
   function folding_filter_map$0(max_queue_length, input, init, f){
    var accum = [0, init];
    return filter_map$0
            (max_queue_length,
             input,
             function(x){
              var
               match = caml_call2(f, accum[1], x),
               x$0 = match[2],
               a = match[1];
              accum[1] = a;
              return x$0;
             });
   }
   function folding_map(max_queue_length, input, init, f){
    return folding_filter_map$0
            (max_queue_length,
             input,
             init,
             function(accum, a){
              var
               match = caml_call2(f, accum, a),
               b = match[2],
               accum$0 = match[1];
              return [0, accum$0, [0, b]];
             });
   }
   function filter(input, f){
    return filter_map$0
            (0, input, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function of_list(l){
    var t = create_internal(0, 0, caml_call1(Core_Queue[38], l));
    caml_call2(Async_kernel_Ivar[14], t[9], 0);
    update_pushback(t);
    return t;
   }
   function empty(param){return of_list(0);}
   function singleton(x){
    var match = create(0, 0, 0), writer = match[2], reader = match[1];
    write_without_pushback(writer, x);
    close(writer);
    return reader;
   }
   function unfold(s, f){
    return create_reader
            (0,
             0,
             function(writer){
              function loop(s){
               function f$0(param){
                if(! param)
                 return caml_call1(Async_kernel_Deferred_std[10], 0);
                var match = param[1], s = match[2], a = match[1];
                if(is_closed(writer))
                 return caml_call1(Async_kernel_Deferred_std[10], 0);
                function f(param){return loop(s);}
                var d = write$0(writer, a);
                return caml_call1(Async_kernel_Deferred[5], d)
                        ? loop(s)
                        : caml_call2(Async_kernel_Deferred_std[3], d, f);
               }
               var
                d = caml_call1(f, s),
                match = caml_call1(Async_kernel_Deferred[5], d);
               if(! match)
                return caml_call2(Async_kernel_Deferred_std[3], d, f$0);
               var x = match[1];
               return f$0(x);
              }
              return loop(s);
             });
   }
   function of_sequence(sequence){
    return create_reader
            (0,
             0,
             function(writer){
              function loop(sequence$1){
               if
                (!
                 is_closed(writer)
                 && ! caml_call1(Core_Sequence[16], sequence$1)){
                start_write(writer);
                var
                 _a7_ = length(writer),
                 i$1 = (1 + writer[4] | 0) - _a7_ | 0;
                a:
                b:
                {
                 var sequence = sequence$1, i = i$1;
                 for(;;){
                  if(caml_call2(Async_kernel_Import[2], i, 0)) break b;
                  var match = caml_call1(Core_Sequence[47], sequence);
                  if(! match) break;
                  var
                   match$0 = match[1],
                   sequence$0 = match$0[2],
                   a = match$0[1];
                  caml_call2(Core_Queue[41], writer[3], a);
                  var i$0 = i - 1 | 0;
                  sequence = sequence$0;
                  i = i$0;
                 }
                 break a;
                }
                finish_write(writer);
                var _a8_ = pushback$1(writer);
                return caml_call2
                        (Async_kernel_Deferred_std[5][1],
                         _a8_,
                         function(param){return loop(sequence);});
               }
               return caml_call1(Async_kernel_Deferred_std[10], 0);
              }
              return loop(sequence);
             });
   }
   function to_sequence(t){
    return caml_call2
            (Core_Sequence[49],
             0,
             function(param){
              var match = gen_read_now(0, t, consume_one);
              if(typeof match === "number")
               return 3456156 <= match
                       ? 0
                       : [0, [0, [1, values_available(t)], 0]];
              var a = match[2];
              return [0, [0, [0, a], 0]];
             });
   }
   function interleave_pipe(inputs){
    var
     match =
       create
        (0, [0, caml_call1(Sexplib0_Sexp_conv[7], cst_Pipe_interleave)], 0),
     output_writer = match[2],
     output = match[1],
     num_pipes_remaining = [0, 1];
    function decr_num_pipes_remaining(param){
     num_pipes_remaining[1]--;
     var _a6_ = caml_call2(Async_kernel_Import[3], num_pipes_remaining[1], 0);
     return _a6_ ? close(output_writer) : _a6_;
    }
    var
     _a2_ =
       iter_without_pushback
        (0,
         0,
         0,
         inputs,
         function(input){
          num_pipes_remaining[1]++;
          var
           _a4_ = transfer_id(0, input, output_writer),
           _a5_ =
             caml_call2
              (Async_kernel_Deferred_std[5][2],
               _a4_,
               function(param){return decr_num_pipes_remaining(0);});
          return caml_call1(Async_kernel_Deferred_std[8], _a5_);
         }),
     _a3_ =
       caml_call2
        (Async_kernel_Deferred_std[5][2],
         _a2_,
         function(param){return decr_num_pipes_remaining(0);});
    caml_call1(Async_kernel_Deferred_std[8], _a3_);
    return output;
   }
   function interleave(inputs){
    if(check_invariant[1]) caml_call2(Core_List[9], inputs, invariant$0);
    return interleave_pipe(of_list(inputs));
   }
   function merge(inputs, compare){
    if(! inputs) return empty(0);
    if(inputs[2]){
     var
      match = create(0, 0, 0),
      w = match[2],
      r = match[1],
      _aU_ = closed(w);
     caml_call2
      (Async_kernel_Deferred_std[11],
       _aU_,
       function(param){return caml_call2(Core_List[9], inputs, close_read);});
     var
      heap =
        caml_call3
         (Pairing_heap[20],
          0,
          function(param, _a1_){
           var a2 = _a1_[1], a1 = param[1];
           return caml_call2(compare, a1, a2);
          },
          0),
      handle_read =
        function(input, eof_or_ok){
         if(typeof eof_or_ok === "number") return 0;
         var v = eof_or_ok[2];
         return caml_call2(Pairing_heap[25], heap, [0, v, input]);
        },
      pop_heap_and_loop =
        function(param){
         for(;;){
          var match = caml_call1(Pairing_heap[28], heap);
          if(! match) return close(w);
          var
           match$0 = match[1],
           input = match$0[2],
           v = match$0[1],
           _aW_ = 1 - is_closed(w);
          if(! _aW_) return _aW_;
          write_without_pushback(w, v);
          var _aX_ = caml_call1(Pairing_heap[3], heap);
          if(caml_call2(Async_kernel_Import[3], _aX_, 0)){
           var _aY_ = transfer_id(0, input, w);
           return caml_call2
                   (Async_kernel_Deferred_std[11],
                    _aY_,
                    function(param){return close(w);});
          }
          var x = gen_read_now(0, input, consume_one);
          if(typeof x === "number" && 3456156 > x){
           var _aZ_ = pushback$1(w);
           return caml_call2
                   (Async_kernel_Deferred_std[1],
                    _aZ_,
                    function(param){
                     var _a0_ = read$0(0, input);
                     return caml_call2
                             (Async_kernel_Deferred_std[1],
                              _a0_,
                              function(x){
                               handle_read(input, x);
                               return pop_heap_and_loop(0);
                              });
                    });
          }
          handle_read(input, x);
         }
        },
      initial_push =
        caml_call3
         (Async_kernel_Deferred_list[14],
          0,
          inputs,
          function(input){
           var _aV_ = read$0(0, input);
           return caml_call2
                   (Async_kernel_Deferred_std[5][2],
                    _aV_,
                    function(x){return handle_read(input, x);});
          });
     caml_call2
      (Async_kernel_Deferred_std[11], initial_push, pop_heap_and_loop);
     return r;
    }
    var input = inputs[1];
    return input;
   }
   function concat_pipe(inputs){
    var
     r =
       create_reader_not_close_on_exc
        (0,
         function(w){
          var link = create$0(inputs, w), consumer = consumer$1(link);
          return iter$0
                  (0,
                   [0, [0, consumer]],
                   inputs,
                   function(input){return transfer_id(0, input, w);});
         }),
     _aT_ = closed(r);
    caml_call2
     (Async_kernel_Deferred_std[11],
      _aT_,
      function(param){return close(inputs);});
    return r;
   }
   function concat(inputs){
    return create_reader_not_close_on_exc
            (0,
             function(w){
              return caml_call3
                      (Async_kernel_Deferred_list[14],
                       0,
                       inputs,
                       function(input){return transfer_id(0, input, w);});
             });
   }
   function fork(t, pushback_uses){
    var
     match = create(0, 0, 0),
     writer0 = match[2],
     reader0 = match[1],
     match$0 = create(0, 0, 0),
     writer1 = match$0[2],
     reader1 = match$0[1],
     some_reader_was_closed = [0, 0],
     consumer =
       add_consumer
        (t,
         function(param){
          var
           some_reader_was_closed$0 = some_reader_was_closed[1],
           _aR_ = [0, downstream_flushed(writer1), 0],
           _aS_ = combine([0, downstream_flushed(writer0), _aR_]);
          return caml_call2
                  (Async_kernel_Deferred_std[5][2],
                   _aS_,
                   function(param){
                    return 17724 <= param
                            ? some_reader_was_closed$0 ? -402004920 : 17724
                            : -402004920;
                   });
         }),
     still_open = [0, writer0, [0, writer1, 0]];
    function filter_open(still_open){
     if(! caml_call2(Core_List[13], still_open, is_closed)) return still_open;
     some_reader_was_closed[1] = 1;
     var
      still_open$0 =
        caml_call2
         (Core_List[50], still_open, function(w){return 1 - is_closed(w);});
     if(caml_call1(Core_List[8], still_open$0)) close(t);
     return still_open$0;
    }
    var
     _aL_ =
       fold
        ([0, [0, consumer]],
         0,
         t,
         still_open,
         function(still_open, queue){
          var still_open$0 = filter_open(still_open);
          if(caml_call1(Core_List[8], still_open$0))
           return caml_call1(Async_kernel_Deferred_std[10], 0);
          function _aN_(param){
           var still_open = filter_open(still_open$0);
           caml_call2
            (Core_List[9],
             still_open,
             function(w){
              start_write(w);
              caml_call2
               (Core_Queue[16],
                queue,
                function(x){return caml_call2(Core_Queue[41], w[3], x);});
              return finish_write(w);
             });
           return still_open;
          }
          if(-648027566 <= pushback_uses)
           var
            _aO_ = caml_call2(Core_List[72], still_open$0, pushback$1),
            _aP_ = caml_call1(Async_kernel_Deferred[23], _aO_);
          else
           var
            _aQ_ = caml_call2(Core_List[72], still_open$0, pushback$1),
            _aP_ = caml_call1(Async_kernel_Deferred[22], _aQ_);
          return caml_call2(Async_kernel_Deferred_std[5][2], _aP_, _aN_);
         }),
     _aM_ =
       caml_call2
        (Async_kernel_Deferred_std[5][1],
         _aL_,
         function(still_open){
          caml_call2(Core_List[9], still_open, close);
          return caml_call1(Async_kernel_Deferred_std[10], 0);
         });
    caml_call1(Async_kernel_Deferred_std[8], _aM_);
    return [0, reader0, reader1];
   }
   function set_info(t, info){var v = [0, info]; t[2] = v; return 0;}
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Pipe);
   var
    Async_kernel_Pipe =
      [0,
       sexp_of_pipe,
       sexp_of_pipe,
       [0, sexp_of_t$4, invariant$0],
       [0, sexp_of_t$3, invariant$0],
       create_reader,
       create_writer,
       create,
       empty,
       of_list,
       singleton,
       unfold,
       of_sequence,
       to_sequence,
       close,
       close_read,
       is_closed,
       closed,
       [0, compare, sexp_of_t],
       upstream_flushed,
       downstream_flushed,
       [0, values_sent_downstream],
       add_consumer,
       length,
       is_empty,
       pushback$1,
       write$0,
       write_without_pushback,
       transfer_in,
       transfer_in_without_pushback,
       write_when_ready,
       write_if_open,
       write_without_pushback_if_open,
       read,
       read$0,
       read_exn,
       read_exactly,
       read_now,
       read_now$0,
       peek,
       clear,
       read_all,
       values_available,
       read_choice,
       read_choice_single_consumer_ex,
       Flushed,
       fold,
       fold$0,
       fold_without_pushback,
       iter,
       iter$0,
       iter_without_pushback,
       transfer,
       transfer$0,
       transfer_id,
       map,
       map$0,
       concat_map_list,
       folding_map,
       filter_map,
       filter_map$0,
       folding_filter_map,
       folding_filter_map$0,
       filter,
       interleave,
       interleave_pipe,
       merge,
       concat,
       concat_pipe,
       fork,
       to_stream_deprecated,
       of_stream_deprecated,
       drain,
       drain_and_count,
       to_list,
       hash,
       equal$0,
       compare$0,
       size_budget,
       set_size_budget$0,
       show_debug_messages,
       check_invariant,
       set_info];
   runtime.caml_register_global(171, Async_kernel_Pipe, cst_Async_kernel_Pipe);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Mvar
//# unitInfo: Requires: Assert_failure, Async_kernel__Bvar, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Pipe, Base__Field, Base__Invariant, Core, Core__Unit, Expect_test_collector, Moption, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Mvar = "Async_kernel__Mvar",
    cst_async_kernel = "async_kernel",
    cst_current_value = "current_value",
    cst_src_mvar_ml = "src/mvar.ml",
    cst_taken = "taken",
    cst_value_available = "value_available",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos = "src/mvar.ml:23:26",
    cst = "",
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Pipe = global_data.Async_kernel__Pipe,
    Async_kernel_Bvar = global_data.Async_kernel__Bvar,
    Moption = global_data.Moption,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Core = global_data.Core,
    Assert_failure = global_data.Assert_failure,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant,
    Core_Unit = global_data.Core__Unit;
   global_data.Base__Field;
   var
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Mvar);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_mvar_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   function value_available(r){return r[3];}
   function set_value_available(r, v){r[3] = v; return 0;}
   function taken(r){return r[2];}
   function current_value(r){return r[1];}
   var
    value_available$0 =
      [0,
       function(param){return 0;},
       cst_value_available,
       [0, set_value_available],
       value_available,
       function(r, v){return [0, r[1], r[2], v];}],
    taken$0 =
      [0,
       function(param){return 0;},
       cst_taken,
       0,
       taken,
       function(r, v){return [0, r[1], v, r[3]];}],
    current_value$0 =
      [0,
       function(param){return 0;},
       cst_current_value,
       0,
       current_value,
       function(r, v){return [0, v, r[2], r[3]];}],
    _a_ = [0, cst_value_available],
    _b_ = [0, cst_taken],
    _c_ = [0, cst_current_value],
    _d_ = [0, "_"],
    _e_ = [0, cst_src_mvar_ml, 16, 357, 379],
    cst_Mvar_peek_exn_called_on_em = "Mvar.peek_exn called on empty mvar";
   function value_available$1(t){
    return caml_call1(Async_kernel_Ivar[18], t[3]);
   }
   function is_empty(t){return caml_call1(Moption[5], t[1]);}
   function invariant(invariant_a, param, t){
    return caml_call4
            (Base_Invariant[1],
             _e_,
             t,
             function(x_010){
              function of_a_001(param){return _d_;}
              var
               taken_006 = x_010[2],
               current_value_004 = x_010[1],
               value_available_008 = x_010[3],
               arg_009 =
                 caml_call2
                  (Async_kernel_Ivar[9], Core[518], value_available_008),
               bnds_003 = [0, [1, [0, _a_, [0, arg_009, 0]]], 0],
               arg_007 =
                 caml_call3
                  (Async_kernel_Bvar[1], Core[518], Core[202], taken_006),
               bnds_003$0 = [0, [1, [0, _b_, [0, arg_007, 0]]], bnds_003],
               arg_005 = caml_call2(Moption[1], of_a_001, current_value_004),
               bnds_003$1 = [0, [1, [0, _c_, [0, arg_005, 0]]], bnds_003$0];
              return [1, bnds_003$1];
             },
             function(param){
              function check(f){return caml_call2(Base_Invariant[2], t, f);}
              var
               value_available_fun =
                 check
                  (function(value_available){
                    var
                     got = caml_call1(Async_kernel_Ivar[17], value_available),
                     expect = caml_call1(Moption[6], t[1]),
                     sexpifier = Core[305];
                    function comparator(a_011, b_012){
                     return caml_call2(Core[301], a_011, b_012);
                    }
                    return caml_call8
                            (Ppx_assert_lib_Runtime[3],
                             pos,
                             sexpifier,
                             comparator,
                             0,
                             0,
                             0,
                             expect,
                             got);
                   }),
               taken_fun =
                 check
                  (caml_call2
                    (Async_kernel_Bvar[2],
                     Core_Unit[5],
                     function(_s_){return 0;})),
               current_value_fun = check(caml_call1(Moption[2], invariant_a));
              caml_call1(current_value_fun, current_value$0);
              caml_call1(taken_fun, taken$0);
              return caml_call1(value_available_fun, value_available$0);
             });
   }
   function peek(t){return caml_call1(Moption[7], t[1]);}
   function peek_exn(t){
    if(is_empty(t)){
     var
      _r_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Mvar_peek_exn_called_on_em);
     caml_call1(Core[253], _r_);
    }
    return caml_call1(Moption[8], t[1]);
   }
   function sexp_of_t(sexp_of_a, param, t){
    var x_013 = peek(t);
    return caml_call2(Core[454], sexp_of_a, x_013);
   }
   function sexp_of_t$0(of_a_014, x_015){
    return sexp_of_t(of_a_014, Core[202], x_015);
   }
   function invariant$0(invariant_a, t){
    return invariant(invariant_a, function(_q_){return 0;}, t);
   }
   var Read_write = [0, sexp_of_t$0, invariant$0];
   function sexp_of_t$1(of_a_016, x_017){
    return sexp_of_t(of_a_016, Core[171], x_017);
   }
   function invariant$1(invariant_a, t){
    return invariant(invariant_a, function(_p_){return 0;}, t);
   }
   var
    Read_only = [0, sexp_of_t$1, invariant$1],
    _f_ = [0, cst_src_mvar_ml, 60, 2],
    cst_Mvar_take_exn_called_on_em = "Mvar.take_exn called on empty mvar";
   function read_only(t){return t;}
   function write_only(t){return t;}
   function create(param){
    var
     _n_ = caml_call1(Async_kernel_Ivar[12], 0),
     _o_ = caml_call1(Async_kernel_Bvar[3], 0);
    return [0, caml_call1(Moption[4], 0), _o_, _n_];
   }
   function take_nonempty(t){
    if(is_empty(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    var r = caml_call1(Moption[8], t[1]);
    caml_call1(Moption[11], t[1]);
    caml_call2(Async_kernel_Bvar[5], t[2], 0);
    t[3] = caml_call1(Async_kernel_Ivar[12], 0);
    return r;
   }
   function take_now_exn(t){
    if(is_empty(t)){
     var
      _m_ = caml_call1(Sexplib0_Sexp_conv[7], cst_Mvar_take_exn_called_on_em);
     caml_call1(Core[253], _m_);
    }
    return take_nonempty(t);
   }
   function take_now(t){return is_empty(t) ? 0 : [0, take_nonempty(t)];}
   function take(t){
    if(is_empty(t)){
     var _k_ = value_available$1(t);
     return caml_call2
             (Async_kernel_Deferred_std[5][1],
              _k_,
              function(param){return take(t);});
    }
    var _l_ = take_nonempty(t);
    return caml_call1(Async_kernel_Deferred_std[10], _l_);
   }
   function set(t, v){
    caml_call2(Moption[12], t[1], v);
    return caml_call2(Async_kernel_Ivar[15], t[3], 0);
   }
   function update(t, f){return set(t, caml_call1(f, peek(t)));}
   function update_exn(t, f){return set(t, caml_call1(f, peek_exn(t)));}
   function taken$1(t){return caml_call1(Async_kernel_Bvar[4], t[2]);}
   function put(t, v){
    if(is_empty(t)){
     set(t, v);
     return caml_call1(Async_kernel_Deferred_std[10], 0);
    }
    var _j_ = taken$1(t);
    return caml_call2
            (Async_kernel_Deferred_std[5][1],
             _j_,
             function(param){return put(t, v);});
   }
   function pipe_when_ready(t){
    var
     match = caml_call3(Async_kernel_Pipe[7], 0, 0, 0),
     w = match[2],
     r = match[1];
    function loop(param){
     var _h_ = value_available$1(t);
     return caml_call2
             (Async_kernel_Deferred_std[5][1],
              _h_,
              function(param){
               if(caml_call1(Async_kernel_Pipe[16], w))
                return caml_call1(Async_kernel_Deferred_std[10], 0);
               var match = take_now(t);
               if(! match) return loop(0);
               var
                x = match[1],
                _i_ = caml_call2(Async_kernel_Pipe[26], w, x);
               return caml_call2
                       (Async_kernel_Deferred_std[5][1],
                        _i_,
                        function(param){return loop(0);});
              });
    }
    var _g_ = loop(0);
    caml_call1(Async_kernel_Deferred_std[8], _g_);
    return r;
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Mvar);
   var
    Async_kernel_Mvar =
      [0,
       sexp_of_t,
       Read_write,
       Read_only,
       create,
       is_empty,
       put,
       set,
       update,
       update_exn,
       read_only,
       write_only,
       value_available$1,
       take,
       take_now,
       take_now_exn,
       taken$1,
       peek,
       peek_exn,
       pipe_when_ready];
   runtime.caml_register_global(37, Async_kernel_Mvar, cst_Async_kernel_Mvar);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Lazy_deferred
//# unitInfo: Requires: Async_kernel__Deferred, Async_kernel__Deferred_std, Async_kernel__Ivar, Async_kernel__Monitor, Base__Monad, Core, Core__Option, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Lazy_deferred = "Async_kernel__Lazy_deferred",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core = global_data.Core,
    Core_Option = global_data.Core__Option,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Async_kernel_Deferred_std = global_data.Async_kernel__Deferred_std,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Base_Monad = global_data.Base__Monad;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Lazy_deferred);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/lazy_deferred.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, 3804260], _b_ = [0, 3804260];
   function create(f){
    var
     start = caml_call1(Async_kernel_Ivar[12], 0),
     _j_ = caml_call1(Async_kernel_Ivar[18], start);
    return [0,
            start,
            caml_call2
             (Async_kernel_Deferred_std[5][1],
              _j_,
              function(param){
               return caml_call6(Async_kernel_Monitor[17], 0, 0, 0, 0, _a_, f);
              })];
   }
   function create_or_error(f){
    var
     start = caml_call1(Async_kernel_Ivar[12], 0),
     _i_ = caml_call1(Async_kernel_Ivar[18], start);
    return [0,
            start,
            caml_call2
             (Async_kernel_Deferred_std[5][1],
              _i_,
              function(param){
               return caml_call6(Async_kernel_Monitor[18], 0, 0, 0, 0, _b_, f);
              })];
   }
   function wait(t){return t[2];}
   function wait_exn(t){
    return caml_call2(Async_kernel_Deferred_std[4], t[2], Core[245]);
   }
   function force(t){caml_call2(Async_kernel_Ivar[15], t[1], 0); return t[2];}
   function force_exn(t){
    var _g_ = Core[245], _h_ = force(t);
    return caml_call2(Async_kernel_Deferred_std[4], _h_, _g_);
   }
   function return$0(a){
    return create
            (function(param){
              return caml_call1(Async_kernel_Deferred_std[10], a);
             });
   }
   function bind(t, f){
    return create
            (function(param){
              var _f_ = force_exn(t);
              return caml_call2
                      (Async_kernel_Deferred_std[5][1],
                       _f_,
                       function(a){return force_exn(caml_call1(f, a));});
             });
   }
   var
    map =
      [0,
       -198771759,
       function(t, f){
        return create
                (function(param){
                  var _e_ = force_exn(t);
                  return caml_call2(Async_kernel_Deferred_std[4], _e_, f);
                 });
       }],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   function bind$1(t, f){
    return caml_call2
            (bind$0,
             t,
             function(a){
              return create(function(param){return caml_call1(f, a);});
             });
   }
   function is_forced(t){return caml_call1(Async_kernel_Ivar[17], t[1]);}
   function is_determined(t){
    return caml_call1(Async_kernel_Deferred[7], t[2]);
   }
   function peek(t){return caml_call1(Async_kernel_Deferred[5], t[2]);}
   function peek_exn(t){
    var _c_ = Core[245], _d_ = peek(t);
    return caml_call2(Core_Option[29], _d_, _c_);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Lazy_deferred);
   var
    Async_kernel_Lazy_deferred =
      [0,
       create,
       create_or_error,
       force,
       force_exn,
       wait,
       wait_exn,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       bind$1,
       peek,
       peek_exn,
       is_determined,
       is_forced];
   runtime.caml_register_global
    (20, Async_kernel_Lazy_deferred, cst_Async_kernel_Lazy_deferred);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_condition
//# unitInfo: Requires: Async_kernel__Deferred, Async_kernel__Ivar, Core__Option, Core__Queue, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_conditi = "Async_kernel__Async_condition",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Ivar = global_data.Async_kernel__Ivar,
    Core_Queue = global_data.Core__Queue,
    Core_Option = global_data.Core__Option,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_conditi);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/async_condition.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var _a_ = [0, "waits"];
   function sexp_of_t(of_a_001, param){
    var
     waits_003 = param[1],
     _c_ = caml_call1(Async_kernel_Ivar[9], of_a_001),
     arg_004 = caml_call2(Core_Queue[11], _c_, waits_003),
     bnds_002 = [0, [1, [0, _a_, [0, arg_004, 0]]], 0];
    return [1, bnds_002];
   }
   function create(param){return [0, caml_call2(Core_Queue[61], 0, 0)];}
   function wait(t){
    return caml_call1
            (Async_kernel_Deferred[3],
             function(ivar){return caml_call2(Core_Queue[41], t[1], ivar);});
   }
   function signal(t, a){
    var _b_ = caml_call1(Core_Queue[43], t[1]);
    return caml_call2
            (Core_Option[41],
             _b_,
             function(ivar){
              return caml_call2(Async_kernel_Ivar[14], ivar, a);
             });
   }
   function broadcast(t, a){
    caml_call2
     (Core_Queue[16],
      t[1],
      function(ivar){return caml_call2(Async_kernel_Ivar[14], ivar, a);});
    return caml_call1(Core_Queue[47], t[1]);
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_conditi);
   var
    Async_kernel_Async_condition =
      [0, sexp_of_t, create, signal, broadcast, wait];
   runtime.caml_register_global
    (16, Async_kernel_Async_condition, cst_Async_kernel_Async_conditi);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_gc
//# unitInfo: Requires: Async_kernel__Scheduler, Core__Gc, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_gc = "Async_kernel__Async_gc",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Core_Gc = global_data.Core__Gc;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_gc);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/async_gc.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    Stat = Core_Gc[1],
    Control = Core_Gc[2],
    print_stat = Core_Gc[3],
    allocated_bytes = Core_Gc[4],
    keep_alive = Core_Gc[5],
    Allocation_policy = Core_Gc[6],
    tune = Core_Gc[7],
    disable_compaction = Core_Gc[8],
    For_testing = Core_Gc[9],
    Stable = Core_Gc[11];
   function add_finalizer(heap_block, f){
    var _e_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[46], _e_), heap_block, f);
   }
   function add_finalizer_exn(heap_block, f){
    var _d_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[47], _d_), heap_block, f);
   }
   function add_finalizer_last(heap_block, f){
    var _c_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[48], _c_), heap_block, f);
   }
   function add_finalizer_last_exn(heap_block, f){
    var _b_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call2
            (caml_call1(Async_kernel_Scheduler[49], _b_), heap_block, f);
   }
   var sexp_of_t = Core_Gc[10][6][1];
   function create(f){
    var _a_ = caml_call1(Async_kernel_Scheduler[2], 0);
    return caml_call1(caml_call1(Async_kernel_Scheduler[45], _a_), f);
   }
   var delete$0 = Core_Gc[10][6][3], Alarm = [0, sexp_of_t, create, delete$0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_gc);
   var
    Async_kernel_Async_gc =
      [0,
       Stat,
       Control,
       print_stat,
       allocated_bytes,
       keep_alive,
       Allocation_policy,
       tune,
       disable_compaction,
       For_testing,
       Stable,
       add_finalizer,
       add_finalizer_exn,
       add_finalizer_last,
       add_finalizer_last_exn,
       Alarm];
   runtime.caml_register_global
    (13, Async_kernel_Async_gc, cst_Async_kernel_Async_gc);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_invariant_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_invaria = "Async_kernel__Async_invariant_intf",
    cst_async_kernel = "async_kernel";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_invaria);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/async_invariant_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var Async = [0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_invaria);
   var Async_kernel_Async_invariant_i = [0, Async];
   runtime.caml_register_global
    (11, Async_kernel_Async_invariant_i, cst_Async_kernel_Async_invaria);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel__Async_invariant
//# unitInfo: Requires: Async_kernel__Async_invariant_intf, Async_kernel__Deferred, Async_kernel__Monitor, Base__Field, Base__Invariant, Core, Core__Source_code_position, Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel_Async_invaria = "Async_kernel__Async_invariant",
    cst_async_kernel = "async_kernel",
    cst_exn = "exn";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Field = global_data.Base__Field,
    Core = global_data.Core,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Core_Source_code_position = global_data.Core__Source_code_position,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Base_Invariant = global_data.Base__Invariant;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel_Async_invaria);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], "src/async_invariant.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    invariant = Base_Invariant[1],
    check_field = Base_Invariant[2],
    _a_ = [0, cst_exn],
    cst_invariant_failed = "invariant failed",
    _b_ = [0, 3804260],
    _c_ = [0, 523273847],
    _d_ = [0, 1],
    _e_ = [0, cst_exn],
    _f_ = [0, "field"],
    cst_problem_with_field = "problem with field",
    _g_ = [0, 3804260],
    _h_ = [0, 523273847],
    _i_ = [0, 1];
   function invariant$0(here, t, sexp_of_t, f){
    var _o_ = caml_call7(Async_kernel_Monitor[16], 0, 0, 0, _d_, _c_, _b_, f);
    return caml_call2
            (Async_kernel_Deferred[16][4][3],
             _o_,
             function(param){
              if(0 === param[0]) return 0;
              var
               exn = param[1],
               _p_ = [0, caml_call1(sexp_of_t, t), 0],
               _q_ =
                 [0, [1, [0, _a_, [0, caml_call1(Core[537], exn), 0]]], _p_],
               _r_ = [0, caml_call1(Core_Source_code_position[1], here), _q_],
               _s_ =
                 [1,
                  [0,
                   caml_call1(Sexplib0_Sexp_conv[7], cst_invariant_failed),
                   _r_]];
              return caml_call1(Core[253], _s_);
             });
   }
   function check_field$0(t, f, wait_for_previous, field){
    return caml_call2
            (Async_kernel_Deferred[16][4][2],
             wait_for_previous,
             function(param){
              var
               _j_ =
                 caml_call7
                  (Async_kernel_Monitor[16],
                   0,
                   0,
                   0,
                   _i_,
                   _h_,
                   _g_,
                   function(param){
                    return caml_call1(f, caml_call2(Base_Field[3], field, t));
                   });
              return caml_call2
                      (Async_kernel_Deferred[16][4][3],
                       _j_,
                       function(param){
                        if(0 === param[0]) return 0;
                        var
                         exn = param[1],
                         _k_ =
                           [0, [1, [0, _e_, [0, caml_call1(Core[537], exn), 0]]], 0],
                         _l_ = caml_call1(Base_Field[2], field),
                         _m_ =
                           [0, [1, [0, _f_, [0, caml_call1(Core[471], _l_), 0]]], _k_],
                         _n_ =
                           [1,
                            [0,
                             caml_call1(Sexplib0_Sexp_conv[7], cst_problem_with_field),
                             _m_]];
                        return caml_call1(Core[253], _n_);
                       });
             });
   }
   var Async = [0, invariant$0, check_field$0];
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel_Async_invaria);
   var Async_kernel_Async_invariant = [0, invariant, check_field, Async];
   runtime.caml_register_global
    (29, Async_kernel_Async_invariant, cst_Async_kernel_Async_invaria);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Async_kernel
//# unitInfo: Requires: Async_kernel__Async_gc, Async_kernel__Clock_ns, Async_kernel__Deferred, Async_kernel__Deferred_result, Async_kernel__Monitor, Async_kernel__Scheduler, Core, Expect_test_collector, Inline_test_config, Ppx_assert_lib__Runtime, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Async_kernel = "Async_kernel",
    cst_async_kernel = "async_kernel",
    cst_src_async_kernel_ml = "src/async_kernel.ml";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    pos = "src/async_kernel.ml:94:17",
    cst = "",
    Core = global_data.Core,
    Ppx_assert_lib_Runtime = global_data.Ppx_assert_lib__Runtime,
    Async_kernel_Deferred = global_data.Async_kernel__Deferred,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime,
    Async_kernel_Clock_ns = global_data.Async_kernel__Clock_ns,
    Async_kernel_Monitor = global_data.Async_kernel__Monitor,
    Async_kernel_Scheduler = global_data.Async_kernel__Scheduler,
    Async_kernel_Deferred_result = global_data.Async_kernel__Deferred_result,
    Inline_test_config = global_data.Inline_test_config;
   caml_call1(Ppx_module_timer_runtime[4], cst_Async_kernel);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_async_kernel);
   caml_call1(Expect_test_collector[5][1], cst_src_async_kernel_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_async_kernel, cst);
   var
    after = Async_kernel_Clock_ns[4],
    at = Async_kernel_Clock_ns[3],
    catch$0 = Async_kernel_Monitor[21],
    choice = Async_kernel_Deferred[27],
    choose = Async_kernel_Deferred[29],
    don_t_wait_for = Async_kernel_Deferred[25],
    every = Async_kernel_Clock_ns[10],
    never = Async_kernel_Deferred[19],
    schedule = Async_kernel_Scheduler[59],
    schedule$0 = Async_kernel_Scheduler[58],
    try_with = Async_kernel_Monitor[16],
    upon = Async_kernel_Deferred[4],
    with_timeout = Async_kernel_Clock_ns[5],
    within = Async_kernel_Scheduler[56],
    within$0 = Async_kernel_Scheduler[55],
    symbol = Async_kernel_Deferred[17][3],
    symbol$0 = Async_kernel_Deferred_result[1],
    symbol$1 = Async_kernel_Deferred_result[2],
    include = Async_kernel_Deferred[16],
    return$0 = include[1],
    symbol_bind = include[2],
    symbol_map = include[3],
    Let_syntax = include[4],
    Async_kernel_private = [0];
   caml_call8
    (Ppx_inline_test_lib_Runtime[5],
     Inline_test_config,
     "[return ()] does not allocate",
     0,
     cst_src_async_kernel_ml,
     87,
     0,
     443,
     function(param){
      var expect = runtime.core_gc_minor_words(0);
      caml_call1(return$0, 0);
      caml_call1(Async_kernel_Deferred[12], 0);
      caml_call1(Async_kernel_Deferred[16][1], 0);
      caml_call1(Async_kernel_Deferred[16][4][1], 0);
      var got = runtime.core_gc_minor_words(0), sexpifier = Core[356];
      function comparator(a_001, b_002){
       return caml_call2(Core[352], a_001, b_002);
      }
      caml_call8
       (Ppx_assert_lib_Runtime[3],
        pos,
        sexpifier,
        comparator,
        0,
        0,
        0,
        expect,
        got);
      return 0;
     });
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_async_kernel);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Async_kernel);
   var
    Async_kernel =
      [0,
       after,
       at,
       catch$0,
       choice,
       choose,
       don_t_wait_for,
       every,
       never,
       schedule,
       schedule$0,
       try_with,
       upon,
       with_timeout,
       within,
       within$0,
       symbol,
       symbol$0,
       symbol$1,
       return$0,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Async_kernel_private];
   runtime.caml_register_global(22, Async_kernel, cst_Async_kernel);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJhc3luY19rZXJuZWwuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImFmdGVyIiwidCIsInNwYW4iLCJyZXN1bHQiLCJsb2ciLCJhcmcyXzAwMyIsImFyZzNfMDA0Iiwic2V4cF9vZl9hIiwiYXJnMV8wMDIiLCJhcmcwXzAwMSIsInJlczBfMDA1IiwicmVzMV8wMDYiLCJyZXMyXzAwNyIsInJlczNfMDA4IiwibG9nX3N0cmluZyIsIm1lc3NhZ2UiLCJjb25jYXQiLCJlcHJpbnQiLCJlcHJpbnRfcyIsImVwcmludHMiLCJwcmludF9zIiwic2V4cCIsInNlYyIsInNleHBfb2ZfdCIsInRvX3JlcHIiLCJvZl9yZXByIiwibmFtZXMiLCJkZWJ1ZyIsImZvcndhcmRpbmciLCJyIiwic2V0X2ZvcndhcmRpbmciLCJ2IiwiaGFzX3NlZW5fZXJyb3IiLCJzZXRfaGFzX3NlZW5fZXJyb3IiLCJ0YWlsc19mb3JfYWxsX2Vycm9ycyIsInNldF90YWlsc19mb3JfYWxsX2Vycm9ycyIsImhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzIiwic2V0X2hhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzIiwibmV4dF9lcnJvciIsInNldF9uZXh0X2Vycm9yIiwiaWQiLCJoZXJlIiwibmFtZSIsImZvcndhcmRpbmckMCIsImhhc19zZWVuX2Vycm9yJDAiLCJ0YWlsc19mb3JfYWxsX2Vycm9ycyQwIiwiaGFuZGxlcnNfZm9yX2FsbF9lcnJvcnMkMCIsIm5leHRfZXJyb3IkMCIsImlkJDAiLCJoZXJlJDAiLCJuYW1lJDAiLCJtYWtlX2NyZWF0b3IiLCJuYW1lX2Z1biIsImhlcmVfZnVuIiwiaWRfZnVuIiwibmV4dF9lcnJvcl9mdW4iLCJoYW5kbGVyc19mb3JfYWxsX2Vycm9yc19mdW4iLCJ0YWlsc19mb3JfYWxsX2Vycm9yc19mdW4iLCJoYXNfc2Vlbl9lcnJvcl9mdW4iLCJmb3J3YXJkaW5nX2Z1biIsImNvbXBpbGVfYWNjIiwiY29tcGlsZV9hY2MkMCIsIm5hbWVfZ2VuIiwiY29tcGlsZV9hY2MkMSIsImhlcmVfZ2VuIiwiY29tcGlsZV9hY2MkMiIsImlkX2dlbiIsImNvbXBpbGVfYWNjJDMiLCJuZXh0X2Vycm9yX2dlbiIsImNvbXBpbGVfYWNjJDQiLCJoYW5kbGVyc19mb3JfYWxsX2Vycm9yc19nZW4iLCJjb21waWxlX2FjYyQ1IiwidGFpbHNfZm9yX2FsbF9lcnJvcnNfZ2VuIiwiY29tcGlsZV9hY2MkNiIsImhhc19zZWVuX2Vycm9yX2dlbiIsImNvbXBpbGVfYWNjJDciLCJmb3J3YXJkaW5nX2dlbiIsImFjYyIsImNyZWF0ZSIsIm1hcCIsIml0ZXIiLCJmb2xkIiwiaW5pdCIsIm1hcF9wb2x5IiwicmVjb3JkIiwiZm9yX2FsbCIsImV4aXN0cyIsInRvX2xpc3QiLCJpdGVyJDAiLCJmb2xkJDAiLCJmb3JfYWxsJDAiLCJleGlzdHMkMCIsInRvX2xpc3QkMCIsIm1hcCQwIiwic2V0X2FsbF9tdXRhYmxlX2ZpZWxkcyIsInJlY29yZCQwIiwiZGVzY3JpcHRpb24iLCJkZXNjcmlwdGlvbnMiLCJ0JDEiLCJhYyIsImFjJDAiLCJ0JDAiLCJ4XzAwMSIsIm5leHRfaWQiLCJjcmVhdGVfd2l0aF9wYXJlbnQiLCJpbmZvIiwicGFyZW50IiwiaSIsInMiLCJzJDAiLCJ4XzAwMiIsInBhcmVudCQwIiwibWFpbiIsImJhY2t0cmFjZV9oaXN0b3J5IiwibG9jYWxfc3RvcmFnZSIsInByaW9yaXR5IiwibW9uaXRvciIsImJhY2t0cmFjZV9oaXN0b3J5JDAiLCJsb2NhbF9zdG9yYWdlJDAiLCJwcmlvcml0eSQwIiwibW9uaXRvciQwIiwibW9uaXRvcl9mdW4iLCJwcmlvcml0eV9mdW4iLCJsb2NhbF9zdG9yYWdlX2Z1biIsImJhY2t0cmFjZV9oaXN0b3J5X2Z1biIsIm1vbml0b3JfZ2VuIiwicHJpb3JpdHlfZ2VuIiwibG9jYWxfc3RvcmFnZV9nZW4iLCJiYWNrdHJhY2VfaGlzdG9yeV9nZW4iLCJiYWNrdHJhY2VfaGlzdG9yeV8wMDgiLCJsb2NhbF9zdG9yYWdlXzAwNiIsInByaW9yaXR5XzAwNCIsIm1vbml0b3JfMDAyIiwiYXJnXzAwOSIsImJuZHNfMDAxIiwiYXJnXzAwNyIsImJuZHNfMDAxJDAiLCJhcmdfMDA1IiwiYm5kc18wMDEkMSIsImFyZ18wMDMiLCJibmRzXzAwMSQyIiwiaW52YXJpYW50IiwiY3JlYXRlX2xpa2UiLCJmaW5kX2xvY2FsIiwia2V5Iiwid2l0aF9sb2NhbCIsImRhdGEiLCJyZWNvcmRfYmFja3RyYWNlIiwiZHVtbXlfZSIsImR1bW15X2YiLCJkdW1teV9hIiwic2V4cF9vZl9zbG90cyIsIm9mX2V2ZW50IiwiZXZlbnQiLCJvZl9qb2IiLCJqb2IiLCJpc19ldmVudCIsImlzX2pvYiIsImtpbmQiLCJwcm9qZWN0Iiwiam9iX29yX2V2ZW50IiwiZXZlbnRzIiwic2V0X2V4ZWN1dGlvbl9jb250ZXh0IiwiZXhlY3V0aW9uX2NvbnRleHQiLCJsZW5ndGgiLCJzZXRfbGVuZ3RoIiwiZnJvbnQiLCJzZXRfZnJvbnQiLCJtYXNrIiwic2V0X21hc2siLCJqb2JzIiwic2V0X2pvYnMiLCJqb2JzX2xlZnRfdGhpc19jeWNsZSIsInNldF9qb2JzX2xlZnRfdGhpc19jeWNsZSIsIm51bV9qb2JzX3J1biIsInNldF9udW1fam9ic19ydW4iLCJsZW5ndGgkMCIsImZyb250JDAiLCJtYXNrJDAiLCJqb2JzJDAiLCJqb2JzX2xlZnRfdGhpc19jeWNsZSQwIiwibnVtX2pvYnNfcnVuJDAiLCJudW1fam9ic19ydW5fMDAyIiwiam9ic19sZWZ0X3RoaXNfY3ljbGVfMDA0Iiwiam9ic18wMDYiLCJtYXNrXzAwOCIsImZyb250XzAxMCIsImxlbmd0aF8wMTIiLCJhcmdfMDEzIiwiYXJnXzAxMSIsImJuZHNfMDAxJDMiLCJibmRzXzAwMSQ0Iiwib2Zmc2V0IiwiY2FwYWNpdHkiLCJjaGVjayIsImYiLCJsZW5ndGhfZnVuIiwiZnJvbnRfZnVuIiwibWFza19mdW4iLCJqb2JzX2Z1biIsImpvYnNfbGVmdF90aGlzX2N5Y2xlX2Z1biIsIm51bV9qb2JzX3J1bl9mdW4iLCJjcmVhdGVfYXJyYXkiLCJjbGVhciIsInNldCIsImEiLCJvZmZzZXQkMCIsImVucXVldWUiLCJvbGRfY2FwYWNpdHkiLCJuZXdfY2FwYWNpdHkiLCJvbGRfam9icyIsIm9sZF9mcm9udCIsImxlbjEiLCJsZW4yIiwibmV3X2pvYnMiLCJzZXRfam9ic19sZWZ0X3RoaXNfY3ljbGUkMCIsIm4iLCJjYW5fcnVuX2Ffam9iIiwicnVuX2pvYiIsInNjaGVkdWxlciIsInJ1bl9leHRlcm5hbF9qb2JzIiwiZXh0ZXJuYWxfam9icyIsInJ1bl9qb2JzIiwidGhpc19qb2IiLCJleG4kMCIsImV4biIsImJhY2t0cmFjZSIsInBvcyQzIiwicG9zJDIiLCJwb3MkMSIsInBvcyQwIiwicG9zIiwibmFtZXMkMCIsImlzX251bGwiLCJkZWZhdWx0X3RpbWluZ193aGVlbF9jb25maWciLCJjb21wYXJlJDAiLCJlcXVhbCQwIiwic2V4cF9vZl90JDEiLCJ0cmFuc2l0aW9uX2lzX2FsbG93ZWQiLCJmcm9tIiwidG8iLCJzZXhwX29mX2V2ZW50IiwiYXQiLCJpbnRlcnZhbCIsInN0YXR1cyIsIm1hdGNoIiwibm9uZSIsInNvbWUiLCJpc19ub25lIiwiaXNfc29tZSIsImZpcnN0X3NvbWUiLCJ0MSIsInQyIiwidW5zYWZlX3ZhbHVlIiwic2V4cF9vZl90JDIiLCJwcHhfb3B0aW9uYWxfZV8wIiwidmFsdWUkMCIsImRlZmF1bHQkMCIsInZhbHVlX2V4biIsInRvX29wdGlvbiIsIm9mX29wdGlvbiIsInNldF9zdGF0dXMiLCJwcmV2X2ZpcmVkIiwic2V0X3ByZXZfZmlyZWQiLCJuZXh0X2ZpcmVkIiwic2V0X25leHRfZmlyZWQiLCJzZXRfaW50ZXJ2YWwiLCJjYWxsYmFjayIsImF0JDAiLCJzZXRfYXQiLCJhbGFybSIsInNldF9hbGFybSIsInN0YXR1cyQwIiwicHJldl9maXJlZCQwIiwibmV4dF9maXJlZCQwIiwiaW50ZXJ2YWwkMCIsImV4ZWN1dGlvbl9jb250ZXh0JDAiLCJjYWxsYmFjayQwIiwiYXQkMSIsImFsYXJtJDAiLCJhbGFybV9mdW4iLCJhdF9mdW4iLCJjYWxsYmFja19mdW4iLCJleGVjdXRpb25fY29udGV4dF9mdW4iLCJpbnRlcnZhbF9mdW4iLCJuZXh0X2ZpcmVkX2Z1biIsInByZXZfZmlyZWRfZnVuIiwic3RhdHVzX2Z1biIsImFsYXJtX2dlbiIsImF0X2dlbiIsImNhbGxiYWNrX2dlbiIsImV4ZWN1dGlvbl9jb250ZXh0X2dlbiIsImludGVydmFsX2dlbiIsIm5leHRfZmlyZWRfZ2VuIiwicHJldl9maXJlZF9nZW4iLCJzdGF0dXNfZ2VuIiwiZ290Iiwic2V4cGlmaWVyIiwiY29tcGFyYXRvciIsImFfMDEzIiwiYl8wMTQiLCJhXzAwOSIsImJfMDEwIiwiZXhwZWN0IiwiYV8wMDUiLCJiXzAwNiIsInNldF9zdGF0dXMkMCIsInNldF9zdGF0dXNfaWYiLCJpcyIsInNleHBfb2ZfdCQzIiwiayIsImlzX3dhbGxfY2xvY2siLCJoYW5kbGVfZmlyZWQiLCJtb3N0X3JlY2VudGx5X2ZpcmVkIiwic2V0X21vc3RfcmVjZW50bHlfZmlyZWQiLCJmaXJlZF9ldmVudHMiLCJzZXRfZmlyZWRfZXZlbnRzIiwiYW1fYWR2YW5jaW5nIiwic2V0X2FtX2FkdmFuY2luZyIsImFkdmFuY2VfZXJyb3JzIiwic2V0X2FkdmFuY2VfZXJyb3JzIiwic2NoZWR1bGVyJDAiLCJpc193YWxsX2Nsb2NrJDAiLCJoYW5kbGVfZmlyZWQkMCIsIm1vc3RfcmVjZW50bHlfZmlyZWQkMCIsImZpcmVkX2V2ZW50cyQwIiwiZXZlbnRzJDAiLCJhbV9hZHZhbmNpbmckMCIsImFkdmFuY2VfZXJyb3JzJDAiLCJtYWtlX2NyZWF0b3IkMCIsImFkdmFuY2VfZXJyb3JzX2Z1biIsImFtX2FkdmFuY2luZ19mdW4iLCJldmVudHNfZnVuIiwiZmlyZWRfZXZlbnRzX2Z1biIsIm1vc3RfcmVjZW50bHlfZmlyZWRfZnVuIiwiaGFuZGxlX2ZpcmVkX2Z1biIsImlzX3dhbGxfY2xvY2tfZnVuIiwic2NoZWR1bGVyX2Z1biIsImFkdmFuY2VfZXJyb3JzX2dlbiIsImFtX2FkdmFuY2luZ19nZW4iLCJldmVudHNfZ2VuIiwiZmlyZWRfZXZlbnRzX2dlbiIsIm1vc3RfcmVjZW50bHlfZmlyZWRfZ2VuIiwiaGFuZGxlX2ZpcmVkX2dlbiIsImlzX3dhbGxfY2xvY2tfZ2VuIiwiY29tcGlsZV9hY2MkOCIsInNjaGVkdWxlcl9nZW4iLCJjcmVhdGUkMCIsIm1hcCQxIiwiaXRlciQxIiwiZm9sZCQxIiwibWFwX3BvbHkkMCIsImZvcl9hbGwkMSIsImV4aXN0cyQxIiwidG9fbGlzdCQxIiwiaXRlciQyIiwiZm9sZCQyIiwiZm9yX2FsbCQyIiwiZXhpc3RzJDIiLCJ0b19saXN0JDIiLCJtYXAkMiIsInNldF9hbGxfbXV0YWJsZV9maWVsZHMkMCIsInNleHBfb2ZfdCQ0Iiwibm93IiwiYWxsX2V2ZW50cyIsImF0MiIsImF0MSIsInRpbWluZ193aGVlbF9ub3ciLCJpc19pbl9maXJlZF9ldmVudHMiLCJ0YXJnZXRfZXZlbnQiLCJjdXJyZW50JDEiLCJjdXJyZW50IiwiY3VycmVudCQwIiwiaW52YXJpYW50X3dpdGhfam9icyIsImpvYl9pbnZhcmlhbnQiLCJ4XzAxNiIsInBweF9vcHRpb25hbF9lXzAkMCIsImFfMDE3IiwiYl8wMTgiLCJnb3QkMCIsInNleHBpZmllciQwIiwiY29tcGFyYXRvciQwIiwiYV8wMTkiLCJiXzAyMCIsImludmFyaWFudCQwIiwic2V4cF9vZl90JDUiLCJ4XzAyMSIsImludmFyaWFudCQxIiwiaW52YXJpYW50X3dpdGhfam9icyQwIiwic2V4cF9vZl90JDYiLCJ4XzAyMiIsImlkJDEiLCJpc193YWxsX2Nsb2NrJDEiLCJtYXhfYWxsb3dlZF9hbGFybV90aW1lIiwicmVhZF9vbmx5IiwiZmlyZSIsImNvbnRpbnVlJDAiLCJuZXh0JDAiLCJjb250aW51ZSQxIiwicHB4X29wdGlvbmFsX2VfMCQxIiwibmV4dCIsInBweF9vcHRpb25hbF9lXzAkMiIsInByZXYiLCJhbGFybV9wcmVjaXNpb24iLCJuZXh0X2FsYXJtX2ZpcmVzX2F0IiwibmV4dF9hbGFybV9ydW5zX2F0Iiwibm93JDAiLCJ0aW1pbmdfd2hlZWxfbm93JDAiLCJzY2hlZHVsZSIsInJlbW92ZV9mcm9tX2ZpcmVkIiwibmV3X3N0YXR1cyIsInNleHBfb2ZfZXZlbnQkMCIsInN0YXR1cyQxIiwicHJldl9maXJlZCQxIiwic2V0X3ByZXZfZmlyZWQkMCIsIm5leHRfZmlyZWQkMSIsInNldF9uZXh0X2ZpcmVkJDAiLCJpbnRlcnZhbCQxIiwic2V0X2ludGVydmFsJDAiLCJleGVjdXRpb25fY29udGV4dCQxIiwiY2FsbGJhY2skMSIsInNldF9hdCQwIiwiYWxhcm0kMSIsInNldF9hbGFybSQwIiwic2V4cF9vZl90JDciLCJpbnZhcmlhbnQkMiIsInNldF9zdGF0dXMkMSIsInNldF9zdGF0dXNfaWYkMCIsInNjaGVkdWxlZF9hdCIsImNyZWF0ZV9pbnRlcm5hbCIsImFkZCQwIiwiY3JlYXRlX2FuZF9hZGQiLCJhdCQyIiwiYWZ0ZXIkMCIsInJlcXVpcmVfc3Bhbl9hdF9sZWFzdF9hbGFybV9wciIsImFsYXJtX3ByZWNpc2lvbiQwIiwiYXRfaW50ZXJ2YWxzIiwic2V4cF9vZl90JDgiLCJhYm9ydCIsImFib3J0X2lmX3Bvc3NpYmxlIiwiYWJvcnRfZXhuIiwicmVhc29uIiwiY3JlYXRlJDEiLCJzY2hlZHVsZV9hdF9pbnRlcm5hbCIsInNjaGVkdWxlX2F0Iiwic2NoZWR1bGVfYWZ0ZXIiLCJzY2hlZHVsZV9hdF9pbnRlcnZhbHMiLCJyZXNjaGVkdWxlX2F0IiwicmVzY2hlZHVsZV9hZnRlciIsInJ1bl9hZnRlciIsInJ1bl9hdCIsInJ1bl9hdF9pbnRlcnZhbHMiLCJydW5fZmlyZWRfZXZlbnRzIiwic2VuZF9leG4iLCJjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0Iiwic2VuZF9leG4kMCIsImFkdmFuY2VfY2xvY2siLCJmaXJlX3Bhc3RfYWxhcm1zIiwiYWR2YW5jZV9pbnRlcm5hbCIsInByZXBhcmVfdG9fYWR2YW5jZSIsImZpbmlzaF9hZHZhbmNpbmciLCJlcnJvcnMiLCJhZHZhbmNlX2J5X2FsYXJtcyIsIm1pbl9hbGFybV90aW1lIiwiYWR2YW5jZV9ieV9tYXhfYWxhcm1zX2luX2VhY2hfIiwiYWR2YW5jZV9kaXJlY3RseSIsImR1cmF0aW9uX29mIiwic3RhcnQiLCJkdXJhdGlvbiIsIm1heF9hbGFybV90aW1lX2luX21pbl90aW1pbmdfdyIsImhhc19ldmVudHNfdG9fcnVuIiwiY3JlYXRlX3dpdGhfY2VsbCIsImNlbGwiLCJjcmVhdGVfZnVsbCIsImV4ZWMiLCJleGVjJDAiLCJleGVjX2Z1biIsImV4ZWNfZ2VuIiwic2V4cF9vZl90JDAiLCJleGVjdXRpb25fY29udGV4dF8wMDIiLCJyZWNvcmRfYmFja3RyYWNlcyIsInNldF9yZWNvcmRfYmFja3RyYWNlcyIsIm1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyXyIsInNldF9tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5XyIsImNoZWNrX2ludmFyaWFudHMiLCJzZXRfY2hlY2tfaW52YXJpYW50cyIsInlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluIiwic2V0X3lpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluIiwieWllbGQkMCIsInNldF95aWVsZCIsImV2ZW50X2FkZGVkX2hvb2siLCJzZXRfZXZlbnRfYWRkZWRfaG9vayIsImpvYl9xdWV1ZWRfaG9vayIsInNldF9qb2JfcXVldWVkX2hvb2siLCJ0aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9vayIsInNldF90aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaCIsInRpbWVfc291cmNlIiwic2V0X3RpbWVfc291cmNlIiwidG90YWxfY3ljbGVfdGltZSIsInNldF90b3RhbF9jeWNsZV90aW1lIiwibGFzdF9jeWNsZV9udW1fam9icyIsInNldF9sYXN0X2N5Y2xlX251bV9qb2JzIiwibGFzdF9jeWNsZV90aW1lIiwic2V0X2xhc3RfY3ljbGVfdGltZSIsInJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGUiLCJydW5fZXZlcnlfY3ljbGVfZW5kIiwic2V0X3J1bl9ldmVyeV9jeWNsZV9lbmQiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnQiLCJzZXRfcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IiwiaW5fY3ljbGUiLCJzZXRfaW5fY3ljbGUiLCJjeWNsZV9zdGFydCIsInNldF9jeWNsZV9zdGFydCIsImN5Y2xlX2NvdW50Iiwic2V0X2N5Y2xlX2NvdW50IiwidW5jYXVnaHRfZXhuX3Vud3JhcHBlZCIsInNldF91bmNhdWdodF9leG4iLCJzZXRfY3VycmVudF9leGVjdXRpb25fY29udGV4dCIsIm1haW5fZXhlY3V0aW9uX2NvbnRleHQiLCJzZXRfbWFpbl9leGVjdXRpb25fY29udGV4dCIsInZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMiLCJsb3dfcHJpb3JpdHlfam9icyIsIm5vcm1hbF9wcmlvcml0eV9qb2JzIiwiam9iX3Bvb2wiLCJzZXRfam9iX3Bvb2wiLCJjaGVja19hY2Nlc3MiLCJzZXRfY2hlY2tfYWNjZXNzIiwicmVjb3JkX2JhY2t0cmFjZXMkMCIsIm1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyXyQwIiwiY2hlY2tfaW52YXJpYW50cyQwIiwieWllbGRfdW50aWxfbm9fam9ic19yZW1haW4kMCIsInlpZWxkJDEiLCJldmVudF9hZGRlZF9ob29rJDAiLCJqb2JfcXVldWVkX2hvb2skMCIsInRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rJDAiLCJleHRlcm5hbF9qb2JzJDAiLCJ0aW1lX3NvdXJjZSQwIiwidG90YWxfY3ljbGVfdGltZSQwIiwibGFzdF9jeWNsZV9udW1fam9icyQwIiwibGFzdF9jeWNsZV90aW1lJDAiLCJydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlJDAiLCJydW5fZXZlcnlfY3ljbGVfZW5kJDAiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUkMCIsInJ1bl9ldmVyeV9jeWNsZV9zdGFydCQwIiwiaW5fY3ljbGUkMCIsImN5Y2xlX3N0YXJ0JDAiLCJjeWNsZV9jb3VudCQwIiwidW5jYXVnaHRfZXhuIiwiY3VycmVudF9leGVjdXRpb25fY29udGV4dCQwIiwibWFpbl9leGVjdXRpb25fY29udGV4dCQwIiwidmVyeV9sb3dfcHJpb3JpdHlfd29ya2VycyQwIiwibG93X3ByaW9yaXR5X2pvYnMkMCIsIm5vcm1hbF9wcmlvcml0eV9qb2JzJDAiLCJqb2JfcG9vbCQwIiwiY2hlY2tfYWNjZXNzJDAiLCJjaGVja19hY2Nlc3NfZnVuIiwiam9iX3Bvb2xfZnVuIiwibm9ybWFsX3ByaW9yaXR5X2pvYnNfZnVuIiwibG93X3ByaW9yaXR5X2pvYnNfZnVuIiwidmVyeV9sb3dfcHJpb3JpdHlfd29ya2Vyc19mdW4iLCJtYWluX2V4ZWN1dGlvbl9jb250ZXh0X2Z1biIsImN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHRfZnVuIiwidW5jYXVnaHRfZXhuX2Z1biIsImN5Y2xlX2NvdW50X2Z1biIsImN5Y2xlX3N0YXJ0X2Z1biIsImluX2N5Y2xlX2Z1biIsInJ1bl9ldmVyeV9jeWNsZV9zdGFydF9mdW4iLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGVfZnUiLCJydW5fZXZlcnlfY3ljbGVfZW5kX2Z1biIsInJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGVfZnVuIiwibGFzdF9jeWNsZV90aW1lX2Z1biIsImxhc3RfY3ljbGVfbnVtX2pvYnNfZnVuIiwidG90YWxfY3ljbGVfdGltZV9mdW4iLCJ0aW1lX3NvdXJjZV9mdW4iLCJleHRlcm5hbF9qb2JzX2Z1biIsInRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rXyIsImpvYl9xdWV1ZWRfaG9va19mdW4iLCJldmVudF9hZGRlZF9ob29rX2Z1biIsInlpZWxkX2Z1biIsInlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluX2Z1biIsImNoZWNrX2ludmFyaWFudHNfZnVuIiwicmVjb3JkX2JhY2t0cmFjZXNfZnVuIiwiY2hlY2tfYWNjZXNzX2dlbiIsImpvYl9wb29sX2dlbiIsIm5vcm1hbF9wcmlvcml0eV9qb2JzX2dlbiIsImxvd19wcmlvcml0eV9qb2JzX2dlbiIsInZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnNfZ2VuIiwibWFpbl9leGVjdXRpb25fY29udGV4dF9nZW4iLCJjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0X2dlbiIsInVuY2F1Z2h0X2V4bl9nZW4iLCJjeWNsZV9jb3VudF9nZW4iLCJjb21waWxlX2FjYyQ5IiwiY3ljbGVfc3RhcnRfZ2VuIiwiY29tcGlsZV9hY2MkMTAiLCJpbl9jeWNsZV9nZW4iLCJjb21waWxlX2FjYyQxMSIsInJ1bl9ldmVyeV9jeWNsZV9zdGFydF9nZW4iLCJjb21waWxlX2FjYyQxMiIsInJ1bl9ldmVyeV9jeWNsZV9zdGFydF9zdGF0ZV9nZSIsImNvbXBpbGVfYWNjJDEzIiwicnVuX2V2ZXJ5X2N5Y2xlX2VuZF9nZW4iLCJjb21waWxlX2FjYyQxNCIsInJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGVfZ2VuIiwiY29tcGlsZV9hY2MkMTUiLCJsYXN0X2N5Y2xlX3RpbWVfZ2VuIiwiY29tcGlsZV9hY2MkMTYiLCJsYXN0X2N5Y2xlX251bV9qb2JzX2dlbiIsImNvbXBpbGVfYWNjJDE3IiwidG90YWxfY3ljbGVfdGltZV9nZW4iLCJjb21waWxlX2FjYyQxOCIsInRpbWVfc291cmNlX2dlbiIsImNvbXBpbGVfYWNjJDE5IiwiZXh0ZXJuYWxfam9ic19nZW4iLCJjb21waWxlX2FjYyQyMCIsInRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rXyQwIiwiY29tcGlsZV9hY2MkMjEiLCJqb2JfcXVldWVkX2hvb2tfZ2VuIiwiY29tcGlsZV9hY2MkMjIiLCJldmVudF9hZGRlZF9ob29rX2dlbiIsImNvbXBpbGVfYWNjJDIzIiwieWllbGRfZ2VuIiwiY29tcGlsZV9hY2MkMjQiLCJ5aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbl9nZW4iLCJjb21waWxlX2FjYyQyNSIsImNoZWNrX2ludmFyaWFudHNfZ2VuIiwiY29tcGlsZV9hY2MkMjYiLCJtYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl8kMSIsImNvbXBpbGVfYWNjJDI3IiwicmVjb3JkX2JhY2t0cmFjZXNfZ2VuIiwiY3JlYXRlJDIiLCJjaGVja19hY2Nlc3NfMDA3Iiwiam9iX3Bvb2xfMDA5IiwidmVyeV9sb3dfcHJpb3JpdHlfd29ya2Vyc18wMTUiLCJsb3dfcHJpb3JpdHlfam9ic18wMTMiLCJub3JtYWxfcHJpb3JpdHlfam9ic18wMTEiLCJtYWluX2V4ZWN1dGlvbl9jb250ZXh0XzAxNyIsImN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHRfMDE5IiwidW5jYXVnaHRfZXhuXzAyMSIsImN5Y2xlX2NvdW50XzAyNyIsImN5Y2xlX3N0YXJ0XzAyOSIsImluX2N5Y2xlXzAzMSIsInJ1bl9ldmVyeV9jeWNsZV9zdGFydF8wMzMiLCJydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGVfMDMiLCJydW5fZXZlcnlfY3ljbGVfZW5kXzAzNyIsInJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGVfMDM5IiwibGFzdF9jeWNsZV90aW1lXzA0MSIsImxhc3RfY3ljbGVfbnVtX2pvYnNfMDQzIiwidG90YWxfY3ljbGVfdGltZV8wNDUiLCJ0aW1lX3NvdXJjZV8wNDciLCJleHRlcm5hbF9qb2JzXzA0OSIsImpvYl9xdWV1ZWRfaG9va18wNTMiLCJldmVudF9hZGRlZF9ob29rXzA1NSIsInlpZWxkXzA1NyIsInlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluXzA1OSIsImNoZWNrX2ludmFyaWFudHNfMDYxIiwicmVjb3JkX2JhY2t0cmFjZXNfMDY1IiwiYXJnXzA2NiIsImJuZHNfMDA2IiwiYXJnXzA2NCIsImJuZHNfMDA2JDAiLCJhcmdfMDYyIiwiYm5kc18wMDYkMSIsImFyZ18wNjAiLCJibmRzXzAwNiQyIiwiYXJnXzA1OCIsImJuZHNfMDA2JDMiLCJhcmdfMDU2IiwiYm5kc18wMDYkNCIsImFyZ18wNTQiLCJibmRzXzAwNiQ1IiwiYXJnXzA1MiIsImJuZHNfMDA2JDYiLCJhcmdfMDUwIiwiYm5kc18wMDYkNyIsImFyZ18wNDgiLCJibmRzXzAwNiQ4IiwiYXJnXzA0NiIsImJuZHNfMDA2JDkiLCJhcmdfMDQ0IiwiYm5kc18wMDYkMTAiLCJhcmdfMDQyIiwiYm5kc18wMDYkMTEiLCJhcmdfMDQwIiwiYm5kc18wMDYkMTIiLCJhcmdfMDM4IiwiYm5kc18wMDYkMTMiLCJhcmdfMDM2IiwiYm5kc18wMDYkMTQiLCJhcmdfMDM0IiwiYm5kc18wMDYkMTUiLCJhcmdfMDMyIiwiYm5kc18wMDYkMTYiLCJhcmdfMDMwIiwiYm5kc18wMDYkMTciLCJhcmdfMDI4IiwiYm5kc18wMDYkMTgiLCJhcmdfMDIyIiwiYXJnMV8wMjQiLCJhcmcwXzAyMyIsInJlczBfMDI1IiwicmVzMV8wMjYiLCJibmRzXzAwNiQxOSIsImFyZ18wMjAiLCJibmRzXzAwNiQyMCIsImFyZ18wMTgiLCJibmRzXzAwNiQyMSIsImFyZ18wMTYiLCJibmRzXzAwNiQyMiIsImFyZ18wMTQiLCJibmRzXzAwNiQyMyIsImFyZ18wMTIiLCJibmRzXzAwNiQyNCIsImFyZ18wMTAiLCJibmRzXzAwNiQyNSIsImFyZ18wMDgiLCJibmRzXzAwNiQyNiIsInVuY2F1Z2h0X2V4biQwIiwiYXJnMV8wNjgiLCJhcmcwXzA2NyIsInJlczBfMDY5IiwicmVzMV8wNzAiLCJudW1fcGVuZGluZ19qb2JzIiwibGFzdF9jeWNsZV9udW1fam9icyQxIiwidW5vcmRlcmVkX2lzX3N1Ymxpc3QiLCJlcXVhbCIsInNtYWxsIiwibGFyZ2UiLCJ4IiwibCQwIiwieSIsImwiLCJjaGVja19ob29rX3RhYmxlX2ludmFyaWFudCIsInRhYmxlIiwibGlzdCIsImZpZWxkIiwicSIsImZyZWVfam9iIiwiam9iX3F1ZXVlIiwiZiQwIiwiZW5xdWV1ZV9qb2IiLCJjcmVhdGUkMyIsImlzX2RlYWQiLCJzZXRfY2hlY2tfYWNjZXNzJDAiLCJ0X3JlZiIsImNoZWNrX2FjY2VzcyQxIiwiY3VycmVudF9leGVjdXRpb25fY29udGV4dCQxIiwid2l0aF9leGVjdXRpb25fY29udGV4dDEiLCJ0bXBfY29udGV4dCIsIm9sZF9jb250ZXh0Iiwid2l0aF9leGVjdXRpb25fY29udGV4dCIsImNyZWF0ZV9qb2IiLCJnb3RfdW5jYXVnaHRfZXhuIiwiYXJnMV8wNzIiLCJhcmcwXzA3MSIsInJlczBfMDczIiwicmVzMV8wNzQiLCJzdGFydF9jeWNsZSIsIm1heF9udW1fam9ic19wZXJfcHJpb3JpdHkiLCJlIiwiZSQwIiwic3RhYmlsaXplIiwiY3JlYXRlX3RpbWVfc291cmNlIiwib3B0Iiwic3RoIiwidGltaW5nX3doZWVsX2NvbmZpZyIsIndhbGxfY2xvY2siLCJzZXRfcHJldiIsInBhcmFtIiwic2V0X25leHQiLCJydW4iLCJjcmVhdGUyIiwicnVuMSIsImV4ZWN1dGlvbl9jb250ZXh0MSIsInJ1bjIiLCJleGVjdXRpb25fY29udGV4dDIiLCJzY2hlZHVsZV9qb2JzIiwiYWRkIiwib2ZfbGlzdCIsImZpcnN0IiwibCQxIiwibCQyIiwicnVuJDAiLCJwcmV2JDAiLCJhY2MkMCIsImNlbGxfb2ZfaGFuZGxlciIsImluZGlyIiwic3F1YXNoIiwidCQzIiwidCQ0IiwiaW5kaXIkMSIsInQkNSIsImluZGlyJDAiLCJ0JDIiLCJhX2ludmFyaWFudCIsImhhbmRsZXIiLCJwZWVrIiwidmFsdWUiLCJpZl9lbXB0eV90aGVuX2ZhaWx3aXRoIiwiaXNfZW1wdHkiLCJpc19mdWxsIiwiZmlsbCIsInJlbW92ZV9oYW5kbGVyIiwieCQwIiwiYWRkX2hhbmRsZXIiLCJoYW5kbGVyJDEiLCJoYW5kbGVyJDIiLCJydW4kMSIsImhhbmRsZXIkMCIsImhhc19oYW5kbGVycyIsInVwb24iLCJ1cG9uJDAiLCJjb25uZWN0IiwiYmluZF9yZXN1bHQiLCJiaW5kX3JocyIsImJpbmRfcmVzdWx0JDAiLCJpdmFyIiwiYmluZF9yaHNfY29udGVudHMiLCJpdmFyJDAiLCJsYXN0MSIsImxhc3QyIiwiaGFuZGxlcjEiLCJleGVjdXRpb25fY29udGV4dDIkMCIsInJ1bjIkMCIsImhhbmRsZXIxJDAiLCJ2JDAiLCJvZl9pdmFyIiwiaW52YXJpYW50X2EiLCJyZXR1cm4kMCIsImlzX2RldGVybWluZWQiLCJiaW5kIiwiaCIsInJlYWQiLCJmaWxsX2lmX2VtcHR5IiwidG9fYmluYWJsZSIsIm9mX2JpbmFibGUiLCJzZXhwX29mX2hvdyIsInZfMDAxIiwibmV2ZXIiLCJyZXR1cm4kMSIsInJldHVybiQyIiwicmV0dXJuJDMiLCJ1bml0IiwiYm90aCQwIiwiYTEiLCJhMiIsImRvbl90X3dhaXRfZm9yIiwiZjIiLCJmMSIsInByb2Nlc3MiLCJyZXN0IiwiY2hvaWNlIiwiZW5hYmxlZCIsImNob2ljZXMiLCJ1bnJlZ2lzdGVycyIsInJlYWR5IiwiY2hvb3NlX3Jlc3VsdCIsImNob2ljZXMkMCIsImNob2ljZXMkMSIsImNob29zZSIsImFueV9mIiwidHMiLCJhbnkiLCJhbnlfdW5pdCIsImZvciQwIiwiZG8kMCIsImxvb3AiLCJyZXBlYXRfdW50aWxfZmluaXNoZWQiLCJzdGF0ZSIsImZpbmlzaGVkIiwiZm9yZXZlciIsImIiLCJ4cyIsInNlcW1hcCIsImJzIiwiYWxsIiwiZHMiLCJhbGxfdW5pdCIsImQiLCJvayIsIm9mX2FfMDA1IiwieF8wMDYiLCJhcmcwXzAwMiIsInJlczBfMDAzIiwieF8wMDciLCJjb2xsZWN0IiwiaXNfY2xvc2VkIiwiZmlsbF9leG4iLCJjbG9zZV9leG4iLCJjbG9zZV9pZl9vcGVuIiwiZXh0ZW5kIiwiZGVmZXJyZWQwIiwiZGVmZXJyZWQxIiwiaW1wb3J0MCIsImVycm9yIiwiZGV0YWNoIiwiZGV0YWNoX2FuZF9pdGVyX2Vycm9ycyIsImhhbmRsZXJfc3RhdGVfcmVmIiwicnVuX2YiLCJiYWdfZWx0IiwiaW5uZXJfZXhuJDAiLCJpbm5lcl9leG4iLCJkZXRhY2hfYW5kX2dldF9lcnJvcl9zdHJlYW0iLCJ0YWlsIiwiZ2V0X25leHRfZXJyb3IiLCJkZXRhY2hfYW5kX2dldF9uZXh0X2Vycm9yIiwiZXh0cmFjdF9leG4iLCJjb2x1bW4iLCJtb25pdG9yJDEiLCJuYW1lJDEiLCJiYWNrdHJhY2UkMCIsImJhY2t0cmFjZSQxIiwicmVzdCQwIiwicmVzdCQxIiwidDMiLCJyZXN0JDIiLCJyZXN0JDMiLCJ0cmFjZXMiLCJyZXN0JDQiLCJ0MSQwIiwicmVzdCQ1IiwidDIkMCIsInJlc3QkNiIsInQyJDEiLCJiYWNrdHJhY2UkMiIsImxpc3RfaWZfbm90X2VtcHR5IiwibWF0Y2gkMiIsIm1hdGNoJDMiLCJleHRyYWN0X2V4biQwIiwiYXJnMV8wMDQiLCJhcmcwXzAwMyIsImFyZzFfMDA4IiwiYXJnMF8wMDciLCJyZXMwXzAwOSIsInJlczFfMDEwIiwid2l0aGluX2NvbnRleHQiLCJjb250ZXh0Iiwid2l0aGluX2dlbiIsIndpdGhpbiIsIndpdGhpbl92Iiwid2l0aGluJDAiLCJzY2hlZHVsZV93aXRoX2RhdGEiLCJ3b3JrIiwidXBvbl93b3JrX2ZpbGxfaSIsInNjaGVkdWxlJDAiLCJwcmVzZXJ2ZV9leGVjdXRpb25fY29udGV4dCIsInByZXNlcnZlX2V4ZWN1dGlvbl9jb250ZXh0JDAiLCJjYWxsX2FuZF9maWxsIiwic3RyZWFtX2l0ZXIiLCJzdHJlYW0iLCJleG5zIiwiZmlsbF9yZXN1bHRfYW5kX2hhbmRsZV9iYWNrZ3JvIiwicmVzdWx0X2ZpbGxlciIsImhhbmRsZV9leG5zX2FmdGVyX3Jlc3VsdCIsInRyeV93aXRoX2xvZ19leG4iLCJ0cnlfd2l0aCIsInN0aCQwIiwiZG9fZXh0cmFjdF9leG4iLCJzdGgkMSIsInN0aCQyIiwiaGFuZGxlX2V4biIsInJlcyIsInRyeV93aXRoX29yX2Vycm9yIiwidHJ5X3dpdGhfam9pbl9vcl9lcnJvciIsInByb3RlY3QiLCJmaW5hbGx5JDAiLCJmciIsInIkMCIsImZpbmFsbHlfZXhuIiwiaGFuZGxlX2Vycm9ycyIsImNhdGNoX3N0cmVhbSIsImNhdGNoJDAiLCJjYXRjaF9lcnJvciIsImRlcHRoIiwibiQwIiwiZmlyc3RfZXhuIiwibG9vcCQwIiwibG9vcF9uZXh0IiwibG9vcF9uZXh0JDAiLCJjbG9zZWQiLCJ1bmZvbGQiLCJjb3B5X3RvX3RhaWwiLCJhcHBlbmQiLCJmaWx0ZXJfZGVwcmVjYXRlZCIsImZpbHRlcl9tYXBfZGVwcmVjYXRlZCIsImZpcnN0X24iLCJhdmFpbGFibGVfbm93Iiwic3BsaXQiLCJzdG9wIiwicmVhc29uX2Zvcl9zdG9wcGluZyIsInByZWZpeCIsImZpbmlzaCIsIm8iLCJmaW5kIiwiZm91bmQiLCJ1bmdyb3VwIiwiaW50ZXJsZWF2ZSIsIm51bV9vcGVuIiwiY2xvc2UiLCJvdXRlcl9jbG9zZWQiLCJ0YWtlX3VudGlsIiwieiIsIml0ZXJfZHVyYWJseSIsIml0ZXJfZHVyYWJseV9yZXBvcnRfZW5kIiwiaXRlcl9kdXJhYmx5JDAiLCJvZl9mdW4iLCJzZXRfaXZhciIsImhhc19hbnlfd2FpdGVycyIsInNldF9oYXNfYW55X3dhaXRlcnMiLCJoYXNfYW55X3dhaXRlcnMkMCIsInJlcHIiLCJvZl9hXzAwMSIsImhhc19hbnlfd2FpdGVyc18wMDMiLCJpdmFyXzAwNSIsImFyZ18wMDYiLCJibmRzXzAwMiIsImFyZ18wMDQiLCJibmRzXzAwMiQwIiwiaXZhcl9mdW4iLCJoYXNfYW55X3dhaXRlcnNfZnVuIiwiYnJvYWRjYXN0Iiwid2FpdCIsImhhc19hbnlfd2FpdGVycyQxIiwieF8wMDMiLCJhZHZhbmNlX2RpcmVjdGx5X2J5IiwiYnkiLCJ3YWl0X2ZvciIsInJ1bl9xdWV1ZWRfYWxhcm1zIiwid2Fsa19hbGFybXMiLCJtaW5fYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWwiLCJxdWV1ZWRfYWxhcm1zX3JhbiIsIm5leHRfYWxhcm1fZmlyZXNfYXQkMCIsImFkdmFuY2VfYnlfYWxhcm1zX2J5Iiwic3Bhbl90b190aW1lIiwicnVuX2F0X2ludGVybmFsIiwidGltZSIsInJlbW92ZV9hbGFybSIsIm9mX2FfMDA4Iiwib2ZfaF8wMDkiLCJhcmcwXzAxMCIsInJlczBfMDExIiwiYXJnMF8wMTIiLCJyZXMwXzAxMyIsInNldF9zY2hlZHVsZWRfYXQiLCJudW1fZmlyZXNfdG9fc2tpcCIsInNldF9udW1fZmlyZXNfdG9fc2tpcCIsImZpcmVkIiwic2NoZWR1bGVkX2F0JDAiLCJudW1fZmlyZXNfdG9fc2tpcCQwIiwiZmlyZWQkMCIsIm9mX2FfMDE2Iiwib2ZfaF8wMTciLCJhbGFybV8wMTkiLCJmaXJlZF8wMjMiLCJudW1fZmlyZXNfdG9fc2tpcF8wMjUiLCJzY2hlZHVsZWRfYXRfMDI3IiwidGltZV9zb3VyY2VfMDI5IiwiYm5kc18wMTgiLCJibmRzXzAxOCQwIiwiYXJnXzAyNiIsImJuZHNfMDE4JDEiLCJhcmdfMDI0IiwiYm5kc18wMTgkMiIsImJuZHNfMDE4JDMiLCJibmRzXzAxOCQ0Iiwic2V4cF9vZl90X3VuaXQiLCJ4XzAzMSIsImZpcmVkJDEiLCJpbnZhcmlhbnRfaCIsInhfMDMyIiwic2NoZWR1bGVkX2F0X2Z1biIsImFfMDMzIiwiYl8wMzQiLCJudW1fZmlyZXNfdG9fc2tpcF9mdW4iLCJmaXJlZF9mdW4iLCJvZl9hXzAzNSIsIm9mX2hfMDM2IiwiYXJnMF8wMzciLCJyZXMwXzAzOCIsImFyZzBfMDM5IiwicmVzMF8wNDAiLCJhcmcwXzA0MSIsInJlczBfMDQyIiwib2ZfYV8wNDUiLCJvZl9oXzA0NiIsImFyZzBfMDQ3IiwicmVzMF8wNDgiLCJhcmcwXzA0OSIsInJlczBfMDUwIiwieF8wNTMiLCJhJDAiLCJvZl9hXzA1NCIsIm9mX2hfMDU1IiwiYXJnMF8wNTYiLCJyZXMwXzA1NyIsImFyZzBfMDU4IiwicmVzMF8wNTkiLCJhcmcxXzA2MyIsImFyZzBfMDYyIiwicmVzMF8wNjQiLCJyZXMxXzA2NSIsImlzX2luX3RpbWluZ193aGVlbCIsImFtX3RyeWluZ190b19yZXNjaGVkdWxlX2luX3RoZSIsInJ1bl9hdCQwIiwicnVuX2FmdGVyJDAiLCJhdF90aW1lcyIsIm5leHRfdGltZSIsImF0X3ZhcnlpbmdfaW50ZXJ2YWxzIiwiY29tcHV0ZV9zcGFuIiwic3RhcnQkMCIsInJ1bl9yZXBlYXRlZGx5IiwiY29udGludWVfb25fZXJyb3IiLCJzdG9wJDAiLCJzdG9wJDEiLCJjb250aW51ZV90cnlfd2l0aCIsImNvbnRpbnVlX2YiLCJiYXNlIiwib3JfZXJyb3IiLCJldmVyeSIsImV2ZXJ5JDAiLCJzdGFydCQxIiwicnVuX2F0X2ludGVydmFscyQwIiwid2l0aF90aW1lb3V0IiwidGltZW91dCIsIm9mX3N5bmNocm9ub3VzIiwidG9fc3luY2hyb25vdXMiLCJvZl9hXzAwMiIsInJlczBfMDA0IiwibGVuZ3RoXzAwNiIsImJuZHNfMDA1IiwiY3JlYXRlX2NvdW50ZXIiLCJwdXNoIiwicG9wX2V4biIsInNleHBfb2Zfb3V0Y29tZSIsInZfMDAyIiwidl8wMDMiLCJjbGVhbmVkIiwibnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCIsInNldF9udW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkIiwiY2FwYWNpdHlfYXZhaWxhYmxlIiwic2V0X2NhcGFjaXR5X2F2YWlsYWJsZSIsIm51bV9qb2JzX3J1bm5pbmciLCJzZXRfbnVtX2pvYnNfcnVubmluZyIsImpvYnNfd2FpdGluZ190b19zdGFydCIsImpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSIsIm1heF9jb25jdXJyZW50X2pvYnMiLCJjbGVhbmVkJDAiLCJudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkJDAiLCJjYXBhY2l0eV9hdmFpbGFibGUkMCIsIm51bV9qb2JzX3J1bm5pbmckMCIsImpvYnNfd2FpdGluZ190b19zdGFydCQwIiwiam9iX3Jlc291cmNlc19ub3RfaW5fdXNlJDAiLCJtYXhfY29uY3VycmVudF9qb2JzJDAiLCJvZl9hXzAxMSIsImpvYnNfd2FpdGluZ190b19zdGFydF8wMTkiLCJqb2JfcmVzb3VyY2VzX25vdF9pbl91c2VfMDE3IiwibWF4X2NvbmN1cnJlbnRfam9ic18wMTUiLCJjb250aW51ZV9vbl9lcnJvcl8wMTMiLCJudW1fam9ic19ydW5uaW5nXzAyMSIsImNhcGFjaXR5X2F2YWlsYWJsZV8wMjMiLCJpc19kZWFkXzAyNSIsImNsZWFuc18wMjciLCJudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkXzAyOSIsImNsZWFuZWRfMDMxIiwiYm5kc18wMTIiLCJibmRzXzAxMiQwIiwiYm5kc18wMTIkMSIsImJuZHNfMDEyJDIiLCJibmRzXzAxMiQzIiwiYm5kc18wMTIkNCIsIm91dGNvbWVfMDA5Iiwic3RhcnRfMDA2Iiwidl8wMDgiLCJibmRzXzAwNSQwIiwiYm5kc18wMTIkNSIsImJuZHNfMDEyJDYiLCJibmRzXzAxMiQ3IiwiYm5kc18wMTIkOCIsInhfMDMzIiwib2ZfYV8wMzQiLCJvZl9raW5kXzAzNSIsInhfMDM2IiwibnVtX2pvYnNfd2FpdGluZ190b19zdGFydCIsImNsZWFuX3Jlc291cmNlIiwia2lsbCIsImF0X2tpbGwiLCJjbGVhbmVkJDEiLCJzdGFydF9qb2IiLCJqb2JfcmVzb3VyY2UiLCJqb2JfcmVzb3VyY2VzIiwiY3JlYXRlX3dpdGgiLCJvdXRjb21lIiwiaW50ZXJuYWxfam9iIiwiaGFuZGxlX2VucXVldWVfcmVzdWx0IiwiZW5xdWV1ZSQwIiwiZW5xdWV1ZV9leGNsdXNpdmUiLCJkb25lIiwiZl9wbGFjZWhvbGRlciIsInNsb3QiLCJtb25hZF9zZXF1ZW5jZV9ob3ciLCJob3ciLCJtb25hZF9zZXF1ZW5jZV9ob3cyIiwicHJpb3Jfam9ic19kb25lIiwiYWxsX2R1bW15X2pvYnNfcnVubmluZyIsImR1bW15X2pvYnNfcnVubmluZyIsImNhcGFjaXR5X2F2YWlsYWJsZSQxIiwiaGFzX3VwY29taW5nX2V2ZW50IiwibmV4dF91cGNvbWluZ19ldmVudCIsIm5leHRfdXBjb21pbmdfZXZlbnRfZXhuIiwiZXZlbnRfcHJlY2lzaW9uIiwiYWRkX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2siLCJoYW5kbGUiLCJhZGRfZXZlcnlfY3ljbGVfZW5kX2hvb2siLCJyZW1vdmVfc2luZ2xlX2N5Y2xlX2hvb2siLCJsc3QiLCJsc3QkMCIsInJlbW92ZV9ldmVyeV9jeWNsZV9zdGFydF9ob29rXyIsInJlbW92ZV9ldmVyeV9jeWNsZV9lbmRfaG9va19leCIsIm1hcF9jeWNsZV90aW1lcyIsImxvbmdfY3ljbGVzIiwiYXRfbGVhc3QiLCJjeWNsZV9udW1fam9icyIsImludCQwIiwidGhyZWFkX3NhZmVfZW5xdWV1ZV9leHRlcm5hbF9qIiwiY3JlYXRlX2FsYXJtIiwiYWRkX2ZpbmFsaXplciIsImhlYXBfYmxvY2siLCJmaW5hbGl6ZXIiLCJhZGRfZmluYWxpemVyX2V4biIsImFkZF9maW5hbGl6ZXJfbGFzdCIsImFkZF9maW5hbGl6ZXJfbGFzdF9leG4iLCJmb3JjZV9jdXJyZW50X2N5Y2xlX3RvX2VuZCIsInJ1bl9jeWNsZSIsIm51bV9qb2JzX3J1bl9hdF9zdGFydF9vZl9jeWNsZSIsImN5Y2xlX3RpbWUiLCJyZXMxXzAwNCIsInJ1bl9jeWNsZXNfdW50aWxfbm9fam9ic19yZW1haSIsIm1ha2VfYXN5bmNfdW51c2FibGUiLCJyZXNldF9pbl9mb3JrZWRfcHJvY2VzcyIsIm1heV9yZXR1cm5faW1tZWRpYXRlbHkiLCJ5aWVsZF9ldmVyeSIsImNvdW50X3VudGlsX3lpZWxkIiwidGhpc19jeWNsZV90aW1lIiwibnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZyIsInlpZWxkX3RoZW5fcnVuIiwid29ya2VyIiwibnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZyQwIiwibnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZyQxIiwiYnQiLCJxdWV1ZSIsInJ1bm5pbmciLCJ0aHJlYWRfc2FmZV9lbnF1ZXVlX2pvYiIsImN5Y2xlX3N0YXJ0X25zIiwiY3ljbGVfdGltZXNfbnMiLCJjeWNsZV90aW1lcyIsImV2ZW50X3ByZWNpc2lvbl9ucyIsImJvb2wiLCJhZGRfZXZlcnlfY3ljbGVfc3RhcnRfaG9vayQwIiwiYWRkX2V2ZXJ5X2N5Y2xlX2VuZF9ob29rJDAiLCJyZW1vdmVfZXZlcnlfY3ljbGVfc3RhcnRfaG9va18kMCIsInJlbW92ZV9ldmVyeV9jeWNsZV9lbmRfaG9va19leCQwIiwid2l0aF9leGVjdXRpb25fY29udGV4dCQwIiwid2l0aF9leGVjdXRpb25fY29udGV4dDEkMCIsImNvbXBhcmUiLCJjbXBfYSIsImFfMDAxIiwiYl8wMDIiLCJyaWdodF8wMDQiLCJsZWZ0XzAwMyIsInZfMDA2IiwiZm9sZGkiLCJzZXFtYXBpIiwiaXRlcmkiLCJtYXBpIiwiZmlsdGVyaSIsImJvb2xzIiwiZmlsdGVyX21hcGkiLCJjb25jYXRfbWFwaSIsImZpbmRfbWFwaSIsImF1eCIsImZpbmRpIiwiZWx0IiwiZXhpc3RzaSIsImZvcl9hbGxpIiwiZmlsdGVyX21hcCIsImZpbHRlciIsImNvbmNhdF9tYXAiLCJmaW5kX21hcCIsInRsIiwiaGQiLCJjaGFuZ2UiLCJ1cGRhdGUiLCJpdGVyX2tleXMiLCJhbGlzdF9pbl9pbmNyZWFzaW5nX2tleV9vcmRlciIsImFsaXN0IiwiZm9sZF9yaWdodCIsImFsaXN0X2luX2RlY3JlYXNpbmdfa2V5X29yZGVyIiwic2VxdWVuY2UiLCJqb2JfbWFwIiwiZmlsdGVyX2tleXMiLCJtZXJnZSIsInRodW5rIiwicmVyYWlzZSIsImdlbmVyYWwiLCJoYXNoYWJsZSIsImNvbWJpbmUiLCJlcnIiLCJmYWlsIiwiZmFpbGYiLCJmb3JtYXQiLCJtYXBfZXJyb3IiLCJpZ25vcmVfbSIsImpvaW4iLCJzeW1ib2xfYmluZCIsImFwcGx5IiwiZTEiLCJlMiIsInN5bWJvbF9iaW5kJDAiLCJzeW1ib2xfbWFwJDAiLCJva19leG4iLCJvZl9leG4iLCJvZl9leG5fcmVzdWx0IiwibXNnIiwic2V4cF9vZiIsImVycm9yX3MiLCJlcnJvcl9zdHJpbmciLCJlcnJvcmYiLCJ0YWciLCJ0YWdfcyIsInRhZ19zX2xhenkiLCJ0YWdfYXJnIiwidW5pbXBsZW1lbnRlZCIsImNvbWJpbmVfZXJyb3JzIiwiY29tYmluZV9lcnJvcnNfdW5pdCIsImZpbHRlcl9va19hdF9sZWFzdF9vbmUiLCJmaW5kX21hcF9vayIsImN1cnJlbnRfZXJyb3IiLCJlcnJvcnMkMCIsIm9rX3VuaXQiLCJ0cnlfd2l0aCQwIiwidHJ5X3dpdGhfam9pbiIsInN0YXRlJDAiLCJmb2xkX21hcGkiLCJtYXBpX2YiLCJmb2xkX2YiLCJ0aHJvdHRsZSIsImMiLCJjJDEiLCJjJDAiLCJpJDAiLCJhY2N1bSIsIm1heWJlX3YiLCJzaG93X2RlYnVnX21lc3NhZ2VzIiwiY2hlY2tfaW52YXJpYW50IiwieF8wMDQiLCJ2YWx1ZXNfcmVhZCIsInNldF92YWx1ZXNfcmVhZCIsInZhbHVlc19yZWFkJDAiLCJwaXBlX2lkXzAwOSIsInZhbHVlc19yZWFkXzAxMSIsImFyZ18wMTUiLCJibmRzXzAwOCIsInZfMDEzIiwiYm5kc18wMDgkMCIsImJuZHNfMDA4JDEiLCJ2YWx1ZXNfc2VudF9kb3duc3RyZWFtIiwidmFsdWVzX3NlbnRfZG93bnN0cmVhbV9hbmRfZmx1Iiwid2hlbl9zZW50X2Rvd25zdHJlYW0iLCJjb25zdW1lciIsIndhbnRzIiwiY29uc3VtZXIkMCIsIndhbnRzJDAiLCJvZl9hXzAyOSIsImNvbnN1bWVyXzAzMyIsIndhbnRzXzAzMSIsImJuZHNfMDMwIiwiYXJnMF8wMTgiLCJyZXMwXzAxOSIsImFyZzBfMDIxIiwicmVzMF8wMjIiLCJ2XzAyMCIsImFyZzFfMDI1IiwiYXJnMF8wMjQiLCJyZXMwXzAyNiIsInJlczFfMDI3Iiwidl8wMjMiLCJibmRzXzAzMCQwIiwiZmlsbF93aXRoX2VvZiIsImkkMSIsImZpbGxfd2hlbl9udW1fdmFsdWVzX3JlYWQiLCJyZWFkeV8wMzkiLCJmaWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkXzAzNyIsImJuZHNfMDM2IiwiYm5kc18wMzYkMCIsImNvbnN1bWVycyIsInNldF9jb25zdW1lcnMiLCJibG9ja2VkX3JlYWRzIiwiYmxvY2tlZF9mbHVzaGVzIiwicHVzaGJhY2siLCJzZXRfcHVzaGJhY2siLCJzaXplX2J1ZGdldCIsInNldF9zaXplX2J1ZGdldCIsImNvbnN1bWVycyQwIiwiYmxvY2tlZF9yZWFkcyQwIiwiYmxvY2tlZF9mbHVzaGVzJDAiLCJwdXNoYmFjayQwIiwic2l6ZV9idWRnZXQkMCIsInNleHBfb2ZfcGlwZSIsIm9mX2FfMDQxIiwib2ZfcGhhbnRvbV8wNDIiLCJpZF8wNDQiLCJpbmZvXzA0NiIsImJ1ZmZlcl8wNTAiLCJzaXplX2J1ZGdldF8wNTIiLCJwdXNoYmFja18wNTQiLCJudW1fdmFsdWVzX3JlYWRfMDU2IiwicmVhZF9jbG9zZWRfMDY0IiwiY2xvc2VkXzA2MiIsImJsb2NrZWRfcmVhZHNfMDYwIiwiYmxvY2tlZF9mbHVzaGVzXzA1OCIsImNvbnN1bWVyc18wNjYiLCJ1cHN0cmVhbV9mbHVzaGVkc18wNjgiLCJhcmdfMDY5IiwiYm5kc18wNDMiLCJhcmdfMDY3IiwiYm5kc18wNDMkMCIsImFyZ18wNjUiLCJibmRzXzA0MyQxIiwiYXJnXzA2MyIsImJuZHNfMDQzJDIiLCJhcmdfMDYxIiwiYm5kc18wNDMkMyIsImFyZ18wNTkiLCJibmRzXzA0MyQ0IiwiYXJnXzA1NyIsImJuZHNfMDQzJDUiLCJhcmdfMDU1IiwiYm5kc18wNDMkNiIsImFyZ18wNTMiLCJibmRzXzA0MyQ3IiwiYXJnXzA1MSIsImJuZHNfMDQzJDgiLCJ2XzA0NyIsImFyZ18wNDkiLCJibmRfMDQ4IiwiYm5kc18wNDMkOSIsImFyZ18wNDUiLCJibmRzXzA0MyQxMCIsImhhc2giLCJpc19yZWFkX2Nsb3NlZCIsInB1c2hiYWNrJDEiLCJ4XzA3MyIsInhfMDM1IiwiaSQyIiwic2V4cF9vZl9waGFudG9tIiwib2ZfYV8wNzQiLCJ4XzA3NSIsInNleHBfb2ZfcGhhbnRvbSQwIiwib2ZfYV8wNzYiLCJ4XzA3NyIsImlkX3JlZiIsImluaXRpYWxfYnVmZmVyIiwidmFsaWRhdGVfc2l6ZV9idWRnZXQiLCJ1cGRhdGVfcHVzaGJhY2siLCJ4XzA3OCIsImNsb3NlX3JlYWQiLCJ4XzA3OSIsImZsdXNoIiwiY3JlYXRlX3JlYWRlcl9ub3RfY2xvc2Vfb25fZXhjIiwidyIsImNyZWF0ZV9yZWFkZXIiLCJjbG9zZV9vbl9leGNlcHRpb24iLCJjcmVhdGVfd3JpdGVyIiwidmFsdWVzX3dlcmVfcmVhZCIsImZsdXNoJDAiLCJmbHVzaF9yZXN1bHQiLCJjb25zdW1lX29uZSIsImNvbnN1bWUiLCJtYXhfcXVldWVfbGVuZ3RoIiwicmVzdWx0JDAiLCJzZXRfc2l6ZV9idWRnZXQkMCIsInN0YXJ0X3dyaXRlIiwieF8wODEiLCJ4XzA4MCIsImZpbmlzaF93cml0ZSIsImJsb2NrZWRfcmVhZCIsIml2YXIkMSIsInRyYW5zZmVyX2luX3dpdGhvdXRfcHVzaGJhY2siLCJ0cmFuc2Zlcl9pbiIsIndyaXRlIiwid3JpdGVfd2l0aG91dF9wdXNoYmFjayIsIndyaXRlJDAiLCJ3cml0ZV93aGVuX3JlYWR5Iiwid3JpdGVfaWZfb3BlbiIsIndyaXRlX3dpdGhvdXRfcHVzaGJhY2tfaWZfb3BlbiIsImVuc3VyZV9jb25zdW1lcl9tYXRjaGVzIiwieF8wODMiLCJzdGFydF9yZWFkIiwibGFiZWwiLCJ4XzA4NCIsImdlbl9yZWFkX25vdyIsImdldF9tYXhfcXVldWVfbGVuZ3RoIiwibWF4X3F1ZXVlX2xlbmd0aCQwIiwicmVhZF9ub3ciLCJyZWFkX25vdyQwIiwicmVhZCQwIiwicmVhZF9leG4iLCJ2YWx1ZXNfYXZhaWxhYmxlIiwicmVhZF9jaG9pY2UiLCJyZWFkX2Nob2ljZV9zaW5nbGVfY29uc3VtZXJfZXgiLCJyZWFkX2V4YWN0bHkiLCJudW1fdmFsdWVzIiwiYWxyZWFkeV9yZWFkIiwiZG93bnN0cmVhbV9mbHVzaGVkIiwidXBzdHJlYW1fZmx1c2hlZCIsImFkZF9jb25zdW1lciIsInBpcGVfaWQiLCJjb25zdW1lciQxIiwidXBzdHJlYW0iLCJkb3duc3RyZWFtIiwidXBzdHJlYW1fZmx1c2hlZCQwIiwiYXJnMF8wODUiLCJyZXMwXzA4NiIsImZvbGRfZ2VuIiwiZmx1c2hlZCIsImZvbGRfd2l0aG91dF9wdXNoYmFjayIsIndpdGhfZXJyb3JfdG9fY3VycmVudF9tb25pdG9yIiwiaXRlcl93aXRob3V0X3B1c2hiYWNrIiwibWF4X2l0ZXJhdGlvbnNfcGVyX2pvYiIsIm1heF9pdGVyYXRpb25zX3Blcl9qb2IkMCIsIm1heF9pdGVyYXRpb25zX3Blcl9qb2IkMSIsInJlbWFpbmluZyIsInJlbWFpbmluZyQwIiwiZHJhaW4iLCJkcmFpbl9hbmRfY291bnQiLCJzdW0iLCJyZWFkX2FsbCIsImlucHV0IiwidG9fc3RyZWFtX2RlcHJlY2F0ZWQiLCJvZl9zdHJlYW1fZGVwcmVjYXRlZCIsInRyYW5zZmVyIiwibmV4dF9kZWZlcnJlZCIsImNoZWNrX2Nsb3NlZF9sb29wX25leHQiLCJ0cmFuc2Zlcl9nZW4iLCJvdXRwdXQiLCJsaW5rIiwidW5saW5rIiwib3V0cHV0X2Nsb3NlZCIsInRyYW5zZmVyJDAiLCJ0cmFuc2Zlcl9pZCIsIm1hcF9nZW4iLCJjb25jYXRfbWFwX2xpc3QiLCJmaWx0ZXJfbWFwJDAiLCJmb2xkaW5nX2ZpbHRlcl9tYXAiLCJmb2xkaW5nX2ZpbHRlcl9tYXAkMCIsImZvbGRpbmdfbWFwIiwiYWNjdW0kMCIsImVtcHR5Iiwic2luZ2xldG9uIiwid3JpdGVyIiwicmVhZGVyIiwib2Zfc2VxdWVuY2UiLCJzZXF1ZW5jZSQxIiwic2VxdWVuY2UkMCIsInRvX3NlcXVlbmNlIiwiaW50ZXJsZWF2ZV9waXBlIiwiaW5wdXRzIiwib3V0cHV0X3dyaXRlciIsIm51bV9waXBlc19yZW1haW5pbmciLCJkZWNyX251bV9waXBlc19yZW1haW5pbmciLCJoZWFwIiwiaGFuZGxlX3JlYWQiLCJlb2Zfb3Jfb2siLCJwb3BfaGVhcF9hbmRfbG9vcCIsImluaXRpYWxfcHVzaCIsImNvbmNhdF9waXBlIiwiZm9yayIsInB1c2hiYWNrX3VzZXMiLCJ3cml0ZXIwIiwicmVhZGVyMCIsIndyaXRlcjEiLCJyZWFkZXIxIiwic29tZV9yZWFkZXJfd2FzX2Nsb3NlZCIsInNvbWVfcmVhZGVyX3dhc19jbG9zZWQkMCIsInN0aWxsX29wZW4iLCJmaWx0ZXJfb3BlbiIsInN0aWxsX29wZW4kMCIsInNldF9pbmZvIiwidmFsdWVfYXZhaWxhYmxlIiwic2V0X3ZhbHVlX2F2YWlsYWJsZSIsInRha2VuIiwiY3VycmVudF92YWx1ZSIsInZhbHVlX2F2YWlsYWJsZSQwIiwidGFrZW4kMCIsImN1cnJlbnRfdmFsdWUkMCIsInZhbHVlX2F2YWlsYWJsZSQxIiwieF8wMTAiLCJ0YWtlbl8wMDYiLCJjdXJyZW50X3ZhbHVlXzAwNCIsInZhbHVlX2F2YWlsYWJsZV8wMDgiLCJibmRzXzAwMyIsImJuZHNfMDAzJDAiLCJibmRzXzAwMyQxIiwidmFsdWVfYXZhaWxhYmxlX2Z1biIsImFfMDExIiwiYl8wMTIiLCJ0YWtlbl9mdW4iLCJjdXJyZW50X3ZhbHVlX2Z1biIsInBlZWtfZXhuIiwieF8wMTMiLCJvZl9hXzAxNCIsInhfMDE1IiwieF8wMTciLCJ3cml0ZV9vbmx5IiwidGFrZV9ub25lbXB0eSIsInRha2Vfbm93X2V4biIsInRha2Vfbm93IiwidGFrZSIsInVwZGF0ZV9leG4iLCJ0YWtlbiQxIiwicHV0IiwicGlwZV93aGVuX3JlYWR5IiwiY3JlYXRlX29yX2Vycm9yIiwid2FpdF9leG4iLCJmb3JjZSIsImZvcmNlX2V4biIsImJpbmQkMSIsImlzX2ZvcmNlZCIsIndhaXRzXzAwMyIsInNpZ25hbCIsImRlbGV0ZSQwIiwiY2hlY2tfZmllbGQkMCIsIndhaXRfZm9yX3ByZXZpb3VzIiwic3ltYm9sIiwic3ltYm9sJDAiLCJzeW1ib2wkMSJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL3RpbWVfbnMubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9kZWJ1Zy5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2ltcG9ydC5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL3ByaW9yaXR5Lm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvdHlwZXMubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9tb25pdG9yMC5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2V4ZWN1dGlvbl9jb250ZXh0Lm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvZXh0ZXJuYWxfam9iLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvam9iX3Bvb2wubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9qb2IubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9qb2Jfb3JfZXZlbnQubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9zY2hlZHVsZXIwLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvam9iX3F1ZXVlLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvc3luY2hyb25vdXNfdGltZV9zb3VyY2UwLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvc2NoZWR1bGVyMS5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2l2YXIwLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWQwLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvaXZhci5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL21vbmFkX3NlcXVlbmNlLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWQxLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWRfc3RkLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvaXZhcl9maWxsZXIubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC90YWlsLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvbW9uaXRvci5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2FzeW5jX3N0cmVhbS5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2J2YXIubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC90aW1lX3NvdXJjZS5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL3N0YWNrX29yX2NvdW50ZXIubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC90aHJvdHRsZS5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL3N5bmNocm9ub3VzX3RpbWVfc291cmNlLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvc2NoZWR1bGVyLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvY3ljbGVfaG9vay5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2FzeW5jX2tlcm5lbF9zY2hlZHVsZXIubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9jbG9ja19pbnRmLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvY2xvY2tfbnMubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9hcnJheS5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkX2xpc3QubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9tYXAubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9tZW1vLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWRfb3B0aW9uLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWRfcmVzdWx0Lm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvZGVmZXJyZWRfb3JfZXJyb3IubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9kZWZlcnJlZF9xdWV1ZS5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2RlZmVycmVkX3NlcXVlbmNlLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvcmVxdWlyZV9leHBsaWNpdF90aW1lX3NvdXJjZS5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL3BpcGUubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9tdmFyLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvbGF6eV9kZWZlcnJlZC5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2FzeW5jX2NvbmRpdGlvbi5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYXN5bmNfa2VybmVsL2FzeW5jX2djLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9hc3luY19rZXJuZWwvYXN5bmNfaW52YXJpYW50X2ludGYubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9hc3luY19pbnZhcmlhbnQubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2FzeW5jX2tlcm5lbC9hc3luY19rZXJuZWwubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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dEI7bUJBUXNCOzs7Ozt3QixtQkFFekI7d0JBR2dDO3lCQUZuQ2dPOztzRUFBQUE7eUJBRW1DLE1BQUEsMEJBYlA4Zjs7Ozs7Ozs7Ozs7O0dBbkJ6QixnQkFHVC9WLGFBZ0JBK3RDOzs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7Ozs7O0lDcUVXeDNDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbkJhO0lBbkMxQnZPO0lBQ0FrUDtJQUNBeXRCO0lBQ0F4SDtJQUNBUTtJQUNBYjtJQUNBZ1I7SUFDQXhSO0lBQ0E5YTtJQUNBd2hCO0lBQ0FXO0lBQ0FqSjtJQUNBd1Q7SUFDQXhMO0lBQ0FFO0lBT0FxckI7SUFHQUM7SUFHQUM7Ozs7OztJQVEwQjs7Ozs7Ozs7Ozs7TUFhbkIsSUFNTXB6QyxTQU5OO01BQ21CO01BQ0E7TUFDQTtNQUNBO01BQ25CLElBQ01QLE1BRE4sZ0NBQ01DO2VBQUFDLFdBQUF1OEIsT0FBQUM7T0FBQSxPQUFBLHNCQUFBRCxPQUFBQztNQUFHOzs7UUFBSDNnQztRQUFBa0U7UUFBQUM7Ozs7UUFBQUs7UUFBQVA7Ozs7Ozs7Ozs7T0F0RGJ4UztPQUNBa1A7T0FDQXl0QjtPQUNBeEg7T0FDQVE7T0FDQWI7T0FDQWdSO09BQ0F4UjtPQUNBOWE7T0FDQXdoQjtPQUNBVztPQUNBako7T0FDQXdUO09BQ0F4TDtPQUNBRTtPQU9BcXJCO09BR0FDO09BR0FDOzs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiaW5jbHVkZSBDb3JlLkNvcmVfcHJpdmF0ZS5UaW1lX25zX2FsdGVybmF0ZV9zZXhwXG5cbigqIFthZnRlcl0gaXMgbGlrZSBbYWRkXSwgYnV0IGRlYWxzIG5pY2VseSB3aXRoIHRoZSBjYXNlIG9mIG92ZXJmbG93IGJ5IGluc3RlYWQgcmV0dXJuaW5nXG4gICBbbWF4X3ZhbHVlXS4gIFRpbWUtc291cmNlIGZ1bmN0aW9ucyB1c2UgW2FmdGVyXSB0byBhdm9pZCBpbW1lZGlhdGVseSBmaXJpbmcgZXZlbnRzIHRoYXRcbiAgIHNob3VsZCBuZXZlciBmaXJlLCBkdWUgdG8gdGhlIG92ZXJmbG93IGxlYWRpbmcgdG8gYSBuZWdhdGl2ZSB0aW1lIHRoYXQgYXBwZWFycyB0byBiZSBpblxuICAgdGhlIHBhc3QuICBXZSBkb24ndCBjaGVjayB1bmRlcmZsb3cgYmVjYXVzZSB0aGF0IGlzIHZlcnkgdW5saWtlbHksIHJlcXVpcmluZyBib3RoIGFcbiAgIG5lZ2F0aXZlIHRpbWUgYW5kIGEgbmVnYXRpdmUgc3Bhbi4gKilcbmxldCBhZnRlciB0IHNwYW4gPVxuICBsZXQgcmVzdWx0ID0gYWRkIHQgc3BhbiBpblxuICBpZiBTcGFuLiggPiApIHNwYW4gU3Bhbi56ZXJvICYmIHJlc3VsdCA8IHQgdGhlbiBtYXhfdmFsdWVfZm9yXzF1c19yb3VuZGluZyBlbHNlIHJlc3VsdFxuOztcbiIsIm1vZHVsZSBUaW1lX25zX2luX3RoaXNfZGlyZWN0b3J5ID0gVGltZV9uc1xub3BlbiBDb3JlXG5tb2R1bGUgVGltZV9ucyA9IFRpbWVfbnNfaW5fdGhpc19kaXJlY3RvcnlcbmluY2x1ZGUgQXN5bmNfa2VybmVsX2NvbmZpZy5QcmludF9kZWJ1Z19tZXNzYWdlc19mb3JcblxubGV0IGxvZyBtZXNzYWdlIGEgc2V4cF9vZl9hID1cbiAgZXByaW50ZlxuICAgIFwiJXNcXG4lIVwiXG4gICAgKFNleHAudG9fc3RyaW5nX2h1bVxuICAgICAgIChbJXNleHBfb2Y6IFNleHAudCAqIFRpbWVfbnMudCAqIHN0cmluZyAqIGFdXG4gICAgICAgICAgKCFBc3luY19rZXJuZWxfY29uZmlnLnRhc2tfaWQgKCksIFRpbWVfbnMubm93ICgpLCBtZXNzYWdlLCBhKSkpXG47O1xuXG5sZXQgbG9nX3N0cmluZyBtZXNzYWdlID0gbG9nIG1lc3NhZ2UgKCkgWyVzZXhwX29mOiB1bml0XVxuIiwibW9kdWxlIERlYnVnX2luX3RoaXNfZGlyZWN0b3J5ID0gRGVidWdcbm1vZHVsZSBUaW1lX25zX2luX3RoaXNfZGlyZWN0b3J5ID0gVGltZV9uc1xub3BlbiEgQ29yZVxuaW5jbHVkZSBJbnQuUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5tb2R1bGUgRGVidWcgPSBEZWJ1Z19pbl90aGlzX2RpcmVjdG9yeVxubW9kdWxlIFRpbWVfbnMgPSBUaW1lX25zX2luX3RoaXNfZGlyZWN0b3J5XG5tb2R1bGUgUG9vbCA9IFR1cGxlX3Bvb2xcblxubW9kdWxlIE1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlID1cbiAgQXN5bmNfa2VybmVsX2NvbmZpZy5NYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZVxuXG5sZXQgY29uY2F0ID0gU3RyaW5nLmNvbmNhdFxubGV0IGVwcmludCA9IENvcmUuRGVidWcuZXByaW50XG5sZXQgZXByaW50X3MgPSBDb3JlLkRlYnVnLmVwcmludF9zXG5sZXQgZXByaW50cyA9IENvcmUuRGVidWcuZXByaW50c1xubGV0IHByaW50X3Mgc2V4cCA9IHByaW50ZiBcIiVzXFxuJSFcIiAoc2V4cCB8PiBTZXhwLnRvX3N0cmluZ19odW0pXG5sZXQgc2VjID0gVGltZV9ucy5TcGFuLm9mX3NlY1xuXG4oKiBXZSBkb24ndCB3YW50IHRvIHVzZSB0aGVzZSBtb2R1bGVzIGluIEFzeW5jX2tlcm5lbCwgdG8gYXZvaWQgZGlmZmljdWx0aWVzIHdpdGhcbiAgIHVzaW5nIGl0IG9uIGpzX29mX29jYW1sLiAqKVxubW9kdWxlIFRocmVhZCA9IHN0cnVjdCBlbmRcbm1vZHVsZSBVbml4ID0gc3RydWN0IGVuZFxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5cbnR5cGUgdCA9XG4gIHwgTm9ybWFsXG4gIHwgTG93XG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgbm9ybWFsID0gTm9ybWFsXG5sZXQgbG93ID0gTG93XG4iLCIoKiBUaGlzIGZpbGUgZGVmaW5lcyB0aGUgbXV0dWFsbHkgcmVjdXJzaXZlIHR5cGVzIGF0IHRoZSBoZWFydCBvZiBBc3luYy4gIFRoZSBmdW5jdGlvbnNcbiAgIGFzc29jaWF0ZWQgd2l0aCB0aGUgdHlwZXMgYXJlIGRlZmluZWQgaW4gdGhlIGNvcnJlc3BvbmRpbmcgZmlsZShzKSBmb3IgZWFjaCBtb2R1bGUuXG4gICBUaGlzIGZpbGUgc2hvdWxkIGRlZmluZSBvbmx5IHR5cGVzLCBub3QgZnVuY3Rpb25zLCBzaW5jZSBmdW5jdGlvbnMgZGVmaW5lZCBpbnNpZGUgdGhlXG4gICByZWN1cnNpdmUgbW9kdWxlcyBhcmUgbm90IGlubGluZWQuXG5cbiAgIElmIHlvdSBuZWVkIHRvIGFkZCBmdW5jdGlvbmFsaXR5IHRvIGEgbW9kdWxlIGJ1dCBkb2luZyBzbyB3b3VsZCBjcmVhdGUgYSBkZXBlbmRlbmN5XG4gICBjeWNsZSwgc3BsaXQgdGhlIGZpbGUgaW50byBwaWVjZXMgYXMgbmVlZGVkIHRvIGJyZWFrIHRoZSBjeWNsZSwgZS5nLiBzY2hlZHVsZXIwLm1sLFxuICAgc2NoZWR1bGVyMS5tbCwgc2NoZWR1bGVyLm1sLiAqKVxuXG5vcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIHJlYyBDZWxsIDogc2lnXG4gIHR5cGUgYW55ID1cbiAgICBbIGBFbXB0eVxuICAgIHwgYEVtcHR5X29uZV9oYW5kbGVyXG4gICAgfCBgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnNcbiAgICB8IGBGdWxsXG4gICAgfCBgSW5kaXJcbiAgICBdXG5cbiAgdHlwZSAoJ2EsICdiKSB0ID1cbiAgICB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIDpcbiAgICAgICAgeyBtdXRhYmxlIHJ1biA6ICdhIC0+IHVuaXRcbiAgICAgICAgOyBleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICAgICAgOyBtdXRhYmxlIHByZXYgOiAnYSBIYW5kbGVyLnRcbiAgICAgICAgOyBtdXRhYmxlIG5leHQgOiAnYSBIYW5kbGVyLnRcbiAgICAgICAgfVxuICAgICAgICAtPiAoJ2EsIFs+IGBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBdKSB0XG4gICAgfCBFbXB0eV9vbmVfaGFuZGxlciA6XG4gICAgICAgICgnYSAtPiB1bml0KSAqIEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICAgICAgLT4gKCdhLCBbPiBgRW1wdHlfb25lX2hhbmRsZXIgXSkgdFxuICAgIHwgRW1wdHkgOiAoJ2EsIFs+IGBFbXB0eSBdKSB0XG4gICAgfCBGdWxsIDogJ2EgLT4gKCdhLCBbPiBgRnVsbCBdKSB0XG4gICAgfCBJbmRpciA6ICdhIEl2YXIudCAtPiAoJ2EsIFs+IGBJbmRpciBdKSB0XG5lbmQgPVxuICBDZWxsXG5cbmFuZCBIYW5kbGVyIDogc2lnXG4gIHR5cGUgJ2EgdCA9ICgnYSwgWyBgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXSkgQ2VsbC50XG5lbmQgPVxuICBIYW5kbGVyXG5cbmFuZCBJdmFyIDogc2lnXG4gIHR5cGUgJ2EgdCA9IHsgbXV0YWJsZSBjZWxsIDogKCdhLCBDZWxsLmFueSkgQ2VsbC50IH1cblxuICBtb2R1bGUgSW1tdXRhYmxlIDogc2lnXG4gICAgdHlwZSAnYSB0ID0geyBjZWxsIDogKCdhLCBDZWxsLmFueSkgQ2VsbC50IH1cbiAgZW5kXG5lbmQgPVxuICBJdmFyXG5cbmFuZCBEZWZlcnJlZCA6IHNpZ1xuICB0eXBlICsnYSB0XG5lbmQgPVxuICBEZWZlcnJlZFxuXG5hbmQgRXhlY3V0aW9uX2NvbnRleHQgOiBzaWdcbiAgdHlwZSB0ID1cbiAgICB7IG1vbml0b3IgOiBNb25pdG9yLnRcbiAgICA7IHByaW9yaXR5IDogUHJpb3JpdHkudFxuICAgIDsgbG9jYWxfc3RvcmFnZSA6IFVuaXZfbWFwLnRcbiAgICA7IGJhY2t0cmFjZV9oaXN0b3J5IDogQmFja3RyYWNlLnQgbGlzdFxuICAgIH1cbmVuZCA9XG4gIEV4ZWN1dGlvbl9jb250ZXh0XG5cbmFuZCBGb3J3YXJkaW5nIDogc2lnXG4gIHR5cGUgdCA9XG4gICAgfCBEZXRhY2hlZFxuICAgIHwgUGFyZW50IG9mIE1vbml0b3IudFxuICAgIHwgUmVwb3J0X3VuY2F1Z2h0X2V4blxuZW5kID1cbiAgRm9yd2FyZGluZ1xuXG5hbmQgTW9uaXRvciA6IHNpZ1xuICB0eXBlIHQgPVxuICAgIHsgbmFtZSA6IEluZm8udFxuICAgIDsgaGVyZSA6IFNvdXJjZV9jb2RlX3Bvc2l0aW9uLnQgb3B0aW9uXG4gICAgOyBpZCA6IGludFxuICAgIDsgbXV0YWJsZSBuZXh0X2Vycm9yIDogZXhuIEl2YXIudFxuICAgIDsgbXV0YWJsZSBoYW5kbGVyc19mb3JfYWxsX2Vycm9ycyA6IChFeGVjdXRpb25fY29udGV4dC50ICogKGV4biAtPiB1bml0KSkgQmFnLnRcbiAgICA7IG11dGFibGUgdGFpbHNfZm9yX2FsbF9lcnJvcnMgOiBleG4gVGFpbC50IGxpc3RcbiAgICA7IG11dGFibGUgaGFzX3NlZW5fZXJyb3IgOiBib29sXG4gICAgOyBtdXRhYmxlIGZvcndhcmRpbmcgOiBGb3J3YXJkaW5nLnRcbiAgICB9XG5lbmQgPVxuICBNb25pdG9yXG5cbmFuZCBUYWlsIDogc2lnXG4gIHR5cGUgJ2EgdCA9IHsgbXV0YWJsZSBuZXh0IDogJ2EgU3RyZWFtLm5leHQgSXZhci50IH1cbmVuZCA9XG4gIFRhaWxcblxuYW5kIFN0cmVhbSA6IHNpZ1xuICB0eXBlICdhIHQgPSAnYSBuZXh0IERlZmVycmVkLnRcblxuICBhbmQgJ2EgbmV4dCA9XG4gICAgfCBOaWxcbiAgICB8IENvbnMgb2YgJ2EgKiAnYSB0XG5lbmQgPVxuICBTdHJlYW1cblxuKCogV2UgYXZvaWQgdXNpbmcgW21vZHVsZSByZWNdIHRvIGRlZmluZSBbQnZhcl0sIHNvIHRoYXQgW3RvX3JlcHJdIGFuZCBbb2ZfcmVwcl0gYXJlXG4gICBpbmxpbmVkLiAqKVxubW9kdWxlIEJ2YXIgOiBzaWdcbiAgdHlwZSAoJ2EsIC0ncGVybWlzc2lvbikgdFxuXG4gICgqKiBbcmVwcl0gZXhpc3RzIHNvIHRoYXQgd2UgbWF5IGhpZGUgdGhlIGltcGxlbWVudGF0aW9uIG9mIGEgW0J2YXIudF0sIGFuZCB0aGVuIGFkZCBhXG4gICAgICBwaGFudG9tIHR5cGUgdG8gaXQgdXBzdHJlYW0uICBXaXRob3V0IHRoaXMsIHRoZSBwaGFudG9tIHR5cGUgdmFyaWFibGUgd291bGQgYWxsb3dcbiAgICAgIGZvciBhbnl0aGluZyB0byBiZSBjb2VyY2VkIGluIGFuZCBvdXQsIHNpbmNlIGl0IGlzIHVudXNlZC4gKilcbiAgdHlwZSAnYSByZXByID1cbiAgICB7IG11dGFibGUgaGFzX2FueV93YWl0ZXJzIDogYm9vbFxuICAgIDsgbXV0YWJsZSBpdmFyIDogJ2EgSXZhci50XG4gICAgfVxuXG4gIHZhbCBvZl9yZXByIDogJ2EgcmVwciAtPiAoJ2EsICdwZXJtaXNzaW9uKSB0XG4gIHZhbCB0b19yZXByIDogKCdhLCAncGVybWlzc2lvbikgdCAtPiAnYSByZXByXG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSByZXByID1cbiAgICB7IG11dGFibGUgaGFzX2FueV93YWl0ZXJzIDogYm9vbFxuICAgIDsgbXV0YWJsZSBpdmFyIDogJ2EgSXZhci50XG4gICAgfVxuXG4gIHR5cGUgKCdhLCAncGVybWlzc2lvbikgdCA9ICdhIHJlcHJcblxuICBsZXQgdG9fcmVwciB0ID0gdFxuICBsZXQgb2ZfcmVwciB0ID0gdFxuZW5kXG5cbm1vZHVsZSByZWMgRXZlbnQgOiBzaWdcbiAgbW9kdWxlIFN0YXR1cyA6IHNpZ1xuICAgIHR5cGUgdCA9XG4gICAgICB8IEZpcmVkXG4gICAgICB8IEhhcHBlbmluZ1xuICAgICAgfCBTY2hlZHVsZWRcbiAgICAgIHwgVW5zY2hlZHVsZWRcbiAgZW5kXG5cbiAgbW9kdWxlIE9wdGlvbiA6IHNpZ1xuICAgIHR5cGUgdFxuICBlbmRcblxuICB0eXBlIHQgPVxuICAgIHsgbXV0YWJsZSBhbGFybSA6IEpvYl9vcl9ldmVudC50IFRpbWluZ193aGVlbC5BbGFybS50XG4gICAgOyBtdXRhYmxlIGF0IDogVGltZV9ucy50XG4gICAgOyBjYWxsYmFjayA6IHVuaXQgLT4gdW5pdFxuICAgIDsgZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50XG4gICAgOyBtdXRhYmxlIGludGVydmFsIDogVGltZV9ucy5TcGFuLnQgb3B0aW9uXG4gICAgOyBtdXRhYmxlIG5leHRfZmlyZWQgOiBPcHRpb24udFxuICAgIDsgbXV0YWJsZSBwcmV2X2ZpcmVkIDogT3B0aW9uLnRcbiAgICA7IG11dGFibGUgc3RhdHVzIDogU3RhdHVzLnRcbiAgICB9XG5lbmQgPVxuICBFdmVudFxuXG5hbmQgRXh0ZXJuYWxfam9iIDogc2lnXG4gIHR5cGUgdCA9IFQgOiBFeGVjdXRpb25fY29udGV4dC50ICogKCdhIC0+IHVuaXQpICogJ2EgLT4gdFxuZW5kID1cbiAgRXh0ZXJuYWxfam9iXG5cbmFuZCBKb2IgOiBzaWdcbiAgdHlwZSBzbG90cyA9IChFeGVjdXRpb25fY29udGV4dC50LCBPYmoudCAtPiB1bml0LCBPYmoudCkgUG9vbC5TbG90cy50M1xuICB0eXBlIHQgPSBzbG90cyBQb29sLlBvaW50ZXIudFxuZW5kID1cbiAgSm9iXG5cbmFuZCBKb2Jfb3JfZXZlbnQgOiBzaWdcbiAgdHlwZSB0XG5lbmQgPVxuICBKb2Jfb3JfZXZlbnRcblxuYW5kIEpvYl9wb29sIDogc2lnXG4gIHR5cGUgdCA9IEpvYi5zbG90cyBQb29sLnRcbmVuZCA9XG4gIEpvYl9wb29sXG5cbmFuZCBKb2JfcXVldWUgOiBzaWdcbiAgdHlwZSB0ID1cbiAgICB7IG11dGFibGUgbnVtX2pvYnNfcnVuIDogaW50XG4gICAgOyBtdXRhYmxlIGpvYnNfbGVmdF90aGlzX2N5Y2xlIDogaW50XG4gICAgOyBtdXRhYmxlIGpvYnMgOiBPYmoudCBVbmlmb3JtX2FycmF5LnRcbiAgICA7IG11dGFibGUgbWFzayA6IGludFxuICAgIDsgbXV0YWJsZSBmcm9udCA6IGludFxuICAgIDsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgICB9XG5lbmQgPVxuICBKb2JfcXVldWVcblxuYW5kIEpvYnMgOiBzaWdcbiAgdHlwZSB0ID1cbiAgICB7IHNjaGVkdWxlciA6IFNjaGVkdWxlci50XG4gICAgOyBtdXRhYmxlIGpvYl9wb29sIDogSm9iX3Bvb2wudFxuICAgIDsgbm9ybWFsIDogSm9iX3F1ZXVlLnRcbiAgICA7IGxvdyA6IEpvYl9xdWV1ZS50XG4gICAgfVxuZW5kID1cbiAgSm9ic1xuXG5hbmQgU2NoZWR1bGVyIDogc2lnXG5cbiAgdHlwZSB0ID1cbiAgICB7IG11dGFibGUgY2hlY2tfYWNjZXNzIDogKHVuaXQgLT4gdW5pdCkgb3B0aW9uXG4gICAgOyBtdXRhYmxlIGpvYl9wb29sIDogSm9iX3Bvb2wudFxuICAgIDsgbm9ybWFsX3ByaW9yaXR5X2pvYnMgOiBKb2JfcXVldWUudFxuICAgIDsgbG93X3ByaW9yaXR5X2pvYnMgOiBKb2JfcXVldWUudFxuICAgIDsgdmVyeV9sb3dfcHJpb3JpdHlfd29ya2VycyA6IFZlcnlfbG93X3ByaW9yaXR5X3dvcmtlci50IERlcXVlLnRcbiAgICA7IG11dGFibGUgbWFpbl9leGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICA7IG11dGFibGUgY3VycmVudF9leGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICA7IG11dGFibGUgdW5jYXVnaHRfZXhuIDogKEV4bi50ICogU2V4cC50KSBvcHRpb25cbiAgICA7IG11dGFibGUgY3ljbGVfY291bnQgOiBpbnRcbiAgICA7IG11dGFibGUgY3ljbGVfc3RhcnQgOiBUaW1lX25zLnRcbiAgICA7IG11dGFibGUgaW5fY3ljbGUgOiBib29sXG4gICAgOyBtdXRhYmxlIHJ1bl9ldmVyeV9jeWNsZV9zdGFydCA6IEN5Y2xlX2hvb2sudCBsaXN0XG4gICAgOyBydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUgOiAoQ3ljbGVfaG9va19oYW5kbGUudCwgQ3ljbGVfaG9vay50KSBIYXNodGJsLnRcbiAgICA7IG11dGFibGUgcnVuX2V2ZXJ5X2N5Y2xlX2VuZCA6IEN5Y2xlX2hvb2sudCBsaXN0XG4gICAgOyBydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlIDogKEN5Y2xlX2hvb2tfaGFuZGxlLnQsIEN5Y2xlX2hvb2sudCkgSGFzaHRibC50XG4gICAgOyBtdXRhYmxlIGxhc3RfY3ljbGVfdGltZSA6IFRpbWVfbnMuU3Bhbi50XG4gICAgOyBtdXRhYmxlIGxhc3RfY3ljbGVfbnVtX2pvYnMgOiBpbnRcbiAgICA7IG11dGFibGUgdG90YWxfY3ljbGVfdGltZSA6IFRpbWVfbnMuU3Bhbi50XG4gICAgOyBtdXRhYmxlIHRpbWVfc291cmNlIDogcmVhZF93cml0ZSBUaW1lX3NvdXJjZS50MVxuICAgIDsgZXh0ZXJuYWxfam9icyA6IEV4dGVybmFsX2pvYi50IFRocmVhZF9zYWZlX3F1ZXVlLnRcbiAgICA7IG11dGFibGUgdGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2sgOiB1bml0IC0+IHVuaXRcbiAgICA7IG11dGFibGUgam9iX3F1ZXVlZF9ob29rIDogKFByaW9yaXR5LnQgLT4gdW5pdCkgb3B0aW9uXG4gICAgOyBtdXRhYmxlIGV2ZW50X2FkZGVkX2hvb2sgOiAoVGltZV9ucy50IC0+IHVuaXQpIG9wdGlvblxuICAgIDsgbXV0YWJsZSB5aWVsZCA6ICh1bml0LCByZWFkX3dyaXRlKSBCdmFyLnRcbiAgICA7IG11dGFibGUgeWllbGRfdW50aWxfbm9fam9ic19yZW1haW4gOiAodW5pdCwgcmVhZF93cml0ZSkgQnZhci50XG4gICAgOyBtdXRhYmxlIGNoZWNrX2ludmFyaWFudHMgOiBib29sXG4gICAgOyBtdXRhYmxlIG1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlIDogTWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUudFxuICAgIDsgbXV0YWJsZSByZWNvcmRfYmFja3RyYWNlcyA6IGJvb2xcbiAgICB9XG5lbmQgPVxuICBTY2hlZHVsZXJcblxuYW5kIEN5Y2xlX2hvb2sgOiBzaWdcbiAgdHlwZSB0ID0gdW5pdCAtPiB1bml0XG5lbmQgPVxuICBDeWNsZV9ob29rXG5cbmFuZCBDeWNsZV9ob29rX2hhbmRsZSA6IFVuaXF1ZV9pZC5JZCA9IFVuaXF1ZV9pZC5JbnQ2MyAoKVxuYW5kIFRpbWVfc291cmNlX2lkIDogVW5pcXVlX2lkLklkID0gVW5pcXVlX2lkLkludDYzICgpXG5cbmFuZCBUaW1lX3NvdXJjZSA6IHNpZ1xuICB0eXBlIC0ncncgdDEgPVxuICAgIHsgaWQgOiBUaW1lX3NvdXJjZV9pZC50XG4gICAgOyBtdXRhYmxlIGFkdmFuY2VfZXJyb3JzIDogRXJyb3IudCBsaXN0XG4gICAgOyBtdXRhYmxlIGFtX2FkdmFuY2luZyA6IGJvb2xcbiAgICA7IGV2ZW50cyA6IEpvYl9vcl9ldmVudC50IFRpbWluZ193aGVlbC50XG4gICAgOyBtdXRhYmxlIGZpcmVkX2V2ZW50cyA6IEV2ZW50Lk9wdGlvbi50XG4gICAgOyBtdXRhYmxlIG1vc3RfcmVjZW50bHlfZmlyZWQgOiBFdmVudC5PcHRpb24udFxuICAgIDsgaGFuZGxlX2ZpcmVkIDogSm9iX29yX2V2ZW50LnQgVGltaW5nX3doZWVsLkFsYXJtLnQgLT4gdW5pdFxuICAgIDsgaXNfd2FsbF9jbG9jayA6IGJvb2xcbiAgICA7IHNjaGVkdWxlciA6IFNjaGVkdWxlci50XG4gICAgfVxuZW5kID1cbiAgVGltZV9zb3VyY2VcblxuYW5kIFZlcnlfbG93X3ByaW9yaXR5X3dvcmtlciA6IHNpZ1xuICBtb2R1bGUgRXhlY19yZXN1bHQgOiBzaWdcbiAgICB0eXBlIHQgPVxuICAgICAgfCBGaW5pc2hlZFxuICAgICAgfCBOb3RfZmluaXNoZWRcbiAgZW5kXG5cbiAgdHlwZSB0ID1cbiAgICB7IGV4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudFxuICAgIDsgZXhlYyA6IHVuaXQgLT4gRXhlY19yZXN1bHQudFxuICAgIH1cbmVuZCA9XG4gIFZlcnlfbG93X3ByaW9yaXR5X3dvcmtlclxuIiwib3BlbiBDb3JlXG5vcGVuIEltcG9ydFxuXG5sZXQgZGVidWcgPSBEZWJ1Zy5tb25pdG9yXG5cbm1vZHVsZSBGb3J3YXJkaW5nID0gVHlwZXMuRm9yd2FyZGluZ1xuXG50eXBlIHQgPSBUeXBlcy5Nb25pdG9yLnQgPVxuICB7IG5hbWUgOiBJbmZvLnRcbiAgOyBoZXJlIDogU291cmNlX2NvZGVfcG9zaXRpb24udCBvcHRpb25cbiAgOyBpZCA6IGludFxuICA7IG11dGFibGUgbmV4dF9lcnJvciA6IGV4biBUeXBlcy5JdmFyLnRcbiAgOyAoKiBbTW9uaXRvci5zZW5kX2V4bl0gc2NoZWR1bGVzIGEgam9iIGZvciBlYWNoIGVsZW1lbnQgb2YgW2hhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzXS4gKilcbiAgICBtdXRhYmxlIGhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzIDogKFR5cGVzLkV4ZWN1dGlvbl9jb250ZXh0LnQgKiAoZXhuIC0+IHVuaXQpKSBCYWcudFxuICA7ICgqIFtNb25pdG9yLnNlbmRfZXhuXSBleHRlbmRzIGVhY2ggdGFpbCBpbiBbdGFpbHNfZm9yX2FsbF9lcnJvcnNdLiAqKVxuICAgIG11dGFibGUgdGFpbHNfZm9yX2FsbF9lcnJvcnMgOiBleG4gVHlwZXMuVGFpbC50IGxpc3RcbiAgOyBtdXRhYmxlIGhhc19zZWVuX2Vycm9yIDogYm9vbFxuICA7IG11dGFibGUgZm9yd2FyZGluZyA6IEZvcndhcmRpbmcudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHNdXG5cbmxldCBkZXNjcmlwdGlvbiB0ID1cbiAgbWF0Y2ggdC5oZXJlIHdpdGhcbiAgfCBOb25lIC0+IFslc2V4cCAodC5uYW1lIDogSW5mby50KV1cbiAgfCBTb21lIGhlcmUgLT4gWyVzZXhwICh0Lm5hbWUgOiBJbmZvLnQpLCAoaGVyZSA6IFNvdXJjZV9jb2RlX3Bvc2l0aW9uLnQpXVxuOztcblxubGV0IGRlc2NyaXB0aW9ucyA9XG4gIGxldCByZWMgbG9vcCB0IGFjID1cbiAgICBsZXQgYWMgPSBkZXNjcmlwdGlvbiB0IDo6IGFjIGluXG4gICAgbWF0Y2ggdC5mb3J3YXJkaW5nIHdpdGhcbiAgICB8IERldGFjaGVkIHwgUmVwb3J0X3VuY2F1Z2h0X2V4biAtPiBMaXN0LnJldiBhY1xuICAgIHwgUGFyZW50IHQgLT4gbG9vcCB0IGFjXG4gIGluXG4gIGZ1biB0IC0+IGxvb3AgdCBbXVxuOztcblxubGV0IHNleHBfb2ZfdCB0ID0gWyVzZXhwIChkZXNjcmlwdGlvbnMgdCA6IFNleHAudCBsaXN0KV1cblxubGV0IG5leHRfaWQgPVxuICBsZXQgciA9IHJlZiAwIGluXG4gIGZ1biAoKSAtPlxuICAgIGluY3IgcjtcbiAgICAhclxuOztcblxubGV0IGNyZWF0ZV93aXRoX3BhcmVudCA/aGVyZSA/aW5mbyA/bmFtZSBwYXJlbnQgPVxuICBsZXQgaWQgPSBuZXh0X2lkICgpIGluXG4gIGxldCBuYW1lID1cbiAgICBtYXRjaCBpbmZvLCBuYW1lIHdpdGhcbiAgICB8IFNvbWUgaSwgTm9uZSAtPiBpXG4gICAgfCBTb21lIGksIFNvbWUgcyAtPiBJbmZvLnRhZyBpIH50YWc6c1xuICAgIHwgTm9uZSwgU29tZSBzIC0+IEluZm8ub2Zfc3RyaW5nIHNcbiAgICB8IE5vbmUsIE5vbmUgLT4gSW5mby5jcmVhdGUgXCJpZFwiIGlkIFslc2V4cF9vZjogaW50IFNleHBfaGlkZGVuX2luX3Rlc3QudF1cbiAgaW5cbiAgbGV0IHQgPVxuICAgIHsgbmFtZVxuICAgIDsgaGVyZVxuICAgIDsgZm9yd2FyZGluZyA9XG4gICAgICAgIChtYXRjaCBwYXJlbnQgd2l0aFxuICAgICAgICAgfCBOb25lIC0+IFJlcG9ydF91bmNhdWdodF9leG5cbiAgICAgICAgIHwgU29tZSBwYXJlbnQgLT4gUGFyZW50IHBhcmVudClcbiAgICA7IGlkXG4gICAgOyBuZXh0X2Vycm9yID0geyBjZWxsID0gRW1wdHkgfVxuICAgIDsgaGFuZGxlcnNfZm9yX2FsbF9lcnJvcnMgPSBCYWcuY3JlYXRlICgpXG4gICAgOyB0YWlsc19mb3JfYWxsX2Vycm9ycyA9IFtdXG4gICAgOyBoYXNfc2Vlbl9lcnJvciA9IGZhbHNlXG4gICAgfVxuICBpblxuICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZyBcImNyZWF0ZWQgbW9uaXRvclwiIHQgWyVzZXhwX29mOiB0XTtcbiAgdFxuOztcblxubGV0IG1haW4gPSBjcmVhdGVfd2l0aF9wYXJlbnQgfm5hbWU6XCJtYWluXCIgTm9uZVxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgTW9uaXRvciA9IE1vbml0b3IwXG5cbnR5cGUgdCA9IFR5cGVzLkV4ZWN1dGlvbl9jb250ZXh0LnQgPVxuICB7IG1vbml0b3IgOiBNb25pdG9yLnRcbiAgOyBwcmlvcml0eSA6IFByaW9yaXR5LnRcbiAgOyBsb2NhbF9zdG9yYWdlIDogVW5pdl9tYXAudFxuICA7IGJhY2t0cmFjZV9oaXN0b3J5IDogQmFja3RyYWNlLnQgbGlzdFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5cbmxldCBtYWluID1cbiAgeyBtb25pdG9yID0gTW9uaXRvci5tYWluXG4gIDsgcHJpb3JpdHkgPSBQcmlvcml0eS5ub3JtYWxcbiAgOyBsb2NhbF9zdG9yYWdlID0gVW5pdl9tYXAuZW1wdHlcbiAgOyBiYWNrdHJhY2VfaGlzdG9yeSA9IFtdXG4gIH1cbjs7XG5cbmxldCBjcmVhdGVfbGlrZSA/bW9uaXRvciA/cHJpb3JpdHkgP2xvY2FsX3N0b3JhZ2UgdCA9XG4gIGxldCBtb25pdG9yID0gT3B0aW9uLnZhbHVlIG1vbml0b3IgfmRlZmF1bHQ6dC5tb25pdG9yIGluXG4gIHsgbW9uaXRvclxuICA7IHByaW9yaXR5ID0gT3B0aW9uLnZhbHVlIHByaW9yaXR5IH5kZWZhdWx0OnQucHJpb3JpdHlcbiAgOyBsb2NhbF9zdG9yYWdlID0gT3B0aW9uLnZhbHVlIGxvY2FsX3N0b3JhZ2UgfmRlZmF1bHQ6dC5sb2NhbF9zdG9yYWdlXG4gIDsgYmFja3RyYWNlX2hpc3RvcnkgPSB0LmJhY2t0cmFjZV9oaXN0b3J5XG4gIH1cbjs7XG5cbmxldCBmaW5kX2xvY2FsIHQga2V5ID0gVW5pdl9tYXAuZmluZCB0LmxvY2FsX3N0b3JhZ2Uga2V5XG5cbmxldCB3aXRoX2xvY2FsIHQga2V5IGRhdGEgPVxuICB7IHQgd2l0aCBsb2NhbF9zdG9yYWdlID0gVW5pdl9tYXAuY2hhbmdlIHQubG9jYWxfc3RvcmFnZSBrZXkgfmY6KGZ1biBfIC0+IGRhdGEpIH1cbjs7XG5cbmxldCByZWNvcmRfYmFja3RyYWNlIHQgPVxuICB7IHQgd2l0aCBiYWNrdHJhY2VfaGlzdG9yeSA9IEJhY2t0cmFjZS5nZXQgKCkgOjogdC5iYWNrdHJhY2VfaGlzdG9yeSB9XG47O1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIFR5cGVzLkV4dGVybmFsX2pvYlxuXG5sZXQgc2V4cF9vZl90IF8gPSBTZXhwLkF0b20gXCI8am9iPlwiXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4gUG9vbFxuXG5sZXQgZHVtbXlfZSA9IEV4ZWN1dGlvbl9jb250ZXh0Lm1haW5cbmxldCBkdW1teV9mIDogT2JqLnQgLT4gdW5pdCA9IGlnbm9yZVxubGV0IGR1bW15X2EgOiBPYmoudCA9IE9iai5yZXByICgpXG5cbnR5cGUgc2xvdHMgPSAoRXhlY3V0aW9uX2NvbnRleHQudCwgT2JqLnQgLT4gdW5pdCwgKE9iai50W0BzZXhwLm9wYXF1ZV0pKSBTbG90cy50M1xuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxudHlwZSB0ID0gc2xvdHMgUG9vbC50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgdCA9IFBvb2wuaW52YXJpYW50IGlnbm9yZSB0XG5sZXQgY3JlYXRlICgpID0gY3JlYXRlIFNsb3RzLnQzIH5jYXBhY2l0eToxIH5kdW1teTooZHVtbXlfZSwgZHVtbXlfZiwgZHVtbXlfYSlcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPSBKb2JfcG9vbC5zbG90cyBQb29sLlBvaW50ZXIudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgRXZlbnQgPSBUeXBlcy5FdmVudFxubW9kdWxlIEpvYiA9IFR5cGVzLkpvYlxuaW5jbHVkZSBUeXBlcy5Kb2Jfb3JfZXZlbnRcblxuKCogVGhpcyByZWRlZmluaXRpb24gb2YgW0V2ZW50XSBpcyBoZXJlIHNvIHRoZSB0eXBlIGNoZWNrcyBhcmUgcmlnaHQgbmV4dCB0b1xuICAgW09iai5tYWdpY11zLiAqKVxubW9kdWxlIF8gOiBzaWcgZW5kID0gc3RydWN0XG4gIG9wZW4gVHlwZXNcbiAgb3BlbiBFdmVudFxuXG4gIHR5cGUgX3QgPSB0ID1cbiAgICB7ICgqIG11c3QgbmV2ZXIgYmUgaW1tZWRpYXRlICopXG4gICAgICBtdXRhYmxlIGFsYXJtIDogSm9iX29yX2V2ZW50LnQgVGltaW5nX3doZWVsLkFsYXJtLnRcbiAgICA7IG11dGFibGUgYXQgOiBUaW1lX25zLnRcbiAgICA7IGNhbGxiYWNrIDogdW5pdCAtPiB1bml0XG4gICAgOyBleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICA7IG11dGFibGUgaW50ZXJ2YWwgOiBUaW1lX25zLlNwYW4udCBvcHRpb25cbiAgICA7IG11dGFibGUgbmV4dF9maXJlZCA6IE9wdGlvbi50XG4gICAgOyBtdXRhYmxlIHByZXZfZmlyZWQgOiBPcHRpb24udFxuICAgIDsgbXV0YWJsZSBzdGF0dXMgOiBTdGF0dXMudFxuICAgIH1cbmVuZFxuXG5tb2R1bGUgXyA6IHNpZyBlbmQgPSBzdHJ1Y3RcbiAgbW9kdWxlIEVuc3VyZV9wcml2YXRlX2ludCAoTSA6IHNpZ1xuICAgICAgdHlwZSB0ID0gcHJpdmF0ZSBpbnRcbiAgICBlbmQpID1cbiAgc3RydWN0XG4gICAgdHlwZSBfdCA9IE0udFxuICBlbmRcblxuICBpbmNsdWRlIEVuc3VyZV9wcml2YXRlX2ludCAoSm9iKVxuZW5kXG5cbmxldCBvZl9ldmVudCBldmVudCA6IHQgPSBPYmoubWFnaWMgKGV2ZW50IDogRXZlbnQudClcbmxldCBvZl9qb2Igam9iIDogdCA9IE9iai5tYWdpYyAoam9iIDogSm9iLnQpXG5sZXQgaXNfZXZlbnQgKHQgOiB0KSA9IE9iai5pc19ibG9jayAoT2JqLnJlcHIgdClcbmxldCBpc19qb2IgKHQgOiB0KSA9IE9iai5pc19pbnQgKE9iai5yZXByIHQpXG5cbm1vZHVsZSBNYXRjaCA9IHN0cnVjdFxuICB0eXBlIF8ga2luZCA9XG4gICAgfCBFdmVudCA6IEV2ZW50LnQga2luZFxuICAgIHwgSm9iIDogSm9iLnQga2luZFxuXG4gIHR5cGUgcGFja2VkID0gSyA6IF8ga2luZCAtPiBwYWNrZWQgW0BAdW5ib3hlZF1cblxuICBsZXQga2luZCB0ID0gaWYgaXNfZXZlbnQgdCB0aGVuIEsgRXZlbnQgZWxzZSBLIEpvYlxuICBsZXQgcHJvamVjdCAodHlwZSBhKSAoXyA6IGEga2luZCkgam9iX29yX2V2ZW50ID0gKE9iai5tYWdpYyA6IHQgLT4gYSkgam9iX29yX2V2ZW50XG5lbmRcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBUeXBlcy5TY2hlZHVsZXJcblxubGV0IGV2ZW50cyB0ID0gdC50aW1lX3NvdXJjZS5ldmVudHNcblxubGV0IHNldF9leGVjdXRpb25fY29udGV4dCB0IGV4ZWN1dGlvbl9jb250ZXh0ID1cbiAgKCogQXZvaWQgYSBjYW1sX21vZGlmeSBpbiBtb3N0IGNhc2VzLiAqKVxuICBpZiBub3QgKHBoeXNfZXF1YWwgdC5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IGV4ZWN1dGlvbl9jb250ZXh0KVxuICB0aGVuIHQuY3VycmVudF9leGVjdXRpb25fY29udGV4dCA8LSBleGVjdXRpb25fY29udGV4dFxuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIFNjaGVkdWxlciA9IFNjaGVkdWxlcjBcblxubGV0IGR1bW15X2UgPSBFeGVjdXRpb25fY29udGV4dC5tYWluXG5sZXQgZHVtbXlfZiA6IE9iai50IC0+IHVuaXQgPSBpZ25vcmVcbmxldCBkdW1teV9hIDogT2JqLnQgPSBPYmoucmVwciAoKVxubGV0IHNsb3RzX3Blcl9lbHQgPSAzXG5cbm1vZHVsZSBBID0gVW5pZm9ybV9hcnJheVxuXG4oKiBUaGlzIGlzIGVzc2VudGlhbGx5IGEgc3BlY2lhbGl6ZWQgW0ZsYXRfcXVldWVdLCBkb25lIGZvciByZWFzb25zIG9mIHNwZWVkLiAqKVxudHlwZSB0ID0gVHlwZXMuSm9iX3F1ZXVlLnQgPVxuICB7IG11dGFibGUgbnVtX2pvYnNfcnVuIDogaW50XG4gIDsgbXV0YWJsZSBqb2JzX2xlZnRfdGhpc19jeWNsZSA6IGludFxuICA7ICgqIFtqb2JzXSBpcyBhbiBhcnJheSBvZiBsZW5ndGggW2NhcGFjaXR5IHQgKiBzbG90c19wZXJfZWx0XSwgd2hlcmUgZWFjaCBlbHQgaGFzIHRoZVxuICAgICAgIHRocmVlIGNvbXBvbmVudHMgb2YgYSBqb2IgKFtleGVjdXRpb25fY29udGV4dF0sIFtmXSwgW2FdKSBpbiBjb25zZWN1dGl2ZSBzcG90cyBpblxuICAgICAgIFtqb2JzXS4gIFtlbnF1ZXVlXSBkb3VibGVzIHRoZSBsZW5ndGggb2YgW2pvYnNdIGlmIFtqb2JzXSBpcyBmdWxsLiAgW2pvYnNdIG5ldmVyXG4gICAgICAgc2hyaW5rcy4gIFtqb2JzXSBpcyBzb21ld2hhdCBsaWtlIGEgW0NvcmUuUG9vbF0gc3BlY2lhbGl6ZWQgdG8gMy10dXBsZXM7IHdlXG4gICAgICAgZG9uJ3QgdXNlIFtQb29sXSBiZWNhdXNlIHRoYXQgaW1wbGVtZW50cyBhIHNldCwgd2hlcmUgW2pvYnNdIGlzIGEgcXVldWUuICopXG4gICAgbXV0YWJsZSBqb2JzIDogKE9iai50IEEudFtAc2V4cC5vcGFxdWVdKVxuICA7ICgqIFttYXNrXSBpcyBbY2FwYWNpdHkgdCAtIDFdLCBhbmQgaXMgdXNlZCBmb3IgcXVpY2tseSBjb21wdXRpbmcgW2kgbW9kIChjYXBhY2l0eVxuICAgICAgIHQpXSAqKVxuICAgIG11dGFibGUgbWFzayA6IGludFxuICA7ICgqIFtmcm9udF0gaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBqb2IgaW4gdGhlIHF1ZXVlLiAgVGhlIGFycmF5IGluZGV4IG9mIHRoYXQgam9iJ3NcbiAgICAgICBleGVjdXRpb24gY29udGV4dCBpcyBbZnJvbnQgKiBzbG90c19wZXJfZWx0XS4gKilcbiAgICBtdXRhYmxlIGZyb250IDogaW50XG4gIDsgbXV0YWJsZSBsZW5ndGggOiBpbnRcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG5sZXQgb2Zmc2V0IHQgaSA9ICh0LmZyb250ICsgaSkgbGFuZCB0Lm1hc2sgKiBzbG90c19wZXJfZWx0XG5sZXQgY2FwYWNpdHkgdCA9IHQubWFzayArIDFcblxubGV0IGludmFyaWFudCB0IDogdW5pdCA9XG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+bnVtX2pvYnNfcnVuOihjaGVjayAoZnVuIG51bV9qb2JzX3J1biAtPiBhc3NlcnQgKG51bV9qb2JzX3J1biA+PSAwKSkpXG4gICAgICB+am9ic19sZWZ0X3RoaXNfY3ljbGU6XG4gICAgICAgIChjaGVjayAoZnVuIGpvYnNfbGVmdF90aGlzX2N5Y2xlIC0+IGFzc2VydCAoam9ic19sZWZ0X3RoaXNfY3ljbGUgPj0gMCkpKVxuICAgICAgfmpvYnM6XG4gICAgICAgIChjaGVjayAoZnVuIGpvYnMgLT5cbiAgICAgICAgICAgZm9yIGkgPSAwIHRvIHQubGVuZ3RoIC0gMSBkb1xuICAgICAgICAgICAgIEV4ZWN1dGlvbl9jb250ZXh0LmludmFyaWFudFxuICAgICAgICAgICAgICAgKE9iai5vYmogKEEuZ2V0IGpvYnMgKG9mZnNldCB0IGkpKSA6IEV4ZWN1dGlvbl9jb250ZXh0LnQpXG4gICAgICAgICAgIGRvbmUpKVxuICAgICAgfm1hc2s6XG4gICAgICAgIChjaGVjayAoZnVuIG1hc2sgLT5cbiAgICAgICAgICAgbGV0IGNhcGFjaXR5ID0gbWFzayArIDEgaW5cbiAgICAgICAgICAgYXNzZXJ0IChJbnQuaXNfcG93MiBjYXBhY2l0eSk7XG4gICAgICAgICAgIGFzc2VydCAoY2FwYWNpdHkgKiBzbG90c19wZXJfZWx0ID0gQS5sZW5ndGggdC5qb2JzKSkpXG4gICAgICB+ZnJvbnQ6XG4gICAgICAgIChjaGVjayAoZnVuIGZyb250IC0+XG4gICAgICAgICAgIGFzc2VydCAoZnJvbnQgPj0gMCk7XG4gICAgICAgICAgIGFzc2VydCAoZnJvbnQgPCBjYXBhY2l0eSB0KSkpXG4gICAgICB+bGVuZ3RoOlxuICAgICAgICAoY2hlY2sgKGZ1biBsZW5ndGggLT5cbiAgICAgICAgICAgYXNzZXJ0IChsZW5ndGggPj0gMCk7XG4gICAgICAgICAgIGFzc2VydCAobGVuZ3RoIDw9IGNhcGFjaXR5IHQpKSkpXG47O1xuXG5sZXQgY3JlYXRlX2FycmF5IH5jYXBhY2l0eSA9IEEuY3JlYXRlX29ial9hcnJheSB+bGVuOihjYXBhY2l0eSAqIHNsb3RzX3Blcl9lbHQpXG5cbmxldCBjcmVhdGUgKCkgPVxuICBsZXQgY2FwYWNpdHkgPSAxIGluXG4gIHsgbnVtX2pvYnNfcnVuID0gMFxuICA7IGpvYnNfbGVmdF90aGlzX2N5Y2xlID0gMFxuICA7IGpvYnMgPSBjcmVhdGVfYXJyYXkgfmNhcGFjaXR5XG4gIDsgbWFzayA9IGNhcGFjaXR5IC0gMVxuICA7IGZyb250ID0gMFxuICA7IGxlbmd0aCA9IDBcbiAgfVxuOztcblxubGV0IGNsZWFyIHQgPVxuICB0LmZyb250IDwtIDA7XG4gIHQubGVuZ3RoIDwtIDA7XG4gIHQuam9ic19sZWZ0X3RoaXNfY3ljbGUgPC0gMFxuOztcblxubGV0IGdyb3cgdCA9XG4gIGxldCBvbGRfY2FwYWNpdHkgPSBjYXBhY2l0eSB0IGluXG4gIGxldCBuZXdfY2FwYWNpdHkgPSBvbGRfY2FwYWNpdHkgKiAyIGluXG4gIGxldCBvbGRfam9icyA9IHQuam9icyBpblxuICBsZXQgb2xkX2Zyb250ID0gdC5mcm9udCBpblxuICBsZXQgbGVuMSA9IEludC5taW4gdC5sZW5ndGggKG9sZF9jYXBhY2l0eSAtIG9sZF9mcm9udCkgKiBzbG90c19wZXJfZWx0IGluXG4gIGxldCBsZW4yID0gKHQubGVuZ3RoICogc2xvdHNfcGVyX2VsdCkgLSBsZW4xIGluXG4gIGxldCBuZXdfam9icyA9IGNyZWF0ZV9hcnJheSB+Y2FwYWNpdHk6bmV3X2NhcGFjaXR5IGluXG4gIEEuYmxpdFxuICAgIH5sZW46bGVuMVxuICAgIH5zcmM6b2xkX2pvYnNcbiAgICB+c3JjX3Bvczoob2xkX2Zyb250ICogc2xvdHNfcGVyX2VsdClcbiAgICB+ZHN0Om5ld19qb2JzXG4gICAgfmRzdF9wb3M6MDtcbiAgQS5ibGl0IH5sZW46bGVuMiB+c3JjOm9sZF9qb2JzIH5zcmNfcG9zOjAgfmRzdDpuZXdfam9icyB+ZHN0X3BvczpsZW4xO1xuICB0Lm1hc2sgPC0gbmV3X2NhcGFjaXR5IC0gMTtcbiAgdC5qb2JzIDwtIG5ld19qb2JzO1xuICB0LmZyb250IDwtIDBcbjs7XG5cbmxldCBzZXQgKHR5cGUgYSkgdCBpIGV4ZWN1dGlvbl9jb250ZXh0IGYgYSA9XG4gIGxldCBvZmZzZXQgPSBvZmZzZXQgdCBpIGluXG4gIEEudW5zYWZlX3NldCB0LmpvYnMgb2Zmc2V0IChPYmoucmVwciAoZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50KSk7XG4gIEEudW5zYWZlX3NldCB0LmpvYnMgKG9mZnNldCArIDEpIChPYmoucmVwciAoZiA6IGEgLT4gdW5pdCkpO1xuICBBLnVuc2FmZV9zZXQgdC5qb2JzIChvZmZzZXQgKyAyKSAoT2JqLnJlcHIgKGEgOiBhKSlcbjs7XG5cbmxldCBlbnF1ZXVlIHQgZXhlY3V0aW9uX2NvbnRleHQgZiBhID1cbiAgaWYgdC5sZW5ndGggPSBjYXBhY2l0eSB0IHRoZW4gZ3JvdyB0O1xuICBzZXQgdCB0Lmxlbmd0aCBleGVjdXRpb25fY29udGV4dCBmIGE7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMVxuOztcblxubGV0IHNldF9qb2JzX2xlZnRfdGhpc19jeWNsZSB0IG4gPVxuICBpZiBuIDwgMFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlIFwiSm9icy5zZXRfam9ic19sZWZ0X3RoaXNfY3ljbGUgZ290IG5lZ2F0aXZlIG51bWJlclwiIChuIDogaW50KSAodCA6IHQpXTtcbiAgdC5qb2JzX2xlZnRfdGhpc19jeWNsZSA8LSBuXG47O1xuXG5sZXQgY2FuX3J1bl9hX2pvYiB0ID0gdC5sZW5ndGggPiAwICYmIHQuam9ic19sZWZ0X3RoaXNfY3ljbGUgPiAwXG5cbmxldCBydW5fam9iIHQgKHNjaGVkdWxlciA6IFNjaGVkdWxlci50KSBleGVjdXRpb25fY29udGV4dCBmIGEgPVxuICB0Lm51bV9qb2JzX3J1biA8LSB0Lm51bV9qb2JzX3J1biArIDE7XG4gIFNjaGVkdWxlci5zZXRfZXhlY3V0aW9uX2NvbnRleHQgc2NoZWR1bGVyIGV4ZWN1dGlvbl9jb250ZXh0O1xuICBmIGFcbjs7XG5cbmxldCBydW5fZXh0ZXJuYWxfam9icyB0IChzY2hlZHVsZXIgOiBTY2hlZHVsZXIudCkgPVxuICBsZXQgZXh0ZXJuYWxfam9icyA9IHNjaGVkdWxlci5leHRlcm5hbF9qb2JzIGluXG4gIHdoaWxlIFRocmVhZF9zYWZlX3F1ZXVlLmxlbmd0aCBleHRlcm5hbF9qb2JzID4gMCBkb1xuICAgIGxldCAoRXh0ZXJuYWxfam9iLlQgKGV4ZWN1dGlvbl9jb250ZXh0LCBmLCBhKSkgPVxuICAgICAgVGhyZWFkX3NhZmVfcXVldWUuZGVxdWV1ZV9leG4gZXh0ZXJuYWxfam9ic1xuICAgIGluXG4gICAgcnVuX2pvYiB0IHNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBmIGFcbiAgZG9uZVxuOztcblxubGV0IHJ1bl9qb2JzICh0eXBlIGEpIHQgc2NoZWR1bGVyID1cbiAgKCogV2UgZG8gdGhlIFt0cnktd2l0aF0gb3V0c2lkZSBvZiB0aGUgW3doaWxlXSBiZWNhdXNlIGl0IGlzIGNoZWFwZXIgdGhhbiBkb2luZyBhXG4gICAgIFt0cnktd2l0aF0gZm9yIGVhY2ggam9iLiAqKVxuICAoKiBbcnVuX2V4dGVybmFsX2pvYnNdIGJlZm9yZSBlbnRlcmluZyB0aGUgbG9vcCwgc2luY2UgaXQgbWlnaHQgZW5xdWV1ZSBhIGpvYixcbiAgICAgY2hhbmdpbmcgW3QubGVuZ3RoXS4gKilcbiAgdHJ5XG4gICAgcnVuX2V4dGVybmFsX2pvYnMgdCBzY2hlZHVsZXI7XG4gICAgd2hpbGUgY2FuX3J1bl9hX2pvYiB0IGRvXG4gICAgICBsZXQgdGhpc19qb2IgPSBvZmZzZXQgdCAwIGluXG4gICAgICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50ID1cbiAgICAgICAgT2JqLm9iaiAoQS51bnNhZmVfZ2V0IHQuam9icyB0aGlzX2pvYilcbiAgICAgIGluXG4gICAgICBsZXQgZiA6IGEgLT4gdW5pdCA9IE9iai5vYmogKEEudW5zYWZlX2dldCB0LmpvYnMgKHRoaXNfam9iICsgMSkpIGluXG4gICAgICBsZXQgYSA6IGEgPSBPYmoub2JqIChBLnVuc2FmZV9nZXQgdC5qb2JzICh0aGlzX2pvYiArIDIpKSBpblxuICAgICAgKCogV2UgY2xlYXIgb3V0IHRoZSBqb2IgcmlnaHQgbm93IHNvIHRoYXQgaXQgaXNuJ3QgbGl2ZSBhdCB0aGUgbmV4dCBtaW5vclxuICAgICAgICAgY29sbGVjdGlvbi4gIFdlIHRyaWVkIG5vdCBkb2luZyB0aGlzIGFuZCBzYXcgc2lnbmlmaWNhbnQgKDE1JSBvciBzbykgcGVyZm9ybWFuY2VcbiAgICAgICAgIGhpdHMgZHVlIHRvIHNwdXJpb3VzIHByb21vdGlvbi4gKilcbiAgICAgIHNldCB0IDAgZHVtbXlfZSBkdW1teV9mIGR1bW15X2E7XG4gICAgICB0LmZyb250IDwtICh0LmZyb250ICsgMSkgbGFuZCB0Lm1hc2s7XG4gICAgICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCAtIDE7XG4gICAgICB0LmpvYnNfbGVmdF90aGlzX2N5Y2xlIDwtIHQuam9ic19sZWZ0X3RoaXNfY3ljbGUgLSAxO1xuICAgICAgKCogSXQgaXMgT0sgaWYgW3J1bl9qb2JdIG9yIFtydW5fZXh0ZXJuYWxfam9ic10gcmFpc2VzLCBpbiB3aGljaCBjYXNlIHRoZSBleG4gaXNcbiAgICAgICAgIGhhbmRsZWQgYnkgdGhlIG91dGVyIHRyeS13aXRoLiAgVGhlIG9ubHkgc2lkZSBlZmZlY3RzIHdlIGhhdmUgZG9uZSBhcmUgdG8gdGFrZVxuICAgICAgICAgdGhlIGpvYiBvdXQgb2YgdGhlIHF1ZXVlIGFuZCBkZWNyZW1lbnQgW2pvYnNfbGVmdF90aGlzX2N5Y2xlXS4gIFtydW5fam9iXSBvclxuICAgICAgICAgW3J1bl9leHRlcm5hbF9qb2JzXSBtYXkgc2lkZSBlZmZlY3QgW3RdLCBlaXRoZXIgYnkgZW5xdWV1ZWluZyBqb2JzLCBvciBieVxuICAgICAgICAgY2xlYXJpbmcgW3RdLiAqKVxuICAgICAgcnVuX2pvYiB0IHNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBmIGE7XG4gICAgICAoKiBbcnVuX2V4dGVybmFsX2pvYnNdIGF0IGVhY2ggaXRlcmF0aW9uIG9mIHRoZSBbd2hpbGVdIGxvb3AsIGZvciBmYWlybmVzcy4gKilcbiAgICAgIHJ1bl9leHRlcm5hbF9qb2JzIHQgc2NoZWR1bGVyXG4gICAgZG9uZTtcbiAgICBPayAoKVxuICB3aXRoXG4gIHwgZXhuIC0+XG4gICAgKCogV2UgY2FsbCBbRXhuLmJhY2t0cmFjZV0gaW1tZWRpYXRlbHkgYWZ0ZXIgY2F0Y2hpbmcgYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbiwgdG9cbiAgICAgICBlbnN1cmUgdGhlcmUgaXMgbm8gaW50ZXJ2ZW5pbmcgY29kZSB0aGF0IGludGVyZmVyZXMgd2l0aCB0aGUgZ2xvYmFsIGJhY2t0cmFjZVxuICAgICAgIHN0YXRlLiAqKVxuICAgIGxldCBiYWNrdHJhY2UgPSBCYWNrdHJhY2UuRXhuLm1vc3RfcmVjZW50ICgpIGluXG4gICAgRXJyb3IgKGV4biwgYmFja3RyYWNlKVxuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVGltZV9ucyA9IHN0cnVjdFxuICBpbmNsdWRlIFRpbWVfbnNcblxuICBleHRlcm5hbCBmb3JtYXQgOiBmbG9hdCAtPiBzdHJpbmcgLT4gc3RyaW5nID0gXCJjb3JlX3RpbWVfbnNfZm9ybWF0XCJcblxuICAoKiBXZSB1c2UgYSBtb3JlIHBsZWFzYW50IGZvcm1hdCB0aGFuIFtDb3JlLlRpbWVfbnMuc2V4cF9vZl90XSxcbiAgICAgd2hpY2ggaGFzIHRvIGJlIG1lc3NpZXIgZm9yIHJvdW5kIHRyaXBwYWJpbGl0eS4gKilcbiAgbGV0IHNleHBfb2ZfdCB0ID1cbiAgICBbJXNleHBcbiAgICAgIChmb3JtYXQgKHQgfD4gdG9fc3Bhbl9zaW5jZV9lcG9jaCB8PiBTcGFuLnRvX3NlYykgXCIlWS0lbS0lZFQlSDolTTolUyV6XCIgOiBzdHJpbmcpXVxuICA7O1xuZW5kXG5cbm1vZHVsZSBBbGFybSA9IHN0cnVjdFxuICBpbmNsdWRlIFRpbWluZ193aGVlbC5BbGFybVxuXG4gIGxldCBpc19udWxsIHQgPSBwaHlzX2VxdWFsIHQgKG51bGwgKCkpXG5lbmRcblxubW9kdWxlIEFsYXJtX3ByZWNpc2lvbiA9IFRpbWluZ193aGVlbC5BbGFybV9wcmVjaXNpb25cblxubGV0IGRlZmF1bHRfdGltaW5nX3doZWVsX2NvbmZpZyA9XG4gICgqIDEvOHRoIG9mIGEgbWlsbGlzZWNvbmQgYWxhcm1fcHJlY2lzaW9uIHNlZW1zIHN1ZmZpY2llbnQgdG8gYXZvaWQgaGF2aW5nIG1hbnkgYWxhcm1zXG4gICAgIGluIHRoZSBzYW1lIGludGVydmFsLCB3aGljaCBhdm9pZHMgcXVhZHJhdGljIGluc2VydGlvbiBzb3J0IHdoZW4gZmlyaW5nIGFsYXJtcy4gIEFuZFxuICAgICB0aGUgbGV2ZWwgYml0cyBnaXZlIHVzIGxldmVscyBvZiA+MXMsID4xbSwgPjFoLCA+MWQuICBTZWUgdGVzdCBpblxuICAgICBbLi4vdGVzdC90ZXN0X3N5bmNocm9ub3VzX3RpbWVfc291cmNlLm1sXS4gKilcbiAgVGltaW5nX3doZWVsLkNvbmZpZy5jcmVhdGVcbiAgICB+YWxhcm1fcHJlY2lzaW9uOkFsYXJtX3ByZWNpc2lvbi4oZGl2IGFib3V0X29uZV9taWxsaXNlY29uZCB+cG93MjozKVxuICAgIH5sZXZlbF9iaXRzOihUaW1pbmdfd2hlZWwuTGV2ZWxfYml0cy5jcmVhdGVfZXhuIFsgMTM7IDY7IDY7IDUgXSlcbiAgICAoKVxuOztcblxudHlwZSBjYWxsYmFjayA9IHVuaXQgLT4gdW5pdFxuXG5tb2R1bGUgSWQgPSBUeXBlcy5UaW1lX3NvdXJjZV9pZFxuXG5tb2R1bGUgVDEgPSBzdHJ1Y3RcbiAgbW9kdWxlIEV2ZW50ID0gc3RydWN0XG4gICAgbW9kdWxlIFN0YXR1cyA9IHN0cnVjdFxuICAgICAgdHlwZSB0ID0gVHlwZXMuRXZlbnQuU3RhdHVzLnQgPVxuICAgICAgICB8IEZpcmVkICgqIGluIFtmaXJlZF9ldmVudHNdLCByZWFkeSB0byBydW4gKilcbiAgICAgICAgfCBIYXBwZW5pbmcgKCogY3VycmVudGx5IHJ1bm5pbmcgdGhlIGNhbGxiYWNrICopXG4gICAgICAgIHwgU2NoZWR1bGVkICgqIGluIHRoZSB0aW1pbmcgd2hlZWwgKilcbiAgICAgICAgfCBVbnNjaGVkdWxlZCAoKiBub3QgaW4gdGltaW5nIHdoZWVsIG9yIFtmaXJlZF9ldmVudHNdICopXG4gICAgICBbQEBkZXJpdmluZyBjb21wYXJlLCBlcXVhbCwgc2V4cF9vZl1cblxuICAgICAgbGV0IHRyYW5zaXRpb25faXNfYWxsb3dlZCB+ZnJvbSB+dG9fID1cbiAgICAgICAgbWF0Y2ggZnJvbSwgdG9fIHdpdGhcbiAgICAgICAgfCBGaXJlZCwgSGFwcGVuaW5nICgqIHN0YXJ0ZWQgcnVubmluZyBjYWxsYmFjayAqKVxuICAgICAgICB8IEZpcmVkLCBVbnNjaGVkdWxlZCAoKiBhYm9ydGVkICopXG4gICAgICAgICgqIFtyZXNjaGVkdWxlXypdIGdvZXMgdGhyb3VnaCBhbiBpbnRlcm1lZGlhdGUgW0ZpcmVkLCBVbnNjaGVkdWxlZF0gc3RhdGUsXG4gICAgICAgICAgIHNvIHdlIG5ldmVyIHRyYW5zaXRpb24gZnJvbSBbRmlyZWRdIGRpcmVjdGx5IHRvIFtTY2hlZHVsZWRdLiAqKVxuICAgICAgICB8IEhhcHBlbmluZywgU2NoZWR1bGVkICgqIGZvciByZXBlYXRpbmcgZXZlbnRzICopXG4gICAgICAgIHwgSGFwcGVuaW5nLCBVbnNjaGVkdWxlZCAoKiBldmVudCBjYWxsYmFjayBmaW5pc2hlZCAqKVxuICAgICAgICB8IFNjaGVkdWxlZCwgRmlyZWQgKCogbW92ZWQgZnJvbSB0aW1pbmcgd2hlZWwgdG8gW2ZpcmVkX2V2ZW50c10gKilcbiAgICAgICAgfCBTY2hlZHVsZWQsIFVuc2NoZWR1bGVkICgqIGFib3J0ZWQgKilcbiAgICAgICAgfCBVbnNjaGVkdWxlZCwgRmlyZWQgKCogZXZlbnQgc2NoZWR1bGVkIGluIHRoZSBwYXN0ICopXG4gICAgICAgIHwgVW5zY2hlZHVsZWQsIFNjaGVkdWxlZCAoKiBldmVudCBzY2hlZHVsZWQgaW4gdGhlIGZ1dHVyZSAqKSAtPiB0cnVlXG4gICAgICAgIHwgKEZpcmVkIHwgSGFwcGVuaW5nIHwgU2NoZWR1bGVkIHwgVW5zY2hlZHVsZWQpLCBfIC0+IGZhbHNlXG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgdHlwZSBldmVudCA9IFR5cGVzLkV2ZW50LnRcblxuICAgIGxldCBzZXhwX29mX2V2ZW50XG4gICAgICAgICAgKHsgYWxhcm0gPSBfXG4gICAgICAgICAgIDsgYXRcbiAgICAgICAgICAgOyBjYWxsYmFjayA9IF9cbiAgICAgICAgICAgOyBleGVjdXRpb25fY29udGV4dCA9IF9cbiAgICAgICAgICAgOyBpbnRlcnZhbFxuICAgICAgICAgICA7IG5leHRfZmlyZWQgPSBfXG4gICAgICAgICAgIDsgcHJldl9maXJlZCA9IF9cbiAgICAgICAgICAgOyBzdGF0dXNcbiAgICAgICAgICAgfSA6XG4gICAgICAgICAgICAgZXZlbnQpXG4gICAgICA9XG4gICAgICBbJXNleHBcbiAgICAgICAgeyBzdGF0dXMgOiBTdGF0dXMudFxuICAgICAgICA7IGF0IDogVGltZV9ucy50XG4gICAgICAgIDsgaW50ZXJ2YWwgOiAoVGltZV9ucy5TcGFuLnQgb3B0aW9uW0BzZXhwLm9wdGlvbl0pXG4gICAgICAgIH1dXG4gICAgOztcblxuICAgIG1vZHVsZSBPcHRpb24gPSBzdHJ1Y3RcbiAgICAgICgqIFRoaXMgcmVkZWZpbml0aW9uIG9mIFtFdmVudF0gaXMgaGVyZSBzbyB0aGUgdHlwZSBjaGVja3MgYXJlIHJpZ2h0IG5leHRcbiAgICAgICAgIHRvIFtPYmoubWFnaWNdcy4gKilcbiAgICAgIG1vZHVsZSBFdmVudF9pc19ibG9jayA6IHNpZyBlbmQgPSBzdHJ1Y3RcbiAgICAgICAgb3BlbiBUeXBlc1xuICAgICAgICBvcGVuIEV2ZW50XG5cbiAgICAgICAgdHlwZSBfdCA9IHQgPVxuICAgICAgICAgIHsgKCogbXVzdCBuZXZlciBiZSBpbW1lZGlhdGUgKilcbiAgICAgICAgICAgIG11dGFibGUgYWxhcm0gOiBKb2Jfb3JfZXZlbnQudCBUaW1pbmdfd2hlZWwuQWxhcm0udFxuICAgICAgICAgIDsgbXV0YWJsZSBhdCA6IFRpbWVfbnMudFxuICAgICAgICAgIDsgY2FsbGJhY2sgOiB1bml0IC0+IHVuaXRcbiAgICAgICAgICA7IGV4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudFxuICAgICAgICAgIDsgbXV0YWJsZSBpbnRlcnZhbCA6IFRpbWVfbnMuU3Bhbi50IG9wdGlvblxuICAgICAgICAgIDsgbXV0YWJsZSBuZXh0X2ZpcmVkIDogT3B0aW9uLnRcbiAgICAgICAgICA7IG11dGFibGUgcHJldl9maXJlZCA6IE9wdGlvbi50XG4gICAgICAgICAgOyBtdXRhYmxlIHN0YXR1cyA6IFN0YXR1cy50XG4gICAgICAgICAgfVxuICAgICAgZW5kXG5cbiAgICAgIHR5cGUgdCA9IFR5cGVzLkV2ZW50Lk9wdGlvbi50XG5cbiAgICAgICgqIFVzaW5nIGFuIGltbWVkaWF0ZSByYXRoZXIgdGhhbiBhIHN0YXRpY2FsbHktYWxsb2NhdGVkIHJlY29yZCBoZXJlIHNlZW1zIHRvXG4gICAgICAgICBpbXByb3ZlIHBlcmZvcm1hbmNlIG5vdGljZWFibHkgKFsuLi9iZW5jaC9iaW4vYmVuY2hfdGltZV9zb3VyY2UuZXhlXSBiZW5jaG1hcmtcbiAgICAgICAgIGlzIGZhc3RlciBieSB+MTBucyBwZXIgYWxhcm0pLCBwcmVzdW1hYmx5IGJlY2F1c2UgaXQgYXZvaWRzIHRoZSBleHBlbnNpdmVcbiAgICAgICAgIHBhcnRzIG9mIGNhbWxfbW9kaWZ5LiAqKVxuICAgICAgbGV0IG5vbmUgPSAoT2JqLm1hZ2ljIE5vbmUgOiB0KSAoKiBhbiBhcmJpdHJhcnkgaW1tZWRpYXRlICopXG5cbiAgICAgIGxldCBzb21lID0gKE9iai5tYWdpYyA6IFR5cGVzLkV2ZW50LnQgLT4gdClcbiAgICAgIGxldCBpc19ub25lIHQgPSBwaHlzX2VxdWFsIHQgbm9uZVxuICAgICAgbGV0IGlzX3NvbWUgdCA9IG5vdCAoaXNfbm9uZSB0KVxuICAgICAgbGV0IGZpcnN0X3NvbWUgdDEgdDIgPSBpZiBpc19zb21lIHQxIHRoZW4gdDEgZWxzZSB0MlxuXG4gICAgICBtb2R1bGUgT3B0aW9uYWxfc3ludGF4ID0gc3RydWN0XG4gICAgICAgIG1vZHVsZSBPcHRpb25hbF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgICAgICBsZXQgaXNfbm9uZSA9IGlzX25vbmVcbiAgICAgICAgICBsZXQgdW5zYWZlX3ZhbHVlID0gKE9iai5tYWdpYyA6IHQgLT4gVHlwZXMuRXZlbnQudClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgb3BlbiBPcHRpb25hbF9zeW50YXhcblxuICAgICAgbGV0IHNleHBfb2ZfdCB0ID1cbiAgICAgICAgbWF0Y2glb3B0aW9uYWwgdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBbJXNleHAgKCldXG4gICAgICAgIHwgU29tZSBldmVudCAtPiBbJXNleHAgKGV2ZW50IDogZXZlbnQpXVxuICAgICAgOztcblxuICAgICAgbGV0IHZhbHVlIHQgfmRlZmF1bHQgPVxuICAgICAgICBtYXRjaCVvcHRpb25hbCB0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGRlZmF1bHRcbiAgICAgICAgfCBTb21lIGV2ZW50IC0+IGV2ZW50XG4gICAgICA7O1xuXG4gICAgICBsZXQgdmFsdWVfZXhuIHQgPVxuICAgICAgICBtYXRjaCVvcHRpb25hbCB0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHJhaXNlX3MgWyVzZXhwIFwiW1N5bmNocm9ub3VzX3RpbWVfc291cmNlLkV2ZW50Lk9wdGlvbi52YWx1ZV9leG4gTm9uZV1cIl1cbiAgICAgICAgfCBTb21lIGV2ZW50IC0+IGV2ZW50XG4gICAgICA7O1xuXG4gICAgICBsZXQgdG9fb3B0aW9uIHQgPVxuICAgICAgICBtYXRjaCVvcHRpb25hbCB0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIGV2ZW50IC0+IFNvbWUgZXZlbnRcbiAgICAgIDs7XG5cbiAgICAgIGxldCBvZl9vcHRpb24gPSBmdW5jdGlvblxuICAgICAgICB8IE5vbmUgLT4gbm9uZVxuICAgICAgICB8IFNvbWUgZXZlbnQgLT4gc29tZSBldmVudFxuICAgICAgOztcbiAgICBlbmRcblxuICAgIHR5cGUgdCA9IFR5cGVzLkV2ZW50LnQgPVxuICAgICAgeyAoKiBbYWxhcm1dIGlzIG5vbi1udWxsIGlmZiB0aGUgZXZlbnQgaXMgaW4gdGhlIHRpbWluZyB3aGVlbC4gKilcbiAgICAgICAgbXV0YWJsZSBhbGFybSA6IEpvYl9vcl9ldmVudC50IEFsYXJtLnRcbiAgICAgIDsgbXV0YWJsZSBhdCA6IFRpbWVfbnMudFxuICAgICAgOyBjYWxsYmFjayA6IHVuaXQgLT4gdW5pdFxuICAgICAgOyBleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICAgIDsgKCogW2ludGVydmFsXSBpcyB0aGUgcGVyaW9kIGZvciB0aGUgcGVyaW9kaWMgZXZlbnRzLiAqKVxuICAgICAgICBtdXRhYmxlIGludGVydmFsIDogVGltZV9ucy5TcGFuLnQgb3B0aW9uXG4gICAgICA7ICgqIFtuZXh0X2ZpcmVkXSBhbmQgW3ByZXZfZmlyZWRdIGNyZWF0ZSBhIGRvdWJseS1saW5rZWQgKG5vbi1jaXJjdWxhcikgbGlzdCBvZlxuICAgICAgICAgICBmaXJlZCBldmVudHMsIGxpbmtlZCB2aWEgdGhlc2UgZmllbGRzLiBBbiBldmVudCBpcyBhZGRlZCB0byB0aGUgbGlzdCB3aGVuXG4gICAgICAgICAgIGl0IGZpcmVzLCBlaXRoZXIgYmVjYXVzZSBpdCBpcyBhZGRlZCB3aXRoIGEgdGltZSBpbiB0aGUgcGFzdCwgb3JcbiAgICAgICAgICAgYmVjYXVzZSB0aW1lIGFkdmFuY2VzLiBbYWR2YW5jZV9ieV9hbGFybXNdIGl0ZXJhdGVzIG92ZXIgdGhlIGV2ZW50c1xuICAgICAgICAgICBpbiBbbmV4dF9maXJlZF0gYW5kIHJ1bnMgdGhlbSwgZW1wdHlpbmcgdGhlIGxpc3QuIFtub25lXSBpcyB1c2VkIHRvXG4gICAgICAgICAgIGluZGljYXRlIHRoZSBlbmQgb2YgdGhlIGxpbmtlZCBsaXN0IG9mIGZpcmVkIGV2ZW50cy4gKilcbiAgICAgICAgbXV0YWJsZSBuZXh0X2ZpcmVkIDogT3B0aW9uLnRcbiAgICAgIDsgbXV0YWJsZSBwcmV2X2ZpcmVkIDogT3B0aW9uLnRcbiAgICAgIDsgbXV0YWJsZSBzdGF0dXMgOiBTdGF0dXMudFxuICAgICAgfVxuICAgIFtAQGRlcml2aW5nIGZpZWxkc11cblxuICAgIGxldCBzZXhwX29mX3QgPSBbJXNleHBfb2Y6IGV2ZW50XVxuXG4gICAgbGV0IGludmFyaWFudCB0ID1cbiAgICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgICAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICAgICAgRmllbGRzLml0ZXJcbiAgICAgICAgICB+YWxhcm06XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBhbGFybSAtPlxuICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogYm9vbF1cbiAgICAgICAgICAgICAgICAgKEFsYXJtLmlzX251bGwgYWxhcm0pXG4gICAgICAgICAgICAgICAgIH5leHBlY3Q6XG4gICAgICAgICAgICAgICAgICAgKG1hdGNoIHQuc3RhdHVzIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgfCBGaXJlZCB8IEhhcHBlbmluZyB8IFVuc2NoZWR1bGVkIC0+IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfCBTY2hlZHVsZWQgLT4gZmFsc2UpKSlcbiAgICAgICAgICB+YXQ6aWdub3JlXG4gICAgICAgICAgfmNhbGxiYWNrOmlnbm9yZVxuICAgICAgICAgIH5leGVjdXRpb25fY29udGV4dDppZ25vcmVcbiAgICAgICAgICB+aW50ZXJ2YWw6aWdub3JlXG4gICAgICAgICAgfm5leHRfZmlyZWQ6XG4gICAgICAgICAgICAoY2hlY2sgKGZ1biBuZXh0X2ZpcmVkIC0+XG4gICAgICAgICAgICAgICBtYXRjaCVvcHRpb25hbCAobmV4dF9maXJlZCA6IE9wdGlvbi50KSB3aXRoXG4gICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgKCogW25leHRfZmlyZWRdIGNhbiBiZSBbTm9uZV0gZXZlbiBpZiB0aGUgZXZlbnQgc3RhdHVzIGlzIEZpcmVkLCBhc3N1bWluZ1xuICAgICAgICAgICAgICAgICAgICBpdCdzIGF0IHRoZSBlbmQgb2YgdGhlIGZpcmVkIGV2ZW50cyBsaXN0ICopXG4gICAgICAgICAgICAgICAgICgpXG4gICAgICAgICAgICAgICB8IFNvbWUgbmV4dF9maXJlZCAtPlxuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBTdGF0dXMudF0gdC5zdGF0dXMgfmV4cGVjdDpGaXJlZDtcbiAgICAgICAgICAgICAgICAgYXNzZXJ0IChwaHlzX2VxdWFsIChPcHRpb24uc29tZSB0KSBuZXh0X2ZpcmVkLnByZXZfZmlyZWQpKSlcbiAgICAgICAgICB+cHJldl9maXJlZDpcbiAgICAgICAgICAgIChjaGVjayAoZnVuIHByZXZfZmlyZWQgLT5cbiAgICAgICAgICAgICAgIG1hdGNoJW9wdGlvbmFsIChwcmV2X2ZpcmVkIDogT3B0aW9uLnQpIHdpdGhcbiAgICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAoKiBbcHJldl9maXJlZF0gY2FuIGJlIFtOb25lXSBldmVuIGlmIHRoZSBldmVudCBzdGF0dXMgaXMgRmlyZWQsIGFzc3VtaW5nXG4gICAgICAgICAgICAgICAgICAgIGl0J3MgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlyZWQgZXZlbnRzIGxpc3QgKilcbiAgICAgICAgICAgICAgICAgKClcbiAgICAgICAgICAgICAgIHwgU29tZSBwcmV2X2ZpcmVkIC0+XG4gICAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IFN0YXR1cy50XSB0LnN0YXR1cyB+ZXhwZWN0OkZpcmVkO1xuICAgICAgICAgICAgICAgICBhc3NlcnQgKHBoeXNfZXF1YWwgKE9wdGlvbi5zb21lIHQpIHByZXZfZmlyZWQubmV4dF9maXJlZCkpKVxuICAgICAgICAgIH5zdGF0dXM6aWdub3JlKVxuICAgIDs7XG5cbiAgICBsZXQgc2V0X3N0YXR1cyB0IHRvXyA9XG4gICAgICBsZXQgZnJvbSA9IHQuc3RhdHVzIGluXG4gICAgICBpZiBub3QgKFN0YXR1cy50cmFuc2l0aW9uX2lzX2FsbG93ZWQgfmZyb20gfnRvXylcbiAgICAgIHRoZW5cbiAgICAgICAgcmFpc2Vfc1xuICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgWyVoZXJlXVxuICAgICAgICAgICAgICBcImJ1ZyAtLSBzZXRfc3RhdHVzIHRyYW5zaXRpb24gbm90IGFsbG93ZWRcIlxuICAgICAgICAgICAgICAoZnJvbSA6IFN0YXR1cy50KVxuICAgICAgICAgICAgICAodG9fIDogU3RhdHVzLnQpXG4gICAgICAgICAgICAgIH5ldmVudDoodCA6IHQpXTtcbiAgICAgIHQuc3RhdHVzIDwtIHRvX1xuICAgIDs7XG5cbiAgICBsZXQgc2V0X3N0YXR1c19pZiB+aXMgdCB0b18gPSBpZiBTdGF0dXMuZXF1YWwgaXMgdC5zdGF0dXMgdGhlbiBzZXRfc3RhdHVzIHQgdG9fXG4gICAgbGV0IHNjaGVkdWxlZF9hdCA9IGF0XG4gIGVuZFxuXG4gIG1vZHVsZSBKb2Jfb3JfZXZlbnQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIEpvYl9vcl9ldmVudFxuXG4gICAgbGV0IHNleHBfb2ZfdCB0ID1cbiAgICAgIGxldCBvcGVuIEpvYl9vcl9ldmVudC5NYXRjaCBpblxuICAgICAgbGV0IChLIGspID0ga2luZCB0IGluXG4gICAgICBtYXRjaCBrLCBwcm9qZWN0IGsgdCB3aXRoXG4gICAgICB8IEV2ZW50LCBldmVudCAtPiBbJXNleHAgKGV2ZW50IDogRXZlbnQudCldXG4gICAgICB8IEpvYiwgXyAtPlxuICAgICAgICAoKiBXZSBkb24ndCBkaXNwbGF5IHRoZSBbSm9iLnRdcyBpbiBbZXZlbnRzXSBiZWNhdXNlIHRob3NlIGFyZVxuICAgICAgICAgICBwb29sIHBvaW50ZXJzLCB3aGljaCBhcmUgdW5pbmZvcm1hdGl2ZS4gKilcbiAgICAgICAgWyVtZXNzYWdlIFwiPEpvYi50PlwiXVxuICAgIDs7XG4gIGVuZFxuXG4gIHR5cGUgLSdydyB0ID0gJ3J3IFR5cGVzLlRpbWVfc291cmNlLnQxID1cbiAgICB7IGlkIDogSWQudFxuICAgIDsgKCogW2FkdmFuY2VfZXJyb3JzXSBhY2N1bXVsYXRlcyBlcnJvcnMgcmFpc2VkIGJ5IGFsYXJtcyBydW4gYnlcbiAgICAgICAgIFthZHZhbmNlX2J5X2FsYXJtc10uICopXG4gICAgICBtdXRhYmxlIGFkdmFuY2VfZXJyb3JzIDogRXJyb3IudCBsaXN0XG4gICAgOyAoKiBbYW1fYWR2YW5jaW5nXSBpcyB0cnVlIG9ubHkgZHVyaW5nIFthZHZhbmNlX2J5X2FsYXJtc10sIGFuZCBpcyB1c2VkIHRvIGNhdXNlXG4gICAgICAgICBjYWxsYmFja3MgdG8gcmFpc2UgaWYgdGhleSBjYWxsIFthZHZhbmNlX2J5X2FsYXJtc10uICopXG4gICAgICBtdXRhYmxlIGFtX2FkdmFuY2luZyA6IGJvb2xcbiAgICA7IGV2ZW50cyA6IEpvYl9vcl9ldmVudC50IFRpbWluZ193aGVlbC50XG4gICAgOyAoKiBbZmlyZWRfZXZlbnRzXSBpcyB0aGUgZnJvbnQgb2YgdGhlIGRvdWJseS1saW5rZWQgbGlzdCBvZiBmaXJlZCBldmVudHMsXG4gICAgICAgICB3aGljaCBpcyBzdG9yZWQgaW4gaW5jcmVhc2luZyBvcmRlciBvZiBbRXZlbnQuYXRdLiAqKVxuICAgICAgbXV0YWJsZSBmaXJlZF9ldmVudHMgOiBFdmVudC5PcHRpb24udFxuICAgIDsgKCogW21vc3RfcmVjZW50bHlfZmlyZWRdIGlzIHRoZSBldmVudCB0aGF0IHdhcyBtb3N0IHJlY2VudGx5IGluc2VydGVkIGludG9cbiAgICAgICAgIFtmaXJlZF9ldmVudHNdLiBJdCBpcyB1c2VkIGFzIGFuIG9wdGltaXphdGlvbiB0byBhbGxvdyBpbnNlcnRpb24gb2ZcbiAgICAgICAgIHN1YnNlcXVlbnQgZXZlbnRzIHRvIHN0YXJ0IGxhdGVyIGluIHRoZSBsaXN0IHJhdGhlciB0aGFuIGF0IHRoZSBiZWdpbm5pbmcuXG4gICAgICAgICBJdCBzcGVjaWZpY2FsbHkgYXZvaWRzIHF1YWRyYXRpYyBiZWhhdmlvciB3aGVuIGluc2VydGluZyBtdWx0aXBsZSBldmVudHNcbiAgICAgICAgIHRoYXQgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIHRpbWUgLS0gdGhlIHRpbWUgc291cmNlIGZpcmVzIHN1Y2ggZXZlbnRzIGluXG4gICAgICAgICB0aGUgb3JkZXIgdGhleSB3ZXJlIGFkZGVkLCBhbmQgd2Ugd2FudCB0aGVtIHRvIGJlIGluIHRoYXQgc2FtZSBvcmRlciBpblxuICAgICAgICAgW2ZpcmVkX2V2ZW50c10uICopXG4gICAgICBtdXRhYmxlIG1vc3RfcmVjZW50bHlfZmlyZWQgOiBFdmVudC5PcHRpb24udFxuICAgIDsgKCogV2Ugc3RvcmUgW2hhbmRsZV9maXJlZF0gaW4gW3RdIHRvIGF2b2lkIGFsbG9jYXRpbmcgaXQgZXZlcnkgdGltZSB3ZSBjYWxsXG4gICAgICAgICBbYWR2YW5jZV9jbG9ja10uICopXG4gICAgICBoYW5kbGVfZmlyZWQgOiBKb2Jfb3JfZXZlbnQudCBBbGFybS50IC0+IHVuaXRcbiAgICA7IGlzX3dhbGxfY2xvY2sgOiBib29sXG4gICAgOyBzY2hlZHVsZXIgOiBTY2hlZHVsZXIwLnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkc11cblxuICAoKiBXZSBkb24ndCBpbmNsdWRlIHRoZSBbaWRdIGluIHRoZSBzZXhwIGJlY2F1c2UgdGhlIHVzZXIgKHJpZ2h0bHkpIGNhbid0IGNvbnRyb2wgaXQsIHNvXG4gICAgIGl0J3MgaGFyZCB0byBtYWtlIGl0IGRldGVybWluaXN0aWMgaW4gdGVzdHMuICopXG4gIGxldCBzZXhwX29mX3RcbiAgICAgICAgX1xuICAgICAgICB7IGlkID0gX1xuICAgICAgICA7IGFkdmFuY2VfZXJyb3JzID0gX1xuICAgICAgICA7IGFtX2FkdmFuY2luZyA9IF9cbiAgICAgICAgOyBldmVudHNcbiAgICAgICAgOyBmaXJlZF9ldmVudHMgPSBfXG4gICAgICAgIDsgaGFuZGxlX2ZpcmVkID0gX1xuICAgICAgICA7IGlzX3dhbGxfY2xvY2tcbiAgICAgICAgOyBtb3N0X3JlY2VudGx5X2ZpcmVkID0gX1xuICAgICAgICA7IHNjaGVkdWxlciA9IF9cbiAgICAgICAgfVxuICAgID1cbiAgICBsZXQgbm93ID0gVGltaW5nX3doZWVsLm5vdyBldmVudHMgaW5cbiAgICBpZiBpc193YWxsX2Nsb2NrXG4gICAgdGhlbiBbJW1lc3NhZ2UgXCJ3YWxsX2Nsb2NrXCIgKG5vdyA6IFRpbWVfbnMudCldXG4gICAgZWxzZSAoXG4gICAgICBsZXQgYWxsX2V2ZW50cyA9IHJlZiBbXSBpblxuICAgICAgVGltaW5nX3doZWVsLml0ZXIgZXZlbnRzIH5mOihmdW4gYWxhcm0gLT5cbiAgICAgICAgYWxsX2V2ZW50cyA6PSAoQWxhcm0uYXQgZXZlbnRzIGFsYXJtLCBBbGFybS52YWx1ZSBldmVudHMgYWxhcm0pIDo6ICFhbGxfZXZlbnRzKTtcbiAgICAgIGxldCBldmVudHMgPVxuICAgICAgICBMaXN0LnNvcnQgIWFsbF9ldmVudHMgfmNvbXBhcmU6KGZ1biAoYXQxLCBfKSAoYXQyLCBfKSAtPiBUaW1lX25zLmNvbXBhcmUgYXQxIGF0MilcbiAgICAgICAgfD4gTGlzdC5tYXAgfmY6c25kXG4gICAgICBpblxuICAgICAgWyVtZXNzYWdlIFwiXCIgKG5vdyA6IFRpbWVfbnMudCkgKGV2ZW50cyA6IEpvYl9vcl9ldmVudC50IGxpc3QpXSlcbiAgOztcblxuICBsZXQgdGltaW5nX3doZWVsX25vdyB0ID0gVGltaW5nX3doZWVsLm5vdyB0LmV2ZW50c1xuXG4gIGxldCBpc19pbl9maXJlZF9ldmVudHMgPVxuICAgIGxldCByZWMgc2VhcmNoIGN1cnJlbnQgfnRhcmdldF9ldmVudCA9XG4gICAgICBtYXRjaCVvcHRpb25hbCAoY3VycmVudCA6IEV2ZW50Lk9wdGlvbi50KSB3aXRoXG4gICAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICAgIHwgU29tZSBjdXJyZW50IC0+XG4gICAgICAgIHBoeXNfZXF1YWwgY3VycmVudCB0YXJnZXRfZXZlbnQgfHwgc2VhcmNoIGN1cnJlbnQubmV4dF9maXJlZCB+dGFyZ2V0X2V2ZW50XG4gICAgaW5cbiAgICBmdW4gdCB0YXJnZXRfZXZlbnQgLT4gc2VhcmNoIHQuZmlyZWRfZXZlbnRzIH50YXJnZXRfZXZlbnRcbiAgOztcblxuICBsZXQgaW52YXJpYW50X3dpdGhfam9icyAodHlwZSBydykgfmpvYjooam9iX2ludmFyaWFudCA6IEpvYi50IC0+IHVuaXQpICh0IDogcncgdCkgPVxuICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogXyB0XSAoZnVuICgpIC0+XG4gICAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH5pZDppZ25vcmVcbiAgICAgICAgfmFkdmFuY2VfZXJyb3JzOmlnbm9yZVxuICAgICAgICB+YW1fYWR2YW5jaW5nOmlnbm9yZVxuICAgICAgICB+ZXZlbnRzOlxuICAgICAgICAgIChjaGVjayAoZnVuIGV2ZW50cyAtPlxuICAgICAgICAgICAgIFRpbWluZ193aGVlbC5pbnZhcmlhbnQgaWdub3JlIGV2ZW50cztcbiAgICAgICAgICAgICBUaW1pbmdfd2hlZWwuaXRlciBldmVudHMgfmY6KGZ1biBhbGFybSAtPlxuICAgICAgICAgICAgICAgbGV0IGpvYl9vcl9ldmVudCA9IEFsYXJtLnZhbHVlIGV2ZW50cyBhbGFybSBpblxuICAgICAgICAgICAgICAgbGV0IG9wZW4gSm9iX29yX2V2ZW50Lk1hdGNoIGluXG4gICAgICAgICAgICAgICBsZXQgKEsgaykgPSBraW5kIGpvYl9vcl9ldmVudCBpblxuICAgICAgICAgICAgICAgbWF0Y2ggaywgcHJvamVjdCBrIGpvYl9vcl9ldmVudCB3aXRoXG4gICAgICAgICAgICAgICB8IEpvYiwgam9iIC0+IGpvYl9pbnZhcmlhbnQgam9iXG4gICAgICAgICAgICAgICB8IEV2ZW50LCBldmVudCAtPlxuICAgICAgICAgICAgICAgICBhc3NlcnQgKHBoeXNfZXF1YWwgYWxhcm0gZXZlbnQuYWxhcm0pO1xuICAgICAgICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBUaW1lX25zLnRdIGV2ZW50LmF0IH5leHBlY3Q6KEFsYXJtLmF0IGV2ZW50cyBhbGFybSk7XG4gICAgICAgICAgICAgICAgIFsldGVzdF9yZXN1bHQ6IEV2ZW50LlN0YXR1cy50XSBldmVudC5zdGF0dXMgfmV4cGVjdDpTY2hlZHVsZWQ7XG4gICAgICAgICAgICAgICAgIEV2ZW50LmludmFyaWFudCBldmVudCkpKVxuICAgICAgICB+ZmlyZWRfZXZlbnRzOlxuICAgICAgICAgIChjaGVjayAoZnVuIChmaXJlZF9ldmVudHMgOiBFdmVudC5PcHRpb24udCkgLT5cbiAgICAgICAgICAgICBsZXQgcmVjIGNoZWNrX2V2ZW50IChjdXJyZW50IDogRXZlbnQudCkgPVxuICAgICAgICAgICAgICAgYXNzZXJ0IChUaW1lX25zLiggPD0gKSBjdXJyZW50LmF0ICh0aW1pbmdfd2hlZWxfbm93IHQpKTtcbiAgICAgICAgICAgICAgIG1hdGNoJW9wdGlvbmFsLkV2ZW50Lk9wdGlvbiBjdXJyZW50Lm5leHRfZmlyZWQgd2l0aFxuICAgICAgICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgICAgICB8IFNvbWUgbmV4dCAtPlxuICAgICAgICAgICAgICAgICBhc3NlcnQgKFRpbWVfbnMuKCA8PSApIGN1cnJlbnQuYXQgbmV4dC5hdCk7XG4gICAgICAgICAgICAgICAgIGNoZWNrX2V2ZW50IG5leHRcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgIG1hdGNoJW9wdGlvbmFsLkV2ZW50Lk9wdGlvbiBmaXJlZF9ldmVudHMgd2l0aFxuICAgICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgICAgIHwgU29tZSBldmVudCAtPiBjaGVja19ldmVudCBldmVudCkpXG4gICAgICAgIH5oYW5kbGVfZmlyZWQ6aWdub3JlXG4gICAgICAgIH5pc193YWxsX2Nsb2NrOmlnbm9yZVxuICAgICAgICB+bW9zdF9yZWNlbnRseV9maXJlZDpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBtb3N0X3JlY2VudGx5X2ZpcmVkIC0+XG4gICAgICAgICAgICAgbWF0Y2glb3B0aW9uYWwgKG1vc3RfcmVjZW50bHlfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgICAgIHwgU29tZSBldmVudCAtPiBhc3NlcnQgKGlzX2luX2ZpcmVkX2V2ZW50cyB0IGV2ZW50KSkpXG4gICAgICAgIH5zY2hlZHVsZXI6aWdub3JlKVxuICA7O1xuXG4gIGxldCBpbnZhcmlhbnQgdCA9IGludmFyaWFudF93aXRoX2pvYnMgfmpvYjooZnVuIF8gLT4gKCkpIHRcbmVuZFxuXG5vcGVuIFQxXG5cbnR5cGUgdCA9IHJlYWQgVDEudCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50ID0gaW52YXJpYW50XG5sZXQgaW52YXJpYW50X3dpdGhfam9icyA9IGludmFyaWFudF93aXRoX2pvYnNcblxubW9kdWxlIFJlYWRfd3JpdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gcmVhZF93cml0ZSBUMS50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCA9IGludmFyaWFudFxuICBsZXQgaW52YXJpYW50X3dpdGhfam9icyA9IGludmFyaWFudF93aXRoX2pvYnNcbmVuZFxuXG5sZXQgaWQgdCA9IHQuaWRcbmxldCBpc193YWxsX2Nsb2NrIHQgPSB0LmlzX3dhbGxfY2xvY2tcbmxldCBsZW5ndGggdCA9IFRpbWluZ193aGVlbC5sZW5ndGggdC5ldmVudHNcbmxldCBtYXhfYWxsb3dlZF9hbGFybV90aW1lIHQgPSBUaW1pbmdfd2hlZWwubWF4X2FsbG93ZWRfYWxhcm1fdGltZSB0LmV2ZW50c1xubGV0IHJlYWRfb25seSAodCA6IFs+IHJlYWQgXSBUMS50KSA9ICh0IDo+IHQpXG5cbigqIFtmaXJlIHQgZXZlbnRdIHNldHMgW2V2ZW50LnN0YXR1cyA9IEZpcmVkXSBhbmQgaW5zZXJ0cyBbZXZlbnRdIGludG9cbiAgIFt0LmZpcmVkX2V2ZW50c10gaW4gc29ydGVkIHRpbWUgb3JkZXIuICopXG5sZXQgZmlyZSB0IChldmVudCA6IEV2ZW50LnQpID1cbiAgRXZlbnQuc2V0X3N0YXR1cyBldmVudCBGaXJlZDtcbiAgZXZlbnQuYWxhcm0gPC0gQWxhcm0ubnVsbCAoKTtcbiAgbGV0ICgpID1cbiAgICAoKiBJZiBbZXZlbnRdIGJlbG9uZ3MgYWZ0ZXIgW3QubW9zdF9yZWNlbnRseV9maXJlZF0sIHRoZW4gd2Ugc3RhcnQgdGhlXG4gICAgICAgaW5zZXJ0aW9uIHRoZXJlIHJhdGhlciB0aGFuIGF0IHRoZSBmcm9udCBvZiBbdC5maXJlZF9ldmVudHNdLiBUaGlzIHdvcmtzXG4gICAgICAgbmljZWx5IGlmIHdlJ3JlIGdldHRpbmcgdGhlIGFsYXJtcyBpbiBub24tZGVjcmVhc2luZyB0aW1lIG9yZGVyLCB3aGljaCBpc1xuICAgICAgIGNsb3NlIHRvIHdoYXQgW1RpbWluZ193aGVlbF0gcHJvdmlkZXMgKGFsdGhvdWdoIFtUaW1pbmdfd2hlZWxdIGRvZXNuJ3RcbiAgICAgICBndWFyYW50ZWUgdGltZSBvcmRlcmluZyBmb3IgdGltZXMgaW4gdGhlIHNhbWUgaW50ZXJ2YWwpLiAqKVxuICAgIG1hdGNoJW9wdGlvbmFsICh0Lm1vc3RfcmVjZW50bHlfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgIHwgU29tZSBtb3N0X3JlY2VudGx5X2ZpcmVkIHdoZW4gVGltZV9ucy4oIDw9ICkgbW9zdF9yZWNlbnRseV9maXJlZC5hdCBldmVudC5hdCAtPlxuICAgICAgZXZlbnQucHJldl9maXJlZCA8LSBFdmVudC5PcHRpb24uc29tZSBtb3N0X3JlY2VudGx5X2ZpcmVkO1xuICAgICAgZXZlbnQubmV4dF9maXJlZCA8LSBtb3N0X3JlY2VudGx5X2ZpcmVkLm5leHRfZmlyZWRcbiAgICB8IF8gLT5cbiAgICAgIGV2ZW50LnByZXZfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLm5vbmU7XG4gICAgICBldmVudC5uZXh0X2ZpcmVkIDwtIHQuZmlyZWRfZXZlbnRzXG4gIGluXG4gIHQubW9zdF9yZWNlbnRseV9maXJlZCA8LSBFdmVudC5PcHRpb24uc29tZSBldmVudDtcbiAgKCogV2UgdXNlIFtUaW1lX25zLiggPD0gKV0gcmF0aGVyIHRoYW4gWzxdIHNvIHRoYXQgW2V2ZW50XSBpcyBhZGRlZCBhZnRlciBvdGhlclxuICAgICBldmVudHMgYXQgdGhlIHNhbWUgdGltZS4gU2luY2UgW1RpbWluZ193aGVlbF0gZmlyZXMgYWxhcm1zIGluIGEgYnVja2V0IGluXG4gICAgIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdlcmUgYWRkZWQsIHVzaW5nIFs8PV0ga2VlcHMgZXZlbnRzIGF0IHRoZSBzYW1lXG4gICAgIHRpbWUgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSBhZGRlZC4gKilcbiAgd2hpbGVcbiAgICBtYXRjaCVvcHRpb25hbCAoZXZlbnQubmV4dF9maXJlZCA6IEV2ZW50Lk9wdGlvbi50KSB3aXRoXG4gICAgfCBOb25lIC0+IGZhbHNlXG4gICAgfCBTb21lIG5leHQgLT5cbiAgICAgIGxldCBjb250aW51ZSA9IFRpbWVfbnMuKCA8PSApIG5leHQuYXQgZXZlbnQuYXQgaW5cbiAgICAgIGlmIGNvbnRpbnVlXG4gICAgICB0aGVuIChcbiAgICAgICAgZXZlbnQucHJldl9maXJlZCA8LSBldmVudC5uZXh0X2ZpcmVkO1xuICAgICAgICBldmVudC5uZXh0X2ZpcmVkIDwtIG5leHQubmV4dF9maXJlZCk7XG4gICAgICBjb250aW51ZVxuICBkb1xuICAgICgpXG4gIGRvbmU7XG4gIGxldCAoKSA9XG4gICAgbWF0Y2glb3B0aW9uYWwgKGV2ZW50Lm5leHRfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBuZXh0IC0+IG5leHQucHJldl9maXJlZCA8LSBFdmVudC5PcHRpb24uc29tZSBldmVudFxuICBpblxuICBtYXRjaCVvcHRpb25hbCAoZXZlbnQucHJldl9maXJlZCA6IEV2ZW50Lk9wdGlvbi50KSB3aXRoXG4gIHwgTm9uZSAtPiB0LmZpcmVkX2V2ZW50cyA8LSBFdmVudC5PcHRpb24uc29tZSBldmVudFxuICB8IFNvbWUgcHJldiAtPiBwcmV2Lm5leHRfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLnNvbWUgZXZlbnRcbjs7XG5cbmxldCBhbGFybV9wcmVjaXNpb24gdCA9IFRpbWluZ193aGVlbC5hbGFybV9wcmVjaXNpb24gdC5ldmVudHNcbmxldCBuZXh0X2FsYXJtX2ZpcmVzX2F0IHQgPSBUaW1pbmdfd2hlZWwubmV4dF9hbGFybV9maXJlc19hdCB0LmV2ZW50c1xuXG5sZXQgbmV4dF9hbGFybV9ydW5zX2F0IHQgPVxuICBpZiBFdmVudC5PcHRpb24uaXNfc29tZSB0LmZpcmVkX2V2ZW50c1xuICB0aGVuIFNvbWUgKHRpbWluZ193aGVlbF9ub3cgdClcbiAgZWxzZSBUaW1pbmdfd2hlZWwubmV4dF9hbGFybV9maXJlc19hdCB0LmV2ZW50c1xuOztcblxubGV0IG5vdyB0ID0gaWYgdC5pc193YWxsX2Nsb2NrIHRoZW4gVGltZV9ucy5ub3cgKCkgZWxzZSB0aW1pbmdfd2hlZWxfbm93IHRcbmxldCB0aW1pbmdfd2hlZWxfbm93ID0gdGltaW5nX3doZWVsX25vd1xuXG5sZXQgc2NoZWR1bGUgdCAoZXZlbnQgOiBFdmVudC50KSA9XG4gIEV2ZW50LnNldF9zdGF0dXMgZXZlbnQgU2NoZWR1bGVkO1xuICBldmVudC5hbGFybSA8LSBUaW1pbmdfd2hlZWwuYWRkIHQuZXZlbnRzIH5hdDpldmVudC5hdCAoZXZlbnQgfD4gSm9iX29yX2V2ZW50Lm9mX2V2ZW50KVxuOztcblxubGV0IHJlbW92ZV9mcm9tX2ZpcmVkIHQgKGV2ZW50IDogRXZlbnQudCkgfm5ld19zdGF0dXMgPVxuICBsZXQgKCkgPVxuICAgIG1hdGNoJW9wdGlvbmFsICh0Lm1vc3RfcmVjZW50bHlfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBtb3N0X3JlY2VudGx5X2ZpcmVkIC0+XG4gICAgICBpZiBwaHlzX2VxdWFsIGV2ZW50IG1vc3RfcmVjZW50bHlfZmlyZWRcbiAgICAgIHRoZW5cbiAgICAgICAgdC5tb3N0X3JlY2VudGx5X2ZpcmVkIDwtIEV2ZW50Lk9wdGlvbi5maXJzdF9zb21lIGV2ZW50Lm5leHRfZmlyZWQgZXZlbnQucHJldl9maXJlZFxuICBpblxuICBsZXQgKCkgPVxuICAgIG1hdGNoJW9wdGlvbmFsIChldmVudC5wcmV2X2ZpcmVkIDogRXZlbnQuT3B0aW9uLnQpIHdpdGhcbiAgICB8IE5vbmUgLT4gdC5maXJlZF9ldmVudHMgPC0gZXZlbnQubmV4dF9maXJlZFxuICAgIHwgU29tZSBwcmV2IC0+IHByZXYubmV4dF9maXJlZCA8LSBldmVudC5uZXh0X2ZpcmVkXG4gIGluXG4gIGxldCAoKSA9XG4gICAgbWF0Y2glb3B0aW9uYWwgKGV2ZW50Lm5leHRfZmlyZWQgOiBFdmVudC5PcHRpb24udCkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSBuZXh0IC0+IG5leHQucHJldl9maXJlZCA8LSBldmVudC5wcmV2X2ZpcmVkXG4gIGluXG4gIGV2ZW50Lm5leHRfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLm5vbmU7XG4gIGV2ZW50LnByZXZfZmlyZWQgPC0gRXZlbnQuT3B0aW9uLm5vbmU7XG4gIEV2ZW50LnNldF9zdGF0dXMgZXZlbnQgbmV3X3N0YXR1c1xuOztcblxubW9kdWxlIEV2ZW50ID0gc3RydWN0XG4gIGluY2x1ZGUgRXZlbnRcblxuICBsZXQgY3JlYXRlX2ludGVybmFsIHQgfmF0IH5pbnRlcnZhbCB+Y2FsbGJhY2sgPVxuICAgIHsgYWxhcm0gPSBBbGFybS5udWxsICgpXG4gICAgOyBhdFxuICAgIDsgY2FsbGJhY2tcbiAgICA7IGV4ZWN1dGlvbl9jb250ZXh0ID0gdC5zY2hlZHVsZXIuY3VycmVudF9leGVjdXRpb25fY29udGV4dFxuICAgIDsgaW50ZXJ2YWxcbiAgICA7IG5leHRfZmlyZWQgPSBFdmVudC5PcHRpb24ubm9uZVxuICAgIDsgcHJldl9maXJlZCA9IEV2ZW50Lk9wdGlvbi5ub25lXG4gICAgOyBzdGF0dXMgPSBVbnNjaGVkdWxlZFxuICAgIH1cbiAgOztcblxuICBsZXQgYWRkIHQgZXZlbnQgPVxuICAgIGlmIFRpbWVfbnMuKCA8PSApIGV2ZW50LmF0ICh0aW1pbmdfd2hlZWxfbm93IHQpXG4gICAgdGhlbiBmaXJlIHQgZXZlbnRcbiAgICBlbHNlIHNjaGVkdWxlIHQgZXZlbnRcbiAgOztcblxuICBsZXQgY3JlYXRlX2FuZF9hZGQgdCB+YXQgfmludGVydmFsIH5jYWxsYmFjayA9XG4gICAgbGV0IGV2ZW50ID0gY3JlYXRlX2ludGVybmFsIHQgfmF0IH5pbnRlcnZhbCB+Y2FsbGJhY2sgaW5cbiAgICBhZGQgdCBldmVudDtcbiAgICBldmVudFxuICA7O1xuXG4gIGxldCBhdCB0IGF0IGNhbGxiYWNrID0gY3JlYXRlX2FuZF9hZGQgdCB+YXQgfmludGVydmFsOk5vbmUgfmNhbGxiYWNrXG5cbiAgbGV0IGFmdGVyIHQgc3BhbiBjYWxsYmFjayA9XG4gICAgY3JlYXRlX2FuZF9hZGQgdCB+YXQ6KFRpbWVfbnMuYWZ0ZXIgKG5vdyB0KSBzcGFuKSB+aW50ZXJ2YWw6Tm9uZSB+Y2FsbGJhY2tcbiAgOztcblxuICBsZXQgcmVxdWlyZV9zcGFuX2F0X2xlYXN0X2FsYXJtX3ByZWNpc2lvbiB0IHNwYW4gPVxuICAgIGxldCBhbGFybV9wcmVjaXNpb24gPSBhbGFybV9wcmVjaXNpb24gdCBpblxuICAgIGlmIFRpbWVfbnMuU3Bhbi4oIDwgKSBzcGFuIGFsYXJtX3ByZWNpc2lvblxuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJpbnRlcnZhbCBzcGFuIHNtYWxsZXIgdGhhbiBhbGFybSBwcmVjaXNpb25cIlxuICAgICAgICAgICAgKHNwYW4gOiBUaW1lX25zLlNwYW4udClcbiAgICAgICAgICAgIChhbGFybV9wcmVjaXNpb24gOiBUaW1lX25zLlNwYW4udCldXG4gIDs7XG5cbiAgbGV0IGF0X2ludGVydmFscyB0IHNwYW4gY2FsbGJhY2sgPVxuICAgIHJlcXVpcmVfc3Bhbl9hdF9sZWFzdF9hbGFybV9wcmVjaXNpb24gdCBzcGFuO1xuICAgIGNyZWF0ZV9hbmRfYWRkIHQgfmF0Oihub3cgdCkgfmludGVydmFsOihTb21lIHNwYW4pIH5jYWxsYmFja1xuICA7O1xuXG4gIG1vZHVsZSBBYm9ydF9yZXN1bHQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgfCBPa1xuICAgICAgfCBDdXJyZW50bHlfaGFwcGVuaW5nXG4gICAgICB8IFByZXZpb3VzbHlfdW5zY2hlZHVsZWRcbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICBlbmRcblxuICBsZXQgYWJvcnQgdCAoZXZlbnQgOiB0KSA6IEFib3J0X3Jlc3VsdC50ID1cbiAgICBtYXRjaCBldmVudC5zdGF0dXMgd2l0aFxuICAgIHwgSGFwcGVuaW5nIC0+XG4gICAgICAobWF0Y2ggZXZlbnQuaW50ZXJ2YWwgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBDdXJyZW50bHlfaGFwcGVuaW5nXG4gICAgICAgfCBTb21lIChfIDogVGltZV9ucy5TcGFuLnQpIC0+XG4gICAgICAgICBldmVudC5pbnRlcnZhbCA8LSBOb25lO1xuICAgICAgICAgT2spXG4gICAgfCBGaXJlZCAtPlxuICAgICAgcmVtb3ZlX2Zyb21fZmlyZWQgdCBldmVudCB+bmV3X3N0YXR1czpVbnNjaGVkdWxlZDtcbiAgICAgIE9rXG4gICAgfCBTY2hlZHVsZWQgLT5cbiAgICAgIEV2ZW50LnNldF9zdGF0dXMgZXZlbnQgVW5zY2hlZHVsZWQ7XG4gICAgICBUaW1pbmdfd2hlZWwucmVtb3ZlIHQuZXZlbnRzIGV2ZW50LmFsYXJtO1xuICAgICAgZXZlbnQuYWxhcm0gPC0gQWxhcm0ubnVsbCAoKTtcbiAgICAgIE9rXG4gICAgfCBVbnNjaGVkdWxlZCAtPiBQcmV2aW91c2x5X3Vuc2NoZWR1bGVkXG4gIDs7XG5cbiAgbGV0IGFib3J0X2lmX3Bvc3NpYmxlIHQgZXZlbnQgPSBpZ25vcmUgKGFib3J0IHQgZXZlbnQgOiBBYm9ydF9yZXN1bHQudClcblxuICBsZXQgYWJvcnRfZXhuIHQgZXZlbnQgPVxuICAgIG1hdGNoIGFib3J0IHQgZXZlbnQgd2l0aFxuICAgIHwgT2sgLT4gKClcbiAgICB8IHJlYXNvbiAtPlxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICBcIltTeW5jaHJvbm91c190aW1lX3NvdXJjZS5hYm9ydF9leG5dIGNhbm5vdCBhYm9ydCBldmVudFwiXG4gICAgICAgICAgICAocmVhc29uIDogQWJvcnRfcmVzdWx0LnQpXVxuICA7O1xuXG4gIGxldCBjcmVhdGUgdCBjYWxsYmFjayA9IGNyZWF0ZV9pbnRlcm5hbCB0IH5hdDpUaW1lX25zLmVwb2NoIH5pbnRlcnZhbDpOb25lIH5jYWxsYmFja1xuXG4gIGxldCBzY2hlZHVsZV9hdF9pbnRlcm5hbCB0IChldmVudCA6IHQpIGF0IH5pbnRlcnZhbCA9XG4gICAgKCogW0ZpcmVkXSBpcyBkaXNhbGxvd2VkIHRvIHByZXZlbnQgdGhlIHVzZXIgZnJvbSBlbnRlcmluZyBpbnRvIGFuIGluZmluaXRlIGxvb3AuICBUaGVcbiAgICAgICB1c2VyIGNvdWxkIHNwZWNpZnkgW2F0XSBpbiB0aGUgcGFzdCB3aGljaCB3b3VsZCBjb25zdGFudGx5IGFkZCBbY2FsbGJhY2tdIHRvIHRoZVxuICAgICAgIGJhY2sgb2YgW3QubmV4dF9maXJlZF0gaWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZnJvbSBbY2FsbGJhY2tdLiAqKVxuICAgIG1hdGNoIGV2ZW50LnN0YXR1cyB3aXRoXG4gICAgfCAoSGFwcGVuaW5nIHwgU2NoZWR1bGVkIHwgRmlyZWQpIGFzIHN0YXR1cyAtPlxuICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICBbJXNleHAgXCJjYW5ub3Qgc2NoZWR1bGUgYW4gZXZlbnQgd2l0aCBzdGF0dXNcIiwgKHN0YXR1cyA6IEV2ZW50LlN0YXR1cy50KV1cbiAgICB8IFVuc2NoZWR1bGVkIC0+XG4gICAgICBldmVudC5hdCA8LSBhdDtcbiAgICAgIGV2ZW50LmludGVydmFsIDwtIGludGVydmFsO1xuICAgICAgYWRkIHQgZXZlbnQ7XG4gICAgICBPayAoKVxuICA7O1xuXG4gIGxldCBzY2hlZHVsZV9hdCB0IGV2ZW50IGF0ID0gc2NoZWR1bGVfYXRfaW50ZXJuYWwgdCBldmVudCBhdCB+aW50ZXJ2YWw6Tm9uZVxuICBsZXQgc2NoZWR1bGVfYWZ0ZXIgdCBldmVudCBzcGFuID0gc2NoZWR1bGVfYXQgdCBldmVudCAoVGltZV9ucy5hZnRlciAobm93IHQpIHNwYW4pXG5cbiAgbGV0IHNjaGVkdWxlX2F0X2ludGVydmFscyB0IGV2ZW50IHNwYW4gPVxuICAgIHJlcXVpcmVfc3Bhbl9hdF9sZWFzdF9hbGFybV9wcmVjaXNpb24gdCBzcGFuO1xuICAgIHNjaGVkdWxlX2F0X2ludGVybmFsIHQgZXZlbnQgKG5vdyB0KSB+aW50ZXJ2YWw6KFNvbWUgc3BhbilcbiAgOztcblxuICBsZXQgcmVzY2hlZHVsZV9hdCB0IGV2ZW50IGF0IDogdW5pdCA9XG4gICAgbWF0Y2ggZXZlbnQuc3RhdHVzIHdpdGhcbiAgICB8IEZpcmVkIC0+XG4gICAgICByZW1vdmVfZnJvbV9maXJlZCB0IGV2ZW50IH5uZXdfc3RhdHVzOlVuc2NoZWR1bGVkO1xuICAgICAgZXZlbnQuYXQgPC0gYXQ7XG4gICAgICBhZGQgdCBldmVudFxuICAgIHwgSGFwcGVuaW5nIC0+XG4gICAgICAoKiBIYXBwZW5pbmcgZXZlbnRzIGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZnJvbSBbZmlyZWRdLiAqKVxuICAgICAgZXZlbnQuYXQgPC0gYXQ7XG4gICAgICBhZGQgdCBldmVudFxuICAgIHwgU2NoZWR1bGVkIC0+XG4gICAgICBldmVudC5hdCA8LSBhdDtcbiAgICAgIGlmIFRpbWVfbnMuKCA+ICkgYXQgKHRpbWluZ193aGVlbF9ub3cgdClcbiAgICAgIHRoZW4gVGltaW5nX3doZWVsLnJlc2NoZWR1bGUgdC5ldmVudHMgZXZlbnQuYWxhcm0gfmF0XG4gICAgICBlbHNlIChcbiAgICAgICAgVGltaW5nX3doZWVsLnJlbW92ZSB0LmV2ZW50cyBldmVudC5hbGFybTtcbiAgICAgICAgZmlyZSB0IGV2ZW50KVxuICAgIHwgVW5zY2hlZHVsZWQgLT5cbiAgICAgIGV2ZW50LmF0IDwtIGF0O1xuICAgICAgZXZlbnQuaW50ZXJ2YWwgPC0gTm9uZTtcbiAgICAgIGFkZCB0IGV2ZW50XG4gIDs7XG5cbiAgbGV0IHJlc2NoZWR1bGVfYWZ0ZXIgdCBldmVudCBzcGFuID0gcmVzY2hlZHVsZV9hdCB0IGV2ZW50IChUaW1lX25zLmFmdGVyIChub3cgdCkgc3BhbilcblxuZW5kXG5cbmxldCBydW5fYWZ0ZXIgdCBzcGFuIGNhbGxiYWNrID0gaWdub3JlIChFdmVudC5hZnRlciB0IHNwYW4gY2FsbGJhY2sgOiBFdmVudC50KVxubGV0IHJ1bl9hdCB0IGF0IGNhbGxiYWNrID0gaWdub3JlIChFdmVudC5hdCB0IGF0IGNhbGxiYWNrIDogRXZlbnQudClcblxubGV0IHJ1bl9hdF9pbnRlcnZhbHMgdCBzcGFuIGNhbGxiYWNrID1cbiAgaWdub3JlIChFdmVudC5hdF9pbnRlcnZhbHMgdCBzcGFuIGNhbGxiYWNrIDogRXZlbnQudClcbjs7XG5cbnR5cGUgc2VuZF9leG4gPSBNb25pdG9yMC50IC0+ID9iYWNrdHJhY2U6WyBgR2V0IHwgYFRoaXMgb2YgQmFja3RyYWNlLnQgXSAtPiBleG4gLT4gdW5pdFxuXG5sZXQgcnVuX2ZpcmVkX2V2ZW50cyB0IH4oc2VuZF9leG4gOiBzZW5kX2V4biBvcHRpb24pID1cbiAgbGV0IGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgPSB0LnNjaGVkdWxlci5jdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IGluXG4gIHdoaWxlXG4gICAgbWF0Y2glb3B0aW9uYWwgKHQuZmlyZWRfZXZlbnRzIDogRXZlbnQuT3B0aW9uLnQpIHdpdGhcbiAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICB8IFNvbWUgZXZlbnQgLT5cbiAgICAgIChtYXRjaCBldmVudC5zdGF0dXMgd2l0aFxuICAgICAgIHwgSGFwcGVuaW5nIHwgU2NoZWR1bGVkIHwgVW5zY2hlZHVsZWQgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgfCBGaXJlZCAtPlxuICAgICAgICAgcmVtb3ZlX2Zyb21fZmlyZWQgdCBldmVudCB+bmV3X3N0YXR1czpIYXBwZW5pbmc7XG4gICAgICAgICAoKiBXZSBzZXQgdGhlIGV4ZWN1dGlvbiBjb250ZXh0IHNvIHRoYXQgW2V2ZW50LmNhbGxiYWNrXSBydW5zIGluIHRoZSBzYW1lIGNvbnRleHRcbiAgICAgICAgICAgIHRoYXQgd2FzIGluIHBsYWNlIHdoZW4gW2V2ZW50XSB3YXMgY3JlYXRlZC4gKilcbiAgICAgICAgIFNjaGVkdWxlcjAuc2V0X2V4ZWN1dGlvbl9jb250ZXh0IHQuc2NoZWR1bGVyIGV2ZW50LmV4ZWN1dGlvbl9jb250ZXh0O1xuICAgICAgICAgKCogQW55IG1vZGlmaWNhdGlvbiBvZiBbc3RhdHVzXSBiZWxvdyBuZWVkcyB0byBmaXJzdCBjaGVjayB0aGF0IHRoZSBldmVudCBpc1xuICAgICAgICAgICAgc3RpbGwgW0hhcHBlbmluZ10uIElmIHRoZSBldmVudCBzdGF0dXMgaXMgbm90IFtIYXBwZW5pbmddIHRoZW4gdGhlIGV2ZW50J3NcbiAgICAgICAgICAgIGNhbGxiYWNrIG11c3QgaGF2ZSByZXNjaGVkdWxlZCB0aGUgZXZlbnQuIEluIHRoYXQgY2FzZSwgZG8gbm90IHNldCB0aGUgc3RhdHVzXG4gICAgICAgICAgICBvciBhdHRlbXB0IHRvIHJlc2NoZWR1bGUgYSByZXBlYXRpbmcgZXZlbnQuXG5cbiAgICAgICAgICAgIFRoaXMgY29kZSBjb3VsZCBiZSBtdWNoIHNpbXBsZXIgaWYgd2UgaW1tZWRpYXRlbHkgcmVzY2hlZHVsZWQgdGhlIGV2ZW50IGJlZm9yZVxuICAgICAgICAgICAgcnVubmluZyB0aGUgY2FsbGJhY2sgKG5vIG5lZWQgZm9yIHRoZSBIYXBwZW5pbmcgc3RhdGUgdGhlbikuIE9uZSByZWFzb24gd2VcbiAgICAgICAgICAgIGRvbid0IGRvIHRoYXQgaXMgdGhhdCB3ZSBkb24ndCB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVzY2hlZHVsZSBhIHBlcmlvZGljXG4gICAgICAgICAgICBldmVudCBpZiBpdHMgY2FsbGJhY2sgcmFpc2VzLiAqKVxuICAgICAgICAgKG1hdGNoIGV2ZW50LmNhbGxiYWNrICgpIHdpdGhcbiAgICAgICAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgICAgICAgIChtYXRjaCBzZW5kX2V4biB3aXRoXG4gICAgICAgICAgICAgfCBOb25lIC0+IHQuYWR2YW5jZV9lcnJvcnMgPC0gRXJyb3Iub2ZfZXhuIGV4biA6OiB0LmFkdmFuY2VfZXJyb3JzXG4gICAgICAgICAgICAgfCBTb21lIHNlbmRfZXhuIC0+XG4gICAgICAgICAgICAgICBsZXQgYmFja3RyYWNlID0gQmFja3RyYWNlLkV4bi5tb3N0X3JlY2VudCAoKSBpblxuICAgICAgICAgICAgICAgc2VuZF9leG4gZXZlbnQuZXhlY3V0aW9uX2NvbnRleHQubW9uaXRvciBleG4gfmJhY2t0cmFjZTooYFRoaXMgYmFja3RyYWNlKSk7XG4gICAgICAgICAgICBFdmVudC5zZXRfc3RhdHVzX2lmIH5pczpIYXBwZW5pbmcgZXZlbnQgVW5zY2hlZHVsZWRcbiAgICAgICAgICB8ICgpIC0+XG4gICAgICAgICAgICAobWF0Y2ggZXZlbnQuaW50ZXJ2YWwgd2l0aFxuICAgICAgICAgICAgIHwgTm9uZSAtPiBFdmVudC5zZXRfc3RhdHVzX2lmIH5pczpIYXBwZW5pbmcgZXZlbnQgVW5zY2hlZHVsZWRcbiAgICAgICAgICAgICB8IFNvbWUgaW50ZXJ2YWwgLT5cbiAgICAgICAgICAgICAgIGlmIEV2ZW50LlN0YXR1cy5lcXVhbCBIYXBwZW5pbmcgZXZlbnQuc3RhdHVzXG4gICAgICAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgICAgICAgKCogVGhlIGV2ZW50J3MgY2FsbGJhY2sgZGlkIG5vdCByZXNjaGVkdWxlIHRoZSBldmVudC4gU28gcmVzY2hlZHVsZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0aW5nIHRpbWVyIGJhc2VkIG9uIHRoZSBsYXN0IFthdF0gdGltZS4gKilcbiAgICAgICAgICAgICAgICAgZXZlbnQuYXRcbiAgICAgICAgICAgICAgICAgPC0gVGltZV9ucy5uZXh0X211bHRpcGxlXG4gICAgICAgICAgICAgICAgICAgICAgKClcbiAgICAgICAgICAgICAgICAgICAgICB+YmFzZTpldmVudC5hdFxuICAgICAgICAgICAgICAgICAgICAgIH5hZnRlcjoodGltaW5nX3doZWVsX25vdyB0KVxuICAgICAgICAgICAgICAgICAgICAgIH5pbnRlcnZhbDtcbiAgICAgICAgICAgICAgICAgc2NoZWR1bGUgdCBldmVudCkpKTtcbiAgICAgICAgIHRydWUpXG4gIGRvXG4gICAgKClcbiAgZG9uZTtcbiAgU2NoZWR1bGVyMC5zZXRfZXhlY3V0aW9uX2NvbnRleHQgdC5zY2hlZHVsZXIgY3VycmVudF9leGVjdXRpb25fY29udGV4dFxuOztcblxubGV0IGFkdmFuY2VfY2xvY2sgdCB+dG9fIH5zZW5kX2V4biA9XG4gIFRpbWluZ193aGVlbC5hZHZhbmNlX2Nsb2NrIHQuZXZlbnRzIH50b18gfmhhbmRsZV9maXJlZDp0LmhhbmRsZV9maXJlZDtcbiAgcnVuX2ZpcmVkX2V2ZW50cyB0IH5zZW5kX2V4blxuOztcblxubGV0IGZpcmVfcGFzdF9hbGFybXMgdCB+c2VuZF9leG4gPVxuICBUaW1pbmdfd2hlZWwuZmlyZV9wYXN0X2FsYXJtcyB0LmV2ZW50cyB+aGFuZGxlX2ZpcmVkOnQuaGFuZGxlX2ZpcmVkO1xuICBydW5fZmlyZWRfZXZlbnRzIHQgfnNlbmRfZXhuXG47O1xuXG5sZXQgYWR2YW5jZV9pbnRlcm5hbCB0IH50b18gfnNlbmRfZXhuID1cbiAgYWR2YW5jZV9jbG9jayB0IH50b18gfnNlbmRfZXhuO1xuICBmaXJlX3Bhc3RfYWxhcm1zIHQgfnNlbmRfZXhuXG47O1xuXG5sZXQgcHJlcGFyZV90b19hZHZhbmNlIHQgfnNlbmRfZXhuID1cbiAgaWYgdC5hbV9hZHZhbmNpbmdcbiAgdGhlblxuICAgIHJhaXNlX3MgWyVzZXhwIFwiY2Fubm90IGNhbGwgW2FkdmFuY2VfYnlfYWxhcm1zXSBvciBbYWR2YW5jZV9kaXJlY3RseV0gZnJvbSBjYWxsYmFja1wiXTtcbiAgdC5hbV9hZHZhbmNpbmcgPC0gdHJ1ZTtcbiAgKG1hdGNoIHQuYWR2YW5jZV9lcnJvcnMgd2l0aFxuICAgfCBbXSAtPiAoKVxuICAgfCBfIC0+IHQuYWR2YW5jZV9lcnJvcnMgPC0gW10pO1xuICBydW5fZmlyZWRfZXZlbnRzIHQgfnNlbmRfZXhuXG47O1xuXG5sZXQgZmluaXNoX2FkdmFuY2luZyB0ID1cbiAgdC5hbV9hZHZhbmNpbmcgPC0gZmFsc2U7XG4gIG1hdGNoIHQuYWR2YW5jZV9lcnJvcnMgd2l0aFxuICB8IFtdIC0+IE9rICgpXG4gIHwgZXJyb3JzIC0+XG4gICAgdC5hZHZhbmNlX2Vycm9ycyA8LSBbXTtcbiAgICBFcnJvciAoRXJyb3Iub2ZfbGlzdCBlcnJvcnMpXG47O1xuXG5sZXQgYWR2YW5jZV9ieV9hbGFybXMgdCB+dG9fID1cbiAgbGV0IHNlbmRfZXhuID0gTm9uZSBpblxuICBwcmVwYXJlX3RvX2FkdmFuY2UgdCB+c2VuZF9leG47XG4gIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFjb250aW51ZSBkb1xuICAgIGlmIFRpbWluZ193aGVlbC5pc19lbXB0eSB0LmV2ZW50c1xuICAgIHRoZW4gY29udGludWUgOj0gZmFsc2VcbiAgICBlbHNlIChcbiAgICAgIGxldCBtaW5fYWxhcm1fdGltZSA9IFRpbWluZ193aGVlbC5taW5fYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWxfZXhuIHQuZXZlbnRzIGluXG4gICAgICBpZiBUaW1lX25zLiggPj0gKSBtaW5fYWxhcm1fdGltZSB0b19cbiAgICAgIHRoZW4gY29udGludWUgOj0gZmFsc2VcbiAgICAgIGVsc2VcbiAgICAgICAgKCogV2UgdXNlIHRoZSBhY3R1YWwgYWxhcm0gdGltZSwgcmF0aGVyIHRoYW4gW25leHRfYWxhcm1fZmlyZXNfYXRdLCBzbyBhcyBub3QgdG9cbiAgICAgICAgICAgZXhwb3NlIChvciBhY2N1bXVsYXRlIGVycm9ycyBhc3NvY2lhdGVkIHdpdGgpIHRoZSBwcmVjaXNpb24gb2ZcbiAgICAgICAgICAgW1RpbWluZ193aGVlbF0uICopXG4gICAgICAgIGFkdmFuY2VfaW50ZXJuYWwgdCB+dG9fOm1pbl9hbGFybV90aW1lIH5zZW5kX2V4bilcbiAgZG9uZTtcbiAgYWR2YW5jZV9pbnRlcm5hbCB0IH50b18gfnNlbmRfZXhuO1xuICBmaW5pc2hfYWR2YW5jaW5nIHRcbjs7XG5cbmxldCBhZHZhbmNlX2J5X21heF9hbGFybXNfaW5fZWFjaF90aW1pbmdfd2hlZWxfaW50ZXJ2YWwgdCB+dG9fID1cbiAgbGV0IHNlbmRfZXhuID0gTm9uZSBpblxuICBwcmVwYXJlX3RvX2FkdmFuY2UgdCB+c2VuZF9leG47XG4gIGxldCBjb250aW51ZSA9IHJlZiB0cnVlIGluXG4gIHdoaWxlICFjb250aW51ZSBkb1xuICAgIGlmIFRpbWluZ193aGVlbC5pc19lbXB0eSB0LmV2ZW50c1xuICAgIHRoZW4gY29udGludWUgOj0gZmFsc2VcbiAgICBlbHNlIChcbiAgICAgIGxldCBuZXh0X2FsYXJtX2ZpcmVzX2F0ID0gVGltaW5nX3doZWVsLm5leHRfYWxhcm1fZmlyZXNfYXRfZXhuIHQuZXZlbnRzIGluXG4gICAgICBpZiBUaW1lX25zLiggPj0gKSBuZXh0X2FsYXJtX2ZpcmVzX2F0IHRvX1xuICAgICAgdGhlbiBjb250aW51ZSA6PSBmYWxzZVxuICAgICAgZWxzZVxuICAgICAgICAoKiBXZSB1c2UgdGhlIGFjdHVhbCBhbGFybSB0aW1lLCByYXRoZXIgdGhhbiBbbmV4dF9hbGFybV9maXJlc19hdF0sIHNvIGFzIG5vdCB0b1xuICAgICAgICAgICBleHBvc2UgKG9yIGFjY3VtdWxhdGUgZXJyb3JzIGFzc29jaWF0ZWQgd2l0aCkgdGhlIHByZWNpc2lvbiBvZlxuICAgICAgICAgICBbVGltaW5nX3doZWVsXS4gKilcbiAgICAgICAgYWR2YW5jZV9pbnRlcm5hbFxuICAgICAgICAgIHRcbiAgICAgICAgICB+dG9fOihUaW1pbmdfd2hlZWwubWF4X2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsX2V4biB0LmV2ZW50cylcbiAgICAgICAgICB+c2VuZF9leG4pXG4gIGRvbmU7XG4gIGFkdmFuY2VfaW50ZXJuYWwgdCB+dG9fIH5zZW5kX2V4bjtcbiAgZmluaXNoX2FkdmFuY2luZyB0XG47O1xuXG5sZXQgYWR2YW5jZV9kaXJlY3RseSB0IH50b18gPVxuICBsZXQgc2VuZF9leG4gPSBOb25lIGluXG4gIHByZXBhcmVfdG9fYWR2YW5jZSB0IH5zZW5kX2V4bjtcbiAgYWR2YW5jZV9pbnRlcm5hbCB0IH50b18gfnNlbmRfZXhuO1xuICBmaW5pc2hfYWR2YW5jaW5nIHRcbjs7XG5cbmxldCBkdXJhdGlvbl9vZiB0IGYgPVxuICBsZXQgc3RhcnQgPSBub3cgdCBpblxuICBsZXQgcmVzdWx0ID0gZiAoKSBpblxuICBsZXQgZHVyYXRpb24gPSBUaW1lX25zLmRpZmYgKG5vdyB0KSBzdGFydCBpblxuICByZXN1bHQsIGR1cmF0aW9uXG47O1xuXG5sZXQgbWF4X2FsYXJtX3RpbWVfaW5fbWluX3RpbWluZ193aGVlbF9pbnRlcnZhbCB0ID1cbiAgVGltaW5nX3doZWVsLm1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCB0LmV2ZW50c1xuOztcblxubGV0IGhhc19ldmVudHNfdG9fcnVuIHQgPSBFdmVudC5PcHRpb24uaXNfc29tZSB0LmZpcmVkX2V2ZW50c1xuIiwib3BlbiBDb3JlXG5vcGVuIEltcG9ydFxuaW5jbHVkZSBTY2hlZHVsZXIwXG5tb2R1bGUgU3luY2hyb25vdXNfdGltZV9zb3VyY2UgPSBTeW5jaHJvbm91c190aW1lX3NvdXJjZTBcbm1vZHVsZSBFdmVudCA9IFN5bmNocm9ub3VzX3RpbWVfc291cmNlLkV2ZW50XG5tb2R1bGUgQWxhcm0gPSBUaW1pbmdfd2hlZWwuQWxhcm1cbm1vZHVsZSBKb2Jfb3JfZXZlbnQgPSBTeW5jaHJvbm91c190aW1lX3NvdXJjZS5UMS5Kb2Jfb3JfZXZlbnRcblxubGV0IGRlYnVnID0gRGVidWcuc2NoZWR1bGVyXG5cbm1vZHVsZSBJdmFyID0gc3RydWN0XG4gIG9wZW4gVHlwZXMuSXZhclxuXG4gIGxldCBjcmVhdGVfd2l0aF9jZWxsIGNlbGwgPSB7IGNlbGwgfVxuICBsZXQgY3JlYXRlICgpID0gY3JlYXRlX3dpdGhfY2VsbCBFbXB0eVxuXG4gIGxldCBjcmVhdGVfZnVsbCAodHlwZSBhKSAoYSA6IGEpID1cbiAgICAoKiBXZSBhbGxvY2F0ZSBhbiBpbW11dGFibGUgaXZhciBhbmQgdGhlbiBjYXN0IGl0IHRvIGEgbXV0YWJsZSBpdmFyLiAgVGhlIGltbXV0YWJpbGl0eVxuICAgICAgIGFsbG93cyBPQ2FtbCB0byBzdGF0aWNhbGx5IGFsbG9jYXRlIHRoZSBpdmFyIGlmIFthXSBpcyBjb25zdGFudC4gIFRoaXMgY2FzdCBpcyBzYWZlXG4gICAgICAgYmVjYXVzZSBhIGZ1bGwgaXZhciBpcyBuZXZlciBtdXRhdGVkLiAgV2UgYWxzbyBiZWxpZXZlIHRoYXQgd2Ugd2lsbCBub3QgdHJpZ2dlclxuICAgICAgIGZsYW1iZGEgdG8gc3B1cmlvdXNseSByZXBvciB3YXJuaW5nIDU5LCBtdXRhdGlvbiBvZiBrbm93biBpbW11dGFibGUgZGF0YS4gIEFsbFxuICAgICAgIG11dGF0aW9ucyBvZiBhbiBpdmFyIGNlbGwsIGkuZS4gW2Zvby5jZWxsIDwtIC4uLl0sIGFyZSBkaXJlY3RseSBwcmVjZWRlZCBieSBhXG4gICAgICAgW21hdGNoIGZvby5jZWxsXSB0aGF0IHByZXZlbnRzIHRoZSBbRnVsbF0gY2FzZSBmcm9tIHJlYWNoaW5nIHRoZSBtb2RpZmljYXRpb24uICBTb1xuICAgICAgIGZsYW1iZGEgc2hvdWxkIGFsd2F5cyBlbGltaW5hdGUgdGhlIFtmb28uY2VsbCA8LSAuLi5dIG9mIGEgY29uc3RhbnQgW0Z1bGxdIGl2YXIsXG4gICAgICAgYW5kIG5vdCB3YXJuLiAqKVxuICAgIChPYmoubWFnaWMgOiBhIEltbXV0YWJsZS50IC0+IGEgdCkgeyBjZWxsID0gRnVsbCBhIH1cbiAgOztcbmVuZFxuXG5tb2R1bGUgQnZhciA9IHN0cnVjdFxuICBvcGVuIFR5cGVzLkJ2YXJcblxuICBsZXQgY3JlYXRlICgpID0gb2ZfcmVwciB7IGhhc19hbnlfd2FpdGVycyA9IGZhbHNlOyBpdmFyID0gSXZhci5jcmVhdGUgKCkgfVxuZW5kXG5cbm1vZHVsZSBWZXJ5X2xvd19wcmlvcml0eV93b3JrZXIgPSBzdHJ1Y3RcbiAgbW9kdWxlIEV4ZWNfcmVzdWx0ID0gc3RydWN0XG4gICAgdHlwZSB0ID0gVHlwZXMuVmVyeV9sb3dfcHJpb3JpdHlfd29ya2VyLkV4ZWNfcmVzdWx0LnQgPVxuICAgICAgfCBGaW5pc2hlZFxuICAgICAgfCBOb3RfZmluaXNoZWRcbiAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICBlbmRcblxuICB0eXBlIHQgPSBUeXBlcy5WZXJ5X2xvd19wcmlvcml0eV93b3JrZXIudCA9XG4gICAgeyBleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICA7IGV4ZWMgOiB1bml0IC0+IEV4ZWNfcmVzdWx0LnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50IHQgPVxuICAgIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSB0IFslc2V4cF9vZjogdF0gKGZ1biAoKSAtPlxuICAgICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgICBGaWVsZHMuaXRlciB+ZXhlY3V0aW9uX2NvbnRleHQ6KGNoZWNrIEV4ZWN1dGlvbl9jb250ZXh0LmludmFyaWFudCkgfmV4ZWM6aWdub3JlKVxuICA7O1xuZW5kXG5cbnR5cGUgdCA9IFNjaGVkdWxlcjAudCA9XG4gIHsgKCogW2NoZWNrX2FjY2Vzc10gb3B0aW9uYWxseSBob2xkcyBhIGZ1bmN0aW9uIHRvIHJ1biB0byBjaGVjayB3aGV0aGVyIGFjY2VzcyB0byBbdF0gaXNcbiAgICAgICBjdXJyZW50bHkgYWxsb3dlZC4gIEl0IGlzIHVzZWQgdG8gZGV0ZWN0IGludmFsaWQgYWNjZXNzIHRvIHRoZSBzY2hlZHVsZXIgZnJvbSBhXG4gICAgICAgdGhyZWFkLiAqKVxuICAgIG11dGFibGUgY2hlY2tfYWNjZXNzIDogKHVuaXQgLT4gdW5pdCkgb3B0aW9uXG4gIDsgbXV0YWJsZSBqb2JfcG9vbCA6IEpvYl9wb29sLnRcbiAgOyBub3JtYWxfcHJpb3JpdHlfam9icyA6IEpvYl9xdWV1ZS50XG4gIDsgbG93X3ByaW9yaXR5X2pvYnMgOiBKb2JfcXVldWUudFxuICA7IHZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMgOiBWZXJ5X2xvd19wcmlvcml0eV93b3JrZXIudCBEZXF1ZS50XG4gIDsgbXV0YWJsZSBtYWluX2V4ZWN1dGlvbl9jb250ZXh0IDogRXhlY3V0aW9uX2NvbnRleHQudFxuICA7IG11dGFibGUgY3VycmVudF9leGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgKCogVGhlIHNjaGVkdWxlciBjYWxscyBbZ290X3VuY2F1Z2h0X2V4bl0gd2hlbiBhbiBleGNlcHRpb24gYnViYmxlcyB0byB0aGUgdG9wIG9mIHRoZVxuICAgICBtb25pdG9yIHRyZWUgd2l0aG91dCBiZWluZyBoYW5kbGVkLiAgVGhpcyBmdW5jdGlvbiBndWFyYW50ZWVzIHRvIG5ldmVyIHJ1biBhbm90aGVyXG4gICAgIGpvYiBhZnRlciB0aGlzIGJ5IGNhbGxpbmcgW2NsZWFyXSBhbmQgYmVjYXVzZSBbZW5xdWV1ZV9qb2JdIHdpbGwgbmV2ZXIgYWRkIGFub3RoZXJcbiAgICAgam9iLiAqKVxuICA7IG11dGFibGUgdW5jYXVnaHRfZXhuIDogKEV4bi50ICogU2V4cC50KSBvcHRpb25cbiAgOyBtdXRhYmxlIGN5Y2xlX2NvdW50IDogaW50XG4gIDsgbXV0YWJsZSBjeWNsZV9zdGFydCA6IFRpbWVfbnMudFxuICA7IG11dGFibGUgaW5fY3ljbGUgOiBib29sXG4gIDsgbXV0YWJsZSBydW5fZXZlcnlfY3ljbGVfc3RhcnQgOiAoVHlwZXMuQ3ljbGVfaG9vay50W0BzZXhwLm9wYXF1ZV0pIGxpc3RcbiAgOyBydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUgOlxuICAgICAgKFR5cGVzLkN5Y2xlX2hvb2tfaGFuZGxlLnQsIChUeXBlcy5DeWNsZV9ob29rLnRbQHNleHAub3BhcXVlXSkpIEhhc2h0YmwudFxuICA7IG11dGFibGUgcnVuX2V2ZXJ5X2N5Y2xlX2VuZCA6IChUeXBlcy5DeWNsZV9ob29rLnRbQHNleHAub3BhcXVlXSkgbGlzdFxuICA7IHJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGUgOlxuICAgICAgKFR5cGVzLkN5Y2xlX2hvb2tfaGFuZGxlLnQsIChUeXBlcy5DeWNsZV9ob29rLnRbQHNleHAub3BhcXVlXSkpIEhhc2h0YmwudFxuICA7IG11dGFibGUgbGFzdF9jeWNsZV90aW1lIDogVGltZV9ucy5TcGFuLnRcbiAgOyBtdXRhYmxlIGxhc3RfY3ljbGVfbnVtX2pvYnMgOiBpbnRcbiAgOyBtdXRhYmxlIHRvdGFsX2N5Y2xlX3RpbWUgOiBUaW1lX25zLlNwYW4udFxuICA7IG11dGFibGUgdGltZV9zb3VyY2UgOiByZWFkX3dyaXRlIFN5bmNocm9ub3VzX3RpbWVfc291cmNlLlQxLnRcbiAgKCogW2V4dGVybmFsX2pvYnNdIGlzIGEgcXVldWUgb2YgYWN0aW9ucyBzZW50IGZyb20gb3V0c2lkZSBvZiBhc3luYy4gIFRoaXMgaXMgZm9yIHRoZVxuICAgICBjYXNlIHdoZXJlIHdlIHdhbnQgdG8gc2NoZWR1bGUgYSBqb2Igb3IgZmlsbCBhbiBpdmFyIGZyb20gYSBjb250ZXh0IHdoZXJlIGl0IGlzIG5vdFxuICAgICBzYWZlIHRvIHJ1biBhc3luYyBjb2RlLCBiZWNhdXNlIHRoZSBhc3luYyBsb2NrIGlzbid0IGhlbGQuICBGb3IgaW5zdGFuY2U6IC0gaW4gYW5cbiAgICAgT0NhbWwgZmluYWxpemVyLCBhcyB0aGV5IGNhbiBydW4gYXQgYW55IHRpbWUgaW4gYW55IHRocmVhZC5cblxuICAgICBUaGUgd2F5IHRvIGRvIGl0IGlzIHRvIHF1ZXVlIGEgdGh1bmsgaW4gW2V4dGVybmFsX2pvYnNdIGFuZCBjYWxsXG4gICAgIFt0aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9va10sIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciBub3RpZnlpbmcgdGhlIHNjaGVkdWxlclxuICAgICB0aGF0IG5ldyBhY3Rpb25zIGFyZSBhdmFpbGFibGUuXG5cbiAgICAgV2hlbiB1c2luZyBBc3luYyBvbiB1bml4LCBbdGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2tdIGlzIHNldCBpbiBbQXN5bmNfdW5peF1cbiAgICAgdG8gY2FsbCBbSW50ZXJydXB0b3IudGhyZWFkX3NhZmVfaW50ZXJydXB0XSwgd2hpY2ggd2lsbCB3YWtlIHVwIHRoZVxuICAgICBbQXN5bmNfdW5peF0gc2NoZWR1bGVyIGFuZCBydW4gYSBjeWNsZS5cblxuICAgICBOb3RlIHRoYXQgdGhpcyBob29rIG1pZ2h0IGJlIHVzZWQgaW4gb3RoZXIgY29udGV4dCAoanNfb2Zfb2NhbWwsIG1pcmFnZSkuXG5cbiAgICAgV2hlbiBydW5uaW5nIGEgY3ljbGUsIHdlIHB1bGwgZXh0ZXJuYWwgYWN0aW9ucyBhdCBldmVyeSBqb2IgYW5kIHBlcmZvcm0gdGhlbVxuICAgICBpbW1lZGlhdGVseS4gKilcbiAgOyBleHRlcm5hbF9qb2JzIDogRXh0ZXJuYWxfam9iLnQgVGhyZWFkX3NhZmVfcXVldWUudFxuICA7IG11dGFibGUgdGhyZWFkX3NhZmVfZXh0ZXJuYWxfam9iX2hvb2sgOiB1bml0IC0+IHVuaXRcbiAgKCogW2pvYl9xdWV1ZWRfaG9va10gYW5kIFtldmVudF9hZGRlZF9ob29rXSBhaW0gdG8gYmUgdXNlZCBieSBqc19vZl9vY2FtbC4gKilcbiAgKCogV2UgdXNlIFtfIG9wdGlvbl0gaGVyZSBiZWNhdXNlIHRob3NlIGhvb2tzIHdpbGwgbm90IGJlIHNldCBpbiB0aGUgY29tbW9uIGNhc2VcbiAgICAgYW5kIHdlIHdhbnQgdG8gYXZvaWQgZXh0cmEgZnVuY3Rpb24gY2FsbHMuICopXG4gIDsgbXV0YWJsZSBqb2JfcXVldWVkX2hvb2sgOiAoUHJpb3JpdHkudCAtPiB1bml0KSBvcHRpb25cbiAgOyBtdXRhYmxlIGV2ZW50X2FkZGVkX2hvb2sgOiAoVGltZV9ucy50IC0+IHVuaXQpIG9wdGlvblxuICA7IG11dGFibGUgeWllbGQgOiAoKHVuaXQsIHJlYWRfd3JpdGUpIFR5cGVzLkJ2YXIudFtAc2V4cC5vcGFxdWVdKVxuICA7IG11dGFibGUgeWllbGRfdW50aWxfbm9fam9ic19yZW1haW4gOlxuICAgICAgKCh1bml0LCByZWFkX3dyaXRlKSBUeXBlcy5CdmFyLnRbQHNleHAub3BhcXVlXSAoKiBjb25maWd1cmF0aW9uKikpXG4gIDsgbXV0YWJsZSBjaGVja19pbnZhcmlhbnRzIDogYm9vbFxuICA7IG11dGFibGUgbWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUgOiBNYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZS50XG4gIDsgbXV0YWJsZSByZWNvcmRfYmFja3RyYWNlcyA6IGJvb2xcbiAgfVxuW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG5sZXQgdW5jYXVnaHRfZXhuX3Vud3JhcHBlZCA9IHVuY2F1Z2h0X2V4blxuXG5sZXQgdW5jYXVnaHRfZXhuIHQgPVxuICBtYXRjaCB0LnVuY2F1Z2h0X2V4biB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSAoZXhuLCBzZXhwKSAtPlxuICAgIFNvbWUgKEVycm9yLmNyZWF0ZSBcInVuaGFuZGxlZCBleGNlcHRpb25cIiAoZXhuLCBzZXhwKSBbJXNleHBfb2Y6IEV4bi50ICogU2V4cC50XSlcbjs7XG5cbmxldCBudW1fcGVuZGluZ19qb2JzIHQgPVxuICBKb2JfcXVldWUubGVuZ3RoIHQubm9ybWFsX3ByaW9yaXR5X2pvYnMgKyBKb2JfcXVldWUubGVuZ3RoIHQubG93X3ByaW9yaXR5X2pvYnNcbjs7XG5cbmxldCBudW1fam9ic19ydW4gdCA9XG4gIEpvYl9xdWV1ZS5udW1fam9ic19ydW4gdC5ub3JtYWxfcHJpb3JpdHlfam9ic1xuICArIEpvYl9xdWV1ZS5udW1fam9ic19ydW4gdC5sb3dfcHJpb3JpdHlfam9ic1xuOztcblxubGV0IGxhc3RfY3ljbGVfbnVtX2pvYnMgdCA9IHQubGFzdF9jeWNsZV9udW1fam9ic1xuXG5sZXQgdW5vcmRlcmVkX2lzX3N1Ymxpc3QgfmVxdWFsIH5zdWJsaXN0OnNtYWxsIGxhcmdlID1cbiAgbGV0IHJlbW92ZSBsIHggPVxuICAgIG1hdGNoIExpc3Quc3BsaXRfd2hpbGUgbCB+ZjooZnVuIHkgLT4gbm90IChlcXVhbCB5IHgpKSB3aXRoXG4gICAgfCBfLCBbXSAtPiBOb25lXG4gICAgfCBsLCBfIDo6IHIgLT4gU29tZSAobCBAIHIpXG4gIGluXG4gIE9wdGlvbi5pc19zb21lXG4gICAgKExpc3QuZm9sZCBzbWFsbCB+aW5pdDooU29tZSBsYXJnZSkgfmY6KGZ1biBhY2MgeCAtPlxuICAgICAgIE9wdGlvbi5iaW5kIGFjYyB+ZjooZnVuIGwgLT4gcmVtb3ZlIGwgeCkpKVxuOztcblxubGV0IGNoZWNrX2hvb2tfdGFibGVfaW52YXJpYW50IHRhYmxlIGxpc3QgPVxuICAoKiBZb3UgY2FuIGluIGZhY3QgaGF2ZSBob29rcyBpbiB0aGUgbGlzdCBmb3Igd2hpY2ggdGhlcmUgaXMgbm8gY29ycmVzcG9uZGluZyBlbnRyeSBpblxuICAgICB0aGUgdGFibGUuIFN1Y2ggaG9va3MgY2FuIG5ldmVyIGJlIHJlbW92ZWQuICopXG4gIGFzc2VydCAodW5vcmRlcmVkX2lzX3N1Ymxpc3QgfmVxdWFsOnBoeXNfZXF1YWwgfnN1Ymxpc3Q6KEhhc2h0YmwuZGF0YSB0YWJsZSkgbGlzdClcbjs7XG5cbmxldCBpbnZhcmlhbnQgdCA6IHVuaXQgPVxuICB0cnlcbiAgICBsZXQgY2hlY2sgZiBmaWVsZCA9IGYgKEZpZWxkLmdldCBmaWVsZCB0KSBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+Y2hlY2tfYWNjZXNzOmlnbm9yZVxuICAgICAgfmpvYl9wb29sOihjaGVjayBKb2JfcG9vbC5pbnZhcmlhbnQpXG4gICAgICB+bm9ybWFsX3ByaW9yaXR5X2pvYnM6KGNoZWNrIEpvYl9xdWV1ZS5pbnZhcmlhbnQpXG4gICAgICB+bG93X3ByaW9yaXR5X2pvYnM6KGNoZWNrIEpvYl9xdWV1ZS5pbnZhcmlhbnQpXG4gICAgICB+dmVyeV9sb3dfcHJpb3JpdHlfd29ya2VyczpcbiAgICAgICAgKGNoZWNrIChmdW4gcSAtPiBEZXF1ZS5pdGVyIHEgfmY6VmVyeV9sb3dfcHJpb3JpdHlfd29ya2VyLmludmFyaWFudCkpXG4gICAgICB+bWFpbl9leGVjdXRpb25fY29udGV4dDooY2hlY2sgRXhlY3V0aW9uX2NvbnRleHQuaW52YXJpYW50KVxuICAgICAgfmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQ6KGNoZWNrIEV4ZWN1dGlvbl9jb250ZXh0LmludmFyaWFudClcbiAgICAgIH51bmNhdWdodF9leG46XG4gICAgICAgIChjaGVjayAoZnVuIHVuY2F1Z2h0X2V4biAtPlxuICAgICAgICAgICBpZiBpc19zb21lIHVuY2F1Z2h0X2V4biB0aGVuIGFzc2VydCAobnVtX3BlbmRpbmdfam9icyB0ID0gMCkpKVxuICAgICAgfmN5Y2xlX2NvdW50OihjaGVjayAoZnVuIGN5Y2xlX2NvdW50IC0+IGFzc2VydCAoY3ljbGVfY291bnQgPj0gMCkpKVxuICAgICAgfmN5Y2xlX3N0YXJ0Omlnbm9yZVxuICAgICAgfmluX2N5Y2xlOmlnbm9yZVxuICAgICAgfnJ1bl9ldmVyeV9jeWNsZV9zdGFydDppZ25vcmVcbiAgICAgIH5ydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGU6XG4gICAgICAgIChjaGVjayAoZnVuIHJ1bl9ldmVyeV9jeWNsZV9zdGFydF9zdGF0ZSAtPlxuICAgICAgICAgICBjaGVja19ob29rX3RhYmxlX2ludmFyaWFudFxuICAgICAgICAgICAgIHJ1bl9ldmVyeV9jeWNsZV9zdGFydF9zdGF0ZVxuICAgICAgICAgICAgIHQucnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0KSlcbiAgICAgIH5ydW5fZXZlcnlfY3ljbGVfZW5kOmlnbm9yZVxuICAgICAgfnJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGU6XG4gICAgICAgIChjaGVjayAoZnVuIHJ1bl9ldmVyeV9jeWNsZV9lbmRfc3RhdGUgLT5cbiAgICAgICAgICAgY2hlY2tfaG9va190YWJsZV9pbnZhcmlhbnQgcnVuX2V2ZXJ5X2N5Y2xlX2VuZF9zdGF0ZSB0LnJ1bl9ldmVyeV9jeWNsZV9lbmQpKVxuICAgICAgfmxhc3RfY3ljbGVfdGltZTppZ25vcmVcbiAgICAgIH50b3RhbF9jeWNsZV90aW1lOmlnbm9yZVxuICAgICAgfmxhc3RfY3ljbGVfbnVtX2pvYnM6XG4gICAgICAgIChjaGVjayAoZnVuIGxhc3RfY3ljbGVfbnVtX2pvYnMgLT4gYXNzZXJ0IChsYXN0X2N5Y2xlX251bV9qb2JzID49IDApKSlcbiAgICAgIH50aW1lX3NvdXJjZTpcbiAgICAgICAgKGNoZWNrXG4gICAgICAgICAgIChTeW5jaHJvbm91c190aW1lX3NvdXJjZS5SZWFkX3dyaXRlLmludmFyaWFudF93aXRoX2pvYnMgfmpvYjooZnVuIGpvYiAtPlxuICAgICAgICAgICAgICBhc3NlcnQgKFBvb2wucG9pbnRlcl9pc192YWxpZCB0LmpvYl9wb29sIGpvYikpKSlcbiAgICAgIH5leHRlcm5hbF9qb2JzOmlnbm9yZVxuICAgICAgfnRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rOmlnbm9yZVxuICAgICAgfmpvYl9xdWV1ZWRfaG9vazppZ25vcmVcbiAgICAgIH5ldmVudF9hZGRlZF9ob29rOmlnbm9yZVxuICAgICAgfnlpZWxkOmlnbm9yZVxuICAgICAgfnlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluOmlnbm9yZVxuICAgICAgfmNoZWNrX2ludmFyaWFudHM6aWdub3JlXG4gICAgICB+bWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGU6aWdub3JlXG4gICAgICB+cmVjb3JkX2JhY2t0cmFjZXM6aWdub3JlXG4gIHdpdGhcbiAgfCBleG4gLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJTY2hlZHVsZXIuaW52YXJpYW50IGZhaWxlZFwiIChleG4gOiBleG4pICh0IDogdCldXG47O1xuXG5sZXQgZnJlZV9qb2IgdCBqb2IgPSBQb29sLmZyZWUgdC5qb2JfcG9vbCBqb2JcblxubGV0IGVucXVldWUgdCAoZXhlY3V0aW9uX2NvbnRleHQgOiBFeGVjdXRpb25fY29udGV4dC50KSBmIGEgPVxuICAoKiBJZiB0aGVyZSdzIGJlZW4gYW4gdW5jYXVnaHQgZXhuLCB3ZSBkb24ndCBhZGQgdGhlIGpvYiwgc2luY2Ugd2UgZG9uJ3Qgd2FudCBhbnkgam9ic1xuICAgICB0byBydW4gb25jZSB0aGVyZSdzIGJlZW4gYW4gdW5jYXVnaHQgZXhuLiAqKVxuICBpZiBpc19ub25lIHQudW5jYXVnaHRfZXhuXG4gIHRoZW4gKFxuICAgIGxldCBwcmlvcml0eSA9IGV4ZWN1dGlvbl9jb250ZXh0LnByaW9yaXR5IGluXG4gICAgbGV0IGpvYl9xdWV1ZSA9XG4gICAgICBtYXRjaCBwcmlvcml0eSB3aXRoXG4gICAgICB8IE5vcm1hbCAtPiB0Lm5vcm1hbF9wcmlvcml0eV9qb2JzXG4gICAgICB8IExvdyAtPiB0Lmxvd19wcmlvcml0eV9qb2JzXG4gICAgaW5cbiAgICBKb2JfcXVldWUuZW5xdWV1ZSBqb2JfcXVldWUgZXhlY3V0aW9uX2NvbnRleHQgZiBhO1xuICAgIG1hdGNoIHQuam9iX3F1ZXVlZF9ob29rIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgZiAtPiBmIHByaW9yaXR5KVxuOztcblxubGV0IGVucXVldWVfam9iIHQgam9iIH5mcmVlX2pvYiA9XG4gIGxldCBqb2JfcG9vbCA9IHQuam9iX3Bvb2wgaW5cbiAgZW5xdWV1ZVxuICAgIHRcbiAgICAoUG9vbC5nZXQgam9iX3Bvb2wgam9iIFBvb2wuU2xvdC50MClcbiAgICAoUG9vbC5nZXQgam9iX3Bvb2wgam9iIFBvb2wuU2xvdC50MSlcbiAgICAoUG9vbC5nZXQgam9iX3Bvb2wgam9iIFBvb2wuU2xvdC50Mik7XG4gIGlmIGZyZWVfam9iIHRoZW4gUG9vbC5mcmVlIHQuam9iX3Bvb2wgam9iXG47O1xuXG5sZXQgaGFuZGxlX2ZpcmVkICh0aW1lX3NvdXJjZSA6IF8gU3luY2hyb25vdXNfdGltZV9zb3VyY2UuVDEudCkgam9iX29yX2V2ZW50ID1cbiAgbGV0IG9wZW4gSm9iX29yX2V2ZW50Lk1hdGNoIGluXG4gIGxldCAoSyBrKSA9IGtpbmQgam9iX29yX2V2ZW50IGluXG4gIG1hdGNoIGssIHByb2plY3QgayBqb2Jfb3JfZXZlbnQgd2l0aFxuICB8IEpvYiwgam9iIC0+IGVucXVldWVfam9iIHRpbWVfc291cmNlLnNjaGVkdWxlciBqb2IgfmZyZWVfam9iOnRydWVcbiAgfCBFdmVudCwgZXZlbnQgLT4gU3luY2hyb25vdXNfdGltZV9zb3VyY2UuZmlyZSB0aW1lX3NvdXJjZSBldmVudFxuOztcblxubGV0IGNyZWF0ZSAoKSA9XG4gIGxldCBub3cgPSBUaW1lX25zLm5vdyAoKSBpblxuICBsZXQgcmVjIHQgPVxuICAgIHsgY2hlY2tfYWNjZXNzID0gTm9uZVxuICAgIDsgam9iX3Bvb2wgPSBKb2JfcG9vbC5jcmVhdGUgKClcbiAgICA7IG5vcm1hbF9wcmlvcml0eV9qb2JzID0gSm9iX3F1ZXVlLmNyZWF0ZSAoKVxuICAgIDsgbG93X3ByaW9yaXR5X2pvYnMgPSBKb2JfcXVldWUuY3JlYXRlICgpXG4gICAgOyB2ZXJ5X2xvd19wcmlvcml0eV93b3JrZXJzID0gRGVxdWUuY3JlYXRlICgpXG4gICAgOyBtYWluX2V4ZWN1dGlvbl9jb250ZXh0ID0gRXhlY3V0aW9uX2NvbnRleHQubWFpblxuICAgIDsgY3VycmVudF9leGVjdXRpb25fY29udGV4dCA9IEV4ZWN1dGlvbl9jb250ZXh0Lm1haW5cbiAgICA7IHVuY2F1Z2h0X2V4biA9IE5vbmVcbiAgICA7IGN5Y2xlX3N0YXJ0ID0gbm93XG4gICAgOyBjeWNsZV9jb3VudCA9IDBcbiAgICA7IGluX2N5Y2xlID0gZmFsc2VcbiAgICA7IHJ1bl9ldmVyeV9jeWNsZV9zdGFydCA9IFtdXG4gICAgOyBydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUgPSBIYXNodGJsLmNyZWF0ZSAobW9kdWxlIFR5cGVzLkN5Y2xlX2hvb2tfaGFuZGxlKVxuICAgIDsgcnVuX2V2ZXJ5X2N5Y2xlX2VuZCA9IFtdXG4gICAgOyBydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlID0gSGFzaHRibC5jcmVhdGUgKG1vZHVsZSBUeXBlcy5DeWNsZV9ob29rX2hhbmRsZSlcbiAgICA7IGxhc3RfY3ljbGVfdGltZSA9IHNlYyAwLlxuICAgIDsgbGFzdF9jeWNsZV9udW1fam9icyA9IDBcbiAgICA7IHRvdGFsX2N5Y2xlX3RpbWUgPSBzZWMgMC5cbiAgICA7IHRpbWVfc291cmNlXG4gICAgOyBleHRlcm5hbF9qb2JzID0gVGhyZWFkX3NhZmVfcXVldWUuY3JlYXRlICgpXG4gICAgOyB0aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9vayA9IGlnbm9yZVxuICAgIDsgam9iX3F1ZXVlZF9ob29rID0gTm9uZVxuICAgIDsgZXZlbnRfYWRkZWRfaG9vayA9IE5vbmVcbiAgICA7IHlpZWxkID0gQnZhci5jcmVhdGUgKClcbiAgICA7IHlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluID0gQnZhci5jcmVhdGUgKCkgKCogY29uZmlndXJhdGlvbiAqKVxuICAgIDsgY2hlY2tfaW52YXJpYW50cyA9IEFzeW5jX2tlcm5lbF9jb25maWcuY2hlY2tfaW52YXJpYW50c1xuICAgIDsgbWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUgPVxuICAgICAgICBBc3luY19rZXJuZWxfY29uZmlnLm1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlXG4gICAgOyByZWNvcmRfYmFja3RyYWNlcyA9IEFzeW5jX2tlcm5lbF9jb25maWcucmVjb3JkX2JhY2t0cmFjZXNcbiAgICB9XG4gIGFuZCBldmVudHMgPVxuICAgIFRpbWluZ193aGVlbC5jcmVhdGUgfmNvbmZpZzpBc3luY19rZXJuZWxfY29uZmlnLnRpbWluZ193aGVlbF9jb25maWcgfnN0YXJ0Om5vd1xuICBhbmQgdGltZV9zb3VyY2UgOiBfIFN5bmNocm9ub3VzX3RpbWVfc291cmNlLlQxLnQgPVxuICAgIHsgaWQgPSBUeXBlcy5UaW1lX3NvdXJjZV9pZC5jcmVhdGUgKClcbiAgICA7IGFkdmFuY2VfZXJyb3JzID0gW11cbiAgICA7IGFtX2FkdmFuY2luZyA9IGZhbHNlXG4gICAgOyBldmVudHNcbiAgICA7IGhhbmRsZV9maXJlZCA9IChmdW4gYWxhcm0gLT4gaGFuZGxlX2ZpcmVkIHRpbWVfc291cmNlIChBbGFybS52YWx1ZSBldmVudHMgYWxhcm0pKVxuICAgIDsgZmlyZWRfZXZlbnRzID0gRXZlbnQuT3B0aW9uLm5vbmVcbiAgICA7IGlzX3dhbGxfY2xvY2sgPSB0cnVlXG4gICAgOyBtb3N0X3JlY2VudGx5X2ZpcmVkID0gRXZlbnQuT3B0aW9uLm5vbmVcbiAgICA7IHNjaGVkdWxlciA9IHRcbiAgICB9XG4gIGluXG4gIHRcbjs7XG5cbmxldCBpc19kZWFkIHQgPSBpc19zb21lIHQudW5jYXVnaHRfZXhuXG5sZXQgc2V0X2NoZWNrX2FjY2VzcyB0IGYgPSB0LmNoZWNrX2FjY2VzcyA8LSBmXG5cbmxldCB0X3JlZiA9XG4gIG1hdGNoIFJlc3VsdC50cnlfd2l0aCBjcmVhdGUgd2l0aFxuICB8IE9rIHQgLT4gcmVmIHRcbiAgfCBFcnJvciBleG4gLT5cbiAgICBEZWJ1Zy5sb2cgXCJBc3luYyBjYW5ub3QgY3JlYXRlIGl0cyByYXcgc2NoZWR1bGVyXCIgZXhuIFslc2V4cF9vZjogZXhuXTtcbiAgICBleGl0IDFcbjs7XG5cbmxldCBjaGVja19hY2Nlc3MgdCA9XG4gIG1hdGNoIHQuY2hlY2tfYWNjZXNzIHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBmIC0+IGYgKClcbjs7XG5cbmxldCB0ICgpID1cbiAgbGV0IHQgPSAhdF9yZWYgaW5cbiAgY2hlY2tfYWNjZXNzIHQ7XG4gIHRcbjs7XG5cbmxldCBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHQgPVxuICBpZiB0LnJlY29yZF9iYWNrdHJhY2VzXG4gIHRoZW4gRXhlY3V0aW9uX2NvbnRleHQucmVjb3JkX2JhY2t0cmFjZSB0LmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHRcbiAgZWxzZSB0LmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHRcbjs7XG5cbmxldCB3aXRoX2V4ZWN1dGlvbl9jb250ZXh0MSB0IHRtcF9jb250ZXh0IH5mIHggPVxuICBsZXQgb2xkX2NvbnRleHQgPSBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0IHQgaW5cbiAgc2V0X2V4ZWN1dGlvbl9jb250ZXh0IHQgdG1wX2NvbnRleHQ7XG4gIHByb3RlY3R4IH5mIHggfmZpbmFsbHk6KGZ1biBfIC0+IHNldF9leGVjdXRpb25fY29udGV4dCB0IG9sZF9jb250ZXh0KVxuOztcblxubGV0IHdpdGhfZXhlY3V0aW9uX2NvbnRleHQgdCB0bXBfY29udGV4dCB+ZiA9IHdpdGhfZXhlY3V0aW9uX2NvbnRleHQxIHQgdG1wX2NvbnRleHQgfmYgKClcblxubGV0IGNyZWF0ZV9qb2IgKHR5cGUgYSkgdCBleGVjdXRpb25fY29udGV4dCBmIGEgPVxuICBpZiBQb29sLmlzX2Z1bGwgdC5qb2JfcG9vbCB0aGVuIHQuam9iX3Bvb2wgPC0gUG9vbC5ncm93IHQuam9iX3Bvb2w7XG4gIFBvb2wubmV3M1xuICAgIHQuam9iX3Bvb2xcbiAgICBleGVjdXRpb25fY29udGV4dFxuICAgIChPYmoubWFnaWMgKGYgOiBhIC0+IHVuaXQpIDogT2JqLnQgLT4gdW5pdClcbiAgICAoT2JqLnJlcHIgKGEgOiBhKSlcbjs7XG5cbmxldCBnb3RfdW5jYXVnaHRfZXhuIHQgZXhuIHNleHAgPVxuICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZyBcImdvdF91bmNhdWdodF9leG5cIiAoZXhuLCBzZXhwKSBbJXNleHBfb2Y6IEV4bi50ICogU2V4cC50XTtcbiAgTGlzdC5pdGVyIFsgdC5ub3JtYWxfcHJpb3JpdHlfam9iczsgdC5sb3dfcHJpb3JpdHlfam9icyBdIH5mOkpvYl9xdWV1ZS5jbGVhcjtcbiAgdC51bmNhdWdodF9leG4gPC0gU29tZSAoZXhuLCBzZXhwKVxuOztcblxuKCogW3N0YXJ0X2N5Y2xlIHQgfm1heF9udW1fam9ic19wZXJfcHJpb3JpdHldIGVuYWJsZXMgc3Vic2VxdWVudCBjYWxscyBvZiBbcnVuX2pvYnNdXG4gICB0byBydW4gdXAgdG8gW21heF9udW1fam9ic19wZXJfcHJpb3JpdHldIGpvYnMgb2YgZWFjaCBwcmlvcml0eSBsZXZlbC4gKilcbmxldCBzdGFydF9jeWNsZSB0IH5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5ID1cbiAgbGV0IG4gPSBNYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZS5yYXcgbWF4X251bV9qb2JzX3Blcl9wcmlvcml0eSBpblxuICBKb2JfcXVldWUuc2V0X2pvYnNfbGVmdF90aGlzX2N5Y2xlIHQubm9ybWFsX3ByaW9yaXR5X2pvYnMgbjtcbiAgSm9iX3F1ZXVlLnNldF9qb2JzX2xlZnRfdGhpc19jeWNsZSB0Lmxvd19wcmlvcml0eV9qb2JzIG5cbjs7XG5cbigqIFtydW5fam9icyB0XSByZW1vdmVzIGpvYnMgZnJvbSBbdF0gb25lIGF0IGEgdGltZSBhbmQgcnVucyB0aGVtLCBzdG9wcGluZyBhcyBzb29uXG4gICBhcyBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uIGlzIHJhaXNlZCwgb3Igd2hlbiBubyBtb3JlIGpvYnMgY2FuIGJlIHJ1biBhdCBhbnkgcHJpb3JpdHksXG4gICBhcyBwZXIgW35tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5XS4gKilcbmxldCByZWMgcnVuX2pvYnMgdCA9XG4gIG1hdGNoIEpvYl9xdWV1ZS5ydW5fam9icyB0Lm5vcm1hbF9wcmlvcml0eV9qb2JzIHQgd2l0aFxuICB8IEVycm9yIF8gYXMgZSAtPiBlXG4gIHwgT2sgKCkgLT5cbiAgICAobWF0Y2ggSm9iX3F1ZXVlLnJ1bl9qb2JzIHQubG93X3ByaW9yaXR5X2pvYnMgdCB3aXRoXG4gICAgIHwgRXJyb3IgXyBhcyBlIC0+IGVcbiAgICAgfCBPayAoKSAtPlxuICAgICAgIGlmIEpvYl9xdWV1ZS5jYW5fcnVuX2Ffam9iIHQubm9ybWFsX3ByaW9yaXR5X2pvYnNcbiAgICAgICB8fCBKb2JfcXVldWUuY2FuX3J1bl9hX2pvYiB0Lmxvd19wcmlvcml0eV9qb2JzXG4gICAgICAgdGhlbiBydW5fam9icyB0XG4gICAgICAgZWxzZSBPayAoKSlcbjs7XG5cbmxldCBzdGFiaWxpemUgdCA9XG4gIHN0YXJ0X2N5Y2xlXG4gICAgdFxuICAgIH5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5OlxuICAgICAgKE1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlLmNyZWF0ZV9leG4gSW50Lm1heF92YWx1ZSk7XG4gIG1hdGNoIHJ1bl9qb2JzIHQgd2l0aFxuICB8IE9rICgpIC0+IE9rICgpXG4gIHwgRXJyb3IgKGV4biwgX2JhY2t0cmFjZSkgLT4gRXJyb3IgZXhuXG47O1xuXG5sZXQgY3JlYXRlX3RpbWVfc291cmNlXG4gICAgICA/KHRpbWluZ193aGVlbF9jb25maWcgPSBBc3luY19rZXJuZWxfY29uZmlnLnRpbWluZ193aGVlbF9jb25maWcpXG4gICAgICB+bm93XG4gICAgICAoKVxuICA9XG4gIGxldCB0ID0gdCAoKSBpblxuICBsZXQgZXZlbnRzID0gVGltaW5nX3doZWVsLmNyZWF0ZSB+Y29uZmlnOnRpbWluZ193aGVlbF9jb25maWcgfnN0YXJ0Om5vdyBpblxuICBsZXQgcmVjIHRpbWVfc291cmNlIDogXyBTeW5jaHJvbm91c190aW1lX3NvdXJjZS5UMS50ID1cbiAgICB7IGlkID0gVHlwZXMuVGltZV9zb3VyY2VfaWQuY3JlYXRlICgpXG4gICAgOyBhZHZhbmNlX2Vycm9ycyA9IFtdXG4gICAgOyBhbV9hZHZhbmNpbmcgPSBmYWxzZVxuICAgIDsgZXZlbnRzXG4gICAgOyBoYW5kbGVfZmlyZWQgPSAoZnVuIGFsYXJtIC0+IGhhbmRsZV9maXJlZCB0aW1lX3NvdXJjZSAoQWxhcm0udmFsdWUgZXZlbnRzIGFsYXJtKSlcbiAgICA7IGZpcmVkX2V2ZW50cyA9IEV2ZW50Lk9wdGlvbi5ub25lXG4gICAgOyBpc193YWxsX2Nsb2NrID0gZmFsc2VcbiAgICA7IG1vc3RfcmVjZW50bHlfZmlyZWQgPSBFdmVudC5PcHRpb24ubm9uZVxuICAgIDsgc2NoZWR1bGVyID0gdFxuICAgIH1cbiAgaW5cbiAgdGltZV9zb3VyY2Vcbjs7XG5cbmxldCB3YWxsX2Nsb2NrICgpID0gU3luY2hyb25vdXNfdGltZV9zb3VyY2UucmVhZF9vbmx5ICh0ICgpKS50aW1lX3NvdXJjZVxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgU2NoZWR1bGVyID0gU2NoZWR1bGVyMVxubW9kdWxlIENlbGwgPSBUeXBlcy5DZWxsXG5cbnR5cGUgYW55ID1cbiAgWyBgRW1wdHlcbiAgfCBgRW1wdHlfb25lX2hhbmRsZXJcbiAgfCBgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnNcbiAgfCBgRnVsbFxuICB8IGBJbmRpclxuICBdXG5cbnR5cGUgJ2EgdCA9ICdhIFR5cGVzLkl2YXIudCA9IHsgbXV0YWJsZSBjZWxsIDogKCdhLCBhbnkpIGNlbGwgfVxuXG4oKiBUaGUgWydiXSBpcyB1c2VkIHRvIGVuY29kZSB0aGUgY29uc3RydWN0b3IuICBUaGlzIGFsbG93cyB1cyB0byB3cml0ZSBmdW5jdGlvbnMgdGhhdFxuICAgdGFrZSBvbmx5IG9uZSBvZiB0aGUgY29uc3RydWN0b3JzLCB3aXRoIG5vIHJ1bnRpbWUgdGVzdC5cblxuICAgV2UgbWFpbnRhaW4gdGhlIGludmFyaWFudCB0aGF0IHRoZSBkaXJlY3RlZCBncmFwaCB3aXRoIGl2YXJzIGFzIG5vZGVzIGFuZCBbSW5kaXJdcyBhc1xuICAgZWRnZXMgaXMgYWN5Y2xpYy4gIFRoZSBvbmx5IGZ1bmN0aW9ucyB0aGF0IGNyZWF0ZSBhbiBbSW5kaXJdIGFyZSBbc3F1YXNoXSBhbmRcbiAgIFtjb25uZWN0XSwgYW5kIGZvciB0aG9zZSwgdGhlIHRhcmdldCBvZiB0aGUgW0luZGlyXSBpcyBhbHdheXMgYSBub24tW0luZGlyXS4gIFRodXMsIHRoZVxuICAgbmV3bHkgYWRkZWQgZWRnZXMgYXJlIG5ldmVyIHBhcnQgb2YgYSBjeWNsZS4gKilcbmFuZCAoJ2EsICdiKSBjZWxsID0gKCdhLCAnYikgVHlwZXMuQ2VsbC50ID1cbiAgfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyA6XG4gICAgICB7ICgqIFtydW5dIGlzIG11dGFibGUgc28gd2UgY2FuIHNldCBpdCB0byBbaWdub3JlXSB3aGVuIHRoZSBoYW5kbGVyIGlzIHJlbW92ZWQuXG4gICAgICAgICAgIFRoaXMgaXMgdXNlZCB3aGVuIHdlIGluc3RhbGwgYSBoYW5kbGVyIG9uIGEgZnVsbCBpdmFyIHNpbmNlIGl0IGlzIGltbWVkaWF0ZWx5XG4gICAgICAgICAgIGFkZGVkIHRvIHRoZSBzY2hlZHVsZXIuICopXG4gICAgICAgIG11dGFibGUgcnVuIDogJ2EgLT4gdW5pdFxuICAgICAgOyBleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICAgIDsgKCogW3ByZXZdIGFuZCBbbmV4dF0gY2lyY3VsYXJseSBkb3VibHkgbGluayBhbGwgaGFuZGxlcnMgb2YgdGhlIHNhbWUgaXZhci4gKilcbiAgICAgICAgbXV0YWJsZSBwcmV2IDogKCdhLCBbIGBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBdKSBjZWxsXG4gICAgICA7IG11dGFibGUgbmV4dCA6ICgnYSwgWyBgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXSkgY2VsbFxuICAgICAgfVxuICAgICAgLT4gKCdhLCBbPiBgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXSkgY2VsbFxuICB8IEVtcHR5X29uZV9oYW5kbGVyIDpcbiAgICAgICgnYSAtPiB1bml0KSAqIEV4ZWN1dGlvbl9jb250ZXh0LnRcbiAgICAgIC0+ICgnYSwgWz4gYEVtcHR5X29uZV9oYW5kbGVyIF0pIGNlbGxcbiAgfCBFbXB0eSA6ICgnYSwgWz4gYEVtcHR5IF0pIGNlbGxcbiAgfCBGdWxsIDogJ2EgLT4gKCdhLCBbPiBgRnVsbCBdKSBjZWxsXG4gIHwgSW5kaXIgOiAnYSB0IC0+ICgnYSwgWz4gYEluZGlyIF0pIGNlbGxcblxubW9kdWxlIEhhbmRsZXIgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gKCdhLCBbIGBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBdKSBjZWxsXG5cbiAgbGV0IHJ1biAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgdCA6IF8gdCkgPSB0LnJ1blxuICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHQgOiBfIHQpID0gdC5leGVjdXRpb25fY29udGV4dFxuICBsZXQgcHJldiAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgdCA6IF8gdCkgPSB0LnByZXZcbiAgbGV0IG5leHQgKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHQgOiBfIHQpID0gdC5uZXh0XG4gIGxldCBzZXRfcnVuIChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyB0IDogXyB0KSB4ID0gdC5ydW4gPC0geFxuICBsZXQgc2V0X3ByZXYgKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHQgOiBfIHQpIHggPSB0LnByZXYgPC0geFxuICBsZXQgc2V0X25leHQgKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHQgOiBfIHQpIHggPSB0Lm5leHQgPC0geFxuXG4gIGxldCBjcmVhdGUgcnVuIGV4ZWN1dGlvbl9jb250ZXh0ID1cbiAgICAoKiBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gb2Y6XG5cbiAgICAgICB7W1xuICAgICAgICAgbGV0IHJlYyB0ID1cbiAgICAgICAgICAgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnNcbiAgICAgICAgICAgICB7IHJ1blxuICAgICAgICAgICAgIDsgZXhlY3V0aW9uX2NvbnRleHRcbiAgICAgICAgICAgICA7IHByZXYgICAgICAgICAgICAgID0gdFxuICAgICAgICAgICAgIDsgbmV4dCAgICAgICAgICAgICAgPSB0IH1cbiAgICAgICAgIGluXG4gICAgICAgICBoMSBdfVxuXG4gICAgICAgSG93ZXZlciB0aGUgY29tcGlsYXRpb24gb2YgcmVjdXJzaXZlIHZhbHVlIGluIE9DYW1sIGlzIG5vdCBvcHRpbWFsOiB0aGUgdmFsdWUgaXNcbiAgICAgICBhbGxvY2F0ZWQgdHdpY2UgYW5kIGNvcGllZCBvbmNlICh3aXRoIGEgbG9vcCBjYWxsaW5nIGNhbWxfbW9kaWZ5KS4gIFRoaXMgaXMgbm90XG4gICAgICAgbmVjZXNzYXJ5IGZvciBzaW1wbGUgcmVjdXJzaXZlIGRlZmluaXRpb25zIGxpa2UgdGhpcyBvbmUuXG5cbiAgICAgICBJbnN0ZWFkIHdlIGFsbG9jYXRlIHRoZSB2YWx1ZSB3aXRoIGR1bW15IGZpZWxkcyBhbmQgdXBkYXRlIHRoZW0gYWZ0ZXIuICopXG4gICAgbGV0IHQgPVxuICAgICAgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnNcbiAgICAgICAgeyBydW47IGV4ZWN1dGlvbl9jb250ZXh0OyBwcmV2ID0gT2JqLm1hZ2ljIE5vbmU7IG5leHQgPSBPYmoubWFnaWMgTm9uZSB9XG4gICAgaW5cbiAgICBzZXRfcHJldiB0IHQ7XG4gICAgc2V0X25leHQgdCB0O1xuICAgIHRcbiAgOztcblxuICBsZXQgY3JlYXRlMiBydW4xIGV4ZWN1dGlvbl9jb250ZXh0MSBydW4yIGV4ZWN1dGlvbl9jb250ZXh0MiA9XG4gICAgKCogQW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIG9mOlxuXG4gICAgICAge1tcbiAgICAgICAgIGxldCByZWMgdDEgPVxuICAgICAgICAgICB7IHJ1biAgICAgICAgICAgICAgID0gcnVuMVxuICAgICAgICAgICA7IGV4ZWN1dGlvbl9jb250ZXh0ID0gZXhlY3V0aW9uX2NvbnRleHQxXG4gICAgICAgICAgIDsgcHJldiAgICAgICAgICAgICAgPSB0MlxuICAgICAgICAgICA7IG5leHQgICAgICAgICAgICAgID0gdDIgfVxuICAgICAgICAgYW5kIHQyID1cbiAgICAgICAgICAgeyBydW4gICAgICAgICAgICAgICA9IHJ1bjJcbiAgICAgICAgICAgOyBleGVjdXRpb25fY29udGV4dCA9IGV4ZWN1dGlvbl9jb250ZXh0MlxuICAgICAgICAgICA7IHByZXYgICAgICAgICAgICAgID0gdDFcbiAgICAgICAgICAgOyBuZXh0ICAgICAgICAgICAgICA9IHQxIH1cbiAgICAgICAgIGluXG4gICAgICAgICB0MSBdfSAqKVxuICAgIGxldCB0MSA9XG4gICAgICBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVyc1xuICAgICAgICB7IHJ1biA9IHJ1bjFcbiAgICAgICAgOyBleGVjdXRpb25fY29udGV4dCA9IGV4ZWN1dGlvbl9jb250ZXh0MVxuICAgICAgICA7IHByZXYgPSBPYmoubWFnaWMgTm9uZVxuICAgICAgICA7IG5leHQgPSBPYmoubWFnaWMgTm9uZVxuICAgICAgICB9XG4gICAgaW5cbiAgICBsZXQgdDIgPVxuICAgICAgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnNcbiAgICAgICAgeyBydW4gPSBydW4yOyBleGVjdXRpb25fY29udGV4dCA9IGV4ZWN1dGlvbl9jb250ZXh0MjsgcHJldiA9IHQxOyBuZXh0ID0gdDEgfVxuICAgIGluXG4gICAgc2V0X3ByZXYgdDEgdDI7XG4gICAgc2V0X25leHQgdDEgdDI7XG4gICAgdDFcbiAgOztcblxuICBsZXQgaW52YXJpYW50IHQgPVxuICAgIEV4ZWN1dGlvbl9jb250ZXh0LmludmFyaWFudCAoZXhlY3V0aW9uX2NvbnRleHQgdCk7XG4gICAgbGV0IHIgPSByZWYgKG5leHQgdCkgaW5cbiAgICB3aGlsZSBub3QgKHBoeXNfZXF1YWwgIXIgdCkgZG9cbiAgICAgIGxldCB0MSA9ICFyIGluXG4gICAgICBhc3NlcnQgKHBoeXNfZXF1YWwgKHByZXYgKG5leHQgdDEpKSB0MSk7XG4gICAgICBFeGVjdXRpb25fY29udGV4dC5pbnZhcmlhbnQgKGV4ZWN1dGlvbl9jb250ZXh0IHQxKTtcbiAgICAgIHIgOj0gbmV4dCAhclxuICAgIGRvbmVcbiAgOztcblxuICBsZXQgaXNfc2luZ2xldG9uIHQgPSBwaHlzX2VxdWFsIHQgKG5leHQgdClcblxuICBsZXQgbGVuZ3RoIHQgPVxuICAgIGxldCBuID0gcmVmIDEgaW5cbiAgICBsZXQgciA9IHJlZiAobmV4dCB0KSBpblxuICAgIHdoaWxlIG5vdCAocGh5c19lcXVhbCAhciB0KSBkb1xuICAgICAgaW5jciBuO1xuICAgICAgciA6PSBuZXh0ICFyXG4gICAgZG9uZTtcbiAgICAhblxuICA7O1xuXG4gIGxldCBlbnF1ZXVlIHQgc2NoZWR1bGVyIHYgPSBTY2hlZHVsZXIuZW5xdWV1ZSBzY2hlZHVsZXIgKGV4ZWN1dGlvbl9jb250ZXh0IHQpIChydW4gdCkgdlxuXG4gIGxldCBzY2hlZHVsZV9qb2JzIHQgdiA9XG4gICAgbGV0IHNjaGVkdWxlciA9IFNjaGVkdWxlci50ICgpIGluXG4gICAgZW5xdWV1ZSB0IHNjaGVkdWxlciB2O1xuICAgIGxldCByID0gcmVmIChuZXh0IHQpIGluXG4gICAgd2hpbGUgbm90IChwaHlzX2VxdWFsICFyIHQpIGRvXG4gICAgICBlbnF1ZXVlICFyIHNjaGVkdWxlciB2O1xuICAgICAgciA6PSBuZXh0ICFyXG4gICAgZG9uZVxuICA7O1xuXG4gIGxldCB1bmxpbmsgdCA9XG4gICAgc2V0X3ByZXYgKG5leHQgdCkgKHByZXYgdCk7XG4gICAgc2V0X25leHQgKHByZXYgdCkgKG5leHQgdCk7XG4gICAgc2V0X3ByZXYgdCB0O1xuICAgIHNldF9uZXh0IHQgdFxuICA7O1xuXG4gIGxldCBhZGQgdCBydW4gZXhlY3V0aW9uX2NvbnRleHQgPVxuICAgIGxldCByZXN1bHQgPVxuICAgICAgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgeyBydW47IGV4ZWN1dGlvbl9jb250ZXh0OyBwcmV2ID0gcHJldiB0OyBuZXh0ID0gdCB9XG4gICAgaW5cbiAgICBzZXRfbmV4dCAocHJldiB0KSByZXN1bHQ7XG4gICAgc2V0X3ByZXYgdCByZXN1bHQ7XG4gICAgcmVzdWx0XG4gIDs7XG5cbiAgKCogW3NwbGljZSB0MSB0Ml0gY3JlYXRlczpcblxuICAgICB7dlxuICAgICAgIC0tPiB0MSA8LS0+IC4uLiA8LS0+IGxhc3QxIDwtLT4gdDIgPC0tPiAuLi4gPC0tPiBsYXN0MiA8LS1cbiAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICB2fSAqKVxuICBsZXQgc3BsaWNlIHQxIHQyID1cbiAgICBsZXQgbGFzdDEgPSBwcmV2IHQxIGluXG4gICAgbGV0IGxhc3QyID0gcHJldiB0MiBpblxuICAgIHNldF9uZXh0IGxhc3QxIHQyO1xuICAgIHNldF9uZXh0IGxhc3QyIHQxO1xuICAgIHNldF9wcmV2IHQxIGxhc3QyO1xuICAgIHNldF9wcmV2IHQyIGxhc3QxXG4gIDs7XG5cbiAgbGV0IG9mX2xpc3QgbCA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCAocnVuLCBleGVjdXRpb25fY29udGV4dCkgOjogbCAtPlxuICAgICAgbGV0IGZpcnN0ID0gY3JlYXRlIHJ1biBleGVjdXRpb25fY29udGV4dCBpblxuICAgICAgbGV0IHJlYyBsb29wIHByZXYgbCA9XG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICB8IFtdIC0+IHNldF9wcmV2IGZpcnN0IHByZXZcbiAgICAgICAgfCAocnVuLCBleGVjdXRpb25fY29udGV4dCkgOjogbCAtPlxuICAgICAgICAgIGxldCB0ID1cbiAgICAgICAgICAgIEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIHsgcnVuOyBleGVjdXRpb25fY29udGV4dDsgcHJldjsgbmV4dCA9IGZpcnN0IH1cbiAgICAgICAgICBpblxuICAgICAgICAgIHNldF9uZXh0IHByZXYgdDtcbiAgICAgICAgICBsb29wIHQgbFxuICAgICAgaW5cbiAgICAgIGxvb3AgZmlyc3QgbDtcbiAgICAgIFNvbWUgZmlyc3RcbiAgOztcblxuICBsZXQgdG9fbGlzdCBmaXJzdCA9XG4gICAgbGV0IHJlYyBsb29wIHQgYWNjID1cbiAgICAgIGxldCBhY2MgPSAocnVuIHQsIGV4ZWN1dGlvbl9jb250ZXh0IHQpIDo6IGFjYyBpblxuICAgICAgaWYgcGh5c19lcXVhbCB0IGZpcnN0IHRoZW4gYWNjIGVsc2UgbG9vcCAocHJldiB0KSBhY2NcbiAgICBpblxuICAgIGxvb3AgKHByZXYgZmlyc3QpIFtdXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBfICh0IDogXyB0KSA9XG4gICAgbGV0IChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyB7IHJ1biA9IF87IGV4ZWN1dGlvbl9jb250ZXh0OyBuZXh0ID0gXzsgcHJldiA9IF8gfSkgPVxuICAgICAgdFxuICAgIGluXG4gICAgWyVtZXNzYWdlIChleGVjdXRpb25fY29udGV4dCA6IEV4ZWN1dGlvbl9jb250ZXh0LnQpXVxuICA7O1xuZW5kXG5cbnR5cGUgJ2EgaXZhciA9ICdhIHRcblxuKCogQ29tcGlsZWQgYXMgdGhlIGlkZW50aXR5LiAqKVxubGV0IGNlbGxfb2ZfaGFuZGxlciA6IF8gSGFuZGxlci50IC0+IF8gPSBmdW5jdGlvblxuICB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgeCAtPiAoeCA6PiAoXywgYW55KSBjZWxsKVxuOztcblxubGV0IGVxdWFsICh0IDogXyB0KSB0JyA9IHBoeXNfZXF1YWwgdCB0J1xubGV0IGluZGlyIHQgPSB7IGNlbGwgPSBJbmRpciB0IH1cblxuaW5jbHVkZSBTY2hlZHVsZXIuSXZhclxuXG4oKiBbc3F1YXNoIHRdIHJldHVybnMgdGhlIG5vbi1bSW5kaXJdIGl2YXIgYXQgdGhlIGVuZCBvZiB0aGUgKHBvc3NpYmx5IGVtcHR5KSBjaGFpbiBvZlxuICAgW0luZGlyXXMgc3RhcnRpbmcgd2l0aCBbdF0gYW5kIGVuc3VyZXMgdGhhdCBhbGwgW0luZGlyXXMgYWxvbmcgdGhhdCBjaGFpbiBhcmUgcmVwbGFjZWRcbiAgIHdpdGggYW4gW0luZGlyXSBwb2ludGluZyB0byB0aGUgZW5kIG9mIHRoZSBjaGFpbi4gKilcbmxldCBzcXVhc2ggPVxuICBsZXQgcmVjIGZvbGxvdyBpbmRpciB0ID1cbiAgICAoKiBbaW5kaXIgPSBJbmRpciB0XSAqKVxuICAgIG1hdGNoIHQuY2VsbCB3aXRoXG4gICAgfCBJbmRpciB0JyBhcyBpbmRpcicgLT4gZm9sbG93IGluZGlyJyB0J1xuICAgIHwgXyAtPiBpbmRpclxuICBpblxuICBsZXQgcmVjIHVwZGF0ZSB0IGluZGlyID1cbiAgICBtYXRjaCB0LmNlbGwgd2l0aFxuICAgIHwgSW5kaXIgdCcgLT5cbiAgICAgIHQuY2VsbCA8LSBpbmRpcjtcbiAgICAgIHVwZGF0ZSB0JyBpbmRpclxuICAgIHwgXyAtPiB0XG4gIGluXG4gIGZ1biB0IC0+XG4gICAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgICB8IEluZGlyIHQnIC0+XG4gICAgICAobWF0Y2ggdCcuY2VsbCB3aXRoXG4gICAgICAgfCBJbmRpciB0JycgYXMgaW5kaXIgLT4gdXBkYXRlIHQgKGZvbGxvdyBpbmRpciB0JycpXG4gICAgICAgfCBfIC0+IHQnICgqIG5vdGhpbmcgdG8gZG8sIHNpbmNlIFt0XSBpcyBhIGNoYWluIHdpdGggYSBzaW5nbGUgW0luZGlyXSAqKSlcbiAgICB8IF8gLT4gdFxuOztcblxuKCogbm90aGluZyB0byBkbywgc2luY2UgW3RdIGlzbid0IGFuIFtJbmRpcl0uICopXG5cbmxldCBpbnZhcmlhbnQgYV9pbnZhcmlhbnQgdCA9XG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBGdWxsIGEgLT4gYV9pbnZhcmlhbnQgYVxuICB8IEVtcHR5IC0+ICgpXG4gIHwgRW1wdHlfb25lX2hhbmRsZXIgKF8sIGV4ZWN1dGlvbl9jb250ZXh0KSAtPlxuICAgIEV4ZWN1dGlvbl9jb250ZXh0LmludmFyaWFudCBleGVjdXRpb25fY29udGV4dFxuICB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgaGFuZGxlciAtPiBIYW5kbGVyLmludmFyaWFudCBoYW5kbGVyXG47O1xuXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSB0IDogU2V4cC50ID1cbiAgbGV0IHQgPSBzcXVhc2ggdCBpblxuICBtYXRjaCB0LmNlbGwgd2l0aFxuICB8IEluZGlyIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGZ1bGZpbGxlZCBieSBbc3F1YXNoXSAqKVxuICB8IEZ1bGwgYSAtPiBMaXN0IFsgQXRvbSBcIkZ1bGxcIjsgc2V4cF9vZl9hIGEgXVxuICB8IEVtcHR5IHwgRW1wdHlfb25lX2hhbmRsZXIgXyB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gLT4gQXRvbSBcIkVtcHR5XCJcbjs7XG5cbmxldCBwZWVrIHQgPVxuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRnVsbCBhIC0+IFNvbWUgYVxuICB8IEVtcHR5IHwgRW1wdHlfb25lX2hhbmRsZXIgXyB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gLT4gTm9uZVxuOztcblxubGV0IHZhbHVlIHQgfmlmX2VtcHR5X3RoZW5fZmFpbHdpdGggPVxuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRnVsbCBhIC0+IGFcbiAgfCBFbXB0eSB8IEVtcHR5X29uZV9oYW5kbGVyIF8gfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIC0+XG4gICAgZmFpbHdpdGggaWZfZW1wdHlfdGhlbl9mYWlsd2l0aFxuOztcblxubGV0IHZhbHVlX2V4biB0ID0gdmFsdWUgdCB+aWZfZW1wdHlfdGhlbl9mYWlsd2l0aDpcIkl2YXIudmFsdWVfZXhuIGNhbGxlZCBvbiBlbXB0eSBpdmFyXCJcblxubGV0IGlzX2VtcHR5IHQgPVxuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRnVsbCBfIC0+IGZhbHNlXG4gIHwgRW1wdHkgfCBFbXB0eV9vbmVfaGFuZGxlciBfIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyAtPiB0cnVlXG47O1xuXG5sZXQgaXNfZnVsbCB0ID0gbm90IChpc19lbXB0eSB0KVxuXG5sZXQgZmlsbCB0IHYgPVxuICBsZXQgdCA9IHNxdWFzaCB0IGluXG4gIG1hdGNoIHQuY2VsbCB3aXRoXG4gIHwgSW5kaXIgXyAtPiBhc3NlcnQgZmFsc2UgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdICopXG4gIHwgRnVsbCBfIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiSXZhci5maWxsIG9mIGZ1bGwgaXZhclwiICh0IDogXyB0KV1cbiAgfCBFbXB0eSAtPiB0LmNlbGwgPC0gRnVsbCB2XG4gIHwgRW1wdHlfb25lX2hhbmRsZXIgKHJ1biwgZXhlY3V0aW9uX2NvbnRleHQpIC0+XG4gICAgdC5jZWxsIDwtIEZ1bGwgdjtcbiAgICBTY2hlZHVsZXIuKGVucXVldWUgKHQgKCkpKSBleGVjdXRpb25fY29udGV4dCBydW4gdlxuICB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgaGFuZGxlciAtPlxuICAgIHQuY2VsbCA8LSBGdWxsIHY7XG4gICAgSGFuZGxlci5zY2hlZHVsZV9qb2JzIGhhbmRsZXIgdlxuOztcblxubGV0IHJlbW92ZV9oYW5kbGVyIHQgKGhhbmRsZXIgOiBfIEhhbmRsZXIudCkgPVxuICBIYW5kbGVyLnNldF9ydW4gaGFuZGxlciBpZ25vcmU7XG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBFbXB0eSB8IEVtcHR5X29uZV9oYW5kbGVyIF8gLT5cbiAgICAoKiBUaGVzZSBhcmUgb25seSBwb3NzaWJsZSBpZiBbaGFuZGxlcl0gd2FzIGFscmVhZHkgcmVtb3ZlZC4gICopXG4gICAgKClcbiAgfCBGdWxsIF8gLT5cbiAgICAoKiBUaGlzIGlzIHBvc3NpYmxlIGlmIFt0XSB3YXMgZmlsbGVkIGJlZm9yZSB3ZSB0cnkgdG8gcmVtb3ZlIHRoZSBoYW5kbGVyLiAgRS5nLlxuICAgICAgIFtEZWZlcnJlZC5jaG9vc2VdIHdpbGwgZG8gdGhpcy4gKilcbiAgICAoKVxuICB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgY2VsbCAtPlxuICAgIGlmIEhhbmRsZXIuaXNfc2luZ2xldG9uIGhhbmRsZXJcbiAgICB0aGVuIHQuY2VsbCA8LSBFbXB0eVxuICAgIGVsc2UgKFxuICAgICAgaWYgcGh5c19lcXVhbCBoYW5kbGVyIGNlbGwgdGhlbiB0LmNlbGwgPC0gY2VsbF9vZl9oYW5kbGVyIChIYW5kbGVyLm5leHQgaGFuZGxlcik7XG4gICAgICBIYW5kbGVyLnVubGluayBoYW5kbGVyKVxuOztcblxubGV0IGFkZF9oYW5kbGVyIHQgcnVuIGV4ZWN1dGlvbl9jb250ZXh0ID1cbiAgbGV0IHQgPSBzcXVhc2ggdCBpblxuICBtYXRjaCB0LmNlbGwgd2l0aFxuICB8IEluZGlyIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGZ1bGZpbGxlZCBieSBbc3F1YXNoXSAqKVxuICB8IEVtcHR5IC0+XG4gICAgbGV0IGhhbmRsZXIgPSBIYW5kbGVyLmNyZWF0ZSBydW4gZXhlY3V0aW9uX2NvbnRleHQgaW5cbiAgICB0LmNlbGwgPC0gY2VsbF9vZl9oYW5kbGVyIGhhbmRsZXI7XG4gICAgaGFuZGxlclxuICB8IEVtcHR5X29uZV9oYW5kbGVyIChydW4nLCBleGVjdXRpb25fY29udGV4dCcpIC0+XG4gICAgbGV0IGhhbmRsZXIgPSBIYW5kbGVyLmNyZWF0ZTIgcnVuIGV4ZWN1dGlvbl9jb250ZXh0IHJ1bicgZXhlY3V0aW9uX2NvbnRleHQnIGluXG4gICAgdC5jZWxsIDwtIGNlbGxfb2ZfaGFuZGxlciBoYW5kbGVyO1xuICAgIGhhbmRsZXJcbiAgfCBFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGhhbmRsZXIgLT4gSGFuZGxlci5hZGQgaGFuZGxlciBydW4gZXhlY3V0aW9uX2NvbnRleHRcbiAgfCBGdWxsIHYgLT5cbiAgICBsZXQgaGFuZGxlciA9IEhhbmRsZXIuY3JlYXRlIHJ1biBleGVjdXRpb25fY29udGV4dCBpblxuICAgICgqIFtydW5dIGNhbGxzIFtoYW5kbGVyLnJ1bl0sIHdoaWNoLCBpZiBbaGFuZGxlcl0gaGFzIGJlZW4gcmVtb3ZlZCwgaGFzIGJlZW4gY2hhbmdlZFxuICAgICAgIHRvIFtpZ25vcmVdLiAqKVxuICAgIGxldCBydW4gdiA9IEhhbmRsZXIucnVuIGhhbmRsZXIgdiBpblxuICAgIFNjaGVkdWxlci4oZW5xdWV1ZSAodCAoKSkpIGV4ZWN1dGlvbl9jb250ZXh0IHJ1biB2O1xuICAgIGhhbmRsZXJcbjs7XG5cbmxldCBoYXNfaGFuZGxlcnMgdCA9XG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBFbXB0eV9vbmVfaGFuZGxlciBfIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyAtPiB0cnVlXG4gIHwgRW1wdHkgfCBGdWxsIF8gLT4gZmFsc2Vcbjs7XG5cbmxldCB1cG9uJyB0IHJ1biA9IGFkZF9oYW5kbGVyIHQgcnVuIFNjaGVkdWxlci4oY3VycmVudF9leGVjdXRpb25fY29udGV4dCAodCAoKSkpXG5cbigqIFt1cG9uXSBpcyBjb25jZXB0dWFsbHkgdGhlIHNhbWUgYXM6XG5cbiAgIHtbXG4gICAgIGxldCB1cG9uIHQgZiA9IGlnbm9yZSAodXBvbicgdCBydW4pIF19XG5cbiAgIEhvd2V2ZXIsIGJlbG93IGlzIGEgbW9yZSBlZmZpY2llbnQgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHdvcnRoIGRvaW5nIGJlY2F1c2UgW3Vwb25dXG4gICBpcyB2ZXJ5IHdpZGVseSB1c2VkIGFuZCBpcyBzbyBtdWNoIG1vcmUgY29tbW9uIHRoYW4gW3Vwb24nXS4gIFRoZSBiZWxvdyBpbXBsZW1lbnRhdGlvblxuICAgYXZvaWRzIHRoZSB1c2Ugb2YgdGhlIGJhZyBvZiBoYW5kbGVycyBpbiB0aGUgZXh0cmVtZWx5IGNvbW1vbiBjYXNlIG9mIG9uZSBoYW5kbGVyIGZvclxuICAgdGhlIGRlZmVycmVkLiAqKVxubGV0IHVwb24gdCBydW4gPVxuICBsZXQgc2NoZWR1bGVyID0gU2NoZWR1bGVyLnQgKCkgaW5cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gU2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgc2NoZWR1bGVyIGluXG4gIGxldCB0ID0gc3F1YXNoIHQgaW5cbiAgbWF0Y2ggdC5jZWxsIHdpdGhcbiAgfCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZSAoKiBmdWxmaWxsZWQgYnkgW3NxdWFzaF0gKilcbiAgfCBGdWxsIHYgLT4gU2NoZWR1bGVyLmVucXVldWUgc2NoZWR1bGVyIGV4ZWN1dGlvbl9jb250ZXh0IHJ1biB2XG4gIHwgRW1wdHkgLT4gdC5jZWxsIDwtIEVtcHR5X29uZV9oYW5kbGVyIChydW4sIGV4ZWN1dGlvbl9jb250ZXh0KVxuICB8IEVtcHR5X29uZV9oYW5kbGVyIChydW4nLCBleGVjdXRpb25fY29udGV4dCcpIC0+XG4gICAgdC5jZWxsXG4gICAgPC0gY2VsbF9vZl9oYW5kbGVyIChIYW5kbGVyLmNyZWF0ZTIgcnVuIGV4ZWN1dGlvbl9jb250ZXh0IHJ1bicgZXhlY3V0aW9uX2NvbnRleHQnKVxuICB8IEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgaGFuZGxlciAtPlxuICAgIGlnbm9yZSAoSGFuZGxlci5hZGQgaGFuZGxlciBydW4gZXhlY3V0aW9uX2NvbnRleHQgOiBfIEhhbmRsZXIudClcbjs7XG5cbigqIFtjb25uZWN0XSB0YWtlcyBpdmFycyBbYmluZF9yZXN1bHRdIGFuZCBbYmluZF9yaHNdLCBhbmQgbWFrZXMgW2JpbmRfcmhzXVxuICAgYmUgYW4gW0luZGlyXSBwb2ludGluZyB0byB0aGUgbm9uLWluZGlyIGNlbGwgcmVhY2hhYmxlIGZyb20gW2JpbmRfcmVzdWx0XS4gIE9uIGVudHJ5XG4gICB0byBbY29ubmVjdF0sIFtiaW5kX3Jlc3VsdF0gYW5kIFtiaW5kX3Joc10gbWF5IGJlIGNoYWlucywgc2luY2UgW2JpbmRfcmhzXSBpcyBhblxuICAgYXJiaXRyYXJ5IHVzZXItc3VwcGxpZWQgZGVmZXJyZWQsIGFuZCBbYmluZF9yZXN1bHRdIGlzIHJldHVybmVkIHRvIHRoZSB1c2VyIHByaW9yIHRvXG4gICBiZWluZyBbY29ubmVjdF1lZCwgYW5kIG1heSBoYXZlIGJlZW4gY29udmVydGVkIHRvIGFuIGluZGlyZWN0aW9uIGluIHRoZSBjYXNlIG9mXG4gICByaWdodC1uZXN0ZWQgYmluZHMuXG5cbiAgIFRoZSBwdXJwb3NlIG9mIFtjb25uZWN0XSBpcyB0byBtYWtlIHRhaWwtcmVjdXJzaXZlIGJpbmQgbG9vcHMgdXNlIGNvbnN0YW50IHNwYWNlLlxuICAgRS5nLjpcblxuICAge1tcbiAgICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgIGlmIGkgPSAwXG4gICAgICAgdGhlbiByZXR1cm4gKClcbiAgICAgICBlbHNlIChcbiAgICAgICAgIGxldCViaW5kICgpID0gYWZ0ZXIgKHNlYyAxLikgaW5cbiAgICAgICAgIGxvb3AgKGkgLSAxKSkgXX1cblxuICAgW2Nvbm5lY3RdIG1ha2VzIGludGVybWVkaWF0ZSBiaW5kIHJlc3VsdHMgYWxsIGJlIFtJbmRpcl1zIHBvaW50aW5nIGF0IHRoZSBvdXRlcm1vc3RcbiAgIGJpbmQsIHJhdGhlciB0aGFuIGJlaW5nIGEgbGluZWFyLWxlbmd0aCBjaGFpbiwgd2l0aCBlYWNoIHBvaW50aW5nIHRvIHRoZSBwcmV2aW91cyBvbmUuXG4gICBUaGVuLCBzaW5jZSB0aGUgcHJvZ3JhbSBpcyBvbmx5IGhvbGRpbmcgb24gdG8gdGhlIGlubmVybW9zdCBhbmQgb3V0ZXJtb3N0IGJpbmRzIGFsbCB0aGVcbiAgIGludGVybWVkaWF0ZSBvbmVzIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cblxuICAgW2Nvbm5lY3RdIHdvcmtzIGJ5IHNxdWFzaGluZyBpdHMgYXJndW1lbnRzIHNvIHRoYXQgdGhlIFtiaW5kX3Joc10gYWx3YXlzIHBvaW50cyBhdCB0aGVcbiAgIHVsdGltYXRlIHJlc3VsdC4gKilcbmxldCBjb25uZWN0ID1cbiAgKCogW3JlcG9pbnRfaW5kaXJzIH5pdmFyIH5pbmRpciB+YmluZF9yZXN1bHRdIHJlcG9pbnRzIHRvIFtpbmRpcl0gYWxsIHRoZSBpdmFycyBpbiB0aGVcbiAgICAgY2hhaW4gcmVhY2hhYmxlIGZyb20gW2l2YXJdLCBhbmQgcmV0dXJucyB0aGUgbm9uLVtJbmRpcl0gY2VsbCBhdCB0aGUgZW5kIG9mIHRoZVxuICAgICBjaGFpbi4gIEFmdGVyIHJlcG9pbnRpbmcsIHdlIHdpbGwgbWVyZ2UgdGhlIGhhbmRsZXJzIGluIHRoYXQgY2VsbCB3aXRoIHRoZSBoYW5kbGVyc1xuICAgICBpbiBbYmluZF9yZXN1bHRdLCBhbmQgcHV0IHRoZSBtZXJnZWQgc2V0IG9mIGhhbmRsZXJzIGluIFtiaW5kX3Jlc3VsdF0uICopXG4gIGxldCByZWMgcmVwb2ludF9pbmRpcnMgfml2YXIgfmluZGlyIH5iaW5kX3Jlc3VsdCA9XG4gICAgbGV0IGNlbGwgPSBpdmFyLmNlbGwgaW5cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IEluZGlyIGl2YXInIC0+XG4gICAgICBpdmFyLmNlbGwgPC0gaW5kaXI7XG4gICAgICByZXBvaW50X2luZGlycyB+aXZhcjppdmFyJyB+aW5kaXIgfmJpbmRfcmVzdWx0XG4gICAgfCBGdWxsIF8gLT4gY2VsbFxuICAgIHwgRW1wdHkgfCBFbXB0eV9vbmVfaGFuZGxlciBfIHwgRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyAtPlxuICAgICAgKCogSXQgaXMgcG9zc2libGUgdGhhdCBbYmluZF9yZXN1bHRdIGFuZCBbYmluZF9yaHNdIGFyZSBub3QgZXF1YWwsIGJ1dCB0aGVpciBjaGFpbnNcbiAgICAgICAgIG9mIGluZGlycyBsZWFkIHRvIHRoZSBzYW1lIG5vbi1bSW5kaXJdIGNlbGwsIGluIHdoaWNoIGNhc2Ugd2UgY2Fubm90IHNldCB0aGF0XG4gICAgICAgICBjZWxsIHRvIHBvaW50IHRvIGl0c2VsZiwgYmVjYXVzZSB0aGF0IHdvdWxkIGludHJvZHVjZSBhIGN5Y2xlLiAqKVxuICAgICAgaWYgbm90IChwaHlzX2VxdWFsIGl2YXIgYmluZF9yZXN1bHQpIHRoZW4gaXZhci5jZWxsIDwtIGluZGlyO1xuICAgICAgY2VsbFxuICBpblxuICBmdW4gfmJpbmRfcmVzdWx0IH5iaW5kX3JocyAtPlxuICAgIGlmIG5vdCAocGh5c19lcXVhbCBiaW5kX3Jlc3VsdCBiaW5kX3JocylcbiAgICB0aGVuIChcbiAgICAgIGxldCBiaW5kX3Jlc3VsdCA9IHNxdWFzaCBiaW5kX3Jlc3VsdCBpblxuICAgICAgbGV0IGluZGlyID0gSW5kaXIgYmluZF9yZXN1bHQgaW5cbiAgICAgIGxldCBiaW5kX3Joc19jb250ZW50cyA9IHJlcG9pbnRfaW5kaXJzIH5pdmFyOmJpbmRfcmhzIH5pbmRpciB+YmluZF9yZXN1bHQgaW5cbiAgICAgICgqIHVwZGF0ZSBbYmluZF9yZXN1bHRdIHdpdGggdGhlIHVuaW9uIG9mIGhhbmRsZXJzIGluIFtiaW5kX3Jlc3VsdF0gYW5kXG4gICAgICAgICBbYmluZF9yaHNdICopXG4gICAgICBtYXRjaCBiaW5kX3Jlc3VsdC5jZWxsLCBiaW5kX3Joc19jb250ZW50cyB3aXRoXG4gICAgICB8IEluZGlyIF8sIF8gfCBfLCBJbmRpciBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgKCogZnVsZmlsbGVkIGJ5IFtzcXVhc2hdIGFuZCBbcmVwb2ludF9pbmRpcnNdICopXG4gICAgICAoKiBbY29ubmVjdF0gaXMgb25seSB1c2VkIGluIGJpbmQsIHdob3NlIGl2YXIgaXMgb25seSBldmVyIGV4cG9ydGVkIGFzIGEgcmVhZC1vbmx5XG4gICAgICAgICBkZWZlcnJlZC4gIFRodXMsIFtiaW5kX3Jlc3VsdF0gbXVzdCBiZSBlbXB0eS4gKilcbiAgICAgIHwgRnVsbCBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBfLCBFbXB0eSAtPiAoKVxuICAgICAgfCBFbXB0eSwgXyAtPiBiaW5kX3Jlc3VsdC5jZWxsIDwtIGJpbmRfcmhzX2NvbnRlbnRzXG4gICAgICB8IEVtcHR5X29uZV9oYW5kbGVyIChydW4sIGV4ZWN1dGlvbl9jb250ZXh0KSwgRnVsbCB2IC0+XG4gICAgICAgIGJpbmRfcmVzdWx0LmNlbGwgPC0gYmluZF9yaHNfY29udGVudHM7XG4gICAgICAgIFNjaGVkdWxlci4oZW5xdWV1ZSAodCAoKSkpIGV4ZWN1dGlvbl9jb250ZXh0IHJ1biB2XG4gICAgICB8IChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGhhbmRsZXIpLCBGdWxsIHYgLT5cbiAgICAgICAgYmluZF9yZXN1bHQuY2VsbCA8LSBiaW5kX3Joc19jb250ZW50cztcbiAgICAgICAgSGFuZGxlci5zY2hlZHVsZV9qb2JzIGhhbmRsZXIgdlxuICAgICAgfCAoIEVtcHR5X29uZV9oYW5kbGVyIChydW4xLCBleGVjdXRpb25fY29udGV4dDEpXG4gICAgICAgICwgRW1wdHlfb25lX2hhbmRsZXIgKHJ1bjIsIGV4ZWN1dGlvbl9jb250ZXh0MikgKSAtPlxuICAgICAgICBsZXQgaGFuZGxlcjEgPSBIYW5kbGVyLmNyZWF0ZTIgcnVuMSBleGVjdXRpb25fY29udGV4dDEgcnVuMiBleGVjdXRpb25fY29udGV4dDIgaW5cbiAgICAgICAgYmluZF9yZXN1bHQuY2VsbCA8LSBjZWxsX29mX2hhbmRsZXIgaGFuZGxlcjFcbiAgICAgIHwgKCAoRW1wdHlfb25lX29yX21vcmVfaGFuZGxlcnMgXyBhcyBoYW5kbGVyMSlcbiAgICAgICAgLCBFbXB0eV9vbmVfaGFuZGxlciAocnVuMiwgZXhlY3V0aW9uX2NvbnRleHQyKSApIC0+XG4gICAgICAgIGlnbm9yZSAoSGFuZGxlci5hZGQgaGFuZGxlcjEgcnVuMiBleGVjdXRpb25fY29udGV4dDIgOiBfIEhhbmRsZXIudClcbiAgICAgIHwgKCBFbXB0eV9vbmVfaGFuZGxlciAocnVuMSwgZXhlY3V0aW9uX2NvbnRleHQxKVxuICAgICAgICAsIChFbXB0eV9vbmVfb3JfbW9yZV9oYW5kbGVycyBfIGFzIGhhbmRsZXIyKSApIC0+XG4gICAgICAgIGxldCBoYW5kbGVyMSA9IEhhbmRsZXIuYWRkIGhhbmRsZXIyIHJ1bjEgZXhlY3V0aW9uX2NvbnRleHQxIGluXG4gICAgICAgIGJpbmRfcmVzdWx0LmNlbGwgPC0gY2VsbF9vZl9oYW5kbGVyIGhhbmRsZXIxXG4gICAgICB8ICggKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgaGFuZGxlcjEpXG4gICAgICAgICwgKEVtcHR5X29uZV9vcl9tb3JlX2hhbmRsZXJzIF8gYXMgaGFuZGxlcjIpICkgLT4gSGFuZGxlci5zcGxpY2UgaGFuZGxlcjEgaGFuZGxlcjIpXG47O1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgSXZhciA9IEl2YXIwXG5tb2R1bGUgSGFuZGxlciA9IEl2YXIuSGFuZGxlclxuXG4oKiBEZWZlcnJlZHMgcHJlc2VudCBhIGNvdmFyaWFudCB2aWV3IG9mIGl2YXJzLiAgV2UgY291bGQgYWN0dWFsbHkgaW1wbGVtZW50IGRlZmVycmVkc1xuICAgdXNpbmcgYSByZWNvcmQgb2YgY2xvc3VyZXMsIGFzIGluIHRoZSBbZXNzZW5jZV9vZl9kZWZlcnJlZF0gcmVjb3JkIGJlbG93LCBmb3Igd2hpY2ggdGhlXG4gICBPQ2FtbCB0eXBlIGNoZWNrZXIgY2FuIGluZmVyIGNvdmFyaWFuY2UuICBIb3dldmVyLCBkb2luZyBzbyB3b3VsZCBtYWtlIFtJdmFyLnJlYWRdIHZlcnlcbiAgIGNvc3RseSwgYmVjYXVzZSBpdCB3b3VsZCBoYXZlIHRvIGFsbG9jYXRlIGxvdHMgb2YgY2xvc3VyZXMgYW5kIGEgcmVjb3JkLiAgSW5zdGVhZCBvZlxuICAgZG9pbmcgdGhpcywgd2UgbWFrZSBkZWZlcnJlZHMgYW4gYWJzdHJhY3QgY292YXJpYW50IHR5cGUsIHdoaWNoIGNvbmNyZXRlbHkgaXMganVzdCB0aGVcbiAgIGl2YXIsIGFuZCB1c2UgW09iai5tYWdpY10gdG8gY29udmVydCBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIGEgZGVmZXJyZWQgYW5kIGl0cyBjb25jcmV0ZVxuICAgcmVwcmVzZW50YXRpb24gYXMgYW4gaXZhci4gIFRoaXMgW09iai5tYWdpY10gaXMgc2FmZSBiZWNhdXNlIHRoZSByZXByZXNlbnRhdGlvbiBpc1xuICAgYWx3YXlzIGp1c3QgYW4gaXZhciwgYW5kIHRoZSBjb3ZhcmlhbmNlIGZvbGxvd3MgZnJvbSB0aGUgZmFjdCB0aGF0IGFsbCB0aGUgZGVmZXJyZWRcbiAgIG9wZXJhdGlvbnMgYXJlIGVxdWl2YWxlbnQgdG8gdGhvc2UgaW1wbGVtZW50ZWQgZGlyZWN0bHkgb24gdG9wIG9mIHRoZVxuICAgW2Vzc2VuY2Vfb2ZfZGVmZXJyZWRdLlxuXG4gICB7W1xuICAgICB0eXBlICgrJ2EsICdleGVjdXRpb25fY29udGV4dCkgZXNzZW5jZV9vZl9kZWZlcnJlZCA9XG4gICAgICAgeyBwZWVrICAgICAgICAgICAgICAgICAgICAgIDogdW5pdCAtPiAnYSBvcHRpb25cbiAgICAgICA7IGlzX2RldGVybWluZWQgICAgICAgICAgICAgOiB1bml0IC0+IGJvb2xcbiAgICAgICA7IHVwb24gICAgICAgICAgICAgICAgICAgICAgOiAoJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICAgICAgIDsgdXBvbicgICAgICAgICAgICAgICAgICAgICA6ICgnYSAtPiB1bml0KSAtPiBVbnJlZ2lzdGVyLnRcbiAgICAgICA7IGluc3RhbGxfcmVtb3ZhYmxlX2hhbmRsZXIgOiAoJ2EsICdleGVjdXRpb25fY29udGV4dCkgUmF3X2hhbmRsZXIudCAtPiBVbnJlZ2lzdGVyLnQ7IH0gXX0gKilcblxudHlwZSArJ2EgdCA9ICdhIFR5cGVzLkRlZmVycmVkLnRcblxuKCogdGhlIGFic3RyYWN0IGNvdmFyaWFudCB0eXBlLCBlcXVpdmFsZW50IHRvIGl2YXIgKilcblxubGV0IG9mX2l2YXIgKHR5cGUgYSkgKGl2YXIgOiBhIEl2YXIudCkgOiBhIHQgPSBPYmoubWFnaWMgaXZhclxubGV0IHRvX2l2YXIgKHR5cGUgYSkgdCA6IGEgSXZhci50ID0gT2JqLm1hZ2ljICh0IDogYSB0KVxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID0gSXZhci5pbnZhcmlhbnQgaW52YXJpYW50X2EgKHRvX2l2YXIgdClcbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSBJdmFyLnNleHBfb2ZfdCBzZXhwX29mX2EgKHRvX2l2YXIgdClcbmxldCBwZWVrIHQgPSBJdmFyLnBlZWsgKHRvX2l2YXIgdClcbmxldCByZXR1cm4gYSA9IG9mX2l2YXIgKEl2YXIuY3JlYXRlX2Z1bGwgYSlcbmxldCBpc19kZXRlcm1pbmVkIHQgPSBJdmFyLmlzX2Z1bGwgKHRvX2l2YXIgdClcblxubGV0IHZhbHVlX2V4biB0ID1cbiAgSXZhci52YWx1ZVxuICAgICh0b19pdmFyIHQpXG4gICAgfmlmX2VtcHR5X3RoZW5fZmFpbHdpdGg6XCJEZWZlcnJlZC52YWx1ZV9leG4gY2FsbGVkIG9uIHVuZGV0ZXJtaW5lZCBkZWZlcnJlZFwiXG47O1xuXG5sZXQgdXBvbiB0IGYgPSBJdmFyLnVwb24gKHRvX2l2YXIgdCkgZlxuXG5sZXQgY3JlYXRlIGYgPVxuICBsZXQgcmVzdWx0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgZiByZXN1bHQ7XG4gIG9mX2l2YXIgcmVzdWx0XG47O1xuXG4oKiBkb24ndCB1c2UgW2NyZWF0ZV0gaGVyZSBhcyBpdCB3b3VsZCBhbGxvY2F0ZSBvbmUgbW9yZSBjbG9zdXJlICopXG5sZXQgYmluZCB0IH5mID1cbiAgbGV0IGJpbmRfcmVzdWx0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgdXBvbiB0IChmdW4gYSAtPiBJdmFyLmNvbm5lY3QgfmJpbmRfcmVzdWx0IH5iaW5kX3JoczoodG9faXZhciAoZiBhKSkpO1xuICBvZl9pdmFyIGJpbmRfcmVzdWx0XG47O1xuXG5sZXQgYWRkX2hhbmRsZXIgdCBmIGV4ZWN1dGlvbl9jb250ZXh0ID0gSXZhci5hZGRfaGFuZGxlciAodG9faXZhciB0KSBmIGV4ZWN1dGlvbl9jb250ZXh0XG5sZXQgcmVtb3ZlX2hhbmRsZXIgdCBoID0gSXZhci5yZW1vdmVfaGFuZGxlciAodG9faXZhciB0KSBoXG4iLCJvcGVuIENvcmVcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMFxuaW5jbHVkZSBJdmFyMFxuXG5sZXQgcmVhZCA9IERlZmVycmVkLm9mX2l2YXJcbmxldCBmaWxsX2lmX2VtcHR5IHQgdiA9IGlmIGlzX2VtcHR5IHQgdGhlbiBmaWxsIHQgdlxuXG5pbmNsdWRlXG4gIEJpbmFibGUuT2ZfYmluYWJsZTFfd2l0aG91dF91dWlkIFtAYWxlcnQgXCItbGVnYWN5XCJdXG4gICAgKE9wdGlvbilcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgICBsZXQgdG9fYmluYWJsZSB0ID0gcGVlayB0XG5cbiAgICAgIGxldCBvZl9iaW5hYmxlID0gZnVuY3Rpb25cbiAgICAgICAgfCBOb25lIC0+IGNyZWF0ZSAoKVxuICAgICAgICB8IFNvbWUgYSAtPiBjcmVhdGVfZnVsbCBhXG4gICAgICA7O1xuICAgIGVuZClcbiIsIigqKiBbTW9uYWRfc2VxdWVuY2UuU10gaXMgYSBnZW5lcmljIGludGVyZmFjZSBzcGVjaWZ5aW5nIGZ1bmN0aW9ucyB0aGF0IGRlYWwgd2l0aCBhXG4gICAgY29udGFpbmVyIGFuZCBhIG1vbmFkLiAgSXQgaXMgc3BlY2lhbGl6ZWQgdG8gdGhlIFtEZWZlcnJlZF0gbW9uYWQgYW5kIHVzZWQgd2l0aFxuICAgIHZhcmlvdXMgY29udGFpbmVycyBpbiBtb2R1bGVzIFtEZWZlcnJlZC5BcnJheV0sIFtEZWZlcnJlZC5MaXN0XSwgW0RlZmVycmVkLlF1ZXVlXSwgYW5kXG4gICAgW0RlZmVycmVkLlNlcXVlbmNlXS4gIFRoZSBbTW9uYWRfc2VxdWVuY2UuaG93XSB0eXBlIHNwZWNpZmllcyB0aGUgcGFyYWxsZWxpc20gb2ZcbiAgICBjb250YWluZXIgaXRlcmF0b3JzLiAqKVxuXG5vcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxudHlwZSBob3cgPVxuICBbIGBQYXJhbGxlbCAoKiogbGlrZSBbYE1heF9jb25jdXJyZW50X2pvYnMgSW50Lm1heF92YWx1ZV0gKilcbiAgfCBgU2VxdWVudGlhbFxuICAoKiogW2BTZXF1ZW50aWFsXSBpcyBvZnRlbiBidXQgbm90IGFsd2F5cyB0aGUgc2FtZSBhcyBbYE1heF9jb25jdXJyZW50X2pvYnMgMV1cbiAgICAgIChmb3IgZXhhbXBsZSwgdGhleSBkaWZmZXIgaW4gdGhlIFtPcl9lcnJvcl0gbW9uYWQpLiAqKVxuICB8IGBNYXhfY29uY3VycmVudF9qb2JzIG9mIGludFxuICBdXG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgJ2EgbW9uYWRcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGZvbGRpIDogJ2EgdCAtPiBpbml0OidiIC0+IGY6KGludCAtPiAnYiAtPiAnYSAtPiAnYiBtb25hZCkgLT4gJ2IgbW9uYWRcbiAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2IgLT4gZjooJ2IgLT4gJ2EgLT4gJ2IgbW9uYWQpIC0+ICdiIG1vbmFkXG4gIHZhbCBmaW5kIDogJ2EgdCAtPiBmOignYSAtPiBib29sIG1vbmFkKSAtPiAnYSBvcHRpb24gbW9uYWRcbiAgdmFsIGZpbmRpIDogJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gYm9vbCBtb25hZCkgLT4gKGludCAqICdhKSBvcHRpb24gbW9uYWRcbiAgdmFsIGZpbmRfbWFwIDogJ2EgdCAtPiBmOignYSAtPiAnYiBvcHRpb24gbW9uYWQpIC0+ICdiIG9wdGlvbiBtb25hZFxuICB2YWwgZmluZF9tYXBpIDogJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gJ2Igb3B0aW9uIG1vbmFkKSAtPiAnYiBvcHRpb24gbW9uYWRcbiAgdmFsIGV4aXN0cyA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCBtb25hZCkgLT4gYm9vbCBtb25hZFxuICB2YWwgZXhpc3RzaSA6ICdhIHQgLT4gZjooaW50IC0+ICdhIC0+IGJvb2wgbW9uYWQpIC0+IGJvb2wgbW9uYWRcbiAgdmFsIGZvcl9hbGwgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wgbW9uYWQpIC0+IGJvb2wgbW9uYWRcbiAgdmFsIGZvcl9hbGxpIDogJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gYm9vbCBtb25hZCkgLT4gYm9vbCBtb25hZFxuICB2YWwgYWxsIDogJ2EgbW9uYWQgdCAtPiAnYSB0IG1vbmFkXG4gIHZhbCBhbGxfdW5pdCA6IHVuaXQgbW9uYWQgdCAtPiB1bml0IG1vbmFkXG5cbiAgKCoqIHsyIERlZmVycmVkIGl0ZXJhdG9yc31cblxuICAgICAgSW4gdGhlIGZvbGxvd2luZywgdGhlIGRlZmF1bHQgW2hvd10gaXMgW2BTZXF1ZW50aWFsXSAqKVxuXG4gIHZhbCBpbml0IDogP2hvdzpob3cgLT4gaW50IC0+IGY6KGludCAtPiAnYSBtb25hZCkgLT4gJ2EgdCBtb25hZFxuICB2YWwgaXRlciA6ID9ob3c6aG93IC0+ICdhIHQgLT4gZjooJ2EgLT4gdW5pdCBtb25hZCkgLT4gdW5pdCBtb25hZFxuICB2YWwgaXRlcmkgOiA/aG93OmhvdyAtPiAnYSB0IC0+IGY6KGludCAtPiAnYSAtPiB1bml0IG1vbmFkKSAtPiB1bml0IG1vbmFkXG4gIHZhbCBtYXAgOiA/aG93OmhvdyAtPiAnYSB0IC0+IGY6KCdhIC0+ICdiIG1vbmFkKSAtPiAnYiB0IG1vbmFkXG4gIHZhbCBtYXBpIDogP2hvdzpob3cgLT4gJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gJ2IgbW9uYWQpIC0+ICdiIHQgbW9uYWRcbiAgdmFsIGZpbHRlciA6ID9ob3c6aG93IC0+ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCBtb25hZCkgLT4gJ2EgdCBtb25hZFxuICB2YWwgZmlsdGVyaSA6ID9ob3c6aG93IC0+ICdhIHQgLT4gZjooaW50IC0+ICdhIC0+IGJvb2wgbW9uYWQpIC0+ICdhIHQgbW9uYWRcbiAgdmFsIGZpbHRlcl9tYXAgOiA/aG93OmhvdyAtPiAnYSB0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbiBtb25hZCkgLT4gJ2IgdCBtb25hZFxuICB2YWwgZmlsdGVyX21hcGkgOiA/aG93OmhvdyAtPiAnYSB0IC0+IGY6KGludCAtPiAnYSAtPiAnYiBvcHRpb24gbW9uYWQpIC0+ICdiIHQgbW9uYWRcbiAgdmFsIGNvbmNhdF9tYXAgOiA/aG93OmhvdyAtPiAnYSB0IC0+IGY6KCdhIC0+ICdiIHQgbW9uYWQpIC0+ICdiIHQgbW9uYWRcbiAgdmFsIGNvbmNhdF9tYXBpIDogP2hvdzpob3cgLT4gJ2EgdCAtPiBmOihpbnQgLT4gJ2EgLT4gJ2IgdCBtb25hZCkgLT4gJ2IgdCBtb25hZFxuZW5kXG4iLCJvcGVuIENvcmVcbm1vZHVsZSBTY2hlZHVsZXIgPSBTY2hlZHVsZXIxXG5pbmNsdWRlIERlZmVycmVkMFxuXG4oKiBUbyBhdm9pZCBhIHNwYWNlIGxlYWssIGl0IGlzIG5lY2Vzc2FyeSB0aGF0IFtuZXZlcl0gYWxsb2NhdGVzIGEgbmV3IGl2YXIgd2hlbmV2ZXIgaXQgaXNcbiAgIGNhbGxlZC4gIENvZGUgY2FuIGJpbmQgb24gW25ldmVyICgpXSwgc28gaWYgd2UgcmUtdXNlZCB0aGUgaXZhciwgd2UgY291bGQgZW5kbGVzc2x5XG4gICBhY2N1bXVsYXRlIGhhbmRsZXJzLiAqKVxubGV0IG5ldmVyICgpID0gSXZhci5yZWFkIChJdmFyLmNyZWF0ZSAoKSlcblxubW9kdWxlIE0gPSBNb25hZC5NYWtlIChzdHJ1Y3RcbiAgICBpbmNsdWRlIERlZmVycmVkMFxuXG4gICAgbGV0IG1hcCB0IH5mID1cbiAgICAgICgqIFdlIG1hbnVhbGx5IGlubGluZSBbRGVmZXJyZWQuY3JlYXRlXSBoZXJlLCBiZWNhdXNlIHRoZSBub24tZmxhbWJkYSBjb21waWxlciBpc24ndFxuICAgICAgICAgYWJsZSB0byBvcHRpbWl6ZSBhd2F5IHRoZSBjbG9zdXJlIHRoYXQgd291bGQgYmUgYmUgY3JlYXRlZC4gKilcbiAgICAgIGxldCByZXN1bHQgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICAgICAgdXBvbiB0IChmdW4gYSAtPiBJdmFyLmZpbGwgcmVzdWx0IChmIGEpKTtcbiAgICAgIG9mX2l2YXIgcmVzdWx0XG4gICAgOztcblxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmQpXG5cbmluY2x1ZGUgTVxuXG4oKiBXZSByZWJpbmQgYWxsIHRoZSB2YXJpb3VzIFtyZXR1cm5dcyBiZWNhdXNlIHRoZSB1c2Ugb2YgdGhlIFtNb25hZC5NYWtlXSBmdW5jdG9yXG4gICBjYXVzZXMgdGhlIGNvbXBpbGVyIHRvIG5vdCBpbmxpbmUgW3JldHVybl0sIGFuZCBoZW5jZSBtYWtlcyBpdCBpbXBvc3NpYmxlIHRvXG4gICBzdGF0aWNhbGx5IGFsbG9jYXRlIGNvbnN0YW50cyBsaWtlIFtyZXR1cm4gKCldLiAgQnkgcmViaW5kaW5nIFtyZXR1cm5dIGFzXG4gICBbRGVmZXJyZWQwLnJldHVybl0sIHRoZSBjb21waWxlciBjYW4gc2VlIHRoYXQ6XG5cbiAgIHtbXG4gICAgIHJldHVybiBhID0geyBJdmFyLkltbXV0YWJsZS4gY2VsbCA9IEZ1bGwgYSB9IF19XG5cbiAgIEFuZCBoZW5jZSwgaWYgW2FdIGlzIGNvbnN0YW50LCB0aGVuIHRoZSByZXR1cm4gaXMgY29uc3RhbnQgYW5kIGNhbiBiZSBzdGF0aWNhbGx5XG4gICBhbGxvY2F0ZWQuICBXaGVuIGNvbXBpbGluZyB3aXRoIGZsYW1iZGEsIHRoZSBjb21waWxlciBpbmxpbmVzIFtyZXR1cm5dIGFuZCB0aGlzIG1hbnVhbFxuICAgcmViaW5kaW5nIHdvdWxkIG5vdCBoZWxwOyB3ZSd2ZSBkZWNpZGVkIHRvIGRvIGl0IGFueXdheSBzbyB0aGF0IG5vbi1mbGFtYmRhIGJ1aWxkc1xuICAgZ2V0IHRoZSBvcHRpbWl6YXRpb24uICopXG5sZXQgcmV0dXJuID0gRGVmZXJyZWQwLnJldHVyblxuXG5tb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICBpbmNsdWRlIE0uTGV0X3N5bnRheFxuXG4gIGxldCByZXR1cm4gPSBEZWZlcnJlZDAucmV0dXJuXG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIE0uTGV0X3N5bnRheC5MZXRfc3ludGF4XG5cbiAgICBsZXQgcmV0dXJuID0gRGVmZXJyZWQwLnJldHVyblxuICBlbmRcbmVuZFxuXG5vcGVuIExldF9zeW50YXhcblxuKCogV2Ugc2hhZG93IFthbGxdIG9uLXB1cnBvc2UgaGVyZSwgc2luY2UgdGhlIGRlZmF1bHQgZGVmaW5pdGlvbiBpbnRyb2R1Y2VzIGEgY2hhaW4gb2ZcbiAgIGJpbmRzIGFzIGxvbmcgYXMgdGhlIGxpc3QuICopXG5sZXQgYWxsID0gYE1ha2Vfc3VyZV90b19kZWZpbmVfYWxsX2Vsc2V3aGVyZVxubGV0IF8gPSBhbGxcbmxldCB1bml0ID0gcmV0dXJuICgpXG5cbmxldCBib3RoIHQxIHQyID1cbiAgY3JlYXRlIChmdW4gcmVzdWx0IC0+IHVwb24gdDEgKGZ1biBhMSAtPiB1cG9uIHQyIChmdW4gYTIgLT4gSXZhci5maWxsIHJlc3VsdCAoYTEsIGEyKSkpKVxuOztcblxubW9kdWxlIEluZml4ID0gc3RydWN0XG4gIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICBsZXQgKCA+Pj4gKSA9IHVwb25cbiAgbGV0IHBweF9ib3RoID0gYm90aFxuZW5kXG5cbm9wZW4gSW5maXhcblxubGV0IGRvbid0X3dhaXRfZm9yIChfIDogdW5pdCB0KSA9ICgpXG5cbm1vZHVsZSBDaG9pY2UgPSBzdHJ1Y3RcbiAgdHlwZSArJ2EgdCA9IFQgOiAnYiBEZWZlcnJlZDAudCAqICgnYiAtPiAnYSkgLT4gJ2EgdFxuXG4gIGxldCBtYXAgKFQgKHQsIGYxKSkgfmY6ZjIgPSBUICh0LCBmdW4geCAtPiBmMiAoZjEgeCkpXG5lbmRcblxubW9kdWxlIFVucmVnaXN0ZXIgPSBzdHJ1Y3RcbiAgKCogVGhpcyByZXByZXNlbnRhdGlvbiBzYXZlcyAybiB3b3JkcyBmb3IgYSBsaXN0IG9mIG4gY2hvaWNlcy4gKilcbiAgdHlwZSB0ID1cbiAgICB8IE5pbCA6IHRcbiAgICB8IENvbnMgOiAnYSBEZWZlcnJlZDAudCAqICdhIERlZmVycmVkMC5IYW5kbGVyLnQgKiB0IC0+IHRcblxuICBsZXQgcmVjIHByb2Nlc3MgPSBmdW5jdGlvblxuICAgIHwgTmlsIC0+ICgpXG4gICAgfCBDb25zICh0LCBoYW5kbGVyLCByZXN0KSAtPlxuICAgICAgcmVtb3ZlX2hhbmRsZXIgdCBoYW5kbGVyO1xuICAgICAgcHJvY2VzcyByZXN0XG4gIDs7XG5lbmRcblxubGV0IGNob2ljZSB0IGYgPSBDaG9pY2UuVCAodCwgZilcblxubGV0IGVuYWJsZWQgY2hvaWNlcyA9XG4gIGxldCByZXN1bHQgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICBsZXQgdW5yZWdpc3RlcnMgPSByZWYgVW5yZWdpc3Rlci5OaWwgaW5cbiAgbGV0IHJlYWR5IF8gPVxuICAgIGlmIEl2YXIuaXNfZW1wdHkgcmVzdWx0XG4gICAgdGhlbiAoXG4gICAgICBVbnJlZ2lzdGVyLnByb2Nlc3MgIXVucmVnaXN0ZXJzO1xuICAgICAgSXZhci5maWxsIHJlc3VsdCAoZnVuICgpIC0+XG4gICAgICAgIExpc3QucmV2XG4gICAgICAgICAgKExpc3QuZm9sZCBjaG9pY2VzIH5pbml0OltdIH5mOihmdW4gYWMgKENob2ljZS5UICh0LCBmKSkgLT5cbiAgICAgICAgICAgICBtYXRjaCBwZWVrIHQgd2l0aFxuICAgICAgICAgICAgIHwgTm9uZSAtPiBhY1xuICAgICAgICAgICAgIHwgU29tZSB2IC0+IGYgdiA6OiBhYykpKSlcbiAgaW5cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gU2NoZWR1bGVyLihjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICh0ICgpKSkgaW5cbiAgdW5yZWdpc3RlcnNcbiAgOj0gTGlzdC5mb2xkIGNob2ljZXMgfmluaXQ6VW5yZWdpc3Rlci5OaWwgfmY6KGZ1biBhY2MgKENob2ljZS5UICh0LCBfKSkgLT5cbiAgICBDb25zICh0LCBEZWZlcnJlZDAuYWRkX2hhbmRsZXIgdCByZWFkeSBleGVjdXRpb25fY29udGV4dCwgYWNjKSk7XG4gIEl2YXIucmVhZCByZXN1bHRcbjs7XG5cbmxldCByZWMgY2hvb3NlX3Jlc3VsdCBjaG9pY2VzID1cbiAgbWF0Y2ggY2hvaWNlcyB3aXRoXG4gIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ2hvaWNlLlQgKHQsIGYpIDo6IGNob2ljZXMgLT5cbiAgICAobWF0Y2ggcGVlayB0IHdpdGhcbiAgICAgfCBOb25lIC0+IGNob29zZV9yZXN1bHQgY2hvaWNlc1xuICAgICB8IFNvbWUgdiAtPiBmIHYpXG47O1xuXG5sZXQgY2hvb3NlIGNob2ljZXMgPVxuICBsZXQgcmVzdWx0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgbGV0IHVucmVnaXN0ZXJzID0gcmVmIFVucmVnaXN0ZXIuTmlsIGluXG4gIGxldCByZWFkeSBfID1cbiAgICBpZiBJdmFyLmlzX2VtcHR5IHJlc3VsdFxuICAgIHRoZW4gKFxuICAgICAgVW5yZWdpc3Rlci5wcm9jZXNzICF1bnJlZ2lzdGVycztcbiAgICAgIEl2YXIuZmlsbCByZXN1bHQgKGNob29zZV9yZXN1bHQgY2hvaWNlcykpXG4gIGluXG4gIGxldCBleGVjdXRpb25fY29udGV4dCA9IFNjaGVkdWxlci4oY3VycmVudF9leGVjdXRpb25fY29udGV4dCAodCAoKSkpIGluXG4gIHVucmVnaXN0ZXJzXG4gIDo9IExpc3QuZm9sZCBjaG9pY2VzIH5pbml0OlVucmVnaXN0ZXIuTmlsIH5mOihmdW4gYWNjIChDaG9pY2UuVCAodCwgXykpIC0+XG4gICAgQ29ucyAodCwgRGVmZXJyZWQwLmFkZF9oYW5kbGVyIHQgcmVhZHkgZXhlY3V0aW9uX2NvbnRleHQsIGFjYykpO1xuICBJdmFyLnJlYWQgcmVzdWx0XG47O1xuXG5sZXQgYW55X2YgdHMgZiA9IGNob29zZSAoTGlzdC5tYXAgdHMgfmY6KGZ1biB0IC0+IGNob2ljZSB0IGYpKVxubGV0IGFueSB0cyA9IGFueV9mIHRzIEZuLmlkXG5sZXQgYW55X3VuaXQgdHMgPSBhbnlfZiB0cyAoRm4uaWdub3JlIDogdW5pdCAtPiB1bml0KVxuXG5sZXQgZm9yXyBzdGFydCB+dG9fIH5kb18gPVxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA+IHRvX1xuICAgIHRoZW4gcmV0dXJuICgpXG4gICAgZWxzZSAoXG4gICAgICBsZXQlYmluZCAoKSA9IGRvXyBpIGluXG4gICAgICBsb29wIChpICsgMSkpXG4gIGluXG4gIGxvb3Agc3RhcnRcbjs7XG5cbmxldCByZXBlYXRfdW50aWxfZmluaXNoZWQgc3RhdGUgZiA9XG4gIGNyZWF0ZSAoZnVuIGZpbmlzaGVkIC0+XG4gICAgbGV0IHJlYyBsb29wIHN0YXRlID1cbiAgICAgIGYgc3RhdGVcbiAgICAgID4+PiBmdW5jdGlvblxuICAgICAgfCBgUmVwZWF0IHN0YXRlIC0+IGxvb3Agc3RhdGVcbiAgICAgIHwgYEZpbmlzaGVkIHJlc3VsdCAtPiBJdmFyLmZpbGwgZmluaXNoZWQgcmVzdWx0XG4gICAgaW5cbiAgICBsb29wIHN0YXRlKVxuOztcblxubGV0IGZvcmV2ZXIgc3RhdGUgZiA9XG4gIHJlcGVhdF91bnRpbF9maW5pc2hlZCBzdGF0ZSAoZnVuIHN0YXRlIC0+XG4gICAgbGV0JW1hcCBzdGF0ZSA9IGYgc3RhdGUgaW5cbiAgICBgUmVwZWF0IHN0YXRlKVxuICA+Pj4gbmV2ZXJfcmV0dXJuc1xuOztcblxudHlwZSBob3cgPSBNb25hZF9zZXF1ZW5jZS5ob3cgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubW9kdWxlIHR5cGUgTW9uYWRfc2VxdWVuY2UgPSBNb25hZF9zZXF1ZW5jZS5TIHdpdGggdHlwZSAnYSBtb25hZCA6PSAnYSB0XG5cblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGNyZWF0ZSAoZnVuIHJlc3VsdCAtPlxuICAgIGxldCByZWMgbG9vcCB0IGIgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IEl2YXIuZmlsbCByZXN1bHQgYlxuICAgICAgfCB4IDo6IHhzIC0+IGYgYiB4ID4+PiBmdW4gYiAtPiBsb29wIHhzIGJcbiAgICBpblxuICAgIGxvb3AgdCBpbml0KVxuOztcblxubGV0IHNlcW1hcCB0IH5mID0gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gYnMgYSAtPiBmIGEgPj58IGZ1biBiIC0+IGIgOjogYnMpID4+fCBMaXN0LnJldlxubGV0IGFsbCBkcyA9IHNlcW1hcCBkcyB+ZjpGbi5pZFxubGV0IGFsbF91bml0IGRzID0gZm9sZCBkcyB+aW5pdDooKSB+ZjooZnVuICgpIGQgLT4gZClcbmxldCBvayB4ID0geCA+PnwgZnVuIHggLT4gT2sgeFxuIiwib3BlbiBEZWZlcnJlZDFcbmluY2x1ZGUgSW5maXhcbmluY2x1ZGUgTGV0X3N5bnRheFxuXG5sZXQgY2hvaWNlID0gY2hvaWNlXG5sZXQgY2hvb3NlID0gY2hvb3NlXG5sZXQgZG9uJ3Rfd2FpdF9mb3IgPSBkb24ndF93YWl0X2ZvclxubGV0IG5ldmVyID0gbmV2ZXJcbmxldCByZXR1cm4gPSByZXR1cm5cbmxldCB1cG9uID0gdXBvblxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5cbnR5cGUgJ2EgdSA9XG4gIHwgRW1wdHkgb2YgJ2EgSXZhci50XG4gIHwgRnVsbFxuW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxudHlwZSAnYSB0ID0gJ2EgdSByZWYgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCBfIHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IF8gdF0gKGZ1biAoKSAtPlxuICAgIG1hdGNoICF0IHdpdGhcbiAgICB8IEZ1bGwgLT4gKClcbiAgICB8IEVtcHR5IGl2YXIgLT4gYXNzZXJ0IChJdmFyLmlzX2VtcHR5IGl2YXIpKVxuOztcblxubGV0IGNyZWF0ZSAoKSA9XG4gIGxldCBpdmFyID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgbGV0IHQgPSByZWYgKEVtcHR5IGl2YXIpIGluXG4gIHQsIEl2YXIucmVhZCBpdmFyXG47O1xuXG5sZXQgaXNfZW1wdHkgdCA9XG4gIG1hdGNoICF0IHdpdGhcbiAgfCBFbXB0eSBfIC0+IHRydWVcbiAgfCBGdWxsIC0+IGZhbHNlXG47O1xuXG5sZXQgZmlsbCB0IGEgPVxuICBtYXRjaCAhdCB3aXRoXG4gIHwgRW1wdHkgaSAtPlxuICAgIHQgOj0gRnVsbDtcbiAgICBJdmFyLmZpbGwgaSBhXG4gIHwgRnVsbCAtPiByYWlzZV9zIFslbWVzc2FnZSBcImF0dGVtcHQgdG8gZmlsbCBmdWxsIGl2YXJcIl1cbjs7XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG5tb2R1bGUgU3RyZWFtID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIG5leHQgRGVmZXJyZWQudFxuXG4gIGFuZCAnYSBuZXh0ID0gJ2EgVHlwZXMuU3RyZWFtLm5leHQgPVxuICAgIHwgTmlsXG4gICAgfCBDb25zIG9mICdhICogJ2EgdFxuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPVxuICAgIGxldCByZWMgbG9vcCBkIGFjIDogU2V4cC50ID1cbiAgICAgIG1hdGNoIERlZmVycmVkLnBlZWsgZCB3aXRoXG4gICAgICB8IE5vbmUgLT4gTGlzdCAoTGlzdC5yZXYgKFNleHAuQXRvbSBcIi4uLlwiIDo6IGFjKSlcbiAgICAgIHwgU29tZSBOaWwgLT4gTGlzdCAoTGlzdC5yZXYgYWMpXG4gICAgICB8IFNvbWUgKENvbnMgKGEsIHQpKSAtPiBsb29wIHQgKHNleHBfb2ZfYSBhIDo6IGFjKVxuICAgIGluXG4gICAgbG9vcCB0IFtdXG4gIDs7XG5cbiAgbGV0IG5leHQgdCA9IHRcbmVuZFxuXG50eXBlICdhIHQgPSAnYSBUeXBlcy5UYWlsLnQgPVxuICB7ICgqIFtuZXh0XSBwb2ludHMgYXQgdGhlIHRhaWwgb2YgdGhlIHN0cmVhbSAqKSBtdXRhYmxlIG5leHQgOiAnYSBTdHJlYW0ubmV4dCBJdmFyLnQgfVxuW0BAZGVyaXZpbmcgZmllbGRzXVxuXG5sZXQgc2V4cF9vZl90IF8gdCA6IFNleHAudCA9XG4gIEF0b20gKGlmIEl2YXIuaXNfZW1wdHkgdC5uZXh0IHRoZW4gXCI8b3BlbiB0YWlsPlwiIGVsc2UgXCI8Y2xvc2VkIHRhaWw+XCIpXG47O1xuXG5sZXQgY3JlYXRlICgpID0geyBuZXh0ID0gSXZhci5jcmVhdGUgKCkgfVxubGV0IGNvbGxlY3QgdCA9IEl2YXIucmVhZCAobmV4dCB0KVxubGV0IGlzX2Nsb3NlZCB0ID0gSXZhci5pc19mdWxsIChuZXh0IHQpXG5cbmxldCBmaWxsX2V4biB0IHYgPVxuICBpZiBpc19jbG9zZWQgdCB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwic3RyZWFtIGlzIGNsb3NlZFwiXSBlbHNlIEl2YXIuZmlsbCAobmV4dCB0KSB2XG47O1xuXG5sZXQgY2xvc2VfZXhuIHQgPSBmaWxsX2V4biB0IE5pbFxubGV0IGNsb3NlX2lmX29wZW4gdCA9IGlmIG5vdCAoaXNfY2xvc2VkIHQpIHRoZW4gSXZhci5maWxsIChuZXh0IHQpIE5pbFxuXG5sZXQgZXh0ZW5kIHQgdiA9XG4gIGxldCBuZXh0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgZmlsbF9leG4gdCAoQ29ucyAodiwgSXZhci5yZWFkIG5leHQpKTtcbiAgdC5uZXh0IDwtIG5leHRcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5tb2R1bGUgU2NoZWR1bGVyID0gU2NoZWR1bGVyMVxubW9kdWxlIFN0cmVhbSA9IFRhaWwuU3RyZWFtXG5tb2R1bGUgTW9uaXRvciA9IE1vbml0b3IwXG5pbmNsdWRlIE1vbml0b3JcblxudHlwZSBtb25pdG9yID0gdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgaW52YXJpYW50IHQgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICBsZXQgY2hlY2sgZiA9IEludmFyaWFudC5jaGVja19maWVsZCB0IGYgaW5cbiAgICBGaWVsZHMuaXRlclxuICAgICAgfm5hbWU6aWdub3JlXG4gICAgICB+aGVyZTppZ25vcmVcbiAgICAgIH5pZDppZ25vcmVcbiAgICAgIH5mb3J3YXJkaW5nOmlnbm9yZVxuICAgICAgfm5leHRfZXJyb3I6KGNoZWNrIChmdW4gbmV4dF9lcnJvciAtPiBhc3NlcnQgKEl2YXIuaXNfZW1wdHkgbmV4dF9lcnJvcikpKVxuICAgICAgfmhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzOmlnbm9yZVxuICAgICAgfnRhaWxzX2Zvcl9hbGxfZXJyb3JzOmlnbm9yZVxuICAgICAgfmhhc19zZWVuX2Vycm9yOmlnbm9yZSlcbjs7XG5cbmxldCBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICgpID0gU2NoZWR1bGVyLihjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICh0ICgpKSlcbmxldCBjdXJyZW50ICgpID0gRXhlY3V0aW9uX2NvbnRleHQubW9uaXRvciAoY3VycmVudF9leGVjdXRpb25fY29udGV4dCAoKSlcblxudHlwZSAnYSB3aXRoX29wdGlvbmFsX21vbml0b3JfbmFtZSA9XG4gID9oZXJlOlNvdXJjZV9jb2RlX3Bvc2l0aW9uLnQgLT4gP2luZm86SW5mby50IC0+ID9uYW1lOnN0cmluZyAtPiAnYVxuXG5sZXQgZGV0YWNoIHQgPSB0LmZvcndhcmRpbmcgPC0gRGV0YWNoZWRcblxudHlwZSBoYW5kbGVyX3N0YXRlID1cbiAgfCBVbmluaXRpYWxpemVkXG4gIHwgUnVubmluZyBvZiAoRXhlY3V0aW9uX2NvbnRleHQudCAqIChleG4gLT4gdW5pdCkpIEJhZy5FbHQudFxuICB8IFRlcm1pbmF0ZWRcblxubGV0IGRldGFjaF9hbmRfaXRlcl9lcnJvcnMgdCB+ZiA9XG4gIGRldGFjaCB0O1xuICBsZXQgc2NoZWR1bGVyID0gU2NoZWR1bGVyLnQgKCkgaW5cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gU2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgc2NoZWR1bGVyIGluXG4gIGxldCBoYW5kbGVyX3N0YXRlX3JlZiA9IHJlZiBVbmluaXRpYWxpemVkIGluXG4gIGxldCBydW5fZiBleG4gPVxuICAgIG1hdGNoICFoYW5kbGVyX3N0YXRlX3JlZiB3aXRoXG4gICAgfCBVbmluaXRpYWxpemVkIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgVGVybWluYXRlZCAtPiAoKVxuICAgIHwgUnVubmluZyBiYWdfZWx0IC0+XG4gICAgICAodHJ5IGYgZXhuIHdpdGhcbiAgICAgICB8IGlubmVyX2V4biAtPlxuICAgICAgICAgaGFuZGxlcl9zdGF0ZV9yZWYgOj0gVGVybWluYXRlZDtcbiAgICAgICAgIEJhZy5yZW1vdmUgdC5oYW5kbGVyc19mb3JfYWxsX2Vycm9ycyBiYWdfZWx0O1xuICAgICAgICAgKCogW3J1bl9mXSBhbHdheXMgcnVucyBpbiBbZXhlY3V0aW9uX2NvbnRleHRdLiAgSGVuY2UsIFtyYWlzZSBpbm5lcl9leG5dIHNlbmRzXG4gICAgICAgICAgICBbaW5uZXJfZXhuXSB0byBbZXhlY3V0aW9uX2NvbnRleHRdJ3MgbW9uaXRvciwgaS5lLiB0aGUgbW9uaXRvciBpbiBlZmZlY3Qgd2hlblxuICAgICAgICAgICAgW2RldGFjaF9hbmRfaXRlcl9lcnJvcnNdIHdhcyBjYWxsZWQuICopXG4gICAgICAgICByYWlzZSBpbm5lcl9leG4pXG4gIGluXG4gIGhhbmRsZXJfc3RhdGVfcmVmXG4gIDo9IFJ1bm5pbmcgKEJhZy5hZGQgdC5oYW5kbGVyc19mb3JfYWxsX2Vycm9ycyAoZXhlY3V0aW9uX2NvbnRleHQsIHJ1bl9mKSlcbjs7XG5cbmxldCBkZXRhY2hfYW5kX2dldF9lcnJvcl9zdHJlYW0gdCA9XG4gIGRldGFjaCB0O1xuICBsZXQgdGFpbCA9IFRhaWwuY3JlYXRlICgpIGluXG4gIHQudGFpbHNfZm9yX2FsbF9lcnJvcnMgPC0gdGFpbCA6OiB0LnRhaWxzX2Zvcl9hbGxfZXJyb3JzO1xuICBUYWlsLmNvbGxlY3QgdGFpbFxuOztcblxubGV0IGdldF9uZXh0X2Vycm9yIHQgPSBJdmFyLnJlYWQgdC5uZXh0X2Vycm9yXG5cbmxldCBkZXRhY2hfYW5kX2dldF9uZXh0X2Vycm9yIHQgPVxuICBkZXRhY2ggdDtcbiAgZ2V0X25leHRfZXJyb3IgdFxuOztcblxubGV0IGNyZWF0ZSA/aGVyZSA/aW5mbyA/bmFtZSAoKSA9XG4gIGxldCBwYXJlbnQgPSBjdXJyZW50ICgpIGluXG4gIGNyZWF0ZV93aXRoX3BhcmVudCA/aGVyZSA/aW5mbyA/bmFtZSAoU29tZSBwYXJlbnQpXG47O1xuXG5tb2R1bGUgTW9uaXRvcl9leG4gPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGV4biA6IGV4blxuICAgIDsgYmFja3RyYWNlIDogQmFja3RyYWNlLnQgb3B0aW9uXG4gICAgOyBiYWNrdHJhY2VfaGlzdG9yeSA6IEJhY2t0cmFjZS50IGxpc3RcbiAgICA7IG1vbml0b3IgOiBNb25pdG9yLnRcbiAgICB9XG5cbiAgbGV0IGJhY2t0cmFjZSB0ID0gdC5iYWNrdHJhY2VcbiAgbGV0IGV4dHJhY3RfZXhuIHQgPSB0LmV4blxuXG4gIGxldCBiYWNrdHJhY2VfdHJ1bmNhdGlvbl9oZXVyaXN0aWNzID1cbiAgICBsZXQgam9iX3F1ZXVlID0gXCJDYWxsZWQgZnJvbSBmaWxlIFxcXCJqb2JfcXVldWUubWxcXFwiXCIgaW5cbiAgICBsZXQgZGVmZXJyZWQwID0gXCJDYWxsZWQgZnJvbSBmaWxlIFxcXCJkZWZlcnJlZDAubWxcXFwiXCIgaW5cbiAgICBsZXQgZGVmZXJyZWQxID0gXCJDYWxsZWQgZnJvbSBmaWxlIFxcXCJkZWZlcnJlZDEubWxcXFwiXCIgaW5cbiAgICBsZXQgbW9uaXRvciA9IFwiQ2FsbGVkIGZyb20gZmlsZSBcXFwibW9uaXRvci5tbFxcXCJcIiBpblxuICAgIGxldCBpbXBvcnQwID0gXCJSYWlzZWQgYXQgZmlsZSBcXFwiaW1wb3J0MC5tbFxcXCJcIiBpblxuICAgIGxldCBlcnJvciA9IFwiQ2FsbGVkIGZyb20gZmlsZSBcXFwiZXJyb3IubWxcXFwiXCIgaW5cbiAgICBmdW4gdHJhY2VzIC0+XG4gICAgICAoKiAuLi90ZXN0L3Rlc3RfdHJ5X3dpdGhfZXJyb3JfZGlzcGxheS5tbCBtYWtlcyBzdXJlIHRoaXMgc3RheXMgdXAtdG8tZGF0ZS4gKilcbiAgICAgIGxldCB0cmFjZXMgPVxuICAgICAgICBtYXRjaCB0cmFjZXMgd2l0aFxuICAgICAgICB8IHQxIDo6IHJlc3Qgd2hlbiBTdHJpbmcuaXNfcHJlZml4IHQxIH5wcmVmaXg6aW1wb3J0MCAtPlxuICAgICAgICAgIChtYXRjaCByZXN0IHdpdGhcbiAgICAgICAgICAgfCB0MiA6OiByZXN0IHdoZW4gU3RyaW5nLmlzX3ByZWZpeCB0MiB+cHJlZml4OmVycm9yIC0+XG4gICAgICAgICAgICAgKG1hdGNoIHJlc3Qgd2l0aFxuICAgICAgICAgICAgICB8IHQzIDo6IHJlc3Qgd2hlbiBTdHJpbmcuaXNfcHJlZml4IHQzIH5wcmVmaXg6ZXJyb3IgLT4gcmVzdFxuICAgICAgICAgICAgICB8IF8gLT4gcmVzdClcbiAgICAgICAgICAgfCBfIC0+IHJlc3QpXG4gICAgICAgIHwgXyAtPiB0cmFjZXNcbiAgICAgIGluXG4gICAgICBtYXRjaCBMaXN0LnJldiB0cmFjZXMgd2l0aFxuICAgICAgfCB0MSA6OiByZXN0IHdoZW4gU3RyaW5nLmlzX3ByZWZpeCB0MSB+cHJlZml4OmpvYl9xdWV1ZSAtPlxuICAgICAgICAobWF0Y2ggcmVzdCB3aXRoXG4gICAgICAgICB8IHQyIDo6IHJlc3Qgd2hlbiBTdHJpbmcuaXNfcHJlZml4IHQyIH5wcmVmaXg6am9iX3F1ZXVlIC0+XG4gICAgICAgICAgIChtYXRjaCByZXN0IHdpdGhcbiAgICAgICAgICAgIHwgdDIgOjogcmVzdFxuICAgICAgICAgICAgICB3aGVuIFN0cmluZy5pc19wcmVmaXggdDIgfnByZWZpeDpkZWZlcnJlZDBcbiAgICAgICAgICAgICAgICAoKiBiaW5kICopXG4gICAgICAgICAgICAgICAgfHwgU3RyaW5nLmlzX3ByZWZpeCB0MiB+cHJlZml4OmRlZmVycmVkMVxuICAgICAgICAgICAgICAgICgqIG1hcCAqKVxuICAgICAgICAgICAgICAgIHx8IFN0cmluZy5pc19wcmVmaXggdDIgfnByZWZpeDptb25pdG9yXG4gICAgICAgICAgICAgICgqIHRyeV93aXRoICopIC0+IExpc3QucmV2IHJlc3RcbiAgICAgICAgICAgIHwgXyAtPiBMaXN0LnJldiByZXN0KVxuICAgICAgICAgfCBfIC0+IExpc3QucmV2IHJlc3QpXG4gICAgICB8IF8gLT4gdHJhY2VzXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCB7IGV4bjsgYmFja3RyYWNlOyBiYWNrdHJhY2VfaGlzdG9yeTsgbW9uaXRvciB9ID1cbiAgICBsZXQgbW9uaXRvciA9XG4gICAgICBsZXQgbmFtZSA9XG4gICAgICAgIG1hdGNoIEluZm8udG9fc3RyaW5nX2h1bSBtb25pdG9yLm5hbWUgd2l0aFxuICAgICAgICB8IFwiXCIgLT4gTm9uZVxuICAgICAgICB8IHMgLT4gU29tZSBzXG4gICAgICBpblxuICAgICAgbGV0IHBvcyA9XG4gICAgICAgIG1hdGNoIG1vbml0b3IuaGVyZSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgIHwgU29tZSBoZXJlIC0+XG4gICAgICAgICAgKCogV2UgZGlzcGxheSB0aGUgZnVsbCBmaWxlbmFtZSwgd2hlcmVhcyBiYWNrdHJhY2VzIG9ubHkgaGF2ZSBiYXNlbmFtZXMsIGJ1dFxuICAgICAgICAgICAgIHBlcmhhcHMgdGhhdCdzIHdoYXQgc2hvdWxkIGNoYW5nZS4gKilcbiAgICAgICAgICBsZXQgY29sdW1uID0gaGVyZS5wb3NfY251bSAtIGhlcmUucG9zX2JvbCBpblxuICAgICAgICAgIFNvbWVcbiAgICAgICAgICAgICgqIFdlIGhpZGUgbGluZSBhbmQgY29sdW1uIG51bWJlcnMgd2hlbiBbYW1fcnVubmluZ190ZXN0XSB0byBtYWtlIHRlc3Qgb3V0cHV0XG4gICAgICAgICAgICAgICBtb3JlIHJvYnVzdC4gIFRoaXMgc2F2ZXMgcGVvcGxlIG1hbnVhbGx5IGhpZGluZyB0aGUgbnVtYmVycyBvciBldmVuIHdvcnNlLFxuICAgICAgICAgICAgICAgbGVhdmluZyB0aGVtIGluIHRlc3Qgb3V0cHV0LiAgSGlkaW5nIGluIHRlc3QgaXMgZGlmZmVyZW50IGNob2ljZSBmb3JcbiAgICAgICAgICAgICAgIGJlaGF2aW9yIHRoYW4gb3VyIGNvZGViYXNlIG1ha2VzIGZvciBbQmFja3RyYWNlLmVsaWRlXSwgd2hpY2ggaGFzIGRlZmF1bHRcbiAgICAgICAgICAgICAgIFtmYWxzZV0sIGFuZCB0aHVzIHNob3dzIGJhY2t0cmFjZXMgaW4gdGVzdC4gIFRoZXJlIGFyZSBhIGNvdXBsZSByZWFzb25zIGZvclxuICAgICAgICAgICAgICAgdGhpcyBkaWZmZXJlbnQgY2hvaWNlLiAgRmlyc3QsIGV4cGVjdC10ZXN0IG1hY2hpbmVyeSBoYXMgY2hlY2sgdG8gcHJldmVudFxuICAgICAgICAgICAgICAgYmFja3RyYWNlcyBmcm9tIGFwcGVhcmluZyBpbiB0ZXN0IG91dHB1dC4gIEl0IGhhcyBubyBzdWNoIGNoZWNrcyBmb3IgbGluZVxuICAgICAgICAgICAgICAgYW5kIGNvbHVtbiBudW1iZXJzLiAgU2Vjb25kLCB3aGVuIHRoZXJlIGlzIGEgcmVhbCBlcnJvciBhbmQgeW91IHdhbnQgdG8gc2VlXG4gICAgICAgICAgICAgICB0aGUgYmFja3RyYWNlLCB0aHJvd2luZyBhd2F5IHRoZSB3aG9sZSBiYWNrdHJhY2UgbG9zZXMgYSBsb3Qgb2YgcG90ZW50aWFsbHlcbiAgICAgICAgICAgICAgIHVzZWZ1bCBpbmZvcm1hdGlvbiB0aGF0IG1heSBiZSBoYXJkIHRvIHJlY292ZXIuICBXaGVyZWFzIHdlJ3JlIGp1c3RcbiAgICAgICAgICAgICAgIHRocm93aW5nIGEgd2F5IGEgbGluZSBudW1iZXIgYW5kIGNvbHVtbiwgd2hpY2ggYXJlIGEgbWlub3IgY29udmVuaWVuY2VcbiAgICAgICAgICAgICAgIGdpdmVuIHRoYXQgdGhlIGZpbGVuYW1lIGhhcyBtb3N0IG9mIHRoZSBpbmZvcm1hdGlvbi4gKilcbiAgICAgICAgICAgIChpZiBhbV9ydW5uaW5nX3Rlc3RcbiAgICAgICAgICAgICB0aGVuIHNwcmludGYgXCJmaWxlICVTLCBsaW5lIExJTkUsIGNoYXJhY3RlcnMgQzEtQzJcIiBoZXJlLnBvc19mbmFtZVxuICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgIHNwcmludGZcbiAgICAgICAgICAgICAgICAgXCJmaWxlICVTLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkXCJcbiAgICAgICAgICAgICAgICAgaGVyZS5wb3NfZm5hbWVcbiAgICAgICAgICAgICAgICAgaGVyZS5wb3NfbG51bVxuICAgICAgICAgICAgICAgICBjb2x1bW5cbiAgICAgICAgICAgICAgICAgY29sdW1uKVxuICAgICAgaW5cbiAgICAgIG1hdGNoIHBvcywgbmFtZSB3aXRoXG4gICAgICB8IE5vbmUsIE5vbmUgLT4gW11cbiAgICAgIHwgU29tZSBwb3MsIE5vbmUgLT4gWyBzcHJpbnRmIFwiQ2F1Z2h0IGJ5IG1vbml0b3IgYXQgJXNcIiBwb3MgXVxuICAgICAgfCBOb25lLCBTb21lIG5hbWUgLT4gWyBzcHJpbnRmIFwiQ2F1Z2h0IGJ5IG1vbml0b3IgJXNcIiBuYW1lIF1cbiAgICAgIHwgU29tZSBwb3MsIFNvbWUgbmFtZSAtPiBbIHNwcmludGYgXCJDYXVnaHQgYnkgbW9uaXRvciAlcyBhdCAlc1wiIG5hbWUgcG9zIF1cbiAgICBpblxuICAgIGxldCBiYWNrdHJhY2UgPVxuICAgICAgbGV0IGJhY2t0cmFjZSA9XG4gICAgICAgIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBbXVxuICAgICAgICB8IFNvbWUgYmFja3RyYWNlIC0+IEJhY2t0cmFjZS50b19zdHJpbmdfbGlzdCBiYWNrdHJhY2VcbiAgICAgIGluXG4gICAgICBiYWNrdHJhY2VfdHJ1bmNhdGlvbl9oZXVyaXN0aWNzIGJhY2t0cmFjZSBAIG1vbml0b3JcbiAgICBpblxuICAgIGxldCBsaXN0X2lmX25vdF9lbXB0eSA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IE5vbmVcbiAgICAgIHwgXyA6OiBfIGFzIGwgLT4gU29tZSBsXG4gICAgaW5cbiAgICBbJXNleHBcbiAgICAgIChleG4gOiBleG4pXG4gICAgLCAobGlzdF9pZl9ub3RfZW1wdHkgYmFja3RyYWNlIDogKHN0cmluZyBsaXN0IG9wdGlvbltAc2V4cC5vcHRpb25dKSlcbiAgICAsIGBiYWNrdHJhY2VfaGlzdG9yeVxuICAgICAgICAobGlzdF9pZl9ub3RfZW1wdHkgYmFja3RyYWNlX2hpc3RvcnkgOiAoQmFja3RyYWNlLnQgbGlzdCBvcHRpb25bQHNleHAub3B0aW9uXSkpXVxuICA7O1xuZW5kXG5cbmV4Y2VwdGlvbiBNb25pdG9yX2V4biBvZiBNb25pdG9yX2V4bi50XG5cbmxldCAoKSA9XG4gIFNleHBsaWIuQ29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBNb25pdG9yX2V4bl0gKGZ1bmN0aW9uXG4gICAgfCBNb25pdG9yX2V4biB0IC0+IFslc2V4cCBcIm1vbml0b3IubWwuRXJyb3JcIiA6OiAodCA6IE1vbml0b3JfZXhuLnQpXVxuICAgIHwgXyAtPlxuICAgICAgKCogUmVhY2hpbmcgdGhpcyBicmFuY2ggaW5kaWNhdGVzIGEgYnVnIGluIHNleHBsaWIuICopXG4gICAgICBhc3NlcnQgZmFsc2UpXG47O1xuXG5sZXQgZXh0cmFjdF9leG4gZXhuID1cbiAgbWF0Y2ggZXhuIHdpdGhcbiAgfCBNb25pdG9yX2V4biBlcnJvciAtPiBlcnJvci5leG5cbiAgfCBleG4gLT4gZXhuXG47O1xuXG5sZXQgc2VuZF9leG4gdCA/KGJhY2t0cmFjZSA9IGBHZXQpIGV4biA9XG4gIGxldCBleG4gPVxuICAgIG1hdGNoIGV4biB3aXRoXG4gICAgfCBNb25pdG9yX2V4biBfIC0+IGV4blxuICAgIHwgXyAtPlxuICAgICAgbGV0IGJhY2t0cmFjZSA9XG4gICAgICAgIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gICAgICAgIHwgYEdldCAtPiBCYWNrdHJhY2UuRXhuLm1vc3RfcmVjZW50X2Zvcl9leG4gZXhuXG4gICAgICAgIHwgYFRoaXMgYiAtPiBTb21lIGJcbiAgICAgIGluXG4gICAgICBsZXQgYmFja3RyYWNlX2hpc3RvcnkgPSAoY3VycmVudF9leGVjdXRpb25fY29udGV4dCAoKSkuYmFja3RyYWNlX2hpc3RvcnkgaW5cbiAgICAgIE1vbml0b3JfZXhuIHsgTW9uaXRvcl9leG4uZXhuOyBiYWNrdHJhY2U7IGJhY2t0cmFjZV9oaXN0b3J5OyBtb25pdG9yID0gdCB9XG4gIGluXG4gIGlmIERlYnVnLm1vbml0b3Jfc2VuZF9leG4gdGhlbiBEZWJ1Zy5sb2cgXCJNb25pdG9yLnNlbmRfZXhuXCIgKHQsIGV4bikgWyVzZXhwX29mOiB0ICogZXhuXTtcbiAgdC5oYXNfc2Vlbl9lcnJvciA8LSB0cnVlO1xuICBsZXQgc2NoZWR1bGVyID0gU2NoZWR1bGVyLnQgKCkgaW5cbiAgbGV0IHJlYyBsb29wIHQgPVxuICAgIEl2YXIuZmlsbCB0Lm5leHRfZXJyb3IgZXhuO1xuICAgIHQubmV4dF9lcnJvciA8LSBJdmFyLmNyZWF0ZSAoKTtcbiAgICBtYXRjaCB0LmZvcndhcmRpbmcgd2l0aFxuICAgIHwgRGV0YWNoZWQgLT5cbiAgICAgIGlmIERlYnVnLm1vbml0b3Jfc2VuZF9leG5cbiAgICAgIHRoZW5cbiAgICAgICAgRGVidWcubG9nIFwiTW9uaXRvci5zZW5kX2V4biBmb3VuZCBsaXN0ZW5pbmcgbW9uaXRvclwiICh0LCBleG4pIFslc2V4cF9vZjogdCAqIGV4bl07XG4gICAgICBCYWcuaXRlciB0LmhhbmRsZXJzX2Zvcl9hbGxfZXJyb3JzIH5mOihmdW4gKGV4ZWN1dGlvbl9jb250ZXh0LCBmKSAtPlxuICAgICAgICBTY2hlZHVsZXIuZW5xdWV1ZSBzY2hlZHVsZXIgZXhlY3V0aW9uX2NvbnRleHQgZiBleG4pO1xuICAgICAgTGlzdC5pdGVyIHQudGFpbHNfZm9yX2FsbF9lcnJvcnMgfmY6KGZ1biB0YWlsIC0+IFRhaWwuZXh0ZW5kIHRhaWwgZXhuKVxuICAgIHwgUGFyZW50IHBhcmVudCAtPiBsb29wIHBhcmVudFxuICAgIHwgUmVwb3J0X3VuY2F1Z2h0X2V4biAtPlxuICAgICAgKCogRG8gbm90IGNoYW5nZSB0aGlzIGJyYW5jaCB0byBwcmludCB0aGUgZXhjZXB0aW9uIG9yIHRvIGV4aXQuICBIYXZpbmcgdGhlXG4gICAgICAgICBzY2hlZHVsZXIgcmFpc2UgYW4gdW5jYXVnaHQgZXhjZXB0aW9uIGlzIHRoZSBuZWNlc3NhcnkgYmVoYXZpb3IgZm9yIHByb2dyYW1zXG4gICAgICAgICB0aGF0IGNhbGwgW1NjaGVkdWxlci5nb10gYW5kIHdhbnQgdG8gaGFuZGxlIGl0LiAqKVxuICAgICAgU2NoZWR1bGVyLihnb3RfdW5jYXVnaHRfZXhuICh0ICgpKSkgZXhuICghQXN5bmNfa2VybmVsX2NvbmZpZy50YXNrX2lkICgpKVxuICBpblxuICBsb29wIHRcbjs7XG5cbm1vZHVsZSBFeHBvcnRlZF9mb3Jfc2NoZWR1bGVyID0gc3RydWN0XG4gIGxldCB3aXRoaW5fY29udGV4dCBjb250ZXh0IGYgPVxuICAgIFNjaGVkdWxlci4od2l0aF9leGVjdXRpb25fY29udGV4dCAodCAoKSkpIGNvbnRleHQgfmY6KGZ1biAoKSAtPlxuICAgICAgbWF0Y2ggUmVzdWx0LnRyeV93aXRoIGYgd2l0aFxuICAgICAgfCBPayB4IC0+IE9rIHhcbiAgICAgIHwgRXJyb3IgZXhuIC0+XG4gICAgICAgIHNlbmRfZXhuIChFeGVjdXRpb25fY29udGV4dC5tb25pdG9yIGNvbnRleHQpIGV4biB+YmFja3RyYWNlOmBHZXQ7XG4gICAgICAgIEVycm9yICgpKVxuICA7O1xuXG4gIHR5cGUgJ2Egd2l0aF9vcHRpb25zID0gP21vbml0b3I6dCAtPiA/cHJpb3JpdHk6UHJpb3JpdHkudCAtPiAnYVxuXG4gIGxldCB3aXRoaW5fZ2VuID9tb25pdG9yID9wcmlvcml0eSBmID1cbiAgICBsZXQgdG1wX2NvbnRleHQgPVxuICAgICAgRXhlY3V0aW9uX2NvbnRleHQuY3JlYXRlX2xpa2UgKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKCkpID9tb25pdG9yID9wcmlvcml0eVxuICAgIGluXG4gICAgd2l0aGluX2NvbnRleHQgdG1wX2NvbnRleHQgZlxuICA7O1xuXG4gIGxldCB3aXRoaW4nID9tb25pdG9yID9wcmlvcml0eSBmID1cbiAgICBtYXRjaCB3aXRoaW5fZ2VuID9tb25pdG9yID9wcmlvcml0eSBmIHdpdGhcbiAgICB8IEVycm9yICgpIC0+IERlZmVycmVkLm5ldmVyICgpXG4gICAgfCBPayBkIC0+IGRcbiAgOztcblxuICBsZXQgd2l0aGluX3YgP21vbml0b3IgP3ByaW9yaXR5IGYgPVxuICAgIG1hdGNoIHdpdGhpbl9nZW4gP21vbml0b3IgP3ByaW9yaXR5IGYgd2l0aFxuICAgIHwgRXJyb3IgKCkgLT4gTm9uZVxuICAgIHwgT2sgeCAtPiBTb21lIHhcbiAgOztcblxuICBsZXQgd2l0aGluID9tb25pdG9yID9wcmlvcml0eSBmID1cbiAgICBtYXRjaCB3aXRoaW5fZ2VuID9tb25pdG9yID9wcmlvcml0eSBmIHdpdGhcbiAgICB8IEVycm9yICgpIC0+ICgpXG4gICAgfCBPayAoKSAtPiAoKVxuICA7O1xuXG4gIGxldCBzY2hlZHVsZV93aXRoX2RhdGEgP21vbml0b3IgP3ByaW9yaXR5IHdvcmsgeCA9XG4gICAgbGV0IHNjaGVkdWxlciA9IFNjaGVkdWxlci50ICgpIGluXG4gICAgU2NoZWR1bGVyLmVucXVldWVcbiAgICAgIHNjaGVkdWxlclxuICAgICAgKEV4ZWN1dGlvbl9jb250ZXh0LmNyZWF0ZV9saWtlXG4gICAgICAgICAoU2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgc2NoZWR1bGVyKVxuICAgICAgICAgP21vbml0b3JcbiAgICAgICAgID9wcmlvcml0eSlcbiAgICAgIHdvcmtcbiAgICAgIHhcbiAgOztcblxuICBsZXQgc2NoZWR1bGUgP21vbml0b3IgP3ByaW9yaXR5IHdvcmsgPSBzY2hlZHVsZV93aXRoX2RhdGEgP21vbml0b3IgP3ByaW9yaXR5IHdvcmsgKClcblxuICBsZXQgc2NoZWR1bGUnID1cbiAgICAoKiBGb3IgcGVyZm9ybWFuY2UsIHdlIHVzZSBbc2NoZWR1bGVfd2l0aF9kYXRhXSB3aXRoIGEgY2xvc2VkIGZ1bmN0aW9uLCBhbmQgaW5saW5lXG4gICAgICAgW0RlZmVycmVkLmNyZWF0ZV0uICopXG4gICAgbGV0IHVwb25fd29ya19maWxsX2kgKHdvcmssIGkpID0gdXBvbiAod29yayAoKSkgKGZ1biBhIC0+IEl2YXIuZmlsbCBpIGEpIGluXG4gICAgZnVuID9tb25pdG9yID9wcmlvcml0eSB3b3JrIC0+XG4gICAgICBsZXQgaSA9IEl2YXIuY3JlYXRlICgpIGluXG4gICAgICBzY2hlZHVsZV93aXRoX2RhdGEgP21vbml0b3IgP3ByaW9yaXR5IHVwb25fd29ya19maWxsX2kgKHdvcmssIGkpO1xuICAgICAgSXZhci5yZWFkIGlcbiAgOztcblxuICBsZXQgcHJlc2VydmVfZXhlY3V0aW9uX2NvbnRleHQgZiA9XG4gICAgbGV0IHNjaGVkdWxlciA9IFNjaGVkdWxlci50ICgpIGluXG4gICAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gU2NoZWR1bGVyLmN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgc2NoZWR1bGVyIGluXG4gICAgc3RhZ2UgKGZ1biBhIC0+IFNjaGVkdWxlci5lbnF1ZXVlIHNjaGVkdWxlciBleGVjdXRpb25fY29udGV4dCBmIGEpXG4gIDs7XG5cbiAgbGV0IHByZXNlcnZlX2V4ZWN1dGlvbl9jb250ZXh0JyBmID1cbiAgICBsZXQgc2NoZWR1bGVyID0gU2NoZWR1bGVyLnQgKCkgaW5cbiAgICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPSBTY2hlZHVsZXIuY3VycmVudF9leGVjdXRpb25fY29udGV4dCBzY2hlZHVsZXIgaW5cbiAgICBsZXQgY2FsbF9hbmRfZmlsbCAoZiwgYSwgaSkgPSB1cG9uIChmIGEpIChmdW4gciAtPiBJdmFyLmZpbGwgaSByKSBpblxuICAgIHN0YWdlIChmdW4gYSAtPlxuICAgICAgRGVmZXJyZWQuY3JlYXRlIChmdW4gaSAtPlxuICAgICAgICBTY2hlZHVsZXIuZW5xdWV1ZSBzY2hlZHVsZXIgZXhlY3V0aW9uX2NvbnRleHQgY2FsbF9hbmRfZmlsbCAoZiwgYSwgaSkpKVxuICA7O1xuZW5kXG5cbm9wZW4gRXhwb3J0ZWRfZm9yX3NjaGVkdWxlclxuXG5sZXQgc3RyZWFtX2l0ZXIgc3RyZWFtIH5mID1cbiAgbGV0IHJlYyBsb29wIHN0cmVhbSA9XG4gICAgU3RyZWFtLm5leHQgc3RyZWFtXG4gICAgPj4+IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgKHYsIHN0cmVhbSkgLT5cbiAgICAgIGxvb3Agc3RyZWFtO1xuICAgICAgZiB2XG4gIGluXG4gIGxvb3Agc3RyZWFtXG47O1xuXG4oKiBBbiBbJ2EgT2tfYW5kX2V4bnMudF0gcmVwcmVzZW50cyB0aGUgb3V0cHV0IG9mIGEgY29tcHV0YXRpb24gcnVubmluZyBpbiBhIGRldGFjaGVkXG4gICBtb25pdG9yLiAqKVxubW9kdWxlIE9rX2FuZF9leG5zID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBvayA6ICdhIERlZmVycmVkLnRcbiAgICA7IGV4bnMgOiBleG4gU3RyZWFtLnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxuICBsZXQgY3JlYXRlID9oZXJlID9pbmZvID9uYW1lIH5ydW4gZiA9XG4gICAgKCogV2UgY2FsbCBbY3JlYXRlX3dpdGhfcGFyZW50IE5vbmVdIGJlY2F1c2UgW21vbml0b3JdIGRvZXMgbm90IG5lZWQgYSBwYXJlbnQuICBJdFxuICAgICAgIGRvZXMgbm90IGJlY2F1c2Ugd2UgY2FsbCBbZGV0YWNoX2FuZF9nZXRfZXJyb3Jfc3RyZWFtIG1vbml0b3JdIGFuZCBkZWFsIHdpdGggdGhlXG4gICAgICAgZXJyb3JzIGV4cGxpY2l0bHksIHRodXMgW3NlbmRfZXhuXSB3b3VsZCBuZXZlciBwcm9wYWdhdGUgYW4gZXhuIHBhc3QgW21vbml0b3JdLiAqKVxuICAgIGxldCBtb25pdG9yID0gY3JlYXRlX3dpdGhfcGFyZW50ID9oZXJlID9pbmZvID9uYW1lIE5vbmUgaW5cbiAgICBsZXQgZXhucyA9IGRldGFjaF9hbmRfZ2V0X2Vycm9yX3N0cmVhbSBtb25pdG9yIGluXG4gICAgbGV0IG9rID1cbiAgICAgIG1hdGNoIHJ1biB3aXRoXG4gICAgICB8IGBOb3cgLT4gd2l0aGluJyB+bW9uaXRvciBmXG4gICAgICB8IGBTY2hlZHVsZSAtPiBzY2hlZHVsZScgfm1vbml0b3IgZlxuICAgIGluXG4gICAgeyBvazsgZXhucyB9XG4gIDs7XG5lbmRcblxubGV0IGZpbGxfcmVzdWx0X2FuZF9oYW5kbGVfYmFja2dyb3VuZF9lcnJvcnNcbiAgICAgIHJlc3VsdF9maWxsZXJcbiAgICAgIHJlc3VsdFxuICAgICAgZXhuc1xuICAgICAgaGFuZGxlX2V4bnNfYWZ0ZXJfcmVzdWx0XG4gID1cbiAgaWYgSXZhcl9maWxsZXIuaXNfZW1wdHkgcmVzdWx0X2ZpbGxlclxuICB0aGVuIChcbiAgICBJdmFyX2ZpbGxlci5maWxsIHJlc3VsdF9maWxsZXIgcmVzdWx0O1xuICAgIGhhbmRsZV9leG5zX2FmdGVyX3Jlc3VsdCBleG5zKVxuOztcblxubW9kdWxlIEV4cGVydCA9IHN0cnVjdFxuICBsZXQgdHJ5X3dpdGhfbG9nX2V4biA6IChleG4gLT4gdW5pdCkgcmVmID1cbiAgICByZWYgKGZ1biBleG4gLT5cbiAgICAgIHJhaXNlX3MgWyVtZXNzYWdlIFwiZmFpbGVkIHRvIHNldCBbTW9uaXRvci5FeHBlcnQudHJ5X3dpdGhfbG9nX2V4bl1cIiAoZXhuIDogRXhuLnQpXSlcbiAgOztcbmVuZFxuXG5sZXQgbWFrZV9oYW5kbGVfZXhuIHJlc3QgPVxuICBtYXRjaCByZXN0IHdpdGhcbiAgfCBgTG9nIC0+XG4gICAgKCogV2UgYXJlIGNhcmVmdWwgdG8gbm90IGNsb3NlIG92ZXIgY3VycmVudCBjb250ZXh0LCB3aGljaCBpcyBub3QgbmVlZGVkLiAqKVxuICAgICFFeHBlcnQudHJ5X3dpdGhfbG9nX2V4blxuICB8IGBSYWlzZSAtPlxuICAgIGxldCBwYXJlbnQgPSBjdXJyZW50ICgpIGluXG4gICAgZnVuIGV4biAtPiBzZW5kX2V4biBwYXJlbnQgZXhuID9iYWNrdHJhY2U6Tm9uZVxuICB8IGBDYWxsIGYgLT5cbiAgICBsZXQgcGFyZW50ID0gY3VycmVudCAoKSBpblxuICAgIGZ1biBleG4gLT4gd2l0aGluIH5tb25pdG9yOnBhcmVudCAoZnVuICgpIC0+IGYgZXhuKVxuOztcblxubGV0IHRyeV93aXRoXG4gICAgICA/aGVyZVxuICAgICAgP2luZm9cbiAgICAgID8obmFtZSA9IFwiXCIpXG4gICAgICA/ZXh0cmFjdF9leG46KGRvX2V4dHJhY3RfZXhuID0gZmFsc2UpXG4gICAgICA/KHJ1biA9IGBOb3cpXG4gICAgICA/KHJlc3QgPSBgUmFpc2UpXG4gICAgICBmXG4gID1cbiAgbGV0IHsgT2tfYW5kX2V4bnMub2s7IGV4bnMgfSA9IE9rX2FuZF9leG5zLmNyZWF0ZSA/aGVyZSA/aW5mbyB+bmFtZSB+cnVuIGYgaW5cbiAgbGV0IGhhbmRsZV9leG4gPSBtYWtlX2hhbmRsZV9leG4gcmVzdCBpblxuICBsZXQgaGFuZGxlX2V4bnNfYWZ0ZXJfcmVzdWx0IGV4bnMgPSBzdHJlYW1faXRlciBleG5zIH5mOmhhbmRsZV9leG4gaW5cbiAgKCogV2UgcnVuIFt3aXRoaW4nIH5tb25pdG9yOm1haW5dIHRvIGF2b2lkIGhvbGRpbmcgb24gdG8gcmVmZXJlbmNlcyB0byB0aGUgZXZhbHVhdGlvblxuICAgICBjb250ZXh0IGluIHdoaWNoIFt0cnlfd2l0aF0gd2FzIGNhbGxlZC4gIFRoaXMgYXZvaWRzIGEgc3BhY2UgbGVhayB3aGVuIGEgY2hhaW4gb2ZcbiAgICAgW3RyeV93aXRoXSdzIGFyZSBydW4gZWFjaCBuZXN0ZWQgd2l0aGluIHRoZSBwcmV2aW91cyBvbmUuICBXaXRob3V0IHRoZSBbd2l0aGluJ10sIHRoZVxuICAgICBlcnJvciBoYW5kbGluZyBmb3IgdGhlIGlubmVybW9zdCBbdHJ5X3dpdGhdIHdvdWxkIGtlZXAgYWxpdmUgdGhlIGVudGlyZSBjaGFpbi4gKilcbiAgd2l0aGluJyB+bW9uaXRvcjptYWluIChmdW4gKCkgLT5cbiAgICBpZiBEZWZlcnJlZC5pc19kZXRlcm1pbmVkIG9rXG4gICAgdGhlbiAoXG4gICAgICBoYW5kbGVfZXhuc19hZnRlcl9yZXN1bHQgZXhucztcbiAgICAgIHJldHVybiAoT2sgKERlZmVycmVkLnZhbHVlX2V4biBvaykpKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHJlc3VsdF9maWxsZXIsIHJlc3VsdCA9IEl2YXJfZmlsbGVyLmNyZWF0ZSAoKSBpblxuICAgICAgdXBvbiBvayAoZnVuIHJlcyAtPlxuICAgICAgICBmaWxsX3Jlc3VsdF9hbmRfaGFuZGxlX2JhY2tncm91bmRfZXJyb3JzXG4gICAgICAgICAgcmVzdWx0X2ZpbGxlclxuICAgICAgICAgIChPayByZXMpXG4gICAgICAgICAgZXhuc1xuICAgICAgICAgIGhhbmRsZV9leG5zX2FmdGVyX3Jlc3VsdCk7XG4gICAgICB1cG9uIChTdHJlYW0ubmV4dCBleG5zKSAoZnVuY3Rpb25cbiAgICAgICAgfCBOaWwgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgIHwgQ29ucyAoZXhuLCBleG5zKSAtPlxuICAgICAgICAgIGxldCBleG4gPSBpZiBkb19leHRyYWN0X2V4biB0aGVuIGV4dHJhY3RfZXhuIGV4biBlbHNlIGV4biBpblxuICAgICAgICAgIGZpbGxfcmVzdWx0X2FuZF9oYW5kbGVfYmFja2dyb3VuZF9lcnJvcnNcbiAgICAgICAgICAgIHJlc3VsdF9maWxsZXJcbiAgICAgICAgICAgIChFcnJvciBleG4pXG4gICAgICAgICAgICBleG5zXG4gICAgICAgICAgICBoYW5kbGVfZXhuc19hZnRlcl9yZXN1bHQpO1xuICAgICAgcmVzdWx0KSlcbjs7XG5cbmxldCB0cnlfd2l0aF9vcl9lcnJvciA/aGVyZSA/aW5mbyA/KG5hbWUgPSBcInRyeV93aXRoX29yX2Vycm9yXCIpID9leHRyYWN0X2V4biA/cmVzdCBmID1cbiAgdHJ5X3dpdGggZiA/aGVyZSA/aW5mbyB+bmFtZSA/ZXh0cmFjdF9leG4gfnJ1bjpgTm93ID9yZXN0ID4+fCBPcl9lcnJvci5vZl9leG5fcmVzdWx0XG47O1xuXG5sZXQgdHJ5X3dpdGhfam9pbl9vcl9lcnJvclxuICAgICAgP2hlcmVcbiAgICAgID9pbmZvXG4gICAgICA/KG5hbWUgPSBcInRyeV93aXRoX2pvaW5fb3JfZXJyb3JcIilcbiAgICAgID9leHRyYWN0X2V4blxuICAgICAgP3Jlc3RcbiAgICAgIGZcbiAgPVxuICB0cnlfd2l0aF9vcl9lcnJvciBmID9oZXJlID9pbmZvIH5uYW1lID9leHRyYWN0X2V4biA/cmVzdCA+PnwgT3JfZXJyb3Iuam9pblxuOztcblxubGV0IHByb3RlY3QgP2hlcmUgP2luZm8gPyhuYW1lID0gXCJNb25pdG9yLnByb3RlY3RcIikgP2V4dHJhY3RfZXhuID9ydW4gP3Jlc3QgZiB+ZmluYWxseSA9XG4gIGxldCViaW5kIHIgPSB0cnlfd2l0aCA/ZXh0cmFjdF9leG4gP2hlcmUgP2luZm8gP3J1biA/cmVzdCB+bmFtZSBmIGluXG4gIGxldCVtYXAgZnIgPVxuICAgIHRyeV93aXRoXG4gICAgICB+ZXh0cmFjdF9leG46ZmFsc2VcbiAgICAgID9oZXJlXG4gICAgICA/aW5mb1xuICAgICAgfnJ1bjpgU2NoZWR1bGUgKCogY29uc2lkZXIgW35ydW46YE5vd10gKilcbiAgICAgID9yZXN0XG4gICAgICB+bmFtZTpcImZpbmFsbHlcIlxuICAgICAgZmluYWxseVxuICBpblxuICBtYXRjaCByLCBmciB3aXRoXG4gIHwgRXJyb3IgZXhuLCBFcnJvciBmaW5hbGx5X2V4biAtPlxuICAgIHJhaXNlX3MgWyVtZXNzYWdlIFwiQXN5bmMgZmluYWxseVwiIChleG4gOiBleG4pIChmaW5hbGx5X2V4biA6IGV4bildXG4gIHwgRXJyb3IgZSwgT2sgKCkgfCBPayBfLCBFcnJvciBlIC0+IHJhaXNlIGVcbiAgfCBPayByLCBPayAoKSAtPiByXG47O1xuXG5sZXQgaGFuZGxlX2Vycm9ycyA/aGVyZSA/aW5mbyA/bmFtZSBmIGhhbmRsZXIgPVxuICBsZXQgeyBPa19hbmRfZXhucy5vazsgZXhucyB9ID0gT2tfYW5kX2V4bnMuY3JlYXRlID9oZXJlID9pbmZvID9uYW1lIH5ydW46YE5vdyBmIGluXG4gIHN0cmVhbV9pdGVyIGV4bnMgfmY6aGFuZGxlcjtcbiAgb2tcbjs7XG5cbmxldCBjYXRjaF9zdHJlYW0gP2hlcmUgP2luZm8gP25hbWUgZiA9XG4gIGxldCB7IE9rX2FuZF9leG5zLmV4bnM7IF8gfSA9XG4gICAgT2tfYW5kX2V4bnMuY3JlYXRlID9oZXJlID9pbmZvID9uYW1lIH5ydW46YE5vdyAoZnVuICgpIC0+XG4gICAgICBmICgpO1xuICAgICAgcmV0dXJuICgpKVxuICBpblxuICBleG5zXG47O1xuXG5sZXQgY2F0Y2ggP2hlcmUgP2luZm8gP25hbWUgZiA9XG4gIG1hdGNoJW1hcCBTdHJlYW0ubmV4dCAoY2F0Y2hfc3RyZWFtID9oZXJlID9pbmZvID9uYW1lIGYpIHdpdGhcbiAgfCBDb25zICh4LCBfKSAtPiB4XG4gIHwgTmlsIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiTW9uaXRvci5jYXRjaCBnb3QgdW5leHBlY3RlZCBlbXB0eSBzdHJlYW1cIl1cbjs7XG5cbmxldCBjYXRjaF9lcnJvciA/aGVyZSA/aW5mbyA/bmFtZSBmID0gY2F0Y2ggP2hlcmUgP2luZm8gP25hbWUgZiA+PnwgRXJyb3Iub2ZfZXhuXG5cbm1vZHVsZSBGb3JfdGVzdHMgPSBzdHJ1Y3RcbiAgbGV0IHBhcmVudCB0ID1cbiAgICBtYXRjaCB0LmZvcndhcmRpbmcgd2l0aFxuICAgIHwgUmVwb3J0X3VuY2F1Z2h0X2V4biAtPiBOb25lXG4gICAgfCBQYXJlbnQgcGFyZW50IC0+IFNvbWUgcGFyZW50XG4gICAgfCBEZXRhY2hlZCAtPiBOb25lXG4gIDs7XG5cbiAgbGV0IGRlcHRoIHQgPVxuICAgIGxldCByZWMgbG9vcCB0IG4gPVxuICAgICAgbWF0Y2ggcGFyZW50IHQgd2l0aFxuICAgICAgfCBOb25lIC0+IG5cbiAgICAgIHwgU29tZSB0IC0+IGxvb3AgdCAobiArIDEpXG4gICAgaW5cbiAgICBsb29wIHQgMFxuICA7O1xuZW5kXG4iLCJvcGVuIENvcmVcbm9wZW4gRGVmZXJyZWRfc3RkXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcbmluY2x1ZGUgVGFpbC5TdHJlYW1cblxubGV0IGZpcnN0X2V4biB0ID1cbiAgbWF0Y2glbWFwIG5leHQgdCB3aXRoXG4gIHwgTmlsIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiU3RyZWFtLmZpcnN0IG9mIGVtcHR5IHN0cmVhbVwiXVxuICB8IENvbnMgKHgsIF8pIC0+IHhcbjs7XG5cbmxldCBmb2xkJyB0IH5pbml0IH5mID1cbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVzdWx0IC0+XG4gICAgbGV0IHJlYyBsb29wIHQgYiA9XG4gICAgICB1cG9uIChuZXh0IHQpIChmdW5jdGlvblxuICAgICAgICB8IE5pbCAtPiBJdmFyLmZpbGwgcmVzdWx0IGJcbiAgICAgICAgfCBDb25zICh2LCB0KSAtPiB1cG9uIChmIGIgdikgKGxvb3AgdCkpXG4gICAgaW5cbiAgICBsb29wIHQgaW5pdClcbjs7XG5cbigqIFtmb2xkXSBpcyBpbXBsZW1lbnRlZCB0byBhdm9pZCBwZXItc3RyZWFtLWVsZW1lbnQgZGVmZXJyZWQgb3ZlcmhlYWQgaW4gdGhlIGNhc2Ugd2hlblxuICAgbXVsdGlwbGUgc3RyZWFtIGVsZW1lbnRzIGFyZSBhdmFpbGFibGUgc2ltdWx0YW5lb3VzbHkuICopXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gcmVzdWx0IC0+XG4gICAgbGV0IHJlYyBsb29wIHQgYiA9XG4gICAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIChuZXh0IHQpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiB1cG9uIChuZXh0IHQpIChmdW4gbmV4dCAtPiBsb29wX25leHQgbmV4dCBiKVxuICAgICAgfCBTb21lIG5leHQgLT4gbG9vcF9uZXh0IG5leHQgYlxuICAgIGFuZCBsb29wX25leHQgbmV4dCBiID1cbiAgICAgIG1hdGNoIG5leHQgd2l0aFxuICAgICAgfCBOaWwgLT4gSXZhci5maWxsIHJlc3VsdCBiXG4gICAgICB8IENvbnMgKHYsIHQpIC0+IGxvb3AgdCAoZiBiIHYpXG4gICAgaW5cbiAgICBsb29wIHQgaW5pdClcbjs7XG5cbmxldCBsZW5ndGggdCA9IGZvbGQgdCB+aW5pdDowIH5mOihmdW4gbiBfIC0+IG4gKyAxKVxubGV0IGl0ZXInIHQgfmYgPSBmb2xkJyB0IH5pbml0OigpIH5mOihmdW4gKCkgdiAtPiBmIHYpXG5cbmxldCBjbG9zZWQgdCA9XG4gIG1hdGNoIERlZmVycmVkLnBlZWsgKG5leHQgdCkgd2l0aFxuICB8IFNvbWUgTmlsIC0+IHJldHVybiAoKVxuICB8IF8gLT4gaXRlcicgdCB+ZjooZnVuIF8gLT4gcmV0dXJuICgpKVxuOztcblxubGV0IGl0ZXIgdCB+ZiA9XG4gIGRvbid0X3dhaXRfZm9yXG4gICAgKGl0ZXInIHQgfmY6KGZ1biBhIC0+XG4gICAgICAgZiBhO1xuICAgICAgIHJldHVybiAoKSkpXG47O1xuXG5sZXQgY3JlYXRlIGYgPVxuICBsZXQgdGFpbCA9IFRhaWwuY3JlYXRlICgpIGluXG4gICgqIGNvbGxlY3QgYmVmb3JlIGNhbGxpbmcgW2ZdLCBpbiBjYXNlIFtmXSBpbW1lZGlhdGVseSBleHRlbmRzLiAqKVxuICBsZXQgdCA9IFRhaWwuY29sbGVjdCB0YWlsIGluXG4gIGYgdGFpbDtcbiAgdFxuOztcblxubGV0IHVuZm9sZCBiIH5mID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIGxldCByZWMgbG9vcCBiID1cbiAgICAgIHVwb24gKGYgYikgKGZ1bmN0aW9uXG4gICAgICAgIHwgTm9uZSAtPiBUYWlsLmNsb3NlX2V4biB0YWlsXG4gICAgICAgIHwgU29tZSAoYSwgYikgLT5cbiAgICAgICAgICBUYWlsLmV4dGVuZCB0YWlsIGE7XG4gICAgICAgICAgbG9vcCBiKVxuICAgIGluXG4gICAgbG9vcCBiKVxuOztcblxubGV0IG9mX2xpc3QgbCA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBMaXN0Lml0ZXIgbCB+ZjooZnVuIHggLT4gVGFpbC5leHRlbmQgdGFpbCB4KTtcbiAgICBUYWlsLmNsb3NlX2V4biB0YWlsKVxuOztcblxubGV0IHRvX2xpc3QgcyA9IGZvbGQnIHMgfmluaXQ6W10gfmY6KGZ1biBiIGEgLT4gcmV0dXJuIChhIDo6IGIpKSA+PnwgTGlzdC5yZXZcbmxldCBjb3B5X3RvX3RhaWwgdCB0YWlsID0gaXRlcicgdCB+ZjooZnVuIGEgLT4gcmV0dXJuIChUYWlsLmV4dGVuZCB0YWlsIGEpKVxuXG5sZXQgYXBwZW5kIHQxIHQyID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIHVwb24gKGNvcHlfdG9fdGFpbCB0MSB0YWlsKSAoZnVuICgpIC0+XG4gICAgICB1cG9uIChjb3B5X3RvX3RhaWwgdDIgdGFpbCkgKGZ1biAoKSAtPiBUYWlsLmNsb3NlX2V4biB0YWlsKSkpXG47O1xuXG5sZXQgY29uY2F0IHQgPVxuICBjcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgdXBvbiAoaXRlcicgdCB+ZjooZnVuIHQgLT4gY29weV90b190YWlsIHQgdGFpbCkpIChmdW4gKCkgLT4gVGFpbC5jbG9zZV9leG4gdGFpbCkpXG47O1xuXG5sZXQgZmlsdGVyJyB0IH5mID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIHVwb25cbiAgICAgIChpdGVyJyB0IH5mOihmdW4gdiAtPlxuICAgICAgICAgbWF0Y2glbWFwIGYgdiB3aXRoXG4gICAgICAgICB8IGZhbHNlIC0+ICgpXG4gICAgICAgICB8IHRydWUgLT4gVGFpbC5leHRlbmQgdGFpbCB2KSlcbiAgICAgIChmdW4gKCkgLT4gVGFpbC5jbG9zZV9leG4gdGFpbCkpXG47O1xuXG5sZXQgZmlsdGVyX2RlcHJlY2F0ZWQgdCB+ZiA9IGZpbHRlcicgdCB+ZjooZnVuIGEgLT4gcmV0dXJuIChmIGEpKVxuXG5sZXQgZmlsdGVyX21hcCcgdCB+ZiA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICB1cG9uXG4gICAgICAoaXRlcicgdCB+ZjooZnVuIHYgLT5cbiAgICAgICAgIG1hdGNoJW1hcCBmIHYgd2l0aFxuICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICB8IFNvbWUgdiAtPiBUYWlsLmV4dGVuZCB0YWlsIHYpKVxuICAgICAgKGZ1biAoKSAtPiBUYWlsLmNsb3NlX2V4biB0YWlsKSlcbjs7XG5cbmxldCBmaWx0ZXJfbWFwX2RlcHJlY2F0ZWQgdCB+ZiA9IGZpbHRlcl9tYXAnIHQgfmY6KGZ1biBhIC0+IHJldHVybiAoZiBhKSlcblxubGV0IG1hcCcgdCB+ZiA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICB1cG9uXG4gICAgICAoaXRlcicgdCB+ZjooZnVuIHYgLT4gZiB2ID4+fCBUYWlsLmV4dGVuZCB0YWlsKSlcbiAgICAgIChmdW4gKCkgLT4gVGFpbC5jbG9zZV9leG4gdGFpbCkpXG47O1xuXG5sZXQgbWFwIHQgfmYgPSBtYXAnIHQgfmY6KGZ1biBhIC0+IHJldHVybiAoZiBhKSlcblxubGV0IGZpcnN0X24gcyBuID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIGxldCByZWMgbG9vcCBzIG4gPVxuICAgICAgaWYgbiA9IDBcbiAgICAgIHRoZW4gVGFpbC5jbG9zZV9leG4gdGFpbFxuICAgICAgZWxzZVxuICAgICAgICB1cG9uIChuZXh0IHMpIChmdW5jdGlvblxuICAgICAgICAgIHwgTmlsIC0+IFRhaWwuY2xvc2VfZXhuIHRhaWxcbiAgICAgICAgICB8IENvbnMgKHgsIHQpIC0+XG4gICAgICAgICAgICBUYWlsLmV4dGVuZCB0YWlsIHg7XG4gICAgICAgICAgICBsb29wIHQgKG4gLSAxKSlcbiAgICBpblxuICAgIGxvb3AgcyBuKVxuOztcblxubGV0IGF2YWlsYWJsZV9ub3cgdCA9XG4gIGxldCByZWMgbG9vcCB0IGFjID1cbiAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIChuZXh0IHQpIHdpdGhcbiAgICB8IE5vbmUgfCBTb21lIE5pbCAtPiBMaXN0LnJldiBhYywgdFxuICAgIHwgU29tZSAoQ29ucyAoeCwgdCkpIC0+IGxvb3AgdCAoeCA6OiBhYylcbiAgaW5cbiAgbG9vcCB0IFtdXG47O1xuXG5sZXQgc3BsaXQgPyhzdG9wID0gRGVmZXJyZWQubmV2ZXIgKCkpID8oZiA9IGZ1biBfIC0+IGBDb250aW51ZSkgdCA9XG4gIGxldCByZWFzb25fZm9yX3N0b3BwaW5nID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgbGV0IHByZWZpeCA9IFRhaWwuY3JlYXRlICgpIGluXG4gIGxldCBmaW5pc2ggdiA9XG4gICAgVGFpbC5jbG9zZV9leG4gcHJlZml4O1xuICAgIEl2YXIuZmlsbCByZWFzb25fZm9yX3N0b3BwaW5nIHZcbiAgaW5cbiAgbGV0IHJlYyBsb29wIHQgPVxuICAgIGNob29zZSBbIGNob2ljZSBzdG9wIChmdW4gKCkgLT4gYFN0b3BwZWQpOyBjaG9pY2UgKG5leHQgdCkgKGZ1biBvIC0+IGBOZXh0IG8pIF1cbiAgICA+Pj4gZnVuY3Rpb25cbiAgICB8IGBTdG9wcGVkIC0+IGZpbmlzaCAoYFN0b3BwZWQgdClcbiAgICB8IGBOZXh0IG8gLT5cbiAgICAgIChtYXRjaCBvIHdpdGhcbiAgICAgICB8IE5pbCAtPiBmaW5pc2ggYEVuZF9vZl9zdHJlYW1cbiAgICAgICB8IENvbnMgKGEsIHQpIC0+XG4gICAgICAgICAobWF0Y2ggZiBhIHdpdGhcbiAgICAgICAgICB8IGBDb250aW51ZSAtPlxuICAgICAgICAgICAgVGFpbC5leHRlbmQgcHJlZml4IGE7XG4gICAgICAgICAgICBsb29wIHRcbiAgICAgICAgICB8IGBGb3VuZCBiIC0+IGZpbmlzaCAoYEZvdW5kIChiLCB0KSkpKVxuICBpblxuICBsb29wIHQ7XG4gIFRhaWwuY29sbGVjdCBwcmVmaXgsIEl2YXIucmVhZCByZWFzb25fZm9yX3N0b3BwaW5nXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgbGV0IF8sIGZvdW5kID0gc3BsaXQgdCB+ZjooZnVuIGEgLT4gaWYgZiBhIHRoZW4gYEZvdW5kIGEgZWxzZSBgQ29udGludWUpIGluXG4gIG1hdGNoJW1hcCBmb3VuZCB3aXRoXG4gIHwgYFN0b3BwZWQgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCAoYEVuZF9vZl9zdHJlYW0gfCBgRm91bmQgXykgYXMgeCAtPiB4XG47O1xuXG5sZXQgdW5ncm91cCB0ID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgIHVwb25cbiAgICAgIChpdGVyJyB0IH5mOihmdW4gbCAtPlxuICAgICAgICAgTGlzdC5pdGVyIGwgfmY6KGZ1biB4IC0+IFRhaWwuZXh0ZW5kIHRhaWwgeCk7XG4gICAgICAgICByZXR1cm4gKCkpKVxuICAgICAgKGZ1biAoKSAtPiBUYWlsLmNsb3NlX2V4biB0YWlsKSlcbjs7XG5cbmxldCBpbnRlcmxlYXZlIHRzID1cbiAgY3JlYXRlIChmdW4gdGFpbCAtPlxuICAgICgqIFRoZSBpbnRlcmxlYXZlZCBzdHJlYW0gc2hvdWxkIGJlIGNsb3NlZCB3aGVuIHRoZSBvdXRlciBzdHJlYW0gYW5kIGFsbCBvZlxuICAgICAgIHRoZSBpbm5lciBzdHJlYW1zIGhhdmUgYmVlbiBjbG9zZWQuICBLZWVwIGEgY291bnQgb2YgdGhlIG51bWJlciBvZiBvcGVuXG4gICAgICAgc3RyZWFtcyBhbmQgY2xvc2UgdGhlIGludGVybGVhdmVkIHN0cmVhbSB3aGVuIHRoYXQgY291bnQgYmVjb21lc1xuICAgICAgIHplcm8uICopXG4gICAgbGV0IG51bV9vcGVuID0gcmVmIDEgaW5cbiAgICAoKiAxIGZvciB0aGUgb3V0ZXIgc3RyZWFtIHRoYXQgaXMgb3BlbiAqKVxuICAgIGxldCBjbG9zZSAoKSA9XG4gICAgICBudW1fb3BlbiA6PSAhbnVtX29wZW4gLSAxO1xuICAgICAgaWYgIW51bV9vcGVuID0gMCB0aGVuIFRhaWwuY2xvc2VfZXhuIHRhaWxcbiAgICBpblxuICAgIGxldCBvdXRlcl9jbG9zZWQgPVxuICAgICAgaXRlcicgdHMgfmY6KGZ1biB0IC0+XG4gICAgICAgIG51bV9vcGVuIDo9ICFudW1fb3BlbiArIDE7XG4gICAgICAgIHVwb24gKGNvcHlfdG9fdGFpbCB0IHRhaWwpIGNsb3NlO1xuICAgICAgICByZXR1cm4gKCkpXG4gICAgaW5cbiAgICB1cG9uIG91dGVyX2Nsb3NlZCBjbG9zZSlcbjs7XG5cbmxldCB0YWtlX3VudGlsIHQgZCA9XG4gIGNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBsZXQgcmVjIGxvb3AgdCA9XG4gICAgICB1cG9uXG4gICAgICAgIChjaG9vc2UgWyBjaG9pY2UgZCAoZnVuICgpIC0+IGBTdG9wKTsgY2hvaWNlIChuZXh0IHQpIChmdW4geiAtPiBgTmV4dCB6KSBdKVxuICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICB8IGBTdG9wIHwgYE5leHQgTmlsIC0+IFRhaWwuY2xvc2VfZXhuIHRhaWxcbiAgICAgICAgICB8IGBOZXh0IChDb25zICh4LCB0KSkgLT5cbiAgICAgICAgICAgIFRhaWwuZXh0ZW5kIHRhaWwgeDtcbiAgICAgICAgICAgIGxvb3AgdClcbiAgICBpblxuICAgIGxvb3AgdClcbjs7XG5cbmxldCBpdGVyX2R1cmFibHknIHQgfmYgPVxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICBsZXQgcmVjIGxvb3AgdCA9XG4gICAgICBuZXh0IHRcbiAgICAgID4+PiBmdW5jdGlvblxuICAgICAgfCBOaWwgLT4gSXZhci5maWxsIHJlc3VsdCAoKVxuICAgICAgfCBDb25zICh4LCB0KSAtPlxuICAgICAgICBNb25pdG9yLnRyeV93aXRoXG4gICAgICAgICAgfnJ1bjpcbiAgICAgICAgICAgIGBTY2hlZHVsZVxuICAgICAgICAgIH5yZXN0OmBSYWlzZVxuICAgICAgICAgIChmdW4gKCkgLT4gZiB4KVxuICAgICAgICA+Pj4gZnVuIHogLT5cbiAgICAgICAgbG9vcCB0O1xuICAgICAgICAobWF0Y2ggeiB3aXRoXG4gICAgICAgICB8IE9rICgpIC0+ICgpXG4gICAgICAgICB8IEVycm9yIGUgLT4gTW9uaXRvci5zZW5kX2V4biAoTW9uaXRvci5jdXJyZW50ICgpKSBlKVxuICAgIGluXG4gICAgbG9vcCB0KVxuOztcblxubGV0IGl0ZXJfZHVyYWJseV9yZXBvcnRfZW5kIHQgfmYgPVxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICBsZXQgcmVjIGxvb3AgdCA9XG4gICAgICBuZXh0IHRcbiAgICAgID4+PiBmdW5jdGlvblxuICAgICAgfCBOaWwgLT4gSXZhci5maWxsIHJlc3VsdCAoKVxuICAgICAgfCBDb25zICh4LCB0KSAtPlxuICAgICAgICAoKiBXZSBpbW1lZGlhdGVseSBjYWxsIFtsb29wXSwgdGh1cyBtYWtpbmcgdGhlIGl0ZXIgZHVyYWJsZS4gIEFueSBleGNlcHRpb25zXG4gICAgICAgICAgIHJhaXNlZCBieSBbZl0gd2lsbCBub3QgcHJldmVudCB0aGUgbG9vcCBmcm9tIGNvbnRpbnVpbmcsIGFuZCB3aWxsIGdvIHRvIHRoZVxuICAgICAgICAgICBtb25pdG9yIG9mIHdob21ldmVyIGNhbGxlZCBbaXRlcl9kdXJhYmx5X3JlcG9ydF9lbmRdLiAqKVxuICAgICAgICBsb29wIHQ7XG4gICAgICAgIGYgeFxuICAgIGluXG4gICAgbG9vcCB0KVxuOztcblxubGV0IGl0ZXJfZHVyYWJseSB0IH5mID0gZG9uJ3Rfd2FpdF9mb3IgKGl0ZXJfZHVyYWJseV9yZXBvcnRfZW5kIHQgfmYpXG5cbmxldCBvZl9mdW4gZiA9XG4gIHVuZm9sZCAoKSB+ZjooZnVuICgpIC0+XG4gICAgbGV0JW1hcCBhID0gZiAoKSBpblxuICAgIFNvbWUgKGEsICgpKSlcbjs7XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxudHlwZSAoJ2EsICdwZXJtaXNzaW9uKSB0ID0gKCdhLCAncGVybWlzc2lvbikgVHlwZXMuQnZhci50XG5cbnR5cGUgJ2EgcmVwciA9ICdhIFR5cGVzLkJ2YXIucmVwciA9XG4gIHsgbXV0YWJsZSBoYXNfYW55X3dhaXRlcnMgOiBib29sXG4gIDsgbXV0YWJsZSBpdmFyIDogJ2EgSXZhci50XG4gIH1cbltAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSBfIHQgPVxuICBsZXQgcmVwciA9IFR5cGVzLkJ2YXIudG9fcmVwciB0IGluXG4gIEludmFyaWFudC5pbnZhcmlhbnQgWyVoZXJlXSByZXByIFslc2V4cF9vZjogXyByZXByXSAoZnVuICgpIC0+XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgcmVwciBmIGluXG4gICAgRmllbGRzX29mX3JlcHIuaXRlclxuICAgICAgfmhhc19hbnlfd2FpdGVyczpcbiAgICAgICAgKGNoZWNrIChmdW4gaGFzX2FueV93YWl0ZXJzIC0+XG4gICAgICAgICAgIGlmIEl2YXIuaGFzX2hhbmRsZXJzIHJlcHIuaXZhciB0aGVuIGFzc2VydCBoYXNfYW55X3dhaXRlcnMpKVxuICAgICAgfml2YXI6XG4gICAgICAgIChjaGVjayAoZnVuIGl2YXIgLT5cbiAgICAgICAgICAgSXZhci5pbnZhcmlhbnQgaW52YXJpYW50X2EgaXZhcjtcbiAgICAgICAgICAgYXNzZXJ0IChJdmFyLmlzX2VtcHR5IGl2YXIpKSkpXG47O1xuXG5sZXQgc2V4cF9vZl90IF8gXyB0ID1cbiAgbGV0IHsgaGFzX2FueV93YWl0ZXJzOyBpdmFyID0gXyB9ID0gVHlwZXMuQnZhci50b19yZXByIHQgaW5cbiAgKCogV2UgZG9uJ3Qgc2hvdyBbaXZhcl0gYmVjYXVzZSBpdCdzIGFsd2F5cyBlbXB0eS4gKilcbiAgWyVtZXNzYWdlIChoYXNfYW55X3dhaXRlcnMgOiBib29sKV1cbjs7XG5cbmluY2x1ZGUgU2NoZWR1bGVyMS5CdmFyXG5cbmxldCBicm9hZGNhc3QgdCBhID1cbiAgbGV0IHJlcHIgPSBUeXBlcy5CdmFyLnRvX3JlcHIgdCBpblxuICBpZiByZXByLmhhc19hbnlfd2FpdGVyc1xuICB0aGVuIChcbiAgICByZXByLmhhc19hbnlfd2FpdGVycyA8LSBmYWxzZTtcbiAgICBJdmFyLmZpbGwgcmVwci5pdmFyIGE7XG4gICAgcmVwci5pdmFyIDwtIEl2YXIuY3JlYXRlICgpKVxuOztcblxubGV0IHdhaXQgdCA9XG4gIGxldCByZXByID0gVHlwZXMuQnZhci50b19yZXByIHQgaW5cbiAgcmVwci5oYXNfYW55X3dhaXRlcnMgPC0gdHJ1ZTtcbiAgSXZhci5yZWFkIHJlcHIuaXZhclxuOztcblxubGV0IGhhc19hbnlfd2FpdGVycyB0ID1cbiAgbGV0IHJlcHIgPSBUeXBlcy5CdmFyLnRvX3JlcHIgdCBpblxuICByZXByLmhhc19hbnlfd2FpdGVyc1xuOztcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxub3BlbiEgRGVmZXJyZWRfc3RkXG5cbmxldCBkZWJ1ZyA9IERlYnVnLmNsb2NrXG5cbm1vZHVsZSBBbGFybSA9IFRpbWluZ193aGVlbC5BbGFybVxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5tb2R1bGUgU2NoZWR1bGVyID0gU2NoZWR1bGVyMVxuXG5sZXQgdXBvbiA9IERlZmVycmVkLnVwb25cbmxldCBjaG9vc2UgPSBEZWZlcnJlZC5jaG9vc2VcbmxldCBjaG9pY2UgPSBEZWZlcnJlZC5jaG9pY2VcbmxldCAoID4+PiApID0gdXBvblxuXG5tb2R1bGUgVDEgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTeW5jaHJvbm91c190aW1lX3NvdXJjZTAuVDFcblxuICAoKiBXZSBkb24ndCBpbmNsdWRlIHRoZSBbaWRdIGluIHRoZSBzZXhwIGJlY2F1c2UgdGhlIHVzZXIgKHJpZ2h0bHkpIGNhbid0IGNvbnRyb2wgaXQsIHNvXG4gICAgIGl0J3MgaGFyZCB0byBtYWtlIGl0IGRldGVybWluaXN0aWMgaW4gdGVzdHMuICopXG4gIGxldCBzZXhwX29mX3RcbiAgICAgICAgX1xuICAgICAgICB7IGlkID0gX1xuICAgICAgICA7IGFkdmFuY2VfZXJyb3JzID0gX1xuICAgICAgICA7IGFtX2FkdmFuY2luZyA9IF9cbiAgICAgICAgOyBldmVudHNcbiAgICAgICAgOyBmaXJlZF9ldmVudHMgPSBfXG4gICAgICAgIDsgaGFuZGxlX2ZpcmVkID0gX1xuICAgICAgICA7IGlzX3dhbGxfY2xvY2tcbiAgICAgICAgOyBtb3N0X3JlY2VudGx5X2ZpcmVkID0gX1xuICAgICAgICA7IHNjaGVkdWxlciA9IF9cbiAgICAgICAgfVxuICAgID1cbiAgICBpZiBpc193YWxsX2Nsb2NrXG4gICAgdGhlbiBbJW1lc3NhZ2UgXCI8d2FsbF9jbG9jaz5cIl1cbiAgICBlbHNlXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgKGlzX3dhbGxfY2xvY2sgOiBib29sKVxuICAgICAgICAgICgqIFdlIGRvbid0IGRpc3BsYXkgdGhlIFtKb2IudF1zIGluIFtldmVudHNdIGJlY2F1c2UgdGhvc2UgYXJlXG4gICAgICAgICAgICAgcG9vbCBwb2ludGVycywgd2hpY2ggYXJlIHVuaW5mb3JtYXRpdmUuICopXG4gICAgICAgICAgKGV2ZW50cyA6IF8gVGltaW5nX3doZWVsLnQpXVxuICA7O1xuZW5kXG5cbm9wZW4gVDFcblxubW9kdWxlIFJlYWRfd3JpdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gcmVhZF93cml0ZSBUMS50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCA9IGludmFyaWFudFxuICBsZXQgaW52YXJpYW50X3dpdGhfam9icyA9IGludmFyaWFudF93aXRoX2pvYnNcbmVuZFxuXG50eXBlIHQgPSByZWFkIFQxLnQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGludmFyaWFudCA9IGludmFyaWFudFxubGV0IGludmFyaWFudF93aXRoX2pvYnMgPSBpbnZhcmlhbnRfd2l0aF9qb2JzXG5sZXQgcmVhZF9vbmx5ICh0IDogWz4gcmVhZCBdIFQxLnQpID0gKHQgOj4gdClcbmxldCBjcmVhdGUgPSBTY2hlZHVsZXIuY3JlYXRlX3RpbWVfc291cmNlXG5sZXQgd2FsbF9jbG9jayA9IFNjaGVkdWxlci53YWxsX2Nsb2NrXG5sZXQgYWxhcm1fcHJlY2lzaW9uIHQgPSBUaW1pbmdfd2hlZWwuYWxhcm1fcHJlY2lzaW9uIHQuZXZlbnRzXG5sZXQgaXNfd2FsbF9jbG9jayB0ID0gdC5pc193YWxsX2Nsb2NrXG5sZXQgbmV4dF9hbGFybV9maXJlc19hdCB0ID0gVGltaW5nX3doZWVsLm5leHRfYWxhcm1fZmlyZXNfYXQgdC5ldmVudHNcbmxldCB0aW1pbmdfd2hlZWxfbm93IHQgPSBUaW1pbmdfd2hlZWwubm93IHQuZXZlbnRzXG5sZXQgaWQgdCA9IHQuaWRcblxubW9kdWxlIElkID0gU3luY2hyb25vdXNfdGltZV9zb3VyY2UwLklkXG5cbmxldCBub3cgdCA9XG4gIGlmIHQuaXNfd2FsbF9jbG9ja1xuICB0aGVuXG4gICAgKCogRm9yIHRoZSB3YWxsLWNsb2NrIHRpbWUtc291cmNlLCB3ZSB1c2UgW1RpbWVfbnMubm93ICgpXSByYXRoZXIgdGhhblxuICAgICAgIFtUaW1pbmdfd2hlZWwubm93IHQuZXZlbnRzXS4gIFRoZSBsYXR0ZXIgaXMgb25seSB1cGRhdGVkIGF0IHRoZSBzdGFydCBvZiBlYWNoXG4gICAgICAgY3ljbGUuICBUaGVyZSBjYW4gYmUgc3Vic3RhbnRpYWwgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB0d28gd2hlbiBwZW9wbGUgZG8gbG9uZ1xuICAgICAgIHJ1bm5pbmcgY29tcHV0YXRpb25zIG9yIG1peCBibG9ja2luZyBjb2RlIHdpdGggYXN5bmMuICBBbmQgaHVtYW5zIGV4cGVjdCB0aGF0XG4gICAgICAgd2FsbC1jbG9jayB0aW1lIGlzIGJhc2VkIG9uIFtUaW1lLm5vd10sIG5vdCBzb21lIGFydGlmYWN0IG9mIGFzeW5jXG4gICAgICAgaW1wbGVtZW50YXRpb24uICopXG4gICAgVGltZV9ucy5ub3cgKClcbiAgZWxzZSB0aW1pbmdfd2hlZWxfbm93IHRcbjs7XG5cbigqIFdlIHByZWFsbG9jYXRlIFtzZW5kX2V4bl0gdG8gYXZvaWQgYWxsb2NhdGluZyBpdCBvbiBlYWNoIGNhbGwgdG8gW2FkdmFuY2VfY2xvY2tdLiAqKVxubGV0IHNlbmRfZXhuID0gU29tZSBNb25pdG9yLnNlbmRfZXhuXG5sZXQgYWR2YW5jZV9kaXJlY3RseSB0IH50b18gPSBTeW5jaHJvbm91c190aW1lX3NvdXJjZTAuYWR2YW5jZV9jbG9jayB0IH50b18gfnNlbmRfZXhuXG5sZXQgYWR2YW5jZV9kaXJlY3RseV9ieSB0IGJ5ID0gYWR2YW5jZV9kaXJlY3RseSB0IH50b186KFRpbWVfbnMuYWZ0ZXIgKG5vdyB0KSBieSlcbmxldCBhZHZhbmNlID0gYWR2YW5jZV9kaXJlY3RseVxubGV0IGFkdmFuY2VfYnkgPSBhZHZhbmNlX2RpcmVjdGx5X2J5XG5sZXQgZmlyZV9wYXN0X2FsYXJtcyB0ID0gU3luY2hyb25vdXNfdGltZV9zb3VyY2UwLmZpcmVfcGFzdF9hbGFybXMgdCB+c2VuZF9leG5cbmxldCB5aWVsZCB0ID0gQnZhci53YWl0IChTY2hlZHVsZXIueWllbGQgdC5zY2hlZHVsZXIpXG5cbmxldCBhZHZhbmNlX2J5X2FsYXJtcyA/d2FpdF9mb3IgdCB+dG9fID1cbiAgbGV0IHJ1bl9xdWV1ZWRfYWxhcm1zICgpID1cbiAgICAoKiBFdmVyeSB0aW1lIHdlIHdhbnQgdG8gcnVuIHF1ZXVlZCBhbGFybXMgd2UgbmVlZCB0byB5aWVsZCBjb250cm9sIGJhY2sgdG8gdGhlXG4gICAgICAgW0FzeW5jLlNjaGVkdWxlcl0gYW5kIFt3YWl0X2Zvcl0gYW55IGxvZ2ljIHRoYXQgaXMgc3VwcG9zZWQgdG8gZmluaXNoIGF0IHRoaXMgdGltZVxuICAgICAgIGJlZm9yZSBhZHZhbmNpbmcuICBJZiBubyBbd2FpdF9mb3JdIGxvZ2ljIGlzIHNwZWNpZmllZCB3ZSBjYW4gc2ltcGx5IHlpZWxkIGNvbnRyb2xcbiAgICAgICBieSBpbnZva2luZyBbeWllbGQgdF0sIHdoaWNoIGVucXVldWVzIGFub3RoZXIgam9iIGF0IHRoZSBlbmQgb2YgdGhlIHNjaGVkdWxlciBqb2JcbiAgICAgICBxdWV1ZSBzbyBhbGFybSBqb2JzIGhhdmUgdGhlIG9wcG9ydHVuaXR5IHRvIHJ1biBiZWZvcmUgd2UgYWR2YW5jZS4gKilcbiAgICBtYXRjaCB3YWl0X2ZvciB3aXRoXG4gICAgfCBOb25lIC0+IHlpZWxkIHRcbiAgICB8IFNvbWUgZiAtPiBmICgpXG4gIGluXG4gIGxldCBmaW5pc2ggKCkgPVxuICAgIGFkdmFuY2VfZGlyZWN0bHkgdCB+dG9fO1xuICAgIGZpcmVfcGFzdF9hbGFybXMgdDtcbiAgICAoKiBzbyB0aGF0IGFsYXJtcyBzY2hlZHVsZWQgYXQgb3IgYmVmb3JlIFt0b19dIGZpcmUgKilcbiAgICBydW5fcXVldWVkX2FsYXJtcyAoKVxuICBpblxuICBsZXQgcmVjIHdhbGtfYWxhcm1zICgpID1cbiAgICBtYXRjaCBUaW1pbmdfd2hlZWwubWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsIHQuZXZlbnRzIHdpdGhcbiAgICB8IE5vbmUgLT4gZmluaXNoICgpXG4gICAgfCBTb21lIG1pbl9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbCAtPlxuICAgICAgaWYgVGltZV9ucy4oID49ICkgbWluX2FsYXJtX3RpbWVfaW5fbWluX2ludGVydmFsIHRvX1xuICAgICAgdGhlbiBmaW5pc2ggKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBhZHZhbmNlX2RpcmVjdGx5IHQgfnRvXzptaW5fYWxhcm1fdGltZV9pbl9taW5faW50ZXJ2YWw7XG4gICAgICAgIGZpcmVfcGFzdF9hbGFybXMgdDtcbiAgICAgICAgbGV0IHF1ZXVlZF9hbGFybXNfcmFuID0gcnVuX3F1ZXVlZF9hbGFybXMgKCkgaW5cbiAgICAgICAgaWYgRGVmZXJyZWQuaXNfZGV0ZXJtaW5lZCBxdWV1ZWRfYWxhcm1zX3JhblxuICAgICAgICB0aGVuIHdhbGtfYWxhcm1zICgpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCViaW5kICgpID0gcXVldWVkX2FsYXJtc19yYW4gaW5cbiAgICAgICAgICB3YWxrX2FsYXJtcyAoKSkpXG4gIGluXG4gIGZpcmVfcGFzdF9hbGFybXMgdDtcbiAgKCogVGhpcyBmaXJzdCBbcnVuX3F1ZXVlZF9hbGFybXNdIGNhbGwgYWxsb3dzIFtDbG9ja19ucy5ldmVyeV0gdGhlIG9wcG9ydHVuaXR5IHRvIHJ1blxuICAgICBpdHMgY29udGludWF0aW9uIGRlZmVycmVkcyBzbyB0aGF0IHRoZXkgY2FuIHJlc2NoZWR1bGUgYWxhcm1zLiAgVGhpcyBpcyBwYXJ0aWN1bGFybHlcbiAgICAgdXNlZnVsIGluIG91ciBcImFkdmFuY2UgaGl0cyBpbnRlcm1lZGlhdGUgYWxhcm1zXCIgdW5pdCB0ZXN0IGJlbG93LCBidXQgbGlrZWx5IHVzZWZ1bFxuICAgICBpbiBvdGhlciBjYXNlcyB3aGVyZSBbZXZlcnldIGlzIHN5bmNocm9ub3VzbHkgZm9sbG93ZWQgYnkgW2FkdmFuY2VdLiAqKVxuICBsZXQlYmluZCAoKSA9IHJ1bl9xdWV1ZWRfYWxhcm1zICgpIGluXG4gIHdhbGtfYWxhcm1zICgpXG47O1xuXG5sZXQgYWR2YW5jZV9ieV9tYXhfYWxhcm1zX2luX2VhY2hfdGltaW5nX3doZWVsX2ludGVydmFsID93YWl0X2ZvciB0IH50b18gPVxuICBsZXQgcnVuX3F1ZXVlZF9hbGFybXMgKCkgPVxuICAgICgqIEV2ZXJ5IHRpbWUgd2Ugd2FudCB0byBydW4gcXVldWVkIGFsYXJtcyB3ZSBuZWVkIHRvIHlpZWxkIGNvbnRyb2wgYmFjayB0byB0aGVcbiAgICAgICBbQXN5bmMuU2NoZWR1bGVyXSBhbmQgW3dhaXRfZm9yXSBhbnkgbG9naWMgdGhhdCBpcyBzdXBwb3NlZCB0byBmaW5pc2ggYXQgdGhpcyB0aW1lXG4gICAgICAgYmVmb3JlIGFkdmFuY2luZy4gIElmIG5vIFt3YWl0X2Zvcl0gbG9naWMgaXMgc3BlY2lmaWVkIHdlIGNhbiBzaW1wbHkgeWllbGQgY29udHJvbFxuICAgICAgIGJ5IGludm9raW5nIFt5aWVsZCB0XSwgd2hpY2ggZW5xdWV1ZXMgYW5vdGhlciBqb2IgYXQgdGhlIGVuZCBvZiB0aGUgc2NoZWR1bGVyIGpvYlxuICAgICAgIHF1ZXVlIHNvIGFsYXJtIGpvYnMgaGF2ZSB0aGUgb3Bwb3J0dW5pdHkgdG8gcnVuIGJlZm9yZSB3ZSBhZHZhbmNlLiAqKVxuICAgIG1hdGNoIHdhaXRfZm9yIHdpdGhcbiAgICB8IE5vbmUgLT4geWllbGQgdFxuICAgIHwgU29tZSBmIC0+IGYgKClcbiAgaW5cbiAgbGV0IGZpbmlzaCAoKSA9XG4gICAgYWR2YW5jZV9kaXJlY3RseSB0IH50b187XG4gICAgZmlyZV9wYXN0X2FsYXJtcyB0O1xuICAgICgqIHNvIHRoYXQgYWxhcm1zIHNjaGVkdWxlZCBhdCBvciBiZWZvcmUgW3RvX10gZmlyZSAqKVxuICAgIHJ1bl9xdWV1ZWRfYWxhcm1zICgpXG4gIGluXG4gIGxldCByZWMgd2Fsa19hbGFybXMgKCkgPVxuICAgIG1hdGNoIG5leHRfYWxhcm1fZmlyZXNfYXQgdCB3aXRoXG4gICAgfCBOb25lIC0+IGZpbmlzaCAoKVxuICAgIHwgU29tZSBuZXh0X2FsYXJtX2ZpcmVzX2F0IC0+XG4gICAgICBpZiBUaW1lX25zLiggPj0gKSBuZXh0X2FsYXJtX2ZpcmVzX2F0IHRvX1xuICAgICAgdGhlbiBmaW5pc2ggKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBhZHZhbmNlX2RpcmVjdGx5IHQgfnRvXzooVGltaW5nX3doZWVsLm1heF9hbGFybV90aW1lX2luX21pbl9pbnRlcnZhbF9leG4gdC5ldmVudHMpO1xuICAgICAgICBmaXJlX3Bhc3RfYWxhcm1zIHQ7XG4gICAgICAgIGxldCBxdWV1ZWRfYWxhcm1zX3JhbiA9IHJ1bl9xdWV1ZWRfYWxhcm1zICgpIGluXG4gICAgICAgIGlmIERlZmVycmVkLmlzX2RldGVybWluZWQgcXVldWVkX2FsYXJtc19yYW5cbiAgICAgICAgdGhlbiB3YWxrX2FsYXJtcyAoKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQlYmluZCAoKSA9IHF1ZXVlZF9hbGFybXNfcmFuIGluXG4gICAgICAgICAgd2Fsa19hbGFybXMgKCkpKVxuICBpblxuICBmaXJlX3Bhc3RfYWxhcm1zIHQ7XG4gICgqIFRoaXMgZmlyc3QgW3J1bl9xdWV1ZWRfYWxhcm1zXSBjYWxsIGFsbG93cyBbQ2xvY2tfbnMuZXZlcnldIHRoZSBvcHBvcnR1bml0eSB0byBydW5cbiAgICAgaXRzIGNvbnRpbnVhdGlvbiBkZWZlcnJlZHMgc28gdGhhdCB0aGV5IGNhbiByZXNjaGVkdWxlIGFsYXJtcy4gIFRoaXMgaXMgcGFydGljdWxhcmx5XG4gICAgIHVzZWZ1bCBpbiBvdXIgXCJhZHZhbmNlIGhpdHMgaW50ZXJtZWRpYXRlIGFsYXJtc1wiIHVuaXQgdGVzdCBiZWxvdywgYnV0IGxpa2VseSB1c2VmdWxcbiAgICAgaW4gb3RoZXIgY2FzZXMgd2hlcmUgW2V2ZXJ5XSBpcyBzeW5jaHJvbm91c2x5IGZvbGxvd2VkIGJ5IFthZHZhbmNlXS4gKilcbiAgbGV0JWJpbmQgKCkgPSBydW5fcXVldWVkX2FsYXJtcyAoKSBpblxuICB3YWxrX2FsYXJtcyAoKVxuOztcblxubGV0IGFkdmFuY2VfYnlfYWxhcm1zX2J5ID93YWl0X2ZvciB0IGJ5ID1cbiAgYWR2YW5jZV9ieV9hbGFybXMgP3dhaXRfZm9yIHQgfnRvXzooVGltZV9ucy5hZnRlciAobm93IHQpIGJ5KVxuOztcblxubGV0IHNwYW5fdG9fdGltZSB0IHNwYW4gPSBUaW1lX25zLmFmdGVyIChub3cgdCkgc3BhblxuXG5sZXQgc2NoZWR1bGVfam9iIHQgfmF0IGV4ZWN1dGlvbl9jb250ZXh0IGYgYSA9XG4gIGxldCBhbGFybSA9XG4gICAgVGltaW5nX3doZWVsLmFkZFxuICAgICAgdC5ldmVudHNcbiAgICAgIH5hdFxuICAgICAgKEpvYl9vcl9ldmVudC5vZl9qb2IgKFNjaGVkdWxlci5jcmVhdGVfam9iIHQuc2NoZWR1bGVyIGV4ZWN1dGlvbl9jb250ZXh0IGYgYSkpXG4gIGluXG4gIChtYXRjaCB0LnNjaGVkdWxlci5ldmVudF9hZGRlZF9ob29rIHdpdGhcbiAgIHwgTm9uZSAtPiAoKVxuICAgfCBTb21lIGYgLT4gZiBhdCk7XG4gIGFsYXJtXG47O1xuXG5sZXQgcnVuX2F0X2ludGVybmFsIHQgdGltZSBmIGEgPVxuICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPSBTY2hlZHVsZXIuY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0LnNjaGVkdWxlciBpblxuICBpZiBUaW1lX25zLiggPiApIHRpbWUgKFRpbWluZ193aGVlbC5ub3cgdC5ldmVudHMpXG4gIHRoZW4gc2NoZWR1bGVfam9iIHQgfmF0OnRpbWUgZXhlY3V0aW9uX2NvbnRleHQgZiBhXG4gIGVsc2UgKFxuICAgIFNjaGVkdWxlci5lbnF1ZXVlIHQuc2NoZWR1bGVyIGV4ZWN1dGlvbl9jb250ZXh0IGYgYTtcbiAgICBBbGFybS5udWxsICgpKVxuOztcblxubGV0IHJ1bl9hdCB0IHRpbWUgZiBhID0gaWdub3JlIChydW5fYXRfaW50ZXJuYWwgdCB0aW1lIGYgYSA6IF8gQWxhcm0udClcbmxldCBydW5fYWZ0ZXIgdCBzcGFuIGYgYSA9IHJ1bl9hdCB0IChzcGFuX3RvX3RpbWUgdCBzcGFuKSBmIGFcblxubGV0IGF0ID1cbiAgbGV0IGZpbGwgcmVzdWx0ID0gSXZhci5maWxsIHJlc3VsdCAoKSBpblxuICBmdW4gdCB0aW1lIC0+XG4gICAgaWYgVGltZV9ucy4oIDw9ICkgdGltZSAoVGltaW5nX3doZWVsLm5vdyB0LmV2ZW50cylcbiAgICB0aGVuIHJldHVybiAoKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHJlc3VsdCA9IEl2YXIuY3JlYXRlICgpIGluXG4gICAgICBpZ25vcmUgKHJ1bl9hdF9pbnRlcm5hbCB0IHRpbWUgZmlsbCByZXN1bHQgOiBfIEFsYXJtLnQpO1xuICAgICAgSXZhci5yZWFkIHJlc3VsdClcbjs7XG5cbmxldCBhZnRlciB0IHNwYW4gPSBhdCB0IChzcGFuX3RvX3RpbWUgdCBzcGFuKVxuXG5sZXQgcmVtb3ZlX2FsYXJtIHQgYWxhcm0gOiB1bml0ID1cbiAgbGV0IGpvYl9vcl9ldmVudCA9IEFsYXJtLnZhbHVlIHQuZXZlbnRzIGFsYXJtIGluXG4gIChsZXQgb3BlbiBKb2Jfb3JfZXZlbnQuTWF0Y2ggaW5cbiAgIGxldCAoSyBrKSA9IGtpbmQgam9iX29yX2V2ZW50IGluXG4gICBtYXRjaCBrLCBwcm9qZWN0IGsgam9iX29yX2V2ZW50IHdpdGhcbiAgIHwgSm9iLCBqb2IgLT4gU2NoZWR1bGVyLmZyZWVfam9iIHQuc2NoZWR1bGVyIGpvYlxuICAgfCBFdmVudCwgXyAtPlxuICAgICAoKiBUaGlzIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgW2FsYXJtXSBvbmx5IGV2ZXIgY29tZXMgZnJvbSBbRXZlbnQuYWxhcm1dIHdoaWNoIG9ubHlcbiAgICAgICAgZXZlciBnZXRzIHBvcHVsYXRlZCBieSBhIGNhbGwgdG8gW3NjaGVkdWxlX2pvYl0uICopXG4gICAgIGFzc2VydCBmYWxzZSk7XG4gIFRpbWluZ193aGVlbC5yZW1vdmUgdC5ldmVudHMgYWxhcm1cbjs7XG5cbmxldCByZW1vdmVfYWxhcm1faWZfc2NoZWR1bGVkIHQgYWxhcm0gPVxuICBpZiBUaW1pbmdfd2hlZWwubWVtIHQuZXZlbnRzIGFsYXJtIHRoZW4gcmVtb3ZlX2FsYXJtIHQgYWxhcm1cbjs7XG5cbm1vZHVsZSBFdmVudCA9IHN0cnVjdFxuICBtb2R1bGUgRmlyZWQgPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2gpIHQgPVxuICAgICAgfCBBYm9ydGVkIG9mICdhXG4gICAgICB8IEhhcHBlbmVkIG9mICdoXG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kXG5cbiAgdHlwZSAoJ2EsICdoKSB0ID1cbiAgICB7IG11dGFibGUgYWxhcm0gOiBKb2Jfb3JfZXZlbnQudCBBbGFybS50XG4gICAgOyBtdXRhYmxlIGZpcmUgOiB1bml0IC0+IHVuaXRcbiAgICA7ICgqIEFzIGxvbmcgYXMgW0l2YXIuaXNfZW1wdHkgZmlyZWRdLCB3ZSBoYXZlIG5vdCB5ZXQgY29tbWl0dGVkIHRvIHdoZXRoZXIgdGhlIGV2ZW50XG4gICAgICAgICB3aWxsIGhhcHBlbiBvciBiZSBhYm9ydGVkLiAgV2hlbiBbSXZhci5pc19lbXB0eSBmaXJlZF0sIHRoZSBhbGFybSBtYXkgb3IgbWF5IG5vdFxuICAgICAgICAgYmUgaW4gdGhlIHRpbWluZyB3aGVlbCAtLSBpZiBpdCBpc24ndCwgdGhlbiB0aGVyZSdzIGEgam9iIGluIEFzeW5jJ3Mgam9iIHF1ZXVlXG4gICAgICAgICB0aGF0IHdpbGwgZmlyZSB0aGUgZXZlbnQsIHVubGVzcyBpdCBpcyBhYm9ydGVkIGJlZm9yZSB0aGF0IGpvYiBjYW4gcnVuLiAqKVxuICAgICAgZmlyZWQgOiAoJ2EsICdoKSBGaXJlZC50IEl2YXIudFxuICAgIDsgKCogW251bV9maXJlc190b19za2lwXSBpcyB1c2VkIHRvIHJlc2NoZWR1bGUgZXZlbnRzIHRoYXQgaGF2ZSBmaXJlZCBhbmQgZW50ZXJlZCB0aGVcbiAgICAgICAgIEFzeW5jIGpvYiBxdWV1ZSwgYnV0IGhhdmUgbm90IHlldCBydW4uICBUaG9zZSBqb2JzIG9ubHkgcnVuIGlmIFtudW1fZmlyZXNfdG9fc2tpcFxuICAgICAgICAgPSAwXSwgYW5kIG90aGVyd2lzZSBqdXN0IGRlY3JlbWVudCBpdC4gIFNvLCB0byByZXNjaGVkdWxlIGFuIGV2ZW50IGluIHN1Y2ggYVxuICAgICAgICAgc3RhdGUsIHdlIGluY3JlbWVudCBbbnVtX2ZpcmVzX3RvX3NraXBdIGFuZCBhZGQgYSBuZXcgYWxhcm0gdG8gdGhlIHRpbWluZ1xuICAgICAgICAgd2hlZWwuICopXG4gICAgICBtdXRhYmxlIG51bV9maXJlc190b19za2lwIDogaW50XG4gICAgOyAoKiBbc2NoZWR1bGVkX2F0XSBpcyB0aGUgdGltZSBhdCB3aGljaCBbdF0gaGFzIG1vc3QgcmVjZW50bHkgYmVlbiBzY2hlZHVsZWQgdG8gZmlyZS5cbiAgICAgICAgIFdoaWxlIFt0LmFsYXJtXSBpcyBzdGlsbCBpbiB0aGUgdGltaW5nIHdoZWVsLCB0aGlzIGlzIHRoZSBzYW1lIGFzIFtBbGFybS5hdFxuICAgICAgICAgdC5hbGFybV0uICopXG4gICAgICBtdXRhYmxlIHNjaGVkdWxlZF9hdCA6IFRpbWVfbnMudFxuICAgIDsgdGltZV9zb3VyY2UgOiBTeW5jaHJvbm91c190aW1lX3NvdXJjZTAudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG4gIHR5cGUgdF91bml0ID0gKHVuaXQsIHVuaXQpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgZmlyZWQgdCA9IEl2YXIucmVhZCB0LmZpcmVkXG5cbiAgbGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSBpbnZhcmlhbnRfaCB0ID1cbiAgICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IChfLCBfKSB0XSAoZnVuICgpIC0+XG4gICAgICBsZXQgZXZlbnRzID0gdC50aW1lX3NvdXJjZS5ldmVudHMgaW5cbiAgICAgIGxldCBjaGVjayBmID0gSW52YXJpYW50LmNoZWNrX2ZpZWxkIHQgZiBpblxuICAgICAgRmllbGRzLml0ZXJcbiAgICAgICAgfmFsYXJtOlxuICAgICAgICAgIChjaGVjayAoZnVuIGFsYXJtIC0+XG4gICAgICAgICAgICAgaWYgSXZhci5pc19mdWxsIHQuZmlyZWRcbiAgICAgICAgICAgICB0aGVuIGFzc2VydCAobm90IChUaW1pbmdfd2hlZWwubWVtIGV2ZW50cyBhbGFybSkpXG4gICAgICAgICAgICAgZWxzZSBpZiBUaW1pbmdfd2hlZWwubWVtIGV2ZW50cyBhbGFybVxuICAgICAgICAgICAgIHRoZW4gYXNzZXJ0IChKb2Jfb3JfZXZlbnQuaXNfam9iIChBbGFybS52YWx1ZSBldmVudHMgYWxhcm0pKSkpXG4gICAgICAgIH5maXJlOmlnbm9yZVxuICAgICAgICB+ZmlyZWQ6XG4gICAgICAgICAgKGNoZWNrIChmdW4gKGZpcmVkIDogXyBGaXJlZC50IEl2YXIudCkgLT5cbiAgICAgICAgICAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIChJdmFyLnJlYWQgZmlyZWQpIHdpdGhcbiAgICAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICAgICB8IFNvbWUgKEFib3J0ZWQgYSkgLT4gaW52YXJpYW50X2EgYVxuICAgICAgICAgICAgIHwgU29tZSAoSGFwcGVuZWQgaCkgLT4gaW52YXJpYW50X2ggaCkpXG4gICAgICAgIH5udW1fZmlyZXNfdG9fc2tpcDpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBudW1fZmlyZXNfdG9fc2tpcCAtPiBhc3NlcnQgKG51bV9maXJlc190b19za2lwID49IDApKSlcbiAgICAgICAgfnNjaGVkdWxlZF9hdDpcbiAgICAgICAgICAoY2hlY2sgKGZ1biBzY2hlZHVsZWRfYXQgLT5cbiAgICAgICAgICAgICBpZiBUaW1pbmdfd2hlZWwubWVtIGV2ZW50cyB0LmFsYXJtXG4gICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICAgWyV0ZXN0X3Jlc3VsdDogVGltZV9ucy50XVxuICAgICAgICAgICAgICAgICBzY2hlZHVsZWRfYXRcbiAgICAgICAgICAgICAgICAgfmV4cGVjdDooQWxhcm0uYXQgZXZlbnRzIHQuYWxhcm0pKSlcbiAgICAgICAgfnRpbWVfc291cmNlOmlnbm9yZSlcbiAgOztcblxuICBtb2R1bGUgU3RhdHVzID0gc3RydWN0XG4gICAgdHlwZSAoJ2EsICdoKSB0ID1cbiAgICAgIHwgQWJvcnRlZCBvZiAnYVxuICAgICAgfCBIYXBwZW5lZCBvZiAnaFxuICAgICAgfCBTY2hlZHVsZWRfYXQgb2YgVGltZV9ucy50XG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kXG5cbiAgbGV0IHN0YXR1cyB0IDogXyBTdGF0dXMudCA9XG4gICAgbWF0Y2ggRGVmZXJyZWQucGVlayAoSXZhci5yZWFkIHQuZmlyZWQpIHdpdGhcbiAgICB8IE5vbmUgLT4gU2NoZWR1bGVkX2F0IHQuc2NoZWR1bGVkX2F0XG4gICAgfCBTb21lIChBYm9ydGVkIGEpIC0+IEFib3J0ZWQgYVxuICAgIHwgU29tZSAoSGFwcGVuZWQgaCkgLT4gSGFwcGVuZWQgaFxuICA7O1xuXG4gIG1vZHVsZSBBYm9ydF9yZXN1bHQgPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2gpIHQgPVxuICAgICAgfCBPa1xuICAgICAgfCBQcmV2aW91c2x5X2Fib3J0ZWQgb2YgJ2FcbiAgICAgIHwgUHJldmlvdXNseV9oYXBwZW5lZCBvZiAnaFxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIGxldCBhYm9ydCB0IGEgOiBfIEFib3J0X3Jlc3VsdC50ID1cbiAgICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZyBcIlRpbWVfc291cmNlLkV2ZW50LmFib3J0XCIgdCBbJXNleHBfb2Y6IChfLCBfKSB0XTtcbiAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIChmaXJlZCB0KSB3aXRoXG4gICAgfCBTb21lIChBYm9ydGVkIGEpIC0+IFByZXZpb3VzbHlfYWJvcnRlZCBhXG4gICAgfCBTb21lIChIYXBwZW5lZCBoKSAtPiBQcmV2aW91c2x5X2hhcHBlbmVkIGhcbiAgICB8IE5vbmUgLT5cbiAgICAgIEl2YXIuZmlsbCB0LmZpcmVkIChBYm9ydGVkIGEpO1xuICAgICAgcmVtb3ZlX2FsYXJtX2lmX3NjaGVkdWxlZCB0LnRpbWVfc291cmNlIHQuYWxhcm07XG4gICAgICBPa1xuICA7O1xuXG4gIGxldCBhYm9ydF9leG4gdCBhID1cbiAgICBtYXRjaCBhYm9ydCB0IGEgd2l0aFxuICAgIHwgT2sgLT4gKClcbiAgICB8IFByZXZpb3VzbHlfaGFwcGVuZWQgXyAtPlxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2UgXCJDbG9jay5FdmVudC5hYm9ydF9leG4gZmFpbGVkIHRvIGFib3J0IGV2ZW50IHRoYXQgcHJldmlvdXNseSBoYXBwZW5lZFwiXVxuICAgIHwgUHJldmlvdXNseV9hYm9ydGVkIF8gLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlIFwiQ2xvY2suRXZlbnQuYWJvcnRfZXhuIGZhaWxlZCB0byBhYm9ydCBldmVudCB0aGF0IHByZXZpb3VzbHkgYWJvcnRlZFwiXVxuICA7O1xuXG4gIGxldCBhYm9ydF9pZl9wb3NzaWJsZSB0IGEgPSBpZ25vcmUgKGFib3J0IHQgYSA6IF8gQWJvcnRfcmVzdWx0LnQpXG4gIGxldCBzY2hlZHVsZSB0ID0gdC5hbGFybSA8LSBydW5fYXRfaW50ZXJuYWwgdC50aW1lX3NvdXJjZSB0LnNjaGVkdWxlZF9hdCB0LmZpcmUgKClcblxuICBtb2R1bGUgUmVzY2hlZHVsZV9yZXN1bHQgPSBzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2gpIHQgPVxuICAgICAgfCBPa1xuICAgICAgfCBQcmV2aW91c2x5X2Fib3J0ZWQgb2YgJ2FcbiAgICAgIHwgUHJldmlvdXNseV9oYXBwZW5lZCBvZiAnaFxuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIGxldCByZXNjaGVkdWxlX2F0IHQgYXQgOiBfIFJlc2NoZWR1bGVfcmVzdWx0LnQgPVxuICAgIGlmIGRlYnVnXG4gICAgdGhlblxuICAgICAgRGVidWcubG9nIFwiVGltZV9zb3VyY2UuRXZlbnQucmVzY2hlZHVsZV9hdFwiICh0LCBhdCkgWyVzZXhwX29mOiAoXywgXykgdCAqIFRpbWVfbnMudF07XG4gICAgbWF0Y2ggRGVmZXJyZWQucGVlayAoZmlyZWQgdCkgd2l0aFxuICAgIHwgU29tZSAoQWJvcnRlZCBhKSAtPiBQcmV2aW91c2x5X2Fib3J0ZWQgYVxuICAgIHwgU29tZSAoSGFwcGVuZWQgaCkgLT4gUHJldmlvdXNseV9oYXBwZW5lZCBoXG4gICAgfCBOb25lIC0+XG4gICAgICBsZXQgZXZlbnRzID0gdC50aW1lX3NvdXJjZS5ldmVudHMgaW5cbiAgICAgIGxldCBpc19pbl90aW1pbmdfd2hlZWwgPSBUaW1pbmdfd2hlZWwubWVtIGV2ZW50cyB0LmFsYXJtIGluXG4gICAgICBsZXQgYW1fdHJ5aW5nX3RvX3Jlc2NoZWR1bGVfaW5fdGhlX2Z1dHVyZSA9XG4gICAgICAgIFRpbWVfbnMuKCA+ICkgYXQgKFRpbWluZ193aGVlbC5ub3cgZXZlbnRzKVxuICAgICAgaW5cbiAgICAgIHQuc2NoZWR1bGVkX2F0IDwtIGF0O1xuICAgICAgKG1hdGNoIGFtX3RyeWluZ190b19yZXNjaGVkdWxlX2luX3RoZV9mdXR1cmUsIGlzX2luX3RpbWluZ193aGVlbCB3aXRoXG4gICAgICAgfCBmYWxzZSwgZmFsc2UgLT4gKClcbiAgICAgICB8IGZhbHNlLCB0cnVlIC0+XG4gICAgICAgICB0LnRpbWVfc291cmNlLmhhbmRsZV9maXJlZCB0LmFsYXJtO1xuICAgICAgICAgVGltaW5nX3doZWVsLnJlbW92ZSBldmVudHMgdC5hbGFybVxuICAgICAgIHwgdHJ1ZSwgZmFsc2UgLT5cbiAgICAgICAgIHQubnVtX2ZpcmVzX3RvX3NraXAgPC0gdC5udW1fZmlyZXNfdG9fc2tpcCArIDE7XG4gICAgICAgICBzY2hlZHVsZSB0XG4gICAgICAgfCB0cnVlLCB0cnVlIC0+IFRpbWluZ193aGVlbC5yZXNjaGVkdWxlIGV2ZW50cyB0LmFsYXJtIH5hdCk7XG4gICAgICBPa1xuICA7O1xuXG4gIGxldCByZXNjaGVkdWxlX2FmdGVyIHQgc3BhbiA9IHJlc2NoZWR1bGVfYXQgdCAoc3Bhbl90b190aW1lIHQudGltZV9zb3VyY2Ugc3BhbilcblxuICBsZXQgcnVuX2F0IHRpbWVfc291cmNlIHNjaGVkdWxlZF9hdCBmIHogPVxuICAgIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nIFwiVGltZV9zb3VyY2UuRXZlbnQucnVuX2F0XCIgc2NoZWR1bGVkX2F0IFslc2V4cF9vZjogVGltZV9ucy50XTtcbiAgICBsZXQgdCA9XG4gICAgICB7IGFsYXJtID0gQWxhcm0ubnVsbCAoKVxuICAgICAgOyBmaXJlID0gaWdub3JlICgqIHNldCBiZWxvdyAqKVxuICAgICAgOyBmaXJlZCA9IEl2YXIuY3JlYXRlICgpXG4gICAgICA7IG51bV9maXJlc190b19za2lwID0gMFxuICAgICAgOyBzY2hlZHVsZWRfYXRcbiAgICAgIDsgdGltZV9zb3VyY2UgPSByZWFkX29ubHkgdGltZV9zb3VyY2VcbiAgICAgIH1cbiAgICBpblxuICAgIGxldCBmaXJlICgpID1cbiAgICAgICgqIFtmaXJlXSBydW5zIGluIGFuIEFzeW5jIGpvYi4gIFRoZSBldmVudCBtYXkgaGF2ZSBiZWVuIGFib3J0ZWQgYWZ0ZXIgdGhlIGpvYlxuICAgICAgICAgd2FzIGVucXVldWVkLCBzbyBbZmlyZV0gbXVzdCBjaGVjayBbZmlyZWRdLiAqKVxuICAgICAgaWYgSXZhci5pc19lbXB0eSB0LmZpcmVkXG4gICAgICB0aGVuXG4gICAgICAgIGlmIHQubnVtX2ZpcmVzX3RvX3NraXAgPiAwXG4gICAgICAgIHRoZW4gdC5udW1fZmlyZXNfdG9fc2tpcCA8LSB0Lm51bV9maXJlc190b19za2lwIC0gMVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZiB6IGluXG4gICAgICAgICAgKCogW2Ygel0gbWF5IGhhdmUgYWJvcnRlZCB0aGUgZXZlbnQsIHNvIHdlIG11c3QgY2hlY2sgW2ZpcmVkXSBhZ2Fpbi4gKilcbiAgICAgICAgICBpZiBJdmFyLmlzX2VtcHR5IHQuZmlyZWQgdGhlbiBJdmFyLmZpbGwgdC5maXJlZCAoSGFwcGVuZWQgcmVzdWx0KSlcbiAgICBpblxuICAgIHQuZmlyZSA8LSBmaXJlO1xuICAgIHNjaGVkdWxlIHQ7XG4gICAgdFxuICA7O1xuXG4gIGxldCBhdCB0aW1lX3NvdXJjZSB0aW1lID0gcnVuX2F0IHRpbWVfc291cmNlIHRpbWUgaWdub3JlICgpXG5cbiAgbGV0IHJ1bl9hZnRlciB0aW1lX3NvdXJjZSBzcGFuIGYgYSA9XG4gICAgcnVuX2F0IHRpbWVfc291cmNlIChzcGFuX3RvX3RpbWUgdGltZV9zb3VyY2Ugc3BhbikgZiBhXG4gIDs7XG5cbiAgbGV0IGFmdGVyIHRpbWVfc291cmNlIHNwYW4gPSBhdCB0aW1lX3NvdXJjZSAoc3Bhbl90b190aW1lIHRpbWVfc291cmNlIHNwYW4pXG5lbmRcblxubGV0IGF0X3RpbWVzID8oc3RvcCA9IERlZmVycmVkLm5ldmVyICgpKSB0IG5leHRfdGltZSA9XG4gIGxldCB0YWlsID0gVGFpbC5jcmVhdGUgKCkgaW5cbiAgbGV0IHJlYyBsb29wICgpID1cbiAgICBjaG9vc2VcbiAgICAgIFsgY2hvaWNlIHN0b3AgKGZ1biAoKSAtPiBgU3RvcCk7IGNob2ljZSAoYXQgdCAobmV4dF90aW1lICgpKSkgKGZ1biAoKSAtPiBgVGljaykgXVxuICAgID4+PiBmdW5jdGlvblxuICAgIHwgYFN0b3AgLT4gVGFpbC5jbG9zZV9leG4gdGFpbFxuICAgIHwgYFRpY2sgLT5cbiAgICAgIFRhaWwuZXh0ZW5kIHRhaWwgKCk7XG4gICAgICBsb29wICgpXG4gIGluXG4gIGxvb3AgKCk7XG4gIFRhaWwuY29sbGVjdCB0YWlsXG47O1xuXG5sZXQgYXRfdmFyeWluZ19pbnRlcnZhbHMgP3N0b3AgdCBjb21wdXRlX3NwYW4gPVxuICBhdF90aW1lcyB0ID9zdG9wIChmdW4gKCkgLT4gVGltZV9ucy5hZnRlciAobm93IHQpIChjb21wdXRlX3NwYW4gKCkpKVxuOztcblxubGV0IGF0X2ludGVydmFscyA/c3RhcnQgP3N0b3AgdCBpbnRlcnZhbCA9XG4gIGxldCBzdGFydCA9XG4gICAgbWF0Y2ggc3RhcnQgd2l0aFxuICAgIHwgU29tZSB4IC0+IHhcbiAgICB8IE5vbmUgLT4gbm93IHRcbiAgaW5cbiAgYXRfdGltZXMgdCA/c3RvcCAoZnVuICgpIC0+XG4gICAgVGltZV9ucy5uZXh0X211bHRpcGxlIH5iYXNlOnN0YXJ0IH5hZnRlcjoobm93IHQpIH5pbnRlcnZhbCAoKSlcbjs7XG5cbm1vZHVsZSBDb250aW51ZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgSW1tZWRpYXRlbHlcbiAgICB8IEFmdGVyIG9mIFRpbWVfbnMuU3Bhbi50XG4gICAgfCBOZXh0X211bHRpcGxlIG9mIFRpbWVfbnMudCAqIFRpbWVfbnMuU3Bhbi50XG5cbiAgbGV0IGltbWVkaWF0ZWx5ID0gSW1tZWRpYXRlbHlcblxuICBsZXQgYXQgdCB0aW1lX3NvdXJjZSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBJbW1lZGlhdGVseSAtPiBUaW1pbmdfd2hlZWwubm93IHRpbWVfc291cmNlLmV2ZW50c1xuICAgIHwgQWZ0ZXIgc3BhbiAtPiBzcGFuX3RvX3RpbWUgdGltZV9zb3VyY2Ugc3BhblxuICAgIHwgTmV4dF9tdWx0aXBsZSAoYmFzZSwgaW50ZXJ2YWwpIC0+XG4gICAgICBUaW1lX25zLm5leHRfbXVsdGlwbGUgfmJhc2UgfmFmdGVyOihub3cgdGltZV9zb3VyY2UpIH5pbnRlcnZhbCAoKVxuICA7O1xuZW5kXG5cbmxldCBydW5fcmVwZWF0ZWRseVxuICAgICAgPyhzdGFydCA9IHJldHVybiAoKSlcbiAgICAgID9zdG9wXG4gICAgICA/KGNvbnRpbnVlX29uX2Vycm9yID0gdHJ1ZSlcbiAgICAgID8oZmluaXNoZWQgPSBJdmFyLmNyZWF0ZSAoKSlcbiAgICAgIHRcbiAgICAgIH5mXG4gICAgICB+Y29udGludWVcbiAgPVxuICBzdGFydFxuICA+Pj4gZnVuICgpIC0+XG4gIGxldCBhbGFybSA9IHJlZiAoQWxhcm0ubnVsbCAoKSkgaW5cbiAgbGV0IHN0b3AgPVxuICAgIG1hdGNoIHN0b3Agd2l0aFxuICAgIHwgTm9uZSAtPiBEZWZlcnJlZC5uZXZlciAoKVxuICAgIHwgU29tZSBzdG9wIC0+XG4gICAgICB1cG9uIHN0b3AgKGZ1biAoKSAtPlxuICAgICAgICBpZiBUaW1pbmdfd2hlZWwubWVtIHQuZXZlbnRzICFhbGFybVxuICAgICAgICB0aGVuIChcbiAgICAgICAgICByZW1vdmVfYWxhcm0gdCAhYWxhcm07XG4gICAgICAgICAgSXZhci5maWxsX2lmX2VtcHR5IGZpbmlzaGVkICgpKSk7XG4gICAgICBzdG9wXG4gIGluXG4gICgqIFtydW5fZl0sIFtjb250aW51ZV9mXSwgYW5kIFtjb250aW51ZV90cnlfd2l0aF0gYXJlIGRlZmluZWQgc28gdGhhdCB3ZSBhbGxvY2F0ZSB0aGVpclxuICAgICBjbG9zdXJlcyBvbmNlLCBub3Qgb25jZSBwZXIgaXRlcmF0aW9uLiAqKVxuICBsZXQgcmVjIHJ1bl9mICgpID1cbiAgICAoKiBCZWZvcmUgY2FsbGluZyBbZl0sIHdlIHN5bmNocm9ub3VzbHkgY2hlY2sgd2hldGhlciBbc3RvcF0gaXMgZGV0ZXJtaW5lZC4gKilcbiAgICBpZiBEZWZlcnJlZC5pc19kZXRlcm1pbmVkIHN0b3BcbiAgICB0aGVuIEl2YXIuZmlsbF9pZl9lbXB0eSBmaW5pc2hlZCAoKVxuICAgIGVsc2UgaWYgY29udGludWVfb25fZXJyb3JcbiAgICB0aGVuIE1vbml0b3IudHJ5X3dpdGggZiB+cnVuOmBOb3cgfnJlc3Q6YFJhaXNlID4+PiBjb250aW51ZV90cnlfd2l0aFxuICAgIGVsc2UgKFxuICAgICAgbGV0IGQgPSBmICgpIGluXG4gICAgICBpZiBEZWZlcnJlZC5pc19kZXRlcm1pbmVkIGQgdGhlbiBjb250aW51ZV9mICgpIGVsc2UgZCA+Pj4gY29udGludWVfZilcbiAgYW5kIGNvbnRpbnVlX2YgKCkgPVxuICAgIGlmIERlZmVycmVkLmlzX2RldGVybWluZWQgc3RvcFxuICAgIHRoZW4gSXZhci5maWxsX2lmX2VtcHR5IGZpbmlzaGVkICgpXG4gICAgZWxzZSBhbGFybSA6PSBydW5fYXRfaW50ZXJuYWwgdCAoQ29udGludWUuYXQgY29udGludWUgdCkgcnVuX2YgKClcbiAgYW5kIGNvbnRpbnVlX3RyeV93aXRoIG9yX2Vycm9yID1cbiAgICAobWF0Y2ggb3JfZXJyb3Igd2l0aFxuICAgICB8IE9rICgpIC0+ICgpXG4gICAgIHwgRXJyb3IgZXJyb3IgLT4gTW9uaXRvci5zZW5kX2V4biAoTW9uaXRvci5jdXJyZW50ICgpKSBlcnJvcik7XG4gICAgY29udGludWVfZiAoKVxuICBpblxuICBydW5fZiAoKVxuOztcblxubGV0IGV2ZXJ5JyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yID9maW5pc2hlZCB0IHNwYW4gZiA9XG4gIGlmIFRpbWVfbnMuU3Bhbi4oIDw9ICkgc3BhbiBUaW1lX25zLlNwYW4uemVyb1xuICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiVGltZV9zb3VyY2UuZXZlcnkgZ290IG5vbnBvc2l0aXZlIHNwYW5cIiAoc3BhbiA6IFRpbWVfbnMuU3Bhbi50KV07XG4gIHJ1bl9yZXBlYXRlZGx5IHQgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciA/ZmluaXNoZWQgfmYgfmNvbnRpbnVlOihBZnRlciBzcGFuKVxuOztcblxubGV0IGV2ZXJ5ID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgdCBzcGFuIGYgPVxuICBldmVyeScgdCA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yID9maW5pc2hlZDpOb25lIHNwYW4gKGZ1biAoKSAtPlxuICAgIGYgKCk7XG4gICAgcmV0dXJuICgpKVxuOztcblxubGV0IHJ1bl9hdF9pbnRlcnZhbHMnID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgdCBpbnRlcnZhbCBmID1cbiAgbGV0IG5vdyA9IG5vdyB0IGluXG4gIGxldCBiYXNlLCBzdGFydCA9XG4gICAgbWF0Y2ggc3RhcnQgd2l0aFxuICAgIHwgTm9uZSAtPiBub3csIE5vbmVcbiAgICB8IFNvbWUgc3RhcnQgLT5cbiAgICAgICggc3RhcnRcbiAgICAgICwgU29tZVxuICAgICAgICAgIChhdFxuICAgICAgICAgICAgIHRcbiAgICAgICAgICAgICAoVGltZV9ucy5uZXh0X211bHRpcGxlXG4gICAgICAgICAgICAgICAgKClcbiAgICAgICAgICAgICAgICB+YmFzZTpzdGFydFxuICAgICAgICAgICAgICAgIH5hZnRlcjpub3dcbiAgICAgICAgICAgICAgICB+Y2FuX2VxdWFsX2FmdGVyOnRydWVcbiAgICAgICAgICAgICAgICB+aW50ZXJ2YWwpKSApXG4gIGluXG4gIHJ1bl9yZXBlYXRlZGx5XG4gICAgdFxuICAgID9zdGFydFxuICAgID9zdG9wXG4gICAgP2NvbnRpbnVlX29uX2Vycm9yXG4gICAgfmZcbiAgICB+Y29udGludWU6KE5leHRfbXVsdGlwbGUgKGJhc2UsIGludGVydmFsKSlcbjs7XG5cbmxldCBydW5fYXRfaW50ZXJ2YWxzID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgdCBpbnRlcnZhbCBmID1cbiAgcnVuX2F0X2ludGVydmFscycgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciB0IGludGVydmFsIChmdW4gKCkgLT5cbiAgICBmICgpO1xuICAgIHJldHVybiAoKSlcbjs7XG5cbmxldCB3aXRoX3RpbWVvdXQgdCBzcGFuIGQgPVxuICBsZXQgdGltZW91dCA9IEV2ZW50LmFmdGVyIHQgc3BhbiBpblxuICBjaG9vc2VcbiAgICAoKiBUaGUgY29kZSBiZWxvdyBkb2VzIGV4aGF1c3RpdmUgY2FzZSBhbmFseXNpcyBpbiBib3RoIFtjaG9pY2Vdcy4gIEJlY2F1c2UgW3RpbWVvdXRdXG4gICAgICAgZG9lcyBub3QgZXNjYXBlIHRoZSBzY29wZSBvZiB0aGlzIGZ1bmN0aW9uLCBjZXJ0YWluIGNhc2VzIHNob3VsZCBiZSBpbXBvc3NpYmxlLCBhbmRcbiAgICAgICBhcmUgbWFya2VkIGFzIHN1Y2ggd2l0aCBleGNlcHRpb25zLiAgV2UgZG8gbm90IGV4cGVjdCB0aG9zZSBleGNlcHRpb25zIHRvIG9jY3VyLFxuICAgICAgIGJ1dCBpZiB0aGV5IGRvLCBpdCBsaWtlbHkgaW5kaWNhdGVzIGEgYnVnIGluIFtjaG9vc2VdIHJhdGhlciB0aGFuXG4gICAgICAgW3dpdGhfdGltZW91dF0uICopXG4gICAgWyBjaG9pY2UgZCAoZnVuIHYgLT5cbiAgICAgICAgKG1hdGNoIEV2ZW50LmFib3J0IHRpbWVvdXQgKCkgd2l0aFxuICAgICAgICAgKCogW1ByZXZpb3VzbHlfaGFwcGVuZWRdIGNhbiBvY2N1ciBpZiBib3RoIFtkXSBhbmQgW3dhaXRdIGJlY29tZSBkZXRlcm1pbmVkIGF0XG4gICAgICAgICAgICB0aGUgc2FtZSB0aW1lLCBlLmcuIFt3aXRoX3RpbWVvdXQgKHNlYyAwLikgKHJldHVybiAoKSldLiAqKVxuICAgICAgICAgfCBPayB8IFByZXZpb3VzbHlfaGFwcGVuZWQgKCkgLT4gKClcbiAgICAgICAgIHwgUHJldmlvdXNseV9hYm9ydGVkICgpIC0+XG4gICAgICAgICAgIHJhaXNlX3MgWyVtZXNzYWdlIFwiVGltZV9zb3VyY2Uud2l0aF90aW1lb3V0IGJ1Zzogc2hvdWxkIG9ubHkgYWJvcnQgb25jZVwiXSk7XG4gICAgICAgIGBSZXN1bHQgdilcbiAgICA7IGNob2ljZSAoRXZlbnQuZmlyZWQgdGltZW91dCkgKGZ1bmN0aW9uXG4gICAgICAgIHwgSGFwcGVuZWQgKCkgLT4gYFRpbWVvdXRcbiAgICAgICAgfCBBYm9ydGVkICgpIC0+XG4gICAgICAgICAgcmFpc2Vfc1xuICAgICAgICAgICAgWyVtZXNzYWdlIFwiVGltZV9zb3VyY2Uud2l0aF90aW1lb3V0IGJ1ZzogYm90aCBjb21wbGV0ZWQgYW5kIHRpbWVkIG91dFwiXSlcbiAgICBdXG47O1xuXG5sZXQgZHVyYXRpb25fb2YgdCBmID1cbiAgbGV0IHN0YXJ0ID0gbm93IHQgaW5cbiAgbGV0JW1hcCByZXN1bHQgPSBmICgpIGluXG4gIGxldCBkdXJhdGlvbiA9IFRpbWVfbnMuZGlmZiAobm93IHQpIHN0YXJ0IGluXG4gIHJlc3VsdCwgZHVyYXRpb25cbjs7XG5cbmxldCBvZl9zeW5jaHJvbm91cyB0ID0gdFxubGV0IHRvX3N5bmNocm9ub3VzIHQgPSB0XG4iLCJvcGVuISBCYXNlXG5cbnR5cGUgXyB0ID1cbiAgfCBTdGFjayA6ICdhIFN0YWNrLnQgLT4gJ2EgdFxuICB8IENvdW50ZXIgOiB7IG11dGFibGUgbGVuZ3RoIDogaW50IH0gLT4gdW5pdCB0XG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgb2ZfbGlzdCBsaXN0ID0gU3RhY2sgKFN0YWNrLm9mX2xpc3QgbGlzdClcblxubGV0IGNyZWF0ZV9jb3VudGVyIH5sZW5ndGggPVxuICBpZiBsZW5ndGggPCAwXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2UgXCJbU3RhY2tfb3JfY291bnRlci5jcmVhdGVfY291bnRlcl0gZ290IG5lZ2F0aXZlIGxlbmd0aFwiIChsZW5ndGggOiBpbnQpXTtcbiAgQ291bnRlciB7IGxlbmd0aCB9XG47O1xuXG5sZXQgbGVuZ3RoICh0eXBlIGEpICh0IDogYSB0KSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFN0YWNrIHMgLT4gU3RhY2subGVuZ3RoIHNcbiAgfCBDb3VudGVyIHIgLT4gci5sZW5ndGhcbjs7XG5cbmxldCBjbGVhciAodHlwZSBhKSAodCA6IGEgdCkgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTdGFjayBzIC0+IFN0YWNrLmNsZWFyIHNcbiAgfCBDb3VudGVyIHIgLT4gci5sZW5ndGggPC0gMFxuOztcblxubGV0IHB1c2ggKHR5cGUgYSkgKHQgOiBhIHQpIGEgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTdGFjayBzIC0+IFN0YWNrLnB1c2ggcyBhXG4gIHwgQ291bnRlciByIC0+IHIubGVuZ3RoIDwtIHIubGVuZ3RoICsgMVxuOztcblxubGV0IHBvcF9leG4gKHR5cGUgYSkgKHQgOiBhIHQpID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU3RhY2sgcyAtPiBTdGFjay5wb3BfZXhuIHNcbiAgfCBDb3VudGVyIHIgLT5cbiAgICBpZiByLmxlbmd0aCA9IDAgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIltTdGFja19vcl9jb3VudGVyLnBvcF9leG5dIG9mIGVtcHR5IHN0YWNrXCJdO1xuICAgIHIubGVuZ3RoIDwtIHIubGVuZ3RoIC0gMVxuOztcblxubGV0IGl0ZXIgKHR5cGUgYSkgKHQgOiBhIHQpIH4oZiA6IGEgLT4gdW5pdCkgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTdGFjayBzIC0+IFN0YWNrLml0ZXIgcyB+ZlxuICB8IENvdW50ZXIgciAtPlxuICAgIGZvciBfID0gMSB0byByLmxlbmd0aCBkb1xuICAgICAgZiAoKVxuICAgIGRvbmVcbjs7XG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbm9wZW4hIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5cbnR5cGUgJ2Egb3V0Y29tZSA9XG4gIFsgYE9rIG9mICdhXG4gIHwgYEFib3J0ZWRcbiAgfCBgUmFpc2VkIG9mIGV4blxuICBdXG5bQEBkZXJpdmluZyBzZXhwX29mXVxuXG5tb2R1bGUgSW50ZXJuYWxfam9iIDogc2lnXG4gIHR5cGUgJ2EgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHZhbCBjcmVhdGUgOiAoJ2EgLT4gJ2IgRGVmZXJyZWQudCkgLT4gJ2EgdCAqICdiIG91dGNvbWUgRGVmZXJyZWQudFxuXG4gICgqIEV2ZXJ5IGludGVybmFsIGpvYiB3aWxsIGV2ZW50dWFsbHkgYmUgZWl0aGVyIFtydW5dIG9yIFthYm9ydF1lZCwgYnV0IG5vdCBib3RoLiAqKVxuXG4gIHZhbCBydW4gOiAnYSB0IC0+ICdhIC0+IFsgYE9rIHwgYFJhaXNlZCBdIERlZmVycmVkLnRcbiAgdmFsIGFib3J0IDogXyB0IC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHsgc3RhcnQgOiBbIGBBYm9ydCB8IGBTdGFydCBvZiAnYSBdIEl2YXIudFxuICAgIDsgb3V0Y29tZSA6IFsgYE9rIHwgYEFib3J0ZWQgfCBgUmFpc2VkIF0gRGVmZXJyZWQudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgY3JlYXRlIHdvcmsgPVxuICAgIGxldCBzdGFydCA9IEl2YXIuY3JlYXRlICgpIGluXG4gICAgbGV0IHJlc3VsdCA9XG4gICAgICBtYXRjaCViaW5kIEl2YXIucmVhZCBzdGFydCB3aXRoXG4gICAgICB8IGBBYm9ydCAtPiByZXR1cm4gYEFib3J0ZWRcbiAgICAgIHwgYFN0YXJ0IGEgLT5cbiAgICAgICAgKG1hdGNoJW1hcFxuICAgICAgICAgICBNb25pdG9yLnRyeV93aXRoXG4gICAgICAgICAgICAgfnJ1bjpcbiAgICAgICAgICAgICAgIGBTY2hlZHVsZVxuICAgICAgICAgICAgIH5yZXN0OmBMb2dcbiAgICAgICAgICAgICAoZnVuICgpIC0+IHdvcmsgYSlcbiAgICAgICAgIHdpdGhcbiAgICAgICAgIHwgT2sgYSAtPiBgT2sgYVxuICAgICAgICAgfCBFcnJvciBleG4gLT4gYFJhaXNlZCBleG4pXG4gICAgaW5cbiAgICBsZXQgb3V0Y29tZSA9XG4gICAgICBtYXRjaCVtYXAgcmVzdWx0IHdpdGhcbiAgICAgIHwgYE9rIF8gLT4gYE9rXG4gICAgICB8IGBBYm9ydGVkIC0+IGBBYm9ydGVkXG4gICAgICB8IGBSYWlzZWQgXyAtPiBgUmFpc2VkXG4gICAgaW5cbiAgICBsZXQgdCA9IHsgc3RhcnQ7IG91dGNvbWUgfSBpblxuICAgIHQsIHJlc3VsdFxuICA7O1xuXG4gIGxldCBydW4gdCBhID1cbiAgICBJdmFyLmZpbGwgdC5zdGFydCAoYFN0YXJ0IGEpO1xuICAgIG1hdGNoJW1hcCB0Lm91dGNvbWUgd2l0aFxuICAgIHwgYEFib3J0ZWQgLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCAoYE9rIHwgYFJhaXNlZCkgYXMgeCAtPiB4XG4gIDs7XG5cbiAgbGV0IGFib3J0IHQgPSBJdmFyLmZpbGwgdC5zdGFydCBgQWJvcnRcbmVuZFxuXG50eXBlICdhIHQgPVxuICB7IGNvbnRpbnVlX29uX2Vycm9yIDogYm9vbFxuICA7IG1heF9jb25jdXJyZW50X2pvYnMgOiBpbnRcbiAgOyAoKiBbam9iX3Jlc291cmNlc19ub3RfaW5fdXNlXSBob2xkcyByZXNvdXJjZXMgdGhhdCBhcmUgbm90IGN1cnJlbnRseSBpbiB1c2UgYnkgYVxuICAgICAgIHJ1bm5pbmcgam9iLiAqKVxuICAgIGpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSA6ICdhIFN0YWNrX29yX2NvdW50ZXIudFxuICA7XG4gICAgKCogW2pvYnNfd2FpdGluZ190b19zdGFydF0gaXMgdGhlIHF1ZXVlIG9mIGpvYnMgdGhhdCBoYXZlbid0IHlldCBzdGFydGVkLiAqKVxuICAgIGpvYnNfd2FpdGluZ190b19zdGFydCA6ICdhIEludGVybmFsX2pvYi50IFF1ZXVlLnRcbiAgOyAoKiBbMCA8PSBudW1fam9ic19ydW5uaW5nIDw9IG1heF9jb25jdXJyZW50X2pvYnNdLiAqKVxuICAgIG11dGFibGUgbnVtX2pvYnNfcnVubmluZyA6IGludFxuICA7ICgqIFtjYXBhY2l0eV9hdmFpbGFibGVdIGlzIFtTb21lIGl2YXJdIGlmIHVzZXIgY29kZSBoYXMgY2FsbGVkIFtjYXBhY2l0eV9hdmFpbGFibGUgdF1cbiAgICAgICBhbmQgaXMgd2FpdGluZyB0byBiZSBub3RpZmllZCB3aGVuIGNhcGFjaXR5IGlzIGF2YWlsYWJsZSBpbiB0aGUgdGhyb3R0bGUuXG4gICAgICAgW21heWJlX3N0YXJ0X2pvYl0gd2lsbCBmaWxsIFtpdmFyXSB3aGVuIGNhcGFjaXR5IGJlY29tZXMgYXZhaWxhYmxlLCBpLmUuIHdoZW5cbiAgICAgICBbam9ic193YWl0aW5nX3RvX3N0YXJ0XSBpcyBlbXB0eSBhbmQgW251bV9qb2JzX3J1bm5pbmcgPCBtYXhfY29uY3VycmVudF9qb2JzXS4gKilcbiAgICBtdXRhYmxlIGNhcGFjaXR5X2F2YWlsYWJsZSA6IHVuaXQgSXZhci50IG9wdGlvblxuICA7ICgqIFtpc19kZWFkXSBpcyB0cnVlIGlmIFt0XSB3YXMga2lsbGVkIGR1ZSB0byBhIGpvYiByYWlzaW5nIGFuIGV4Y2VwdGlvbiBvciBba2lsbCB0XVxuICAgICAgIGJlaW5nIGNhbGxlZC4gKilcbiAgICBtdXRhYmxlIGlzX2RlYWQgOiBib29sXG4gIDsgKCogW2NsZWFuc10gaG9sZHMgZnVuY3Rpb25zIHRoYXQgd2lsbCBiZSBjYWxsZWQgdG8gY2xlYW4gZWFjaCByZXNvdXJjZSB3aGVuIFt0XSBpc1xuICAgICAgIGtpbGxlZC4gKilcbiAgICBtdXRhYmxlIGNsZWFucyA6ICgnYSAtPiB1bml0IERlZmVycmVkLnQpIGxpc3RcbiAgOyAoKiBbbnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZF0gaXMgdGhlIG51bWJlciBvZiByZXNvdXJjZXMgd2hvc2UgY2xlYW4gZnVuY3Rpb25zIGhhdmVcbiAgICAgICBub3QgeWV0IGNvbXBsZXRlZC4gIFdoaWxlIFt0XSBpcyBhbGl2ZSwgW251bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgPVxuICAgICAgIG1heF9jb25jdXJyZW50X2pvYnNdLiAgT25jZSBbdF0gaXMga2lsbGVkLCBbbnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZF0gZGVjcmVhc2VzIHRvXG4gICAgICAgemVybyBvdmVyIHRpbWUgYXMgdGhlIGNsZWFuIGZ1bmN0aW9ucyBjb21wbGV0ZS4gKilcbiAgICBtdXRhYmxlIG51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgOiBpbnRcbiAgOyAoKiBbY2xlYW5lZF0gYmVjb21lcyBkZXRlcm1pbmVkIHdoZW4gW251bV9yZXNvdXJjZXNfbm90X2NsZWFuZWRdIHJlYWNoZXMgemVybyxcbiAgICAgICBpLmUuIGFmdGVyIFt0XSBpcyBraWxsZWQgYW5kIGFsbCBpdHMgY2xlYW4gZnVuY3Rpb25zIGNvbXBsZXRlLiAqKVxuICAgIGNsZWFuZWQgOiB1bml0IEl2YXIudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA6IHVuaXQgPVxuICB0cnlcbiAgICBsZXQgY2hlY2sgZiBmaWVsZCA9IGYgKEZpZWxkLmdldCBmaWVsZCB0KSBpblxuICAgIEZpZWxkcy5pdGVyXG4gICAgICB+Y29udGludWVfb25fZXJyb3I6aWdub3JlXG4gICAgICB+bWF4X2NvbmN1cnJlbnRfam9iczpcbiAgICAgICAgKGNoZWNrIChmdW4gbWF4X2NvbmN1cnJlbnRfam9icyAtPiBhc3NlcnQgKG1heF9jb25jdXJyZW50X2pvYnMgPiAwKSkpXG4gICAgICB+am9iX3Jlc291cmNlc19ub3RfaW5fdXNlOlxuICAgICAgICAoY2hlY2sgKGZ1biBqb2JfcmVzb3VyY2VzX25vdF9pbl91c2UgLT5cbiAgICAgICAgICAgU3RhY2tfb3JfY291bnRlci5pdGVyIGpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSB+ZjppbnZhcmlhbnRfYTtcbiAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICBTdGFja19vcl9jb3VudGVyLmxlbmd0aCBqb2JfcmVzb3VyY2VzX25vdF9pbl91c2VcbiAgICAgICAgICAgICA9IGlmIHQuaXNfZGVhZCB0aGVuIDAgZWxzZSB0Lm1heF9jb25jdXJyZW50X2pvYnMgLSB0Lm51bV9qb2JzX3J1bm5pbmcpKSlcbiAgICAgIH5qb2JzX3dhaXRpbmdfdG9fc3RhcnQ6XG4gICAgICAgIChjaGVjayAoZnVuY3Rpb24gam9ic193YWl0aW5nX3RvX3N0YXJ0IC0+XG4gICAgICAgICAgIGlmIHQuaXNfZGVhZCB0aGVuIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgam9ic193YWl0aW5nX3RvX3N0YXJ0KSkpXG4gICAgICB+bnVtX2pvYnNfcnVubmluZzpcbiAgICAgICAgKGNoZWNrIChmdW4gbnVtX2pvYnNfcnVubmluZyAtPlxuICAgICAgICAgICBhc3NlcnQgKG51bV9qb2JzX3J1bm5pbmcgPj0gMCk7XG4gICAgICAgICAgIGFzc2VydCAobnVtX2pvYnNfcnVubmluZyA8PSB0Lm1heF9jb25jdXJyZW50X2pvYnMpO1xuICAgICAgICAgICBpZiBudW1fam9ic19ydW5uaW5nIDwgdC5tYXhfY29uY3VycmVudF9qb2JzXG4gICAgICAgICAgIHRoZW4gYXNzZXJ0IChRdWV1ZS5pc19lbXB0eSB0LmpvYnNfd2FpdGluZ190b19zdGFydCkpKVxuICAgICAgfmNhcGFjaXR5X2F2YWlsYWJsZTpcbiAgICAgICAgKGNoZWNrIChmdW5jdGlvblxuICAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICAgfCBTb21lIGl2YXIgLT4gYXNzZXJ0IChJdmFyLmlzX2VtcHR5IGl2YXIpKSlcbiAgICAgIH5pc19kZWFkOmlnbm9yZVxuICAgICAgfmNsZWFuczppZ25vcmVcbiAgICAgIH5udW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkOlxuICAgICAgICAoY2hlY2sgKGZ1biBudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkIC0+XG4gICAgICAgICAgIGFzc2VydCAobnVtX3Jlc291cmNlc19ub3RfY2xlYW5lZCA+PSAwKTtcbiAgICAgICAgICAgYXNzZXJ0IChudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkIDw9IHQubWF4X2NvbmN1cnJlbnRfam9icyk7XG4gICAgICAgICAgIGlmIG51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgPCB0Lm1heF9jb25jdXJyZW50X2pvYnMgdGhlbiBhc3NlcnQgdC5pc19kZWFkKSlcbiAgICAgIH5jbGVhbmVkOlxuICAgICAgICAoY2hlY2sgKGZ1biBjbGVhbmVkIC0+XG4gICAgICAgICAgIGlmIEl2YXIuaXNfZnVsbCBjbGVhbmVkIHRoZW4gYXNzZXJ0ICh0Lm51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgPSAwKSkpXG4gIHdpdGhcbiAgfCBleG4gLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJUaHJvdHRsZS5pbnZhcmlhbnQgZmFpbGVkXCIgKGV4biA6IGV4bikgKHQgOiBfIHQpXVxuOztcblxubW9kdWxlIFQyID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2tpbmQpIHQgPSAnYSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSBfIHQgPSBpbnZhcmlhbnQgaW52YXJpYW50X2EgdFxuZW5kXG5cbmxldCBudW1fam9ic193YWl0aW5nX3RvX3N0YXJ0IHQgPSBRdWV1ZS5sZW5ndGggdC5qb2JzX3dhaXRpbmdfdG9fc3RhcnRcblxubGV0IGNsZWFuX3Jlc291cmNlIHQgYSA9XG4gIERlZmVycmVkLmFsbF91bml0IChMaXN0Lm1hcCB0LmNsZWFucyB+ZjooZnVuIGYgLT4gZiBhKSlcbiAgPj4+IGZ1biAoKSAtPlxuICB0Lm51bV9yZXNvdXJjZXNfbm90X2NsZWFuZWQgPC0gdC5udW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkIC0gMTtcbiAgaWYgdC5udW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkID0gMCB0aGVuIEl2YXIuZmlsbCB0LmNsZWFuZWQgKClcbjs7XG5cbmxldCBraWxsIHQgPVxuICBpZiBub3QgdC5pc19kZWFkXG4gIHRoZW4gKFxuICAgIHQuaXNfZGVhZCA8LSB0cnVlO1xuICAgIFF1ZXVlLml0ZXIgdC5qb2JzX3dhaXRpbmdfdG9fc3RhcnQgfmY6SW50ZXJuYWxfam9iLmFib3J0O1xuICAgIFF1ZXVlLmNsZWFyIHQuam9ic193YWl0aW5nX3RvX3N0YXJ0O1xuICAgIFN0YWNrX29yX2NvdW50ZXIuaXRlciB0LmpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSB+ZjooZnVuIGEgLT4gY2xlYW5fcmVzb3VyY2UgdCBhKTtcbiAgICBTdGFja19vcl9jb3VudGVyLmNsZWFyIHQuam9iX3Jlc291cmNlc19ub3RfaW5fdXNlKVxuOztcblxubGV0IGF0X2tpbGwgdCBmID1cbiAgKCogV2UgcHJlc2VydmUgdGhlIGV4ZWN1dGlvbiBjb250ZXh0IHNvIHRoYXQgZXhjZXB0aW9ucyByYWlzZWQgYnkgW2ZdIGdvIHRvIHRoZSBtb25pdG9yXG4gICAgIGluIGVmZmVjdCB3aGVuIFthdF9raWxsXSB3YXMgY2FsbGVkLiAqKVxuICBsZXQgZiA9IHVuc3RhZ2UgKE1vbml0b3IuRXhwb3J0ZWRfZm9yX3NjaGVkdWxlci5wcmVzZXJ2ZV9leGVjdXRpb25fY29udGV4dCcgZikgaW5cbiAgdC5jbGVhbnMgPC0gZiA6OiB0LmNsZWFuc1xuOztcblxubGV0IGNsZWFuZWQgdCA9IEl2YXIucmVhZCB0LmNsZWFuZWRcblxubGV0IHJlYyBzdGFydF9qb2IgdCA9XG4gIGFzc2VydCAobm90IHQuaXNfZGVhZCk7XG4gIGFzc2VydCAodC5udW1fam9ic19ydW5uaW5nIDwgdC5tYXhfY29uY3VycmVudF9qb2JzKTtcbiAgYXNzZXJ0IChub3QgKFF1ZXVlLmlzX2VtcHR5IHQuam9ic193YWl0aW5nX3RvX3N0YXJ0KSk7XG4gIGxldCBqb2IgPSBRdWV1ZS5kZXF1ZXVlX2V4biB0LmpvYnNfd2FpdGluZ190b19zdGFydCBpblxuICB0Lm51bV9qb2JzX3J1bm5pbmcgPC0gdC5udW1fam9ic19ydW5uaW5nICsgMTtcbiAgbGV0IGpvYl9yZXNvdXJjZSA9IFN0YWNrX29yX2NvdW50ZXIucG9wX2V4biB0LmpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSBpblxuICBJbnRlcm5hbF9qb2IucnVuIGpvYiBqb2JfcmVzb3VyY2VcbiAgPj4+IGZ1biByZXMgLT5cbiAgdC5udW1fam9ic19ydW5uaW5nIDwtIHQubnVtX2pvYnNfcnVubmluZyAtIDE7XG4gIChtYXRjaCByZXMgd2l0aFxuICAgfCBgT2sgLT4gKClcbiAgIHwgYFJhaXNlZCAtPiBpZiBub3QgdC5jb250aW51ZV9vbl9lcnJvciB0aGVuIGtpbGwgdCk7XG4gIGlmIHQuaXNfZGVhZFxuICB0aGVuIGNsZWFuX3Jlc291cmNlIHQgam9iX3Jlc291cmNlXG4gIGVsc2UgKFxuICAgIFN0YWNrX29yX2NvdW50ZXIucHVzaCB0LmpvYl9yZXNvdXJjZXNfbm90X2luX3VzZSBqb2JfcmVzb3VyY2U7XG4gICAgaWYgbm90IChRdWV1ZS5pc19lbXB0eSB0LmpvYnNfd2FpdGluZ190b19zdGFydClcbiAgICB0aGVuIHN0YXJ0X2pvYiB0XG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCB0LmNhcGFjaXR5X2F2YWlsYWJsZSB3aXRoXG4gICAgICB8IE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBpdmFyIC0+XG4gICAgICAgIEl2YXIuZmlsbCBpdmFyICgpO1xuICAgICAgICB0LmNhcGFjaXR5X2F2YWlsYWJsZSA8LSBOb25lKSlcbjs7XG5cbmxldCBjcmVhdGVfaW50ZXJuYWwgfmNvbnRpbnVlX29uX2Vycm9yIGpvYl9yZXNvdXJjZXMgPVxuICBsZXQgbWF4X2NvbmN1cnJlbnRfam9icyA9IFN0YWNrX29yX2NvdW50ZXIubGVuZ3RoIGpvYl9yZXNvdXJjZXMgaW5cbiAgeyBjb250aW51ZV9vbl9lcnJvclxuICA7IG1heF9jb25jdXJyZW50X2pvYnNcbiAgOyBqb2JfcmVzb3VyY2VzX25vdF9pbl91c2UgPSBqb2JfcmVzb3VyY2VzXG4gIDsgam9ic193YWl0aW5nX3RvX3N0YXJ0ID0gUXVldWUuY3JlYXRlICgpXG4gIDsgbnVtX2pvYnNfcnVubmluZyA9IDBcbiAgOyBjYXBhY2l0eV9hdmFpbGFibGUgPSBOb25lXG4gIDsgaXNfZGVhZCA9IGZhbHNlXG4gIDsgY2xlYW5zID0gW11cbiAgOyBudW1fcmVzb3VyY2VzX25vdF9jbGVhbmVkID0gbWF4X2NvbmN1cnJlbnRfam9ic1xuICA7IGNsZWFuZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICB9XG47O1xuXG5sZXQgY3JlYXRlX3dpdGggfmNvbnRpbnVlX29uX2Vycm9yIGpvYl9yZXNvdXJjZXMgPVxuICBjcmVhdGVfaW50ZXJuYWwgfmNvbnRpbnVlX29uX2Vycm9yIChTdGFja19vcl9jb3VudGVyLm9mX2xpc3Qgam9iX3Jlc291cmNlcylcbjs7XG5cbm1vZHVsZSBTZXF1ZW5jZXIgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgY3JlYXRlID8oY29udGludWVfb25fZXJyb3IgPSBmYWxzZSkgYSA9IGNyZWF0ZV93aXRoIH5jb250aW51ZV9vbl9lcnJvciBbIGEgXVxuZW5kXG5cbmxldCBjcmVhdGUgfmNvbnRpbnVlX29uX2Vycm9yIH5tYXhfY29uY3VycmVudF9qb2JzID1cbiAgaWYgbWF4X2NvbmN1cnJlbnRfam9icyA8PSAwXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJUaHJvdHRsZS5jcmVhdGUgcmVxdWlyZXMgcG9zaXRpdmUgbWF4X2NvbmN1cnJlbnRfam9icywgYnV0IGdvdFwiXG4gICAgICAgICAgKG1heF9jb25jdXJyZW50X2pvYnMgOiBpbnQpXTtcbiAgY3JlYXRlX2ludGVybmFsXG4gICAgfmNvbnRpbnVlX29uX2Vycm9yXG4gICAgKFN0YWNrX29yX2NvdW50ZXIuY3JlYXRlX2NvdW50ZXIgfmxlbmd0aDptYXhfY29uY3VycmVudF9qb2JzKVxuOztcblxubW9kdWxlIEpvYiA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPVxuICAgIHsgaW50ZXJuYWxfam9iIDogJ2EgSW50ZXJuYWxfam9iLnRcbiAgICA7IHJlc3VsdCA6IFsgYE9rIG9mICdiIHwgYEFib3J0ZWQgfCBgUmFpc2VkIG9mIGV4biBdIERlZmVycmVkLnRcbiAgICB9XG5cbiAgbGV0IHJlc3VsdCB0ID0gdC5yZXN1bHRcbiAgbGV0IGFib3J0IHQgPSBJbnRlcm5hbF9qb2IuYWJvcnQgdC5pbnRlcm5hbF9qb2JcblxuICBsZXQgY3JlYXRlIGYgPVxuICAgIGxldCBpbnRlcm5hbF9qb2IsIHJlc3VsdCA9IEludGVybmFsX2pvYi5jcmVhdGUgZiBpblxuICAgIHsgaW50ZXJuYWxfam9iOyByZXN1bHQgfVxuICA7O1xuZW5kXG5cbmxldCBlbnF1ZXVlJyB0IGYgPVxuICBsZXQgam9iID0gSm9iLmNyZWF0ZSBmIGluXG4gIGlmIHQuaXNfZGVhZFxuICB0aGVuIEpvYi5hYm9ydCBqb2JcbiAgZWxzZSAoXG4gICAgUXVldWUuZW5xdWV1ZSB0LmpvYnNfd2FpdGluZ190b19zdGFydCBqb2IuaW50ZXJuYWxfam9iO1xuICAgIGlmIHQubnVtX2pvYnNfcnVubmluZyA8IHQubWF4X2NvbmN1cnJlbnRfam9icyB0aGVuIHN0YXJ0X2pvYiB0KTtcbiAgSm9iLnJlc3VsdCBqb2Jcbjs7XG5cbmxldCBoYW5kbGVfZW5xdWV1ZV9yZXN1bHQgcmVzdWx0ID1cbiAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgfCBgT2sgYSAtPiBhXG4gIHwgYEFib3J0ZWQgLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJ0aHJvdHRsZSBhYm9ydGVkIGpvYlwiXVxuICB8IGBSYWlzZWQgZXhuIC0+IHJhaXNlIGV4blxuOztcblxubGV0IGVucXVldWUgdCBmID0gZW5xdWV1ZScgdCBmID4+fCBoYW5kbGVfZW5xdWV1ZV9yZXN1bHRcblxubGV0IGVucXVldWVfZXhjbHVzaXZlIHQgZiA9XG4gIGxldCBuID0gdC5tYXhfY29uY3VycmVudF9qb2JzIGluXG4gIGlmIEludC4oID49ICkgbiAxXzAwMF8wMDBcbiAgdGhlblxuICAgIHJhaXNlX3NcbiAgICAgIFslc2V4cFxuICAgICAgICBcIltlbnF1ZXVlX2V4Y2x1c2l2ZV0gd2FzIGNhbGxlZCB3aXRoIGEgdmVyeSBsYXJnZSB2YWx1ZSBvZiBcXFxuICAgICAgICAgW21heF9jb25jdXJyZW50X2pvYnNdLiBUaGlzIGRvZXNuJ3Qgd29yay5cIl07XG4gIGxldCBkb25lXyA9IEl2YXIuY3JlYXRlICgpIGluXG4gIGFzc2VydCAobiA+IDApO1xuICBsZXQgZl9wbGFjZWhvbGRlciBfc2xvdCA9IEl2YXIucmVhZCBkb25lXyBpblxuICBmb3IgXyA9IDEgdG8gbiAtIDEgZG9cbiAgICBkb24ndF93YWl0X2ZvciAoZW5xdWV1ZSB0IGZfcGxhY2Vob2xkZXIpXG4gIGRvbmU7XG4gIGxldCVtYXAgcmVzdWx0ID0gZW5xdWV1ZScgdCAoZnVuIF9zbG90IC0+IGYgKCkpIGluXG4gIEl2YXIuZmlsbCBkb25lXyAoKTtcbiAgaGFuZGxlX2VucXVldWVfcmVzdWx0IHJlc3VsdFxuOztcblxubGV0IG1vbmFkX3NlcXVlbmNlX2hvdyB+aG93IH5mID1cbiAgc3RhZ2VcbiAgICAobWF0Y2ggaG93IHdpdGhcbiAgICAgfCBgUGFyYWxsZWwgLT4gZlxuICAgICB8IChgU2VxdWVudGlhbCB8IGBNYXhfY29uY3VycmVudF9qb2JzIF8pIGFzIGhvdyAtPlxuICAgICAgIGxldCBtYXhfY29uY3VycmVudF9qb2JzID1cbiAgICAgICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgICAgICB8IGBTZXF1ZW50aWFsIC0+IDFcbiAgICAgICAgIHwgYE1heF9jb25jdXJyZW50X2pvYnMgbWF4X2NvbmN1cnJlbnRfam9icyAtPiBtYXhfY29uY3VycmVudF9qb2JzXG4gICAgICAgaW5cbiAgICAgICBsZXQgdCA9IGNyZWF0ZSB+Y29udGludWVfb25fZXJyb3I6ZmFsc2Ugfm1heF9jb25jdXJyZW50X2pvYnMgaW5cbiAgICAgICBmdW4gYSAtPiBlbnF1ZXVlIHQgKGZ1biAoKSAtPiBmIGEpKVxuOztcblxubGV0IG1vbmFkX3NlcXVlbmNlX2hvdzIgfmhvdyB+ZiA9XG4gIHN0YWdlXG4gICAgKG1hdGNoIGhvdyB3aXRoXG4gICAgIHwgYFBhcmFsbGVsIC0+IGZcbiAgICAgfCAoYFNlcXVlbnRpYWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfKSBhcyBob3cgLT5cbiAgICAgICBsZXQgbWF4X2NvbmN1cnJlbnRfam9icyA9XG4gICAgICAgICBtYXRjaCBob3cgd2l0aFxuICAgICAgICAgfCBgU2VxdWVudGlhbCAtPiAxXG4gICAgICAgICB8IGBNYXhfY29uY3VycmVudF9qb2JzIG1heF9jb25jdXJyZW50X2pvYnMgLT4gbWF4X2NvbmN1cnJlbnRfam9ic1xuICAgICAgIGluXG4gICAgICAgbGV0IHQgPSBjcmVhdGUgfmNvbnRpbnVlX29uX2Vycm9yOmZhbHNlIH5tYXhfY29uY3VycmVudF9qb2JzIGluXG4gICAgICAgZnVuIGExIGEyIC0+IGVucXVldWUgdCAoZnVuICgpIC0+IGYgYTEgYTIpKVxuOztcblxubGV0IHByaW9yX2pvYnNfZG9uZSB0ID1cbiAgKCogV2UgcXVldWUgW3QubWF4X2NvbmN1cnJlbnRfam9ic10gZHVtbXkgam9icyBhbmQgd2hlbiB0aGV5IGFyZSBhbGwgc3RhcnRlZCB3ZSBrbm93XG4gICAgIHRoYXQgYWxsIHByaW9yIGpvYnMgZmluaXNoZWQuICBXZSBtYWtlIHN1cmUgdGhhdCBhbGwgZHVtbXkgam9icyB3YWl0IGZvciB0aGUgbGFzdCBvbmVcbiAgICAgdG8gZ2V0IHN0YXJ0ZWQgYmVmb3JlIGZpbmlzaGluZy4gKilcbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gYWxsX2R1bW15X2pvYnNfcnVubmluZyAtPlxuICAgIGxldCBkdW1teV9qb2JzX3J1bm5pbmcgPSByZWYgMCBpblxuICAgIGZvciBfID0gMSB0byB0Lm1heF9jb25jdXJyZW50X2pvYnMgZG9cbiAgICAgIGRvbid0X3dhaXRfZm9yXG4gICAgICAgIChlbnF1ZXVlIHQgKGZ1biBfIC0+XG4gICAgICAgICAgIGluY3IgZHVtbXlfam9ic19ydW5uaW5nO1xuICAgICAgICAgICBpZiAhZHVtbXlfam9ic19ydW5uaW5nID0gdC5tYXhfY29uY3VycmVudF9qb2JzXG4gICAgICAgICAgIHRoZW4gSXZhci5maWxsIGFsbF9kdW1teV9qb2JzX3J1bm5pbmcgKCk7XG4gICAgICAgICAgIEl2YXIucmVhZCBhbGxfZHVtbXlfam9ic19ydW5uaW5nKSlcbiAgICBkb25lKVxuOztcblxubGV0IGNhcGFjaXR5X2F2YWlsYWJsZSB0ID1cbiAgaWYgbnVtX2pvYnNfcnVubmluZyB0IDwgbWF4X2NvbmN1cnJlbnRfam9icyB0XG4gIHRoZW4gcmV0dXJuICgpXG4gIGVsc2UgKFxuICAgIG1hdGNoIHQuY2FwYWNpdHlfYXZhaWxhYmxlIHdpdGhcbiAgICB8IFNvbWUgaXZhciAtPiBJdmFyLnJlYWQgaXZhclxuICAgIHwgTm9uZSAtPiBEZWZlcnJlZC5jcmVhdGUgKGZ1biBpdmFyIC0+IHQuY2FwYWNpdHlfYXZhaWxhYmxlIDwtIFNvbWUgaXZhcikpXG47O1xuIiwib3BlbiEgQ29yZVxuaW5jbHVkZSBTeW5jaHJvbm91c190aW1lX3NvdXJjZTBcblxubGV0IGNyZWF0ZSA9IFNjaGVkdWxlcjEuY3JlYXRlX3RpbWVfc291cmNlXG5sZXQgd2FsbF9jbG9jayA9IFNjaGVkdWxlcjEud2FsbF9jbG9ja1xuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuISBEZWZlcnJlZF9zdGRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxubW9kdWxlIFNjaGVkdWxlciA9IFNjaGVkdWxlcjFcbm1vZHVsZSBTdHJlYW0gPSBBc3luY19zdHJlYW1cbmluY2x1ZGUgKFNjaGVkdWxlciA6IG1vZHVsZSB0eXBlIG9mIFNjaGVkdWxlciB3aXRoIG1vZHVsZSBCdmFyIDo9IFNjaGVkdWxlci5CdmFyKVxuXG5sZXQgdCA9IFNjaGVkdWxlci50XG5cbmluY2x1ZGUgTW9uaXRvci5FeHBvcnRlZF9mb3Jfc2NoZWR1bGVyXG5cbmxldCBmaW5kX2xvY2FsIGtleSA9IEV4ZWN1dGlvbl9jb250ZXh0LmZpbmRfbG9jYWwgKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgKHQgKCkpKSBrZXlcblxubGV0IHdpdGhfbG9jYWwga2V5IHZhbHVlIH5mID1cbiAgbGV0IHQgPSB0ICgpIGluXG4gIGxldCBleGVjdXRpb25fY29udGV4dCA9XG4gICAgRXhlY3V0aW9uX2NvbnRleHQud2l0aF9sb2NhbCAoY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0KSBrZXkgdmFsdWVcbiAgaW5cbiAgd2l0aF9leGVjdXRpb25fY29udGV4dCB0IGV4ZWN1dGlvbl9jb250ZXh0IH5mXG47O1xuXG5sZXQgbWFpbl9leGVjdXRpb25fY29udGV4dCA9ICh0ICgpKS5tYWluX2V4ZWN1dGlvbl9jb250ZXh0XG5sZXQgY2FuX3J1bl9hX2pvYiB0ID0gbnVtX3BlbmRpbmdfam9icyB0ID4gMCB8fCBCdmFyLmhhc19hbnlfd2FpdGVycyB0LnlpZWxkXG5sZXQgaGFzX3VwY29taW5nX2V2ZW50IHQgPSBub3QgKFRpbWluZ193aGVlbC5pc19lbXB0eSAoZXZlbnRzIHQpKVxubGV0IG5leHRfdXBjb21pbmdfZXZlbnQgdCA9IFRpbWluZ193aGVlbC5uZXh0X2FsYXJtX2ZpcmVzX2F0IChldmVudHMgdClcbmxldCBuZXh0X3VwY29taW5nX2V2ZW50X2V4biB0ID0gVGltaW5nX3doZWVsLm5leHRfYWxhcm1fZmlyZXNfYXRfZXhuIChldmVudHMgdClcbmxldCBldmVudF9wcmVjaXNpb24gdCA9IFRpbWluZ193aGVlbC5hbGFybV9wcmVjaXNpb24gKGV2ZW50cyB0KVxubGV0IGN5Y2xlX3N0YXJ0IHQgPSB0LmN5Y2xlX3N0YXJ0XG5sZXQgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IHQgfmYgPSB0LnJ1bl9ldmVyeV9jeWNsZV9zdGFydCA8LSBmIDo6IHQucnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0XG5sZXQgcnVuX2V2ZXJ5X2N5Y2xlX2VuZCB0IH5mID0gdC5ydW5fZXZlcnlfY3ljbGVfZW5kIDwtIGYgOjogdC5ydW5fZXZlcnlfY3ljbGVfZW5kXG5cbmxldCBhZGRfZXZlcnlfY3ljbGVfc3RhcnRfaG9vayB0IH5mID1cbiAgbGV0IGhhbmRsZSA9IFR5cGVzLkN5Y2xlX2hvb2tfaGFuZGxlLmNyZWF0ZSAoKSBpblxuICBIYXNodGJsLmFkZF9leG4gdC5ydW5fZXZlcnlfY3ljbGVfc3RhcnRfc3RhdGUgfmtleTpoYW5kbGUgfmRhdGE6ZjtcbiAgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IHQgfmY7XG4gIGhhbmRsZVxuOztcblxubGV0IGFkZF9ldmVyeV9jeWNsZV9lbmRfaG9vayB0IH5mID1cbiAgbGV0IGhhbmRsZSA9IFR5cGVzLkN5Y2xlX2hvb2tfaGFuZGxlLmNyZWF0ZSAoKSBpblxuICBIYXNodGJsLmFkZF9leG4gdC5ydW5fZXZlcnlfY3ljbGVfZW5kX3N0YXRlIH5rZXk6aGFuZGxlIH5kYXRhOmY7XG4gIHJ1bl9ldmVyeV9jeWNsZV9lbmQgdCB+ZjtcbiAgaGFuZGxlXG47O1xuXG4oKiBVbmJlbGlldmFibGUgdGhhdCBbTGlzdC5yZW1vdmVdIGlzIG5vdCBhIHRoaW5nICopXG5sZXQgbGlzdF9yZW1vdmVfZmlyc3QgbHN0IH5mID1cbiAgbWF0Y2ggTGlzdC5zcGxpdF93aGlsZSB+ZjooZnVuIHggLT4gbm90IChmIHgpKSBsc3Qgd2l0aFxuICB8IF8sIFtdIC0+IE5vbmVcbiAgfCBsLCBfIDo6IHIgLT4gU29tZSAobCBAIHIpXG47O1xuXG5sZXQgcmVtb3ZlX3NpbmdsZV9jeWNsZV9ob29rIGxzdCBmID1cbiAgKCogUmVtb3ZlIGEgc2luZ2xlIGluc3RhbmNlIG9mIFtmXSBmcm9tIFtsc3RdLiBNb3JlIHRoYW4gb25lIGluc3RhbmNlIG1heSBiZSBwcmVzZW50LFxuICAgICBidXQgcmVtb3ZhbCBpcyByZWZlcmVuY2UtY291bnRlZCBieSBbcnVuX2V2ZXJ5X2N5Y2xlXyhzdGFydHxlbmQpX3N0YXRlXSB0YWJsZXMuICopXG4gIG1hdGNoIGxpc3RfcmVtb3ZlX2ZpcnN0IH5mOihwaHlzX2VxdWFsIGYpIGxzdCB3aXRoXG4gIHwgU29tZSBsc3QgLT4gbHN0XG4gIHwgTm9uZSAtPlxuICAgICgqIFRoaXMgc2hvdWxkIGJlIHVucmVhY2hhYmxlLCBzZWUgdGhlIFtpbnZhcmlhbnRdIGluIFtzY2hlZHVsZXIxLm1sXS4gKilcbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJTY2hlZHVsZXIucmVtb3ZlX3NpbmdsZV9jeWNsZV9ob29rIGNhbGxlZCB3aXRoIGEgaG9vayB0aGF0IGlzbid0IHJlZ2lzdGVyZWRcIl1cbjs7XG5cbmxldCByZW1vdmVfZXZlcnlfY3ljbGVfc3RhcnRfaG9va19leG4gdCBoYW5kbGUgPVxuICBtYXRjaCBIYXNodGJsLmZpbmRfYW5kX3JlbW92ZSB0LnJ1bl9ldmVyeV9jeWNsZV9zdGFydF9zdGF0ZSBoYW5kbGUgd2l0aFxuICB8IE5vbmUgLT5cbiAgICBmYWlsd2l0aCBcIkF0dGVtcHRlZCB0byByZW1vdmUgYSBjeWNsZSBzdGFydCBob29rIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZC5cIlxuICB8IFNvbWUgZiAtPlxuICAgIHQucnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IDwtIHJlbW92ZV9zaW5nbGVfY3ljbGVfaG9vayB0LnJ1bl9ldmVyeV9jeWNsZV9zdGFydCBmXG47O1xuXG5sZXQgcmVtb3ZlX2V2ZXJ5X2N5Y2xlX2VuZF9ob29rX2V4biB0IGhhbmRsZSA9XG4gIG1hdGNoIEhhc2h0YmwuZmluZF9hbmRfcmVtb3ZlIHQucnVuX2V2ZXJ5X2N5Y2xlX2VuZF9zdGF0ZSBoYW5kbGUgd2l0aFxuICB8IE5vbmUgLT5cbiAgICBmYWlsd2l0aCBcIkF0dGVtcHRlZCB0byByZW1vdmUgYSBjeWNsZSBlbmQgaG9vayB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQuXCJcbiAgfCBTb21lIGYgLT4gdC5ydW5fZXZlcnlfY3ljbGVfZW5kIDwtIHJlbW92ZV9zaW5nbGVfY3ljbGVfaG9vayB0LnJ1bl9ldmVyeV9jeWNsZV9lbmQgZlxuOztcblxubGV0IG1hcF9jeWNsZV90aW1lcyB0IH5mID1cbiAgU3RyZWFtLmNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBydW5fZXZlcnlfY3ljbGVfc3RhcnQgdCB+ZjooZnVuICgpIC0+IFRhaWwuZXh0ZW5kIHRhaWwgKGYgdC5sYXN0X2N5Y2xlX3RpbWUpKSlcbjs7XG5cbmxldCBsb25nX2N5Y2xlcyB0IH5hdF9sZWFzdCA9XG4gIFN0cmVhbS5jcmVhdGUgKGZ1biB0YWlsIC0+XG4gICAgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IHQgfmY6KGZ1biAoKSAtPlxuICAgICAgaWYgVGltZV9ucy5TcGFuLiggPj0gKSB0Lmxhc3RfY3ljbGVfdGltZSBhdF9sZWFzdFxuICAgICAgdGhlbiBUYWlsLmV4dGVuZCB0YWlsIHQubGFzdF9jeWNsZV90aW1lKSlcbjs7XG5cbmxldCBjeWNsZV9udW1fam9icyB0ID1cbiAgU3RyZWFtLmNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBydW5fZXZlcnlfY3ljbGVfc3RhcnQgdCB+ZjooZnVuICgpIC0+IFRhaWwuZXh0ZW5kIHRhaWwgdC5sYXN0X2N5Y2xlX251bV9qb2JzKSlcbjs7XG5cbmxldCBjeWNsZV9jb3VudCB0ID0gdC5jeWNsZV9jb3VudFxuXG5sZXQgc2V0X21heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlIHQgaW50ID1cbiAgdC5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZVxuICA8LSBNYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZS5jcmVhdGVfZXhuIGludFxuOztcblxubGV0IG1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlIHQgPVxuICBNYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZS5yYXcgdC5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZVxuOztcblxubGV0IHNldF90aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9vayB0IGYgPSB0LnRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rIDwtIGZcblxubGV0IHRocmVhZF9zYWZlX2VucXVldWVfZXh0ZXJuYWxfam9iIHQgZXhlY3V0aW9uX2NvbnRleHQgZiBhID1cbiAgVGhyZWFkX3NhZmVfcXVldWUuZW5xdWV1ZSB0LmV4dGVybmFsX2pvYnMgKEV4dGVybmFsX2pvYi5UIChleGVjdXRpb25fY29udGV4dCwgZiwgYSkpO1xuICB0LnRocmVhZF9zYWZlX2V4dGVybmFsX2pvYl9ob29rICgpXG47O1xuXG5sZXQgc2V0X2V2ZW50X2FkZGVkX2hvb2sgdCBmID0gdC5ldmVudF9hZGRlZF9ob29rIDwtIFNvbWUgZlxubGV0IHNldF9qb2JfcXVldWVkX2hvb2sgdCBmID0gdC5qb2JfcXVldWVkX2hvb2sgPC0gU29tZSBmXG5cbmxldCBjcmVhdGVfYWxhcm0gdCBmID1cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0IGluXG4gIEdjLkV4cGVydC5BbGFybS5jcmVhdGUgKGZ1biAoKSAtPlxuICAgIHRocmVhZF9zYWZlX2VucXVldWVfZXh0ZXJuYWxfam9iIHQgZXhlY3V0aW9uX2NvbnRleHQgZiAoKSlcbjs7XG5cbmxldCBhZGRfZmluYWxpemVyIHQgaGVhcF9ibG9jayBmID1cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0IGluXG4gIGxldCBmaW5hbGl6ZXIgaGVhcF9ibG9jayA9XG4gICAgKCogSGVyZSB3ZSBjYW4gYmUgaW4gYW55IHRocmVhZCwgYW5kIG1heSBub3QgYmUgaG9sZGluZyB0aGUgYXN5bmMgbG9jay4gIFNvLCB3ZSBjYW5cbiAgICAgICBvbmx5IGRvIHRocmVhZC1zYWZlIHRoaW5ncy5cblxuICAgICAgIEJ5IHB1dHRpbmcgW2hlYXBfYmxvY2tdIGluIFtleHRlcm5hbF9qb2JzXSwgd2UgYXJlIGtlZXBpbmcgaXQgYWxpdmUgdW50aWwgdGhlIG5leHRcbiAgICAgICB0aW1lIHRoZSBhc3luYyBzY2hlZHVsZXIgZ2V0cyBhcm91bmQgdG8gZGVxdWV1ZWluZyBpdC4gIENhbGxpbmdcbiAgICAgICBbdC50aHJlYWRfc2FmZV9leHRlcm5hbF9qb2JfaG9va10gZW5zdXJlcyB0aGF0IHdpbGwgaGFwcGVuIGluIHNob3J0IG9yZGVyLiAgVGh1cyxcbiAgICAgICB3ZSBhcmUgbm90IGRyYW1hdGljYWxseSBpbmNyZWFzaW5nIHRoZSBsaWZldGltZSBvZiBbaGVhcF9ibG9ja10sIHNpbmNlIHRoZSBPQ2FtbFxuICAgICAgIHJ1bnRpbWUgYWxyZWFkeSByZXN1cnJlY3RlZCBbaGVhcF9ibG9ja10gc28gdGhhdCB3ZSBjb3VsZCByZWZlciB0byBpdCBoZXJlLiAgVGhlXG4gICAgICAgT0NhbWwgcnVudGltZSBhbHJlYWR5IHJlbW92ZWQgdGhlIGZpbmFsaXplciBmdW5jdGlvbiB3aGVuIGl0IG5vdGljZWQgW2hlYXBfYmxvY2tdXG4gICAgICAgY291bGQgYmUgZmluYWxpemVkLCBzbyB0aGVyZSBpcyBubyBpbmZpbml0ZSBsb29wIGluIHdoaWNoIHdlIGFyZSBjYXVzaW5nIHRoZVxuICAgICAgIGZpbmFsaXplciB0byBydW4gYWdhaW4uICBBbHNvLCBPQ2FtbCBkb2VzIG5vdCBpbXBvc2UgYW55IHJlcXVpcmVtZW50IG9uIGZpbmFsaXplclxuICAgICAgIGZ1bmN0aW9ucyB0aGF0IHRoZXkgbmVlZCB0byBkaXNwb3NlIG9mIHRoZSBibG9jaywgc28gaXQncyBmaW5lIHRoYXQgd2Uga2VlcFxuICAgICAgIFtoZWFwX2Jsb2NrXSBhcm91bmQgdW50aWwgbGF0ZXIuICopXG4gICAgaWYgRGVidWcuZmluYWxpemVycyB0aGVuIERlYnVnLmxvZ19zdHJpbmcgXCJlbnF1ZXVlaW5nIGZpbmFsaXplclwiO1xuICAgIHRocmVhZF9zYWZlX2VucXVldWVfZXh0ZXJuYWxfam9iIHQgZXhlY3V0aW9uX2NvbnRleHQgZiBoZWFwX2Jsb2NrXG4gIGluXG4gIGlmIERlYnVnLmZpbmFsaXplcnMgdGhlbiBEZWJ1Zy5sb2dfc3RyaW5nIFwiYWRkaW5nIGZpbmFsaXplclwiO1xuICAoKiBXZSB1c2UgW0NhbWwuR2MuZmluYWxpc2VdIGluc3RlYWQgb2YgW0NvcmUuR2MuYWRkX2ZpbmFsaXplcl0gYmVjYXVzZSB0aGUgbGF0dGVyXG4gICAgIGhhcyBpdHMgb3duIHdyYXBwZXIgYXJvdW5kIFtDYW1sLkdjLmZpbmFsaXNlXSB0byBydW4gZmluYWxpemVycyBzeW5jaHJvbm91c2x5LiAqKVxuICB0cnkgQ2FtbC5HYy5maW5hbGlzZSBmaW5hbGl6ZXIgaGVhcF9ibG9jayB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+XG4gICAgKCogW0hlYXBfYmxvY2tdIGVuc3VyZXMgdGhhdCB0aGlzIHdpbGwgb25seSBmYWlsIGZvciBzdGF0aWMgZGF0YSwgaW4gd2hpY2ggY2FzZSB3ZVxuICAgICAgIGNhbiBkcm9wIHRoZSBmaW5hbGl6ZXIgc2luY2UgdGhlIGJsb2NrIHdpbGwgbmV2ZXIgYmUgY29sbGVjdGVkLiopXG4gICAgKClcbjs7XG5cbmxldCBhZGRfZmluYWxpemVyX2V4biB0IHggZiA9XG4gIGFkZF9maW5hbGl6ZXIgdCAoSGVhcF9ibG9jay5jcmVhdGVfZXhuIHgpIChmdW4gaGVhcF9ibG9jayAtPlxuICAgIGYgKEhlYXBfYmxvY2sudmFsdWUgaGVhcF9ibG9jaykpXG47O1xuXG5sZXQgYWRkX2ZpbmFsaXplcl9sYXN0IHQgaGVhcF9ibG9jayBmID1cbiAgbGV0IGV4ZWN1dGlvbl9jb250ZXh0ID0gY3VycmVudF9leGVjdXRpb25fY29udGV4dCB0IGluXG4gIGxldCBmaW5hbGl6ZXIgKCkgPVxuICAgICgqIEhlcmUgd2UgY2FuIGJlIGluIGFueSB0aHJlYWQsIGFuZCBtYXkgbm90IGJlIGhvbGRpbmcgdGhlIGFzeW5jIGxvY2suICBTbywgd2UgY2FuXG4gICAgICAgb25seSBkbyB0aHJlYWQtc2FmZSB0aGluZ3MuICopXG4gICAgaWYgRGVidWcuZmluYWxpemVyc1xuICAgIHRoZW4gRGVidWcubG9nX3N0cmluZyBcImVucXVldWVpbmcgZmluYWxpemVyICh1c2luZyAnbGFzdCcgc2VtYW50aWMpXCI7XG4gICAgdGhyZWFkX3NhZmVfZW5xdWV1ZV9leHRlcm5hbF9qb2IgdCBleGVjdXRpb25fY29udGV4dCBmICgpXG4gIGluXG4gIGlmIERlYnVnLmZpbmFsaXplcnMgdGhlbiBEZWJ1Zy5sb2dfc3RyaW5nIFwiYWRkaW5nIGZpbmFsaXplciAodXNpbmcgJ2xhc3QnIHNlbWFudGljKVwiO1xuICAoKiBXZSB1c2UgW0NhbWwuR2MuZmluYWxpc2VfbGFzdF0gaW5zdGVhZCBvZiBbQ29yZS5HYy5hZGRfZmluYWxpemVyX2xhc3RdIGJlY2F1c2VcbiAgICAgdGhlIGxhdHRlciBoYXMgaXRzIG93biB3cmFwcGVyIGFyb3VuZCBbQ2FtbC5HYy5maW5hbGlzZV9sYXN0XSB0byBydW4gZmluYWxpemVyc1xuICAgICBzeW5jaHJvbm91c2x5LiAqKVxuICB0cnkgQ2FtbC5HYy5maW5hbGlzZV9sYXN0IGZpbmFsaXplciBoZWFwX2Jsb2NrIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT5cbiAgICAoKiBbSGVhcF9ibG9ja10gZW5zdXJlcyB0aGF0IHRoaXMgd2lsbCBvbmx5IGZhaWwgZm9yIHN0YXRpYyBkYXRhLCBpbiB3aGljaCBjYXNlIHdlXG4gICAgICAgY2FuIGRyb3AgdGhlIGZpbmFsaXplciBzaW5jZSB0aGUgYmxvY2sgd2lsbCBuZXZlciBiZSBjb2xsZWN0ZWQuKilcbiAgICAoKVxuOztcblxubGV0IGFkZF9maW5hbGl6ZXJfbGFzdF9leG4gdCB4IGYgPSBhZGRfZmluYWxpemVyX2xhc3QgdCAoSGVhcF9ibG9jay5jcmVhdGVfZXhuIHgpIGZcblxuKCoqIFtmb3JjZV9jdXJyZW50X2N5Y2xlX3RvX2VuZF0gc2V0cyB0aGUgbnVtYmVyIG9mIG5vcm1hbCBqb2JzIGFsbG93ZWQgdG8gcnVuIGluIHRoaXNcbiAgICBjeWNsZSB0byB6ZXJvLiAgVGh1cywgYWZ0ZXIgdGhlIGN1cnJlbnRseSBydW5uaW5nIGpvYiBjb21wbGV0ZXMsIHRoZSBzY2hlZHVsZXIgd2lsbFxuICAgIHN3aXRjaCB0byBsb3cgcHJpb3JpdHkgam9icyBhbmQgdGhlbiBlbmQgdGhlIGN1cnJlbnQgY3ljbGUuICopXG5sZXQgZm9yY2VfY3VycmVudF9jeWNsZV90b19lbmQgdCA9XG4gIEpvYl9xdWV1ZS5zZXRfam9ic19sZWZ0X3RoaXNfY3ljbGUgdC5ub3JtYWxfcHJpb3JpdHlfam9icyAwXG47O1xuXG4oKiBXZSBwcmVhbGxvY2F0ZSBbc2VuZF9leG5dIHRvIGF2b2lkIGFsbG9jYXRpbmcgaXQgb24gZWFjaCBjYWxsIHRvIFthZHZhbmNlX2Nsb2NrXS4gKilcbmxldCBzZW5kX2V4biA9IFNvbWUgTW9uaXRvci5zZW5kX2V4blxuXG5sZXQgYWR2YW5jZV9jbG9jayB0IH5ub3cgPVxuICBTeW5jaHJvbm91c190aW1lX3NvdXJjZTAuYWR2YW5jZV9pbnRlcm5hbCB0LnRpbWVfc291cmNlIH50b186bm93IH5zZW5kX2V4blxuOztcblxubGV0IHJ1bl9jeWNsZSB0ID1cbiAgaWYgZGVidWcgdGhlbiBEZWJ1Zy5sb2cgXCJydW5fY3ljbGUgc3RhcnRpbmdcIiB0IFslc2V4cF9vZjogdF07XG4gIGxldCBub3cgPSBUaW1lX25zLm5vdyAoKSBpblxuICB0LmN5Y2xlX2NvdW50IDwtIHQuY3ljbGVfY291bnQgKyAxO1xuICB0LmN5Y2xlX3N0YXJ0IDwtIG5vdztcbiAgdC5pbl9jeWNsZSA8LSB0cnVlO1xuICBCdmFyLmJyb2FkY2FzdCB0LnlpZWxkICgpO1xuICBsZXQgbnVtX2pvYnNfcnVuX2F0X3N0YXJ0X29mX2N5Y2xlID0gbnVtX2pvYnNfcnVuIHQgaW5cbiAgTGlzdC5pdGVyIHQucnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IH5mOihmdW4gZiAtPiBmICgpKTtcbiAgYWR2YW5jZV9jbG9jayB0IH5ub3c7XG4gIHN0YXJ0X2N5Y2xlIHQgfm1heF9udW1fam9ic19wZXJfcHJpb3JpdHk6dC5tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZTtcbiAgbGV0IHJlYyBydW5fam9icyB0ID1cbiAgICBtYXRjaCBTY2hlZHVsZXIucnVuX2pvYnMgdCB3aXRoXG4gICAgfCBPayAoKSAtPiAoKVxuICAgIHwgRXJyb3IgKGV4biwgYmFja3RyYWNlKSAtPlxuICAgICAgTW9uaXRvci5zZW5kX2V4biAoTW9uaXRvci5jdXJyZW50ICgpKSBleG4gfmJhY2t0cmFjZTooYFRoaXMgYmFja3RyYWNlKTtcbiAgICAgICgqIFtydW5fam9ic10gc3RvcHBlZCBkdWUgdG8gYW4gZXhuLiAgVGhlcmUgbWF5IHN0aWxsIGJlIGpvYnMgdGhhdCBjb3VsZCBiZVxuICAgICAgICAgcnVuIHRoaXMgY3ljbGUsIHNvIFtydW5fam9ic10gYWdhaW4uICopXG4gICAgICBydW5fam9icyB0XG4gIGluXG4gIHJ1bl9qb2JzIHQ7XG4gIGxldCBjeWNsZV90aW1lID0gVGltZV9ucy5kaWZmIChUaW1lX25zLm5vdyAoKSkgdC5jeWNsZV9zdGFydCBpblxuICB0Lmxhc3RfY3ljbGVfdGltZSA8LSBjeWNsZV90aW1lO1xuICB0Lmxhc3RfY3ljbGVfbnVtX2pvYnMgPC0gbnVtX2pvYnNfcnVuIHQgLSBudW1fam9ic19ydW5fYXRfc3RhcnRfb2ZfY3ljbGU7XG4gIHQudG90YWxfY3ljbGVfdGltZSA8LSBUaW1lX25zLlNwYW4uKHQudG90YWxfY3ljbGVfdGltZSArIGN5Y2xlX3RpbWUpO1xuICBpZiBCdmFyLmhhc19hbnlfd2FpdGVycyB0LnlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluICYmIG51bV9wZW5kaW5nX2pvYnMgdCA9IDBcbiAgdGhlbiBCdmFyLmJyb2FkY2FzdCB0LnlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluICgpO1xuICBMaXN0Lml0ZXIgdC5ydW5fZXZlcnlfY3ljbGVfZW5kIH5mOihmdW4gZiAtPiBmICgpKTtcbiAgdC5pbl9jeWNsZSA8LSBmYWxzZTtcbiAgaWYgZGVidWdcbiAgdGhlblxuICAgIERlYnVnLmxvZ1xuICAgICAgXCJydW5fY3ljbGUgZmluaXNoZWRcIlxuICAgICAgKHVuY2F1Z2h0X2V4biB0LCBpc19zb21lIChuZXh0X3VwY29taW5nX2V2ZW50IHQpKVxuICAgICAgWyVzZXhwX29mOiBFcnJvci50IG9wdGlvbiAqIGJvb2xdXG47O1xuXG5sZXQgcnVuX2N5Y2xlc191bnRpbF9ub19qb2JzX3JlbWFpbiAoKSA9XG4gIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nX3N0cmluZyBcInJ1bl9jeWNsZXNfdW50aWxfbm9fam9ic19yZW1haW4gc3RhcnRpbmdcIjtcbiAgbGV0IHQgPSB0ICgpIGluXG4gIGlmIGlzX2RlYWQgdFxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwicnVuX2N5Y2xlc191bnRpbF9ub19qb2JzX3JlbWFpbiBjYW5ub3QgcHJvY2VlZCAtLSBzY2hlZHVsZXIgaXMgZGVhZFwiXG4gICAgICAgICAgfnNjaGVkdWxlcjoodCA6IHQpXTtcbiAgbGV0IHJlYyBsb29wICgpID1cbiAgICBydW5fY3ljbGUgdDtcbiAgICBhZHZhbmNlX2Nsb2NrIHQgfm5vdzooVGltZV9ucy5ub3cgKCkpO1xuICAgIGlmIGNhbl9ydW5fYV9qb2IgdCB0aGVuIGxvb3AgKClcbiAgaW5cbiAgbG9vcCAoKTtcbiAgKCogUmVzZXQgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQgdG8gbWFpbnRhaW4gdGhlIGludmFyaWFudCB0aGF0IHdoZW4gd2UncmUgbm90IGluXG4gICAgIGEgam9iLCBbY3VycmVudF9leGVjdXRpb25fY29udGV4dCA9IG1haW5fZXhlY3V0aW9uX2NvbnRleHRdLiAqKVxuICBzZXRfZXhlY3V0aW9uX2NvbnRleHQgdCB0Lm1haW5fZXhlY3V0aW9uX2NvbnRleHQ7XG4gIGlmIGRlYnVnIHRoZW4gRGVidWcubG9nX3N0cmluZyBcInJ1bl9jeWNsZXNfdW50aWxfbm9fam9ic19yZW1haW4gZmluaXNoZWRcIjtcbiAgT3B0aW9uLml0ZXIgKHVuY2F1Z2h0X2V4biB0KSB+ZjpFcnJvci5yYWlzZVxuOztcblxubGV0IG1ha2VfYXN5bmNfdW51c2FibGUgKCkgPVxuICBsZXQgdCA9ICF0X3JlZiBpblxuICB0LmNoZWNrX2FjY2Vzc1xuICA8LSBTb21lXG4gICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgIHJhaXNlX3MgWyVzZXhwIFwiQXN5bmMgc2NoZWR1bGVyIGlzIHVudXNhYmxlIGR1ZSB0byBbbWFrZV9hc3luY191bnVzYWJsZV1cIl0pXG47O1xuXG5sZXQgcmVzZXRfaW5fZm9ya2VkX3Byb2Nlc3MgKCkgPVxuICBpZiBkZWJ1ZyB0aGVuIERlYnVnLmxvZ19zdHJpbmcgXCJyZXNldF9pbl9mb3JrZWRfcHJvY2Vzc1wiO1xuICAoKiBUaGVyZSBpcyBubyBuZWVkIHRvIGVtcHR5IFttYWluX21vbml0b3JfaG9sZV0uICopXG4gIFNjaGVkdWxlci4odF9yZWYgOj0gY3JlYXRlICgpKVxuOztcblxubGV0IGNoZWNrX2ludmFyaWFudHMgdCA9IHQuY2hlY2tfaW52YXJpYW50c1xubGV0IHNldF9jaGVja19pbnZhcmlhbnRzIHQgYiA9IHQuY2hlY2tfaW52YXJpYW50cyA8LSBiXG5sZXQgc2V0X3JlY29yZF9iYWNrdHJhY2VzIHQgYiA9IHQucmVjb3JkX2JhY2t0cmFjZXMgPC0gYlxubGV0IHlpZWxkIHQgPSBCdmFyLndhaXQgdC55aWVsZFxuXG5sZXQgeWllbGRfdW50aWxfbm9fam9ic19yZW1haW4gPyhtYXlfcmV0dXJuX2ltbWVkaWF0ZWx5ID0gZmFsc2UpIHQgPVxuICBpZiBtYXlfcmV0dXJuX2ltbWVkaWF0ZWx5ICYmIG51bV9wZW5kaW5nX2pvYnMgdCA9IDBcbiAgdGhlbiByZXR1cm4gKClcbiAgZWxzZSBCdmFyLndhaXQgdC55aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpblxuOztcblxubGV0IHlpZWxkX2V2ZXJ5IH5uID1cbiAgaWYgbiA8PSAwXG4gIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJTY2hlZHVsZXIueWllbGRfZXZlcnkgZ290IG5vbnBvc2l0aXZlIGNvdW50XCIgKG4gOiBpbnQpXVxuICBlbHNlIGlmIG4gPSAxXG4gIHRoZW4gc3RhZ2UgKGZ1biB0IC0+IHlpZWxkIHQpXG4gIGVsc2UgKFxuICAgIGxldCBjb3VudF91bnRpbF95aWVsZCA9IHJlZiBuIGluXG4gICAgc3RhZ2UgKGZ1biB0IC0+XG4gICAgICBkZWNyIGNvdW50X3VudGlsX3lpZWxkO1xuICAgICAgaWYgIWNvdW50X3VudGlsX3lpZWxkID4gMFxuICAgICAgdGhlbiByZXR1cm4gKClcbiAgICAgIGVsc2UgKFxuICAgICAgICBjb3VudF91bnRpbF95aWVsZCA6PSBuO1xuICAgICAgICB5aWVsZCB0KSkpXG47O1xuXG5sZXQgdG90YWxfY3ljbGVfdGltZSB0ID1cbiAgKCogQWRqdXN0IGZvciB0aGUgZmFjdCB0aGUgY2FsbGVyJ3MgcHJvYmFibHkgYW4gQXN5bmMgam9iLiAqKVxuICBpZiB0LmluX2N5Y2xlXG4gIHRoZW4gKFxuICAgIGxldCB0aGlzX2N5Y2xlX3RpbWUgPSBUaW1lX25zLihkaWZmIChub3cgKCkpIHQuY3ljbGVfc3RhcnQpIGluXG4gICAgVGltZV9ucy5TcGFuLih0LnRvdGFsX2N5Y2xlX3RpbWUgKyB0aGlzX2N5Y2xlX3RpbWUpKVxuICBlbHNlIHQudG90YWxfY3ljbGVfdGltZVxuOztcblxubW9kdWxlIFZlcnlfbG93X3ByaW9yaXR5X3dvcmsgPSBzdHJ1Y3RcbiAgbW9kdWxlIFdvcmtlcl9yZXN1bHQgPSBWZXJ5X2xvd19wcmlvcml0eV93b3JrZXIuRXhlY19yZXN1bHRcblxuXG4gIGxldCByZWMgcnVuIHQgPSBydW5fd29ya2VycyB0IH5udW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nOjFfMDAwXG5cbiAgYW5kIHJ1bl93b3JrZXJzIHQgfm51bV9leGVjc19iZWZvcmVfeWllbGRpbmcgPVxuICAgIGlmIG51bV9leGVjc19iZWZvcmVfeWllbGRpbmcgPSAwXG4gICAgdGhlbiB5aWVsZF90aGVuX3J1biB0XG4gICAgZWxzZSBpZiBub3QgKERlcXVlLmlzX2VtcHR5IHQudmVyeV9sb3dfcHJpb3JpdHlfd29ya2VycylcbiAgICB0aGVuIChcbiAgICAgIGxldCB3b3JrZXIgPSBEZXF1ZS5kZXF1ZXVlX2Zyb250X2V4biB0LnZlcnlfbG93X3ByaW9yaXR5X3dvcmtlcnMgaW5cbiAgICAgIHNldF9leGVjdXRpb25fY29udGV4dCB0IHdvcmtlci5leGVjdXRpb25fY29udGV4dDtcbiAgICAgIHJ1bl93b3JrZXIgdCB3b3JrZXIgfm51bV9leGVjc19iZWZvcmVfeWllbGRpbmcpXG5cbiAgYW5kIHlpZWxkX3RoZW5fcnVuIHQgPVxuICAgIGlmIG5vdCAoRGVxdWUuaXNfZW1wdHkgdC52ZXJ5X2xvd19wcmlvcml0eV93b3JrZXJzKVxuICAgIHRoZW4gRGVmZXJyZWQudXBvbiAoeWllbGQgdCkgKGZ1biAoKSAtPiBydW4gdClcblxuICBhbmQgcnVuX3dvcmtlciB0IHdvcmtlciB+bnVtX2V4ZWNzX2JlZm9yZV95aWVsZGluZyA9XG4gICAgYXNzZXJ0IChwaHlzX2VxdWFsIHQuY3VycmVudF9leGVjdXRpb25fY29udGV4dCB3b3JrZXIuZXhlY3V0aW9uX2NvbnRleHQpO1xuICAgIGlmIG51bV9leGVjc19iZWZvcmVfeWllbGRpbmcgPSAwXG4gICAgdGhlbiAoXG4gICAgICBEZXF1ZS5lbnF1ZXVlX2Zyb250IHQudmVyeV9sb3dfcHJpb3JpdHlfd29ya2VycyB3b3JrZXI7XG4gICAgICB5aWVsZF90aGVuX3J1biB0KVxuICAgIGVsc2UgKFxuICAgICAgbGV0IG51bV9leGVjc19iZWZvcmVfeWllbGRpbmcgPSBudW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nIC0gMSBpblxuICAgICAgbWF0Y2ggd29ya2VyLmV4ZWMgKCkgd2l0aFxuICAgICAgfCBGaW5pc2hlZCAtPiBydW5fd29ya2VycyB0IH5udW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nXG4gICAgICB8IE5vdF9maW5pc2hlZCAtPiBydW5fd29ya2VyIHQgd29ya2VyIH5udW1fZXhlY3NfYmVmb3JlX3lpZWxkaW5nXG4gICAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgICAgbGV0IGJ0ID0gQmFja3RyYWNlLkV4bi5tb3N0X3JlY2VudCAoKSBpblxuICAgICAgICBNb25pdG9yLnNlbmRfZXhuIChNb25pdG9yLmN1cnJlbnQgKCkpIGV4biB+YmFja3RyYWNlOihgVGhpcyBidCk7XG4gICAgICAgIHJ1bl93b3JrZXJzIHQgfm51bV9leGVjc19iZWZvcmVfeWllbGRpbmcpXG4gIDs7XG5cbiAgbGV0IGVucXVldWUgfmYgPVxuICAgIGxldCB0ID0gdCAoKSBpblxuICAgIGxldCBxdWV1ZSA9IHQudmVyeV9sb3dfcHJpb3JpdHlfd29ya2VycyBpblxuICAgIGxldCBydW5uaW5nID0gbm90IChEZXF1ZS5pc19lbXB0eSBxdWV1ZSkgaW5cbiAgICBsZXQgZXhlY3V0aW9uX2NvbnRleHQgPVxuICAgICAgRXhlY3V0aW9uX2NvbnRleHQuY3JlYXRlX2xpa2UgKGN1cnJlbnRfZXhlY3V0aW9uX2NvbnRleHQgdCkgfnByaW9yaXR5Okxvd1xuICAgIGluXG4gICAgRGVxdWUuZW5xdWV1ZV9iYWNrIHF1ZXVlIHsgZXhlY3V0aW9uX2NvbnRleHQ7IGV4ZWMgPSBmIH07XG4gICAgaWYgbm90IHJ1bm5pbmcgdGhlbiBlbnF1ZXVlIHQgZXhlY3V0aW9uX2NvbnRleHQgcnVuIHRcbiAgOztcbmVuZFxuXG5tb2R1bGUgRm9yX2JlbmNoID0gc3RydWN0XG4gIGxldCBhZHZhbmNlX2Nsb2NrID0gYWR2YW5jZV9jbG9ja1xuZW5kXG5cbmxldCBpbl9jeWNsZSB0ID0gdC5pbl9jeWNsZVxuIiwidHlwZSB0ID0gdW5pdCAtPiB1bml0XG5cbm1vZHVsZSBIYW5kbGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gVHlwZXMuQ3ljbGVfaG9va19oYW5kbGUudFxuZW5kXG4iLCJvcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgU2NoZWR1bGVyXG5cbmxldCBlbnF1ZXVlX2pvYiBleGVjdXRpb25fY29udGV4dCBmIGEgPSBlbnF1ZXVlICh0ICgpKSBleGVjdXRpb25fY29udGV4dCBmIGFcblxubGV0IHRocmVhZF9zYWZlX2VucXVldWVfam9iIGV4ZWN1dGlvbl9jb250ZXh0IGYgYSA9XG4gIHRocmVhZF9zYWZlX2VucXVldWVfZXh0ZXJuYWxfam9iICh0ICgpKSBleGVjdXRpb25fY29udGV4dCBmIGFcbjs7XG5cbmxldCBjdXJyZW50X2V4ZWN1dGlvbl9jb250ZXh0ICgpID0gY3VycmVudF9leGVjdXRpb25fY29udGV4dCAodCAoKSlcbmxldCBjeWNsZV9jb3VudCAoKSA9IGN5Y2xlX2NvdW50ICh0ICgpKVxubGV0IGN5Y2xlX3N0YXJ0X25zICgpID0gY3ljbGVfc3RhcnQgKHQgKCkpXG5sZXQgY3ljbGVfc3RhcnQgKCkgPSBUaW1lX25zLnRvX3RpbWVfZmxvYXRfcm91bmRfbmVhcmVzdCAoY3ljbGVfc3RhcnRfbnMgKCkpXG5sZXQgY3ljbGVfdGltZXNfbnMgKCkgPSBtYXBfY3ljbGVfdGltZXMgKHQgKCkpIH5mOkZuLmlkXG5sZXQgY3ljbGVfdGltZXMgKCkgPSBtYXBfY3ljbGVfdGltZXMgKHQgKCkpIH5mOlRpbWVfbnMuU3Bhbi50b19zcGFuX2Zsb2F0X3JvdW5kX25lYXJlc3RcbmxldCB0b3RhbF9jeWNsZV90aW1lICgpID0gdG90YWxfY3ljbGVfdGltZSAodCAoKSlcbmxldCBsYXN0X2N5Y2xlX3RpbWUgKCkgPSBsYXN0X2N5Y2xlX3RpbWUgKHQgKCkpXG5sZXQgbG9uZ19jeWNsZXMgfmF0X2xlYXN0ID0gbG9uZ19jeWNsZXMgKHQgKCkpIH5hdF9sZWFzdFxubGV0IGV2ZW50X3ByZWNpc2lvbl9ucyAoKSA9IGV2ZW50X3ByZWNpc2lvbiAodCAoKSlcbmxldCBldmVudF9wcmVjaXNpb24gKCkgPSBUaW1lX25zLlNwYW4udG9fc3Bhbl9mbG9hdF9yb3VuZF9uZWFyZXN0IChldmVudF9wcmVjaXNpb25fbnMgKCkpXG5cbmxldCBzZXRfbWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUgaSA9XG4gIHNldF9tYXhfbnVtX2pvYnNfcGVyX3ByaW9yaXR5X3Blcl9jeWNsZSAodCAoKSkgaVxuOztcblxubGV0IG1heF9udW1fam9ic19wZXJfcHJpb3JpdHlfcGVyX2N5Y2xlICgpID0gbWF4X251bV9qb2JzX3Blcl9wcmlvcml0eV9wZXJfY3ljbGUgKHQgKCkpXG5sZXQgc2V0X3JlY29yZF9iYWNrdHJhY2VzIGJvb2wgPSBzZXRfcmVjb3JkX2JhY2t0cmFjZXMgKHQgKCkpIGJvb2xcbmxldCBmb3JjZV9jdXJyZW50X2N5Y2xlX3RvX2VuZCAoKSA9IGZvcmNlX2N1cnJlbnRfY3ljbGVfdG9fZW5kICh0ICgpKVxubGV0IHlpZWxkICgpID0geWllbGQgKHQgKCkpXG5cbmxldCB5aWVsZF91bnRpbF9ub19qb2JzX3JlbWFpbiA/bWF5X3JldHVybl9pbW1lZGlhdGVseSAoKSA9XG4gIHlpZWxkX3VudGlsX25vX2pvYnNfcmVtYWluID9tYXlfcmV0dXJuX2ltbWVkaWF0ZWx5ICh0ICgpKVxuOztcblxubGV0IHlpZWxkX2V2ZXJ5IH5uID1cbiAgbGV0IHlpZWxkX2V2ZXJ5ID0gU3RhZ2VkLnVuc3RhZ2UgKHlpZWxkX2V2ZXJ5IH5uKSBpblxuICBsZXQgdCA9IHQgKCkgaW5cbiAgc3RhZ2UgKGZ1biAoKSAtPiB5aWVsZF9ldmVyeSB0KVxuOztcblxubGV0IG51bV9qb2JzX3J1biAoKSA9IG51bV9qb2JzX3J1biAodCAoKSlcbmxldCBudW1fcGVuZGluZ19qb2JzICgpID0gbnVtX3BlbmRpbmdfam9icyAodCAoKSlcblxubW9kdWxlIEV4cGVydCA9IHN0cnVjdFxuICBsZXQgcnVuX2N5Y2xlc191bnRpbF9ub19qb2JzX3JlbWFpbiA9IHJ1bl9jeWNsZXNfdW50aWxfbm9fam9ic19yZW1haW5cbiAgbGV0IGxhc3RfY3ljbGVfbnVtX2pvYnMgKCkgPSBsYXN0X2N5Y2xlX251bV9qb2JzICh0ICgpKVxuICBsZXQgcnVuX2V2ZXJ5X2N5Y2xlX3N0YXJ0IGYgPSBydW5fZXZlcnlfY3ljbGVfc3RhcnQgKHQgKCkpIH5mXG4gIGxldCBydW5fZXZlcnlfY3ljbGVfZW5kIGYgPSBydW5fZXZlcnlfY3ljbGVfZW5kICh0ICgpKSB+ZlxuICBsZXQgYWRkX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2sgfmYgPSBhZGRfZXZlcnlfY3ljbGVfc3RhcnRfaG9vayAodCAoKSkgfmZcbiAgbGV0IGFkZF9ldmVyeV9jeWNsZV9lbmRfaG9vayB+ZiA9IGFkZF9ldmVyeV9jeWNsZV9lbmRfaG9vayAodCAoKSkgfmZcblxuICBsZXQgcmVtb3ZlX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2tfZXhuIGhhbmRsZSA9XG4gICAgcmVtb3ZlX2V2ZXJ5X2N5Y2xlX3N0YXJ0X2hvb2tfZXhuICh0ICgpKSBoYW5kbGVcbiAgOztcblxuICBsZXQgcmVtb3ZlX2V2ZXJ5X2N5Y2xlX2VuZF9ob29rX2V4biBoYW5kbGUgPVxuICAgIHJlbW92ZV9ldmVyeV9jeWNsZV9lbmRfaG9va19leG4gKHQgKCkpIGhhbmRsZVxuICA7O1xuXG4gIGxldCB3aXRoX2V4ZWN1dGlvbl9jb250ZXh0IGV4ZWN1dGlvbl9jb250ZXh0IGYgPVxuICAgIHdpdGhfZXhlY3V0aW9uX2NvbnRleHQgKHQgKCkpIGV4ZWN1dGlvbl9jb250ZXh0IH5mXG4gIDs7XG5cbiAgbGV0IHdpdGhfZXhlY3V0aW9uX2NvbnRleHQxIGV4ZWN1dGlvbl9jb250ZXh0IH5mIHggPVxuICAgIHdpdGhfZXhlY3V0aW9uX2NvbnRleHQxICh0ICgpKSBleGVjdXRpb25fY29udGV4dCB+ZiB4XG4gIDs7XG5lbmRcblxubW9kdWxlIFByaXZhdGUgPSBTY2hlZHVsZXJcbiIsIigqKiBTY2hlZHVsZSBqb2JzIHRvIHJ1biBhdCBhIHRpbWUgaW4gdGhlIGZ1dHVyZS5cblxuICAgIFRoZSB1bmRlcmx5aW5nIGltcGxlbWVudGF0aW9uIHVzZXMgYSBoZWFwIG9mIGV2ZW50cywgb25lIGZvciBlYWNoIGpvYiB0aGF0IG5lZWRzIHRvXG4gICAgcnVuIGluIHRoZSBmdXR1cmUuICBUaGUgQXN5bmMgc2NoZWR1bGVyIGlzIHJlc3BvbnNpYmxlIGZvciB3YWtpbmcgdXAgYXQgdGhlIHJpZ2h0IHRpbWVcbiAgICB0byBydW4gdGhlIGpvYnMuICopXG5cbm9wZW4gQ29yZVxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5cbm1vZHVsZSBPcl90aW1lb3V0ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgWyBgUmVzdWx0IG9mICdhXG4gICAgfCBgVGltZW91dFxuICAgIF1cbiAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cbmVuZFxuXG5tb2R1bGUgdHlwZSBDbG9jayA9IHNpZ1xuICBtb2R1bGUgT3JfdGltZW91dCA9IE9yX3RpbWVvdXRcblxuICBtb2R1bGUgVGltZSA6IHNpZ1xuICAgIG1vZHVsZSBTcGFuIDogc2lnXG4gICAgICB0eXBlIHRcbiAgICBlbmRcblxuICAgIHR5cGUgdFxuICBlbmRcblxuICAoKiogW3J1bl9hdCB0aW1lIGYgYV0gcnVucyBbZiBhXSBhcyBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIFt0aW1lXS4gIElmIFt0aW1lXSBpcyBpbiB0aGVcbiAgICAgIHBhc3QsIHRoZW4gW3J1bl9hdF0gd2lsbCBpbW1lZGlhdGVseSBzY2hlZHVsZSBhIGpvYiBbdF0gdGhhdCB3aWxsIHJ1biBbZiBhXS4gIEluIG5vXG4gICAgICBzaXR1YXRpb24gd2lsbCBbcnVuX2F0XSBhY3R1YWxseSBjYWxsIFtmXSBpdHNlbGYuICBUaGUgY2FsbCB0byBbZl0gd2lsbCBhbHdheXMgYmUgaW5cbiAgICAgIGFub3RoZXIgam9iLiAqKVxuICB2YWwgcnVuX2F0IDogVGltZS50IC0+ICgnYSAtPiB1bml0KSAtPiAnYSAtPiB1bml0XG5cbiAgKCoqIFtydW5fYWZ0ZXJdIGlzIGxpa2UgW3J1bl9hdF0sIGV4Y2VwdCB0aGF0IG9uZSBzcGVjaWZpZXMgYSB0aW1lIHNwYW4gcmF0aGVyIHRoYW4gYW5cbiAgICAgIGFic29sdXRlIHRpbWUuICopXG4gIHZhbCBydW5fYWZ0ZXIgOiBUaW1lLlNwYW4udCAtPiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdFxuXG4gICgqKiBbYXQgdGltZV0gcmV0dXJucyBhIGRlZmVycmVkIFtkXSB0aGF0IHdpbGwgYmVjb21lIGRldGVybWluZWQgYXMgc29vbiBhcyBwb3NzaWJsZVxuICAgICAgYWZ0ZXIgW3RpbWVdLiAqKVxuICB2YWwgYXQgOiBUaW1lLnQgLT4gdW5pdCBEZWZlcnJlZC50XG5cbiAgKCoqIFthZnRlcl0gaXMgbGlrZSBbYXRdLCBleGNlcHQgdGhhdCBvbmUgc3BlY2lmaWVzIGEgdGltZSBzcGFuIHJhdGhlciB0aGFuIGFuIGFic29sdXRlXG4gICAgICB0aW1lLiAqKVxuICB2YWwgYWZ0ZXIgOiBUaW1lLlNwYW4udCAtPiB1bml0IERlZmVycmVkLnRcblxuICAoKiogW3dpdGhfdGltZW91dCBzcGFuIGRdIHJldHVybnMgYSBkZWZlcnJlZCB0aGF0IHdpbGwgYmVjb21lIGRldGVybWluZWQgYWZ0ZXIgZWl0aGVyXG4gICAgICBbc3Bhbl0gZWxhcHNlcyBvciBbZF0gaXMgZGV0ZXJtaW5lZCwgcmV0dXJuaW5nIGVpdGhlciBbYFRpbWVvdXRdIG9yIFtgUmVzdWx0XVxuICAgICAgZGVwZW5kaW5nIG9uIHdoaWNoIG9uZSBzdWNjZWVkZWQgZmlyc3QuICBBdCB0aGUgdGltZSB0aGUgcmV0dXJuZWQgZGVmZXJyZWQgYmVjb21lc1xuICAgICAgZGV0ZXJtaW5lZCwgYm90aCB0aGluZ3MgbWF5IGhhdmUgaGFwcGVuZWQsIGluIHdoaWNoIGNhc2UgW2BSZXN1bHRdIGlzIGdpdmVuXG4gICAgICBwcmVmZXJlbmNlLiAqKVxuICB2YWwgd2l0aF90aW1lb3V0IDogVGltZS5TcGFuLnQgLT4gJ2EgRGVmZXJyZWQudCAtPiAnYSBPcl90aW1lb3V0LnQgRGVmZXJyZWQudFxuXG4gICgqKiBFdmVudHMgcHJvdmlkZSB2YXJpYW50cyBvZiBbcnVuX2F0XSBhbmQgW3J1bl9hZnRlcl0gd2l0aCB0aGUgYWJpbGl0eSB0byBhYm9ydCBvclxuICAgICAgcmVzY2hlZHVsZSBhbiBldmVudCB0aGF0IGhhc24ndCB5ZXQgaGFwcGVuZWQuICBPbmNlIGFuIGV2ZW50IGhhcHBlbnMgb3IgaXMgYWJvcnRlZCxcbiAgICAgIEFzeW5jIGRvZXNuJ3QgdXNlIGFueSBzcGFjZSBmb3IgdHJhY2tpbmcgaXQuICopXG4gIG1vZHVsZSBFdmVudCA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnaCkgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIHR5cGUgdF91bml0ID0gKHVuaXQsIHVuaXQpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgSW52YXJpYW50LlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICAgIHZhbCBzY2hlZHVsZWRfYXQgOiAoXywgXykgdCAtPiBUaW1lLnRcblxuICAgIG1vZHVsZSBTdGF0dXMgOiBzaWdcbiAgICAgIHR5cGUgKCdhLCAnaCkgdCA9XG4gICAgICAgIHwgQWJvcnRlZCBvZiAnYVxuICAgICAgICB8IEhhcHBlbmVkIG9mICdoXG4gICAgICAgIHwgU2NoZWR1bGVkX2F0IG9mIFRpbWUudFxuICAgICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgICBlbmRcblxuICAgICgqKiBJZiBbc3RhdHVzXSByZXR1cm5zIFtTY2hlZHVsZWRfYXQgdGltZV0sIGl0IGlzIHBvc3NpYmxlIHRoYXQgW3RpbWUgPCBUaW1lLm5vdyAoKV1cbiAgICAgICAgaWYgQXN5bmMncyBzY2hlZHVsZXIgaGFzbid0IHlldCBnb3R0ZW4gdGhlIGNoYW5jZSB0byB1cGRhdGUgaXRzIGNsb2NrLCBlLmcuLCBkdWVcbiAgICAgICAgdG8gdXNlciBqb2JzIHJ1bm5pbmcuICopXG4gICAgdmFsIHN0YXR1cyA6ICgnYSwgJ2gpIHQgLT4gKCdhLCAnaCkgU3RhdHVzLnRcblxuICAgICgqKiBMZXQgW3QgPSBydW5fYXQgdGltZSBmIHpdLiAgQXQgW3RpbWVdLCB0aGlzIHJ1bnMgW2Ygel0gYW5kIHRyYW5zaXRpb25zIFtzdGF0dXMgdF1cbiAgICAgICAgdG8gW0hhcHBlbmVkIGhdLCB3aGVyZSBbaF0gaXMgcmVzdWx0IG9mIFtmIHpdLlxuXG4gICAgICAgIE1vcmUgcHJlY2lzZWx5LCBhdCBbdGltZV0sIHByb3ZpZGVkIFthYm9ydCB0IGFdIGhhcyBub3QgcHJldmlvdXNseSBiZWVuIGNhbGxlZCxcbiAgICAgICAgdGhpcyB3aWxsIGNhbGwgW2Ygel0sIHdpdGggdGhlIGd1YXJhbnRlZSB0aGF0IFtzdGF0dXMgdCA9IFNjaGVkdWxlZF9hdCB0aW1lXS4gIElmXG4gICAgICAgIFtmIHpdIHJldHVybnMgW2hdIGFuZCBkaWQgbm90IGNhbGwgW2Fib3J0IHQgYV0sIHRoZW4gW3N0YXR1cyB0XSBiZWNvbWVzIFtIYXBwZW5lZFxuICAgICAgICBoXS4gIElmIFtmIHpdIGNhbGxzIFthYm9ydCB0IGFdLCB0aGVuIHRoZSByZXN1bHQgb2YgW2ZdIGlzIGlnbm9yZWQsIGFuZCBbc3RhdHVzIHRdXG4gICAgICAgIGlzIFtBYm9ydGVkIGFdLlxuXG4gICAgICAgIElmIFtmIHpdIHJhaXNlcywgdGhlbiBbc3RhdHVzIHRdIGRvZXMgbm90IHRyYW5zaXRpb24gYW5kIHJlbWFpbnMgW1NjaGVkdWxlZF9hdFxuICAgICAgICB0aW1lXSwgYW5kIHRoZSBleGNlcHRpb24gaXMgc2VudCB0byB0aGUgbW9uaXRvciBpbiBlZmZlY3Qgd2hlbiBbcnVuX2F0XSB3YXNcbiAgICAgICAgY2FsbGVkLiAqKVxuICAgIHZhbCBydW5fYXQgOiBUaW1lLnQgLT4gKCd6IC0+ICdoKSAtPiAneiAtPiAoXywgJ2gpIHRcblxuICAgIHZhbCBydW5fYWZ0ZXIgOiBUaW1lLlNwYW4udCAtPiAoJ3ogLT4gJ2gpIC0+ICd6IC0+IChfLCAnaCkgdFxuXG4gICAgbW9kdWxlIEFib3J0X3Jlc3VsdCA9IFRpbWVfc291cmNlLkV2ZW50LkFib3J0X3Jlc3VsdFxuXG4gICAgKCoqIFthYm9ydCB0XSBjaGFuZ2VzIFtzdGF0dXMgdF0gdG8gW0Fib3J0ZWRdIGFuZCByZXR1cm5zIFtPa10sIHVubGVzcyBbdF1cbiAgICAgICAgcHJldmlvdXNseSBoYXBwZW5lZCBvciB3YXMgcHJldmlvdXNseSBhYm9ydGVkLiAqKVxuICAgIHZhbCBhYm9ydCA6ICgnYSwgJ2gpIHQgLT4gJ2EgLT4gKCdhLCAnaCkgQWJvcnRfcmVzdWx0LnRcblxuICAgICgqKiBbYWJvcnRfZXhuIHQgYV0gcmV0dXJucyBbdW5pdF0gaWYgW2Fib3J0IHQgYSA9IGBPa10sIGFuZCBvdGhlcndpc2UgcmFpc2VzLiAqKVxuICAgIHZhbCBhYm9ydF9leG4gOiAoJ2EsICdoKSB0IC0+ICdhIC0+IHVuaXRcblxuICAgICgqKiBbYWJvcnRfaWZfcG9zc2libGUgdCBhID0gaWdub3JlIChhYm9ydCB0IGEpXS4gKilcbiAgICB2YWwgYWJvcnRfaWZfcG9zc2libGUgOiAoJ2EsIF8pIHQgLT4gJ2EgLT4gdW5pdFxuXG4gICAgbW9kdWxlIEZpcmVkID0gVGltZV9zb3VyY2UuRXZlbnQuRmlyZWRcblxuICAgIHZhbCBmaXJlZCA6ICgnYSwgJ2gpIHQgLT4gKCdhLCAnaCkgRmlyZWQudCBEZWZlcnJlZC50XG5cbiAgICBtb2R1bGUgUmVzY2hlZHVsZV9yZXN1bHQgPSBUaW1lX3NvdXJjZS5FdmVudC5SZXNjaGVkdWxlX3Jlc3VsdFxuXG4gICAgKCoqIFtyZXNjaGVkdWxlX2F0IHRdIGFuZCBbcmVzY2hlZHVsZV9hZnRlciB0XSBjaGFuZ2UgdGhlIHRpbWUgdGhhdCBbdF0gd2lsbCBmaXJlLCBpZlxuICAgICAgICBwb3NzaWJsZSwgYW5kIGlmIG5vdCwgZ2l2ZSBhIHJlYXNvbiB3aHkuICBMaWtlIFtydW5fYXRdLCBpZiB0aGUgcmVxdWVzdGVkIHRpbWUgaXNcbiAgICAgICAgaW4gdGhlIHBhc3QsIHRoZSBldmVudCB3aWxsIGJlIHNjaGVkdWxlZCB0byBydW4gaW1tZWRpYXRlbHkuICBJZiBbcmVzY2hlZHVsZV9hdCB0XG4gICAgICAgIHRpbWUgPSBPa10sIHRoZW4gc3Vic2VxdWVudGx5IFtzY2hlZHVsZWRfYXQgdCA9IHRpbWVdLiAgKilcbiAgICB2YWwgcmVzY2hlZHVsZV9hdCA6ICgnYSwgJ2gpIHQgLT4gVGltZS50IC0+ICgnYSwgJ2gpIFJlc2NoZWR1bGVfcmVzdWx0LnRcblxuICAgIHZhbCByZXNjaGVkdWxlX2FmdGVyIDogKCdhLCAnaCkgdCAtPiBUaW1lLlNwYW4udCAtPiAoJ2EsICdoKSBSZXNjaGVkdWxlX3Jlc3VsdC50XG5cbiAgICAoKiogW2F0IHRpbWVdICAgIGlzIFtydW5fYXQgICAgdGltZSBpZ25vcmUgKCldLlxuICAgICAgICBbYWZ0ZXIgdGltZV0gaXMgW3J1bl9hZnRlciB0aW1lIGlnbm9yZSAoKV0uXG5cbiAgICAgICAgWW91IHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSB0aGUgW3J1bl8qXSBmdW5jdGlvbnMsIHdoaWNoIGFsbG93IHlvdSB0b1xuICAgICAgICBzeW5jaHJvbm91c2x5IHVwZGF0ZSBzdGF0ZSB2aWEgYSB1c2VyLXN1cHBsaWVkIGZ1bmN0aW9uIHdoZW4gdGhlIGV2ZW50XG4gICAgICAgIHRyYW5zaXRpb25zIHRvIFtIYXBwZW5lZF0uICBUaGF0IGlzLCB0aGVyZSBpcyBhbiBpbXBvcnRhbnQgZGlmZmVyZW5jZSBiZXR3ZWVuOlxuXG4gICAgICAgIHtbXG4gICAgICAgICAgbGV0IHQgPSBydW5fYXQgdGltZSBmICgpIF19XG5cbiAgICAgICAgYW5kOlxuXG4gICAgICAgIHtbXG4gICAgICAgICAgbGV0IHQgPSBhdCB0aW1lIGluXG4gICAgICAgICAgZmlyZWQgdFxuICAgICAgICAgID4+PiBmdW5jdGlvblxuICAgICAgICAgIHwgSGFwcGVuZWQgKCkgLT4gZiAoKVxuICAgICAgICAgIHwgQWJvcnRlZCAoKSAtPiAoKSBdfVxuXG4gICAgICAgIFdpdGggW3J1bl9hdF0sIGlmIFtzdGF0dXMgdCA9IEhhcHBlbmVkXSwgb25lIGtub3dzIHRoYXQgW2ZdIGhhcyBydW4uICBXaXRoIFthdF1cbiAgICAgICAgYW5kIFtmaXJlZF0sIG9uZSBkb2VzIG5vdCBrbm93IHdoZXRoZXIgW2ZdIGhhcyB5ZXQgcnVuOyBpdCBtYXkgc3RpbGwgYmUgc2NoZWR1bGVkXG4gICAgICAgIHRvIHJ1bi4gIFRodXMsIHdpdGggW2F0XSBhbmQgW2ZpcmVkXSwgaXQgaXMgZWFzeSB0byBpbnRyb2R1Y2UgYSByYWNlLiAgRm9yXG4gICAgICAgIGV4YW1wbGUsIGNvbnNpZGVyIHRoZXNlIHR3byBjb2RlIHNuaXBwZXRzOlxuXG4gICAgICAgIHtbXG4gICAgICAgICAgbGV0IHQgPSBFdmVudC5hZnRlciAoc2VjIDIuKSBpblxuICAgICAgICAgIHVwb24gKEV2ZW50LmZpcmVkIHQpIChmdW5jdGlvblxuICAgICAgICAgICAgfCBBYm9ydGVkICgpIC0+ICgpXG4gICAgICAgICAgICB8IEhhcHBlbmVkICgpIC0+IHByaW50ZiBcIlRpbWVyIGZpcmVkXCIpO1xuICAgICAgICAgIHVwb24gZGVmZXJyZWRfZXZlbnQgKGZ1biAoKSAtPlxuICAgICAgICAgICAgbWF0Y2ggRXZlbnQuYWJvcnQgdCAoKSB3aXRoXG4gICAgICAgICAgICB8IE9rIC0+IHByaW50ZiBcIkV2ZW50IG9jY3VycmVkXCJcbiAgICAgICAgICAgIHwgUHJldmlvdXNseV9hYm9ydGVkICgpIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgfCBQcmV2aW91c2x5X2hhcHBlbmVkICgpIC0+IHByaW50ZiBcIkV2ZW50IG9jY3VycmVkIGFmdGVyIHRpbWVyIGZpcmVkXCIpOyBdfVxuXG4gICAgICAgIHtbXG4gICAgICAgICAgbGV0IHQgPSBFdmVudC5ydW5fYWZ0ZXIgKHNlYyAyLikgcHJpbnRmIFwiVGltZXIgZmlyZWRcIiBpblxuICAgICAgICAgIHVwb24gZGVmZXJyZWRfZXZlbnQgKGZ1biAoKSAtPlxuICAgICAgICAgICAgbWF0Y2ggRXZlbnQuYWJvcnQgdCAoKSB3aXRoXG4gICAgICAgICAgICB8IE9rIC0+IHByaW50ZiBcIkV2ZW50IG9jY3VycmVkXCJcbiAgICAgICAgICAgIHwgUHJldmlvdXNseV9hYm9ydGVkICgpIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgfCBQcmV2aW91c2x5X2hhcHBlbmVkICgpIC0+IHByaW50ZiBcIkV2ZW50IG9jY3VycmVkIGFmdGVyIHRpbWVyIGZpcmVkXCIpOyBdfVxuXG4gICAgICAgIEluIGJvdGggc25pcHBldHMsIGlmIFtFdmVudC5hYm9ydF0gcmV0dXJucyBbT2tdLCBcIlRpbWVyIGZpcmVkXCIgaXMgbmV2ZXIgcHJpbnRlZC5cbiAgICAgICAgSG93ZXZlciwgdGhlIGZpcnN0IHNuaXBwZXQgbWlnaHQgcHJpbnQgXCJFdmVudCBvY2N1cnJlZCBhZnRlciB0aW1lciBmaXJlZFwiIGFuZCB0aGVuXG4gICAgICAgIFwiVGltZXIgZmlyZWRcIi4gIFRoaXMgY29uZnVzZWQgb3JkZXJpbmcgY2Fubm90IGhhcHBlbiB3aXRoIFtFdmVudC5ydW5fYWZ0ZXJdLiAqKVxuICAgIHZhbCBhdCA6IFRpbWUudCAtPiAoXywgdW5pdCkgdFxuXG4gICAgdmFsIGFmdGVyIDogVGltZS5TcGFuLnQgLT4gKF8sIHVuaXQpIHRcbiAgZW5kXG5cbiAgKCoqIFthdF92YXJ5aW5nX2ludGVydmFscyBmID9zdG9wXSByZXR1cm5zIGEgc3RyZWFtIHdob3NlIG5leHQgZWxlbWVudCBiZWNvbWVzXG4gICAgICBkZXRlcm1pbmVkIGJ5IGNhbGxpbmcgW2YgKCldIGFuZCB3YWl0aW5nIGZvciB0aGF0IGFtb3VudCBvZiB0aW1lLCBhbmQgdGhlbiBsb29waW5nXG4gICAgICB0byBkZXRlcm1pbmUgc3Vic2VxdWVudCBlbGVtZW50cy4gIFRoZSBzdHJlYW0gd2lsbCBlbmQgYWZ0ZXIgW3N0b3BdIGJlY29tZXNcbiAgICAgIGRldGVybWluZWQuICopXG4gIHZhbCBhdF92YXJ5aW5nX2ludGVydmFsc1xuICAgIDogID9zdG9wOnVuaXQgRGVmZXJyZWQudFxuICAgIC0+ICh1bml0IC0+IFRpbWUuU3Bhbi50KVxuICAgIC0+IHVuaXQgQXN5bmNfc3RyZWFtLnRcblxuICAoKiogW2F0X2ludGVydmFscyBpbnRlcnZhbCA/c3RhcnQgP3N0b3BdIHJldHVybnMgYSBzdHJlYW0gd2hvc2UgZWxlbWVudHMgd2lsbCBiZWNvbWVcbiAgICAgIGRldGVybWluZWQgYXQgbm9ubmVnYXRpdmUgaW50ZWdlciBtdWx0aXBsZXMgb2YgW2ludGVydmFsXSBhZnRlciB0aGUgW3N0YXJ0XSB0aW1lLFxuICAgICAgdW50aWwgW3N0b3BdIGJlY29tZXMgZGV0ZXJtaW5lZDpcblxuICAgICAge3ZcbiAgICAgICAgc3RhcnQgKyAwICogaW50ZXJ2YWxcbiAgICAgICAgc3RhcnQgKyAxICogaW50ZXJ2YWxcbiAgICAgICAgc3RhcnQgKyAyICogaW50ZXJ2YWxcbiAgICAgICAgc3RhcnQgKyAzICogaW50ZXJ2YWxcbiAgICAgICAgLi4uXG4gICAgICB2fVxuXG4gICAgICBOb3RlIHRoYXQgb25seSBlbGVtZW50cyB0aGF0IGFyZSBzdHJpY3RseSBpbiB0aGUgZnV0dXJlIGV2ZXIgYmVjb21lIGRldGVybWluZWQuXG4gICAgICBJbiBwYXJ0aWN1bGFyLCBpZiBbc3RhcnRdIGlzIG5vdCBpbiB0aGUgZnV0dXJlLCBvciBbc3RhcnRdIGlzIG5vdCBwcm92aWRlZCxcbiAgICAgIHRoZW4gdGhlcmUgd2lsbCBiZSBubyBlbGVtZW50IGJlZm9yZSB0aGUgW2ludGVydmFsXSBoYXMgcGFzc2VkLlxuXG4gICAgICBJZiB0aGUgaW50ZXJ2YWwgaXMgdG9vIHNtYWxsIG9yIHRoZSBDUFUgaXMgdG9vIGxvYWRlZCwgW2F0X2ludGVydmFsc10gd2lsbCBza2lwXG4gICAgICB1bnRpbCB0aGUgbmV4dCB1cGNvbWluZyBtdWx0aXBsZSBvZiBbaW50ZXJ2YWxdIGFmdGVyIFtzdGFydF0uICopXG4gIHZhbCBhdF9pbnRlcnZhbHNcbiAgICA6ICA/c3RhcnQ6VGltZS50XG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50XG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiB1bml0IEFzeW5jX3N0cmVhbS50XG5cbiAgKCoqIFtldmVyeScgP3N0YXJ0ID9zdG9wIHNwYW4gZl0gcnVucyBbZiAoKV0gZXZlcnkgW3NwYW5dIGFtb3VudCBvZiB0aW1lIHN0YXJ0aW5nIHdoZW5cbiAgICAgIFtzdGFydF0gYmVjb21lcyBkZXRlcm1pbmVkIGFuZCBzdG9wcGluZyB3aGVuIFtzdG9wXSBiZWNvbWVzIGRldGVybWluZWQuICBbZXZlcnknXVxuICAgICAgd2FpdHMgdW50aWwgdGhlIG91dGNvbWUgb2YgW2YgKCldIGJlY29tZXMgZGV0ZXJtaW5lZCBiZWZvcmUgd2FpdGluZyBmb3IgdGhlIG5leHRcbiAgICAgIFtzcGFuXS5cblxuICAgICAgSXQgaXMgZ3VhcmFudGVlZCB0aGF0IGlmIFtzdG9wXSBiZWNvbWVzIGRldGVybWluZWQsIGV2ZW4gZHVyaW5nIGV2YWx1YXRpb24gb2YgW2ZdLFxuICAgICAgdGhlbiBbZl0gd2lsbCBub3QgYmUgY2FsbGVkIGFnYWluIGJ5IGEgc3Vic2VxdWVudCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuXG5cbiAgICAgIEl0IGlzIGFuIGVycm9yIGZvciBbc3Bhbl0gdG8gYmUgbm9ucG9zaXRpdmUuXG5cbiAgICAgIFtjb250aW51ZV9vbl9lcnJvcl0gY29udHJvbHMgd2hhdCBzaG91bGQgaGFwcGVuIGlmIFtmXSByYWlzZXMgYW4gZXhjZXB0aW9uLlxuICAgICAgV2l0aCBbfmNvbnRpbnVlX29uX2Vycm9yOmZhbHNlXSwgaXRlcmF0aW9uIG9ubHkgY29udGludWVzIGlmIFtmXSBzdWNjZXNzZnVsbHlcbiAgICAgIHJldHVybnMgYSBkZWZlcnJlZCBhbmQgdGhhdCBkZWZlcnJlZCBpcyBkZXRlcm1pbmVkLlxuICAgICAgV2l0aCBbfmNvbnRpbnVlX29uX2Vycm9yOnRydWVdLCBpdGVyYXRpb24gYWxzbyBjb250aW51ZXMgaWYgW2ZdIHJhaXNlcyBhbiBleGNlcHRpb24uXG4gICAgICBJZiBbZl0gcmFpc2VzIGFuIGV4Y2VwdGlvbiBhc3luY2hyb25vdXNseSwgdGhpcyBtYXkgY2F1c2UgdXMgdG8gcHJvY2VlZCB3aXRoIHRoZVxuICAgICAgbmV4dCBpdGVyYXRpb24gd2hpbGUgdGhlIHByZXZpb3VzIGNhbGwgdG8gW2ZdIGlzIHN0aWxsIHJ1bm5pbmcuXG5cbiAgICAgIEV4Y2VwdGlvbnMgcmFpc2VkIGJ5IFtmXSBhcmUgYWx3YXlzIHNlbnQgdG8gdGhlIG1vbml0b3IgaW4gZWZmZWN0IHdoZW4gW2V2ZXJ5J10gd2FzXG4gICAgICBjYWxsZWQsIGV2ZW4gd2l0aCBbfmNvbnRpbnVlX29uX2Vycm9yOnRydWVdLlxuXG4gICAgICBJZiBbZmluaXNoZWRdIGlzIHN1cHBsaWVkLCBbZXZlcnknXSB3aWxsIGZpbGwgaXQgb25jZSBhbGwgb2YgdGhlIGZvbGxvd2luZyBiZWNvbWVcbiAgICAgIGRldGVybWluZWQ6IFtzdGFydF0sIFtzdG9wXSwgYW5kIHRoZSBvdXRjb21lIG9mIHRoZSBmaW5hbCBjYWxsIHRvIFtmXS4gKilcbiAgdmFsIGV2ZXJ5J1xuICAgIDogID9zdGFydDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW3JldHVybiAoKV0gKilcbiAgICAtPiA/c3RvcDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW0RlZmVycmVkLm5ldmVyICgpXSAqKVxuICAgIC0+ID9jb250aW51ZV9vbl9lcnJvcjpib29sICgqKiBkZWZhdWx0IGlzIFt0cnVlXSAqKVxuICAgIC0+ID9maW5pc2hlZDp1bml0IEl2YXIudFxuICAgIC0+IFRpbWUuU3Bhbi50XG4gICAgLT4gKHVuaXQgLT4gdW5pdCBEZWZlcnJlZC50KVxuICAgIC0+IHVuaXRcblxuICAoKiogW2V2ZXJ5ID9zdGFydCA/c3RvcCBzcGFuIGZdIGlzXG4gICAgICBbZXZlcnknID9zdGFydCA/c3RvcCBzcGFuIChmdW4gKCkgLT4gZiAoKTsgcmV0dXJuICgpKV0uICopXG4gIHZhbCBldmVyeVxuICAgIDogID9zdGFydDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW3JldHVybiAoKV0gKilcbiAgICAtPiA/c3RvcDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW0RlZmVycmVkLm5ldmVyICgpXSAqKVxuICAgIC0+ID9jb250aW51ZV9vbl9lcnJvcjpib29sICgqKiBkZWZhdWx0IGlzIFt0cnVlXSAqKVxuICAgIC0+IFRpbWUuU3Bhbi50XG4gICAgLT4gKHVuaXQgLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgKCoqIFtydW5fYXRfaW50ZXJ2YWxzJyA/c3RhcnQgP3N0b3Agc3BhbiBmXSBydW5zIFtmKCldIGF0IGluY3JlbWVudHMgb2YgW3N0YXJ0ICsgaSAqXG4gICAgICBzcGFuXSBmb3Igbm9ubmVnYXRpdmUgaW50ZWdlcnMgW2ldLCB1bnRpbCBbc3RvcF0gYmVjb21lcyBkZXRlcm1pbmVkLlxuICAgICAgSWYgdGhlIHJlc3VsdCBvZiBbZl0gaXMgbm90IGRldGVybWluZWQgZmFzdCBlbm91Z2ggdGhlbiB0aGUgbmV4dCBpbnRlcnZhbChzKVxuICAgICAgYXJlIHNraXBwZWQgc28gdGhhdCB0aGVyZSBhcmUgbmV2ZXIgbXVsdGlwbGUgY29uY3VycmVudCBpbnZvY2F0aW9ucyBvZiBbZl0gaW5cbiAgICAgIGZsaWdodC5cblxuICAgICAgRXhjZXB0aW9ucyByYWlzZWQgYnkgW2ZdIGFyZSBhbHdheXMgc2VudCB0byBtb25pdG9yIGluIGVmZmVjdCB3aGVuXG4gICAgICBbcnVuX2F0X2ludGVydmFscyddIHdhcyBjYWxsZWQsIGV2ZW4gd2l0aCBbfmNvbnRpbnVlX29uX2Vycm9yOnRydWVdLiAqKVxuICB2YWwgcnVuX2F0X2ludGVydmFscydcbiAgICA6ICA/c3RhcnQ6VGltZS50ICgqKiBkZWZhdWx0IGlzIFtUaW1lLm5vdyAoKV0gKilcbiAgICAtPiA/c3RvcDp1bml0IERlZmVycmVkLnQgKCoqIGRlZmF1bHQgaXMgW0RlZmVycmVkLm5ldmVyICgpXSAqKVxuICAgIC0+ID9jb250aW51ZV9vbl9lcnJvcjpib29sICgqKiBkZWZhdWx0IGlzIFt0cnVlXSAqKVxuICAgIC0+IFRpbWUuU3Bhbi50XG4gICAgLT4gKHVuaXQgLT4gdW5pdCBEZWZlcnJlZC50KVxuICAgIC0+IHVuaXRcblxuICAoKiogW3J1bl9hdF9pbnRlcnZhbHMgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciBzcGFuIGZdIGlzIGVxdWl2YWxlbnQgdG86XG5cbiAgICAgIHtbXG4gICAgICAgIHJ1bl9hdF9pbnRlcnZhbHMnID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3Igc3BhblxuICAgICAgICAgIChmdW4gKCkgLT4gZiAoKTsgcmV0dXJuICgpKSBdfSAqKVxuICB2YWwgcnVuX2F0X2ludGVydmFsc1xuICAgIDogID9zdGFydDpUaW1lLnQgKCoqIGRlZmF1bHQgaXMgW1RpbWUubm93ICgpXSAqKVxuICAgIC0+ID9zdG9wOnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbRGVmZXJyZWQubmV2ZXIgKCldICopXG4gICAgLT4gP2NvbnRpbnVlX29uX2Vycm9yOmJvb2wgKCoqIGRlZmF1bHQgaXMgW3RydWVdICopXG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiAodW5pdCAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICAoKiogW2R1cmF0aW9uX29mIGZdIGludm9rZXMgW2YgKCldIGFuZCBtZWFzdXJlcyBob3cgbG9uZyBpdCB0YWtlcyBmcm9tIHRoZSBpbnZvY2F0aW9uXG4gICAgICB0byBhZnRlciB0aGUgZGVmZXJyZWQgaXMgZGV0ZXJtaW5lZC5cblxuICAgICAgTm90ZSB0aGF0IHRoZSBtZWFzdXJlbWVudCBpcyBub3QgZXhhY3Q7IGJlY2F1c2UgaXQgaW52b2x2ZXMgYW4gYWRkaXRpb25hbCBtYXAgb24gdGhlXG4gICAgICBkZWZlcnJlZCwgdGhlIHRpbWluZyBhbHNvIGluY2x1ZGVzIHRoZSBkdXJhdGlvbiBvZiBqb2JzIGluIHRoZSBqb2IgcXVldWUgd2hlbiBbZiAoKV1cbiAgICAgIGlzIGRldGVybWluZWQuICopXG4gIHZhbCBkdXJhdGlvbl9vZiA6ICh1bml0IC0+ICdhIERlZmVycmVkLnQpIC0+ICgnYSAqIFRpbWUuU3Bhbi50KSBEZWZlcnJlZC50XG5lbmRcblxuKCoqIFtDbG9ja19kZXByZWNhdGVkXSBpcyB1c2VkIGluIFtSZXF1aXJlX2V4cGxpY2l0X3RpbWVfc291cmNlXSB0byBjcmVhdGUgYSBjbG9ja1xuICAgIG1vZHVsZSBpbiB3aGljaCBhbGwgZnVuY3Rpb25zIGFyZSBkZXByZWNhdGVkLiAqKVxubW9kdWxlIHR5cGUgQ2xvY2tfZGVwcmVjYXRlZCA9IHNpZ1xuICBtb2R1bGUgT3JfdGltZW91dCA9IE9yX3RpbWVvdXRcblxuICBtb2R1bGUgVGltZSA6IHNpZ1xuICAgIG1vZHVsZSBTcGFuIDogc2lnXG4gICAgICB0eXBlIHRcbiAgICBlbmRcblxuICAgIHR5cGUgdFxuICBlbmRcblxuICB2YWwgcnVuX2F0IDogVGltZS50IC0+ICgnYSAtPiB1bml0KSAtPiAnYSAtPiB1bml0XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICB2YWwgcnVuX2FmdGVyIDogVGltZS5TcGFuLnQgLT4gKCdhIC0+IHVuaXQpIC0+ICdhIC0+IHVuaXRcbiAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBhdCA6IFRpbWUudCAtPiB1bml0IERlZmVycmVkLnQgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBhZnRlciA6IFRpbWUuU3Bhbi50IC0+IHVuaXQgRGVmZXJyZWQudFxuICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgdmFsIHdpdGhfdGltZW91dCA6IFRpbWUuU3Bhbi50IC0+ICdhIERlZmVycmVkLnQgLT4gJ2EgT3JfdGltZW91dC50IERlZmVycmVkLnRcbiAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIG1vZHVsZSBFdmVudCA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnaCkgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIHR5cGUgdF91bml0ID0gKHVuaXQsIHVuaXQpIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICAgIGluY2x1ZGVcbiAgICAgIEludmFyaWFudC5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICB2YWwgc2NoZWR1bGVkX2F0IDogKF8sIF8pIHQgLT4gVGltZS50XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgbW9kdWxlIFN0YXR1cyA6IHNpZ1xuICAgICAgdHlwZSAoJ2EsICdoKSB0ID1cbiAgICAgICAgfCBBYm9ydGVkIG9mICdhXG4gICAgICAgIHwgSGFwcGVuZWQgb2YgJ2hcbiAgICAgICAgfCBTY2hlZHVsZWRfYXQgb2YgVGltZS50XG4gICAgICBbQEBkZXJpdmluZyBzZXhwX29mXVxuICAgIGVuZFxuXG4gICAgdmFsIHN0YXR1cyA6ICgnYSwgJ2gpIHQgLT4gKCdhLCAnaCkgU3RhdHVzLnRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICB2YWwgcnVuX2F0IDogVGltZS50IC0+ICgneiAtPiAnaCkgLT4gJ3ogLT4gKF8sICdoKSB0XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgdmFsIHJ1bl9hZnRlciA6IFRpbWUuU3Bhbi50IC0+ICgneiAtPiAnaCkgLT4gJ3ogLT4gKF8sICdoKSB0XG4gICAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gICAgbW9kdWxlIEFib3J0X3Jlc3VsdCA9IFRpbWVfc291cmNlLkV2ZW50LkFib3J0X3Jlc3VsdFxuXG4gICAgdmFsIGFib3J0IDogKCdhLCAnaCkgdCAtPiAnYSAtPiAoJ2EsICdoKSBBYm9ydF9yZXN1bHQudFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICAgIHZhbCBhYm9ydF9leG4gOiAoJ2EsICdoKSB0IC0+ICdhIC0+IHVuaXRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICB2YWwgYWJvcnRfaWZfcG9zc2libGUgOiAoJ2EsIF8pIHQgLT4gJ2EgLT4gdW5pdFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICAgIG1vZHVsZSBGaXJlZCA9IFRpbWVfc291cmNlLkV2ZW50LkZpcmVkXG5cbiAgICB2YWwgZmlyZWQgOiAoJ2EsICdoKSB0IC0+ICgnYSwgJ2gpIEZpcmVkLnQgRGVmZXJyZWQudFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICAgIG1vZHVsZSBSZXNjaGVkdWxlX3Jlc3VsdCA9IFRpbWVfc291cmNlLkV2ZW50LlJlc2NoZWR1bGVfcmVzdWx0XG5cbiAgICB2YWwgcmVzY2hlZHVsZV9hdCA6ICgnYSwgJ2gpIHQgLT4gVGltZS50IC0+ICgnYSwgJ2gpIFJlc2NoZWR1bGVfcmVzdWx0LnRcbiAgICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICB2YWwgcmVzY2hlZHVsZV9hZnRlciA6ICgnYSwgJ2gpIHQgLT4gVGltZS5TcGFuLnQgLT4gKCdhLCAnaCkgUmVzY2hlZHVsZV9yZXN1bHQudFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICAgIHZhbCBhdCA6IFRpbWUudCAtPiAoXywgdW5pdCkgdCBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgICB2YWwgYWZ0ZXIgOiBUaW1lLlNwYW4udCAtPiAoXywgdW5pdCkgdFxuICAgIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cbiAgZW5kXG5cbiAgdmFsIGF0X3ZhcnlpbmdfaW50ZXJ2YWxzXG4gICAgOiAgP3N0b3A6dW5pdCBEZWZlcnJlZC50XG4gICAgLT4gKHVuaXQgLT4gVGltZS5TcGFuLnQpXG4gICAgLT4gdW5pdCBBc3luY19zdHJlYW0udFxuICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgdmFsIGF0X2ludGVydmFsc1xuICAgIDogID9zdGFydDpUaW1lLnRcbiAgICAtPiA/c3RvcDp1bml0IERlZmVycmVkLnRcbiAgICAtPiBUaW1lLlNwYW4udFxuICAgIC0+IHVuaXQgQXN5bmNfc3RyZWFtLnRcbiAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBldmVyeSdcbiAgICA6ICA/c3RhcnQ6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtyZXR1cm4gKCldICopXG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtEZWZlcnJlZC5uZXZlciAoKV0gKilcbiAgICAtPiA/Y29udGludWVfb25fZXJyb3I6Ym9vbCAoKiogZGVmYXVsdCBpcyBbdHJ1ZV0gKilcbiAgICAtPiA/ZmluaXNoZWQ6dW5pdCBJdmFyLnRcbiAgICAtPiBUaW1lLlNwYW4udFxuICAgIC0+ICh1bml0IC0+IHVuaXQgRGVmZXJyZWQudClcbiAgICAtPiB1bml0XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICB2YWwgZXZlcnlcbiAgICA6ICA/c3RhcnQ6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtyZXR1cm4gKCldICopXG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtEZWZlcnJlZC5uZXZlciAoKV0gKilcbiAgICAtPiA/Y29udGludWVfb25fZXJyb3I6Ym9vbCAoKiogZGVmYXVsdCBpcyBbdHJ1ZV0gKilcbiAgICAtPiBUaW1lLlNwYW4udFxuICAgIC0+ICh1bml0IC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTYtMDJdIFVzZSBbVGltZV9zb3VyY2VdXCJdXG5cbiAgdmFsIHJ1bl9hdF9pbnRlcnZhbHMnXG4gICAgOiAgP3N0YXJ0OlRpbWUudCAoKiogZGVmYXVsdCBpcyBbVGltZS5ub3cgKCldICopXG4gICAgLT4gP3N0b3A6dW5pdCBEZWZlcnJlZC50ICgqKiBkZWZhdWx0IGlzIFtEZWZlcnJlZC5uZXZlciAoKV0gKilcbiAgICAtPiA/Y29udGludWVfb25fZXJyb3I6Ym9vbCAoKiogZGVmYXVsdCBpcyBbdHJ1ZV0gKilcbiAgICAtPiBUaW1lLlNwYW4udFxuICAgIC0+ICh1bml0IC0+IHVuaXQgRGVmZXJyZWQudClcbiAgICAtPiB1bml0XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cblxuICB2YWwgcnVuX2F0X2ludGVydmFsc1xuICAgIDogID9zdGFydDpUaW1lLnQgKCoqIGRlZmF1bHQgaXMgW1RpbWUubm93ICgpXSAqKVxuICAgIC0+ID9zdG9wOnVuaXQgRGVmZXJyZWQudCAoKiogZGVmYXVsdCBpcyBbRGVmZXJyZWQubmV2ZXIgKCldICopXG4gICAgLT4gP2NvbnRpbnVlX29uX2Vycm9yOmJvb2wgKCoqIGRlZmF1bHQgaXMgW3RydWVdICopXG4gICAgLT4gVGltZS5TcGFuLnRcbiAgICAtPiAodW5pdCAtPiB1bml0KVxuICAgIC0+IHVuaXRcbiAgW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE2LTAyXSBVc2UgW1RpbWVfc291cmNlXVwiXVxuXG4gIHZhbCBkdXJhdGlvbl9vZiA6ICh1bml0IC0+ICdhIERlZmVycmVkLnQpIC0+ICgnYSAqIFRpbWUuU3Bhbi50KSBEZWZlcnJlZC50XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAxNi0wMl0gVXNlIFtUaW1lX3NvdXJjZV1cIl1cbmVuZFxuXG4oKiogQGlubGluZSAqKVxuaW5jbHVkZSAoXG5zdHJ1Y3RcbiAgW0BAQHdhcm5pbmcgXCItM1wiXVxuXG4gIG1vZHVsZSBfIChDIDogQ2xvY2spIDogQ2xvY2tfZGVwcmVjYXRlZCA9IENcblxuICBtb2R1bGUgXyAoQyA6IENsb2NrX2RlcHJlY2F0ZWQpIDogQ2xvY2sgPSBDXG5lbmQgOlxuc2lnIGVuZClcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgdHlwZSBDbG9jayA9IENsb2NrX2ludGYuQ2xvY2tcbm1vZHVsZSB0eXBlIENsb2NrX2RlcHJlY2F0ZWQgPSBDbG9ja19pbnRmLkNsb2NrX2RlcHJlY2F0ZWRcblxubW9kdWxlIE9yX3RpbWVvdXQgPSBDbG9ja19pbnRmLk9yX3RpbWVvdXRcbm1vZHVsZSBTY2hlZHVsZXIgPSBTY2hlZHVsZXIxXG5cbmxldCB0aW1lX3NvdXJjZSAoKSA9IChTY2hlZHVsZXIudCAoKSkudGltZV9zb3VyY2UgfD4gVGltZV9zb3VyY2Uub2Zfc3luY2hyb25vdXNcbmxldCBhZnRlciBzcGFuID0gVGltZV9zb3VyY2UuYWZ0ZXIgKHRpbWVfc291cmNlICgpKSBzcGFuXG5sZXQgYXQgdGltZSA9IFRpbWVfc291cmNlLmF0ICh0aW1lX3NvdXJjZSAoKSkgdGltZVxuXG5sZXQgYXRfdmFyeWluZ19pbnRlcnZhbHMgP3N0b3AgY29tcHV0ZV9zcGFuID1cbiAgVGltZV9zb3VyY2UuYXRfdmFyeWluZ19pbnRlcnZhbHMgP3N0b3AgKHRpbWVfc291cmNlICgpKSBjb21wdXRlX3NwYW5cbjs7XG5cbmxldCBhdF9pbnRlcnZhbHMgP3N0YXJ0ID9zdG9wIGludGVydmFsID1cbiAgVGltZV9zb3VyY2UuYXRfaW50ZXJ2YWxzID9zdGFydCA/c3RvcCAodGltZV9zb3VyY2UgKCkpIGludGVydmFsXG47O1xuXG5sZXQgZXZlcnknID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgP2ZpbmlzaGVkIHNwYW4gZiA9XG4gIFRpbWVfc291cmNlLmV2ZXJ5JyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yID9maW5pc2hlZCAodGltZV9zb3VyY2UgKCkpIHNwYW4gZlxuOztcblxubGV0IGV2ZXJ5ID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3Igc3BhbiBmID1cbiAgVGltZV9zb3VyY2UuZXZlcnkgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciAodGltZV9zb3VyY2UgKCkpIHNwYW4gZlxuOztcblxubGV0IHJ1bl9hZnRlciBzcGFuIGYgYSA9IFRpbWVfc291cmNlLnJ1bl9hZnRlciAodGltZV9zb3VyY2UgKCkpIHNwYW4gZiBhXG5sZXQgcnVuX2F0IHRpbWUgZiBhID0gVGltZV9zb3VyY2UucnVuX2F0ICh0aW1lX3NvdXJjZSAoKSkgdGltZSBmIGFcblxubGV0IHJ1bl9hdF9pbnRlcnZhbHMgP3N0YXJ0ID9zdG9wID9jb250aW51ZV9vbl9lcnJvciBpbnRlcnZhbCBmID1cbiAgVGltZV9zb3VyY2UucnVuX2F0X2ludGVydmFscyA/c3RhcnQgP3N0b3AgP2NvbnRpbnVlX29uX2Vycm9yICh0aW1lX3NvdXJjZSAoKSkgaW50ZXJ2YWwgZlxuOztcblxubGV0IHJ1bl9hdF9pbnRlcnZhbHMnID9zdGFydCA/c3RvcCA/Y29udGludWVfb25fZXJyb3IgaW50ZXJ2YWwgZiA9XG4gIFRpbWVfc291cmNlLnJ1bl9hdF9pbnRlcnZhbHMnXG4gICAgP3N0YXJ0XG4gICAgP3N0b3BcbiAgICA/Y29udGludWVfb25fZXJyb3JcbiAgICAodGltZV9zb3VyY2UgKCkpXG4gICAgaW50ZXJ2YWxcbiAgICBmXG47O1xuXG5sZXQgd2l0aF90aW1lb3V0IHNwYW4gZCA9IFRpbWVfc291cmNlLndpdGhfdGltZW91dCAodGltZV9zb3VyY2UgKCkpIHNwYW4gZFxubGV0IGR1cmF0aW9uX29mIGYgPSBUaW1lX3NvdXJjZS5kdXJhdGlvbl9vZiAodGltZV9zb3VyY2UgKCkpIGZcblxubW9kdWxlIEV2ZW50ID0gc3RydWN0XG4gIGluY2x1ZGUgVGltZV9zb3VyY2UuRXZlbnRcblxuICBsZXQgYWZ0ZXIgc3BhbiA9IGFmdGVyICh0aW1lX3NvdXJjZSAoKSkgc3BhblxuICBsZXQgcnVuX2FmdGVyIHNwYW4gZiBhID0gcnVuX2FmdGVyICh0aW1lX3NvdXJjZSAoKSkgc3BhbiBmIGFcbiAgbGV0IGF0IHRpbWUgPSBhdCAodGltZV9zb3VyY2UgKCkpIHRpbWVcbiAgbGV0IHJ1bl9hdCB0aW1lIGYgeiA9IHJ1bl9hdCAodGltZV9zb3VyY2UgKCkpIHRpbWUgZiB6XG5lbmRcbiIsIm9wZW4gQ29yZVxub3BlbiBEZWZlcnJlZF9zdGRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG5sZXQgZm9sZGkgdCB+aW5pdCB+ZiA9XG4gIERlZmVycmVkLmNyZWF0ZSAoZnVuIHJlc3VsdCAtPlxuICAgIGxldCByZWMgbG9vcCBpIGIgPVxuICAgICAgaWYgaSA9IEFycmF5Lmxlbmd0aCB0XG4gICAgICB0aGVuIEl2YXIuZmlsbCByZXN1bHQgYlxuICAgICAgZWxzZSBmIGkgYiB0LihpKSA+Pj4gZnVuIGIgLT4gbG9vcCAoaSArIDEpIGJcbiAgICBpblxuICAgIGxvb3AgMCBpbml0KVxuOztcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9IGZvbGRpIHQgfmluaXQgfmY6KGZ1biBfIGEgeCAtPiBmIGEgeClcblxubGV0IHNlcW1hcGkgdCB+ZiA9XG4gIGxldCVtYXAgYnMgPSBmb2xkaSB0IH5pbml0OltdIH5mOihmdW4gaSBicyBhIC0+IGYgaSBhID4+fCBmdW4gYiAtPiBiIDo6IGJzKSBpblxuICBBcnJheS5vZl9saXN0IChDb3JlLkxpc3QucmV2IGJzKVxuOztcblxubGV0IGFsbCBkcyA9IHNlcW1hcGkgZHMgfmY6KGZ1biBfIHggLT4geClcbmxldCBhbGxfdW5pdCBkcyA9IERlZmVycmVkLmlnbm9yZV9tIChmb2xkIGRzIH5pbml0OigpIH5mOihmdW4gKCkgZCAtPiBkKSlcblxubGV0IGl0ZXJpID8oaG93ID0gYFNlcXVlbnRpYWwpIHQgfmYgPVxuICBtYXRjaCBob3cgd2l0aFxuICB8IChgUGFyYWxsZWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfKSBhcyBob3cgLT5cbiAgICBhbGxfdW5pdCAoQXJyYXkubWFwaSB0IH5mOih1bnN0YWdlIChUaHJvdHRsZS5tb25hZF9zZXF1ZW5jZV9ob3cyIH5ob3cgfmYpKSlcbiAgfCBgU2VxdWVudGlhbCAtPiBmb2xkaSB0IH5pbml0OigpIH5mOihmdW4gaSAoKSB4IC0+IGYgaSB4KVxuOztcblxubGV0IG1hcGkgPyhob3cgPSBgU2VxdWVudGlhbCkgdCB+ZiA9XG4gIG1hdGNoIGhvdyB3aXRoXG4gIHwgKGBQYXJhbGxlbCB8IGBNYXhfY29uY3VycmVudF9qb2JzIF8pIGFzIGhvdyAtPlxuICAgIGFsbCAoQXJyYXkubWFwaSB0IH5mOih1bnN0YWdlIChUaHJvdHRsZS5tb25hZF9zZXF1ZW5jZV9ob3cyIH5ob3cgfmYpKSlcbiAgfCBgU2VxdWVudGlhbCAtPiBzZXFtYXBpIHQgfmZcbjs7XG5cbmxldCBmaWx0ZXJpID9ob3cgdCB+ZiA9XG4gIGxldCVtYXAgYm9vbHMgPSBtYXBpIHQgP2hvdyB+ZiBpblxuICBBcnJheS5vZl9saXN0X3JldlxuICAgIChBcnJheS5mb2xkMl9leG4gdCBib29scyB+aW5pdDpbXSB+ZjooZnVuIGFjIHggYiAtPiBpZiBiIHRoZW4geCA6OiBhYyBlbHNlIGFjKSlcbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSA/aG93IHQgfmYgPSBtYXBpIHQgP2hvdyB+ZiA+PnwgQXJyYXkuZmlsdGVyX29wdFxuXG5sZXQgY29uY2F0X21hcGkgP2hvdyB0IH5mID1cbiAgbGV0JW1hcCB0ID0gbWFwaSB0ID9ob3cgfmYgaW5cbiAgQXJyYXkuY29uY2F0IChBcnJheS50b19saXN0IHQpXG47O1xuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgcmVjIGF1eCBpID1cbiAgICBpZiBpID0gQXJyYXkubGVuZ3RoIHRcbiAgICB0aGVuIHJldHVybiBOb25lXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCViaW5kIGYgaSB0LihpKSB3aXRoXG4gICAgICB8IE5vbmUgLT4gYXV4IChpICsgMSlcbiAgICAgIHwgU29tZSBfIGFzIHNvbWUgLT4gcmV0dXJuIHNvbWUpXG4gIGluXG4gIGF1eCAwXG47O1xuXG5sZXQgZmluZGkgdCB+ZiA9XG4gIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgaWYgYiB0aGVuIFNvbWUgKGksIGVsdCkgZWxzZSBOb25lKVxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIGZpbmRfbWFwaSB0IH5mOihmdW4gXyBlbHQgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGVsdCBpblxuICAgIGlmIGIgdGhlbiBTb21lIGVsdCBlbHNlIE5vbmUpXG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgbWF0Y2glbWFwXG4gICAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgICAgaWYgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICB3aXRoXG4gIHwgU29tZSAoKSAtPiB0cnVlXG4gIHwgTm9uZSAtPiBmYWxzZVxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBtYXRjaCVtYXBcbiAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICBpZiBub3QgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICB3aXRoXG4gIHwgU29tZSAoKSAtPiBmYWxzZVxuICB8IE5vbmUgLT4gdHJ1ZVxuOztcblxubGV0IGl0ZXIgP2hvdyB0IH5mID0gaXRlcmkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBtYXAgP2hvdyB0IH5mID0gbWFwaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZpbHRlcl9tYXAgP2hvdyB0IH5mID0gZmlsdGVyX21hcGkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmaWx0ZXIgP2hvdyB0IH5mID0gZmlsdGVyaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGNvbmNhdF9tYXAgP2hvdyB0IH5mID0gY29uY2F0X21hcGkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmaW5kX21hcCB0IH5mID0gZmluZF9tYXBpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGV4aXN0cyB0IH5mID0gZXhpc3RzaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmb3JfYWxsIHQgfmYgPSBmb3JfYWxsaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBpbml0ID9ob3cgbiB+ZiA9IG1hcCA/aG93IChBcnJheS5pbml0IG4gfmY6Rm4uaWQpIH5mXG4iLCJvcGVuIENvcmVcbm9wZW4gRGVmZXJyZWRfc3RkXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICBsZXQgcmVjIGxvb3AgdCBpIGIgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IEl2YXIuZmlsbCByZXN1bHQgYlxuICAgICAgfCB4IDo6IHhzIC0+IGYgaSBiIHggPj4+IGZ1biBiIC0+IGxvb3AgeHMgKGkgKyAxKSBiXG4gICAgaW5cbiAgICBsb29wIHQgMCBpbml0KVxuOztcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9IGZvbGRpIHQgfmluaXQgfmY6KGZ1biBfIGEgeCAtPiBmIGEgeClcblxubGV0IHNlcW1hcGkgdCB+ZiA9XG4gIGZvbGRpIHQgfmluaXQ6W10gfmY6KGZ1biBpIGJzIGEgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGkgYSBpblxuICAgIGIgOjogYnMpXG4gID4+fCBMaXN0LnJldlxuOztcblxubGV0IGFsbCBkcyA9IHNlcW1hcGkgZHMgfmY6KGZ1biBfIHggLT4geClcbmxldCBhbGxfdW5pdCBkcyA9IERlZmVycmVkLmlnbm9yZV9tIChmb2xkIGRzIH5pbml0OigpIH5mOihmdW4gKCkgZCAtPiBkKSlcblxubGV0IGl0ZXJpID8oaG93ID0gYFNlcXVlbnRpYWwpIHQgfmYgPVxuICBtYXRjaCBob3cgd2l0aFxuICB8IChgUGFyYWxsZWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfKSBhcyBob3cgLT5cbiAgICBhbGxfdW5pdCAoTGlzdC5tYXBpIHQgfmY6KHVuc3RhZ2UgKFRocm90dGxlLm1vbmFkX3NlcXVlbmNlX2hvdzIgfmhvdyB+ZikpKVxuICB8IGBTZXF1ZW50aWFsIC0+IGZvbGRpIHQgfmluaXQ6KCkgfmY6KGZ1biBpICgpIHggLT4gZiBpIHgpXG47O1xuXG5sZXQgbWFwaSA/KGhvdyA9IGBTZXF1ZW50aWFsKSB0IH5mID1cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCAoYFBhcmFsbGVsIHwgYE1heF9jb25jdXJyZW50X2pvYnMgXykgYXMgaG93IC0+XG4gICAgYWxsIChMaXN0Lm1hcGkgdCB+ZjoodW5zdGFnZSAoVGhyb3R0bGUubW9uYWRfc2VxdWVuY2VfaG93MiB+aG93IH5mKSkpXG4gIHwgYFNlcXVlbnRpYWwgLT4gc2VxbWFwaSB0IH5mXG47O1xuXG5sZXQgZmlsdGVyaSA/aG93IHQgfmYgPVxuICBsZXQlbWFwIGJvb2xzID0gbWFwaSB0ID9ob3cgfmYgaW5cbiAgTGlzdC5yZXYgKExpc3QuZm9sZDJfZXhuIHQgYm9vbHMgfmluaXQ6W10gfmY6KGZ1biBhYyB4IGIgLT4gaWYgYiB0aGVuIHggOjogYWMgZWxzZSBhYykpXG47O1xuXG5sZXQgZmlsdGVyX21hcGkgP2hvdyB0IH5mID0gbWFwaSB0ID9ob3cgfmYgPj58IExpc3QuZmlsdGVyX29wdFxubGV0IGNvbmNhdF9tYXBpID9ob3cgdCB+ZiA9IG1hcGkgdCA/aG93IH5mID4+fCBMaXN0LmNvbmNhdFxuXG5sZXQgZmluZF9tYXBpIHQgfmYgPVxuICBsZXQgcmVjIGZpbmRfbWFwaSB0IH5mIGkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgW10gLT4gcmV0dXJuIE5vbmVcbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAobWF0Y2glYmluZCBmIGkgaGQgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBmaW5kX21hcGkgdGwgfmYgKGkgKyAxKVxuICAgICAgIHwgU29tZSBfIGFzIHNvbWUgLT4gcmV0dXJuIHNvbWUpXG4gIGluXG4gIGZpbmRfbWFwaSB0IH5mIDBcbjs7XG5cbmxldCBmaW5kaSB0IH5mID1cbiAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICBpZiBiIHRoZW4gU29tZSAoaSwgZWx0KSBlbHNlIE5vbmUpXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgZmluZF9tYXBpIHQgfmY6KGZ1biBfIGVsdCAtPlxuICAgIGxldCVtYXAgYiA9IGYgZWx0IGluXG4gICAgaWYgYiB0aGVuIFNvbWUgZWx0IGVsc2UgTm9uZSlcbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBtYXRjaCVtYXBcbiAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICBpZiBiIHRoZW4gU29tZSAoKSBlbHNlIE5vbmUpXG4gIHdpdGhcbiAgfCBTb21lICgpIC0+IHRydWVcbiAgfCBOb25lIC0+IGZhbHNlXG47O1xuXG5sZXQgZm9yX2FsbGkgdCB+ZiA9XG4gIG1hdGNoJW1hcFxuICAgIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICAgIGlmIG5vdCBiIHRoZW4gU29tZSAoKSBlbHNlIE5vbmUpXG4gIHdpdGhcbiAgfCBTb21lICgpIC0+IGZhbHNlXG4gIHwgTm9uZSAtPiB0cnVlXG47O1xuXG5sZXQgaXRlciA/aG93IHQgfmYgPSBpdGVyaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IG1hcCA/aG93IHQgfmYgPSBtYXBpID9ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZmlsdGVyID9ob3cgdCB+ZiA9IGZpbHRlcmkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmaWx0ZXJfbWFwID9ob3cgdCB+ZiA9IGZpbHRlcl9tYXBpID9ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgY29uY2F0X21hcCA/aG93IHQgfmYgPSBjb25jYXRfbWFwaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZpbmRfbWFwIHQgfmYgPSBmaW5kX21hcGkgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZXhpc3RzIHQgfmYgPSBleGlzdHNpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZvcl9hbGwgdCB+ZiA9IGZvcl9hbGxpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGluaXQgP2hvdyBuIH5mID0gbWFwID9ob3cgKExpc3QuaW5pdCBuIH5mOkZuLmlkKSB+ZlxuIiwib3BlbiBDb3JlXG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5tb2R1bGUgTGlzdCA9IERlZmVycmVkX2xpc3RcblxudHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBNYXAudFxuXG5sZXQgY2hhbmdlIHQgayB+ZiA9XG4gIGxldCVtYXAgb3B0ID0gZiAoTWFwLmZpbmQgdCBrKSBpblxuICBNYXAuY2hhbmdlIHQgayB+ZjooZnVuIF8gLT4gb3B0KVxuOztcblxubGV0IHVwZGF0ZSB0IGsgfmYgPVxuICBsZXQlbWFwIGRhdGEgPSBmIChNYXAuZmluZCB0IGspIGluXG4gIE1hcC5zZXQgdCB+a2V5OmsgfmRhdGFcbjs7XG5cbmxldCBpdGVyX2tleXMgP2hvdyB0IH5mID0gTGlzdC5pdGVyID9ob3cgKE1hcC5rZXlzIHQpIH5mXG5sZXQgaXRlciA/aG93IHQgfmYgPSBMaXN0Lml0ZXIgP2hvdyAoTWFwLmRhdGEgdCkgfmZcbmxldCBpdGVyaSA/aG93IHQgfmYgPSBMaXN0Lml0ZXIgP2hvdyAoTWFwLnRvX2FsaXN0IHQpIH5mOihmdW4gKGtleSwgZGF0YSkgLT4gZiB+a2V5IH5kYXRhKVxuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgbGV0IGFsaXN0X2luX2luY3JlYXNpbmdfa2V5X29yZGVyID1cbiAgICBNYXAuZm9sZF9yaWdodCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSBhbGlzdCAtPiAoa2V5LCBkYXRhKSA6OiBhbGlzdClcbiAgaW5cbiAgTGlzdC5mb2xkIGFsaXN0X2luX2luY3JlYXNpbmdfa2V5X29yZGVyIH5pbml0IH5mOihmdW4gYWMgKGtleSwgZGF0YSkgLT4gZiB+a2V5IH5kYXRhIGFjKVxuOztcblxubGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9XG4gIGxldCBhbGlzdF9pbl9kZWNyZWFzaW5nX2tleV9vcmRlciA9XG4gICAgTWFwLmZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgYWxpc3QgLT4gKGtleSwgZGF0YSkgOjogYWxpc3QpXG4gIGluXG4gIExpc3QuZm9sZCBhbGlzdF9pbl9kZWNyZWFzaW5nX2tleV9vcmRlciB+aW5pdCB+ZjooZnVuIGFjIChrZXksIGRhdGEpIC0+IGYgfmtleSB+ZGF0YSBhYylcbjs7XG5cbm1vZHVsZSBKb2IgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiLCAnYykgdCA9XG4gICAgeyBrZXkgOiAnYVxuICAgIDsgZGF0YSA6ICdiXG4gICAgOyBtdXRhYmxlIHJlc3VsdCA6ICdjIG9wdGlvblxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzXVxuZW5kXG5cbmxldCBmaWx0ZXJfbWFwaV9zZXF1ZW50aWFsIHQgfmYgPVxuICBsZXQgY29tcGFyYXRvciA9IE1hcC5jb21wYXJhdG9yIHQgaW5cbiAgbGV0IHNlcXVlbmNlID0gTWFwLnRvX3NlcXVlbmNlIH5vcmRlcjpgSW5jcmVhc2luZ19rZXkgdCBpblxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBpdmFyIC0+XG4gICAgU2VxdWVuY2UuZGVsYXllZF9mb2xkXG4gICAgICBzZXF1ZW5jZVxuICAgICAgfmluaXQ6QmFzZS5NYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLkJ1aWxkX2luY3JlYXNpbmcuZW1wdHlcbiAgICAgIH5mOihmdW4gcyAoa2V5LCBkYXRhKSB+ayAtPlxuICAgICAgICB1cG9uIChmIH5rZXkgfmRhdGEpIChmdW5jdGlvblxuICAgICAgICAgIHwgTm9uZSAtPiBrIHNcbiAgICAgICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgbGV0IHMgPVxuICAgICAgICAgICAgICBCYXNlLk1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUuQnVpbGRfaW5jcmVhc2luZy5hZGRfZXhuXG4gICAgICAgICAgICAgICAgc1xuICAgICAgICAgICAgICAgIH5jb21wYXJhdG9yXG4gICAgICAgICAgICAgICAgfmtleVxuICAgICAgICAgICAgICAgIH5kYXRhXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgayBzKSlcbiAgICAgIH5maW5pc2g6KGZ1biB4IC0+XG4gICAgICAgIEl2YXIuZmlsbFxuICAgICAgICAgIGl2YXJcbiAgICAgICAgICAoTWFwLlVzaW5nX2NvbXBhcmF0b3Iub2ZfdHJlZVxuICAgICAgICAgICAgIH5jb21wYXJhdG9yXG4gICAgICAgICAgICAgKEJhc2UuTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5CdWlsZF9pbmNyZWFzaW5nLnRvX3RyZWUgeCkpKSlcbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSA/KGhvdyA9IGBTZXF1ZW50aWFsKSB0IH5mID1cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCBgU2VxdWVudGlhbCAtPiBmaWx0ZXJfbWFwaV9zZXF1ZW50aWFsIHQgfmZcbiAgfCBgUGFyYWxsZWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfIC0+XG4gICAgbGV0IGpvYnMgPSByZWYgW10gaW5cbiAgICBsZXQgam9iX21hcCA9XG4gICAgICBNYXAubWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICBsZXQgam9iID0geyBKb2Iua2V5OyBkYXRhOyByZXN1bHQgPSBOb25lIH0gaW5cbiAgICAgICAgam9icyA6PSBqb2IgOjogIWpvYnM7XG4gICAgICAgIGpvYilcbiAgICBpblxuICAgIGxldCVtYXAgKCkgPVxuICAgICAgTGlzdC5pdGVyIH5ob3cgKEJhc2UuTGlzdC5yZXYgIWpvYnMpIH5mOihmdW5jdGlvblxuICAgICAgICB8IHsgSm9iLmtleTsgZGF0YTsgcmVzdWx0ID0gXyB9IGFzIGpvYiAtPlxuICAgICAgICAgIGxldCVtYXAgeCA9IGYgfmtleSB+ZGF0YSBpblxuICAgICAgICAgIGpvYi5yZXN1bHQgPC0geClcbiAgICBpblxuICAgIE1hcC5maWx0ZXJfbWFwIGpvYl9tYXAgfmY6Sm9iLnJlc3VsdFxuOztcblxubGV0IGZpbHRlcl9tYXAgP2hvdyB0IH5mID0gZmlsdGVyX21hcGkgP2hvdyB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcblxubGV0IGZpbHRlcl9rZXlzID9ob3cgdCB+ZiA9XG4gIGZpbHRlcl9tYXBpID9ob3cgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGtleSBpblxuICAgIGlmIGIgdGhlbiBTb21lIGRhdGEgZWxzZSBOb25lKVxuOztcblxubGV0IGZpbHRlciA/aG93IHQgfmYgPVxuICBmaWx0ZXJfbWFwaSA/aG93IHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGRhdGEgaW5cbiAgICBpZiBiIHRoZW4gU29tZSBkYXRhIGVsc2UgTm9uZSlcbjs7XG5cbmxldCBmaWx0ZXJpID9ob3cgdCB+ZiA9XG4gIGZpbHRlcl9tYXBpID9ob3cgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICBsZXQlbWFwIGIgPSBmIH5rZXkgfmRhdGEgaW5cbiAgICBpZiBiIHRoZW4gU29tZSBkYXRhIGVsc2UgTm9uZSlcbjs7XG5cbmxldCBtYXBpID9ob3cgdCB+ZiA9XG4gIGZpbHRlcl9tYXBpID9ob3cgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICBsZXQlbWFwIHogPSBmIH5rZXkgfmRhdGEgaW5cbiAgICBTb21lIHopXG47O1xuXG5sZXQgbWFwID9ob3cgdCB+ZiA9IG1hcGkgP2hvdyB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcblxubGV0IG1lcmdlID9ob3cgdDEgdDIgfmYgPVxuICBmaWx0ZXJfbWFwXG4gICAgP2hvd1xuICAgIChNYXAubWVyZ2UgdDEgdDIgfmY6KGZ1biB+a2V5IHogLT4gU29tZSAoZnVuICgpIC0+IGYgfmtleSB6KSkpXG4gICAgfmY6KGZ1biB0aHVuayAtPiB0aHVuayAoKSlcbjs7XG5cbmxldCBhbGwgdCA9IG1hcCB0IH5mOkZuLmlkXG4iLCJvcGVuIENvcmVcbm9wZW4gRGVmZXJyZWRfc3RkXG5tb2R1bGUgRGVmZXJyZWQgPSBEZWZlcnJlZDFcblxubGV0IHJlcmFpc2UgPSBmdW5jdGlvblxuICB8IE9rIHggLT4geFxuICB8IEVycm9yIGV4biAtPiBFeG4ucmVyYWlzZSBleG4gXCJjYXVnaHQgZXhjZXB0aW9uIGluIG1lbW9pemVkIGZ1bmN0aW9uXCJcbjs7XG5cbmxldCBnZW5lcmFsICh0eXBlIGEpIChoYXNoYWJsZSA6IChtb2R1bGUgSGFzaGFibGUuU19wbGFpbiB3aXRoIHR5cGUgdCA9IGEpKSBmID1cbiAgbGV0IG1vZHVsZSBIYXNoYWJsZSA9ICh2YWwgaGFzaGFibGUpIGluXG4gIGxldCBmID1cbiAgICBNZW1vLmdlbmVyYWwgfmhhc2hhYmxlOkhhc2hhYmxlLmhhc2hhYmxlIChmdW4gYSAtPlxuICAgICAgTW9uaXRvci50cnlfd2l0aFxuICAgICAgICB+cmVzdDpgTG9nXG4gICAgICAgIH5ydW46YE5vd1xuICAgICAgICAoZnVuICgpIC0+IGYgYSkpXG4gIGluXG4gIFN0YWdlZC5zdGFnZSAoZnVuIGEgLT4gZiBhID4+fCByZXJhaXNlKVxuOztcblxubGV0IHVuaXQgZiA9XG4gIGxldCBmID1cbiAgICBNZW1vLnVuaXQgKGZ1biAoKSAtPlxuICAgICAgTW9uaXRvci50cnlfd2l0aFxuICAgICAgICB+cmVzdDpgTG9nXG4gICAgICAgIH5ydW46YE5vd1xuICAgICAgICBmKVxuICBpblxuICBTdGFnZWQuc3RhZ2UgKGZ1biAoKSAtPiBmICgpID4+fCByZXJhaXNlKVxuOztcbiIsIm9wZW4gQ29yZVxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIE9wdGlvbi50IERlZmVycmVkLnRcbmVuZFxuXG5pbmNsdWRlIFRcblxuaW5jbHVkZSBNb25hZC5NYWtlIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCByZXR1cm4gYSA9IERlZmVycmVkLnJldHVybiAoU29tZSBhKVxuXG4gICAgbGV0IGJpbmQgdCB+ZiA9XG4gICAgICBEZWZlcnJlZC5iaW5kIHQgfmY6KGZ1bmN0aW9uXG4gICAgICAgIHwgU29tZSBhIC0+IGYgYVxuICAgICAgICB8IE5vbmUgLT4gRGVmZXJyZWQucmV0dXJuIE5vbmUpXG4gICAgOztcblxuICAgIGxldCBtYXAgdCB+ZiA9IERlZmVycmVkLm1hcCB0IH5mOihmdW4gciAtPiBPcHRpb24ubWFwIHIgfmYpXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZClcbiIsIm9wZW4gQ29yZVxub3BlbiBEZWZlcnJlZF9zdGRcbm1vZHVsZSBEZWZlcnJlZCA9IERlZmVycmVkMVxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2Vycm9yKSB0ID0gKCdhLCAnZXJyb3IpIFJlc3VsdC50IERlZmVycmVkLnRcbmVuZFxuXG5pbmNsdWRlIFRcblxubGV0IGNvbWJpbmUgdDEgdDIgfm9rIH5lcnIgPVxuICBsZXQlbWFwIHQxID0gdDFcbiAgYW5kIHQyID0gdDIgaW5cbiAgUmVzdWx0LmNvbWJpbmUgdDEgdDIgfm9rIH5lcnJcbjs7XG5cbmluY2x1ZGUgTW9uYWQuTWFrZTIgKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHJldHVybiBhID0gRGVmZXJyZWQucmV0dXJuIChPayBhKVxuXG4gICAgbGV0IGJpbmQgdCB+ZiA9XG4gICAgICBEZWZlcnJlZC5iaW5kIHQgfmY6KGZ1bmN0aW9uXG4gICAgICAgIHwgT2sgYSAtPiBmIGFcbiAgICAgICAgfCBFcnJvciBfIGFzIGVycm9yIC0+IERlZmVycmVkLnJldHVybiBlcnJvcilcbiAgICA7O1xuXG4gICAgbGV0IG1hcCB0IH5mID0gRGVmZXJyZWQubWFwIHQgfmY6KGZ1biByIC0+IFJlc3VsdC5tYXAgciB+ZilcbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgZW5kKVxuXG5sZXQgZmFpbCB4ID0gRGVmZXJyZWQucmV0dXJuIChFcnJvciB4KVxubGV0IGZhaWxmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBmYWlsIGZvcm1hdFxubGV0IG1hcF9lcnJvciB0IH5mID0gRGVmZXJyZWQubWFwIHQgfmY6KGZ1biByIC0+IFJlc3VsdC5tYXBfZXJyb3IgciB+ZilcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5cbm1vZHVsZSBNb25pdG9yID0gc3RydWN0XG4gIGxldCB0cnlfd2l0aCA9IE1vbml0b3IudHJ5X3dpdGhcbmVuZFxuXG4oKiBDb3BpZWQgdG8gW2VhZ2VyX2RlZmVycmVkX29yX2Vycm9yLm1sXS4gIFRoZXJlIHNob3VsZCBiZSBubyBkaWZmcyBiZWxvdyB0aGlzIGxpbmUuICopXG5cbmluY2x1ZGUgKERlZmVycmVkX3Jlc3VsdCA6IE1vbmFkLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIERlZmVycmVkX3Jlc3VsdC50KVxuXG50eXBlICdhIHQgPSAnYSBPcl9lcnJvci50IERlZmVycmVkLnRcblxuaW5jbHVkZSBBcHBsaWNhdGl2ZS5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuXG4gICAgbGV0IGFwcGx5IGYgeCA9XG4gICAgICBEZWZlcnJlZF9yZXN1bHQuY29tYmluZVxuICAgICAgICBmXG4gICAgICAgIHhcbiAgICAgICAgfm9rOihmdW4gZiB4IC0+IGYgeClcbiAgICAgICAgfmVycjooZnVuIGUxIGUyIC0+IEVycm9yLm9mX2xpc3QgWyBlMTsgZTIgXSlcbiAgICA7O1xuXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZClcblxubW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgbGV0IHJldHVybiA9IHJldHVyblxuXG4gIGluY2x1ZGUgTW9uYWRfaW5maXhcblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgbWFwID0gbWFwXG4gICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgbGV0IGJvdGggPSBib3RoXG5cbiAgICAoKiBmcm9tIEFwcGxpY2F0aXZlLk1ha2UgKilcbiAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBzdHJ1Y3QgZW5kXG4gIGVuZFxuZW5kXG5cbm9wZW4gTGV0X3N5bnRheFxuXG5sZXQgZmFpbCBlcnJvciA9IERlZmVycmVkLnJldHVybiAoUmVzdWx0LmZhaWwgZXJyb3IpXG5sZXQgb2tfZXhuIHQgPSBEZWZlcnJlZC5tYXAgdCB+ZjpPcl9lcnJvci5va19leG5cbmxldCBvZl9leG4gZXhuID0gRGVmZXJyZWQucmV0dXJuIChPcl9lcnJvci5vZl9leG4gZXhuKVxubGV0IG9mX2V4bl9yZXN1bHQgdCA9IERlZmVycmVkLm1hcCB0IH5mOk9yX2Vycm9yLm9mX2V4bl9yZXN1bHRcbmxldCBlcnJvciBtc2cgdiBzZXhwX29mID0gRGVmZXJyZWQucmV0dXJuIChPcl9lcnJvci5lcnJvciBtc2cgdiBzZXhwX29mKVxubGV0IGVycm9yX3Mgc2V4cCA9IERlZmVycmVkLnJldHVybiAoT3JfZXJyb3IuZXJyb3JfcyBzZXhwKVxubGV0IGVycm9yX3N0cmluZyBtc2cgPSBEZWZlcnJlZC5yZXR1cm4gKE9yX2Vycm9yLmVycm9yX3N0cmluZyBtc2cpXG5sZXQgZXJyb3JmIGZvcm1hdCA9IGtzcHJpbnRmIGVycm9yX3N0cmluZyBmb3JtYXRcbmxldCB0YWcgdCB+dGFnID0gRGVmZXJyZWQubWFwIHQgfmY6KE9yX2Vycm9yLnRhZyB+dGFnKVxubGV0IHRhZ19zIHQgfnRhZyA9IERlZmVycmVkLm1hcCB0IH5mOihPcl9lcnJvci50YWdfcyB+dGFnKVxubGV0IHRhZ19zX2xhenkgdCB+dGFnID0gRGVmZXJyZWQubWFwIHQgfmY6KE9yX2Vycm9yLnRhZ19zX2xhenkgfnRhZylcblxubGV0IHRhZ19hcmcgdCBtZXNzYWdlIGEgc2V4cF9vZl9hID1cbiAgRGVmZXJyZWQubWFwIHQgfmY6KGZ1biB0IC0+IE9yX2Vycm9yLnRhZ19hcmcgdCBtZXNzYWdlIGEgc2V4cF9vZl9hKVxuOztcblxubGV0IHVuaW1wbGVtZW50ZWQgbXNnID0gRGVmZXJyZWQucmV0dXJuIChPcl9lcnJvci51bmltcGxlbWVudGVkIG1zZylcbmxldCBjb21iaW5lX2Vycm9ycyBsID0gRGVmZXJyZWQubWFwIChEZWZlcnJlZC5hbGwgbCkgfmY6T3JfZXJyb3IuY29tYmluZV9lcnJvcnNcbmxldCBjb21iaW5lX2Vycm9yc191bml0IGwgPSBEZWZlcnJlZC5tYXAgKERlZmVycmVkLmFsbCBsKSB+ZjpPcl9lcnJvci5jb21iaW5lX2Vycm9yc191bml0XG5cbmxldCBmaWx0ZXJfb2tfYXRfbGVhc3Rfb25lIGwgPVxuICBEZWZlcnJlZC5tYXAgKERlZmVycmVkLmFsbCBsKSB+ZjpPcl9lcnJvci5maWx0ZXJfb2tfYXRfbGVhc3Rfb25lXG47O1xuXG5sZXQgZmluZF9tYXBfb2sgbCB+ZiA9XG4gIERlZmVycmVkLnJlcGVhdF91bnRpbF9maW5pc2hlZCAobCwgW10pIChmdW4gKGwsIGVycm9ycykgLT5cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBsZXQgZXJyb3JzID0gRXJyb3Iub2ZfbGlzdCAoTGlzdC5yZXYgZXJyb3JzKSBpblxuICAgICAgRGVmZXJyZWQucmV0dXJuIChgRmluaXNoZWQgKEVycm9yIGVycm9ycykpXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgRGVmZXJyZWQubWFwIChmIGhkKSB+ZjooZnVuY3Rpb25cbiAgICAgICAgfCBFcnJvciBjdXJyZW50X2Vycm9yIC0+IGBSZXBlYXQgKHRsLCBjdXJyZW50X2Vycm9yIDo6IGVycm9ycylcbiAgICAgICAgfCBPayByZXN1bHQgLT4gYEZpbmlzaGVkIChPayByZXN1bHQpKSlcbjs7XG5cbmxldCBva191bml0ID0gcmV0dXJuICgpXG5cbmxldCB0cnlfd2l0aCA/ZXh0cmFjdF9leG4gP3J1biA/cmVzdCA/aGVyZSA/bmFtZSBmID1cbiAgRGVmZXJyZWQubWFwIChNb25pdG9yLnRyeV93aXRoID9leHRyYWN0X2V4biA/cnVuID9yZXN0ID9oZXJlID9uYW1lIGYpIH5mOihmdW5jdGlvblxuICAgIHwgRXJyb3IgZXhuIC0+IEVycm9yIChFcnJvci5vZl9leG4gZXhuKVxuICAgIHwgT2sgXyBhcyBvayAtPiBvaylcbjs7XG5cbmxldCB0cnlfd2l0aF9qb2luID9leHRyYWN0X2V4biA/cnVuID9yZXN0ID9oZXJlID9uYW1lIGYgPVxuICBEZWZlcnJlZC5tYXAgKHRyeV93aXRoID9leHRyYWN0X2V4biA/cnVuID9yZXN0ID9oZXJlID9uYW1lIGYpIH5mOk9yX2Vycm9yLmpvaW5cbjs7XG5cbm1vZHVsZSBMaXN0ID0gc3RydWN0XG4gIGxldCBmb2xkaSBsaXN0IH5pbml0OmFjYyB+ZiA9XG4gICAgbGV0IHJlYyBsb29wIGkgYWNjID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuIGFjY1xuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICBsZXQlYmluZCBhY2MgPSBmIGkgYWNjIGhkIGluXG4gICAgICAgIGxvb3AgKGkgKyAxKSBhY2MgdGxcbiAgICBpblxuICAgIGxvb3AgMCBhY2MgbGlzdFxuICA7O1xuXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBmb2xkaSB0IH5pbml0IH5mOihmdW4gXyBhIHggLT4gZiBhIHgpXG5cbiAgbGV0IHNlcW1hcGkgdCB+ZiA9XG4gICAgZm9sZGkgdCB+aW5pdDpbXSB+ZjooZnVuIGkgYnMgYSAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBpIGEgaW5cbiAgICAgIGIgOjogYnMpXG4gICAgPj58IExpc3QucmV2XG4gIDs7XG5cbiAgbGV0IGFsbCA9IGFsbFxuICBsZXQgYWxsX3VuaXQgPSBhbGxfdW5pdFxuXG4gIGxldCBpdGVyaSA/KGhvdyA9IGBTZXF1ZW50aWFsKSB0IH5mID1cbiAgICBtYXRjaCBob3cgd2l0aFxuICAgIHwgKGBQYXJhbGxlbCB8IGBNYXhfY29uY3VycmVudF9qb2JzIF8pIGFzIGhvdyAtPlxuICAgICAgYWxsX3VuaXQgKExpc3QubWFwaSB0IH5mOih1bnN0YWdlIChUaHJvdHRsZS5tb25hZF9zZXF1ZW5jZV9ob3cyIH5ob3cgfmYpKSlcbiAgICB8IGBTZXF1ZW50aWFsIC0+IGZvbGRpIHQgfmluaXQ6KCkgfmY6KGZ1biBpICgpIHggLT4gZiBpIHgpXG4gIDs7XG5cbiAgbGV0IG1hcGkgPyhob3cgPSBgU2VxdWVudGlhbCkgdCB+ZiA9XG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IChgUGFyYWxsZWwgfCBgTWF4X2NvbmN1cnJlbnRfam9icyBfKSBhcyBob3cgLT5cbiAgICAgIGFsbCAoTGlzdC5tYXBpIHQgfmY6KHVuc3RhZ2UgKFRocm90dGxlLm1vbmFkX3NlcXVlbmNlX2hvdzIgfmhvdyB+ZikpKVxuICAgIHwgYFNlcXVlbnRpYWwgLT4gc2VxbWFwaSB0IH5mXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXBpID9ob3cgdCB+ZiA9IG1hcGkgdCA/aG93IH5mID4+fCBMaXN0LmZpbHRlcl9vcHRcbiAgbGV0IGNvbmNhdF9tYXBpID9ob3cgdCB+ZiA9IG1hcGkgdCA/aG93IH5mID4+fCBMaXN0LmNvbmNhdFxuXG4gIGxldCBmaWx0ZXJpID9ob3cgdCB+ZiA9XG4gICAgZmlsdGVyX21hcGkgP2hvdyB0IH5mOihmdW4gaSB4IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgeCBpblxuICAgICAgaWYgYiB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpXG4gIDs7XG5cbiAgbGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgICBsZXQgcmVjIGZpbmRfbWFwaSB0IH5mIGkgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IHJldHVybiBOb25lXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIChtYXRjaCViaW5kIGYgaSBoZCB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gZmluZF9tYXBpIHRsIH5mIChpICsgMSlcbiAgICAgICAgIHwgU29tZSBfIGFzIHNvbWUgLT4gcmV0dXJuIHNvbWUpXG4gICAgaW5cbiAgICBmaW5kX21hcGkgdCB+ZiAwXG4gIDs7XG5cbiAgbGV0IGZpbmRfbWFwIHQgfmYgPSBmaW5kX21hcGkgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5cbiAgbGV0IGZpbmRpIHQgfmYgPVxuICAgIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICAgIGxldCVtYXAgYiA9IGYgaSBlbHQgaW5cbiAgICAgIGlmIGIgdGhlbiBTb21lIChpLCBlbHQpIGVsc2UgTm9uZSlcbiAgOztcblxuICBsZXQgZmluZCB0IH5mID1cbiAgICBmaW5kX21hcCB0IH5mOihmdW4gZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGVsdCBpblxuICAgICAgaWYgYiB0aGVuIFNvbWUgZWx0IGVsc2UgTm9uZSlcbiAgOztcblxuICBsZXQgZXhpc3RzaSB0IH5mID1cbiAgICBtYXRjaCVtYXBcbiAgICAgIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICAgICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgICAgICBpZiBiIHRoZW4gU29tZSAoKSBlbHNlIE5vbmUpXG4gICAgd2l0aFxuICAgIHwgU29tZSAoKSAtPiB0cnVlXG4gICAgfCBOb25lIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IGZvcl9hbGxpIHQgfmYgPVxuICAgIG1hdGNoJW1hcFxuICAgICAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICAgIGlmIG5vdCBiIHRoZW4gU29tZSAoKSBlbHNlIE5vbmUpXG4gICAgd2l0aFxuICAgIHwgU29tZSAoKSAtPiBmYWxzZVxuICAgIHwgTm9uZSAtPiB0cnVlXG4gIDs7XG5cbiAgbGV0IGl0ZXIgP2hvdyB0IH5mID0gaXRlcmkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IG1hcCA/aG93IHQgfmYgPSBtYXBpID9ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG4gIGxldCBmaWx0ZXIgP2hvdyB0IH5mID0gZmlsdGVyaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgZmlsdGVyX21hcCA/aG93IHQgfmYgPSBmaWx0ZXJfbWFwaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgY29uY2F0X21hcCA/aG93IHQgfmYgPSBjb25jYXRfbWFwaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgZmluZF9tYXAgdCB+ZiA9IGZpbmRfbWFwaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IGV4aXN0cyB0IH5mID0gZXhpc3RzaSB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IGZvcl9hbGxpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxuICBsZXQgaW5pdCA/aG93IG4gfmYgPSBtYXAgP2hvdyAoTGlzdC5pbml0IG4gfmY6Rm4uaWQpIH5mXG5lbmRcblxubGV0IHJlYyByZXBlYXRfdW50aWxfZmluaXNoZWQgc3RhdGUgZiA9XG4gIG1hdGNoJWJpbmQgZiBzdGF0ZSB3aXRoXG4gIHwgYFJlcGVhdCBzdGF0ZSAtPiByZXBlYXRfdW50aWxfZmluaXNoZWQgc3RhdGUgZlxuICB8IGBGaW5pc2hlZCBzdGF0ZSAtPiByZXR1cm4gc3RhdGVcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4gRGVmZXJyZWRfc3RkXG5tb2R1bGUgTGlzdCA9IERlZmVycmVkX2xpc3RcblxuKCogV2UgaW1wbGVtZW50IGFsbCBvZiB0aGUgW1F1ZXVlXSBvcGVyYXRpb25zIGJ5IGNvbnZlcnRpbmcgdGhlIHF1ZXVlIHRvIGEgbGlzdCBhbmQgdGhlblxuICAgdXNpbmcgdGhlIGNvcnJlc3BvbmRpbmcgW0xpc3RdIG9wZXJhdGlvbi4gIFdlIHVzZSBsaXN0cyByYXRoZXIgdGhhbiBhcnJheXMgYmVjYXVzZVxuICAgYXJyYXlzIGxvbmdlciB0aGFuIGEgY2VydGFpbiBsZW5ndGggYXJlIGFsbG9jYXRlZCBpbiB0aGUgbWFqb3IgaGVhcCwgd2hpY2ggY2FuIGNhdXNlXG4gICB1bm5lY2Vzc2FyeSBwcm9tb3Rpb24gb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBxdWV1ZS4gIEFsc28sIHdoZW4gb25lIGlzIGZvbGRpbmcgb3JcbiAgIGl0ZXJhdGluZyBvdmVyIGFuIGFycmF5LCB0aGUgZW50aXJlIGFycmF5IG11c3QgYmUga2VwdCBhbGl2ZS4gIFdoZW4gZm9sZGluZyBvclxuICAgaXRlcmF0aW5nIG92ZXIgYSBsaXN0LCBvbmx5IHRoZSByZW1haW5pbmcgdGFpbCBvZiB0aGUgbGlzdCBpcyBrZXB0IGFsaXZlLiAgU28sIHVzaW5nXG4gICBhcnJheXMgcmF0aGVyIHRoYW4gbGlzdHMgd291bGQgaW5jcmVhc2UgdGhlIGxpdmUtc3BhY2UgbmVlZGVkIGJ5IHRoZSBwcm9ncmFtLiAqKVxuXG5sZXQgZm9sZGkgdCB+aW5pdCB+ZiA9IExpc3QuZm9sZGkgKFF1ZXVlLnRvX2xpc3QgdCkgfmluaXQgfmZcbmxldCBmb2xkIHQgfmluaXQgfmYgPSBMaXN0LmZvbGQgKFF1ZXVlLnRvX2xpc3QgdCkgfmluaXQgfmZcbmxldCBhbGwgdCA9IExpc3QuYWxsIChRdWV1ZS50b19saXN0IHQpID4+fCBRdWV1ZS5vZl9saXN0XG5sZXQgYWxsX3VuaXQgdCA9IExpc3QuYWxsX3VuaXQgKFF1ZXVlLnRvX2xpc3QgdClcbmxldCBpdGVyID9ob3cgdCB+ZiA9IExpc3QuaXRlciA/aG93IChRdWV1ZS50b19saXN0IHQpIH5mXG5sZXQgaXRlcmkgP2hvdyB0IH5mID0gTGlzdC5pdGVyaSA/aG93IChRdWV1ZS50b19saXN0IHQpIH5mXG5sZXQgbWFwID9ob3cgdCB+ZiA9IExpc3QubWFwID9ob3cgKFF1ZXVlLnRvX2xpc3QgdCkgfmYgPj58IFF1ZXVlLm9mX2xpc3RcbmxldCBtYXBpID9ob3cgdCB+ZiA9IExpc3QubWFwaSA/aG93IChRdWV1ZS50b19saXN0IHQpIH5mID4+fCBRdWV1ZS5vZl9saXN0XG5sZXQgaW5pdCA/aG93IG4gfmYgPSBMaXN0LmluaXQgP2hvdyBuIH5mID4+fCBRdWV1ZS5vZl9saXN0XG5sZXQgZmlsdGVyID9ob3cgdCB+ZiA9IExpc3QuZmlsdGVyID9ob3cgKFF1ZXVlLnRvX2xpc3QgdCkgfmYgPj58IFF1ZXVlLm9mX2xpc3RcbmxldCBmaWx0ZXJpID9ob3cgdCB+ZiA9IExpc3QuZmlsdGVyaSA/aG93IChRdWV1ZS50b19saXN0IHQpIH5mID4+fCBRdWV1ZS5vZl9saXN0XG5sZXQgZmlsdGVyX21hcCA/aG93IHQgfmYgPSBMaXN0LmZpbHRlcl9tYXAgP2hvdyAoUXVldWUudG9fbGlzdCB0KSB+ZiA+PnwgUXVldWUub2ZfbGlzdFxubGV0IGZpbHRlcl9tYXBpID9ob3cgdCB+ZiA9IExpc3QuZmlsdGVyX21hcGkgP2hvdyAoUXVldWUudG9fbGlzdCB0KSB+ZiA+PnwgUXVldWUub2ZfbGlzdFxuXG5sZXQgY29uY2F0X21hcCA/aG93IHQgfmYgPVxuICBMaXN0LmNvbmNhdF9tYXAgP2hvdyAoUXVldWUudG9fbGlzdCB0KSB+ZjooZnVuIHggLT4gZiB4ID4+fCBRdWV1ZS50b19saXN0KVxuICA+PnwgUXVldWUub2ZfbGlzdFxuOztcblxubGV0IGNvbmNhdF9tYXBpID9ob3cgdCB+ZiA9XG4gIExpc3QuY29uY2F0X21hcGkgP2hvdyAoUXVldWUudG9fbGlzdCB0KSB+ZjooZnVuIGkgeCAtPiBmIGkgeCA+PnwgUXVldWUudG9fbGlzdClcbiAgPj58IFF1ZXVlLm9mX2xpc3Rcbjs7XG5cbmxldCBmaW5kX21hcCB0IH5mID0gTGlzdC5maW5kX21hcCAoUXVldWUudG9fbGlzdCB0KSB+ZlxubGV0IGZpbmRfbWFwaSB0IH5mID0gTGlzdC5maW5kX21hcGkgKFF1ZXVlLnRvX2xpc3QgdCkgfmZcbmxldCBmaW5kIHQgfmYgPSBMaXN0LmZpbmQgKFF1ZXVlLnRvX2xpc3QgdCkgfmZcbmxldCBmaW5kaSB0IH5mID0gTGlzdC5maW5kaSAoUXVldWUudG9fbGlzdCB0KSB+ZlxubGV0IGZvcl9hbGwgdCB+ZiA9IExpc3QuZm9yX2FsbCAoUXVldWUudG9fbGlzdCB0KSB+ZlxubGV0IGZvcl9hbGxpIHQgfmYgPSBMaXN0LmZvcl9hbGxpIChRdWV1ZS50b19saXN0IHQpIH5mXG5sZXQgZXhpc3RzIHQgfmYgPSBMaXN0LmV4aXN0cyAoUXVldWUudG9fbGlzdCB0KSB+ZlxubGV0IGV4aXN0c2kgdCB+ZiA9IExpc3QuZXhpc3RzaSAoUXVldWUudG9fbGlzdCB0KSB+ZlxuIiwib3BlbiBDb3JlXG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWQxXG5cbigqIFtmb2xkX21hcGkgP2hvdyB0IH5pbml0IH5tYXBpX2YgfmZvbGRfZl0gaXMgYSBtb3JlIGVmZmljaWVudCB2ZXJzaW9uIG9mOlxuXG4gICB7W1xuICAgICBmb2xkIH5pbml0IH5mOihmdW4gYiBhIC0+IHJldHVybiAoZm9sZF9mIGIgYSkpIChtYXBpIHQgP2hvdyB+ZjptYXBpX2YpIF19XG5cbiAgIEl0IGF2b2lkcyBjcmVhdGluZyB0aGUgaW50ZXJtZWRpYXRlIHNlcXVlbmNlIHRoYXQgd291bGQgcmVzdWx0IGZyb20gW21hcGldLCBhbmRcbiAgIGFsbG93cyB0aGUgW2ZvbGRdIHRvIHByb2NlZWQgY29uY3VycmVudGx5IHdpdGggdGhlIFttYXBpXSwgc28gdGhhdCBvbmUgY2FuIGFjY3VtdWxhdGVcbiAgIHRoZSByZXN1bHQgYXMgc29vbiBhcyBwb3NzaWJsZSwgcG9zc2libHkgYXZvaWRpbmcgY3JlYXRpbmcgYW4gaW50ZXJtZWRpYXRlIHN0cnVjdHVyZVxuICAgKGUuZy4gW2l0ZXJpXSBhbmQgW2ZpbHRlcl9tYXBdIHVzZXMgW2ZvbGRfbWFwaV0gdG8gZG8gdGhpcykuICopXG5sZXQgZm9sZF9tYXBpXG4gICAgICAodHlwZSBhIGIgYylcbiAgICAgID8oaG93ID0gYFNlcXVlbnRpYWwpXG4gICAgICAodCA6IGEgU2VxdWVuY2UudClcbiAgICAgIH4oaW5pdCA6IGMpXG4gICAgICB+KG1hcGlfZiA6IGludCAtPiBhIC0+IGIgRGVmZXJyZWQudClcbiAgICAgIH4oZm9sZF9mIDogYyAtPiBiIC0+IGMpXG4gIDogYyBEZWZlcnJlZC50XG4gID1cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCBgU2VxdWVudGlhbCAtPlxuICAgIGxldCByZWMgbG9vcCBpIHQgKGMgOiBjKSA9XG4gICAgICBtYXRjaCBTZXF1ZW5jZS5uZXh0IHQgd2l0aFxuICAgICAgfCBOb25lIC0+IHJldHVybiBjXG4gICAgICB8IFNvbWUgKGEsIHQpIC0+XG4gICAgICAgIGxldCViaW5kIGIgPSBtYXBpX2YgaSBhIGluXG4gICAgICAgIGxvb3AgKGkgKyAxKSB0IChmb2xkX2YgYyBiKVxuICAgIGluXG4gICAgbG9vcCAwIHQgaW5pdFxuICB8IGBQYXJhbGxlbCAtPlxuICAgIGxldCByZWMgbG9vcCBpIHQgKGMgOiBjIERlZmVycmVkLnQpID1cbiAgICAgIG1hdGNoIFNlcXVlbmNlLm5leHQgdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gY1xuICAgICAgfCBTb21lIChhLCB0KSAtPlxuICAgICAgICBsb29wXG4gICAgICAgICAgKGkgKyAxKVxuICAgICAgICAgIHRcbiAgICAgICAgICAobGV0JWJpbmQgYiA9IG1hcGlfZiBpIGEgaW5cbiAgICAgICAgICAgbGV0JW1hcCBjID0gYyBpblxuICAgICAgICAgICBmb2xkX2YgYyBiKVxuICAgIGluXG4gICAgbG9vcCAwIHQgKHJldHVybiBpbml0KVxuICB8IGBNYXhfY29uY3VycmVudF9qb2JzIG1heF9jb25jdXJyZW50X2pvYnMgLT5cbiAgICBsZXQgdGhyb3R0bGUgPSBUaHJvdHRsZS5jcmVhdGUgfm1heF9jb25jdXJyZW50X2pvYnMgfmNvbnRpbnVlX29uX2Vycm9yOmZhbHNlIGluXG4gICAgKCogW2xvb3BdIGZvcmNlcyB0aGUgaW5wdXQgc2VxdWVuY2UgYW5kIGVucXVldWVzIGEgdGhyb3R0bGUgam9iIG9ubHkgaWYgdGhlcmUgaXNcbiAgICAgICBjYXBhY2l0eSBhdmFpbGFibGUuICopXG4gICAgbGV0IHJlYyBsb29wIGkgdCAoYyA6IGMgRGVmZXJyZWQudCkgPVxuICAgICAgbGV0JWJpbmQgKCkgPSBUaHJvdHRsZS5jYXBhY2l0eV9hdmFpbGFibGUgdGhyb3R0bGUgaW5cbiAgICAgIG1hdGNoIFNlcXVlbmNlLm5leHQgdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gY1xuICAgICAgfCBTb21lIChhLCB0KSAtPlxuICAgICAgICBsb29wXG4gICAgICAgICAgKGkgKyAxKVxuICAgICAgICAgIHRcbiAgICAgICAgICAobGV0JWJpbmQgYiA9IFRocm90dGxlLmVucXVldWUgdGhyb3R0bGUgKGZ1biAoKSAtPiBtYXBpX2YgaSBhKSBpblxuICAgICAgICAgICBsZXQlbWFwIGMgPSBjIGluXG4gICAgICAgICAgIGZvbGRfZiBjIGIpXG4gICAgaW5cbiAgICBsb29wIDAgdCAocmV0dXJuIGluaXQpXG47O1xuXG5sZXQgZm9sZGkgdCB+aW5pdCB+ZiA9XG4gIFNlcXVlbmNlLmRlbGF5ZWRfZm9sZFxuICAgIHRcbiAgICB+aW5pdDooMCwgaW5pdClcbiAgICB+ZjooZnVuIChpLCBiKSBhIH5rIC0+XG4gICAgICBsZXQlYmluZCBiID0gZiBpIGIgYSBpblxuICAgICAgayAoaSArIDEsIGIpKVxuICAgIH5maW5pc2g6KGZ1biAoXywgYikgLT4gcmV0dXJuIGIpXG47O1xuXG4oKiBbZm9sZF0gaXMgbm90IGltcGxlbWVudGVkIGluIHRlcm1zIG9mIFtmb2xkaV0gdG8gc2F2ZSB0aGUgaW50ZXJtZWRpYXRlIGNsb3N1cmVcbiAgIGFsbG9jYXRpb24uICopXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgU2VxdWVuY2UuZGVsYXllZF9mb2xkIHQgfmluaXQgfmY6KGZ1biBiIGEgfmsgLT4gZiBiIGEgPj49IGspIH5maW5pc2g6cmV0dXJuXG47O1xuXG5sZXQgYWxsIHQgPVxuICBsZXQlbWFwIHJlcyA9XG4gICAgZm9sZCB0IH5pbml0OltdIH5mOihmdW4gYWNjdW0gZCAtPlxuICAgICAgbGV0JW1hcCBhID0gZCBpblxuICAgICAgYSA6OiBhY2N1bSlcbiAgaW5cbiAgU2VxdWVuY2Uub2ZfbGlzdCAoTGlzdC5yZXYgcmVzKVxuOztcblxubGV0IGFsbF91bml0IHQgPSBmb2xkIHQgfmluaXQ6KCkgfmY6KGZ1biAoKSB2IC0+IHYpXG5cbmxldCBmaW5kX21hcGkgdCB+ZiA9XG4gIGxldCByZWMgZmluZF9tYXBpIHQgfmYgaSA9XG4gICAgbWF0Y2ggU2VxdWVuY2UubmV4dCB0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmV0dXJuIE5vbmVcbiAgICB8IFNvbWUgKHYsIHJlc3QpIC0+XG4gICAgICAobWF0Y2glYmluZCBmIGkgdiB3aXRoXG4gICAgICAgfCBOb25lIC0+IGZpbmRfbWFwaSByZXN0IH5mIChpICsgMSlcbiAgICAgICB8IFNvbWUgXyBhcyBzb21lIC0+IHJldHVybiBzb21lKVxuICBpblxuICBmaW5kX21hcGkgdCB+ZiAwXG47O1xuXG5sZXQgZmluZGkgdCB+ZiA9XG4gIGZpbmRfbWFwaSB0IH5mOihmdW4gaSBlbHQgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgaWYgYiB0aGVuIFNvbWUgKGksIGVsdCkgZWxzZSBOb25lKVxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIGZpbmRfbWFwaSB0IH5mOihmdW4gXyBlbHQgLT5cbiAgICBsZXQlbWFwIGIgPSBmIGVsdCBpblxuICAgIGlmIGIgdGhlbiBTb21lIGVsdCBlbHNlIE5vbmUpXG47O1xuXG5sZXQgZXhpc3RzaSB0IH5mID1cbiAgbWF0Y2glbWFwXG4gICAgZmluZF9tYXBpIHQgfmY6KGZ1biBpIGVsdCAtPlxuICAgICAgbGV0JW1hcCBiID0gZiBpIGVsdCBpblxuICAgICAgaWYgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICB3aXRoXG4gIHwgU29tZSAoKSAtPiB0cnVlXG4gIHwgTm9uZSAtPiBmYWxzZVxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBtYXRjaCVtYXBcbiAgICBmaW5kX21hcGkgdCB+ZjooZnVuIGkgZWx0IC0+XG4gICAgICBsZXQlbWFwIGIgPSBmIGkgZWx0IGluXG4gICAgICBpZiBub3QgYiB0aGVuIFNvbWUgKCkgZWxzZSBOb25lKVxuICB3aXRoXG4gIHwgU29tZSAoKSAtPiBmYWxzZVxuICB8IE5vbmUgLT4gdHJ1ZVxuOztcblxubGV0IGl0ZXJpID9ob3cgdCB+ZiA6IHVuaXQgRGVmZXJyZWQudCA9XG4gIGZvbGRfbWFwaSA/aG93IHQgfm1hcGlfZjpmIH5pbml0OigpIH5mb2xkX2Y6KGZ1biAoKSAoKSAtPiAoKSlcbjs7XG5cbmxldCBtYXBpID9ob3cgdCB+ZiA9XG4gIGxldCVtYXAgYnMgPVxuICAgIGZvbGRfbWFwaSA/aG93IHQgfm1hcGlfZjooZnVuIGkgYSAtPiBmIGkgYSkgfmluaXQ6W10gfmZvbGRfZjooZnVuIGJzIGIgLT4gYiA6OiBicylcbiAgaW5cbiAgU2VxdWVuY2Uub2ZfbGlzdCAoTGlzdC5yZXYgYnMpXG47O1xuXG4oKiBbZmlsdGVyX21hcGldIGlzIGltcGxlbWVudGVkIHVzaW5nIFtmb2xkX21hcGldIHJhdGhlciB0aGFuIFttYXBdIHNvIHRoYXQgd2UgbmV2ZXIgbmVlZFxuICAgdG8ga2VlcCBhIGxvbmcgc3RyZWFtIG9mIGludGVybWVkaWF0ZSBbTm9uZV0gcmVzdWx0cyBpbiB0aGUgYWNjdW11bGF0b3IsIG9ubHkgdG8gbGF0ZXJcbiAgIGZpbHRlciB0aGVtIGFsbCBvdXQuICopXG5sZXQgZmlsdGVyX21hcGkgP2hvdyB0IH5mID1cbiAgbGV0JW1hcCBicyA9XG4gICAgZm9sZF9tYXBpXG4gICAgICB0XG4gICAgICA/aG93XG4gICAgICB+bWFwaV9mOihmdW4gaSBhIC0+IGYgaSBhKVxuICAgICAgfmluaXQ6W11cbiAgICAgIH5mb2xkX2Y6KGZ1biBicyBtYXliZV92IC0+XG4gICAgICAgIG1hdGNoIG1heWJlX3Ygd2l0aFxuICAgICAgICB8IE5vbmUgLT4gYnNcbiAgICAgICAgfCBTb21lIGIgLT4gYiA6OiBicylcbiAgaW5cbiAgU2VxdWVuY2Uub2ZfbGlzdCAoTGlzdC5yZXYgYnMpXG47O1xuXG5sZXQgY29uY2F0X21hcGkgP2hvdyB0IH5mID0gbWFwaSA/aG93IHQgfmYgPj58IFNlcXVlbmNlLmNvbmNhdFxuXG5sZXQgZmlsdGVyaSA/aG93IHQgfmYgPVxuICBmaWx0ZXJfbWFwaSA/aG93IHQgfmY6KGZ1biBpIGEgLT5cbiAgICBtYXRjaCVtYXAgZiBpIGEgd2l0aFxuICAgIHwgdHJ1ZSAtPiBTb21lIGFcbiAgICB8IGZhbHNlIC0+IE5vbmUpXG47O1xuXG5sZXQgaXRlciA/aG93IHQgfmYgPSBpdGVyaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IG1hcCA/aG93IHQgfmYgPSBtYXBpID9ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZmlsdGVyID9ob3cgdCB+ZiA9IGZpbHRlcmkgP2hvdyB0IH5mOihmdW4gXyBhIC0+IGYgYSlcbmxldCBmaWx0ZXJfbWFwID9ob3cgdCB+ZiA9IGZpbHRlcl9tYXBpID9ob3cgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgY29uY2F0X21hcCA/aG93IHQgfmYgPSBjb25jYXRfbWFwaSA/aG93IHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZpbmRfbWFwIHQgfmYgPSBmaW5kX21hcGkgdCB+ZjooZnVuIF8gYSAtPiBmIGEpXG5sZXQgZXhpc3RzIHQgfmYgPSBleGlzdHNpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGZvcl9hbGwgdCB+ZiA9IGZvcl9hbGxpIHQgfmY6KGZ1biBfIGEgLT4gZiBhKVxubGV0IGluaXQgP2hvdyBuIH5mID0gbWFwID9ob3cgKFNlcXVlbmNlLmluaXQgbiB+ZjpGbi5pZCkgfmZcbiIsIm9wZW4hIENvcmVcbm9wZW4hIEltcG9ydFxubW9kdWxlIENsb2NrX25zID0gQ2xvY2tfbnNcbm1vZHVsZSBUaW1lX25zID0gVGltZV9uc1xubW9kdWxlIFRpbWUgPSBUaW1lXG5tb2R1bGUgQXN5bmNfa2VybmVsX3NjaGVkdWxlciA9IEFzeW5jX2tlcm5lbF9zY2hlZHVsZXJcbm1vZHVsZSBEYXRlID0gRGF0ZVxuXG5sZXQgYWZ0ZXIgPSBDbG9ja19ucy5hZnRlclxubGV0IGF0ID0gQ2xvY2tfbnMuYXRcbmxldCBldmVyeSA9IENsb2NrX25zLmV2ZXJ5XG5sZXQgd2l0aF90aW1lb3V0ID0gQ2xvY2tfbnMud2l0aF90aW1lb3V0XG4iLCJvcGVuIENvcmVcbm9wZW4gSW1wb3J0XG5vcGVuIERlZmVycmVkX3N0ZFxubW9kdWxlIFN0cmVhbSA9IEFzeW5jX3N0cmVhbVxuXG5sZXQgc2hvd19kZWJ1Z19tZXNzYWdlcyA9IHJlZiBmYWxzZVxubGV0IGNoZWNrX2ludmFyaWFudCA9IHJlZiBmYWxzZVxuXG5tb2R1bGUgRmx1c2hlZF9yZXN1bHQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICBbIGBPa1xuICAgIHwgYFJlYWRlcl9jbG9zZWRcbiAgICBdXG4gIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgbGV0IGVxdWFsID0gWyVjb21wYXJlLmVxdWFsOiB0XVxuXG4gIGxldCBjb21iaW5lIChsIDogdCBEZWZlcnJlZC50IGxpc3QpID1cbiAgICBsZXQlbWFwIGwgPSBEZWZlcnJlZC5hbGwgbCBpblxuICAgIG1hdGNoIExpc3QubWVtIGwgYFJlYWRlcl9jbG9zZWQgfmVxdWFsIHdpdGhcbiAgICB8IHRydWUgLT4gYFJlYWRlcl9jbG9zZWRcbiAgICB8IGZhbHNlIC0+IGBPa1xuICA7O1xuZW5kXG5cbigqIEEgW0NvbnN1bWVyLnRdIGFjdHMgYXMgdGhlIG1vbml0b3Igb2Ygc29tZSBwcm9jZXNzIHRoYXQgcmVhZHMgdmFsdWVzIGZyb20gYSBwaXBlIGFuZFxuICAgcHJvY2Vzc2VzIHRoZW0sIGFsbG93aW5nIHRoYXQgcHJvY2VzczpcbiAgIC0gdG8gY29tbXVuaWNhdGUgdGhhdCBpdCBoYXMgdGFrZW4gcmVzcG9uc2liaWxpdHkgZm9yIHRoZSB2YWx1ZXNcbiAgIC0gdG8gc2lnbmFsIHdoZW4gaXQgaGFzIGZpbmlzaGVkIHdpdGggdGhlIHZhbHVlcyB0byBpbnRlcmVzdGVkIHBhcnRpZXMgKHZpYVxuICAgICBbZG93bnN0cmVhbV9mbHVzaGVkXSlcblxuICAgSXQgaXMgdXNlZCBpbiB0d28gc3RlcHM6XG5cbiAgIDEuIGNhbGxpbmcgW0NvbnN1bWVyLnN0YXJ0XSBhdCB0aGUgcG9pbnQgd2hlcmUgdGhlIGNvbnN1bWVyIHRha2VzIHZhbHVlcyBvdXQgb2YgdGhlXG4gICBQaXBlIHZpYSBbcmVhZF0gb3IgW3JlYWQnXS5cblxuICAgMi4gY2FsbGluZyBbQ29uc3VtZXIudmFsdWVzX3NlbnRfZG93bnN0cmVhbV0uXG5cbiAgIEJ5IGNhbGxpbmcgW3ZhbHVlc19zZW50X2Rvd25zdHJlYW1dIG9uZSBhc3NlcnRzIHRoYXQgdGhlIFtkb3duc3RyZWFtX2ZsdXNoZWRdIGZ1bmN0aW9uXG4gICBzdXBwbGllZCB0byBbY3JlYXRlXSB3aWxsIG5vdyB3YWl0IGZvciB0aGlzIHZhbHVlLlxuXG4gICBJZiBubyBbQ29uc3VtZXIudF0gaXMgc3VwcGxpZWQgd2hlbiBhIHZhbHVlIGlzIHJlYWQgdGhlbiB0aGUgdmFsdWUgaXMgZGVmaW5lZCB0byBiZVxuICAgZmx1c2hlZCBhdCB0aGF0IHRpbWUuICopXG5tb2R1bGUgQ29uc3VtZXIgOiBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBJbnZhcmlhbnQuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsIGNyZWF0ZVxuICAgIDogIHBpcGVfaWQ6aW50XG4gICAgLT4gZG93bnN0cmVhbV9mbHVzaGVkOih1bml0IC0+IEZsdXNoZWRfcmVzdWx0LnQgRGVmZXJyZWQudClcbiAgICAtPiB0XG5cbiAgdmFsIHBpcGVfaWQgOiB0IC0+IGludFxuICB2YWwgc3RhcnQgOiB0IC0+IHVuaXRcbiAgdmFsIHZhbHVlc19zZW50X2Rvd25zdHJlYW0gOiB0IC0+IHVuaXRcbiAgdmFsIHZhbHVlc19zZW50X2Rvd25zdHJlYW1fYW5kX2ZsdXNoZWQgOiB0IC0+IEZsdXNoZWRfcmVzdWx0LnQgRGVmZXJyZWQudFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBwaXBlX2lkIDogaW50XG4gICAgOyAoKiBbdmFsdWVzX3JlYWRdIHJlZmxlY3RzIHdoZXRoZXIgdmFsdWVzIHRoZSBjb25zdW1lciBoYXMgcmVhZCBmcm9tIHRoZSBwaXBlIGhhdmUgYmVlblxuICAgICAgICAgc2VudCBkb3duc3RyZWFtIG9yIGlmIG5vdCwgaG9sZHMgYW4gaXZhciB0aGF0IGlzIHRvIGJlIGZpbGxlZCB3aGVuIHRoZXkgYXJlLiAqKVxuICAgICAgbXV0YWJsZSB2YWx1ZXNfcmVhZCA6XG4gICAgICAgIFsgYEhhdmVfYmVlbl9zZW50X2Rvd25zdHJlYW0gfCBgSGF2ZV9ub3RfYmVlbl9zZW50X2Rvd25zdHJlYW0gb2YgdW5pdCBJdmFyLnQgXVxuICAgIDsgKCogW2Rvd25zdHJlYW1fZmx1c2hlZCAoKV0gcmV0dXJucyB3aGVuIGFsbCBwcmlvciB2YWx1ZXMgdGhhdCB0aGUgY29uc3VtZXIgaGFzXG4gICAgICAgICBwYXNzZWQgZG93bnN0cmVhbSBoYXZlIGJlZW4gZmx1c2hlZCBhbGwgdGhlIHdheSBkb3duIHRoZSBjaGFpbiBvZiBwaXBlcy4gKilcbiAgICAgIGRvd25zdHJlYW1fZmx1c2hlZCA6IHVuaXQgLT4gRmx1c2hlZF9yZXN1bHQudCBEZWZlcnJlZC50XG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCB0IDogdW5pdCA9XG4gICAgdHJ5XG4gICAgICBsZXQgY2hlY2sgZiBmaWVsZCA9IGYgKEZpZWxkLmdldCBmaWVsZCB0KSBpblxuICAgICAgRmllbGRzLml0ZXJcbiAgICAgICAgfnBpcGVfaWQ6aWdub3JlXG4gICAgICAgIH52YWx1ZXNfcmVhZDpcbiAgICAgICAgICAoY2hlY2sgKGZ1bmN0aW9uXG4gICAgICAgICAgICAgfCBgSGF2ZV9iZWVuX3NlbnRfZG93bnN0cmVhbSAtPiAoKVxuICAgICAgICAgICAgIHwgYEhhdmVfbm90X2JlZW5fc2VudF9kb3duc3RyZWFtIGl2YXIgLT4gYXNzZXJ0IChJdmFyLmlzX2VtcHR5IGl2YXIpKSlcbiAgICAgICAgfmRvd25zdHJlYW1fZmx1c2hlZDppZ25vcmVcbiAgICB3aXRoXG4gICAgfCBleG4gLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJQaXBlLkNvbnN1bWVyLmludmFyaWFudCBmYWlsZWRcIiAoZXhuIDogZXhuKSB+cGlwZToodCA6IHQpXVxuICA7O1xuXG4gIGxldCBjcmVhdGUgfnBpcGVfaWQgfmRvd25zdHJlYW1fZmx1c2hlZCA9XG4gICAgeyBwaXBlX2lkOyB2YWx1ZXNfcmVhZCA9IGBIYXZlX2JlZW5fc2VudF9kb3duc3RyZWFtOyBkb3duc3RyZWFtX2ZsdXNoZWQgfVxuICA7O1xuXG4gIGxldCBzdGFydCB0ID1cbiAgICBtYXRjaCB0LnZhbHVlc19yZWFkIHdpdGhcbiAgICB8IGBIYXZlX25vdF9iZWVuX3NlbnRfZG93bnN0cmVhbSBfIC0+ICgpXG4gICAgfCBgSGF2ZV9iZWVuX3NlbnRfZG93bnN0cmVhbSAtPlxuICAgICAgdC52YWx1ZXNfcmVhZCA8LSBgSGF2ZV9ub3RfYmVlbl9zZW50X2Rvd25zdHJlYW0gKEl2YXIuY3JlYXRlICgpKVxuICA7O1xuXG4gIGxldCB2YWx1ZXNfc2VudF9kb3duc3RyZWFtIHQgPVxuICAgIG1hdGNoIHQudmFsdWVzX3JlYWQgd2l0aFxuICAgIHwgYEhhdmVfYmVlbl9zZW50X2Rvd25zdHJlYW0gLT4gKClcbiAgICB8IGBIYXZlX25vdF9iZWVuX3NlbnRfZG93bnN0cmVhbSBpdmFyIC0+XG4gICAgICBJdmFyLmZpbGwgaXZhciAoKTtcbiAgICAgIHQudmFsdWVzX3JlYWQgPC0gYEhhdmVfYmVlbl9zZW50X2Rvd25zdHJlYW1cbiAgOztcblxuICBsZXQgdmFsdWVzX3NlbnRfZG93bnN0cmVhbV9hbmRfZmx1c2hlZCB0ID1cbiAgICBtYXRjaCB0LnZhbHVlc19yZWFkIHdpdGhcbiAgICB8IGBIYXZlX2JlZW5fc2VudF9kb3duc3RyZWFtIC0+IHQuZG93bnN0cmVhbV9mbHVzaGVkICgpXG4gICAgfCBgSGF2ZV9ub3RfYmVlbl9zZW50X2Rvd25zdHJlYW0gd2hlbl9zZW50X2Rvd25zdHJlYW0gLT5cbiAgICAgIGxldCViaW5kICgpID0gSXZhci5yZWFkIHdoZW5fc2VudF9kb3duc3RyZWFtIGluXG4gICAgICB0LmRvd25zdHJlYW1fZmx1c2hlZCAoKVxuICA7O1xuZW5kXG5cbm1vZHVsZSBCbG9ja2VkX3JlYWQgPSBzdHJ1Y3RcbiAgKCogQSBbQmxvY2tlZF9yZWFkLnRdIHJlcHJlc2VudHMgYSBibG9ja2VkIHJlYWQgYXR0ZW1wdC4gIElmIHNvbWVvbmUgcmVhZHMgZnJvbSBhbiBlbXB0eVxuICAgICBwaXBlLCB0aGV5IGVucXVldWUgYSBbQmxvY2tlZF9yZWFkLnRdIGluIHRoZSBxdWV1ZSBvZiBbYmxvY2tlZF9yZWFkc10uICBMYXRlciwgd2hlblxuICAgICB2YWx1ZXMgYXJlIHdyaXR0ZW4gdG8gYSBwaXBlLCB0aGF0IHdpbGwgY2F1c2Ugc29tZSBudW1iZXIgb2YgYmxvY2tlZCByZWFkcyB0byBiZVxuICAgICBmaWxsZWQsIGZpcnN0IGNvbWUgZmlyc3Qgc2VydmUuICBUaGUgYmxvY2tlZC1yZWFkIGNvbnN0cnVjdG9yIHNwZWNpZmllcyBob3cgbWFueVxuICAgICB2YWx1ZXMgYSByZWFkIHNob3VsZCBjb25zdW1lIGZyb20gdGhlIHBpcGUgd2hlbiBpdCBnZXRzIGl0cyB0dXJuLlxuXG4gICAgIElmIGEgcGlwZSBpcyBjbG9zZWQsIHRoZW4gYWxsIGJsb2NrZWQgcmVhZHMgd2lsbCBiZSBmaWxsZWQgd2l0aCBbYEVvZl0uICopXG4gIHR5cGUgJ2Egd2FudHMgPVxuICAgIHwgWmVybyBvZiBbIGBFb2YgfCBgT2sgXSBJdmFyLnRcbiAgICB8IE9uZSBvZiBbIGBFb2YgfCBgT2sgb2YgJ2EgXSBJdmFyLnRcbiAgICB8IEF0X21vc3Qgb2YgaW50ICogWyBgRW9mIHwgYE9rIG9mICdhIFF1ZXVlLnQgXSBJdmFyLnRcbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICB0eXBlICdhIHQgPVxuICAgIHsgd2FudHMgOiAnYSB3YW50c1xuICAgIDsgY29uc3VtZXIgOiBDb25zdW1lci50IG9wdGlvblxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgdCA6IHVuaXQgPVxuICAgIHRyeVxuICAgICAgbGV0IGNoZWNrIGYgZmllbGQgPSBmIChGaWVsZC5nZXQgZmllbGQgdCkgaW5cbiAgICAgIEZpZWxkcy5pdGVyXG4gICAgICAgIH53YW50czpcbiAgICAgICAgICAoY2hlY2sgKGZ1bmN0aW9uXG4gICAgICAgICAgICAgfCBaZXJvIF8gfCBPbmUgXyAtPiAoKVxuICAgICAgICAgICAgIHwgQXRfbW9zdCAoaSwgXykgLT4gYXNzZXJ0IChpID4gMCkpKVxuICAgICAgICB+Y29uc3VtZXI6XG4gICAgICAgICAgKGNoZWNrIChmdW5jdGlvblxuICAgICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgICAgIHwgU29tZSBjb25zdW1lciAtPiBDb25zdW1lci5pbnZhcmlhbnQgY29uc3VtZXIpKVxuICAgIHdpdGhcbiAgICB8IGV4biAtPlxuICAgICAgcmFpc2VfcyBbJW1lc3NhZ2UgXCJQaXBlLkJsb2NrZWRfcmVhZC5pbnZhcmlhbnQgZmFpbGVkXCIgKGV4biA6IGV4bikgfnBpcGU6KHQgOiBfIHQpXVxuICA7O1xuXG4gIGxldCBjcmVhdGUgd2FudHMgY29uc3VtZXIgPSB7IHdhbnRzOyBjb25zdW1lciB9XG5cbiAgbGV0IGlzX2VtcHR5IHQgPVxuICAgIG1hdGNoIHQud2FudHMgd2l0aFxuICAgIHwgWmVybyBpIC0+IEl2YXIuaXNfZW1wdHkgaVxuICAgIHwgT25lIGkgLT4gSXZhci5pc19lbXB0eSBpXG4gICAgfCBBdF9tb3N0IChfLCBpKSAtPiBJdmFyLmlzX2VtcHR5IGlcbiAgOztcblxuICBsZXQgZmlsbF93aXRoX2VvZiB0ID1cbiAgICBtYXRjaCB0LndhbnRzIHdpdGhcbiAgICB8IFplcm8gaSAtPiBJdmFyLmZpbGwgaSBgRW9mXG4gICAgfCBPbmUgaSAtPiBJdmFyLmZpbGwgaSBgRW9mXG4gICAgfCBBdF9tb3N0IChfLCBpKSAtPiBJdmFyLmZpbGwgaSBgRW9mXG4gIDs7XG5lbmRcblxubW9kdWxlIEJsb2NrZWRfZmx1c2ggPSBzdHJ1Y3RcbiAgKCogQSBbQmxvY2tlZF9mbHVzaC50XSByZXByZXNlbnRzIGEgYmxvY2tlZCBmbHVzaCBvcGVyYXRpb24sIHdoaWNoIGNhbiBiZSBlbmFibGVkIGJ5IGFcbiAgICAgZnV0dXJlIHJlYWQuICBJZiBzb21lb25lIGRvZXMgW2ZsdXNoZWQgcF0gb24gYSBwaXBlLCB0aGF0IGJsb2NrcyB1bnRpbCBldmVyeXRoaW5nXG4gICAgIHRoYXQncyBjdXJyZW50bHkgaW4gdGhlIHBpcGUgYXQgdGhhdCBwb2ludCBoYXMgZHJhaW5lZCBvdXQgb2YgdGhlIHBpcGUuICBXaGVuIHdlIGNhbGxcbiAgICAgW2ZsdXNoZWRdLCBpdCByZWNvcmRzIHRoZSB0b3RhbCBhbW91bnQgb2YgZGF0YSB0aGF0IGhhcyBiZWVuIHdyaXR0ZW4gc28gZmFyIGluXG4gICAgIFtmaWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkXS4gIFdlIGZpbGwgdGhlIFtGbHVzaC50XSB3aXRoIFtgT2tdIHdoZW4gdGhpcyBhbW91bnQgb2ZcbiAgICAgZGF0YSBoYXMgYmVlbiByZWFkIGZyb20gdGhlIHBpcGUuXG5cbiAgICAgQSBbQmxvY2tlZF9mbHVzaC50XSBjYW4gYWxzbyBiZSBmaWxsZWQgd2l0aCBbYFJlYWRlcl9jbG9zZWRdLCB3aGljaCBoYXBwZW5zIHdoZW4gdGhlXG4gICAgIHJlYWRlciBlbmQgb2YgdGhlIHBpcGUgaXMgY2xvc2VkLCBhbmQgd2UgYXJlIHRodXMgc3VyZSB0aGF0IHRoZSB1bnJlYWQgZWxlbWVudHNcbiAgICAgcHJlY2VkaW5nIHRoZSBmbHVzaCB3aWxsIG5ldmVyIGJlIHJlYWQuICopXG4gIHR5cGUgdCA9XG4gICAgeyBmaWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkIDogaW50XG4gICAgOyByZWFkeSA6IFsgYE9rIHwgYFJlYWRlcl9jbG9zZWQgXSBJdmFyLnRcbiAgICB9XG4gIFtAQGRlcml2aW5nIGZpZWxkcywgc2V4cF9vZl1cblxuICBsZXQgZmlsbCB0IHYgPSBJdmFyLmZpbGwgdC5yZWFkeSB2XG5lbmRcblxudHlwZSAoJ2EsICdwaGFudG9tKSB0ID1cbiAgeyAoKiBbaWRdIGlzIGFuIGludGVnZXIgdXNlZCB0byBkaXN0aW5ndWlzaCBwaXBlcyB3aGVuIGRlYnVnZ2luZy4gKilcbiAgICBpZCA6IGludCBTZXhwX2hpZGRlbl9pbl90ZXN0LnRcbiAgOyAoKiBbaW5mb10gaXMgdXNlci1wcm92aWRlZCBhcmJpdHJhcnkgc2V4cCwgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy4gKilcbiAgICBtdXRhYmxlIGluZm8gOiBTZXhwLnQgb3B0aW9uIFtAc2V4cC5vcHRpb25dXG4gIDsgKCogW2J1ZmZlcl0gaG9sZHMgdmFsdWVzIHdyaXR0ZW4gdG8gdGhlIHBpcGUgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiByZWFkLiAqKVxuICAgIG11dGFibGUgYnVmZmVyIDogJ2EgUXVldWUudFxuICA7ICgqIFtzaXplX2J1ZGdldF0gZ292ZXJucyBwdXNoYmFjayBvbiB3cml0ZXJzIHRvIHRoZSBwaXBlLlxuXG4gICAgICAgVGhlcmUgaXMgKm5vKiBpbnZhcmlhbnQgdGhhdCBbUXVldWUubGVuZ3RoIGJ1ZmZlciA8PSBzaXplX2J1ZGdldF0uICBUaGVyZSBpcyBub1xuICAgICAgIGhhcmQgdXBwZXIgYm91bmQgb24gdGhlIG51bWJlciBvZiBlbGVtZW50cyB0aGF0IGNhbiBiZSBzdHVmZmVkIGludG8gdGhlIFtidWZmZXJdLlxuICAgICAgIFRoaXMgaXMgZHVlIHRvIHRoZSB3YXkgd2UgaGFuZGxlIHdyaXRlcy4gIFdoZW4gd2UgZG8gYSB3cml0ZSwgYWxsIG9mIHRoZSB2YWx1ZXNcbiAgICAgICB3cml0dGVuIGFyZSBpbW1lZGlhdGVseSBlbnF1ZXVlZCBpbnRvIFtidWZmZXJdLiAgQWZ0ZXIgdGhlIHdyaXRlLCBpZiBbUXVldWUubGVuZ3RoXG4gICAgICAgYnVmZmVyIDw9IHQuc2l6ZV9idWRnZXRdLCB0aGVuIHRoZSB3cml0ZXIgd2lsbCBiZSBub3RpZmllZCB0byBjb250aW51ZSB3cml0aW5nLlxuICAgICAgIEFmdGVyIHRoZSB3cml0ZSwgaWYgW2xlbmd0aCB0ID4gdC5zaXplX2J1ZGdldF0sIHRoZW4gdGhlIHdyaXRlIHdpbGwgYmxvY2sgdW50aWwgdGhlXG4gICAgICAgcGlwZSBpcyB1bmRlciBidWRnZXQuICopXG4gICAgbXV0YWJsZSBzaXplX2J1ZGdldCA6IGludFxuICA7ICgqIFtwdXNoYmFja10gaXMgdXNlZCB0byBnaXZlIGZlZWRiYWNrIHRvIHdyaXRlcnMgYWJvdXQgd2hldGhlciB0aGV5IHNob3VsZCB3cml0ZSB0b1xuICAgICAgIHRoZSBwaXBlLiAgW3B1c2hiYWNrXSBpcyBmdWxsIGlmZiBbbGVuZ3RoIHQgPD0gdC5zaXplX2J1ZGdldCB8fCBpc19jbG9zZWQgdF0uICopXG4gICAgbXV0YWJsZSBwdXNoYmFjayA6IHVuaXQgSXZhci50XG4gIDsgKCogW251bV92YWx1ZXNfcmVhZF0ga2VlcHMgdHJhY2sgb2YgdGhlIHRvdGFsIG51bWJlciBvZiB2YWx1ZXMgdGhhdCBoYXZlIGJlZW4gcmVhZFxuICAgICAgIGZyb20gdGhlIHBpcGUuICBXZSBkbyBub3QgaGF2ZSB0byB3b3JyeSBhYm91dCBvdmVyZmxvdyBpbiBbbnVtX3ZhbHVlc19yZWFkXS4gIFlvdSdkXG4gICAgICAgbmVlZCB0byB3cml0ZSAyXjYyIGVsZW1lbnRzIHRvIHRoZSBwaXBlLCB3aGljaCB3b3VsZCB0YWtlIGFib3V0IDE0NiB5ZWFycywgYXQgYVxuICAgICAgIGZsb3cgcmF0ZSBvZiAxIHNpemUtdW5pdC9uYW5vc2Vjb25kLiAqKVxuICAgIG11dGFibGUgbnVtX3ZhbHVlc19yZWFkIDogaW50XG4gIDsgKCogW2Jsb2NrZWRfZmx1c2hlc10gaG9sZHMgZmx1c2hlcyB3aG9zZSBwcmVjZWRpbmcgZWxlbWVudHMgaGF2ZSBub3QgYmVlbiBjb21wbGV0ZWx5XG4gICAgICAgcmVhZC4gIEZvciBlYWNoIGJsb2NrZWQgZmx1c2gsIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGJlIHJlYWQgZnJvbSB0aGVcbiAgICAgICBwaXBlIGluIG9yZGVyIHRvIGZpbGwgdGhlIGZsdXNoIGlzICAgICAgICAgICAgICAgICAgICAgICAgOlxuXG4gICAgICAgZmlsbF93aGVuX251bV92YWx1ZXNfcmVhZCAtIG51bV92YWx1ZXNfcmVhZFxuXG4gICAgICAgS2VlcGluZyB0aGUgZGF0YSBpbiB0aGlzIGZvcm0gYWxsb3dzIHVzIHRvIGNoYW5nZSBhIHNpbmdsZSBmaWVsZChudW1fdmFsdWVzX3JlYWQpXG4gICAgICAgd2hlbiB3ZSBjb25zdW1lIHZhbHVlcyBpbnN0ZWFkIG9mIGhhdmluZyB0byBpdGVyYXRlIG92ZXIgdGhlIHdob2xlIHF1ZXVlIG9mXG4gICAgICAgZmx1c2hlcy4gKilcbiAgICBibG9ja2VkX2ZsdXNoZXMgOiBCbG9ja2VkX2ZsdXNoLnQgUXVldWUudFxuICA7ICgqIFtibG9ja2VkX3JlYWRzXSBob2xkcyByZWFkcyB0aGF0IGFyZSB3YWl0aW5nIG9uIGRhdGEgdG8gYmUgd3JpdHRlbiB0byB0aGUgcGlwZS4gKilcbiAgICBibG9ja2VkX3JlYWRzIDogJ2EgQmxvY2tlZF9yZWFkLnQgUXVldWUudFxuICA7ICgqIFtjbG9zZWRdIGlzIGZpbGxlZCB3aGVuIHdlIGNsb3NlIHRoZSB3cml0ZSBlbmQgb2YgdGhlIHBpcGUuICopXG4gICAgY2xvc2VkIDogdW5pdCBJdmFyLnRcbiAgOyAoKiBbcmVhZF9jbG9zZWRdIGlzIGZpbGxlZCB3aGVuIHdlIGNsb3NlIHRoZSByZWFkIGVuZCBvZiB0aGUgcGlwZS4gKilcbiAgICByZWFkX2Nsb3NlZCA6IHVuaXQgSXZhci50XG4gIDsgKCogW2NvbnN1bWVyc10gaXMgYSBsaXN0IG9mIGFsbCBjb25zdW1lcnMgdGhhdCBtYXkgYmUgaGFuZGxpbmcgdmFsdWVzIHJlYWQgZnJvbSB0aGVcbiAgICAgICBwaXBlLiAqKVxuICAgIG11dGFibGUgY29uc3VtZXJzIDogQ29uc3VtZXIudCBsaXN0XG4gIDsgKCogW3Vwc3RyZWFtX2ZsdXNoZWRzXSBoYXMgYSBmdW5jdGlvbiBmb3IgZWFjaCBwaXBlIGltbWVkaWF0ZWx5IHVwc3RyZWFtIG9mIHRoaXMgb25lLlxuICAgICAgIFRoYXQgZnVuY3Rpb24gd2Fsa3MgdG8gdGhlIGhlYWQocykgb2YgdGhlIHVwc3RyZWFtIHBpcGUsIGFuZCBjYWxsc1xuICAgICAgIFtkb3duc3RyZWFtX2ZsdXNoZWRdIG9uIHRoZSBoZWFkKHMpLiAgU2VlIHRoZSBkZWZpbml0aW9uIG9mIFt1cHN0cmVhbV9mbHVzaGVkXVxuICAgICAgIGJlbG93LiAqKVxuICAgIHVwc3RyZWFtX2ZsdXNoZWRzIDogKHVuaXQgLT4gRmx1c2hlZF9yZXN1bHQudCBEZWZlcnJlZC50KSBCYWcudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbnR5cGUgKCdhLCAncGhhbnRvbSkgcGlwZSA9ICgnYSwgJ3BoYW50b20pIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxubGV0IGhhc2ggdCA9IEhhc2h0YmwuaGFzaCB0LmlkXG5sZXQgZXF1YWwgKHQxIDogKF8sIF8pIHQpIHQyID0gcGh5c19lcXVhbCB0MSB0MlxubGV0IGNvbXBhcmUgdDEgdDIgPSBJbnQuY29tcGFyZSB0MS5pZCB0Mi5pZFxubGV0IGlzX2Nsb3NlZCB0ID0gSXZhci5pc19mdWxsIHQuY2xvc2VkXG5sZXQgaXNfcmVhZF9jbG9zZWQgdCA9IEl2YXIuaXNfZnVsbCB0LnJlYWRfY2xvc2VkXG5sZXQgY2xvc2VkIHQgPSBJdmFyLnJlYWQgdC5jbG9zZWRcbmxldCBwdXNoYmFjayB0ID0gSXZhci5yZWFkIHQucHVzaGJhY2tcbmxldCBsZW5ndGggdCA9IFF1ZXVlLmxlbmd0aCB0LmJ1ZmZlclxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxubGV0IGludmFyaWFudCB0IDogdW5pdCA9XG4gIHRyeVxuICAgIGxldCBjaGVjayBmIGZpZWxkID0gZiAoRmllbGQuZ2V0IGZpZWxkIHQpIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5pZDppZ25vcmVcbiAgICAgIH5pbmZvOmlnbm9yZVxuICAgICAgfmJ1ZmZlcjppZ25vcmVcbiAgICAgIH5zaXplX2J1ZGdldDooY2hlY2sgKGZ1biBzaXplX2J1ZGdldCAtPiBhc3NlcnQgKHNpemVfYnVkZ2V0ID49IDApKSlcbiAgICAgIH5wdXNoYmFjazpcbiAgICAgICAgKGNoZWNrIChmdW4gcHVzaGJhY2sgLT5cbiAgICAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAgICBCb29sLmVxdWFsXG4gICAgICAgICAgICAgICAoSXZhci5pc19mdWxsIHB1c2hiYWNrKVxuICAgICAgICAgICAgICAgKGxlbmd0aCB0IDw9IHQuc2l6ZV9idWRnZXQgfHwgaXNfY2xvc2VkIHQpKSkpXG4gICAgICB+bnVtX3ZhbHVlc19yZWFkOmlnbm9yZVxuICAgICAgfmJsb2NrZWRfZmx1c2hlczpcbiAgICAgICAgKGNoZWNrIChmdW4gYmxvY2tlZF9mbHVzaGVzIC0+XG4gICAgICAgICAgIFF1ZXVlLml0ZXIgYmxvY2tlZF9mbHVzaGVzIH5mOihmdW4gKGYgOiBCbG9ja2VkX2ZsdXNoLnQpIC0+XG4gICAgICAgICAgICAgYXNzZXJ0IChmLmZpbGxfd2hlbl9udW1fdmFsdWVzX3JlYWQgPiB0Lm51bV92YWx1ZXNfcmVhZCkpO1xuICAgICAgICAgICBhc3NlcnQgKFxuICAgICAgICAgICAgIExpc3QuaXNfc29ydGVkXG4gICAgICAgICAgICAgICB+Y29tcGFyZTpJbnQuY29tcGFyZVxuICAgICAgICAgICAgICAgKExpc3QubWFwXG4gICAgICAgICAgICAgICAgICAoUXVldWUudG9fbGlzdCBibG9ja2VkX2ZsdXNoZXMpXG4gICAgICAgICAgICAgICAgICB+ZjpCbG9ja2VkX2ZsdXNoLmZpbGxfd2hlbl9udW1fdmFsdWVzX3JlYWQpKTtcbiAgICAgICAgICAgaWYgaXNfZW1wdHkgdCB0aGVuIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgYmxvY2tlZF9mbHVzaGVzKSkpXG4gICAgICB+YmxvY2tlZF9yZWFkczpcbiAgICAgICAgKGNoZWNrIChmdW4gYmxvY2tlZF9yZWFkcyAtPlxuICAgICAgICAgICAoKiBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgbm8gb25lIGlzIHdhaXRpbmcgZm9yIGl0LiAgVGhpcyB3b3VsZCBuZWVkIHRvIGNoYW5nZSBpZlxuICAgICAgICAgICAgICB3ZSBldmVyIGltcGxlbWVudCBbcmVhZF9leGFjdGx5XSBhcyBhbiBhdG9taWMgb3BlcmF0aW9uLiAqKVxuICAgICAgICAgICBpZiBub3QgKGlzX2VtcHR5IHQpIHRoZW4gYXNzZXJ0IChRdWV1ZS5pc19lbXB0eSBibG9ja2VkX3JlYWRzKTtcbiAgICAgICAgICAgUXVldWUuaXRlciBibG9ja2VkX3JlYWRzIH5mOihmdW4gcmVhZCAtPlxuICAgICAgICAgICAgIEJsb2NrZWRfcmVhZC5pbnZhcmlhbnQgcmVhZDtcbiAgICAgICAgICAgICBhc3NlcnQgKEJsb2NrZWRfcmVhZC5pc19lbXB0eSByZWFkKSk7XG4gICAgICAgICAgICgqIFlvdSBuZXZlciBibG9jayB0cnlpbmcgdG8gcmVhZCBhIGNsb3NlZCBwaXBlLiAqKVxuICAgICAgICAgICBpZiBpc19jbG9zZWQgdCB0aGVuIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgYmxvY2tlZF9yZWFkcykpKVxuICAgICAgfmNsb3NlZDppZ25vcmVcbiAgICAgIH5yZWFkX2Nsb3NlZDppZ25vcmVcbiAgICAgIH5jb25zdW1lcnM6XG4gICAgICAgIChjaGVjayAoZnVuIGwgLT5cbiAgICAgICAgICAgTGlzdC5pdGVyIGwgfmY6KGZ1biBjb25zdW1lciAtPlxuICAgICAgICAgICAgIENvbnN1bWVyLmludmFyaWFudCBjb25zdW1lcjtcbiAgICAgICAgICAgICBhc3NlcnQgKENvbnN1bWVyLnBpcGVfaWQgY29uc3VtZXIgPSB0LmlkKSkpKVxuICAgICAgfnVwc3RyZWFtX2ZsdXNoZWRzOmlnbm9yZVxuICB3aXRoXG4gIHwgZXhuIC0+IHJhaXNlX3MgWyVtZXNzYWdlIFwiUGlwZS5pbnZhcmlhbnQgZmFpbGVkXCIgKGV4biA6IGV4bikgfnBpcGU6KHQgOiAoXywgXykgdCldXG47O1xuXG5tb2R1bGUgUmVhZGVyID0gc3RydWN0XG4gIHR5cGUgcGhhbnRvbSBbQEBkZXJpdmluZyBzZXhwX29mXVxuICB0eXBlICdhIHQgPSAoJ2EsIHBoYW50b20pIHBpcGUgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgaW52YXJpYW50ID0gaW52YXJpYW50XG5lbmRcblxubW9kdWxlIFdyaXRlciA9IHN0cnVjdFxuICB0eXBlIHBoYW50b20gW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgdHlwZSAnYSB0ID0gKCdhLCBwaGFudG9tKSBwaXBlIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGludmFyaWFudCA9IGludmFyaWFudFxuZW5kXG5cbmxldCBpZF9yZWYgPSByZWYgMFxuXG5sZXQgY3JlYXRlX2ludGVybmFsIH5zaXplX2J1ZGdldCB+aW5mbyB+aW5pdGlhbF9idWZmZXIgPVxuICBpbmNyIGlkX3JlZjtcbiAgbGV0IHQgPVxuICAgIHsgaWQgPSAhaWRfcmVmXG4gICAgOyBpbmZvXG4gICAgOyBjbG9zZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgIDsgcmVhZF9jbG9zZWQgPSBJdmFyLmNyZWF0ZSAoKVxuICAgIDtcbiAgICAgIHNpemVfYnVkZ2V0XG4gICAgOyBwdXNoYmFjayA9IEl2YXIuY3JlYXRlICgpXG4gICAgOyBidWZmZXIgPSBpbml0aWFsX2J1ZmZlclxuICAgIDsgbnVtX3ZhbHVlc19yZWFkID0gMFxuICAgIDsgYmxvY2tlZF9mbHVzaGVzID0gUXVldWUuY3JlYXRlICgpXG4gICAgOyBibG9ja2VkX3JlYWRzID0gUXVldWUuY3JlYXRlICgpXG4gICAgOyBjb25zdW1lcnMgPSBbXVxuICAgIDsgdXBzdHJlYW1fZmx1c2hlZHMgPSBCYWcuY3JlYXRlICgpXG4gICAgfVxuICBpblxuICB0XG47O1xuXG5sZXQgdmFsaWRhdGVfc2l6ZV9idWRnZXQgc2l6ZV9idWRnZXQgPVxuICBpZiBzaXplX2J1ZGdldCA8IDBcbiAgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIm5lZ2F0aXZlIHNpemVfYnVkZ2V0XCIgKHNpemVfYnVkZ2V0IDogaW50KV1cbiAgZWxzZSBzaXplX2J1ZGdldFxuOztcblxubGV0IGNyZWF0ZSA/c2l6ZV9idWRnZXQgP2luZm8gKCkgPVxuICBsZXQgc2l6ZV9idWRnZXQgPVxuICAgIG1hdGNoIHNpemVfYnVkZ2V0IHdpdGhcbiAgICB8IFNvbWUgdiAtPiB2YWxpZGF0ZV9zaXplX2J1ZGdldCB2XG4gICAgfCBOb25lIC0+IDBcbiAgaW5cbiAgbGV0IHQgPSBjcmVhdGVfaW50ZXJuYWwgfnNpemVfYnVkZ2V0IH5pbmZvIH5pbml0aWFsX2J1ZmZlcjooUXVldWUuY3JlYXRlICgpKSBpblxuICAoKiBpbml0aWFsbHksIHRoZSBwaXBlIGRvZXMgbm90IHB1c2hiYWNrICopXG4gIEl2YXIuZmlsbCB0LnB1c2hiYWNrICgpO1xuICBpZiAhY2hlY2tfaW52YXJpYW50IHRoZW4gaW52YXJpYW50IHQ7XG4gIHQsIHRcbjs7XG5cbmxldCB1cGRhdGVfcHVzaGJhY2sgdCA9XG4gIGlmIGxlbmd0aCB0IDw9IHQuc2l6ZV9idWRnZXQgfHwgaXNfY2xvc2VkIHRcbiAgdGhlbiBJdmFyLmZpbGxfaWZfZW1wdHkgdC5wdXNoYmFjayAoKVxuICBlbHNlIGlmIEl2YXIuaXNfZnVsbCB0LnB1c2hiYWNrXG4gIHRoZW4gdC5wdXNoYmFjayA8LSBJdmFyLmNyZWF0ZSAoKVxuOztcblxubGV0IGNsb3NlIHQgPVxuICBpZiAhc2hvd19kZWJ1Z19tZXNzYWdlcyB0aGVuIGVwcmludHMgXCJjbG9zZVwiIHQgWyVzZXhwX29mOiAoXywgXykgdF07XG4gIGlmICFjaGVja19pbnZhcmlhbnQgdGhlbiBpbnZhcmlhbnQgdDtcbiAgaWYgbm90IChpc19jbG9zZWQgdClcbiAgdGhlbiAoXG4gICAgSXZhci5maWxsIHQuY2xvc2VkICgpO1xuICAgIGlmIGlzX2VtcHR5IHRcbiAgICB0aGVuIChcbiAgICAgIFF1ZXVlLml0ZXIgdC5ibG9ja2VkX3JlYWRzIH5mOkJsb2NrZWRfcmVhZC5maWxsX3dpdGhfZW9mO1xuICAgICAgUXVldWUuY2xlYXIgdC5ibG9ja2VkX3JlYWRzKTtcbiAgICB1cGRhdGVfcHVzaGJhY2sgdClcbjs7XG5cbmxldCBjbG9zZV9yZWFkIHQgPVxuICBpZiAhc2hvd19kZWJ1Z19tZXNzYWdlcyB0aGVuIGVwcmludHMgXCJjbG9zZV9yZWFkXCIgdCBbJXNleHBfb2Y6IChfLCBfKSB0XTtcbiAgaWYgIWNoZWNrX2ludmFyaWFudCB0aGVuIGludmFyaWFudCB0O1xuICBpZiBub3QgKGlzX3JlYWRfY2xvc2VkIHQpXG4gIHRoZW4gKFxuICAgIEl2YXIuZmlsbCB0LnJlYWRfY2xvc2VkICgpO1xuICAgIFF1ZXVlLml0ZXIgdC5ibG9ja2VkX2ZsdXNoZXMgfmY6KGZ1biBmbHVzaCAtPiBCbG9ja2VkX2ZsdXNoLmZpbGwgZmx1c2ggYFJlYWRlcl9jbG9zZWQpO1xuICAgIFF1ZXVlLmNsZWFyIHQuYmxvY2tlZF9mbHVzaGVzO1xuICAgIFF1ZXVlLmNsZWFyIHQuYnVmZmVyO1xuICAgIHVwZGF0ZV9wdXNoYmFjayB0O1xuICAgICgqIHdlIGp1c3QgY2xlYXJlZCB0aGUgYnVmZmVyLCBzbyBtYXkgbmVlZCB0byBmaWxsIFt0LnB1c2hiYWNrXSAqKVxuICAgIGNsb3NlIHQpXG47O1xuXG5sZXQgY3JlYXRlX3JlYWRlcl9ub3RfY2xvc2Vfb25fZXhjZXB0aW9uID9zaXplX2J1ZGdldCBmID1cbiAgbGV0IHIsIHcgPSBjcmVhdGUgP3NpemVfYnVkZ2V0ICgpIGluXG4gIHVwb24gKGYgdykgKGZ1biAoKSAtPiBjbG9zZSB3KTtcbiAgclxuOztcblxubGV0IGNyZWF0ZV9yZWFkZXIgP3NpemVfYnVkZ2V0IH5jbG9zZV9vbl9leGNlcHRpb24gZiA9XG4gIGlmIG5vdCBjbG9zZV9vbl9leGNlcHRpb25cbiAgdGhlbiBjcmVhdGVfcmVhZGVyX25vdF9jbG9zZV9vbl9leGNlcHRpb24gP3NpemVfYnVkZ2V0IGZcbiAgZWxzZSAoXG4gICAgbGV0IHIsIHcgPSBjcmVhdGUgP3NpemVfYnVkZ2V0ICgpIGluXG4gICAgZG9uJ3Rfd2FpdF9mb3JcbiAgICAgIChNb25pdG9yLnByb3RlY3RcbiAgICAgICAgIH5ydW46XG4gICAgICAgICAgIGBTY2hlZHVsZVxuICAgICAgICAgfnJlc3Q6YExvZ1xuICAgICAgICAgKGZ1biAoKSAtPiBmIHcpXG4gICAgICAgICB+ZmluYWxseTooZnVuICgpIC0+XG4gICAgICAgICAgIGNsb3NlIHc7XG4gICAgICAgICAgIHJldHVybiAoKSkpO1xuICAgIHIpXG47O1xuXG5sZXQgY3JlYXRlX3dyaXRlciA/c2l6ZV9idWRnZXQgZiA9XG4gIGxldCByLCB3ID0gY3JlYXRlID9zaXplX2J1ZGdldCAoKSBpblxuICBkb24ndF93YWl0X2ZvclxuICAgIChNb25pdG9yLnByb3RlY3RcbiAgICAgICB+cnVuOlxuICAgICAgICAgYFNjaGVkdWxlXG4gICAgICAgfnJlc3Q6YExvZ1xuICAgICAgIChmdW4gKCkgLT4gZiByKVxuICAgICAgIH5maW5hbGx5OihmdW4gKCkgLT5cbiAgICAgICAgIGNsb3NlX3JlYWQgcjtcbiAgICAgICAgIHJldHVybiAoKSkpO1xuICB3XG47O1xuXG5sZXQgdmFsdWVzX3dlcmVfcmVhZCB0IGNvbnN1bWVyID1cbiAgT3B0aW9uLml0ZXIgY29uc3VtZXIgfmY6Q29uc3VtZXIuc3RhcnQ7XG4gIGxldCByZWMgbG9vcCAoKSA9XG4gICAgbWF0Y2ggUXVldWUucGVlayB0LmJsb2NrZWRfZmx1c2hlcyB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGZsdXNoIC0+XG4gICAgICBpZiB0Lm51bV92YWx1ZXNfcmVhZCA+PSBmbHVzaC5maWxsX3doZW5fbnVtX3ZhbHVlc19yZWFkXG4gICAgICB0aGVuIChcbiAgICAgICAgaWdub3JlIChRdWV1ZS5kZXF1ZXVlX2V4biB0LmJsb2NrZWRfZmx1c2hlcyA6IEJsb2NrZWRfZmx1c2gudCk7XG4gICAgICAgIChtYXRjaCBjb25zdW1lciB3aXRoXG4gICAgICAgICB8IE5vbmUgLT4gQmxvY2tlZF9mbHVzaC5maWxsIGZsdXNoIGBPa1xuICAgICAgICAgfCBTb21lIGNvbnN1bWVyIC0+XG4gICAgICAgICAgIHVwb24gKENvbnN1bWVyLnZhbHVlc19zZW50X2Rvd25zdHJlYW1fYW5kX2ZsdXNoZWQgY29uc3VtZXIpIChmdW4gZmx1c2hfcmVzdWx0IC0+XG4gICAgICAgICAgICAgQmxvY2tlZF9mbHVzaC5maWxsIGZsdXNoIGZsdXNoX3Jlc3VsdCkpO1xuICAgICAgICBsb29wICgpKVxuICBpblxuICBsb29wICgpXG47O1xuXG4oKiBbY29uc3VtZV9hbGwgdF0gcmVhZHMgYWxsIHRoZSBlbGVtZW50cyBpbiBbdF0uICopXG5sZXQgY29uc3VtZV9hbGwgdCBjb25zdW1lciA9XG4gIGxldCByZXN1bHQgPSB0LmJ1ZmZlciBpblxuICB0LmJ1ZmZlciA8LSBRdWV1ZS5jcmVhdGUgKCk7XG4gIHQubnVtX3ZhbHVlc19yZWFkIDwtIHQubnVtX3ZhbHVlc19yZWFkICsgUXVldWUubGVuZ3RoIHJlc3VsdDtcbiAgdmFsdWVzX3dlcmVfcmVhZCB0IGNvbnN1bWVyO1xuICB1cGRhdGVfcHVzaGJhY2sgdDtcbiAgcmVzdWx0XG47O1xuXG5sZXQgY29uc3VtZV9vbmUgdCBjb25zdW1lciA9XG4gIGFzc2VydCAobGVuZ3RoIHQgPj0gMSk7XG4gIGxldCByZXN1bHQgPSBRdWV1ZS5kZXF1ZXVlX2V4biB0LmJ1ZmZlciBpblxuICB0Lm51bV92YWx1ZXNfcmVhZCA8LSB0Lm51bV92YWx1ZXNfcmVhZCArIDE7XG4gIHZhbHVlc193ZXJlX3JlYWQgdCBjb25zdW1lcjtcbiAgdXBkYXRlX3B1c2hiYWNrIHQ7XG4gIHJlc3VsdFxuOztcblxubGV0IGNvbnN1bWUgdCB+bWF4X3F1ZXVlX2xlbmd0aCBjb25zdW1lciA9XG4gIGFzc2VydCAobWF4X3F1ZXVlX2xlbmd0aCA+PSAwKTtcbiAgaWYgbWF4X3F1ZXVlX2xlbmd0aCA+PSBsZW5ndGggdFxuICB0aGVuIGNvbnN1bWVfYWxsIHQgY29uc3VtZXJcbiAgZWxzZSAoXG4gICAgdC5udW1fdmFsdWVzX3JlYWQgPC0gdC5udW1fdmFsdWVzX3JlYWQgKyBtYXhfcXVldWVfbGVuZ3RoO1xuICAgIHZhbHVlc193ZXJlX3JlYWQgdCBjb25zdW1lcjtcbiAgICBsZXQgcmVzdWx0ID0gUXVldWUuY3JlYXRlIH5jYXBhY2l0eTptYXhfcXVldWVfbGVuZ3RoICgpIGluXG4gICAgUXVldWUuYmxpdF90cmFuc2ZlciB+c3JjOnQuYnVmZmVyIH5kc3Q6cmVzdWx0IH5sZW46bWF4X3F1ZXVlX2xlbmd0aCAoKTtcbiAgICB1cGRhdGVfcHVzaGJhY2sgdDtcbiAgICByZXN1bHQpXG47O1xuXG5sZXQgc2V0X3NpemVfYnVkZ2V0IHQgc2l6ZV9idWRnZXQgPVxuICBsZXQgc2l6ZV9idWRnZXQgPSB2YWxpZGF0ZV9zaXplX2J1ZGdldCBzaXplX2J1ZGdldCBpblxuICB0LnNpemVfYnVkZ2V0IDwtIHNpemVfYnVkZ2V0O1xuICB1cGRhdGVfcHVzaGJhY2sgdFxuOztcblxubGV0IGZpbGxfYmxvY2tlZF9yZWFkcyB0ID1cbiAgd2hpbGUgKG5vdCAoUXVldWUuaXNfZW1wdHkgdC5ibG9ja2VkX3JlYWRzKSkgJiYgbm90IChpc19lbXB0eSB0KSBkb1xuICAgIGxldCBibG9ja2VkX3JlYWQgPSBRdWV1ZS5kZXF1ZXVlX2V4biB0LmJsb2NrZWRfcmVhZHMgaW5cbiAgICBsZXQgY29uc3VtZXIgPSBibG9ja2VkX3JlYWQuY29uc3VtZXIgaW5cbiAgICBtYXRjaCBibG9ja2VkX3JlYWQud2FudHMgd2l0aFxuICAgIHwgWmVybyBpdmFyIC0+IEl2YXIuZmlsbCBpdmFyIGBPa1xuICAgIHwgT25lIGl2YXIgLT4gSXZhci5maWxsIGl2YXIgKGBPayAoY29uc3VtZV9vbmUgdCBjb25zdW1lcikpXG4gICAgfCBBdF9tb3N0IChtYXhfcXVldWVfbGVuZ3RoLCBpdmFyKSAtPlxuICAgICAgSXZhci5maWxsIGl2YXIgKGBPayAoY29uc3VtZSB0IH5tYXhfcXVldWVfbGVuZ3RoIGNvbnN1bWVyKSlcbiAgZG9uZVxuOztcblxuKCogY2hlY2tzIGFsbCBpbnZhcmlhbnRzLCBjYWxscyBhIHBhc3NlZCBpbiBmIHRvIGhhbmRsZSBhIHdyaXRlLCB0aGVuIHVwZGF0ZXMgcmVhZHMgYW5kXG4gICBwdXNoYmFjayAqKVxubGV0IHN0YXJ0X3dyaXRlIHQgPVxuICBpZiAhc2hvd19kZWJ1Z19tZXNzYWdlcyB0aGVuIGVwcmludHMgXCJ3cml0ZVwiIHQgWyVzZXhwX29mOiAoXywgXykgdF07XG4gIGlmICFjaGVja19pbnZhcmlhbnQgdGhlbiBpbnZhcmlhbnQgdDtcbiAgaWYgaXNfY2xvc2VkIHQgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIndyaXRlIHRvIGNsb3NlZCBwaXBlXCIgfnBpcGU6KHQgOiAoXywgXykgdCldXG47O1xuXG5sZXQgZmluaXNoX3dyaXRlIHQgPVxuICBmaWxsX2Jsb2NrZWRfcmVhZHMgdDtcbiAgdXBkYXRlX3B1c2hiYWNrIHRcbjs7XG5cbmxldCB0cmFuc2Zlcl9pbl93aXRob3V0X3B1c2hiYWNrIHQgfmZyb20gPVxuICBzdGFydF93cml0ZSB0O1xuICBRdWV1ZS5ibGl0X3RyYW5zZmVyIH5zcmM6ZnJvbSB+ZHN0OnQuYnVmZmVyICgpO1xuICBmaW5pc2hfd3JpdGUgdFxuOztcblxubGV0IHRyYW5zZmVyX2luIHQgfmZyb20gPVxuICB0cmFuc2Zlcl9pbl93aXRob3V0X3B1c2hiYWNrIHQgfmZyb207XG4gIHB1c2hiYWNrIHRcbjs7XG5cbmxldCBjb3B5X2luX3dpdGhvdXRfcHVzaGJhY2sgdCB+ZnJvbSA9XG4gIHN0YXJ0X3dyaXRlIHQ7XG4gIFF1ZXVlLml0ZXIgZnJvbSB+ZjooZnVuIHggLT4gUXVldWUuZW5xdWV1ZSB0LmJ1ZmZlciB4KTtcbiAgZmluaXNoX3dyaXRlIHRcbjs7XG5cbigqIFt3cml0ZSddIGlzIHVzZWQgaW50ZXJuYWxseSAqKVxubGV0IHdyaXRlJyB0IHEgPSB0cmFuc2Zlcl9pbiB0IH5mcm9tOnFcblxubGV0IHdyaXRlX3dpdGhvdXRfcHVzaGJhY2sgdCB2YWx1ZSA9XG4gIHN0YXJ0X3dyaXRlIHQ7XG4gIFF1ZXVlLmVucXVldWUgdC5idWZmZXIgdmFsdWU7XG4gIGZpbmlzaF93cml0ZSB0XG47O1xuXG5sZXQgd3JpdGUgdCB2YWx1ZSA9XG4gIHdyaXRlX3dpdGhvdXRfcHVzaGJhY2sgdCB2YWx1ZTtcbiAgcHVzaGJhY2sgdFxuOztcblxubGV0IHdyaXRlX3doZW5fcmVhZHkgdCB+ZiA9XG4gIGxldCVtYXAgKCkgPSBwdXNoYmFjayB0IGluXG4gIGlmIGlzX2Nsb3NlZCB0IHRoZW4gYENsb3NlZCBlbHNlIGBPayAoZiAoZnVuIHggLT4gd3JpdGVfd2l0aG91dF9wdXNoYmFjayB0IHgpKVxuOztcblxubGV0IHdyaXRlX2lmX29wZW4gdCB4ID0gaWYgbm90IChpc19jbG9zZWQgdCkgdGhlbiB3cml0ZSB0IHggZWxzZSByZXR1cm4gKClcblxubGV0IHdyaXRlX3dpdGhvdXRfcHVzaGJhY2tfaWZfb3BlbiB0IHggPVxuICBpZiBub3QgKGlzX2Nsb3NlZCB0KSB0aGVuIHdyaXRlX3dpdGhvdXRfcHVzaGJhY2sgdCB4XG47O1xuXG5sZXQgZW5zdXJlX2NvbnN1bWVyX21hdGNoZXMgP2NvbnN1bWVyIHQgPVxuICBtYXRjaCBjb25zdW1lciB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgY29uc3VtZXIgLT5cbiAgICBpZiB0LmlkIDw+IENvbnN1bWVyLnBpcGVfaWQgY29uc3VtZXJcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiQXR0ZW1wdCB0byB1c2UgY29uc3VtZXIgd2l0aCB3cm9uZyBwaXBlXCJcbiAgICAgICAgICAgIChjb25zdW1lciA6IENvbnN1bWVyLnQpXG4gICAgICAgICAgICB+cGlwZToodCA6IF8gUmVhZGVyLnQpXVxuOztcblxubGV0IHN0YXJ0X3JlYWQgP2NvbnN1bWVyIHQgbGFiZWwgPVxuICBpZiAhc2hvd19kZWJ1Z19tZXNzYWdlcyB0aGVuIGVwcmludHMgbGFiZWwgdCBbJXNleHBfb2Y6IChfLCBfKSB0XTtcbiAgaWYgIWNoZWNrX2ludmFyaWFudCB0aGVuIGludmFyaWFudCB0O1xuICBlbnN1cmVfY29uc3VtZXJfbWF0Y2hlcyB0ID9jb25zdW1lclxuOztcblxubGV0IGdlbl9yZWFkX25vdyA/Y29uc3VtZXIgdCBjb25zdW1lID1cbiAgc3RhcnRfcmVhZCB0IFwicmVhZF9ub3dcIiA/Y29uc3VtZXI7XG4gIGlmIGlzX2VtcHR5IHRcbiAgdGhlbiBpZiBpc19jbG9zZWQgdCB0aGVuIGBFb2YgZWxzZSBgTm90aGluZ19hdmFpbGFibGVcbiAgZWxzZSAoXG4gICAgYXNzZXJ0IChRdWV1ZS5pc19lbXB0eSB0LmJsb2NrZWRfcmVhZHMpO1xuICAgICgqIGZyb20gW2ludmFyaWFudF0gYW5kIFtub3QgKGlzX2VtcHR5IHQpXSAqKVxuICAgIGBPayAoY29uc3VtZSB0IGNvbnN1bWVyKSlcbjs7XG5cbmxldCBnZXRfbWF4X3F1ZXVlX2xlbmd0aCB+bWF4X3F1ZXVlX2xlbmd0aCA9XG4gIG1hdGNoIG1heF9xdWV1ZV9sZW5ndGggd2l0aFxuICB8IE5vbmUgLT4gSW50Lm1heF92YWx1ZVxuICB8IFNvbWUgbWF4X3F1ZXVlX2xlbmd0aCAtPlxuICAgIGlmIG1heF9xdWV1ZV9sZW5ndGggPD0gMFxuICAgIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJtYXhfcXVldWVfbGVuZ3RoIDw9IDBcIiAobWF4X3F1ZXVlX2xlbmd0aCA6IGludCldO1xuICAgIG1heF9xdWV1ZV9sZW5ndGhcbjs7XG5cbmxldCByZWFkX25vdycgP2NvbnN1bWVyID9tYXhfcXVldWVfbGVuZ3RoIHQgPVxuICBsZXQgbWF4X3F1ZXVlX2xlbmd0aCA9IGdldF9tYXhfcXVldWVfbGVuZ3RoIH5tYXhfcXVldWVfbGVuZ3RoIGluXG4gIGdlbl9yZWFkX25vdyB0ID9jb25zdW1lciAoZnVuIHQgY29uc3VtZXIgLT4gY29uc3VtZSB0IH5tYXhfcXVldWVfbGVuZ3RoIGNvbnN1bWVyKVxuOztcblxubGV0IHJlYWRfbm93ID9jb25zdW1lciB0ID0gZ2VuX3JlYWRfbm93IHQgP2NvbnN1bWVyIGNvbnN1bWVfb25lXG5sZXQgcGVlayB0ID0gUXVldWUucGVlayB0LmJ1ZmZlclxuXG5sZXQgY2xlYXIgdCA9XG4gIG1hdGNoIHJlYWRfbm93JyB0IHdpdGhcbiAgfCBgRW9mIHwgYE5vdGhpbmdfYXZhaWxhYmxlIHwgYE9rIF8gLT4gKClcbjs7XG5cbmxldCByZWFkJyA/Y29uc3VtZXIgP21heF9xdWV1ZV9sZW5ndGggdCA9XG4gIGxldCBtYXhfcXVldWVfbGVuZ3RoID0gZ2V0X21heF9xdWV1ZV9sZW5ndGggfm1heF9xdWV1ZV9sZW5ndGggaW5cbiAgc3RhcnRfcmVhZCB0IFwicmVhZCdcIiA/Y29uc3VtZXI7XG4gIG1hdGNoIHJlYWRfbm93JyB0ID9jb25zdW1lciB+bWF4X3F1ZXVlX2xlbmd0aCB3aXRoXG4gIHwgKGBPayBfIHwgYEVvZikgYXMgciAtPiByZXR1cm4gclxuICB8IGBOb3RoaW5nX2F2YWlsYWJsZSAtPlxuICAgIERlZmVycmVkLmNyZWF0ZSAoZnVuIGl2YXIgLT5cbiAgICAgIFF1ZXVlLmVucXVldWVcbiAgICAgICAgdC5ibG9ja2VkX3JlYWRzXG4gICAgICAgIChCbG9ja2VkX3JlYWQuY3JlYXRlIChBdF9tb3N0IChtYXhfcXVldWVfbGVuZ3RoLCBpdmFyKSkgY29uc3VtZXIpKVxuOztcblxubGV0IHJlYWQgP2NvbnN1bWVyIHQgPVxuICBzdGFydF9yZWFkIHQgXCJyZWFkXCIgP2NvbnN1bWVyO1xuICBpZiBpc19lbXB0eSB0XG4gIHRoZW5cbiAgICBpZiBpc19jbG9zZWQgdFxuICAgIHRoZW4gcmV0dXJuIGBFb2ZcbiAgICBlbHNlXG4gICAgICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBpdmFyIC0+XG4gICAgICAgIFF1ZXVlLmVucXVldWUgdC5ibG9ja2VkX3JlYWRzIChCbG9ja2VkX3JlYWQuKGNyZWF0ZSAoT25lIGl2YXIpKSBjb25zdW1lcikpXG4gIGVsc2UgKFxuICAgIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgdC5ibG9ja2VkX3JlYWRzKTtcbiAgICByZXR1cm4gKGBPayAoY29uc3VtZV9vbmUgdCBjb25zdW1lcikpKVxuOztcblxubGV0IHJlYWRfZXhuID9jb25zdW1lciB0ID1cbiAgbWF0Y2glbWFwIHJlYWQgP2NvbnN1bWVyIHQgd2l0aFxuICB8IGBPayB2YWx1ZSAtPiB2YWx1ZVxuICB8IGBFb2YgLT4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJQaXBlLnJlYWRfZXhuOiByZWNlaXZlZCBFT0ZcIl1cbjs7XG5cbmxldCB2YWx1ZXNfYXZhaWxhYmxlIHQgPVxuICBzdGFydF9yZWFkIHQgXCJ2YWx1ZXNfYXZhaWxhYmxlXCI7XG4gIGlmIG5vdCAoaXNfZW1wdHkgdClcbiAgdGhlbiByZXR1cm4gYE9rXG4gIGVsc2UgaWYgaXNfY2xvc2VkIHRcbiAgdGhlbiByZXR1cm4gYEVvZlxuICBlbHNlIChcbiAgICBtYXRjaCBRdWV1ZS5sYXN0IHQuYmxvY2tlZF9yZWFkcyB3aXRoXG4gICAgfCBTb21lIHsgY29uc3VtZXIgPSBOb25lOyB3YW50cyA9IFplcm8gaXZhciB9IC0+XG4gICAgICAoKiBUaGlzIGNhc2UgaXMgYW4gb3B0aW1pemF0aW9uIGZvciBtdWx0aXBsZSBjYWxscyB0byBbdmFsdWVzX2F2YWlsYWJsZV0gaW5cbiAgICAgICAgIHNlcXVlbmNlLiAgSXQgY2F1c2VzIHRoZW0gdG8gYWxsIHNoYXJlIHRoZSBzYW1lIGl2YXIsIHJhdGhlciB0aGFuIGFsbG9jYXRlXG4gICAgICAgICBhbiBpdmFyIHBlciBjYWxsLiAqKVxuICAgICAgSXZhci5yZWFkIGl2YXJcbiAgICB8IF8gLT5cbiAgICAgIERlZmVycmVkLmNyZWF0ZSAoZnVuIGl2YXIgLT5cbiAgICAgICAgUXVldWUuZW5xdWV1ZSB0LmJsb2NrZWRfcmVhZHMgKEJsb2NrZWRfcmVhZC4oY3JlYXRlIChaZXJvIGl2YXIpKSBOb25lKSkpXG47O1xuXG5sZXQgcmVhZF9jaG9pY2UgdCA9IGNob2ljZSAodmFsdWVzX2F2YWlsYWJsZSB0KSAoZnVuIChfIDogWyBgT2sgfCBgRW9mIF0pIC0+IHJlYWRfbm93IHQpXG5cbmxldCByZWFkX2Nob2ljZV9zaW5nbGVfY29uc3VtZXJfZXhuIHQgaGVyZSA9XG4gIERlZmVycmVkLkNob2ljZS5tYXAgKHJlYWRfY2hvaWNlIHQpIH5mOihmdW5jdGlvblxuICAgIHwgKGBPayBfIHwgYEVvZikgYXMgeCAtPiB4XG4gICAgfCBgTm90aGluZ19hdmFpbGFibGUgLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJQaXBlLnJlYWRfY2hvaWNlX3NpbmdsZV9jb25zdW1lcl9leG46IGNob2ljZSB3YXMgZW5hYmxlZCBidXQgcGlwZSBpcyBlbXB0eTsgXFxcbiAgICAgICAgICAgdGhpcyBpcyBsaWtlbHkgZHVlIHRvIGEgcmFjZSBjb25kaXRpb24gd2l0aCBvbmUgb3IgbW9yZSBvdGhlciBjb25zdW1lcnNcIlxuICAgICAgICAgICAgKGhlcmUgOiBTb3VyY2VfY29kZV9wb3NpdGlvbi50KV0pXG47O1xuXG4oKiBbcmVhZF9leGFjdGx5IHQgfm51bV92YWx1ZXNdIGxvb3BzLCBnZXR0aW5nIHlvdSBhbGwgW251bV92YWx1ZXNdIGl0ZW1zLCB1cFxuICAgdG8gRU9GLiAqKVxubGV0IHJlYWRfZXhhY3RseSA/Y29uc3VtZXIgdCB+bnVtX3ZhbHVlcyA9XG4gIHN0YXJ0X3JlYWQgdCBcInJlYWRfZXhhY3RseVwiID9jb25zdW1lcjtcbiAgaWYgbnVtX3ZhbHVlcyA8PSAwXG4gIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJQaXBlLnJlYWRfZXhhY3RseSBnb3QgbnVtX3ZhbHVlcyA8PSAwXCIgKG51bV92YWx1ZXMgOiBpbnQpXTtcbiAgRGVmZXJyZWQuY3JlYXRlIChmdW4gZmluaXNoIC0+XG4gICAgbGV0IHJlc3VsdCA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICAgIGxldCByZWMgbG9vcCAoKSA9XG4gICAgICBsZXQgYWxyZWFkeV9yZWFkID0gUXVldWUubGVuZ3RoIHJlc3VsdCBpblxuICAgICAgYXNzZXJ0IChhbHJlYWR5X3JlYWQgPD0gbnVtX3ZhbHVlcyk7XG4gICAgICBpZiBhbHJlYWR5X3JlYWQgPSBudW1fdmFsdWVzXG4gICAgICB0aGVuIEl2YXIuZmlsbCBmaW5pc2ggKGBFeGFjdGx5IHJlc3VsdClcbiAgICAgIGVsc2VcbiAgICAgICAgcmVhZCcgP2NvbnN1bWVyIHQgfm1heF9xdWV1ZV9sZW5ndGg6KG51bV92YWx1ZXMgLSBhbHJlYWR5X3JlYWQpXG4gICAgICAgID4+PiBmdW5jdGlvblxuICAgICAgICB8IGBFb2YgLT4gSXZhci5maWxsIGZpbmlzaCAoaWYgYWxyZWFkeV9yZWFkID0gMCB0aGVuIGBFb2YgZWxzZSBgRmV3ZXIgcmVzdWx0KVxuICAgICAgICB8IGBPayBxIC0+XG4gICAgICAgICAgUXVldWUuYmxpdF90cmFuc2ZlciB+c3JjOnEgfmRzdDpyZXN1bHQgKCk7XG4gICAgICAgICAgbG9vcCAoKVxuICAgIGluXG4gICAgbG9vcCAoKSlcbjs7XG5cbmxldCBkb3duc3RyZWFtX2ZsdXNoZWQgdCA9XG4gIGlmIGlzX2VtcHR5IHRcbiAgdGhlblxuICAgIGlmIExpc3QuaXNfZW1wdHkgdC5jb25zdW1lcnNcbiAgICB0aGVuIHJldHVybiBgT2tcbiAgICBlbHNlXG4gICAgICBGbHVzaGVkX3Jlc3VsdC5jb21iaW5lXG4gICAgICAgIChMaXN0Lm1hcCB0LmNvbnN1bWVycyB+ZjpDb25zdW1lci52YWx1ZXNfc2VudF9kb3duc3RyZWFtX2FuZF9mbHVzaGVkKVxuICBlbHNlXG4gICAgKCogW3RdIG1pZ2h0IGJlIGNsb3NlZC4gIEJ1dCB0aGUgcmVhZCBlbmQgY2FuJ3QgYmUgY2xvc2VkLCBiZWNhdXNlIGlmIGl0IHdlcmUsIHRoZW5cbiAgICAgICBbdF0gd291bGQgYmUgZW1wdHkuICBJZiB0aGUgd3JpdGUgZW5kIGlzIGNsb3NlZCBidXQgbm90IHRoZSByZWFkIGVuZCwgdGhlbiB3ZSB3YW50XG4gICAgICAgdG8gZW5xdWV1ZSBhIGJsb2NrZWQgZmx1c2ggYmVjYXVzZSB0aGUgZW5xdWV1ZWQgdmFsdWVzIG1heSBnZXQgcmVhZC4gKilcbiAgICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZWFkeSAtPlxuICAgICAgUXVldWUuZW5xdWV1ZVxuICAgICAgICB0LmJsb2NrZWRfZmx1c2hlc1xuICAgICAgICB7IGZpbGxfd2hlbl9udW1fdmFsdWVzX3JlYWQgPSB0Lm51bV92YWx1ZXNfcmVhZCArIGxlbmd0aCB0OyByZWFkeSB9KVxuOztcblxuKCogSW4gcHJhY3RpY2UsIGFsb25nIHdpdGggW0xpbmsuY3JlYXRlXSBhbmQgW2FkZF91cHN0cmVhbV9mbHVzaGVkXSwgW3Vwc3RyZWFtX2ZsdXNoZWRdXG4gICB0cmF2ZXJzZXMgdGhlIGdyYXBoIG9mIGxpbmtlZCBwaXBlcyB1cCB0byB0aGUgaGVhZHMgYW5kIHRoZW4gY2FsbHMgW2Rvd25zdHJlYW1fZmx1c2hlZF1cbiAgIG9uIHRoZW0uICopXG5sZXQgdXBzdHJlYW1fZmx1c2hlZCB0ID1cbiAgaWYgQmFnLmlzX2VtcHR5IHQudXBzdHJlYW1fZmx1c2hlZHNcbiAgdGhlbiBkb3duc3RyZWFtX2ZsdXNoZWQgdFxuICBlbHNlXG4gICAgQmFnLnRvX2xpc3QgdC51cHN0cmVhbV9mbHVzaGVkc1xuICAgIHw+IExpc3QubWFwIH5mOihmdW4gZiAtPiBmICgpKVxuICAgIHw+IEZsdXNoZWRfcmVzdWx0LmNvbWJpbmVcbjs7XG5cbmxldCBhZGRfdXBzdHJlYW1fZmx1c2hlZCB0IHVwc3RyZWFtX2ZsdXNoZWQgPSBCYWcuYWRkIHQudXBzdHJlYW1fZmx1c2hlZHMgdXBzdHJlYW1fZmx1c2hlZFxuXG5sZXQgYWRkX2NvbnN1bWVyIHQgfmRvd25zdHJlYW1fZmx1c2hlZCA9XG4gIGxldCBjb25zdW1lciA9IENvbnN1bWVyLmNyZWF0ZSB+cGlwZV9pZDp0LmlkIH5kb3duc3RyZWFtX2ZsdXNoZWQgaW5cbiAgdC5jb25zdW1lcnMgPC0gY29uc3VtZXIgOjogdC5jb25zdW1lcnM7XG4gIGNvbnN1bWVyXG47O1xuXG4oKiBBIFtMaW5rLnRdIGxpbmtzIGZsdXNoaW5nIG9mIHR3byBwaXBlcyB0b2dldGhlci4gKilcbm1vZHVsZSBMaW5rIDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBjcmVhdGUgOiB1cHN0cmVhbTooXywgXykgcGlwZSAtPiBkb3duc3RyZWFtOihfLCBfKSBwaXBlIC0+IHRcbiAgdmFsIGNvbnN1bWVyIDogdCAtPiBDb25zdW1lci50XG5cbiAgKCogW3VubGlua191cHN0cmVhbV0gcmVtb3ZlcyBkb3duc3RyZWFtJ3MgcmVmZXJlbmNlIHRvIHVwc3RyZWFtLiAqKVxuXG4gIHZhbCB1bmxpbmtfdXBzdHJlYW0gOiB0IC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHVucGFja2VkID1cbiAgICB7IGRvd25zdHJlYW0gOiAoJ2EsICdiKSB0XG4gICAgOyBjb25zdW1lciA6IENvbnN1bWVyLnRcbiAgICA7IHVwc3RyZWFtX2ZsdXNoZWRzX2JhZ19lbHQgOiAodW5pdCAtPiBGbHVzaGVkX3Jlc3VsdC50IERlZmVycmVkLnQpIEJhZy5FbHQudFxuICAgIH1cblxuICB0eXBlIHQgPSBUIDogKF8sIF8pIHVucGFja2VkIC0+IHRcblxuICBsZXQgY29uc3VtZXIgKFQgdCkgPSB0LmNvbnN1bWVyXG5cbiAgbGV0IGNyZWF0ZSB+dXBzdHJlYW0gfmRvd25zdHJlYW0gPVxuICAgIFRcbiAgICAgIHsgZG93bnN0cmVhbVxuICAgICAgOyBjb25zdW1lciA9XG4gICAgICAgICAgYWRkX2NvbnN1bWVyIHVwc3RyZWFtIH5kb3duc3RyZWFtX2ZsdXNoZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgICAgZG93bnN0cmVhbV9mbHVzaGVkIGRvd25zdHJlYW0pXG4gICAgICA7IHVwc3RyZWFtX2ZsdXNoZWRzX2JhZ19lbHQgPVxuICAgICAgICAgIGFkZF91cHN0cmVhbV9mbHVzaGVkIGRvd25zdHJlYW0gKGZ1biAoKSAtPiB1cHN0cmVhbV9mbHVzaGVkIHVwc3RyZWFtKVxuICAgICAgfVxuICA7O1xuXG4gIGxldCB1bmxpbmtfdXBzdHJlYW0gKFQgdCkgPVxuICAgIEJhZy5yZW1vdmUgdC5kb3duc3RyZWFtLnVwc3RyZWFtX2ZsdXNoZWRzIHQudXBzdHJlYW1fZmx1c2hlZHNfYmFnX2VsdFxuICA7O1xuZW5kXG5cbm1vZHVsZSBGbHVzaGVkID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBDb25zdW1lciBvZiBDb25zdW1lci50XG4gICAgfCBXaGVuX3ZhbHVlX3Byb2Nlc3NlZFxuICAgIHwgV2hlbl92YWx1ZV9yZWFkXG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5lbmRcblxubGV0IGZvbGRfZ2VuXG4gICAgICAocmVhZF9ub3cgOiA/Y29uc3VtZXI6Q29uc3VtZXIudCAtPiBfIFJlYWRlci50IC0+IF8pXG4gICAgICA/KGZsdXNoZWQgPSBGbHVzaGVkLldoZW5fdmFsdWVfcmVhZClcbiAgICAgIHRcbiAgICAgIH5pbml0XG4gICAgICB+ZlxuICA9XG4gIGxldCBjb25zdW1lciA9XG4gICAgbWF0Y2ggZmx1c2hlZCB3aXRoXG4gICAgfCBXaGVuX3ZhbHVlX3JlYWQgLT4gTm9uZVxuICAgIHwgQ29uc3VtZXIgY29uc3VtZXIgLT4gU29tZSBjb25zdW1lclxuICAgIHwgV2hlbl92YWx1ZV9wcm9jZXNzZWQgLT5cbiAgICAgICgqIFRoZSBmYWN0IHRoYXQgXCJubyBjb25zdW1lclwiIGJlaGF2ZXMgZGlmZmVyZW50IGZyb20gXCJ0cml2aWFsIGNvbnN1bWVyXCIgaXMgd2VpcmQsXG4gICAgICAgICBidXQgdGhhdCdzIGhvdyB0aGUgY29uc3VtZXIgbWFjaGluZXJ5IHdvcmtzLiAqKVxuICAgICAgU29tZSAoYWRkX2NvbnN1bWVyIHQgfmRvd25zdHJlYW1fZmx1c2hlZDooZnVuICgpIC0+IHJldHVybiBgT2spKVxuICBpblxuICBpZiAhY2hlY2tfaW52YXJpYW50IHRoZW4gaW52YXJpYW50IHQ7XG4gIGVuc3VyZV9jb25zdW1lcl9tYXRjaGVzIHQgP2NvbnN1bWVyO1xuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBmaW5pc2hlZCAtPlxuICAgICgqIFdlIGRvIFtyZXR1cm4gKCkgPj4+XSB0byBlbnN1cmUgdGhhdCBbZl0gaXMgb25seSBjYWxsZWQgYXN5bmNocm9ub3VzbHkuICopXG4gICAgcmV0dXJuICgpXG4gICAgPj4+IGZ1biAoKSAtPlxuICAgIGxldCByZWMgbG9vcCBiID1cbiAgICAgIG1hdGNoIHJlYWRfbm93IHQgP2NvbnN1bWVyIHdpdGhcbiAgICAgIHwgYEVvZiAtPiBJdmFyLmZpbGwgZmluaXNoZWQgYlxuICAgICAgfCBgT2sgdiAtPiBmIGIgdiBjb250aW51ZVxuICAgICAgfCBgTm90aGluZ19hdmFpbGFibGUgLT4gdmFsdWVzX2F2YWlsYWJsZSB0ID4+PiBmdW4gXyAtPiBsb29wIGJcbiAgICBhbmQgY29udGludWUgYiA9XG4gICAgICBPcHRpb24uaXRlciBjb25zdW1lciB+ZjpDb25zdW1lci52YWx1ZXNfc2VudF9kb3duc3RyZWFtO1xuICAgICAgbG9vcCBiXG4gICAgaW5cbiAgICBsb29wIGluaXQpXG47O1xuXG5sZXQgZm9sZCcgP2ZsdXNoZWQgP21heF9xdWV1ZV9sZW5ndGggdCB+aW5pdCB+ZiA9XG4gIGZvbGRfZ2VuIChyZWFkX25vdycgP21heF9xdWV1ZV9sZW5ndGgpID9mbHVzaGVkIHQgfmluaXQgfmY6KGZ1biBiIHEgbG9vcCAtPlxuICAgIGYgYiBxID4+PiBsb29wKVxuOztcblxubGV0IGZvbGQgP2ZsdXNoZWQgdCB+aW5pdCB+ZiA9XG4gIGZvbGRfZ2VuIHJlYWRfbm93ID9mbHVzaGVkIHQgfmluaXQgfmY6KGZ1biBiIGEgbG9vcCAtPiBmIGIgYSA+Pj4gbG9vcClcbjs7XG5cbmxldCBmb2xkX3dpdGhvdXRfcHVzaGJhY2sgP2NvbnN1bWVyIHQgfmluaXQgfmYgPVxuICBmb2xkX2dlblxuICAgIHJlYWRfbm93XG4gICAgdFxuICAgIH5pbml0XG4gICAgfmY6KGZ1biBiIGEgbG9vcCAtPiBsb29wIChmIGIgYSkpXG4gICAgP2ZsdXNoZWQ6XG4gICAgICAobWF0Y2ggY29uc3VtZXIgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgfCBTb21lIGMgLT4gU29tZSAoQ29uc3VtZXIgYykpXG47O1xuXG5sZXQgd2l0aF9lcnJvcl90b19jdXJyZW50X21vbml0b3IgPyhjb250aW51ZV9vbl9lcnJvciA9IGZhbHNlKSBmIGEgPVxuICBpZiBub3QgY29udGludWVfb25fZXJyb3JcbiAgdGhlbiBmIGFcbiAgZWxzZSAoXG4gICAgbWF0Y2glbWFwXG4gICAgICBNb25pdG9yLnRyeV93aXRoXG4gICAgICAgIH5ydW46XG4gICAgICAgICAgYFNjaGVkdWxlXG4gICAgICAgIH5yZXN0OmBMb2dcbiAgICAgICAgKGZ1biAoKSAtPiBmIGEpXG4gICAgd2l0aFxuICAgIHwgT2sgKCkgLT4gKClcbiAgICB8IEVycm9yIGV4biAtPiBNb25pdG9yLnNlbmRfZXhuIChNb25pdG9yLmN1cnJlbnQgKCkpIChNb25pdG9yLmV4dHJhY3RfZXhuIGV4bikpXG47O1xuXG5sZXQgaXRlcicgP2NvbnRpbnVlX29uX2Vycm9yID9mbHVzaGVkID9tYXhfcXVldWVfbGVuZ3RoIHQgfmYgPVxuICBmb2xkJyA/bWF4X3F1ZXVlX2xlbmd0aCA/Zmx1c2hlZCB0IH5pbml0OigpIH5mOihmdW4gKCkgcSAtPlxuICAgIHdpdGhfZXJyb3JfdG9fY3VycmVudF9tb25pdG9yID9jb250aW51ZV9vbl9lcnJvciBmIHEpXG47O1xuXG5sZXQgaXRlciA/Y29udGludWVfb25fZXJyb3IgP2ZsdXNoZWQgdCB+ZiA9XG4gIGZvbGRfZ2VuIHJlYWRfbm93ID9mbHVzaGVkIHQgfmluaXQ6KCkgfmY6KGZ1biAoKSBhIGxvb3AgLT5cbiAgICB3aXRoX2Vycm9yX3RvX2N1cnJlbnRfbW9uaXRvciA/Y29udGludWVfb25fZXJyb3IgZiBhID4+PiBmdW4gKCkgLT4gbG9vcCAoKSlcbjs7XG5cbigqIFtpdGVyX3dpdGhvdXRfcHVzaGJhY2tdIGlzIGEgY29tbW9uIGNhc2UsIHNvIHdlIGltcGxlbWVudCBpdCBpbiBhbiBvcHRpbWl6ZWQgbWFubmVyLFxuICAgcmF0aGVyIHRoYW4gdmlhIFtpdGVyXS4gIFRoZSBpbXBsZW1lbnRhdGlvbiByZWFkcyBvbmx5IG9uZSBlbGVtZW50IGF0IGEgdGltZSwgc28gdGhhdFxuICAgaWYgW2ZdIGNsb3NlcyBbdF0gb3IgcmFpc2VzLCBubyBtb3JlIGVsZW1lbnRzIHdpbGwgYmUgcmVhZC4gKilcbmxldCBpdGVyX3dpdGhvdXRfcHVzaGJhY2tcbiAgICAgID9jb25zdW1lclxuICAgICAgPyhjb250aW51ZV9vbl9lcnJvciA9IGZhbHNlKVxuICAgICAgP21heF9pdGVyYXRpb25zX3Blcl9qb2JcbiAgICAgIHRcbiAgICAgIH5mXG4gID1cbiAgZW5zdXJlX2NvbnN1bWVyX21hdGNoZXMgdCA/Y29uc3VtZXI7XG4gIGxldCBtYXhfaXRlcmF0aW9uc19wZXJfam9iID1cbiAgICBtYXRjaCBtYXhfaXRlcmF0aW9uc19wZXJfam9iIHdpdGhcbiAgICB8IE5vbmUgLT4gSW50Lm1heF92YWx1ZVxuICAgIHwgU29tZSBtYXhfaXRlcmF0aW9uc19wZXJfam9iIC0+XG4gICAgICBpZiBtYXhfaXRlcmF0aW9uc19wZXJfam9iIDw9IDBcbiAgICAgIHRoZW5cbiAgICAgICAgcmFpc2Vfc1xuICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgXCJpdGVyX3dpdGhvdXRfcHVzaGJhY2sgZ290IG5vbi1wb3NpdGl2ZSBtYXhfaXRlcmF0aW9uc19wZXJfam9iXCJcbiAgICAgICAgICAgICAgKG1heF9pdGVyYXRpb25zX3Blcl9qb2IgOiBpbnQpXTtcbiAgICAgIG1heF9pdGVyYXRpb25zX3Blcl9qb2JcbiAgaW5cbiAgbGV0IGYgPVxuICAgIGlmIG5vdCBjb250aW51ZV9vbl9lcnJvclxuICAgIHRoZW4gZlxuICAgIGVsc2VcbiAgICAgIGZ1biBhIC0+XG4gICAgICAgIHRyeSBmIGEgd2l0aFxuICAgICAgICB8IGV4biAtPiBNb25pdG9yLnNlbmRfZXhuIChNb25pdG9yLmN1cnJlbnQgKCkpIGV4blxuICBpblxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biBmaW5pc2hlZCAtPlxuICAgICgqIFdlIGRvIFtyZXR1cm4gKCkgPj4+XSB0byBlbnN1cmUgdGhhdCBbZl0gaXMgb25seSBjYWxsZWQgYXN5bmNocm9ub3VzbHkuICopXG4gICAgcmV0dXJuICgpXG4gICAgPj4+IGZ1biAoKSAtPlxuICAgIGxldCByZWMgc3RhcnQgKCkgPSBsb29wIH5yZW1haW5pbmc6bWF4X2l0ZXJhdGlvbnNfcGVyX2pvYlxuICAgIGFuZCBsb29wIH5yZW1haW5pbmcgPVxuICAgICAgaWYgcmVtYWluaW5nID0gMFxuICAgICAgdGhlbiByZXR1cm4gKCkgPj4+IGZ1biAoKSAtPiBzdGFydCAoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHJlYWRfbm93IHQgP2NvbnN1bWVyIHdpdGhcbiAgICAgICAgfCBgRW9mIC0+IEl2YXIuZmlsbCBmaW5pc2hlZCAoKVxuICAgICAgICB8IGBPayBhIC0+XG4gICAgICAgICAgZiBhO1xuICAgICAgICAgIGxvb3AgfnJlbWFpbmluZzoocmVtYWluaW5nIC0gMSlcbiAgICAgICAgfCBgTm90aGluZ19hdmFpbGFibGUgLT4gdmFsdWVzX2F2YWlsYWJsZSB0ID4+PiBmdW4gXyAtPiBzdGFydCAoKSlcbiAgICBpblxuICAgIHN0YXJ0ICgpKVxuOztcblxubGV0IGRyYWluIHQgPSBpdGVyJyB0IH5mOihmdW4gXyAtPiByZXR1cm4gKCkpXG5sZXQgZHJhaW5fYW5kX2NvdW50IHQgPSBmb2xkJyB0IH5pbml0OjAgfmY6KGZ1biBzdW0gcSAtPiByZXR1cm4gKHN1bSArIFF1ZXVlLmxlbmd0aCBxKSlcblxubGV0IHJlYWRfYWxsIGlucHV0ID1cbiAgbGV0IHJlc3VsdCA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICBsZXQlbWFwICgpID1cbiAgICBpdGVyJyBpbnB1dCB+ZjooZnVuIHEgLT5cbiAgICAgIFF1ZXVlLmJsaXRfdHJhbnNmZXIgfnNyYzpxIH5kc3Q6cmVzdWx0ICgpO1xuICAgICAgcmV0dXJuICgpKVxuICBpblxuICByZXN1bHRcbjs7XG5cbmxldCB0b19saXN0IHIgPSByZWFkX2FsbCByID4+fCBRdWV1ZS50b19saXN0XG5cbmxldCB0b19zdHJlYW1fZGVwcmVjYXRlZCB0ID1cbiAgU3RyZWFtLmNyZWF0ZSAoZnVuIHRhaWwgLT5cbiAgICBpdGVyX3dpdGhvdXRfcHVzaGJhY2sgdCB+ZjooZnVuIHggLT4gVGFpbC5leHRlbmQgdGFpbCB4KVxuICAgID4+PiBmdW4gKCkgLT4gVGFpbC5jbG9zZV9leG4gdGFpbClcbjs7XG5cbigqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBbb2Zfc3RyZWFtX2RlcHJlY2F0ZWRdIGRvZXMgYXMgbXVjaCBiYXRjaGluZyBhcyBwb3NzaWJsZS4gIEl0XG4gICBncmFicyBhcyBtYW55IGl0ZW1zIGFzIGFyZSBhdmFpbGFibGUgaW50byBhbiBpbnRlcm5hbCBxdWV1ZS4gIE9uY2UgaXQgaGFzIGdyYWJiZWRcbiAgIGV2ZXJ5dGhpbmcsIGl0IHdyaXRlcyBpdCB0byB0aGUgcGlwZSBhbmQgdGhlbiBibG9ja3Mgd2FpdGluZyBmb3IgdGhlIG5leHQgZWxlbWVudCBmcm9tXG4gICB0aGUgc3RyZWFtLlxuXG4gICBUaGVyZSdzIG5vIHBvc3NpYmlsaXR5IHRoYXQgd2UnbGwgc3RhcnZlIHRoZSBwaXBlIHJlYWRpbmcgYW4gZW5kbGVzcyBzdHJlYW0sIGp1c3RcbiAgIGFjY3VtdWxhdGluZyB0aGUgZWxlbWVudHMgaW50byBvdXIgcHJpdmF0ZSBxdWV1ZSBmb3JldmVyIHdpdGhvdXQgZXZlciB3cml0aW5nIHRoZW1cbiAgIGRvd25zdHJlYW0gdG8gdGhlIHBpcGUuICBXaHk/IGJlY2F1c2Ugd2hpbGUgd2UncmUgcnVubmluZywgdGhlIHN0cmVhbS1wcm9kdWNlciAqaXNuJ3QqXG4gICBydW5uaW5nIC0tIHRoZXJlIGFyZSBubyBBc3luYyBibG9jayBwb2ludHMgaW4gdGhlIHF1ZXVlLWFjY3VtdWxhdG9yIGxvb3AuICBTbyB0aGVcbiAgIHF1ZXVlLWFjY3VtdWxhdG9yIGxvb3Agd2lsbCBldmVudHVhbGx5IGNhdGNoIHVwIHRvIHRoZSBjdXJyZW50IHN0cmVhbSB0YWlsLCBhdCB3aGljaFxuICAgcG9pbnQgd2UnbGwgZG8gdGhlIHBpcGUtd3JpdGUgYW5kIHRoZW4gYmxvY2sgb24gdGhlIHN0cmVhbS4uLiB0aHVzIGdpdmluZyB0aGVcbiAgIHN0cmVhbS1wcm9kdWNlciBhIGNoYW5jZSB0byBtYWtlIG1vcmUgZWxlbWVudHMuXG5cbiAgIE9uZSBjYW4ndCBpbXBsZW1lbnQgW29mX3N0cmVhbV0gdXNpbmcgW1N0cmVhbS5pdGVyXSBvciBbU3RyZWFtLml0ZXInXSBiZWNhdXNlIHlvdVxuICAgbmVlZCB0byBiZSBhYmxlIHRvIHN0b3AgZWFybHkgd2hlbiB0aGUgY29uc3VtZXIgY2xvc2VzIHRoZSBwaXBlLiAgQWxzbywgdXNpbmcgZWl0aGVyXG4gICBvZiB0aG9zZSB3b3VsZCBlbnRhaWwgc2lnbmlmaWNhbnRseSBtb3JlIGRlZmVycmVkIG92ZXJoZWFkLCB3aGVyZWFzIHRoZSBiZWxvd1xuICAgaW1wbGVtZW50YXRpb24gdXNlcyBhIGRlZmVycmVkIG9ubHkgd2hlbiBpdCBuZWVkcyB0byB3YWl0IGZvciBkYXRhIGZyb20gdGhlIHN0cmVhbS4gKilcbmxldCBvZl9zdHJlYW1fZGVwcmVjYXRlZCBzID1cbiAgbGV0IHIsIHcgPSBjcmVhdGUgKCkgaW5cbiAgbGV0IHEgPSBRdWV1ZS5jcmVhdGUgKCkgaW5cbiAgbGV0IHRyYW5zZmVyICgpID1cbiAgICBpZiBub3QgKFF1ZXVlLmlzX2VtcHR5IHEpXG4gICAgdGhlblxuICAgICAgKCogQ2FuIG5vdCBwdXNoYmFjayBvbiB0aGUgc3RyZWFtLCBzbyBpZ25vcmUgdGhlIHB1c2hiYWNrIG9uIHRoZSBwaXBlLiAqKVxuICAgICAgZG9uJ3Rfd2FpdF9mb3IgKHdyaXRlJyB3IHEpXG4gIGluXG4gIGxldCByZWMgbG9vcCBzID1cbiAgICBhc3NlcnQgKG5vdCAoaXNfY2xvc2VkIHcpKTtcbiAgICBsZXQgbmV4dF9kZWZlcnJlZCA9IFN0cmVhbS5uZXh0IHMgaW5cbiAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIG5leHRfZGVmZXJyZWQgd2l0aFxuICAgIHwgU29tZSBuZXh0IC0+IGxvb3BfbmV4dCBuZXh0XG4gICAgfCBOb25lIC0+XG4gICAgICB0cmFuc2ZlciAoKTtcbiAgICAgIHVwb24gbmV4dF9kZWZlcnJlZCBjaGVja19jbG9zZWRfbG9vcF9uZXh0XG4gIGFuZCBjaGVja19jbG9zZWRfbG9vcF9uZXh0IG5leHQgPSBpZiBub3QgKGlzX2Nsb3NlZCB3KSB0aGVuIGxvb3BfbmV4dCBuZXh0XG4gIGFuZCBsb29wX25leHQgPSBmdW5jdGlvblxuICAgIHwgTmlsIC0+XG4gICAgICB0cmFuc2ZlciAoKTtcbiAgICAgIGNsb3NlIHdcbiAgICB8IENvbnMgKHgsIHMpIC0+XG4gICAgICBRdWV1ZS5lbnF1ZXVlIHEgeDtcbiAgICAgIGxvb3Agc1xuICBpblxuICBsb29wIHM7XG4gIHJcbjs7XG5cbmxldCB0cmFuc2Zlcl9nZW5cbiAgICAgIChyZWFkX25vdyA6ID9jb25zdW1lcjpDb25zdW1lci50IC0+IF8gUmVhZGVyLnQgLT4gXylcbiAgICAgIHdyaXRlXG4gICAgICBpbnB1dFxuICAgICAgb3V0cHV0XG4gICAgICB+ZlxuICA9XG4gIGlmICFjaGVja19pbnZhcmlhbnRcbiAgdGhlbiAoXG4gICAgaW52YXJpYW50IGlucHV0O1xuICAgIGludmFyaWFudCBvdXRwdXQpO1xuICBsZXQgbGluayA9IExpbmsuY3JlYXRlIH51cHN0cmVhbTppbnB1dCB+ZG93bnN0cmVhbTpvdXRwdXQgaW5cbiAgbGV0IGNvbnN1bWVyID0gTGluay5jb25zdW1lciBsaW5rIGluXG4gICgqIFdoZW4gd2UncmUgZG9uZSB3aXRoIFtpbnB1dF0sIHdlIHVubGluayB0byByZW1vdmUgcG9pbnRlcnMgZnJvbVxuICAgICBbb3V0cHV0XSB0byBbaW5wdXRdLCB3aGljaCB3b3VsZCBjYXVzZSBhIHNwYWNlIGxlYWsgaWYgd2UgaGFkIHNpbmdsZSBsb25nLWxpdmVkXG4gICAgIG91dHB1dCBpbnRvIHdoaWNoIHdlIHRyYW5zZmVyIGxvdHMgb2Ygc2hvcnQtbGl2ZWQgaW5wdXRzLiAqKVxuICBsZXQgdW5saW5rICgpID0gTGluay51bmxpbmtfdXBzdHJlYW0gbGluayBpblxuICBEZWZlcnJlZC5jcmVhdGUgKGZ1biByZXN1bHQgLT5cbiAgICAoKiBXZSBkbyBbcmV0dXJuICgpID4+Pl0gdG8gZW5zdXJlIHRoYXQgW2ZdIGlzIG9ubHkgY2FsbGVkIGFzeW5jaHJvbm91c2x5LiAqKVxuICAgIHJldHVybiAoKVxuICAgID4+PiBmdW4gKCkgLT5cbiAgICBsZXQgb3V0cHV0X2Nsb3NlZCAoKSA9XG4gICAgICBjbG9zZV9yZWFkIGlucHV0O1xuICAgICAgdW5saW5rICgpO1xuICAgICAgSXZhci5maWxsIHJlc3VsdCAoKVxuICAgIGluXG4gICAgbGV0IHJlYyBsb29wICgpID1cbiAgICAgIGlmIGlzX2Nsb3NlZCBvdXRwdXRcbiAgICAgIHRoZW4gb3V0cHV0X2Nsb3NlZCAoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHJlYWRfbm93IGlucHV0IH5jb25zdW1lciB3aXRoXG4gICAgICAgIHwgYEVvZiAtPlxuICAgICAgICAgIHVubGluayAoKTtcbiAgICAgICAgICBJdmFyLmZpbGwgcmVzdWx0ICgpXG4gICAgICAgIHwgYE9rIHggLT4gZiB4IGNvbnRpbnVlXG4gICAgICAgIHwgYE5vdGhpbmdfYXZhaWxhYmxlIC0+XG4gICAgICAgICAgY2hvb3NlXG4gICAgICAgICAgICBbIGNob2ljZSAodmFsdWVzX2F2YWlsYWJsZSBpbnB1dCkgaWdub3JlOyBjaG9pY2UgKGNsb3NlZCBvdXRwdXQpIGlnbm9yZSBdXG4gICAgICAgICAgPj4+IGZ1biAoKSAtPiBsb29wICgpKVxuICAgIGFuZCBjb250aW51ZSB5ID1cbiAgICAgIGlmIGlzX2Nsb3NlZCBvdXRwdXRcbiAgICAgIHRoZW4gb3V0cHV0X2Nsb3NlZCAoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBwdXNoYmFjayA9IHdyaXRlIG91dHB1dCB5IGluXG4gICAgICAgIENvbnN1bWVyLnZhbHVlc19zZW50X2Rvd25zdHJlYW0gY29uc3VtZXI7XG4gICAgICAgIHB1c2hiYWNrID4+PiBmdW4gKCkgLT4gbG9vcCAoKSlcbiAgICBpblxuICAgIGxvb3AgKCkpXG47O1xuXG5sZXQgdHJhbnNmZXInID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IG91dHB1dCB+ZiA9XG4gIHRyYW5zZmVyX2dlbiAocmVhZF9ub3cnID9tYXhfcXVldWVfbGVuZ3RoKSB3cml0ZScgaW5wdXQgb3V0cHV0IH5mOihmdW4gcSBrIC0+IGYgcSA+Pj4gaylcbjs7XG5cbmxldCB0cmFuc2ZlciBpbnB1dCBvdXRwdXQgfmYgPVxuICB0cmFuc2Zlcl9nZW4gcmVhZF9ub3cgd3JpdGUgaW5wdXQgb3V0cHV0IH5mOihmdW4gYSBrIC0+IGsgKGYgYSkpXG47O1xuXG5sZXQgdHJhbnNmZXJfaWQgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgb3V0cHV0ID1cbiAgdHJhbnNmZXJfZ2VuIChyZWFkX25vdycgP21heF9xdWV1ZV9sZW5ndGgpIHdyaXRlJyBpbnB1dCBvdXRwdXQgfmY6KGZ1biBxIGsgLT4gayBxKVxuOztcblxubGV0IG1hcF9nZW4gcmVhZCB3cml0ZSBpbnB1dCB+ZiA9XG4gIGxldCBpbmZvID0gT3B0aW9uLm1hcCBpbnB1dC5pbmZvIH5mOihmdW4gaW5mbyAtPiBbJXNleHAgTWFwcGVkIChpbmZvIDogU2V4cC50KV0pIGluXG4gIGxldCByZXN1bHQsIG91dHB1dCA9IGNyZWF0ZSA/aW5mbyAoKSBpblxuICB1cG9uICh0cmFuc2Zlcl9nZW4gcmVhZCB3cml0ZSBpbnB1dCBvdXRwdXQgfmYpIChmdW4gKCkgLT4gY2xvc2Ugb3V0cHV0KTtcbiAgcmVzdWx0XG47O1xuXG5sZXQgbWFwJyA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCB+ZiA9XG4gIG1hcF9nZW4gKHJlYWRfbm93JyA/bWF4X3F1ZXVlX2xlbmd0aCkgd3JpdGUnIGlucHV0IH5mOihmdW4gcSBrIC0+IGYgcSA+Pj4gaylcbjs7XG5cbmxldCBtYXAgaW5wdXQgfmYgPSBtYXBfZ2VuIHJlYWRfbm93IHdyaXRlIGlucHV0IH5mOihmdW4gYSBrIC0+IGsgKGYgYSkpXG5cbmxldCBjb25jYXRfbWFwX2xpc3QgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmYgPVxuICBtYXBfZ2VuIChyZWFkX25vdycgP21heF9xdWV1ZV9sZW5ndGgpIHdyaXRlJyBpbnB1dCB+ZjooZnVuIHEgayAtPlxuICAgIGsgKFF1ZXVlLmNvbmNhdF9tYXAgcSB+ZikpXG47O1xuXG5sZXQgZmlsdGVyX21hcCcgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmYgPVxuICBtYXAnID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5mOihmdW4gcSAtPiBEZWZlcnJlZC5RdWV1ZS5maWx0ZXJfbWFwIHEgfmYpXG47O1xuXG5sZXQgZmlsdGVyX21hcCA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCB+ZiA9XG4gIG1hcF9nZW4gKHJlYWRfbm93JyA/bWF4X3F1ZXVlX2xlbmd0aCkgd3JpdGUnIGlucHV0IH5mOihmdW4gcSBrIC0+XG4gICAgayAoUXVldWUuZmlsdGVyX21hcCBxIH5mOihmdW4geCAtPiBpZiBpc19yZWFkX2Nsb3NlZCBpbnB1dCB0aGVuIE5vbmUgZWxzZSBmIHgpKSlcbjs7XG5cbmxldCBmb2xkaW5nX2ZpbHRlcl9tYXAnID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5pbml0IH5mID1cbiAgbGV0IGFjY3VtID0gcmVmIGluaXQgaW5cbiAgZmlsdGVyX21hcCcgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmY6KGZ1biB4IC0+XG4gICAgbGV0JW1hcCBhLCB4ID0gZiAhYWNjdW0geCBpblxuICAgIGFjY3VtIDo9IGE7XG4gICAgeClcbjs7XG5cbmxldCBmb2xkaW5nX2ZpbHRlcl9tYXAgP21heF9xdWV1ZV9sZW5ndGggaW5wdXQgfmluaXQgfmYgPVxuICBsZXQgYWNjdW0gPSByZWYgaW5pdCBpblxuICBmaWx0ZXJfbWFwID9tYXhfcXVldWVfbGVuZ3RoIGlucHV0IH5mOihmdW4geCAtPlxuICAgIGxldCBhLCB4ID0gZiAhYWNjdW0geCBpblxuICAgIGFjY3VtIDo9IGE7XG4gICAgeClcbjs7XG5cbmxldCBmb2xkaW5nX21hcCA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCB+aW5pdCB+ZiA9XG4gIGZvbGRpbmdfZmlsdGVyX21hcCA/bWF4X3F1ZXVlX2xlbmd0aCBpbnB1dCB+aW5pdCB+ZjooZnVuIGFjY3VtIGEgLT5cbiAgICBsZXQgYWNjdW0sIGIgPSBmIGFjY3VtIGEgaW5cbiAgICBhY2N1bSwgU29tZSBiKVxuOztcblxubGV0IGZpbHRlciBpbnB1dCB+ZiA9IGZpbHRlcl9tYXAgaW5wdXQgfmY6KGZ1biB4IC0+IGlmIGYgeCB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpXG5cbmxldCBvZl9saXN0IGwgPVxuICBsZXQgdCA9IGNyZWF0ZV9pbnRlcm5hbCB+c2l6ZV9idWRnZXQ6MCB+aW5mbzpOb25lIH5pbml0aWFsX2J1ZmZlcjooUXVldWUub2ZfbGlzdCBsKSBpblxuICBJdmFyLmZpbGwgdC5jbG9zZWQgKCk7XG4gIHVwZGF0ZV9wdXNoYmFjayB0O1xuICB0XG47O1xuXG5sZXQgZW1wdHkgKCkgPSBvZl9saXN0IFtdXG5cbmxldCBzaW5nbGV0b24geCA9XG4gIGxldCByZWFkZXIsIHdyaXRlciA9IGNyZWF0ZSAoKSBpblxuICB3cml0ZV93aXRob3V0X3B1c2hiYWNrIHdyaXRlciB4O1xuICBjbG9zZSB3cml0ZXI7XG4gIHJlYWRlclxuOztcblxubGV0IHVuZm9sZCB+aW5pdDpzIH5mID1cbiAgKCogVG8gZ2V0IHNvbWUgYmF0Y2hpbmcsIHdlIHJ1biB0aGUgY29udGludWF0aW9uIGltbWVkaWF0ZWx5IGlmIHRoZSBkZWZlcnJlZCBpc1xuICAgICBkZXRlcm1pbmVkLiAgSG93ZXZlciwgd2UgYWx3YXlzIGNoZWNrIGZvciBwdXNoYmFjay4gIEJlY2F1c2Ugc2l6ZSBidWRnZXQgY2FuJ3QgYmVcbiAgICAgaW5maW5pdGUsIHRoZSBiZWxvdyBsb29wIGlzIGd1YXJhbnRlZWQgdG8gZXZlbnR1YWxseSB5aWVsZCB0byB0aGUgc2NoZWR1bGVyLiAqKVxuICBsZXQgKCA+Pj1+ICkgZCBmID1cbiAgICBtYXRjaCBEZWZlcnJlZC5wZWVrIGQgd2l0aFxuICAgIHwgTm9uZSAtPiBkID4+PSBmXG4gICAgfCBTb21lIHggLT4gZiB4XG4gIGluXG4gIGNyZWF0ZV9yZWFkZXIgfmNsb3NlX29uX2V4Y2VwdGlvbjpmYWxzZSAoZnVuIHdyaXRlciAtPlxuICAgIGxldCByZWMgbG9vcCBzID1cbiAgICAgIGYgc1xuICAgICAgPj49fiBmdW5jdGlvblxuICAgICAgfCBOb25lIC0+IHJldHVybiAoKVxuICAgICAgfCBTb21lIChhLCBzKSAtPlxuICAgICAgICBpZiBpc19jbG9zZWQgd3JpdGVyIHRoZW4gcmV0dXJuICgpIGVsc2Ugd3JpdGUgd3JpdGVyIGEgPj49fiBmdW4gKCkgLT4gbG9vcCBzXG4gICAgaW5cbiAgICBsb29wIHMpXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2Ugc2VxdWVuY2UgPVxuICBjcmVhdGVfcmVhZGVyIH5jbG9zZV9vbl9leGNlcHRpb246ZmFsc2UgKGZ1biB3cml0ZXIgLT5cbiAgICBsZXQgcmVjIGVucXVldWVfbiBzZXF1ZW5jZSBpID1cbiAgICAgIGlmIGkgPD0gMFxuICAgICAgdGhlbiBzZXF1ZW5jZVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIFNlcXVlbmNlLm5leHQgc2VxdWVuY2Ugd2l0aFxuICAgICAgICB8IE5vbmUgLT4gc2VxdWVuY2VcbiAgICAgICAgfCBTb21lIChhLCBzZXF1ZW5jZSkgLT5cbiAgICAgICAgICBRdWV1ZS5lbnF1ZXVlIHdyaXRlci5idWZmZXIgYTtcbiAgICAgICAgICBlbnF1ZXVlX24gc2VxdWVuY2UgKGkgLSAxKSlcbiAgICBpblxuICAgIGxldCByZWMgbG9vcCBzZXF1ZW5jZSA9XG4gICAgICBpZiBpc19jbG9zZWQgd3JpdGVyIHx8IFNlcXVlbmNlLmlzX2VtcHR5IHNlcXVlbmNlXG4gICAgICB0aGVuIHJldHVybiAoKVxuICAgICAgZWxzZSAoXG4gICAgICAgIHN0YXJ0X3dyaXRlIHdyaXRlcjtcbiAgICAgICAgbGV0IHNlcXVlbmNlID0gZW5xdWV1ZV9uIHNlcXVlbmNlICgxICsgd3JpdGVyLnNpemVfYnVkZ2V0IC0gbGVuZ3RoIHdyaXRlcikgaW5cbiAgICAgICAgZmluaXNoX3dyaXRlIHdyaXRlcjtcbiAgICAgICAgbGV0JWJpbmQgKCkgPSBwdXNoYmFjayB3cml0ZXIgaW5cbiAgICAgICAgbG9vcCBzZXF1ZW5jZSlcbiAgICBpblxuICAgIGxvb3Agc2VxdWVuY2UpXG47O1xuXG50eXBlICdhIHRvX3NlcXVlbmNlX2VsdCA9XG4gIHwgVmFsdWUgb2YgJ2FcbiAgfCBXYWl0X2ZvciA6IF8gRGVmZXJyZWQudCAtPiBfIHRvX3NlcXVlbmNlX2VsdFxuXG5sZXQgdG9fc2VxdWVuY2UgdCA9XG4gIFNlcXVlbmNlLnVuZm9sZCB+aW5pdDooKSB+ZjooZnVuICgpIC0+XG4gICAgbWF0Y2ggcmVhZF9ub3cgdCB3aXRoXG4gICAgfCBgRW9mIC0+IE5vbmVcbiAgICB8IGBPayBhIC0+IFNvbWUgKFZhbHVlIGEsICgpKVxuICAgIHwgYE5vdGhpbmdfYXZhaWxhYmxlIC0+IFNvbWUgKFdhaXRfZm9yICh2YWx1ZXNfYXZhaWxhYmxlIHQpLCAoKSkpXG47O1xuXG5sZXQgaW50ZXJsZWF2ZV9waXBlIGlucHV0cyA9XG4gIGxldCBvdXRwdXQsIG91dHB1dF93cml0ZXIgPSBjcmVhdGUgfmluZm86WyVzZXhwIFwiUGlwZS5pbnRlcmxlYXZlXCJdICgpIGluXG4gICgqIFdlIGtlZXAgYSByZWZlcmVuY2UgY291bnQgb2YgYWxsIHRoZSBwaXBlcyB0aGF0IFtpbnRlcmxlYXZlX3BpcGVdIGlzIG1hbmFnaW5nO1xuICAgICBbaW5wdXRzXSBjb3VudHMgYXMgb25lLiAgV2hlbiB0aGUgcmVmZXJlbmNlIGNvdW50IGRyb3BzIHRvIHplcm8sIHdlIGtub3cgdGhhdCBhbGxcbiAgICAgcGlwZXMgYXJlIGNsb3NlZCBhbmQgd2UgY2FuIGNsb3NlIFtvdXRwdXRfd3JpdGVyXS4gKilcbiAgbGV0IG51bV9waXBlc19yZW1haW5pbmcgPSByZWYgMSBpblxuICBsZXQgZGVjcl9udW1fcGlwZXNfcmVtYWluaW5nICgpID1cbiAgICBkZWNyIG51bV9waXBlc19yZW1haW5pbmc7XG4gICAgaWYgIW51bV9waXBlc19yZW1haW5pbmcgPSAwIHRoZW4gY2xvc2Ugb3V0cHV0X3dyaXRlclxuICBpblxuICBkb24ndF93YWl0X2ZvclxuICAgIChsZXQlbWFwICgpID1cbiAgICAgICBpdGVyX3dpdGhvdXRfcHVzaGJhY2sgaW5wdXRzIH5mOihmdW4gaW5wdXQgLT5cbiAgICAgICAgIGluY3IgbnVtX3BpcGVzX3JlbWFpbmluZztcbiAgICAgICAgIGRvbid0X3dhaXRfZm9yXG4gICAgICAgICAgIChsZXQlbWFwICgpID0gdHJhbnNmZXJfaWQgaW5wdXQgb3V0cHV0X3dyaXRlciBpblxuICAgICAgICAgICAgZGVjcl9udW1fcGlwZXNfcmVtYWluaW5nICgpKSlcbiAgICAgaW5cbiAgICAgZGVjcl9udW1fcGlwZXNfcmVtYWluaW5nICgpKTtcbiAgKCogZm9yIFtpbnB1dHNdICopXG4gIG91dHB1dFxuOztcblxubGV0IGludGVybGVhdmUgaW5wdXRzID1cbiAgaWYgIWNoZWNrX2ludmFyaWFudCB0aGVuIExpc3QuaXRlciBpbnB1dHMgfmY6aW52YXJpYW50O1xuICBpbnRlcmxlYXZlX3BpcGUgKG9mX2xpc3QgaW5wdXRzKVxuOztcblxubGV0IG1lcmdlIGlucHV0cyB+Y29tcGFyZSA9XG4gIG1hdGNoIGlucHV0cyB3aXRoXG4gIHwgW10gLT4gZW1wdHkgKClcbiAgfCBbIGlucHV0IF0gLT4gaW5wdXRcbiAgfCBpbnB1dHMgLT5cbiAgICBsZXQgbW9kdWxlIEhlYXAgPSBQYWlyaW5nX2hlYXAgaW5cbiAgICBsZXQgciwgdyA9IGNyZWF0ZSAoKSBpblxuICAgIHVwb24gKGNsb3NlZCB3KSAoZnVuICgpIC0+IExpc3QuaXRlciBpbnB1dHMgfmY6Y2xvc2VfcmVhZCk7XG4gICAgbGV0IGhlYXAgPSBIZWFwLmNyZWF0ZSB+Y21wOihmdW4gKGExLCBfKSAoYTIsIF8pIC0+IGNvbXBhcmUgYTEgYTIpICgpIGluXG4gICAgbGV0IGhhbmRsZV9yZWFkIGlucHV0IGVvZl9vcl9vayA9XG4gICAgICBtYXRjaCBlb2Zfb3Jfb2sgd2l0aFxuICAgICAgfCBgRW9mIC0+ICgpXG4gICAgICB8IGBPayB2IC0+IEhlYXAuYWRkIGhlYXAgKHYsIGlucHV0KVxuICAgIGluXG4gICAgbGV0IHJlYyBwb3BfaGVhcF9hbmRfbG9vcCAoKSA9XG4gICAgICAoKiBBdCB0aGlzIHBvaW50LCBhbGwgaW5wdXRzIG5vdCBhdCBFb2Ygb2NjdXIgaW4gW2hlYXBdIGV4YWN0bHkgb25jZSwgc28gd2Uga25vd1xuICAgICAgICAgd2hhdCB0aGUgbmV4dCBvdXRwdXQgZWxlbWVudCBpcy4gIFtwb3BfaGVhcF9hbmRfbG9vcF0gcmVwZWF0ZWRseSB0YWtlcyBlbGVtZW50c1xuICAgICAgICAgZnJvbSB0aGUgaW5wdXRzIGFzIGxvbmcgYXMgaXQgaGFzIG9uZSBmcm9tIGVhY2ggaW5wdXQuICBUaGlzIGlzIGRvbmVcbiAgICAgICAgIHN5bmNocm9ub3VzbHkgdG8gYXZvaWQgdGhlIGNvc3Qgb2YgYSBkZWZlcnJlZCBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSBvdXRwdXQgLS1cbiAgICAgICAgIHRoZXJlJ3Mgbm8gbmVlZCB0byBwdXNoYmFjayBzaW5jZSB0aGF0IGlzIG9ubHkgbW92aW5nIGVsZW1lbnRzIGZyb20gb25lIHBpcGUgdG9cbiAgICAgICAgIGFub3RoZXIuICBBcyBzb29uIGFzIFtwb3BfaGVhcF9hbmRfbG9vcF0gY2FuJ3QgZ2V0IGFuIGVsZW1lbnQgZnJvbSBzb21lIGlucHV0LCBpdFxuICAgICAgICAgd2FpdHMgb24gcHVzaGJhY2sgZnJvbSB0aGUgb3V0cHV0LCBzaW5jZSBpdCBoYXMgdG8gd2FpdCBvbiB0aGUgaW5wdXQgYW55d2F5LlxuICAgICAgICAgVGhpcyBhbHNvIHByZXZlbnRzIFttZXJnZV0gZnJvbSBjb25zdW1pbmcgaW5wdXRzIGF0IGEgcmF0ZSBmYXN0ZXIgdGhhbiBpdHMgb3V0cHV0XG4gICAgICAgICBpcyBjb25zdW1lZC4gKilcbiAgICAgIG1hdGNoIEhlYXAucG9wIGhlYXAgd2l0aFxuICAgICAgfCBOb25lIC0+IGNsb3NlIHdcbiAgICAgIHwgU29tZSAodiwgaW5wdXQpIC0+XG4gICAgICAgIGlmIG5vdCAoaXNfY2xvc2VkIHcpXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHdyaXRlX3dpdGhvdXRfcHVzaGJhY2sgdyB2O1xuICAgICAgICAgIGlmIEhlYXAubGVuZ3RoIGhlYXAgPSAwXG4gICAgICAgICAgdGhlbiB1cG9uICh0cmFuc2Zlcl9pZCBpbnB1dCB3KSAoZnVuICgpIC0+IGNsb3NlIHcpXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBtYXRjaCByZWFkX25vdyBpbnB1dCB3aXRoXG4gICAgICAgICAgICB8IChgRW9mIHwgYE9rIF8pIGFzIHggLT5cbiAgICAgICAgICAgICAgaGFuZGxlX3JlYWQgaW5wdXQgeDtcbiAgICAgICAgICAgICAgcG9wX2hlYXBfYW5kX2xvb3AgKClcbiAgICAgICAgICAgIHwgYE5vdGhpbmdfYXZhaWxhYmxlIC0+XG4gICAgICAgICAgICAgIHB1c2hiYWNrIHdcbiAgICAgICAgICAgICAgPj4+IGZ1biAoKSAtPlxuICAgICAgICAgICAgICByZWFkIGlucHV0XG4gICAgICAgICAgICAgID4+PiBmdW4geCAtPlxuICAgICAgICAgICAgICBoYW5kbGVfcmVhZCBpbnB1dCB4O1xuICAgICAgICAgICAgICBwb3BfaGVhcF9hbmRfbG9vcCAoKSkpXG4gICAgaW5cbiAgICBsZXQgaW5pdGlhbF9wdXNoID1cbiAgICAgIERlZmVycmVkLkxpc3QuaXRlciBpbnB1dHMgfmY6KGZ1biBpbnB1dCAtPlxuICAgICAgICBsZXQlbWFwIHggPSByZWFkIGlucHV0IGluXG4gICAgICAgIGhhbmRsZV9yZWFkIGlucHV0IHgpXG4gICAgaW5cbiAgICB1cG9uIGluaXRpYWxfcHVzaCBwb3BfaGVhcF9hbmRfbG9vcDtcbiAgICByXG47O1xuXG5sZXQgY29uY2F0X3BpcGUgaW5wdXRzID1cbiAgbGV0IHIgPVxuICAgIGNyZWF0ZV9yZWFkZXJfbm90X2Nsb3NlX29uX2V4Y2VwdGlvbiAoZnVuIHcgLT5cbiAgICAgIGxldCBsaW5rID0gTGluay5jcmVhdGUgfnVwc3RyZWFtOmlucHV0cyB+ZG93bnN0cmVhbTp3IGluXG4gICAgICBsZXQgY29uc3VtZXIgPSBMaW5rLmNvbnN1bWVyIGxpbmsgaW5cbiAgICAgIGl0ZXIgfmZsdXNoZWQ6KENvbnN1bWVyIGNvbnN1bWVyKSBpbnB1dHMgfmY6KGZ1biBpbnB1dCAtPiB0cmFuc2Zlcl9pZCBpbnB1dCB3KSlcbiAgaW5cbiAgdXBvbiAoY2xvc2VkIHIpIChmdW4gKCkgLT4gY2xvc2UgaW5wdXRzKTtcbiAgclxuOztcblxubGV0IGNvbmNhdCBpbnB1dHMgPVxuICBjcmVhdGVfcmVhZGVyX25vdF9jbG9zZV9vbl9leGNlcHRpb24gKGZ1biB3IC0+XG4gICAgRGVmZXJyZWQuTGlzdC5pdGVyIGlucHV0cyB+ZjooZnVuIGlucHV0IC0+IHRyYW5zZmVyX2lkIGlucHV0IHcpKVxuOztcblxubGV0IGZvcmsgdCB+cHVzaGJhY2tfdXNlcyA9XG4gIGxldCByZWFkZXIwLCB3cml0ZXIwID0gY3JlYXRlICgpIGluXG4gIGxldCByZWFkZXIxLCB3cml0ZXIxID0gY3JlYXRlICgpIGluXG4gIGxldCBzb21lX3JlYWRlcl93YXNfY2xvc2VkID0gcmVmIGZhbHNlIGluXG4gIGxldCBjb25zdW1lciA9XG4gICAgYWRkX2NvbnN1bWVyIHQgfmRvd25zdHJlYW1fZmx1c2hlZDooZnVuICgpIC0+XG4gICAgICBsZXQgc29tZV9yZWFkZXJfd2FzX2Nsb3NlZCA9ICFzb21lX3JlYWRlcl93YXNfY2xvc2VkIGluXG4gICAgICBtYXRjaCVtYXBcbiAgICAgICAgRmx1c2hlZF9yZXN1bHQuY29tYmluZVxuICAgICAgICAgIFsgZG93bnN0cmVhbV9mbHVzaGVkIHdyaXRlcjA7IGRvd25zdHJlYW1fZmx1c2hlZCB3cml0ZXIxIF1cbiAgICAgIHdpdGhcbiAgICAgIHwgYFJlYWRlcl9jbG9zZWQgLT4gYFJlYWRlcl9jbG9zZWRcbiAgICAgIHwgYE9rIC0+XG4gICAgICAgICgqIEluIHRoaXMgY2FzZSwgdGhlcmUgY291bGQgaGF2ZSBiZWVuIG5vIHBlbmRpbmcgaXRlbXMgaW4gW3dyaXRlcjBdIG5vciBpblxuICAgICAgICAgICBbd3JpdGVyMV0sIGluIHdoaWNoIGNhc2Ugd2UgY291bGQgaGF2ZSBoYWQgYSBjbG9zZWQgcGlwZSB0aGF0IG1pc3NlZCBzb21lXG4gICAgICAgICAgIHdyaXRlcywgYnV0IFtGbHVzaGVkX3Jlc3VsdC5jb21iaW5lXSB3b3VsZCBzdGlsbCBoYXZlIHJldHVybmVkIFtgT2tdICopXG4gICAgICAgIGlmIHNvbWVfcmVhZGVyX3dhc19jbG9zZWQgdGhlbiBgUmVhZGVyX2Nsb3NlZCBlbHNlIGBPaylcbiAgaW5cbiAgZG9uJ3Rfd2FpdF9mb3JcbiAgICAobGV0IHN0aWxsX29wZW4gPSBbIHdyaXRlcjA7IHdyaXRlcjEgXSBpblxuICAgICBsZXQgZmlsdGVyX29wZW4gc3RpbGxfb3BlbiA9XG4gICAgICAgKCogT25seSBjYWxsIFtmaWx0ZXJdIGFuZCByZWFsbG9jYXRlIGxpc3QgaWYgc29tZXRoaW5nIHdpbGwgZ2V0IGZpbHRlcmVkICopXG4gICAgICAgaWYgbm90IChMaXN0LmV4aXN0cyBzdGlsbF9vcGVuIH5mOmlzX2Nsb3NlZClcbiAgICAgICB0aGVuIHN0aWxsX29wZW5cbiAgICAgICBlbHNlIChcbiAgICAgICAgIHNvbWVfcmVhZGVyX3dhc19jbG9zZWQgOj0gdHJ1ZTtcbiAgICAgICAgIGxldCBzdGlsbF9vcGVuID0gTGlzdC5maWx0ZXIgc3RpbGxfb3BlbiB+ZjooZnVuIHcgLT4gbm90IChpc19jbG9zZWQgdykpIGluXG4gICAgICAgICBpZiBMaXN0LmlzX2VtcHR5IHN0aWxsX29wZW4gdGhlbiBjbG9zZSB0O1xuICAgICAgICAgc3RpbGxfb3BlbilcbiAgICAgaW5cbiAgICAgbGV0JWJpbmQgc3RpbGxfb3BlbiA9XG4gICAgICAgZm9sZCcgdCB+Zmx1c2hlZDooQ29uc3VtZXIgY29uc3VtZXIpIH5pbml0OnN0aWxsX29wZW4gfmY6KGZ1biBzdGlsbF9vcGVuIHF1ZXVlIC0+XG4gICAgICAgICBsZXQgc3RpbGxfb3BlbiA9IGZpbHRlcl9vcGVuIHN0aWxsX29wZW4gaW5cbiAgICAgICAgIGlmIExpc3QuaXNfZW1wdHkgc3RpbGxfb3BlblxuICAgICAgICAgdGhlbiByZXR1cm4gW11cbiAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICBsZXQlbWFwICgpID1cbiAgICAgICAgICAgICBtYXRjaCBwdXNoYmFja191c2VzIHdpdGhcbiAgICAgICAgICAgICB8IGBGYXN0X2NvbnN1bWVyX29ubHkgLT4gRGVmZXJyZWQuYW55IChMaXN0Lm1hcCBzdGlsbF9vcGVuIH5mOnB1c2hiYWNrKVxuICAgICAgICAgICAgIHwgYEJvdGhfY29uc3VtZXJzIC0+IERlZmVycmVkLmFsbF91bml0IChMaXN0Lm1hcCBzdGlsbF9vcGVuIH5mOnB1c2hiYWNrKVxuICAgICAgICAgICBpblxuICAgICAgICAgICBsZXQgc3RpbGxfb3BlbiA9IGZpbHRlcl9vcGVuIHN0aWxsX29wZW4gaW5cbiAgICAgICAgICAgTGlzdC5pdGVyIHN0aWxsX29wZW4gfmY6KGZ1biB3IC0+IGNvcHlfaW5fd2l0aG91dF9wdXNoYmFjayB3IH5mcm9tOnF1ZXVlKTtcbiAgICAgICAgICAgc3RpbGxfb3BlbikpXG4gICAgIGluXG4gICAgIExpc3QuaXRlciBzdGlsbF9vcGVuIH5mOmNsb3NlO1xuICAgICByZXR1cm4gKCkpO1xuICByZWFkZXIwLCByZWFkZXIxXG47O1xuXG5sZXQgc2V0X2luZm8gdCBpbmZvID0gc2V0X2luZm8gdCAoU29tZSBpbmZvKVxuIiwib3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5vcGVuISBEZWZlcnJlZF9zdGRcblxudHlwZSAoJ2EsICdwaGFudG9tKSB0ID1cbiAgeyBjdXJyZW50X3ZhbHVlIDogJ2EgTW9wdGlvbi50XG4gIDsgdGFrZW4gOiAodW5pdCwgcmVhZF93cml0ZSkgQnZhci50XG4gIDsgbXV0YWJsZSB2YWx1ZV9hdmFpbGFibGUgOiB1bml0IEl2YXIudFxuICB9XG5bQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5cbmxldCB2YWx1ZV9hdmFpbGFibGUgdCA9IEl2YXIucmVhZCB0LnZhbHVlX2F2YWlsYWJsZVxubGV0IGlzX2VtcHR5IHQgPSBNb3B0aW9uLmlzX25vbmUgdC5jdXJyZW50X3ZhbHVlXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgXyAodCA6IF8gdCkgPVxuICBJbnZhcmlhbnQuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IChfLCBfKSB0XSAoZnVuICgpIC0+XG4gICAgbGV0IGNoZWNrIGYgPSBJbnZhcmlhbnQuY2hlY2tfZmllbGQgdCBmIGluXG4gICAgRmllbGRzLml0ZXJcbiAgICAgIH5jdXJyZW50X3ZhbHVlOihjaGVjayAoTW9wdGlvbi5pbnZhcmlhbnQgaW52YXJpYW50X2EpKVxuICAgICAgfnRha2VuOihjaGVjayAoQnZhci5pbnZhcmlhbnQgVW5pdC5pbnZhcmlhbnQgaWdub3JlKSlcbiAgICAgIH52YWx1ZV9hdmFpbGFibGU6XG4gICAgICAgIChjaGVjayAoZnVuIHZhbHVlX2F2YWlsYWJsZSAtPlxuICAgICAgICAgICBbJXRlc3RfcmVzdWx0OiBib29sXVxuICAgICAgICAgICAgIChJdmFyLmlzX2Z1bGwgdmFsdWVfYXZhaWxhYmxlKVxuICAgICAgICAgICAgIH5leHBlY3Q6KE1vcHRpb24uaXNfc29tZSB0LmN1cnJlbnRfdmFsdWUpKSkpXG47O1xuXG5sZXQgcGVlayB0ID0gTW9wdGlvbi5nZXQgdC5jdXJyZW50X3ZhbHVlXG5cbmxldCBwZWVrX2V4biB0ID1cbiAgaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiTXZhci5wZWVrX2V4biBjYWxsZWQgb24gZW1wdHkgbXZhclwiXTtcbiAgTW9wdGlvbi5nZXRfc29tZV9leG4gdC5jdXJyZW50X3ZhbHVlXG47O1xuXG5sZXQgc2V4cF9vZl90IHNleHBfb2ZfYSBfIHQgPSBbJXNleHAgKHBlZWsgdCA6IGEgb3B0aW9uKV1cblxubW9kdWxlIFJlYWRfd3JpdGUgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICgnYSwgcmVhZF93cml0ZSkgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9IGludmFyaWFudCBpbnZhcmlhbnRfYSBpZ25vcmUgdFxuZW5kXG5cbm1vZHVsZSBSZWFkX29ubHkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ2EgdCA9ICgnYSwgcmVhZCkgdCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9IGludmFyaWFudCBpbnZhcmlhbnRfYSBpZ25vcmUgdFxuZW5kXG5cbmxldCByZWFkX29ubHkgKHQgOiAoJ2EsIFs+IHJlYWQgXSkgdCkgPSAodCA6PiAoJ2EsIHJlYWQpIHQpXG5sZXQgd3JpdGVfb25seSAodCA6ICgnYSwgWz4gd3JpdGUgXSkgdCkgPSAodCA6PiAoJ2EsIHdyaXRlKSB0KVxuXG5sZXQgY3JlYXRlICgpID1cbiAgeyBjdXJyZW50X3ZhbHVlID0gTW9wdGlvbi5jcmVhdGUgKClcbiAgOyB0YWtlbiA9IEJ2YXIuY3JlYXRlICgpXG4gIDsgdmFsdWVfYXZhaWxhYmxlID0gSXZhci5jcmVhdGUgKClcbiAgfVxuOztcblxubGV0IHRha2Vfbm9uZW1wdHkgdCA9XG4gIGFzc2VydCAobm90IChpc19lbXB0eSB0KSk7XG4gIGxldCByID0gTW9wdGlvbi5nZXRfc29tZV9leG4gdC5jdXJyZW50X3ZhbHVlIGluXG4gIE1vcHRpb24uc2V0X25vbmUgdC5jdXJyZW50X3ZhbHVlO1xuICBCdmFyLmJyb2FkY2FzdCB0LnRha2VuICgpO1xuICB0LnZhbHVlX2F2YWlsYWJsZSA8LSBJdmFyLmNyZWF0ZSAoKTtcbiAgclxuOztcblxubGV0IHRha2Vfbm93X2V4biB0ID1cbiAgaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiTXZhci50YWtlX2V4biBjYWxsZWQgb24gZW1wdHkgbXZhclwiXTtcbiAgdGFrZV9ub25lbXB0eSB0XG47O1xuXG5sZXQgdGFrZV9ub3cgdCA9IGlmIG5vdCAoaXNfZW1wdHkgdCkgdGhlbiBTb21lICh0YWtlX25vbmVtcHR5IHQpIGVsc2UgTm9uZVxuXG5sZXQgcmVjIHRha2UgdCA9XG4gIGlmIG5vdCAoaXNfZW1wdHkgdClcbiAgdGhlbiByZXR1cm4gKHRha2Vfbm9uZW1wdHkgdClcbiAgZWxzZSAoXG4gICAgbGV0JWJpbmQgKCkgPSB2YWx1ZV9hdmFpbGFibGUgdCBpblxuICAgIHRha2UgdClcbjs7XG5cbmxldCBzZXQgdCB2ID1cbiAgTW9wdGlvbi5zZXRfc29tZSB0LmN1cnJlbnRfdmFsdWUgdjtcbiAgSXZhci5maWxsX2lmX2VtcHR5IHQudmFsdWVfYXZhaWxhYmxlICgpXG47O1xuXG5sZXQgdXBkYXRlIHQgfmYgPSBzZXQgdCAoZiAocGVlayB0KSlcbmxldCB1cGRhdGVfZXhuIHQgfmYgPSBzZXQgdCAoZiAocGVla19leG4gdCkpXG5sZXQgdGFrZW4gdCA9IEJ2YXIud2FpdCB0LnRha2VuXG5cbmxldCByZWMgcHV0IHQgdiA9XG4gIGlmIGlzX2VtcHR5IHRcbiAgdGhlbiAoXG4gICAgc2V0IHQgdjtcbiAgICByZXR1cm4gKCkpXG4gIGVsc2UgKFxuICAgIGxldCViaW5kICgpID0gdGFrZW4gdCBpblxuICAgIHB1dCB0IHYpXG47O1xuXG5sZXQgcGlwZV93aGVuX3JlYWR5IHQgPVxuICBsZXQgciwgdyA9IFBpcGUuY3JlYXRlICgpIGluXG4gIGxldCByZWMgbG9vcCAoKSA9XG4gICAgbGV0JWJpbmQgKCkgPSB2YWx1ZV9hdmFpbGFibGUgdCBpblxuICAgIGlmIG5vdCAoUGlwZS5pc19jbG9zZWQgdylcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIHRha2Vfbm93IHQgd2l0aFxuICAgICAgfCBOb25lIC0+IGxvb3AgKClcbiAgICAgIHwgU29tZSB4IC0+XG4gICAgICAgIGxldCViaW5kICgpID0gUGlwZS53cml0ZSB3IHggaW5cbiAgICAgICAgbG9vcCAoKSlcbiAgICBlbHNlIHJldHVybiAoKVxuICBpblxuICBkb24ndF93YWl0X2ZvciAobG9vcCAoKSk7XG4gIHJcbjs7XG4iLCJvcGVuIENvcmVcbm9wZW4gRGVmZXJyZWRfc3RkXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgeyBzdGFydCA6IHVuaXQgSXZhci50XG4gICAgOyByZXN1bHQgOiAnYSBPcl9lcnJvci50IERlZmVycmVkLnRcbiAgICB9XG5cbiAgbGV0IGNyZWF0ZSBmID1cbiAgICBsZXQgc3RhcnQgPSBJdmFyLmNyZWF0ZSAoKSBpblxuICAgIHsgc3RhcnRcbiAgICA7IHJlc3VsdCA9XG4gICAgICAgIChsZXQlYmluZCAoKSA9IEl2YXIucmVhZCBzdGFydCBpblxuICAgICAgICAgTW9uaXRvci50cnlfd2l0aF9vcl9lcnJvclxuICAgICAgICAgICB+cmVzdDpgTG9nXG4gICAgICAgICAgIGYpXG4gICAgfVxuICA7O1xuXG4gIGxldCBjcmVhdGVfb3JfZXJyb3IgZiA9XG4gICAgbGV0IHN0YXJ0ID0gSXZhci5jcmVhdGUgKCkgaW5cbiAgICB7IHN0YXJ0XG4gICAgOyByZXN1bHQgPVxuICAgICAgICAobGV0JWJpbmQgKCkgPSBJdmFyLnJlYWQgc3RhcnQgaW5cbiAgICAgICAgIE1vbml0b3IudHJ5X3dpdGhfam9pbl9vcl9lcnJvclxuICAgICAgICAgICB+cmVzdDpgTG9nXG4gICAgICAgICAgIGYpXG4gICAgfVxuICA7O1xuXG4gIGxldCB3YWl0IHQgPSB0LnJlc3VsdFxuICBsZXQgd2FpdF9leG4gdCA9IHdhaXQgdCA+Pnwgb2tfZXhuXG4gIGxldCBzdGFydCB0ID0gSXZhci5maWxsX2lmX2VtcHR5IHQuc3RhcnQgKClcblxuICBsZXQgZm9yY2UgdCA9XG4gICAgc3RhcnQgdDtcbiAgICB3YWl0IHRcbiAgOztcblxuICBsZXQgZm9yY2VfZXhuIHQgPSBmb3JjZSB0ID4+fCBva19leG5cbiAgbGV0IHJldHVybiBhID0gY3JlYXRlIChmdW4gKCkgLT4gcmV0dXJuIGEpXG5cbiAgbGV0IGJpbmQgdCB+ZiA9XG4gICAgY3JlYXRlIChmdW4gKCkgLT5cbiAgICAgIGxldCViaW5kIGEgPSBmb3JjZV9leG4gdCBpblxuICAgICAgZm9yY2VfZXhuIChmIGEpKVxuICA7O1xuXG4gIGxldCBtYXAgdCB+ZiA9IGNyZWF0ZSAoZnVuICgpIC0+IGZvcmNlX2V4biB0ID4+fCBmKVxuICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgTW9uYWQuTWFrZSAoVClcblxubGV0IGJpbmQnIHQgZiA9IGJpbmQgdCB+ZjooZnVuIGEgLT4gY3JlYXRlIChmdW4gKCkgLT4gZiBhKSlcbmxldCBpc19mb3JjZWQgdCA9IEl2YXIuaXNfZnVsbCB0LnN0YXJ0XG5sZXQgaXNfZGV0ZXJtaW5lZCB0ID0gRGVmZXJyZWQuaXNfZGV0ZXJtaW5lZCB0LnJlc3VsdFxubGV0IHBlZWsgdCA9IERlZmVycmVkLnBlZWsgdC5yZXN1bHRcbmxldCBwZWVrX2V4biB0ID0gT3B0aW9uLm1hcCAocGVlayB0KSB+Zjpva19leG5cbiIsIm9wZW4gQ29yZVxuXG50eXBlICdhIHQgPSB7IHdhaXRzIDogJ2EgSXZhci50IFF1ZXVlLnQgfSBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG5sZXQgY3JlYXRlICgpID0geyB3YWl0cyA9IFF1ZXVlLmNyZWF0ZSAoKSB9XG5sZXQgd2FpdCB0ID0gRGVmZXJyZWQuY3JlYXRlIChmdW4gaXZhciAtPiBRdWV1ZS5lbnF1ZXVlIHQud2FpdHMgaXZhcilcbmxldCBzaWduYWwgdCBhID0gT3B0aW9uLml0ZXIgKFF1ZXVlLmRlcXVldWUgdC53YWl0cykgfmY6KGZ1biBpdmFyIC0+IEl2YXIuZmlsbCBpdmFyIGEpXG5cbmxldCBicm9hZGNhc3QgdCBhID1cbiAgUXVldWUuaXRlciB0LndhaXRzIH5mOihmdW4gaXZhciAtPiBJdmFyLmZpbGwgaXZhciBhKTtcbiAgUXVldWUuY2xlYXIgdC53YWl0c1xuOztcbiIsIm9wZW4gQ29yZVxuaW5jbHVkZSBHY1xuXG4oKiogW2FkZF9maW5hbGl6ZXIgZiB4XSBpcyBsaWtlIFtHYy5maW5hbGlzZSBmIHhdLCBleGNlcHQgdGhhdCB0aGUgZmluYWxpemVyIGlzIGd1YXJhbnRlZWRcbiAgICB0byBydW4gYXMgYW4gQXN5bmMgam9iIChpLmUuIHdpdGhvdXQgaW50ZXJydXB0aW5nIG90aGVyIEFzeW5jIGpvYnMpLiAgVW5wcm90ZWN0ZWQgdXNlXG4gICAgb2YgW0NhbWwuR2MuZmluYWxpc2VdIG9yIFtDb3JlLkdjLmFkZF9maW5hbGl6ZXJdIGluIEFzeW5jIHByb2dyYW1zIGlzIHdyb25nLCBiZWNhdXNlXG4gICAgdGhlIGZpbmFsaXplcnMgd29uJ3QgaG9sZCB0aGUgYXN5bmMgbG9jaywgYW5kIHRodXMgY291bGQgaW50ZXJsZWF2ZSBhcmJpdHJhcmlseSB3aXRoXG4gICAgYXN5bmMgam9icy4gKilcbmxldCBhZGRfZmluYWxpemVyIGhlYXBfYmxvY2sgZiA9IFNjaGVkdWxlci4oYWRkX2ZpbmFsaXplciAodCAoKSkpIGhlYXBfYmxvY2sgZlxuXG5sZXQgYWRkX2ZpbmFsaXplcl9leG4gaGVhcF9ibG9jayBmID0gU2NoZWR1bGVyLihhZGRfZmluYWxpemVyX2V4biAodCAoKSkpIGhlYXBfYmxvY2sgZlxubGV0IGFkZF9maW5hbGl6ZXJfbGFzdCBoZWFwX2Jsb2NrIGYgPSBTY2hlZHVsZXIuKGFkZF9maW5hbGl6ZXJfbGFzdCAodCAoKSkpIGhlYXBfYmxvY2sgZlxuXG5sZXQgYWRkX2ZpbmFsaXplcl9sYXN0X2V4biBoZWFwX2Jsb2NrIGYgPVxuICBTY2hlZHVsZXIuKGFkZF9maW5hbGl6ZXJfbGFzdF9leG4gKHQgKCkpKSBoZWFwX2Jsb2NrIGZcbjs7XG5cbm1vZHVsZSBBbGFybSA9IHN0cnVjdFxuICBtb2R1bGUgQWxhcm0gPSBHYy5FeHBlcnQuQWxhcm1cblxuICB0eXBlIHQgPSBBbGFybS50IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgbGV0IGNyZWF0ZSBmID0gU2NoZWR1bGVyLihjcmVhdGVfYWxhcm0gKHQgKCkpKSBmXG4gIGxldCBkZWxldGUgPSBBbGFybS5kZWxldGVcbmVuZFxuIiwiKCoqIFRoaXMgbW9kdWxlIGRlZmluZXMgc2lnbmF0dXJlcyB0aGF0IGV4dGVuZCBbQ29yZS5JbnZhcmlhbnRdIHdpdGggYW4gW0FzeW5jXVxuICAgIHN1Ym1vZHVsZSBmb3IgaW52YXJpYW50cyB0aGF0IHVzZSBhc3luYyBjb21wdXRhdGlvbiBhbmQgcmV0dXJuIFt1bml0IERlZmVycmVkLnRdLiAqKVxuXG5vcGVuISBDb3JlXG5vcGVuISBJbXBvcnRcblxubW9kdWxlIEFzeW5jID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIC0+IHVuaXQgRGVmZXJyZWQudFxuICB0eXBlICdhIGludiA9ICdhIHRcblxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgaW52YXJpYW50IDogdCBpbnZcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBpbnZhcmlhbnQgOiAnYSBpbnYgLT4gJ2EgdCBpbnZcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBpbnZhcmlhbnQgOiAnYSBpbnYgLT4gJ2IgaW52IC0+ICgnYSwgJ2IpIHQgaW52XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiLCAnYykgdFxuXG4gICAgdmFsIGludmFyaWFudCA6ICdhIGludiAtPiAnYiBpbnYgLT4gJ2MgaW52IC0+ICgnYSwgJ2IsICdjKSB0IGludlxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBBc3luY19pbnZhcmlhbnQgPSBzaWdcbiAgaW5jbHVkZSBtb2R1bGUgdHlwZSBvZiBDb3JlLkludmFyaWFudFxuXG4gIG1vZHVsZSBBc3luYyA6IHNpZ1xuICAgIG9wZW4gQXN5bmNcblxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSBBc3luYy50XG5cbiAgICBtb2R1bGUgdHlwZSBTID0gU1xuICAgIG1vZHVsZSB0eXBlIFMxID0gUzFcbiAgICBtb2R1bGUgdHlwZSBTMiA9IFMyXG4gICAgbW9kdWxlIHR5cGUgUzMgPSBTM1xuXG4gICAgdmFsIGludmFyaWFudFxuICAgICAgOiAgU291cmNlX2NvZGVfcG9zaXRpb24udFxuICAgICAgLT4gJ2FcbiAgICAgIC0+ICgnYSAtPiBTZXhwLnQpXG4gICAgICAtPiAodW5pdCAtPiB1bml0IERlZmVycmVkLnQpXG4gICAgICAtPiB1bml0IERlZmVycmVkLnRcblxuICAgICgqKiBbY2hlY2tfZmllbGRdIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHJlY29yZCBmaWVsZHMgd2hlbiB1c2luZyBbW0BAZGVyaXZpbmcgZmllbGRzXV0uXG4gICAgICAgIElkaW9tYXRpYyB1c2FnZSBsb29rcyBsaWtlOlxuXG4gICAgICAgIHtbXG4gICAgICAgICAgdHlwZSB0ID0geyBmb28gOiBGb28udCA7IGJhciA6IEJhci50IH1cbiAgICAgICAgICBbQEBkZXJpdmluZyBmaWVsZHNdXG5cbiAgICAgICAgICBsZXQgaW52YXJpYW50IHQgPVxuICAgICAgICAgICAgSW52YXJpYW50LkFzeW5jLmludmFyaWFudCBbJWhlcmVdIHQgWyVzZXhwX29mOiB0XSAoZnVuICgpIC0+XG4gICAgICAgICAgICAgIGxldCBjaGVjayBpbnYgPSBJbnZhcmlhbnQuQXN5bmMuY2hlY2tfZmllbGQgdCBpbnYgaW5cbiAgICAgICAgICAgICAgRmllbGRzLmZvbGQgfmluaXQ6KHJldHVybiAoKSlcbiAgICAgICAgICAgICAgICB+Zm9vOiAoY2hlY2sgRm9vLmludmFyaWFudClcbiAgICAgICAgICAgICAgICB+YmFyOiAoY2hlY2sgQmFyLmludmFyaWFudCkgXX1cblxuICAgICAgICBXaGVuIHNvbWUgZmllbGRzIGhhdmUgc3luY2hyb25vdXMgaW52YXJpYW50cywgb3IgZG8gbm90IG5lZWQgdG8gYmUgY2hlY2tlZCwgaXRcbiAgICAgICAgbWF5IGJlIHVzZWZ1bCB0byBkZWZpbmUgYSBzZWNvbmQgd3JhcHBlciBhcm91bmQgW2NoZWNrX2ZpZWxkXTpcblxuICAgICAgICB7W1xuICAgICAgICAgIHR5cGUgdCA9IHsgZm9vIDogRm9vLnQgOyBiYXIgOiBCYXIudCA7IHF1dXggOiBRdXV4LnQgfVxuICAgICAgICAgIFtAQGRlcml2aW5nIGZpZWxkc11cblxuICAgICAgICAgIGxldCBpbnZhcmlhbnQgdCA9XG4gICAgICAgICAgICBJbnZhcmlhbnQuQXN5bmMuaW52YXJpYW50IFslaGVyZV0gdCBbJXNleHBfb2Y6IHRdIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgbGV0IGNoZWNrJyBpbnYgPSBJbnZhcmlhbnQuQXN5bmMuY2hlY2tfZmllbGQgdCBpbnYgaW5cbiAgICAgICAgICAgICAgbGV0IGNoZWNrIGludiA9IGNoZWNrJyAoZnVuIHggLT4gaW52IHg7IHJldHVybiAoKSkgaW5cbiAgICAgICAgICAgICAgRmllbGRzLmZvbGQgfmluaXQ6KHJldHVybiAoKSlcbiAgICAgICAgICAgICAgICB+Zm9vOiAgKGNoZWNrJyBGb28uaW52YXJpYW50KVxuICAgICAgICAgICAgICAgIH5iYXI6ICAoY2hlY2sgIEJhci5pbnZhcmlhbnQpXG4gICAgICAgICAgICAgICAgfnF1dXg6IChjaGVjayAgaWdub3JlKSBdfSAqKVxuICAgIHZhbCBjaGVja19maWVsZCA6ICdhIC0+ICdiIHQgLT4gdW5pdCBEZWZlcnJlZC50IC0+ICgnYSwgJ2IpIEZpZWxkLnQgLT4gdW5pdCBEZWZlcnJlZC50XG4gIGVuZFxuZW5kXG4iLCJvcGVuISBDb3JlXG5vcGVuISBEZWZlcnJlZC5MZXRfc3ludGF4XG5vcGVuISBJbXBvcnRcbmluY2x1ZGUgQ29yZS5JbnZhcmlhbnRcblxubW9kdWxlIEFzeW5jID0gc3RydWN0XG4gIGluY2x1ZGUgQXN5bmNfaW52YXJpYW50X2ludGYuQXN5bmNcblxuICBsZXQgaW52YXJpYW50IGhlcmUgdCBzZXhwX29mX3QgZiA9XG4gICAgbWF0Y2glbWFwXG4gICAgICBNb25pdG9yLnRyeV93aXRoXG4gICAgICAgIH5ydW46XG4gICAgICAgICAgYFNjaGVkdWxlXG4gICAgICAgIH5yZXN0OmBMb2dcbiAgICAgICAgZlxuICAgICAgICB+ZXh0cmFjdF9leG46dHJ1ZVxuICAgIHdpdGhcbiAgICB8IE9rICgpIC0+ICgpXG4gICAgfCBFcnJvciBleG4gLT5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgXCJpbnZhcmlhbnQgZmFpbGVkXCIgfl86KGhlcmUgOiBTb3VyY2VfY29kZV9wb3NpdGlvbi50KSAoZXhuIDogZXhuKSB+XzoodCA6IHQpXVxuICA7O1xuXG4gIGxldCBjaGVja19maWVsZCB0IGYgd2FpdF9mb3JfcHJldmlvdXMgZmllbGQgPVxuICAgIGxldCViaW5kICgpID0gd2FpdF9mb3JfcHJldmlvdXMgaW5cbiAgICBtYXRjaCVtYXBcbiAgICAgIE1vbml0b3IudHJ5X3dpdGhcbiAgICAgICAgfnJ1bjpcbiAgICAgICAgICBgU2NoZWR1bGVcbiAgICAgICAgfnJlc3Q6YExvZ1xuICAgICAgICB+ZXh0cmFjdF9leG46dHJ1ZVxuICAgICAgICAoZnVuICgpIC0+IGYgKEZpZWxkLmdldCBmaWVsZCB0KSlcbiAgICB3aXRoXG4gICAgfCBPayAoKSAtPiAoKVxuICAgIHwgRXJyb3IgZXhuIC0+XG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZSBcInByb2JsZW0gd2l0aCBmaWVsZFwiIH5maWVsZDooRmllbGQubmFtZSBmaWVsZCA6IHN0cmluZykgKGV4biA6IGV4bildXG4gIDs7XG5lbmRcbiIsIigqKiBDb250YWlucyBBc3luYydzIGNvcmUgZGF0YSBzdHJ1Y3R1cmVzLCBsaWtlIHt7IUFzeW5jX2tlcm5lbC5EZWZlcnJlZH1bRGVmZXJyZWRdfSxcbiAgICB7eyFBc3luY19rZXJuZWwuSXZhcn1bSXZhcl19LCBhbmQge3shQXN5bmNfa2VybmVsLkNsb2NrX2ludGYuQ2xvY2t9W0Nsb2NrXX0uXG5cbiAgICBbQXN5bmNfa2VybmVsXSBpcyBkZXNpZ25lZCB0byBkZXBlbmQgb25seSBvbiB7eyFDb3JlfVtDb3JlXX0gYW5kIHNvIGlzIG1vcmVcbiAgICBwbGF0Zm9ybS1pbmRlcGVuZGVudC4gKilcblxub3BlbiEgQ29yZVxub3BlbiEgSW1wb3J0XG5tb2R1bGUgQXN5bmNfa2VybmVsX2NvbmZpZyA9IEFzeW5jX2tlcm5lbF9jb25maWdcbm1vZHVsZSBBc3luY19rZXJuZWxfcmVxdWlyZV9leHBsaWNpdF90aW1lX3NvdXJjZSA9IFJlcXVpcmVfZXhwbGljaXRfdGltZV9zb3VyY2Vcbm1vZHVsZSBBc3luY19rZXJuZWxfc2NoZWR1bGVyID0gQXN5bmNfa2VybmVsX3NjaGVkdWxlclxubW9kdWxlIEJ2YXIgPSBCdmFyXG5tb2R1bGUgQ2xvY2tfbnMgPSBDbG9ja19uc1xubW9kdWxlIENvbmRpdGlvbiA9IEFzeW5jX2NvbmRpdGlvblxubW9kdWxlIERlZmVycmVkID0gRGVmZXJyZWRcbm1vZHVsZSBFeGVjdXRpb25fY29udGV4dCA9IEV4ZWN1dGlvbl9jb250ZXh0XG5tb2R1bGUgR2MgPSBBc3luY19nY1xubW9kdWxlIEludmFyaWFudCA9IEFzeW5jX2ludmFyaWFudFxubW9kdWxlIEl2YXIgPSBJdmFyXG5tb2R1bGUgTGF6eV9kZWZlcnJlZCA9IExhenlfZGVmZXJyZWRcbm1vZHVsZSBNb25hZF9zZXF1ZW5jZSA9IE1vbmFkX3NlcXVlbmNlXG5tb2R1bGUgTW9uaXRvciA9IE1vbml0b3Jcbm1vZHVsZSBNdmFyID0gTXZhclxubW9kdWxlIFBpcGUgPSBQaXBlXG5tb2R1bGUgUHJpb3JpdHkgPSBQcmlvcml0eVxubW9kdWxlIFNlcXVlbmNlciA9IFRocm90dGxlLlNlcXVlbmNlclxubW9kdWxlIFN0cmVhbSA9IEFzeW5jX3N0cmVhbVxubW9kdWxlIFN5bmNocm9ub3VzX3RpbWVfc291cmNlID0gU3luY2hyb25vdXNfdGltZV9zb3VyY2Vcbm1vZHVsZSBUYWlsID0gVGFpbFxubW9kdWxlIFRocm90dGxlID0gVGhyb3R0bGVcbm1vZHVsZSBUaW1lX3NvdXJjZSA9IFRpbWVfc291cmNlXG5cblxuKCoqIHsyIFRvcGxldmVsIGZ1bmN0aW9ucyB9XG5cbiAgICBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBicm9hZGx5IHVzZWZ1bCB3aGVuIHdyaXRpbmcgQXN5bmMgcHJvZ3JhbXMsIGFuZCBzbyBhcmUgbWFkZVxuICAgIGF2YWlsYWJsZSBhdCB0aGUgdG9wbGV2ZWwuICopXG5cblxubGV0IGFmdGVyID0gQ2xvY2tfbnMuYWZ0ZXJcbmxldCBhdCA9IENsb2NrX25zLmF0XG5sZXQgY2F0Y2ggPSBNb25pdG9yLmNhdGNoXG5sZXQgY2hvaWNlID0gRGVmZXJyZWQuY2hvaWNlXG5sZXQgY2hvb3NlID0gRGVmZXJyZWQuY2hvb3NlXG5sZXQgZG9uJ3Rfd2FpdF9mb3IgPSBEZWZlcnJlZC5kb24ndF93YWl0X2ZvclxubGV0IGV2ZXJ5ID0gQ2xvY2tfbnMuZXZlcnlcbmxldCBuZXZlciA9IERlZmVycmVkLm5ldmVyXG5sZXQgc2NoZWR1bGUgPSBTY2hlZHVsZXIuc2NoZWR1bGVcbmxldCBzY2hlZHVsZScgPSBTY2hlZHVsZXIuc2NoZWR1bGUnXG5sZXQgdHJ5X3dpdGggPSBNb25pdG9yLnRyeV93aXRoXG5sZXQgdXBvbiA9IERlZmVycmVkLnVwb25cbmxldCB3aXRoX3RpbWVvdXQgPSBDbG9ja19ucy53aXRoX3RpbWVvdXRcbmxldCB3aXRoaW4gPSBTY2hlZHVsZXIud2l0aGluXG5sZXQgd2l0aGluJyA9IFNjaGVkdWxlci53aXRoaW4nXG5cbigqKiB7MiBJbmZpeCBvcGVyYXRvcnMgYW5kIFtMZXRfc3ludGF4XSBzdXBwb3J0fSAqKVxuXG5pbmNsdWRlIChEZWZlcnJlZCA6IE1vbmFkLkluZml4IHdpdGggdHlwZSAnYSB0IDo9ICdhIERlZmVycmVkLnQpXG5cbigqKiBlcXVpdmFsZW50IHRvIHshRGVmZXJyZWQudXBvbn0uICopXG5sZXQgKCA+Pj4gKSA9IERlZmVycmVkLkluZml4LiggPj4+IClcblxuKCoqIGVxdWl2YWxlbnQgdG8geyFEZWZlcnJlZC5SZXN1bHQuYmluZH0uICopXG5sZXQgKCA+Pj0/ICkgPSBEZWZlcnJlZC5SZXN1bHQuKCA+Pj0gKVxuXG4oKiogZXF1aXZhbGVudCB0byB7IURlZmVycmVkLlJlc3VsdC5tYXB9LiAqKVxubGV0ICggPj58PyApID0gRGVmZXJyZWQuUmVzdWx0LiggPj58IClcblxuaW5jbHVkZSBEZWZlcnJlZC5MZXRfc3ludGF4XG5cbigqKi8qKilcblxuKCoqIFRoZSBtb2R1bGVzIGluIFtBc3luY19rZXJuZWxfcHJpdmF0ZV0gYXJlIHVzZWQgZm9yIGNvbnN0cnVjdGluZyBhbmQgdGVzdGluZyBBc3luYywgYW5kXG4gICAgc2hvdWxkIG5vdCBvdGhlcndpc2UgYmUgdXNlZC4gKilcbm1vZHVsZSBBc3luY19rZXJuZWxfcHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgRGVidWcgPSBEZWJ1Z1xuICBtb2R1bGUgSXZhcjAgPSBJdmFyMFxuICBtb2R1bGUgSXZhcl9maWxsZXIgPSBJdmFyX2ZpbGxlclxuICBtb2R1bGUgSm9iID0gSm9iXG4gIG1vZHVsZSBTdGFja19vcl9jb3VudGVyID0gU3RhY2tfb3JfY291bnRlclxuZW5kXG5cbigqKi8qKilcblxuKCogVGhpcyB0ZXN0IG11c3QgYmUgaW4gdGhpcyBsaWJyYXJ5LCBiZWNhdXNlIGl0IHJlcXVpcmVzIFtyZXR1cm5dIHRvIGJlIGlubGluZWQuICBNb3ZpbmdcbiAgIGl0IHRvIGFub3RoZXIgbGlicmFyeSB3aWxsIGNhdXNlIGl0IHRvIGJyZWFrIHdpdGggW1hfTElCUkFSWV9JTkxJTklORz1mYWxzZV0uICopXG5sZXQldGVzdF91bml0IFwiW3JldHVybiAoKV0gZG9lcyBub3QgYWxsb2NhdGVcIiA9XG4gIGxldCB3MSA9IEdjLm1pbm9yX3dvcmRzICgpIGluXG4gIGlnbm9yZSAoU3lzLm9wYXF1ZV9pZGVudGl0eSAocmV0dXJuICgpKSA6IF8gRGVmZXJyZWQudCk7XG4gIGlnbm9yZSAoU3lzLm9wYXF1ZV9pZGVudGl0eSAoRGVmZXJyZWQucmV0dXJuICgpKSA6IF8gRGVmZXJyZWQudCk7XG4gIGlnbm9yZSAoU3lzLm9wYXF1ZV9pZGVudGl0eSAoRGVmZXJyZWQuTGV0X3N5bnRheC5yZXR1cm4gKCkpIDogXyBEZWZlcnJlZC50KTtcbiAgaWdub3JlIChTeXMub3BhcXVlX2lkZW50aXR5IChEZWZlcnJlZC5MZXRfc3ludGF4LkxldF9zeW50YXgucmV0dXJuICgpKSA6IF8gRGVmZXJyZWQudCk7XG4gIGxldCB3MiA9IEdjLm1pbm9yX3dvcmRzICgpIGluXG4gIFsldGVzdF9yZXN1bHQ6IGludF0gdzIgfmV4cGVjdDp3MVxuOztcbiJdfQ==
