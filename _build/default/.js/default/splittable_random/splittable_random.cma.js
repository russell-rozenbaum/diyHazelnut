// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1+5.8.1

//# unitInfo: Provides: Splittable_random
//# unitInfo: Requires: Assert_failure, Base, Base__Error, Base__Float, Base__Int, Base__Int32, Base__Int63, Base__Int64, Base__Nativeint, Base__Random, Ppx_bench_lib__Benchmark_accumulator, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_hi = "hi",
    cst_lo = "lo",
    cst_src_splittable_random_ml$1 = "src/splittable_random.ml",
    caml_div = runtime.caml_div,
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_div = runtime.caml_int64_div,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_int64_xor = runtime.caml_int64_xor,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_notequal = runtime.caml_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    int64$0 = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    golden_gamma = runtime.caml_int64_create_lo_mi_hi(4881429, 7977343, 40503),
    Base_Int = global_data.Base__Int,
    Assert_failure = global_data.Assert_failure,
    Base = global_data.Base,
    Base_Float = global_data.Base__Float,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Int64 = global_data.Base__Int64,
    Base_Int63 = global_data.Base__Int63,
    Base_Error = global_data.Base__Error,
    Base_Random = global_data.Base__Random,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Base_Int32 = global_data.Base__Int32,
    Base_Nativeint = global_data.Base__Nativeint;
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], "splittable_random");
   var
    popcount = Base_Int64[47],
    _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(5606605, 11524077, 65361),
    _c_ = runtime.caml_int64_create_lo_mi_hi(8776787, 12189210, 50382),
    _d_ = runtime.caml_int64_create_lo_mi_hi(15001017, 4680988, 48984),
    _e_ = runtime.caml_int64_create_lo_mi_hi(3215851, 4832019, 38096),
    _f_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _g_ = runtime.caml_int64_create_lo_mi_hi(11184810, 11184810, 43690),
    _h_ = [0, cst_hi],
    _i_ = [0, cst_lo],
    cst_int64_crossed_bounds = "int64: crossed bounds",
    _j_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0);
   function of_int(seed){return [0, caml_int64_of_int32(seed), golden_gamma];}
   function copy(param){
    var seed = param[1], odd_gamma = param[2];
    return [0, seed, odd_gamma];
   }
   function mix_bits(z, n){
    return caml_int64_xor(z, caml_int64_shift_right_unsigne(z, n));
   }
   function mix64(z){
    var
     z$0 = caml_int64_mul(mix_bits(z, 33), _b_),
     z$1 = caml_int64_mul(mix_bits(z$0, 33), _c_);
    return mix_bits(z$1, 33);
   }
   function next_seed(t){
    var next = caml_int64_add(t[1], t[2]);
    t[1] = next;
    return next;
   }
   function of_seed_and_gamma(seed, gamma){
    var
     seed$0 = mix64(seed),
     z = caml_int64_mul(mix_bits(gamma, 30), _d_),
     z$0 = caml_int64_mul(mix_bits(z, 27), _e_),
     z$1 = caml_int64_or(mix_bits(z$0, 31), _f_),
     n =
       caml_call1
        (popcount,
         caml_int64_xor(z$1, caml_int64_shift_right_unsigne(z$1, 1))),
     odd_gamma = 24 <= n ? z$1 : caml_int64_xor(z$1, _g_);
    return [0, seed$0, odd_gamma];
   }
   function random_int64(random_state){
    return caml_call3
            (Base_Random[18][14],
             random_state,
             Base_Int64[61],
             Base_Int64[60]);
   }
   function create(random_state){
    var seed = random_int64(random_state), gamma = random_int64(random_state);
    return of_seed_and_gamma(seed, gamma);
   }
   function split(t){
    var seed = next_seed(t), gamma = next_seed(t);
    return of_seed_and_gamma(seed, gamma);
   }
   function next_int64(t){return mix64(next_seed(t));}
   function perturb(t, salt){
    var
     _aU_ = mix64(caml_int64_of_int32(salt)),
     next = caml_int64_add(t[1], _aU_);
    t[1] = next;
    return 0;
   }
   function bool(state){
    var x = next_int64(state);
    return caml_equal(caml_int64_or(x, _a_), x);
   }
   function int64(state, lo, hi){
    if(caml_greaterthan(lo, hi)){
     var
      _aQ_ = [0, [1, [0, _h_, [0, caml_call1(Base[133], hi), 0]]], 0],
      _aR_ = [0, [1, [0, _i_, [0, caml_call1(Base[133], lo), 0]]], _aQ_],
      _aS_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_int64_crossed_bounds),
          _aR_]];
     caml_call1(Base_Error[30], _aS_);
    }
    var remainder_maximum = caml_int64_sub(hi, lo);
    if(caml_equal(remainder_maximum, Base_Int64[60])){
     var _aT_ = Base_Int64[60];
     return caml_int64_add(caml_int64_and(next_int64(state), _aT_), lo);
    }
    if(caml_greaterequal(remainder_maximum, _j_))
     for(;;){
      var
       _aO_ = Base_Int64[60],
       draw$0 = caml_int64_and(next_int64(state), _aO_),
       _aP_ = caml_call1(Base_Int64[40], remainder_maximum),
       remainder = caml_call2(Base_Int64[34], draw$0, _aP_),
       draw_maximum = Base_Int64[60];
      if
       (caml_lessequal
         (caml_int64_sub(draw$0, remainder),
          caml_int64_sub(draw_maximum, remainder_maximum)))
       return caml_int64_add(remainder, lo);
     }
    else
     for(;;){
      var draw = next_int64(state);
      if(caml_lessequal(lo, draw) && caml_lessequal(draw, hi)) return draw;
     }
   }
   function int$0(state, lo, hi){
    var lo$0 = caml_int64_of_int32(lo), hi$0 = caml_int64_of_int32(hi);
    return caml_int64_to_int32(int64(state, lo$0, hi$0));
   }
   function int32(state, lo, hi){
    var lo$0 = caml_int64_of_int32(lo), hi$0 = caml_int64_of_int32(hi);
    return caml_int64_to_int32(int64(state, lo$0, hi$0));
   }
   function nativeint(state, lo, hi){
    var
     lo$0 = caml_call1(Base_Int64[80], lo),
     hi$0 = caml_call1(Base_Int64[80], hi);
    return caml_int64_to_int32(int64(state, lo$0, hi$0));
   }
   function int63(state, lo, hi){
    var
     lo$0 = caml_call1(Base_Int63[79], lo),
     hi$0 = caml_call1(Base_Int63[79], hi),
     _aN_ = int64(state, lo$0, hi$0);
    return caml_call1(Base_Int63[105], _aN_);
   }
   var
    double_ulp = caml_call2(Base[195], 2., -53.),
    _k_ = [0, cst_hi],
    _l_ = [0, cst_lo],
    cst_float_bounds_are_not_finit = "float: bounds are not finite numbers",
    _m_ = [0, cst_hi],
    _n_ = [0, cst_lo],
    cst_float_bounds_are_crossed = "float: bounds are crossed";
   function unit_float_from_int64(int64){
    var
     _aM_ =
       caml_call1(Base_Int64[3], caml_int64_shift_right_unsigne(int64, 11));
    return caml_call2(Base[192], _aM_, double_ulp);
   }
   function unit_float(state){
    return unit_float_from_int64(next_int64(state));
   }
   function float$0(state, lo$0, hi$0){
    var
     _aE_ = caml_call1(Base_Float[84], lo$0),
     _aF_ = _aE_ ? caml_call1(Base_Float[84], hi$0) : _aE_;
    if(1 - _aF_){
     var
      _aG_ = [0, [1, [0, _k_, [0, caml_call1(Base[112], hi$0), 0]]], 0],
      _aH_ = [0, [1, [0, _l_, [0, caml_call1(Base[112], lo$0), 0]]], _aG_],
      _aI_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_float_bounds_are_not_finit),
          _aH_]];
     caml_call1(Base[202], _aI_);
    }
    if(caml_call2(Base_Float[12], lo$0, hi$0)){
     var
      _aJ_ = [0, [1, [0, _m_, [0, caml_call1(Base[112], hi$0), 0]]], 0],
      _aK_ = [0, [1, [0, _n_, [0, caml_call1(Base[112], lo$0), 0]]], _aJ_],
      _aL_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_float_bounds_are_crossed),
          _aK_]];
     caml_call1(Base[202], _aL_);
    }
    var lo = lo$0, hi = hi$0;
    for(;;){
     var range = caml_call2(Base[191], hi, lo);
     if(caml_call1(Base_Float[84], range)){
      var _aB_ = unit_float(state), _aC_ = caml_call2(Base[192], _aB_, range);
      return caml_call2(Base[190], lo, _aC_);
     }
     var
      _aD_ = caml_call2(Base[190], hi, lo),
      mid = caml_call2(Base[193], _aD_, 2.);
     if(bool(state)) hi = mid; else lo = mid;
    }
   }
   var
    _o_ = [0, cst_src_splittable_random_ml$1, 289, 6],
    cst_src_splittable_random_ml = cst_src_splittable_random_ml$1,
    cst_src_splittable_random_ml$0 = cst_src_splittable_random_ml$1,
    cst_let_int64_1L_in_fun_unit_f =
      "let int64 = 1L in fun () -> unit_float_from_int64 int64",
    cst_unit_float_from_int64 = "unit_float_from_int64";
   if(Ppx_bench_lib_Benchmark_accumu[3]){
    var
     f =
       function(param){
        return function(param){return unit_float_from_int64(int64$0);};
       };
    caml_call8
     (Ppx_bench_lib_Benchmark_accumu[5],
      cst_unit_float_from_int64,
      cst_let_int64_1L_in_fun_unit_f,
      cst_src_splittable_random_ml$0,
      cst_src_splittable_random_ml,
      278,
      0,
      99,
      [0, f]);
   }
   function Make(M){
    function bits_to_represent(t){
     if(! caml_call2(M[12], t, M[38]))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
     var t$0 = [0, t], n = [0, 0];
     for(;;){
      if(! caml_call2(M[15], t$0[1], M[38])) return n[1];
      t$0[1] = caml_call2(M[73], t$0[1], 1);
      caml_call1(Base_Int[51], n);
     }
    }
    function log_uniform(state, lo, hi){
     var
      min_bits = bits_to_represent(lo),
      max_bits = bits_to_represent(hi),
      bits = int$0(state, min_bits, max_bits),
      _aw_ = caml_call2(M[72], M[39], bits),
      _ax_ = caml_call1(M[65], _aw_),
      _ay_ = caml_call1(caml_call1(M[20], hi), _ax_);
     if(caml_call2(Base_Int[12], bits, 0))
      var _az_ = M[38];
     else
      var
       _av_ = caml_call1(Base_Int[41], bits),
       _az_ = caml_call2(M[72], M[39], _av_);
     var _aA_ = caml_call1(caml_call1(M[21], lo), _az_);
     return caml_call3(M[96], state, _aA_, _ay_);
    }
    return [0, log_uniform];
   }
   var
    t_sexp_grammar = Base_Int[1],
    of_float = Base_Int[2],
    to_float = Base_Int[3],
    of_int_exn = Base_Int[4],
    to_int_exn = Base_Int[5],
    hash_fold_t = Base_Int[6],
    hash = Base_Int[7],
    t_of_sexp = Base_Int[8],
    sexp_of_t = Base_Int[9],
    of_string = Base_Int[10],
    to_string = Base_Int[11],
    equal = Base_Int[12],
    compare = Base_Int[13],
    min = Base_Int[14],
    max = Base_Int[15],
    ascending = Base_Int[16],
    descending = Base_Int[17],
    between = Base_Int[18],
    clamp_exn = Base_Int[19],
    clamp = Base_Int[20],
    comparator = Base_Int[21],
    pp = Base_Int[22],
    hashable = Base_Int[23],
    is_positive = Base_Int[24],
    is_non_negative = Base_Int[25],
    is_negative = Base_Int[26],
    is_non_positive = Base_Int[27],
    sign = Base_Int[28],
    invariant = Base_Int[29],
    Hex = Base_Int[30],
    to_string_hum = Base_Int[31],
    one = Base_Int[32],
    minus_one = Base_Int[33],
    rem = Base_Int[34],
    round = Base_Int[35],
    round_towards_zero = Base_Int[36],
    round_down = Base_Int[37],
    round_up = Base_Int[38],
    round_nearest = Base_Int[39],
    succ = Base_Int[40],
    pred = Base_Int[41],
    pow = Base_Int[42],
    bit_and = Base_Int[43],
    bit_or = Base_Int[44],
    bit_xor = Base_Int[45],
    bit_not = Base_Int[46],
    popcount$0 = Base_Int[47],
    shift_left = Base_Int[48],
    shift_right = Base_Int[49],
    decr = Base_Int[50],
    incr = Base_Int[51],
    of_int32_exn = Base_Int[52],
    to_int32_exn = Base_Int[53],
    of_int64_exn = Base_Int[54],
    to_int64 = Base_Int[55],
    of_nativeint_exn = Base_Int[56],
    to_nativeint_exn = Base_Int[57],
    of_float_unchecked = Base_Int[58],
    num_bits = Base_Int[59],
    max_value = Base_Int[60],
    min_value = Base_Int[61],
    shift_right_logical = Base_Int[62],
    ceil_pow2 = Base_Int[63],
    floor_pow2 = Base_Int[64],
    ceil_log2 = Base_Int[65],
    floor_log2 = Base_Int[66],
    is_pow2 = Base_Int[67],
    clz = Base_Int[68],
    ctz = Base_Int[69],
    O = Base_Int[70],
    symbol = Base_Int[71],
    lnot = Base_Int[72],
    abs = Base_Int[73],
    zero = Base_Int[74],
    symbol$0 = Base_Int[75],
    symbol$1 = Base_Int[76],
    symbol$2 = Base_Int[77],
    For_int =
      Make
       ([0,
         t_sexp_grammar,
         of_float,
         to_float,
         of_int_exn,
         to_int_exn,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         function(_au_, _at_){return _at_ <= _au_ ? 1 : 0;},
         function(_as_, _ar_){return _as_ <= _ar_ ? 1 : 0;},
         function(_aq_, _ap_){return _aq_ === _ap_ ? 1 : 0;},
         function(_ao_, _an_){return _an_ < _ao_ ? 1 : 0;},
         function(_am_, _al_){return _am_ < _al_ ? 1 : 0;},
         function(_ak_, _aj_){return _ak_ !== _aj_ ? 1 : 0;},
         equal,
         compare,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator,
         pp,
         hashable,
         is_positive,
         is_non_negative,
         is_negative,
         is_non_positive,
         sign,
         invariant,
         Hex,
         to_string_hum,
         zero,
         one,
         minus_one,
         function(_ai_, _ah_){return _ai_ + _ah_ | 0;},
         function(_ag_, _af_){return _ag_ - _af_ | 0;},
         caml_mul,
         symbol,
         function(_ae_){return - _ae_ | 0;},
         function(_ad_){return - _ad_ | 0;},
         symbol$1,
         symbol$0,
         caml_div,
         rem,
         symbol$2,
         function(_ac_, _ab_){return _ac_ & _ab_;},
         function(_aa_, _$_){return _aa_ | _$_;},
         function(___, _Z_){return ___ ^ _Z_;},
         lnot,
         function(_Y_, _X_){return _Y_ << _X_;},
         function(_W_, _V_){return _W_ >> _V_;},
         round,
         round_towards_zero,
         round_down,
         round_up,
         round_nearest,
         abs,
         succ,
         pred,
         pow,
         bit_and,
         bit_or,
         bit_xor,
         bit_not,
         popcount$0,
         shift_left,
         shift_right,
         decr,
         incr,
         of_int32_exn,
         to_int32_exn,
         of_int64_exn,
         to_int64,
         of_nativeint_exn,
         to_nativeint_exn,
         of_float_unchecked,
         num_bits,
         max_value,
         min_value,
         function(_U_, _T_){return _U_ >>> _T_ | 0;},
         shift_right_logical,
         ceil_pow2,
         floor_pow2,
         ceil_log2,
         floor_log2,
         is_pow2,
         clz,
         ctz,
         [0,
          function(_S_, _R_){return _S_ + _R_ | 0;},
          function(_Q_, _P_){return _Q_ - _P_ | 0;},
          caml_mul,
          caml_div,
          function(_O_){return - _O_ | 0;},
          O[1],
          function(_N_, _M_){return _M_ <= _N_ ? 1 : 0;},
          function(_L_, _K_){return _L_ <= _K_ ? 1 : 0;},
          function(_J_, _I_){return _J_ === _I_ ? 1 : 0;},
          function(_H_, _G_){return _G_ < _H_ ? 1 : 0;},
          function(_F_, _E_){return _F_ < _E_ ? 1 : 0;},
          function(_D_, _C_){return _D_ !== _C_ ? 1 : 0;},
          O[3],
          function(_B_){return - _B_ | 0;},
          O[4],
          O[5],
          O[6],
          O[7],
          function(_A_, _z_){return _A_ & _z_;},
          function(_y_, _x_){return _y_ | _x_;},
          function(_w_, _v_){return _w_ ^ _v_;},
          O[2],
          function(_u_, _t_){return _u_ << _t_;},
          function(_s_, _r_){return _s_ >> _r_;},
          function(_q_, _p_){return _q_ >>> _p_ | 0;}],
         int$0]),
    t_sexp_grammar$0 = Base_Int32[1],
    of_float$0 = Base_Int32[2],
    to_float$0 = Base_Int32[3],
    of_int_exn$0 = Base_Int32[4],
    to_int_exn$0 = Base_Int32[5],
    hash_fold_t$0 = Base_Int32[6],
    hash$0 = Base_Int32[7],
    t_of_sexp$0 = Base_Int32[8],
    sexp_of_t$0 = Base_Int32[9],
    of_string$0 = Base_Int32[10],
    to_string$0 = Base_Int32[11],
    symbol$3 = Base_Int32[12],
    symbol$4 = Base_Int32[13],
    symbol$5 = Base_Int32[14],
    symbol$6 = Base_Int32[15],
    symbol$7 = Base_Int32[16],
    symbol$8 = Base_Int32[17],
    equal$0 = Base_Int32[18],
    compare$0 = Base_Int32[19],
    min$0 = Base_Int32[20],
    max$0 = Base_Int32[21],
    ascending$0 = Base_Int32[22],
    descending$0 = Base_Int32[23],
    between$0 = Base_Int32[24],
    clamp_exn$0 = Base_Int32[25],
    clamp$0 = Base_Int32[26],
    comparator$0 = Base_Int32[27],
    pp$0 = Base_Int32[28],
    hashable$0 = Base_Int32[29],
    is_positive$0 = Base_Int32[30],
    is_non_negative$0 = Base_Int32[31],
    is_negative$0 = Base_Int32[32],
    is_non_positive$0 = Base_Int32[33],
    sign$0 = Base_Int32[34],
    invariant$0 = Base_Int32[35],
    Hex$0 = Base_Int32[36],
    to_string_hum$0 = Base_Int32[37],
    zero$0 = Base_Int32[38],
    one$0 = Base_Int32[39],
    minus_one$0 = Base_Int32[40],
    symbol$9 = Base_Int32[41],
    symbol$10 = Base_Int32[42],
    symbol$11 = Base_Int32[43],
    symbol$12 = Base_Int32[44],
    neg = Base_Int32[45],
    symbol$13 = Base_Int32[46],
    symbol$14 = Base_Int32[47],
    symbol$15 = Base_Int32[48],
    symbol$16 = Base_Int32[49],
    rem$0 = Base_Int32[50],
    symbol$17 = Base_Int32[51],
    land = Base_Int32[52],
    lor = Base_Int32[53],
    lxor = Base_Int32[54],
    lnot$0 = Base_Int32[55],
    lsl = Base_Int32[56],
    asr = Base_Int32[57],
    round$0 = Base_Int32[58],
    round_towards_zero$0 = Base_Int32[59],
    round_down$0 = Base_Int32[60],
    round_up$0 = Base_Int32[61],
    round_nearest$0 = Base_Int32[62],
    abs$0 = Base_Int32[63],
    succ$0 = Base_Int32[64],
    pred$0 = Base_Int32[65],
    pow$0 = Base_Int32[66],
    bit_and$0 = Base_Int32[67],
    bit_or$0 = Base_Int32[68],
    bit_xor$0 = Base_Int32[69],
    bit_not$0 = Base_Int32[70],
    popcount$1 = Base_Int32[71],
    shift_left$0 = Base_Int32[72],
    shift_right$0 = Base_Int32[73],
    decr$0 = Base_Int32[74],
    incr$0 = Base_Int32[75],
    of_int32_exn$0 = Base_Int32[76],
    to_int32_exn$0 = Base_Int32[77],
    of_int64_exn$0 = Base_Int32[78],
    to_int64$0 = Base_Int32[79],
    of_nativeint_exn$0 = Base_Int32[80],
    to_nativeint_exn$0 = Base_Int32[81],
    of_float_unchecked$0 = Base_Int32[82],
    num_bits$0 = Base_Int32[83],
    max_value$0 = Base_Int32[84],
    min_value$0 = Base_Int32[85],
    lsr = Base_Int32[86],
    shift_right_logical$0 = Base_Int32[87],
    ceil_pow2$0 = Base_Int32[88],
    floor_pow2$0 = Base_Int32[89],
    ceil_log2$0 = Base_Int32[90],
    floor_log2$0 = Base_Int32[91],
    is_pow2$0 = Base_Int32[92],
    clz$0 = Base_Int32[93],
    ctz$0 = Base_Int32[94],
    O$0 = Base_Int32[95],
    For_int32 =
      Make
       ([0,
         t_sexp_grammar$0,
         of_float$0,
         to_float$0,
         of_int_exn$0,
         to_int_exn$0,
         hash_fold_t$0,
         hash$0,
         t_of_sexp$0,
         sexp_of_t$0,
         of_string$0,
         to_string$0,
         symbol$3,
         symbol$4,
         symbol$5,
         symbol$6,
         symbol$7,
         symbol$8,
         equal$0,
         compare$0,
         min$0,
         max$0,
         ascending$0,
         descending$0,
         between$0,
         clamp_exn$0,
         clamp$0,
         comparator$0,
         pp$0,
         hashable$0,
         is_positive$0,
         is_non_negative$0,
         is_negative$0,
         is_non_positive$0,
         sign$0,
         invariant$0,
         Hex$0,
         to_string_hum$0,
         zero$0,
         one$0,
         minus_one$0,
         symbol$9,
         symbol$10,
         symbol$11,
         symbol$12,
         neg,
         symbol$13,
         symbol$14,
         symbol$15,
         symbol$16,
         rem$0,
         symbol$17,
         land,
         lor,
         lxor,
         lnot$0,
         lsl,
         asr,
         round$0,
         round_towards_zero$0,
         round_down$0,
         round_up$0,
         round_nearest$0,
         abs$0,
         succ$0,
         pred$0,
         pow$0,
         bit_and$0,
         bit_or$0,
         bit_xor$0,
         bit_not$0,
         popcount$1,
         shift_left$0,
         shift_right$0,
         decr$0,
         incr$0,
         of_int32_exn$0,
         to_int32_exn$0,
         of_int64_exn$0,
         to_int64$0,
         of_nativeint_exn$0,
         to_nativeint_exn$0,
         of_float_unchecked$0,
         num_bits$0,
         max_value$0,
         min_value$0,
         lsr,
         shift_right_logical$0,
         ceil_pow2$0,
         floor_pow2$0,
         ceil_log2$0,
         floor_log2$0,
         is_pow2$0,
         clz$0,
         ctz$0,
         O$0,
         int32]),
    t_sexp_grammar$1 = Base_Int63[1],
    of_float$1 = Base_Int63[2],
    to_float$1 = Base_Int63[3],
    of_int_exn$1 = Base_Int63[4],
    to_int_exn$1 = Base_Int63[5],
    hash_fold_t$1 = Base_Int63[6],
    hash$1 = Base_Int63[7],
    t_of_sexp$1 = Base_Int63[8],
    sexp_of_t$1 = Base_Int63[9],
    of_string$1 = Base_Int63[10],
    to_string$1 = Base_Int63[11],
    symbol$18 = Base_Int63[12],
    symbol$19 = Base_Int63[13],
    symbol$20 = Base_Int63[14],
    symbol$21 = Base_Int63[15],
    symbol$22 = Base_Int63[16],
    symbol$23 = Base_Int63[17],
    equal$1 = Base_Int63[18],
    compare$1 = Base_Int63[19],
    min$1 = Base_Int63[20],
    max$1 = Base_Int63[21],
    ascending$1 = Base_Int63[22],
    descending$1 = Base_Int63[23],
    between$1 = Base_Int63[24],
    clamp_exn$1 = Base_Int63[25],
    clamp$1 = Base_Int63[26],
    comparator$1 = Base_Int63[27],
    pp$1 = Base_Int63[28],
    hashable$1 = Base_Int63[29],
    is_positive$1 = Base_Int63[30],
    is_non_negative$1 = Base_Int63[31],
    is_negative$1 = Base_Int63[32],
    is_non_positive$1 = Base_Int63[33],
    sign$1 = Base_Int63[34],
    invariant$1 = Base_Int63[35],
    Hex$1 = Base_Int63[36],
    to_string_hum$1 = Base_Int63[37],
    zero$1 = Base_Int63[38],
    one$1 = Base_Int63[39],
    minus_one$1 = Base_Int63[40],
    symbol$24 = Base_Int63[41],
    symbol$25 = Base_Int63[42],
    symbol$26 = Base_Int63[43],
    symbol$27 = Base_Int63[44],
    neg$0 = Base_Int63[45],
    symbol$28 = Base_Int63[46],
    symbol$29 = Base_Int63[47],
    symbol$30 = Base_Int63[48],
    symbol$31 = Base_Int63[49],
    rem$1 = Base_Int63[50],
    symbol$32 = Base_Int63[51],
    land$0 = Base_Int63[52],
    lor$0 = Base_Int63[53],
    lxor$0 = Base_Int63[54],
    lnot$1 = Base_Int63[55],
    lsl$0 = Base_Int63[56],
    asr$0 = Base_Int63[57],
    round$1 = Base_Int63[58],
    round_towards_zero$1 = Base_Int63[59],
    round_down$1 = Base_Int63[60],
    round_up$1 = Base_Int63[61],
    round_nearest$1 = Base_Int63[62],
    abs$1 = Base_Int63[63],
    succ$1 = Base_Int63[64],
    pred$1 = Base_Int63[65],
    pow$1 = Base_Int63[66],
    bit_and$1 = Base_Int63[67],
    bit_or$1 = Base_Int63[68],
    bit_xor$1 = Base_Int63[69],
    bit_not$1 = Base_Int63[70],
    popcount$2 = Base_Int63[71],
    shift_left$1 = Base_Int63[72],
    shift_right$1 = Base_Int63[73],
    decr$1 = Base_Int63[74],
    incr$1 = Base_Int63[75],
    of_int32_exn$1 = Base_Int63[76],
    to_int32_exn$1 = Base_Int63[77],
    of_int64_exn$1 = Base_Int63[78],
    to_int64$1 = Base_Int63[79],
    of_nativeint_exn$1 = Base_Int63[80],
    to_nativeint_exn$1 = Base_Int63[81],
    of_float_unchecked$1 = Base_Int63[82],
    num_bits$1 = Base_Int63[83],
    max_value$1 = Base_Int63[84],
    min_value$1 = Base_Int63[85],
    lsr$0 = Base_Int63[86],
    shift_right_logical$1 = Base_Int63[87],
    ceil_pow2$1 = Base_Int63[88],
    floor_pow2$1 = Base_Int63[89],
    ceil_log2$1 = Base_Int63[90],
    is_pow2$1 = Base_Int63[91],
    clz$1 = Base_Int63[92],
    ctz$1 = Base_Int63[93],
    O$1 = Base_Int63[94],
    floor_log2$1 = Base_Int63[113],
    For_int63 =
      Make
       ([0,
         t_sexp_grammar$1,
         of_float$1,
         to_float$1,
         of_int_exn$1,
         to_int_exn$1,
         hash_fold_t$1,
         hash$1,
         t_of_sexp$1,
         sexp_of_t$1,
         of_string$1,
         to_string$1,
         symbol$18,
         symbol$19,
         symbol$20,
         symbol$21,
         symbol$22,
         symbol$23,
         equal$1,
         compare$1,
         min$1,
         max$1,
         ascending$1,
         descending$1,
         between$1,
         clamp_exn$1,
         clamp$1,
         comparator$1,
         pp$1,
         hashable$1,
         is_positive$1,
         is_non_negative$1,
         is_negative$1,
         is_non_positive$1,
         sign$1,
         invariant$1,
         Hex$1,
         to_string_hum$1,
         zero$1,
         one$1,
         minus_one$1,
         symbol$24,
         symbol$25,
         symbol$26,
         symbol$27,
         neg$0,
         symbol$28,
         symbol$29,
         symbol$30,
         symbol$31,
         rem$1,
         symbol$32,
         land$0,
         lor$0,
         lxor$0,
         lnot$1,
         lsl$0,
         asr$0,
         round$1,
         round_towards_zero$1,
         round_down$1,
         round_up$1,
         round_nearest$1,
         abs$1,
         succ$1,
         pred$1,
         pow$1,
         bit_and$1,
         bit_or$1,
         bit_xor$1,
         bit_not$1,
         popcount$2,
         shift_left$1,
         shift_right$1,
         decr$1,
         incr$1,
         of_int32_exn$1,
         to_int32_exn$1,
         of_int64_exn$1,
         to_int64$1,
         of_nativeint_exn$1,
         to_nativeint_exn$1,
         of_float_unchecked$1,
         num_bits$1,
         max_value$1,
         min_value$1,
         lsr$0,
         shift_right_logical$1,
         ceil_pow2$1,
         floor_pow2$1,
         ceil_log2$1,
         floor_log2$1,
         is_pow2$1,
         clz$1,
         ctz$1,
         O$1,
         int63]),
    t_sexp_grammar$2 = Base_Int64[1],
    of_float$2 = Base_Int64[2],
    to_float$2 = Base_Int64[3],
    of_int_exn$2 = Base_Int64[4],
    to_int_exn$2 = Base_Int64[5],
    hash_fold_t$2 = Base_Int64[6],
    hash$2 = Base_Int64[7],
    t_of_sexp$2 = Base_Int64[8],
    sexp_of_t$2 = Base_Int64[9],
    of_string$2 = Base_Int64[10],
    to_string$2 = Base_Int64[11],
    equal$2 = Base_Int64[12],
    compare$2 = Base_Int64[13],
    min$2 = Base_Int64[14],
    max$2 = Base_Int64[15],
    ascending$2 = Base_Int64[16],
    descending$2 = Base_Int64[17],
    between$2 = Base_Int64[18],
    clamp_exn$2 = Base_Int64[19],
    clamp$2 = Base_Int64[20],
    comparator$2 = Base_Int64[21],
    pp$2 = Base_Int64[22],
    hashable$2 = Base_Int64[23],
    is_positive$2 = Base_Int64[24],
    is_non_negative$2 = Base_Int64[25],
    is_negative$2 = Base_Int64[26],
    is_non_positive$2 = Base_Int64[27],
    sign$2 = Base_Int64[28],
    invariant$2 = Base_Int64[29],
    Hex$2 = Base_Int64[30],
    to_string_hum$2 = Base_Int64[31],
    one$2 = Base_Int64[32],
    minus_one$2 = Base_Int64[33],
    rem$2 = Base_Int64[34],
    round$2 = Base_Int64[35],
    round_towards_zero$2 = Base_Int64[36],
    round_down$2 = Base_Int64[37],
    round_up$2 = Base_Int64[38],
    round_nearest$2 = Base_Int64[39],
    succ$2 = Base_Int64[40],
    pred$2 = Base_Int64[41],
    pow$2 = Base_Int64[42],
    bit_and$2 = Base_Int64[43],
    bit_or$2 = Base_Int64[44],
    bit_xor$2 = Base_Int64[45],
    bit_not$2 = Base_Int64[46],
    popcount$3 = Base_Int64[47],
    shift_left$2 = Base_Int64[48],
    shift_right$2 = Base_Int64[49],
    decr$2 = Base_Int64[50],
    incr$2 = Base_Int64[51],
    of_int32_exn$2 = Base_Int64[52],
    to_int32_exn$2 = Base_Int64[53],
    of_int64_exn$2 = Base_Int64[54],
    to_int64$2 = Base_Int64[55],
    of_nativeint_exn$2 = Base_Int64[56],
    to_nativeint_exn$2 = Base_Int64[57],
    of_float_unchecked$2 = Base_Int64[58],
    num_bits$2 = Base_Int64[59],
    max_value$2 = Base_Int64[60],
    min_value$2 = Base_Int64[61],
    shift_right_logical$2 = Base_Int64[62],
    ceil_pow2$2 = Base_Int64[63],
    floor_pow2$2 = Base_Int64[64],
    ceil_log2$2 = Base_Int64[65],
    floor_log2$2 = Base_Int64[66],
    is_pow2$2 = Base_Int64[67],
    clz$2 = Base_Int64[68],
    ctz$2 = Base_Int64[69],
    O$2 = Base_Int64[70],
    symbol$33 = Base_Int64[71],
    lnot$2 = Base_Int64[72],
    abs$2 = Base_Int64[73],
    zero$2 = Base_Int64[74],
    symbol$34 = Base_Int64[75],
    symbol$35 = Base_Int64[76],
    symbol$36 = Base_Int64[77],
    For_int64 =
      Make
       ([0,
         t_sexp_grammar$2,
         of_float$2,
         to_float$2,
         of_int_exn$2,
         to_int_exn$2,
         hash_fold_t$2,
         hash$2,
         t_of_sexp$2,
         sexp_of_t$2,
         of_string$2,
         to_string$2,
         caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         caml_notequal,
         equal$2,
         compare$2,
         min$2,
         max$2,
         ascending$2,
         descending$2,
         between$2,
         clamp_exn$2,
         clamp$2,
         comparator$2,
         pp$2,
         hashable$2,
         is_positive$2,
         is_non_negative$2,
         is_negative$2,
         is_non_positive$2,
         sign$2,
         invariant$2,
         Hex$2,
         to_string_hum$2,
         zero$2,
         one$2,
         minus_one$2,
         caml_int64_add,
         caml_int64_sub,
         caml_int64_mul,
         symbol$33,
         caml_int64_neg,
         caml_int64_neg,
         symbol$35,
         symbol$34,
         caml_int64_div,
         rem$2,
         symbol$36,
         caml_int64_and,
         caml_int64_or,
         caml_int64_xor,
         lnot$2,
         caml_int64_shift_left,
         caml_int64_shift_right,
         round$2,
         round_towards_zero$2,
         round_down$2,
         round_up$2,
         round_nearest$2,
         abs$2,
         succ$2,
         pred$2,
         pow$2,
         bit_and$2,
         bit_or$2,
         bit_xor$2,
         bit_not$2,
         popcount$3,
         shift_left$2,
         shift_right$2,
         decr$2,
         incr$2,
         of_int32_exn$2,
         to_int32_exn$2,
         of_int64_exn$2,
         to_int64$2,
         of_nativeint_exn$2,
         to_nativeint_exn$2,
         of_float_unchecked$2,
         num_bits$2,
         max_value$2,
         min_value$2,
         caml_int64_shift_right_unsigne,
         shift_right_logical$2,
         ceil_pow2$2,
         floor_pow2$2,
         ceil_log2$2,
         floor_log2$2,
         is_pow2$2,
         clz$2,
         ctz$2,
         [0,
          caml_int64_add,
          caml_int64_sub,
          caml_int64_mul,
          caml_int64_div,
          caml_int64_neg,
          O$2[1],
          caml_greaterequal,
          caml_lessequal,
          caml_equal,
          caml_greaterthan,
          caml_lessthan,
          caml_notequal,
          O$2[3],
          caml_int64_neg,
          O$2[4],
          O$2[5],
          O$2[6],
          O$2[7],
          caml_int64_and,
          caml_int64_or,
          caml_int64_xor,
          O$2[2],
          caml_int64_shift_left,
          caml_int64_shift_right,
          caml_int64_shift_right_unsigne],
         int64]),
    t_sexp_grammar$3 = Base_Nativeint[1],
    of_float$3 = Base_Nativeint[2],
    to_float$3 = Base_Nativeint[3],
    of_int_exn$3 = Base_Nativeint[4],
    to_int_exn$3 = Base_Nativeint[5],
    hash_fold_t$3 = Base_Nativeint[6],
    hash$3 = Base_Nativeint[7],
    t_of_sexp$3 = Base_Nativeint[8],
    sexp_of_t$3 = Base_Nativeint[9],
    of_string$3 = Base_Nativeint[10],
    to_string$3 = Base_Nativeint[11],
    symbol$37 = Base_Nativeint[12],
    symbol$38 = Base_Nativeint[13],
    symbol$39 = Base_Nativeint[14],
    symbol$40 = Base_Nativeint[15],
    symbol$41 = Base_Nativeint[16],
    symbol$42 = Base_Nativeint[17],
    equal$3 = Base_Nativeint[18],
    compare$3 = Base_Nativeint[19],
    min$3 = Base_Nativeint[20],
    max$3 = Base_Nativeint[21],
    ascending$3 = Base_Nativeint[22],
    descending$3 = Base_Nativeint[23],
    between$3 = Base_Nativeint[24],
    clamp_exn$3 = Base_Nativeint[25],
    clamp$3 = Base_Nativeint[26],
    comparator$3 = Base_Nativeint[27],
    pp$3 = Base_Nativeint[28],
    hashable$3 = Base_Nativeint[29],
    is_positive$3 = Base_Nativeint[30],
    is_non_negative$3 = Base_Nativeint[31],
    is_negative$3 = Base_Nativeint[32],
    is_non_positive$3 = Base_Nativeint[33],
    sign$3 = Base_Nativeint[34],
    invariant$3 = Base_Nativeint[35],
    Hex$3 = Base_Nativeint[36],
    to_string_hum$3 = Base_Nativeint[37],
    zero$3 = Base_Nativeint[38],
    one$3 = Base_Nativeint[39],
    minus_one$3 = Base_Nativeint[40],
    symbol$43 = Base_Nativeint[41],
    symbol$44 = Base_Nativeint[42],
    symbol$45 = Base_Nativeint[43],
    symbol$46 = Base_Nativeint[44],
    neg$1 = Base_Nativeint[45],
    symbol$47 = Base_Nativeint[46],
    symbol$48 = Base_Nativeint[47],
    symbol$49 = Base_Nativeint[48],
    symbol$50 = Base_Nativeint[49],
    rem$3 = Base_Nativeint[50],
    symbol$51 = Base_Nativeint[51],
    land$1 = Base_Nativeint[52],
    lor$1 = Base_Nativeint[53],
    lxor$1 = Base_Nativeint[54],
    lnot$3 = Base_Nativeint[55],
    lsl$1 = Base_Nativeint[56],
    asr$1 = Base_Nativeint[57],
    round$3 = Base_Nativeint[58],
    round_towards_zero$3 = Base_Nativeint[59],
    round_down$3 = Base_Nativeint[60],
    round_up$3 = Base_Nativeint[61],
    round_nearest$3 = Base_Nativeint[62],
    abs$3 = Base_Nativeint[63],
    succ$3 = Base_Nativeint[64],
    pred$3 = Base_Nativeint[65],
    pow$3 = Base_Nativeint[66],
    bit_and$3 = Base_Nativeint[67],
    bit_or$3 = Base_Nativeint[68],
    bit_xor$3 = Base_Nativeint[69],
    bit_not$3 = Base_Nativeint[70],
    popcount$4 = Base_Nativeint[71],
    shift_left$3 = Base_Nativeint[72],
    shift_right$3 = Base_Nativeint[73],
    decr$3 = Base_Nativeint[74],
    incr$3 = Base_Nativeint[75],
    of_int32_exn$3 = Base_Nativeint[76],
    to_int32_exn$3 = Base_Nativeint[77],
    of_int64_exn$3 = Base_Nativeint[78],
    to_int64$3 = Base_Nativeint[79],
    of_nativeint_exn$3 = Base_Nativeint[80],
    to_nativeint_exn$3 = Base_Nativeint[81],
    of_float_unchecked$3 = Base_Nativeint[82],
    num_bits$3 = Base_Nativeint[83],
    max_value$3 = Base_Nativeint[84],
    min_value$3 = Base_Nativeint[85],
    lsr$1 = Base_Nativeint[86],
    shift_right_logical$3 = Base_Nativeint[87],
    ceil_pow2$3 = Base_Nativeint[88],
    floor_pow2$3 = Base_Nativeint[89],
    ceil_log2$3 = Base_Nativeint[90],
    floor_log2$3 = Base_Nativeint[91],
    is_pow2$3 = Base_Nativeint[92],
    clz$3 = Base_Nativeint[93],
    ctz$3 = Base_Nativeint[94],
    O$3 = Base_Nativeint[95],
    For_nativeint =
      Make
       ([0,
         t_sexp_grammar$3,
         of_float$3,
         to_float$3,
         of_int_exn$3,
         to_int_exn$3,
         hash_fold_t$3,
         hash$3,
         t_of_sexp$3,
         sexp_of_t$3,
         of_string$3,
         to_string$3,
         symbol$37,
         symbol$38,
         symbol$39,
         symbol$40,
         symbol$41,
         symbol$42,
         equal$3,
         compare$3,
         min$3,
         max$3,
         ascending$3,
         descending$3,
         between$3,
         clamp_exn$3,
         clamp$3,
         comparator$3,
         pp$3,
         hashable$3,
         is_positive$3,
         is_non_negative$3,
         is_negative$3,
         is_non_positive$3,
         sign$3,
         invariant$3,
         Hex$3,
         to_string_hum$3,
         zero$3,
         one$3,
         minus_one$3,
         symbol$43,
         symbol$44,
         symbol$45,
         symbol$46,
         neg$1,
         symbol$47,
         symbol$48,
         symbol$49,
         symbol$50,
         rem$3,
         symbol$51,
         land$1,
         lor$1,
         lxor$1,
         lnot$3,
         lsl$1,
         asr$1,
         round$3,
         round_towards_zero$3,
         round_down$3,
         round_up$3,
         round_nearest$3,
         abs$3,
         succ$3,
         pred$3,
         pow$3,
         bit_and$3,
         bit_or$3,
         bit_xor$3,
         bit_not$3,
         popcount$4,
         shift_left$3,
         shift_right$3,
         decr$3,
         incr$3,
         of_int32_exn$3,
         to_int32_exn$3,
         of_int64_exn$3,
         to_int64$3,
         of_nativeint_exn$3,
         to_nativeint_exn$3,
         of_float_unchecked$3,
         num_bits$3,
         max_value$3,
         min_value$3,
         lsr$1,
         shift_right_logical$3,
         ceil_pow2$3,
         floor_pow2$3,
         ceil_log2$3,
         floor_log2$3,
         is_pow2$3,
         clz$3,
         ctz$3,
         O$3,
         nativeint]),
    int$1 = For_int[1],
    int32$0 = For_int32[1],
    int63$0 = For_int63[1],
    int64$1 = For_int64[1],
    nativeint$0 = For_nativeint[1];
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   var
    Splittable_random =
      [0,
       [0, create, of_int, perturb, copy, split],
       bool,
       int$0,
       int32,
       int63,
       int64,
       nativeint,
       float$0,
       unit_float,
       [0, int$1, int32$0, int63$0, int64$1, nativeint$0]];
   runtime.caml_register_global(40, Splittable_random, "Splittable_random");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzcGxpdHRhYmxlX3JhbmRvbS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiaW50NjQkMCIsImdvbGRlbl9nYW1tYSIsInBvcGNvdW50Iiwib2ZfaW50Iiwic2VlZCIsImNvcHkiLCJvZGRfZ2FtbWEiLCJtaXhfYml0cyIsInoiLCJuIiwibWl4NjQiLCJ6JDAiLCJ6JDEiLCJuZXh0X3NlZWQiLCJ0IiwibmV4dCIsIm9mX3NlZWRfYW5kX2dhbW1hIiwiZ2FtbWEiLCJzZWVkJDAiLCJyYW5kb21faW50NjQiLCJyYW5kb21fc3RhdGUiLCJjcmVhdGUiLCJzcGxpdCIsIm5leHRfaW50NjQiLCJwZXJ0dXJiIiwic2FsdCIsImJvb2wiLCJzdGF0ZSIsIngiLCJpbnQ2NCIsImxvIiwiaGkiLCJyZW1haW5kZXJfbWF4aW11bSIsImRyYXckMCIsInJlbWFpbmRlciIsImRyYXdfbWF4aW11bSIsImRyYXciLCJpbnQkMCIsImxvJDAiLCJoaSQwIiwiaW50MzIiLCJuYXRpdmVpbnQiLCJpbnQ2MyIsImRvdWJsZV91bHAiLCJ1bml0X2Zsb2F0X2Zyb21faW50NjQiLCJ1bml0X2Zsb2F0IiwiZmxvYXQkMCIsInJhbmdlIiwibWlkIiwiZiIsImJpdHNfdG9fcmVwcmVzZW50IiwidCQwIiwibG9nX3VuaWZvcm0iLCJtaW5fYml0cyIsIm1heF9iaXRzIiwiYml0cyIsInRfc2V4cF9ncmFtbWFyIiwib2ZfZmxvYXQiLCJ0b19mbG9hdCIsIm9mX2ludF9leG4iLCJ0b19pbnRfZXhuIiwiaGFzaF9mb2xkX3QiLCJoYXNoIiwidF9vZl9zZXhwIiwic2V4cF9vZl90Iiwib2Zfc3RyaW5nIiwidG9fc3RyaW5nIiwiZXF1YWwiLCJjb21wYXJlIiwibWluIiwibWF4IiwiYXNjZW5kaW5nIiwiZGVzY2VuZGluZyIsImJldHdlZW4iLCJjbGFtcF9leG4iLCJjbGFtcCIsImNvbXBhcmF0b3IiLCJwcCIsImhhc2hhYmxlIiwiaXNfcG9zaXRpdmUiLCJpc19ub25fbmVnYXRpdmUiLCJpc19uZWdhdGl2ZSIsImlzX25vbl9wb3NpdGl2ZSIsInNpZ24iLCJpbnZhcmlhbnQiLCJ0b19zdHJpbmdfaHVtIiwib25lIiwibWludXNfb25lIiwicmVtIiwicm91bmQiLCJyb3VuZF90b3dhcmRzX3plcm8iLCJyb3VuZF9kb3duIiwicm91bmRfdXAiLCJyb3VuZF9uZWFyZXN0Iiwic3VjYyIsInByZWQiLCJwb3ciLCJiaXRfYW5kIiwiYml0X29yIiwiYml0X3hvciIsImJpdF9ub3QiLCJwb3Bjb3VudCQwIiwic2hpZnRfbGVmdCIsInNoaWZ0X3JpZ2h0IiwiZGVjciIsImluY3IiLCJvZl9pbnQzMl9leG4iLCJ0b19pbnQzMl9leG4iLCJvZl9pbnQ2NF9leG4iLCJ0b19pbnQ2NCIsIm9mX25hdGl2ZWludF9leG4iLCJ0b19uYXRpdmVpbnRfZXhuIiwib2ZfZmxvYXRfdW5jaGVja2VkIiwibnVtX2JpdHMiLCJtYXhfdmFsdWUiLCJtaW5fdmFsdWUiLCJzaGlmdF9yaWdodF9sb2dpY2FsIiwiY2VpbF9wb3cyIiwiZmxvb3JfcG93MiIsImNlaWxfbG9nMiIsImZsb29yX2xvZzIiLCJpc19wb3cyIiwiY2x6IiwiY3R6Iiwic3ltYm9sIiwibG5vdCIsImFicyIsInplcm8iLCJzeW1ib2wkMCIsInN5bWJvbCQxIiwic3ltYm9sJDIiLCJ0X3NleHBfZ3JhbW1hciQwIiwib2ZfZmxvYXQkMCIsInRvX2Zsb2F0JDAiLCJvZl9pbnRfZXhuJDAiLCJ0b19pbnRfZXhuJDAiLCJoYXNoX2ZvbGRfdCQwIiwiaGFzaCQwIiwidF9vZl9zZXhwJDAiLCJzZXhwX29mX3QkMCIsIm9mX3N0cmluZyQwIiwidG9fc3RyaW5nJDAiLCJzeW1ib2wkMyIsInN5bWJvbCQ0Iiwic3ltYm9sJDUiLCJzeW1ib2wkNiIsInN5bWJvbCQ3Iiwic3ltYm9sJDgiLCJlcXVhbCQwIiwiY29tcGFyZSQwIiwibWluJDAiLCJtYXgkMCIsImFzY2VuZGluZyQwIiwiZGVzY2VuZGluZyQwIiwiYmV0d2VlbiQwIiwiY2xhbXBfZXhuJDAiLCJjbGFtcCQwIiwiY29tcGFyYXRvciQwIiwicHAkMCIsImhhc2hhYmxlJDAiLCJpc19wb3NpdGl2ZSQwIiwiaXNfbm9uX25lZ2F0aXZlJDAiLCJpc19uZWdhdGl2ZSQwIiwiaXNfbm9uX3Bvc2l0aXZlJDAiLCJzaWduJDAiLCJpbnZhcmlhbnQkMCIsInRvX3N0cmluZ19odW0kMCIsInplcm8kMCIsIm9uZSQwIiwibWludXNfb25lJDAiLCJzeW1ib2wkOSIsInN5bWJvbCQxMCIsInN5bWJvbCQxMSIsInN5bWJvbCQxMiIsIm5lZyIsInN5bWJvbCQxMyIsInN5bWJvbCQxNCIsInN5bWJvbCQxNSIsInN5bWJvbCQxNiIsInJlbSQwIiwic3ltYm9sJDE3IiwibGFuZCIsImxvciIsImx4b3IiLCJsbm90JDAiLCJsc2wiLCJhc3IiLCJyb3VuZCQwIiwicm91bmRfdG93YXJkc196ZXJvJDAiLCJyb3VuZF9kb3duJDAiLCJyb3VuZF91cCQwIiwicm91bmRfbmVhcmVzdCQwIiwiYWJzJDAiLCJzdWNjJDAiLCJwcmVkJDAiLCJwb3ckMCIsImJpdF9hbmQkMCIsImJpdF9vciQwIiwiYml0X3hvciQwIiwiYml0X25vdCQwIiwicG9wY291bnQkMSIsInNoaWZ0X2xlZnQkMCIsInNoaWZ0X3JpZ2h0JDAiLCJkZWNyJDAiLCJpbmNyJDAiLCJvZl9pbnQzMl9leG4kMCIsInRvX2ludDMyX2V4biQwIiwib2ZfaW50NjRfZXhuJDAiLCJ0b19pbnQ2NCQwIiwib2ZfbmF0aXZlaW50X2V4biQwIiwidG9fbmF0aXZlaW50X2V4biQwIiwib2ZfZmxvYXRfdW5jaGVja2VkJDAiLCJudW1fYml0cyQwIiwibWF4X3ZhbHVlJDAiLCJtaW5fdmFsdWUkMCIsImxzciIsInNoaWZ0X3JpZ2h0X2xvZ2ljYWwkMCIsImNlaWxfcG93MiQwIiwiZmxvb3JfcG93MiQwIiwiY2VpbF9sb2cyJDAiLCJmbG9vcl9sb2cyJDAiLCJpc19wb3cyJDAiLCJjbHokMCIsImN0eiQwIiwidF9zZXhwX2dyYW1tYXIkMiIsIm9mX2Zsb2F0JDIiLCJ0b19mbG9hdCQyIiwib2ZfaW50X2V4biQyIiwidG9faW50X2V4biQyIiwiaGFzaF9mb2xkX3QkMiIsImhhc2gkMiIsInRfb2Zfc2V4cCQyIiwic2V4cF9vZl90JDIiLCJvZl9zdHJpbmckMiIsInRvX3N0cmluZyQyIiwiZXF1YWwkMiIsImNvbXBhcmUkMiIsIm1pbiQyIiwibWF4JDIiLCJhc2NlbmRpbmckMiIsImRlc2NlbmRpbmckMiIsImJldHdlZW4kMiIsImNsYW1wX2V4biQyIiwiY2xhbXAkMiIsImNvbXBhcmF0b3IkMiIsInBwJDIiLCJoYXNoYWJsZSQyIiwiaXNfcG9zaXRpdmUkMiIsImlzX25vbl9uZWdhdGl2ZSQyIiwiaXNfbmVnYXRpdmUkMiIsImlzX25vbl9wb3NpdGl2ZSQyIiwic2lnbiQyIiwiaW52YXJpYW50JDIiLCJ0b19zdHJpbmdfaHVtJDIiLCJvbmUkMiIsIm1pbnVzX29uZSQyIiwicmVtJDIiLCJyb3VuZCQyIiwicm91bmRfdG93YXJkc196ZXJvJDIiLCJyb3VuZF9kb3duJDIiLCJyb3VuZF91cCQyIiwicm91bmRfbmVhcmVzdCQyIiwic3VjYyQyIiwicHJlZCQyIiwicG93JDIiLCJiaXRfYW5kJDIiLCJiaXRfb3IkMiIsImJpdF94b3IkMiIsImJpdF9ub3QkMiIsInBvcGNvdW50JDMiLCJzaGlmdF9sZWZ0JDIiLCJzaGlmdF9yaWdodCQyIiwiZGVjciQyIiwiaW5jciQyIiwib2ZfaW50MzJfZXhuJDIiLCJ0b19pbnQzMl9leG4kMiIsIm9mX2ludDY0X2V4biQyIiwidG9faW50NjQkMiIsIm9mX25hdGl2ZWludF9leG4kMiIsInRvX25hdGl2ZWludF9leG4kMiIsIm9mX2Zsb2F0X3VuY2hlY2tlZCQyIiwibnVtX2JpdHMkMiIsIm1heF92YWx1ZSQyIiwibWluX3ZhbHVlJDIiLCJzaGlmdF9yaWdodF9sb2dpY2FsJDIiLCJjZWlsX3BvdzIkMiIsImZsb29yX3BvdzIkMiIsImNlaWxfbG9nMiQyIiwiZmxvb3JfbG9nMiQyIiwiaXNfcG93MiQyIiwiY2x6JDIiLCJjdHokMiIsInN5bWJvbCQzMyIsImxub3QkMiIsImFicyQyIiwiemVybyQyIiwic3ltYm9sJDM0Iiwic3ltYm9sJDM1Iiwic3ltYm9sJDM2IiwidF9zZXhwX2dyYW1tYXIkMyIsIm9mX2Zsb2F0JDMiLCJ0b19mbG9hdCQzIiwib2ZfaW50X2V4biQzIiwidG9faW50X2V4biQzIiwiaGFzaF9mb2xkX3QkMyIsImhhc2gkMyIsInRfb2Zfc2V4cCQzIiwic2V4cF9vZl90JDMiLCJvZl9zdHJpbmckMyIsInRvX3N0cmluZyQzIiwic3ltYm9sJDM3Iiwic3ltYm9sJDM4Iiwic3ltYm9sJDM5Iiwic3ltYm9sJDQwIiwic3ltYm9sJDQxIiwic3ltYm9sJDQyIiwiZXF1YWwkMyIsImNvbXBhcmUkMyIsIm1pbiQzIiwibWF4JDMiLCJhc2NlbmRpbmckMyIsImRlc2NlbmRpbmckMyIsImJldHdlZW4kMyIsImNsYW1wX2V4biQzIiwiY2xhbXAkMyIsImNvbXBhcmF0b3IkMyIsInBwJDMiLCJoYXNoYWJsZSQzIiwiaXNfcG9zaXRpdmUkMyIsImlzX25vbl9uZWdhdGl2ZSQzIiwiaXNfbmVnYXRpdmUkMyIsImlzX25vbl9wb3NpdGl2ZSQzIiwic2lnbiQzIiwiaW52YXJpYW50JDMiLCJ0b19zdHJpbmdfaHVtJDMiLCJ6ZXJvJDMiLCJvbmUkMyIsIm1pbnVzX29uZSQzIiwic3ltYm9sJDQzIiwic3ltYm9sJDQ0Iiwic3ltYm9sJDQ1Iiwic3ltYm9sJDQ2IiwibmVnJDEiLCJzeW1ib2wkNDciLCJzeW1ib2wkNDgiLCJzeW1ib2wkNDkiLCJzeW1ib2wkNTAiLCJyZW0kMyIsInN5bWJvbCQ1MSIsImxhbmQkMSIsImxvciQxIiwibHhvciQxIiwibG5vdCQzIiwibHNsJDEiLCJhc3IkMSIsInJvdW5kJDMiLCJyb3VuZF90b3dhcmRzX3plcm8kMyIsInJvdW5kX2Rvd24kMyIsInJvdW5kX3VwJDMiLCJyb3VuZF9uZWFyZXN0JDMiLCJhYnMkMyIsInN1Y2MkMyIsInByZWQkMyIsInBvdyQzIiwiYml0X2FuZCQzIiwiYml0X29yJDMiLCJiaXRfeG9yJDMiLCJiaXRfbm90JDMiLCJwb3Bjb3VudCQ0Iiwic2hpZnRfbGVmdCQzIiwic2hpZnRfcmlnaHQkMyIsImRlY3IkMyIsImluY3IkMyIsIm9mX2ludDMyX2V4biQzIiwidG9faW50MzJfZXhuJDMiLCJvZl9pbnQ2NF9leG4kMyIsInRvX2ludDY0JDMiLCJvZl9uYXRpdmVpbnRfZXhuJDMiLCJ0b19uYXRpdmVpbnRfZXhuJDMiLCJvZl9mbG9hdF91bmNoZWNrZWQkMyIsIm51bV9iaXRzJDMiLCJtYXhfdmFsdWUkMyIsIm1pbl92YWx1ZSQzIiwibHNyJDEiLCJzaGlmdF9yaWdodF9sb2dpY2FsJDMiLCJjZWlsX3BvdzIkMyIsImZsb29yX3BvdzIkMyIsImNlaWxfbG9nMiQzIiwiZmxvb3JfbG9nMiQzIiwiaXNfcG93MiQzIiwiY2x6JDMiLCJjdHokMyIsImludCQxIiwiaW50MzIkMCIsImludDYzJDAiLCJpbnQ2NCQxIiwibmF0aXZlaW50JDAiXSwic291cmNlcyI6WyIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL3NwbGl0dGFibGVfcmFuZG9tL3NwbGl0dGFibGVfcmFuZG9tLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9vY2FtbC9pbnQ2NC5tbGkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7SUFzUk1BO0lBbFBBQzs7Ozs7Ozs7Ozs7Ozs7OztJQVRGQzs7Ozs7Ozs7Ozs7O1lBV0VDLE9BQU9DLE1BQ1QsV0FBYyxvQkFETEEsT0FGUEgsY0FLRDtZQUVDSTtRQUFPRCxpQkFBT0U7SUFBYyxXQUFyQkYsTUFBT0U7O1lBRWRDLFNBQVNDLEdBQUVDO0lBQ2IsT0FBQSxlQURXRCxHQUNKLCtCQURJQSxHQUFFQztHQUNHO1lBRWRDLE1BQU1GO0lBQ1I7S0FBSUcsTUFBSSxlQUpOSixTQUdNQztLQUVKSSxNQUFJLGVBTE5MLFNBSUVJO0lBRUosT0FORUosU0FL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U0FNQUM7U0FNQUM7OzZCOzZCOzs7d0I7OzZCOzZCOzZCOzZCOzZCOzZCOzt3Qjs7Ozs7NkI7NkI7NkI7OzZCOzZCOzZCO1NBakhFdEY7SUFySEY4RjtJQUlRQztJQUFBQztJQUNBQztJQUFBQztJQUNBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUNBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUNBQzs7SUFJUkM7SUFJQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFHQUM7SUFJQUM7SUFDQUM7SUFzQkFDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBR0FDO0lBR0FDO0lBR0FDO0lBR0FDO0lBR0FDO0lBR0FDO0lBR0FDO0lBSVFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBSVJDO0lBSUFDO0lBQ0FDO0lBTUFDO0lBTUFDO0lBRUFDO0lBQ0FDO0lBQ0FDO0lBR0FDO0lBT0FDO0lBR0FDO0lBSUFDO0lBQ0FDO0lBSUFDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBTUFDO0lBbURBQztJQUdBQztJQUdBQztJQUdBQztJQUlBQztJQUlBQztJQUlBQztJQUdBQztJQUdBQztJQUdBQztJQU1BQztJQU1BQzs7Ozs7U0F0T0E1RjtTQUlRQztTQUFBQztTQUNBQztTQUFBQztTQUNBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUNBQztTQUFBQztTQUFBQztTQUFBQztTQUFBQztTQUNBQzs7U0FJUkM7U0FJQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FHQUM7U0FJQUM7U0FDQUM7U0FzQkFDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBR0FDO1NBR0FDO1NBR0FDO1NBR0FDO1NBR0FDO1NBR0FDO1NBR0FDO1NBSVFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBSVJDO1NBSUFDO1NBQ0FDO1NBTUFDO1NBTUFDO1NBRUFDO1NBQ0FDO1NBQ0FDO1NBR0FDO1NBT0FDO1NBR0FDO1NBSUFDO1NBQ0FDO1NBSUFDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBQ0FDO1NBTUFDO1NBbURBQztTQUdBQztTQUdBQztTQUdBQztTQUlBQztTQUlBQztTQUlBQztTQUdBQztTQUdBQztTQUdBQztTQU1BQztTQU1BQzs7U0EzR0V2TDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0FZQUU7SUF2SUZzTDtJQUlRQztJQUFBQztJQUNBQztJQUFBQztJQUNBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUNBQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQUNBQzs7SUFJUkM7SUFLQUM7SUFDQUM7SUFvQ0FDO0lBeUJRQztJQUFBQztJQUFBQztJQUFBQztJQUFBQztJQVFSQztJQUNBQztJQU1BQztJQU1BQztJQUVBQztJQUNBQztJQUNBQztJQUdBQztJQU9BQztJQUdBQztJQUlBQztJQUNBQztJQUlBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQU1BQztJQW1EQUM7SUFHQUM7SUFHQUM7SUFPQUM7SUFJQUM7SUFJQUM7SUFHQUM7SUFHQUM7SUFHQUM7SUFNQUM7SUFNQUM7O0lDMVJBQztJQVVBQztJQUNBQztJQUVBQztJQUNBQztJQUNBQztJQUNBQzs7OztTRG9DQTFFO1NBSVFDO1NBQUFDO1NBQ0FDO1NBQUFDO1NBQ0FDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDOzs7Ozs7O1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQ0FDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQ0FDOztTQUlSQztTQ25EQTBDO1NEd0RBekM7U0FDQUM7Ozs7U0N0RUFxQzs7O1NBZUFLO1NBREFEOztTRDRGQXhDO1NDMUZBMEM7Ozs7U0FOQUw7OztTRHlIUXBDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NDeEhSaUM7U0RnSUFoQztTQUNBQztTQU1BQztTQU1BQztTQUVBQztTQUNBQztTQUNBQztTQUdBQztTQU9BQztTQUdBQztTQUlBQztTQUNBQztTQUlBQztTQUNBQztTQUNBQztTQUNBQztTQUNBQztTQUNBQztTQU1BQztTQW1EQUM7U0FHQUM7U0FHQUM7O1NBT0FDO1NBSUFDO1NBSUFDO1NBR0FDO1NBR0FDO1NBR0FDO1NBTUFDO1NBTUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0EvSUV0UTtJQXZGRjhRO0lBSVFDO0lBQUFDO0lBQ0FDO0lBQUFDO0lBQ0FDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQ0FDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQUFDO0lBQ0FDOztJQUlSQztJQUlBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUdBQztJQUlBQztJQUNBQztJQXNCQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFHQUM7SUFHQUM7SUFHQUM7SUFHQUM7SUFHQUM7SUFHQUM7SUFHQUM7SUFJUUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFBQUM7SUFJUkM7SUFJQUM7SUFDQUM7SUFNQUM7SUFNQUM7SUFFQUM7SUFDQUM7SUFDQUM7SUFHQUM7SUFPQUM7SUFHQUM7SUFJQUM7SUFDQUM7SUFJQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFNQUM7SUFtREFDO0lBR0FDO0lBR0FDO0lBR0FDO0lBSUFDO0lBSUFDO0lBSUFDO0lBR0FDO0lBR0FDO0lBR0FDO0lBTUFDO0lBTUFDOzs7OztTQXRPQTVGO1NBSVFDO1NBQUFDO1NBQ0FDO1NBQUFDO1NBQ0FDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQ0FDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQUFDO1NBQ0FDOztTQUlSQztTQUlBQztTQUNBQztTQUNBQztTQUNBQztTQUNBQztTQUNBQztTQUdBQztTQUlBQztTQUNBQztTQXNCQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FHQUM7U0FHQUM7U0FHQUM7U0FHQUM7U0FHQUM7U0FHQUM7U0FHQUM7U0FJUUM7U0FBQUM7U0FBQUM7U0FBQUM7U0FBQUM7U0FJUkM7U0FJQUM7U0FDQUM7U0FNQUM7U0FNQUM7U0FFQUM7U0FDQUM7U0FDQUM7U0FHQUM7U0FPQUM7U0FHQUM7U0FJQUM7U0FDQUM7U0FJQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FDQUM7U0FNQUM7U0FtREFDO1NBR0FDO1NBR0FDO1NBR0FDO1NBSUFDO1NBSUFDO1NBSUFDO1NBR0FDO1NBR0FDO1NBR0FDO1NBTUFDO1NBTUFDOztTQXJHRTlWO0lBbUtFK1Y7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7Ozs7O1dBM1FBdlgsUUF4REFsQixRQXNFQXFCLFNBakVBbkIsTUF3REFpQjtPQWVGSTtPQW9FQVc7T0FNQUc7T0FZQUU7T0FoREFiO09BMENBWTtPQStDQUs7T0FYQUQ7V0ErSEUyVixPQUNBQyxTQUNBQyxTQUNBQyxTQUNBQzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiogVGhpcyBtb2R1bGUgaW1wbGVtZW50cyBcIkZhc3QgU3BsaXR0YWJsZSBQc2V1ZG9yYW5kb20gTnVtYmVyIEdlbmVyYXRvcnNcIiBieSBTdGVlbGUgZXQuXG4gICAgYWwuICgxKS4gIFRoZSBwYXBlcidzIGFsZ29yaXRobSBwcm92aWRlcyBkZWNlbnQgcmFuZG9tbmVzcyBmb3IgbW9zdCBwdXJwb3NlcywgYnV0XG4gICAgc2FjcmlmaWNlcyBjcnlwdG9ncmFwaGljLXF1YWxpdHkgcmFuZG9tbmVzcyBpbiBmYXZvciBvZiBwZXJmb3JtYW5jZS4gIFRoZSBvcmlnaW5hbFxuICAgIGltcGxlbWVudGF0aW9uIHdhcyB0ZXN0ZWQgd2l0aCBEaWVIYXJkZXIgYW5kIEJpZ0NydXNoOyBzZWUgdGhlIHBhcGVyIGZvciBkZXRhaWxzLlxuXG4gICAgT3VyIGltcGxlbWVudGF0aW9uIGlzIGEgcG9ydCBmcm9tIEphdmEgdG8gT0NhbWwgb2YgdGhlIHBhcGVyJ3MgYWxnb3JpdGhtLiAgT3RoZXIgdGhhblxuICAgIHRoZSBjaG9pY2Ugb2YgaW5pdGlhbCBzZWVkIGZvciBbY3JlYXRlXSwgb3VyIHBvcnQgc2hvdWxkIGJlIGZhaXRoZnVsLiAgV2UgaGF2ZSBub3RcbiAgICByZS1ydW4gdGhlIERpZUhhcmRlciBvciBCaWdDcnVzaCB0ZXN0cyBvbiBvdXIgaW1wbGVtZW50YXRpb24uICBPdXIgcG9ydCBpcyBhbHNvIG5vdCBhc1xuICAgIHBlcmZvcm1hbnQgYXMgdGhlIG9yaWdpbmFsOyB0d28gZmFjdG9ycyB0aGF0IGh1cnQgdXMgYXJlIGJveGVkIFtpbnQ2NF0gdmFsdWVzIGFuZCBsYWNrXG4gICAgb2YgYSBQT1BDTlQgcHJpbWl0aXZlLlxuXG4gICAgKDEpIGh0dHA6Ly8yMDE0LnNwbGFzaGNvbi5vcmcvZXZlbnQvb29wc2xhMjAxNC1mYXN0LXNwbGl0dGFibGUtcHNldWRvcmFuZG9tLW51bWJlci1nZW5lcmF0b3JzXG4gICAgKGFsc28gbWlycm9yZWQgYXQgaHR0cDovL2dlZS5jcy5vc3dlZ28uZWR1L2RsL3BhcGVycy9vb3BzbGExNC5wZGYpXG5cbiAgICBCZXdhcmUgd2hlbiBpbXBsZW1lbnRpbmcgdGhpcyBpbnRlcmZhY2U7IGl0IGlzIGVhc3kgdG8gaW1wbGVtZW50IGEgW3NwbGl0XSBvcGVyYXRpb25cbiAgICB3aG9zZSBvdXRwdXQgaXMgbm90IGFzIFwiaW5kZXBlbmRlbnRcIiBhcyBpdCBzZWVtcyAoMikuICBUaGlzIGJ1ZyBjYXVzZWQgcHJvYmxlbXMgZm9yXG4gICAgSGFza2VsbCdzIFF1aWNrY2hlY2sgbGlicmFyeSBmb3IgYSBsb25nIHRpbWUuXG5cbiAgICAoMikgU2NoYWF0aHVuLCBcIkV2YWx1YXRpb24gb2Ygc3BsaXR0YWJsZSBwc2V1ZG8tcmFuZG9tIGdlbmVyYXRvcnNcIiwgSkZQIDIwMTUuXG4gICAgaHR0cDovL3d3dy5oZy5zY2hhYXRodW4ubmV0L3Jlc2VhcmNoL1BhcGVycy9oZ3MyMDE1amZwLnBkZlxuKilcblxub3BlbiEgQmFzZVxub3BlbiAgSW50NjQuT1xuXG5sZXQgaXNfb2RkIHggPSB4IGxvciAxTCA9IHhcblxubGV0IHBvcGNvdW50ID0gSW50NjQucG9wY291bnRcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG5cbiAgdHlwZSB0ID1cbiAgICB7IG11dGFibGUgc2VlZCA6IGludDY0XG4gICAgOyBvZGRfZ2FtbWEgICAgOiBpbnQ2NFxuICAgIH1cblxuICBsZXQgZ29sZGVuX2dhbW1hID0gMHg5ZTM3Xzc5YjlfN2Y0YV83YzE1TFxuXG4gIGxldCBvZl9pbnQgc2VlZCA9XG4gICAgeyBzZWVkICAgICAgPSBJbnQ2NC5vZl9pbnQgc2VlZFxuICAgIDsgb2RkX2dhbW1hID0gZ29sZGVuX2dhbW1hXG4gICAgfVxuXG4gIGxldCBjb3B5IHsgc2VlZCA7IG9kZF9nYW1tYSB9ID0geyBzZWVkIDsgb2RkX2dhbW1hIH1cblxuICBsZXQgbWl4X2JpdHMgeiBuID1cbiAgICB6IGx4b3IgKHogbHNyIG4pXG5cbiAgbGV0IG1peDY0IHogPVxuICAgIGxldCB6ID0gKG1peF9iaXRzIHogMzMpICogMHhmZjUxX2FmZDdfZWQ1NV84Y2NkTCBpblxuICAgIGxldCB6ID0gKG1peF9iaXRzIHogMzMpICogMHhjNGNlX2I5ZmVfMWE4NV9lYzUzTCBpblxuICAgIG1peF9iaXRzIHogMzNcblxuICBsZXQgbWl4NjRfdmFyaWFudDEzIHogPVxuICAgIGxldCB6ID0gKG1peF9iaXRzIHogMzApICogMHhiZjU4XzQ3NmRfMWNlNF9lNWI5TCBpblxuICAgIGxldCB6ID0gKG1peF9iaXRzIHogMjcpICogMHg5NGQwXzQ5YmJfMTMzMV8xMWViTCBpblxuICAgIG1peF9iaXRzIHogMzFcblxuICBsZXQgbWl4X29kZF9nYW1tYSB6ID1cbiAgICBsZXQgeiA9IChtaXg2NF92YXJpYW50MTMgeikgbG9yIDFMIGluXG4gICAgbGV0IG4gPSBwb3Bjb3VudCAoeiBseG9yICh6IGxzciAxKSkgaW5cbiAgICAoKiBUaGUgb3JpZ2luYWwgcGFwZXIgdXNlcyBbPj1dIGluIHRoZSBjb25kaXRpb25hbCBpbW1lZGlhdGVseSBiZWxvdzsgaG93ZXZlciB0aGlzIGlzXG4gICAgICAgYSB0eXBvLCBhbmQgd2UgY29ycmVjdCBpdCBieSB1c2luZyBbPF0uIFRoaXMgd2FzIGZpeGVkIGluIHJlc3BvbnNlIHRvIFsxXSBhbmQgWzJdLlxuXG4gICAgICAgWzFdIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5lc3RyZWV0L3NwbGl0dGFibGVfcmFuZG9tL2lzc3Vlcy8xXG4gICAgICAgWzJdIGh0dHA6Ly93d3cucGNnLXJhbmRvbS5vcmcvcG9zdHMvYnVncy1pbi1zcGxpdG1peC5odG1sXG4gICAgKilcbiAgICBpZiBJbnQuKCA8ICkgbiAyNFxuICAgIHRoZW4geiBseG9yIDB4YWFhYV9hYWFhX2FhYWFfYWFhYUxcbiAgICBlbHNlIHpcblxuICBsZXQldGVzdF91bml0IFwib2RkIGdhbW1hXCIgPVxuICAgIGZvciBpbnB1dCA9IC0xXzAwMF8wMDAgdG8gMV8wMDBfMDAwIGRvXG4gICAgICBsZXQgb3V0cHV0ID0gbWl4X29kZF9nYW1tYSAoSW50NjQub2ZfaW50IGlucHV0KSBpblxuICAgICAgaWYgbm90IChpc19vZGQgb3V0cHV0KSB0aGVuXG4gICAgICAgIEVycm9yLnJhaXNlX3MgWyVtZXNzYWdlXG4gICAgICAgICAgXCJnYW1tYSB2YWx1ZSBpcyBub3Qgb2RkXCJcbiAgICAgICAgICAgIChpbnB1dCAgOiBpbnQpXG4gICAgICAgICAgICAob3V0cHV0IDogaW50NjQpXVxuICAgIGRvbmVcblxuICBsZXQgbmV4dF9zZWVkIHQgPVxuICAgIGxldCBuZXh0ID0gdC5zZWVkICsgdC5vZGRfZ2FtbWEgaW5cbiAgICB0LnNlZWQgPC0gbmV4dDtcbiAgICBuZXh0XG5cbiAgbGV0IG9mX3NlZWRfYW5kX2dhbW1hIH5zZWVkIH5nYW1tYSA9XG4gICAgbGV0IHNlZWQgICAgICA9IG1peDY0ICAgICAgICAgc2VlZCAgaW5cbiAgICBsZXQgb2RkX2dhbW1hID0gbWl4X29kZF9nYW1tYSBnYW1tYSBpblxuICAgIHsgc2VlZDsgb2RkX2dhbW1hIH1cblxuICBsZXQgcmFuZG9tX2ludDY0IHJhbmRvbV9zdGF0ZSA9XG4gICAgUmFuZG9tLlN0YXRlLmludDY0X2luY2wgcmFuZG9tX3N0YXRlIEludDY0Lm1pbl92YWx1ZSBJbnQ2NC5tYXhfdmFsdWVcblxuICBsZXQgY3JlYXRlIHJhbmRvbV9zdGF0ZSA9XG4gICAgbGV0IHNlZWQgID0gcmFuZG9tX2ludDY0IHJhbmRvbV9zdGF0ZSBpblxuICAgIGxldCBnYW1tYSA9IHJhbmRvbV9pbnQ2NCByYW5kb21fc3RhdGUgaW5cbiAgICBvZl9zZWVkX2FuZF9nYW1tYSB+c2VlZCB+Z2FtbWFcblxuICBsZXQgc3BsaXQgdCA9XG4gICAgbGV0IHNlZWQgID0gbmV4dF9zZWVkIHQgaW5cbiAgICBsZXQgZ2FtbWEgPSBuZXh0X3NlZWQgdCBpblxuICAgIG9mX3NlZWRfYW5kX2dhbW1hIH5zZWVkIH5nYW1tYVxuXG4gIGxldCBuZXh0X2ludDY0IHQgPSBtaXg2NCAobmV4dF9zZWVkIHQpXG5cbiAgKCogW3BlcnR1cmJdIGlzIG5vdCBmcm9tIGFueSBleHRlcm5hbCBzb3VyY2UsIGJ1dCBwcm92aWRlcyBhIHdheSB0byBtaXggaW4gZXh0ZXJuYWxcbiAgICAgZW50cm9weSB3aXRoIGEgcHNldWRvLXJhbmRvbSBzdGF0ZS4gKilcbiAgbGV0IHBlcnR1cmIgdCBzYWx0ID1cbiAgICBsZXQgbmV4dCA9IHQuc2VlZCArIG1peDY0IChJbnQ2NC5vZl9pbnQgc2FsdCkgaW5cbiAgICB0LnNlZWQgPC0gbmV4dFxuXG5lbmRcblxubGV0IGJvb2wgc3RhdGUgPSBpc19vZGQgKFN0YXRlLm5leHRfaW50NjQgc3RhdGUpXG5cbigqIFdlIGFidXNlIHRlcm1pbm9sb2d5IGFuZCByZWZlciB0byBpbmRpdmlkdWFsIHZhbHVlcyBhcyBiaWFzZWQgb3IgdW5iaWFzZWQuICBNb3JlXG4gICBwcm9wZXJseSwgd2hhdCBpcyB1bmJpYXNlZCBpcyB0aGUgc2FtcGxlciB0aGF0IHJlc3VsdHMgaWYgd2Uga2VlcCBvbmx5IHRoZXNlIFwidW5iaWFzZWRcIlxuICAgdmFsdWVzLiAqKVxubGV0IHJlbWFpbmRlcl9pc191bmJpYXNlZFxuICAgICAgfmRyYXdcbiAgICAgIH5yZW1haW5kZXJcbiAgICAgIH5kcmF3X21heGltdW1cbiAgICAgIH5yZW1haW5kZXJfbWF4aW11bVxuICA9XG4gIGxldCBvcGVuIEludDY0Lk8gaW5cbiAgZHJhdyAtIHJlbWFpbmRlciA8PSBkcmF3X21heGltdW0gLSByZW1haW5kZXJfbWF4aW11bVxuXG5sZXQldGVzdF91bml0IFwicmVtYWluZGVyX2lzX3VuYmlhc2VkXCIgPVxuICAoKiBjaG9vc2luZyBhIHJhbmdlIG9mIDEwIHZhbHVlcyBiYXNlZCBvbiBhIHJhbmdlIG9mIDEwNSB2YWx1ZXMgKilcbiAgbGV0IGRyYXdfbWF4aW11bSA9IDEwNEwgaW5cbiAgbGV0IHJlbWFpbmRlcl9tYXhpbXVtID0gOUwgaW5cbiAgbGV0IGlzX3VuYmlhc2VkIGRyYXcgPVxuICAgIGxldCByZW1haW5kZXIgPSBJbnQ2NC5yZW0gZHJhdyAoSW50NjQuc3VjYyByZW1haW5kZXJfbWF4aW11bSkgaW5cbiAgICByZW1haW5kZXJfaXNfdW5iaWFzZWQgfmRyYXcgfnJlbWFpbmRlciB+ZHJhd19tYXhpbXVtIH5yZW1haW5kZXJfbWF4aW11bVxuICBpblxuICBmb3IgaSA9IDAgdG8gOTkgZG9cbiAgICBbJXRlc3RfcmVzdWx0OiBib29sXVxuICAgICAgKGlzX3VuYmlhc2VkIChJbnQ2NC5vZl9pbnQgaSkpXG4gICAgICB+ZXhwZWN0OnRydWVcbiAgICAgIH5tZXNzYWdlOihJbnQudG9fc3RyaW5nIGkpXG4gIGRvbmU7XG4gIGZvciBpID0gMTAwIHRvIDEwNCBkb1xuICAgIFsldGVzdF9yZXN1bHQ6IGJvb2xdXG4gICAgICAoaXNfdW5iaWFzZWQgKEludDY0Lm9mX2ludCBpKSlcbiAgICAgIH5leHBlY3Q6ZmFsc2VcbiAgICAgIH5tZXNzYWdlOihJbnQudG9fc3RyaW5nIGkpXG4gIGRvbmVcblxuKCogVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBib3VuZGVkIHJhbmRvbW5lc3MgaXMgYWRhcHRlZCBmcm9tIFtSYW5kb20uU3RhdGUuaW50Kl0gaW4gdGhlXG4gICBPQ2FtbCBzdGFuZGFyZCBsaWJyYXJ5LiAgVGhlIHB1cnBvc2UgaXMgdG8gdXNlIHRoZSBtaW5pbXVtIG51bWJlciBvZiBjYWxscyB0b1xuICAgW25leHRfaW50NjRdIHRvIHByb2R1Y2UgYSBudW1iZXIgdW5pZm9ybWx5IGNob3NlbiB3aXRoaW4gdGhlIGdpdmVuIHJhbmdlLiAqKVxubGV0IGludDY0ID1cbiAgbGV0IG9wZW4gSW50NjQuTyBpblxuICBsZXQgcmVjIGJldHdlZW4gc3RhdGUgfmxvIH5oaSA9XG4gICAgbGV0IGRyYXcgPSBTdGF0ZS5uZXh0X2ludDY0IHN0YXRlIGluXG4gICAgaWYgbG8gPD0gZHJhdyAmJiBkcmF3IDw9IGhpXG4gICAgdGhlbiBkcmF3XG4gICAgZWxzZSBiZXR3ZWVuIHN0YXRlIH5sbyB+aGlcbiAgaW5cbiAgbGV0IHJlYyBub25fbmVnYXRpdmVfdXBfdG8gc3RhdGUgbWF4aW11bSA9XG4gICAgbGV0IGRyYXcgPSBTdGF0ZS5uZXh0X2ludDY0IHN0YXRlIGxhbmQgSW50NjQubWF4X3ZhbHVlIGluXG4gICAgbGV0IHJlbWFpbmRlciA9IEludDY0LnJlbSBkcmF3IChJbnQ2NC5zdWNjIG1heGltdW0pIGluXG4gICAgaWYgcmVtYWluZGVyX2lzX3VuYmlhc2VkXG4gICAgICAgICB+ZHJhd1xuICAgICAgICAgfnJlbWFpbmRlclxuICAgICAgICAgfmRyYXdfbWF4aW11bTpJbnQ2NC5tYXhfdmFsdWVcbiAgICAgICAgIH5yZW1haW5kZXJfbWF4aW11bTptYXhpbXVtXG4gICAgdGhlbiByZW1haW5kZXJcbiAgICBlbHNlIG5vbl9uZWdhdGl2ZV91cF90byBzdGF0ZSBtYXhpbXVtXG4gIGluXG4gIGZ1biBzdGF0ZSB+bG8gfmhpIC0+XG4gICAgaWYgbG8gPiBoaSB0aGVuIGJlZ2luXG4gICAgICBFcnJvci5yYWlzZV9zIFslbWVzc2FnZSBcImludDY0OiBjcm9zc2VkIGJvdW5kc1wiIChsbyA6IGludDY0KSAoaGkgOiBpbnQ2NCldXG4gICAgZW5kO1xuICAgIGxldCBkaWZmID0gaGkgLSBsbyBpblxuICAgIGlmIGRpZmYgPSBJbnQ2NC5tYXhfdmFsdWVcbiAgICB0aGVuICgoU3RhdGUubmV4dF9pbnQ2NCBzdGF0ZSkgbGFuZCBJbnQ2NC5tYXhfdmFsdWUpICsgbG9cbiAgICBlbHNlIGlmIGRpZmYgPj0gMExcbiAgICB0aGVuIChub25fbmVnYXRpdmVfdXBfdG8gc3RhdGUgZGlmZikgKyBsb1xuICAgIGVsc2UgYmV0d2VlbiBzdGF0ZSB+bG8gfmhpXG5cbmxldCBpbnQgc3RhdGUgfmxvIH5oaSA9XG4gIGxldCBsbyA9IEludDY0Lm9mX2ludCBsbyBpblxuICBsZXQgaGkgPSBJbnQ2NC5vZl9pbnQgaGkgaW5cbiAgKCogdHJ1bmNhdGUgdW5uZWVkZWQgYml0cyAqKVxuICBJbnQ2NC50b19pbnRfdHJ1bmMgKGludDY0IHN0YXRlIH5sbyB+aGkpXG5cbmxldCBpbnQzMiBzdGF0ZSB+bG8gfmhpID1cbiAgbGV0IGxvID0gSW50NjQub2ZfaW50MzIgbG8gaW5cbiAgbGV0IGhpID0gSW50NjQub2ZfaW50MzIgaGkgaW5cbiAgKCogdHJ1bmNhdGUgdW5uZWVkZWQgYml0cyAqKVxuICBJbnQ2NC50b19pbnQzMl90cnVuYyAoaW50NjQgc3RhdGUgfmxvIH5oaSlcblxubGV0IG5hdGl2ZWludCBzdGF0ZSB+bG8gfmhpID1cbiAgbGV0IGxvID0gSW50NjQub2ZfbmF0aXZlaW50IGxvIGluXG4gIGxldCBoaSA9IEludDY0Lm9mX25hdGl2ZWludCBoaSBpblxuICAoKiB0cnVuY2F0ZSB1bm5lZWRlZCBiaXRzICopXG4gIEludDY0LnRvX25hdGl2ZWludF90cnVuYyAoaW50NjQgc3RhdGUgfmxvIH5oaSlcblxubGV0IGludDYzIHN0YXRlIH5sbyB+aGkgPVxuICBsZXQgbG8gPSBJbnQ2My50b19pbnQ2NCBsbyBpblxuICBsZXQgaGkgPSBJbnQ2My50b19pbnQ2NCBoaSBpblxuICAoKiB0cnVuY2F0ZSB1bm5lZWRlZCBiaXRzICopXG4gIEludDYzLm9mX2ludDY0X3RydW5jIChpbnQ2NCBzdGF0ZSB+bG8gfmhpKVxuXG5sZXQgZG91YmxlX3VscCA9IDIuICoqLiAtNTMuXG5cbmxldCV0ZXN0X3VuaXQgXCJkb3VibGVfdWxwXCIgPVxuICBsZXQgb3BlbiBGbG9hdC5PIGluXG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPlxuICAgIGFzc2VydCAoMS4wIC0uICBkb3VibGVfdWxwICAgICAgICAgPCAxLjApO1xuICAgIGFzc2VydCAoMS4wIC0uIChkb3VibGVfdWxwIC8uIDIuMCkgPSAxLjApXG4gIHwgVzMyIC0+XG4gICAgKCogMzItYml0IE9DYW1sIHVzZXMgYSA2NC1iaXQgZmxvYXQgcmVwcmVzZW50YXRpb24gYnV0IDgwLWJpdCBmbG9hdCBpbnN0cnVjdGlvbnMsIHNvXG4gICAgICAgcm91bmRpbmcgd29ya3MgZGlmZmVyZW50bHkgZHVlIHRvIHRoZSBjb252ZXJzaW9uIGJhY2sgYW5kIGZvcnRoLiAqKVxuICAgIGFzc2VydCAoMS4wIC0uICBkb3VibGVfdWxwICAgICAgICAgPCAgMS4wKTtcbiAgICBhc3NlcnQgKDEuMCAtLiAoZG91YmxlX3VscCAvLiAyLjApIDw9IDEuMClcblxubGV0IHVuaXRfZmxvYXRfZnJvbV9pbnQ2NCBpbnQ2NCA9XG4gIChJbnQ2NC50b19mbG9hdCAoaW50NjQgbHNyIDExKSkgKi4gZG91YmxlX3VscFxuXG5sZXQldGVzdF91bml0IFwidW5pdF9mbG9hdF9mcm9tX2ludDY0XCIgPSBiZWdpblxuICBsZXQgb3BlbiBGbG9hdC5PIGluXG4gIGFzc2VydCAodW5pdF9mbG9hdF9mcm9tX2ludDY0IDB4MDAwMF8wMDAwXzAwMDBfMDAwMEwgPSAwLik7XG4gIGFzc2VydCAodW5pdF9mbG9hdF9mcm9tX2ludDY0IDB4ZmZmZl9mZmZmX2ZmZmZfZmZmZkwgPCAxLjApO1xuICBhc3NlcnQgKHVuaXRfZmxvYXRfZnJvbV9pbnQ2NCAweGZmZmZfZmZmZl9mZmZmX2ZmZmZMID0gKDEuMCAtLiBkb3VibGVfdWxwKSk7XG5lbmRcblxubGV0IHVuaXRfZmxvYXQgc3RhdGUgPVxuICB1bml0X2Zsb2F0X2Zyb21faW50NjQgKFN0YXRlLm5leHRfaW50NjQgc3RhdGUpXG5cbigqIE5vdGUgYWJvdXQgcm91bmRvZmYgZXJyb3I6XG5cbiAgIEFsdGhvdWdoIFtmbG9hdCBzdGF0ZSB+bG8gfmhpXSBpcyBub21pbmFsbHkgaW5jbHVzaXZlIG9mIGVuZHBvaW50cywgd2UgYXJlIHJlbHlpbmcgb25cbiAgIHRoZSBmYWN0IHRoYXQgW3VuaXRfZmxvYXRdIG5ldmVyIHJldHVybnMgMS4sIGJlY2F1c2UgdGhlcmUgYXJlIHBhaXJzIFsobG8saGkpXSBmb3JcbiAgIHdoaWNoIFtsbyArLiAxLiAqLiAoaGkgLS4gbG8pID4gaGldLiAgVGhlcmUgYXJlIGFsc28gcGFpcnMgWyhsbyxoaSldIGFuZCB2YWx1ZXMgb2YgW3hdXG4gICB3aXRoIFt4IDwgMS5dIHN1Y2ggdGhhdCBbbG8gKy4geCAqLiAoaGkgLS4gbG8pID0gaGldLCBzbyBpdCB3b3VsZCBub3QgYmUgY29ycmVjdCB0b1xuICAgZG9jdW1lbnQgdGhpcyBhcyBiZWluZyBleGNsdXNpdmUgb2YgW2hpXS5cbiopXG5sZXQgZmxvYXQgPVxuICBsZXQgcmVjIGZpbml0ZV9mbG9hdCBzdGF0ZSB+bG8gfmhpID1cbiAgICBsZXQgcmFuZ2UgPSBoaSAtLiBsbyBpblxuICAgIGlmIEZsb2F0LmlzX2Zpbml0ZSByYW5nZVxuICAgIHRoZW4gKGxvICsuICh1bml0X2Zsb2F0IHN0YXRlICouIHJhbmdlKSlcbiAgICBlbHNlIGJlZ2luXG4gICAgICAoKiBJZiBbaGkgLSBsb10gaXMgaW5maW5pdGUsIHRoZW4gW2hpICsgbG9dIGlzIGZpbml0ZSBiZWNhdXNlIFtoaV0gYW5kIFtsb10gaGF2ZVxuICAgICAgICAgb3Bwb3NpdGUgc2lnbnMuICopXG4gICAgICBsZXQgbWlkID0gKGhpICsuIGxvKSAvLiAyLiBpblxuICAgICAgaWYgYm9vbCBzdGF0ZVxuICAgICAgKCogRGVwZW5kaW5nIG9uIHJvdW5kaW5nLCB0aGUgcmVjdXJzaW9uIHdpdGggW35oaTptaWRdIG1pZ2h0IGJlIGluY2x1c2l2ZSBvZiBbbWlkXSxcbiAgICAgICAgIHdoaWNoIHdvdWxkIG1lYW4gdGhlIHR3byBjYXNlcyBvdmVybGFwIG9uIFttaWRdLiBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gaW5jcmVtZW50XG4gICAgICAgICBvciBkZWNyZW1lbnQgW21pZF0gdXNpbmcgW29uZV91bHBdIGluIGVpdGhlciBvZiB0aGUgY2FsbHMsIGJ1dCB0aGVuIGlmIHRoZSBmaXJzdFxuICAgICAgICAgY2FzZSBpcyBleGNsdXNpdmUgd2UgbGVhdmUgYSBcImdhcFwiIGJldHdlZW4gdGhlIHR3byByYW5nZXMuIFRoZXJlJ3Mgbm8gcGVyZmVjdGx5XG4gICAgICAgICB1bmlmb3JtIHNvbHV0aW9uLCBzbyB3ZSB1c2UgdGhlIHNpbXBsZXIgY29kZSB0aGF0IGRvZXMgbm90IGNhbGwgW29uZV91bHBdLiAqKVxuICAgICAgdGhlbiBmaW5pdGVfZmxvYXQgc3RhdGUgfmxvIH5oaTptaWRcbiAgICAgIGVsc2UgZmluaXRlX2Zsb2F0IHN0YXRlIH5sbzptaWQgfmhpXG4gICAgZW5kXG4gIGluXG4gIGZ1biBzdGF0ZSB+bG8gfmhpIC0+XG4gICAgaWYgbm90IChGbG9hdC5pc19maW5pdGUgbG8gJiYgRmxvYXQuaXNfZmluaXRlIGhpKVxuICAgIHRoZW4gYmVnaW5cbiAgICAgIHJhaXNlX3MgWyVtZXNzYWdlXG4gICAgICAgIFwiZmxvYXQ6IGJvdW5kcyBhcmUgbm90IGZpbml0ZSBudW1iZXJzXCJcbiAgICAgICAgICAobG8gOiBmbG9hdClcbiAgICAgICAgICAoaGkgOiBmbG9hdCldXG4gICAgZW5kO1xuICAgIGlmIEZsb2F0LiggPiApIGxvIGhpXG4gICAgdGhlbiBiZWdpblxuICAgICAgcmFpc2VfcyBbJW1lc3NhZ2VcbiAgICAgICAgXCJmbG9hdDogYm91bmRzIGFyZSBjcm9zc2VkXCJcbiAgICAgICAgICAobG8gOiBmbG9hdClcbiAgICAgICAgICAoaGkgOiBmbG9hdCldXG4gICAgZW5kO1xuICAgIGZpbml0ZV9mbG9hdCBzdGF0ZSB+bG8gfmhpXG5cbmxldCViZW5jaF9mdW4gXCJ1bml0X2Zsb2F0X2Zyb21faW50NjRcIiA9XG4gIGxldCBpbnQ2NCA9IDFMIGluXG4gIGZ1biAoKSAtPiB1bml0X2Zsb2F0X2Zyb21faW50NjQgaW50NjRcblxubW9kdWxlIExvZ191bmlmb3JtID0gc3RydWN0XG4gIG1vZHVsZSBNYWtlIChNIDogc2lnIGluY2x1ZGUgSW50LlMgdmFsIHVuaWZvcm0gOiBTdGF0ZS50IC0+IGxvOnQgLT4gaGk6dCAtPiB0IGVuZCkgOiBzaWdcbiAgICB2YWwgbG9nX3VuaWZvcm0gOiBTdGF0ZS50IC0+IGxvOk0udCAtPiBoaTpNLnQgLT4gTS50XG4gIGVuZCA9IHN0cnVjdFxuICAgIG9wZW4gTVxuXG4gICAgbGV0IGJpdHNfdG9fcmVwcmVzZW50IHQgPVxuICAgICAgYXNzZXJ0ICh0ID49IHplcm8pO1xuICAgICAgbGV0IHQgPSByZWYgdCBpblxuICAgICAgbGV0IG4gPSByZWYgMCBpblxuICAgICAgd2hpbGUgIXQgPiB6ZXJvIGRvXG4gICAgICAgIHQgOj0gc2hpZnRfcmlnaHQgIXQgMTtcbiAgICAgICAgSW50LmluY3IgbjtcbiAgICAgIGRvbmU7XG4gICAgICAhblxuXG4gICAgbGV0JXRlc3RfdW5pdCBcImJpdHNfdG9fcmVwcmVzZW50XCIgPVxuICAgICAgbGV0IHRlc3QgbiBleHBlY3QgPSBbJXRlc3RfcmVzdWx0OiBpbnRdIChiaXRzX3RvX3JlcHJlc2VudCBuKSB+ZXhwZWN0ICBpblxuICAgICAgdGVzdCAoTS5vZl9pbnRfZXhuIDApICAgMDtcbiAgICAgIHRlc3QgKE0ub2ZfaW50X2V4biAxKSAgIDE7XG4gICAgICB0ZXN0IChNLm9mX2ludF9leG4gMikgICAyO1xuICAgICAgdGVzdCAoTS5vZl9pbnRfZXhuIDMpICAgMjtcbiAgICAgIHRlc3QgKE0ub2ZfaW50X2V4biA0KSAgIDM7XG4gICAgICB0ZXN0IChNLm9mX2ludF9leG4gNSkgICAzO1xuICAgICAgdGVzdCAoTS5vZl9pbnRfZXhuIDYpICAgMztcbiAgICAgIHRlc3QgKE0ub2ZfaW50X2V4biA3KSAgIDM7XG4gICAgICB0ZXN0IChNLm9mX2ludF9leG4gOCkgICA0O1xuICAgICAgdGVzdCAoTS5vZl9pbnRfZXhuIDEwMCkgNztcbiAgICAgIHRlc3QgTS5tYXhfdmFsdWUgKEludC5wcmVkIE0ubnVtX2JpdHMpO1xuICAgIDs7XG5cbiAgICBsZXQgbWluX3JlcHJlc2VudGVkX2J5X25fYml0cyBuID1cbiAgICAgIGlmIEludC5lcXVhbCBuIDBcbiAgICAgIHRoZW4gemVyb1xuICAgICAgZWxzZSBzaGlmdF9sZWZ0IG9uZSAoSW50LnByZWQgbilcblxuICAgIGxldCV0ZXN0X3VuaXQgXCJtaW5fcmVwcmVzZW50ZWRfYnlfbl9iaXRzXCIgPVxuICAgICAgbGV0IHRlc3QgbiBleHBlY3QgPSBbJXRlc3RfcmVzdWx0OiBNLnRdIChtaW5fcmVwcmVzZW50ZWRfYnlfbl9iaXRzIG4pIH5leHBlY3QgaW5cbiAgICAgIHRlc3QgMCAoTS5vZl9pbnRfZXhuIDApO1xuICAgICAgdGVzdCAxIChNLm9mX2ludF9leG4gMSk7XG4gICAgICB0ZXN0IDIgKE0ub2ZfaW50X2V4biAyKTtcbiAgICAgIHRlc3QgMyAoTS5vZl9pbnRfZXhuIDQpO1xuICAgICAgdGVzdCA0IChNLm9mX2ludF9leG4gOCk7XG4gICAgICB0ZXN0IDcgKE0ub2ZfaW50X2V4biA2NCk7XG4gICAgICB0ZXN0IChJbnQucHJlZCBNLm51bV9iaXRzKSAoTS5zaGlmdF9yaWdodF9sb2dpY2FsIE0ubWluX3ZhbHVlIDEpO1xuICAgIDs7XG5cbiAgICBsZXQgbWF4X3JlcHJlc2VudGVkX2J5X25fYml0cyBuID1cbiAgICAgIHByZWQgKHNoaWZ0X2xlZnQgb25lIG4pXG5cbiAgICBsZXQldGVzdF91bml0IFwibWF4X3JlcHJlc2VudGVkX2J5X25fYml0c1wiID1cbiAgICAgIGxldCB0ZXN0IG4gZXhwZWN0ID0gWyV0ZXN0X3Jlc3VsdDogTS50XSAobWF4X3JlcHJlc2VudGVkX2J5X25fYml0cyBuKSB+ZXhwZWN0ICBpblxuICAgICAgdGVzdCAwIChNLm9mX2ludF9leG4gMCk7XG4gICAgICB0ZXN0IDEgKE0ub2ZfaW50X2V4biAxKTtcbiAgICAgIHRlc3QgMiAoTS5vZl9pbnRfZXhuIDMpO1xuICAgICAgdGVzdCAzIChNLm9mX2ludF9leG4gNyk7XG4gICAgICB0ZXN0IDQgKE0ub2ZfaW50X2V4biAxNSk7XG4gICAgICB0ZXN0IDcgKE0ub2ZfaW50X2V4biAxMjcpO1xuICAgICAgdGVzdCAoSW50LnByZWQgTS5udW1fYml0cykgTS5tYXhfdmFsdWU7XG4gICAgOztcblxuICAgIGxldCBsb2dfdW5pZm9ybSBzdGF0ZSB+bG8gfmhpID1cbiAgICAgIGxldCBtaW5fYml0cyA9IGJpdHNfdG9fcmVwcmVzZW50IGxvIGluXG4gICAgICBsZXQgbWF4X2JpdHMgPSBiaXRzX3RvX3JlcHJlc2VudCBoaSBpblxuICAgICAgbGV0IGJpdHMgPSBpbnQgc3RhdGUgfmxvOm1pbl9iaXRzIH5oaTptYXhfYml0cyBpblxuICAgICAgdW5pZm9ybSBzdGF0ZVxuICAgICAgICB+bG86KG1pbl9yZXByZXNlbnRlZF9ieV9uX2JpdHMgYml0cyB8PiBtYXggbG8pXG4gICAgICAgIH5oaToobWF4X3JlcHJlc2VudGVkX2J5X25fYml0cyBiaXRzIHw+IG1pbiBoaSlcbiAgZW5kXG5cbiAgbW9kdWxlIEZvcl9pbnQgICAgICAgPSBNYWtlIChzdHJ1Y3QgaW5jbHVkZSBJbnQgICAgICAgbGV0IHVuaWZvcm0gPSBpbnQgICAgICAgZW5kKVxuICBtb2R1bGUgRm9yX2ludDMyICAgICA9IE1ha2UgKHN0cnVjdCBpbmNsdWRlIEludDMyICAgICBsZXQgdW5pZm9ybSA9IGludDMyICAgICBlbmQpXG4gIG1vZHVsZSBGb3JfaW50NjMgICAgID0gTWFrZSAoc3RydWN0IGluY2x1ZGUgSW50NjMgICAgIGxldCB1bmlmb3JtID0gaW50NjMgICAgIGVuZClcbiAgbW9kdWxlIEZvcl9pbnQ2NCAgICAgPSBNYWtlIChzdHJ1Y3QgaW5jbHVkZSBJbnQ2NCAgICAgbGV0IHVuaWZvcm0gPSBpbnQ2NCAgICAgZW5kKVxuICBtb2R1bGUgRm9yX25hdGl2ZWludCA9IE1ha2UgKHN0cnVjdCBpbmNsdWRlIE5hdGl2ZWludCBsZXQgdW5pZm9ybSA9IG5hdGl2ZWludCBlbmQpXG5cbiAgbGV0IGludCAgICAgICA9IEZvcl9pbnQubG9nX3VuaWZvcm1cbiAgbGV0IGludDMyICAgICA9IEZvcl9pbnQzMi5sb2dfdW5pZm9ybVxuICBsZXQgaW50NjMgICAgID0gRm9yX2ludDYzLmxvZ191bmlmb3JtXG4gIGxldCBpbnQ2NCAgICAgPSBGb3JfaW50NjQubG9nX3VuaWZvcm1cbiAgbGV0IG5hdGl2ZWludCA9IEZvcl9uYXRpdmVpbnQubG9nX3VuaWZvcm1cbmVuZFxuXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqKiA2NC1iaXQgaW50ZWdlcnMuXG5cbiAgIFRoaXMgbW9kdWxlIHByb3ZpZGVzIG9wZXJhdGlvbnMgb24gdGhlIHR5cGUgW2ludDY0XSBvZlxuICAgc2lnbmVkIDY0LWJpdCBpbnRlZ2Vycy4gIFVubGlrZSB0aGUgYnVpbHQtaW4gW2ludF0gdHlwZSxcbiAgIHRoZSB0eXBlIFtpbnQ2NF0gaXMgZ3VhcmFudGVlZCB0byBiZSBleGFjdGx5IDY0LWJpdCB3aWRlIG9uIGFsbFxuICAgcGxhdGZvcm1zLiAgQWxsIGFyaXRobWV0aWMgb3BlcmF0aW9ucyBvdmVyIFtpbnQ2NF0gYXJlIHRha2VuXG4gICBtb2R1bG8gMnteNjR9XG5cbiAgIFBlcmZvcm1hbmNlIG5vdGljZTogdmFsdWVzIG9mIHR5cGUgW2ludDY0XSBvY2N1cHkgbW9yZSBtZW1vcnlcbiAgIHNwYWNlIHRoYW4gdmFsdWVzIG9mIHR5cGUgW2ludF0sIGFuZCBhcml0aG1ldGljIG9wZXJhdGlvbnMgb25cbiAgIFtpbnQ2NF0gYXJlIGdlbmVyYWxseSBzbG93ZXIgdGhhbiB0aG9zZSBvbiBbaW50XS4gIFVzZSBbaW50NjRdXG4gICBvbmx5IHdoZW4gdGhlIGFwcGxpY2F0aW9uIHJlcXVpcmVzIGV4YWN0IDY0LWJpdCBhcml0aG1ldGljLlxuXG4gICAgTGl0ZXJhbHMgZm9yIDY0LWJpdCBpbnRlZ2VycyBhcmUgc3VmZml4ZWQgYnkgTDpcbiAgICB7W1xuICAgICAgbGV0IHplcm86IGludDY0ID0gMExcbiAgICAgIGxldCBvbmU6IGludDY0ID0gMUxcbiAgICAgIGxldCBtX29uZTogaW50NjQgPSAtMUxcbiAgICBdfVxuKilcblxudmFsIHplcm8gOiBpbnQ2NFxuKCoqIFRoZSA2NC1iaXQgaW50ZWdlciAwLiAqKVxuXG52YWwgb25lIDogaW50NjRcbigqKiBUaGUgNjQtYml0IGludGVnZXIgMS4gKilcblxudmFsIG1pbnVzX29uZSA6IGludDY0XG4oKiogVGhlIDY0LWJpdCBpbnRlZ2VyIC0xLiAqKVxuXG5leHRlcm5hbCBuZWcgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X25lZ1wiXG4oKiogVW5hcnkgbmVnYXRpb24uICopXG5cbmV4dGVybmFsIGFkZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYWRkXCJcbigqKiBBZGRpdGlvbi4gKilcblxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuKCoqIFN1YnRyYWN0aW9uLiAqKVxuXG5leHRlcm5hbCBtdWwgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X211bFwiXG4oKiogTXVsdGlwbGljYXRpb24uICopXG5cbmV4dGVybmFsIGRpdiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfZGl2XCJcbigqKiBJbnRlZ2VyIGRpdmlzaW9uLlxuICAgQHJhaXNlIERpdmlzaW9uX2J5X3plcm8gaWYgdGhlIHNlY29uZFxuICAgYXJndW1lbnQgaXMgemVyby4gIFRoaXMgZGl2aXNpb24gcm91bmRzIHRoZSByZWFsIHF1b3RpZW50IG9mXG4gICBpdHMgYXJndW1lbnRzIHRvd2FyZHMgemVybywgYXMgc3BlY2lmaWVkIGZvciB7IVN0ZGxpYi4oLyl9LiAqKVxuXG52YWwgdW5zaWduZWRfZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjRcbigqKiBTYW1lIGFzIHshZGl2fSwgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFuZCByZXN1bHQgYXJlIGludGVycHJldGVkIGFzIHtlXG4gICAgdW5zaWduZWR9IDY0LWJpdCBpbnRlZ2Vycy5cblxuICAgIEBzaW5jZSA0LjA4LjAgKilcblxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuKCoqIEludGVnZXIgcmVtYWluZGVyLiAgSWYgW3ldIGlzIG5vdCB6ZXJvLCB0aGUgcmVzdWx0XG4gICBvZiBbSW50NjQucmVtIHggeV0gc2F0aXNmaWVzIHRoZSBmb2xsb3dpbmcgcHJvcGVydHk6XG4gICBbeCA9IEludDY0LmFkZCAoSW50NjQubXVsIChJbnQ2NC5kaXYgeCB5KSB5KSAoSW50NjQucmVtIHggeSldLlxuICAgSWYgW3kgPSAwXSwgW0ludDY0LnJlbSB4IHldIHJhaXNlcyBbRGl2aXNpb25fYnlfemVyb10uICopXG5cbnZhbCB1bnNpZ25lZF9yZW0gOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIFNhbWUgYXMgeyFyZW19LCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYW5kIHJlc3VsdCBhcmUgaW50ZXJwcmV0ZWQgYXMge2VcbiAgICB1bnNpZ25lZH0gNjQtYml0IGludGVnZXJzLlxuXG4gICAgQHNpbmNlIDQuMDguMCAqKVxuXG52YWwgc3VjYyA6IGludDY0IC0+IGludDY0XG4oKiogU3VjY2Vzc29yLiAgW0ludDY0LnN1Y2MgeF0gaXMgW0ludDY0LmFkZCB4IEludDY0Lm9uZV0uICopXG5cbnZhbCBwcmVkIDogaW50NjQgLT4gaW50NjRcbigqKiBQcmVkZWNlc3Nvci4gIFtJbnQ2NC5wcmVkIHhdIGlzIFtJbnQ2NC5zdWIgeCBJbnQ2NC5vbmVdLiAqKVxuXG52YWwgYWJzIDogaW50NjQgLT4gaW50NjRcbigqKiBSZXR1cm4gdGhlIGFic29sdXRlIHZhbHVlIG9mIGl0cyBhcmd1bWVudC4gKilcblxudmFsIG1heF9pbnQgOiBpbnQ2NFxuKCoqIFRoZSBncmVhdGVzdCByZXByZXNlbnRhYmxlIDY0LWJpdCBpbnRlZ2VyLCAye142M30gLSAxLiAqKVxuXG52YWwgbWluX2ludCA6IGludDY0XG4oKiogVGhlIHNtYWxsZXN0IHJlcHJlc2VudGFibGUgNjQtYml0IGludGVnZXIsIC0ye142M30uICopXG5cbmV4dGVybmFsIGxvZ2FuZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYW5kXCJcbigqKiBCaXR3aXNlIGxvZ2ljYWwgYW5kLiAqKVxuXG5leHRlcm5hbCBsb2dvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfb3JcIlxuKCoqIEJpdHdpc2UgbG9naWNhbCBvci4gKilcblxuZXh0ZXJuYWwgbG9neG9yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF94b3JcIlxuKCoqIEJpdHdpc2UgbG9naWNhbCBleGNsdXNpdmUgb3IuICopXG5cbnZhbCBsb2dub3QgOiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIEJpdHdpc2UgbG9naWNhbCBuZWdhdGlvbi4gKilcblxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzbFwiXG4oKiogW0ludDY0LnNoaWZ0X2xlZnQgeCB5XSBzaGlmdHMgW3hdIHRvIHRoZSBsZWZ0IGJ5IFt5XSBiaXRzLlxuICAgVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiBbeSA8IDBdIG9yIFt5ID49IDY0XS4gKilcblxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuKCoqIFtJbnQ2NC5zaGlmdF9yaWdodCB4IHldIHNoaWZ0cyBbeF0gdG8gdGhlIHJpZ2h0IGJ5IFt5XSBiaXRzLlxuICAgVGhpcyBpcyBhbiBhcml0aG1ldGljIHNoaWZ0OiB0aGUgc2lnbiBiaXQgb2YgW3hdIGlzIHJlcGxpY2F0ZWRcbiAgIGFuZCBpbnNlcnRlZCBpbiB0aGUgdmFjYXRlZCBiaXRzLlxuICAgVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiBbeSA8IDBdIG9yIFt5ID49IDY0XS4gKilcblxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG4oKiogW0ludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgeCB5XSBzaGlmdHMgW3hdIHRvIHRoZSByaWdodCBieSBbeV0gYml0cy5cbiAgIFRoaXMgaXMgYSBsb2dpY2FsIHNoaWZ0OiB6ZXJvZXMgYXJlIGluc2VydGVkIGluIHRoZSB2YWNhdGVkIGJpdHNcbiAgIHJlZ2FyZGxlc3Mgb2YgdGhlIHNpZ24gb2YgW3hdLlxuICAgVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiBbeSA8IDBdIG9yIFt5ID49IDY0XS4gKilcblxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50XCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiBpbnRlZ2VyICh0eXBlIFtpbnRdKSB0byBhIDY0LWJpdCBpbnRlZ2VyXG4gICAgKHR5cGUgW2ludDY0XSkuICopXG5cbmV4dGVybmFsIHRvX2ludCA6IGludDY0IC0+IGludCA9IFwiJWludDY0X3RvX2ludFwiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkgdG8gYW5cbiAgIGludGVnZXIgKHR5cGUgW2ludF0pLiAgT24gNjQtYml0IHBsYXRmb3JtcywgdGhlIDY0LWJpdCBpbnRlZ2VyXG4gICBpcyB0YWtlbiBtb2R1bG8gMnteNjN9LCBpLmUuIHRoZSBoaWdoLW9yZGVyIGJpdCBpcyBsb3N0XG4gICBkdXJpbmcgdGhlIGNvbnZlcnNpb24uICBPbiAzMi1iaXQgcGxhdGZvcm1zLCB0aGUgNjQtYml0IGludGVnZXJcbiAgIGlzIHRha2VuIG1vZHVsbyAye14zMX0sIGkuZS4gdGhlIHRvcCAzMyBiaXRzIGFyZSBsb3N0XG4gICBkdXJpbmcgdGhlIGNvbnZlcnNpb24uICopXG5cbnZhbCB1bnNpZ25lZF90b19pbnQgOiBpbnQ2NCAtPiBpbnQgb3B0aW9uXG4oKiogU2FtZSBhcyB7IXRvX2ludH0sIGJ1dCBpbnRlcnByZXRzIHRoZSBhcmd1bWVudCBhcyBhbiB7ZSB1bnNpZ25lZH0gaW50ZWdlci5cbiAgICBSZXR1cm5zIFtOb25lXSBpZiB0aGUgdW5zaWduZWQgdmFsdWUgb2YgdGhlIGFyZ3VtZW50IGNhbm5vdCBmaXQgaW50byBhblxuICAgIFtpbnRdLlxuXG4gICAgQHNpbmNlIDQuMDguMCAqKVxuXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIGZsb2F0aW5nLXBvaW50IG51bWJlciB0byBhIDY0LWJpdCBpbnRlZ2VyLFxuICAgZGlzY2FyZGluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0ICh0cnVuY2F0ZSB0b3dhcmRzIDApLlxuICAgVGhlIHJlc3VsdCBvZiB0aGUgY29udmVyc2lvbiBpcyB1bmRlZmluZWQgaWYsIGFmdGVyIHRydW5jYXRpb24sXG4gICB0aGUgbnVtYmVyIGlzIG91dHNpZGUgdGhlIHJhbmdlIFxcW3shSW50NjQubWluX2ludH0sIHshSW50NjQubWF4X2ludH1cXF0uICopXG5cbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfdG9fZmxvYXRcIiBcImNhbWxfaW50NjRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gNjQtYml0IGludGVnZXIgdG8gYSBmbG9hdGluZy1wb2ludCBudW1iZXIuICopXG5cblxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiAzMi1iaXQgaW50ZWdlciAodHlwZSBbaW50MzJdKVxuICAgdG8gYSA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKS4gKilcblxuZXh0ZXJuYWwgdG9faW50MzIgOiBpbnQ2NCAtPiBpbnQzMiA9IFwiJWludDY0X3RvX2ludDMyXCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKSB0byBhXG4gICAzMi1iaXQgaW50ZWdlciAodHlwZSBbaW50MzJdKS4gVGhlIDY0LWJpdCBpbnRlZ2VyXG4gICBpcyB0YWtlbiBtb2R1bG8gMnteMzJ9LCBpLmUuIHRoZSB0b3AgMzIgYml0cyBhcmUgbG9zdFxuICAgZHVyaW5nIHRoZSBjb252ZXJzaW9uLiAgKilcblxuZXh0ZXJuYWwgb2ZfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfbmF0aXZlaW50XCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiBuYXRpdmUgaW50ZWdlciAodHlwZSBbbmF0aXZlaW50XSlcbiAgIHRvIGEgNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkuICopXG5cbmV4dGVybmFsIHRvX25hdGl2ZWludCA6IGludDY0IC0+IG5hdGl2ZWludCA9IFwiJWludDY0X3RvX25hdGl2ZWludFwiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkgdG8gYVxuICAgbmF0aXZlIGludGVnZXIuICBPbiAzMi1iaXQgcGxhdGZvcm1zLCB0aGUgNjQtYml0IGludGVnZXJcbiAgIGlzIHRha2VuIG1vZHVsbyAye14zMn0uICBPbiA2NC1iaXQgcGxhdGZvcm1zLFxuICAgdGhlIGNvbnZlcnNpb24gaXMgZXhhY3QuICopXG5cbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQ2NCA9IFwiY2FtbF9pbnQ2NF9vZl9zdHJpbmdcIlxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIHN0cmluZyB0byBhIDY0LWJpdCBpbnRlZ2VyLlxuICAgVGhlIHN0cmluZyBpcyByZWFkIGluIGRlY2ltYWwgKGJ5IGRlZmF1bHQsIG9yIGlmIHRoZSBzdHJpbmdcbiAgIGJlZ2lucyB3aXRoIFswdV0pIG9yIGluIGhleGFkZWNpbWFsLCBvY3RhbCBvciBiaW5hcnkgaWYgdGhlXG4gICBzdHJpbmcgYmVnaW5zIHdpdGggWzB4XSwgWzBvXSBvciBbMGJdIHJlc3BlY3RpdmVseS5cblxuICAgVGhlIFswdV0gcHJlZml4IHJlYWRzIHRoZSBpbnB1dCBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyIGluIHRoZSByYW5nZVxuICAgW1swLCAyKkludDY0Lm1heF9pbnQrMV1dLiAgSWYgdGhlIGlucHV0IGV4Y2VlZHMgeyFJbnQ2NC5tYXhfaW50fVxuICAgaXQgaXMgY29udmVydGVkIHRvIHRoZSBzaWduZWQgaW50ZWdlclxuICAgW0ludDY0Lm1pbl9pbnQgKyBpbnB1dCAtIEludDY0Lm1heF9pbnQgLSAxXS5cblxuICAgVGhlIFtfXSAodW5kZXJzY29yZSkgY2hhcmFjdGVyIGNhbiBhcHBlYXIgYW55d2hlcmUgaW4gdGhlIHN0cmluZ1xuICAgYW5kIGlzIGlnbm9yZWQuXG4gICBAcmFpc2UgRmFpbHVyZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIG5vdFxuICAgYSB2YWxpZCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLCBvciBpZiB0aGUgaW50ZWdlciByZXByZXNlbnRlZFxuICAgZXhjZWVkcyB0aGUgcmFuZ2Ugb2YgaW50ZWdlcnMgcmVwcmVzZW50YWJsZSBpbiB0eXBlIFtpbnQ2NF0uICopXG5cbnZhbCBvZl9zdHJpbmdfb3B0OiBzdHJpbmcgLT4gaW50NjQgb3B0aW9uXG4oKiogU2FtZSBhcyBbb2Zfc3RyaW5nXSwgYnV0IHJldHVybiBbTm9uZV0gaW5zdGVhZCBvZiByYWlzaW5nLlxuICAgIEBzaW5jZSA0LjA1ICopXG5cbnZhbCB0b19zdHJpbmcgOiBpbnQ2NCAtPiBzdHJpbmdcbigqKiBSZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdHMgYXJndW1lbnQsIGluIGRlY2ltYWwuICopXG5cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4oKiogUmV0dXJuIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZmxvYXQgYWNjb3JkaW5nXG4gICB0byB0aGUgSUVFRSA3NTQgZmxvYXRpbmctcG9pbnQgJ2RvdWJsZSBmb3JtYXQnIGJpdCBsYXlvdXQuXG4gICBCaXQgNjMgb2YgdGhlIHJlc3VsdCByZXByZXNlbnRzIHRoZSBzaWduIG9mIHRoZSBmbG9hdDtcbiAgIGJpdHMgNjIgdG8gNTIgcmVwcmVzZW50IHRoZSAoYmlhc2VkKSBleHBvbmVudDsgYml0cyA1MSB0byAwXG4gICByZXByZXNlbnQgdGhlIG1hbnRpc3NhLiAqKVxuXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuKCoqIFJldHVybiB0aGUgZmxvYXRpbmctcG9pbnQgbnVtYmVyIHdob3NlIGludGVybmFsIHJlcHJlc2VudGF0aW9uLFxuICAgYWNjb3JkaW5nIHRvIHRoZSBJRUVFIDc1NCBmbG9hdGluZy1wb2ludCAnZG91YmxlIGZvcm1hdCcgYml0IGxheW91dCxcbiAgIGlzIHRoZSBnaXZlbiBbaW50NjRdLiAqKVxuXG50eXBlIHQgPSBpbnQ2NFxuKCoqIEFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiA2NC1iaXQgaW50ZWdlcnMuICopXG5cbnZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4oKiogVGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIDY0LWJpdCBpbnRlZ2Vycywgd2l0aCB0aGUgc2FtZSBzcGVjaWZpY2F0aW9uIGFzXG4gICAgeyFTdGRsaWIuY29tcGFyZX0uICBBbG9uZyB3aXRoIHRoZSB0eXBlIFt0XSwgdGhpcyBmdW5jdGlvbiBbY29tcGFyZV1cbiAgICBhbGxvd3MgdGhlIG1vZHVsZSBbSW50NjRdIHRvIGJlIHBhc3NlZCBhcyBhcmd1bWVudCB0byB0aGUgZnVuY3RvcnNcbiAgICB7IVNldC5NYWtlfSBhbmQgeyFNYXAuTWFrZX0uICopXG5cbnZhbCB1bnNpZ25lZF9jb21wYXJlOiB0IC0+IHQgLT4gaW50XG4oKiogU2FtZSBhcyB7IWNvbXBhcmV9LCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYXJlIGludGVycHJldGVkIGFzIHtlIHVuc2lnbmVkfVxuICAgIDY0LWJpdCBpbnRlZ2Vycy5cblxuICAgIEBzaW5jZSA0LjA4LjAgKilcblxudmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuKCoqIFRoZSBlcXVhbCBmdW5jdGlvbiBmb3IgaW50NjRzLlxuICAgIEBzaW5jZSA0LjAzLjAgKilcblxudmFsIG1pbjogdCAtPiB0IC0+IHRcbigqKiBSZXR1cm4gdGhlIHNtYWxsZXIgb2YgdGhlIHR3byBhcmd1bWVudHMuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIG1heDogdCAtPiB0IC0+IHRcbigqKiBSZXR1cm4gdGhlIGdyZWF0ZXIgb2YgdGhlIHR3byBhcmd1bWVudHMuXG4gICAgQHNpbmNlIDQuMTMuMFxuICopXG5cbigqKi8qKilcblxuKCoqIHsxIERlcHJlY2F0ZWQgZnVuY3Rpb25zfSAqKVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG4oKiogRG8gbm90IHVzZSB0aGlzIGRlcHJlY2F0ZWQgZnVuY3Rpb24uICBJbnN0ZWFkLFxuICAgdXNlZCB7IVByaW50Zi5zcHJpbnRmfSB3aXRoIGEgWyVMLi4uXSBmb3JtYXQuICopXG4iXX0=
