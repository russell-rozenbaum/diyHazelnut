// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1+5.8.1

//# unitInfo: Provides: Incr_map__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Incr_map = [0];
   runtime.caml_register_global(0, Incr_map, "Incr_map__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incr_map__Incr_map_intf
//# unitInfo: Requires: Expect_test_collector, Ppx_bench_lib__Benchmark_accumulator, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incr_map_Incr_map_intf = "Incr_map__Incr_map_intf",
    cst_incr_map = "incr_map";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incr_map_Incr_map_intf);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incr_map);
   caml_call1(Expect_test_collector[5][1], "src/incr_map_intf.ml");
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incr_map, cst);
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incr_map);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incr_map_Incr_map_intf);
   var Incr_map_Incr_map_intf = [0];
   runtime.caml_register_global
    (11, Incr_map_Incr_map_intf, cst_Incr_map_Incr_map_intf);
   return;
  }
  (globalThis));

//# unitInfo: Provides: Incr_map
//# unitInfo: Requires: Assert_failure, CamlinternalLazy, Core, Core__Bool, Core__Info, Core__Int, Core__Lazy, Core__List, Core__Map, Core__Maybe_bound, Core__Option, Core__Sequence, Core__Set, Core__Tuple, Expect_test_collector, Incr_map__Incr_map_intf, Incremental, Ppx_bench_lib__Benchmark_accumulator, Ppx_compare_lib, Ppx_inline_test_lib__Runtime, Ppx_module_timer_runtime, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Incr_map = "Incr_map",
    cst_incr_map = "incr_map",
    cst_src_incr_map_ml = "src/incr_map.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Core_Int = global_data.Core__Int,
    Core_Map = global_data.Core__Map,
    Core = global_data.Core,
    Incremental = global_data.Incremental,
    Core_Option = global_data.Core__Option,
    Core_Info = global_data.Core__Info,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Core_List = global_data.Core__List,
    Core_Bool = global_data.Core__Bool,
    Core_Tuple = global_data.Core__Tuple,
    Assert_failure = global_data.Assert_failure,
    Core_Maybe_bound = global_data.Core__Maybe_bound,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Ppx_compare_lib = global_data.Ppx_compare_lib,
    Core_Lazy = global_data.Core__Lazy,
    Core_Set = global_data.Core__Set,
    Core_Sequence = global_data.Core__Sequence,
    Ppx_module_timer_runtime = global_data.Ppx_module_timer_runtime,
    Ppx_bench_lib_Benchmark_accumu =
      global_data.Ppx_bench_lib__Benchmark_accumulator,
    Expect_test_collector = global_data.Expect_test_collector,
    Ppx_inline_test_lib_Runtime = global_data.Ppx_inline_test_lib__Runtime;
   caml_call1(Ppx_module_timer_runtime[4], cst_Incr_map);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][1], cst_incr_map);
   caml_call1(Expect_test_collector[5][1], cst_src_incr_map_ml);
   caml_call2(Ppx_inline_test_lib_Runtime[2], cst_incr_map, cst);
   var
    _a_ = [0, cst_src_incr_map_ml, 238, 11],
    _b_ = [0, cst_src_incr_map_ml, 311, 12],
    _c_ = [0, 1],
    _d_ = [0, 1],
    cst_impossible_case_BUG_in_inc =
      "impossible case: BUG in incr_map.ml subrange",
    _e_ = [0, 1],
    cst_BUG_Hit_supposedly_impossi =
      "BUG: Hit supposedly impossible case in Incr_map.index_by",
    _f_ = [0, 1],
    _g_ = [0, "to_"],
    _h_ = [0, "from"],
    cst_Invalid_indices = "Invalid indices",
    _i_ = [0, 0, 0],
    _j_ = [0, cst_src_incr_map_ml, 1195, 10],
    _k_ = [0, cst_src_incr_map_ml, 1194, 10],
    _l_ = [0, cst_src_incr_map_ml, 1210, 6],
    _m_ = [0, [0, 0, 0]],
    _n_ = [0, cst_src_incr_map_ml, 1210, 6],
    _o_ = [0, cst_src_incr_map_ml, 1210, 6],
    _p_ = [0, cst_src_incr_map_ml, 1210, 6],
    _q_ = [0, cst_src_incr_map_ml, 1210, 6],
    _r_ = [0, cst_src_incr_map_ml, 1210, 6],
    _s_ = [0, cst_src_incr_map_ml, 1210, 6],
    _t_ = [0, cst_src_incr_map_ml, 1210, 6],
    _u_ = [0, cst_src_incr_map_ml, 1210, 6],
    _v_ = [0, 1],
    _w_ = [0, 1],
    _x_ = [0, 1],
    _y_ = [0, 1],
    _z_ = [0, 1];
   function with_old(i, f){
    var old = [0, 0];
    return caml_call2
            (Incremental[76][3][5],
             i,
             function(a){
              var b = caml_call2(f, old[1], a);
              old[1] = [0, [0, a, b]];
              return b;
             });
   }
   function unordered_fold
   (opt, update, specialized_initial, _cq_, map, init, add, remove){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    if(_cq_)
     var sth$0 = _cq_[1], revert_to_init_when_empty = sth$0;
    else
     var revert_to_init_when_empty = 0;
    function default$0(key, old_data, new_data, acc){
     return caml_call3
             (add, key, new_data, caml_call3(remove, key, old_data, acc));
    }
    var update$0 = caml_call2(Core_Option[34], update, default$0);
    return with_old
            (map,
             function(old, new_in){
              if(! old){
               if(! specialized_initial)
                return caml_call3(Core_Map[55], new_in, init, add);
               var initial = specialized_initial[1];
               return caml_call2(initial, init, new_in);
              }
              var match = old[1], old_out = match[2], old_in = match[1];
              if(revert_to_init_when_empty){
               var _cr_ = caml_call1(Core_Map[29], new_in);
               if(caml_call2(Core[90], _cr_, 0)) return init;
              }
              return caml_call5
                      (Core_Map[81],
                       old_in,
                       new_in,
                       data_equal,
                       old_out,
                       function(acc, param){
                        var change = param[2], key = param[1], _cs_ = change[1];
                        if(847852583 === _cs_){
                         var old = change[2];
                         return caml_call3(remove, key, old, acc);
                        }
                        if(1013247643 <= _cs_){
                         var match = change[2], new$0 = match[2], old$0 = match[1];
                         return caml_call4(update$0, key, old$0, new$0, acc);
                        }
                        var new$1 = change[2];
                        return caml_call3(add, key, new$1, acc);
                       });
             });
   }
   function unordered_fold_nested_maps
   (opt, revert_to_init_when_empty, update, incr_map, init, add, remove){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    if(update)
     var update$0 = update[1], update$1 = update$0;
    else
     var
      update$1 =
        function(outer_key, inner_key, old_data, new_data, acc){
         return caml_call4
                 (add,
                  outer_key,
                  inner_key,
                  new_data,
                  caml_call4(remove, outer_key, inner_key, old_data, acc));
        };
    return unordered_fold
            (0,
             [0,
              function(outer_key, old_inner_map, new_inner_map, acc){
               return caml_call2
                       (caml_call3
                         (Core_Map[81], old_inner_map, new_inner_map, data_equal),
                        acc,
                        function(acc, param){
                         var diff = param[2], inner_key = param[1], _cp_ = diff[1];
                         if(847852583 === _cp_){
                          var data_removed = diff[2];
                          return caml_call4
                                  (remove, outer_key, inner_key, data_removed, acc);
                         }
                         if(1013247643 <= _cp_){
                          var
                           match = diff[2],
                           new_data = match[2],
                           old_data = match[1];
                          return caml_call5
                                  (update$1, outer_key, inner_key, old_data, new_data, acc);
                         }
                         var data_added = diff[2];
                         return caml_call4
                                 (add, outer_key, inner_key, data_added, acc);
                        });
              }],
             0,
             revert_to_init_when_empty,
             incr_map,
             init,
             function(outer_key, inner_map, acc){
              return caml_call3
                      (Core_Map[55],
                       inner_map,
                       acc,
                       function(inner_key, data, acc){
                        return caml_call4(add, outer_key, inner_key, data, acc);
                       });
             },
             function(outer_key, inner_map, acc){
              return caml_call3
                      (Core_Map[55],
                       inner_map,
                       acc,
                       function(inner_key, data, acc){
                        return caml_call4(remove, outer_key, inner_key, data, acc);
                       });
             });
   }
   function with_comparator(get_comparator, x, f){
    var
     _cn_ = caml_call2(Incremental[10], x, get_comparator),
     _co_ = caml_call2(Incremental[34], 0, _cn_);
    return caml_call2(Incremental[26], _co_, f);
   }
   function with_comparator$0(map, f){
    return with_comparator(Core_Map[2], map, f);
   }
   function of_set(set){
    return with_comparator
            (Core_Set[5],
             set,
             function(comparator){
              var
               old_input = [0, caml_call1(Core_Set[3][1], comparator)],
               old_output = [0, caml_call1(Core_Map[110][1], comparator)];
              return caml_call2
                      (Incremental[10],
                       set,
                       function(new_input){
                        var
                         _cl_ = old_output[1],
                         _cm_ = caml_call2(Core_Set[17], old_input[1], new_input),
                         new_output =
                           caml_call3
                            (Core_Sequence[18],
                             _cm_,
                             _cl_,
                             function(output, param){
                              if(0 === param[0]){
                               var k = param[1];
                               return caml_call2(Core_Map[41], output, k);
                              }
                              var k$0 = param[1];
                              return caml_call3(Core_Map[31], output, k$0, 0);
                             });
                        old_input[1] = new_input;
                        old_output[1] = new_output;
                        return new_output;
                       });
             });
   }
   function generic_mapi(witness, opt, map){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    return function(f){
     return with_old
             (map,
              function(old, input){
               if(0 !== caml_call1(Core_Map[29], input) && old){
                var
                 match = old[1],
                 old_output = match[2],
                 old_input = match[1];
                return caml_call5
                        (Core_Map[81],
                         old_input,
                         input,
                         data_equal,
                         old_output,
                         function(output, param){
                          var change = param[2], key = param[1], _ck_ = change[1];
                          if(847852583 === _ck_)
                           return caml_call2(Core_Map[41], output, key);
                          var
                           new_data = 1013247643 <= _ck_ ? change[2][2] : change[2],
                           res = caml_call2(f, key, new_data);
                          if(! witness)
                           return caml_call3(Core_Map[32], output, key, res);
                          if(! res) return caml_call2(Core_Map[41], output, key);
                          var output_data = res[1];
                          return caml_call3(Core_Map[32], output, key, output_data);
                         });
               }
               return witness
                       ? caml_call2(Core_Map[63], input, f)
                       : caml_call2(Core_Map[52], input, f);
              });};
   }
   function mapi(data_equal, map, f){
    return generic_mapi(0, data_equal, map)(f);
   }
   function filter_mapi(data_equal, map, f){
    return generic_mapi(1, data_equal, map)(f);
   }
   function map(data_equal, map, f){
    return mapi
            (data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function filter_map(data_equal, map, f){
    return filter_mapi
            (data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function with_old2(i1, i2, f){
    var old = [0, 0];
    return caml_call3
            (Incremental[12],
             i1,
             i2,
             function(a1, a2){
              var b = caml_call3(f, old[1], a1, a2);
              old[1] = [0, [0, a1, a2, b]];
              return b;
             });
   }
   function mapi_count(opt, input, comparator){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    return function(f){
     function add(new_key, acc){
      return caml_call3
              (Core_Map[37],
               acc,
               new_key,
               function(param){
                if(! param) return 1;
                var n = param[1];
                return n + 1 | 0;
               });
     }
     function remove(new_key, acc){
      return caml_call3
              (Core_Map[36],
               acc,
               new_key,
               function(param){
                if(! param) return 0;
                var n = param[1];
                return 1 === n ? 0 : [0, n - 1 | 0];
               });
     }
     return unordered_fold
             ([0, data_equal],
              [0,
               function(key, old_data, new_data, acc){
                var
                 prev_key = caml_call2(f, key, old_data),
                 new_key = caml_call2(f, key, new_data),
                 _cj_ = caml_call2(comparator[1][1], prev_key, new_key);
                return caml_call2(Core[90], _cj_, 0)
                        ? acc
                        : add(new_key, remove(prev_key, acc));
               }],
              0,
              0,
              input,
              caml_call1(Core_Map[4], comparator),
              function(key, data, acc){
               return add(caml_call2(f, key, data), acc);
              },
              function(key, data, acc){
               return remove(caml_call2(f, key, data), acc);
              });};
   }
   function map_count(data_equal, input, comparator, f){
    return mapi_count(data_equal, input, comparator)
            (function(param, data){return caml_call1(f, data);});
   }
   function min_helper(map){
    var match = caml_call1(Core_Map[82], map);
    if(! match) return 0;
    var min = match[1][1];
    return [0, min];
   }
   function max_helper(map){
    var match = caml_call1(Core_Map[84], map);
    if(! match) return 0;
    var max = match[1][1];
    return [0, max];
   }
   function bounds_helper(map){
    var
     match = caml_call1(Core_Map[82], map),
     match$0 = caml_call1(Core_Map[84], map);
    if(match){
     if(match$0){
      var max = match$0[1][1], min = match[1][1];
      return [0, [0, min, max]];
     }
    }
    else if(! match$0) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function mapi_min(data_equal, input, comparator, f){
    var _ci_ = mapi_count(data_equal, input, comparator)(f);
    return caml_call2(Incremental[10], _ci_, min_helper);
   }
   function mapi_max(data_equal, input, comparator, f){
    var _ch_ = mapi_count(data_equal, input, comparator)(f);
    return caml_call2(Incremental[10], _ch_, max_helper);
   }
   function mapi_bounds(data_equal, input, comparator, f){
    var _cg_ = mapi_count(data_equal, input, comparator)(f);
    return caml_call2(Incremental[10], _cg_, bounds_helper);
   }
   function mapi_mn(data_equal, input, comparator, f){
    return mapi_min
            (data_equal,
             input,
             comparator,
             function(param, data){return caml_call1(f, data);});
   }
   function map_max(data_equal, input, comparator, f){
    return mapi_max
            (data_equal,
             input,
             comparator,
             function(param, data){return caml_call1(f, data);});
   }
   function min_value(data_equal, input, comparator){
    return mapi_mn
            (data_equal, input, comparator, function(_cf_){return _cf_;});
   }
   function max_value(data_equal, input, comparator){
    return map_max
            (data_equal, input, comparator, function(_ce_){return _ce_;});
   }
   function map_bounds(data_equal, input, comparator, f){
    return mapi_bounds
            (data_equal,
             input,
             comparator,
             function(param, data){return caml_call1(f, data);});
   }
   function value_bounds(data_equal, input, comparator){
    return map_bounds
            (data_equal, input, comparator, function(_cd_){return _cd_;});
   }
   function merge(opt, _b9_, left_map, right_map, f){
    if(opt)
     var sth = opt[1], data_equal_left = sth;
    else
     var data_equal_left = Core[246];
    if(_b9_)
     var sth$0 = _b9_[1], data_equal_right = sth$0;
    else
     var data_equal_right = Core[246];
    return with_old2
            (left_map,
             right_map,
             function(old, new_left_map, new_right_map){
              var comparator = caml_call1(Core_Map[2], new_left_map);
              if(old)
               var
                x = old[1],
                old_output = x[3],
                old_right_map = x[2],
                old_left_map = x[1];
              else
               var
                old_left_map$0 = caml_call1(Core_Map[110][1], comparator),
                old_output = old_left_map$0,
                old_right_map = old_left_map$0,
                old_left_map = old_left_map$0;
              var
               left_diff =
                 caml_call3
                  (Core_Map[80], old_left_map, new_left_map, data_equal_left),
               right_diff =
                 caml_call3
                  (Core_Map[80],
                   old_right_map,
                   new_right_map,
                   data_equal_right),
               _b__ =
                 caml_call3
                  (Core_Sequence[62],
                   left_diff,
                   right_diff,
                   function(param, _cc_){
                    var right_key = _cc_[1], left_key = param[1];
                    return caml_call2(comparator[1], left_key, right_key);
                   });
              return caml_call3
                      (Core_Sequence[18],
                       _b__,
                       old_output,
                       function(output, diff_element){
                        if(2 === diff_element[0]){
                         var
                          right_key = diff_element[2][1],
                          left_key = diff_element[1][1],
                          _ca_ = caml_call2(comparator[1], left_key, right_key);
                         if(! caml_call2(Core[90], _ca_, 0))
                          throw caml_maybe_attach_backtrace
                                 ([0, Assert_failure, _b_], 1);
                         var key$0 = left_key;
                        }
                        else
                         var key = diff_element[1][1], key$0 = key;
                        function new_data(param){
                         var _cb_ = param[1];
                         if(847852583 === _cb_) return 0;
                         var x = 1013247643 <= _cb_ ? param[2][2] : param[2];
                         return [0, x];
                        }
                        switch(diff_element[0]){
                          case 0:
                           var
                            left_diff = diff_element[1][2],
                            right_data_opt =
                              caml_call2(Core_Map[38], new_right_map, key$0),
                            right_data_opt$0 = right_data_opt,
                            left_data_opt = new_data(left_diff);
                           break;
                          case 1:
                           var
                            right_diff = diff_element[1][2],
                            right_data_opt$1 = new_data(right_diff),
                            right_data_opt$0 = right_data_opt$1,
                            left_data_opt =
                              caml_call2(Core_Map[38], new_left_map, key$0);
                           break;
                          default:
                           var
                            right_diff$0 = diff_element[2][2],
                            left_diff$0 = diff_element[1][2],
                            right_data_opt$2 = new_data(right_diff$0),
                            left_data_opt$0 = new_data(left_diff$0),
                            right_data_opt$0 = right_data_opt$2,
                            left_data_opt = left_data_opt$0;
                        }
                        if(left_data_opt){
                         var x = left_data_opt[1];
                         if(right_data_opt$0)
                          var
                           y = right_data_opt$0[1],
                           _b$_ = caml_call2(f, key$0, [0, 737457313, [0, x, y]]);
                         else
                          var _b$_ = caml_call2(f, key$0, [0, 847852583, x]);
                         var output_data_opt = _b$_;
                        }
                        else if(right_data_opt$0)
                         var
                          y$0 = right_data_opt$0[1],
                          output_data_opt = caml_call2(f, key$0, [0, -57574468, y$0]);
                        else
                         var output_data_opt = 0;
                        if(! output_data_opt)
                         return caml_call2(Core_Map[41], output, key$0);
                        var data = output_data_opt[1];
                        return caml_call3(Core_Map[32], output, key$0, data);
                       });
             });
   }
   function generic_mapi_with_comparator(witness, cutoff, opt, lhs){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    return function(comparator, f){
     var
      incremental_state = caml_call1(Incremental[4], lhs),
      empty_map = caml_call1(Core_Map[110][1], comparator),
      prev_map = [0, empty_map],
      prev_nodes = [0, empty_map],
      acc = [0, empty_map],
      result =
        caml_call3
         (Incremental[79][2][2],
          incremental_state,
          0,
          function(param){return acc[1];}),
      on_inner_change =
        witness
         ? function
          (key, opt){
           var old = acc[1];
           if(opt)
            var
             data = opt[1],
             _b8_ = caml_call3(Core_Map[32], old, key, data);
           else
            var _b8_ = caml_call2(Core_Map[41], old, key);
           acc[1] = _b8_;
           return 0;
          }
         : function
          (key, data){
           acc[1] = caml_call3(Core_Map[32], acc[1], key, data);
           return 0;
          },
      lhs_change = [];
     caml_update_dummy
      (lhs_change,
       [246,
        function(_b1_){
         return caml_call2
                 (Incremental[10],
                  lhs,
                  function(map){
                   var
                    new_nodes =
                      caml_call5
                       (Core_Map[81],
                        prev_map[1],
                        map,
                        data_equal,
                        prev_nodes[1],
                        function(nodes, param){
                         var changed = param[2], key = param[1], _b2_ = changed[1];
                         if(847852583 === _b2_){
                          var
                           match = caml_call2(Core_Map[39], nodes, key),
                           dep = match[2],
                           node = match[1],
                           nodes$0 = caml_call2(Core_Map[41], nodes, key);
                          caml_call2(Incremental[79][2][7], result, dep);
                          acc[1] = caml_call2(Core_Map[41], acc[1], key);
                          caml_call1(Incremental[79][2][5], node);
                          return nodes$0;
                         }
                         if(1013247643 <= _b2_){
                          var node$0 = caml_call2(Core_Map[39], nodes, key)[1];
                          caml_call1(Incremental[79][2][4], node$0);
                          return nodes;
                         }
                         var
                          node$1 =
                            caml_call3
                             (Incremental[79][2][2],
                              incremental_state,
                              0,
                              function(param){
                               return caml_call2(Core_Map[39], prev_map[1], key);
                              });
                         caml_call2
                          (Core_Option[41],
                           cutoff,
                           function(c){
                            var _b7_ = caml_call1(Incremental[79][2][3], node$1);
                            return caml_call2(Incremental[59], _b7_, c);
                           });
                         var
                          _b3_ = caml_call1(Core[237], lhs_change),
                          _b4_ = caml_call2(Incremental[79][1][2], 0, _b3_);
                         caml_call2(Incremental[79][2][6], node$1, _b4_);
                         var
                          _b5_ =
                            caml_call2
                             (f, key, caml_call1(Incremental[79][2][3], node$1)),
                          user_function_dep =
                            caml_call2
                             (Incremental[79][1][2],
                              [0, function(_b6_){return on_inner_change(key, _b6_);}],
                              _b5_);
                         caml_call2(Incremental[79][2][6], result, user_function_dep);
                         return caml_call3
                                 (Core_Map[32], nodes, key, [0, node$1, user_function_dep]);
                        });
                   prev_nodes[1] = new_nodes;
                   prev_map[1] = map;
                   return 0;
                  });
        }]);
     var
      _bZ_ = caml_call1(Core[237], lhs_change),
      _b0_ = caml_call2(Incremental[79][1][2], 0, _bZ_);
     caml_call2(Incremental[79][2][6], result, _b0_);
     return caml_call1(Incremental[79][2][3], result);};
   }
   function filter_mapi$0(cutoff, data_equal, map, f){
    return with_comparator$0
            (map,
             function(comparator){
              return generic_mapi_with_comparator(1, cutoff, data_equal, map)
                      (comparator, f);
             });
   }
   function mapi$0(cutoff, data_equal, map, f){
    return with_comparator$0
            (map,
             function(comparator){
              return generic_mapi_with_comparator(0, cutoff, data_equal, map)
                      (comparator, f);
             });
   }
   function map$0(cutoff, data_equal, map, f){
    return mapi$0
            (cutoff,
             data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function filter_map$0(cutoff, data_equal, map, f){
    return filter_mapi$0
            (cutoff,
             data_equal,
             map,
             function(param, data){return caml_call1(f, data);});
   }
   function merge$0(cutoff, data_equal_left, data_equal_right, map1, map2, f){
    return filter_mapi$0
            (cutoff,
             0,
             merge
              (data_equal_left,
               data_equal_right,
               map1,
               map2,
               function(param, diff){return [0, diff];}),
             function(key, diff){return caml_call2(f, key, diff);});
   }
   function unzip_mapi
   (data_equal, left_result_equal, right_result_equal, input, f){
    var
     pair =
       with_comparator$0
        (input,
         function(comparator){
          if(data_equal)
           var sth = data_equal[1], data_equal$0 = sth;
          else
           var data_equal$0 = Core[246];
          if(left_result_equal)
           var sth$0 = left_result_equal[1], left_result_equal$0 = sth$0;
          else
           var left_result_equal$0 = Core[246];
          if(right_result_equal)
           var sth$1 = right_result_equal[1], right_result_equal$0 = sth$1;
          else
           var right_result_equal$0 = Core[246];
          var
           incremental_state = caml_call1(Incremental[4], input),
           empty_map = caml_call1(Core_Map[110][1], comparator),
           left_acc = [0, empty_map],
           left_result =
             caml_call3
              (Incremental[79][2][2],
               incremental_state,
               0,
               function(param){return left_acc[1];}),
           right_acc = [0, empty_map],
           right_result =
             caml_call3
              (Incremental[79][2][2],
               incremental_state,
               0,
               function(param){return right_acc[1];}),
           prev_map = [0, empty_map],
           input_change =
             caml_call2
              (Incremental[10],
               input,
               function(map){
                var
                 match = caml_call1(Core_Map[28], prev_map[1]),
                 match$0 = caml_call1(Core_Map[28], map);
                a:
                {
                 if(match){
                  if(! match$0){
                   var
                    left$0 =
                      caml_call2
                       (Core_Map[52],
                        map,
                        function(key, data){
                         var l = caml_call2(f, key, data)[1];
                         return l;
                        }),
                    right$0 =
                      caml_call2
                       (Core_Map[52],
                        map,
                        function(key, data){
                         var r = caml_call2(f, key, data)[2];
                         return r;
                        }),
                    right = right$0,
                    left = left$0;
                   break a;
                  }
                 }
                 else if(! match$0){
                  var
                   _bU_ =
                     caml_call5
                      (Core_Map[81],
                       prev_map[1],
                       map,
                       data_equal$0,
                       [0, left_acc[1], right_acc[1]],
                       function(param, _bV_){
                        var
                         changed = _bV_[2],
                         key = _bV_[1],
                         right = param[2],
                         left = param[1],
                         _bW_ = changed[1];
                        if(847852583 === _bW_){
                         var _bX_ = caml_call2(Core_Map[41], right, key);
                         return [0, caml_call2(Core_Map[41], left, key), _bX_];
                        }
                        if(1013247643 <= _bW_){
                         var
                          match = changed[2],
                          new$0 = match[2],
                          prev = match[1],
                          match$0 = caml_call2(f, key, prev),
                          prev_b = match$0[2],
                          prev_a = match$0[1],
                          match$1 = caml_call2(f, key, new$0),
                          new_b = match$1[2],
                          new_a = match$1[1],
                          left$0 =
                            caml_call2(left_result_equal$0, prev_a, new_a)
                             ? left
                             : caml_call3(Core_Map[32], left, key, new_a),
                          right$0 =
                            caml_call2(right_result_equal$0, prev_b, new_b)
                             ? right
                             : caml_call3(Core_Map[32], right, key, new_b);
                         return [0, left$0, right$0];
                        }
                        var
                         element = changed[2],
                         match$2 = caml_call2(f, key, element),
                         b = match$2[2],
                         a = match$2[1],
                         _bY_ = caml_call3(Core_Map[32], right, key, b);
                        return [0, caml_call3(Core_Map[32], left, key, a), _bY_];
                       }),
                   right = _bU_[2],
                   left = _bU_[1];
                  break a;
                 }
                 var right = empty_map, left = empty_map;
                }
                if(1 - caml_call2(Core[246], left_acc[1], left))
                 caml_call1(Incremental[79][2][4], left_result);
                if(1 - caml_call2(Core[246], right_acc[1], right))
                 caml_call1(Incremental[79][2][4], right_result);
                left_acc[1] = left;
                right_acc[1] = right;
                prev_map[1] = map;
                return 0;
               }),
           _bQ_ = caml_call2(Incremental[79][1][2], 0, input_change);
          caml_call2(Incremental[79][2][6], left_result, _bQ_);
          var _bR_ = caml_call2(Incremental[79][1][2], 0, input_change);
          caml_call2(Incremental[79][2][6], right_result, _bR_);
          var
           _bS_ = caml_call1(Incremental[79][2][3], right_result),
           _bT_ = [0, caml_call1(Incremental[79][2][3], left_result), _bS_];
          return caml_call2(Core_Tuple[1][8], Incremental[40], _bT_);
         }),
     _bN_ = caml_call2(Incremental[10], pair, function(_bP_){return _bP_[2];});
    return [0,
            caml_call2(Incremental[10], pair, function(_bO_){return _bO_[1];}),
            _bN_];
   }
   function unzip(left_result_equal, right_result_equal, input){
    var
     data_equal =
       caml_call3
        (Core_Option[23],
         left_result_equal,
         right_result_equal,
         function(l, r){return caml_call2(Core_Tuple[1][10], l, r);});
    return unzip_mapi
            (data_equal,
             left_result_equal,
             right_result_equal,
             input,
             function(param, data){return data;});
   }
   function unzip_mapi$0(cutoff, data_equal, input, f){
    var
     pair =
       with_comparator$0
        (input,
         function(comparator){
          if(data_equal)
           var sth = data_equal[1], data_equal$0 = sth;
          else
           var data_equal$0 = Core[246];
          var
           incremental_state = caml_call1(Incremental[4], input),
           empty_map = caml_call1(Core_Map[110][1], comparator),
           prev_map = [0, empty_map],
           prev_nodes = [0, empty_map],
           left_acc = [0, empty_map],
           left_result =
             caml_call3
              (Incremental[79][2][2],
               incremental_state,
               0,
               function(param){return left_acc[1];}),
           right_acc = [0, empty_map],
           right_result =
             caml_call3
              (Incremental[79][2][2],
               incremental_state,
               0,
               function(param){return right_acc[1];}),
           input_change = [];
          caml_update_dummy
           (input_change,
            [246,
             function(_bI_){
              return caml_call2
                      (Incremental[10],
                       input,
                       function(map){
                        var
                         new_nodes =
                           caml_call5
                            (Core_Map[81],
                             prev_map[1],
                             map,
                             data_equal$0,
                             prev_nodes[1],
                             function(nodes, param){
                              var changed = param[2], key = param[1], _bJ_ = changed[1];
                              if(847852583 === _bJ_){
                               var
                                match = caml_call2(Core_Map[39], nodes, key),
                                right_dep = match[3],
                                left_dep = match[2],
                                node = match[1],
                                nodes$0 = caml_call2(Core_Map[41], nodes, key);
                               caml_call2(Incremental[79][2][7], left_result, left_dep);
                               caml_call2(Incremental[79][2][7], right_result, right_dep);
                               left_acc[1] = caml_call2(Core_Map[41], left_acc[1], key);
                               right_acc[1] = caml_call2(Core_Map[41], right_acc[1], key);
                               caml_call1(Incremental[79][2][5], node);
                               return nodes$0;
                              }
                              if(1013247643 <= _bJ_){
                               var node$0 = caml_call2(Core_Map[39], nodes, key)[1];
                               caml_call1(Incremental[79][2][4], node$0);
                               return nodes;
                              }
                              var
                               node$1 =
                                 caml_call3
                                  (Incremental[79][2][2],
                                   incremental_state,
                                   0,
                                   function(param){
                                    return caml_call2(Core_Map[39], prev_map[1], key);
                                   });
                              caml_call2
                               (Core_Option[41],
                                cutoff,
                                function(c){
                                 var _bM_ = caml_call1(Incremental[79][2][3], node$1);
                                 return caml_call2(Incremental[59], _bM_, c);
                                });
                              var
                               _bK_ = caml_call1(Core[237], input_change),
                               _bL_ = caml_call2(Incremental[79][1][2], 0, _bK_);
                              caml_call2(Incremental[79][2][6], node$1, _bL_);
                              var
                               match$0 =
                                 caml_call2
                                  (f, key, caml_call1(Incremental[79][2][3], node$1)),
                               right_incr = match$0[2],
                               left_incr = match$0[1],
                               left_user_function_dep =
                                 caml_call2
                                  (Incremental[79][1][2],
                                   [0,
                                    function(data){
                                     left_acc[1] =
                                      caml_call3(Core_Map[32], left_acc[1], key, data);
                                     return 0;
                                    }],
                                   left_incr),
                               right_user_function_dep =
                                 caml_call2
                                  (Incremental[79][1][2],
                                   [0,
                                    function(data){
                                     right_acc[1] =
                                      caml_call3(Core_Map[32], right_acc[1], key, data);
                                     return 0;
                                    }],
                                   right_incr);
                              caml_call2
                               (Incremental[79][2][6], left_result, left_user_function_dep);
                              caml_call2
                               (Incremental[79][2][6],
                                right_result,
                                right_user_function_dep);
                              return caml_call3
                                      (Core_Map[32],
                                       nodes,
                                       key,
                                       [0, node$1, left_user_function_dep, right_user_function_dep]);
                             });
                        prev_nodes[1] = new_nodes;
                        prev_map[1] = map;
                        return 0;
                       });
             }]);
          var
           _bC_ = caml_call1(Core[237], input_change),
           _bD_ = caml_call2(Incremental[79][1][2], 0, _bC_);
          caml_call2(Incremental[79][2][6], left_result, _bD_);
          var
           _bE_ = caml_call1(Core[237], input_change),
           _bF_ = caml_call2(Incremental[79][1][2], 0, _bE_);
          caml_call2(Incremental[79][2][6], right_result, _bF_);
          var
           _bG_ = caml_call1(Incremental[79][2][3], right_result),
           _bH_ = [0, caml_call1(Incremental[79][2][3], left_result), _bG_];
          return caml_call2(Core_Tuple[1][8], Incremental[40], _bH_);
         }),
     _bz_ = caml_call2(Incremental[10], pair, function(_bB_){return _bB_[2];});
    return [0,
            caml_call2(Incremental[10], pair, function(_bA_){return _bA_[1];}),
            _bz_];
   }
   function keys(map){
    return with_comparator$0
            (map,
             function(comparator){
              function add(key, param, acc){
               return caml_call2(Core_Set[11], acc, key);
              }
              function remove(key, param, acc){
               return caml_call2(Core_Set[12], acc, key);
              }
              function data_equal(param, _by_){return 1;}
              return unordered_fold
                      ([0, data_equal],
                       0,
                       0,
                       _c_,
                       map,
                       caml_call1(Core_Set[3][1], comparator),
                       add,
                       remove);
             });
   }
   function partition_mapi(data_equal, map, f){
    return with_comparator$0
            (map,
             function(comparator){
              var empty = caml_call1(Core_Map[110][1], comparator);
              return unordered_fold
                      (data_equal,
                       [0,
                        function(key, param, data, _bv_){
                         var
                          second = _bv_[2],
                          first = _bv_[1],
                          match = caml_call2(f, key, data);
                         if(0 === match[0]){
                          var
                           data$0 = match[1],
                           _bw_ = caml_call2(Core_Map[41], second, key);
                          return [0,
                                  caml_call3(Core_Map[32], first, key, data$0),
                                  _bw_];
                         }
                         var
                          data$1 = match[1],
                          _bx_ = caml_call3(Core_Map[32], second, key, data$1);
                         return [0, caml_call2(Core_Map[41], first, key), _bx_];
                        }],
                       0,
                       _d_,
                       map,
                       [0, empty, empty],
                       function(key, data, param){
                        var
                         second = param[2],
                         first = param[1],
                         match = caml_call2(f, key, data);
                        if(0 === match[0]){
                         var data$0 = match[1];
                         return [0,
                                 caml_call3(Core_Map[31], first, key, data$0),
                                 second];
                        }
                        var data$1 = match[1];
                        return [0,
                                first,
                                caml_call3(Core_Map[31], second, key, data$1)];
                       },
                       function(key, param, _bt_){
                        var
                         second = _bt_[2],
                         first = _bt_[1],
                         _bu_ = caml_call2(Core_Map[41], second, key);
                        return [0, caml_call2(Core_Map[41], first, key), _bu_];
                       });
             });
   }
   function flatten(state, map){
    var
     _br_ = caml_call1(Core_Map[2], map),
     result = [0, caml_call1(Core_Map[110][1], _br_)],
     node =
       caml_call3
        (Incremental[79][2][2], state, 0, function(param){return result[1];});
    caml_call2
     (Core_Map[45],
      map,
      function(key, incr){
       var
        _bs_ =
          caml_call2
           (Incremental[79][1][2],
            [0,
             function(a){
              result[1] = caml_call3(Core_Map[32], result[1], key, a);
              return 0;
             }],
            incr);
       return caml_call2(Incremental[79][2][6], node, _bs_);
      });
    return caml_call1(Incremental[79][2][3], node);
   }
   function join(map_incr){
    return with_comparator$0
            (map_incr,
             function(comparator){
              var
               incremental_state = caml_call1(Incremental[4], map_incr),
               empty_map = caml_call1(Core_Map[110][1], comparator),
               result_map = [0, empty_map],
               old_map_of_incrs = [0, empty_map],
               current_dependencies = [0, empty_map],
               result =
                 caml_call3
                  (Incremental[79][2][2],
                   incremental_state,
                   0,
                   function(param){return result_map[1];});
              function add_subnode(current_dependencies, key, data_node){
               var
                new_dep =
                  caml_call2
                   (Incremental[79][1][2],
                    [0,
                     function(data){
                      result_map[1] =
                       caml_call3(Core_Map[32], result_map[1], key, data);
                      return 0;
                     }],
                    data_node);
               caml_call2(Incremental[79][2][6], result, new_dep);
               return caml_call3
                       (Core_Map[32], current_dependencies, key, new_dep);
              }
              function remove_subnode(current_dependencies, key){
               var dep = caml_call2(Core_Map[39], current_dependencies, key);
               caml_call2(Incremental[79][2][7], result, dep);
               result_map[1] = caml_call2(Core_Map[41], result_map[1], key);
               return caml_call2(Core_Map[41], current_dependencies, key);
              }
              var
               lhs_change =
                 caml_call2
                  (Incremental[10],
                   map_incr,
                   function(map_of_incrs){
                    var
                     new_dependency_map =
                       caml_call5
                        (Core_Map[81],
                         old_map_of_incrs[1],
                         map_of_incrs,
                         Core[246],
                         current_dependencies[1],
                         function(current_dependencies, param){
                          var diff = param[2], key = param[1], _bq_ = diff[1];
                          if(847852583 === _bq_)
                           return remove_subnode(current_dependencies, key);
                          if(1013247643 <= _bq_){
                           var data_node = diff[2][2];
                           return add_subnode
                                   (remove_subnode(current_dependencies, key), key, data_node);
                          }
                          var data_node$0 = diff[2];
                          return add_subnode(current_dependencies, key, data_node$0);
                         });
                    current_dependencies[1] = new_dependency_map;
                    old_map_of_incrs[1] = map_of_incrs;
                    return 0;
                   }),
               _bp_ = caml_call2(Incremental[79][1][2], 0, lhs_change);
              caml_call2(Incremental[79][2][6], result, _bp_);
              return caml_call1(Incremental[79][2][3], result);
             });
   }
   function separate(input_map, data_equal){
    var incremental_state = caml_call1(Incremental[4], input_map);
    return with_comparator$0
            (input_map,
             function(comparator){
              var
               empty = caml_call1(Core_Map[110][1], comparator),
               state = [0, empty, empty, empty],
               output_map_node =
                 caml_call3
                  (Incremental[79][2][2],
                   incremental_state,
                   0,
                   function(param){return state[3];});
              function make_node_depend_on_input_map_(node, input_map_changed){
               var
                _bo_ = caml_call1(Core_Lazy[32], input_map_changed),
                dependency = caml_call2(Incremental[79][1][2], 0, _bo_);
               return caml_call2(Incremental[79][2][6], node, dependency);
              }
              var input_map_changed = [];
              caml_update_dummy
               (input_map_changed,
                [246,
                 function(_bh_){
                  return caml_call2
                          (Incremental[10],
                           input_map,
                           function(input_map){
                            var
                             prev_input_map = state[1],
                             match =
                               caml_call5
                                (Core_Map[81],
                                 prev_input_map,
                                 input_map,
                                 data_equal,
                                 [0, state[2], state[3]],
                                 function(param, _bi_){
                                  var
                                   change = _bi_[2],
                                   key = _bi_[1],
                                   output_map = param[2],
                                   expert_nodes = param[1],
                                   _bj_ = change[1];
                                  if(847852583 === _bj_){
                                   var old_node = caml_call2(Core_Map[39], expert_nodes, key);
                                   caml_call1(Incremental[79][2][5], old_node);
                                   caml_call1(Incremental[79][2][4], output_map_node);
                                   var _bk_ = caml_call2(Core_Map[41], output_map, key);
                                   return [0,
                                           caml_call2(Core_Map[41], expert_nodes, key),
                                           _bk_];
                                  }
                                  if(1013247643 <= _bj_){
                                   var _bl_ = caml_call2(Core_Map[39], expert_nodes, key);
                                   caml_call1(Incremental[79][2][4], _bl_);
                                   return [0, expert_nodes, output_map];
                                  }
                                  var
                                   node =
                                     caml_call3
                                      (Incremental[79][2][2],
                                       incremental_state,
                                       0,
                                       function(param){
                                        return caml_call2(Core_Map[39], state[1], key);
                                       });
                                  make_node_depend_on_input_map_(node, input_map_changed);
                                  caml_call1(Incremental[79][2][4], output_map_node);
                                  var
                                   _bm_ = caml_call1(Incremental[79][2][3], node),
                                   _bn_ = caml_call3(Core_Map[31], output_map, key, _bm_);
                                  return [0,
                                          caml_call3(Core_Map[31], expert_nodes, key, node),
                                          _bn_];
                                 }),
                             output_map = match[2],
                             expert_nodes = match[1];
                            state[1] = input_map;
                            state[2] = expert_nodes;
                            state[3] = output_map;
                            return 0;
                           });
                 }]);
              make_node_depend_on_input_map_
               (output_map_node, input_map_changed);
              return caml_call1(Incremental[79][2][3], output_map_node);
             });
   }
   function subrange(opt, map_incr){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    return function(range){
     return with_old2
             (map_incr,
              range,
              function(old, map, range){
               var compare = caml_call1(Core_Map[2], map)[1];
               function equal(l, r){
                var _bg_ = caml_call2(compare, l, r);
                return caml_call2(Core[90], _bg_, 0);
               }
               function maybe_bound_equal(a_002, b_003){
                if(caml_call2(Ppx_compare_lib[1], a_002, b_003)) return 1;
                if(typeof a_002 === "number"){
                 if(typeof b_003 === "number") return 1;
                 if(1 === b_003[0]) return 0;
                }
                else{
                 if(0 === a_002[0]){
                  var a_004 = a_002[1];
                  if(typeof b_003 !== "number" && 0 === b_003[0]){
                   var b_005 = b_003[1];
                   return equal(a_004, b_005);
                  }
                  return 0;
                 }
                 var a_006 = a_002[1];
                 if(typeof b_003 === "number") return 0;
                 if(0 !== b_003[0]){
                  var b_007 = b_003[1];
                  return equal(a_006, b_007);
                 }
                }
                return 0;
               }
               function range_is_empty(min, max){
                a:
                if(typeof min !== "number"){
                 if(0 === min[0]){
                  var min$0 = min[1];
                  if(typeof max === "number") break a;
                  if(0 === max[0]){
                   var
                    max$0 = max[1],
                    _bd_ = caml_call2(compare, min$0, max$0);
                   return caml_call2(Core[91], _bd_, 0);
                  }
                  var max$1 = max[1], min$1 = min$0;
                 }
                 else{
                  var _bf_ = min[1];
                  if(typeof max === "number") break a;
                  var max$1 = max[1], min$1 = _bf_;
                 }
                 var _be_ = caml_call2(compare, min$1, max$1);
                 return caml_call2(Core[88], _be_, 0);
                }
                return 0;
               }
               function range_includes(min, max, key){
                var
                 _bc_ = caml_call3(Core_Maybe_bound[17], min, key, compare);
                return _bc_
                        ? caml_call3(Core_Maybe_bound[18], max, key, compare)
                        : _bc_;
               }
               if(! range){
                var _a7_ = caml_call1(Core_Map[2], map);
                return caml_call1(Core_Map[110][1], _a7_);
               }
               var range$0 = range[1], max = range$0[2], min = range$0[1];
               function from_scratch(param){
                return caml_call3(Core_Map[94], map, min, max);
               }
               if(old){
                var _a6_ = old[1], match = _a6_[2];
                if(match){
                 var
                  old_range = match[1],
                  old_min = old_range[1],
                  old_map = _a6_[1],
                  old_max = old_range[2];
                 if
                  (!
                   range_is_empty(old_min, old_max)
                   &&
                    !
                    range_is_empty(min, old_max)
                    && ! range_is_empty(old_min, max)){
                  var old_res = _a6_[3], old_max$0 = old_range[2];
                  return caml_call1
                          (Core[260],
                           function(param){
                            function apply_diff_in_intersection(param$0, _a$_){
                             var
                              data = _a$_[2],
                              key = _a$_[1],
                              map = param$0[2],
                              outside = param$0[1],
                              _a__ = range_includes(min, max, key),
                              _ba_ = _a__ ? range_includes(old_min, old_max$0, key) : _a__;
                             if(! _ba_){
                              var outside$0 = outside - 1 | 0;
                              return 0 <= outside$0
                                      ? [0, outside$0, caml_call2(Core_Map[41], map, key)]
                                      : caml_call1(param, from_scratch(0));
                             }
                             var _bb_ = data[1];
                             if(847852583 === _bb_)
                              return [0, outside, caml_call2(Core_Map[41], map, key)];
                             var data$0 = 1013247643 <= _bb_ ? data[2][2] : data[2];
                             return [0,
                                     outside,
                                     caml_call3(Core_Map[32], map, key, data$0)];
                            }
                            var
                             outside_cutoff = caml_call1(Core_Map[29], old_res) / 4 | 0,
                             with_updated_values_in_interse =
                               caml_call5
                                 (Core_Map[81],
                                  old_map,
                                  map,
                                  data_equal,
                                  [0, outside_cutoff, old_res],
                                  apply_diff_in_intersection)
                                [2];
                            if
                             (caml_call4
                               (Core_Tuple[1][10],
                                maybe_bound_equal,
                                maybe_bound_equal,
                                old_range,
                                range$0))
                             return with_updated_values_in_interse;
                            var
                             without_keys_out_of_range =
                               caml_call3
                                (Core_Map[94], with_updated_values_in_interse, min, max);
                            function map_append_exn(lower_part, upper_part){
                             var
                              match = caml_call2(Core_Map[93], lower_part, upper_part);
                             if(typeof match === "number")
                              return caml_call1(Core[6], cst_impossible_case_BUG_in_inc);
                             var map = match[2];
                             return map;
                            }
                            if(typeof old_min === "number")
                             var
                              _a8_ = caml_call1(Core_Map[2], map),
                              lower_part = caml_call1(Core_Map[110][1], _a8_);
                            else if(0 === old_min[0])
                             var
                              old_min$0 = old_min[1],
                              lower_part =
                                caml_call3(Core_Map[94], map, min, [1, old_min$0]);
                            else
                             var
                              old_min$1 = old_min[1],
                              lower_part =
                                caml_call3(Core_Map[94], map, min, [0, old_min$1]);
                            if(typeof old_max$0 === "number")
                             var
                              _a9_ = caml_call1(Core_Map[2], map),
                              upper_part = caml_call1(Core_Map[110][1], _a9_);
                            else if(0 === old_max$0[0])
                             var
                              old_max = old_max$0[1],
                              upper_part =
                                caml_call3(Core_Map[94], map, [1, old_max], max);
                            else
                             var
                              old_max$1 = old_max$0[1],
                              upper_part =
                                caml_call3(Core_Map[94], map, [0, old_max$1], max);
                            var
                             with_new_keys_now_in_range =
                               map_append_exn
                                (lower_part,
                                 map_append_exn(without_keys_out_of_range, upper_part));
                            return with_new_keys_now_in_range;
                           });
                 }
                 return from_scratch(0);
                }
               }
               return from_scratch(0);
              });};
   }
   function rekey(data_equal, map_incr, outer_comparator, f){
    return unordered_fold
            (data_equal,
             [0,
              function(key, old_data, new_data, output){
               var
                prev_key = caml_call2(f, key, old_data),
                new_key = caml_call2(f, key, new_data),
                _a4_ =
                  caml_call2
                   (caml_call1(Core_Map[2], output)[1], prev_key, new_key);
               if(caml_call2(Core[90], _a4_, 0))
                return caml_call3(Core_Map[32], output, new_key, new_data);
               var _a5_ = caml_call2(Core_Map[41], output, prev_key);
               return caml_call3(Core_Map[31], _a5_, new_key, new_data);
              }],
             0,
             _e_,
             map_incr,
             caml_call1(Core_Map[4], outer_comparator),
             function(key, data, output){
              var _a3_ = caml_call2(f, key, data);
              return caml_call3(Core_Map[31], output, _a3_, data);
             },
             function(key, data, output){
              var _a2_ = caml_call2(f, key, data);
              return caml_call2(Core_Map[41], output, _a2_);
             });
   }
   function index_byi(data_equal, map_incr, outer_comparator, index){
    return with_comparator$0
            (map_incr,
             function(inner_comparator){
              return unordered_fold
                      (data_equal,
                       0,
                       0,
                       _f_,
                       map_incr,
                       caml_call1(Core_Map[4], outer_comparator),
                       function(inner_key, data, outer_map){
                        var match = caml_call2(index, inner_key, data);
                        if(! match) return outer_map;
                        var outer_key = match[1];
                        return caml_call3
                                (Core_Map[37],
                                 outer_map,
                                 outer_key,
                                 function(param){
                                  if(! param)
                                   return caml_call3
                                           (Core_Map[110][2], inner_comparator, inner_key, data);
                                  var inner_map = param[1];
                                  return caml_call3(Core_Map[31], inner_map, inner_key, data);
                                 });
                       },
                       function(inner_key, data, outer_map){
                        var match = caml_call2(index, inner_key, data);
                        if(! match) return outer_map;
                        var outer_key = match[1];
                        return caml_call3
                                (Core_Map[36],
                                 outer_map,
                                 outer_key,
                                 function(param){
                                  if(! param)
                                   return caml_call1(Core[6], cst_BUG_Hit_supposedly_impossi);
                                  var
                                   inner_map = param[1],
                                   inner_map$0 = caml_call2(Core_Map[41], inner_map, inner_key);
                                  return caml_call1(Core_Map[28], inner_map$0)
                                          ? 0
                                          : [0, inner_map$0];
                                 });
                       });
             });
   }
   function index_by(data_equal, map_incr, comparator, index){
    return index_byi
            (data_equal,
             map_incr,
             comparator,
             function(param, data){return caml_call1(index, data);});
   }
   function is_known(param){
    if(typeof param === "number" && param) return 0;
    return 1;
   }
   function to_option(param){
    if(typeof param === "number") return 0;
    var k = param[1];
    return [0, k];
   }
   function find_key_range_linear(from, to, map){
    var
     len = caml_call1(Core_Map[29], map),
     begin_key = caml_call2(Core_Int[84], from, len) ? 0 : 1,
     end_key = caml_call2(Core_Int[84], to, len) ? 0 : 1;
    function find_keys(fold, start_pos, advance_pos){
     return caml_call1
             (Core[260],
              function(param){
               return caml_call3
                       (fold,
                        map,
                        [0, begin_key, end_key, start_pos],
                        function(key, param$0, _a1_){
                         var
                          pos = _a1_[3],
                          end_key = _a1_[2],
                          begin_key = _a1_[1],
                          begin_key$0 =
                            caml_call2(Core_Int[86], pos, from) ? [0, key] : begin_key,
                          end_key$0 =
                            caml_call2(Core_Int[86], pos, to) ? [0, key] : end_key;
                         if(is_known(begin_key$0) && is_known(end_key$0))
                          return caml_call1(param, [0, begin_key$0, end_key$0, pos]);
                         return [0,
                                 begin_key$0,
                                 end_key$0,
                                 caml_call1(advance_pos, pos)];
                        });
              });
    }
    var
     match =
       caml_call2(Core[92], to, len - from | 0)
        ? find_keys(Core_Map[55], 0, function(pos){return pos + 1 | 0;})
        : find_keys
          (Core_Map[57], len - 1 | 0, function(pos){return pos - 1 | 0;}),
     end_key$0 = match[2],
     begin_key$0 = match[1],
     _a0_ = to_option(begin_key$0);
    return caml_call2
            (Core_Option[29],
             _a0_,
             function(begin_key){return [0, begin_key, to_option(end_key$0)];});
   }
   function find_offset(compare, key, changed_key, change){
    var _aY_ = caml_call2(compare, changed_key, key);
    if(! caml_call2(Core_Int[88], _aY_, 0)) return 0;
    if(typeof change !== "number"){
     var _aZ_ = change[1];
     if(-57574468 === _aZ_) return -1;
     if(847852583 === _aZ_) return 1;
    }
    return 0;
   }
   function rank(map, key){
    return with_comparator$0
            (map,
             function(comparator){
              var compare_key = comparator[1];
              function same_key(a, b){
               var _aX_ = caml_call2(compare_key, a, b);
               return caml_call2(Core[90], _aX_, 0);
              }
              function process(old, new_map, new_key){
               var old$0 = old;
               for(;;){
                if(! caml_call2(Core_Map[42], new_map, new_key)) return 0;
                if(old$0){
                 var
                  match = old$0[1],
                  old_rank = match[3],
                  old_key = match[2],
                  old_map = match[1];
                 if
                  (caml_call2(Core[246], new_map, old_map)
                   && same_key(old_key, new_key))
                  return old_rank;
                 if(old_rank){
                  var old_rank$0 = old_rank[1];
                  if(! caml_call2(Core[246], new_map, old_map)){
                   if(same_key(new_key, old_key))
                    return [0,
                            caml_call5
                             (Core_Map[81],
                              old_map,
                              new_map,
                              function(param, _aW_){return 1;},
                              old_rank$0,
                              function(acc, param){
                               var diff = param[2], diff_key = param[1];
                               if(typeof diff !== "number"){
                                var _aT_ = diff[1];
                                if(-57574468 === _aT_){
                                 var _aU_ = caml_call2(compare_key, diff_key, new_key);
                                 if(caml_call2(Core[92], _aU_, 0)) return acc + 1 | 0;
                                }
                                else if(847852583 === _aT_){
                                 var _aV_ = caml_call2(compare_key, diff_key, new_key);
                                 if(caml_call2(Core[92], _aV_, 0)) return acc - 1 | 0;
                                }
                               }
                               return acc;
                              })];
                   var
                    old_rank$1 =
                      process
                       ([0, [0, old_map, old_key, [0, old_rank$0]]],
                        new_map,
                        old_key),
                    old$1 = [0, [0, new_map, old_key, old_rank$1]];
                   old$0 = old$1;
                   continue;
                  }
                  var _aR_ = caml_call2(compare_key, new_key, old_key);
                  if(caml_call2(Core[92], _aR_, 0))
                   var
                    upper_bound = [1, old_key],
                    lower_bound = [1, new_key],
                    subrange =
                      caml_call3(Core_Map[94], new_map, lower_bound, upper_bound),
                    _aS_ =
                      (old_rank$0 - caml_call1(Core_Map[29], subrange) | 0) - 1
                      | 0;
                  else
                   var
                    upper_bound$0 = [1, new_key],
                    lower_bound$0 = [1, old_key],
                    subrange$0 =
                      caml_call3
                       (Core_Map[94], new_map, lower_bound$0, upper_bound$0),
                    _aS_ =
                      (old_rank$0 + caml_call1(Core_Map[29], subrange$0) | 0) + 1
                      | 0;
                  return [0, _aS_];
                 }
                }
                return caml_call2(Core_Map[100], new_map, new_key);
               }
              }
              return with_old2(map, key, process);
             });
   }
   function subrange_by_rank(data_equal, map, range){
    function find_key_range(range){
     return with_old2
             (map,
              range,
              function(old, map, param){
               var
                to = param[2],
                from = param[1],
                _aB_ = caml_call2(Core_Int[88], to, from),
                _aC_ = _aB_ || caml_call2(Core_Int[88], from, 0);
               if(_aC_){
                var
                 _aD_ =
                   [0, [1, [0, _g_, [0, caml_call1(Core[356], to), 0]]], 0],
                 _aE_ =
                   [0,
                    [1, [0, _h_, [0, caml_call1(Core[356], from), 0]]],
                    _aD_],
                 _aF_ =
                   [1,
                    [0,
                     caml_call1(Sexplib0_Sexp_conv[7], cst_Invalid_indices),
                     _aE_]];
                caml_call1(Core[253], _aF_);
               }
               if(old){
                var _aG_ = old[1], _aH_ = _aG_[3];
                if(_aH_){
                 var
                  _aI_ = _aH_[1],
                  end_key_opt$0 = _aI_[2],
                  begin_key = _aI_[1],
                  match = _aG_[2],
                  old_to = match[2],
                  old_from = match[1],
                  old_map = _aG_[1],
                  _aJ_ = caml_call1(Core_Map[2], map)[1],
                  range_offset_begin = from - old_from | 0,
                  range_offset_end = to - old_to | 0,
                  adjust_and_offset =
                    function(by$1, key$1){
                     a:
                     {
                      if
                       (caml_call2(Core[88], by$1, 0)
                        && ! caml_call2(Core_Map[42], map, key$1)){var _aQ_ = 1; break a;}
                      var _aQ_ = 0;
                     }
                     var by$2 = by$1 + _aQ_ | 0, key = key$1, by = by$2;
                     for(;;){
                      if(caml_call2(Core_Int[86], by, 0)) return [0, key];
                      if(caml_call2(Core_Int[88], by, 0))
                       var add = 1, closest_dir = -640801497;
                      else
                       var add = -1, closest_dir = -779285466;
                      var match = caml_call3(Core_Map[97], map, closest_dir, key);
                      if(! match) return 0;
                      var key$0 = match[1][1], by$0 = by + add | 0;
                      key = key$0;
                      by = by$0;
                     }
                    },
                  diff =
                    function(init, f){
                     return caml_call5
                             (Core_Map[81],
                              old_map,
                              map,
                              function(param, _aP_){return 1;},
                              init,
                              f);
                    };
                 if(end_key_opt$0)
                  var
                   end_key = end_key_opt$0[1],
                   match$0 =
                     diff
                      (_i_,
                       function(param, _aM_){
                        var
                         change = _aM_[2],
                         key = _aM_[1],
                         offset_end = param[2],
                         offset_begin = param[1],
                         _aN_ =
                           offset_end + find_offset(_aJ_, end_key, key, change) | 0;
                        return [0,
                                offset_begin + find_offset(_aJ_, begin_key, key, change) | 0,
                                _aN_];
                       }),
                   map_offset_end = match$0[2],
                   map_offset_begin = match$0[1],
                   end_key_opt$1 =
                     adjust_and_offset
                      (map_offset_end + range_offset_end | 0, end_key),
                   end_key_opt$2 = end_key_opt$1,
                   begin_key_opt =
                     adjust_and_offset
                      (map_offset_begin + range_offset_begin | 0, begin_key);
                 else
                  var
                   map_offset_begin$0 =
                     diff
                      (0,
                       function(offset_begin, param){
                        var change = param[2], key = param[1];
                        return offset_begin
                               + find_offset(_aJ_, begin_key, key, change)
                               | 0;
                       }),
                   _aA_ = find_key_range_linear(to, to, map),
                   end_key_opt =
                     caml_call2
                      (Core_Option[29], _aA_, function(_aO_){return _aO_[1];}),
                   begin_key_opt$0 =
                     adjust_and_offset
                      (map_offset_begin$0 + range_offset_begin | 0, begin_key),
                   end_key_opt$2 = end_key_opt,
                   begin_key_opt = begin_key_opt$0;
                 var _aK_ = caml_call1(Core_Map[42], map);
                 if(! caml_call2(Core_Option[43], begin_key_opt, _aK_))
                  throw caml_maybe_attach_backtrace
                         ([0, Assert_failure, _k_], 1);
                 var _aL_ = caml_call1(Core_Map[42], map);
                 if(caml_call2(Core_Option[43], end_key_opt$2, _aL_))
                  return caml_call2
                          (Core_Option[29],
                           begin_key_opt,
                           function(begin_key){return [0, begin_key, end_key_opt$2];});
                 throw caml_maybe_attach_backtrace
                        ([0, Assert_failure, _j_], 1);
                }
               }
               return find_key_range_linear(from, to, map);
              });
    }
    function symbol(new$0, bound){
     return caml_call2
             (Core_Maybe_bound[16], bound, function(param){return new$0;});
    }
    var
     _aq_ = caml_call1(Incremental[4], map),
     return$0 = caml_call1(Incremental[9], _aq_),
     _ar_ =
       caml_call2
        (Incremental[76][3][5],
         range,
         function(param){
          return typeof param[1] === "number"
                  ? typeof param[2] === "number" ? 0 : 3
                  : typeof param[2] === "number" ? 2 : 1;
         }),
     key_range =
       caml_call2
        (Incremental[76][3][1],
         _ar_,
         function(param){
          if(3 < param >>> 0)
           throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
          switch(param){
            case 0:
             return caml_call1(return$0, _m_);
            case 1:
             var
              l =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   var _az_ = param[1];
                   if(typeof _az_ !== "number"){
                    var pattern_syntax_008 = _az_[1];
                    if(typeof param[2] !== "number") return pattern_syntax_008;
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _n_], 1);
                  }),
              lb =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   var pattern_syntax_009 = param[1];
                   if
                    (typeof pattern_syntax_009 !== "number"
                     && typeof param[2] !== "number")
                    return pattern_syntax_009;
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _o_], 1);
                  }),
              u =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   if(typeof param[1] !== "number"){
                    var match = param[2];
                    if(typeof match !== "number"){
                     var pattern_syntax_010 = match[1];
                     return pattern_syntax_010;
                    }
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _p_], 1);
                  }),
              ub =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   if(typeof param[1] !== "number"){
                    var pattern_syntax_011 = param[2];
                    if(typeof pattern_syntax_011 !== "number")
                     return pattern_syntax_011;
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _q_], 1);
                  }),
              let_syntax_016 =
                find_key_range(caml_call2(Incremental[40], l, u)),
              _as_ = caml_call2(Incremental[76][3][20], lb, ub),
              _at_ = caml_call2(Incremental[76][3][20], let_syntax_016, _as_);
             return caml_call2
                     (Incremental[76][3][5],
                      _at_,
                      function(param){
                       var
                        match = param[2],
                        ub = match[2],
                        lb = match[1],
                        key_range = param[1];
                       if(! key_range) return 0;
                       var
                        _ax_ = key_range[1],
                        match$0 = _ax_[2],
                        begin_key = _ax_[1];
                       if(! match$0) return [0, [0, symbol(begin_key, lb), 0]];
                       var end_key = match$0[1], _ay_ = symbol(end_key, ub);
                       return [0, [0, symbol(begin_key, lb), _ay_]];
                      });
            case 2:
             var
              l$0 =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   var _aw_ = param[1];
                   if(typeof _aw_ !== "number"){
                    var pattern_syntax_012 = _aw_[1];
                    if(typeof param[2] === "number") return pattern_syntax_012;
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _r_], 1);
                  }),
              lb$0 =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   var pattern_syntax_013 = param[1];
                   if
                    (typeof pattern_syntax_013 !== "number"
                     && typeof param[2] === "number")
                    return pattern_syntax_013;
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _s_], 1);
                  }),
              let_syntax_020 =
                find_key_range(caml_call2(Incremental[40], l$0, l$0)),
              _au_ = caml_call2(Incremental[76][3][20], let_syntax_020, lb$0);
             return caml_call2
                     (Incremental[76][3][5],
                      _au_,
                      function(param){
                       var lb = param[2], key_range = param[1];
                       if(! key_range) return 0;
                       var key = key_range[1][1];
                       return [0, [0, symbol(key, lb), 0]];
                      });
            default:
             var
              u$0 =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   if(typeof param[1] === "number"){
                    var match = param[2];
                    if(typeof match !== "number"){
                     var pattern_syntax_014 = match[1];
                     return pattern_syntax_014;
                    }
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _t_], 1);
                  }),
              ub$0 =
                caml_call2
                 (Incremental[76][3][5],
                  range,
                  function(param){
                   if(typeof param[1] === "number"){
                    var pattern_syntax_015 = param[2];
                    if(typeof pattern_syntax_015 !== "number")
                     return pattern_syntax_015;
                   }
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _u_], 1);
                  }),
              let_syntax_023 =
                find_key_range(caml_call2(Incremental[40], u$0, u$0)),
              _av_ = caml_call2(Incremental[76][3][20], let_syntax_023, ub$0);
             return caml_call2
                     (Incremental[76][3][5],
                      _av_,
                      function(param){
                       var ub = param[2], key_range = param[1];
                       if(! key_range) return 0;
                       var key = key_range[1][1];
                       return [0, [0, 0, symbol(key, ub)]];
                      });
          }
         });
    return subrange(data_equal, map)(key_range);
   }
   function transpose(opt, k2_comparator, m){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    return with_comparator$0
            (m,
             function(k1_comparator){
              function update(k1, old_data, new_data, acc){
               return caml_call5
                       (Core_Map[81],
                        old_data,
                        new_data,
                        data_equal,
                        acc,
                        function(acc, param){
                         var diff = param[2], k2 = param[1], _an_ = diff[1];
                         if(847852583 === _an_)
                          var value = 0;
                         else
                          var
                           x = 1013247643 <= _an_ ? diff[2][2] : diff[2],
                           value = [0, x];
                         return caml_call3
                                 (Core_Map[36],
                                  acc,
                                  k2,
                                  function(acc_inner){
                                   var
                                    _ao_ = caml_call1(Core_Map[110][1], k1_comparator),
                                    _ap_ = caml_call2(Core_Option[34], acc_inner, _ao_),
                                    acc_inner$0 =
                                      caml_call3
                                       (Core_Map[36], _ap_, k1, function(param){return value;});
                                   return caml_call1(Core_Map[28], acc_inner$0)
                                           ? 0
                                           : [0, acc_inner$0];
                                  });
                        });
              }
              function add(key, data){
               var _al_ = caml_call1(Core_Map[4], k2_comparator);
               return function(_am_){return update(key, _al_, data, _am_);};
              }
              function remove(key, data){
               var _aj_ = caml_call1(Core_Map[4], k2_comparator);
               return function(_ak_){return update(key, data, _aj_, _ak_);};
              }
              return unordered_fold
                      (0,
                       [0, update],
                       0,
                       _v_,
                       m,
                       caml_call1(Core_Map[4], k2_comparator),
                       add,
                       remove);
             });
   }
   function collapse_by(data_equal, map_incr, merge_keys, comparator){
    return unordered_fold_nested_maps
            (data_equal,
             _w_,
             [0,
              function(outer_key, inner_key, param, new_data, acc){
               var _ai_ = caml_call2(merge_keys, outer_key, inner_key);
               return caml_call3(Core_Map[32], acc, _ai_, new_data);
              }],
             map_incr,
             caml_call1(Core_Map[4], comparator),
             function(outer_key, inner_key, data, acc){
              var _ah_ = caml_call2(merge_keys, outer_key, inner_key);
              return caml_call3(Core_Map[31], acc, _ah_, data);
             },
             function(outer_key, inner_key, param, acc){
              var _ag_ = caml_call2(merge_keys, outer_key, inner_key);
              return caml_call2(Core_Map[41], acc, _ag_);
             });
   }
   function collapse(data_equal, map_incr, inner_comparator){
    return with_comparator$0
            (map_incr,
             function(outer_comparator){
              var
               inner_comparator$0 = inner_comparator[1],
               comparator =
                 caml_call2
                  (Core_Tuple[1][5], outer_comparator, inner_comparator$0);
              return collapse_by
                      (data_equal, map_incr, Core_Tuple[1][6], [0, comparator]);
             });
   }
   function expand(data_equal, map_incr, outer_comparator, inner_comparator){
    return unordered_fold
            (data_equal,
             [0,
              function(param, _af_, new_data, acc){
               var inner_key = param[2], outer_key = param[1];
               return caml_call3
                       (Core_Map[37],
                        acc,
                        outer_key,
                        function(param){
                         if(! param)
                          return caml_call3
                                  (Core_Map[5], inner_comparator, inner_key, new_data);
                         var map = param[1];
                         return caml_call3(Core_Map[32], map, inner_key, new_data);
                        });
              }],
             0,
             _x_,
             map_incr,
             caml_call1(Core_Map[4], outer_comparator),
             function(param, data, acc){
              var inner_key = param[2], outer_key = param[1];
              return caml_call3
                      (Core_Map[37],
                       acc,
                       outer_key,
                       function(param){
                        if(! param)
                         return caml_call3
                                 (Core_Map[5], inner_comparator, inner_key, data);
                        var map = param[1];
                        return caml_call3(Core_Map[31], map, inner_key, data);
                       });
             },
             function(param, _ad_, acc){
              var inner_key = param[2], outer_key = param[1];
              return caml_call3
                      (Core_Map[36],
                       acc,
                       outer_key,
                       function(param){
                        if(! param) return 0;
                        var
                         map = param[1],
                         map$0 = caml_call2(Core_Map[41], map, inner_key),
                         _ae_ = 1 - caml_call1(Core_Map[28], map$0);
                        return caml_call2(Core_Option[55], _ae_, map$0);
                       });
             });
   }
   function counti(data_equal, map_incr, f){
    return unordered_fold
            (data_equal,
             0,
             0,
             _y_,
             map_incr,
             0,
             function(key, data, count){
              return caml_call2(f, key, data) ? count + 1 | 0 : count;
             },
             function(key, data, count){
              return caml_call2(f, key, data) ? count - 1 | 0 : count;
             });
   }
   function count(data_equal, map_incr, f){
    return counti
            (data_equal,
             map_incr,
             function(param, data){return caml_call1(f, data);});
   }
   function existsi(data_equal, map_incr, f){
    var _ac_ = counti(data_equal, map_incr, f);
    return caml_call2
            (Incremental[10],
             _ac_,
             function(count){return caml_call2(Core[93], count, 0);});
   }
   function exists(data_equal, map_incr, f){
    return existsi
            (data_equal,
             map_incr,
             function(param, data){return caml_call1(f, data);});
   }
   function sum(data_equal, map_incr, Group){
    return function(f){
     return unordered_fold
             (data_equal,
              0,
              0,
              _z_,
              map_incr,
              Group[1],
              function(param, v, acc){
               var _ab_ = caml_call1(f, v);
               return caml_call2(Group[2], acc, _ab_);
              },
              function(param, v, acc){
               var _aa_ = caml_call1(f, v);
               return caml_call2(Group[3], acc, _aa_);
              });};
   }
   function for_alli(data_equal, map_incr, f){
    var
     _$_ =
       counti
        (data_equal,
         map_incr,
         function(key, data){return 1 - caml_call2(f, key, data);});
    return caml_call2
            (Incremental[10],
             _$_,
             function(count){return caml_call2(Core[90], count, 0);});
   }
   function for_all(data_equal, map_incr, f){
    return for_alli
            (data_equal,
             map_incr,
             function(param, data){return caml_call1(f, data);});
   }
   var
    For_testing = [0, find_key_range_linear],
    _A_ = [0, "node_is_unnecessary"],
    _B_ = [0, "node_is_invalid"],
    _C_ = [0, "node_is_const"],
    _D_ = [0, "node_info"],
    _E_ = [0, "saved_value"],
    _F_ = [0, "entries"],
    _G_ = [0, "actual_value"],
    _H_ = [0, "key"];
   function M(K){return [0];}
   function create(opt, input_map, comparator){
    if(opt)
     var sth = opt[1], data_equal = sth;
    else
     var data_equal = Core[246];
    var self = [];
    caml_update_dummy
     (self,
      [246,
       function(param){
        var
         updater_node =
           caml_call2
            (Incremental[10],
             input_map,
             function(input_map){
              var
               _X_ = caml_obj_tag(self),
               self$0 =
                 250 === _X_
                  ? self[1]
                  : 246 === _X_ ? caml_call1(CamlinternalLazy[2], self) : self;
              caml_call5
               (Core_Map[81],
                self$0[1],
                input_map,
                data_equal,
                0,
                function(param, _Y_){
                 var
                  changed_value = _Y_[2],
                  key = _Y_[1],
                  entries = caml_call2(Core_Map[35], self$0[2], key);
                 return caml_call2
                         (Core_List[9],
                          entries,
                          function(entry){
                           var _Z_ = changed_value[1];
                           if(847852583 === _Z_)
                            var ___ = 0;
                           else
                            var
                             new_value =
                               1013247643 <= _Z_ ? changed_value[2][2] : changed_value[2],
                             ___ = [0, new_value];
                           entry[1] = ___;
                           return caml_call1(Incremental[79][2][4], entry[2]);
                          });
                });
              self$0[1] = input_map;
              return 0;
             }),
         empty_map = caml_call1(Core_Map[110][1], comparator),
         _W_ = caml_call1(Incremental[4], input_map);
        return [0,
                empty_map,
                empty_map,
                updater_node,
                caml_call2(Incremental[50][2], _W_, 0)];
       }]);
    var _V_ = caml_obj_tag(self);
    return 250 === _V_
            ? self[1]
            : 246 === _V_ ? caml_call1(CamlinternalLazy[2], self) : self;
   }
   function find(t, key){
    var match = caml_call2(Core_Map[35], t[2], key);
    if(match){
     var entry = match[1];
     return caml_call1(Incremental[79][2][3], entry[2]);
    }
    var incremental_state = caml_call1(Incremental[4], t[3]);
    return caml_call3
            (Incremental[50][3],
             incremental_state,
             t[4],
             function(param){
              var entry = [];
              caml_update_dummy
               (entry,
                [246,
                 function(param){
                  var
                   _R_ =
                     caml_call3
                      (Incremental[79][2][2],
                       incremental_state,
                       [0,
                        function(is_now_observable){
                         var
                          _S_ = caml_obj_tag(entry),
                          entry$0 =
                            250 === _S_
                             ? entry[1]
                             : 246
                               === _S_
                               ? caml_call1(CamlinternalLazy[2], entry)
                               : entry,
                          current_entries = caml_call2(Core_Map[35], t[2], key),
                          _T_ = caml_call1(Core[246], entry$0),
                          is_linked = caml_call2(Core_List[13], current_entries, _T_);
                         if(caml_call2(Core_Bool[27], is_linked, is_now_observable))
                          return 0;
                         if(is_now_observable){
                          t[2] =
                           caml_call3
                            (Core_Map[37],
                             t[2],
                             key,
                             function(param){
                              if(param){
                               var other_entries = param[1];
                               if(other_entries){
                                var other_entry = other_entries[1];
                                entry$0[1] = other_entry[1];
                                return [0, entry$0, other_entries];
                               }
                              }
                              entry$0[1] = caml_call2(Core_Map[38], t[1], key);
                              return [0, entry$0, 0];
                             });
                          return 0;
                         }
                         var
                          new_entries =
                            caml_call2
                             (Core_List[50],
                              current_entries,
                              function(x){return 1 - caml_call2(Core[246], entry$0, x);}),
                          _U_ =
                            caml_call1(Core_List[8], new_entries)
                             ? caml_call2(Core_Map[41], t[2], key)
                             : caml_call3(Core_Map[32], t[2], key, new_entries);
                         t[2] = _U_;
                         return 0;
                        }],
                       function(param){return caml_call1(Core[237], entry)[1];});
                  return [0, caml_call2(Core_Map[38], t[1], key), _R_];
                 }]);
              var
               _P_ = caml_obj_tag(entry),
               entry$0 =
                 250 === _P_
                  ? entry[1]
                  : 246
                    === _P_
                    ? caml_call1(CamlinternalLazy[2], entry)
                    : entry,
               _Q_ = caml_call2(Incremental[79][1][2], 0, t[3]);
              caml_call2(Incremental[79][2][6], entry$0[2], _Q_);
              return caml_call1(Incremental[79][2][3], entry$0[2]);
             });
   }
   function sexp_of_t(sexp_of_key, sexp_of_value, t){
    var
     info_per_key =
       caml_call3
        (Core_Map[77],
         t[1],
         t[2],
         function(key, data){
          var _I_ = data[1];
          if(737457313 === _I_)
           var
            match = data[2],
            entries = match[2],
            x = match[1],
            actual_value = [0, x],
            entries$0 = entries,
            actual_value$0 = actual_value;
          else if(847852583 <= _I_)
           var x$0 = data[2], entries$0 = 0, actual_value$0 = [0, x$0];
          else
           var y = data[2], entries$0 = y, actual_value$0 = 0;
          var
           match$0 =
             [0,
              [1,
               [0,
                _F_,
                [0,
                 caml_call2
                  (Core[421],
                   function(entry){
                    var
                     saved_value = entry[1],
                     node = entry[2],
                     node$0 = caml_call1(Incremental[79][2][3], node),
                     match = caml_call1(Incremental[67], node$0),
                     _K_ = caml_call1(Incremental[5], node$0),
                     match$0 = caml_call2(Core_Option[55], _K_, 0),
                     _L_ = 1 - caml_call1(Incremental[6], node$0),
                     match$1 = caml_call2(Core_Option[55], _L_, 0),
                     _M_ = 1 - caml_call1(Incremental[7], node$0),
                     _N_ = caml_call2(Core_Option[55], _M_, 0),
                     match$2 = 0;
                    if(_N_)
                     var
                      v = _N_[1],
                      match$3 =
                        [0,
                         [1, [0, _A_, [0, caml_call1(Core[518], v), 0]]],
                         match$2];
                    else
                     var match$3 = match$2;
                    if(match$1)
                     var
                      v$0 = match$1[1],
                      match$4 =
                        [0,
                         [1, [0, _B_, [0, caml_call1(Core[518], v$0), 0]]],
                         match$3];
                    else
                     var match$4 = match$3;
                    if(match$0)
                     var
                      v$1 = match$0[1],
                      match$5 =
                        [0,
                         [1, [0, _C_, [0, caml_call1(Core[518], v$1), 0]]],
                         match$4];
                    else
                     var match$5 = match$4;
                    if(match)
                     var
                      v$2 = match[1],
                      _O_ =
                        [0,
                         [1, [0, _D_, [0, caml_call1(Core_Info[6], v$2), 0]]],
                         match$5];
                    else
                     var _O_ = match$5;
                    return [1,
                            [0,
                             [1,
                              [0,
                               _E_,
                               [0, caml_call2(Core[454], sexp_of_value, saved_value), 0]]],
                             _O_]];
                   },
                   entries$0),
                 0]]],
              0];
          if(actual_value$0)
           var
            v = actual_value$0[1],
            _J_ =
              [0,
               [1, [0, _G_, [0, caml_call1(sexp_of_value, v), 0]]],
               match$0];
          else
           var _J_ = match$0;
          return [0,
                  [1,
                   [0,
                    [1, [0, _H_, [0, caml_call1(sexp_of_key, key), 0]]],
                    _J_]]];
         });
    return [1, caml_call1(Core_Map[73], info_per_key)];
   }
   caml_call1(Ppx_inline_test_lib_Runtime[3], cst_incr_map);
   caml_call1(Expect_test_collector[5][2], 0);
   caml_call1(Ppx_bench_lib_Benchmark_accumu[1][2], 0);
   caml_call1(Ppx_module_timer_runtime[5], cst_Incr_map);
   var
    Incr_map =
      [0,
       of_set,
       filter_mapi,
       mapi,
       filter_map,
       map,
       filter_mapi$0,
       map$0,
       filter_map$0,
       mapi$0,
       partition_mapi,
       unordered_fold,
       mapi_count,
       map_count,
       mapi_min,
       mapi_max,
       mapi_mn,
       map_max,
       min_value,
       max_value,
       mapi_bounds,
       map_bounds,
       value_bounds,
       merge,
       merge$0,
       unzip,
       unzip_mapi,
       unzip_mapi$0,
       flatten,
       join,
       separate,
       keys,
       rank,
       subrange,
       subrange_by_rank,
       rekey,
       index_byi,
       index_by,
       unordered_fold_nested_maps,
       transpose,
       collapse,
       collapse_by,
       expand,
       counti,
       count,
       for_alli,
       for_all,
       existsi,
       exists,
       sum,
       [0, create, find, M, [0, sexp_of_t]],
       For_testing,
       function(Incr){
        function flatten$0(x){return flatten(Incr[2][3], x);}
        function M(K){return [0];}
        return [0,
                of_set,
                filter_mapi,
                mapi,
                filter_map,
                map,
                filter_mapi$0,
                mapi$0,
                filter_map$0,
                map$0,
                partition_mapi,
                unordered_fold,
                mapi_count,
                map_count,
                mapi_min,
                mapi_max,
                mapi_mn,
                map_max,
                min_value,
                max_value,
                mapi_bounds,
                map_bounds,
                value_bounds,
                merge,
                unzip,
                unzip_mapi,
                unzip_mapi$0,
                merge$0,
                flatten$0,
                join,
                separate,
                keys,
                rank,
                subrange,
                subrange_by_rank,
                rekey,
                index_byi,
                index_by,
                unordered_fold_nested_maps,
                transpose,
                collapse,
                collapse_by,
                expand,
                counti,
                count,
                for_alli,
                for_all,
                existsi,
                exists,
                sum,
                [0, create, find, M, [0, sexp_of_t]],
                For_testing];
       }];
   runtime.caml_register_global(65, Incr_map, cst_Incr_map);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJpbmNyX21hcC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsid2l0aF9vbGQiLCJpIiwiZiIsIm9sZCIsImEiLCJiIiwidW5vcmRlcmVkX2ZvbGQiLCJvcHQiLCJ1cGRhdGUiLCJzcGVjaWFsaXplZF9pbml0aWFsIiwibWFwIiwiaW5pdCIsImFkZCIsInJlbW92ZSIsInN0aCIsImRhdGFfZXF1YWwiLCJzdGgkMCIsInJldmVydF90b19pbml0X3doZW5fZW1wdHkiLCJkZWZhdWx0JDAiLCJrZXkiLCJvbGRfZGF0YSIsIm5ld19kYXRhIiwiYWNjIiwidXBkYXRlJDAiLCJuZXdfaW4iLCJpbml0aWFsIiwib2xkX291dCIsIm9sZF9pbiIsImNoYW5nZSIsIm5ldyQwIiwib2xkJDAiLCJuZXckMSIsInVub3JkZXJlZF9mb2xkX25lc3RlZF9tYXBzIiwiaW5jcl9tYXAiLCJ1cGRhdGUkMSIsIm91dGVyX2tleSIsImlubmVyX2tleSIsIm9sZF9pbm5lcl9tYXAiLCJuZXdfaW5uZXJfbWFwIiwiZGlmZiIsImRhdGFfcmVtb3ZlZCIsImRhdGFfYWRkZWQiLCJpbm5lcl9tYXAiLCJkYXRhIiwid2l0aF9jb21wYXJhdG9yIiwiZ2V0X2NvbXBhcmF0b3IiLCJ4Iiwid2l0aF9jb21wYXJhdG9yJDAiLCJvZl9zZXQiLCJzZXQiLCJjb21wYXJhdG9yIiwib2xkX2lucHV0Iiwib2xkX291dHB1dCIsIm5ld19pbnB1dCIsIm5ld19vdXRwdXQiLCJvdXRwdXQiLCJrIiwiayQwIiwiZ2VuZXJpY19tYXBpIiwid2l0bmVzcyIsImlucHV0IiwicmVzIiwib3V0cHV0X2RhdGEiLCJtYXBpIiwiZmlsdGVyX21hcGkiLCJmaWx0ZXJfbWFwIiwid2l0aF9vbGQyIiwiaTEiLCJpMiIsImExIiwiYTIiLCJtYXBpX2NvdW50IiwibmV3X2tleSIsIm4iLCJwcmV2X2tleSIsIm1hcF9jb3VudCIsIm1pbl9oZWxwZXIiLCJtaW4iLCJtYXhfaGVscGVyIiwibWF4IiwiYm91bmRzX2hlbHBlciIsIm1hcGlfbWluIiwibWFwaV9tYXgiLCJtYXBpX2JvdW5kcyIsIm1hcGlfbW4iLCJtYXBfbWF4IiwibWluX3ZhbHVlIiwibWF4X3ZhbHVlIiwibWFwX2JvdW5kcyIsInZhbHVlX2JvdW5kcyIsIm1lcmdlIiwibGVmdF9tYXAiLCJyaWdodF9tYXAiLCJkYXRhX2VxdWFsX2xlZnQiLCJkYXRhX2VxdWFsX3JpZ2h0IiwibmV3X2xlZnRfbWFwIiwibmV3X3JpZ2h0X21hcCIsIm9sZF9yaWdodF9tYXAiLCJvbGRfbGVmdF9tYXAiLCJvbGRfbGVmdF9tYXAkMCIsImxlZnRfZGlmZiIsInJpZ2h0X2RpZmYiLCJyaWdodF9rZXkiLCJsZWZ0X2tleSIsImRpZmZfZWxlbWVudCIsImtleSQwIiwicmlnaHRfZGF0YV9vcHQkMCIsImxlZnRfZGF0YV9vcHQiLCJyaWdodF9kaWZmJDAiLCJsZWZ0X2RpZmYkMCIsInJpZ2h0X2RhdGFfb3B0JDIiLCJsZWZ0X2RhdGFfb3B0JDAiLCJ5Iiwib3V0cHV0X2RhdGFfb3B0IiwieSQwIiwiZ2VuZXJpY19tYXBpX3dpdGhfY29tcGFyYXRvciIsImN1dG9mZiIsImluY3JlbWVudGFsX3N0YXRlIiwiZW1wdHlfbWFwIiwicHJldl9tYXAiLCJwcmV2X25vZGVzIiwicmVzdWx0Iiwib25faW5uZXJfY2hhbmdlIiwibGhzX2NoYW5nZSIsIm5ld19ub2RlcyIsIm5vZGVzIiwiY2hhbmdlZCIsImRlcCIsIm5vZGUiLCJub2RlcyQwIiwibm9kZSQwIiwibm9kZSQxIiwiYyIsInVzZXJfZnVuY3Rpb25fZGVwIiwiZmlsdGVyX21hcGkkMCIsIm1hcGkkMCIsIm1hcCQwIiwiZmlsdGVyX21hcCQwIiwibWVyZ2UkMCIsIm1hcDEiLCJtYXAyIiwidW56aXBfbWFwaSIsImxlZnRfcmVzdWx0X2VxdWFsIiwicmlnaHRfcmVzdWx0X2VxdWFsIiwicGFpciIsImRhdGFfZXF1YWwkMCIsImxlZnRfcmVzdWx0X2VxdWFsJDAiLCJzdGgkMSIsInJpZ2h0X3Jlc3VsdF9lcXVhbCQwIiwibGVmdF9hY2MiLCJsZWZ0X3Jlc3VsdCIsInJpZ2h0X2FjYyIsInJpZ2h0X3Jlc3VsdCIsImlucHV0X2NoYW5nZSIsImxlZnQkMCIsImwiLCJyaWdodCQwIiwiciIsInJpZ2h0IiwibGVmdCIsInByZXYiLCJwcmV2X2IiLCJwcmV2X2EiLCJuZXdfYiIsIm5ld19hIiwiZWxlbWVudCIsInVuemlwIiwidW56aXBfbWFwaSQwIiwicmlnaHRfZGVwIiwibGVmdF9kZXAiLCJyaWdodF9pbmNyIiwibGVmdF9pbmNyIiwibGVmdF91c2VyX2Z1bmN0aW9uX2RlcCIsInJpZ2h0X3VzZXJfZnVuY3Rpb25fZGVwIiwia2V5cyIsInBhcnRpdGlvbl9tYXBpIiwiZW1wdHkiLCJzZWNvbmQiLCJmaXJzdCIsImRhdGEkMCIsImRhdGEkMSIsImZsYXR0ZW4iLCJzdGF0ZSIsImluY3IiLCJqb2luIiwibWFwX2luY3IiLCJyZXN1bHRfbWFwIiwib2xkX21hcF9vZl9pbmNycyIsImN1cnJlbnRfZGVwZW5kZW5jaWVzIiwiYWRkX3N1Ym5vZGUiLCJkYXRhX25vZGUiLCJuZXdfZGVwIiwicmVtb3ZlX3N1Ym5vZGUiLCJtYXBfb2ZfaW5jcnMiLCJuZXdfZGVwZW5kZW5jeV9tYXAiLCJkYXRhX25vZGUkMCIsInNlcGFyYXRlIiwiaW5wdXRfbWFwIiwib3V0cHV0X21hcF9ub2RlIiwibWFrZV9ub2RlX2RlcGVuZF9vbl9pbnB1dF9tYXBfIiwiaW5wdXRfbWFwX2NoYW5nZWQiLCJkZXBlbmRlbmN5IiwicHJldl9pbnB1dF9tYXAiLCJvdXRwdXRfbWFwIiwiZXhwZXJ0X25vZGVzIiwib2xkX25vZGUiLCJzdWJyYW5nZSIsInJhbmdlIiwiY29tcGFyZSIsImVxdWFsIiwibWF5YmVfYm91bmRfZXF1YWwiLCJhXzAwMiIsImJfMDAzIiwiYV8wMDQiLCJiXzAwNSIsImFfMDA2IiwiYl8wMDciLCJyYW5nZV9pc19lbXB0eSIsIm1pbiQwIiwibWF4JDAiLCJtYXgkMSIsIm1pbiQxIiwicmFuZ2VfaW5jbHVkZXMiLCJyYW5nZSQwIiwiZnJvbV9zY3JhdGNoIiwib2xkX3JhbmdlIiwib2xkX21pbiIsIm9sZF9tYXAiLCJvbGRfbWF4Iiwib2xkX3JlcyIsIm9sZF9tYXgkMCIsInBhcmFtIiwiYXBwbHlfZGlmZl9pbl9pbnRlcnNlY3Rpb24iLCJvdXRzaWRlIiwib3V0c2lkZSQwIiwib3V0c2lkZV9jdXRvZmYiLCJ3aXRoX3VwZGF0ZWRfdmFsdWVzX2luX2ludGVyc2UiLCJ3aXRob3V0X2tleXNfb3V0X29mX3JhbmdlIiwibWFwX2FwcGVuZF9leG4iLCJsb3dlcl9wYXJ0IiwidXBwZXJfcGFydCIsIm9sZF9taW4kMCIsIm9sZF9taW4kMSIsIm9sZF9tYXgkMSIsIndpdGhfbmV3X2tleXNfbm93X2luX3JhbmdlIiwicmVrZXkiLCJvdXRlcl9jb21wYXJhdG9yIiwiaW5kZXhfYnlpIiwiaW5kZXgiLCJpbm5lcl9jb21wYXJhdG9yIiwib3V0ZXJfbWFwIiwiaW5uZXJfbWFwJDAiLCJpbmRleF9ieSIsImlzX2tub3duIiwidG9fb3B0aW9uIiwiZmluZF9rZXlfcmFuZ2VfbGluZWFyIiwiZnJvbSIsInRvIiwibGVuIiwiYmVnaW5fa2V5IiwiZW5kX2tleSIsImZpbmRfa2V5cyIsImZvbGQiLCJzdGFydF9wb3MiLCJhZHZhbmNlX3BvcyIsInBvcyIsImJlZ2luX2tleSQwIiwiZW5kX2tleSQwIiwiZmluZF9vZmZzZXQiLCJjaGFuZ2VkX2tleSIsInJhbmsiLCJjb21wYXJlX2tleSIsInNhbWVfa2V5IiwicHJvY2VzcyIsIm5ld19tYXAiLCJvbGRfcmFuayIsIm9sZF9rZXkiLCJvbGRfcmFuayQwIiwiZGlmZl9rZXkiLCJvbGRfcmFuayQxIiwib2xkJDEiLCJ1cHBlcl9ib3VuZCIsImxvd2VyX2JvdW5kIiwidXBwZXJfYm91bmQkMCIsImxvd2VyX2JvdW5kJDAiLCJzdWJyYW5nZSQwIiwic3VicmFuZ2VfYnlfcmFuayIsImZpbmRfa2V5X3JhbmdlIiwiZW5kX2tleV9vcHQkMCIsIm9sZF90byIsIm9sZF9mcm9tIiwicmFuZ2Vfb2Zmc2V0X2JlZ2luIiwicmFuZ2Vfb2Zmc2V0X2VuZCIsImFkanVzdF9hbmRfb2Zmc2V0IiwiYnkkMSIsImtleSQxIiwiYnkkMiIsImJ5IiwiY2xvc2VzdF9kaXIiLCJieSQwIiwib2Zmc2V0X2VuZCIsIm9mZnNldF9iZWdpbiIsIm1hcF9vZmZzZXRfZW5kIiwibWFwX29mZnNldF9iZWdpbiIsImVuZF9rZXlfb3B0JDIiLCJiZWdpbl9rZXlfb3B0IiwibWFwX29mZnNldF9iZWdpbiQwIiwiZW5kX2tleV9vcHQiLCJiZWdpbl9rZXlfb3B0JDAiLCJzeW1ib2wiLCJib3VuZCIsInJldHVybiQwIiwia2V5X3JhbmdlIiwicGF0dGVybl9zeW50YXhfMDA4IiwibGIiLCJwYXR0ZXJuX3N5bnRheF8wMDkiLCJ1IiwicGF0dGVybl9zeW50YXhfMDEwIiwidWIiLCJwYXR0ZXJuX3N5bnRheF8wMTEiLCJsZXRfc3ludGF4XzAxNiIsImwkMCIsInBhdHRlcm5fc3ludGF4XzAxMiIsImxiJDAiLCJwYXR0ZXJuX3N5bnRheF8wMTMiLCJsZXRfc3ludGF4XzAyMCIsInUkMCIsInBhdHRlcm5fc3ludGF4XzAxNCIsInViJDAiLCJwYXR0ZXJuX3N5bnRheF8wMTUiLCJsZXRfc3ludGF4XzAyMyIsInRyYW5zcG9zZSIsImsyX2NvbXBhcmF0b3IiLCJtIiwiazFfY29tcGFyYXRvciIsImsxIiwiazIiLCJ2YWx1ZSIsImFjY19pbm5lciIsImFjY19pbm5lciQwIiwiY29sbGFwc2VfYnkiLCJtZXJnZV9rZXlzIiwiY29sbGFwc2UiLCJpbm5lcl9jb21wYXJhdG9yJDAiLCJleHBhbmQiLCJjb3VudGkiLCJjb3VudCIsImV4aXN0c2kiLCJleGlzdHMiLCJzdW0iLCJHcm91cCIsInYiLCJmb3JfYWxsaSIsImZvcl9hbGwiLCJjcmVhdGUiLCJzZWxmIiwidXBkYXRlcl9ub2RlIiwic2VsZiQwIiwiY2hhbmdlZF92YWx1ZSIsImVudHJpZXMiLCJlbnRyeSIsIm5ld192YWx1ZSIsImZpbmQiLCJ0IiwiaXNfbm93X29ic2VydmFibGUiLCJlbnRyeSQwIiwiY3VycmVudF9lbnRyaWVzIiwiaXNfbGlua2VkIiwib3RoZXJfZW50cmllcyIsIm90aGVyX2VudHJ5IiwibmV3X2VudHJpZXMiLCJzZXhwX29mX3QiLCJzZXhwX29mX2tleSIsInNleHBfb2ZfdmFsdWUiLCJpbmZvX3Blcl9rZXkiLCJhY3R1YWxfdmFsdWUiLCJlbnRyaWVzJDAiLCJhY3R1YWxfdmFsdWUkMCIsIngkMCIsIm1hdGNoJDAiLCJzYXZlZF92YWx1ZSIsIm1hdGNoJDIiLCJtYXRjaCQzIiwidiQwIiwibWF0Y2gkNCIsInYkMSIsIm1hdGNoJDUiLCJ2JDIiLCJmbGF0dGVuJDAiXSwic291cmNlcyI6WyIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2luY3JfbWFwL2luY3JfbWFwLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBbUJNQSxTQUFTQyxHQUFHQztJQUVKLElBQU5DOzs7YUFGT0Y7c0JBR0hHO2NBQ0EsSUFBSkMsSUFBSSxXQUpNSCxHQUVWQyxRQUNJQztjQURKRCxpQkFDSUMsR0FDSkM7Y0FFSixPQUZJQTthQUVIO0dBQUE7WUFHQ0M7SUFDSUMsS0FDREMsUUFDQUMsMkJBRURDLEtBQ0NDLE1BQ0FDLEtBQ0FDO0lBRUwsR0FUTU47U0FBYU8sTUFBYlAsUUFBQVEsYUFBYUQ7O1NBQWJDO0lBU047U0FOa0NDLGlCQUE1QkMsNEJBQTRCRDs7U0FBNUJDO2FBT0FDLFVBQVNDLEtBQUtDLFVBQVVDLFVBQVNDO0tBQ25DLE9BQXdCO2NBTHZCVixLQUlVTyxLQUFlRSxVQUNGLFdBSnZCUixRQUdVTSxLQUFLQyxVQUFtQkU7SUFDcUI7SUFFMUQsSUFKRUMsV0FJRiw0QkFaR2YsUUFTQ1U7SUFLVSxPQXpCZGxCO2FBY0VVO3NCQVdrQlAsS0FBSXFCO2NBQ3hCLEtBRG9CckI7b0JBYmpCTTtnREFhcUJlLFFBVnJCYixNQUNBQzttQkFjT2EsVUFsQlBoQjtlQWtCa0IsT0FBQSxXQUFYZ0IsU0FmUGQsTUFVcUJhOzswQkFBSnJCLFFBTUp1QixvQkFBUkM7Y0FDTixHQW5CRVY7ZUFtQjhCLFdBQUEseUJBUFZPO2VBT1UsR0FBQSxzQ0FqQi9CYjs7Y0F5Qk0sT0FBQTs7dUJBVERnQjt1QkFOZ0JIO3VCQWZwQlQ7dUJBcUJZVztnQ0FTRko7d0JBQUwsSUFBZU0sbUJBQUxULGdCQUNYLE9BRGdCUzs7NkJBRVJ6QixNQUZReUI7eUJBRUQsT0FBQSxXQXpCcEJmLFFBdUJnQk0sS0FFSGhCLEtBRkZtQjs7O3FDQUFVTSxXQUlDQyxrQkFBTEM7eUJBQWMsT0FBQSxXQXpCaENQLFVBcUJpQkosS0FJQ1csT0FBS0QsT0FKWFA7OzRCQUdHUyxRQUhPSDt3QkFHQyxPQUFBLFdBM0J0QmhCLEtBd0JnQk8sS0FHRlksT0FISFQ7dUJBSWlFO2FBQUE7R0FBQztZQUdoRlU7SUFDSXpCLEtBQ0RVLDJCQUNBVCxRQUNEeUIsVUFDQ3RCLE1BQ0FDLEtBQ0FDO0lBRUwsR0FSTU47U0FBYU8sTUFBYlAsUUFBQVEsYUFBYUQ7O1NBQWJDO0lBUU4sR0FOS1A7U0FRSWUsV0FSSmYsV0FNRDBCLFdBRUtYOzs7TUFGTFc7aUJBSUtDLFdBQVdDLFdBQVdoQixVQUFVQyxVQUFTQztTQUM1QyxPQUlFO2tCQVpIVjtrQkFPSXVCO2tCQUFXQztrQkFBcUJmO2tCQUtqQyxXQVhIUixRQU1Jc0IsV0FBV0MsV0FBV2hCLFVBQW1CRTtRQUtPO0lBa0IvQyxPQTFFUmhCOzs7dUJBOERrQjZCLFdBQW9CRSxlQUF3QkMsZUFBY2hCO2VBQzFFLE9BRUs7d0JBRkw7d0NBRG9DZSxlQUF3QkMsZUF2QjFEdkI7d0JBdUJ3RU87aUNBR2hFQTt5QkFBTCxJQUFxQmlCLGlCQUFYSCxzQkFDWCxPQURzQkc7OzhCQUVkQyxlQUZjRDswQkFFRSxPQUFBO21DQXRCM0IxQixRQWlCZXNCLFdBR0RDLFdBRUhJLGNBRkZsQjs7OzttQ0FBZ0JpQjsyQkFJQWxCOzJCQUFWRDswQkFDVixPQUFBO21DQXZCTmMsVUFlZ0JDLFdBR0RDLFdBSUNoQixVQUFVQyxVQUpoQkM7OzZCQUdHbUIsYUFIYUY7eUJBR0MsT0FBQTtrQ0F4QjFCM0IsS0FrQmV1QixXQUdEQyxXQUdGSyxZQUhIbkI7d0JBS2lEO2NBQUE7O2FBOUIxREw7YUFFRGdCO2FBQ0N0QjtzQkE0Qll3QixXQUFnQk8sV0FBVXBCO2NBQ3ZDLE9BQWdDOzt1QkFESG9CO3VCQUFVcEI7Z0NBQ0djLFdBQVdPLE1BQUtyQjt3QkFDeEQsT0FBQSxXQTdCRFYsS0EyQll1QixXQUM2QkMsV0FBV08sTUFBS3JCO3VCQUNyQjthQUFDO3NCQUN0QmEsV0FBZ0JPLFdBQVVwQjtjQUMxQyxPQUFnQzs7dUJBREFvQjt1QkFBVXBCO2dDQUNBYyxXQUFXTyxNQUFLckI7d0JBQ3hELE9BQUEsV0EvQkRULFFBNkJlc0IsV0FDMEJDLFdBQVdPLE1BQUtyQjt1QkFDbEI7YUFBQztHQUFDO1lBRzVDc0IsZ0JBQWlCQyxnQkFBZUMsR0FBRTVDO0lBQ3BDO0tBQXFDLE9BQUEsNEJBREg0QyxHQUFmRDtLQUNGLE9BQUE7SUFBakIsT0FBQSxrQ0FEb0MzQztHQUMwQztZQU81RTZDLGtCQUFnQnJDLEtBQUlSO0lBQUksT0FSeEIwQyw2QkFRZ0JsQyxLQUFJUjtHQUF5QztZQUU3RDhDLE9BQU9DO0lBQ1QsT0FYRUw7O2FBVU9LO3NCQUNnQ0M7Y0FDdkM7ZUFBSUMsZ0JBQWdCLDJCQURtQkQ7ZUFFbkNFLGlCQUFpQiw2QkFGa0JGO2NBR2hCLE9BQUE7O3VCQUpoQkQ7Z0NBSXFCSTt3QkFDMUI7Z0NBRkVEO3lCQUlFLE9BQUEseUJBTEZELGNBRXdCRTt5QkFDdEJDOzJCQUNGOzs7O3NDQUdVQzs4QkFBTDttQ0FDT0M7K0JBQUssT0FBQSx5QkFEUEQsUUFDRUM7O2tDQUNDQzs4QkFBSyxPQUFBLHlCQUZSRixRQUVHRTs2QkFBd0M7d0JBVHJETixlQUV3QkU7d0JBRHhCRCxnQkFFRUU7d0JBVUosT0FWSUE7dUJBVU07YUFBQztHQUFDO1lBR2RJLGFBRUdDLFNBQ0NwRDtJLEdBQUFBO1NBQWFPLE1BQWJQLFFBQUFRLGFBQWFEOztTQUFiQztvQkFFQWI7S0FFTixPQTNIRUY7O3VCQTJIb0JHLEtBQUl5RDtlQUN4QixTQUFXLHlCQURhQSxVQUFKekQ7O3lCQUFBQTtpQkFNRGlEO2lCQUFYRDtnQkFNRCxPQUFBOzt5QkFOQ0E7eUJBTmdCUzt5QkFKcEI3Qzt5QkFVZXFDO2tDQU1QRzswQkFBTCxJQUFrQjNCLG1CQUFMVCxnQkFDZCxPQURtQlM7OzJCQUVOLE9BQUEseUJBRlAyQixRQUFRcEM7MEJBSUY7MkJBREhFLGdDQUhVTyxlQUFBQTsyQkFJYmlDLE1BQU0sV0FsQmQzRCxHQWNnQmlCLEtBR0xFOzBCQUVQLEtBdEJMc0M7MkJBdUJ3QixPQUFBLHlCQU5mSixRQUFRcEMsS0FJUjBDOytCQUFBQSxLQUtVLE9BQUEseUJBVFZOLFFBQVFwQzs4QkFVRDJDLGNBTlBEOzBCQU1zQixPQUFBLHlCQVZ0Qk4sUUFBUXBDLEtBVUQyQzt5QkFBdUQ7O3NCQTNCdkVIO3lCQUtMLHlCQUEwQkMsT0FGcEIxRDt5QkFFTix5QkFBMEIwRCxPQUZwQjFEO2NBd0JzRSxHQUFDOztZQUczRTZELEtBQU1oRCxZQUFXTCxLQUFLUjtJQUFJLE9BaEMxQndELGdCQWdDTTNDLFlBQVdMLEtBQUtSO0dBQXVDO1lBQzdEOEQsWUFBYWpELFlBQVdMLEtBQUtSO0lBQUksT0FqQ2pDd0QsZ0JBaUNhM0MsWUFBV0wsS0FBS1I7R0FBOEM7WUFDM0VRLElBQUtLLFlBQVdMLEtBQUtSO0lBQUksT0FGekI2RDthQUVLaEQ7YUFBV0w7NkJBQThDaUMsTUFBUSxPQUFBLFdBQWpEekMsR0FBeUN5QyxNQUFjO0dBQUM7WUFFN0VzQixXQUFZbEQsWUFBV0wsS0FBS1I7SUFDOUIsT0FKRThEO2FBR1lqRDthQUFXTDs2QkFDbUJpQyxNQUFRLE9BQUEsV0FEdEJ6QyxHQUNjeUMsTUFBYztHQUFDO1lBR3pEdUIsVUFBVUMsSUFBR0MsSUFBSWxFO0lBQ1QsSUFBTkM7SUFDc0IsT0FBQTs7YUFGZGdFO2FBQUdDO3NCQUVnQkMsSUFBR0M7Y0FDeEIsSUFBSmpFLElBQUksV0FIU0gsR0FDZkMsUUFDMkJrRSxJQUFHQztjQUQ5Qm5FLGlCQUMyQmtFLElBQUdDLElBQzVCakU7Y0FFSixPQUZJQTthQUVIO0dBQUM7WUFHRmtFLFdBRUloRSxLQUNGcUQ7SSxHQURFckQ7U0FBYU8sTUFBYlAsUUFBQVEsYUFBYUQ7O1NBQWJDO29CQUlEYjtjQUdEVSxJQUFJNEQsU0FBUWxEO01BQ2QsT0FBMEI7O2VBRFpBO2VBQVJrRDs7Z0JBQ29CLFlBQ2Q7b0JBQ0hDO2dCQUFLLE9BQUxBO2VBQVc7S0FBQTtLQUV0QixTQUFJNUQsT0FBTzJELFNBQVFsRDtNQUNqQixPQUEwQjs7ZUFEVEE7ZUFBUmtEOztnQkFDaUIsWUFDZDtvQkFFSEM7NkJBQUFBLFlBQUFBO2VBQWtCO0tBQUE7S0FPbkIsT0FwTFJuRTtrQkE2SklTOzt3QkF3QlVJLEtBQUtDLFVBQVVDLFVBQVNDO2dCQUNwQztpQkFBSW9ELFdBQVcsV0FyQmR4RSxHQW9CV2lCLEtBQUtDO2lCQUVib0QsVUFBVSxXQXRCYnRFLEdBb0JXaUIsS0FBZUU7aUJBR3hCLE9BQUEsNkJBRkNxRCxVQUNBRjtnQkFDRCxPQUFBOzBCQUhpQ2xEOzBCQWpCcENWLElBbUJJNEQsU0FkSjNELE9BYUk2RCxVQURnQ3BEO2VBS007OztjQTVCMUNzQztjQW9CSTt1QkFDS3pDLEtBQUt3QixNQUFLckI7ZUFBTyxPQWYxQlYsSUFlOEIsV0FsQjdCVixHQWtCUWlCLEtBQUt3QixPQUFLckI7Y0FBNkI7dUJBQ3BDSCxLQUFLd0IsTUFBS3JCO2VBQU8sT0FYN0JULE9BV29DLFdBbkJuQ1gsR0FtQldpQixLQUFLd0IsT0FBS3JCO2NBQWdDLEdBTVg7O1lBRzdDcUQsVUFBVzVELFlBQVc2QyxPQUFPVixZQUFZaEQ7SUFDM0MsT0FuQ0VxRSxXQWtDV3hELFlBQVc2QyxPQUFPVjs2QkFDMEJQLE1BQVEsT0FBQSxXQUR0QnpDLEdBQ2N5QyxNQUFjO0dBQUM7WUFHdEVpQyxXQUFXbEU7SUFDUCxZQUFBLHlCQURPQTtnQkFFSDtRQUNGbUU7SUFBVyxXQUFYQTtHQUFtQjtZQUd6QkMsV0FBV3BFO0lBQ1AsWUFBQSx5QkFET0E7Z0JBRUg7UUFDRnFFO0lBQVcsV0FBWEE7R0FBbUI7WUFHekJDLGNBQWN0RTtJQUNoQjtLQUFNLFFBQUEseUJBRFVBO0tBQ08sVUFBQSx5QkFEUEE7OztVQUdPcUUscUJBQWZGO01BQTBCLGVBQTFCQSxLQUFlRTs7O3VCQURQO0lBRVQsTUFBQTtHQUFZO1lBR2pCRSxTQUFVbEUsWUFBVzZDLE9BQU9WLFlBQVloRDtJQUNaLFdBMUQ1QnFFLFdBeURVeEQsWUFBVzZDLE9BQU9WLFlBQVloRDs2Q0FuQnhDMEU7R0FvQnlFO1lBR3pFTSxTQUFVbkUsWUFBVzZDLE9BQU9WLFlBQVloRDtJQUNaLFdBOUQ1QnFFLFdBNkRVeEQsWUFBVzZDLE9BQU9WLFlBQVloRDs2Q0FqQnhDNEU7R0FrQnlFO1lBR3pFSyxZQUFhcEUsWUFBVzZDLE9BQU9WLFlBQVloRDtJQUNaLFdBbEUvQnFFLFdBaUVheEQsWUFBVzZDLE9BQU9WLFlBQVloRDs2Q0FmM0M4RTtHQWdCNEU7WUFHNUVJLFFBQVNyRSxZQUFXNkMsT0FBT1YsWUFBWWhEO0lBQ3pDLE9BYkUrRTthQVlTbEU7YUFBVzZDO2FBQU9WOzZCQUMwQlAsTUFBUSxPQUFBLFdBRHRCekMsR0FDY3lDLE1BQWM7R0FBQztZQUdwRTBDLFFBQVN0RSxZQUFXNkMsT0FBT1YsWUFBWWhEO0lBQ3pDLE9BYkVnRjthQVlTbkU7YUFBVzZDO2FBQU9WOzZCQUMwQlAsTUFBUSxPQUFBLFdBRHRCekMsR0FDY3lDLE1BQWM7R0FBQztZQUdwRTJDLFVBQVd2RSxZQUFXNkMsT0FBT1Y7SUFDL0IsT0FURWtDO2FBUVdyRSxZQUFXNkMsT0FBT1YsMkJBQy9CO0dBQThDO1lBRzVDcUMsVUFBV3hFLFlBQVc2QyxPQUFPVjtJQUMvQixPQVRFbUM7YUFRV3RFLFlBQVc2QyxPQUFPViwyQkFDL0I7R0FBOEM7WUFHNUNzQyxXQUFZekUsWUFBVzZDLE9BQU9WLFlBQVloRDtJQUM1QyxPQXJCRWlGO2FBb0JZcEU7YUFBVzZDO2FBQU9WOzZCQUMwQlAsTUFBUSxPQUFBLFdBRHRCekMsR0FDY3lDLE1BQWM7R0FBQztZQUd2RThDLGFBQWMxRSxZQUFXNkMsT0FBT1Y7SUFDbEMsT0FMRXNDO2FBSWN6RSxZQUFXNkMsT0FBT1YsMkJBQ2xDO0dBQWlEO1lBRy9Dd0MsTUFDSW5GLFdBRUZvRixVQUNBQyxXQUNDMUY7SUFFTCxHQU5NSztTQUFrQk8sTUFBbEJQLFFBQUFzRixrQkFBa0IvRTs7U0FBbEIrRTtJQU1OO1NBTHlCN0UsaUJBQW5COEUsbUJBQW1COUU7O1NBQW5COEU7SUFLMEIsT0E1RzlCNUI7YUF3R0V5QjthQUNBQztzQkFHa0N6RixLQUFJNEYsY0FBYUM7Y0FDcEMsSUFBYjlDLGFBQWEsd0JBRHVCNkM7aUJBQUo1Rjs7Z0JBTzNCMkMsSUFQMkIzQztnQkFFSGlELGFBS3hCTjtnQkFMU21ELGdCQUtUbkQ7Z0JBTExvRCxlQUtLcEQ7O2VBRk87Z0JBSFpxRCxpQkFHWSw2QkFKWmpEO2dCQUM2QkUsYUFBN0IrQztnQkFBY0YsZ0JBQWRFO2dCQUFBRCxlQUFBQztjQVFGO2VBREVDO2lCQUNGO2lDQVJFRixjQUZvQ0gsY0FOcENGO2VBa0JBUTtpQkFDRjs7bUJBWGdCSjttQkFGbUNEO21CQUxqREY7ZUFzQko7aUJBQUE7O21CQVJJTTttQkFHQUM7O29CQVFPLElBQW9CQyxxQkFBZEM7b0JBQ2IsT0FBQSxXQXBCQXJELGVBbUJhcUQsVUFBY0Q7bUJBQ1c7Y0FDTCxPQUFBOzs7dUJBcEJKbEQ7Z0NBb0JTRyxRQUFPaUQ7d0JBQy9DLFNBRCtDQTt5QkFLbkM7MEJBRGNGLFlBSnFCRTswQkFJcENELFdBSm9DQzswQkFLbkMsT0FBQSxXQTFCVnRELGVBeUJTcUQsVUFBZUQ7eUJBQ2YsS0FBQTswQkFBUCxNQUFBOzs2QkFKQUcsUUFHT0Y7Ozs2QkFERHBGLE1BSHFDcUYsb0JBQzNDQyxRQUVNdEY7aUNBUUpFO3lCQUFXO2dEQUNBOzZCQUNKeUI7eUJBQXVCLFdBQXZCQTt3QkFBNkI7d0JBRXhDLE9BZjZDMEQ7OzJCQWtCQTs0QkFBbENKLFlBbEJrQ0k7NEJBa0JBOzhCQUFBLHlCQXhDSVIsZUF1Qi9DUzs0QkFTZUM7NEJBQWZDLGdCQUNFdEYsU0FPTytFOzs7MkJBQzJDOzRCQUExQ0MsYUFuQmlDRzs0QkFtQlMsbUJBUmxEbkYsU0FRUWdGOzRCQVRLSzs0QkFBZkM7OEJBU3lCLHlCQXpDU1osY0F1QmxDVTs7OzJCQWdCb0I7NEJBRE1HLGVBaEJpQko7NEJBZ0JqQ0ssY0FoQmlDTDs0QkFVNUJNLG1CQUNiekYsU0FLd0J1Rjs0QkFOMUJHLGtCQUNFMUYsU0FLUXdGOzRCQU5LSCxtQkFBQUk7NEJBQWZILGdCQUFBSTs7MkJBQUFKOzZCQWNLN0QsSUFkTDZEOzRCQUFlRDs7MkJBZ0JGTSxJQWhCRU47a0NBZ0JHLFdBbERyQnhHLEdBeUJHdUcsMEJBdUJLM0QsR0FFUWtFOztxQ0FGRyxXQWhEbkI5RyxHQXlCR3VHLHNCQXVCSzNEOzZCQUhMbUU7O2dDQVhlUDs7MEJBZUpRLE1BZklSOzBCQVdmTyxrQkFJZ0IsV0FqRG5CL0csR0F5Qkd1RyxzQkF3QldTOzs2QkFKWEQ7d0JBT0osS0FQSUE7eUJBUU0sT0FBQSx5QkE3QjhCMUQsUUFDcENrRDs0QkE2Qkc5RCxPQVRIc0U7d0JBU1csT0FBQSx5QkE5QnlCMUQsUUFDcENrRCxPQTZCRzlEO3VCQUFpQzthQUFDO0dBQUM7WUFHNUN3RSw2QkFFR3hELFNBQ0F5RCxRQUNDN0c7SSxHQUFBQTtTQUFhTyxNQUFiUCxRQUFBUSxhQUFhRDs7U0FBYkM7b0JBRUFtQyxZQUNBaEQ7S0FNTjtNQUNJbUgsb0JBQW9CO01BQ3BCQyxZQUFZLDZCQVRWcEU7TUFVRnFFLGVBREFEO01BRUFFLGlCQUZBRjtNQUdBaEcsVUFIQWdHO01BSUFHO1FBQVM7O1VBTFRKOzswQkFLb0QsT0FEcEQvRixPQUN3RDtNQUN2RG9HO1FBbEJBL0Q7O1dBc0JJeEMsS0FBSVo7V0FDUCxJQUFJSixNQVBObUI7V0FRRSxHQUZPZjs7YUFLRW9DLE9BTEZwQztvQkFLVSx5QkFKYkosS0FERGdCLEtBS013Qjs7dUJBREcseUJBSFJ4QyxLQUREZ0I7V0FOTEc7O1VBVzBDOztXQVByQkgsS0FBSXdCO1dBSnpCckIsU0FJd0MseUJBSnhDQSxRQUlxQkgsS0FBSXdCOztVQUFzQztNQVMzRGdGOztPQUFBQTs7O1NBRW9CLE9BQUE7OzsyQkFBS2pIO21CQUV4QjtvQkFERWtIO3NCQUNGOzt3QkFuQkxMO3dCQWlCNkI3Rzt3QkE3QjNCSzt3QkFhRnlHO2lDQXVCZUs7eUJBQUwsSUFBaUJDLG9CQUFMM0csZ0JBQ2IsT0FEa0IyRzs7MEJBT0E7MkJBQUEsUUFBQSx5QkFQWkQsT0FBTzFHOzJCQU9ENEc7MkJBQU5DOzJCQUNBQyxVQUFRLHlCQVJSSixPQUFPMUc7MEJBU1gsa0NBOUJYc0csUUE0QnFCTTswQkE3QnJCekcsU0FnQ2tCLHlCQWhDbEJBLFFBc0JzQkg7MEJBV1gsa0NBSkk2RzswQkFJSixPQUhJQzs7OzhCQUxBQyxTQUFhLHlCQUhiTCxPQUFPMUc7MEJBSVgsa0NBREkrRzswQkFDSixPQUpJTDs7eUJBZUY7MEJBREVNOzRCQUNGOzs4QkF6Q2JkOzs7K0JBMENlLE9BRkoseUJBdENYRSxhQXdCc0JwRzs4QkFnQm1CO3lCQUU5Qjs7MkJBdkRWaUc7b0NBdURxQ2dCOzRCQUNGLFdBQUEsa0NBTHJCRDs0QkFLRixPQUFBLGtDQUR5QkM7MkJBQ21CO3lCQUNFOzBCQUFBLE9BQUEsc0JBN0J2RFQ7MEJBNkJrQyxPQUFBO3lCQUEzQixrQ0FOSVE7eUJBU0E7MEJBQUE7NEJBQUE7OEJBeERiakksR0FpQ29CaUIsS0F1Qk8sa0NBVGRnSDswQkFPQUU7NEJBQ0Y7O2lELE9BMUNaWCxnQkFvQnFCdkc7O3lCQTBCWCxrQ0EvQ1hzRyxRQTBDZVk7eUJBTXFCLE9BQUE7Z0RBM0JyQlIsT0FBTzFHLFNBY1BnSCxRQU9BRTt3QkFNK0M7bUJBbEQ5RGIsZ0JBaUJPSTttQkFsQlBMLGNBaUI2QjdHOztrQkFxQ1g7O0tBRTRCO01BQUEsT0FBQSxzQkF6QzFDaUg7TUF5Q3FCLE9BQUE7S0FBN0Isa0NBckRJRjtLQXFESixPQUFBLGtDQXJESUEsUUFzRGU7O1lBR2pCYSxjQUFjbEIsUUFBUXJHLFlBQVdMLEtBQUtSO0lBQ3hDLE9BNVNFNkM7YUEyU2lDckM7c0JBQ1Z3QztjQUN2QixPQTlFQWlFLGdDQTRFY0MsUUFBUXJHLFlBQVdMO3VCQUNWd0MsWUFEZWhEO2FBUXpCO0dBQUM7WUFHZHFJLE9BQU9uQixRQUFRckcsWUFBV0wsS0FBS1I7SUFDakMsT0F2VEU2QzthQXNUMEJyQztzQkFDSHdDO2NBQ3ZCLE9BekZBaUUsZ0NBdUZPQyxRQUFRckcsWUFBV0w7dUJBQ0h3QyxZQURRaEQ7YUFFa0Q7R0FBQztZQUdsRnNJLE1BQU1wQixRQUFRckcsWUFBV0wsS0FBS1I7SUFDaEMsT0FORXFJO2FBS01uQjthQUFRckc7YUFBV0w7NkJBQ21CaUMsTUFBUSxPQUFBLFdBRHRCekMsR0FDY3lDLE1BQWM7R0FBQztZQUczRDhGLGFBQWFyQixRQUFRckcsWUFBV0wsS0FBS1I7SUFDdkMsT0FyQkVvSTthQW9CYWxCO2FBQVFyRzthQUFXTDs2QkFDbUJpQyxNQUFRLE9BQUEsV0FEdEJ6QyxHQUNjeUMsTUFBYztHQUFDO1lBR2xFK0YsUUFBUXRCLFFBQVF2QixpQkFBaUJDLGtCQUFpQjZDLE1BQUtDLE1BQU0xSTtJQUMvRCxPQXpCRW9JO2FBd0JRbEI7O2FBbEtSMUI7ZUFrS2dCRztlQUFpQkM7ZUFBaUI2QztlQUFLQzsrQkFDU3JHLE1BQVEsV0FBUkEsTUFBaUI7c0JBQ2xEcEIsS0FBVW9CLE1BQVEsT0FBQSxXQUZZckMsR0FFOUJpQixLQUFVb0IsTUFBbUI7R0FBQztZQWlGN0RzRztJQTVFSTlILFlBNEVvQitILG1CQUFtQkMsMkJBdkV2QzdJO0lBd0VOO0tBQUk4STtPQXZaRmpHOztrQkE4VUlHO1VBMkVGLEdBL0VFbkM7ZUFBOEJELE1BQTlCQyxlQUFBa0ksZUFBOEJuSTs7ZUFBOUJtSTthQTRFb0JIO2VBM0VtQjlILFFBMkVuQjhILHNCQTNFcEJJLHNCQUF1Q2xJOztlQUF2Q2tJO2FBMkV1Q0g7ZUExRUNJLFFBMEVESix1QkExRXZDSyx1QkFBd0NEOztlQUF4Q0M7VUFRa0I7V0FBcEIvQixvQkFBb0I7V0FDcEJDLFlBQVksNkJBUFZwRTtXQVFGbUcsZUFEQS9CO1dBRUFnQzthQUFjOztlQUhkakM7OytCQUd5RCxPQUR6RGdDLFlBQ2tFO1dBQ2xFRSxnQkFIQWpDO1dBSUFrQzthQUFlOztlQUxmbkM7OytCQUswRCxPQUQxRGtDLGFBQ29FO1dBQ3BFaEMsZUFMQUQ7V0FNQW1DO2FBQ0Y7Ozt3QkFBOEIvSTtnQkFDNUI7aUJBQ1EsUUFBQSx5QkFKUjZHO2lCQUlnQyxVQUFBLHlCQUZKN0c7Ozs7a0JBRUk7bUJBUTFCO29CQURFZ0o7c0JBQ0Y7O3dCQVZzQmhKO2lDQVVBUyxLQUFLd0I7eUJBQ3pCLElBQUlnSCxJQUFPLFdBeEJqQnpKLEdBdUIwQmlCLEtBQUt3Qjt5QkFFekIsT0FESWdIO3dCQUNIO29CQUVEQztzQkFDRjs7d0JBZnNCbEo7aUNBZUFTLEtBQUt3Qjt5QkFDekIsSUFBT2tILElBQUksV0E3QmpCM0osR0E0QjBCaUIsS0FBS3dCO3lCQUV6QixPQURPa0g7d0JBQ047b0JBaEJDQyxRQWFGRjtvQkFiSkcsT0FRSUw7Ozs7Ozs7Ozt1QkFYUm5DO3VCQUU0QjdHO3VCQWxCMUJ1STsyQkFZRkksYUFFQUU7O3dCQThCUzt5QkFBeUJ6Qjt5QkFBTDNHO3lCQUFSMkk7eUJBQU5DO3lCQUNQLE9BRDBCakM7O3lCQWdCUSxXQUFBLHlCQWhCckJnQyxPQUFRM0k7eUJBZ0JSLFdBQUEseUJBaEJONEksTUFBYzVJOzs7eUJBR0U7a0NBSEcyRzswQkFFUmpHOzBCQUFObUk7MEJBQ1csVUFBQSxXQTFDN0I5SixHQXVDMkJpQixLQUVUNkk7MEJBQ0VDOzBCQUFSQzswQkFDZSxVQUFBLFdBM0MzQmhLLEdBdUMyQmlCLEtBRUhVOzBCQUVMc0k7MEJBQVBDOzBCQUNBVjs0QkFDQyxXQWpEYlIscUJBOENZZ0IsUUFDQUU7K0JBSkNMOytCQVFFLHlCQVJGQSxNQUFjNUksS0FJZmlKOzBCQU1BUjs0QkFDQyxXQXJEYlIsc0JBNkNvQmEsUUFDREU7K0JBSkFMOytCQWFKLHlCQWJJQSxPQUFRM0ksS0FJUmdKO3lCQVdYLFdBVklULFFBS0FFOzt3QkFRTzt5QkFESlMsVUFqQmlCdkM7eUJBa0JiLFVBQUEsV0F6RG5CNUgsR0F1QzJCaUIsS0FpQlprSjt5QkFDQWhLO3lCQUFIRDt5QkFDdUIsT0FBQSx5QkFuQmhCMEosT0FBUTNJLEtBa0JaZDt3QkFDUCxXQUFBLHlCQW5CSzBKLE1BQWM1SSxLQWtCZmY7dUJBQ2tEO21CQTVDdEQwSjttQkFBTkM7OztxQkFBTUQsUUFSVnhDLFdBUUl5QyxPQVJKekM7O3VCQXNETyxzQkFyRFArQixhQU9JVTtpQkE4Q29DLGtDQXBEeENUO3VCQXFETyxzQkFwRFBDLGNBS1VPO2lCQStDZ0Msa0NBbkQxQ047Z0JBSEFILGNBT0lVO2dCQUxKUixlQUtVTztnQkFIVnZDLGNBRTRCN0c7O2VBbURiO1dBRWUsT0FBQSxxQ0F0RDlCK0k7VUFzREosa0NBMURJSDtVQTJEK0IsV0FBQSxxQ0F2RC9CRztVQXVESixrQ0F6RElEO1VBMERzQjtXQUFBLE9BQUEsa0NBMUR0QkE7V0EwREosV0FBQSxrQ0E1RElGO1VBa0VBLE9BQUE7U0FPa0M7S0FFVCxPQUFBLDRCQVh6Qk4scUI7SUFXSjtZQUFBLDRCQVhJQSxxQjs7R0FXb0Q7WUFHdERzQixNQUFPeEIsbUJBQW1CQyxvQkFBbUJuRjtJQUU3QztLQURFN0M7T0FDRjs7U0FGTytIO1NBQW1CQztrQkFFK0JZLEdBQUVFLEdBQ3pELE9BQUEsOEJBRHVERixHQUFFRSxHQUMvQjtJQU96QixPQXpCSGhCO2FBZ0JFOUg7YUFESytIO2FBQW1CQzthQUFtQm5GOzZCQVU3QmpCLE1BQVEsT0FBUkEsS0FBWTtHQUFDO1lBcUY3QjRILGFBaEZHbkQsUUFDQ3JHLG1CQUdBYjtJQTZFTjtLQUFJOEk7T0FyZ0JGakc7O2tCQXViSUc7VUFnRkYsR0FsRkVuQztlQUFhRCxNQUFiQyxlQUFBa0ksZUFBYW5JOztlQUFibUk7VUFXa0I7V0FBcEI1QixvQkFBb0I7V0FDcEJDLFlBQVksNkJBVlZwRTtXQVdGcUUsZUFEQUQ7V0FFQUUsaUJBRkFGO1dBR0ErQixlQUhBL0I7V0FJQWdDO2FBQWM7O2VBTGRqQzs7K0JBS3lELE9BRHpEZ0MsWUFDa0U7V0FDbEVFLGdCQUxBakM7V0FNQWtDO2FBQWU7O2VBUGZuQzs7K0JBTzBELE9BRDFEa0MsYUFDb0U7V0FHaEVFOztZQUFBQTs7O2NBRXNCLE9BQUE7OztnQ0FBSy9JO3dCQUUxQjt5QkFERWtIOzJCQUNGOzs2QkFaTEw7NkJBVStCN0c7NkJBdkI3QnVJOzZCQWNGekI7c0NBZ0JlSzs4QkFBTCxJQUFpQkMsb0JBQUwzRyxnQkFDYixPQURrQjJHOzsrQkFPZ0I7Z0NBQUEsUUFBQSx5QkFQNUJELE9BQU8xRztnQ0FPU3FKO2dDQUFWQztnQ0FBTnpDO2dDQUNBQyxVQUFRLHlCQVJSSixPQUFPMUc7K0JBU1gsa0NBdkJYbUksYUFxQnFCbUI7K0JBR1Ysa0NBdEJYakIsY0FtQitCZ0I7K0JBdEIvQm5CLGNBMEJ1Qix5QkExQnZCQSxhQWVzQmxJOytCQWJ0Qm9JLGVBeUJ3Qix5QkF6QnhCQSxjQWFzQnBJOytCQWFYLGtDQU5JNkc7K0JBTUosT0FMSUM7OzttQ0FMQUMsU0FBOEIseUJBSDlCTCxPQUFPMUc7K0JBSVgsa0NBREkrRzsrQkFDSixPQUpJTDs7OEJBaUJGOytCQURFTTtpQ0FDRjs7bUNBcENiZDs7O29DQXFDZSxPQUZKLHlCQWpDWEUsYUFpQnNCcEc7bUNBa0JtQjs4QkFFOUI7O2dDQW5EVmlHO3lDQW1EcUNnQjtpQ0FDRixXQUFBLGtDQUxyQkQ7aUNBS0YsT0FBQSxrQ0FEeUJDO2dDQUNtQjs4QkFDRTsrQkFBQSxPQUFBLHNCQS9CdkRxQjsrQkErQmtDLE9BQUE7OEJBQTNCLGtDQU5JdEI7OEJBT3dCOytCQUFBO2lDQUFBO21DQWxEckNqSSxHQTJCb0JpQixLQXVCOEIsa0NBUHJDZ0g7K0JBT1d1QzsrQkFBWEM7K0JBQ0FDO2lDQUNGOzs7NkNBcENhakk7cUNBSjFCMEc7c0NBSTZDLHlCQUo3Q0EsYUFlc0JsSSxLQVhJd0I7OzttQ0FrQ1hnSTsrQkFNQUU7aUNBQ0Y7Ozs2Q0F4Q2NsSTtxQ0FIM0I0RztzQ0FHK0MseUJBSC9DQSxjQWFzQnBJLEtBVkt3Qjs7O21DQWlDRCtIOzhCQVdmO3VEQWhEWHBCLGFBc0Nlc0I7OEJBV0o7O2dDQS9DWHBCO2dDQXlDZXFCOzhCQVVJLE9BQUE7O3VDQXZDSmhEO3VDQUFPMUc7MkNBZ0JQZ0gsUUFRQXlDLHdCQUtBQzs2QkFVNEQ7d0JBdkQzRXJELGdCQVVPSTt3QkFYUEwsY0FVK0I3Rzs7dUJBaURiOztVQUVpQztXQUFBLE9BQUEsc0JBckQvQytJO1dBcUQwQixPQUFBO1VBQWxDLGtDQTFESUg7VUEyRG9EO1dBQUEsT0FBQSxzQkF0RGhERztXQXNEMkIsT0FBQTtVQUFuQyxrQ0F6RElEO1VBMERzQjtXQUFBLE9BQUEsa0NBMUR0QkE7V0EwREosV0FBQSxrQ0E1RElGO1VBa0VBLE9BQUE7U0FFa0M7S0FFVCxPQUFBLDRCQU56Qk4scUI7SUFNSjtZQUFBLDRCQU5JQSxxQjs7R0FNb0Q7WUFHdEQ4QixLQUFLcEs7SUFDUCxPQS9nQkVxQzthQThnQktyQztzQkFDa0J3QztjQUN2QixTQUFJdEMsSUFBS08sWUFBWUc7ZUFBTSxPQUFBLHlCQUFOQSxLQUFaSDtjQUFpQztjQUMxQyxTQUFJTixPQUFRTSxZQUFZRztlQUFNLE9BQUEseUJBQU5BLEtBQVpIO2NBQW9DO2NBQ2hELFNBQUlKLHdCQUFpQixTQUFJO2NBQ3pCLE9BMW1CQVQ7MkJBeW1CSVM7Ozs7dUJBSkNMO3VCQU9HLDJCQU5ld0M7dUJBQ25CdEM7dUJBQ0FDO2FBUUs7R0FBQztZQUdWa0ssZUFBZ0JoSyxZQUFXTCxLQUFLUjtJQUNsQyxPQTdoQkU2QzthQTRoQjJCckM7c0JBQ0p3QztjQUNYLElBQVI4SCxRQUFRLDZCQURXOUg7Y0FlYixPQW5vQlY1Qzt1QkFtbkJnQlM7O2lDQVFBSSxZQUEwQndCO3lCQUFoQzswQkFBNkNzSTswQkFBUEM7MEJBQ3RDLFFBQUEsV0FUc0JoTCxHQVFoQmlCLEtBQTBCd0I7OzBCQUVJOzJCQUFsQ3dJOzJCQUFrQyxPQUFBLHlCQUZTRixRQUF2QzlKOzBCQUVJO2tDQUFBLHlCQUY0QitKLE9BQWhDL0osS0FFSmdLOzs7eUJBQytCOzBCQUE5QkM7MEJBQThCLE9BQUEseUJBSFlILFFBQXZDOUosS0FHSGlLO3lCQUFRLFdBQUEseUJBSDJCRixPQUFoQy9KO3dCQUdxRDs7O3VCQVgxQ1Q7MkJBRXZCc0ssT0FBQUE7Z0NBVVM3SixLQUFLd0I7d0JBQVg7eUJBQXdCc0k7eUJBQVBDO3lCQUNkLFFBQUEsV0Fic0JoTCxHQVluQmlCLEtBQUt3Qjs7NkJBRU53STt5QkFBUTtpQ0FBQSx5QkFGSUQsT0FBWC9KLEtBRURnSztpQ0FGbUJGOzs0QkFHbEJHO3dCQUFRO2dDQUhHRjtnQ0FHSSx5QkFIR0QsUUFBbEI5SixLQUdBaUs7dUJBQTZDO2dDQUMxQ2pLO3dCQUFOO3lCQUEwQjhKO3lCQUFQQzt5QkFDSCxPQUFBLHlCQURVRCxRQUFwQjlKO3dCQUNaLFdBQUEseUJBRHlCK0osT0FBYi9KO3VCQUNnQzthQUFBO0dBQUM7WUFHakRrSyxRQUFRQyxPQUFNNUs7SUFDaEI7S0FDeUQsT0FBQSx3QkFGekNBO0tBRVorRyxhQUFhO0tBQ2JPO09BQU87Z0NBSERzRCwwQkFHZ0MsT0FEdEM3RCxVQUM2QztJQUNqRDs7TUFKZ0IvRztlQUlPUyxLQUFVb0s7T0FHN0I7O1VBQUE7OztzQkFBMENuTDtjQUwxQ3FILFlBTWEseUJBTmJBLFdBRW1CdEcsS0FHdUJmOzthQUNEO1lBSlptTDtPQUc3QixPQUFBLGtDQUpBdkQ7TUFLMkM7SUFKL0MsT0FBQSxrQ0FESUE7R0FNYTtZQStDZndELEtBNUNxQkM7SUE2Q3ZCLE9Bem1CRTFJO2FBNGpCcUIwSTtzQkFBVXZJO2NBNkNNO2VBM0NuQ21FLG9CQUFvQiwyQkFGRG9FO2VBR25CbkUsWUFBWSw2QkFIaUJwRTtlQUk3QndJLGlCQURBcEU7ZUFFQXFFLHVCQUZBckU7ZUFHQXNFLDJCQUhBdEU7ZUFJQUc7aUJBQVM7O21CQUxUSjs7bUNBS29ELE9BSHBEcUUsY0FHK0Q7dUJBQy9ERyxZQUFZRCxzQkFBc0J6SyxLQUFLMks7ZUFFdkM7Z0JBREVDO2tCQUNGOzs7OEJBQThDcEo7c0JBTjlDK0k7dUJBT2dCLHlCQVBoQkEsZUFJa0N2SyxLQUVZd0I7O3FCQUNBO29CQUhQbUo7ZUFLekMsa0NBTkVyRSxRQUVFc0U7ZUFJSixPQUFBO3NDQUxjSCxzQkFBc0J6SyxLQUNoQzRLO2NBSzJDO3VCQUU3Q0MsZUFBZUosc0JBQXNCeks7ZUFDN0IsSUFBTjRHLE1BQU0seUJBRE82RCxzQkFBc0J6SztlQUV2QyxrQ0FYRXNHLFFBVUVNO2VBYkYyRCxnQkFlWSx5QkFmWkEsZUFZcUN2SztlQUl2QyxPQUFBLHlCQUppQnlLLHNCQUFzQnpLO2NBSUo7Y0FHbkM7ZUFERXdHO2lCQUNGOzttQkF2QnFCOEQ7NEJBdUJZUTtvQkFFN0I7cUJBREVDO3VCQUNGOzt5QkFwQkZQO3lCQWtCK0JNOzt5QkFqQi9CTDtrQ0F3QllBOzBCQUFMLElBQWdDckosaUJBQUxwQixnQkFDNUIsT0FEaUNvQjs7MkJBRXBCLE9BaEJuQnlKLGVBY1lKLHNCQUFzQnpLOzsrQkFJYjJLLFlBSmtCdko7MkJBSy9CLE9BM0JSc0o7b0NBUUFHLGVBY1lKLHNCQUFzQnpLLE1BQUFBLEtBSWIySzs7OEJBRE5LLGNBSHdCNUo7MEJBR1gsT0F6QjVCc0osWUFzQllELHNCQUFzQnpLLEtBR25CZ0w7eUJBRWlFO29CQTdCaEZQLDBCQWtCSU07b0JBbkJKUCxzQkFrQitCTTs7bUJBZUM7ZUFFUCxPQUFBLHFDQWxCekJ0RTtjQWtCSixrQ0FqQ0lGO2NBaUNKLE9BQUEsa0NBakNJQTthQXNDdUU7R0FBQztZQW9CMUUyRSxTQUFTQyxXQUFXdEw7SUFDRSxJQU5Ec0csb0JBTUMsMkJBRGJnRjtJQUVlLE9BL25CeEJ0SjthQTZuQlNzSjtzQkFWQW5KO2NBYVQ7ZUFaSThILFFBQVEsNkJBREg5SDtlQWFMb0ksWUFaQU4sT0FBQUEsT0FBQUE7ZUFhQXNCO2lCQUNGOzttQkFWbUJqRjs7bUNBVXlDLE9BRjFEaUUsU0FFMEU7Y0FFOUUsU0FBSWlCLCtCQUFzQ3ZFLE1BQU13RTtlQUM5QztnQkFDdUMsT0FBQSwwQkFGT0E7Z0JBQzFDQyxhQUNGO2VBRUYsT0FBQSxrQ0FKd0N6RSxNQUNwQ3lFO2NBR2tEO2NBUXhELElBQVFEOztnQkFBQUE7OztrQkFFMEIsT0FBQTs7MkJBckJ6Qkg7b0NBcUI4QkE7NEJBQ2hDOzZCQUFJSyxpQkFuQlBwQjs2QkFxQks7K0JBQUE7O2lDQUZFb0I7aUNBRDRCTDtpQ0FyQm5CdEw7cUNBR2hCdUssVUFBQUE7O2tDQTBCVTttQ0FBc0MxSjttQ0FsQ3ZCVDttQ0FrQ0t3TDttQ0FBZEM7bUNBQ1AsT0FEdUNoTDs7bUNBR3RCLElBQVhpTCxXQUFXLHlCQUhWRCxjQWxDU3pMO21DQXNDZCxrQ0FESTBMO21DQUVKLGtDQTlCWFA7bUNBK0J3QyxXQUFBLHlCQU5WSyxZQWxDTHhMO21DQXdDZDsyQ0FBQSx5QkFOS3lMLGNBbENTekw7Ozs7bUNBc0RaLFdBQUEseUJBcEJHeUwsY0FsQ1N6TDttQ0FxRGQ7bUNBRUEsV0FyQkt5TCxjQUFjRDs7a0NBakNHO21DQXlDbEIzRTtxQ0F6Q2tCOzt1Q0FEaEJYOzs7d0NBQzJCLE9BQWhELHlCQU9JaUUsVUFSeUJuSzt1Q0FDK0M7a0NBV3hFb0wsK0JBOEJldkUsTUFsQlh3RTtrQ0FzQk8sa0NBckNYRjtrQ0EwQ3FCO21DQUFBLE9BQUEsa0NBVE50RTttQ0FNRixPQUFBLHlCQWRpQjJFLFlBbENMeEw7a0NBK0NkOzBDQUFFLHlCQWJHeUwsY0FsQ1N6TCxLQTBDVjZHOztpQ0FhcUI7NkJBM0JmMkU7NkJBQWRDOzRCQXBCUHRCLFdBa0JtQ2U7NEJBbEJuQ2YsV0FvQk9zQjs0QkFwQlB0QixXQW9CcUJxQjs7MkJBK0JZOztjQS9DakNKO2dCQUhBRCxpQkFlSUU7Y0FxQ1IsT0FBQSxrQ0FwRElGO2FBcUR5QztHQUFDO1lBVTlDUSxTQUVJdk07SSxHQUFBQTtTQUFhTyxNQUFiUCxRQUFBUSxhQUFhRDs7U0FBYkM7b0JBRUZnTTtLQUVKLE9BMW9CRTdJOztjQXdvQkU2STt1QkFFOEI1TSxLQUFJTyxLQUFJcU07ZUFDMUIsSUFBVkMsVUFBVSx3QkFEc0J0TTtlQUVwQyxTQWRKdU0sTUFjY3RELEdBQUVFO2dCQUFJLFdBQUEsV0FEWm1ELFNBQ01yRCxHQUFFRTtnQkFBSSxPQUFBO2VBQWU7d0JBRzNCcUQsa0JBakJSQyxPQUFBQztnQkFpQnVDLEdBakJ2QywrQkFBQUQsT0FBQUMsUUFBQTswQkFBQUQ7MkJBQUFDLG9CQUdFOzBCQUhGQSxVQUVFOzs7MEJBRkZEO3NCQUNFRSxRQURGRjs0QkFBQUMsNEJBQUFBO3VCQUNFRSxRQURGRjttQkFDWSxPQURaSCxNQUNFSSxPQUFBQzs7a0JBQUE7O3FCQUNBQyxRQUZGSjsyQkFBQUMsb0JBRUU7MEJBRkZBO3NCQUVFSSxRQUZGSjtrQkFFWSxPQUZaSCxNQUVFTSxPQUFBQzs7O2dCQURBO2VBZ0I2RTt3QkFDdkVDLGVBQWdCNUksS0FBS0U7Z0JBQ3ZCOzBCQURrQkY7MEJBQUFBO3NCQUlYNkksUUFKVzdJOzRCQUFLRTsyQkFBQUE7bUJBSFQ7b0JBQUo0SSxRQUdhNUk7b0JBSFQsT0FBQSxXQUZaaUksU0FTS1UsT0FQR0M7bUJBQUksT0FBQTs7c0JBQ0hDLFFBRVk3SSxRQUZkOEksUUFNRkg7Ozs2QkFKVzdJOzRCQUFLRTtzQkFGWjZJLFFBRVk3SSxRQUZkOEk7O2lCQUFNLFdBQUEsV0FIYmIsU0FHT2EsT0FBRUQ7aUJBQUksT0FBQTs7Z0JBS2I7ZUFFMEU7ZUFFOUUsU0FBSUUsZUFBZ0JqSixLQUFLRSxLQUFJNUQ7Z0JBQzNCO3dCQUFBLGlDQURrQjBELEtBQVMxRCxLQVp6QjZMO2dCQWFGOzBCQURGLGlDQUF5QmpJLEtBQUk1RCxLQVp6QjZMOztlQWNpRDtlQUVyRCxLQWpCd0NEO2dCQW9CQyxXQUFBLHdCQXBCTHJNO2dCQW9CSyxPQUFBOzttQkFDbENxTixVQXJCaUNoQixVQXFCMUJoSSxNQUFQZ0osWUFBRWxKLE1BQUZrSjt3QkFDREM7Z0JBQWtCLE9BQXRCLHlCQXRCa0N0TixLQXFCM0JtRSxLQUFLRTtlQUM0RDtlQUN4RSxHQXZCOEI1RTsyQkFBQUE7OztrQkFpQ1A4TjtrQkFBRUMsVUFBRkQ7a0JBQWRFO2tCQU5rQkMsVUFNSkg7aUJBSGY7O21CQXhCTlIsZUEyQnVCUyxTQU5FRTs7O29CQXJCekJYLGVBZUs1SSxLQU1vQnVKO3lCQXJCekJYLGVBMkJ1QlMsU0FaYm5KO3NCQVk4Q3NKLG1CQUF4QkMsWUFBWEw7a0JBQ1IsT0FBQTs7b0NBQU9NO3FDQVliQzs2QkFURjs4QkFTa0Q3TDs4QkFBTHhCOzhCQUFOVDs4QkFBVCtOOzhCQVQ5QixPQXhCTFgsZUFRS2pKLEtBQUtFLEtBeUJ3QzVEOzhCQVQ3QyxjQXhCTDJNLGVBb0J1QkksU0FBU0ksV0Fha0JuTjs2QkFDMUM7OEJBS0UsSUFDQ3VOLFlBUHdCRDs4QkFRNUIsWUFESUM7NENBQUFBLFdBR1UseUJBVnVCaE8sS0FBTVM7d0NBUy9CLFdBckJDb04sT0FabEJQOzt3Q0F3QnFEckw7OzhCQUluQyxXQUplOEwsU0FJTix5QkFKZS9OLEtBQU1TO2lDQUtsQ2dLLDhCQUx1Q3hJLGFBQUFBOzZCQUtWO3FDQUxWOEw7cUNBS21CLHlCQUxWL04sS0FBTVMsS0FLbENnSzs7NEJBV1U7NkJBQWpCd0QsaUJBQWlCLHlCQTdCOEJOOzZCQTBCakRPOytCQUlGOztrQ0E5QkVUO2tDQWpDeUJ6TjtrQ0FKaENLO3NDQWtFUzROLGdCQTdCK0NOO2tDQWFqREc7OzRCQXlCRDs4QkFBQTs7Z0NBbEVOdEI7Z0NBQUFBO2dDQTRCcUJlO2dDQVpsQkY7NkJBeURFLE9BbkJFYTs0QkF1QkE7NkJBREVDOytCQUNGOytDQXZCQUQsZ0NBdENGL0osS0FBS0U7NEJBbUVMLFNBQ00rSixlQUFlQyxZQUFXQzs2QkFDdEI7c0NBQUEseUJBRFdELFlBQVdDOzs4QkFJMUIsT0FBQTtpQ0FGSXRPOzZCQUFPLE9BQVBBOzRCQUVtRDs0QkFFM0QsVUE5RGdCd047NkJBaUUyQjs4QkFBQSxPQUFBLHdCQWxHbEJ4Tjs4QkErRnJCcU8sYUFHQTswQ0FqRVliOzs4QkFvRVBlLFlBcEVPZjs4QkE4RFphO2dDQU9BLHlCQXRHcUJyTyxLQXFCM0JtRSxTQWdGV29LOzs7OEJBRkFDLFlBbEVPaEI7OEJBOERaYTtnQ0FLQSx5QkFwR3FCck8sS0FxQjNCbUUsU0E4RVdxSztzQ0FsRWdCWjs2QkF5RWtCOzhCQUFBLE9BQUEsd0JBMUdsQjVOOzhCQXVHckJzTyxhQUdBOzBDQXpFcUJWOzs4QkE0RWhCRixVQTVFZ0JFOzhCQXNFckJVO2dDQU9BLHlCQTlHcUJ0TyxTQTZHaEIwTixVQXhGTnJKOzs7OEJBc0ZNb0ssWUExRWdCYjs4QkFzRXJCVTtnQ0FLQSx5QkE1R3FCdE8sU0EyR2hCeU8sWUF0Rk5wSzs0QkEyRkg7NkJBeEJFcUs7K0JBQ0VOO2lDQU1BQztpQ0FOQUQsZUFSRkQsMkJBc0JFRzs0QkFhTixPQTVCSUk7MkJBNEJ3Qjs7aUJBcEZoQyxPQVZDcEI7OztlQUlELE9BSkNBO2NBOEZnQyxHQUFDOztZQUd2Q3FCLE1BQU90TyxZQUFXMEssVUFBcUI2RCxrQkFBa0JwUDtJQUMzRCxPQXI1QkVJO2FBbzVCT1M7O3VCQVFPSSxLQUFLQyxVQUFVQyxVQUFTa0M7ZUFDcEM7Z0JBQUltQixXQUFXLFdBVHdDeEUsR0FRM0NpQixLQUFLQztnQkFFYm9ELFVBQVUsV0FWeUN0RSxHQVEzQ2lCLEtBQWVFO2dCQUd4QjtrQkFBQTtvQkFBQSx3QkFIaUNrQyxZQUNoQ21CLFVBQ0FGO2VBQ0QsR0FBQTtnQkFDRSxPQUFBLHlCQUorQmpCLFFBRWhDaUIsU0FGdUJuRDtlQUt0QixXQUFBLHlCQUwrQmtDLFFBQ2hDbUI7ZUFJQyxPQUFBLCtCQUhERixTQUZ1Qm5EO2NBSytDOzs7YUFiMURvSzthQUlaLHdCQUppQzZEO3NCQU01Qm5PLEtBQUt3QixNQUFLWTtjQUFrQyxXQUFBLFdBTkVyRCxHQU05Q2lCLEtBQUt3QjtjQUFlLE9BQUEseUJBQVZZLGNBQUxaO2FBQTJEO3NCQUM3RHhCLEtBQUt3QixNQUFLWTtjQUE0QixXQUFBLFdBUEtyRCxHQU8zQ2lCLEtBQUt3QjtjQUFpQyxPQUFBLHlCQUE1Qlk7YUFBMEM7R0FNVztZQUc3RWdNLFVBQVd4TyxZQUFXMEssVUFBcUI2RCxrQkFBa0JFO0lBQy9ELE9BOTBCRXpNO2FBNjBCc0IwSTtzQkFDTWdFO2NBQzVCLE9BdDZCQW5QO3VCQW82QldTOzs7O3VCQUFXMEs7dUJBS2Qsd0JBTG1DNkQ7Z0NBTzFCbE4sV0FBV08sTUFBSytNO3dCQUN2QixZQUFBLFdBUm1ERixPQU81Q3BOLFdBQVdPO29DQUVkLE9BRm1CK007NEJBR3RCdk47d0JBQzZCLE9BQUE7O2lDQUpQdU47aUNBR3RCdk47O2tDQUM2QjttQ0FBbEMsT0FBQTs4REFWc0JzTixrQkFNWHJOLFdBQVdPO3NDQVViRDtrQ0FBYSxPQUFBLHlCQUFiQSxXQVZFTixXQUFXTztpQ0FVMkM7dUJBQUE7Z0NBQ25EUCxXQUFXTyxNQUFLK007d0JBQzFCLFlBQUEsV0FuQm1ERixPQWtCekNwTixXQUFXTztvQ0FFakIsT0FGc0IrTTs0QkFHekJ2Tjt3QkFDNkIsT0FBQTs7aUNBSkp1TjtpQ0FHekJ2Tjs7a0NBQzZCO21DQUU5QixPQUFBO2tDQUVnQjttQ0FEWE87bUNBQ0RpTixjQUFZLHlCQURYak4sV0FQS047a0NBU1AsT0FBQSx5QkFEQ3VOOztnREFBQUE7aUNBQ29EO3VCQUFBO2FBQUM7R0FBQztZQUdwRUMsU0FBVTdPLFlBQVcwSyxVQUFVdkksWUFBWXNNO0lBQzdDLE9BL0JFRDthQThCVXhPO2FBQVcwSzthQUFVdkk7NkJBQzhCUCxNQUFRLE9BQUEsV0FEMUI2TSxPQUNrQjdNLE1BQWtCO0dBQUM7WUFjOUVrTjtJQUFXLHVDQUNBO0lBQ047R0FBSTtZQUdUQztJQUFZLDhCQUNZO1FBQ2xCdE07SUFBSyxXQUFMQTtHQUFXO1lBSW5CdU0sc0JBQWdDQyxNQUFNQyxJQUFLdlA7SUFHN0M7S0FDSXdQLE1BQU0seUJBSm1DeFA7S0FLekN5UCxZQUFlLHlCQUxlSCxNQUk5QkU7S0FFQUUsVUFBYSx5QkFOdUJILElBSXBDQzthQUdBRyxVQUFVQyxNQUFNQyxXQUFXQztLQUM3QixPQUFZOzt1QkFBT2pDO2VBQVAsT0FJTDt3QkFMSytCO3dCQVArQjVQOzRCQUt6Q3lQLFdBQ0FDLFNBQ2dCRztpQ0FLTHBQO3lCQUFOOzBCQUF1Q3NQOzBCQUFUTDswQkFBWEQ7MEJBQ2hCTzs0QkFBZSx5QkFEcUJELEtBWmRULFlBWW5CN08sT0FBYWdQOzBCQUVoQlE7NEJBQWEseUJBRnVCRixLQVpSUixVQVl6QjlPLE9BQXdCaVA7eUJBR04sR0ExQjdCUCxTQXdCUWEsZ0JBeEJSYixTQXlCUWM7MEJBRVEsT0FBQSxXQVJDcEMsV0FLVG1DLGFBQ0FDLFdBRm9DRjt5QkFLbkM7aUNBSkRDO2lDQUNBQztpQ0FHcUIsV0FWRkgsYUFLaUJDO3dCQUtDO2NBQUM7SUFBQTtJQUs3QztLQUFBO09BQUEscUJBdEJtQ1IsSUFJcENDLE1BSjhCRjtVQU85Qkssb0NBZ0JxREksS0FBTyxPQUFQQSxZQUFjO1VBaEJuRUo7eUJBSEFILHNCQW9CbUVPLEtBQU8sT0FBUEEsWUFBYztLQUx0RUU7S0FBWEQ7S0FPTyxPQWhDUFosVUF5QkFZO0lBTzJDLE9BQUE7OztzQkFBS1AsV0FDbEQsV0FEa0RBLFdBaENoREwsVUF5QldhLFlBUTBCO0dBQUM7WUFzQnhDQyxZQUFhNUQsU0FBUzdMLEtBQUswUCxhQUFZalA7SUFDNUIsV0FBQSxXQURFb0wsU0FBYzZELGFBQUwxUDtJQUNyQixLQUFBLG1DQU1FO2NBUG9DUztnQkFBQUE7NEJBS3pCOzRCQUREOztJQUVOO0dBQ0g7WUFHSmtQLEtBRUdwUSxLQUNBUztJQUVMLE9BcjhCRTRCO2FBazhCR3JDO3NCQUdvQndDO2NBQ3ZCLElBQUk2TixjQURtQjdOO2NBRXZCLFNBQUk4TixTQUFTNVEsR0FBRUM7ZUFBSSxXQUFBLFdBRGYwUSxhQUNTM1EsR0FBRUM7ZUFBSSxPQUFBO2NBQW1CO3VCQTZCOUI0USxRQUFVOVEsS0FBd0MrUSxTQUFTMU07ZUFDakUsSUFEZ0IxQyxRQUFBM0I7ZUFDaEI7Z0JBQU8sS0FBQSx5QkFEaUQrUSxTQUFTMU0sVUFFNUQ7bUJBRlcxQzs7MEJBQUFBO2tCQU1ZcVA7a0JBVVRDO2tCQUFUakQ7aUJBVDZCO21CQUE5QixzQkFQK0MrQyxTQWdCOUMvQztzQkE3Q1I2QyxTQTZDaUJJLFNBaEI4QzVNO2tCQU9FLE9BRHZDMk07b0JBQUFBO3NCQVVLRSxhQVZMRjtrQkFHb0IsS0FBQSxzQkFUUUQsU0FnQjlDL0M7bUJBSnNDLEdBekM5QzZDLFNBNkIrRHhNLFNBZ0I5QzRNO29CQUhmOzRCQW5CQzs7OEJBc0JLakQ7OEJBaEI4QytDO29EQVY5QixTQUFJOzhCQTBCR0c7dUNBdEJ2Qi9QOytCQUFMLElBQW9CaUIsaUJBQVYrTzsrQkFDWCxVQURxQi9POzJDQUFBQTs7aUNBR0wsV0FBQSxXQTNCbEJ3TyxhQXdCYU8sVUFNa0Q5TTtpQ0FIN0MsR0FBQSwrQkFBZ0MsT0FIMUNsRDs7O2lDQUVTLFdBQUEsV0ExQmpCeVAsYUF3QmFPLFVBTWtEOU07aUNBSjlDLEdBQUEsK0JBQWdDLE9BRnpDbEQ7OzsrQkFJQyxPQUpEQTs4QkFJSzttQkF3QlQ7b0JBREVpUTtzQkFyQkZOO2dDQWdCSTlDLFNBQVNpRCxhQUFjQzt3QkFoQnVCSDt3QkFnQnJDRTtvQkFoQkhJLGdCQUF3Q04sU0FnQnJDRSxTQUtYRzttQkFyQlF6UCxRQUFBMFA7OztrQkEzQmIsV0FBQSxXQUhEVCxhQThCK0R2TSxTQWdCOUM0TTtrQkEzQ2hCLEdBQUE7bUJBSTRDO29CQUE1Qkssa0JBdUNBTDtvQkF2Q2JNLGtCQXVCMkRsTjtvQkF0QjNEc0k7c0JBQVcseUJBc0J1Q29FLFNBdkJsRFEsYUFBYUQ7O3VCQXVDY0osYUFyQ3BCLHlCQURQdkU7OzttQkFLeUM7b0JBQTVCNkUsb0JBaUI4Q25OO29CQWpCM0RvTixvQkFpQ2FSO29CQWhDYlM7c0JBQVc7c0NBZ0J1Q1gsU0FqQmxEVSxlQUFhRDs7dUJBaUNjTixhQS9CcEIseUJBRFBROztrQkEwQkY7OztnQkFpQjRCLE9BQUEsMEJBM0J3QlgsU0FBUzFNOztjQTJCUjtjQUUzRCxPQXI4QkFOLFVBczRCR3hELEtBQ0FTLEtBaUNLOFA7YUE2Qm9CO0dBQUM7WUFJN0JhLGlCQUVHL1EsWUFDQUwsS0FDQXFNO2FBRURnRixlQUFnQmhGO0tBR2xCLE9BbDlCQTdJO2NBNDhCR3hEO2NBR2VxTTt1QkFHVzVNLEtBdEdOTztlQXNHQTtnQkEzR091UDtnQkEyR1FEO2dCQU1qQyxPQUFBLHlCQWpIeUJDLElBMkdRRDtnQkFNakMsZUFBc0IseUJBTldBO2VBTVg7Ozs4REFqSEdDOzs7MkRBMkdRRDs7Ozs7OztnQkFPL0I7O2tCQVBzQjdQOzJCQUFBQTs7aUJBVWM7O2tCQURhNlI7a0JBQVg3Qjs7a0JBQWY4QjtrQkFBVkM7a0JBQVYvRDtrQkFDaUMsT0FBQSx3QkFoSHBCek47a0JBaUhmeVIscUJBWDhCbkMsT0FTbEJrQztrQkFHWkUsbUJBdkhzQm5DLEtBb0hBZ0M7a0JBSXRCSTs2QkFBbUJDLE1BbkhmQztxQkFvSE47O3NCQUFnQzt3QkFBZixxQkFESUQ7NkJBQ1cseUJBcEhmNVIsS0FBWDZSOzs7eUJBQW9DQyxPQW1IckJGLGlCQW5IZm5SLE1BQUFvUixPQUFvQ0UsS0FBQUQ7cUJBQ2xEO3NCQUFHLEdBQUEseUJBRCtDQyxRQUU3QyxXQUZTdFI7c0JBS1AsR0FBQSx5QkFMMkNzUjsyQkFJL0I3UixTQUFiOFI7OzJCQUFhOVIsVUFBYjhSO3NCQUdFLFlBQUEseUJBUGlCaFMsS0FJbkJnUyxhQUpRdlI7a0NBUUY7MEJBUkVzRixxQkFBb0NrTSxPQUFBRixLQUkvQjdSO3NCQUpMTyxNQUFBc0Y7c0JBQW9DZ00sS0FBQUU7O29CQXFIeEI7a0JBSWhCcFE7NkJBQU01QixNQUFNVDtxQkFDZCxPQUFBOzs4QkFYSWlPOzhCQS9HYXpOO29EQTBIK0IsU0FBSTs4QkFENUNDOzhCQUFNVDtvQkFDNEQ7b0JBWHhCOFI7a0JBaUI5QzttQkFGRzVCLFVBZjJDNEI7bUJBaUI5QztxQkFQRnpQOzs7d0JBT3VCO3lCQUFzQ1g7eUJBQUxUO3lCQUFieVI7eUJBQWRDOzsyQkFBY0QsYUFsSG5EaEMsa0JBZ0hhUixTQUVtRGpQLEtBQUtTO3dCQUN6RDtnQ0FEeUJpUixlQWxIckNqQyxrQkFpRzZDVCxXQWlCbUJoUCxLQUFLUzs7dUJBRVM7bUJBSGhEa1I7bUJBQWxCQzttQkFNRjtxQkFsQkZWO3VCQVlzQlMsaUJBYnRCVixzQkFZS2hDO21CQUZVNEM7bUJBQWZDO3FCQVRBWjt1QkFZSVUsbUJBZEpaLHdCQUZxQ2hDOztrQkF5Qm5DO21CQURFK0M7cUJBZEozUTs7Z0NBZXVCc1E7d0JBQUwsSUFBd0JqUixtQkFBTFQ7K0JBQWQwUjtpQ0ExSC9CakMsa0JBaUc2Q1QsV0F5QkFoUCxLQUFLUzs7dUJBQzRCO21CQTdJOUQsT0EvQmhCbU8sc0JBOEI4QkUsSUFBQUEsSUFLUHZQO21CQTRIQXlTO3FCQWhJWDs2RDttQkFnSUpDO3FCQVRBZjt1QkFvQklhLHFCQXRCSmYsd0JBRnFDaEM7bUJBYXRCNkMsZ0JBQUFHO21CQUFmRixnQkFBQUc7aUJBa0JzQixXQUFBLHlCQTlJUDFTO2lCQThJWixLQUFBLDRCQWxCSHVTO2tCQWtCSixNQUFBOztpQkFDMEIsV0FBQSx5QkEvSVB2UztpQkErSVosR0FBQSw0QkFuQllzUztrQkFvQlMsT0FBQTs7MkJBcEJ4QkM7b0NBb0I2QjlDLFdBQWEsV0FBYkEsV0FwQmQ2QyxlQW9CaUQ7aUJBRHBFLE1BQUE7Ozs7ZUFPQSxPQXpMSmpELHNCQXlJc0NDLE1BM0dSQyxJQUtQdlA7Y0FzSmtCO0lBQUE7SUFJM0MsU0FDSTJTLE9BQVF4UixPQUFLeVI7S0FBUSxPQUFtQjtvQ0FBM0JBLHVCQUFxQyxPQUExQ3pSLE1BQThDO0lBQU87SUFDakM7S0FBQSxPQUFBLDJCQTVEM0JuQjtLQTRERDZTLFdBQVM7Ozs7U0EzRFJ4Rzs7VTs7OztLQTRERHlHOzs7OztVOzs7O2FBR0EsT0FBQSxXQUpBRDs7YUFPb0I7Y0FGQzVKOzs7a0JBaEVwQm9EOzs7O3dCQWdFb0IwRzs0REFBQUE7Ozs7O2NBQTJCQzs7O2tCQWhFL0MzRzs7dUJBZ0VDNEc7OzRCQUFBQTs7MkJBQUFBOzs7O2NBQ21CQzs7O2tCQWpFcEI3Rzs7bUI7Ozt5QkFpRW9COEc7NEJBQUFBOzs7Ozs7Y0FBMkJDOzs7a0JBakUvQy9HOzttQjt3QkFpRUNnSDs4QkFBQUE7NEJBQUFBOzs7OztjQUNNQztnQkFoRVJqQyxlQWdFbUMsNEJBRmRwSSxHQUNBaUs7d0RBRDJCRixJQUNBSTt3REFDeENFOzs7Ozs7O3dCQUVKRjt3QkFEQUo7d0JBRElGO3VCQUdSLEtBSFFBLFdBTUc7OytCQU5IQTs7d0JBS0NyRDtxQ0FBb0IsZUFiN0JrRCxPQWFTbEQsV0FKTHVEO3VCQUd5RCxJQUFwQ3RELHNCQUFvQyxPQVo3RGlELE9BWXlCakQsU0FGckIwRDt1QkFFaUMsZUFackNULE9BYVNsRCxXQUpMdUQ7OzthQU9nQjtjQURETzs7O2tCQXpFbEJsSDs7Ozt3QkF5RWtCbUg7NERBQUFBOzs7OztjQUEyQkM7OztrQkF6RTdDcEg7O3VCQXlFRHFIOzs0QkFBQUE7OzJCQUFBQTs7OztjQUNRQztnQkF4RVJ0QyxlQXdFbUMsNEJBRGhCa0MsS0FBQUE7d0RBQ1hJLGdCQURzQ0Y7Ozs7OzJCQUUxQ1QsZUFESUY7dUJBRVIsS0FGUUEsV0FJRzsyQkFERnJTLE1BSERxUzt1QkFHWSxlQW5CcEJILE9BbUJTbFMsS0FGTHVTOzs7YUFLZ0I7Y0FEc0JZOzs7a0JBL0V6Q3ZIOzttQjs7O3lCQStFeUN3SDs0QkFBQUE7Ozs7OztjQUEyQkM7OztrQkEvRXBFekg7O21CO3dCQStFc0IwSDs4QkFBQUE7NEJBQUFBOzs7OztjQUNmQztnQkE5RVIzQyxlQThFbUMsNEJBRE91QyxLQUFBQTt3REFDbENJLGdCQUQ2REY7Ozs7OzJCQUVqRVYsZUFESU47dUJBRVIsS0FGUUEsV0FJRzsyQkFERnJTLE1BSERxUzt1QkFHWSxrQkF6QnBCSCxPQXlCU2xTLEtBRkwyUzs7OztJQUtSLE9BL1pFaEgsU0F1VUcvTCxZQUNBTCxLQTZERDhTO0dBMEI4QjtZQUdoQ21CLFVBT0lwVSxLQUF5QnFVLGVBQWNDO0lBQzNDLEdBREl0VTtTQUFhTyxNQUFiUCxRQUFBUSxhQUFhRDs7U0FBYkM7SUFDYyxPQTFtQ2xCZ0M7YUF5bUMyQzhSO3NCQUNwQkM7dUJBQ2pCdFUsT0FLT3VVLElBQUkzVCxVQUFVQyxVQUFTQztlQUM5QixPQUtLOzt3QkFOTUY7d0JBQVVDO3dCQVB2Qk47d0JBT2dDTztpQ0FNcEJBO3lCQUFMLElBQWNpQixpQkFBSnlTLGVBQ1gsT0FEZXpTOzs4QkFDWDBTOzs7MkJBR09uUyx5QkFKSVAsYUFBQUE7MkJBQ1gwUyxZQUdPblM7eUJBRVUsT0FBQTs7a0NBTmZ4QjtrQ0FBSzBUOzJDQU1lRTttQ0FDeEI7b0NBSWdCLE9BQUEsNkJBdkJMSjtvQ0FxQlAsT0FBQSw0QkFIb0JJO29DQUNwQkM7c0NBQ0Y7NERBZERKLG9CQW1CZ0IsT0FaZkUsTUFZb0I7bUNBRW5CLE9BQUEseUJBUkNFOztpREFBQUE7a0NBUW1EO3dCQUFFO2NBQUE7dUJBRS9EdlUsSUFBS08sS0FBS3dCO2VBQ1UsV0FBQSx3QkEvQkdpUztlQStCekIsc0IsT0E3QkVwVSxPQTRCS1csV0FBS3dCO2NBQ2tEO3VCQUU1RDlCLE9BQVFNLEtBQUt3QjtlQUNzQixXQUFBLHdCQWxDWmlTO2VBa0NZLHNCLE9BaENuQ3BVLE9BK0JRVyxLQUFLd0I7Y0FDK0M7Y0FFaEUsT0FwdUNGckM7OzJCQWtzQ01FOzs7dUJBRnFDcVU7dUJBc0NqQyx3QkF0Q21CRDt1QkE4QnZCaFU7dUJBR0FDO2FBU0s7R0FBQztZQUdadVUsWUFFR3JVLFlBQ0EwSyxVQUVDNEosWUFDQW5TO0lBRU4sT0Evc0NFbEI7YUF5c0NHakI7Ozt1QkFXV29CLFdBQVdDLGtCQUF1QmYsVUFBU0M7ZUFDdEMsV0FBQSxXQVRmK1QsWUFRVWxULFdBQVdDO2VBQ3ZCLE9BQUEseUJBRHVEZCxXQUFURDtjQUNrQjthQVgvRG9LO2FBUUcsd0JBTEZ2STtzQkFTT2YsV0FBV0MsV0FBV08sTUFBS3JCO2NBQ2YsV0FBQSxXQVhuQitULFlBVU9sVCxXQUFXQztjQUNwQixPQUFBLHlCQURvQ2QsV0FBTHFCO2FBQzRCO3NCQUMvQ1IsV0FBV0Msa0JBQWtCZDtjQUMxQixXQUFBLFdBYmIrVCxZQVlVbFQsV0FBV0M7Y0FDUixPQUFBLHlCQUQwQmQ7YUFDTTtHQUFDO1lBR2xEZ1UsU0FFR3ZVLFlBQ0EwSyxVQUVZZ0U7SUFFakIsT0FsckNFMU07YUE4cUNHMEk7c0JBSXlCNkQ7Y0FDNUI7ZUFLUWlHLHFCQVJPOUY7ZUFPVHZNO2lCQUtGO3FDQVZ3Qm9NLGtCQU1wQmlHO2NBTFMsT0E3QmpCSDt1QkF1QkdyVSxZQUNBMEssZ0NBU0d2STthQWFvQjtHQUFDO1lBRzNCc1MsT0FBUXpVLFlBQVcwSyxVQUFVNkQsa0JBQWtCRztJQUNqRCxPQS94Q0VuUDthQTh4Q1FTOztvQ0FNOENNLFVBQVNDO2VBQXZELElBQXNCYyxzQkFBWEQ7ZUFDVyxPQUFBOzt3QkFEaUNiO3dCQUE1Q2E7O3lCQUNXOzBCQUE1QixPQUFBO2dEQVA2Q3NOLGtCQU1qQnJOLFdBQXdCZjs2QkFHM0NYO3lCQUFPLE9BQUEseUJBQVBBLEtBSG1CMEIsV0FBd0JmO3dCQUdNO2NBQUM7OzthQVQxQ29LO2FBSWIsd0JBSnVCNkQ7NkJBVVUzTSxNQUFLckI7Y0FBdkMsSUFBc0JjLHNCQUFYRDtjQUNjLE9BQUE7O3VCQURjYjt1QkFBNUJhOzt3QkFDYzt5QkFBNUIsT0FBQTsrQ0FYNkNzTixrQkFVcEJyTixXQUFZTzs0QkFHNUJqQzt3QkFBTyxPQUFBLHlCQUFQQSxLQUhnQjBCLFdBQVlPO3VCQUdnQjthQUFDO21DQUNQckI7Y0FBekMsSUFBc0JjLHNCQUFYRDtjQUNXLE9BQUE7O3VCQURtQmI7dUJBQTlCYTs7d0JBQ1csWUFDaEI7d0JBRUU7eUJBREx6Qjt5QkFDRDhILFFBQU0seUJBREw5SCxLQUhtQjBCO3lCQUtKLFdBQUEseUJBRGhCb0c7d0JBQ0osT0FBQSxrQ0FESUE7dUJBQ3dDO2FBQUM7R0FBQTtZQUduRGlOLE9BQVExVSxZQUFXMEssVUFBVXZMO0lBQy9CLE9BcnpDRUk7YUFvekNRUzs7OzthQUFXMEs7O3NCQU1SdEssS0FBS3dCLE1BQUsrUztjQUFTLE9BQUcsV0FOSnhWLEdBTWxCaUIsS0FBS3dCLFFBQUsrUyxnQkFBQUE7YUFBa0Q7c0JBQ3pEdlUsS0FBS3dCLE1BQUsrUztjQUFTLE9BQUcsV0FQUHhWLEdBT2ZpQixLQUFLd0IsUUFBSytTLGdCQUFBQTthQUFrRDtHQUFDO1lBRzNFQSxNQUFPM1UsWUFBVzBLLFVBQVV2TDtJQUM5QixPQVhFdVY7YUFVTzFVO2FBQVcwSzs2QkFDd0I5SSxNQUFRLE9BQUEsV0FEdEJ6QyxHQUNjeUMsTUFBYztHQUFDO1lBR3pEZ1QsUUFBUzVVLFlBQVcwSyxVQUFVdkw7SUFDaEIsV0FmZHVWLE9BY1MxVSxZQUFXMEssVUFBVXZMO0lBQ29CLE9BQUE7OztzQkFBS3dWLE9BQVMsT0FBQSxxQkFBVEEsVUFBbUI7R0FBQztZQUczRUUsT0FBUTdVLFlBQVcwSyxVQUFVdkw7SUFDL0IsT0FMRXlWO2FBSVE1VTthQUFXMEs7NkJBQ3dCOUksTUFBUSxPQUFBLFdBRHRCekMsR0FDY3lDLE1BQWM7R0FBQztZQUcxRGtULElBRUc5VSxZQUNBMEssVUFDT3FLO0ksZ0JBQ1A1VjtLQUVMLE9BajFDRUk7Y0E0MENHUzs7OztjQUNBMEs7Y0FDT3FLOzhCQVFhQyxHQUFFelU7ZUFBdUIsV0FBQSxXQVA3Q3BCLEdBT29CNlY7ZUFBeUIsT0FBQSxXQVJ0Q0QsVUFRZXhVO2NBQTRCOzhCQUMzQnlVLEdBQUV6VTtlQUF1QixXQUFBLFdBUmhEcEIsR0FRdUI2VjtlQUF5QixPQUFBLFdBVHpDRCxVQVNrQnhVO2NBQTRCLEdBQUM7O1lBR3pEMFUsU0FBVWpWLFlBQVcwSyxVQUFVdkw7SUFFL0I7O09BeENBdVY7U0FzQ1UxVTtTQUFXMEs7a0JBRWlCdEssS0FBS3dCLE1BQVEsV0FBSSxXQUZ4QnpDLEdBRU9pQixLQUFLd0IsTUFBMEI7SUFDbEUsT0FBQTs7O3NCQUFLK1MsT0FBUyxPQUFBLHFCQUFUQSxVQUFrQjtHQUFDO1lBRzNCTyxRQUFTbFYsWUFBVzBLLFVBQVV2TDtJQUNoQyxPQVBFOFY7YUFNU2pWO2FBQVcwSzs2QkFDd0I5SSxNQUFRLE9BQUEsV0FEdEJ6QyxHQUNjeUMsTUFBYztHQUFDO0dBRzFDO0lBQUEsa0JBeFlqQm9OOzs7Ozs7Ozs7aUJBK1pGLFdBRUc7WUFFQ21HLE9BQVMzVixLQUF5QjhMLFdBQVduSjtJQUMvQyxHQURXM0M7U0FBYU8sTUFBYlAsUUFBQVEsYUFBYUQ7O1NBQWJDO0lBQ1gsSUFBUW9WOztNQUFBQTs7O1FBR0Q7U0FERUM7V0FDRjs7YUFKNkIvSjtzQkFJS0E7Y0FDaEM7a0NBSkQ4SjtlQUlXRTs7b0JBSlhGO2tFQUFBQSxRQUFBQTtjQUtDOztnQkFEVUU7Z0JBRHNCaEs7Z0JBSjlCdEw7OztpQkFXRztrQkFBY3VWO2tCQUFMblY7a0JBQ05vVixVQUFVLHlCQVBSRixXQU1JbFY7aUJBRVcsT0FBQTs7MEJBRGpCb1Y7bUNBQ3NCQzsyQkFDeEIsVUFIYUY7Ozs7OzZCQU1GRzttREFORUgsc0JBQUFBO3VDQU1GRzsyQkFKYUQ7b0VBQUFBOzBCQU1xQjtnQkFBRTtjQWQzQ0gsWUFEc0JoSzs7YUFnQkw7U0FFM0IvRSxZQUFZLDZCQXRCMEJwRTtTQTBCTixNQUFBLDJCQTFCTG1KO1FBdUIvQjtnQkFESS9FO2dCQUFBQTtnQkFuQkE4TztnQkF1Qk07OzJCQXpCUEQ7O2NBQUFBOzRCQTRCUixnQ0E1QlFBLFFBQUFBO0dBNEJPO1lBa0RiTyxLQXBCNkJDLEdBQUV4VjtJQXFCM0IsWUFBQSx5QkFyQnlCd1YsTUFBRXhWOztTQXNCL0JxVjtLQUFjLE9BQUEsa0NBQWRBOztJQXJCc0IsSUFBcEJuUCxvQkFBb0IsMkJBRE9zUDtJQUV1QixPQUFBOzthQURsRHRQO2FBRDJCc1A7O2NBRzdCLElBOUI4Qkg7O2dCQUFBQTs7O2tCQWtDdEI7O3FCQUFBOzt1QkFOTm5QOztpQ0E1QndDdVA7eUJBRXRCOzZDQUZVSjswQkFDdEJLOzsrQkFEc0JMOzs7aUVBQUFBO2lDQUFBQTswQkFFNUJNLGtCQUFrQix5QkF5QlNILE1BQUV4VjswQkF4QmMsTUFBQSxzQkFGckMwVjswQkFFTkUsWUFBWSwwQkFEWkQ7eUJBRUQsR0FBQSwwQkFEQ0MsV0FId0NIOzBCQUt2Qzs0QkFMdUNBOzBCQTJCYkQ7MkJBbEIxQjs7NkJBa0IwQkE7NkJBQUV4Vjs7OEJBbEJPO21DQUM3QjZWO2tDQUFBQTtvQ0FBQ0MsY0FBREQ7Z0NBVERILGFBU0VJO2dDQUdOLFdBWklKLFNBU0NHOzs7OEJBVERILGFBY2lCLHlCQVlJRixNQUFFeFY7OEJBWDNCLFdBZkkwVjs2QkFlTTs7O3lCQUdaOzBCQURFSzs0QkFDRjs7OEJBakJBSjt1Q0FpQm9DaFUsR0FBSyxXQUFJLHNCQWxCdkMrVCxTQWtCOEIvVCxHQUE2QjswQkFHNUQ7NEJBQUEseUJBSkhvVTsrQkFLSyx5QkFJb0JQLE1BQUV4VjsrQkFIdEIseUJBR29Cd1YsTUFBRXhWLEtBVDNCK1Y7eUJBU3lCUDs7O3VDQVNSLE9BQUEsc0JBcENTSCxVQW9DZ0I7a0JBSjFDLFdBQWdCLHlCQUxTRyxNQUFFeFY7O2NBZ0I3QjtrQ0EzQzRCcVY7ZUF3Q3BCSzs7b0JBeENvQkw7OztzREFBQUE7c0JBQUFBO2VBMkM1QixNQUFBLHFDQWhCMkJHO2NBYzdCLGtDQURVRTt1REFBQUE7YUFJOEI7R0FNUDtZQXFCeEJNLFVBQVVDLGFBakJJQyxlQWlCc0JWO0lBRTNDO0tBREVXO09BQ0Y7O1NBRjJDWDtTQUFBQTtrQkFFS3hWLEtBQUl3QjtVQUNsRCxVQURrREE7O1dBSzlCO29CQUw4QkE7WUFDaEM0VDtZQUlQelQ7WUFKUHlVLG1CQUlPelU7WUFNSzBVLFlBVkVqQjtZQUFka0IsaUJBQUFGOztlQUVNRyxNQUh3Qy9VLFNBV2xDNlUsZUFWWkMscUJBRU1DOztlQUNDMVEsSUFKdUNyRSxTQVdsQzZVLFlBUEx4USxHQUhQeVE7O1dBUUFFOzs7Ozs7Ozs0QkE1QjZCbkI7b0JBRTFCO3FCQURMb0IsY0FEK0JwQjtxQkFDbEJ4TyxPQURrQndPO3FCQUVqQ3RPLFNBQU8sa0NBRFFGO3FCQUlGLFFBQUEsNEJBSGJFO3FCQUtrQixNQUFBLDJCQUxsQkE7cUJBS0csVUFBQTtxQkFFb0IsVUFBQSwyQkFQdkJBO3FCQU9HLFVBQUE7cUJBR29CLFVBQUEsMkJBVnZCQTtxQkFVRyxNQUFBO3FCQVJMMlA7OztzQkFBQTlCO3NCQUFBK0I7O2dFQUFBL0I7eUJBQUE4Qjs7eUJBQUFDLFVBQUFEOzs7c0JBQUFFO3NCQUFBQzs7Z0VBQUFEO3lCQUFBRDs7eUJBQUFFLFVBQUFGOzs7c0JBQUFHO3NCQUFBQzs7Z0VBQUFEO3lCQUFBRDs7eUJBQUFFLFVBQUFGOzs7c0JBQUFHOzs7bUVBQUFBO3lCQUFBRDs7K0JBQUFBOzs7Ozs7eURBSnFCYixlQUNqQk87OzttQkE2QmNKOzs7YUFWWkM7O1lBUUExQixJQVJBMEI7OzsyQ0FwQmVKLGVBNEJmdEI7ZUFBQTRCOztxQkFBQUE7VUFGSjs7O2dEQVRlUCxhQUUrQmpXOztTQVl4QztJQUVWLFdBQVUseUJBZk5tVztHQWU2Qjs7Ozs7Ozs7T0E3NUNuQ3RVO09BbURBZ0I7T0FEQUQ7T0FJQUU7T0FGQXZEO09BcVBBNEg7T0FnQkFFO09BSUFDO09BVEFGO09Bc09Bd0M7T0FubkJBeks7T0EySkFpRTtPQWtDQUk7T0F1QkFNO09BSUFDO09BUUFFO09BSUFDO09BSUFDO09BSUFDO09BaEJBSjtPQW9CQUs7T0FJQUM7T0FJQUM7T0FrS0FnRDtPQWtHQTRCO09BZkF6QjtPQThHQTBCO09BNENBYztPQXdEQUc7T0FxQkFZO09BL0dBdEI7T0FrYkFnRztPQWhRQWhFO09BcVVBZ0Y7T0F4TUF6QztPQWdCQUU7T0E4QkFLO09BNTVCQTVOO09BbXBDQTJTO09BeUVBVztPQXJCQUY7T0FpREFJO09Bc0JBQztPQVVBQztPQTRCQU07T0FNQUM7T0E5QkFOO09BSUFDO09BSUFDO1dBcURFSyxRQStFQVEsYUF3QlNTOzs7aUJBbUNYaUIsVUFBUXRWLEdBQUksT0FsNEJadUksb0JBazRCUXZJLEdBQTBCO3NCQVk5QixXQUVIOztnQkE5N0NERTtnQkFtREFnQjtnQkFEQUQ7Z0JBSUFFO2dCQUZBdkQ7Z0JBcVBBNEg7Z0JBV0FDO2dCQVNBRTtnQkFKQUQ7Z0JBaU9BdUM7Z0JBbm5CQXpLO2dCQTJKQWlFO2dCQWtDQUk7Z0JBdUJBTTtnQkFJQUM7Z0JBUUFFO2dCQUlBQztnQkFJQUM7Z0JBSUFDO2dCQWhCQUo7Z0JBb0JBSztnQkFJQUM7Z0JBSUFDO2dCQW9RQTRFO2dCQWZBekI7Z0JBOEdBMEI7Z0JBak1BN0I7Z0JBK21DQTBQO2dCQTEwQkE1TTtnQkFxQkFZO2dCQS9HQXRCO2dCQWtiQWdHO2dCQWhRQWhFO2dCQXFVQWdGO2dCQXhNQXpDO2dCQWdCQUU7Z0JBOEJBSztnQkE1NUJBNU47Z0JBbXBDQTJTO2dCQXlFQVc7Z0JBckJBRjtnQkFpREFJO2dCQXNCQUM7Z0JBVUFDO2dCQTRCQU07Z0JBTUFDO2dCQTlCQU47Z0JBSUFDO2dCQUlBQztvQkFxREVLLFFBK0VBUSxhQXdCU1M7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuISBDb3JlXG5pbmNsdWRlIEluY3JfbWFwX2ludGZcblxuKCoqIFRoaXMgdHlwZSBsZXRzIHVzIGNhcHR1cmUgdGhlIGtpbmQgb2YgbWFwIGZ1bmN0aW9uIGJlaW5nIHBlcmZvcm1lZCwgc28gd2UgY2FuIHdpdGhcbiAgICBvbmUgaW1wbGVtZW50YXRpb24gcGVyZm9ybSBtYXAgYW5kIGZpbHRlci1tYXAgb3BlcmF0aW9ucy5cblxuICAgIEhlcmUsIFsnaW5wdXRfZGF0YV0gaXMgdGhlIHR5cGUgb2YgZGF0YSBpbiB0aGUgaW5wdXQgbWFwLCBbJ291dHB1dF9kYXRhXSBpcyB0aGUgdHlwZVxuICAgIG9mIGRhdGEgaW4gdGhlIG91dHB1dCBtYXAsIGFuZCBbJ2Zfb3V0cHV0XSBpcyB0aGUgcmV0dXJuIHR5cGUgb2YgdGhlIFt+Zl0gZnVuY3Rpb25cbiAgICBwYXNzZWQgdG8gdGhlIG1hcHBpbmcgZnVuY3Rpb24uICopXG5tb2R1bGUgTWFwX3R5cGUgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2lucHV0X2RhdGEsICdvdXRwdXRfZGF0YSwgJ2Zfb3V0cHV0KSB0ID1cbiAgICB8IE1hcCA6ICgnaW5wdXRfZGF0YSwgJ291dHB1dF9kYXRhLCAnb3V0cHV0X2RhdGEpIHRcbiAgICB8IEZpbHRlcl9tYXAgOiAoJ2lucHV0X2RhdGEsICdvdXRwdXRfZGF0YSwgJ291dHB1dF9kYXRhIG9wdGlvbikgdFxuXG4gICgqIFRoZSBleHRyYSB0eXBlIHZhcmlhYmxlICdhIGlzIHRvIGFsbG93IGluIGZ1dHVyZTpcbiAgICAgfCBGaWx0ZXIgOiAoJ291dHB1dF9kYXRhLCAnb3V0cHV0X2RhdGEsIGJvb2wpIHQgKilcbmVuZFxuXG5tb2R1bGUgR2VuZXJpYyA9IHN0cnVjdFxuICBsZXQgd2l0aF9vbGQgaSB+ZiA9XG4gICAgbGV0IG9wZW4gSW5jcmVtZW50YWwuTGV0X3N5bnRheCBpblxuICAgIGxldCBvbGQgPSByZWYgTm9uZSBpblxuICAgIGxldCVtYXAgYSA9IGkgaW5cbiAgICBsZXQgYiA9IGYgfm9sZDohb2xkIGEgaW5cbiAgICBvbGQgOj0gU29tZSAoYSwgYik7XG4gICAgYlxuICA7O1xuXG4gIGxldCB1bm9yZGVyZWRfZm9sZFxuICAgICAgICA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKVxuICAgICAgICA/dXBkYXRlXG4gICAgICAgID9zcGVjaWFsaXplZF9pbml0aWFsXG4gICAgICAgID8ocmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eSA9IGZhbHNlKVxuICAgICAgICBtYXBcbiAgICAgICAgfmluaXRcbiAgICAgICAgfmFkZFxuICAgICAgICB+cmVtb3ZlXG4gICAgPVxuICAgIGxldCB1cGRhdGUgPVxuICAgICAgbGV0IGRlZmF1bHQgfmtleSB+b2xkX2RhdGEgfm5ld19kYXRhIGFjYyA9XG4gICAgICAgIGFkZCB+a2V5IH5kYXRhOm5ld19kYXRhIChyZW1vdmUgfmtleSB+ZGF0YTpvbGRfZGF0YSBhY2MpXG4gICAgICBpblxuICAgICAgT3B0aW9uLnZhbHVlIHVwZGF0ZSB+ZGVmYXVsdFxuICAgIGluXG4gICAgd2l0aF9vbGQgbWFwIH5mOihmdW4gfm9sZCBuZXdfaW4gLT5cbiAgICAgIG1hdGNoIG9sZCB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgKG1hdGNoIHNwZWNpYWxpemVkX2luaXRpYWwgd2l0aFxuICAgICAgICAgfCBOb25lIC0+IE1hcC5mb2xkIH5pbml0IH5mOmFkZCBuZXdfaW5cbiAgICAgICAgIHwgU29tZSBpbml0aWFsIC0+IGluaXRpYWwgfmluaXQgbmV3X2luKVxuICAgICAgfCBTb21lIChvbGRfaW4sIG9sZF9vdXQpIC0+XG4gICAgICAgIGlmIHJldmVydF90b19pbml0X3doZW5fZW1wdHkgJiYgTWFwLmxlbmd0aCBuZXdfaW4gPSAwXG4gICAgICAgIHRoZW4gaW5pdFxuICAgICAgICBlbHNlXG4gICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICAgIH5pbml0Om9sZF9vdXRcbiAgICAgICAgICAgIG9sZF9pblxuICAgICAgICAgICAgbmV3X2luXG4gICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgfmY6KGZ1biBhY2MgKGtleSwgY2hhbmdlKSAtPlxuICAgICAgICAgICAgICBtYXRjaCBjaGFuZ2Ugd2l0aFxuICAgICAgICAgICAgICB8IGBMZWZ0IG9sZCAtPiByZW1vdmUgfmtleSB+ZGF0YTpvbGQgYWNjXG4gICAgICAgICAgICAgIHwgYFJpZ2h0IG5ld18gLT4gYWRkIH5rZXkgfmRhdGE6bmV3XyBhY2NcbiAgICAgICAgICAgICAgfCBgVW5lcXVhbCAob2xkLCBuZXdfKSAtPiB1cGRhdGUgfmtleSB+b2xkX2RhdGE6b2xkIH5uZXdfZGF0YTpuZXdfIGFjYykpXG4gIDs7XG5cbiAgbGV0IHVub3JkZXJlZF9mb2xkX25lc3RlZF9tYXBzXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgID9yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5XG4gICAgICAgID91cGRhdGVcbiAgICAgICAgaW5jcl9tYXBcbiAgICAgICAgfmluaXRcbiAgICAgICAgfmFkZFxuICAgICAgICB+cmVtb3ZlXG4gICAgPVxuICAgIGxldCB1cGRhdGUgPVxuICAgICAgbWF0Y2ggdXBkYXRlIHdpdGhcbiAgICAgIHwgU29tZSB1cGRhdGUgLT4gdXBkYXRlXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgZnVuIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+b2xkX2RhdGEgfm5ld19kYXRhIGFjYyAtPlxuICAgICAgICAgIGFkZFxuICAgICAgICAgICAgfm91dGVyX2tleVxuICAgICAgICAgICAgfmlubmVyX2tleVxuICAgICAgICAgICAgfmRhdGE6bmV3X2RhdGFcbiAgICAgICAgICAgIChyZW1vdmUgfm91dGVyX2tleSB+aW5uZXJfa2V5IH5kYXRhOm9sZF9kYXRhIGFjYylcbiAgICBpblxuICAgIHVub3JkZXJlZF9mb2xkXG4gICAgICBpbmNyX21hcFxuICAgICAgP3JldmVydF90b19pbml0X3doZW5fZW1wdHlcbiAgICAgIH5pbml0XG4gICAgICB+dXBkYXRlOihmdW4gfmtleTpvdXRlcl9rZXkgfm9sZF9kYXRhOm9sZF9pbm5lcl9tYXAgfm5ld19kYXRhOm5ld19pbm5lcl9tYXAgYWNjIC0+XG4gICAgICAgIChNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZiBvbGRfaW5uZXJfbWFwIG5ld19pbm5lcl9tYXAgfmRhdGFfZXF1YWwpXG4gICAgICAgICAgfmluaXQ6YWNjXG4gICAgICAgICAgfmY6KGZ1biBhY2MgKGlubmVyX2tleSwgZGlmZikgLT5cbiAgICAgICAgICAgIG1hdGNoIGRpZmYgd2l0aFxuICAgICAgICAgICAgfCBgTGVmdCBkYXRhX3JlbW92ZWQgLT4gcmVtb3ZlIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+ZGF0YTpkYXRhX3JlbW92ZWQgYWNjXG4gICAgICAgICAgICB8IGBSaWdodCBkYXRhX2FkZGVkIC0+IGFkZCB+b3V0ZXJfa2V5IH5pbm5lcl9rZXkgfmRhdGE6ZGF0YV9hZGRlZCBhY2NcbiAgICAgICAgICAgIHwgYFVuZXF1YWwgKG9sZF9kYXRhLCBuZXdfZGF0YSkgLT5cbiAgICAgICAgICAgICAgdXBkYXRlIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+b2xkX2RhdGEgfm5ld19kYXRhIGFjYykpXG4gICAgICB+YWRkOihmdW4gfmtleTpvdXRlcl9rZXkgfmRhdGE6aW5uZXJfbWFwIGFjYyAtPlxuICAgICAgICBNYXAuZm9sZCBpbm5lcl9tYXAgfmluaXQ6YWNjIH5mOihmdW4gfmtleTppbm5lcl9rZXkgfmRhdGEgYWNjIC0+XG4gICAgICAgICAgYWRkIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+ZGF0YSBhY2MpKVxuICAgICAgfnJlbW92ZTooZnVuIH5rZXk6b3V0ZXJfa2V5IH5kYXRhOmlubmVyX21hcCBhY2MgLT5cbiAgICAgICAgTWFwLmZvbGQgaW5uZXJfbWFwIH5pbml0OmFjYyB+ZjooZnVuIH5rZXk6aW5uZXJfa2V5IH5kYXRhIGFjYyAtPlxuICAgICAgICAgIHJlbW92ZSB+b3V0ZXJfa2V5IH5pbm5lcl9rZXkgfmRhdGEgYWNjKSlcbiAgOztcblxuICBsZXQgd2l0aF9jb21wYXJhdG9yJyBnZXRfY29tcGFyYXRvciB4IGYgPVxuICAgIEluY3JlbWVudGFsLmJpbmQgKEluY3JlbWVudGFsLmZyZWV6ZSAoSW5jcmVtZW50YWwubWFwIHggfmY6Z2V0X2NvbXBhcmF0b3IpKSB+ZlxuICA7O1xuXG4gICgqKiBDYXB0dXJlcyB0aGUgY29tcGFyYXRvciAod2hpY2ggY2FuJ3QgY2hhbmdlIGFueXdheSwgc2luY2UgdGhlIHR5cGUgZGV0ZXJtaW5lcyB0aGVcbiAgICAgIGNvbXBhcmF0b3IpIGJ5IGZyZWV6aW5nIHRoZSBjb3JyZXNwb25kaW5nIG1hcC4gIE5vdGUgdGhhdCBieSBmaXJzdCB1c2luZyBJbmNyZW1lbnRhbC5tYXAgdG9cbiAgICAgIGdldCB0aGUgY29tcGFyYXRvciBvdXQgb2YgdGhlIG1hcCwgd2UgYWxsb3cgdGhlIGluaXRpYWwgbWFwIGl0c2VsZiB0byBiZSBnYXJiYWdlXG4gICAgICBjb2xsZWN0ZWQgKilcbiAgbGV0IHdpdGhfY29tcGFyYXRvciBtYXAgZiA9IHdpdGhfY29tcGFyYXRvcicgTWFwLmNvbXBhcmF0b3IgbWFwIGZcblxuICBsZXQgb2Zfc2V0IHNldCA9XG4gICAgd2l0aF9jb21wYXJhdG9yJyBTZXQuY29tcGFyYXRvciBzZXQgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICBsZXQgb2xkX2lucHV0ID0gcmVmIChTZXQuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcikgaW5cbiAgICAgIGxldCBvbGRfb3V0cHV0ID0gcmVmIChNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcikgaW5cbiAgICAgIEluY3JlbWVudGFsLm1hcCBzZXQgfmY6KGZ1biBuZXdfaW5wdXQgLT5cbiAgICAgICAgbGV0IG5ld19vdXRwdXQgPVxuICAgICAgICAgIFNlcXVlbmNlLmZvbGRcbiAgICAgICAgICAgIChTZXQuc3ltbWV0cmljX2RpZmYgIW9sZF9pbnB1dCBuZXdfaW5wdXQpXG4gICAgICAgICAgICB+aW5pdDohb2xkX291dHB1dFxuICAgICAgICAgICAgfmY6KGZ1biBvdXRwdXQgLT4gZnVuY3Rpb25cbiAgICAgICAgICAgICAgfCBGaXJzdCBrIC0+IE1hcC5yZW1vdmUgb3V0cHV0IGtcbiAgICAgICAgICAgICAgfCBTZWNvbmQgayAtPiBNYXAuYWRkX2V4biBvdXRwdXQgfmtleTprIH5kYXRhOigpKVxuICAgICAgICBpblxuICAgICAgICBvbGRfaW5wdXQgOj0gbmV3X2lucHV0O1xuICAgICAgICBvbGRfb3V0cHV0IDo9IG5ld19vdXRwdXQ7XG4gICAgICAgIG5ld19vdXRwdXQpKVxuICA7O1xuXG4gIGxldCBnZW5lcmljX21hcGlcbiAgICAgICAgKHR5cGUgaW5wdXRfZGF0YSBvdXRwdXRfZGF0YSBmX291dHB1dCBzdGF0ZV93aXRuZXNzKVxuICAgICAgICAod2l0bmVzcyA6IChpbnB1dF9kYXRhLCBvdXRwdXRfZGF0YSwgZl9vdXRwdXQpIE1hcF90eXBlLnQpXG4gICAgICAgID8oZGF0YV9lcXVhbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgIChtYXAgOiAoKCdrZXksIGlucHV0X2RhdGEsICdjbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICB+KGYgOiBrZXk6J2tleSAtPiBkYXRhOmlucHV0X2RhdGEgLT4gZl9vdXRwdXQpXG4gICAgPVxuICAgIHdpdGhfb2xkIG1hcCB+ZjooZnVuIH5vbGQgaW5wdXQgLT5cbiAgICAgIG1hdGNoIG9sZCwgTWFwLmxlbmd0aCBpbnB1dCB3aXRoXG4gICAgICB8IF8sIDAgfCBOb25lLCBfIC0+XG4gICAgICAgIChtYXRjaCB3aXRuZXNzIHdpdGhcbiAgICAgICAgIHwgTWFwX3R5cGUuTWFwIC0+IChNYXAubWFwaSBpbnB1dCB+ZiA6ICgna2V5LCBvdXRwdXRfZGF0YSwgJ2NtcCkgTWFwLnQpXG4gICAgICAgICB8IE1hcF90eXBlLkZpbHRlcl9tYXAgLT4gTWFwLmZpbHRlcl9tYXBpIGlucHV0IH5mKVxuICAgICAgfCBTb21lIChvbGRfaW5wdXQsIG9sZF9vdXRwdXQpLCBfIC0+XG4gICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgb2xkX2lucHV0XG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgIH5pbml0Om9sZF9vdXRwdXRcbiAgICAgICAgICB+ZjooZnVuIG91dHB1dCAoa2V5LCBjaGFuZ2UpIC0+XG4gICAgICAgICAgICBtYXRjaCBjaGFuZ2Ugd2l0aFxuICAgICAgICAgICAgfCBgTGVmdCBfIC0+IE1hcC5yZW1vdmUgb3V0cHV0IGtleVxuICAgICAgICAgICAgfCBgUmlnaHQgbmV3X2RhdGEgfCBgVW5lcXVhbCAoXywgbmV3X2RhdGEpIC0+XG4gICAgICAgICAgICAgIGxldCByZXMgPSBmIH5rZXkgfmRhdGE6bmV3X2RhdGEgaW5cbiAgICAgICAgICAgICAgKG1hdGNoIHdpdG5lc3Mgd2l0aFxuICAgICAgICAgICAgICAgfCBNYXBfdHlwZS5NYXAgLT4gTWFwLnNldCBvdXRwdXQgfmtleSB+ZGF0YTpyZXNcbiAgICAgICAgICAgICAgIHwgTWFwX3R5cGUuRmlsdGVyX21hcCAtPlxuICAgICAgICAgICAgICAgICAobWF0Y2ggcmVzIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiBNYXAucmVtb3ZlIG91dHB1dCBrZXlcbiAgICAgICAgICAgICAgICAgIHwgU29tZSBvdXRwdXRfZGF0YSAtPiBNYXAuc2V0IG91dHB1dCB+a2V5IH5kYXRhOm91dHB1dF9kYXRhKSkpKVxuICA7O1xuXG4gIGxldCBtYXBpID9kYXRhX2VxdWFsIG1hcCB+ZiA9IGdlbmVyaWNfbWFwaSBNYXAgP2RhdGFfZXF1YWwgbWFwIH5mXG4gIGxldCBmaWx0ZXJfbWFwaSA/ZGF0YV9lcXVhbCBtYXAgfmYgPSBnZW5lcmljX21hcGkgRmlsdGVyX21hcCA/ZGF0YV9lcXVhbCBtYXAgfmZcbiAgbGV0IG1hcCA/ZGF0YV9lcXVhbCBtYXAgfmYgPSBtYXBpID9kYXRhX2VxdWFsIG1hcCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5cbiAgbGV0IGZpbHRlcl9tYXAgP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICBmaWx0ZXJfbWFwaSA/ZGF0YV9lcXVhbCBtYXAgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuICA7O1xuXG4gIGxldCB3aXRoX29sZDIgaTEgaTIgfmYgPVxuICAgIGxldCBvbGQgPSByZWYgTm9uZSBpblxuICAgIEluY3JlbWVudGFsLm1hcDIgaTEgaTIgfmY6KGZ1biBhMSBhMiAtPlxuICAgICAgbGV0IGIgPSBmIH5vbGQ6IW9sZCBhMSBhMiBpblxuICAgICAgb2xkIDo9IFNvbWUgKGExLCBhMiwgYik7XG4gICAgICBiKVxuICA7O1xuXG4gIGxldCBtYXBpX2NvdW50XG4gICAgICAgICh0eXBlIGEgY21wKVxuICAgICAgICA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKVxuICAgICAgICBpbnB1dFxuICAgICAgICB+KGNvbXBhcmF0b3IgOlxuICAgICAgICAgICAgKG1vZHVsZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgPSBhIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGNtcCkpXG4gICAgICAgIH5mXG4gICAgPVxuICAgIGxldCBtb2R1bGUgTSA9ICh2YWwgY29tcGFyYXRvcikgaW5cbiAgICBsZXQgYWRkIG5ld19rZXkgYWNjID1cbiAgICAgIE1hcC51cGRhdGUgYWNjIG5ld19rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgIHwgTm9uZSAtPiAxXG4gICAgICAgIHwgU29tZSBuIC0+IG4gKyAxKVxuICAgIGluXG4gICAgbGV0IHJlbW92ZSBuZXdfa2V5IGFjYyA9XG4gICAgICBNYXAuY2hhbmdlIGFjYyBuZXdfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICB8IFNvbWUgMSAtPiBOb25lXG4gICAgICAgIHwgU29tZSBuIC0+IFNvbWUgKG4gLSAxKSlcbiAgICBpblxuICAgIHVub3JkZXJlZF9mb2xkXG4gICAgICB+ZGF0YV9lcXVhbFxuICAgICAgaW5wdXRcbiAgICAgIH5pbml0OihNYXAuZW1wdHkgKG1vZHVsZSBNKSlcbiAgICAgIH5hZGQ6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBhZGQgKGYgfmtleSB+ZGF0YSkgYWNjKVxuICAgICAgfnJlbW92ZTooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IHJlbW92ZSAoZiB+a2V5IH5kYXRhKSBhY2MpXG4gICAgICB+dXBkYXRlOihmdW4gfmtleSB+b2xkX2RhdGEgfm5ld19kYXRhIGFjYyAtPlxuICAgICAgICBsZXQgcHJldl9rZXkgPSBmIH5rZXkgfmRhdGE6b2xkX2RhdGEgaW5cbiAgICAgICAgbGV0IG5ld19rZXkgPSBmIH5rZXkgfmRhdGE6bmV3X2RhdGEgaW5cbiAgICAgICAgaWYgTS5jb21wYXJhdG9yLmNvbXBhcmUgcHJldl9rZXkgbmV3X2tleSA9IDBcbiAgICAgICAgdGhlbiBhY2NcbiAgICAgICAgZWxzZSBhY2MgfD4gcmVtb3ZlIHByZXZfa2V5IHw+IGFkZCBuZXdfa2V5KVxuICA7O1xuXG4gIGxldCBtYXBfY291bnQgP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYgPVxuICAgIG1hcGlfY291bnQgP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuICA7O1xuXG4gIGxldCBtaW5faGVscGVyIG1hcCA9XG4gICAgbWF0Y2ggTWFwLm1pbl9lbHQgbWFwIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSAobWluLCBfKSAtPiBTb21lIG1pblxuICA7O1xuXG4gIGxldCBtYXhfaGVscGVyIG1hcCA9XG4gICAgbWF0Y2ggTWFwLm1heF9lbHQgbWFwIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSAobWF4LCBfKSAtPiBTb21lIG1heFxuICA7O1xuXG4gIGxldCBib3VuZHNfaGVscGVyIG1hcCA9XG4gICAgbWF0Y2ggTWFwLm1pbl9lbHQgbWFwLCBNYXAubWF4X2VsdCBtYXAgd2l0aFxuICAgIHwgTm9uZSwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIChtaW4sIF8pLCBTb21lIChtYXgsIF8pIC0+IFNvbWUgKG1pbiwgbWF4KVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgOztcblxuICBsZXQgbWFwaV9taW4gP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYgPVxuICAgIEluY3JlbWVudGFsLm1hcCB+ZjptaW5faGVscGVyIChtYXBpX2NvdW50ID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mKVxuICA7O1xuXG4gIGxldCBtYXBpX21heCA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZiA9XG4gICAgSW5jcmVtZW50YWwubWFwIH5mOm1heF9oZWxwZXIgKG1hcGlfY291bnQgP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmYpXG4gIDs7XG5cbiAgbGV0IG1hcGlfYm91bmRzID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mID1cbiAgICBJbmNyZW1lbnRhbC5tYXAgfmY6Ym91bmRzX2hlbHBlciAobWFwaV9jb3VudCA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZilcbiAgOztcblxuICBsZXQgbWFwaV9tbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZiA9XG4gICAgbWFwaV9taW4gP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuICA7O1xuXG4gIGxldCBtYXBfbWF4ID9kYXRhX2VxdWFsIGlucHV0IH5jb21wYXJhdG9yIH5mID1cbiAgICBtYXBpX21heCA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IG1pbl92YWx1ZSA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciA9XG4gICAgbWFwaV9tbiA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZjpGbi5pZFxuICA7O1xuXG4gIGxldCBtYXhfdmFsdWUgP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgPVxuICAgIG1hcF9tYXggP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmY6Rm4uaWRcbiAgOztcblxuICBsZXQgbWFwX2JvdW5kcyA/ZGF0YV9lcXVhbCBpbnB1dCB+Y29tcGFyYXRvciB+ZiA9XG4gICAgbWFwaV9ib3VuZHMgP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuICA7O1xuXG4gIGxldCB2YWx1ZV9ib3VuZHMgP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgPVxuICAgIG1hcF9ib3VuZHMgP2RhdGFfZXF1YWwgaW5wdXQgfmNvbXBhcmF0b3IgfmY6Rm4uaWRcbiAgOztcblxuICBsZXQgbWVyZ2VcbiAgICAgICAgPyhkYXRhX2VxdWFsX2xlZnQgPSBwaHlzX2VxdWFsKVxuICAgICAgICA/KGRhdGFfZXF1YWxfcmlnaHQgPSBwaHlzX2VxdWFsKVxuICAgICAgICBsZWZ0X21hcFxuICAgICAgICByaWdodF9tYXBcbiAgICAgICAgfmZcbiAgICA9XG4gICAgd2l0aF9vbGQyIGxlZnRfbWFwIHJpZ2h0X21hcCB+ZjooZnVuIH5vbGQgbmV3X2xlZnRfbWFwIG5ld19yaWdodF9tYXAgLT5cbiAgICAgIGxldCBjb21wYXJhdG9yID0gTWFwLmNvbXBhcmF0b3IgbmV3X2xlZnRfbWFwIGluXG4gICAgICBsZXQgb2xkX2xlZnRfbWFwLCBvbGRfcmlnaHRfbWFwLCBvbGRfb3V0cHV0ID1cbiAgICAgICAgbWF0Y2ggb2xkIHdpdGhcbiAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgbGV0IGVtcHR5ID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IgaW5cbiAgICAgICAgICBlbXB0eSwgZW1wdHksIGVtcHR5XG4gICAgICAgIHwgU29tZSB4IC0+IHhcbiAgICAgIGluXG4gICAgICBsZXQgbGVmdF9kaWZmID1cbiAgICAgICAgTWFwLnN5bW1ldHJpY19kaWZmIG9sZF9sZWZ0X21hcCBuZXdfbGVmdF9tYXAgfmRhdGFfZXF1YWw6ZGF0YV9lcXVhbF9sZWZ0XG4gICAgICBpblxuICAgICAgbGV0IHJpZ2h0X2RpZmYgPVxuICAgICAgICBNYXAuc3ltbWV0cmljX2RpZmYgb2xkX3JpZ2h0X21hcCBuZXdfcmlnaHRfbWFwIH5kYXRhX2VxdWFsOmRhdGFfZXF1YWxfcmlnaHRcbiAgICAgIGluXG4gICAgICAoKiBXZSBtZXJnZSB0aGUgdHdvIHNpZGVzIG9mIHRoZSBkaWZmcyB0b2dldGhlciBzbyB3ZSBjYW4gbWFrZSBzdXJlIHRvIGhhbmRsZSBlYWNoXG4gICAgICAgICBrZXkgZXhhY3RseSBvbmNlLiBUaGlzIHJlbGllcyBvbiBzeW1tZXRyaWMgZGlmZiBnaXZpbmcgc29ydGVkIG91dHB1dC4gKilcbiAgICAgIFNlcXVlbmNlLm1lcmdlX3dpdGhfZHVwbGljYXRlc1xuICAgICAgICBsZWZ0X2RpZmZcbiAgICAgICAgcmlnaHRfZGlmZlxuICAgICAgICB+Y29tcGFyZTooZnVuIChsZWZ0X2tleSwgXykgKHJpZ2h0X2tleSwgXykgLT5cbiAgICAgICAgICBjb21wYXJhdG9yLmNvbXBhcmUgbGVmdF9rZXkgcmlnaHRfa2V5KVxuICAgICAgfD4gU2VxdWVuY2UuZm9sZCB+aW5pdDpvbGRfb3V0cHV0IH5mOihmdW4gb3V0cHV0IGRpZmZfZWxlbWVudCAtPlxuICAgICAgICBsZXQga2V5ID1cbiAgICAgICAgICBtYXRjaCBkaWZmX2VsZW1lbnQgd2l0aFxuICAgICAgICAgIHwgTGVmdCAoa2V5LCBfKSB8IFJpZ2h0IChrZXksIF8pIC0+IGtleVxuICAgICAgICAgIHwgQm90aCAoKGxlZnRfa2V5LCBfKSwgKHJpZ2h0X2tleSwgXykpIC0+XG4gICAgICAgICAgICBhc3NlcnQgKGNvbXBhcmF0b3IuY29tcGFyZSBsZWZ0X2tleSByaWdodF9rZXkgPSAwKTtcbiAgICAgICAgICAgIGxlZnRfa2V5XG4gICAgICAgIGluXG4gICAgICAgICgqIFRoZXNlIHZhbHVlcyByZXByZXNlbnQgd2hldGhlciB0aGVyZSBpcyBkYXRhIGZvciB0aGUgZ2l2ZW4ga2V5IGluIHRoZSBuZXdcbiAgICAgICAgICAgaW5wdXQgaW4gdGhlIGxlZnQgYW5kIHJpZ2h0IG1hcC4gKilcbiAgICAgICAgbGV0IGxlZnRfZGF0YV9vcHQsIHJpZ2h0X2RhdGFfb3B0ID1cbiAgICAgICAgICBsZXQgbmV3X2RhdGEgPSBmdW5jdGlvblxuICAgICAgICAgICAgfCBgTGVmdCBfIC0+IE5vbmVcbiAgICAgICAgICAgIHwgYFJpZ2h0IHggfCBgVW5lcXVhbCAoXywgeCkgLT4gU29tZSB4XG4gICAgICAgICAgaW5cbiAgICAgICAgICBtYXRjaCBkaWZmX2VsZW1lbnQgd2l0aFxuICAgICAgICAgIHwgQm90aCAoKF8sIGxlZnRfZGlmZiksIChfLCByaWdodF9kaWZmKSkgLT5cbiAgICAgICAgICAgIG5ld19kYXRhIGxlZnRfZGlmZiwgbmV3X2RhdGEgcmlnaHRfZGlmZlxuICAgICAgICAgIHwgTGVmdCAoXywgbGVmdF9kaWZmKSAtPiBuZXdfZGF0YSBsZWZ0X2RpZmYsIE1hcC5maW5kIG5ld19yaWdodF9tYXAga2V5XG4gICAgICAgICAgfCBSaWdodCAoXywgcmlnaHRfZGlmZikgLT4gTWFwLmZpbmQgbmV3X2xlZnRfbWFwIGtleSwgbmV3X2RhdGEgcmlnaHRfZGlmZlxuICAgICAgICBpblxuICAgICAgICBsZXQgb3V0cHV0X2RhdGFfb3B0ID1cbiAgICAgICAgICBtYXRjaCBsZWZ0X2RhdGFfb3B0LCByaWdodF9kYXRhX29wdCB3aXRoXG4gICAgICAgICAgfCBOb25lLCBOb25lIC0+IE5vbmVcbiAgICAgICAgICB8IFNvbWUgeCwgTm9uZSAtPiBmIH5rZXkgKGBMZWZ0IHgpXG4gICAgICAgICAgfCBOb25lLCBTb21lIHkgLT4gZiB+a2V5IChgUmlnaHQgeSlcbiAgICAgICAgICB8IFNvbWUgeCwgU29tZSB5IC0+IGYgfmtleSAoYEJvdGggKHgsIHkpKVxuICAgICAgICBpblxuICAgICAgICBtYXRjaCBvdXRwdXRfZGF0YV9vcHQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gTWFwLnJlbW92ZSBvdXRwdXQga2V5XG4gICAgICAgIHwgU29tZSBkYXRhIC0+IE1hcC5zZXQgb3V0cHV0IH5rZXkgfmRhdGEpKVxuICA7O1xuXG4gIGxldCBnZW5lcmljX21hcGlfd2l0aF9jb21wYXJhdG9yJ1xuICAgICAgICAodHlwZSBpbnB1dF9kYXRhIG91dHB1dF9kYXRhIGZfb3V0cHV0IHN0YXRlX3dpdG5lc3MpXG4gICAgICAgICh3aXRuZXNzIDogKGlucHV0X2RhdGEsIG91dHB1dF9kYXRhLCBmX291dHB1dCkgTWFwX3R5cGUudClcbiAgICAgICAgP2N1dG9mZlxuICAgICAgICA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKVxuICAgICAgICAobGhzIDogKCgna2V5LCBpbnB1dF9kYXRhLCAnY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICAgICAgfihjb21wYXJhdG9yIDogKCdrZXksICdjbXApIENvbXBhcmF0b3IudClcbiAgICAgICAgfihmIDpcbiAgICAgICAgICAgIGtleTona2V5XG4gICAgICAgICAgLT4gZGF0YTooaW5wdXRfZGF0YSwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgICAgICAgIC0+IChmX291dHB1dCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICA6ICgoJ2tleSwgb3V0cHV0X2RhdGEsICdjbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgPVxuICAgIGxldCBtb2R1bGUgRSA9IEluY3JlbWVudGFsLkV4cGVydCBpblxuICAgIGxldCBpbmNyZW1lbnRhbF9zdGF0ZSA9IEluY3JlbWVudGFsLnN0YXRlIGxocyBpblxuICAgIGxldCBlbXB0eV9tYXAgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgIGxldCBwcmV2X21hcCA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgcHJldl9ub2RlcyA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgYWNjIDogKCdrZXksIG91dHB1dF9kYXRhLCAnY21wKSBNYXAudCByZWYgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IHJlc3VsdCA9IEUuTm9kZS5jcmVhdGUgaW5jcmVtZW50YWxfc3RhdGUgKGZ1biAoKSAtPiAhYWNjKSBpblxuICAgIGxldCAob25faW5uZXJfY2hhbmdlIDoga2V5OidrZXkgLT4gZl9vdXRwdXQgLT4gdW5pdCkgPVxuICAgICAgbWF0Y2ggd2l0bmVzcyB3aXRoXG4gICAgICB8IE1hcF90eXBlLk1hcCAtPiBmdW4gfmtleSBkYXRhIC0+IGFjYyA6PSBNYXAuc2V0ICFhY2MgfmtleSB+ZGF0YVxuICAgICAgfCBNYXBfdHlwZS5GaWx0ZXJfbWFwIC0+XG4gICAgICAgIGZ1biB+a2V5IG9wdCAtPlxuICAgICAgICAgIGxldCBvbGQgPSAhYWNjIGluXG4gICAgICAgICAgYWNjXG4gICAgICAgICAgOj0gKG1hdGNoIG9wdCB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gTWFwLnJlbW92ZSBvbGQga2V5XG4gICAgICAgICAgICB8IFNvbWUgZGF0YSAtPiBNYXAuc2V0IG9sZCB+a2V5IH5kYXRhKVxuICAgIGluXG4gICAgbGV0IHJlYyBsaHNfY2hhbmdlID1cbiAgICAgIGxhenlcbiAgICAgICAgKEluY3JlbWVudGFsLm1hcCBsaHMgfmY6KGZ1biBtYXAgLT5cbiAgICAgICAgICAgbGV0IG5ld19ub2RlcyA9XG4gICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgICAgICAhcHJldl9tYXBcbiAgICAgICAgICAgICAgIG1hcFxuICAgICAgICAgICAgICAgfmluaXQ6IXByZXZfbm9kZXNcbiAgICAgICAgICAgICAgIH5mOihmdW4gbm9kZXMgKGtleSwgY2hhbmdlZCkgLT5cbiAgICAgICAgICAgICAgICAgbWF0Y2ggY2hhbmdlZCB3aXRoXG4gICAgICAgICAgICAgICAgIHwgYFVuZXF1YWwgXyAtPlxuICAgICAgICAgICAgICAgICAgIGxldCBub2RlLCBfZGVwID0gTWFwLmZpbmRfZXhuIG5vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5tYWtlX3N0YWxlIG5vZGU7XG4gICAgICAgICAgICAgICAgICAgbm9kZXNcbiAgICAgICAgICAgICAgICAgfCBgTGVmdCBfIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IG5vZGUsIGRlcCA9IE1hcC5maW5kX2V4biBub2RlcyBrZXkgaW5cbiAgICAgICAgICAgICAgICAgICBsZXQgbm9kZXMgPSBNYXAucmVtb3ZlIG5vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5yZW1vdmVfZGVwZW5kZW5jeSByZXN1bHQgZGVwO1xuICAgICAgICAgICAgICAgICAgIGFjYyA6PSBNYXAucmVtb3ZlICFhY2Mga2V5O1xuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5pbnZhbGlkYXRlIG5vZGU7XG4gICAgICAgICAgICAgICAgICAgbm9kZXNcbiAgICAgICAgICAgICAgICAgfCBgUmlnaHQgXyAtPlxuICAgICAgICAgICAgICAgICAgIGxldCBub2RlID1cbiAgICAgICAgICAgICAgICAgICAgIEUuTm9kZS5jcmVhdGUgaW5jcmVtZW50YWxfc3RhdGUgKGZ1biAoKSAtPlxuICAgICAgICAgICAgICAgICAgICAgICBNYXAuZmluZF9leG4gIXByZXZfbWFwIGtleSlcbiAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgIE9wdGlvbi5pdGVyIGN1dG9mZiB+ZjooZnVuIGMgLT5cbiAgICAgICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLnNldF9jdXRvZmYgKEUuTm9kZS53YXRjaCBub2RlKSBjKTtcbiAgICAgICAgICAgICAgICAgICBFLk5vZGUuYWRkX2RlcGVuZGVuY3kgbm9kZSAoRS5EZXBlbmRlbmN5LmNyZWF0ZSAoZm9yY2UgbGhzX2NoYW5nZSkpO1xuICAgICAgICAgICAgICAgICAgIGxldCB1c2VyX2Z1bmN0aW9uX2RlcCA9XG4gICAgICAgICAgICAgICAgICAgICBFLkRlcGVuZGVuY3kuY3JlYXRlXG4gICAgICAgICAgICAgICAgICAgICAgIChmIH5rZXkgfmRhdGE6KEUuTm9kZS53YXRjaCBub2RlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgfm9uX2NoYW5nZToob25faW5uZXJfY2hhbmdlIH5rZXkpXG4gICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICBFLk5vZGUuYWRkX2RlcGVuZGVuY3kgcmVzdWx0IHVzZXJfZnVuY3Rpb25fZGVwO1xuICAgICAgICAgICAgICAgICAgIE1hcC5zZXQgbm9kZXMgfmtleSB+ZGF0YToobm9kZSwgdXNlcl9mdW5jdGlvbl9kZXApKVxuICAgICAgICAgICBpblxuICAgICAgICAgICBwcmV2X25vZGVzIDo9IG5ld19ub2RlcztcbiAgICAgICAgICAgcHJldl9tYXAgOj0gbWFwKSlcbiAgICBpblxuICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSByZXN1bHQgKEUuRGVwZW5kZW5jeS5jcmVhdGUgKGZvcmNlIGxoc19jaGFuZ2UpKTtcbiAgICBFLk5vZGUud2F0Y2ggcmVzdWx0XG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXBpJyA/Y3V0b2ZmID9kYXRhX2VxdWFsIG1hcCB+ZiA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgIGdlbmVyaWNfbWFwaV93aXRoX2NvbXBhcmF0b3InXG4gICAgICAgIE1hcF90eXBlLkZpbHRlcl9tYXBcbiAgICAgICAgP2N1dG9mZlxuICAgICAgICA/ZGF0YV9lcXVhbFxuICAgICAgICBtYXBcbiAgICAgICAgfmZcbiAgICAgICAgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG1hcGknID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICB3aXRoX2NvbXBhcmF0b3IgbWFwIChmdW4gY29tcGFyYXRvciAtPlxuICAgICAgZ2VuZXJpY19tYXBpX3dpdGhfY29tcGFyYXRvcicgTWFwX3R5cGUuTWFwID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBtYXAnID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICBtYXBpJyA/Y3V0b2ZmID9kYXRhX2VxdWFsIG1hcCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXAnID9jdXRvZmYgP2RhdGFfZXF1YWwgbWFwIH5mID1cbiAgICBmaWx0ZXJfbWFwaScgP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuICA7O1xuXG4gIGxldCBtZXJnZScgP2N1dG9mZiA/ZGF0YV9lcXVhbF9sZWZ0ID9kYXRhX2VxdWFsX3JpZ2h0IG1hcDEgbWFwMiB+ZiA9XG4gICAgbWVyZ2UgP2RhdGFfZXF1YWxfbGVmdCA/ZGF0YV9lcXVhbF9yaWdodCBtYXAxIG1hcDIgfmY6KGZ1biB+a2V5Ol8gZGlmZiAtPiBTb21lIGRpZmYpXG4gICAgfD4gZmlsdGVyX21hcGknID9jdXRvZmYgfmY6KGZ1biB+a2V5IH5kYXRhOmRpZmYgLT4gZiB+a2V5IGRpZmYpXG4gIDs7XG5cbiAgbGV0IHVuemlwX21hcGlfd2l0aF9jb21wYXJhdG9yXG4gICAgICAgICh0eXBlIHYgdjEgdjIgc3RhdGVfd2l0bmVzcylcbiAgICAgICAgPyhkYXRhX2VxdWFsIDogdiAtPiB2IC0+IGJvb2wgPSBwaHlzX2VxdWFsKVxuICAgICAgICA/KGxlZnRfcmVzdWx0X2VxdWFsIDogdjEgLT4gdjEgLT4gYm9vbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgID8ocmlnaHRfcmVzdWx0X2VxdWFsIDogdjIgLT4gdjIgLT4gYm9vbCA9IHBoeXNfZXF1YWwpXG4gICAgICAgIChpbnB1dCA6ICgoJ2tleSwgdiwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICAgIH4oY29tcGFyYXRvciA6ICgna2V5LCAnY21wKSBDb21wYXJhdG9yLnQpXG4gICAgICAgIH4oZiA6IGtleTona2V5IC0+IGRhdGE6diAtPiB2MSAqIHYyKVxuICAgIDogKCgna2V5LCB2MSwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICAgICogKCgna2V5LCB2MiwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICA9XG4gICAgbGV0IG1vZHVsZSBFID0gSW5jcmVtZW50YWwuRXhwZXJ0IGluXG4gICAgbGV0IGluY3JlbWVudGFsX3N0YXRlID0gSW5jcmVtZW50YWwuc3RhdGUgaW5wdXQgaW5cbiAgICBsZXQgZW1wdHlfbWFwID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IgaW5cbiAgICBsZXQgbGVmdF9hY2MgOiAoJ2tleSwgdjEsICdjbXApIE1hcC50IHJlZiA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgbGVmdF9yZXN1bHQgPSBFLk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT4gIWxlZnRfYWNjKSBpblxuICAgIGxldCByaWdodF9hY2MgOiAoJ2tleSwgdjIsICdjbXApIE1hcC50IHJlZiA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgcmlnaHRfcmVzdWx0ID0gRS5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+ICFyaWdodF9hY2MpIGluXG4gICAgbGV0IHByZXZfbWFwID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCBpbnB1dF9jaGFuZ2UgPVxuICAgICAgSW5jcmVtZW50YWwubWFwIGlucHV0IH5mOihmdW4gbWFwIC0+XG4gICAgICAgIGxldCBsZWZ0LCByaWdodCA9XG4gICAgICAgICAgbWF0Y2ggTWFwLmlzX2VtcHR5ICFwcmV2X21hcCwgTWFwLmlzX2VtcHR5IG1hcCB3aXRoXG4gICAgICAgICAgfCB0cnVlLCB0cnVlIHwgZmFsc2UsIHRydWUgLT4gZW1wdHlfbWFwLCBlbXB0eV9tYXBcbiAgICAgICAgICB8IHRydWUsIGZhbHNlIC0+XG4gICAgICAgICAgICAoKiBNYXBwaW5nIG9uIGEgbWFwIGlzIHdheSBmYXN0ZXIgdGhhbiBzeW1tZXRyaWMgZGlmZmluZyBhbmQgdGhlblxuICAgICAgICAgICAgICAgYnVpbGRpbmcgdGhlIG1hcHMgdXAgcGllY2UgYnkgcGllY2UsIHNvIHdlIGRvIHRoaXMgd2hlbmV2ZXIgd2VcbiAgICAgICAgICAgICAgIHRyYW5zaXRpb24gZnJvbSBcImVtcHR5XCIgdG8gXCJzb21ldGhpbmdcIiwgd2hpY2ggd2lsbCBhbG1vc3QgYWx3YXlzXG4gICAgICAgICAgICAgICBoYXBwZW4gb24gdGhlIGZpcnN0IHN0YWJpbGl6YXRpb24uICopXG4gICAgICAgICAgICBsZXQgbGVmdCA9XG4gICAgICAgICAgICAgIE1hcC5tYXBpIG1hcCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgICAgICAgICAgICBsZXQgbCwgXyA9IGYgfmtleSB+ZGF0YSBpblxuICAgICAgICAgICAgICAgIGwpXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgbGV0IHJpZ2h0ID1cbiAgICAgICAgICAgICAgTWFwLm1hcGkgbWFwIH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICAgICAgICAgIGxldCBfLCByID0gZiB+a2V5IH5kYXRhIGluXG4gICAgICAgICAgICAgICAgcilcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBsZWZ0LCByaWdodFxuICAgICAgICAgIHwgZmFsc2UsIGZhbHNlIC0+XG4gICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgICAhcHJldl9tYXBcbiAgICAgICAgICAgICAgbWFwXG4gICAgICAgICAgICAgIH5pbml0OighbGVmdF9hY2MsICFyaWdodF9hY2MpXG4gICAgICAgICAgICAgIH5mOihmdW4gKGxlZnQsIHJpZ2h0KSAoa2V5LCBjaGFuZ2VkKSAtPlxuICAgICAgICAgICAgICAgIG1hdGNoIGNoYW5nZWQgd2l0aFxuICAgICAgICAgICAgICAgIHwgYFVuZXF1YWwgKHByZXYsIG5ld18pIC0+XG4gICAgICAgICAgICAgICAgICBsZXQgcHJldl9hLCBwcmV2X2IgPSBmIH5rZXkgfmRhdGE6cHJldiBpblxuICAgICAgICAgICAgICAgICAgbGV0IG5ld19hLCBuZXdfYiA9IGYgfmtleSB+ZGF0YTpuZXdfIGluXG4gICAgICAgICAgICAgICAgICBsZXQgbGVmdCA9XG4gICAgICAgICAgICAgICAgICAgIGlmIGxlZnRfcmVzdWx0X2VxdWFsIHByZXZfYSBuZXdfYVxuICAgICAgICAgICAgICAgICAgICB0aGVuIGxlZnRcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBNYXAuc2V0IGxlZnQgfmtleSB+ZGF0YTpuZXdfYVxuICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgIGxldCByaWdodCA9XG4gICAgICAgICAgICAgICAgICAgIGlmIHJpZ2h0X3Jlc3VsdF9lcXVhbCBwcmV2X2IgbmV3X2JcbiAgICAgICAgICAgICAgICAgICAgdGhlbiByaWdodFxuICAgICAgICAgICAgICAgICAgICBlbHNlIE1hcC5zZXQgcmlnaHQgfmtleSB+ZGF0YTpuZXdfYlxuICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgIGxlZnQsIHJpZ2h0XG4gICAgICAgICAgICAgICAgfCBgTGVmdCBfIC0+IE1hcC5yZW1vdmUgbGVmdCBrZXksIE1hcC5yZW1vdmUgcmlnaHQga2V5XG4gICAgICAgICAgICAgICAgfCBgUmlnaHQgZWxlbWVudCAtPlxuICAgICAgICAgICAgICAgICAgbGV0IGEsIGIgPSBmIH5rZXkgfmRhdGE6ZWxlbWVudCBpblxuICAgICAgICAgICAgICAgICAgTWFwLnNldCBsZWZ0IH5rZXkgfmRhdGE6YSwgTWFwLnNldCByaWdodCB+a2V5IH5kYXRhOmIpXG4gICAgICAgIGluXG4gICAgICAgIGlmIG5vdCAocGh5c19lcXVhbCAhbGVmdF9hY2MgbGVmdCkgdGhlbiBFLk5vZGUubWFrZV9zdGFsZSBsZWZ0X3Jlc3VsdDtcbiAgICAgICAgaWYgbm90IChwaHlzX2VxdWFsICFyaWdodF9hY2MgcmlnaHQpIHRoZW4gRS5Ob2RlLm1ha2Vfc3RhbGUgcmlnaHRfcmVzdWx0O1xuICAgICAgICBsZWZ0X2FjYyA6PSBsZWZ0O1xuICAgICAgICByaWdodF9hY2MgOj0gcmlnaHQ7XG4gICAgICAgIHByZXZfbWFwIDo9IG1hcClcbiAgICBpblxuICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSBsZWZ0X3Jlc3VsdCAoRS5EZXBlbmRlbmN5LmNyZWF0ZSBpbnB1dF9jaGFuZ2UpO1xuICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSByaWdodF9yZXN1bHQgKEUuRGVwZW5kZW5jeS5jcmVhdGUgaW5wdXRfY2hhbmdlKTtcbiAgICBFLk5vZGUud2F0Y2ggbGVmdF9yZXN1bHQsIEUuTm9kZS53YXRjaCByaWdodF9yZXN1bHRcbiAgOztcblxuICBsZXQgdW56aXBfbWFwaSA/ZGF0YV9lcXVhbCA/bGVmdF9yZXN1bHRfZXF1YWwgP3JpZ2h0X3Jlc3VsdF9lcXVhbCBpbnB1dCB+ZiA9XG4gICAgbGV0IHBhaXIgPVxuICAgICAgd2l0aF9jb21wYXJhdG9yIGlucHV0IChmdW4gY29tcGFyYXRvciAtPlxuICAgICAgICBpbnB1dFxuICAgICAgICB8PiB1bnppcF9tYXBpX3dpdGhfY29tcGFyYXRvclxuICAgICAgICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgICAgICAgP2xlZnRfcmVzdWx0X2VxdWFsXG4gICAgICAgICAgICAgP3JpZ2h0X3Jlc3VsdF9lcXVhbFxuICAgICAgICAgICAgIH5jb21wYXJhdG9yXG4gICAgICAgICAgICAgfmZcbiAgICAgICAgfD4gVHVwbGUyLnVuY3VycnkgSW5jcmVtZW50YWwuYm90aClcbiAgICBpblxuICAgIEluY3JlbWVudGFsLm1hcCB+Zjpmc3QgcGFpciwgSW5jcmVtZW50YWwubWFwIH5mOnNuZCBwYWlyXG4gIDs7XG5cbiAgbGV0IHVuemlwID9sZWZ0X3Jlc3VsdF9lcXVhbCA/cmlnaHRfcmVzdWx0X2VxdWFsIGlucHV0ID1cbiAgICBsZXQgZGF0YV9lcXVhbCA9XG4gICAgICBPcHRpb24ubWFwMiBsZWZ0X3Jlc3VsdF9lcXVhbCByaWdodF9yZXN1bHRfZXF1YWwgfmY6KGZ1biBsIHIgLT5cbiAgICAgICAgVHVwbGUyLmVxdWFsIH5lcTE6bCB+ZXEyOnIpXG4gICAgaW5cbiAgICB1bnppcF9tYXBpXG4gICAgICA/ZGF0YV9lcXVhbFxuICAgICAgP2xlZnRfcmVzdWx0X2VxdWFsXG4gICAgICA/cmlnaHRfcmVzdWx0X2VxdWFsXG4gICAgICBpbnB1dFxuICAgICAgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZGF0YSlcbiAgOztcblxuICBsZXQgdW56aXBfbWFwaV93aXRoX2NvbXBhcmF0b3InXG4gICAgICAgICh0eXBlIHYgdjEgdjIgc3RhdGVfd2l0bmVzcylcbiAgICAgICAgP2N1dG9mZlxuICAgICAgICA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKVxuICAgICAgICAoaW5wdXQgOiAoKCdrZXksIHYsICdjbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICB+KGNvbXBhcmF0b3IgOiAoJ2tleSwgJ2NtcCkgQ29tcGFyYXRvci50KVxuICAgICAgICB+KGYgOlxuICAgICAgICAgICAga2V5OidrZXlcbiAgICAgICAgICAtPiBkYXRhOih2LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgICAgICAgLT4gKHYxLCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50ICogKHYyLCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgIDogKCgna2V5LCB2MSwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICAgICogKCgna2V5LCB2MiwgJ2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICA9XG4gICAgbGV0IG1vZHVsZSBFID0gSW5jcmVtZW50YWwuRXhwZXJ0IGluXG4gICAgbGV0IGluY3JlbWVudGFsX3N0YXRlID0gSW5jcmVtZW50YWwuc3RhdGUgaW5wdXQgaW5cbiAgICBsZXQgZW1wdHlfbWFwID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IgaW5cbiAgICBsZXQgcHJldl9tYXAgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IHByZXZfbm9kZXMgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IGxlZnRfYWNjIDogKCdrZXksIHYxLCAnY21wKSBNYXAudCByZWYgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IGxlZnRfcmVzdWx0ID0gRS5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+ICFsZWZ0X2FjYykgaW5cbiAgICBsZXQgcmlnaHRfYWNjIDogKCdrZXksIHYyLCAnY21wKSBNYXAudCByZWYgPSByZWYgZW1wdHlfbWFwIGluXG4gICAgbGV0IHJpZ2h0X3Jlc3VsdCA9IEUuTm9kZS5jcmVhdGUgaW5jcmVtZW50YWxfc3RhdGUgKGZ1biAoKSAtPiAhcmlnaHRfYWNjKSBpblxuICAgIGxldCBsZWZ0X29uX2lubmVyX2NoYW5nZSB+a2V5IGRhdGEgPSBsZWZ0X2FjYyA6PSBNYXAuc2V0ICFsZWZ0X2FjYyB+a2V5IH5kYXRhIGluXG4gICAgbGV0IHJpZ2h0X29uX2lubmVyX2NoYW5nZSB+a2V5IGRhdGEgPSByaWdodF9hY2MgOj0gTWFwLnNldCAhcmlnaHRfYWNjIH5rZXkgfmRhdGEgaW5cbiAgICBsZXQgcmVjIGlucHV0X2NoYW5nZSA9XG4gICAgICBsYXp5XG4gICAgICAgIChJbmNyZW1lbnRhbC5tYXAgaW5wdXQgfmY6KGZ1biBtYXAgLT5cbiAgICAgICAgICAgbGV0IG5ld19ub2RlcyA9XG4gICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgICAgICAhcHJldl9tYXBcbiAgICAgICAgICAgICAgIG1hcFxuICAgICAgICAgICAgICAgfmluaXQ6IXByZXZfbm9kZXNcbiAgICAgICAgICAgICAgIH5mOihmdW4gbm9kZXMgKGtleSwgY2hhbmdlZCkgLT5cbiAgICAgICAgICAgICAgICAgbWF0Y2ggY2hhbmdlZCB3aXRoXG4gICAgICAgICAgICAgICAgIHwgYFVuZXF1YWwgXyAtPlxuICAgICAgICAgICAgICAgICAgIGxldCBub2RlLCBfbGVmdF9kZXAsIF9yaWdodF9kZXAgPSBNYXAuZmluZF9leG4gbm9kZXMga2V5IGluXG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLm1ha2Vfc3RhbGUgbm9kZTtcbiAgICAgICAgICAgICAgICAgICBub2Rlc1xuICAgICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT5cbiAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSwgbGVmdF9kZXAsIHJpZ2h0X2RlcCA9IE1hcC5maW5kX2V4biBub2RlcyBrZXkgaW5cbiAgICAgICAgICAgICAgICAgICBsZXQgbm9kZXMgPSBNYXAucmVtb3ZlIG5vZGVzIGtleSBpblxuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5yZW1vdmVfZGVwZW5kZW5jeSBsZWZ0X3Jlc3VsdCBsZWZ0X2RlcDtcbiAgICAgICAgICAgICAgICAgICBFLk5vZGUucmVtb3ZlX2RlcGVuZGVuY3kgcmlnaHRfcmVzdWx0IHJpZ2h0X2RlcDtcbiAgICAgICAgICAgICAgICAgICBsZWZ0X2FjYyA6PSBNYXAucmVtb3ZlICFsZWZ0X2FjYyBrZXk7XG4gICAgICAgICAgICAgICAgICAgcmlnaHRfYWNjIDo9IE1hcC5yZW1vdmUgIXJpZ2h0X2FjYyBrZXk7XG4gICAgICAgICAgICAgICAgICAgRS5Ob2RlLmludmFsaWRhdGUgbm9kZTtcbiAgICAgICAgICAgICAgICAgICBub2Rlc1xuICAgICAgICAgICAgICAgICB8IGBSaWdodCBfIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPVxuICAgICAgICAgICAgICAgICAgICAgRS5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgIE1hcC5maW5kX2V4biAhcHJldl9tYXAga2V5KVxuICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgT3B0aW9uLml0ZXIgY3V0b2ZmIH5mOihmdW4gYyAtPlxuICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuc2V0X2N1dG9mZiAoRS5Ob2RlLndhdGNoIG5vZGUpIGMpO1xuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSBub2RlIChFLkRlcGVuZGVuY3kuY3JlYXRlIChmb3JjZSBpbnB1dF9jaGFuZ2UpKTtcbiAgICAgICAgICAgICAgICAgICBsZXQgbGVmdF9pbmNyLCByaWdodF9pbmNyID0gZiB+a2V5IH5kYXRhOihFLk5vZGUud2F0Y2ggbm9kZSkgaW5cbiAgICAgICAgICAgICAgICAgICBsZXQgbGVmdF91c2VyX2Z1bmN0aW9uX2RlcCA9XG4gICAgICAgICAgICAgICAgICAgICBFLkRlcGVuZGVuY3kuY3JlYXRlXG4gICAgICAgICAgICAgICAgICAgICAgIGxlZnRfaW5jclxuICAgICAgICAgICAgICAgICAgICAgICB+b25fY2hhbmdlOihsZWZ0X29uX2lubmVyX2NoYW5nZSB+a2V5KVxuICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0X3VzZXJfZnVuY3Rpb25fZGVwID1cbiAgICAgICAgICAgICAgICAgICAgIEUuRGVwZW5kZW5jeS5jcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRfaW5jclxuICAgICAgICAgICAgICAgICAgICAgICB+b25fY2hhbmdlOihyaWdodF9vbl9pbm5lcl9jaGFuZ2UgfmtleSlcbiAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSBsZWZ0X3Jlc3VsdCBsZWZ0X3VzZXJfZnVuY3Rpb25fZGVwO1xuICAgICAgICAgICAgICAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSByaWdodF9yZXN1bHQgcmlnaHRfdXNlcl9mdW5jdGlvbl9kZXA7XG4gICAgICAgICAgICAgICAgICAgTWFwLnNldFxuICAgICAgICAgICAgICAgICAgICAgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgIH5rZXlcbiAgICAgICAgICAgICAgICAgICAgIH5kYXRhOihub2RlLCBsZWZ0X3VzZXJfZnVuY3Rpb25fZGVwLCByaWdodF91c2VyX2Z1bmN0aW9uX2RlcCkpXG4gICAgICAgICAgIGluXG4gICAgICAgICAgIHByZXZfbm9kZXMgOj0gbmV3X25vZGVzO1xuICAgICAgICAgICBwcmV2X21hcCA6PSBtYXApKVxuICAgIGluXG4gICAgRS5Ob2RlLmFkZF9kZXBlbmRlbmN5IGxlZnRfcmVzdWx0IChFLkRlcGVuZGVuY3kuY3JlYXRlIChmb3JjZSBpbnB1dF9jaGFuZ2UpKTtcbiAgICBFLk5vZGUuYWRkX2RlcGVuZGVuY3kgcmlnaHRfcmVzdWx0IChFLkRlcGVuZGVuY3kuY3JlYXRlIChmb3JjZSBpbnB1dF9jaGFuZ2UpKTtcbiAgICBFLk5vZGUud2F0Y2ggbGVmdF9yZXN1bHQsIEUuTm9kZS53YXRjaCByaWdodF9yZXN1bHRcbiAgOztcblxuICBsZXQgdW56aXBfbWFwaScgP2N1dG9mZiA/ZGF0YV9lcXVhbCBtYXAgfmYgPVxuICAgIGxldCBwYWlyID1cbiAgICAgIHdpdGhfY29tcGFyYXRvciBtYXAgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICAgIG1hcFxuICAgICAgICB8PiB1bnppcF9tYXBpX3dpdGhfY29tcGFyYXRvcicgP2N1dG9mZiA/ZGF0YV9lcXVhbCB+Y29tcGFyYXRvciB+ZlxuICAgICAgICB8PiBUdXBsZTIudW5jdXJyeSBJbmNyZW1lbnRhbC5ib3RoKVxuICAgIGluXG4gICAgSW5jcmVtZW50YWwubWFwIH5mOmZzdCBwYWlyLCBJbmNyZW1lbnRhbC5tYXAgfmY6c25kIHBhaXJcbiAgOztcblxuICBsZXQga2V5cyBtYXAgPVxuICAgIHdpdGhfY29tcGFyYXRvciBtYXAgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICBsZXQgYWRkIH5rZXkgfmRhdGE6XyBhY2MgPSBTZXQuYWRkIGFjYyBrZXkgaW5cbiAgICAgIGxldCByZW1vdmUgfmtleSB+ZGF0YTpfIGFjYyA9IFNldC5yZW1vdmUgYWNjIGtleSBpblxuICAgICAgbGV0IGRhdGFfZXF1YWwgXyBfID0gdHJ1ZSBpblxuICAgICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgICAgbWFwXG4gICAgICAgIH5pbml0OihTZXQuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcilcbiAgICAgICAgfnJldmVydF90b19pbml0X3doZW5fZW1wdHk6dHJ1ZVxuICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICB+YWRkXG4gICAgICAgIH5yZW1vdmUpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl9tYXBpID9kYXRhX2VxdWFsIG1hcCB+ZiA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgIGxldCBlbXB0eSA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yIGluXG4gICAgICB1bm9yZGVyZWRfZm9sZFxuICAgICAgICA/ZGF0YV9lcXVhbFxuICAgICAgICBtYXBcbiAgICAgICAgfmluaXQ6KGVtcHR5LCBlbXB0eSlcbiAgICAgICAgfnJldmVydF90b19pbml0X3doZW5fZW1wdHk6dHJ1ZVxuICAgICAgICB+dXBkYXRlOihmdW4gfmtleSB+b2xkX2RhdGE6XyB+bmV3X2RhdGE6ZGF0YSAoZmlyc3QsIHNlY29uZCkgLT5cbiAgICAgICAgICBtYXRjaCBmIH5rZXkgfmRhdGEgd2l0aFxuICAgICAgICAgIHwgRmlyc3QgZGF0YSAtPiBNYXAuc2V0IGZpcnN0IH5rZXkgfmRhdGEsIE1hcC5yZW1vdmUgc2Vjb25kIGtleVxuICAgICAgICAgIHwgU2Vjb25kIGRhdGEgLT4gTWFwLnJlbW92ZSBmaXJzdCBrZXksIE1hcC5zZXQgc2Vjb25kIH5rZXkgfmRhdGEpXG4gICAgICAgIH5hZGQ6KGZ1biB+a2V5IH5kYXRhIChmaXJzdCwgc2Vjb25kKSAtPlxuICAgICAgICAgIG1hdGNoIGYgfmtleSB+ZGF0YSB3aXRoXG4gICAgICAgICAgfCBGaXJzdCBkYXRhIC0+IE1hcC5hZGRfZXhuIGZpcnN0IH5rZXkgfmRhdGEsIHNlY29uZFxuICAgICAgICAgIHwgU2Vjb25kIGRhdGEgLT4gZmlyc3QsIE1hcC5hZGRfZXhuIHNlY29uZCB+a2V5IH5kYXRhKVxuICAgICAgICB+cmVtb3ZlOihmdW4gfmtleSB+ZGF0YTpfIChmaXJzdCwgc2Vjb25kKSAtPlxuICAgICAgICAgIE1hcC5yZW1vdmUgZmlyc3Qga2V5LCBNYXAucmVtb3ZlIHNlY29uZCBrZXkpKVxuICA7O1xuXG4gIGxldCBmbGF0dGVuIHN0YXRlIG1hcCA9XG4gICAgbGV0IG1vZHVsZSBFID0gSW5jcmVtZW50YWwuRXhwZXJ0IGluXG4gICAgbGV0IHJlc3VsdCA9IHJlZiAoTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3I6KE1hcC5jb21wYXJhdG9yIG1hcCkpIGluXG4gICAgbGV0IG5vZGUgPSBFLk5vZGUuY3JlYXRlIHN0YXRlIChmdW4gKCkgLT4gIXJlc3VsdCkgaW5cbiAgICBNYXAuaXRlcmkgbWFwIH5mOihmdW4gfmtleSB+ZGF0YTppbmNyIC0+XG4gICAgICBFLk5vZGUuYWRkX2RlcGVuZGVuY3lcbiAgICAgICAgbm9kZVxuICAgICAgICAoRS5EZXBlbmRlbmN5LmNyZWF0ZSBpbmNyIH5vbl9jaGFuZ2U6KGZ1biBhIC0+XG4gICAgICAgICAgIHJlc3VsdCA6PSBNYXAuc2V0ICFyZXN1bHQgfmtleSB+ZGF0YTphKSkpO1xuICAgIEUuTm9kZS53YXRjaCBub2RlXG4gIDs7XG5cbiAgbGV0IGpvaW5fd2l0aF9jb21wYXJhdG9yIG1hcF9pbmNyIH5jb21wYXJhdG9yID1cbiAgICBsZXQgbW9kdWxlIEUgPSBJbmNyZW1lbnRhbC5FeHBlcnQgaW5cbiAgICBsZXQgaW5jcmVtZW50YWxfc3RhdGUgPSBJbmNyZW1lbnRhbC5zdGF0ZSBtYXBfaW5jciBpblxuICAgIGxldCBlbXB0eV9tYXAgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvciBpblxuICAgIGxldCByZXN1bHRfbWFwID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCBvbGRfbWFwX29mX2luY3JzID0gcmVmIGVtcHR5X21hcCBpblxuICAgIGxldCBjdXJyZW50X2RlcGVuZGVuY2llcyA9IHJlZiBlbXB0eV9tYXAgaW5cbiAgICBsZXQgcmVzdWx0ID0gRS5Ob2RlLmNyZWF0ZSBpbmNyZW1lbnRhbF9zdGF0ZSAoZnVuICgpIC0+ICFyZXN1bHRfbWFwKSBpblxuICAgIGxldCBhZGRfc3Vibm9kZSBjdXJyZW50X2RlcGVuZGVuY2llcyB+a2V5IH5kYXRhX25vZGUgPVxuICAgICAgbGV0IG5ld19kZXAgPVxuICAgICAgICBFLkRlcGVuZGVuY3kuY3JlYXRlIGRhdGFfbm9kZSB+b25fY2hhbmdlOihmdW4gZGF0YSAtPlxuICAgICAgICAgIHJlc3VsdF9tYXAgOj0gTWFwLnNldCAhcmVzdWx0X21hcCB+a2V5IH5kYXRhKVxuICAgICAgaW5cbiAgICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSByZXN1bHQgbmV3X2RlcDtcbiAgICAgIE1hcC5zZXQgY3VycmVudF9kZXBlbmRlbmNpZXMgfmtleSB+ZGF0YTpuZXdfZGVwXG4gICAgaW5cbiAgICBsZXQgcmVtb3ZlX3N1Ym5vZGUgY3VycmVudF9kZXBlbmRlbmNpZXMgfmtleSA9XG4gICAgICBsZXQgZGVwID0gTWFwLmZpbmRfZXhuIGN1cnJlbnRfZGVwZW5kZW5jaWVzIGtleSBpblxuICAgICAgRS5Ob2RlLnJlbW92ZV9kZXBlbmRlbmN5IHJlc3VsdCBkZXA7XG4gICAgICByZXN1bHRfbWFwIDo9IE1hcC5yZW1vdmUgIXJlc3VsdF9tYXAga2V5O1xuICAgICAgTWFwLnJlbW92ZSBjdXJyZW50X2RlcGVuZGVuY2llcyBrZXlcbiAgICBpblxuICAgIGxldCBsaHNfY2hhbmdlID1cbiAgICAgIEluY3JlbWVudGFsLm1hcCBtYXBfaW5jciB+ZjooZnVuIG1hcF9vZl9pbmNycyAtPlxuICAgICAgICBsZXQgbmV3X2RlcGVuZGVuY3lfbWFwID1cbiAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgfmRhdGFfZXF1YWw6cGh5c19lcXVhbFxuICAgICAgICAgICAgIW9sZF9tYXBfb2ZfaW5jcnNcbiAgICAgICAgICAgIG1hcF9vZl9pbmNyc1xuICAgICAgICAgICAgfmluaXQ6IWN1cnJlbnRfZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICB+ZjooZnVuIGN1cnJlbnRfZGVwZW5kZW5jaWVzIChrZXksIGRpZmYpIC0+XG4gICAgICAgICAgICAgIG1hdGNoIGRpZmYgd2l0aFxuICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT4gcmVtb3ZlX3N1Ym5vZGUgY3VycmVudF9kZXBlbmRlbmNpZXMgfmtleVxuICAgICAgICAgICAgICB8IGBSaWdodCBkYXRhX25vZGUgLT4gYWRkX3N1Ym5vZGUgY3VycmVudF9kZXBlbmRlbmNpZXMgfmtleSB+ZGF0YV9ub2RlXG4gICAgICAgICAgICAgIHwgYFVuZXF1YWwgKF8sIGRhdGFfbm9kZSkgLT5cbiAgICAgICAgICAgICAgICByZW1vdmVfc3Vibm9kZSBjdXJyZW50X2RlcGVuZGVuY2llcyB+a2V5IHw+IGFkZF9zdWJub2RlIH5rZXkgfmRhdGFfbm9kZSlcbiAgICAgICAgaW5cbiAgICAgICAgY3VycmVudF9kZXBlbmRlbmNpZXMgOj0gbmV3X2RlcGVuZGVuY3lfbWFwO1xuICAgICAgICBvbGRfbWFwX29mX2luY3JzIDo9IG1hcF9vZl9pbmNycylcbiAgICBpblxuICAgIEUuTm9kZS5hZGRfZGVwZW5kZW5jeSByZXN1bHQgKEUuRGVwZW5kZW5jeS5jcmVhdGUgbGhzX2NoYW5nZSk7XG4gICAgRS5Ob2RlLndhdGNoIHJlc3VsdFxuICA7O1xuXG4gIGxldCBqb2luIG1hcCA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcCAoZnVuIGNvbXBhcmF0b3IgLT4gam9pbl93aXRoX2NvbXBhcmF0b3IgbWFwIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIG1vZHVsZSBTZXBhcmF0ZV9zdGF0ZSA9IHN0cnVjdFxuICAgIHR5cGUgKCdrLCAndiwgJ2NtcCwgJ3cpIHQgPVxuICAgICAgeyBtdXRhYmxlIGlucHV0X21hcCA6ICgnaywgJ3YsICdjbXApIE1hcC50XG4gICAgICA7IG11dGFibGUgZXhwZXJ0X25vZGVzIDogKCdrLCAoJ3YsICd3KSBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS50LCAnY21wKSBNYXAudFxuICAgICAgOyBtdXRhYmxlIG91dHB1dF9tYXAgOiAoJ2ssICgndiwgJ3cpIEluY3JlbWVudGFsLnQsICdjbXApIE1hcC50XG4gICAgICB9XG5cbiAgICBsZXQgY3JlYXRlIGNvbXBhcmF0b3IgPVxuICAgICAgbGV0IGVtcHR5ID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IgaW5cbiAgICAgIHsgaW5wdXRfbWFwID0gZW1wdHk7IGV4cGVydF9ub2RlcyA9IGVtcHR5OyBvdXRwdXRfbWFwID0gZW1wdHkgfVxuICAgIDs7XG5cbiAgICBsZXQgY3JlYXRlX2xvb2t1cF9ub2RlIHN0YXRlIHQga2V5ID1cbiAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLmNyZWF0ZSBzdGF0ZSAoZnVuICgpIC0+IE1hcC5maW5kX2V4biB0LmlucHV0X21hcCBrZXkpXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IHNlcGFyYXRlIGlucHV0X21hcCB+ZGF0YV9lcXVhbCA9XG4gICAgbGV0IGluY3JlbWVudGFsX3N0YXRlID0gSW5jcmVtZW50YWwuc3RhdGUgaW5wdXRfbWFwIGluXG4gICAgd2l0aF9jb21wYXJhdG9yIGlucHV0X21hcCAoZnVuIGNvbXBhcmF0b3IgLT5cbiAgICAgIGxldCBzdGF0ZSA9IFNlcGFyYXRlX3N0YXRlLmNyZWF0ZSBjb21wYXJhdG9yIGluXG4gICAgICBsZXQgb3V0cHV0X21hcF9ub2RlID1cbiAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUuY3JlYXRlIGluY3JlbWVudGFsX3N0YXRlIChmdW4gKCkgLT4gc3RhdGUub3V0cHV0X21hcClcbiAgICAgIGluXG4gICAgICBsZXQgbWFrZV9ub2RlX2RlcGVuZF9vbl9pbnB1dF9tYXBfY2hhbmdlZCBub2RlIH5pbnB1dF9tYXBfY2hhbmdlZCA9XG4gICAgICAgIGxldCBkZXBlbmRlbmN5ID1cbiAgICAgICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuRGVwZW5kZW5jeS5jcmVhdGUgKExhenkuZm9yY2VfdmFsIGlucHV0X21hcF9jaGFuZ2VkKVxuICAgICAgICBpblxuICAgICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS5hZGRfZGVwZW5kZW5jeSBub2RlIGRlcGVuZGVuY3lcbiAgICAgIGluXG4gICAgICAoKiBXZSB3YW50IHRvIG1ha2Ugbm9kZXMgZGVwZW5kIG9uIFtpbnB1dF9tYXBfY2hhbmdlZF0gc28gdGhhdCBbaW5wdXRfbWFwX2NoYW5nZWRdXG4gICAgICAgICBpcyBhbGxvd2VkIHRvIG1ha2UgdGhlbSBzdGFsZSwgYnV0IHdlIGRvIG5vdCB3YW50IHRoZW0gdG8gYmUgcmVjb21wdXRlZCBmb3IgYW55XG4gICAgICAgICBvdGhlciByZWFzb24uIFNvIHdlIG1ha2UgW2lucHV0X21hcF9jaGFuZ2VkXSBhIHVuaXQgaW5jcmVtZW50YWwgKHRoYXQgdGhlcmVmb3JlXG4gICAgICAgICBuZXZlciBjaGFuZ2VzKSBhbmQgdGhpcyB3YXkgW291dHB1dF9tYXBfbm9kZV0gYW5kIHRoZSBsb29rdXAgbm9kZXMgd2lsbCBvbmx5IGJlXG4gICAgICAgICByZWNvbXB1dGVkIHdoZW4gdGhleSBhcmUgZXhwbGljaXRseSBtYWRlIHN0YWxlLlxuICAgICAgKilcbiAgICAgIGxldCByZWMgaW5wdXRfbWFwX2NoYW5nZWQgPVxuICAgICAgICBsYXp5XG4gICAgICAgICAgKEluY3JlbWVudGFsLm1hcCBpbnB1dF9tYXAgfmY6KGZ1biBpbnB1dF9tYXAgLT5cbiAgICAgICAgICAgICBsZXQgcHJldl9pbnB1dF9tYXAgPSBzdGF0ZS5pbnB1dF9tYXAgaW5cbiAgICAgICAgICAgICBsZXQgZXhwZXJ0X25vZGVzLCBvdXRwdXRfbWFwID1cbiAgICAgICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICAgICAgIHByZXZfaW5wdXRfbWFwXG4gICAgICAgICAgICAgICAgIGlucHV0X21hcFxuICAgICAgICAgICAgICAgICB+ZGF0YV9lcXVhbFxuICAgICAgICAgICAgICAgICB+aW5pdDooc3RhdGUuZXhwZXJ0X25vZGVzLCBzdGF0ZS5vdXRwdXRfbWFwKVxuICAgICAgICAgICAgICAgICB+ZjooZnVuIChleHBlcnRfbm9kZXMsIG91dHB1dF9tYXApIChrZXksIGNoYW5nZSkgLT5cbiAgICAgICAgICAgICAgICAgICBtYXRjaCBjaGFuZ2Ugd2l0aFxuICAgICAgICAgICAgICAgICAgIHwgYExlZnQgX29sZF92YWx1ZSAtPlxuICAgICAgICAgICAgICAgICAgICAgbGV0IG9sZF9ub2RlID0gTWFwLmZpbmRfZXhuIGV4cGVydF9ub2RlcyBrZXkgaW5cbiAgICAgICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLmludmFsaWRhdGUgb2xkX25vZGU7XG4gICAgICAgICAgICAgICAgICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS5tYWtlX3N0YWxlIG91dHB1dF9tYXBfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgIE1hcC5yZW1vdmUgZXhwZXJ0X25vZGVzIGtleSwgTWFwLnJlbW92ZSBvdXRwdXRfbWFwIGtleVxuICAgICAgICAgICAgICAgICAgIHwgYFJpZ2h0IF9uZXdfdmFsdWUgLT5cbiAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID1cbiAgICAgICAgICAgICAgICAgICAgICAgU2VwYXJhdGVfc3RhdGUuY3JlYXRlX2xvb2t1cF9ub2RlIGluY3JlbWVudGFsX3N0YXRlIHN0YXRlIGtleVxuICAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgIG1ha2Vfbm9kZV9kZXBlbmRfb25faW5wdXRfbWFwX2NoYW5nZWQgbm9kZSB+aW5wdXRfbWFwX2NoYW5nZWQ7XG4gICAgICAgICAgICAgICAgICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS5tYWtlX3N0YWxlIG91dHB1dF9tYXBfbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICggTWFwLmFkZF9leG4gZXhwZXJ0X25vZGVzIH5rZXkgfmRhdGE6bm9kZVxuICAgICAgICAgICAgICAgICAgICAgLCBNYXAuYWRkX2V4blxuICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dF9tYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICB+a2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgfmRhdGE6KEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLndhdGNoIG5vZGUpIClcbiAgICAgICAgICAgICAgICAgICB8IGBVbmVxdWFsIChfb2xkX3ZhbHVlLCBfbmV3X3ZhbHVlKSAtPlxuICAgICAgICAgICAgICAgICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUubWFrZV9zdGFsZVxuICAgICAgICAgICAgICAgICAgICAgICAoTWFwLmZpbmRfZXhuIGV4cGVydF9ub2RlcyBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgZXhwZXJ0X25vZGVzLCBvdXRwdXRfbWFwKVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgc3RhdGUuaW5wdXRfbWFwIDwtIGlucHV0X21hcDtcbiAgICAgICAgICAgICBzdGF0ZS5leHBlcnRfbm9kZXMgPC0gZXhwZXJ0X25vZGVzO1xuICAgICAgICAgICAgIHN0YXRlLm91dHB1dF9tYXAgPC0gb3V0cHV0X21hcCkpXG4gICAgICBpblxuICAgICAgbWFrZV9ub2RlX2RlcGVuZF9vbl9pbnB1dF9tYXBfY2hhbmdlZCBvdXRwdXRfbWFwX25vZGUgfmlucHV0X21hcF9jaGFuZ2VkO1xuICAgICAgSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUud2F0Y2ggb3V0cHV0X21hcF9ub2RlKVxuICA7O1xuXG4gICgqIEp1c3QgZm9yIGRlcml2aW5nIHN0cnVjdHVyYWwgZXF1YWxpdHkuICopXG4gIHR5cGUgJ2EgbWF5YmVfYm91bmRfc3RydWN0dXJhbGx5ID0gJ2EgTWF5YmVfYm91bmQudCA9XG4gICAgfCBJbmNsIG9mICdhXG4gICAgfCBFeGNsIG9mICdhXG4gICAgfCBVbmJvdW5kZWRcbiAgW0BAZGVyaXZpbmcgZXF1YWxdXG5cbiAgbGV0IHN1YnJhbmdlXG4gICAgICAgICh0eXBlIGsgdiBjbXAgc3RhdGVfd2l0bmVzcylcbiAgICAgICAgPyhkYXRhX2VxdWFsID0gcGh5c19lcXVhbClcbiAgICAgICAgKG1hcF9pbmNyIDogKChrLCB2LCBjbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICByYW5nZVxuICAgID1cbiAgICB3aXRoX29sZDIgbWFwX2luY3IgcmFuZ2UgfmY6KGZ1biB+b2xkIG1hcCByYW5nZSAtPlxuICAgICAgbGV0IGNvbXBhcmUgPSAoTWFwLmNvbXBhcmF0b3IgbWFwKS5jb21wYXJlIGluXG4gICAgICBsZXQgZXF1YWwgbCByID0gY29tcGFyZSBsIHIgPSAwIGluXG4gICAgICBsZXQgKCA+ICkgYSBiID0gY29tcGFyZSBhIGIgPiAwXG4gICAgICBhbmQgKCA+PSApIGEgYiA9IGNvbXBhcmUgYSBiID49IDAgaW5cbiAgICAgIGxldCBtYXliZV9ib3VuZF9lcXVhbCBhIGIgOiBib29sID0gZXF1YWxfbWF5YmVfYm91bmRfc3RydWN0dXJhbGx5IGVxdWFsIGEgYiBpblxuICAgICAgbGV0IHJhbmdlX2lzX2VtcHR5IH5taW4gfm1heCA6IGJvb2wgPVxuICAgICAgICBtYXRjaCBtaW4sIG1heCB3aXRoXG4gICAgICAgIHwgVW5ib3VuZGVkLCAoVW5ib3VuZGVkIHwgRXhjbCBfIHwgSW5jbCBfKSB8IChFeGNsIF8gfCBJbmNsIF8pLCBVbmJvdW5kZWQgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgICB8IEluY2wgbWluLCBJbmNsIG1heCAtPiBtaW4gPiBtYXhcbiAgICAgICAgfCBFeGNsIG1pbiwgRXhjbCBtYXggfCBJbmNsIG1pbiwgRXhjbCBtYXggfCBFeGNsIG1pbiwgSW5jbCBtYXggLT4gbWluID49IG1heFxuICAgICAgaW5cbiAgICAgIGxldCByYW5nZV9pbmNsdWRlcyB+bWluIH5tYXgga2V5IDogYm9vbCA9XG4gICAgICAgIE1heWJlX2JvdW5kLmlzX2xvd2VyX2JvdW5kIG1pbiB+b2ZfOmtleSB+Y29tcGFyZVxuICAgICAgICAmJiBNYXliZV9ib3VuZC5pc191cHBlcl9ib3VuZCBtYXggfm9mXzprZXkgfmNvbXBhcmVcbiAgICAgIGluXG4gICAgICBtYXRjaCByYW5nZSB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgKCogRW1wdHkgbmV3IHJhbmdlIG1lYW5zIGVtcHR5IG1hcCAqKVxuICAgICAgICBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcjooTWFwLmNvbXBhcmF0b3IgbWFwKVxuICAgICAgfCBTb21lICgobWluLCBtYXgpIGFzIHJhbmdlKSAtPlxuICAgICAgICBsZXQgZnJvbV9zY3JhdGNoICgpID0gTWFwLnN1YnJhbmdlIG1hcCB+bG93ZXJfYm91bmQ6bWluIH51cHBlcl9ib3VuZDptYXggaW5cbiAgICAgICAgKG1hdGNoIG9sZCB3aXRoXG4gICAgICAgICB8IE5vbmUgfCBTb21lIChfLCBOb25lLCBfKSAtPlxuICAgICAgICAgICAoKiBubyBvbGQgcmFuZ2UgKilcbiAgICAgICAgICAgZnJvbV9zY3JhdGNoICgpXG4gICAgICAgICB8IFNvbWUgKF8sIFNvbWUgKG9sZF9taW4sIG9sZF9tYXgpLCBfKVxuICAgICAgICAgICB3aGVuIHJhbmdlX2lzX2VtcHR5IH5taW46b2xkX21pbiB+bWF4Om9sZF9tYXhcbiAgICAgICAgICAgICB8fCByYW5nZV9pc19lbXB0eSB+bWluIH5tYXg6b2xkX21heFxuICAgICAgICAgICAgIHx8IHJhbmdlX2lzX2VtcHR5IH5taW46b2xkX21pbiB+bWF4IC0+XG4gICAgICAgICAgICgqIGVtcHR5IG9sZCByYW5nZSBvciBvbGQgcmFuZ2UgZGlzam9pbnQgd2l0aCBuZXcgKilcbiAgICAgICAgICAgZnJvbV9zY3JhdGNoICgpXG4gICAgICAgICB8IFNvbWUgKG9sZF9tYXAsIFNvbWUgKChvbGRfbWluLCBvbGRfbWF4KSBhcyBvbGRfcmFuZ2UpLCBvbGRfcmVzKSAtPlxuICAgICAgICAgICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICAgICAgICAgICAoKiBSZXR1cm5zIHRydWUgaWZmIHRoZSBrZXkgaXMgaW4gYm90aCBuZXcgYW5kIG9sZCByYW5nZXMgKilcbiAgICAgICAgICAgICBsZXQgaW5fcmFuZ2VfaW50ZXJzZWN0aW9uIGtleSA9XG4gICAgICAgICAgICAgICByYW5nZV9pbmNsdWRlcyB+bWluIH5tYXgga2V5XG4gICAgICAgICAgICAgICAmJiByYW5nZV9pbmNsdWRlcyB+bWluOm9sZF9taW4gfm1heDpvbGRfbWF4IGtleVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgKCogQXBwbHkgY2hhbmdlcyB0byBrZXlzIHdoaWNoIGFyZSBpbiB0aGUgaW50ZXJzZWN0aW9uIG9mIGJvdGggcmFuZ2VzLlxuXG4gICAgICAgICAgICAgICAgW291dHNpZGVdIGlzIHRoZSBudW1iZXIgb2YgdXBkYXRlcyBvdXRzaWRlIHRoZSByYW5nZSBpbnRlcnNlY3Rpb24gdGhhdCB3ZVxuICAgICAgICAgICAgICAgIHRvbGVyYXRlIGJlZm9yZSBnaXZpbmcgdXAgYW5kIHJlY29uc3RydWN0aW5nIGJhc2VkIG9uIHRoZSBuZXcgcmFuZ2UuIFRoaXNcbiAgICAgICAgICAgICAgICBpcyBhbiBvcHRpbWlzYXRpb24gaW4gdGhlIGNhc2UgdGhhdCB0aGUgbWFwIGNoYW5nZXMgaW4gYSB2ZXJ5IGJpZyB3YXksIGF0XG4gICAgICAgICAgICAgICAgd2hpY2ggcG9pbnQgY29tcHV0aW5nIGJhc2VkIG9uIHRoZSBuZXcgcmFuZ2UgaXMgY2hlYXBlci4gICopXG4gICAgICAgICAgICAgbGV0IGFwcGx5X2RpZmZfaW5faW50ZXJzZWN0aW9uIChvdXRzaWRlLCBtYXApIChrZXksIGRhdGEpID1cbiAgICAgICAgICAgICAgIGlmIGluX3JhbmdlX2ludGVyc2VjdGlvbiBrZXlcbiAgICAgICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgICAgICBtYXRjaCBkYXRhIHdpdGhcbiAgICAgICAgICAgICAgICAgfCBgTGVmdCBfIC0+IG91dHNpZGUsIE1hcC5yZW1vdmUgbWFwIGtleVxuICAgICAgICAgICAgICAgICB8IGBSaWdodCBkYXRhIHwgYFVuZXF1YWwgKF8sIGRhdGEpIC0+IG91dHNpZGUsIE1hcC5zZXQgbWFwIH5rZXkgfmRhdGEpXG4gICAgICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgICAgbGV0IG91dHNpZGUgPSBvdXRzaWRlIC0gMSBpblxuICAgICAgICAgICAgICAgICBpZiBJbnQuTy4ob3V0c2lkZSA8IDApXG4gICAgICAgICAgICAgICAgIHRoZW4gcmV0dXJuIChmcm9tX3NjcmF0Y2ggKCkpXG4gICAgICAgICAgICAgICAgIGVsc2Ugb3V0c2lkZSwgTWFwLnJlbW92ZSBtYXAga2V5KVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgKCogRmlyc3QgdXBkYXRlIHRoZSBrZXlzIGluIC9ib3RoLyB0aGUgb2xkIGFuZCB0aGUgbmV3IHJhbmdlLiAqKVxuICAgICAgICAgICAgIGxldCB3aXRoX3VwZGF0ZWRfdmFsdWVzX2luX2ludGVyc2VjdGlvbiA9XG4gICAgICAgICAgICAgICAoKiBDdXRvZmYgdGhlIGJpZyBkaWZmIGNvbXB1dGF0aW9uIGlmIHdlIHJlYWNoIE8ofHN1Ym1hcHwpIG51bWJlciBvZlxuICAgICAgICAgICAgICAgICAgY2hhbmdlcyB0aGF0IGFyZSBvdXRzaWRlIHRoZSByYW5nZSAqKVxuICAgICAgICAgICAgICAgbGV0IG91dHNpZGVfY3V0b2ZmID0gTWFwLmxlbmd0aCBvbGRfcmVzIC8gNCBpblxuICAgICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICAgICAgICAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgICAgICAgICAgb2xkX21hcFxuICAgICAgICAgICAgICAgICBtYXBcbiAgICAgICAgICAgICAgICAgfmluaXQ6KG91dHNpZGVfY3V0b2ZmLCBvbGRfcmVzKVxuICAgICAgICAgICAgICAgICB+ZjphcHBseV9kaWZmX2luX2ludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgfD4gc25kXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICBpZiBUdXBsZTIuZXF1YWxcbiAgICAgICAgICAgICAgICAgIH5lcTE6bWF5YmVfYm91bmRfZXF1YWxcbiAgICAgICAgICAgICAgICAgIH5lcTI6bWF5YmVfYm91bmRfZXF1YWxcbiAgICAgICAgICAgICAgICAgIG9sZF9yYW5nZVxuICAgICAgICAgICAgICAgICAgcmFuZ2VcbiAgICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICAoKiBUaGVyZSBhcmUgbm8ga2V5cyB0byByZW1vdmUgYW5kIGV2ZXJ5dGhpbmcgaW4gcmFuZ2UgaXMgdXBkYXRlZC4gKilcbiAgICAgICAgICAgICAgIHdpdGhfdXBkYXRlZF92YWx1ZXNfaW5faW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICAgICAoKiBSZW1vdmUgYW55IGtleXMgd2hpY2ggYXJlIG5vdCBpbiB0aGUgbmV3IHJhbmdlLiAqKVxuICAgICAgICAgICAgICAgbGV0IHdpdGhvdXRfa2V5c19vdXRfb2ZfcmFuZ2UgPVxuICAgICAgICAgICAgICAgICBNYXAuc3VicmFuZ2VcbiAgICAgICAgICAgICAgICAgICB3aXRoX3VwZGF0ZWRfdmFsdWVzX2luX2ludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgICAgIH5sb3dlcl9ib3VuZDptaW5cbiAgICAgICAgICAgICAgICAgICB+dXBwZXJfYm91bmQ6bWF4XG4gICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgKCogQWRkIGluIGFueSBrZXlzIHdoaWNoIGFyZSBpbiB0aGUgbmV3IHJhbmdlIGJ1dCBub3QgdGhlIG9sZCByYW5nZS4gKilcbiAgICAgICAgICAgICAgIGxldCB3aXRoX25ld19rZXlzX25vd19pbl9yYW5nZSA9XG4gICAgICAgICAgICAgICAgIGxldCBtYXBfYXBwZW5kX2V4biBsb3dlcl9wYXJ0IHVwcGVyX3BhcnQgPVxuICAgICAgICAgICAgICAgICAgIG1hdGNoIE1hcC5hcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgd2l0aFxuICAgICAgICAgICAgICAgICAgIHwgYE9rIG1hcCAtPiBtYXBcbiAgICAgICAgICAgICAgICAgICB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIC0+XG4gICAgICAgICAgICAgICAgICAgICBmYWlsd2l0aCBcImltcG9zc2libGUgY2FzZTogQlVHIGluIGluY3JfbWFwLm1sIHN1YnJhbmdlXCJcbiAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgbGV0IGxvd2VyX3BhcnQgPVxuICAgICAgICAgICAgICAgICAgIG1hdGNoIG9sZF9taW4gd2l0aFxuICAgICAgICAgICAgICAgICAgIHwgVW5ib3VuZGVkIC0+XG4gICAgICAgICAgICAgICAgICAgICBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcjooTWFwLmNvbXBhcmF0b3IgbWFwKVxuICAgICAgICAgICAgICAgICAgIHwgRXhjbCBvbGRfbWluIC0+XG4gICAgICAgICAgICAgICAgICAgICBNYXAuc3VicmFuZ2UgbWFwIH5sb3dlcl9ib3VuZDptaW4gfnVwcGVyX2JvdW5kOihJbmNsIG9sZF9taW4pXG4gICAgICAgICAgICAgICAgICAgfCBJbmNsIG9sZF9taW4gLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5zdWJyYW5nZSBtYXAgfmxvd2VyX2JvdW5kOm1pbiB+dXBwZXJfYm91bmQ6KEV4Y2wgb2xkX21pbilcbiAgICAgICAgICAgICAgICAgYW5kIHVwcGVyX3BhcnQgPVxuICAgICAgICAgICAgICAgICAgIG1hdGNoIG9sZF9tYXggd2l0aFxuICAgICAgICAgICAgICAgICAgIHwgVW5ib3VuZGVkIC0+XG4gICAgICAgICAgICAgICAgICAgICBNYXAuVXNpbmdfY29tcGFyYXRvci5lbXB0eSB+Y29tcGFyYXRvcjooTWFwLmNvbXBhcmF0b3IgbWFwKVxuICAgICAgICAgICAgICAgICAgIHwgRXhjbCBvbGRfbWF4IC0+XG4gICAgICAgICAgICAgICAgICAgICBNYXAuc3VicmFuZ2UgbWFwIH5sb3dlcl9ib3VuZDooSW5jbCBvbGRfbWF4KSB+dXBwZXJfYm91bmQ6bWF4XG4gICAgICAgICAgICAgICAgICAgfCBJbmNsIG9sZF9tYXggLT5cbiAgICAgICAgICAgICAgICAgICAgIE1hcC5zdWJyYW5nZSBtYXAgfmxvd2VyX2JvdW5kOihFeGNsIG9sZF9tYXgpIH51cHBlcl9ib3VuZDptYXhcbiAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgbWFwX2FwcGVuZF9leG5cbiAgICAgICAgICAgICAgICAgICBsb3dlcl9wYXJ0XG4gICAgICAgICAgICAgICAgICAgKG1hcF9hcHBlbmRfZXhuIHdpdGhvdXRfa2V5c19vdXRfb2ZfcmFuZ2UgdXBwZXJfcGFydClcbiAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICB3aXRoX25ld19rZXlzX25vd19pbl9yYW5nZSkpKSlcbiAgOztcblxuICBsZXQgcmVrZXkgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmNvbXBhcmF0b3I6b3V0ZXJfY29tcGFyYXRvciB+ZiA9XG4gICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgIG1hcF9pbmNyXG4gICAgICA/ZGF0YV9lcXVhbFxuICAgICAgfmluaXQ6KE1hcC5lbXB0eSBvdXRlcl9jb21wYXJhdG9yKVxuICAgICAgfnJldmVydF90b19pbml0X3doZW5fZW1wdHk6dHJ1ZVxuICAgICAgfmFkZDooZnVuIH5rZXkgfmRhdGEgb3V0cHV0IC0+IE1hcC5hZGRfZXhuIG91dHB1dCB+a2V5OihmIH5rZXkgfmRhdGEpIH5kYXRhKVxuICAgICAgfnJlbW92ZTooZnVuIH5rZXkgfmRhdGEgb3V0cHV0IC0+IE1hcC5yZW1vdmUgb3V0cHV0IChmIH5rZXkgfmRhdGEpKVxuICAgICAgfnVwZGF0ZTooZnVuIH5rZXkgfm9sZF9kYXRhIH5uZXdfZGF0YSBvdXRwdXQgLT5cbiAgICAgICAgbGV0IHByZXZfa2V5ID0gZiB+a2V5IH5kYXRhOm9sZF9kYXRhIGluXG4gICAgICAgIGxldCBuZXdfa2V5ID0gZiB+a2V5IH5kYXRhOm5ld19kYXRhIGluXG4gICAgICAgIGlmIChNYXAuY29tcGFyYXRvciBvdXRwdXQpLmNvbXBhcmUgcHJldl9rZXkgbmV3X2tleSA9IDBcbiAgICAgICAgdGhlbiBNYXAuc2V0IG91dHB1dCB+a2V5Om5ld19rZXkgfmRhdGE6bmV3X2RhdGFcbiAgICAgICAgZWxzZSBNYXAucmVtb3ZlIG91dHB1dCBwcmV2X2tleSB8PiBNYXAuYWRkX2V4biB+a2V5Om5ld19rZXkgfmRhdGE6bmV3X2RhdGEpXG4gIDs7XG5cbiAgbGV0IGluZGV4X2J5aSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+Y29tcGFyYXRvcjpvdXRlcl9jb21wYXJhdG9yIH5pbmRleCA9XG4gICAgd2l0aF9jb21wYXJhdG9yIG1hcF9pbmNyIChmdW4gaW5uZXJfY29tcGFyYXRvciAtPlxuICAgICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgbWFwX2luY3JcbiAgICAgICAgfmluaXQ6KE1hcC5lbXB0eSBvdXRlcl9jb21wYXJhdG9yKVxuICAgICAgICB+cmV2ZXJ0X3RvX2luaXRfd2hlbl9lbXB0eTp0cnVlXG4gICAgICAgIH5hZGQ6KGZ1biB+a2V5OmlubmVyX2tleSB+ZGF0YSBvdXRlcl9tYXAgLT5cbiAgICAgICAgICBtYXRjaCBpbmRleCB+a2V5OmlubmVyX2tleSB+ZGF0YSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IG91dGVyX21hcFxuICAgICAgICAgIHwgU29tZSBvdXRlcl9rZXkgLT5cbiAgICAgICAgICAgIE1hcC51cGRhdGUgb3V0ZXJfbWFwIG91dGVyX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgTWFwLlVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uXG4gICAgICAgICAgICAgICAgICBpbm5lcl9rZXlcbiAgICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgIH5jb21wYXJhdG9yOmlubmVyX2NvbXBhcmF0b3JcbiAgICAgICAgICAgICAgfCBTb21lIGlubmVyX21hcCAtPiBNYXAuYWRkX2V4biBpbm5lcl9tYXAgfmtleTppbm5lcl9rZXkgfmRhdGEpKVxuICAgICAgICB+cmVtb3ZlOihmdW4gfmtleTppbm5lcl9rZXkgfmRhdGEgb3V0ZXJfbWFwIC0+XG4gICAgICAgICAgbWF0Y2ggaW5kZXggfmtleTppbm5lcl9rZXkgfmRhdGEgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBvdXRlcl9tYXBcbiAgICAgICAgICB8IFNvbWUgb3V0ZXJfa2V5IC0+XG4gICAgICAgICAgICBNYXAuY2hhbmdlIG91dGVyX21hcCBvdXRlcl9rZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgIGZhaWx3aXRoIFwiQlVHOiBIaXQgc3VwcG9zZWRseSBpbXBvc3NpYmxlIGNhc2UgaW4gSW5jcl9tYXAuaW5kZXhfYnlcIlxuICAgICAgICAgICAgICB8IFNvbWUgaW5uZXJfbWFwIC0+XG4gICAgICAgICAgICAgICAgbGV0IGlubmVyX21hcCA9IE1hcC5yZW1vdmUgaW5uZXJfbWFwIGlubmVyX2tleSBpblxuICAgICAgICAgICAgICAgIGlmIE1hcC5pc19lbXB0eSBpbm5lcl9tYXAgdGhlbiBOb25lIGVsc2UgU29tZSBpbm5lcl9tYXApKSlcbiAgOztcblxuICBsZXQgaW5kZXhfYnkgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmNvbXBhcmF0b3IgfmluZGV4ID1cbiAgICBpbmRleF9ieWkgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmNvbXBhcmF0b3IgfmluZGV4OihmdW4gfmtleTpfIH5kYXRhIC0+IGluZGV4IGRhdGEpXG4gIDs7XG5cblxuICAoKiogRmluZCB0d28ga2V5cyBpbiBtYXAgYnkgaW5kZXgsIE8obikuIFdlIHVzZSBqdXN0IG9uZSBmb2xkICh0d28gTWFwLm50aCB3b3VsZCB1c2UgdHdvKVxuICAgICAgYW5kIG9wdGltaXplIGZvciBrZXlzIGNsb3NlIHRvIGVpdGhlciBiZWdpbm5pbmcgb3IgZW5kIGJ5IHVzaW5nIGVpdGhlciBmb2xkIG9yXG4gICAgICBmb2xkX3JpZ2h0LlxuICAqKVxuICBtb2R1bGUgS2V5X3N0YXR1cyA9IHN0cnVjdFxuICAgIHR5cGUgJ2sgdCA9XG4gICAgICB8IEtub3duIG9mICdrXG4gICAgICB8IEtub3duX25vbmVcbiAgICAgIHwgVW5rbm93blxuXG4gICAgbGV0IGlzX2tub3duID0gZnVuY3Rpb25cbiAgICAgIHwgVW5rbm93biAtPiBmYWxzZVxuICAgICAgfCBfIC0+IHRydWVcbiAgICA7O1xuXG4gICAgbGV0IHRvX29wdGlvbiA9IGZ1bmN0aW9uXG4gICAgICB8IFVua25vd24gfCBLbm93bl9ub25lIC0+IE5vbmVcbiAgICAgIHwgS25vd24gayAtPiBTb21lIGtcbiAgICA7O1xuICBlbmRcblxuICBsZXQgZmluZF9rZXlfcmFuZ2VfbGluZWFyICh0eXBlIGspIH5mcm9tIH50b18gKG1hcCA6IChrLCBfLCBfKSBNYXAudClcbiAgICA6IChrICogayBvcHRpb24pIG9wdGlvblxuICAgID1cbiAgICBsZXQgb3BlbiBLZXlfc3RhdHVzIGluXG4gICAgbGV0IGxlbiA9IE1hcC5sZW5ndGggbWFwIGluXG4gICAgbGV0IGJlZ2luX2tleSA9IGlmIEludC4oID49ICkgZnJvbSBsZW4gdGhlbiBLbm93bl9ub25lIGVsc2UgVW5rbm93biBpblxuICAgIGxldCBlbmRfa2V5ID0gaWYgSW50LiggPj0gKSB0b18gbGVuIHRoZW4gS25vd25fbm9uZSBlbHNlIFVua25vd24gaW5cbiAgICBsZXQgZmluZF9rZXlzIGZvbGQgfnN0YXJ0X3BvcyB+YWR2YW5jZV9wb3MgPVxuICAgICAgd2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgICAgIGZvbGRcbiAgICAgICAgICBtYXBcbiAgICAgICAgICB+aW5pdDooYmVnaW5fa2V5LCBlbmRfa2V5LCBzdGFydF9wb3MpXG4gICAgICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhOl8gKGJlZ2luX2tleSwgZW5kX2tleSwgcG9zKSAtPlxuICAgICAgICAgICAgbGV0IGJlZ2luX2tleSA9IGlmIEludC4oID0gKSBwb3MgZnJvbSB0aGVuIEtub3duIGtleSBlbHNlIGJlZ2luX2tleSBpblxuICAgICAgICAgICAgbGV0IGVuZF9rZXkgPSBpZiBJbnQuKCA9ICkgcG9zIHRvXyB0aGVuIEtub3duIGtleSBlbHNlIGVuZF9rZXkgaW5cbiAgICAgICAgICAgIGlmIGlzX2tub3duIGJlZ2luX2tleSAmJiBpc19rbm93biBlbmRfa2V5XG4gICAgICAgICAgICB0aGVuIHJldHVybiAoYmVnaW5fa2V5LCBlbmRfa2V5LCBwb3MpXG4gICAgICAgICAgICBlbHNlIGJlZ2luX2tleSwgZW5kX2tleSwgYWR2YW5jZV9wb3MgcG9zKSlcbiAgICBpblxuICAgIGxldCBiZWdpbl9rZXksIGVuZF9rZXksIF8gPVxuICAgICAgKCogU2VhcmNoaW5nIGZyb20gbGVmdCB0YWtlcyBPKHRvXyksIGZyb20gcmlnaHQgLSBPKGxlbiAtIGZyb20pLCBzbyBzZWxlY3QgdGhlXG4gICAgICAgICBzbWFsbGVyIG9uZS4gKilcbiAgICAgIGlmIHRvXyA8IGxlbiAtIGZyb21cbiAgICAgIHRoZW4gZmluZF9rZXlzIE1hcC5mb2xkIH5zdGFydF9wb3M6MCB+YWR2YW5jZV9wb3M6KGZ1biBwb3MgLT4gcG9zICsgMSlcbiAgICAgIGVsc2UgZmluZF9rZXlzIE1hcC5mb2xkX3JpZ2h0IH5zdGFydF9wb3M6KGxlbiAtIDEpIH5hZHZhbmNlX3BvczooZnVuIHBvcyAtPiBwb3MgLSAxKVxuICAgIGluXG4gICAgT3B0aW9uLm1hcCAoS2V5X3N0YXR1cy50b19vcHRpb24gYmVnaW5fa2V5KSB+ZjooZnVuIGJlZ2luX2tleSAtPlxuICAgICAgYmVnaW5fa2V5LCBLZXlfc3RhdHVzLnRvX29wdGlvbiBlbmRfa2V5KVxuICA7O1xuXG4gIGxldCBudGhfZnJvbV9laXRoZXJfc2lkZSAodHlwZSBrKSBuIChtYXAgOiAoaywgXywgXykgTWFwLnQpIDogayBvcHRpb24gPVxuICAgIE9wdGlvbi5tYXAgfmY6ZnN0IChmaW5kX2tleV9yYW5nZV9saW5lYXIgfmZyb206biB+dG9fOm4gbWFwKVxuICA7O1xuXG4gICgqKiBGaW5kIGtleSBbYnldIHBvc2l0aW9ucyBlYXJsaWVyL2xhdGVyIGluIGEgbWFwLiBSZXR1cm5zIG5vbmUgaWYgb3V0IG9mIGJvdW5kcy4gKilcbiAgbGV0IHJlYyBvZmZzZXQgKGtleSA6ICdrKSAobWFwIDogKCdrLCBfLCBfKSBNYXAudCkgfmJ5IDogJ2sgb3B0aW9uID1cbiAgICBpZiBJbnQuKCA9ICkgYnkgMFxuICAgIHRoZW4gU29tZSBrZXlcbiAgICBlbHNlIChcbiAgICAgIGxldCBjbG9zZXN0X2RpciwgYWRkID1cbiAgICAgICAgaWYgSW50LiggPCApIGJ5IDAgdGhlbiBgTGVzc190aGFuLCAxIGVsc2UgYEdyZWF0ZXJfdGhhbiwgLTFcbiAgICAgIGluXG4gICAgICBtYXRjaCBNYXAuY2xvc2VzdF9rZXkgbWFwIGNsb3Nlc3RfZGlyIGtleSB3aXRoXG4gICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgfCBTb21lIChrZXksIF8pIC0+IG9mZnNldCBrZXkgbWFwIH5ieTooYnkgKyBhZGQpKVxuICA7O1xuXG4gICgqKiBGaW5kIGhvdyB3ZSBuZWVkIHRvIG1vdmUgW2tleV0gaWYgW2NoYW5nZWRfa2V5XSBjaGFuZ2VkIGluIHRoZSBnaXZlblxuICAgICAgd2F5ICopXG4gIGxldCBmaW5kX29mZnNldCB+Y29tcGFyZSB+a2V5IH5jaGFuZ2VkX2tleSBjaGFuZ2UgPVxuICAgIGlmIEludC4oIDwgKSAoY29tcGFyZSBjaGFuZ2VkX2tleSBrZXkpIDBcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIGNoYW5nZSB3aXRoXG4gICAgICB8IGBMZWZ0IF8gLT4gMVxuICAgICAgfCBgUmlnaHQgXyAtPiAtMVxuICAgICAgfCBfIC0+IDApXG4gICAgZWxzZSAwXG4gIDs7XG5cbiAgbGV0IHJhbmtcbiAgICAgICAgKHR5cGUgayB2IGNtcCBzdGF0ZV93aXRuZXNzKVxuICAgICAgICAobWFwIDogKChrLCB2LCBjbXApIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICAoa2V5IDogKGssIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgPVxuICAgIHdpdGhfY29tcGFyYXRvciBtYXAgKGZ1biBjb21wYXJhdG9yIC0+XG4gICAgICBsZXQgY29tcGFyZV9rZXkgPSBjb21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgICAgIGxldCBzYW1lX2tleSBhIGIgPSBjb21wYXJlX2tleSBhIGIgPSAwIGluXG4gICAgICBsZXQgd2hlbl9rZXlfY2hhbmdlZCB+bWFwIH5vbGRfa2V5IH5uZXdfa2V5IH5vbGRfcmFuayA9XG4gICAgICAgIGlmIGNvbXBhcmVfa2V5IG5ld19rZXkgb2xkX2tleSA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgKCogSWYgdGhlIG5ldyBrZXkgaXMgc21hbGxlciB0aGFuIHRoZSBvbGQga2V5LCBmaW5kIHRoZSBzaXplIG9mIHRoZSBtYXAgc3VicmFuZ2VcbiAgICAgICAgICAgICBiZXR3ZWVuIHRoZW0gYW5kIHN1YnRyYWN0IGl0IGZyb20gdGhlIHByZXZpb3VzIHJhbmsgKilcbiAgICAgICAgICBsZXQgbG93ZXJfYm91bmQsIHVwcGVyX2JvdW5kID0gRXhjbCBuZXdfa2V5LCBFeGNsIG9sZF9rZXkgaW5cbiAgICAgICAgICBsZXQgc3VicmFuZ2UgPSBNYXAuc3VicmFuZ2UgbWFwIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgaW5cbiAgICAgICAgICBvbGRfcmFuayAtIE1hcC5sZW5ndGggc3VicmFuZ2UgLSAxKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBPdGhlcndpc2UsIHRoZSBuZXcga2V5IGlzIGxhcmdlciB0aGFuIHRoZSBvbGQga2V5LCBzbyBmaW5kIHRoZSBzaXplIG9mIHRoZVxuICAgICAgICAgICAgIG1hcCBzdWJyYW5nZSBiZXR3ZWVuIHRoZW0gYW5kIGFkZCBpdCB0byB0aGUgcHJldmlvdXMgcmFuayAqKVxuICAgICAgICAgIGxldCBsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQgPSBFeGNsIG9sZF9rZXksIEV4Y2wgbmV3X2tleSBpblxuICAgICAgICAgIGxldCBzdWJyYW5nZSA9IE1hcC5zdWJyYW5nZSBtYXAgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCBpblxuICAgICAgICAgIG9sZF9yYW5rICsgTWFwLmxlbmd0aCBzdWJyYW5nZSArIDEpXG4gICAgICBpblxuICAgICAgbGV0IHdoZW5fbWFwX2NoYW5nZWQgfm9sZF9tYXAgfm5ld19tYXAgfmtleSB+b2xkX3JhbmsgPVxuICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICgqIFdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIGRhdGEsIHNvIG9wdGltaXplIHRoZXNlIGNoZWNrcyAqKVxuICAgICAgICAgIH5kYXRhX2VxdWFsOihmdW4gXyBfIC0+IHRydWUpXG4gICAgICAgICAgb2xkX21hcFxuICAgICAgICAgIG5ld19tYXBcbiAgICAgICAgICB+aW5pdDpvbGRfcmFua1xuICAgICAgICAgIH5mOihmdW4gYWNjIChkaWZmX2tleSwgZGlmZikgLT5cbiAgICAgICAgICAgIG1hdGNoIGRpZmYgd2l0aFxuICAgICAgICAgICAgfCBgTGVmdCBfIHdoZW4gY29tcGFyZV9rZXkgZGlmZl9rZXkga2V5IDwgMCAtPiBhY2MgLSAxXG4gICAgICAgICAgICB8IGBSaWdodCBfIHdoZW4gY29tcGFyZV9rZXkgZGlmZl9rZXkga2V5IDwgMCAtPiBhY2MgKyAxXG4gICAgICAgICAgICB8IF8gLT4gYWNjKVxuICAgICAgaW5cbiAgICAgIGxldCByZWMgcHJvY2VzcyB+KG9sZCA6ICgoaywgdiwgXykgTWFwLnQgKiBfICogXykgb3B0aW9uKSBuZXdfbWFwIChuZXdfa2V5IDogaykgPVxuICAgICAgICBpZiBub3QgKE1hcC5tZW0gbmV3X21hcCBuZXdfa2V5KVxuICAgICAgICB0aGVuIE5vbmVcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggb2xkIHdpdGhcbiAgICAgICAgICAoKiBJZiB0aGUgbWFwIGFuZCBrZXkgYXJlIHRoZSBzYW1lLCBqdXN0IHJldXNlIHRoZSBvbGQgcmFuayAqKVxuICAgICAgICAgIHwgU29tZSAob2xkX21hcCwgb2xkX2tleSwgb2xkX3JhbmspXG4gICAgICAgICAgICB3aGVuIHBoeXNfZXF1YWwgbmV3X21hcCBvbGRfbWFwICYmIHNhbWVfa2V5IG9sZF9rZXkgbmV3X2tleSAtPiBvbGRfcmFua1xuICAgICAgICAgICgqIElmIHRoZSBtYXAgaXMgdGhlIHNhbWUgYnV0IHRoZSBrZXkgY2hhbmdlZCAqKVxuICAgICAgICAgIHwgU29tZSAob2xkX21hcCwgb2xkX2tleSwgU29tZSBvbGRfcmFuaykgd2hlbiBwaHlzX2VxdWFsIG5ld19tYXAgb2xkX21hcCAtPlxuICAgICAgICAgICAgU29tZSAod2hlbl9rZXlfY2hhbmdlZCB+bWFwOm5ld19tYXAgfm9sZF9rZXkgfm5ld19rZXkgfm9sZF9yYW5rKVxuICAgICAgICAgICgqIElmIHRoZSBrZXkgaXMgdGhlIHNhbWUgYnV0IHRoZSBtYXAgY2hhbmdlZCAqKVxuICAgICAgICAgIHwgU29tZSAob2xkX21hcCwgb2xkX2tleSwgU29tZSBvbGRfcmFuaykgd2hlbiBzYW1lX2tleSBuZXdfa2V5IG9sZF9rZXkgLT5cbiAgICAgICAgICAgIFNvbWUgKHdoZW5fbWFwX2NoYW5nZWQgfm9sZF9tYXAgfm5ld19tYXAgfmtleTpuZXdfa2V5IH5vbGRfcmFuaylcbiAgICAgICAgICAoKiBJZiBib3RoIHRoZSBtYXAgYW5kIHRoZSBrZXkgY2hhbmdlZCwgdGhpcyBjYW4gYmUgc2ltdWxhdGVkIGFzIHRoZVxuICAgICAgICAgICAgIG1hcCBjaGFuZ2luZyBmb2xsb3dlZCBieSB0aGUga2V5IGNoYW5naW5nICopXG4gICAgICAgICAgfCBTb21lIChvbGRfbWFwLCBvbGRfa2V5LCBTb21lIG9sZF9yYW5rKSAtPlxuICAgICAgICAgICAgKCogV2UgY2FsbCBbcHJvY2Vzc10gcmVjdXJzaXZlbHkgaW5zdGVhZCBvZiBkaXJlY3RseSBjYWxsaW5nXG4gICAgICAgICAgICAgICBbd2hlbl9tYXBfY2hhbmdlZF0gZm9sbG93ZWQgYnkgW3doZW5fa2V5X2NoYW5nZWRdIHNpbmNlIGl0IG1pZ2h0IGJlIHRoZVxuICAgICAgICAgICAgICAgY2FzZSB0aGF0IFtvbGRfa2V5XSBpcyBpbiBbb2xkX21hcF0gYW5kIFtuZXdfa2V5XSBpcyBpbiBbbmV3X21hcF0sIGJ1dFxuICAgICAgICAgICAgICAgW29sZF9rZXldIGlzIG5vdCBpbiBbbmV3X21hcF0uICopXG4gICAgICAgICAgICBsZXQgb2xkX3JhbmsgPVxuICAgICAgICAgICAgICBwcm9jZXNzIH5vbGQ6KFNvbWUgKG9sZF9tYXAsIG9sZF9rZXksIFNvbWUgb2xkX3JhbmspKSBuZXdfbWFwIG9sZF9rZXlcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBwcm9jZXNzIH5vbGQ6KFNvbWUgKG5ld19tYXAsIG9sZF9rZXksIG9sZF9yYW5rKSkgbmV3X21hcCBuZXdfa2V5XG4gICAgICAgICAgKCogSWYgdGhlIHByZXZpb3VzIGtleSB3YXMgbm90IGluIHRoZSBtYXAgb3IgdGhpcyBpcyB0aGUgZmlyc3Qgc3RhYmlsaXphdGlvbixcbiAgICAgICAgICAgICBjb21wdXRlIHRoZSByYW5rIGZyb20gc2NyYXRjaCAqKVxuICAgICAgICAgIHwgU29tZSAoXywgXywgTm9uZSkgfCBOb25lIC0+IE1hcC5yYW5rIG5ld19tYXAgbmV3X2tleSlcbiAgICAgIGluXG4gICAgICB3aXRoX29sZDIgbWFwIGtleSB+Zjpwcm9jZXNzKVxuICA7O1xuXG4gICgqKiBSYW5nZSBtYXAgYnkgaW5kaWNlcyAqKVxuICBsZXQgc3VicmFuZ2VfYnlfcmFua1xuICAgICAgICAodHlwZSBrIHN0YXRlX3dpdG5lc3MpXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIChtYXAgOiAoKGssIF8sIF8pIE1hcC50LCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICAocmFuZ2UgOiAoaW50IE1heWJlX2JvdW5kLnQgKiBpbnQgTWF5YmVfYm91bmQudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudClcbiAgICA9XG4gICAgbGV0IGZpbmRfa2V5X3JhbmdlIChyYW5nZSA6IChpbnQgKiBpbnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnQpXG4gICAgICA6ICgoayAqIGsgb3B0aW9uKSBvcHRpb24sIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICAgID1cbiAgICAgIHdpdGhfb2xkMiBtYXAgcmFuZ2UgfmY6KGZ1biB+b2xkIG1hcCAoZnJvbSwgdG9fKSAtPlxuICAgICAgICAoKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgbm8ga2V5cywgb25seSBiZWdpbiBrZXksIG9yIGJlZ2luIGFuZCBlbmQga2V5cy5cbiAgICAgICAgICAgVGhlc2UgYXJlIHRoZSBrZXlzIGF0IFtmcm9tXSBhbmQgW3RvX10gcG9zaXRpb25zIGluIHRoZSBtYXAsIG9yIE5vbmUgaWYgdGhlXG4gICAgICAgICAgIGluZGljZXMgYXJlIHRvbyBiaWcuIEFzIGFsd2F5cyBbMCA8PSBmcm9tICYmIGZyb20gPD0gdG9fXSwgdGhlcmUgaXMgbm9cbiAgICAgICAgICAgcG9zc2liaWxpdHkgb2Ygb25seSBbdG9fXSBiZWluZyBhIHZhbGlkIHBvc2l0aW9uLlxuICAgICAgICAqKVxuICAgICAgICBpZiBJbnQuKCA8ICkgdG9fIGZyb20gfHwgSW50LiggPCApIGZyb20gMFxuICAgICAgICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiSW52YWxpZCBpbmRpY2VzXCIgKGZyb20gOiBpbnQpICh0b18gOiBpbnQpXTtcbiAgICAgICAgbWF0Y2ggb2xkIHdpdGhcbiAgICAgICAgfCBTb21lIChvbGRfbWFwLCAob2xkX2Zyb20sIG9sZF90byksIFNvbWUgKGJlZ2luX2tleSwgZW5kX2tleV9vcHQpKSAtPlxuICAgICAgICAgIGxldCBmaW5kX29mZnNldCA9IGZpbmRfb2Zmc2V0IH5jb21wYXJlOihNYXAuY29tcGFyYXRvciBtYXApLmNvbXBhcmUgaW5cbiAgICAgICAgICBsZXQgcmFuZ2Vfb2Zmc2V0X2JlZ2luID0gZnJvbSAtIG9sZF9mcm9tIGluXG4gICAgICAgICAgbGV0IHJhbmdlX29mZnNldF9lbmQgPSB0b18gLSBvbGRfdG8gaW5cbiAgICAgICAgICBsZXQgYWRqdXN0X2FuZF9vZmZzZXQgfmJ5IGtleSA9XG4gICAgICAgICAgICBsZXQgYnkgPSBieSArIGlmIGJ5ID49IDAgJiYgbm90IChNYXAubWVtIG1hcCBrZXkpIHRoZW4gMSBlbHNlIDAgaW5cbiAgICAgICAgICAgIG9mZnNldCBrZXkgbWFwIH5ieVxuICAgICAgICAgIGluXG4gICAgICAgICAgKCogV2Ugb25seSBjYXJlIGFib3V0IHRoZSBrZXlzIGNoYW5naW5nIGFuZCBub3QgdGhlIGRhdGEsIHNvIFtkYXRhX2VxdWFsXSBoZXJlXG4gICAgICAgICAgICAgY2FuIGJlIGFsd2F5cyB0cnVlICopXG4gICAgICAgICAgbGV0IGRpZmYgfmluaXQgfmYgPVxuICAgICAgICAgICAgTWFwLmZvbGRfc3ltbWV0cmljX2RpZmYgfmRhdGFfZXF1YWw6KGZ1biBfIF8gLT4gdHJ1ZSkgb2xkX21hcCBtYXAgfmluaXQgfmZcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBiZWdpbl9rZXlfb3B0LCBlbmRfa2V5X29wdCA9XG4gICAgICAgICAgICBtYXRjaCBlbmRfa2V5X29wdCB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgZW5kX2tleSAtPlxuICAgICAgICAgICAgICBsZXQgbWFwX29mZnNldF9iZWdpbiwgbWFwX29mZnNldF9lbmQgPVxuICAgICAgICAgICAgICAgIGRpZmYgfmluaXQ6KDAsIDApIH5mOihmdW4gKG9mZnNldF9iZWdpbiwgb2Zmc2V0X2VuZCkgKGtleSwgY2hhbmdlKSAtPlxuICAgICAgICAgICAgICAgICAgKCBvZmZzZXRfYmVnaW4gKyBmaW5kX29mZnNldCB+a2V5OmJlZ2luX2tleSB+Y2hhbmdlZF9rZXk6a2V5IGNoYW5nZVxuICAgICAgICAgICAgICAgICAgLCBvZmZzZXRfZW5kICsgZmluZF9vZmZzZXQgfmtleTplbmRfa2V5IH5jaGFuZ2VkX2tleTprZXkgY2hhbmdlICkpXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICggYWRqdXN0X2FuZF9vZmZzZXQgYmVnaW5fa2V5IH5ieToobWFwX29mZnNldF9iZWdpbiArIHJhbmdlX29mZnNldF9iZWdpbilcbiAgICAgICAgICAgICAgLCBhZGp1c3RfYW5kX29mZnNldCBlbmRfa2V5IH5ieToobWFwX29mZnNldF9lbmQgKyByYW5nZV9vZmZzZXRfZW5kKSApXG4gICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgbGV0IG1hcF9vZmZzZXRfYmVnaW4gPVxuICAgICAgICAgICAgICAgIGRpZmYgfmluaXQ6MCB+ZjooZnVuIG9mZnNldF9iZWdpbiAoa2V5LCBjaGFuZ2UpIC0+XG4gICAgICAgICAgICAgICAgICBvZmZzZXRfYmVnaW4gKyBmaW5kX29mZnNldCB+a2V5OmJlZ2luX2tleSB+Y2hhbmdlZF9rZXk6a2V5IGNoYW5nZSlcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgKCBhZGp1c3RfYW5kX29mZnNldCBiZWdpbl9rZXkgfmJ5OihtYXBfb2Zmc2V0X2JlZ2luICsgcmFuZ2Vfb2Zmc2V0X2JlZ2luKVxuICAgICAgICAgICAgICAsIG50aF9mcm9tX2VpdGhlcl9zaWRlIHRvXyBtYXAgKVxuICAgICAgICAgIGluXG4gICAgICAgICAgYXNzZXJ0IChPcHRpb24uZm9yX2FsbCB+ZjooTWFwLm1lbSBtYXApIGJlZ2luX2tleV9vcHQpO1xuICAgICAgICAgIGFzc2VydCAoT3B0aW9uLmZvcl9hbGwgfmY6KE1hcC5tZW0gbWFwKSBlbmRfa2V5X29wdCk7XG4gICAgICAgICAgT3B0aW9uLm1hcCBiZWdpbl9rZXlfb3B0IH5mOihmdW4gYmVnaW5fa2V5IC0+IGJlZ2luX2tleSwgZW5kX2tleV9vcHQpXG4gICAgICAgIHwgTm9uZSB8IFNvbWUgKF8sIF8sIE5vbmUpIC0+XG4gICAgICAgICAgKCogT24gZmlyc3QgcnVuICh3aGVuIHdlIGhhdmUgdG8pIG9yIHdoZW4gYm90aCB0aGUga2V5cyBhcmUgbm9uZSwgcnVuIE8obilcbiAgICAgICAgICAgICBzY2FuLiBUaGlzIGlzIGZpbmUgZm9yIGtleXMtYXJlLW5vbmUgY2FzZSBhcyBpdCBoYXBwZW5zIHdoZW4gdGhlIHBvc2l0aW9uc1xuICAgICAgICAgICAgIGFyZSBwYXN0IGVuZCBvZiB0aGUgbWFwLCBzbyB0aGV5IHNob3VsZG4ndCBiZSB0b28gZmFyIGZyb20gZW5kIGFmdGVyIHRoZVxuICAgICAgICAgICAgIG1hcCBjaGFuZ2VzLCBhbmQgW2ZpbmRfa2V5X3JhbmdlX2xpbmVhcl0gaXMgZmFzdCBpbiBzdWNoIGNhc2UuICopXG4gICAgICAgICAgZmluZF9rZXlfcmFuZ2VfbGluZWFyIG1hcCB+ZnJvbSB+dG9fKVxuICAgIGluXG4gICAgKCogSGFuZGxlIGRpZmZlcmVudCBNYXliZV9ib3VuZCBjYXNlcyBhbmQgY2FsbCBmaW5kX2tleV9yYW5nZSBpZiBuZWNlc3NhcnkuIEl0J3NcbiAgICAgICBuaWNlciB0byBkbyB0aGlzIGhlcmUgYXMgb3Bwb3NlZCB0byBtYWtpbmcgZmluZF9rZXlfcmFuZ2UgZXZlbiBtb3JlIGNvbXBsaWNhdGVkICopXG4gICAgbGV0IG9wZW4gSW5jcmVtZW50YWwuTGV0X3N5bnRheCBpblxuICAgIGxldCAoID4+PiApIG5ld18gYm91bmQgPSBNYXliZV9ib3VuZC5tYXAgfmY6KGZ1biBfIC0+IG5ld18pIGJvdW5kIGluXG4gICAgbGV0IHJldHVybiA9IEluY3JlbWVudGFsLnJldHVybiAoSW5jcmVtZW50YWwuc3RhdGUgbWFwKSBpblxuICAgIGxldCBrZXlfcmFuZ2UgPVxuICAgICAgbWF0Y2glcGF0dGVybl9iaW5kIHJhbmdlIHdpdGhcbiAgICAgIHwgTWF5YmVfYm91bmQuVW5ib3VuZGVkLCBNYXliZV9ib3VuZC5VbmJvdW5kZWQgLT5cbiAgICAgICAgcmV0dXJuIChTb21lIChNYXliZV9ib3VuZC5VbmJvdW5kZWQsIE1heWJlX2JvdW5kLlVuYm91bmRlZCkpXG4gICAgICB8ICggKChNYXliZV9ib3VuZC5JbmNsIGwgfCBNYXliZV9ib3VuZC5FeGNsIGwpIGFzIGxiKVxuICAgICAgICAsICgoTWF5YmVfYm91bmQuSW5jbCB1IHwgTWF5YmVfYm91bmQuRXhjbCB1KSBhcyB1YikgKSAtPlxuICAgICAgICBsZXQlbWFwIGtleV9yYW5nZSA9IGZpbmRfa2V5X3JhbmdlIChJbmNyZW1lbnRhbC5ib3RoIGwgdSlcbiAgICAgICAgYW5kIGxiID0gbGJcbiAgICAgICAgYW5kIHViID0gdWIgaW5cbiAgICAgICAgKG1hdGNoIGtleV9yYW5nZSB3aXRoXG4gICAgICAgICB8IFNvbWUgKGJlZ2luX2tleSwgU29tZSBlbmRfa2V5KSAtPiBTb21lIChiZWdpbl9rZXkgPj4+IGxiLCBlbmRfa2V5ID4+PiB1YilcbiAgICAgICAgIHwgU29tZSAoYmVnaW5fa2V5LCBOb25lKSAtPiBTb21lIChiZWdpbl9rZXkgPj4+IGxiLCBVbmJvdW5kZWQpXG4gICAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICAgIHwgKChNYXliZV9ib3VuZC5JbmNsIGwgfCBNYXliZV9ib3VuZC5FeGNsIGwpIGFzIGxiKSwgTWF5YmVfYm91bmQuVW5ib3VuZGVkIC0+XG4gICAgICAgIGxldCVtYXAga2V5X3JhbmdlID0gZmluZF9rZXlfcmFuZ2UgKEluY3JlbWVudGFsLmJvdGggbCBsKVxuICAgICAgICBhbmQgbGIgPSBsYiBpblxuICAgICAgICAobWF0Y2gga2V5X3JhbmdlIHdpdGhcbiAgICAgICAgIHwgU29tZSAoa2V5LCBfKSAtPiBTb21lIChrZXkgPj4+IGxiLCBVbmJvdW5kZWQpXG4gICAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICAgIHwgTWF5YmVfYm91bmQuVW5ib3VuZGVkLCAoKE1heWJlX2JvdW5kLkluY2wgdSB8IE1heWJlX2JvdW5kLkV4Y2wgdSkgYXMgdWIpIC0+XG4gICAgICAgIGxldCVtYXAga2V5X3JhbmdlID0gZmluZF9rZXlfcmFuZ2UgKEluY3JlbWVudGFsLmJvdGggdSB1KVxuICAgICAgICBhbmQgdWIgPSB1YiBpblxuICAgICAgICAobWF0Y2gga2V5X3JhbmdlIHdpdGhcbiAgICAgICAgIHwgU29tZSAoa2V5LCBfKSAtPiBTb21lIChVbmJvdW5kZWQsIGtleSA+Pj4gdWIpXG4gICAgICAgICB8IE5vbmUgLT4gTm9uZSlcbiAgICBpblxuICAgIHN1YnJhbmdlID9kYXRhX2VxdWFsIG1hcCBrZXlfcmFuZ2VcbiAgOztcblxuICBsZXQgdHJhbnNwb3NlXG4gICAgOiB0eXBlIGsxIGsyIHYgazFfY21wIGsyX2NtcCBzdGF0ZV93aXRuZXNzLlxuICAgICAgP2RhdGFfZXF1YWw6KHYgLT4gdiAtPiBib29sKVxuICAgICAgLT4gKGsyLCBrMl9jbXApIE1hcC5jb21wYXJhdG9yXG4gICAgICAtPiAoKGsxLCAoazIsIHYsIGsyX2NtcCkgTWFwLnQsIGsxX2NtcCkgTWFwLnQsIHN0YXRlX3dpdG5lc3MpIEluY3JlbWVudGFsLnRcbiAgICAgIC0+ICgoazIsIChrMSwgdiwgazFfY21wKSBNYXAudCwgazJfY21wKSBNYXAudCwgc3RhdGVfd2l0bmVzcykgSW5jcmVtZW50YWwudFxuICAgID1cbiAgICBmdW4gPyhkYXRhX2VxdWFsID0gcGh5c19lcXVhbCkgazJfY29tcGFyYXRvciBtIC0+XG4gICAgICB3aXRoX2NvbXBhcmF0b3IgbSAoZnVuIGsxX2NvbXBhcmF0b3IgLT5cbiAgICAgICAgbGV0IHVwZGF0ZVxuICAgICAgICAgIDogIGtleTprMSAtPiBvbGRfZGF0YTooazIsIHYsIGsyX2NtcCkgTWFwLnQgLT4gbmV3X2RhdGE6KGsyLCB2LCBrMl9jbXApIE1hcC50XG4gICAgICAgICAgICAtPiAoazIsIChrMSwgdiwgazFfY21wKSBNYXAudCwgazJfY21wKSBNYXAudFxuICAgICAgICAgICAgLT4gKGsyLCAoazEsIHYsIGsxX2NtcCkgTWFwLnQsIGsyX2NtcCkgTWFwLnRcbiAgICAgICAgICA9XG4gICAgICAgICAgZnVuIH5rZXk6azEgfm9sZF9kYXRhIH5uZXdfZGF0YSBhY2MgLT5cbiAgICAgICAgICAgIE1hcC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICAgICAgICAgIG9sZF9kYXRhXG4gICAgICAgICAgICAgIG5ld19kYXRhXG4gICAgICAgICAgICAgIH5kYXRhX2VxdWFsXG4gICAgICAgICAgICAgIH5pbml0OmFjY1xuICAgICAgICAgICAgICB+ZjooZnVuIGFjYyAoazIsIGRpZmYpIC0+XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID1cbiAgICAgICAgICAgICAgICAgIG1hdGNoIGRpZmYgd2l0aFxuICAgICAgICAgICAgICAgICAgfCBgTGVmdCBfIC0+IE5vbmVcbiAgICAgICAgICAgICAgICAgIHwgYFJpZ2h0IHggfCBgVW5lcXVhbCAoXywgeCkgLT4gU29tZSB4XG4gICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICBNYXAuY2hhbmdlIGFjYyBrMiB+ZjooZnVuIGFjY19pbm5lciAtPlxuICAgICAgICAgICAgICAgICAgbGV0IGFjY19pbm5lciA9XG4gICAgICAgICAgICAgICAgICAgIE1hcC5jaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAoT3B0aW9uLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgYWNjX2lubmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgfmRlZmF1bHQ6KE1hcC5Vc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOmsxX2NvbXBhcmF0b3IpKVxuICAgICAgICAgICAgICAgICAgICAgIGsxXG4gICAgICAgICAgICAgICAgICAgICAgfmY6KGZ1biBfIC0+IHZhbHVlKVxuICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgIGlmIE1hcC5pc19lbXB0eSBhY2NfaW5uZXIgdGhlbiBOb25lIGVsc2UgU29tZSBhY2NfaW5uZXIpKVxuICAgICAgICBpblxuICAgICAgICBsZXQgYWRkIH5rZXkgfmRhdGEgPVxuICAgICAgICAgIHVwZGF0ZSB+a2V5IH5vbGRfZGF0YTooTWFwLmVtcHR5IGsyX2NvbXBhcmF0b3IpIH5uZXdfZGF0YTpkYXRhXG4gICAgICAgIGluXG4gICAgICAgIGxldCByZW1vdmUgfmtleSB+ZGF0YSA9XG4gICAgICAgICAgdXBkYXRlIH5rZXkgfm9sZF9kYXRhOmRhdGEgfm5ld19kYXRhOihNYXAuZW1wdHkgazJfY29tcGFyYXRvcilcbiAgICAgICAgaW5cbiAgICAgICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgICAgICBtXG4gICAgICAgICAgfmluaXQ6KE1hcC5lbXB0eSBrMl9jb21wYXJhdG9yKVxuICAgICAgICAgIH5yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OnRydWVcbiAgICAgICAgICB+dXBkYXRlXG4gICAgICAgICAgfmFkZFxuICAgICAgICAgIH5yZW1vdmUpXG4gIDs7XG5cbiAgbGV0IGNvbGxhcHNlX2J5XG4gICAgICAgICh0eXBlIG91dGVyX2tleSBvdXRlcl9jbXAgaW5uZXJfa2V5IGlubmVyX2NtcCBjb21iaW5lZF9rZXkgY29tYmluZWRfY21wKVxuICAgICAgICA/ZGF0YV9lcXVhbFxuICAgICAgICAobWFwX2luY3IgOlxuICAgICAgICAgICAoKG91dGVyX2tleSwgKGlubmVyX2tleSwgXywgaW5uZXJfY21wKSBNYXAudCwgb3V0ZXJfY21wKSBNYXAudCwgXykgSW5jcmVtZW50YWwudClcbiAgICAgICAgfihtZXJnZV9rZXlzIDogb3V0ZXJfa2V5IC0+IGlubmVyX2tleSAtPiBjb21iaW5lZF9rZXkpXG4gICAgICAgIH4oY29tcGFyYXRvciA6IChjb21iaW5lZF9rZXksIGNvbWJpbmVkX2NtcCkgTWFwLmNvbXBhcmF0b3IpXG4gICAgPVxuICAgIHVub3JkZXJlZF9mb2xkX25lc3RlZF9tYXBzXG4gICAgICA/ZGF0YV9lcXVhbFxuICAgICAgbWFwX2luY3JcbiAgICAgIH5pbml0OihNYXAuZW1wdHkgY29tcGFyYXRvcilcbiAgICAgIH5yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OnRydWVcbiAgICAgIH51cGRhdGU6KGZ1biB+b3V0ZXJfa2V5IH5pbm5lcl9rZXkgfm9sZF9kYXRhOl8gfm5ld19kYXRhIGFjYyAtPlxuICAgICAgICBNYXAuc2V0IGFjYyB+a2V5OihtZXJnZV9rZXlzIG91dGVyX2tleSBpbm5lcl9rZXkpIH5kYXRhOm5ld19kYXRhKVxuICAgICAgfmFkZDooZnVuIH5vdXRlcl9rZXkgfmlubmVyX2tleSB+ZGF0YSBhY2MgLT5cbiAgICAgICAgTWFwLmFkZF9leG4gYWNjIH5rZXk6KG1lcmdlX2tleXMgb3V0ZXJfa2V5IGlubmVyX2tleSkgfmRhdGEpXG4gICAgICB+cmVtb3ZlOihmdW4gfm91dGVyX2tleSB+aW5uZXJfa2V5IH5kYXRhOl8gYWNjIC0+XG4gICAgICAgIE1hcC5yZW1vdmUgYWNjIChtZXJnZV9rZXlzIG91dGVyX2tleSBpbm5lcl9rZXkpKVxuICA7O1xuXG4gIGxldCBjb2xsYXBzZVxuICAgICAgICAodHlwZSBvdXRlcl9rZXkgb3V0ZXJfY21wIGlubmVyX2tleSBpbm5lcl9jbXApXG4gICAgICAgID9kYXRhX2VxdWFsXG4gICAgICAgIChtYXBfaW5jciA6XG4gICAgICAgICAgICgob3V0ZXJfa2V5LCAoaW5uZXJfa2V5LCBfLCBpbm5lcl9jbXApIE1hcC50LCBvdXRlcl9jbXApIE1hcC50LCBfKSBJbmNyZW1lbnRhbC50KVxuICAgICAgICB+Y29tcGFyYXRvcjooaW5uZXJfY29tcGFyYXRvciA6IChpbm5lcl9rZXksIGlubmVyX2NtcCkgTWFwLmNvbXBhcmF0b3IpXG4gICAgPVxuICAgIHdpdGhfY29tcGFyYXRvciBtYXBfaW5jciAoZnVuIG91dGVyX2NvbXBhcmF0b3IgLT5cbiAgICAgIGxldCBtb2R1bGUgQ21wID0gc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IG91dGVyX2tleSAqIGlubmVyX2tleVxuICAgICAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IChvdXRlcl9jbXAsIGlubmVyX2NtcCkgVHVwbGUyLmNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gICAgICAgIGxldCBjb21wYXJhdG9yID1cbiAgICAgICAgICBsZXQgaW5uZXJfY29tcGFyYXRvciA9XG4gICAgICAgICAgICBsZXQgbW9kdWxlIE0gPSAodmFsIGlubmVyX2NvbXBhcmF0b3IpIGluXG4gICAgICAgICAgICBNLmNvbXBhcmF0b3JcbiAgICAgICAgICBpblxuICAgICAgICAgIFR1cGxlMi5jb21wYXJhdG9yIG91dGVyX2NvbXBhcmF0b3IgaW5uZXJfY29tcGFyYXRvclxuICAgICAgICA7O1xuICAgICAgZW5kXG4gICAgICBpblxuICAgICAgY29sbGFwc2VfYnlcbiAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgbWFwX2luY3JcbiAgICAgICAgfm1lcmdlX2tleXM6VHVwbGUyLmNyZWF0ZVxuICAgICAgICB+Y29tcGFyYXRvcjoobW9kdWxlIENtcCkpXG4gIDs7XG5cbiAgbGV0IGV4cGFuZCA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+b3V0ZXJfY29tcGFyYXRvciB+aW5uZXJfY29tcGFyYXRvciA9XG4gICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICBtYXBfaW5jclxuICAgICAgfmluaXQ6KE1hcC5lbXB0eSBvdXRlcl9jb21wYXJhdG9yKVxuICAgICAgfnJldmVydF90b19pbml0X3doZW5fZW1wdHk6dHJ1ZVxuICAgICAgfnVwZGF0ZTooZnVuIH5rZXk6KG91dGVyX2tleSwgaW5uZXJfa2V5KSB+b2xkX2RhdGE6XyB+bmV3X2RhdGEgYWNjIC0+XG4gICAgICAgIE1hcC51cGRhdGUgYWNjIG91dGVyX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICB8IE5vbmUgLT4gTWFwLnNpbmdsZXRvbiBpbm5lcl9jb21wYXJhdG9yIGlubmVyX2tleSBuZXdfZGF0YVxuICAgICAgICAgIHwgU29tZSBtYXAgLT4gTWFwLnNldCBtYXAgfmtleTppbm5lcl9rZXkgfmRhdGE6bmV3X2RhdGEpKVxuICAgICAgfmFkZDooZnVuIH5rZXk6KG91dGVyX2tleSwgaW5uZXJfa2V5KSB+ZGF0YSBhY2MgLT5cbiAgICAgICAgTWFwLnVwZGF0ZSBhY2Mgb3V0ZXJfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICAgIHwgTm9uZSAtPiBNYXAuc2luZ2xldG9uIGlubmVyX2NvbXBhcmF0b3IgaW5uZXJfa2V5IGRhdGFcbiAgICAgICAgICB8IFNvbWUgbWFwIC0+IE1hcC5hZGRfZXhuIG1hcCB+a2V5OmlubmVyX2tleSB+ZGF0YSkpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleToob3V0ZXJfa2V5LCBpbm5lcl9rZXkpIH5kYXRhOl8gYWNjIC0+XG4gICAgICAgIE1hcC5jaGFuZ2UgYWNjIG91dGVyX2tleSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgIHwgU29tZSBtYXAgLT5cbiAgICAgICAgICAgIGxldCBtYXAgPSBNYXAucmVtb3ZlIG1hcCBpbm5lcl9rZXkgaW5cbiAgICAgICAgICAgIE9wdGlvbi5zb21lX2lmIChub3QgKE1hcC5pc19lbXB0eSBtYXApKSBtYXApKVxuICA7O1xuXG4gIGxldCBjb3VudGkgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYgPVxuICAgIHVub3JkZXJlZF9mb2xkXG4gICAgICA/ZGF0YV9lcXVhbFxuICAgICAgbWFwX2luY3JcbiAgICAgIH5pbml0OjBcbiAgICAgIH5yZXZlcnRfdG9faW5pdF93aGVuX2VtcHR5OnRydWVcbiAgICAgIH5hZGQ6KGZ1biB+a2V5IH5kYXRhIGNvdW50IC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIGNvdW50ICsgMSBlbHNlIGNvdW50KVxuICAgICAgfnJlbW92ZTooZnVuIH5rZXkgfmRhdGEgY291bnQgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gY291bnQgLSAxIGVsc2UgY291bnQpXG4gIDs7XG5cbiAgbGV0IGNvdW50ID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mID1cbiAgICBjb3VudGkgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuICA7O1xuXG4gIGxldCBleGlzdHNpID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mID1cbiAgICBJbmNyZW1lbnRhbC5tYXAgKGNvdW50aSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZikgfmY6KGZ1biBjb3VudCAtPiBjb3VudCA8PiAwKVxuICA7O1xuXG4gIGxldCBleGlzdHMgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYgPVxuICAgIGV4aXN0c2kgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuICA7O1xuXG4gIGxldCBzdW1cbiAgICAgICAgKHR5cGUgdSlcbiAgICAgICAgP2RhdGFfZXF1YWxcbiAgICAgICAgKG1hcF9pbmNyIDogKChfLCBfLCBfKSBNYXAudCwgXykgSW5jcmVtZW50YWwudClcbiAgICAgICAgKG1vZHVsZSBHcm91cCA6IEFic3RyYWN0X2FsZ2VicmEuQ29tbXV0YXRpdmVfZ3JvdXAuV2l0aG91dF9zZXhwIHdpdGggdHlwZSB0ID0gdSlcbiAgICAgICAgfmZcbiAgICA9XG4gICAgdW5vcmRlcmVkX2ZvbGRcbiAgICAgID9kYXRhX2VxdWFsXG4gICAgICBtYXBfaW5jclxuICAgICAgfmluaXQ6R3JvdXAuemVyb1xuICAgICAgfnJldmVydF90b19pbml0X3doZW5fZW1wdHk6dHJ1ZVxuICAgICAgfmFkZDooZnVuIH5rZXk6XyB+ZGF0YTp2IGFjYyAtPiBHcm91cC4oICsgKSBhY2MgKGYgdikpXG4gICAgICB+cmVtb3ZlOihmdW4gfmtleTpfIH5kYXRhOnYgYWNjIC0+IEdyb3VwLiggLSApIGFjYyAoZiB2KSlcbiAgOztcblxuICBsZXQgZm9yX2FsbGkgP2RhdGFfZXF1YWwgbWFwX2luY3IgfmYgPVxuICAgIEluY3JlbWVudGFsLm1hcFxuICAgICAgKGNvdW50aSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gbm90IChmIH5rZXkgfmRhdGEpKSlcbiAgICAgIH5mOihmdW4gY291bnQgLT4gY291bnQgPSAwKVxuICA7O1xuXG4gIGxldCBmb3JfYWxsID9kYXRhX2VxdWFsIG1hcF9pbmNyIH5mID1cbiAgICBmb3JfYWxsaSA/ZGF0YV9lcXVhbCBtYXBfaW5jciB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG4gIDs7XG5cbiAgbW9kdWxlIEZvcl90ZXN0aW5nID0gc3RydWN0XG4gICAgbGV0IGZpbmRfa2V5X3JhbmdlX2xpbmVhciA9IGZpbmRfa2V5X3JhbmdlX2xpbmVhclxuICBlbmRcblxuICBtb2R1bGUgTG9va3VwID0gc3RydWN0XG4gICAgdHlwZSAoJ3YsICd3KSBlbnRyeSA9XG4gICAgICB7IG11dGFibGUgc2F2ZWRfdmFsdWUgOiAndiBvcHRpb25cbiAgICAgIDsgbm9kZSA6ICgndiBvcHRpb24sICd3KSBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS50XG4gICAgICB9XG5cbiAgICB0eXBlICgnaywgJ3YsICdjbXAsICd3KSB0ID1cbiAgICAgIHsgbXV0YWJsZSBzYXZlZF9tYXAgOiAoJ2ssICd2LCAnY21wKSBNYXAudFxuICAgICAgKCogV2UgbWF5IGhhdmUgbXVsdGlwbGUgZW50cmllcyBwZXIga2V5IGlmIG5vZGVzIGJlY29tZSBuZWNlc3NhcnkgYWdhaW4gYWZ0ZXIgYmVpbmdcbiAgICAgICAgIHJlbW92ZWQuICopXG4gICAgICA7IG11dGFibGUgbG9va3VwX2VudHJpZXMgOiAoJ2ssICgndiwgJ3cpIGVudHJ5IGxpc3QsICdjbXApIE1hcC50XG4gICAgICA7IHVwZGF0ZXJfbm9kZSA6ICh1bml0LCAndykgSW5jcmVtZW50YWwudFxuICAgICAgOyBzY29wZSA6ICd3IEluY3JlbWVudGFsLlNjb3BlLnRcbiAgICAgIH1cblxuICAgIG1vZHVsZSBNIChLIDogc2lnXG4gICAgICAgIHR5cGUgdFxuICAgICAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgICAgZW5kKSA9XG4gICAgc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAoJ3YsICd3KSB0ID0gKEsudCwgJ3YsIEsuY29tcGFyYXRvcl93aXRuZXNzLCAndykgdFxuICAgIGVuZFxuXG4gICAgbGV0IGNyZWF0ZSA/KGRhdGFfZXF1YWwgPSBwaHlzX2VxdWFsKSBpbnB1dF9tYXAgfmNvbXBhcmF0b3IgPVxuICAgICAgbGV0IHJlYyBzZWxmID1cbiAgICAgICAgbGF6eVxuICAgICAgICAgIChsZXQgdXBkYXRlcl9ub2RlID1cbiAgICAgICAgICAgICBJbmNyZW1lbnRhbC5tYXAgaW5wdXRfbWFwIH5mOihmdW4gaW5wdXRfbWFwIC0+XG4gICAgICAgICAgICAgICBsZXQgKGxhenkgc2VsZikgPSBzZWxmIGluXG4gICAgICAgICAgICAgICBNYXAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgICAgICAgICAgICBzZWxmLnNhdmVkX21hcFxuICAgICAgICAgICAgICAgICBpbnB1dF9tYXBcbiAgICAgICAgICAgICAgICAgfmRhdGFfZXF1YWxcbiAgICAgICAgICAgICAgICAgfmluaXQ6KClcbiAgICAgICAgICAgICAgICAgfmY6KGZ1biAoKSAoa2V5LCBjaGFuZ2VkX3ZhbHVlKSAtPlxuICAgICAgICAgICAgICAgICAgIGxldCBlbnRyaWVzID0gTWFwLmZpbmRfbXVsdGkgc2VsZi5sb29rdXBfZW50cmllcyBrZXkgaW5cbiAgICAgICAgICAgICAgICAgICBMaXN0Lml0ZXIgZW50cmllcyB+ZjooZnVuIGVudHJ5IC0+XG4gICAgICAgICAgICAgICAgICAgICBlbnRyeS5zYXZlZF92YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgPC0gKG1hdGNoIGNoYW5nZWRfdmFsdWUgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICB8IGBMZWZ0IF8gLT4gTm9uZVxuICAgICAgICAgICAgICAgICAgICAgICB8IGBSaWdodCBuZXdfdmFsdWUgfCBgVW5lcXVhbCAoXywgbmV3X3ZhbHVlKSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgIFNvbWUgbmV3X3ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLm1ha2Vfc3RhbGUgZW50cnkubm9kZSkpO1xuICAgICAgICAgICAgICAgc2VsZi5zYXZlZF9tYXAgPC0gaW5wdXRfbWFwKVxuICAgICAgICAgICBpblxuICAgICAgICAgICBsZXQgZW1wdHlfbWFwID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuZW1wdHkgfmNvbXBhcmF0b3IgaW5cbiAgICAgICAgICAgeyBzYXZlZF9tYXAgPSBlbXB0eV9tYXBcbiAgICAgICAgICAgOyBsb29rdXBfZW50cmllcyA9IGVtcHR5X21hcFxuICAgICAgICAgICA7IHVwZGF0ZXJfbm9kZVxuICAgICAgICAgICA7IHNjb3BlID0gSW5jcmVtZW50YWwuU2NvcGUuY3VycmVudCAoSW5jcmVtZW50YWwuc3RhdGUgaW5wdXRfbWFwKSAoKVxuICAgICAgICAgICB9KVxuICAgICAgaW5cbiAgICAgIExhenkuZm9yY2Ugc2VsZlxuICAgIDs7XG5cbiAgICBsZXRbQGNvbGRdIHNsb3dfcGF0aF9saW5rX2VudHJ5IHQgZW50cnkgfmtleSB+aXNfbm93X29ic2VydmFibGUgPVxuICAgICAgbGV0IChsYXp5IGVudHJ5KSA9IGVudHJ5IGluXG4gICAgICBsZXQgY3VycmVudF9lbnRyaWVzID0gTWFwLmZpbmRfbXVsdGkgdC5sb29rdXBfZW50cmllcyBrZXkgaW5cbiAgICAgIGxldCBpc19saW5rZWQgPSBMaXN0LmV4aXN0cyBjdXJyZW50X2VudHJpZXMgfmY6KHBoeXNfZXF1YWwgZW50cnkpIGluXG4gICAgICBpZiBCb29sLmVxdWFsIGlzX2xpbmtlZCBpc19ub3dfb2JzZXJ2YWJsZVxuICAgICAgdGhlbiAoKVxuICAgICAgZWxzZSBpZiBpc19ub3dfb2JzZXJ2YWJsZVxuICAgICAgdGhlblxuICAgICAgICB0Lmxvb2t1cF9lbnRyaWVzXG4gICAgICAgIDwtIE1hcC51cGRhdGUgdC5sb29rdXBfZW50cmllcyBrZXkgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgfCBTb21lIChvdGhlcl9lbnRyeSA6OiBfIGFzIG90aGVyX2VudHJpZXMpIC0+XG4gICAgICAgICAgICAoKiBVcGRhdGUgdGhpcyBlbnRyeSdzIHZhbHVlIHRvIGJlIGN1cnJlbnQuICopXG4gICAgICAgICAgICBlbnRyeS5zYXZlZF92YWx1ZSA8LSBvdGhlcl9lbnRyeS5zYXZlZF92YWx1ZTtcbiAgICAgICAgICAgIGVudHJ5IDo6IG90aGVyX2VudHJpZXNcbiAgICAgICAgICB8IE5vbmUgfCBTb21lIFtdIC0+XG4gICAgICAgICAgICBlbnRyeS5zYXZlZF92YWx1ZSA8LSBNYXAuZmluZCB0LnNhdmVkX21hcCBrZXk7XG4gICAgICAgICAgICBbIGVudHJ5IF0pXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IG5ld19lbnRyaWVzID1cbiAgICAgICAgICBMaXN0LmZpbHRlciBjdXJyZW50X2VudHJpZXMgfmY6KGZ1biB4IC0+IG5vdCAocGh5c19lcXVhbCBlbnRyeSB4KSlcbiAgICAgICAgaW5cbiAgICAgICAgdC5sb29rdXBfZW50cmllc1xuICAgICAgICA8LSAoaWYgTGlzdC5pc19lbXB0eSBuZXdfZW50cmllc1xuICAgICAgICAgICAgdGhlbiBNYXAucmVtb3ZlIHQubG9va3VwX2VudHJpZXMga2V5XG4gICAgICAgICAgICBlbHNlIE1hcC5zZXQgdC5sb29rdXBfZW50cmllcyB+a2V5IH5kYXRhOm5ld19lbnRyaWVzKSlcbiAgICA7O1xuXG4gICAgbGV0W0Bjb2xkXSBzbG93X3BhdGhfY3JlYXRlX25vZGUgdCBrZXkgPVxuICAgICAgbGV0IGluY3JlbWVudGFsX3N0YXRlID0gSW5jcmVtZW50YWwuc3RhdGUgdC51cGRhdGVyX25vZGUgaW5cbiAgICAgIEluY3JlbWVudGFsLlNjb3BlLndpdGhpbiBpbmNyZW1lbnRhbF9zdGF0ZSB0LnNjb3BlIH5mOihmdW4gKCkgLT5cbiAgICAgICAgbGV0IHJlYyBlbnRyeSA9XG4gICAgICAgICAgbGF6eVxuICAgICAgICAgICAgeyBzYXZlZF92YWx1ZSA9IE1hcC5maW5kIHQuc2F2ZWRfbWFwIGtleVxuICAgICAgICAgICAgOyBub2RlID1cbiAgICAgICAgICAgICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS5jcmVhdGVcbiAgICAgICAgICAgICAgICAgIGluY3JlbWVudGFsX3N0YXRlXG4gICAgICAgICAgICAgICAgICAoZnVuICgpIC0+IChmb3JjZSBlbnRyeSkuc2F2ZWRfdmFsdWUpXG4gICAgICAgICAgICAgICAgICB+b25fb2JzZXJ2YWJpbGl0eV9jaGFuZ2U6KHNsb3dfcGF0aF9saW5rX2VudHJ5IHQgZW50cnkgfmtleSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgaW5cbiAgICAgICAgbGV0IChsYXp5IGVudHJ5KSA9IGVudHJ5IGluXG4gICAgICAgIEluY3JlbWVudGFsLkV4cGVydC5Ob2RlLmFkZF9kZXBlbmRlbmN5XG4gICAgICAgICAgZW50cnkubm9kZVxuICAgICAgICAgIChJbmNyZW1lbnRhbC5FeHBlcnQuRGVwZW5kZW5jeS5jcmVhdGUgdC51cGRhdGVyX25vZGUpO1xuICAgICAgICBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS53YXRjaCBlbnRyeS5ub2RlKVxuICAgIDs7XG5cbiAgICBsZXQgZmluZCB0IGtleSA9XG4gICAgICBtYXRjaCBNYXAuZmluZF9tdWx0aSB0Lmxvb2t1cF9lbnRyaWVzIGtleSB3aXRoXG4gICAgICB8IGVudHJ5IDo6IF8gLT4gSW5jcmVtZW50YWwuRXhwZXJ0Lk5vZGUud2F0Y2ggZW50cnkubm9kZVxuICAgICAgfCBbXSAtPiBzbG93X3BhdGhfY3JlYXRlX25vZGUgdCBrZXlcbiAgICA7O1xuXG4gICAgbW9kdWxlIEZvcl9kZWJ1ZyA9IHN0cnVjdFxuICAgICAgbGV0W0Bjb2xkXSBzZXhwX29mX2VudHJ5IHNleHBfb2ZfdmFsdWUgZW50cnkgPVxuICAgICAgICBsZXQgeyBzYXZlZF92YWx1ZTsgbm9kZSB9ID0gZW50cnkgaW5cbiAgICAgICAgbGV0IG5vZGUgPSBJbmNyZW1lbnRhbC5FeHBlcnQuTm9kZS53YXRjaCBub2RlIGluXG4gICAgICAgIFslc2V4cFxuICAgICAgICAgIHsgc2F2ZWRfdmFsdWUgOiB2YWx1ZSBvcHRpb25cbiAgICAgICAgICA7IG5vZGVfaW5mbyA9IChJbmNyZW1lbnRhbC51c2VyX2luZm8gbm9kZSA6IChJbmZvLnQgb3B0aW9uW0BzZXhwLm9wdGlvbl0pKVxuICAgICAgICAgIDsgbm9kZV9pc19jb25zdCA9XG4gICAgICAgICAgICAgIChPcHRpb24uc29tZV9pZiAoSW5jcmVtZW50YWwuaXNfY29uc3Qgbm9kZSkgKCkgOiAodW5pdCBvcHRpb25bQHNleHAub3B0aW9uXSkpXG4gICAgICAgICAgOyBub2RlX2lzX2ludmFsaWQgPVxuICAgICAgICAgICAgICAoT3B0aW9uLnNvbWVfaWYgKG5vdCAoSW5jcmVtZW50YWwuaXNfdmFsaWQgbm9kZSkpICgpIDogKHVuaXQgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW0BzZXhwLm9wdGlvbl0pKVxuICAgICAgICAgIDsgbm9kZV9pc191bm5lY2Vzc2FyeSA9XG4gICAgICAgICAgICAgIChPcHRpb24uc29tZV9pZiAobm90IChJbmNyZW1lbnRhbC5pc19uZWNlc3Nhcnkgbm9kZSkpICgpIDogKHVuaXQgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtAc2V4cC5vcHRpb25dKSlcbiAgICAgICAgICB9XVxuICAgICAgOztcblxuICAgICAgbGV0W0Bjb2xkXSBzZXhwX29mX3Qgc2V4cF9vZl9rZXkgc2V4cF9vZl92YWx1ZSB0ID1cbiAgICAgICAgbGV0IGluZm9fcGVyX2tleSA9XG4gICAgICAgICAgTWFwLm1lcmdlIHQuc2F2ZWRfbWFwIHQubG9va3VwX2VudHJpZXMgfmY6KGZ1biB+a2V5IGRhdGEgLT5cbiAgICAgICAgICAgIGxldCBhY3R1YWxfdmFsdWUsIGVudHJpZXMgPVxuICAgICAgICAgICAgICBtYXRjaCBkYXRhIHdpdGhcbiAgICAgICAgICAgICAgfCBgTGVmdCB4IC0+IFNvbWUgeCwgW11cbiAgICAgICAgICAgICAgfCBgUmlnaHQgeSAtPiBOb25lLCB5XG4gICAgICAgICAgICAgIHwgYEJvdGggKHgsIHkpIC0+IFNvbWUgeCwgeVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIFNvbWVcbiAgICAgICAgICAgICAgWyVzZXhwXG4gICAgICAgICAgICAgICAgeyBrZXkgOiBrZXlcbiAgICAgICAgICAgICAgICA7IGFjdHVhbF92YWx1ZSA6ICh2YWx1ZSBvcHRpb25bQHNleHAub3B0aW9uXSlcbiAgICAgICAgICAgICAgICA7IGVudHJpZXMgOiB2YWx1ZSBlbnRyeSBsaXN0XG4gICAgICAgICAgICAgICAgfV0pXG4gICAgICAgIGluXG4gICAgICAgIFNleHAuTGlzdCAoTWFwLmRhdGEgaW5mb19wZXJfa2V5KVxuICAgICAgOztcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIHN0YXRlX3dpdG5lc3NcblxuICBpbmNsdWRlXG4gICAgU19nZW5cbiAgICB3aXRoIHR5cGUgJ2EgSW5jci50ID0gKCdhLCBzdGF0ZV93aXRuZXNzKSBJbmNyZW1lbnRhbC50XG4gICAgIGFuZCB0eXBlICdhIEluY3IuQ3V0b2ZmLnQgPSAnYSBJbmNyZW1lbnRhbC5DdXRvZmYudFxuICAgICBhbmQgdHlwZSAoJ2ssICd2LCAnY21wKSBMb29rdXAudCA9ICgnaywgJ3YsICdjbXAsIHN0YXRlX3dpdG5lc3MpIEdlbmVyaWMuTG9va3VwLnRcbmVuZFxuXG5tb2R1bGUgTWFrZSAoSW5jciA6IEluY3JlbWVudGFsLlMpID0gc3RydWN0XG4gIGluY2x1ZGUgR2VuZXJpY1xuXG4gIGxldCBmbGF0dGVuIHggPSBmbGF0dGVuIEluY3IuU3RhdGUudCB4XG5cbiAgbW9kdWxlIExvb2t1cCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgTG9va3VwXG5cbiAgICB0eXBlICgnaywgJ3YsICdjbXApIHQgPSAoJ2ssICd2LCAnY21wLCBJbmNyLnN0YXRlX3dpdG5lc3MpIExvb2t1cC50XG5cbiAgICBtb2R1bGUgTSAoSyA6IHNpZ1xuICAgICAgICB0eXBlIHRcbiAgICAgICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcbiAgICAgIGVuZCkgOiBzaWdcbiAgICAgIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgICBlbmQgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuaW5jbHVkZSBHZW5lcmljXG4iXX0=
