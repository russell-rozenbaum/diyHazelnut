// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.8.1+5.8.1

//# unitInfo: Provides: Base_quickcheck__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_quickcheck = [0];
   runtime.caml_register_global(0, Base_quickcheck, "Base_quickcheck__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__With_basic_types
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Base_quickcheck_With_basic_typ = [0];
   runtime.caml_register_global
    (0, Base_quickcheck_With_basic_typ, "Base_quickcheck__With_basic_types");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Bigarray_helpers
//# unitInfo: Requires: Base, Base__Array, Stdlib__Bigarray
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_dim_2 = runtime.caml_ba_dim_2,
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_ba_get_2 = runtime.caml_ba_get_2,
    caml_ba_layout = runtime.caml_ba_layout;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base = global_data.Base,
    Base_Array = global_data.Base__Array,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray;
   function offset(param){return param ? 1 : 0;}
   var Layout = [0, offset];
   function iteri(t, f){
    var
     _s_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _s_),
     _u_ = caml_ba_dim_1(t) - 1 | 0,
     _t_ = 0;
    if(_u_ >= 0){
     var i = _t_;
     for(;;){
      caml_call2(f, i + offset | 0, caml_ba_get_1(t, i + offset | 0));
      var _v_ = i + 1 | 0;
      if(_u_ === i) break;
      i = _v_;
     }
    }
    return 0;
   }
   function init(kind, layout, dim, f){
    var t = caml_call3(Stdlib_Bigarray[19][1], kind, layout, dim);
    iteri
     (t,
      function(i, param){
       return runtime.caml_ba_set_1(t, i, caml_call1(f, i));
      });
    return t;
   }
   function fold(t, init, f){
    var init$0 = [0, init];
    iteri
     (t,
      function(i, param){
       var _r_ = caml_ba_get_1(t, i);
       init$0[1] = caml_call2(f, init$0[1], _r_);
       return 0;
      });
    return init$0[1];
   }
   function to_array(t){
    var
     _p_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _p_),
     _q_ = caml_ba_dim_1(t);
    return caml_call2
            (Base_Array[27],
             _q_,
             function(i){return caml_ba_get_1(t, i + offset | 0);});
   }
   function sexp_of_t(sexp_of_elt, sexp_of_pack, sexp_of_layout, t){
    var x_001 = to_array(t);
    return caml_call2(Base[90], sexp_of_elt, x_001);
   }
   function hash_fold(hash_fold_elt, state, t){
    var _o_ = caml_ba_dim_1(t), state$0 = caml_call2(Base[116], state, _o_);
    return fold(t, state$0, hash_fold_elt);
   }
   function iteri$0(t, f){
    var
     _h_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _h_),
     _j_ = caml_ba_dim_1(t) - 1 | 0,
     _i_ = 0;
    if(_j_ >= 0){
     var i = _i_;
     for(;;){
      var _l_ = caml_ba_dim_2(t) - 1 | 0, _k_ = 0;
      if(_l_ >= 0){
       var j = _k_;
       for(;;){
        caml_call3
         (f,
          i + offset | 0,
          j + offset | 0,
          caml_ba_get_2(t, i + offset | 0, j + offset | 0));
        var _n_ = j + 1 | 0;
        if(_l_ === j) break;
        j = _n_;
       }
      }
      var _m_ = i + 1 | 0;
      if(_j_ === i) break;
      i = _m_;
     }
    }
    return 0;
   }
   function init$0(kind, layout, dim1, dim2, f){
    var t = caml_call4(Stdlib_Bigarray[20][1], kind, layout, dim1, dim2);
    iteri$0
     (t,
      function(i, j, param){
       return runtime.caml_ba_set_2(t, i, j, caml_call2(f, i, j));
      });
    return t;
   }
   function fold$0(t, init, f){
    var init$0 = [0, init];
    iteri$0
     (t,
      function(param, _g_, elt){
       init$0[1] = caml_call2(f, init$0[1], elt);
       return 0;
      });
    return init$0[1];
   }
   function to_array$0(t){
    var
     _d_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _d_),
     _e_ = caml_ba_dim_1(t);
    return caml_call2
            (Base_Array[27],
             _e_,
             function(i){
              var _f_ = caml_ba_dim_2(t);
              return caml_call2
                      (Base_Array[27],
                       _f_,
                       function(j){
                        return caml_ba_get_2(t, i + offset | 0, j + offset | 0);
                       });
             });
   }
   function sexp_of_t$0(sexp_of_elt, sexp_of_pack, sexp_of_layout, t){
    var x_002 = to_array$0(t), _c_ = caml_call1(Base[90], sexp_of_elt);
    return caml_call2(Base[90], _c_, x_002);
   }
   function hash_fold$0(hash_fold_elt, state, t){
    var
     _a_ = caml_ba_dim_1(t),
     state$0 = caml_call2(Base[116], state, _a_),
     _b_ = caml_ba_dim_2(t),
     state$1 = caml_call2(Base[116], state$0, _b_);
    return fold$0(t, state$1, hash_fold_elt);
   }
   var
    Base_quickcheck_Bigarray_helpe =
      [0,
       Layout,
       [0, sexp_of_t, init, iteri, fold, to_array, hash_fold],
       [0, sexp_of_t$0, init$0, iteri$0, fold$0, to_array$0, hash_fold$0]];
   runtime.caml_register_global
    (3, Base_quickcheck_Bigarray_helpe, "Base_quickcheck__Bigarray_helpers");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Observer0
//# unitInfo: Requires: Base, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base = global_data.Base,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    _a_ = [0, "size"],
    cst_Base_quickcheck_Observer_o =
      "Base_quickcheck.Observer.observe: size < 0";
   function create(f){return f;}
   function observe(t, x, size, hash){
    if(0 <= size) return caml_call3(t, x, size, hash);
    var
     _c_ = [0, [1, [0, _a_, [0, caml_call1(Base[119], size), 0]]], 0],
     _d_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Observer_o),
         _c_]];
    return caml_call1(Base[202], _d_);
   }
   function opaque(param, _b_, hash){return hash;}
   var Base_quickcheck_Observer0 = [0, opaque, create, observe];
   runtime.caml_register_global
    (4, Base_quickcheck_Observer0, "Base_quickcheck__Observer0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Generator
//# unitInfo: Requires: Assert_failure, Base, Base__Applicative, Base__Array, Base__Bytes, Base__Char, Base__Either, Base__Error, Base__Float, Base__Hash, Base__Int, Base__Int32, Base__Int63, Base__Int64, Base__Lazy, Base__List, Base__Map, Base__Monad, Base__Nativeint, Base__Option, Base__Sequence, Base__Set, Base__Staged, Base__String, Base_quickcheck__Bigarray_helpers, Base_quickcheck__Observer0, CamlinternalLazy, Sexplib0__Sexp_conv, Splittable_random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lower_bound = "lower_bound",
    cst_src_generator_ml = "src/generator.ml",
    cst_upper_bound = "upper_bound",
    cst_weight = "weight",
    caml_check_bound = runtime.caml_check_bound,
    caml_div = runtime.caml_div,
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_div = runtime.caml_int64_div,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_xor = runtime.caml_int64_xor,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_notequal = runtime.caml_notequal,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Base_Map = global_data.Base__Map,
    Base_Sequence = global_data.Base__Sequence,
    Base_Array = global_data.Base__Array,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Set = global_data.Base__Set,
    Base_List = global_data.Base__List,
    Base_String = global_data.Base__String,
    Base_Float = global_data.Base__Float,
    Splittable_random = global_data.Splittable_random,
    Base = global_data.Base,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Int63 = global_data.Base__Int63,
    Base_Char = global_data.Base__Char,
    Base_Lazy = global_data.Base__Lazy,
    Base_Int = global_data.Base__Int,
    Base_Either = global_data.Base__Either,
    Base_Option = global_data.Base__Option,
    Assert_failure = global_data.Assert_failure,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Error = global_data.Base__Error,
    Base_Hash = global_data.Base__Hash,
    Base_quickcheck_Observer0 = global_data.Base_quickcheck__Observer0,
    Base_Staged = global_data.Base__Staged,
    Base_Applicative = global_data.Base__Applicative,
    Base_Monad = global_data.Base__Monad,
    Base_Int32 = global_data.Base__Int32,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_Bytes = global_data.Base__Bytes,
    _a_ = [0, "size"],
    cst_Base_quickcheck_Generator_ =
      "Base_quickcheck.Generator.generate: size < 0";
   function create(f){return caml_call1(Base_Staged[1], f);}
   function generate(t, size, random){
    if(0 <= size) return caml_call3(Base_Staged[2], t, size, random);
    var
     _b3_ = [0, [1, [0, _a_, [0, caml_call1(Base[119], size), 0]]], 0],
     _b4_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_),
         _b3_]];
    return caml_call1(Base[202], _b4_);
   }
   var size = create(function(size, param){return size;});
   function fn(dom, rng){
    return create
            (function(size, random){
              var random$0 = caml_call1(Splittable_random[1][5], random);
              return function(x){
               var
                _b1_ = caml_call1(Base_Hash[7], 0),
                hash =
                  caml_call4(Base_quickcheck_Observer0[3], dom, x, size, _b1_),
                random = caml_call1(Splittable_random[1][4], random$0),
                _b2_ = caml_call1(Base_Hash[9], hash);
               caml_call2(Splittable_random[1][3], random, _b2_);
               return generate(rng, size, random);};
             });
   }
   function with_size(t, size){
    return create(function(param, random){return generate(t, size, random);});
   }
   function perturb(t, salt){
    return create
            (function(size, random){
              caml_call2(Splittable_random[1][3], random, salt);
              return generate(t, size, random);
             });
   }
   function filter_map(t, f){
    function loop(size, random){
     var size$0 = size;
     for(;;){
      var x = generate(t, size$0, random), match = caml_call1(f, x);
      if(match){var y = match[1]; return y;}
      var size$1 = size$0 + 1 | 0;
      size$0 = size$1;
     }
    }
    return create(loop);
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function return$0(x){return create(function(param, _b0_){return x;});}
   function map(t, f){
    return create
            (function(size, random){
              return caml_call1(f, generate(t, size, random));
             });
   }
   function apply(tf, tx){
    return create
            (function(size, random){
              var
               f = generate(tf, size, random),
               x = generate(tx, size, random);
              return caml_call1(f, x);
             });
   }
   function bind(t, f){
    return create
            (function(size, random){
              var x = generate(t, size, random);
              return generate(caml_call1(f, x), size, random);
             });
   }
   function all(list){
    return create
            (function(size, random){
              return caml_call2
                      (Base_List[76],
                       list,
                       function(_bZ_){return generate(_bZ_, size, random);});
             });
   }
   function all_unit(list){
    return create
            (function(size, random){
              return caml_call2
                      (Base_List[9],
                       list,
                       function(_bY_){return generate(_bY_, size, random);});
             });
   }
   var
    map$0 = [0, -198771759, map],
    For_applicative =
      caml_call1(Base_Applicative[5], [0, return$0, apply, map$0]),
    both = For_applicative[3],
    map2 = For_applicative[9],
    map3 = For_applicative[10],
    include = For_applicative[13],
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    map$1 = [0, -198771759, map],
    For_monad = caml_call1(Base_Monad[1], [0, bind, return$0, map$1]),
    ignore_m = For_monad[8],
    join = For_monad[7],
    include$0 = For_monad[3],
    symbol_bind = include$0[1],
    symbol_map = include$0[2],
    cst_Base_quickcheck_Generator_$0 =
      "Base_quickcheck.Generator.of_list: empty list",
    cst_Base_quickcheck_Generator_$1 =
      "Base_quickcheck.Generator.of_weighted_list: empty list",
    _b_ = [0, cst_weight],
    cst_Base_quickcheck_Generator_$2 =
      "Base_quickcheck.Generator.of_weighted_list: weight is not finite",
    _c_ = [0, cst_weight],
    cst_Base_quickcheck_Generator_$3 =
      "Base_quickcheck.Generator.of_weighted_list: weight is negative",
    cst_Base_quickcheck_Generator_$4 =
      "Base_quickcheck.Generator.of_weighted_list: total weight is zero",
    _d_ = [0, cst_src_generator_ml, 160, 14],
    cst_Base_quickcheck_Generator_$5 =
      "Base_quickcheck.Generator.weighted_recursive_union: lists must be non-empty",
    _e_ = [0, cst_src_generator_ml, 225, 6],
    _f_ = [0, cst_src_generator_ml, 198, 4];
   function of_list(list){
    if(caml_call1(Base_List[8], list)){
     var
      _bX_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$0);
     caml_call1(Base_Error[30], _bX_);
    }
    var
     array = caml_call1(Base_Array[39], list),
     hi = array.length - 2 | 0,
     lo = 0;
    return create
            (function(param, random){
              var index = caml_call3(Splittable_random[3], random, lo, hi);
              return caml_check_bound(array, index)[1 + index];
             });
   }
   function union(list){return caml_call1(join, of_list(list));}
   function of_weighted_list(alist){
    if(caml_call1(Base_List[8], alist)){
     var
      _bR_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$1);
     caml_call1(Base_Error[30], _bR_);
    }
    var
     match = caml_call1(Base_List[92], alist),
     values = match[2],
     weights = match[1],
     value_array = caml_call1(Base_Array[39], values),
     array =
       caml_call2
        (Base_Array[27], value_array.length - 1, function(param){return 0.;}),
     sum =
       caml_call3
        (Base_List[99],
         weights,
         0.,
         function(index, acc, weight){
          if(1 - caml_call1(Base_Float[84], weight)){
           var
            _bT_ =
              [0, [1, [0, _b_, [0, caml_call1(Base[112], weight), 0]]], 0],
            _bU_ =
              [1,
               [0,
                caml_call1
                 (Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$2),
                _bT_]];
           caml_call1(Base_Error[30], _bU_);
          }
          if(caml_call2(Base_Float[13], weight, 0.)){
           var
            _bV_ =
              [0, [1, [0, _c_, [0, caml_call1(Base[112], weight), 0]]], 0],
            _bW_ =
              [1,
               [0,
                caml_call1
                 (Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$3),
                _bV_]];
           caml_call1(Base_Error[30], _bW_);
          }
          var cumulative = caml_call2(Base[190], acc, weight);
          runtime.caml_array_set(array, index, cumulative);
          return cumulative;
         });
    if(caml_call2(Base_Float[10], sum, 0.)){
     var
      _bS_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$4);
     caml_call1(Base_Error[30], _bS_);
    }
    return create
            (function(param, random){
              var
               choice = caml_call3(Splittable_random[8], random, 0., sum),
               match =
                 caml_call6
                  (Base_Array[5],
                   0,
                   0,
                   array,
                   Base_Float[16],
                   926943384,
                   choice);
              if(! match)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
              var index = match[1];
              return caml_check_bound(value_array, index)[1 + index];
             });
   }
   function weighted_union(alist){
    return caml_call1(join, of_weighted_list(alist));
   }
   function of_lazy(lazy_t){
    return create
            (function(size, random){
              var
               _bP_ = caml_obj_tag(lazy_t),
               _bQ_ =
                 250 === _bP_
                  ? lazy_t[1]
                  : 246
                    === _bP_
                    ? caml_call1(CamlinternalLazy[2], lazy_t)
                    : lazy_t;
              return generate(_bQ_, size, random);
             });
   }
   function fixed_point(of_generator){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246,
       function(param){return caml_call1(of_generator, of_lazy(lazy_t));}]);
    var _bO_ = caml_obj_tag(lazy_t);
    return 250 === _bO_
            ? lazy_t[1]
            : 246 === _bO_ ? caml_call1(CamlinternalLazy[2], lazy_t) : lazy_t;
   }
   function weighted_recursive_union(nonrec_list, f){
    return fixed_point
            (function(self){
              var
               _bK_ = caml_call1(f, self),
               rec_list =
                 caml_call2
                  (Base_List[76],
                   _bK_,
                   function(param){
                    var t = param[2], w = param[1];
                    return [0,
                            w,
                            caml_call2
                             (For_monad[11][4][2],
                              size,
                              function(n){return with_size(t, n - 1 | 0);})];
                   }),
               _bL_ = caml_call1(Base_List[8], nonrec_list),
               _bM_ = _bL_ || caml_call1(Base_List[8], rec_list);
              if(_bM_){
               var
                _bN_ =
                  caml_call1
                   (Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$5);
               caml_call1(Base[202], _bN_);
              }
              var
               nonrec_gen = weighted_union(nonrec_list),
               rec_gen =
                 weighted_union(caml_call2(Base[178], nonrec_list, rec_list));
              return caml_call2
                      (For_monad[11][4][2],
                       size,
                       function(param){return 0 === param ? nonrec_gen : rec_gen;});
             });
   }
   function recursive_union(nonrec_list, f){
    function weighted(list){
     return caml_call2(Base_List[76], list, function(t){return [0, 1., t];});
    }
    return weighted_recursive_union
            (weighted(nonrec_list),
             function(self){return weighted(caml_call1(f, self));});
   }
   function sizes(opt, _bB_, param){
    if(opt) var sth = opt[1], min_length = sth; else var min_length = 0;
    if(_bB_)
     var sth$0 = _bB_[1], max_length = sth$0;
    else
     var max_length = Base_Int[60];
    return create
            (function(size, random){
              if(min_length > max_length)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
              var
               upper_bound = min_length + size | 0,
               max_length$0 =
                 min_length <= upper_bound
                  ? caml_call2(Base[189], max_length, upper_bound)
                  : max_length,
               len =
                 caml_call3
                  (Splittable_random[10][1], random, min_length, max_length$0);
              if(0 === len) return 0;
              var
               sizes =
                 caml_call2(Base_Array[27], len, function(param){return 0;}),
               remaining = size - (len - min_length | 0) | 0,
               max_index = len - 1 | 0,
               _bC_ = 1;
              if(remaining >= 1){
               var for$0 = _bC_;
               for(;;){
                var
                 index =
                   caml_call3(Splittable_random[10][1], random, 0, max_index);
                sizes[1 + index] =
                 caml_check_bound(sizes, index)[1 + index] + 1 | 0;
                var _bG_ = for$0 + 1 | 0;
                if(remaining === for$0) break;
                for$0 = _bG_;
               }
              }
              var _bE_ = max_index - 1 | 0, _bD_ = 0;
              if(_bE_ >= 0){
               var i = _bD_;
               for(;;){
                var
                 j = caml_call3(Splittable_random[3], random, i, max_index);
                caml_call3(Base_Array[74], sizes, i, j);
                var _bF_ = i + 1 | 0;
                if(_bE_ === i) break;
                i = _bF_;
               }
              }
              if
               ((caml_call3
                 (Base_Array[16],
                  [0,
                   Base_Int[74],
                   function(_bJ_, _bI_){return _bJ_ + _bI_ | 0;}],
                  sizes,
                  function(_bH_){return _bH_;})
                + (len - min_length | 0)
                | 0)
                === size)
               return caml_call1(Base_Array[19], sizes);
              throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
             });
   }
   var
    unit = caml_call1(For_monad[11][1], 0),
    bool =
      create
       (function(param, random){
         return caml_call1(Splittable_random[2], random);
        }),
    _g_ = [0, 1],
    _h_ = [0, 0];
   function option(value_t){
    var _bA_ = [0, map(value_t, Base_Option[20]), 0];
    return union([0, caml_call1(For_monad[11][1], 0), _bA_]);
   }
   function either(fst_t, snd_t){
    var _bz_ = [0, map(snd_t, Base_Either[18]), 0];
    return union([0, map(fst_t, Base_Either[17]), _bz_]);
   }
   function result(ok_t, err_t){
    return map
            (either(ok_t, err_t),
             function(param){
              if(0 === param[0]){var ok = param[1]; return [0, ok];}
              var err = param[1];
              return [1, err];
             });
   }
   function list_generic(min_length, max_length, elt_gen){
    var _by_ = sizes(min_length, max_length, 0);
    return caml_call2
            (For_monad[11][4][2],
             _by_,
             function(sizes){
              return all
                      (caml_call2
                        (Base_List[76],
                         sizes,
                         function(size){return with_size(elt_gen, size);}));
             });
   }
   function list(elt_gen){return list_generic(0, 0, elt_gen);}
   function list_non_empty(elt_gen){return list_generic(_g_, 0, elt_gen);}
   function list_with_length(elt_gen, length){
    return list_generic([0, length], [0, length], elt_gen);
   }
   function list_filtered(elts){
    var
     elts$0 = caml_call1(Base_Array[39], elts),
     length_of_input = elts$0.length - 1;
    return create
            (function(param, random){
              var
               length_of_output =
                 caml_call3(Splittable_random[3], random, 0, length_of_input),
               indices =
                 caml_call2
                  (Base_Array[27],
                   length_of_input,
                   function(_bx_){return _bx_;}),
               _bu_ = length_of_output - 1 | 0,
               _bt_ = 0;
              if(_bu_ >= 0){
               var i = _bt_;
               for(;;){
                var
                 j =
                   caml_call3
                    (Splittable_random[3], random, i, length_of_input - 1 | 0);
                caml_call3(Base_Array[74], indices, i, j);
                var _bv_ = i + 1 | 0;
                if(_bu_ === i) break;
                i = _bv_;
               }
              }
              caml_call4
               (Base_Array[49],
                _h_,
                [0, length_of_output],
                indices,
                Base_Int[13]);
              return caml_call2
                      (Base_List[123],
                       length_of_output,
                       function(i){
                        var _bw_ = caml_check_bound(indices, i)[1 + i];
                        return caml_check_bound(elts$0, _bw_)[1 + _bw_];
                       });
             });
   }
   function list_permutations(list){
    return create
            (function(param, random){
              var
               array = caml_call1(Base_Array[39], list),
               _br_ = array.length - 2 | 0,
               _bq_ = 1;
              if(_br_ >= 1){
               var i = _bq_;
               for(;;){
                var j = caml_call3(Splittable_random[3], random, 0, i);
                caml_call3(Base_Array[74], array, i, j);
                var _bs_ = i + 1 | 0;
                if(_br_ === i) break;
                i = _bs_;
               }
              }
              return caml_call1(Base_Array[19], array);
             });
   }
   function array(t){var _bp_ = Base_Array[39]; return map(list(t), _bp_);}
   function ref(t){return map(t, function(_bo_){return [0, _bo_];});}
   function lazy_t(t){return map(t, Base_Lazy[21]);}
   function char_uniform_inclusive(lo, hi){
    return create
            (function(param, random){
              var
               _bl_ = caml_call1(Base_Char[29], hi),
               _bm_ = caml_call1(Base_Char[29], lo),
               _bn_ = caml_call3(Splittable_random[3], random, _bm_, _bl_);
              return caml_call1(Base_Char[32], _bn_);
             });
   }
   var
    char_uppercase = char_uniform_inclusive(65, 90),
    char_lowercase = char_uniform_inclusive(97, 122),
    char_digit = char_uniform_inclusive(48, 57),
    char_print_uniform = char_uniform_inclusive(32, 126),
    char_uniform = char_uniform_inclusive(Base_Char[50], Base_Char[51]),
    char_alpha = union([0, char_lowercase, [0, char_uppercase, 0]]),
    char_alphanum =
      weighted_union([0, [0, 52., char_alpha], [0, [0, 10., char_digit], 0]]),
    char_whitespace =
      of_list(caml_call2(Base_List[54], Base_Char[1], Base_Char[42])),
    char_print =
      weighted_union
       ([0, [0, 10., char_alphanum], [0, [0, 1., char_print_uniform], 0]]),
    _i_ = [0, [0, 1., caml_call1(For_monad[11][1], Base_Char[51])], 0],
    char$0 =
      weighted_union
       ([0,
         [0, 100., char_print],
         [0,
          [0, 10., char_uniform],
          [0, [0, 1., caml_call1(For_monad[11][1], Base_Char[50])], _i_]]]);
   function small_int(allow_zero){
    return create
            (function(size, random){
              var
               lower_bound = allow_zero ? 0 : 1,
               upper_bound = size + 1 | 0,
               weighted_low =
                 caml_call3
                  (Splittable_random[10][1],
                   random,
                   0,
                   upper_bound - lower_bound | 0),
               weighted_high = upper_bound - weighted_low | 0;
              return weighted_high;
             });
   }
   var
    small_positive_or_zero_int = small_int(1),
    small_strictly_positive_int = small_int(0);
   function For_integer(Integer){
    function uniform_inclusive(lo, hi){
     return create
             (function(param, random){
               return caml_call3(Integer[96], random, lo, hi);
              });
    }
    function log_uniform_inclusive(lo, hi){
     return create
             (function(param, random){
               return caml_call3(Integer[97], random, lo, hi);
              });
    }
    function non_uniform(f, lo, hi){
     var
      _bj_ = [0, [0, 0.9, caml_call2(f, lo, hi)], 0],
      _bk_ = [0, [0, 0.05, caml_call1(For_monad[11][1], hi)], _bj_];
     return weighted_union
             ([0, [0, 0.05, caml_call1(For_monad[11][1], lo)], _bk_]);
    }
    function inclusive(_bh_, _bi_){
     return non_uniform(uniform_inclusive, _bh_, _bi_);
    }
    function log_inclusive(_bf_, _bg_){
     return non_uniform(log_uniform_inclusive, _bf_, _bg_);
    }
    var
     uniform_all = uniform_inclusive(Integer[85], Integer[84]),
     let_syntax_004 =
       non_uniform(log_uniform_inclusive, Integer[38], Integer[84]),
     _be_ = caml_call2(For_monad[11][4][4], bool, let_syntax_004),
     all =
       caml_call2
        (For_monad[11][4][3],
         _be_,
         function(param){
          var magnitude = param[2], negative = param[1];
          return negative ? caml_call1(Integer[70], magnitude) : magnitude;
         });
    return [0,
            uniform_inclusive,
            log_uniform_inclusive,
            ,
            inclusive,
            log_inclusive,
            uniform_all,
            all];
   }
   var
    t_sexp_grammar = Base_Int[1],
    of_float = Base_Int[2],
    to_float = Base_Int[3],
    of_int_exn = Base_Int[4],
    to_int_exn = Base_Int[5],
    hash_fold_t = Base_Int[6],
    hash = Base_Int[7],
    t_of_sexp = Base_Int[8],
    sexp_of_t = Base_Int[9],
    of_string = Base_Int[10],
    to_string = Base_Int[11],
    equal = Base_Int[12],
    compare = Base_Int[13],
    min = Base_Int[14],
    max = Base_Int[15],
    ascending = Base_Int[16],
    descending = Base_Int[17],
    between = Base_Int[18],
    clamp_exn = Base_Int[19],
    clamp = Base_Int[20],
    comparator = Base_Int[21],
    pp = Base_Int[22],
    hashable = Base_Int[23],
    is_positive = Base_Int[24],
    is_non_negative = Base_Int[25],
    is_negative = Base_Int[26],
    is_non_positive = Base_Int[27],
    sign = Base_Int[28],
    invariant = Base_Int[29],
    Hex = Base_Int[30],
    to_string_hum = Base_Int[31],
    one = Base_Int[32],
    minus_one = Base_Int[33],
    rem = Base_Int[34],
    round = Base_Int[35],
    round_towards_zero = Base_Int[36],
    round_down = Base_Int[37],
    round_up = Base_Int[38],
    round_nearest = Base_Int[39],
    succ = Base_Int[40],
    pred = Base_Int[41],
    pow = Base_Int[42],
    bit_and = Base_Int[43],
    bit_or = Base_Int[44],
    bit_xor = Base_Int[45],
    bit_not = Base_Int[46],
    popcount = Base_Int[47],
    shift_left = Base_Int[48],
    shift_right = Base_Int[49],
    decr = Base_Int[50],
    incr = Base_Int[51],
    of_int32_exn = Base_Int[52],
    to_int32_exn = Base_Int[53],
    of_int64_exn = Base_Int[54],
    to_int64 = Base_Int[55],
    of_nativeint_exn = Base_Int[56],
    to_nativeint_exn = Base_Int[57],
    of_float_unchecked = Base_Int[58],
    num_bits = Base_Int[59],
    max_value = Base_Int[60],
    min_value = Base_Int[61],
    shift_right_logical = Base_Int[62],
    ceil_pow2 = Base_Int[63],
    floor_pow2 = Base_Int[64],
    ceil_log2 = Base_Int[65],
    floor_log2 = Base_Int[66],
    is_pow2 = Base_Int[67],
    clz = Base_Int[68],
    ctz = Base_Int[69],
    O = Base_Int[70],
    symbol$2 = Base_Int[71],
    lnot = Base_Int[72],
    abs = Base_Int[73],
    zero = Base_Int[74],
    symbol$3 = Base_Int[75],
    symbol$4 = Base_Int[76],
    symbol$5 = Base_Int[77],
    uniform = Splittable_random[3],
    log_uniform = Splittable_random[10][1],
    For_int =
      For_integer
       ([0,
         t_sexp_grammar,
         of_float,
         to_float,
         of_int_exn,
         to_int_exn,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         function(_bd_, _bc_){return _bc_ <= _bd_ ? 1 : 0;},
         function(_bb_, _ba_){return _bb_ <= _ba_ ? 1 : 0;},
         function(_a$_, _a__){return _a$_ === _a__ ? 1 : 0;},
         function(_a9_, _a8_){return _a8_ < _a9_ ? 1 : 0;},
         function(_a7_, _a6_){return _a7_ < _a6_ ? 1 : 0;},
         function(_a5_, _a4_){return _a5_ !== _a4_ ? 1 : 0;},
         equal,
         compare,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator,
         pp,
         hashable,
         is_positive,
         is_non_negative,
         is_negative,
         is_non_positive,
         sign,
         invariant,
         Hex,
         to_string_hum,
         zero,
         one,
         minus_one,
         function(_a3_, _a2_){return _a3_ + _a2_ | 0;},
         function(_a1_, _a0_){return _a1_ - _a0_ | 0;},
         caml_mul,
         symbol$2,
         function(_aZ_){return - _aZ_ | 0;},
         function(_aY_){return - _aY_ | 0;},
         symbol$4,
         symbol$3,
         caml_div,
         rem,
         symbol$5,
         function(_aX_, _aW_){return _aX_ & _aW_;},
         function(_aV_, _aU_){return _aV_ | _aU_;},
         function(_aT_, _aS_){return _aT_ ^ _aS_;},
         lnot,
         function(_aR_, _aQ_){return _aR_ << _aQ_;},
         function(_aP_, _aO_){return _aP_ >> _aO_;},
         round,
         round_towards_zero,
         round_down,
         round_up,
         round_nearest,
         abs,
         succ,
         pred,
         pow,
         bit_and,
         bit_or,
         bit_xor,
         bit_not,
         popcount,
         shift_left,
         shift_right,
         decr,
         incr,
         of_int32_exn,
         to_int32_exn,
         of_int64_exn,
         to_int64,
         of_nativeint_exn,
         to_nativeint_exn,
         of_float_unchecked,
         num_bits,
         max_value,
         min_value,
         function(_aN_, _aM_){return _aN_ >>> _aM_ | 0;},
         shift_right_logical,
         ceil_pow2,
         floor_pow2,
         ceil_log2,
         floor_log2,
         is_pow2,
         clz,
         ctz,
         [0,
          function(_aL_, _aK_){return _aL_ + _aK_ | 0;},
          function(_aJ_, _aI_){return _aJ_ - _aI_ | 0;},
          caml_mul,
          caml_div,
          function(_aH_){return - _aH_ | 0;},
          O[1],
          function(_aG_, _aF_){return _aF_ <= _aG_ ? 1 : 0;},
          function(_aE_, _aD_){return _aE_ <= _aD_ ? 1 : 0;},
          function(_aC_, _aB_){return _aC_ === _aB_ ? 1 : 0;},
          function(_aA_, _az_){return _az_ < _aA_ ? 1 : 0;},
          function(_ay_, _ax_){return _ay_ < _ax_ ? 1 : 0;},
          function(_aw_, _av_){return _aw_ !== _av_ ? 1 : 0;},
          O[3],
          function(_au_){return - _au_ | 0;},
          O[4],
          O[5],
          O[6],
          O[7],
          function(_at_, _as_){return _at_ & _as_;},
          function(_ar_, _aq_){return _ar_ | _aq_;},
          function(_ap_, _ao_){return _ap_ ^ _ao_;},
          O[2],
          function(_an_, _am_){return _an_ << _am_;},
          function(_al_, _ak_){return _al_ >> _ak_;},
          function(_aj_, _ai_){return _aj_ >>> _ai_ | 0;}],
         uniform,
         log_uniform]),
    int$0 = For_int[7],
    int_uniform = For_int[6],
    int_inclusive = For_int[4],
    int_uniform_inclusive = For_int[1],
    int_log_inclusive = For_int[5],
    int_log_uniform_inclusive = For_int[2],
    t_sexp_grammar$0 = Base_Int32[1],
    of_float$0 = Base_Int32[2],
    to_float$0 = Base_Int32[3],
    of_int_exn$0 = Base_Int32[4],
    to_int_exn$0 = Base_Int32[5],
    hash_fold_t$0 = Base_Int32[6],
    hash$0 = Base_Int32[7],
    t_of_sexp$0 = Base_Int32[8],
    sexp_of_t$0 = Base_Int32[9],
    of_string$0 = Base_Int32[10],
    to_string$0 = Base_Int32[11],
    symbol$6 = Base_Int32[12],
    symbol$7 = Base_Int32[13],
    symbol$8 = Base_Int32[14],
    symbol$9 = Base_Int32[15],
    symbol$10 = Base_Int32[16],
    symbol$11 = Base_Int32[17],
    equal$0 = Base_Int32[18],
    compare$0 = Base_Int32[19],
    min$0 = Base_Int32[20],
    max$0 = Base_Int32[21],
    ascending$0 = Base_Int32[22],
    descending$0 = Base_Int32[23],
    between$0 = Base_Int32[24],
    clamp_exn$0 = Base_Int32[25],
    clamp$0 = Base_Int32[26],
    comparator$0 = Base_Int32[27],
    pp$0 = Base_Int32[28],
    hashable$0 = Base_Int32[29],
    is_positive$0 = Base_Int32[30],
    is_non_negative$0 = Base_Int32[31],
    is_negative$0 = Base_Int32[32],
    is_non_positive$0 = Base_Int32[33],
    sign$0 = Base_Int32[34],
    invariant$0 = Base_Int32[35],
    Hex$0 = Base_Int32[36],
    to_string_hum$0 = Base_Int32[37],
    zero$0 = Base_Int32[38],
    one$0 = Base_Int32[39],
    minus_one$0 = Base_Int32[40],
    symbol$12 = Base_Int32[41],
    symbol$13 = Base_Int32[42],
    symbol$14 = Base_Int32[43],
    symbol$15 = Base_Int32[44],
    neg = Base_Int32[45],
    symbol$16 = Base_Int32[46],
    symbol$17 = Base_Int32[47],
    symbol$18 = Base_Int32[48],
    symbol$19 = Base_Int32[49],
    rem$0 = Base_Int32[50],
    symbol$20 = Base_Int32[51],
    land = Base_Int32[52],
    lor = Base_Int32[53],
    lxor = Base_Int32[54],
    lnot$0 = Base_Int32[55],
    lsl = Base_Int32[56],
    asr = Base_Int32[57],
    round$0 = Base_Int32[58],
    round_towards_zero$0 = Base_Int32[59],
    round_down$0 = Base_Int32[60],
    round_up$0 = Base_Int32[61],
    round_nearest$0 = Base_Int32[62],
    abs$0 = Base_Int32[63],
    succ$0 = Base_Int32[64],
    pred$0 = Base_Int32[65],
    pow$0 = Base_Int32[66],
    bit_and$0 = Base_Int32[67],
    bit_or$0 = Base_Int32[68],
    bit_xor$0 = Base_Int32[69],
    bit_not$0 = Base_Int32[70],
    popcount$0 = Base_Int32[71],
    shift_left$0 = Base_Int32[72],
    shift_right$0 = Base_Int32[73],
    decr$0 = Base_Int32[74],
    incr$0 = Base_Int32[75],
    of_int32_exn$0 = Base_Int32[76],
    to_int32_exn$0 = Base_Int32[77],
    of_int64_exn$0 = Base_Int32[78],
    to_int64$0 = Base_Int32[79],
    of_nativeint_exn$0 = Base_Int32[80],
    to_nativeint_exn$0 = Base_Int32[81],
    of_float_unchecked$0 = Base_Int32[82],
    num_bits$0 = Base_Int32[83],
    max_value$0 = Base_Int32[84],
    min_value$0 = Base_Int32[85],
    lsr = Base_Int32[86],
    shift_right_logical$0 = Base_Int32[87],
    ceil_pow2$0 = Base_Int32[88],
    floor_pow2$0 = Base_Int32[89],
    ceil_log2$0 = Base_Int32[90],
    floor_log2$0 = Base_Int32[91],
    is_pow2$0 = Base_Int32[92],
    clz$0 = Base_Int32[93],
    ctz$0 = Base_Int32[94],
    O$0 = Base_Int32[95],
    uniform$0 = Splittable_random[4],
    log_uniform$0 = Splittable_random[10][2],
    For_int32 =
      For_integer
       ([0,
         t_sexp_grammar$0,
         of_float$0,
         to_float$0,
         of_int_exn$0,
         to_int_exn$0,
         hash_fold_t$0,
         hash$0,
         t_of_sexp$0,
         sexp_of_t$0,
         of_string$0,
         to_string$0,
         symbol$6,
         symbol$7,
         symbol$8,
         symbol$9,
         symbol$10,
         symbol$11,
         equal$0,
         compare$0,
         min$0,
         max$0,
         ascending$0,
         descending$0,
         between$0,
         clamp_exn$0,
         clamp$0,
         comparator$0,
         pp$0,
         hashable$0,
         is_positive$0,
         is_non_negative$0,
         is_negative$0,
         is_non_positive$0,
         sign$0,
         invariant$0,
         Hex$0,
         to_string_hum$0,
         zero$0,
         one$0,
         minus_one$0,
         symbol$12,
         symbol$13,
         symbol$14,
         symbol$15,
         neg,
         symbol$16,
         symbol$17,
         symbol$18,
         symbol$19,
         rem$0,
         symbol$20,
         land,
         lor,
         lxor,
         lnot$0,
         lsl,
         asr,
         round$0,
         round_towards_zero$0,
         round_down$0,
         round_up$0,
         round_nearest$0,
         abs$0,
         succ$0,
         pred$0,
         pow$0,
         bit_and$0,
         bit_or$0,
         bit_xor$0,
         bit_not$0,
         popcount$0,
         shift_left$0,
         shift_right$0,
         decr$0,
         incr$0,
         of_int32_exn$0,
         to_int32_exn$0,
         of_int64_exn$0,
         to_int64$0,
         of_nativeint_exn$0,
         to_nativeint_exn$0,
         of_float_unchecked$0,
         num_bits$0,
         max_value$0,
         min_value$0,
         lsr,
         shift_right_logical$0,
         ceil_pow2$0,
         floor_pow2$0,
         ceil_log2$0,
         floor_log2$0,
         is_pow2$0,
         clz$0,
         ctz$0,
         O$0,
         uniform$0,
         log_uniform$0]),
    int32 = For_int32[7],
    int32_uniform = For_int32[6],
    int32_inclusive = For_int32[4],
    int32_uniform_inclusive = For_int32[1],
    int32_log_inclusive = For_int32[5],
    int32_log_uniform_inclusive = For_int32[2],
    t_sexp_grammar$1 = Base_Int63[1],
    of_float$1 = Base_Int63[2],
    to_float$1 = Base_Int63[3],
    of_int_exn$1 = Base_Int63[4],
    to_int_exn$1 = Base_Int63[5],
    hash_fold_t$1 = Base_Int63[6],
    hash$1 = Base_Int63[7],
    t_of_sexp$1 = Base_Int63[8],
    sexp_of_t$1 = Base_Int63[9],
    of_string$1 = Base_Int63[10],
    to_string$1 = Base_Int63[11],
    symbol$21 = Base_Int63[12],
    symbol$22 = Base_Int63[13],
    symbol$23 = Base_Int63[14],
    symbol$24 = Base_Int63[15],
    symbol$25 = Base_Int63[16],
    symbol$26 = Base_Int63[17],
    equal$1 = Base_Int63[18],
    compare$1 = Base_Int63[19],
    min$1 = Base_Int63[20],
    max$1 = Base_Int63[21],
    ascending$1 = Base_Int63[22],
    descending$1 = Base_Int63[23],
    between$1 = Base_Int63[24],
    clamp_exn$1 = Base_Int63[25],
    clamp$1 = Base_Int63[26],
    comparator$1 = Base_Int63[27],
    pp$1 = Base_Int63[28],
    hashable$1 = Base_Int63[29],
    is_positive$1 = Base_Int63[30],
    is_non_negative$1 = Base_Int63[31],
    is_negative$1 = Base_Int63[32],
    is_non_positive$1 = Base_Int63[33],
    sign$1 = Base_Int63[34],
    invariant$1 = Base_Int63[35],
    Hex$1 = Base_Int63[36],
    to_string_hum$1 = Base_Int63[37],
    zero$1 = Base_Int63[38],
    one$1 = Base_Int63[39],
    minus_one$1 = Base_Int63[40],
    symbol$27 = Base_Int63[41],
    symbol$28 = Base_Int63[42],
    symbol$29 = Base_Int63[43],
    symbol$30 = Base_Int63[44],
    neg$0 = Base_Int63[45],
    symbol$31 = Base_Int63[46],
    symbol$32 = Base_Int63[47],
    symbol$33 = Base_Int63[48],
    symbol$34 = Base_Int63[49],
    rem$1 = Base_Int63[50],
    symbol$35 = Base_Int63[51],
    land$0 = Base_Int63[52],
    lor$0 = Base_Int63[53],
    lxor$0 = Base_Int63[54],
    lnot$1 = Base_Int63[55],
    lsl$0 = Base_Int63[56],
    asr$0 = Base_Int63[57],
    round$1 = Base_Int63[58],
    round_towards_zero$1 = Base_Int63[59],
    round_down$1 = Base_Int63[60],
    round_up$1 = Base_Int63[61],
    round_nearest$1 = Base_Int63[62],
    abs$1 = Base_Int63[63],
    succ$1 = Base_Int63[64],
    pred$1 = Base_Int63[65],
    pow$1 = Base_Int63[66],
    bit_and$1 = Base_Int63[67],
    bit_or$1 = Base_Int63[68],
    bit_xor$1 = Base_Int63[69],
    bit_not$1 = Base_Int63[70],
    popcount$1 = Base_Int63[71],
    shift_left$1 = Base_Int63[72],
    shift_right$1 = Base_Int63[73],
    decr$1 = Base_Int63[74],
    incr$1 = Base_Int63[75],
    of_int32_exn$1 = Base_Int63[76],
    to_int32_exn$1 = Base_Int63[77],
    of_int64_exn$1 = Base_Int63[78],
    to_int64$1 = Base_Int63[79],
    of_nativeint_exn$1 = Base_Int63[80],
    to_nativeint_exn$1 = Base_Int63[81],
    of_float_unchecked$1 = Base_Int63[82],
    num_bits$1 = Base_Int63[83],
    max_value$1 = Base_Int63[84],
    min_value$1 = Base_Int63[85],
    lsr$0 = Base_Int63[86],
    shift_right_logical$1 = Base_Int63[87],
    ceil_pow2$1 = Base_Int63[88],
    floor_pow2$1 = Base_Int63[89],
    ceil_log2$1 = Base_Int63[90],
    is_pow2$1 = Base_Int63[91],
    clz$1 = Base_Int63[92],
    ctz$1 = Base_Int63[93],
    O$1 = Base_Int63[94],
    floor_log2$1 = Base_Int63[113],
    uniform$1 = Splittable_random[5],
    log_uniform$1 = Splittable_random[10][3],
    For_int63 =
      For_integer
       ([0,
         t_sexp_grammar$1,
         of_float$1,
         to_float$1,
         of_int_exn$1,
         to_int_exn$1,
         hash_fold_t$1,
         hash$1,
         t_of_sexp$1,
         sexp_of_t$1,
         of_string$1,
         to_string$1,
         symbol$21,
         symbol$22,
         symbol$23,
         symbol$24,
         symbol$25,
         symbol$26,
         equal$1,
         compare$1,
         min$1,
         max$1,
         ascending$1,
         descending$1,
         between$1,
         clamp_exn$1,
         clamp$1,
         comparator$1,
         pp$1,
         hashable$1,
         is_positive$1,
         is_non_negative$1,
         is_negative$1,
         is_non_positive$1,
         sign$1,
         invariant$1,
         Hex$1,
         to_string_hum$1,
         zero$1,
         one$1,
         minus_one$1,
         symbol$27,
         symbol$28,
         symbol$29,
         symbol$30,
         neg$0,
         symbol$31,
         symbol$32,
         symbol$33,
         symbol$34,
         rem$1,
         symbol$35,
         land$0,
         lor$0,
         lxor$0,
         lnot$1,
         lsl$0,
         asr$0,
         round$1,
         round_towards_zero$1,
         round_down$1,
         round_up$1,
         round_nearest$1,
         abs$1,
         succ$1,
         pred$1,
         pow$1,
         bit_and$1,
         bit_or$1,
         bit_xor$1,
         bit_not$1,
         popcount$1,
         shift_left$1,
         shift_right$1,
         decr$1,
         incr$1,
         of_int32_exn$1,
         to_int32_exn$1,
         of_int64_exn$1,
         to_int64$1,
         of_nativeint_exn$1,
         to_nativeint_exn$1,
         of_float_unchecked$1,
         num_bits$1,
         max_value$1,
         min_value$1,
         lsr$0,
         shift_right_logical$1,
         ceil_pow2$1,
         floor_pow2$1,
         ceil_log2$1,
         floor_log2$1,
         is_pow2$1,
         clz$1,
         ctz$1,
         O$1,
         uniform$1,
         log_uniform$1]),
    int63 = For_int63[7],
    int63_uniform = For_int63[6],
    int63_inclusive = For_int63[4],
    int63_uniform_inclusive = For_int63[1],
    int63_log_inclusive = For_int63[5],
    int63_log_uniform_inclusive = For_int63[2],
    t_sexp_grammar$2 = Base_Int64[1],
    of_float$2 = Base_Int64[2],
    to_float$2 = Base_Int64[3],
    of_int_exn$2 = Base_Int64[4],
    to_int_exn$2 = Base_Int64[5],
    hash_fold_t$2 = Base_Int64[6],
    hash$2 = Base_Int64[7],
    t_of_sexp$2 = Base_Int64[8],
    sexp_of_t$2 = Base_Int64[9],
    of_string$2 = Base_Int64[10],
    to_string$2 = Base_Int64[11],
    equal$2 = Base_Int64[12],
    compare$2 = Base_Int64[13],
    min$2 = Base_Int64[14],
    max$2 = Base_Int64[15],
    ascending$2 = Base_Int64[16],
    descending$2 = Base_Int64[17],
    between$2 = Base_Int64[18],
    clamp_exn$2 = Base_Int64[19],
    clamp$2 = Base_Int64[20],
    comparator$2 = Base_Int64[21],
    pp$2 = Base_Int64[22],
    hashable$2 = Base_Int64[23],
    is_positive$2 = Base_Int64[24],
    is_non_negative$2 = Base_Int64[25],
    is_negative$2 = Base_Int64[26],
    is_non_positive$2 = Base_Int64[27],
    sign$2 = Base_Int64[28],
    invariant$2 = Base_Int64[29],
    Hex$2 = Base_Int64[30],
    to_string_hum$2 = Base_Int64[31],
    one$2 = Base_Int64[32],
    minus_one$2 = Base_Int64[33],
    rem$2 = Base_Int64[34],
    round$2 = Base_Int64[35],
    round_towards_zero$2 = Base_Int64[36],
    round_down$2 = Base_Int64[37],
    round_up$2 = Base_Int64[38],
    round_nearest$2 = Base_Int64[39],
    succ$2 = Base_Int64[40],
    pred$2 = Base_Int64[41],
    pow$2 = Base_Int64[42],
    bit_and$2 = Base_Int64[43],
    bit_or$2 = Base_Int64[44],
    bit_xor$2 = Base_Int64[45],
    bit_not$2 = Base_Int64[46],
    popcount$2 = Base_Int64[47],
    shift_left$2 = Base_Int64[48],
    shift_right$2 = Base_Int64[49],
    decr$2 = Base_Int64[50],
    incr$2 = Base_Int64[51],
    of_int32_exn$2 = Base_Int64[52],
    to_int32_exn$2 = Base_Int64[53],
    of_int64_exn$2 = Base_Int64[54],
    to_int64$2 = Base_Int64[55],
    of_nativeint_exn$2 = Base_Int64[56],
    to_nativeint_exn$2 = Base_Int64[57],
    of_float_unchecked$2 = Base_Int64[58],
    num_bits$2 = Base_Int64[59],
    max_value$2 = Base_Int64[60],
    min_value$2 = Base_Int64[61],
    shift_right_logical$2 = Base_Int64[62],
    ceil_pow2$2 = Base_Int64[63],
    floor_pow2$2 = Base_Int64[64],
    ceil_log2$2 = Base_Int64[65],
    floor_log2$2 = Base_Int64[66],
    is_pow2$2 = Base_Int64[67],
    clz$2 = Base_Int64[68],
    ctz$2 = Base_Int64[69],
    O$2 = Base_Int64[70],
    symbol$36 = Base_Int64[71],
    lnot$2 = Base_Int64[72],
    abs$2 = Base_Int64[73],
    zero$2 = Base_Int64[74],
    symbol$37 = Base_Int64[75],
    symbol$38 = Base_Int64[76],
    symbol$39 = Base_Int64[77],
    uniform$2 = Splittable_random[6],
    log_uniform$2 = Splittable_random[10][4],
    For_int64 =
      For_integer
       ([0,
         t_sexp_grammar$2,
         of_float$2,
         to_float$2,
         of_int_exn$2,
         to_int_exn$2,
         hash_fold_t$2,
         hash$2,
         t_of_sexp$2,
         sexp_of_t$2,
         of_string$2,
         to_string$2,
         caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         caml_notequal,
         equal$2,
         compare$2,
         min$2,
         max$2,
         ascending$2,
         descending$2,
         between$2,
         clamp_exn$2,
         clamp$2,
         comparator$2,
         pp$2,
         hashable$2,
         is_positive$2,
         is_non_negative$2,
         is_negative$2,
         is_non_positive$2,
         sign$2,
         invariant$2,
         Hex$2,
         to_string_hum$2,
         zero$2,
         one$2,
         minus_one$2,
         caml_int64_add,
         caml_int64_sub,
         caml_int64_mul,
         symbol$36,
         caml_int64_neg,
         caml_int64_neg,
         symbol$38,
         symbol$37,
         caml_int64_div,
         rem$2,
         symbol$39,
         caml_int64_and,
         caml_int64_or,
         caml_int64_xor,
         lnot$2,
         caml_int64_shift_left,
         caml_int64_shift_right,
         round$2,
         round_towards_zero$2,
         round_down$2,
         round_up$2,
         round_nearest$2,
         abs$2,
         succ$2,
         pred$2,
         pow$2,
         bit_and$2,
         bit_or$2,
         bit_xor$2,
         bit_not$2,
         popcount$2,
         shift_left$2,
         shift_right$2,
         decr$2,
         incr$2,
         of_int32_exn$2,
         to_int32_exn$2,
         of_int64_exn$2,
         to_int64$2,
         of_nativeint_exn$2,
         to_nativeint_exn$2,
         of_float_unchecked$2,
         num_bits$2,
         max_value$2,
         min_value$2,
         caml_int64_shift_right_unsigne,
         shift_right_logical$2,
         ceil_pow2$2,
         floor_pow2$2,
         ceil_log2$2,
         floor_log2$2,
         is_pow2$2,
         clz$2,
         ctz$2,
         [0,
          caml_int64_add,
          caml_int64_sub,
          caml_int64_mul,
          caml_int64_div,
          caml_int64_neg,
          O$2[1],
          caml_greaterequal,
          caml_lessequal,
          caml_equal,
          caml_greaterthan,
          caml_lessthan,
          caml_notequal,
          O$2[3],
          caml_int64_neg,
          O$2[4],
          O$2[5],
          O$2[6],
          O$2[7],
          caml_int64_and,
          caml_int64_or,
          caml_int64_xor,
          O$2[2],
          caml_int64_shift_left,
          caml_int64_shift_right,
          caml_int64_shift_right_unsigne],
         uniform$2,
         log_uniform$2]),
    int64 = For_int64[7],
    int64_uniform = For_int64[6],
    int64_inclusive = For_int64[4],
    int64_uniform_inclusive = For_int64[1],
    int64_log_inclusive = For_int64[5],
    int64_log_uniform_inclusive = For_int64[2],
    t_sexp_grammar$3 = Base_Nativeint[1],
    of_float$3 = Base_Nativeint[2],
    to_float$3 = Base_Nativeint[3],
    of_int_exn$3 = Base_Nativeint[4],
    to_int_exn$3 = Base_Nativeint[5],
    hash_fold_t$3 = Base_Nativeint[6],
    hash$3 = Base_Nativeint[7],
    t_of_sexp$3 = Base_Nativeint[8],
    sexp_of_t$3 = Base_Nativeint[9],
    of_string$3 = Base_Nativeint[10],
    to_string$3 = Base_Nativeint[11],
    symbol$40 = Base_Nativeint[12],
    symbol$41 = Base_Nativeint[13],
    symbol$42 = Base_Nativeint[14],
    symbol$43 = Base_Nativeint[15],
    symbol$44 = Base_Nativeint[16],
    symbol$45 = Base_Nativeint[17],
    equal$3 = Base_Nativeint[18],
    compare$3 = Base_Nativeint[19],
    min$3 = Base_Nativeint[20],
    max$3 = Base_Nativeint[21],
    ascending$3 = Base_Nativeint[22],
    descending$3 = Base_Nativeint[23],
    between$3 = Base_Nativeint[24],
    clamp_exn$3 = Base_Nativeint[25],
    clamp$3 = Base_Nativeint[26],
    comparator$3 = Base_Nativeint[27],
    pp$3 = Base_Nativeint[28],
    hashable$3 = Base_Nativeint[29],
    is_positive$3 = Base_Nativeint[30],
    is_non_negative$3 = Base_Nativeint[31],
    is_negative$3 = Base_Nativeint[32],
    is_non_positive$3 = Base_Nativeint[33],
    sign$3 = Base_Nativeint[34],
    invariant$3 = Base_Nativeint[35],
    Hex$3 = Base_Nativeint[36],
    to_string_hum$3 = Base_Nativeint[37],
    zero$3 = Base_Nativeint[38],
    one$3 = Base_Nativeint[39],
    minus_one$3 = Base_Nativeint[40],
    symbol$46 = Base_Nativeint[41],
    symbol$47 = Base_Nativeint[42],
    symbol$48 = Base_Nativeint[43],
    symbol$49 = Base_Nativeint[44],
    neg$1 = Base_Nativeint[45],
    symbol$50 = Base_Nativeint[46],
    symbol$51 = Base_Nativeint[47],
    symbol$52 = Base_Nativeint[48],
    symbol$53 = Base_Nativeint[49],
    rem$3 = Base_Nativeint[50],
    symbol$54 = Base_Nativeint[51],
    land$1 = Base_Nativeint[52],
    lor$1 = Base_Nativeint[53],
    lxor$1 = Base_Nativeint[54],
    lnot$3 = Base_Nativeint[55],
    lsl$1 = Base_Nativeint[56],
    asr$1 = Base_Nativeint[57],
    round$3 = Base_Nativeint[58],
    round_towards_zero$3 = Base_Nativeint[59],
    round_down$3 = Base_Nativeint[60],
    round_up$3 = Base_Nativeint[61],
    round_nearest$3 = Base_Nativeint[62],
    abs$3 = Base_Nativeint[63],
    succ$3 = Base_Nativeint[64],
    pred$3 = Base_Nativeint[65],
    pow$3 = Base_Nativeint[66],
    bit_and$3 = Base_Nativeint[67],
    bit_or$3 = Base_Nativeint[68],
    bit_xor$3 = Base_Nativeint[69],
    bit_not$3 = Base_Nativeint[70],
    popcount$3 = Base_Nativeint[71],
    shift_left$3 = Base_Nativeint[72],
    shift_right$3 = Base_Nativeint[73],
    decr$3 = Base_Nativeint[74],
    incr$3 = Base_Nativeint[75],
    of_int32_exn$3 = Base_Nativeint[76],
    to_int32_exn$3 = Base_Nativeint[77],
    of_int64_exn$3 = Base_Nativeint[78],
    to_int64$3 = Base_Nativeint[79],
    of_nativeint_exn$3 = Base_Nativeint[80],
    to_nativeint_exn$3 = Base_Nativeint[81],
    of_float_unchecked$3 = Base_Nativeint[82],
    num_bits$3 = Base_Nativeint[83],
    max_value$3 = Base_Nativeint[84],
    min_value$3 = Base_Nativeint[85],
    lsr$1 = Base_Nativeint[86],
    shift_right_logical$3 = Base_Nativeint[87],
    ceil_pow2$3 = Base_Nativeint[88],
    floor_pow2$3 = Base_Nativeint[89],
    ceil_log2$3 = Base_Nativeint[90],
    floor_log2$3 = Base_Nativeint[91],
    is_pow2$3 = Base_Nativeint[92],
    clz$3 = Base_Nativeint[93],
    ctz$3 = Base_Nativeint[94],
    O$3 = Base_Nativeint[95],
    uniform$3 = Splittable_random[7],
    log_uniform$3 = Splittable_random[10][5],
    For_nativeint =
      For_integer
       ([0,
         t_sexp_grammar$3,
         of_float$3,
         to_float$3,
         of_int_exn$3,
         to_int_exn$3,
         hash_fold_t$3,
         hash$3,
         t_of_sexp$3,
         sexp_of_t$3,
         of_string$3,
         to_string$3,
         symbol$40,
         symbol$41,
         symbol$42,
         symbol$43,
         symbol$44,
         symbol$45,
         equal$3,
         compare$3,
         min$3,
         max$3,
         ascending$3,
         descending$3,
         between$3,
         clamp_exn$3,
         clamp$3,
         comparator$3,
         pp$3,
         hashable$3,
         is_positive$3,
         is_non_negative$3,
         is_negative$3,
         is_non_positive$3,
         sign$3,
         invariant$3,
         Hex$3,
         to_string_hum$3,
         zero$3,
         one$3,
         minus_one$3,
         symbol$46,
         symbol$47,
         symbol$48,
         symbol$49,
         neg$1,
         symbol$50,
         symbol$51,
         symbol$52,
         symbol$53,
         rem$3,
         symbol$54,
         land$1,
         lor$1,
         lxor$1,
         lnot$3,
         lsl$1,
         asr$1,
         round$3,
         round_towards_zero$3,
         round_down$3,
         round_up$3,
         round_nearest$3,
         abs$3,
         succ$3,
         pred$3,
         pow$3,
         bit_and$3,
         bit_or$3,
         bit_xor$3,
         bit_not$3,
         popcount$3,
         shift_left$3,
         shift_right$3,
         decr$3,
         incr$3,
         of_int32_exn$3,
         to_int32_exn$3,
         of_int64_exn$3,
         to_int64$3,
         of_nativeint_exn$3,
         to_nativeint_exn$3,
         of_float_unchecked$3,
         num_bits$3,
         max_value$3,
         min_value$3,
         lsr$1,
         shift_right_logical$3,
         ceil_pow2$3,
         floor_pow2$3,
         ceil_log2$3,
         floor_log2$3,
         is_pow2$3,
         clz$3,
         ctz$3,
         O$3,
         uniform$3,
         log_uniform$3]),
    nativeint = For_nativeint[7],
    nativeint_uniform = For_nativeint[6],
    nativeint_inclusive = For_nativeint[4],
    nativeint_uniform_inclusive = For_nativeint[1],
    nativeint_log_inclusive = For_nativeint[5],
    nativeint_log_uniform_inclusiv = For_nativeint[2],
    float_zero_exponent = caml_call1(Base_Float[121], 0.),
    float_zero_mantissa = caml_call1(Base_Float[122], 0.),
    float_max_positive_subnormal_v =
      caml_call2(Base_Float[51], 759637122, Base_Float[47]),
    float_subnormal_exponent = caml_call1(Base_Float[121], Base_Float[46]),
    float_min_subnormal_mantissa = caml_call1(Base_Float[122], Base_Float[46]),
    float_max_subnormal_mantissa =
      caml_call1(Base_Float[122], float_max_positive_subnormal_v),
    float_max_positive_normal_valu = Base_Float[45],
    float_min_normal_exponent = caml_call1(Base_Float[121], Base_Float[47]),
    float_max_normal_exponent =
      caml_call1(Base_Float[121], float_max_positive_normal_valu),
    float_max_normal_mantissa =
      caml_call1(Base_Float[122], float_max_positive_normal_valu),
    float_inf_exponent = caml_call1(Base_Float[121], Base_Float[33]),
    float_inf_mantissa = caml_call1(Base_Float[122], Base_Float[33]),
    float_nan_exponent = caml_call1(Base_Float[121], Base_Float[32]),
    float_min_nan_mantissa = caml_call1(Base_Int63[64], float_inf_mantissa),
    _j_ = For_int[1].call(null, 0, 52),
    float_normal_mantissa =
      caml_call2
       (For_monad[11][4][2],
        _j_,
        function(num_bits){
         var
          _af_ = caml_call2(Base_Int63[72], Base_Int63[39], num_bits),
          _ag_ = caml_call1(Base_Int63[65], _af_),
          _ah_ = For_int63[4].call(null, Base_Int63[38], _ag_);
         return caml_call2
                 (For_monad[11][4][3],
                  _ah_,
                  function(bits){
                   return caml_call2(Base_Int63[72], bits, 52 - num_bits | 0);
                  });
        }),
    lower_bound = caml_call1(Base_Float[121], 1.),
    _k_ =
      For_int[5].call(null, 0, float_max_normal_exponent - lower_bound | 0),
    _m_ =
      [0,
       caml_call2
        (For_monad[11][4][3],
         _k_,
         function(offset){return lower_bound + offset | 0;}),
       0],
    _l_ =
      For_int[5].call(null, 0, lower_bound - float_min_normal_exponent | 0),
    float_exponent =
      union
       ([0,
         caml_call2
          (For_monad[11][4][3],
           _l_,
           function(offset){return lower_bound - offset | 0;}),
         _m_]),
    float_zero =
      caml_call2
       (For_monad[11][4][3],
        bool,
        function(negative){
         return caml_call3
                 (Base_Float[119],
                  negative,
                  float_zero_exponent,
                  float_zero_mantissa);
        }),
    let_syntax_012 = caml_call1(For_monad[11][1], float_subnormal_exponent),
    let_syntax_013 =
      For_int63[5].call
       (null, float_min_subnormal_mantissa, float_max_subnormal_mantissa),
    _n_ = caml_call2(For_monad[11][4][4], let_syntax_012, let_syntax_013),
    _o_ = caml_call2(For_monad[11][4][4], bool, _n_),
    float_subnormal =
      caml_call2
       (For_monad[11][4][3],
        _o_,
        function(param){
         var
          match = param[2],
          mantissa = match[2],
          exponent = match[1],
          negative = param[1];
         return caml_call3(Base_Float[119], negative, exponent, mantissa);
        }),
    _p_ =
      caml_call2(For_monad[11][4][4], float_exponent, float_normal_mantissa),
    _q_ = caml_call2(For_monad[11][4][4], bool, _p_),
    float_normal =
      caml_call2
       (For_monad[11][4][3],
        _q_,
        function(param){
         var
          match = param[2],
          mantissa = match[2],
          exponent = match[1],
          negative = param[1];
         return caml_call3(Base_Float[119], negative, exponent, mantissa);
        }),
    float_infinite =
      caml_call2
       (For_monad[11][4][3],
        bool,
        function(negative){
         return caml_call3
                 (Base_Float[119],
                  negative,
                  float_inf_exponent,
                  float_inf_mantissa);
        }),
    let_syntax_021 = caml_call1(For_monad[11][1], float_nan_exponent),
    let_syntax_022 =
      For_int63[4].call
       (null, float_min_nan_mantissa, float_max_normal_mantissa),
    _r_ = caml_call2(For_monad[11][4][4], let_syntax_021, let_syntax_022),
    _s_ = caml_call2(For_monad[11][4][4], bool, _r_),
    float_nan =
      caml_call2
       (For_monad[11][4][3],
        _s_,
        function(param){
         var
          match = param[2],
          mantissa = match[2],
          exponent = match[1],
          negative = param[1];
         return caml_call3(Base_Float[119], negative, exponent, mantissa);
        });
   function float_of_class(c){
    switch(c){
      case 0:
       return float_infinite;
      case 1:
       return float_nan;
      case 2:
       return float_normal;
      case 3:
       return float_subnormal;
      default: return float_zero;
    }
   }
   function float_matching_classes(filter){
    return weighted_union
            (caml_call2
              (Base_List[126],
               Base_Float[113][2],
               function(c){
                if(! caml_call1(filter, c)) return 0;
                var _ad_ = float_of_class(c);
                switch(c){
                  case 0:
                   var _ae_ = 1.; break;
                  case 1:
                   var _ae_ = 1.; break;
                  case 2:
                   var _ae_ = 100.; break;
                  case 3:
                   var _ae_ = 10.; break;
                  default: var _ae_ = 1.;
                }
                return [0, [0, _ae_, _ad_]];
               }));
   }
   var
    float_finite =
      float_matching_classes(function(param){return 2 <= param ? 1 : 0;}),
    float_without_nan =
      float_matching_classes(function(param){return 1 === param ? 0 : 1;}),
    float$0 = float_matching_classes(function(param){return 1;}),
    float_finite_non_zero =
      float_matching_classes
       (function(param){return 1 < param - 2 >>> 0 ? 0 : 1;}),
    float_strictly_positive =
      caml_call2
       (For_monad[11][4][3],
        float_finite_non_zero,
        function(t){return caml_call1(Base_Float[102], t);}),
    float_strictly_negative =
      caml_call2
       (For_monad[11][4][3],
        float_finite_non_zero,
        function(t){
         var _ac_ = caml_call1(Base_Float[102], t);
         return caml_call1(Base[196], _ac_);
        }),
    float_positive_or_zero =
      caml_call2
       (For_monad[11][4][3],
        float_finite,
        function(t){return caml_call1(Base_Float[102], t);}),
    float_negative_or_zero =
      caml_call2
       (For_monad[11][4][3],
        float_finite,
        function(t){
         var _ab_ = caml_call1(Base_Float[102], t);
         return caml_call1(Base[196], _ab_);
        }),
    _t_ = [0, cst_upper_bound],
    _u_ = [0, cst_lower_bound],
    cst_Float_uniform_exclusive_bo =
      "Float.uniform_exclusive: bounds are not finite",
    _v_ = [0, cst_upper_bound],
    _w_ = [0, cst_lower_bound],
    cst_Float_uniform_exclusive_re =
      "Float.uniform_exclusive: requested range is empty";
   function float_uniform_exclusive(lower_bound, upper_bound){
    var
     _V_ = 1 - caml_call1(Base_Float[84], lower_bound),
     _W_ = _V_ || 1 - caml_call1(Base_Float[84], upper_bound);
    if(_W_){
     var
      _X_ = [0, [1, [0, _t_, [0, caml_call1(Base[112], upper_bound), 0]]], 0],
      _Y_ =
        [0, [1, [0, _u_, [0, caml_call1(Base[112], lower_bound), 0]]], _X_],
      _Z_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Float_uniform_exclusive_bo),
          _Y_]];
     caml_call1(Base[202], _Z_);
    }
    var
     lower_inclusive = caml_call2(Base_Float[51], 19067, lower_bound),
     upper_inclusive = caml_call2(Base_Float[51], 759637122, upper_bound);
    if(caml_call2(Base_Float[103][11], lower_inclusive, upper_inclusive)){
     var
      ___ = [0, [1, [0, _v_, [0, caml_call1(Base[112], upper_bound), 0]]], 0],
      _$_ =
        [0, [1, [0, _w_, [0, caml_call1(Base[112], lower_bound), 0]]], ___],
      _aa_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Float_uniform_exclusive_re),
          _$_]];
     caml_call1(Base[202], _aa_);
    }
    return create
            (function(param, random){
              return caml_call3
                      (Splittable_random[8],
                       random,
                       lower_inclusive,
                       upper_inclusive);
             });
   }
   function float_inclusive(lower_bound, upper_bound){
    if(caml_call2(Base_Float[15], lower_bound, upper_bound))
     return caml_call1(For_monad[11][1], lower_bound);
    var _R_ = caml_call2(Base_Float[51], 19067, lower_bound);
    if(caml_call2(Base_Float[11], _R_, upper_bound)){
     var _S_ = [0, caml_call1(For_monad[11][1], upper_bound), 0];
     return union([0, caml_call1(For_monad[11][1], lower_bound), _S_]);
    }
    var
     _T_ = [0, [0, 0.9, float_uniform_exclusive(lower_bound, upper_bound)], 0],
     _U_ = [0, [0, 0.05, caml_call1(For_monad[11][1], upper_bound)], _T_];
    return weighted_union
            ([0, [0, 0.05, caml_call1(For_monad[11][1], lower_bound)], _U_]);
   }
   function string_with_length_of(char_gen, length){
    var _Q_ = list_with_length(char_gen, length);
    return map(_Q_, Base_String[123]);
   }
   function string_of(char_gen){
    return bind
            (small_positive_or_zero_int,
             function(length){return string_with_length_of(char_gen, length);});
   }
   function string_non_empty_of(char_gen){
    return bind
            (small_strictly_positive_int,
             function(length){return string_with_length_of(char_gen, length);});
   }
   var
    string = string_of(char$0),
    string_non_empty = string_non_empty_of(char$0);
   function string_with_length(length){
    return string_with_length_of(char$0, length);
   }
   var bytes = map(string, Base_Bytes[25]);
   function sexp_of(atom){
    return fixed_point
            (function(self){
              return caml_call2
                      (For_monad[11][4][2],
                       size,
                       function(size){
                        var _O_ = For_int[2].call(null, 0, size + 1 | 0);
                        return caml_call2
                                (For_monad[11][4][2],
                                 _O_,
                                 function(param){
                                  if(0 === param)
                                   return caml_call2
                                           (For_monad[11][4][3],
                                            atom,
                                            function(atom){return [0, atom];});
                                  var _P_ = list(self);
                                  return caml_call2
                                          (For_monad[11][4][3],
                                           _P_,
                                           function(list){return [1, list];});
                                 });
                       });
             });
   }
   var sexp = sexp_of(string);
   function map_tree_using_comparator(comparator, key_gen, data_gen){
    var _K_ = list(key_gen);
    return caml_call2
            (For_monad[11][4][2],
             _K_,
             function(keys){
              var
               keys$0 = caml_call2(Base_List[114], keys, comparator[1]),
               _L_ =
                 list_with_length(data_gen, caml_call1(Base_List[7], keys$0));
              return caml_call2
                      (For_monad[11][4][2],
                       _L_,
                       function(data){
                        var
                         _M_ = caml_call2(Base_List[95], keys$0, data),
                         _N_ = caml_call2(Base_Map[104][3][9], comparator, _M_);
                        return caml_call1(For_monad[11][1], _N_);
                       });
             });
   }
   function set_tree_using_comparator(comparator, elt_gen){
    var _J_ = caml_call1(Base_Set[74][3][54], comparator);
    return map(list(elt_gen), _J_);
   }
   function map_t_m(m, key_gen, data_gen){
    var
     comparator = m[1],
     _I_ = map_tree_using_comparator(comparator, key_gen, data_gen);
    return map(_I_, caml_call1(Base_Map[104][95], comparator));
   }
   function set_t_m(m, elt_gen){
    var
     comparator = m[1],
     _H_ = set_tree_using_comparator(comparator, elt_gen);
    return map(_H_, caml_call1(Base_Set[74][64], comparator));
   }
   function bigarray1(t, kind, layout){
    var _F_ = list(t);
    return caml_call2
            (For_monad[11][4][3],
             _F_,
             function(elts){
              var
               elts$0 = caml_call1(Base_Array[39], elts),
               dim = elts$0.length - 1,
               offset =
                 caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
              return caml_call4
                      (Base_quickcheck_Bigarray_helpe[2][2],
                       kind,
                       layout,
                       dim,
                       function(i){
                        var _G_ = i - offset | 0;
                        return caml_check_bound(elts$0, _G_)[1 + _G_];
                       });
             });
   }
   var
    bigstring = bigarray1(char$0, 12, 0),
    float32_vec = bigarray1(float$0, 0, 1),
    float64_vec = bigarray1(float$0, 1, 1),
    _x_ = [0, 0, 0],
    bigarray2_dim =
      caml_call2
       (For_monad[11][4][2],
        size,
        function(max_total_size){
         if(0 === max_total_size) return caml_call1(For_monad[11][1], _x_);
         var _C_ = int_log_uniform_inclusive(1, max_total_size);
         return caml_call2
                 (For_monad[11][4][2],
                  _C_,
                  function(a){
                   var
                    max_b = caml_div(max_total_size, a),
                    _D_ = int_log_uniform_inclusive(0, max_b),
                    _E_ =
                      caml_call2
                       (For_monad[11][4][3],
                        _D_,
                        function(b_weighted_low){return max_b - b_weighted_low | 0;});
                   return caml_call2
                           (For_monad[11][4][2],
                            _E_,
                            function(b){
                             return caml_call2
                                     (For_monad[11][4][3],
                                      bool,
                                      function(param){return param ? [0, a, b] : [0, b, a];});
                            });
                  });
        });
   function bigarray2(t, kind, layout){
    return caml_call2
            (For_monad[11][4][2],
             bigarray2_dim,
             function(param){
              var
               dim2 = param[2],
               dim1 = param[1],
               _z_ = list_with_length(list_with_length(t, dim2), dim1);
              return caml_call2
                      (For_monad[11][4][3],
                       _z_,
                       function(elts){
                        var
                         elts$0 = caml_call2(Base_Array[78], elts, Base_Array[39]),
                         offset =
                           caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
                        return caml_call5
                                (Base_quickcheck_Bigarray_helpe[3][2],
                                 kind,
                                 layout,
                                 dim1,
                                 dim2,
                                 function(i, j){
                                  var _A_ = j - offset | 0, _B_ = i - offset | 0;
                                  return caml_check_bound
                                           (caml_check_bound(elts$0, _B_)[1 + _B_], _A_)
                                          [1 + _A_];
                                 });
                       });
             });
   }
   var
    float32_mat = bigarray2(float$0, 0, 1),
    float64_mat = bigarray2(float$0, 1, 1);
   function coverage(Cmp){
    return function(sample){
     var _y_ = caml_call1(Base_Map[6], Cmp);
     return caml_call3
             (Base_Sequence[8],
              sample,
              _y_,
              function(counts, value){
               return caml_call3
                       (Base_Map[35],
                        counts,
                        value,
                        function(param){
                         if(! param) return 1;
                         var prev = param[1];
                         return prev + 1 | 0;
                        });
              });};
   }
   function monitor(t, f){
    return map(t, function(value){caml_call1(f, value); return value;});
   }
   var
    Debug = [0, coverage, monitor],
    Base_quickcheck_Generator =
      [0,
       unit,
       bool,
       char$0,
       string,
       bytes,
       int$0,
       int32,
       int63,
       int64,
       nativeint,
       float$0,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       either,
       result,
       bigstring,
       float32_vec,
       float64_vec,
       float32_mat,
       float64_mat,
       fn,
       map_t_m,
       set_t_m,
       map_tree_using_comparator,
       set_tree_using_comparator,
       of_list,
       union,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply,
       map2,
       map3,
       For_applicative[13],
       symbol_bind,
       symbol_map,
       For_monad[3],
       bind,
       return$0,
       map,
       join,
       ignore_m,
       all,
       all_unit,
       For_monad[11],
       size,
       with_size,
       sizes,
       filter,
       filter_map,
       recursive_union,
       fixed_point,
       of_lazy,
       of_weighted_list,
       weighted_union,
       weighted_recursive_union,
       small_positive_or_zero_int,
       small_strictly_positive_int,
       int_uniform,
       int32_uniform,
       int63_uniform,
       int64_uniform,
       nativeint_uniform,
       int_inclusive,
       int32_inclusive,
       int63_inclusive,
       int64_inclusive,
       nativeint_inclusive,
       int_uniform_inclusive,
       int32_uniform_inclusive,
       int63_uniform_inclusive,
       int64_uniform_inclusive,
       nativeint_uniform_inclusive,
       int_log_uniform_inclusive,
       int32_log_uniform_inclusive,
       int63_log_uniform_inclusive,
       int64_log_uniform_inclusive,
       nativeint_log_uniform_inclusiv,
       int_log_inclusive,
       int32_log_inclusive,
       int63_log_inclusive,
       int64_log_inclusive,
       nativeint_log_inclusive,
       float_inclusive,
       float_uniform_exclusive,
       float_without_nan,
       float_finite,
       float_strictly_positive,
       float_strictly_negative,
       float_positive_or_zero,
       float_negative_or_zero,
       float_of_class,
       char_lowercase,
       char_uppercase,
       char_digit,
       char_alpha,
       char_alphanum,
       char_whitespace,
       char_print,
       char_uniform_inclusive,
       string_non_empty,
       string_with_length,
       string_of,
       string_non_empty_of,
       string_with_length_of,
       sexp_of,
       list_non_empty,
       list_with_length,
       list_filtered,
       list_permutations,
       perturb,
       create,
       generate,
       Debug];
   runtime.caml_register_global
    (79, Base_quickcheck_Generator, "Base_quickcheck__Generator");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Shrinker
//# unitInfo: Requires: Base__Array, Base__Bytes, Base__Either, Base__Field, Base__Int, Base__Lazy, Base__List, Base__Map, Base__Option, Base__Sequence, Base__Set, Base__String, Base_quickcheck__Bigarray_helpers, CamlinternalLazy, Stdlib__Bigarray
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_kind = runtime.caml_ba_kind,
    caml_ba_layout = runtime.caml_ba_layout,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Set = global_data.Base__Set,
    Base_Map = global_data.Base__Map,
    Base_Sequence = global_data.Base__Sequence,
    Base_List = global_data.Base__List,
    Base_Either = global_data.Base__Either,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Lazy = global_data.Base__Lazy,
    Base_Array = global_data.Base__Array,
    Base_Option = global_data.Base__Option,
    Base_Field = global_data.Base__Field,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Int = global_data.Base__Int,
    Base_String = global_data.Base__String,
    Base_Bytes = global_data.Base__Bytes;
   function atomic(param){return Base_Sequence[38];}
   function create(_X_){return _X_;}
   function shrink(_W_){return _W_;}
   function map(t, f, f_inverse){
    return function(x){
     var _V_ = caml_call1(t, caml_call1(f_inverse, x));
     return caml_call2(Base_Sequence[32], _V_, f);};
   }
   function filter(t, f){
    return function(x){
     var _U_ = caml_call1(t, x);
     return caml_call2(Base_Sequence[51], _U_, f);};
   }
   function filter_map(t, f, f_inverse){
    return function(x){
     var _T_ = caml_call1(t, caml_call1(f_inverse, x));
     return caml_call2(Base_Sequence[78], _T_, f);};
   }
   function of_lazy(lazy_t){
    return function(x){
     return caml_call1
             (Base_Sequence[105],
              [246,
               function(_Q_){
                var
                 _R_ = caml_obj_tag(lazy_t),
                 _S_ =
                   250 === _R_
                    ? lazy_t[1]
                    : 246
                      === _R_
                      ? caml_call1(CamlinternalLazy[2], lazy_t)
                      : lazy_t;
                return caml_call1(_S_, x);
               }]);};
   }
   function fixed_point(of_shrinker){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246, function(param){return caml_call1(of_shrinker, of_lazy(lazy_t));}]);
    return of_lazy(lazy_t);
   }
   function both(fst_t, snd_t){
    return function(param){
     var
      snd = param[2],
      fst = param[1],
      _M_ = caml_call1(snd_t, snd),
      _N_ =
        [0,
         caml_call2
          (Base_Sequence[32], _M_, function(snd){return [0, fst, snd];}),
         0],
      _O_ = caml_call1(fst_t, fst),
      _P_ =
        [0,
         caml_call2
          (Base_Sequence[32], _O_, function(fst){return [0, fst, snd];}),
         _N_];
     return caml_call1(Base_Sequence[68], _P_);};
   }
   function float32_vec(src){
    var dim = caml_ba_dim_1(src);
    if(0 === dim) return Base_Sequence[38];
    var
     kind = caml_ba_kind(src),
     layout = caml_ba_layout(src),
     offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
    return caml_call2
            (Base_Sequence[77],
             dim,
             function(to_skip){
              var to_skip$0 = to_skip + offset | 0;
              return caml_call4
                      (Base_quickcheck_Bigarray_helpe[2][2],
                       kind,
                       layout,
                       dim - 1 | 0,
                       function(i){
                        var i$0 = i < to_skip$0 ? i : i + 1 | 0;
                        return runtime.caml_ba_get_1(src, i$0);
                       });
             });
   }
   function dim2(r){return r[2];}
   function dim1(r){return r[1];}
   var
    dim2$0 =
      [0,
       function(param){return 0;},
       "dim2",
       0,
       dim2,
       function(r, v){return [0, r[1], v];}],
    dim1$0 =
      [0,
       function(param){return 0;},
       "dim1",
       0,
       dim1,
       function(r, v){return [0, v, r[2]];}];
   function shrink$0(field, src){
    var _K_ = runtime.caml_ba_dim_2(src), dims = [0, caml_ba_dim_1(src), _K_];
    if(0 === caml_call2(Base_Field[3], field, dims)) return Base_Sequence[38];
    var
     kind = caml_ba_kind(src),
     layout = caml_ba_layout(src),
     offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout),
     match = caml_call3(Base_Field[6], field, dims, Base_Int[41]),
     dim2 = match[2],
     dim1 = match[1],
     _L_ = caml_call2(Base_Field[3], field, dims);
    return caml_call2
            (Base_Sequence[77],
             _L_,
             function(to_skip){
              var to_skip$0 = to_skip + offset | 0;
              function skip(i){return i < to_skip$0 ? i : i + 1 | 0;}
              return caml_call5
                      (Base_quickcheck_Bigarray_helpe[3][2],
                       kind,
                       layout,
                       dim1,
                       dim2,
                       function(dim1, dim2){
                        var
                         match =
                           caml_call3(Base_Field[6], field, [0, dim1, dim2], skip),
                         dim2$0 = match[2],
                         dim1$0 = match[1];
                        return runtime.caml_ba_get_2(src, dim1$0, dim2$0);
                       });
             });
   }
   function float32_mat(src){
    var
     _I_ = [0, shrink$0(dim2$0, src), 0],
     _J_ = [0, shrink$0(dim1$0, src), _I_];
    return caml_call1(Base_Sequence[68], _J_);
   }
   function option(value_t){
    return function(param){
     if(! param) return Base_Sequence[38];
     var
      value = param[1],
      _E_ = Base_Option[20],
      _F_ = caml_call1(value_t, value),
      _G_ = caml_call2(Base_Sequence[32], _F_, _E_),
      _H_ = caml_call1(Base_Sequence[99], 0);
     return caml_call2(Base_Sequence[63], _H_, _G_);};
   }
   function list(elt_t){
    return fixed_point
            (function(list_t){
              return function(param){
               if(! param) return Base_Sequence[38];
               var
                tail = param[2],
                head = param[1],
                _z_ = caml_call1(list_t, tail),
                _A_ =
                  [0,
                   caml_call2
                    (Base_Sequence[32],
                     _z_,
                     function(tail){return [0, head, tail];}),
                   0],
                _B_ = caml_call1(elt_t, head),
                _C_ =
                  [0,
                   caml_call2
                    (Base_Sequence[32],
                     _B_,
                     function(head){return [0, head, tail];}),
                   _A_],
                _D_ = [0, caml_call1(Base_Sequence[99], tail), _C_];
               return caml_call1(Base_Sequence[68], _D_);};
             });
   }
   var
    _a_ = Base_String[16],
    _b_ = Base_String[123],
    string = map(list(atomic), _b_, _a_),
    bytes = map(string, Base_Bytes[25], Base_Bytes[26]);
   function array(t){
    var _x_ = Base_Array[19], _y_ = Base_Array[39];
    return map(list(t), _y_, _x_);
   }
   function ref(t){
    return map
            (t,
             function(_w_){return [0, _w_];},
             function(_v_){return _v_[1];});
   }
   function lazy_t(t){
    return map
            (t,
             Base_Lazy[21],
             function(_t_){
              var _u_ = caml_obj_tag(_t_);
              return 250 === _u_
                      ? _t_[1]
                      : 246 === _u_ ? caml_call1(CamlinternalLazy[2], _t_) : _t_;
             });
   }
   var
    sexp =
      fixed_point
       (function(shrinker){
         return function(param){
          if(0 === param[0]) return Base_Sequence[38];
          var
           l = param[1],
           _s_ = list(shrinker)(l),
           shrink_list =
             caml_call2(Base_Sequence[32], _s_, function(l){return [1, l];}),
           shrink_tree = caml_call1(Base_Sequence[104], l);
          return caml_call1
                  (Base_Sequence[68], [0, shrink_list, [0, shrink_tree, 0]]);};
        });
   function either(fst_t, snd_t){
    return function(either){
     if(0 === either[0]){
      var
       fst = either[1],
       _o_ = Base_Either[17],
       _p_ = caml_call1(fst_t, fst);
      return caml_call2(Base_Sequence[32], _p_, _o_);
     }
     var snd = either[1], _q_ = Base_Either[18], _r_ = caml_call1(snd_t, snd);
     return caml_call2(Base_Sequence[32], _r_, _q_);};
   }
   function result(ok_t, err_t){
    return map
            (either(ok_t, err_t),
             function(param){
              if(0 === param[0]){var ok = param[1]; return [0, ok];}
              var err = param[1];
              return [1, err];
             },
             function(param){
              if(0 === param[0]){var ok = param[1]; return [0, ok];}
              var err = param[1];
              return [1, err];
             });
   }
   function map_tree_using_comparator(comparator, key_t, data_t){
    return function(tree){
     var
      alist = caml_call2(Base_Map[104][3][66], 0, tree),
      _j_ = caml_call1(Base_Sequence[104], alist),
      drop_keys =
        caml_call2
         (Base_Sequence[32],
          _j_,
          function(param){
           var k = param[1];
           return caml_call3(Base_Map[104][3][39], comparator, tree, k);
          }),
      _k_ =
        caml_call2
         (Base_List[76],
          alist,
          function(param){
           var
            data = param[2],
            key = param[1],
            tree$0 = caml_call3(Base_Map[104][3][39], comparator, tree, key),
            _n_ = caml_call1(key_t, key);
           return caml_call2
                   (Base_Sequence[78],
                    _n_,
                    function(smaller_key){
                     var
                      match =
                        caml_call4
                         (Base_Map[104][3][29],
                          comparator,
                          tree$0,
                          smaller_key,
                          data);
                     if(typeof match === "number") return 0;
                     var tree = match[2];
                     return [0, tree];
                    });
          }),
      shrink_keys = caml_call1(Base_Sequence[68], _k_),
      _l_ =
        caml_call2
         (Base_List[76],
          alist,
          function(param){
           var
            data = param[2],
            key = param[1],
            _m_ = caml_call1(data_t, data);
           return caml_call2
                   (Base_Sequence[32],
                    _m_,
                    function(smaller_data){
                     return caml_call4
                             (Base_Map[104][3][31], comparator, tree, key, smaller_data);
                    });
          }),
      shrink_data = caml_call1(Base_Sequence[68], _l_);
     return caml_call1
             (Base_Sequence[68],
              [0, drop_keys, [0, shrink_keys, [0, shrink_data, 0]]]);};
   }
   function set_tree_using_comparator(comparator, elt_t){
    return function(tree){
     var
      list = caml_call1(Base_Set[74][3][15], tree),
      _g_ = caml_call1(Base_Sequence[104], list),
      drop_elts =
        caml_call2
         (Base_Sequence[32],
          _g_,
          function(elt){
           return caml_call3(Base_Set[74][3][20], comparator, tree, elt);
          }),
      _h_ =
        caml_call2
         (Base_List[76],
          list,
          function(elt){
           var
            tree$0 = caml_call3(Base_Set[74][3][20], comparator, tree, elt),
            _i_ = caml_call1(elt_t, elt);
           return caml_call2
                   (Base_Sequence[78],
                    _i_,
                    function(smaller_elt){
                     return caml_call3
                              (Base_Set[74][3][18], comparator, tree$0, smaller_elt)
                             ? 0
                             : [0,
                               caml_call3
                                (Base_Set[74][3][19], comparator, tree$0, smaller_elt)];
                    });
          }),
      shrink_elts = caml_call1(Base_Sequence[68], _h_);
     return caml_call1(Base_Sequence[68], [0, drop_elts, [0, shrink_elts, 0]]);};
   }
   function map_t(key_t, data_t){
    return function(map_t){
     var
      comparator = caml_call1(Base_Map[5], map_t),
      _e_ = Base_Map[104][68],
      _f_ = caml_call1(Base_Map[104][95], comparator),
      t = map(map_tree_using_comparator(comparator, key_t, data_t), _f_, _e_);
     return t(map_t);};
   }
   function set_t(elt_t){
    return function(set_t){
     var
      comparator = caml_call1(Base_Set[4], set_t),
      _c_ = Base_Set[74][47],
      _d_ = caml_call1(Base_Set[74][64], comparator),
      t = map(set_tree_using_comparator(comparator, elt_t), _d_, _c_);
     return t(set_t);};
   }
   var
    Base_quickcheck_Shrinker =
      [0,
       atomic,
       atomic,
       atomic,
       atomic,
       string,
       bytes,
       atomic,
       atomic,
       atomic,
       atomic,
       atomic,
       atomic,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       both,
       either,
       result,
       float32_vec,
       float32_vec,
       float32_vec,
       float32_mat,
       float32_mat,
       map_t,
       set_t,
       map_tree_using_comparator,
       set_tree_using_comparator,
       map,
       filter,
       filter_map,
       fixed_point,
       of_lazy,
       create,
       shrink];
   runtime.caml_register_global
    (17, Base_quickcheck_Shrinker, "Base_quickcheck__Shrinker");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Test_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_quickcheck_Test_intf = [0];
   runtime.caml_register_global
    (0, Base_quickcheck_Test_intf, "Base_quickcheck__Test_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Test
//# unitInfo: Requires: Base, Base__Backtrace, Base__Error, Base__Field, Base__List, Base__Or_error, Base__Random, Base__Sequence, Base__String, Base_quickcheck__Generator, Base_quickcheck__Shrinker, Base_quickcheck__Test_intf, CamlinternalLazy, Sexplib0__Sexp_conv, Splittable_random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_seed = "seed",
    cst_shrink_count = "shrink_count",
    cst_sizes = "sizes",
    cst_test_count = "test_count";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "...",
    names =
      [0,
       cst_seed,
       [0, cst_test_count, [0, cst_shrink_count, [0, cst_sizes, 0]]]],
    Base_Backtrace = global_data.Base__Backtrace,
    Base_Or_error = global_data.Base__Or_error,
    Base_Error = global_data.Base__Error,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Sequence = global_data.Base__Sequence,
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_quickcheck_Shrinker = global_data.Base_quickcheck__Shrinker,
    Base = global_data.Base,
    Splittable_random = global_data.Splittable_random,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Random = global_data.Base__Random,
    Base_Field = global_data.Base__Field,
    Base_List = global_data.Base__List,
    _a_ = [0, "Deterministic"],
    _b_ = [0, "Nondeterministic"];
   function sexp_of_t(param){
    if(! param) return _b_;
    var arg0_001 = param[1], res0_002 = caml_call1(Base[164], arg0_001);
    return [1, [0, _a_, [0, res0_002, 0]]];
   }
   var Seed = [0, sexp_of_t];
   function sizes(r){return r[4];}
   function shrink_count(r){return r[3];}
   function test_count(r){return r[2];}
   function seed(r){return r[1];}
   var
    sizes$0 =
      [0,
       function(param){return 0;},
       cst_sizes,
       0,
       sizes,
       function(r, v){return [0, r[1], r[2], r[3], v];}],
    shrink_count$0 =
      [0,
       function(param){return 0;},
       cst_shrink_count,
       0,
       shrink_count,
       function(r, v){return [0, r[1], r[2], v, r[4]];}],
    test_count$0 =
      [0,
       function(param){return 0;},
       cst_test_count,
       0,
       test_count,
       function(r, v){return [0, r[1], v, r[3], r[4]];}],
    seed$0 =
      [0,
       function(param){return 0;},
       cst_seed,
       0,
       seed,
       function(r, v){return [0, v, r[2], r[3], r[4]];}];
   function make_creator
   (seed_fun, test_count_fun, shrink_count_fun, sizes_fun, compile_acc){
    var
     match = caml_call2(seed_fun, seed$0, compile_acc),
     compile_acc$0 = match[2],
     seed_gen = match[1],
     match$0 = caml_call2(test_count_fun, test_count$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     test_count_gen = match$0[1],
     match$1 = caml_call2(shrink_count_fun, shrink_count$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     shrink_count_gen = match$1[1],
     match$2 = caml_call2(sizes_fun, sizes$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     sizes_gen = match$2[1];
    return [0,
            function(acc){
             var
              seed = caml_call1(seed_gen, acc),
              test_count = caml_call1(test_count_gen, acc),
              shrink_count = caml_call1(shrink_count_gen, acc),
              sizes = caml_call1(sizes_gen, acc);
             return [0, seed, test_count, shrink_count, sizes];
            },
            compile_acc$3];
   }
   function create(seed, test_count, shrink_count, sizes){return [0, seed, test_count, shrink_count, sizes];
   }
   function map(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _ag_ = caml_call1(sizes_fun, sizes$0),
     _ah_ = caml_call1(shrink_count_fun, shrink_count$0),
     _ai_ = caml_call1(test_count_fun, test_count$0);
    return [0, caml_call1(seed_fun, seed$0), _ai_, _ah_, _ag_];
   }
   function iter(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    caml_call1(seed_fun, seed$0);
    caml_call1(test_count_fun, test_count$0);
    caml_call1(shrink_count_fun, shrink_count$0);
    return caml_call1(sizes_fun, sizes$0);
   }
   function fold(init, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    return caml_call2
            (sizes_fun,
             caml_call2
              (shrink_count_fun,
               caml_call2
                (test_count_fun,
                 caml_call2(seed_fun, init, seed$0),
                 test_count$0),
               shrink_count$0),
             sizes$0);
   }
   function map_poly(record){
    var
     _ad_ = [0, caml_call1(record[1], sizes$0), 0],
     _ae_ = [0, caml_call1(record[1], shrink_count$0), _ad_],
     _af_ = [0, caml_call1(record[1], test_count$0), _ae_];
    return [0, caml_call1(record[1], seed$0), _af_];
   }
   function for_all(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _aa_ = caml_call1(seed_fun, seed$0),
     _ab_ = _aa_ ? caml_call1(test_count_fun, test_count$0) : _aa_,
     _ac_ = _ab_ ? caml_call1(shrink_count_fun, shrink_count$0) : _ab_;
    return _ac_ ? caml_call1(sizes_fun, sizes$0) : _ac_;
   }
   function exists(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _$_ = caml_call1(seed_fun, seed$0),
     _Z_ = _$_ || caml_call1(test_count_fun, test_count$0),
     ___ = _Z_ || caml_call1(shrink_count_fun, shrink_count$0);
    return ___ ? ___ : caml_call1(sizes_fun, sizes$0);
   }
   function to_list(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _W_ = [0, caml_call1(sizes_fun, sizes$0), 0],
     _X_ = [0, caml_call1(shrink_count_fun, shrink_count$0), _W_],
     _Y_ = [0, caml_call1(test_count_fun, test_count$0), _X_];
    return [0, caml_call1(seed_fun, seed$0), _Y_];
   }
   function iter$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    caml_call3(seed_fun, seed$0, record, record[1]);
    caml_call3(test_count_fun, test_count$0, record, record[2]);
    caml_call3(shrink_count_fun, shrink_count$0, record, record[3]);
    return caml_call3(sizes_fun, sizes$0, record, record[4]);
   }
   function fold$0
   (record, init, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var _T_ = record[4], _U_ = record[3], _V_ = record[2];
    return caml_call4
            (sizes_fun,
             caml_call4
              (shrink_count_fun,
               caml_call4
                (test_count_fun,
                 caml_call4(seed_fun, init, seed$0, record, record[1]),
                 test_count$0,
                 record,
                 _V_),
               shrink_count$0,
               record,
               _U_),
             sizes$0,
             record,
             _T_);
   }
   function for_all$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _Q_ = caml_call3(seed_fun, seed$0, record, record[1]),
     _R_ =
       _Q_ ? caml_call3(test_count_fun, test_count$0, record, record[2]) : _Q_,
     _S_ =
       _R_
        ? caml_call3(shrink_count_fun, shrink_count$0, record, record[3])
        : _R_;
    return _S_ ? caml_call3(sizes_fun, sizes$0, record, record[4]) : _S_;
   }
   function exists$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _P_ = caml_call3(seed_fun, seed$0, record, record[1]),
     _N_ = _P_ || caml_call3(test_count_fun, test_count$0, record, record[2]),
     _O_ =
       _N_ || caml_call3(shrink_count_fun, shrink_count$0, record, record[3]);
    return _O_ ? _O_ : caml_call3(sizes_fun, sizes$0, record, record[4]);
   }
   function to_list$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _K_ = [0, caml_call3(sizes_fun, sizes$0, record, record[4]), 0],
     _L_ =
       [0,
        caml_call3(shrink_count_fun, shrink_count$0, record, record[3]),
        _K_],
     _M_ =
       [0, caml_call3(test_count_fun, test_count$0, record, record[2]), _L_];
    return [0, caml_call3(seed_fun, seed$0, record, record[1]), _M_];
   }
   function map$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _H_ = caml_call3(sizes_fun, sizes$0, record, record[4]),
     _I_ = caml_call3(shrink_count_fun, shrink_count$0, record, record[3]),
     _J_ = caml_call3(test_count_fun, test_count$0, record, record[2]);
    return [0, caml_call3(seed_fun, seed$0, record, record[1]), _J_, _I_, _H_];
   }
   function set_all_mutable_fields(record){
    caml_call1(Base_Field[1][1], record);
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields],
    _c_ = [0, cst_sizes],
    _d_ = [0, cst_shrink_count],
    _e_ = [0, cst_test_count],
    _f_ = [0, cst_seed];
   function sexp_of_t$0(param){
    var
     sizes_010 = param[4],
     shrink_count_008 = param[3],
     test_count_006 = param[2],
     seed_004 = param[1],
     sexp_of_elt = Base[119],
     match = caml_call2(Base_Sequence[88], sizes_010, 100),
     suffix = match[2],
     prefix = match[1],
     prefix$0 = caml_call2(Base_List[76], prefix, sexp_of_elt),
     bnds_003 = 0,
     suffix$0 =
       caml_call1(Base_Sequence[6], suffix)
        ? 0
        : [0, caml_call1(Sexplib0_Sexp_conv[7], cst), 0],
     arg_011 = [1, caml_call2(Base[178], prefix$0, suffix$0)],
     bnds_003$0 = [0, [1, [0, _c_, [0, arg_011, 0]]], bnds_003],
     arg_009 = caml_call1(Base[119], shrink_count_008),
     bnds_003$1 = [0, [1, [0, _d_, [0, arg_009, 0]]], bnds_003$0],
     arg_007 = caml_call1(Base[119], test_count_006),
     bnds_003$2 = [0, [1, [0, _e_, [0, arg_007, 0]]], bnds_003$1],
     arg_005 = caml_call1(Seed[1], seed_004),
     bnds_003$3 = [0, [1, [0, _f_, [0, arg_005, 0]]], bnds_003$2];
    return [1, bnds_003$3];
   }
   var
    _g_ = caml_call5(Base_List[121], 0, [0, 104758188], [0, 104758188], 0, 30),
    default_config =
      [0,
       [0, "an arbitrary but deterministic string"],
       10000,
       10000,
       caml_call1(Base_Sequence[97], _g_)],
    lazy_nondeterministic_state =
      [246, function(_G_){return caml_call2(Base_Random[18][3], 0, 0);}],
    _h_ = [0, "number_of_size_values"],
    _i_ = [0, cst_test_count],
    cst_Base_quickcheck_Test_run_i =
      "Base_quickcheck.Test.run: insufficient size values for test count",
    _j_ = [0, 0],
    _k_ = [0, 0],
    _l_ = [0, 0],
    _m_ = [0, "error"],
    _n_ = [0, "input"],
    cst_Base_quickcheck_Test_run_t = "Base_quickcheck.Test.run: test failed";
   function with_sample(f, opt, _C_, generator){
    if(opt) var sth = opt[1], config = sth; else var config = default_config;
    if(_C_) var sth$0 = _C_[1], examples = sth$0; else var examples = 0;
    var match = config[1];
    if(match)
     var
      string = match[1],
      _w_ = runtime.Base_hash_string(string),
      random = caml_call1(Splittable_random[1][2], _w_);
    else
     var
      _x_ = runtime.caml_obj_tag(lazy_nondeterministic_state),
      _y_ =
        250 === _x_
         ? lazy_nondeterministic_state[1]
         : 246
           === _x_
           ? caml_call1(CamlinternalLazy[2], lazy_nondeterministic_state)
           : lazy_nondeterministic_state,
      random = caml_call1(Splittable_random[1][1], _y_);
    var
     _z_ =
       caml_call2
        (Base_Sequence[42],
         [0, config[4], 0],
         function(param){
          var number_of_size_values = param[2], sizes = param[1];
          if(config[2] <= number_of_size_values) return 0;
          var match = caml_call1(Base_Sequence[39], sizes);
          if(match){
           var
            match$0 = match[1],
            remaining_sizes = match$0[2],
            size = match$0[1];
           return [0,
                   [0,
                    size,
                    [0, remaining_sizes, number_of_size_values + 1 | 0]]];
          }
          var
           _D_ =
             [0,
              [1,
               [0, _h_, [0, caml_call1(Base[119], number_of_size_values), 0]]],
              0],
           _E_ =
             [0, [1, [0, _i_, [0, caml_call1(Base[119], config[2]), 0]]], _D_],
           _F_ =
             [1,
              [0,
               caml_call1
                (Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Test_run_i),
               _E_]];
          return caml_call1(Base[202], _F_);
         }),
     _A_ =
       caml_call2
        (Base_Sequence[32],
         _z_,
         function(size){
          return caml_call3
                  (Base_quickcheck_Generator[118], generator, size, random);
         }),
     _B_ = caml_call1(Base_Sequence[104], examples),
     sequence = caml_call2(Base_Sequence[63], _B_, _A_);
    return caml_call1(f, sequence);
   }
   function result(f, opt, _v_, m){
    if(opt) var sth = opt[1], config = sth; else var config = default_config;
    if(_v_) var sth$0 = _v_[1], examples = sth$0; else var examples = 0;
    return with_sample
            (function(sequence){
              var
               match$2 =
                 caml_call3
                  (Base_Sequence[9],
                   sequence,
                   0,
                   function(param, input){
                    var match = caml_call1(f, input);
                    if(0 === match[0]) return _j_;
                    var error = match[1];
                    return [1, [0, input, error]];
                   });
              if(0 === match$2[0]) return _k_;
              var
               match$3 = match$2[1],
               error$1 = match$3[2],
               input$0 = match$3[1],
               shrinker = m[3],
               shrink_count$1 = config[3],
               alternates$2 =
                 caml_call2(Base_quickcheck_Shrinker[37], shrinker, input$0),
               shrink_count = shrink_count$1,
               alternates = alternates$2,
               input = input$0,
               error = error$1;
              for(;;){
               if(0 !== shrink_count){
                var
                 shrink_count$0 = shrink_count - 1 | 0,
                 match = caml_call1(Base_Sequence[39], alternates);
                if(match){
                 var
                  match$0 = match[1],
                  alternates$0 = match$0[2],
                  alternate = match$0[1],
                  match$1 = caml_call1(f, alternate);
                 if(0 === match$1[0]){
                  shrink_count = shrink_count$0;
                  alternates = alternates$0;
                  continue;
                 }
                 var
                  error$0 = match$1[1],
                  alternates$1 =
                    caml_call2
                     (Base_quickcheck_Shrinker[37], shrinker, alternate);
                 shrink_count = shrink_count$0;
                 alternates = alternates$1;
                 input = alternate;
                 error = error$0;
                 continue;
                }
               }
               return [1, [0, input, error]];
              }
             },
             [0, config],
             [0, examples],
             m[2]);
   }
   function run(f, config, examples, M){
    function f$0(x){
     var _u_ = [0, caml_call1(Base_Backtrace[6][1], 0)];
     return caml_call2
             (Base_Or_error[29],
              _u_,
              function(param){return caml_call1(f, x);});
    }
    var match = result(f$0, config, examples, M);
    if(0 === match[0]) return _l_;
    var
     match$0 = match[1],
     error = match$0[2],
     input = match$0[1],
     _r_ = [0, [1, [0, _m_, [0, caml_call1(Base_Error[6], error), 0]]], 0],
     _s_ = [0, [1, [0, _n_, [0, caml_call1(M[1], input), 0]]], _r_],
     _t_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Test_run_t),
         _s_]];
    return caml_call1(Base_Or_error[35], _t_);
   }
   function with_sample_exn(f, config, examples, generator){
    function f$0(x){
     return caml_call2
             (Base_Or_error[28], 0, function(param){return caml_call1(f, x);});
    }
    var _q_ = with_sample(f$0, config, examples, generator);
    return caml_call1(Base_Or_error[31], _q_);
   }
   function run_exn(f, config, examples, testable){
    function f$0(x){
     var _p_ = [0, caml_call1(Base_Backtrace[6][1], 0)];
     return caml_call2
             (Base_Or_error[28],
              _p_,
              function(param){return caml_call1(f, x);});
    }
    var _o_ = run(f$0, config, examples, testable);
    return caml_call1(Base_Or_error[31], _o_);
   }
   var
    Base_quickcheck_Test =
      [0,
       [0,
        Seed,
        sizes,
        shrink_count,
        test_count,
        seed,
        [0,
         names,
         sizes$0,
         shrink_count$0,
         test_count$0,
         seed$0,
         fold,
         make_creator,
         create,
         map,
         iter,
         for_all,
         exists,
         to_list,
         map_poly,
         Direct],
        sexp_of_t$0],
       default_config,
       run,
       run_exn,
       result,
       with_sample,
       with_sample_exn];
   runtime.caml_register_global
    (37, Base_quickcheck_Test, "Base_quickcheck__Test");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Observer
//# unitInfo: Requires: Base, Base__Array, Base__Bool, Base__Bytes, Base__Char, Base__Float, Base__Hash, Base__Int, Base__Int32, Base__Int63, Base__Int64, Base__List, Base__Map, Base__Nativeint, Base__Set, Base__String, Base_quickcheck__Bigarray_helpers, Base_quickcheck__Generator, Base_quickcheck__Observer0, CamlinternalLazy, Splittable_random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Set = global_data.Base__Set,
    Base_Map = global_data.Base__Map,
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_Hash = global_data.Base__Hash,
    Splittable_random = global_data.Splittable_random,
    Base_List = global_data.Base__List,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Array = global_data.Base__Array,
    Base = global_data.Base,
    Base_quickcheck_Observer0 = global_data.Base_quickcheck__Observer0,
    Base_Bool = global_data.Base__Bool,
    Base_Char = global_data.Base__Char,
    Base_Int = global_data.Base__Int,
    Base_Int32 = global_data.Base__Int32,
    Base_Int63 = global_data.Base__Int63,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_Float = global_data.Base__Float,
    Base_String = global_data.Base__String,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Bytes = global_data.Base__Bytes,
    opaque = Base_quickcheck_Observer0[1],
    create = Base_quickcheck_Observer0[2],
    observe = Base_quickcheck_Observer0[3];
   function unmap(t, f){
    return caml_call1
            (create,
             function(x, size, hash){
              return caml_call4(observe, t, caml_call1(f, x), size, hash);
             });
   }
   function of_hash_fold(f){
    return caml_call1
            (create, function(x, param, hash){return caml_call2(f, hash, x);});
   }
   function of_lazy(lazy_t){
    return caml_call1
            (create,
             function(x, size, hash){
              var
               _n_ = caml_obj_tag(lazy_t),
               _o_ =
                 250 === _n_
                  ? lazy_t[1]
                  : 246
                    === _n_
                    ? caml_call1(CamlinternalLazy[2], lazy_t)
                    : lazy_t;
              return caml_call4(observe, _o_, x, size, hash);
             });
   }
   function fixed_point(wrap){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246, function(param){return caml_call1(wrap, of_lazy(lazy_t));}]);
    return of_lazy(lazy_t);
   }
   var
    bool = of_hash_fold(Base_Bool[3]),
    char$0 = of_hash_fold(Base_Char[3]),
    int$0 = of_hash_fold(Base_Int[6]),
    int32 = of_hash_fold(Base_Int32[6]),
    int63 = of_hash_fold(Base_Int63[6]),
    int64 = of_hash_fold(Base_Int64[6]),
    nativeint = of_hash_fold(Base_Nativeint[6]),
    float$0 = of_hash_fold(Base_Float[4]),
    string = of_hash_fold(Base_String[26]),
    sexp = of_hash_fold(Base[84][1]),
    bigstring =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[101])),
    float32_vec =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[109])),
    float64_vec =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[109])),
    float32_mat =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[3][6], Base[109])),
    float64_mat =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[3][6], Base[109])),
    bytes = unmap(string, Base_Bytes[26]),
    _a_ = [0, 0];
   function either(fst_t, snd_t){
    return caml_call1
            (create,
             function(either, size, hash){
              if(0 === either[0]){
               var fst = either[1];
               return caml_call4
                       (observe, fst_t, fst, size, caml_call2(Base[116], hash, 1));
              }
              var snd = either[1];
              return caml_call4
                      (observe, snd_t, snd, size, caml_call2(Base[116], hash, 2));
             });
   }
   function result(ok_t, err_t){
    return unmap
            (either(ok_t, err_t),
             function(param){
              if(0 === param[0]){var ok = param[1]; return [0, ok];}
              var err = param[1];
              return [1, err];
             });
   }
   function both(fst_t, snd_t){
    return caml_call1
            (create,
             function(param, size, hash){
              var
               snd = param[2],
               fst = param[1],
               hash$0 = caml_call4(observe, fst_t, fst, size, hash),
               hash$1 = caml_call4(observe, snd_t, snd, size, hash$0);
              return hash$1;
             });
   }
   function option(value_t){
    return unmap
            (either(opaque, value_t),
             function(param){
              if(! param) return _a_;
              var value = param[1];
              return [1, value];
             });
   }
   function list(elt_t){
    return caml_call1
            (create,
             function(list, size, hash){
              var
               _k_ = caml_call1(Base_Hash[9], hash),
               random = caml_call1(Splittable_random[1][2], _k_),
               length = caml_call1(Base_List[7], list),
               _l_ =
                 caml_call3
                  (Base_quickcheck_Generator[53], [0, length], [0, length], 0),
               sizes =
                 caml_call3(Base_quickcheck_Generator[118], _l_, size, random),
               _m_ = caml_call2(Base[116], hash, 0);
              return caml_call4
                      (Base_List[46],
                       list,
                       sizes,
                       _m_,
                       function(hash, elt, size){
                        return caml_call4
                                (observe, elt_t, elt, size, caml_call2(Base[116], hash, 1));
                       });
             });
   }
   function array(t){var _j_ = Base_Array[19]; return unmap(list(t), _j_);}
   function ref(t){return unmap(t, function(_i_){return _i_[1];});}
   function lazy_t(t){
    return unmap
            (t,
             function(_g_){
              var _h_ = caml_obj_tag(_g_);
              return 250 === _h_
                      ? _g_[1]
                      : 246 === _h_ ? caml_call1(CamlinternalLazy[2], _g_) : _g_;
             });
   }
   function fn(dom, rng){
    return caml_call1
            (create,
             function(f, size, hash){
              var
               _e_ = caml_call1(Base_Hash[9], hash),
               random = caml_call1(Splittable_random[1][2], _e_),
               _f_ = caml_call3(Base_quickcheck_Generator[53], 0, 0, 0),
               sizes =
                 caml_call3
                  (Base_quickcheck_Generator[118], _f_, size * 2 | 0, random);
              return caml_call3
                      (Base_List[10],
                       sizes,
                       hash,
                       function(hash, size){
                        var
                         x =
                           caml_call3
                            (Base_quickcheck_Generator[118], dom, size, random);
                        return caml_call4
                                (observe, rng, caml_call1(f, x), size, hash);
                       });
             });
   }
   function map_tree(key_obs, data_obs){
    var arg = Base_Map[104][3][66];
    return unmap
            (list(both(key_obs, data_obs)),
             function(eta){return caml_call2(arg, 0, eta);});
   }
   function set_tree(elt_obs){
    var _d_ = Base_Set[74][3][15];
    return unmap(list(elt_obs), _d_);
   }
   function map_t(key_obs, data_obs){
    var _c_ = Base_Map[104][68];
    return unmap(map_tree(key_obs, data_obs), _c_);
   }
   function set_t(elt_obs){
    var _b_ = Base_Set[74][47];
    return unmap(set_tree(elt_obs), _b_);
   }
   var
    Base_quickcheck_Observer =
      [0,
       opaque,
       opaque,
       bool,
       char$0,
       string,
       bytes,
       int$0,
       int32,
       int63,
       int64,
       nativeint,
       float$0,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       both,
       either,
       result,
       bigstring,
       float32_vec,
       float64_vec,
       float32_mat,
       float64_mat,
       fn,
       map_t,
       set_t,
       map_tree,
       set_tree,
       of_hash_fold,
       unmap,
       fixed_point,
       of_lazy,
       create,
       observe];
   runtime.caml_register_global
    (22, Base_quickcheck_Observer, "Base_quickcheck__Observer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Export
//# unitInfo: Requires: Base_quickcheck__Generator, Base_quickcheck__Observer, Base_quickcheck__Shrinker
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_quickcheck_Observer = global_data.Base_quickcheck__Observer,
    Base_quickcheck_Shrinker = global_data.Base_quickcheck__Shrinker,
    quickcheck_generator_unit = Base_quickcheck_Generator[1],
    quickcheck_generator_bool = Base_quickcheck_Generator[2],
    quickcheck_generator_char = Base_quickcheck_Generator[3],
    quickcheck_generator_string = Base_quickcheck_Generator[4],
    quickcheck_generator_bytes = Base_quickcheck_Generator[5],
    quickcheck_generator_int = Base_quickcheck_Generator[6],
    quickcheck_generator_int32 = Base_quickcheck_Generator[7],
    quickcheck_generator_int64 = Base_quickcheck_Generator[9],
    quickcheck_generator_nativeint = Base_quickcheck_Generator[10],
    quickcheck_generator_float = Base_quickcheck_Generator[11],
    quickcheck_generator_option = Base_quickcheck_Generator[13],
    quickcheck_generator_list = Base_quickcheck_Generator[14],
    quickcheck_generator_array = Base_quickcheck_Generator[15],
    quickcheck_generator_ref = Base_quickcheck_Generator[16],
    quickcheck_generator_lazy_t = Base_quickcheck_Generator[17],
    quickcheck_observer_unit = Base_quickcheck_Observer[2],
    quickcheck_observer_bool = Base_quickcheck_Observer[3],
    quickcheck_observer_char = Base_quickcheck_Observer[4],
    quickcheck_observer_string = Base_quickcheck_Observer[5],
    quickcheck_observer_bytes = Base_quickcheck_Observer[6],
    quickcheck_observer_int = Base_quickcheck_Observer[7],
    quickcheck_observer_int32 = Base_quickcheck_Observer[8],
    quickcheck_observer_int64 = Base_quickcheck_Observer[10],
    quickcheck_observer_nativeint = Base_quickcheck_Observer[11],
    quickcheck_observer_float = Base_quickcheck_Observer[12],
    quickcheck_observer_option = Base_quickcheck_Observer[14],
    quickcheck_observer_list = Base_quickcheck_Observer[15],
    quickcheck_observer_array = Base_quickcheck_Observer[16],
    quickcheck_observer_ref = Base_quickcheck_Observer[17],
    quickcheck_observer_lazy_t = Base_quickcheck_Observer[18],
    quickcheck_shrinker_unit = Base_quickcheck_Shrinker[2],
    quickcheck_shrinker_bool = Base_quickcheck_Shrinker[3],
    quickcheck_shrinker_char = Base_quickcheck_Shrinker[4],
    quickcheck_shrinker_string = Base_quickcheck_Shrinker[5],
    quickcheck_shrinker_bytes = Base_quickcheck_Shrinker[6],
    quickcheck_shrinker_int = Base_quickcheck_Shrinker[7],
    quickcheck_shrinker_int32 = Base_quickcheck_Shrinker[8],
    quickcheck_shrinker_int64 = Base_quickcheck_Shrinker[10],
    quickcheck_shrinker_nativeint = Base_quickcheck_Shrinker[11],
    quickcheck_shrinker_float = Base_quickcheck_Shrinker[12],
    quickcheck_shrinker_option = Base_quickcheck_Shrinker[14],
    quickcheck_shrinker_list = Base_quickcheck_Shrinker[15],
    quickcheck_shrinker_array = Base_quickcheck_Shrinker[16],
    quickcheck_shrinker_ref = Base_quickcheck_Shrinker[17],
    quickcheck_shrinker_lazy_t = Base_quickcheck_Shrinker[18],
    Base_quickcheck_Export =
      [0,
       quickcheck_generator_unit,
       quickcheck_generator_bool,
       quickcheck_generator_char,
       quickcheck_generator_string,
       quickcheck_generator_bytes,
       quickcheck_generator_int,
       quickcheck_generator_int32,
       quickcheck_generator_int64,
       quickcheck_generator_nativeint,
       quickcheck_generator_float,
       quickcheck_observer_unit,
       quickcheck_observer_bool,
       quickcheck_observer_char,
       quickcheck_observer_string,
       quickcheck_observer_bytes,
       quickcheck_observer_int,
       quickcheck_observer_int32,
       quickcheck_observer_int64,
       quickcheck_observer_nativeint,
       quickcheck_observer_float,
       quickcheck_shrinker_unit,
       quickcheck_shrinker_bool,
       quickcheck_shrinker_char,
       quickcheck_shrinker_string,
       quickcheck_shrinker_bytes,
       quickcheck_shrinker_int,
       quickcheck_shrinker_int32,
       quickcheck_shrinker_int64,
       quickcheck_shrinker_nativeint,
       quickcheck_shrinker_float,
       quickcheck_generator_option,
       quickcheck_generator_list,
       quickcheck_generator_array,
       quickcheck_generator_ref,
       quickcheck_generator_lazy_t,
       quickcheck_observer_option,
       quickcheck_observer_list,
       quickcheck_observer_array,
       quickcheck_observer_ref,
       quickcheck_observer_lazy_t,
       quickcheck_shrinker_option,
       quickcheck_shrinker_list,
       quickcheck_shrinker_array,
       quickcheck_shrinker_ref,
       quickcheck_shrinker_lazy_t];
   runtime.caml_register_global
    (3, Base_quickcheck_Export, "Base_quickcheck__Export");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck
//# unitInfo: Requires: Base_quickcheck__Export
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_quickcheck_Export = global_data.Base_quickcheck__Export,
    quickcheck_generator_unit = Base_quickcheck_Export[1],
    quickcheck_generator_bool = Base_quickcheck_Export[2],
    quickcheck_generator_char = Base_quickcheck_Export[3],
    quickcheck_generator_string = Base_quickcheck_Export[4],
    quickcheck_generator_bytes = Base_quickcheck_Export[5],
    quickcheck_generator_int = Base_quickcheck_Export[6],
    quickcheck_generator_int32 = Base_quickcheck_Export[7],
    quickcheck_generator_int64 = Base_quickcheck_Export[8],
    quickcheck_generator_nativeint = Base_quickcheck_Export[9],
    quickcheck_generator_float = Base_quickcheck_Export[10],
    quickcheck_observer_unit = Base_quickcheck_Export[11],
    quickcheck_observer_bool = Base_quickcheck_Export[12],
    quickcheck_observer_char = Base_quickcheck_Export[13],
    quickcheck_observer_string = Base_quickcheck_Export[14],
    quickcheck_observer_bytes = Base_quickcheck_Export[15],
    quickcheck_observer_int = Base_quickcheck_Export[16],
    quickcheck_observer_int32 = Base_quickcheck_Export[17],
    quickcheck_observer_int64 = Base_quickcheck_Export[18],
    quickcheck_observer_nativeint = Base_quickcheck_Export[19],
    quickcheck_observer_float = Base_quickcheck_Export[20],
    quickcheck_shrinker_unit = Base_quickcheck_Export[21],
    quickcheck_shrinker_bool = Base_quickcheck_Export[22],
    quickcheck_shrinker_char = Base_quickcheck_Export[23],
    quickcheck_shrinker_string = Base_quickcheck_Export[24],
    quickcheck_shrinker_bytes = Base_quickcheck_Export[25],
    quickcheck_shrinker_int = Base_quickcheck_Export[26],
    quickcheck_shrinker_int32 = Base_quickcheck_Export[27],
    quickcheck_shrinker_int64 = Base_quickcheck_Export[28],
    quickcheck_shrinker_nativeint = Base_quickcheck_Export[29],
    quickcheck_shrinker_float = Base_quickcheck_Export[30],
    quickcheck_generator_option = Base_quickcheck_Export[31],
    quickcheck_generator_list = Base_quickcheck_Export[32],
    quickcheck_generator_array = Base_quickcheck_Export[33],
    quickcheck_generator_ref = Base_quickcheck_Export[34],
    quickcheck_generator_lazy_t = Base_quickcheck_Export[35],
    quickcheck_observer_option = Base_quickcheck_Export[36],
    quickcheck_observer_list = Base_quickcheck_Export[37],
    quickcheck_observer_array = Base_quickcheck_Export[38],
    quickcheck_observer_ref = Base_quickcheck_Export[39],
    quickcheck_observer_lazy_t = Base_quickcheck_Export[40],
    quickcheck_shrinker_option = Base_quickcheck_Export[41],
    quickcheck_shrinker_list = Base_quickcheck_Export[42],
    quickcheck_shrinker_array = Base_quickcheck_Export[43],
    quickcheck_shrinker_ref = Base_quickcheck_Export[44],
    quickcheck_shrinker_lazy_t = Base_quickcheck_Export[45],
    Private = [0],
    Base_quickcheck =
      [0,
       quickcheck_generator_unit,
       quickcheck_generator_bool,
       quickcheck_generator_char,
       quickcheck_generator_string,
       quickcheck_generator_bytes,
       quickcheck_generator_int,
       quickcheck_generator_int32,
       quickcheck_generator_int64,
       quickcheck_generator_nativeint,
       quickcheck_generator_float,
       quickcheck_observer_unit,
       quickcheck_observer_bool,
       quickcheck_observer_char,
       quickcheck_observer_string,
       quickcheck_observer_bytes,
       quickcheck_observer_int,
       quickcheck_observer_int32,
       quickcheck_observer_int64,
       quickcheck_observer_nativeint,
       quickcheck_observer_float,
       quickcheck_shrinker_unit,
       quickcheck_shrinker_bool,
       quickcheck_shrinker_char,
       quickcheck_shrinker_string,
       quickcheck_shrinker_bytes,
       quickcheck_shrinker_int,
       quickcheck_shrinker_int32,
       quickcheck_shrinker_int64,
       quickcheck_shrinker_nativeint,
       quickcheck_shrinker_float,
       quickcheck_generator_option,
       quickcheck_generator_list,
       quickcheck_generator_array,
       quickcheck_generator_ref,
       quickcheck_generator_lazy_t,
       quickcheck_observer_option,
       quickcheck_observer_list,
       quickcheck_observer_array,
       quickcheck_observer_ref,
       quickcheck_observer_lazy_t,
       quickcheck_shrinker_option,
       quickcheck_shrinker_list,
       quickcheck_shrinker_array,
       quickcheck_shrinker_ref,
       quickcheck_shrinker_lazy_t,
       Private];
   runtime.caml_register_global(1, Base_quickcheck, "Base_quickcheck");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYXNlX3F1aWNrY2hlY2suY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbIm9mZnNldCIsIml0ZXJpIiwidCIsImYiLCJpIiwiaW5pdCIsImtpbmQiLCJsYXlvdXQiLCJkaW0iLCJmb2xkIiwiaW5pdCQwIiwidG9fYXJyYXkiLCJzZXhwX29mX3QiLCJzZXhwX29mX2VsdCIsInNleHBfb2ZfcGFjayIsInNleHBfb2ZfbGF5b3V0IiwieF8wMDEiLCJoYXNoX2ZvbGQiLCJoYXNoX2ZvbGRfZWx0Iiwic3RhdGUiLCJzdGF0ZSQwIiwiaXRlcmkkMCIsImoiLCJkaW0xIiwiZGltMiIsImZvbGQkMCIsImVsdCIsInRvX2FycmF5JDAiLCJzZXhwX29mX3QkMCIsInhfMDAyIiwiaGFzaF9mb2xkJDAiLCJzdGF0ZSQxIiwiY3JlYXRlIiwib2JzZXJ2ZSIsIngiLCJzaXplIiwiaGFzaCIsIm9wYXF1ZSIsImdlbmVyYXRlIiwicmFuZG9tIiwiZm4iLCJkb20iLCJybmciLCJyYW5kb20kMCIsIndpdGhfc2l6ZSIsInBlcnR1cmIiLCJzYWx0IiwiZmlsdGVyX21hcCIsImxvb3AiLCJzaXplJDAiLCJ5Iiwic2l6ZSQxIiwiZmlsdGVyIiwicmV0dXJuJDAiLCJtYXAiLCJhcHBseSIsInRmIiwidHgiLCJiaW5kIiwiYWxsIiwibGlzdCIsImFsbF91bml0IiwibWFwJDAiLCJib3RoIiwibWFwMiIsIm1hcDMiLCJtYXAkMSIsImlnbm9yZV9tIiwiam9pbiIsIm9mX2xpc3QiLCJhcnJheSIsImhpIiwibG8iLCJpbmRleCIsInVuaW9uIiwib2Zfd2VpZ2h0ZWRfbGlzdCIsImFsaXN0IiwidmFsdWVzIiwid2VpZ2h0cyIsInZhbHVlX2FycmF5Iiwic3VtIiwiYWNjIiwid2VpZ2h0IiwiY3VtdWxhdGl2ZSIsImNob2ljZSIsIndlaWdodGVkX3VuaW9uIiwib2ZfbGF6eSIsImxhenlfdCIsImZpeGVkX3BvaW50Iiwib2ZfZ2VuZXJhdG9yIiwid2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uIiwibm9ucmVjX2xpc3QiLCJzZWxmIiwicmVjX2xpc3QiLCJ3IiwibiIsIm5vbnJlY19nZW4iLCJyZWNfZ2VuIiwicmVjdXJzaXZlX3VuaW9uIiwid2VpZ2h0ZWQiLCJzaXplcyIsIm9wdCIsInN0aCIsIm1pbl9sZW5ndGgiLCJzdGgkMCIsIm1heF9sZW5ndGgiLCJ1cHBlcl9ib3VuZCIsIm1heF9sZW5ndGgkMCIsImxlbiIsInJlbWFpbmluZyIsIm1heF9pbmRleCIsInVuaXQiLCJib29sIiwib3B0aW9uIiwidmFsdWVfdCIsImVpdGhlciIsImZzdF90Iiwic25kX3QiLCJyZXN1bHQiLCJva190IiwiZXJyX3QiLCJvayIsImVyciIsImxpc3RfZ2VuZXJpYyIsImVsdF9nZW4iLCJsaXN0X25vbl9lbXB0eSIsImxpc3Rfd2l0aF9sZW5ndGgiLCJsZW5ndGgiLCJsaXN0X2ZpbHRlcmVkIiwiZWx0cyIsImVsdHMkMCIsImxlbmd0aF9vZl9pbnB1dCIsImxlbmd0aF9vZl9vdXRwdXQiLCJpbmRpY2VzIiwibGlzdF9wZXJtdXRhdGlvbnMiLCJyZWYiLCJjaGFyX3VuaWZvcm1faW5jbHVzaXZlIiwiY2hhcl91cHBlcmNhc2UiLCJjaGFyX2xvd2VyY2FzZSIsImNoYXJfZGlnaXQiLCJjaGFyX3ByaW50X3VuaWZvcm0iLCJjaGFyX3VuaWZvcm0iLCJjaGFyX2FscGhhIiwiY2hhcl9hbHBoYW51bSIsImNoYXJfd2hpdGVzcGFjZSIsImNoYXJfcHJpbnQiLCJjaGFyJDAiLCJzbWFsbF9pbnQiLCJhbGxvd196ZXJvIiwibG93ZXJfYm91bmQiLCJ3ZWlnaHRlZF9sb3ciLCJ3ZWlnaHRlZF9oaWdoIiwic21hbGxfcG9zaXRpdmVfb3JfemVyb19pbnQiLCJzbWFsbF9zdHJpY3RseV9wb3NpdGl2ZV9pbnQiLCJ1bmlmb3JtX2luY2x1c2l2ZSIsImxvZ191bmlmb3JtX2luY2x1c2l2ZSIsIm5vbl91bmlmb3JtIiwiaW5jbHVzaXZlIiwibG9nX2luY2x1c2l2ZSIsInVuaWZvcm1fYWxsIiwibGV0X3N5bnRheF8wMDQiLCJtYWduaXR1ZGUiLCJuZWdhdGl2ZSIsInVuaWZvcm0iLCJsb2dfdW5pZm9ybSIsImludCQwIiwiaW50X3VuaWZvcm0iLCJpbnRfaW5jbHVzaXZlIiwiaW50X3VuaWZvcm1faW5jbHVzaXZlIiwiaW50X2xvZ19pbmNsdXNpdmUiLCJpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlIiwidW5pZm9ybSQwIiwibG9nX3VuaWZvcm0kMCIsImludDMyIiwiaW50MzJfdW5pZm9ybSIsImludDMyX2luY2x1c2l2ZSIsImludDMyX3VuaWZvcm1faW5jbHVzaXZlIiwiaW50MzJfbG9nX2luY2x1c2l2ZSIsImludDMyX2xvZ191bmlmb3JtX2luY2x1c2l2ZSIsInVuaWZvcm0kMSIsImxvZ191bmlmb3JtJDEiLCJpbnQ2MyIsImludDYzX3VuaWZvcm0iLCJpbnQ2M19pbmNsdXNpdmUiLCJpbnQ2M191bmlmb3JtX2luY2x1c2l2ZSIsImludDYzX2xvZ19pbmNsdXNpdmUiLCJpbnQ2M19sb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJzeW1ib2wkMzYiLCJsbm90JDIiLCJhYnMkMiIsInplcm8kMiIsInN5bWJvbCQzNyIsInN5bWJvbCQzOCIsInN5bWJvbCQzOSIsInVuaWZvcm0kMiIsImxvZ191bmlmb3JtJDIiLCJpbnQ2NCIsImludDY0X3VuaWZvcm0iLCJpbnQ2NF9pbmNsdXNpdmUiLCJpbnQ2NF91bmlmb3JtX2luY2x1c2l2ZSIsImludDY0X2xvZ19pbmNsdXNpdmUiLCJpbnQ2NF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJ1bmlmb3JtJDMiLCJsb2dfdW5pZm9ybSQzIiwibmF0aXZlaW50IiwibmF0aXZlaW50X3VuaWZvcm0iLCJuYXRpdmVpbnRfaW5jbHVzaXZlIiwibmF0aXZlaW50X3VuaWZvcm1faW5jbHVzaXZlIiwibmF0aXZlaW50X2xvZ19pbmNsdXNpdmUiLCJuYXRpdmVpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXYiLCJmbG9hdF96ZXJvX2V4cG9uZW50IiwiZmxvYXRfemVyb19tYW50aXNzYSIsImZsb2F0X21heF9wb3NpdGl2ZV9zdWJub3JtYWxfdiIsImZsb2F0X3N1Ym5vcm1hbF9leHBvbmVudCIsImZsb2F0X21pbl9zdWJub3JtYWxfbWFudGlzc2EiLCJmbG9hdF9tYXhfc3Vibm9ybWFsX21hbnRpc3NhIiwiZmxvYXRfbWF4X3Bvc2l0aXZlX25vcm1hbF92YWx1IiwiZmxvYXRfbWluX25vcm1hbF9leHBvbmVudCIsImZsb2F0X21heF9ub3JtYWxfZXhwb25lbnQiLCJmbG9hdF9tYXhfbm9ybWFsX21hbnRpc3NhIiwiZmxvYXRfaW5mX2V4cG9uZW50IiwiZmxvYXRfaW5mX21hbnRpc3NhIiwiZmxvYXRfbmFuX2V4cG9uZW50IiwiZmxvYXRfbWluX25hbl9tYW50aXNzYSIsImZsb2F0X25vcm1hbF9tYW50aXNzYSIsIm51bV9iaXRzIiwiYml0cyIsImZsb2F0X2V4cG9uZW50IiwiZmxvYXRfemVybyIsImxldF9zeW50YXhfMDEyIiwibGV0X3N5bnRheF8wMTMiLCJmbG9hdF9zdWJub3JtYWwiLCJtYW50aXNzYSIsImV4cG9uZW50IiwiZmxvYXRfbm9ybWFsIiwiZmxvYXRfaW5maW5pdGUiLCJsZXRfc3ludGF4XzAyMSIsImxldF9zeW50YXhfMDIyIiwiZmxvYXRfbmFuIiwiZmxvYXRfb2ZfY2xhc3MiLCJjIiwiZmxvYXRfbWF0Y2hpbmdfY2xhc3NlcyIsImZsb2F0X2Zpbml0ZSIsImZsb2F0X3dpdGhvdXRfbmFuIiwiZmxvYXQkMCIsImZsb2F0X2Zpbml0ZV9ub25femVybyIsImZsb2F0X3N0cmljdGx5X3Bvc2l0aXZlIiwiZmxvYXRfc3RyaWN0bHlfbmVnYXRpdmUiLCJmbG9hdF9wb3NpdGl2ZV9vcl96ZXJvIiwiZmxvYXRfbmVnYXRpdmVfb3JfemVybyIsImZsb2F0X3VuaWZvcm1fZXhjbHVzaXZlIiwibG93ZXJfaW5jbHVzaXZlIiwidXBwZXJfaW5jbHVzaXZlIiwiZmxvYXRfaW5jbHVzaXZlIiwic3RyaW5nX3dpdGhfbGVuZ3RoX29mIiwiY2hhcl9nZW4iLCJzdHJpbmdfb2YiLCJzdHJpbmdfbm9uX2VtcHR5X29mIiwic3RyaW5nIiwic3RyaW5nX25vbl9lbXB0eSIsInN0cmluZ193aXRoX2xlbmd0aCIsImJ5dGVzIiwic2V4cF9vZiIsImF0b20iLCJzZXhwIiwibWFwX3RyZWVfdXNpbmdfY29tcGFyYXRvciIsImNvbXBhcmF0b3IiLCJrZXlfZ2VuIiwiZGF0YV9nZW4iLCJrZXlzIiwia2V5cyQwIiwiZGF0YSIsInNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IiLCJtYXBfdF9tIiwibSIsInNldF90X20iLCJiaWdhcnJheTEiLCJiaWdzdHJpbmciLCJmbG9hdDMyX3ZlYyIsImZsb2F0NjRfdmVjIiwiYmlnYXJyYXkyX2RpbSIsIm1heF90b3RhbF9zaXplIiwiYSIsIm1heF9iIiwiYl93ZWlnaHRlZF9sb3ciLCJiIiwiYmlnYXJyYXkyIiwiZmxvYXQzMl9tYXQiLCJmbG9hdDY0X21hdCIsImNvdmVyYWdlIiwiQ21wIiwic2FtcGxlIiwiY291bnRzIiwidmFsdWUiLCJwcmV2IiwibW9uaXRvciIsImF0b21pYyIsInNocmluayIsImZfaW52ZXJzZSIsIm9mX3Nocmlua2VyIiwic25kIiwiZnN0Iiwic3JjIiwidG9fc2tpcCIsInRvX3NraXAkMCIsImkkMCIsInIiLCJkaW0yJDAiLCJ2IiwiZGltMSQwIiwic2hyaW5rJDAiLCJmaWVsZCIsImRpbXMiLCJza2lwIiwiZWx0X3QiLCJsaXN0X3QiLCJ0YWlsIiwiaGVhZCIsInNocmlua2VyIiwibCIsInNocmlua19saXN0Iiwic2hyaW5rX3RyZWUiLCJrZXlfdCIsImRhdGFfdCIsInRyZWUiLCJkcm9wX2tleXMiLCJrIiwia2V5IiwidHJlZSQwIiwic21hbGxlcl9rZXkiLCJzaHJpbmtfa2V5cyIsInNtYWxsZXJfZGF0YSIsInNocmlua19kYXRhIiwiZHJvcF9lbHRzIiwic21hbGxlcl9lbHQiLCJzaHJpbmtfZWx0cyIsIm1hcF90Iiwic2V0X3QiLCJuYW1lcyIsImFyZzBfMDAxIiwicmVzMF8wMDIiLCJzaHJpbmtfY291bnQiLCJ0ZXN0X2NvdW50Iiwic2VlZCIsInNpemVzJDAiLCJzaHJpbmtfY291bnQkMCIsInRlc3RfY291bnQkMCIsInNlZWQkMCIsIm1ha2VfY3JlYXRvciIsInNlZWRfZnVuIiwidGVzdF9jb3VudF9mdW4iLCJzaHJpbmtfY291bnRfZnVuIiwic2l6ZXNfZnVuIiwiY29tcGlsZV9hY2MiLCJjb21waWxlX2FjYyQwIiwic2VlZF9nZW4iLCJjb21waWxlX2FjYyQxIiwidGVzdF9jb3VudF9nZW4iLCJjb21waWxlX2FjYyQyIiwic2hyaW5rX2NvdW50X2dlbiIsImNvbXBpbGVfYWNjJDMiLCJzaXplc19nZW4iLCJpdGVyIiwibWFwX3BvbHkiLCJyZWNvcmQiLCJmb3JfYWxsIiwiZXhpc3RzIiwidG9fbGlzdCIsIml0ZXIkMCIsImZvcl9hbGwkMCIsImV4aXN0cyQwIiwidG9fbGlzdCQwIiwic2V0X2FsbF9tdXRhYmxlX2ZpZWxkcyIsInNpemVzXzAxMCIsInNocmlua19jb3VudF8wMDgiLCJ0ZXN0X2NvdW50XzAwNiIsInNlZWRfMDA0Iiwic3VmZml4IiwicHJlZml4IiwicHJlZml4JDAiLCJibmRzXzAwMyIsInN1ZmZpeCQwIiwiYXJnXzAxMSIsImJuZHNfMDAzJDAiLCJhcmdfMDA5IiwiYm5kc18wMDMkMSIsImFyZ18wMDciLCJibmRzXzAwMyQyIiwiYXJnXzAwNSIsImJuZHNfMDAzJDMiLCJkZWZhdWx0X2NvbmZpZyIsImxhenlfbm9uZGV0ZXJtaW5pc3RpY19zdGF0ZSIsIndpdGhfc2FtcGxlIiwiZ2VuZXJhdG9yIiwiY29uZmlnIiwiZXhhbXBsZXMiLCJudW1iZXJfb2Zfc2l6ZV92YWx1ZXMiLCJyZW1haW5pbmdfc2l6ZXMiLCJzZXF1ZW5jZSIsImlucHV0IiwiZXJyb3IiLCJlcnJvciQxIiwiaW5wdXQkMCIsInNocmlua19jb3VudCQxIiwiYWx0ZXJuYXRlcyQyIiwiYWx0ZXJuYXRlcyIsImFsdGVybmF0ZXMkMCIsImFsdGVybmF0ZSIsImVycm9yJDAiLCJhbHRlcm5hdGVzJDEiLCJydW4iLCJNIiwiZiQwIiwid2l0aF9zYW1wbGVfZXhuIiwicnVuX2V4biIsInRlc3RhYmxlIiwidW5tYXAiLCJvZl9oYXNoX2ZvbGQiLCJ3cmFwIiwiaGFzaCQwIiwiaGFzaCQxIiwibWFwX3RyZWUiLCJrZXlfb2JzIiwiZGF0YV9vYnMiLCJzZXRfdHJlZSIsImVsdF9vYnMiXSwic291cmNlcyI6WyIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2VfcXVpY2tjaGVjay9iaWdhcnJheV9oZWxwZXJzLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlX3F1aWNrY2hlY2svb2JzZXJ2ZXIwLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9iYXNlX3F1aWNrY2hlY2svZ2VuZXJhdG9yLm1sIiwiL1VzZXJzL3J1c3NlbGxyb3plbmJhdW0vLm9wYW0vZGl5LWhhemVsbnV0L2xpYi9vY2FtbC9pbnQ2NC5tbGkiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2VfcXVpY2tjaGVjay9zaHJpbmtlci5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZV9xdWlja2NoZWNrL3Rlc3QubWwiLCIvVXNlcnMvcnVzc2VsbHJvemVuYmF1bS8ub3BhbS9kaXktaGF6ZWxudXQvbGliL2Jhc2VfcXVpY2tjaGVjay9vYnNlcnZlci5tbCIsIi9Vc2Vycy9ydXNzZWxscm96ZW5iYXVtLy5vcGFtL2RpeS1oYXplbG51dC9saWIvYmFzZV9xdWlja2NoZWNrL2Jhc2VfcXVpY2tjaGVjay5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7O1lBS01BLGNBQUEscUJBRXNCO0dBTFosaUJBR1ZBO1lBU0FDLE1BQU1DLEdBQUdDO0lBQ1g7S0FBMkIsTUFBQSxl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T0FDQWlFO09BQ0FoRDtPQTNCQXhCO09BYkFvRDtPQU9BRztPQWRBK0o7T0FDQUM7T0FDQUM7T0FDQVE7T0FDQUM7T0E2Q0F4UDtPQW1CQXdTO09BSUFDO09BVkFvRjtPQUlBRztPQXJGQVA7T0FEQUQ7T0FJQXhVO09BRkFGOzs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFOzs7Ozs7OztHQ09hOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsib3BlbiEgQmFzZVxuXG5tb2R1bGUgTGF5b3V0ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIEJpZ2FycmF5LmxheW91dFxuXG4gIGxldCBvZmZzZXQgOiB0eXBlIGEuIGEgdCAtPiBpbnQgPSBmdW5jdGlvblxuICAgIHwgQmlnYXJyYXkuRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIHwgQmlnYXJyYXkuQ19sYXlvdXQgLT4gMFxuICA7O1xuZW5kXG5cbm1vZHVsZSBBcnJheTEgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBCaWdhcnJheS5BcnJheTEudFxuXG4gIGxldCBpdGVyaSB0IH5mID1cbiAgICBsZXQgb2Zmc2V0ID0gTGF5b3V0Lm9mZnNldCAoQmlnYXJyYXkuQXJyYXkxLmxheW91dCB0KSBpblxuICAgIGZvciBpID0gMCB0byBCaWdhcnJheS5BcnJheTEuZGltIHQgLSAxIGRvXG4gICAgICBmIChpICsgb2Zmc2V0KSB0LntpICsgb2Zmc2V0fVxuICAgIGRvbmVcbiAgOztcblxuICBsZXQgaW5pdCAodHlwZSBlbHQpIChraW5kIDogKGVsdCwgXykgQmlnYXJyYXkua2luZCkgbGF5b3V0IGRpbSB+ZiA9XG4gICAgbGV0IHQgPSBCaWdhcnJheS5BcnJheTEuY3JlYXRlIGtpbmQgbGF5b3V0IGRpbSBpblxuICAgIGl0ZXJpIHQgfmY6KGZ1biBpIChfIDogZWx0KSAtPiB0LntpfSA8LSBmIGkpO1xuICAgIHRcbiAgOztcblxuICBsZXQgZm9sZCAodHlwZSBlbHQpICh0IDogKGVsdCwgXywgXykgdCkgfmluaXQgfmYgPVxuICAgIGxldCBpbml0ID0gcmVmIGluaXQgaW5cbiAgICBpdGVyaSB0IH5mOihmdW4gaSAoXyA6IGVsdCkgLT4gaW5pdCA6PSBmICFpbml0IHQue2l9KTtcbiAgICAhaW5pdFxuICA7O1xuXG4gIGxldCB0b19hcnJheSB0ID1cbiAgICBsZXQgb2Zmc2V0ID0gTGF5b3V0Lm9mZnNldCAoQmlnYXJyYXkuQXJyYXkxLmxheW91dCB0KSBpblxuICAgIEFycmF5LmluaXQgKEJpZ2FycmF5LkFycmF5MS5kaW0gdCkgfmY6KGZ1biBpIC0+IHQue2kgKyBvZmZzZXR9KVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9lbHQgX3NleHBfb2ZfcGFjayBfc2V4cF9vZl9sYXlvdXQgdCA9XG4gICAgWyVzZXhwICh0b19hcnJheSB0IDogZWx0IGFycmF5KV1cbiAgOztcblxuICBsZXQgaGFzaF9mb2xkIGhhc2hfZm9sZF9lbHQgc3RhdGUgdCA9XG4gICAgbGV0IHN0YXRlID0gaGFzaF9mb2xkX2ludCBzdGF0ZSAoQmlnYXJyYXkuQXJyYXkxLmRpbSB0KSBpblxuICAgIGZvbGQgdCB+aW5pdDpzdGF0ZSB+ZjpoYXNoX2ZvbGRfZWx0XG4gIDs7XG5lbmRcblxubW9kdWxlIEFycmF5MiA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIEJpZ2FycmF5LkFycmF5Mi50XG5cbiAgbGV0IGl0ZXJpIHQgfmYgPVxuICAgIGxldCBvZmZzZXQgPSBMYXlvdXQub2Zmc2V0IChCaWdhcnJheS5BcnJheTIubGF5b3V0IHQpIGluXG4gICAgZm9yIGkgPSAwIHRvIEJpZ2FycmF5LkFycmF5Mi5kaW0xIHQgLSAxIGRvXG4gICAgICBmb3IgaiA9IDAgdG8gQmlnYXJyYXkuQXJyYXkyLmRpbTIgdCAtIDEgZG9cbiAgICAgICAgZiAoaSArIG9mZnNldCkgKGogKyBvZmZzZXQpIHQue2kgKyBvZmZzZXQsIGogKyBvZmZzZXR9XG4gICAgICBkb25lXG4gICAgZG9uZVxuICA7O1xuXG4gIGxldCBpbml0ICh0eXBlIGVsdCkgKGtpbmQgOiAoZWx0LCBfKSBCaWdhcnJheS5raW5kKSBsYXlvdXQgZGltMSBkaW0yIH5mID1cbiAgICBsZXQgdCA9IEJpZ2FycmF5LkFycmF5Mi5jcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGluXG4gICAgaXRlcmkgdCB+ZjooZnVuIGkgaiAoXyA6IGVsdCkgLT4gdC57aSwgan0gPC0gZiBpIGopO1xuICAgIHRcbiAgOztcblxuICBsZXQgZm9sZCAodHlwZSBlbHQpICh0IDogKGVsdCwgXywgXykgdCkgfmluaXQgfmYgPVxuICAgIGxldCBpbml0ID0gcmVmIGluaXQgaW5cbiAgICBpdGVyaSB0IH5mOihmdW4gKF8gOiBpbnQpIChfIDogaW50KSBlbHQgLT4gaW5pdCA6PSBmICFpbml0IGVsdCk7XG4gICAgIWluaXRcbiAgOztcblxuICBsZXQgdG9fYXJyYXkgdCA9XG4gICAgbGV0IG9mZnNldCA9IExheW91dC5vZmZzZXQgKEJpZ2FycmF5LkFycmF5Mi5sYXlvdXQgdCkgaW5cbiAgICBBcnJheS5pbml0IChCaWdhcnJheS5BcnJheTIuZGltMSB0KSB+ZjooZnVuIGkgLT5cbiAgICAgIEFycmF5LmluaXQgKEJpZ2FycmF5LkFycmF5Mi5kaW0yIHQpIH5mOihmdW4gaiAtPiB0LntpICsgb2Zmc2V0LCBqICsgb2Zmc2V0fSkpXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2VsdCBfc2V4cF9vZl9wYWNrIF9zZXhwX29mX2xheW91dCB0ID1cbiAgICBbJXNleHAgKHRvX2FycmF5IHQgOiBlbHQgYXJyYXkgYXJyYXkpXVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGQgaGFzaF9mb2xkX2VsdCBzdGF0ZSB0ID1cbiAgICBsZXQgc3RhdGUgPSBoYXNoX2ZvbGRfaW50IHN0YXRlIChCaWdhcnJheS5BcnJheTIuZGltMSB0KSBpblxuICAgIGxldCBzdGF0ZSA9IGhhc2hfZm9sZF9pbnQgc3RhdGUgKEJpZ2FycmF5LkFycmF5Mi5kaW0yIHQpIGluXG4gICAgZm9sZCB0IH5pbml0OnN0YXRlIH5mOmhhc2hfZm9sZF9lbHRcbiAgOztcbmVuZFxuIiwib3BlbiEgQmFzZVxuXG50eXBlICdhIHQgPSAnYSAtPiBzaXplOmludCAtPiBoYXNoOkhhc2guc3RhdGUgLT4gSGFzaC5zdGF0ZVxuXG5sZXQgY3JlYXRlIGYgOiBfIHQgPSBmXG5cbmxldCBvYnNlcnZlICh0IDogXyB0KSB4IH5zaXplIH5oYXNoID1cbiAgaWYgc2l6ZSA8IDBcbiAgdGhlbiByYWlzZV9zIFslbWVzc2FnZSBcIkJhc2VfcXVpY2tjaGVjay5PYnNlcnZlci5vYnNlcnZlOiBzaXplIDwgMFwiIChzaXplIDogaW50KV1cbiAgZWxzZSB0IHggfnNpemUgfmhhc2hcbjs7XG5cbmxldCBvcGFxdWUgXyB+c2l6ZTpfIH5oYXNoID0gaGFzaFxuIiwib3BlbiEgQmFzZVxuXG5tb2R1bGUgVCA6IHNpZ1xuICB0eXBlICsnYSB0XG5cbiAgdmFsIGNyZWF0ZSA6IChzaXplOmludCAtPiByYW5kb206U3BsaXR0YWJsZV9yYW5kb20uU3RhdGUudCAtPiAnYSkgLT4gJ2EgdFxuICB2YWwgZ2VuZXJhdGUgOiAnYSB0IC0+IHNpemU6aW50IC0+IHJhbmRvbTpTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS50IC0+ICdhXG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gKHNpemU6aW50IC0+IHJhbmRvbTpTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS50IC0+ICdhKSBTdGFnZWQudFxuXG4gIGxldCBjcmVhdGUgZiA6IF8gdCA9IFN0YWdlZC5zdGFnZSBmXG5cbiAgbGV0IGdlbmVyYXRlICh0IDogXyB0KSB+c2l6ZSB+cmFuZG9tID1cbiAgICBpZiBzaXplIDwgMFxuICAgIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suR2VuZXJhdG9yLmdlbmVyYXRlOiBzaXplIDwgMFwiIChzaXplIDogaW50KV1cbiAgICBlbHNlIFN0YWdlZC51bnN0YWdlIHQgfnNpemUgfnJhbmRvbVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgVFxuXG5sZXQgc2l6ZSA9IGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb206XyAtPiBzaXplKVxuXG5sZXQgZm4gZG9tIHJuZyA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT5cbiAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUuc3BsaXQgcmFuZG9tIGluXG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBoYXNoID0gT2JzZXJ2ZXIwLm9ic2VydmUgZG9tIHggfnNpemUgfmhhc2g6KEhhc2guYWxsb2MgKCkpIGluXG4gICAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUuY29weSByYW5kb20gaW5cbiAgICAgIFNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLnBlcnR1cmIgcmFuZG9tIChIYXNoLmdldF9oYXNoX3ZhbHVlIGhhc2gpO1xuICAgICAgZ2VuZXJhdGUgcm5nIH5zaXplIH5yYW5kb20pXG47O1xuXG5sZXQgd2l0aF9zaXplIHQgfnNpemUgPSBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT4gZ2VuZXJhdGUgdCB+c2l6ZSB+cmFuZG9tKVxuXG5sZXQgcGVydHVyYiB0IHNhbHQgPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUucGVydHVyYiByYW5kb20gc2FsdDtcbiAgICBnZW5lcmF0ZSB0IH5zaXplIH5yYW5kb20pXG47O1xuXG5sZXQgZmlsdGVyX21hcCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIH5zaXplIH5yYW5kb20gPVxuICAgIGxldCB4ID0gZ2VuZXJhdGUgdCB+c2l6ZSB+cmFuZG9tIGluXG4gICAgbWF0Y2ggZiB4IHdpdGhcbiAgICB8IFNvbWUgeSAtPiB5XG4gICAgfCBOb25lIC0+IGxvb3AgfnNpemU6KHNpemUgKyAxKSB+cmFuZG9tXG4gIGluXG4gIGNyZWF0ZSBsb29wXG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPSBmaWx0ZXJfbWFwIHQgfmY6KGZ1biB4IC0+IGlmIGYgeCB0aGVuIFNvbWUgeCBlbHNlIE5vbmUpXG5sZXQgcmV0dXJuIHggPSBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb206XyAtPiB4KVxubGV0IG1hcCB0IH5mID0gY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPiBmIChnZW5lcmF0ZSB0IH5zaXplIH5yYW5kb20pKVxuXG5sZXQgYXBwbHkgdGYgdHggPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgbGV0IGYgPSBnZW5lcmF0ZSB0ZiB+c2l6ZSB+cmFuZG9tIGluXG4gICAgbGV0IHggPSBnZW5lcmF0ZSB0eCB+c2l6ZSB+cmFuZG9tIGluXG4gICAgZiB4KVxuOztcblxubGV0IGJpbmQgdCB+ZiA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT5cbiAgICBsZXQgeCA9IGdlbmVyYXRlIHQgfnNpemUgfnJhbmRvbSBpblxuICAgIGdlbmVyYXRlIChmIHgpIH5zaXplIH5yYW5kb20pXG47O1xuXG5sZXQgYWxsIGxpc3QgPSBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+IExpc3QubWFwIGxpc3QgfmY6KGdlbmVyYXRlIH5zaXplIH5yYW5kb20pKVxuXG5sZXQgYWxsX3VuaXQgbGlzdCA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT4gTGlzdC5pdGVyIGxpc3QgfmY6KGdlbmVyYXRlIH5zaXplIH5yYW5kb20pKVxuOztcblxubW9kdWxlIEZvcl9hcHBsaWNhdGl2ZSA9IEFwcGxpY2F0aXZlLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IGFwcGx5ID0gYXBwbHlcbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgZW5kKVxuXG5sZXQgYm90aCA9IEZvcl9hcHBsaWNhdGl2ZS5ib3RoXG5sZXQgbWFwMiA9IEZvcl9hcHBsaWNhdGl2ZS5tYXAyXG5sZXQgbWFwMyA9IEZvcl9hcHBsaWNhdGl2ZS5tYXAzXG5cbm1vZHVsZSBBcHBsaWNhdGl2ZV9pbmZpeCA9IEZvcl9hcHBsaWNhdGl2ZS5BcHBsaWNhdGl2ZV9pbmZpeFxuaW5jbHVkZSBBcHBsaWNhdGl2ZV9pbmZpeFxuXG5tb2R1bGUgRm9yX21vbmFkID0gTW9uYWQuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgYmluZCA9IGJpbmRcbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgZW5kKVxuXG5sZXQgaWdub3JlX20gPSBGb3JfbW9uYWQuaWdub3JlX21cbmxldCBqb2luID0gRm9yX21vbmFkLmpvaW5cblxubW9kdWxlIE1vbmFkX2luZml4ID0gRm9yX21vbmFkLk1vbmFkX2luZml4XG5pbmNsdWRlIE1vbmFkX2luZml4XG5tb2R1bGUgTGV0X3N5bnRheCA9IEZvcl9tb25hZC5MZXRfc3ludGF4XG5vcGVuIExldF9zeW50YXhcblxubGV0IG9mX2xpc3QgbGlzdCA9XG4gIGlmIExpc3QuaXNfZW1wdHkgbGlzdFxuICB0aGVuIEVycm9yLnJhaXNlX3MgWyVtZXNzYWdlIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5vZl9saXN0OiBlbXB0eSBsaXN0XCJdO1xuICBsZXQgYXJyYXkgPSBBcnJheS5vZl9saXN0IGxpc3QgaW5cbiAgbGV0IGxvID0gMCBpblxuICBsZXQgaGkgPSBBcnJheS5sZW5ndGggYXJyYXkgLSAxIGluXG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIGxldCBpbmRleCA9IFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvIH5oaSBpblxuICAgIGFycmF5LihpbmRleCkpXG47O1xuXG5sZXQgdW5pb24gbGlzdCA9IGpvaW4gKG9mX2xpc3QgbGlzdClcblxubGV0IG9mX3dlaWdodGVkX2xpc3QgYWxpc3QgPVxuICBpZiBMaXN0LmlzX2VtcHR5IGFsaXN0XG4gIHRoZW4gRXJyb3IucmFpc2VfcyBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suR2VuZXJhdG9yLm9mX3dlaWdodGVkX2xpc3Q6IGVtcHR5IGxpc3RcIl07XG4gIGxldCB3ZWlnaHRzLCB2YWx1ZXMgPSBMaXN0LnVuemlwIGFsaXN0IGluXG4gIGxldCB2YWx1ZV9hcnJheSA9IEFycmF5Lm9mX2xpc3QgdmFsdWVzIGluXG4gIGxldCB0b3RhbF93ZWlnaHQsIGN1bXVsYXRpdmVfd2VpZ2h0X2FycmF5ID1cbiAgICBsZXQgYXJyYXkgPSBBcnJheS5pbml0IChBcnJheS5sZW5ndGggdmFsdWVfYXJyYXkpIH5mOihmdW4gXyAtPiAwLikgaW5cbiAgICBsZXQgc3VtID1cbiAgICAgIExpc3QuZm9sZGkgd2VpZ2h0cyB+aW5pdDowLiB+ZjooZnVuIGluZGV4IGFjYyB3ZWlnaHQgLT5cbiAgICAgICAgaWYgbm90IChGbG9hdC5pc19maW5pdGUgd2VpZ2h0KVxuICAgICAgICB0aGVuXG4gICAgICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICAgIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5vZl93ZWlnaHRlZF9saXN0OiB3ZWlnaHQgaXMgbm90IGZpbml0ZVwiXG4gICAgICAgICAgICAgICAgKHdlaWdodCA6IGZsb2F0KV07XG4gICAgICAgIGlmIEZsb2F0LiggPCApIHdlaWdodCAwLlxuICAgICAgICB0aGVuXG4gICAgICAgICAgRXJyb3IucmFpc2Vfc1xuICAgICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICAgIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5vZl93ZWlnaHRlZF9saXN0OiB3ZWlnaHQgaXMgbmVnYXRpdmVcIlxuICAgICAgICAgICAgICAgICh3ZWlnaHQgOiBmbG9hdCldO1xuICAgICAgICBsZXQgY3VtdWxhdGl2ZSA9IGFjYyArLiB3ZWlnaHQgaW5cbiAgICAgICAgYXJyYXkuKGluZGV4KSA8LSBjdW11bGF0aXZlO1xuICAgICAgICBjdW11bGF0aXZlKVxuICAgIGluXG4gICAgaWYgRmxvYXQuKCA8PSApIHN1bSAwLlxuICAgIHRoZW5cbiAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgWyVtZXNzYWdlIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5vZl93ZWlnaHRlZF9saXN0OiB0b3RhbCB3ZWlnaHQgaXMgemVyb1wiXTtcbiAgICBzdW0sIGFycmF5XG4gIGluXG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIGxldCBjaG9pY2UgPSBTcGxpdHRhYmxlX3JhbmRvbS5mbG9hdCByYW5kb20gfmxvOjAuIH5oaTp0b3RhbF93ZWlnaHQgaW5cbiAgICBtYXRjaFxuICAgICAgQXJyYXkuYmluYXJ5X3NlYXJjaFxuICAgICAgICBjdW11bGF0aXZlX3dlaWdodF9hcnJheVxuICAgICAgICB+Y29tcGFyZTpGbG9hdC5jb21wYXJlXG4gICAgICAgIGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG9cbiAgICAgICAgY2hvaWNlXG4gICAgd2l0aFxuICAgIHwgU29tZSBpbmRleCAtPiB2YWx1ZV9hcnJheS4oaW5kZXgpXG4gICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZSlcbjs7XG5cbmxldCB3ZWlnaHRlZF91bmlvbiBhbGlzdCA9IGpvaW4gKG9mX3dlaWdodGVkX2xpc3QgYWxpc3QpXG5sZXQgb2ZfbGF6eSBsYXp5X3QgPSBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+IGdlbmVyYXRlIChmb3JjZSBsYXp5X3QpIH5zaXplIH5yYW5kb20pXG5cbmxldCBmaXhlZF9wb2ludCBvZl9nZW5lcmF0b3IgPVxuICBsZXQgcmVjIGxhenlfdCA9IGxhenkgKG9mX2dlbmVyYXRvciAob2ZfbGF6eSBsYXp5X3QpKSBpblxuICBmb3JjZSBsYXp5X3Rcbjs7XG5cbmxldCB3ZWlnaHRlZF9yZWN1cnNpdmVfdW5pb24gbm9ucmVjX2xpc3QgfmYgPVxuICBmaXhlZF9wb2ludCAoZnVuIHNlbGYgLT5cbiAgICBsZXQgcmVjX2xpc3QgPVxuICAgICAgTGlzdC5tYXAgKGYgc2VsZikgfmY6KGZ1biAodywgdCkgLT5cbiAgICAgICAgKCB3XG4gICAgICAgICwgbGV0JWJpbmQgbiA9IHNpemUgaW5cbiAgICAgICAgICB3aXRoX3NpemUgfnNpemU6KG4gLSAxKSB0ICkpXG4gICAgaW5cbiAgICBpZiBMaXN0LmlzX2VtcHR5IG5vbnJlY19saXN0IHx8IExpc3QuaXNfZW1wdHkgcmVjX2xpc3RcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci53ZWlnaHRlZF9yZWN1cnNpdmVfdW5pb246IGxpc3RzIG11c3QgYmUgbm9uLWVtcHR5XCJdO1xuICAgIGxldCBub25yZWNfZ2VuID0gd2VpZ2h0ZWRfdW5pb24gbm9ucmVjX2xpc3QgaW5cbiAgICBsZXQgcmVjX2dlbiA9IHdlaWdodGVkX3VuaW9uIChub25yZWNfbGlzdCBAIHJlY19saXN0KSBpblxuICAgIG1hdGNoJWJpbmQgc2l6ZSB3aXRoXG4gICAgfCAwIC0+IG5vbnJlY19nZW5cbiAgICB8IF8gLT4gcmVjX2dlbilcbjs7XG5cbmxldCByZWN1cnNpdmVfdW5pb24gbm9ucmVjX2xpc3QgfmYgPVxuICBsZXQgd2VpZ2h0ZWQgbGlzdCA9IExpc3QubWFwIGxpc3QgfmY6KGZ1biB0IC0+IDEuLCB0KSBpblxuICB3ZWlnaHRlZF9yZWN1cnNpdmVfdW5pb24gKHdlaWdodGVkIG5vbnJlY19saXN0KSB+ZjooZnVuIHNlbGYgLT4gd2VpZ2h0ZWQgKGYgc2VsZikpXG47O1xuXG5sZXQgc2l6ZXMgPyhtaW5fbGVuZ3RoID0gMCkgPyhtYXhfbGVuZ3RoID0gSW50Lm1heF92YWx1ZSkgKCkgPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgYXNzZXJ0IChtaW5fbGVuZ3RoIDw9IG1heF9sZW5ndGgpO1xuICAgIGxldCB1cHBlcl9ib3VuZCA9IG1pbl9sZW5ndGggKyBzaXplIGluXG4gICAgbGV0IG1heF9sZW5ndGggPVxuICAgICAgaWYgdXBwZXJfYm91bmQgPj0gbWluX2xlbmd0aCAoKiBndWFyZCBhZ2FpbnN0IG92ZXJmbG93ICopXG4gICAgICB0aGVuIG1pbiBtYXhfbGVuZ3RoIHVwcGVyX2JvdW5kXG4gICAgICBlbHNlIG1heF9sZW5ndGhcbiAgICBpblxuICAgICgqIHBpY2sgYSBsZW5ndGgsIHdlaWdodGVkIGxvdyBzbyB0aGF0IG1vc3Qgb2YgdGhlIHNpemUgaXMgc3BlbnQgb24gZWxlbWVudHMgKilcbiAgICBsZXQgbGVuID0gU3BsaXR0YWJsZV9yYW5kb20uTG9nX3VuaWZvcm0uaW50IHJhbmRvbSB+bG86bWluX2xlbmd0aCB+aGk6bWF4X2xlbmd0aCBpblxuICAgICgqIGlmIHRoZXJlIGFyZSBubyBlbGVtZW50cyByZXR1cm4gYW4gZW1wdHkgYXJyYXksIG90aGVyd2lzZSByZXR1cm4gYSBub24tZW1wdHkgYXJyYXlcbiAgICAgICB3aXRoIHRoZSBzaXplIGRpc3RyaWJ1dGVkIGFtb25nIHRoZSBlbGVtZW50cyAqKVxuICAgIGlmIGxlbiA9IDBcbiAgICB0aGVuIFtdXG4gICAgZWxzZSAoXG4gICAgICBsZXQgc2l6ZXMgPSBBcnJheS5pbml0IGxlbiB+ZjooZnVuIF8gLT4gMCkgaW5cbiAgICAgIGxldCByZW1haW5pbmcgPSBzaXplIC0gKGxlbiAtIG1pbl9sZW5ndGgpIGluXG4gICAgICBsZXQgbWF4X2luZGV4ID0gbGVuIC0gMSBpblxuICAgICAgZm9yIF8gPSAxIHRvIHJlbWFpbmluZyBkb1xuICAgICAgICAoKiBwaWNrIGFuIGluZGV4LCB3ZWlnaHRlZCBsb3cgc28gdGhhdCB3ZSBzZWUgdW5iYWxhbmNlZCBkaXN0cmlidXRpb25zIG9mdGVuICopXG4gICAgICAgIGxldCBpbmRleCA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludCByYW5kb20gfmxvOjAgfmhpOm1heF9pbmRleCBpblxuICAgICAgICBzaXplcy4oaW5kZXgpIDwtIHNpemVzLihpbmRleCkgKyAxXG4gICAgICBkb25lO1xuICAgICAgKCogcGVybXV0ZSB0aGUgYXJyYXkgc28gdGhhdCBubyBpbmRleCBpcyBmYXZvcmVkIG92ZXIgYW5vdGhlciAqKVxuICAgICAgZm9yIGkgPSAwIHRvIG1heF9pbmRleCAtIDEgZG9cbiAgICAgICAgbGV0IGogPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQgcmFuZG9tIH5sbzppIH5oaTptYXhfaW5kZXggaW5cbiAgICAgICAgQXJyYXkuc3dhcCBzaXplcyBpIGpcbiAgICAgIGRvbmU7XG4gICAgICBhc3NlcnQgKEFycmF5LnN1bSAobW9kdWxlIEludCkgc2l6ZXMgfmY6Rm4uaWQgKyAobGVuIC0gbWluX2xlbmd0aCkgPSBzaXplKTtcbiAgICAgIEFycmF5LnRvX2xpc3Qgc2l6ZXMpKVxuOztcblxubGV0IHVuaXQgPSByZXR1cm4gKClcbmxldCBib29sID0gY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+IFNwbGl0dGFibGVfcmFuZG9tLmJvb2wgcmFuZG9tKVxubGV0IG9wdGlvbiB2YWx1ZV90ID0gdW5pb24gWyByZXR1cm4gTm9uZTsgbWFwIHZhbHVlX3QgfmY6T3B0aW9uLnJldHVybiBdXG5sZXQgZWl0aGVyIGZzdF90IHNuZF90ID0gdW5pb24gWyBtYXAgZnN0X3QgfmY6RWl0aGVyLmZpcnN0OyBtYXAgc25kX3QgfmY6RWl0aGVyLnNlY29uZCBdXG5cbmxldCByZXN1bHQgb2tfdCBlcnJfdCA9XG4gIG1hcCAoZWl0aGVyIG9rX3QgZXJyX3QpIH5mOihmdW5jdGlvblxuICAgIHwgRmlyc3Qgb2sgLT4gT2sgb2tcbiAgICB8IFNlY29uZCBlcnIgLT4gRXJyb3IgZXJyKVxuOztcblxubGV0IGxpc3RfZ2VuZXJpYyA/bWluX2xlbmd0aCA/bWF4X2xlbmd0aCBlbHRfZ2VuID1cbiAgbGV0JWJpbmQgc2l6ZXMgPSBzaXplcyA/bWluX2xlbmd0aCA/bWF4X2xlbmd0aCAoKSBpblxuICBMaXN0Lm1hcCBzaXplcyB+ZjooZnVuIHNpemUgLT4gd2l0aF9zaXplIH5zaXplIGVsdF9nZW4pIHw+IGFsbFxuOztcblxubGV0IGxpc3QgZWx0X2dlbiA9IGxpc3RfZ2VuZXJpYyBlbHRfZ2VuXG5sZXQgbGlzdF9ub25fZW1wdHkgZWx0X2dlbiA9IGxpc3RfZ2VuZXJpYyB+bWluX2xlbmd0aDoxIGVsdF9nZW5cblxubGV0IGxpc3Rfd2l0aF9sZW5ndGggZWx0X2dlbiB+bGVuZ3RoID1cbiAgbGlzdF9nZW5lcmljIH5taW5fbGVuZ3RoOmxlbmd0aCB+bWF4X2xlbmd0aDpsZW5ndGggZWx0X2dlblxuOztcblxubGV0IGxpc3RfZmlsdGVyZWQgZWx0cyA9XG4gIGxldCBlbHRzID0gQXJyYXkub2ZfbGlzdCBlbHRzIGluXG4gIGxldCBsZW5ndGhfb2ZfaW5wdXQgPSBBcnJheS5sZW5ndGggZWx0cyBpblxuICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT5cbiAgICBsZXQgbGVuZ3RoX29mX291dHB1dCA9IFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvOjAgfmhpOmxlbmd0aF9vZl9pbnB1dCBpblxuICAgIGxldCBpbmRpY2VzID0gQXJyYXkuaW5pdCBsZW5ndGhfb2ZfaW5wdXQgfmY6Rm4uaWQgaW5cbiAgICAoKiBDaG9vc2UgW2xlbmd0aF9vZl9vdXRwdXRdIHJhbmRvbSB2YWx1ZXMgaW4gdGhlIHByZWZpeCBvZiBbaW5kaWNlc10uICopXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aF9vZl9vdXRwdXQgLSAxIGRvXG4gICAgICBsZXQgaiA9IFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvOmkgfmhpOihsZW5ndGhfb2ZfaW5wdXQgLSAxKSBpblxuICAgICAgQXJyYXkuc3dhcCBpbmRpY2VzIGkgalxuICAgIGRvbmU7XG4gICAgKCogU29ydCB0aGUgY2hvc2VuIGluZGljZXMgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIHJlb3JkZXIgdGhlbS4gKilcbiAgICBBcnJheS5zb3J0IGluZGljZXMgfnBvczowIH5sZW46bGVuZ3RoX29mX291dHB1dCB+Y29tcGFyZTpJbnQuY29tcGFyZTtcbiAgICAoKiBSZXR1cm4gdGhlIGNob3NlbiBlbGVtZW50cy4gKilcbiAgICBMaXN0LmluaXQgbGVuZ3RoX29mX291dHB1dCB+ZjooZnVuIGkgLT4gZWx0cy4oaW5kaWNlcy4oaSkpKSlcbjs7XG5cbmxldCBsaXN0X3Blcm11dGF0aW9ucyBsaXN0ID1cbiAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgbGV0IGFycmF5ID0gQXJyYXkub2ZfbGlzdCBsaXN0IGluXG4gICAgZm9yIGkgPSAxIHRvIEFycmF5Lmxlbmd0aCBhcnJheSAtIDEgZG9cbiAgICAgIGxldCBqID0gU3BsaXR0YWJsZV9yYW5kb20uaW50IHJhbmRvbSB+bG86MCB+aGk6aSBpblxuICAgICAgQXJyYXkuc3dhcCBhcnJheSBpIGpcbiAgICBkb25lO1xuICAgIEFycmF5LnRvX2xpc3QgYXJyYXkpXG47O1xuXG5sZXQgYXJyYXkgdCA9IG1hcCAobGlzdCB0KSB+ZjpBcnJheS5vZl9saXN0XG5sZXQgcmVmIHQgPSBtYXAgdCB+ZjpSZWYuY3JlYXRlXG5sZXQgbGF6eV90IHQgPSBtYXAgdCB+ZjpMYXp5LmZyb21fdmFsXG5cbmxldCBjaGFyX3VuaWZvcm1faW5jbHVzaXZlIGxvIGhpID1cbiAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgU3BsaXR0YWJsZV9yYW5kb20uaW50IHJhbmRvbSB+bG86KENoYXIudG9faW50IGxvKSB+aGk6KENoYXIudG9faW50IGhpKVxuICAgIHw+IENoYXIudW5zYWZlX29mX2ludClcbjs7XG5cbmxldCBjaGFyX3VwcGVyY2FzZSA9IGNoYXJfdW5pZm9ybV9pbmNsdXNpdmUgJ0EnICdaJ1xubGV0IGNoYXJfbG93ZXJjYXNlID0gY2hhcl91bmlmb3JtX2luY2x1c2l2ZSAnYScgJ3onXG5sZXQgY2hhcl9kaWdpdCA9IGNoYXJfdW5pZm9ybV9pbmNsdXNpdmUgJzAnICc5J1xubGV0IGNoYXJfcHJpbnRfdW5pZm9ybSA9IGNoYXJfdW5pZm9ybV9pbmNsdXNpdmUgJyAnICd+J1xubGV0IGNoYXJfdW5pZm9ybSA9IGNoYXJfdW5pZm9ybV9pbmNsdXNpdmUgQ2hhci5taW5fdmFsdWUgQ2hhci5tYXhfdmFsdWVcbmxldCBjaGFyX2FscGhhID0gdW5pb24gWyBjaGFyX2xvd2VyY2FzZTsgY2hhcl91cHBlcmNhc2UgXVxuXG5sZXQgY2hhcl9hbHBoYW51bSA9XG4gIHdlaWdodGVkX3VuaW9uXG4gICAgKCogTW9zdCBwZW9wbGUgcHJvYmFibHkgZXhwZWN0IHRoaXMgdG8gYmUgYSB1bmlmb3JtIGRpc3RyaWJ1dGlvbiwgbm90IHdlaWdodGVkXG4gICAgICAgdG93YXJkIGRpZ2l0cyBsaWtlIHdlIHdvdWxkIGdldCB3aXRoIFt1bmlvbl0gKHNpbmNlIHRoZXJlIGFyZSBmZXdlciBkaWdpdHMgdGhhblxuICAgICAgIGxldHRlcnMpLiAqKVxuICAgIFsgNTIuLCBjaGFyX2FscGhhOyAxMC4sIGNoYXJfZGlnaXQgXVxuOztcblxubGV0IGNoYXJfd2hpdGVzcGFjZSA9IG9mX2xpc3QgKExpc3QuZmlsdGVyIENoYXIuYWxsIH5mOkNoYXIuaXNfd2hpdGVzcGFjZSlcbmxldCBjaGFyX3ByaW50ID0gd2VpZ2h0ZWRfdW5pb24gWyAxMC4sIGNoYXJfYWxwaGFudW07IDEuLCBjaGFyX3ByaW50X3VuaWZvcm0gXVxuXG5sZXQgY2hhciA9XG4gIHdlaWdodGVkX3VuaW9uXG4gICAgWyAxMDAuLCBjaGFyX3ByaW50XG4gICAgOyAxMC4sIGNoYXJfdW5pZm9ybVxuICAgIDsgMS4sIHJldHVybiBDaGFyLm1pbl92YWx1ZVxuICAgIDsgMS4sIHJldHVybiBDaGFyLm1heF92YWx1ZVxuICAgIF1cbjs7XG5cbigqIFByb2R1Y2VzIGEgbnVtYmVyIGZyb20gMCBvciAxIHRvIHNpemUgKyAxLCB3ZWlnaHRlZCBoaWdoLiBXZSBoYXZlIGZvdW5kIHRoaXNcbiAgIGRpc3RyaWJ1dGlvbiBlbXBpcmljYWxseSB1c2VmdWwgZm9yIHN0cmluZyBsZW5ndGhzLiAqKVxubGV0IHNtYWxsX2ludCB+YWxsb3dfemVybyA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT5cbiAgICBsZXQgbG93ZXJfYm91bmQgPSBpZiBhbGxvd196ZXJvIHRoZW4gMCBlbHNlIDEgaW5cbiAgICBsZXQgdXBwZXJfYm91bmQgPSBzaXplICsgMSBpblxuICAgIGxldCB3ZWlnaHRlZF9sb3cgPVxuICAgICAgU3BsaXR0YWJsZV9yYW5kb20uTG9nX3VuaWZvcm0uaW50IHJhbmRvbSB+bG86MCB+aGk6KHVwcGVyX2JvdW5kIC0gbG93ZXJfYm91bmQpXG4gICAgaW5cbiAgICBsZXQgd2VpZ2h0ZWRfaGlnaCA9IHVwcGVyX2JvdW5kIC0gd2VpZ2h0ZWRfbG93IGluXG4gICAgd2VpZ2h0ZWRfaGlnaClcbjs7XG5cbmxldCBzbWFsbF9wb3NpdGl2ZV9vcl96ZXJvX2ludCA9IHNtYWxsX2ludCB+YWxsb3dfemVybzp0cnVlXG5sZXQgc21hbGxfc3RyaWN0bHlfcG9zaXRpdmVfaW50ID0gc21hbGxfaW50IH5hbGxvd196ZXJvOmZhbHNlXG5cbm1vZHVsZSB0eXBlIEludF93aXRoX3JhbmRvbSA9IHNpZ1xuICBpbmNsdWRlIEludC5TXG5cbiAgdmFsIHVuaWZvcm0gOiBTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS50IC0+IGxvOnQgLT4gaGk6dCAtPiB0XG4gIHZhbCBsb2dfdW5pZm9ybSA6IFNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLnQgLT4gbG86dCAtPiBoaTp0IC0+IHRcbmVuZFxuXG5tb2R1bGUgRm9yX2ludGVnZXIgKEludGVnZXIgOiBJbnRfd2l0aF9yYW5kb20pID0gc3RydWN0XG4gIGxldCB1bmlmb3JtX2luY2x1c2l2ZSBsbyBoaSA9XG4gICAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+IEludGVnZXIudW5pZm9ybSByYW5kb20gfmxvIH5oaSlcbiAgOztcblxuICBsZXQgbG9nX3VuaWZvcm1faW5jbHVzaXZlIGxvIGhpID1cbiAgICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT4gSW50ZWdlci5sb2dfdW5pZm9ybSByYW5kb20gfmxvIH5oaSlcbiAgOztcblxuICBsZXQgbm9uX3VuaWZvcm0gZiBsbyBoaSA9XG4gICAgd2VpZ2h0ZWRfdW5pb24gWyAwLjA1LCByZXR1cm4gbG87IDAuMDUsIHJldHVybiBoaTsgMC45LCBmIGxvIGhpIF1cbiAgOztcblxuICBsZXQgaW5jbHVzaXZlID0gbm9uX3VuaWZvcm0gdW5pZm9ybV9pbmNsdXNpdmVcbiAgbGV0IGxvZ19pbmNsdXNpdmUgPSBub25fdW5pZm9ybSBsb2dfdW5pZm9ybV9pbmNsdXNpdmVcbiAgbGV0IHVuaWZvcm1fYWxsID0gdW5pZm9ybV9pbmNsdXNpdmUgSW50ZWdlci5taW5fdmFsdWUgSW50ZWdlci5tYXhfdmFsdWVcblxuICBsZXQgYWxsID1cbiAgICBbJW1hcFxuICAgICAgbGV0IG5lZ2F0aXZlID0gYm9vbFxuICAgICAgYW5kIG1hZ25pdHVkZSA9IGxvZ19pbmNsdXNpdmUgSW50ZWdlci56ZXJvIEludGVnZXIubWF4X3ZhbHVlIGluXG4gICAgICBpZiBuZWdhdGl2ZSB0aGVuIEludGVnZXIuYml0X25vdCBtYWduaXR1ZGUgZWxzZSBtYWduaXR1ZGVdXG4gIDs7XG5lbmRcblxubW9kdWxlIEZvcl9pbnQgPSBGb3JfaW50ZWdlciAoc3RydWN0XG4gICAgaW5jbHVkZSBJbnRcblxuICAgIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uaW50XG4gICAgbGV0IGxvZ191bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uTG9nX3VuaWZvcm0uaW50XG4gIGVuZClcblxubGV0IGludCA9IEZvcl9pbnQuYWxsXG5sZXQgaW50X3VuaWZvcm0gPSBGb3JfaW50LnVuaWZvcm1fYWxsXG5sZXQgaW50X2luY2x1c2l2ZSA9IEZvcl9pbnQuaW5jbHVzaXZlXG5sZXQgaW50X3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludC51bmlmb3JtX2luY2x1c2l2ZVxubGV0IGludF9sb2dfaW5jbHVzaXZlID0gRm9yX2ludC5sb2dfaW5jbHVzaXZlXG5sZXQgaW50X2xvZ191bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQubG9nX3VuaWZvcm1faW5jbHVzaXZlXG5cbm1vZHVsZSBGb3JfaW50MzIgPSBGb3JfaW50ZWdlciAoc3RydWN0XG4gICAgaW5jbHVkZSBJbnQzMlxuXG4gICAgbGV0IHVuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQzMlxuICAgIGxldCBsb2dfdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludDMyXG4gIGVuZClcblxubGV0IGludDMyID0gRm9yX2ludDMyLmFsbFxubGV0IGludDMyX3VuaWZvcm0gPSBGb3JfaW50MzIudW5pZm9ybV9hbGxcbmxldCBpbnQzMl9pbmNsdXNpdmUgPSBGb3JfaW50MzIuaW5jbHVzaXZlXG5sZXQgaW50MzJfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50MzIudW5pZm9ybV9pbmNsdXNpdmVcbmxldCBpbnQzMl9sb2dfaW5jbHVzaXZlID0gRm9yX2ludDMyLmxvZ19pbmNsdXNpdmVcbmxldCBpbnQzMl9sb2dfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50MzIubG9nX3VuaWZvcm1faW5jbHVzaXZlXG5cbm1vZHVsZSBGb3JfaW50NjMgPSBGb3JfaW50ZWdlciAoc3RydWN0XG4gICAgaW5jbHVkZSBJbnQ2M1xuXG4gICAgbGV0IHVuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQ2M1xuICAgIGxldCBsb2dfdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludDYzXG4gIGVuZClcblxubGV0IGludDYzID0gRm9yX2ludDYzLmFsbFxubGV0IGludDYzX3VuaWZvcm0gPSBGb3JfaW50NjMudW5pZm9ybV9hbGxcbmxldCBpbnQ2M19pbmNsdXNpdmUgPSBGb3JfaW50NjMuaW5jbHVzaXZlXG5sZXQgaW50NjNfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50NjMudW5pZm9ybV9pbmNsdXNpdmVcbmxldCBpbnQ2M19sb2dfaW5jbHVzaXZlID0gRm9yX2ludDYzLmxvZ19pbmNsdXNpdmVcbmxldCBpbnQ2M19sb2dfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50NjMubG9nX3VuaWZvcm1faW5jbHVzaXZlXG5cbm1vZHVsZSBGb3JfaW50NjQgPSBGb3JfaW50ZWdlciAoc3RydWN0XG4gICAgaW5jbHVkZSBJbnQ2NFxuXG4gICAgbGV0IHVuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQ2NFxuICAgIGxldCBsb2dfdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludDY0XG4gIGVuZClcblxubGV0IGludDY0ID0gRm9yX2ludDY0LmFsbFxubGV0IGludDY0X3VuaWZvcm0gPSBGb3JfaW50NjQudW5pZm9ybV9hbGxcbmxldCBpbnQ2NF9pbmNsdXNpdmUgPSBGb3JfaW50NjQuaW5jbHVzaXZlXG5sZXQgaW50NjRfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50NjQudW5pZm9ybV9pbmNsdXNpdmVcbmxldCBpbnQ2NF9sb2dfaW5jbHVzaXZlID0gRm9yX2ludDY0LmxvZ19pbmNsdXNpdmVcbmxldCBpbnQ2NF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50NjQubG9nX3VuaWZvcm1faW5jbHVzaXZlXG5cbm1vZHVsZSBGb3JfbmF0aXZlaW50ID0gRm9yX2ludGVnZXIgKHN0cnVjdFxuICAgIGluY2x1ZGUgTmF0aXZlaW50XG5cbiAgICBsZXQgdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLm5hdGl2ZWludFxuICAgIGxldCBsb2dfdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLm5hdGl2ZWludFxuICBlbmQpXG5cbmxldCBuYXRpdmVpbnQgPSBGb3JfbmF0aXZlaW50LmFsbFxubGV0IG5hdGl2ZWludF91bmlmb3JtID0gRm9yX25hdGl2ZWludC51bmlmb3JtX2FsbFxubGV0IG5hdGl2ZWludF9pbmNsdXNpdmUgPSBGb3JfbmF0aXZlaW50LmluY2x1c2l2ZVxubGV0IG5hdGl2ZWludF91bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9uYXRpdmVpbnQudW5pZm9ybV9pbmNsdXNpdmVcbmxldCBuYXRpdmVpbnRfbG9nX2luY2x1c2l2ZSA9IEZvcl9uYXRpdmVpbnQubG9nX2luY2x1c2l2ZVxubGV0IG5hdGl2ZWludF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfbmF0aXZlaW50LmxvZ191bmlmb3JtX2luY2x1c2l2ZVxubGV0IGZsb2F0X3plcm9fZXhwb25lbnQgPSBGbG9hdC5pZWVlX2V4cG9uZW50IDAuXG5sZXQgZmxvYXRfemVyb19tYW50aXNzYSA9IEZsb2F0LmllZWVfbWFudGlzc2EgMC5cblxubGV0IGZsb2F0X21heF9wb3NpdGl2ZV9zdWJub3JtYWxfdmFsdWUgPVxuICBGbG9hdC5vbmVfdWxwIGBEb3duIEZsb2F0Lm1pbl9wb3NpdGl2ZV9ub3JtYWxfdmFsdWVcbjs7XG5cbmxldCBmbG9hdF9zdWJub3JtYWxfZXhwb25lbnQgPSBGbG9hdC5pZWVlX2V4cG9uZW50IEZsb2F0Lm1pbl9wb3NpdGl2ZV9zdWJub3JtYWxfdmFsdWVcbmxldCBmbG9hdF9taW5fc3Vibm9ybWFsX21hbnRpc3NhID0gRmxvYXQuaWVlZV9tYW50aXNzYSBGbG9hdC5taW5fcG9zaXRpdmVfc3Vibm9ybWFsX3ZhbHVlXG5sZXQgZmxvYXRfbWF4X3N1Ym5vcm1hbF9tYW50aXNzYSA9IEZsb2F0LmllZWVfbWFudGlzc2EgZmxvYXRfbWF4X3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZVxubGV0IGZsb2F0X21heF9wb3NpdGl2ZV9ub3JtYWxfdmFsdWUgPSBGbG9hdC5tYXhfZmluaXRlX3ZhbHVlXG5sZXQgZmxvYXRfbWluX25vcm1hbF9leHBvbmVudCA9IEZsb2F0LmllZWVfZXhwb25lbnQgRmxvYXQubWluX3Bvc2l0aXZlX25vcm1hbF92YWx1ZVxubGV0IGZsb2F0X21heF9ub3JtYWxfZXhwb25lbnQgPSBGbG9hdC5pZWVlX2V4cG9uZW50IGZsb2F0X21heF9wb3NpdGl2ZV9ub3JtYWxfdmFsdWVcbmxldCBmbG9hdF9tYXhfbm9ybWFsX21hbnRpc3NhID0gRmxvYXQuaWVlZV9tYW50aXNzYSBmbG9hdF9tYXhfcG9zaXRpdmVfbm9ybWFsX3ZhbHVlXG5sZXQgZmxvYXRfaW5mX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCBGbG9hdC5pbmZpbml0eVxubGV0IGZsb2F0X2luZl9tYW50aXNzYSA9IEZsb2F0LmllZWVfbWFudGlzc2EgRmxvYXQuaW5maW5pdHlcbmxldCBmbG9hdF9uYW5fZXhwb25lbnQgPSBGbG9hdC5pZWVlX2V4cG9uZW50IEZsb2F0Lm5hblxubGV0IGZsb2F0X21pbl9uYW5fbWFudGlzc2EgPSBJbnQ2My5zdWNjIGZsb2F0X2luZl9tYW50aXNzYVxubGV0IGZsb2F0X21heF9uYW5fbWFudGlzc2EgPSBmbG9hdF9tYXhfbm9ybWFsX21hbnRpc3NhXG5sZXQgZmxvYXRfbnVtX21hbnRpc3NhX2JpdHMgPSA1MlxuXG4oKiBXZSB3ZWlnaHQgbWFudGlzc2FzIHNvIHRoYXQgXCJpbnRlZ2VyLWxpa2VcIiB2YWx1ZXMsIGFuZCB2YWx1ZXMgd2l0aCBvbmx5IGEgZmV3IGRpZ2l0c1xuICAgcGFzdCB0aGUgZGVjaW1hbCwgYXJlIHJlYXNvbmFibHkgY29tbW9uLiAqKVxubGV0IGZsb2F0X25vcm1hbF9tYW50aXNzYSA9XG4gIGxldCViaW5kIG51bV9iaXRzID0gRm9yX2ludC51bmlmb3JtX2luY2x1c2l2ZSAwIGZsb2F0X251bV9tYW50aXNzYV9iaXRzIGluXG4gIGxldCVtYXAgYml0cyA9XG4gICAgRm9yX2ludDYzLmluY2x1c2l2ZSBJbnQ2My56ZXJvIChJbnQ2My5wcmVkIChJbnQ2My5zaGlmdF9sZWZ0IEludDYzLm9uZSBudW1fYml0cykpXG4gIGluXG4gIEludDYzLnNoaWZ0X2xlZnQgYml0cyAoSW50LiggLSApIGZsb2F0X251bV9tYW50aXNzYV9iaXRzIG51bV9iaXRzKVxuOztcblxubGV0IGZsb2F0X2V4cG9uZW50X3dlaWdodGVkX2xvdyBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZCA9XG4gIGxldCVtYXAgb2Zmc2V0ID0gRm9yX2ludC5sb2dfaW5jbHVzaXZlIDAgKEludC4oIC0gKSB1cHBlcl9ib3VuZCBsb3dlcl9ib3VuZCkgaW5cbiAgSW50LiggKyApIGxvd2VyX2JvdW5kIG9mZnNldFxuOztcblxubGV0IGZsb2F0X2V4cG9uZW50X3dlaWdodGVkX2hpZ2ggbG93ZXJfYm91bmQgdXBwZXJfYm91bmQgPVxuICBsZXQlbWFwIG9mZnNldCA9IEZvcl9pbnQubG9nX2luY2x1c2l2ZSAwIChJbnQuKCAtICkgdXBwZXJfYm91bmQgbG93ZXJfYm91bmQpIGluXG4gIEludC4oIC0gKSB1cHBlcl9ib3VuZCBvZmZzZXRcbjs7XG5cbigqIFdlIHdlaWdodCBleHBvbmVudHMgc3VjaCB0aGF0IHZhbHVlcyBuZWFyIDEgYXJlIG1vcmUgbGlrZWx5LiAqKVxubGV0IGZsb2F0X2V4cG9uZW50ID1cbiAgbGV0IG1pZHBvaW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCAxLiBpblxuICB1bmlvblxuICAgIFsgZmxvYXRfZXhwb25lbnRfd2VpZ2h0ZWRfaGlnaCBmbG9hdF9taW5fbm9ybWFsX2V4cG9uZW50IG1pZHBvaW50XG4gICAgOyBmbG9hdF9leHBvbmVudF93ZWlnaHRlZF9sb3cgbWlkcG9pbnQgZmxvYXRfbWF4X25vcm1hbF9leHBvbmVudFxuICAgIF1cbjs7XG5cbmxldCBmbG9hdF96ZXJvID1cbiAgbGV0JW1hcCBuZWdhdGl2ZSA9IGJvb2wgaW5cbiAgRmxvYXQuY3JlYXRlX2llZWVfZXhuXG4gICAgfm5lZ2F0aXZlXG4gICAgfmV4cG9uZW50OmZsb2F0X3plcm9fZXhwb25lbnRcbiAgICB+bWFudGlzc2E6ZmxvYXRfemVyb19tYW50aXNzYVxuOztcblxubGV0IGZsb2F0X3N1Ym5vcm1hbCA9XG4gIGxldCVtYXAgbmVnYXRpdmUgPSBib29sXG4gIGFuZCBleHBvbmVudCA9IHJldHVybiBmbG9hdF9zdWJub3JtYWxfZXhwb25lbnRcbiAgYW5kIG1hbnRpc3NhID1cbiAgICBGb3JfaW50NjMubG9nX2luY2x1c2l2ZSBmbG9hdF9taW5fc3Vibm9ybWFsX21hbnRpc3NhIGZsb2F0X21heF9zdWJub3JtYWxfbWFudGlzc2FcbiAgaW5cbiAgRmxvYXQuY3JlYXRlX2llZWVfZXhuIH5uZWdhdGl2ZSB+ZXhwb25lbnQgfm1hbnRpc3NhXG47O1xuXG5sZXQgZmxvYXRfbm9ybWFsID1cbiAgbGV0JW1hcCBuZWdhdGl2ZSA9IGJvb2xcbiAgYW5kIGV4cG9uZW50ID0gZmxvYXRfZXhwb25lbnRcbiAgYW5kIG1hbnRpc3NhID0gZmxvYXRfbm9ybWFsX21hbnRpc3NhIGluXG4gIEZsb2F0LmNyZWF0ZV9pZWVlX2V4biB+bmVnYXRpdmUgfmV4cG9uZW50IH5tYW50aXNzYVxuOztcblxubGV0IGZsb2F0X2luZmluaXRlID1cbiAgbGV0JW1hcCBuZWdhdGl2ZSA9IGJvb2wgaW5cbiAgRmxvYXQuY3JlYXRlX2llZWVfZXhuXG4gICAgfm5lZ2F0aXZlXG4gICAgfmV4cG9uZW50OmZsb2F0X2luZl9leHBvbmVudFxuICAgIH5tYW50aXNzYTpmbG9hdF9pbmZfbWFudGlzc2Fcbjs7XG5cbmxldCBmbG9hdF9uYW4gPVxuICBsZXQlbWFwIG5lZ2F0aXZlID0gYm9vbFxuICBhbmQgZXhwb25lbnQgPSByZXR1cm4gZmxvYXRfbmFuX2V4cG9uZW50XG4gIGFuZCBtYW50aXNzYSA9IEZvcl9pbnQ2My5pbmNsdXNpdmUgZmxvYXRfbWluX25hbl9tYW50aXNzYSBmbG9hdF9tYXhfbmFuX21hbnRpc3NhIGluXG4gIEZsb2F0LmNyZWF0ZV9pZWVlX2V4biB+bmVnYXRpdmUgfmV4cG9uZW50IH5tYW50aXNzYVxuOztcblxubGV0IGZsb2F0X29mX2NsYXNzIGMgPVxuICBtYXRjaCAoYyA6IEZsb2F0LkNsYXNzLnQpIHdpdGhcbiAgfCBaZXJvIC0+IGZsb2F0X3plcm9cbiAgfCBTdWJub3JtYWwgLT4gZmxvYXRfc3Vibm9ybWFsXG4gIHwgTm9ybWFsIC0+IGZsb2F0X25vcm1hbFxuICB8IEluZmluaXRlIC0+IGZsb2F0X2luZmluaXRlXG4gIHwgTmFuIC0+IGZsb2F0X25hblxuOztcblxubGV0IGZsb2F0X3dlaWdodF9vZl9jbGFzcyBjID1cbiAgbWF0Y2ggKGMgOiBGbG9hdC5DbGFzcy50KSB3aXRoXG4gIHwgWmVybyAtPiAxLlxuICB8IFN1Ym5vcm1hbCAtPiAxMC5cbiAgfCBOb3JtYWwgLT4gMTAwLlxuICB8IEluZmluaXRlIC0+IDEuXG4gIHwgTmFuIC0+IDEuXG47O1xuXG5sZXQgZmxvYXRfbWF0Y2hpbmdfY2xhc3NlcyBmaWx0ZXIgPVxuICBMaXN0LmZpbHRlcl9tYXAgRmxvYXQuQ2xhc3MuYWxsIH5mOihmdW4gYyAtPlxuICAgIGlmIGZpbHRlciBjIHRoZW4gU29tZSAoZmxvYXRfd2VpZ2h0X29mX2NsYXNzIGMsIGZsb2F0X29mX2NsYXNzIGMpIGVsc2UgTm9uZSlcbiAgfD4gd2VpZ2h0ZWRfdW5pb25cbjs7XG5cbmxldCBmbG9hdF9maW5pdGUgPVxuICBmbG9hdF9tYXRjaGluZ19jbGFzc2VzIChmdW5jdGlvblxuICAgIHwgWmVybyB8IFN1Ym5vcm1hbCB8IE5vcm1hbCAtPiB0cnVlXG4gICAgfCBJbmZpbml0ZSB8IE5hbiAtPiBmYWxzZSlcbjs7XG5cbmxldCBmbG9hdF93aXRob3V0X25hbiA9XG4gIGZsb2F0X21hdGNoaW5nX2NsYXNzZXMgKGZ1bmN0aW9uXG4gICAgfCBaZXJvIHwgU3Vibm9ybWFsIHwgTm9ybWFsIHwgSW5maW5pdGUgLT4gdHJ1ZVxuICAgIHwgTmFuIC0+IGZhbHNlKVxuOztcblxubGV0IGZsb2F0ID0gZmxvYXRfbWF0Y2hpbmdfY2xhc3NlcyAoZnVuIF8gLT4gdHJ1ZSlcblxubGV0IGZsb2F0X2Zpbml0ZV9ub25femVybyA9XG4gIGZsb2F0X21hdGNoaW5nX2NsYXNzZXMgKGZ1bmN0aW9uXG4gICAgfCBTdWJub3JtYWwgfCBOb3JtYWwgLT4gdHJ1ZVxuICAgIHwgWmVybyB8IEluZmluaXRlIHwgTmFuIC0+IGZhbHNlKVxuOztcblxubGV0IGZsb2F0X3N0cmljdGx5X3Bvc2l0aXZlID1cbiAgbGV0JW1hcCB0ID0gZmxvYXRfZmluaXRlX25vbl96ZXJvIGluXG4gIEZsb2F0LmFicyB0XG47O1xuXG5sZXQgZmxvYXRfc3RyaWN0bHlfbmVnYXRpdmUgPVxuICBsZXQlbWFwIHQgPSBmbG9hdF9maW5pdGVfbm9uX3plcm8gaW5cbiAgfi0uKEZsb2F0LmFicyB0KVxuOztcblxubGV0IGZsb2F0X3Bvc2l0aXZlX29yX3plcm8gPVxuICBsZXQlbWFwIHQgPSBmbG9hdF9maW5pdGUgaW5cbiAgRmxvYXQuYWJzIHRcbjs7XG5cbmxldCBmbG9hdF9uZWdhdGl2ZV9vcl96ZXJvID1cbiAgbGV0JW1hcCB0ID0gZmxvYXRfZmluaXRlIGluXG4gIH4tLihGbG9hdC5hYnMgdClcbjs7XG5cbmxldCBmbG9hdF91bmlmb3JtX2V4Y2x1c2l2ZSBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZCA9XG4gIGxldCBvcGVuIEZsb2F0Lk8gaW5cbiAgaWYgKG5vdCAoRmxvYXQuaXNfZmluaXRlIGxvd2VyX2JvdW5kKSkgfHwgbm90IChGbG9hdC5pc19maW5pdGUgdXBwZXJfYm91bmQpXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJGbG9hdC51bmlmb3JtX2V4Y2x1c2l2ZTogYm91bmRzIGFyZSBub3QgZmluaXRlXCJcbiAgICAgICAgICAobG93ZXJfYm91bmQgOiBmbG9hdClcbiAgICAgICAgICAodXBwZXJfYm91bmQgOiBmbG9hdCldO1xuICBsZXQgbG93ZXJfaW5jbHVzaXZlID0gRmxvYXQub25lX3VscCBgVXAgbG93ZXJfYm91bmQgaW5cbiAgbGV0IHVwcGVyX2luY2x1c2l2ZSA9IEZsb2F0Lm9uZV91bHAgYERvd24gdXBwZXJfYm91bmQgaW5cbiAgaWYgbG93ZXJfaW5jbHVzaXZlID4gdXBwZXJfaW5jbHVzaXZlXG4gIHRoZW5cbiAgICByYWlzZV9zXG4gICAgICBbJW1lc3NhZ2VcbiAgICAgICAgXCJGbG9hdC51bmlmb3JtX2V4Y2x1c2l2ZTogcmVxdWVzdGVkIHJhbmdlIGlzIGVtcHR5XCJcbiAgICAgICAgICAobG93ZXJfYm91bmQgOiBmbG9hdClcbiAgICAgICAgICAodXBwZXJfYm91bmQgOiBmbG9hdCldO1xuICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT5cbiAgICBTcGxpdHRhYmxlX3JhbmRvbS5mbG9hdCByYW5kb20gfmxvOmxvd2VyX2luY2x1c2l2ZSB+aGk6dXBwZXJfaW5jbHVzaXZlKVxuOztcblxubGV0IGZsb2F0X2luY2x1c2l2ZSBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZCA9XG4gIGlmIEZsb2F0LmVxdWFsIGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kXG4gIHRoZW4gcmV0dXJuIGxvd2VyX2JvdW5kXG4gIGVsc2UgaWYgRmxvYXQuKCA9ICkgKEZsb2F0Lm9uZV91bHAgYFVwIGxvd2VyX2JvdW5kKSB1cHBlcl9ib3VuZFxuICB0aGVuIHVuaW9uIFsgcmV0dXJuIGxvd2VyX2JvdW5kOyByZXR1cm4gdXBwZXJfYm91bmQgXVxuICBlbHNlXG4gICAgd2VpZ2h0ZWRfdW5pb25cbiAgICAgIFsgMC4wNSwgcmV0dXJuIGxvd2VyX2JvdW5kXG4gICAgICA7IDAuMDUsIHJldHVybiB1cHBlcl9ib3VuZFxuICAgICAgOyAwLjksIGZsb2F0X3VuaWZvcm1fZXhjbHVzaXZlIGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kXG4gICAgICBdXG47O1xuXG5sZXQgc3RyaW5nX3dpdGhfbGVuZ3RoX29mIGNoYXJfZ2VuIH5sZW5ndGggPVxuICBsaXN0X3dpdGhfbGVuZ3RoIGNoYXJfZ2VuIH5sZW5ndGggfD4gbWFwIH5mOlN0cmluZy5vZl9jaGFyX2xpc3Rcbjs7XG5cbmxldCBzdHJpbmdfb2YgY2hhcl9nZW4gPVxuICBiaW5kIHNtYWxsX3Bvc2l0aXZlX29yX3plcm9faW50IH5mOihmdW4gbGVuZ3RoIC0+XG4gICAgc3RyaW5nX3dpdGhfbGVuZ3RoX29mIGNoYXJfZ2VuIH5sZW5ndGgpXG47O1xuXG5sZXQgc3RyaW5nX25vbl9lbXB0eV9vZiBjaGFyX2dlbiA9XG4gIGJpbmQgc21hbGxfc3RyaWN0bHlfcG9zaXRpdmVfaW50IH5mOihmdW4gbGVuZ3RoIC0+XG4gICAgc3RyaW5nX3dpdGhfbGVuZ3RoX29mIGNoYXJfZ2VuIH5sZW5ndGgpXG47O1xuXG5sZXQgc3RyaW5nID0gc3RyaW5nX29mIGNoYXJcbmxldCBzdHJpbmdfbm9uX2VtcHR5ID0gc3RyaW5nX25vbl9lbXB0eV9vZiBjaGFyXG5sZXQgc3RyaW5nX3dpdGhfbGVuZ3RoIH5sZW5ndGggPSBzdHJpbmdfd2l0aF9sZW5ndGhfb2YgY2hhciB+bGVuZ3RoXG5sZXQgYnl0ZXMgPSBtYXAgc3RyaW5nIH5mOkJ5dGVzLm9mX3N0cmluZ1xuXG5sZXQgc2V4cF9vZiBhdG9tID1cbiAgZml4ZWRfcG9pbnQgKGZ1biBzZWxmIC0+XG4gICAgbGV0JWJpbmQgc2l6ZSA9IHNpemUgaW5cbiAgICAoKiBjaG9vc2UgYSBudW1iZXIgd2VpZ2h0ZWQgbG93IHNvIHdlIGhhdmUgYSBkZWNyZWFzaW5nLCBidXQgbm90IHZhbmlzaGluZywgY2hhbmNlXG4gICAgICAgdG8gZ2VuZXJhdGUgYXRvbXMgYXMgc2l6ZSBncm93cyAqKVxuICAgIG1hdGNoJWJpbmQgRm9yX2ludC5sb2dfdW5pZm9ybV9pbmNsdXNpdmUgMCAoc2l6ZSArIDEpIHdpdGhcbiAgICAoKiBnZW5lcmF0ZSBhbiBhdG9tIHVzaW5nIHRoZSBnaXZlbiBzaXplICopXG4gICAgfCAwIC0+XG4gICAgICBsZXQlbWFwIGF0b20gPSBhdG9tIGluXG4gICAgICBTZXhwLkF0b20gYXRvbVxuICAgICgqIHJlbHlpbmcgb24gW0xpc3QuZ2VuXSB0byBkaXN0cmlidXRlIFtzaXplXSBvdmVyIHN1Yi1zZXhwcyAqKVxuICAgIHwgXyAtPlxuICAgICAgbGV0JW1hcCBsaXN0ID0gbGlzdCBzZWxmIGluXG4gICAgICBTZXhwLkxpc3QgbGlzdClcbjs7XG5cbmxldCBzZXhwID0gc2V4cF9vZiBzdHJpbmdcblxubGV0IG1hcF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3Iga2V5X2dlbiBkYXRhX2dlbiA9XG4gIGxldCViaW5kIGtleXMgPSBsaXN0IGtleV9nZW4gaW5cbiAgbGV0IGtleXMgPSBMaXN0LmRlZHVwX2FuZF9zb3J0IGtleXMgfmNvbXBhcmU6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgbGV0JWJpbmQgZGF0YSA9IGxpc3Rfd2l0aF9sZW5ndGggZGF0YV9nZW4gfmxlbmd0aDooTGlzdC5sZW5ndGgga2V5cykgaW5cbiAgcmV0dXJuIChNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLm9mX2FsaXN0X2V4biB+Y29tcGFyYXRvciAoTGlzdC56aXBfZXhuIGtleXMgZGF0YSkpXG47O1xuXG5sZXQgc2V0X3RyZWVfdXNpbmdfY29tcGFyYXRvciB+Y29tcGFyYXRvciBlbHRfZ2VuID1cbiAgbWFwIChsaXN0IGVsdF9nZW4pIH5mOihTZXQuVXNpbmdfY29tcGFyYXRvci5UcmVlLm9mX2xpc3QgfmNvbXBhcmF0b3IpXG47O1xuXG5sZXQgY29tcGFyYXRvcl9vZl9tXG4gICAgICAodHlwZSBhIGMpXG4gICAgICAobW9kdWxlIE0gOiBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgPSBhIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGMpXG4gID1cbiAgTS5jb21wYXJhdG9yXG47O1xuXG5sZXQgbWFwX3RfbSBtIGtleV9nZW4gZGF0YV9nZW4gPVxuICBsZXQgY29tcGFyYXRvciA9IGNvbXBhcmF0b3Jfb2ZfbSBtIGluXG4gIG1hcF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3Iga2V5X2dlbiBkYXRhX2dlblxuICB8PiBtYXAgfmY6KE1hcC5Vc2luZ19jb21wYXJhdG9yLm9mX3RyZWUgfmNvbXBhcmF0b3IpXG47O1xuXG5sZXQgc2V0X3RfbSBtIGVsdF9nZW4gPVxuICBsZXQgY29tcGFyYXRvciA9IGNvbXBhcmF0b3Jfb2ZfbSBtIGluXG4gIHNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3IgZWx0X2dlblxuICB8PiBtYXAgfmY6KFNldC5Vc2luZ19jb21wYXJhdG9yLm9mX3RyZWUgfmNvbXBhcmF0b3IpXG47O1xuXG5sZXQgYmlnYXJyYXkxIHQga2luZCBsYXlvdXQgPVxuICBsZXQlbWFwIGVsdHMgPSBsaXN0IHQgaW5cbiAgbGV0IGVsdHMgPSBBcnJheS5vZl9saXN0IGVsdHMgaW5cbiAgbGV0IGRpbSA9IEFycmF5Lmxlbmd0aCBlbHRzIGluXG4gIGxldCBvZmZzZXQgPSBCaWdhcnJheV9oZWxwZXJzLkxheW91dC5vZmZzZXQgbGF5b3V0IGluXG4gIEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkxLmluaXQga2luZCBsYXlvdXQgZGltIH5mOihmdW4gaSAtPiBlbHRzLihpIC0gb2Zmc2V0KSlcbjs7XG5cbmxldCBiaWdzdHJpbmcgPSBiaWdhcnJheTEgY2hhciBDaGFyIENfbGF5b3V0XG5sZXQgZmxvYXQzMl92ZWMgPSBiaWdhcnJheTEgZmxvYXQgRmxvYXQzMiBGb3J0cmFuX2xheW91dFxubGV0IGZsb2F0NjRfdmVjID0gYmlnYXJyYXkxIGZsb2F0IEZsb2F0NjQgRm9ydHJhbl9sYXlvdXRcblxubGV0IGJpZ2FycmF5Ml9kaW0gPVxuICBtYXRjaCViaW5kIHNpemUgd2l0aFxuICB8IDAgLT4gcmV0dXJuICgwLCAwKVxuICB8IG1heF90b3RhbF9zaXplIC0+XG4gICAgbGV0JWJpbmQgYSA9XG4gICAgICAoKiBjaG9vc2UgYSBkaW1lbnNpb24gdXAgdG8gW21heF90b3RhbF9zaXplXSwgd2VpZ2h0ZWQgbG93IHRvIGdpdmUgdGhlIG90aGVyXG4gICAgICAgICBkaW1lbnNpb24gYSBnb29kIGNoYW5jZSBvZiBiZWluZyBjb21wYXJhdGl2ZWx5IGhpZ2ggKilcbiAgICAgIGludF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUgMSBtYXhfdG90YWxfc2l6ZVxuICAgIGluXG4gICAgbGV0JWJpbmQgYiA9XG4gICAgICAoKiBjaG9vc2UgYSBkaW1lbnNpb24gdXAgdG8gW21heF90b3RhbF9zaXplIC8gYV0sIHdlaWdodGVkIGhpZ2ggdG8gcmVhY2ggY2xvc2UgdG9cbiAgICAgICAgIFttYXhfdG90YWxfc2l6ZV0gbW9zdCBvZiB0aGUgdGltZSAqKVxuICAgICAgbGV0IG1heF9iID0gbWF4X3RvdGFsX3NpemUgLyBhIGluXG4gICAgICBsZXQlbWFwIGJfd2VpZ2h0ZWRfbG93ID0gaW50X2xvZ191bmlmb3JtX2luY2x1c2l2ZSAwIG1heF9iIGluXG4gICAgICBtYXhfYiAtIGJfd2VpZ2h0ZWRfbG93XG4gICAgaW5cbiAgICAoKiBhdm9pZCBhbnkgc2tldyBvZiBhIHZzIGIgYnkgcmFuZG9tbHkgc3dhcHBpbmcgKilcbiAgICBpZiVtYXAgYm9vbCB0aGVuIGEsIGIgZWxzZSBiLCBhXG47O1xuXG5sZXQgYmlnYXJyYXkyIHQga2luZCBsYXlvdXQgPVxuICBsZXQlYmluZCBkaW0xLCBkaW0yID0gYmlnYXJyYXkyX2RpbSBpblxuICBsZXQlbWFwIGVsdHMgPSBsaXN0X3dpdGhfbGVuZ3RoIH5sZW5ndGg6ZGltMSAobGlzdF93aXRoX2xlbmd0aCB+bGVuZ3RoOmRpbTIgdCkgaW5cbiAgbGV0IGVsdHMgPSBBcnJheS5vZl9saXN0X21hcCB+ZjpBcnJheS5vZl9saXN0IGVsdHMgaW5cbiAgbGV0IG9mZnNldCA9IEJpZ2FycmF5X2hlbHBlcnMuTGF5b3V0Lm9mZnNldCBsYXlvdXQgaW5cbiAgQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaW5pdCBraW5kIGxheW91dCBkaW0xIGRpbTIgfmY6KGZ1biBpIGogLT5cbiAgICBlbHRzLihpIC0gb2Zmc2V0KS4oaiAtIG9mZnNldCkpXG47O1xuXG5sZXQgZmxvYXQzMl9tYXQgPSBiaWdhcnJheTIgZmxvYXQgRmxvYXQzMiBGb3J0cmFuX2xheW91dFxubGV0IGZsb2F0NjRfbWF0ID0gYmlnYXJyYXkyIGZsb2F0IEZsb2F0NjQgRm9ydHJhbl9sYXlvdXRcblxubW9kdWxlIERlYnVnID0gc3RydWN0XG4gIGxldCBjb3ZlcmFnZVxuICAgICAgICAodHlwZSBrIGNtcClcbiAgICAgICAgKG1vZHVsZSBDbXAgOiBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgPSBrIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IGNtcClcbiAgICAgICAgc2FtcGxlXG4gICAgPVxuICAgIFNlcXVlbmNlLmZvbGRcbiAgICAgIHNhbXBsZVxuICAgICAgfmluaXQ6KE1hcC5lbXB0eSAobW9kdWxlIENtcCkpXG4gICAgICB+ZjooZnVuIGNvdW50cyB2YWx1ZSAtPlxuICAgICAgICBNYXAudXBkYXRlIGNvdW50cyB2YWx1ZSB+ZjooZnVuY3Rpb25cbiAgICAgICAgICB8IE5vbmUgLT4gMVxuICAgICAgICAgIHwgU29tZSBwcmV2IC0+IHByZXYgKyAxKSlcbiAgOztcblxuICBsZXQgbW9uaXRvciB0IH5mID1cbiAgICBtYXAgdCB+ZjooZnVuIHZhbHVlIC0+XG4gICAgICBmIHZhbHVlO1xuICAgICAgdmFsdWUpXG4gIDs7XG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCoqIDY0LWJpdCBpbnRlZ2Vycy5cblxuICAgVGhpcyBtb2R1bGUgcHJvdmlkZXMgb3BlcmF0aW9ucyBvbiB0aGUgdHlwZSBbaW50NjRdIG9mXG4gICBzaWduZWQgNjQtYml0IGludGVnZXJzLiAgVW5saWtlIHRoZSBidWlsdC1pbiBbaW50XSB0eXBlLFxuICAgdGhlIHR5cGUgW2ludDY0XSBpcyBndWFyYW50ZWVkIHRvIGJlIGV4YWN0bHkgNjQtYml0IHdpZGUgb24gYWxsXG4gICBwbGF0Zm9ybXMuICBBbGwgYXJpdGhtZXRpYyBvcGVyYXRpb25zIG92ZXIgW2ludDY0XSBhcmUgdGFrZW5cbiAgIG1vZHVsbyAye142NH1cblxuICAgUGVyZm9ybWFuY2Ugbm90aWNlOiB2YWx1ZXMgb2YgdHlwZSBbaW50NjRdIG9jY3VweSBtb3JlIG1lbW9yeVxuICAgc3BhY2UgdGhhbiB2YWx1ZXMgb2YgdHlwZSBbaW50XSwgYW5kIGFyaXRobWV0aWMgb3BlcmF0aW9ucyBvblxuICAgW2ludDY0XSBhcmUgZ2VuZXJhbGx5IHNsb3dlciB0aGFuIHRob3NlIG9uIFtpbnRdLiAgVXNlIFtpbnQ2NF1cbiAgIG9ubHkgd2hlbiB0aGUgYXBwbGljYXRpb24gcmVxdWlyZXMgZXhhY3QgNjQtYml0IGFyaXRobWV0aWMuXG5cbiAgICBMaXRlcmFscyBmb3IgNjQtYml0IGludGVnZXJzIGFyZSBzdWZmaXhlZCBieSBMOlxuICAgIHtbXG4gICAgICBsZXQgemVybzogaW50NjQgPSAwTFxuICAgICAgbGV0IG9uZTogaW50NjQgPSAxTFxuICAgICAgbGV0IG1fb25lOiBpbnQ2NCA9IC0xTFxuICAgIF19XG4qKVxuXG52YWwgemVybyA6IGludDY0XG4oKiogVGhlIDY0LWJpdCBpbnRlZ2VyIDAuICopXG5cbnZhbCBvbmUgOiBpbnQ2NFxuKCoqIFRoZSA2NC1iaXQgaW50ZWdlciAxLiAqKVxuXG52YWwgbWludXNfb25lIDogaW50NjRcbigqKiBUaGUgNjQtYml0IGludGVnZXIgLTEuICopXG5cbmV4dGVybmFsIG5lZyA6IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbmVnXCJcbigqKiBVbmFyeSBuZWdhdGlvbi4gKilcblxuZXh0ZXJuYWwgYWRkIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hZGRcIlxuKCoqIEFkZGl0aW9uLiAqKVxuXG5leHRlcm5hbCBzdWIgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X3N1YlwiXG4oKiogU3VidHJhY3Rpb24uICopXG5cbmV4dGVybmFsIG11bCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbXVsXCJcbigqKiBNdWx0aXBsaWNhdGlvbi4gKilcblxuZXh0ZXJuYWwgZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9kaXZcIlxuKCoqIEludGVnZXIgZGl2aXNpb24uXG4gICBAcmFpc2UgRGl2aXNpb25fYnlfemVybyBpZiB0aGUgc2Vjb25kXG4gICBhcmd1bWVudCBpcyB6ZXJvLiAgVGhpcyBkaXZpc2lvbiByb3VuZHMgdGhlIHJlYWwgcXVvdGllbnQgb2ZcbiAgIGl0cyBhcmd1bWVudHMgdG93YXJkcyB6ZXJvLCBhcyBzcGVjaWZpZWQgZm9yIHshU3RkbGliLigvKX0uICopXG5cbnZhbCB1bnNpZ25lZF9kaXYgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIFNhbWUgYXMgeyFkaXZ9LCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYW5kIHJlc3VsdCBhcmUgaW50ZXJwcmV0ZWQgYXMge2VcbiAgICB1bnNpZ25lZH0gNjQtYml0IGludGVnZXJzLlxuXG4gICAgQHNpbmNlIDQuMDguMCAqKVxuXG5leHRlcm5hbCByZW0gOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X21vZFwiXG4oKiogSW50ZWdlciByZW1haW5kZXIuICBJZiBbeV0gaXMgbm90IHplcm8sIHRoZSByZXN1bHRcbiAgIG9mIFtJbnQ2NC5yZW0geCB5XSBzYXRpc2ZpZXMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0eTpcbiAgIFt4ID0gSW50NjQuYWRkIChJbnQ2NC5tdWwgKEludDY0LmRpdiB4IHkpIHkpIChJbnQ2NC5yZW0geCB5KV0uXG4gICBJZiBbeSA9IDBdLCBbSW50NjQucmVtIHggeV0gcmFpc2VzIFtEaXZpc2lvbl9ieV96ZXJvXS4gKilcblxudmFsIHVuc2lnbmVkX3JlbSA6IGludDY0IC0+IGludDY0IC0+IGludDY0XG4oKiogU2FtZSBhcyB7IXJlbX0sIGV4Y2VwdCB0aGF0IGFyZ3VtZW50cyBhbmQgcmVzdWx0IGFyZSBpbnRlcnByZXRlZCBhcyB7ZVxuICAgIHVuc2lnbmVkfSA2NC1iaXQgaW50ZWdlcnMuXG5cbiAgICBAc2luY2UgNC4wOC4wICopXG5cbnZhbCBzdWNjIDogaW50NjQgLT4gaW50NjRcbigqKiBTdWNjZXNzb3IuICBbSW50NjQuc3VjYyB4XSBpcyBbSW50NjQuYWRkIHggSW50NjQub25lXS4gKilcblxudmFsIHByZWQgOiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIFByZWRlY2Vzc29yLiAgW0ludDY0LnByZWQgeF0gaXMgW0ludDY0LnN1YiB4IEludDY0Lm9uZV0uICopXG5cbnZhbCBhYnMgOiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIFJldHVybiB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgaXRzIGFyZ3VtZW50LiAqKVxuXG52YWwgbWF4X2ludCA6IGludDY0XG4oKiogVGhlIGdyZWF0ZXN0IHJlcHJlc2VudGFibGUgNjQtYml0IGludGVnZXIsIDJ7XjYzfSAtIDEuICopXG5cbnZhbCBtaW5faW50IDogaW50NjRcbigqKiBUaGUgc21hbGxlc3QgcmVwcmVzZW50YWJsZSA2NC1iaXQgaW50ZWdlciwgLTJ7XjYzfS4gKilcblxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuKCoqIEJpdHdpc2UgbG9naWNhbCBhbmQuICopXG5cbmV4dGVybmFsIGxvZ29yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vclwiXG4oKiogQml0d2lzZSBsb2dpY2FsIG9yLiAqKVxuXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X3hvclwiXG4oKiogQml0d2lzZSBsb2dpY2FsIGV4Y2x1c2l2ZSBvci4gKilcblxudmFsIGxvZ25vdCA6IGludDY0IC0+IGludDY0XG4oKiogQml0d2lzZSBsb2dpY2FsIG5lZ2F0aW9uLiAqKVxuXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfbHNsXCJcbigqKiBbSW50NjQuc2hpZnRfbGVmdCB4IHldIHNoaWZ0cyBbeF0gdG8gdGhlIGxlZnQgYnkgW3ldIGJpdHMuXG4gICBUaGUgcmVzdWx0IGlzIHVuc3BlY2lmaWVkIGlmIFt5IDwgMF0gb3IgW3kgPj0gNjRdLiAqKVxuXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2FzclwiXG4oKiogW0ludDY0LnNoaWZ0X3JpZ2h0IHggeV0gc2hpZnRzIFt4XSB0byB0aGUgcmlnaHQgYnkgW3ldIGJpdHMuXG4gICBUaGlzIGlzIGFuIGFyaXRobWV0aWMgc2hpZnQ6IHRoZSBzaWduIGJpdCBvZiBbeF0gaXMgcmVwbGljYXRlZFxuICAgYW5kIGluc2VydGVkIGluIHRoZSB2YWNhdGVkIGJpdHMuXG4gICBUaGUgcmVzdWx0IGlzIHVuc3BlY2lmaWVkIGlmIFt5IDwgMF0gb3IgW3kgPj0gNjRdLiAqKVxuXG5leHRlcm5hbCBzaGlmdF9yaWdodF9sb2dpY2FsIDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfbHNyXCJcbigqKiBbSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCB4IHldIHNoaWZ0cyBbeF0gdG8gdGhlIHJpZ2h0IGJ5IFt5XSBiaXRzLlxuICAgVGhpcyBpcyBhIGxvZ2ljYWwgc2hpZnQ6IHplcm9lcyBhcmUgaW5zZXJ0ZWQgaW4gdGhlIHZhY2F0ZWQgYml0c1xuICAgcmVnYXJkbGVzcyBvZiB0aGUgc2lnbiBvZiBbeF0uXG4gICBUaGUgcmVzdWx0IGlzIHVuc3BlY2lmaWVkIGlmIFt5IDwgMF0gb3IgW3kgPj0gNjRdLiAqKVxuXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIGludGVnZXIgKHR5cGUgW2ludF0pIHRvIGEgNjQtYml0IGludGVnZXJcbiAgICAodHlwZSBbaW50NjRdKS4gKilcblxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKSB0byBhblxuICAgaW50ZWdlciAodHlwZSBbaW50XSkuICBPbiA2NC1iaXQgcGxhdGZvcm1zLCB0aGUgNjQtYml0IGludGVnZXJcbiAgIGlzIHRha2VuIG1vZHVsbyAye142M30sIGkuZS4gdGhlIGhpZ2gtb3JkZXIgYml0IGlzIGxvc3RcbiAgIGR1cmluZyB0aGUgY29udmVyc2lvbi4gIE9uIDMyLWJpdCBwbGF0Zm9ybXMsIHRoZSA2NC1iaXQgaW50ZWdlclxuICAgaXMgdGFrZW4gbW9kdWxvIDJ7XjMxfSwgaS5lLiB0aGUgdG9wIDMzIGJpdHMgYXJlIGxvc3RcbiAgIGR1cmluZyB0aGUgY29udmVyc2lvbi4gKilcblxudmFsIHVuc2lnbmVkX3RvX2ludCA6IGludDY0IC0+IGludCBvcHRpb25cbigqKiBTYW1lIGFzIHshdG9faW50fSwgYnV0IGludGVycHJldHMgdGhlIGFyZ3VtZW50IGFzIGFuIHtlIHVuc2lnbmVkfSBpbnRlZ2VyLlxuICAgIFJldHVybnMgW05vbmVdIGlmIHRoZSB1bnNpZ25lZCB2YWx1ZSBvZiB0aGUgYXJndW1lbnQgY2Fubm90IGZpdCBpbnRvIGFuXG4gICAgW2ludF0uXG5cbiAgICBAc2luY2UgNC4wOC4wICopXG5cbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gZmxvYXRpbmctcG9pbnQgbnVtYmVyIHRvIGEgNjQtYml0IGludGVnZXIsXG4gICBkaXNjYXJkaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgKHRydW5jYXRlIHRvd2FyZHMgMCkuXG4gICBUaGUgcmVzdWx0IG9mIHRoZSBjb252ZXJzaW9uIGlzIHVuZGVmaW5lZCBpZiwgYWZ0ZXIgdHJ1bmNhdGlvbixcbiAgIHRoZSBudW1iZXIgaXMgb3V0c2lkZSB0aGUgcmFuZ2UgXFxbeyFJbnQ2NC5taW5faW50fSwgeyFJbnQ2NC5tYXhfaW50fVxcXS4gKilcblxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF90b19mbG9hdFwiIFwiY2FtbF9pbnQ2NF90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbigqKiBDb252ZXJ0IHRoZSBnaXZlbiA2NC1iaXQgaW50ZWdlciB0byBhIGZsb2F0aW5nLXBvaW50IG51bWJlci4gKilcblxuXG5leHRlcm5hbCBvZl9pbnQzMiA6IGludDMyIC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50MzJcIlxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIDMyLWJpdCBpbnRlZ2VyICh0eXBlIFtpbnQzMl0pXG4gICB0byBhIDY0LWJpdCBpbnRlZ2VyICh0eXBlIFtpbnQ2NF0pLiAqKVxuXG5leHRlcm5hbCB0b19pbnQzMiA6IGludDY0IC0+IGludDMyID0gXCIlaW50NjRfdG9faW50MzJcIlxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIDY0LWJpdCBpbnRlZ2VyICh0eXBlIFtpbnQ2NF0pIHRvIGFcbiAgIDMyLWJpdCBpbnRlZ2VyICh0eXBlIFtpbnQzMl0pLiBUaGUgNjQtYml0IGludGVnZXJcbiAgIGlzIHRha2VuIG1vZHVsbyAye14zMn0sIGkuZS4gdGhlIHRvcCAzMiBiaXRzIGFyZSBsb3N0XG4gICBkdXJpbmcgdGhlIGNvbnZlcnNpb24uICAqKVxuXG5leHRlcm5hbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9uYXRpdmVpbnRcIlxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIG5hdGl2ZSBpbnRlZ2VyICh0eXBlIFtuYXRpdmVpbnRdKVxuICAgdG8gYSA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKS4gKilcblxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50IDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKSB0byBhXG4gICBuYXRpdmUgaW50ZWdlci4gIE9uIDMyLWJpdCBwbGF0Zm9ybXMsIHRoZSA2NC1iaXQgaW50ZWdlclxuICAgaXMgdGFrZW4gbW9kdWxvIDJ7XjMyfS4gIE9uIDY0LWJpdCBwbGF0Zm9ybXMsXG4gICB0aGUgY29udmVyc2lvbiBpcyBleGFjdC4gKilcblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDY0ID0gXCJjYW1sX2ludDY0X29mX3N0cmluZ1wiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIGEgNjQtYml0IGludGVnZXIuXG4gICBUaGUgc3RyaW5nIGlzIHJlYWQgaW4gZGVjaW1hbCAoYnkgZGVmYXVsdCwgb3IgaWYgdGhlIHN0cmluZ1xuICAgYmVnaW5zIHdpdGggWzB1XSkgb3IgaW4gaGV4YWRlY2ltYWwsIG9jdGFsIG9yIGJpbmFyeSBpZiB0aGVcbiAgIHN0cmluZyBiZWdpbnMgd2l0aCBbMHhdLCBbMG9dIG9yIFswYl0gcmVzcGVjdGl2ZWx5LlxuXG4gICBUaGUgWzB1XSBwcmVmaXggcmVhZHMgdGhlIGlucHV0IGFzIGFuIHVuc2lnbmVkIGludGVnZXIgaW4gdGhlIHJhbmdlXG4gICBbWzAsIDIqSW50NjQubWF4X2ludCsxXV0uICBJZiB0aGUgaW5wdXQgZXhjZWVkcyB7IUludDY0Lm1heF9pbnR9XG4gICBpdCBpcyBjb252ZXJ0ZWQgdG8gdGhlIHNpZ25lZCBpbnRlZ2VyXG4gICBbSW50NjQubWluX2ludCArIGlucHV0IC0gSW50NjQubWF4X2ludCAtIDFdLlxuXG4gICBUaGUgW19dICh1bmRlcnNjb3JlKSBjaGFyYWN0ZXIgY2FuIGFwcGVhciBhbnl3aGVyZSBpbiB0aGUgc3RyaW5nXG4gICBhbmQgaXMgaWdub3JlZC5cbiAgIEByYWlzZSBGYWlsdXJlIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgbm90XG4gICBhIHZhbGlkIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIsIG9yIGlmIHRoZSBpbnRlZ2VyIHJlcHJlc2VudGVkXG4gICBleGNlZWRzIHRoZSByYW5nZSBvZiBpbnRlZ2VycyByZXByZXNlbnRhYmxlIGluIHR5cGUgW2ludDY0XS4gKilcblxudmFsIG9mX3N0cmluZ19vcHQ6IHN0cmluZyAtPiBpbnQ2NCBvcHRpb25cbigqKiBTYW1lIGFzIFtvZl9zdHJpbmddLCBidXQgcmV0dXJuIFtOb25lXSBpbnN0ZWFkIG9mIHJhaXNpbmcuXG4gICAgQHNpbmNlIDQuMDUgKilcblxudmFsIHRvX3N0cmluZyA6IGludDY0IC0+IHN0cmluZ1xuKCoqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGl0cyBhcmd1bWVudCwgaW4gZGVjaW1hbC4gKilcblxuZXh0ZXJuYWwgYml0c19vZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbigqKiBSZXR1cm4gdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBmbG9hdCBhY2NvcmRpbmdcbiAgIHRvIHRoZSBJRUVFIDc1NCBmbG9hdGluZy1wb2ludCAnZG91YmxlIGZvcm1hdCcgYml0IGxheW91dC5cbiAgIEJpdCA2MyBvZiB0aGUgcmVzdWx0IHJlcHJlc2VudHMgdGhlIHNpZ24gb2YgdGhlIGZsb2F0O1xuICAgYml0cyA2MiB0byA1MiByZXByZXNlbnQgdGhlIChiaWFzZWQpIGV4cG9uZW50OyBiaXRzIDUxIHRvIDBcbiAgIHJlcHJlc2VudCB0aGUgbWFudGlzc2EuICopXG5cbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4oKiogUmV0dXJuIHRoZSBmbG9hdGluZy1wb2ludCBudW1iZXIgd2hvc2UgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24sXG4gICBhY2NvcmRpbmcgdG8gdGhlIElFRUUgNzU0IGZsb2F0aW5nLXBvaW50ICdkb3VibGUgZm9ybWF0JyBiaXQgbGF5b3V0LFxuICAgaXMgdGhlIGdpdmVuIFtpbnQ2NF0uICopXG5cbnR5cGUgdCA9IGludDY0XG4oKiogQW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIDY0LWJpdCBpbnRlZ2Vycy4gKilcblxudmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbigqKiBUaGUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgNjQtYml0IGludGVnZXJzLCB3aXRoIHRoZSBzYW1lIHNwZWNpZmljYXRpb24gYXNcbiAgICB7IVN0ZGxpYi5jb21wYXJlfS4gIEFsb25nIHdpdGggdGhlIHR5cGUgW3RdLCB0aGlzIGZ1bmN0aW9uIFtjb21wYXJlXVxuICAgIGFsbG93cyB0aGUgbW9kdWxlIFtJbnQ2NF0gdG8gYmUgcGFzc2VkIGFzIGFyZ3VtZW50IHRvIHRoZSBmdW5jdG9yc1xuICAgIHshU2V0Lk1ha2V9IGFuZCB7IU1hcC5NYWtlfS4gKilcblxudmFsIHVuc2lnbmVkX2NvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbigqKiBTYW1lIGFzIHshY29tcGFyZX0sIGV4Y2VwdCB0aGF0IGFyZ3VtZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXMge2UgdW5zaWduZWR9XG4gICAgNjQtYml0IGludGVnZXJzLlxuXG4gICAgQHNpbmNlIDQuMDguMCAqKVxuXG52YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4oKiogVGhlIGVxdWFsIGZ1bmN0aW9uIGZvciBpbnQ2NHMuXG4gICAgQHNpbmNlIDQuMDMuMCAqKVxuXG52YWwgbWluOiB0IC0+IHQgLT4gdFxuKCoqIFJldHVybiB0aGUgc21hbGxlciBvZiB0aGUgdHdvIGFyZ3VtZW50cy5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgbWF4OiB0IC0+IHQgLT4gdFxuKCoqIFJldHVybiB0aGUgZ3JlYXRlciBvZiB0aGUgdHdvIGFyZ3VtZW50cy5cbiAgICBAc2luY2UgNC4xMy4wXG4gKilcblxuKCoqLyoqKVxuXG4oKiogezEgRGVwcmVjYXRlZCBmdW5jdGlvbnN9ICopXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmcgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbigqKiBEbyBub3QgdXNlIHRoaXMgZGVwcmVjYXRlZCBmdW5jdGlvbi4gIEluc3RlYWQsXG4gICB1c2VkIHshUHJpbnRmLnNwcmludGZ9IHdpdGggYSBbJUwuLi5dIGZvcm1hdC4gKilcbiIsIm9wZW4hIEJhc2VcblxubW9kdWxlIFQgOiBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGF0b21pYyA6IF8gdFxuICB2YWwgY3JlYXRlIDogKCdhIC0+ICdhIFNlcXVlbmNlLnQpIC0+ICdhIHRcbiAgdmFsIHNocmluayA6ICdhIHQgLT4gJ2EgLT4gJ2EgU2VxdWVuY2UudFxuZW5kID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIC0+ICdhIFNlcXVlbmNlLnRcblxuICBsZXQgYXRvbWljIF8gPSBTZXF1ZW5jZS5lbXB0eVxuICBsZXQgY3JlYXRlID0gRm4uaWRcbiAgbGV0IHNocmluayA9IEZuLmlkXG5lbmRcblxuaW5jbHVkZSBUXG5cbmxldCBtYXAgdCB+ZiB+Zl9pbnZlcnNlID0gY3JlYXRlIChmdW4geCAtPiBTZXF1ZW5jZS5tYXAgfmYgKHNocmluayB0IChmX2ludmVyc2UgeCkpKVxubGV0IGZpbHRlciB0IH5mID0gY3JlYXRlIChmdW4geCAtPiBTZXF1ZW5jZS5maWx0ZXIgfmYgKHNocmluayB0IHgpKVxuXG5sZXQgZmlsdGVyX21hcCB0IH5mIH5mX2ludmVyc2UgPVxuICBjcmVhdGUgKGZ1biB4IC0+IFNlcXVlbmNlLmZpbHRlcl9tYXAgfmYgKHNocmluayB0IChmX2ludmVyc2UgeCkpKVxuOztcblxubGV0IG9mX2xhenkgbGF6eV90ID0gY3JlYXRlIChmdW4geCAtPiBTZXF1ZW5jZS5vZl9sYXp5IChsYXp5IChzaHJpbmsgKGZvcmNlIGxhenlfdCkgeCkpKVxuXG5sZXQgZml4ZWRfcG9pbnQgb2Zfc2hyaW5rZXIgPVxuICBsZXQgcmVjIGxhenlfdCA9IGxhenkgKG9mX3Nocmlua2VyIChvZl9sYXp5IGxhenlfdCkpIGluXG4gIG9mX2xhenkgbGF6eV90XG47O1xuXG5sZXQgYm90aCBmc3RfdCBzbmRfdCA9XG4gIGNyZWF0ZSAoZnVuIChmc3QsIHNuZCkgLT5cbiAgICBTZXF1ZW5jZS5yb3VuZF9yb2JpblxuICAgICAgWyBTZXF1ZW5jZS5tYXAgKHNocmluayBmc3RfdCBmc3QpIH5mOihmdW4gZnN0IC0+IGZzdCwgc25kKVxuICAgICAgOyBTZXF1ZW5jZS5tYXAgKHNocmluayBzbmRfdCBzbmQpIH5mOihmdW4gc25kIC0+IGZzdCwgc25kKVxuICAgICAgXSlcbjs7XG5cbmxldCB1bml0ID0gYXRvbWljXG5sZXQgYm9vbCA9IGF0b21pY1xubGV0IGNoYXIgPSBhdG9taWNcbmxldCBpbnQgPSBhdG9taWNcbmxldCBpbnQzMiA9IGF0b21pY1xubGV0IGludDYzID0gYXRvbWljXG5sZXQgaW50NjQgPSBhdG9taWNcbmxldCBuYXRpdmVpbnQgPSBhdG9taWNcbmxldCBmbG9hdCA9IGF0b21pY1xuXG5sZXQgYmlnYXJyYXkxIHNyYyA9XG4gIGxldCBkaW0gPSBCaWdhcnJheS5BcnJheTEuZGltIHNyYyBpblxuICBtYXRjaCBkaW0gd2l0aFxuICB8IDAgLT4gU2VxdWVuY2UuZW1wdHlcbiAgfCBfIC0+XG4gICAgbGV0IGtpbmQgPSBCaWdhcnJheS5BcnJheTEua2luZCBzcmMgaW5cbiAgICBsZXQgbGF5b3V0ID0gQmlnYXJyYXkuQXJyYXkxLmxheW91dCBzcmMgaW5cbiAgICBsZXQgb2Zmc2V0ID0gQmlnYXJyYXlfaGVscGVycy5MYXlvdXQub2Zmc2V0IGxheW91dCBpblxuICAgIFNlcXVlbmNlLmluaXQgZGltIH5mOihmdW4gdG9fc2tpcCAtPlxuICAgICAgbGV0IHRvX3NraXAgPSB0b19za2lwICsgb2Zmc2V0IGluXG4gICAgICBCaWdhcnJheV9oZWxwZXJzLkFycmF5MS5pbml0IGtpbmQgbGF5b3V0IChkaW0gLSAxKSB+ZjooZnVuIGkgLT5cbiAgICAgICAgc3JjLntpZiBpIDwgdG9fc2tpcCB0aGVuIGkgZWxzZSBpICsgMX0pKVxuOztcblxubGV0IGJpZ3N0cmluZyA9IGNyZWF0ZSBiaWdhcnJheTFcbmxldCBmbG9hdDMyX3ZlYyA9IGNyZWF0ZSBiaWdhcnJheTFcbmxldCBmbG9hdDY0X3ZlYyA9IGNyZWF0ZSBiaWdhcnJheTFcblxubGV0IGJpZ2FycmF5MiA9XG4gIGxldCBtb2R1bGUgRGltcyA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB7IGRpbTEgOiBpbnRcbiAgICAgIDsgZGltMiA6IGludFxuICAgICAgfVxuICAgIFtAQGRlcml2aW5nIGZpZWxkc11cblxuICAgIGxldCBjcmVhdGUgYSA9IEJpZ2FycmF5LkFycmF5Mi57IGRpbTEgPSBkaW0xIGE7IGRpbTIgPSBkaW0yIGEgfVxuICBlbmRcbiAgaW5cbiAgbGV0IHNocmluayBmaWVsZCBzcmMgPVxuICAgIGxldCBkaW1zID0gRGltcy5jcmVhdGUgc3JjIGluXG4gICAgbWF0Y2ggRmllbGQuZ2V0IGZpZWxkIGRpbXMgd2l0aFxuICAgIHwgMCAtPiBTZXF1ZW5jZS5lbXB0eVxuICAgIHwgXyAtPlxuICAgICAgbGV0IGtpbmQgPSBCaWdhcnJheS5BcnJheTIua2luZCBzcmMgaW5cbiAgICAgIGxldCBsYXlvdXQgPSBCaWdhcnJheS5BcnJheTIubGF5b3V0IHNyYyBpblxuICAgICAgbGV0IG9mZnNldCA9IEJpZ2FycmF5X2hlbHBlcnMuTGF5b3V0Lm9mZnNldCBsYXlvdXQgaW5cbiAgICAgIGxldCAoeyBkaW0xOyBkaW0yIH0gOiBEaW1zLnQpID0gRmllbGQubWFwIGZpZWxkIGRpbXMgfmY6SW50LnByZWQgaW5cbiAgICAgIFNlcXVlbmNlLmluaXQgKEZpZWxkLmdldCBmaWVsZCBkaW1zKSB+ZjooZnVuIHRvX3NraXAgLT5cbiAgICAgICAgbGV0IHRvX3NraXAgPSB0b19za2lwICsgb2Zmc2V0IGluXG4gICAgICAgIGxldCBza2lwIGkgPSBpZiBpIDwgdG9fc2tpcCB0aGVuIGkgZWxzZSBpICsgMSBpblxuICAgICAgICBCaWdhcnJheV9oZWxwZXJzLkFycmF5Mi5pbml0IGtpbmQgbGF5b3V0IGRpbTEgZGltMiB+ZjooZnVuIGRpbTEgZGltMiAtPlxuICAgICAgICAgIGxldCAoeyBkaW0xOyBkaW0yIH0gOiBEaW1zLnQpID0gRmllbGQubWFwIGZpZWxkIHsgZGltMTsgZGltMiB9IH5mOnNraXAgaW5cbiAgICAgICAgICBzcmMue2RpbTEsIGRpbTJ9KSlcbiAgaW5cbiAgZnVuIHNyYyAtPlxuICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluIFsgc2hyaW5rIERpbXMuRmllbGRzLmRpbTEgc3JjOyBzaHJpbmsgRGltcy5GaWVsZHMuZGltMiBzcmMgXVxuOztcblxubGV0IGZsb2F0MzJfbWF0ID0gY3JlYXRlIGJpZ2FycmF5MlxubGV0IGZsb2F0NjRfbWF0ID0gY3JlYXRlIGJpZ2FycmF5MlxuXG5sZXQgb3B0aW9uIHZhbHVlX3QgPVxuICBjcmVhdGUgKGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IFNlcXVlbmNlLmVtcHR5XG4gICAgfCBTb21lIHZhbHVlIC0+XG4gICAgICBTZXF1ZW5jZS5hcHBlbmRcbiAgICAgICAgKFNlcXVlbmNlLnNpbmdsZXRvbiBOb25lKVxuICAgICAgICAoU2VxdWVuY2UubWFwIH5mOk9wdGlvbi5yZXR1cm4gKHNocmluayB2YWx1ZV90IHZhbHVlKSkpXG47O1xuXG5sZXQgbGlzdCBlbHRfdCA9XG4gIGZpeGVkX3BvaW50IChmdW4gbGlzdF90IC0+XG4gICAgY3JlYXRlIChmdW5jdGlvblxuICAgICAgfCBbXSAtPiBTZXF1ZW5jZS5lbXB0eVxuICAgICAgfCBoZWFkIDo6IHRhaWwgLT5cbiAgICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgICAgICBbIFNlcXVlbmNlLnNpbmdsZXRvbiB0YWlsXG4gICAgICAgICAgOyBTZXF1ZW5jZS5tYXAgKHNocmluayBlbHRfdCBoZWFkKSB+ZjooZnVuIGhlYWQgLT4gaGVhZCA6OiB0YWlsKVxuICAgICAgICAgIDsgU2VxdWVuY2UubWFwIChzaHJpbmsgbGlzdF90IHRhaWwpIH5mOihmdW4gdGFpbCAtPiBoZWFkIDo6IHRhaWwpXG4gICAgICAgICAgXSkpXG47O1xuXG5sZXQgc3RyaW5nID0gbWFwIChsaXN0IGNoYXIpIH5mOlN0cmluZy5vZl9jaGFyX2xpc3QgfmZfaW52ZXJzZTpTdHJpbmcudG9fbGlzdFxubGV0IGJ5dGVzID0gbWFwIHN0cmluZyB+ZjpCeXRlcy5vZl9zdHJpbmcgfmZfaW52ZXJzZTpCeXRlcy50b19zdHJpbmdcbmxldCBhcnJheSB0ID0gbWFwIChsaXN0IHQpIH5mOkFycmF5Lm9mX2xpc3QgfmZfaW52ZXJzZTpBcnJheS50b19saXN0XG5sZXQgcmVmIHQgPSBtYXAgdCB+ZjpSZWYuY3JlYXRlIH5mX2ludmVyc2U6UmVmLiggISApXG5sZXQgbGF6eV90IHQgPSBtYXAgdCB+ZjpMYXp5LmZyb21fdmFsIH5mX2ludmVyc2U6TGF6eS5mb3JjZVxuXG5sZXQgc2V4cCA9XG4gIGZpeGVkX3BvaW50IChmdW4gc2hyaW5rZXIgLT5cbiAgICBjcmVhdGUgKGZ1bmN0aW9uXG4gICAgICB8IFNleHAuQXRvbSBfIC0+IFNlcXVlbmNlLmVtcHR5XG4gICAgICB8IFNleHAuTGlzdCBsIC0+XG4gICAgICAgIGxldCBzaHJpbmtfbGlzdCA9XG4gICAgICAgICAgc2hyaW5rIChsaXN0IHNocmlua2VyKSBsIHw+IFNlcXVlbmNlLm1hcCB+ZjooZnVuIGwgLT4gU2V4cC5MaXN0IGwpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBzaHJpbmtfdHJlZSA9IFNlcXVlbmNlLm9mX2xpc3QgbCBpblxuICAgICAgICBTZXF1ZW5jZS5yb3VuZF9yb2JpbiBbIHNocmlua19saXN0OyBzaHJpbmtfdHJlZSBdKSlcbjs7XG5cbmxldCBlaXRoZXIgZnN0X3Qgc25kX3QgPVxuICBjcmVhdGUgKGZ1biBlaXRoZXIgLT5cbiAgICBtYXRjaCAoZWl0aGVyIDogXyBFaXRoZXIudCkgd2l0aFxuICAgIHwgRmlyc3QgZnN0IC0+IFNlcXVlbmNlLm1hcCAoc2hyaW5rIGZzdF90IGZzdCkgfmY6RWl0aGVyLmZpcnN0XG4gICAgfCBTZWNvbmQgc25kIC0+IFNlcXVlbmNlLm1hcCAoc2hyaW5rIHNuZF90IHNuZCkgfmY6RWl0aGVyLnNlY29uZClcbjs7XG5cbmxldCByZXN1bHQgb2tfdCBlcnJfdCA9XG4gIG1hcFxuICAgIChlaXRoZXIgb2tfdCBlcnJfdClcbiAgICB+ZjooZnVuY3Rpb25cbiAgICAgIHwgRmlyc3Qgb2sgLT4gT2sgb2tcbiAgICAgIHwgU2Vjb25kIGVyciAtPiBFcnJvciBlcnIpXG4gICAgfmZfaW52ZXJzZTooZnVuY3Rpb25cbiAgICAgIHwgT2sgb2sgLT4gRmlyc3Qgb2tcbiAgICAgIHwgRXJyb3IgZXJyIC0+IFNlY29uZCBlcnIpXG47O1xuXG5sZXQgbWFwX3RyZWVfdXNpbmdfY29tcGFyYXRvciB+Y29tcGFyYXRvciBrZXlfdCBkYXRhX3QgPVxuICBjcmVhdGUgKGZ1biB0cmVlIC0+XG4gICAgbGV0IGFsaXN0ID0gTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS50b19hbGlzdCB0cmVlIGluXG4gICAgbGV0IGRyb3Bfa2V5cyA9XG4gICAgICBTZXF1ZW5jZS5tYXAgKFNlcXVlbmNlLm9mX2xpc3QgYWxpc3QpIH5mOihmdW4gKGssIF8pIC0+XG4gICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUucmVtb3ZlIH5jb21wYXJhdG9yIHRyZWUgaylcbiAgICBpblxuICAgIGxldCBzaHJpbmtfa2V5cyA9XG4gICAgICBTZXF1ZW5jZS5yb3VuZF9yb2JpblxuICAgICAgICAoTGlzdC5tYXAgYWxpc3QgfmY6KGZ1biAoa2V5LCBkYXRhKSAtPlxuICAgICAgICAgICBsZXQgdHJlZSA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUucmVtb3ZlIH5jb21wYXJhdG9yIHRyZWUga2V5IGluXG4gICAgICAgICAgIFNlcXVlbmNlLmZpbHRlcl9tYXAgKHNocmluayBrZXlfdCBrZXkpIH5mOihmdW4gc21hbGxlcl9rZXkgLT5cbiAgICAgICAgICAgICBtYXRjaFxuICAgICAgICAgICAgICAgTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5hZGQgfmNvbXBhcmF0b3IgdHJlZSB+a2V5OnNtYWxsZXJfa2V5IH5kYXRhXG4gICAgICAgICAgICAgd2l0aFxuICAgICAgICAgICAgIHwgYE9rIHRyZWUgLT4gU29tZSB0cmVlXG4gICAgICAgICAgICAgfCBgRHVwbGljYXRlIC0+IE5vbmUpKSlcbiAgICBpblxuICAgIGxldCBzaHJpbmtfZGF0YSA9XG4gICAgICBTZXF1ZW5jZS5yb3VuZF9yb2JpblxuICAgICAgICAoTGlzdC5tYXAgYWxpc3QgfmY6KGZ1biAoa2V5LCBkYXRhKSAtPlxuICAgICAgICAgICBTZXF1ZW5jZS5tYXAgKHNocmluayBkYXRhX3QgZGF0YSkgfmY6KGZ1biBzbWFsbGVyX2RhdGEgLT5cbiAgICAgICAgICAgICBNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnNldCB+Y29tcGFyYXRvciB0cmVlIH5rZXkgfmRhdGE6c21hbGxlcl9kYXRhKSkpXG4gICAgaW5cbiAgICBTZXF1ZW5jZS5yb3VuZF9yb2JpbiBbIGRyb3Bfa2V5czsgc2hyaW5rX2tleXM7IHNocmlua19kYXRhIF0pXG47O1xuXG5sZXQgc2V0X3RyZWVfdXNpbmdfY29tcGFyYXRvciB+Y29tcGFyYXRvciBlbHRfdCA9XG4gIGNyZWF0ZSAoZnVuIHRyZWUgLT5cbiAgICBsZXQgbGlzdCA9IFNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUudG9fbGlzdCB0cmVlIGluXG4gICAgbGV0IGRyb3BfZWx0cyA9XG4gICAgICBTZXF1ZW5jZS5tYXAgKFNlcXVlbmNlLm9mX2xpc3QgbGlzdCkgfmY6KGZ1biBlbHQgLT5cbiAgICAgICAgU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5yZW1vdmUgfmNvbXBhcmF0b3IgdHJlZSBlbHQpXG4gICAgaW5cbiAgICBsZXQgc2hyaW5rX2VsdHMgPVxuICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgICAgKExpc3QubWFwIGxpc3QgfmY6KGZ1biBlbHQgLT5cbiAgICAgICAgICAgbGV0IHRyZWUgPSBTZXQuVXNpbmdfY29tcGFyYXRvci5UcmVlLnJlbW92ZSB+Y29tcGFyYXRvciB0cmVlIGVsdCBpblxuICAgICAgICAgICBTZXF1ZW5jZS5maWx0ZXJfbWFwIChzaHJpbmsgZWx0X3QgZWx0KSB+ZjooZnVuIHNtYWxsZXJfZWx0IC0+XG4gICAgICAgICAgICAgbWF0Y2ggU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5tZW0gfmNvbXBhcmF0b3IgdHJlZSBzbWFsbGVyX2VsdCB3aXRoXG4gICAgICAgICAgICAgfCB0cnVlIC0+IE5vbmVcbiAgICAgICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgICAgICBTb21lIChTZXQuVXNpbmdfY29tcGFyYXRvci5UcmVlLmFkZCB0cmVlIH5jb21wYXJhdG9yIHNtYWxsZXJfZWx0KSkpKVxuICAgIGluXG4gICAgU2VxdWVuY2Uucm91bmRfcm9iaW4gWyBkcm9wX2VsdHM7IHNocmlua19lbHRzIF0pXG47O1xuXG5sZXQgbWFwX3Qga2V5X3QgZGF0YV90ID1cbiAgY3JlYXRlIChmdW4gbWFwX3QgLT5cbiAgICBsZXQgY29tcGFyYXRvciA9IE1hcC5jb21wYXJhdG9yIG1hcF90IGluXG4gICAgbGV0IHQgPVxuICAgICAgbWFwXG4gICAgICAgIChtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGtleV90IGRhdGFfdClcbiAgICAgICAgfmY6KE1hcC5Vc2luZ19jb21wYXJhdG9yLm9mX3RyZWUgfmNvbXBhcmF0b3IpXG4gICAgICAgIH5mX2ludmVyc2U6TWFwLlVzaW5nX2NvbXBhcmF0b3IudG9fdHJlZVxuICAgIGluXG4gICAgc2hyaW5rIHQgbWFwX3QpXG47O1xuXG5sZXQgc2V0X3QgZWx0X3QgPVxuICBjcmVhdGUgKGZ1biBzZXRfdCAtPlxuICAgIGxldCBjb21wYXJhdG9yID0gU2V0LmNvbXBhcmF0b3Igc2V0X3QgaW5cbiAgICBsZXQgdCA9XG4gICAgICBtYXBcbiAgICAgICAgKHNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3IgZWx0X3QpXG4gICAgICAgIH5mOihTZXQuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuICAgICAgICB+Zl9pbnZlcnNlOlNldC5Vc2luZ19jb21wYXJhdG9yLnRvX3RyZWVcbiAgICBpblxuICAgIHNocmluayB0IHNldF90KVxuOztcbiIsIm9wZW4hIEJhc2VcbmluY2x1ZGUgVGVzdF9pbnRmXG5cbm1vZHVsZSBDb25maWcgPSBzdHJ1Y3RcbiAgbW9kdWxlIFNlZWQgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgfCBOb25kZXRlcm1pbmlzdGljXG4gICAgICB8IERldGVybWluaXN0aWMgb2Ygc3RyaW5nXG4gICAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cbiAgZW5kXG5cbiAgbW9kdWxlIFBvdGVudGlhbGx5X2luZmluaXRlX3NlcXVlbmNlID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gJ2EgU2VxdWVuY2UudFxuXG4gICAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2VsdCBzZXF1ZW5jZSA9XG4gICAgICBsZXQgcHJlZml4LCBzdWZmaXggPSBTZXF1ZW5jZS5zcGxpdF9uIHNlcXVlbmNlIDEwMCBpblxuICAgICAgbGV0IHByZWZpeCA9IExpc3QubWFwIHByZWZpeCB+ZjpzZXhwX29mX2VsdCBpblxuICAgICAgbGV0IHN1ZmZpeCA9XG4gICAgICAgIG1hdGNoIFNlcXVlbmNlLmlzX2VtcHR5IHN1ZmZpeCB3aXRoXG4gICAgICAgIHwgdHJ1ZSAtPiBbXVxuICAgICAgICB8IGZhbHNlIC0+IFsgWyVtZXNzYWdlIFwiLi4uXCJdIF1cbiAgICAgIGluXG4gICAgICBTZXhwLkxpc3QgKHByZWZpeCBAIHN1ZmZpeClcbiAgICA7O1xuICBlbmRcblxuICB0eXBlIHQgPVxuICAgIHsgc2VlZCA6IFNlZWQudFxuICAgIDsgdGVzdF9jb3VudCA6IGludFxuICAgIDsgc2hyaW5rX2NvdW50IDogaW50XG4gICAgOyBzaXplcyA6IGludCBQb3RlbnRpYWxseV9pbmZpbml0ZV9zZXF1ZW5jZS50XG4gICAgfVxuICBbQEBkZXJpdmluZyBmaWVsZHMsIHNleHBfb2ZdXG5lbmRcblxubGV0IGRlZmF1bHRfY29uZmlnIDogQ29uZmlnLnQgPVxuICB7IHNlZWQgPSBEZXRlcm1pbmlzdGljIFwiYW4gYXJiaXRyYXJ5IGJ1dCBkZXRlcm1pbmlzdGljIHN0cmluZ1wiXG4gIDsgdGVzdF9jb3VudCA9IDEwXzAwMFxuICA7IHNocmlua19jb3VudCA9IDEwXzAwMFxuICA7IHNpemVzID0gU2VxdWVuY2UuY3ljbGVfbGlzdF9leG4gKExpc3QucmFuZ2UgMCB+c3RhcnQ6YGluY2x1c2l2ZSAzMCB+c3RvcDpgaW5jbHVzaXZlKVxuICB9XG47O1xuXG5sZXQgbGF6eV9ub25kZXRlcm1pbmlzdGljX3N0YXRlID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0ICgpKVxuXG5sZXQgaW5pdGlhbF9yYW5kb21fc3RhdGUgfmNvbmZpZyA9XG4gIG1hdGNoIENvbmZpZy5zZWVkIGNvbmZpZyB3aXRoXG4gIHwgTm9uZGV0ZXJtaW5pc3RpYyAtPiBTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS5jcmVhdGUgKGZvcmNlIGxhenlfbm9uZGV0ZXJtaW5pc3RpY19zdGF0ZSlcbiAgfCBEZXRlcm1pbmlzdGljIHN0cmluZyAtPiBTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS5vZl9pbnQgKFN0cmluZy5oYXNoIHN0cmluZylcbjs7XG5cbmxldCBvbmVfc2l6ZV9wZXJfdGVzdCB+KGNvbmZpZyA6IENvbmZpZy50KSA9XG4gIFNlcXVlbmNlLnVuZm9sZCB+aW5pdDooY29uZmlnLnNpemVzLCAwKSB+ZjooZnVuIChzaXplcywgbnVtYmVyX29mX3NpemVfdmFsdWVzKSAtPlxuICAgIG1hdGNoIG51bWJlcl9vZl9zaXplX3ZhbHVlcyA+PSBjb25maWcudGVzdF9jb3VudCB3aXRoXG4gICAgfCB0cnVlIC0+IE5vbmVcbiAgICB8IGZhbHNlIC0+XG4gICAgICAobWF0Y2ggU2VxdWVuY2UubmV4dCBzaXplcyB3aXRoXG4gICAgICAgfCBTb21lIChzaXplLCByZW1haW5pbmdfc2l6ZXMpIC0+XG4gICAgICAgICBTb21lIChzaXplLCAocmVtYWluaW5nX3NpemVzLCBudW1iZXJfb2Zfc2l6ZV92YWx1ZXMgKyAxKSlcbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIHJhaXNlX3NcbiAgICAgICAgICAgWyVtZXNzYWdlXG4gICAgICAgICAgICAgXCJCYXNlX3F1aWNrY2hlY2suVGVzdC5ydW46IGluc3VmZmljaWVudCBzaXplIHZhbHVlcyBmb3IgdGVzdCBjb3VudFwiXG4gICAgICAgICAgICAgICB+dGVzdF9jb3VudDooY29uZmlnLnRlc3RfY291bnQgOiBpbnQpXG4gICAgICAgICAgICAgICAobnVtYmVyX29mX3NpemVfdmFsdWVzIDogaW50KV0pKVxuOztcblxubGV0IHNocmlua19lcnJvciB+c2hyaW5rZXIgfmNvbmZpZyB+ZiBpbnB1dCBlcnJvciA9XG4gIGxldCByZWMgbG9vcCB+c2hyaW5rX2NvdW50IH5hbHRlcm5hdGVzIGlucHV0IGVycm9yID1cbiAgICBtYXRjaCBzaHJpbmtfY291bnQgd2l0aFxuICAgIHwgMCAtPiBpbnB1dCwgZXJyb3JcbiAgICB8IF8gLT5cbiAgICAgIGxldCBzaHJpbmtfY291bnQgPSBzaHJpbmtfY291bnQgLSAxIGluXG4gICAgICAobWF0Y2ggU2VxdWVuY2UubmV4dCBhbHRlcm5hdGVzIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gaW5wdXQsIGVycm9yXG4gICAgICAgfCBTb21lIChhbHRlcm5hdGUsIGFsdGVybmF0ZXMpIC0+XG4gICAgICAgICAobWF0Y2ggZiBhbHRlcm5hdGUgd2l0aFxuICAgICAgICAgIHwgT2sgKCkgLT4gbG9vcCB+c2hyaW5rX2NvdW50IH5hbHRlcm5hdGVzIGlucHV0IGVycm9yXG4gICAgICAgICAgfCBFcnJvciBlcnJvciAtPlxuICAgICAgICAgICAgbGV0IGFsdGVybmF0ZXMgPSBTaHJpbmtlci5zaHJpbmsgc2hyaW5rZXIgYWx0ZXJuYXRlIGluXG4gICAgICAgICAgICBsb29wIH5zaHJpbmtfY291bnQgfmFsdGVybmF0ZXMgYWx0ZXJuYXRlIGVycm9yKSlcbiAgaW5cbiAgbGV0IHNocmlua19jb3VudCA9IENvbmZpZy5zaHJpbmtfY291bnQgY29uZmlnIGluXG4gIGxldCBhbHRlcm5hdGVzID0gU2hyaW5rZXIuc2hyaW5rIHNocmlua2VyIGlucHV0IGluXG4gIGxvb3AgfnNocmlua19jb3VudCB+YWx0ZXJuYXRlcyBpbnB1dCBlcnJvclxuOztcblxubGV0IGlucHV0X3NlcXVlbmNlIH5jb25maWcgfmV4YW1wbGVzIH5nZW5lcmF0b3IgPVxuICBsZXQgcmFuZG9tID0gaW5pdGlhbF9yYW5kb21fc3RhdGUgfmNvbmZpZyBpblxuICBTZXF1ZW5jZS5hcHBlbmRcbiAgICAoU2VxdWVuY2Uub2ZfbGlzdCBleGFtcGxlcylcbiAgICAob25lX3NpemVfcGVyX3Rlc3QgfmNvbmZpZ1xuICAgICB8PiBTZXF1ZW5jZS5tYXAgfmY6KGZ1biBzaXplIC0+IEdlbmVyYXRvci5nZW5lcmF0ZSBnZW5lcmF0b3IgfnNpemUgfnJhbmRvbSkpXG47O1xuXG5sZXQgd2l0aF9zYW1wbGUgfmYgPyhjb25maWcgPSBkZWZhdWx0X2NvbmZpZykgPyhleGFtcGxlcyA9IFtdKSBnZW5lcmF0b3IgPVxuICBsZXQgc2VxdWVuY2UgPSBpbnB1dF9zZXF1ZW5jZSB+Y29uZmlnIH5leGFtcGxlcyB+Z2VuZXJhdG9yIGluXG4gIGYgc2VxdWVuY2Vcbjs7XG5cbmxldCByZXN1bHQgKHR5cGUgYSkgfmYgPyhjb25maWcgPSBkZWZhdWx0X2NvbmZpZykgPyhleGFtcGxlcyA9IFtdKSBtID1cbiAgbGV0IChtb2R1bGUgTSA6IFMgd2l0aCB0eXBlIHQgPSBhKSA9IG0gaW5cbiAgd2l0aF9zYW1wbGUgTS5xdWlja2NoZWNrX2dlbmVyYXRvciB+Y29uZmlnIH5leGFtcGxlcyB+ZjooZnVuIHNlcXVlbmNlIC0+XG4gICAgbWF0Y2hcbiAgICAgIFNlcXVlbmNlLmZvbGRfcmVzdWx0IHNlcXVlbmNlIH5pbml0OigpIH5mOihmdW4gKCkgaW5wdXQgLT5cbiAgICAgICAgbWF0Y2ggZiBpbnB1dCB3aXRoXG4gICAgICAgIHwgT2sgKCkgLT4gT2sgKClcbiAgICAgICAgfCBFcnJvciBlcnJvciAtPiBFcnJvciAoaW5wdXQsIGVycm9yKSlcbiAgICB3aXRoXG4gICAgfCBPayAoKSAtPiBPayAoKVxuICAgIHwgRXJyb3IgKGlucHV0LCBlcnJvcikgLT5cbiAgICAgIGxldCBzaHJpbmtlciA9IE0ucXVpY2tjaGVja19zaHJpbmtlciBpblxuICAgICAgbGV0IGlucHV0LCBlcnJvciA9IHNocmlua19lcnJvciB+c2hyaW5rZXIgfmNvbmZpZyB+ZiBpbnB1dCBlcnJvciBpblxuICAgICAgRXJyb3IgKGlucHV0LCBlcnJvcikpXG47O1xuXG5sZXQgcnVuICh0eXBlIGEpIH5mID9jb25maWcgP2V4YW1wbGVzIChtb2R1bGUgTSA6IFMgd2l0aCB0eXBlIHQgPSBhKSA9XG4gIGxldCBmIHggPVxuICAgIE9yX2Vycm9yLnRyeV93aXRoX2pvaW4gfmJhY2t0cmFjZTooQmFja3RyYWNlLkV4bi5hbV9yZWNvcmRpbmcgKCkpIChmdW4gKCkgLT4gZiB4KVxuICBpblxuICBtYXRjaCByZXN1bHQgfmYgP2NvbmZpZyA/ZXhhbXBsZXMgKG1vZHVsZSBNKSB3aXRoXG4gIHwgT2sgKCkgLT4gT2sgKClcbiAgfCBFcnJvciAoaW5wdXQsIGVycm9yKSAtPlxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIFslbWVzc2FnZSBcIkJhc2VfcXVpY2tjaGVjay5UZXN0LnJ1bjogdGVzdCBmYWlsZWRcIiAoaW5wdXQgOiBNLnQpIChlcnJvciA6IEVycm9yLnQpXVxuOztcblxubGV0IHdpdGhfc2FtcGxlX2V4biB+ZiA/Y29uZmlnID9leGFtcGxlcyBnZW5lcmF0b3IgPVxuICBsZXQgZiB4ID0gT3JfZXJyb3IudHJ5X3dpdGggKGZ1biAoKSAtPiBmIHgpIGluXG4gIHdpdGhfc2FtcGxlIH5mID9jb25maWcgP2V4YW1wbGVzIGdlbmVyYXRvciB8PiBPcl9lcnJvci5va19leG5cbjs7XG5cbmxldCBydW5fZXhuIH5mID9jb25maWcgP2V4YW1wbGVzIHRlc3RhYmxlID1cbiAgbGV0IGYgeCA9XG4gICAgT3JfZXJyb3IudHJ5X3dpdGggfmJhY2t0cmFjZTooQmFja3RyYWNlLkV4bi5hbV9yZWNvcmRpbmcgKCkpIChmdW4gKCkgLT4gZiB4KVxuICBpblxuICBydW4gfmYgP2NvbmZpZyA/ZXhhbXBsZXMgdGVzdGFibGUgfD4gT3JfZXJyb3Iub2tfZXhuXG47O1xuIiwib3BlbiEgQmFzZVxuaW5jbHVkZSBPYnNlcnZlcjBcblxubGV0IHVubWFwIHQgfmYgPSBjcmVhdGUgKGZ1biB4IH5zaXplIH5oYXNoIC0+IG9ic2VydmUgdCAoZiB4KSB+c2l6ZSB+aGFzaClcbmxldCBvZl9oYXNoX2ZvbGQgZiA9IGNyZWF0ZSAoZnVuIHggfnNpemU6XyB+aGFzaCAtPiBmIGhhc2ggeClcbmxldCBvZl9sYXp5IGxhenlfdCA9IGNyZWF0ZSAoZnVuIHggfnNpemUgfmhhc2ggLT4gb2JzZXJ2ZSAoZm9yY2UgbGF6eV90KSB4IH5zaXplIH5oYXNoKVxuXG5sZXQgZml4ZWRfcG9pbnQgd3JhcCA9XG4gIGxldCByZWMgbGF6eV90ID0gbGF6eSAod3JhcCAob2ZfbGF6eSBsYXp5X3QpKSBpblxuICBvZl9sYXp5IGxhenlfdFxuOztcblxubGV0IHVuaXQgPSBvcGFxdWVcbmxldCBib29sID0gb2ZfaGFzaF9mb2xkIEJvb2wuaGFzaF9mb2xkX3RcbmxldCBjaGFyID0gb2ZfaGFzaF9mb2xkIENoYXIuaGFzaF9mb2xkX3RcbmxldCBpbnQgPSBvZl9oYXNoX2ZvbGQgSW50Lmhhc2hfZm9sZF90XG5sZXQgaW50MzIgPSBvZl9oYXNoX2ZvbGQgSW50MzIuaGFzaF9mb2xkX3RcbmxldCBpbnQ2MyA9IG9mX2hhc2hfZm9sZCBJbnQ2My5oYXNoX2ZvbGRfdFxubGV0IGludDY0ID0gb2ZfaGFzaF9mb2xkIEludDY0Lmhhc2hfZm9sZF90XG5sZXQgbmF0aXZlaW50ID0gb2ZfaGFzaF9mb2xkIE5hdGl2ZWludC5oYXNoX2ZvbGRfdFxubGV0IGZsb2F0ID0gb2ZfaGFzaF9mb2xkIEZsb2F0Lmhhc2hfZm9sZF90XG5sZXQgc3RyaW5nID0gb2ZfaGFzaF9mb2xkIFN0cmluZy5oYXNoX2ZvbGRfdFxubGV0IHNleHAgPSBvZl9oYXNoX2ZvbGQgU2V4cC5oYXNoX2ZvbGRfdFxubGV0IGJpZ3N0cmluZyA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaGFzaF9mb2xkIGhhc2hfZm9sZF9jaGFyKVxubGV0IGZsb2F0MzJfdmVjID0gb2ZfaGFzaF9mb2xkIChCaWdhcnJheV9oZWxwZXJzLkFycmF5MS5oYXNoX2ZvbGQgaGFzaF9mb2xkX2Zsb2F0KVxubGV0IGZsb2F0NjRfdmVjID0gb2ZfaGFzaF9mb2xkIChCaWdhcnJheV9oZWxwZXJzLkFycmF5MS5oYXNoX2ZvbGQgaGFzaF9mb2xkX2Zsb2F0KVxubGV0IGZsb2F0MzJfbWF0ID0gb2ZfaGFzaF9mb2xkIChCaWdhcnJheV9oZWxwZXJzLkFycmF5Mi5oYXNoX2ZvbGQgaGFzaF9mb2xkX2Zsb2F0KVxubGV0IGZsb2F0NjRfbWF0ID0gb2ZfaGFzaF9mb2xkIChCaWdhcnJheV9oZWxwZXJzLkFycmF5Mi5oYXNoX2ZvbGQgaGFzaF9mb2xkX2Zsb2F0KVxubGV0IGJ5dGVzID0gdW5tYXAgc3RyaW5nIH5mOkJ5dGVzLnRvX3N0cmluZ1xuXG5sZXQgZWl0aGVyIGZzdF90IHNuZF90ID1cbiAgY3JlYXRlIChmdW4gZWl0aGVyIH5zaXplIH5oYXNoIC0+XG4gICAgbWF0Y2ggKGVpdGhlciA6IF8gRWl0aGVyLnQpIHdpdGhcbiAgICB8IEZpcnN0IGZzdCAtPiBvYnNlcnZlIGZzdF90IGZzdCB+c2l6ZSB+aGFzaDooaGFzaF9mb2xkX2ludCBoYXNoIDEpXG4gICAgfCBTZWNvbmQgc25kIC0+IG9ic2VydmUgc25kX3Qgc25kIH5zaXplIH5oYXNoOihoYXNoX2ZvbGRfaW50IGhhc2ggMikpXG47O1xuXG5sZXQgcmVzdWx0IG9rX3QgZXJyX3QgPVxuICB1bm1hcCAoZWl0aGVyIG9rX3QgZXJyX3QpIH5mOihmdW5jdGlvblxuICAgIHwgT2sgb2sgLT4gRmlyc3Qgb2tcbiAgICB8IEVycm9yIGVyciAtPiBTZWNvbmQgZXJyKVxuOztcblxubGV0IGJvdGggZnN0X3Qgc25kX3QgPVxuICBjcmVhdGUgKGZ1biAoZnN0LCBzbmQpIH5zaXplIH5oYXNoIC0+XG4gICAgbGV0IGhhc2ggPSBvYnNlcnZlIGZzdF90IGZzdCB+c2l6ZSB+aGFzaCBpblxuICAgIGxldCBoYXNoID0gb2JzZXJ2ZSBzbmRfdCBzbmQgfnNpemUgfmhhc2ggaW5cbiAgICBoYXNoKVxuOztcblxubGV0IG9wdGlvbiB2YWx1ZV90ID1cbiAgdW5tYXAgKGVpdGhlciBvcGFxdWUgdmFsdWVfdCkgfmY6KGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IEZpcnN0ICgpXG4gICAgfCBTb21lIHZhbHVlIC0+IFNlY29uZCB2YWx1ZSlcbjs7XG5cbmxldCBsaXN0IGVsdF90ID1cbiAgY3JlYXRlIChmdW4gbGlzdCB+c2l6ZSB+aGFzaCAtPlxuICAgIGxldCByYW5kb20gPSBTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS5vZl9pbnQgKEhhc2guZ2V0X2hhc2hfdmFsdWUgaGFzaCkgaW5cbiAgICBsZXQgbGVuZ3RoID0gTGlzdC5sZW5ndGggbGlzdCBpblxuICAgIGxldCBzaXplcyA9XG4gICAgICBHZW5lcmF0b3Iuc2l6ZXMgfm1pbl9sZW5ndGg6bGVuZ3RoIH5tYXhfbGVuZ3RoOmxlbmd0aCAoKVxuICAgICAgfD4gR2VuZXJhdG9yLmdlbmVyYXRlIH5zaXplIH5yYW5kb21cbiAgICBpblxuICAgIExpc3QuZm9sZDJfZXhuIGxpc3Qgc2l6ZXMgfmluaXQ6KGhhc2hfZm9sZF9pbnQgaGFzaCAwKSB+ZjooZnVuIGhhc2ggZWx0IHNpemUgLT5cbiAgICAgIG9ic2VydmUgZWx0X3QgZWx0IH5zaXplIH5oYXNoOihoYXNoX2ZvbGRfaW50IGhhc2ggMSkpKVxuOztcblxubGV0IGFycmF5IHQgPSB1bm1hcCAobGlzdCB0KSB+ZjpBcnJheS50b19saXN0XG5sZXQgcmVmIHQgPSB1bm1hcCB0IH5mOlJlZi4oICEgKVxubGV0IGxhenlfdCB0ID0gdW5tYXAgdCB+ZjpMYXp5LmZvcmNlXG5cbmxldCBmbiBkb20gcm5nID1cbiAgY3JlYXRlIChmdW4gZiB+c2l6ZSB+aGFzaCAtPlxuICAgIGxldCByYW5kb20gPSBTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS5vZl9pbnQgKEhhc2guZ2V0X2hhc2hfdmFsdWUgaGFzaCkgaW5cbiAgICBsZXQgc2l6ZXMgPVxuICAgICAgKCogRW1waXJpY2FsbHksIGRvdWJsaW5nIHRoZSBzaXplIHdoZW4gZ2VuZXJhdGluZyB0aGUgbGlzdCBvZiBpbnB1dHMgZ2l2ZXMgdXMgbXVjaFxuICAgICAgICAgYmV0dGVyIGNvdmVyYWdlIG9mIHRoZSBzcGFjZSBvZiBmdW5jdGlvbnMuICopXG4gICAgICBHZW5lcmF0b3IuZ2VuZXJhdGUgKEdlbmVyYXRvci5zaXplcyAoKSkgfnNpemU6KHNpemUgKiAyKSB+cmFuZG9tXG4gICAgaW5cbiAgICBMaXN0LmZvbGQgc2l6ZXMgfmluaXQ6aGFzaCB+ZjooZnVuIGhhc2ggc2l6ZSAtPlxuICAgICAgbGV0IHggPSBHZW5lcmF0b3IuZ2VuZXJhdGUgZG9tIH5zaXplIH5yYW5kb20gaW5cbiAgICAgIG9ic2VydmUgcm5nIChmIHgpIH5zaXplIH5oYXNoKSlcbjs7XG5cbmxldCBtYXBfdHJlZSBrZXlfb2JzIGRhdGFfb2JzID1cbiAgdW5tYXAgKGxpc3QgKGJvdGgga2V5X29icyBkYXRhX29icykpIH5mOk1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUudG9fYWxpc3Rcbjs7XG5cbmxldCBzZXRfdHJlZSBlbHRfb2JzID0gdW5tYXAgKGxpc3QgZWx0X29icykgfmY6U2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS50b19saXN0XG5cbmxldCBtYXBfdCBrZXlfb2JzIGRhdGFfb2JzID1cbiAgdW5tYXAgKG1hcF90cmVlIGtleV9vYnMgZGF0YV9vYnMpIH5mOk1hcC5Vc2luZ19jb21wYXJhdG9yLnRvX3RyZWVcbjs7XG5cbmxldCBzZXRfdCBlbHRfb2JzID0gdW5tYXAgKHNldF90cmVlIGVsdF9vYnMpIH5mOlNldC5Vc2luZ19jb21wYXJhdG9yLnRvX3RyZWVcbiIsIm1vZHVsZSBHZW5lcmF0b3IgPSBHZW5lcmF0b3Jcbm1vZHVsZSBPYnNlcnZlciA9IE9ic2VydmVyXG5tb2R1bGUgU2hyaW5rZXIgPSBTaHJpbmtlclxubW9kdWxlIFRlc3QgPSBUZXN0XG5tb2R1bGUgRXhwb3J0ID0gRXhwb3J0XG5pbmNsdWRlIEV4cG9ydFxuXG4oKiovKiopXG5cbigqXyBUaGlzIG1vZHVsZSBpcyBleHBvc2VkIG9ubHkgdG8gbWFrZSBvY2FtbGRvYyBvdXRwdXQgbW9yZSByZWFkYWJsZS4gKilcbm1vZHVsZSBXaXRoX2Jhc2ljX3R5cGVzID0gV2l0aF9iYXNpY190eXBlc1xuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgQmlnYXJyYXlfaGVscGVycyA9IEJpZ2FycmF5X2hlbHBlcnNcbmVuZFxuIl19
